{
  "run_index": 36,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 397,
  "generation_or_validation_failure_count": 42,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,2,6,6,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 2, 6, 6, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果串列。\"\"\"\n    return [random.randint(1, 6) for _ in range(n)]\n\ndef main():\n    # 讀取整個 stdin 的內容\n    code = sys.stdin.read()\n    if code.strip():          # 若有輸入才執行\n        exec(code, globals())  # 允許執行輸入中的程式碼（例如 print(roll_dice(5))）\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Need to not output actual code, only steps. For each line: virtual step then // explanation.\n\nNeed to produce step-by-step pseudocode using Start, Decision, etc.\n\nWe need to simulate roll_dice(n) using random module. So steps:\n\nStart\n→ Step: 定義函數 roll_dice(n) // declare function\n→ Step: 建立空串列 results = [] // prepare list\n→ Decision: n 是否大於 0? // validate input\n    Yes → Loop i from 1 to n\n        → Step: 隨機產生 1-6 的數字 rand_val = random.randint(1,6) // random\n        → Step: results.append(rand_val) // add to list\n    No → Step: 直接回傳空串列 // if n <=0\n→ Step: 回傳 results // return list\nEnd\n\nBut we need to use virtual code arrow '→', Decision. And each line with explanation. Let's format each step.\n\nWe also need to note that inside loop we need step lines. Use indentation? The example uses indent for nested decisions. So we can mimic.\n\nMake sure each line: `虛擬碼步驟 // 解釋`. For loop we need `→ Step: 迴圈 i = 1 to n` etc.\n\nMaybe: `→ Step: for i in range(1, n+1):` but in virtual code. We'll just write \"for i from 1 to n\".\n\nLet's produce.\n\nWe should also include the import random? The function uses random module; we might need to import at top.\n\nAdd: `→ Step: import random` // import module\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: import random // 導入隨機模組  \n→ Step: 定義函數 roll_dice(n) // 宣告 roll_dice 函式  \n→ Step: 建立空串列 results = [] // 用於儲存每次擲骰的結果  \n→ Decision: n 是否大於 0? // 檢查輸入是否合法  \n  Yes → Step: for i 取自 1 到 n // 迴圈擲 n 次  \n     → Step: 隨機產生數字 rand_val = random.randint(1, 6) // 產生 1-6 之間的隨機整數  \n     → Step: results.append(rand_val) // 將結果加入清單  \n  No → Step: 直接回傳空串列 // 如果 n <= 0，回傳空列表  \n→ Step: 回傳 results // 函式完成，輸出所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    以高解析度計時器測量 func 執行時間，回傳秒數並四捨五入到小數點三位。\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format: \"Start\", \"→\", \"Decision:\" etc. Need to produce step-by-step for measure_time(func, *args). Use time module. Steps: import time; define function; record start; call func(*args); record end; compute elapsed; round to 3 decimals; return elapsed. Then maybe return result of function? Wait requirement: \"測量函數 func 執行所需的秒數，並回傳結果\". Means return the elapsed time? \"回傳結果\" ambiguous: could be return elapsed time. Let's assume return elapsed time. Might also want to return function result? but says \"測量函數 func 執行所需的秒數，並回傳結果\". I think they want the elapsed time. Let's produce steps.\n\nAlso include import. Use time.perf_counter for high resolution. Steps: import time; define measure_time; start = time.perf_counter(); result = func(*args); end = time.perf_counter(); elapsed = end - start; elapsed_rounded = round(elapsed, 3); return elapsed_rounded.\n\nOk produce virtual code lines.\n\nWe must not output actual code, only virtual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow, etc.\n\nStart // 程式開始執行\n→ Step 1: 導入 time 模組 // 需要時間測量\n→ Step 2: 定義函式 measure_time(func, *args) // 用於測量指定函式執行時間\n→ Step 3: 取得起始時間 start ← time.perf_counter() // 開始計時\n→ Step 4: 執行 func(*args) 並儲存回傳值 // 執行目標函式\n→ Step 5: 取得結束時間 end ← time.perf_counter() // 停止計時\n→ Step 6: 計算 elapsed ← end - start // 取得執行秒數\n→ Step 7: 取小數點三位四捨五入 elapsed_rounded ← round(elapsed, 3) // 四捨五入到 3 位\n→ Step 8: 回傳 elapsed_rounded // 回傳測量結果\nEnd // 程式執行結束\n\nBut we need to follow format: \"Start\" then \"→\". They used \"Start //\". We can maintain consistent style.\n\nThey used \"Start // 程式開始執行\" no arrow. Then \"→ Step 1: ...\" etc.\n\nWe need to include decisions? None.\n\nOk produce lines accordingly. Use \"Step\" prefix.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 time 模組 // 需要時間測量  \n→ Step 2: 定義函式 measure_time(func, *args) // 用於測量指定函式執行時間  \n→ Step 3: 取得起始時間 start ← time.perf_counter() // 開始計時  \n→ Step 4: 執行 func(*args) 並儲存回傳值 result ← func(*args) // 執行目標函式  \n→ Step 5: 取得結束時間 end ← time.perf_counter() // 停止計時  \n→ Step 6: 計算 elapsed ← end - start // 取得執行秒數  \n→ Step 7: 取小數點三位四捨五入 elapsed_rounded ← round(elapsed, 3) // 四捨五入到 3 位  \n→ Step 8: 回傳 elapsed_rounded // 回傳測量結果  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"apple\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'apple', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（若有任何輸入），但此題無需處理任何資料\n    sys.stdin.read()\n    \n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n    \n    # 1. 新增 'orange'\n    fruits.add('orange')\n    \n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n    \n    # 3. 移除 'banana'\n    fruits.remove('banana')\n    \n    # 4. 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output line-by-line pseudocode with comments in Chinese. Must use virtual code arrow, etc. Let's produce steps:\n\nStart\n→ Step 1: Initialize set fruits = {'apple', 'banana'} // create set\n→ Step 2: fruits.add('orange') // add orange\n→ Step 3: fruits.update({'grape', 'melon'}) // add two items\n→ Step 4: fruits.remove('banana') // remove banana\n→ Step 5: fruits.discard('pineapple') // discard nonexistent element\n→ Step 6: Output fruits // show final set\nEnd\n\nMake sure to include decision? None needed. Just simple steps.\n\nReturn each line. Ensure each line: \"虛擬碼步驟 // 解釋\". Also arrows and spacing exactly like example: `→ Step 1: ... // ...`. Use `Start` and `End`. Use `Step` numbering.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'  \n→ Step 6: Output fruits // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate():\n    \"\"\"取得 USD 對 TWD 的匯率，失敗時回傳 None\"\"\"\n    url = 'https://api.exchangerate-api.com/v4/latest/USD'\n    try:\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef main():\n    \"\"\"主程式：讀入 stdin，若有輸入則印出匯率，接著啟動 GUI\"\"\"\n    # 讀取 stdin（只取第一行）\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # --- GUI ---------------------------------------------------------\n    root = tk.Tk()\n    root.title('匯率查詢')\n\n    label = tk.Label(root, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(root, text='更新匯率', command=update_label).pack(pady=5)\n\n    root.mainloop()\n    # ----------------------------------------------------------------\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines with explanation per line. Use \"Start\", \"End\", \"Decision:\" etc. Should produce code lines for fetching API, updating tkinter window. We need to include pseudo code steps. Use arrows. Let's craft.\n\nWe need to start with Start. Then import modules, create Tk window, label, button. Button command fetches rate. Function fetch_rate: send GET request, parse JSON, get TWD, update label. Use try/except for errors. After update, maybe schedule next update? Not needed.\n\nWe need each line: e.g., `→ Import: requests` etc. Let's produce.\n\nMake sure to include arrow \"→\" before each step, and \"Decision:\" with Yes/No. No loops maybe. Let's produce.\n\nLet's write as:\n\nStart\n→ Import: requests // 載入 HTTP 請求模組\n→ Import: json // 處理 JSON 資料\n→ Import: tkinter as tk // 建立 GUI\n→ Variable: api_url = 'https://api.exchangerate-api.com/v4/latest/USD' // API 端點\n→ Create: root = tk.Tk() // 建立主視窗\n→ Set: root.title('USD to TWD 匯率') // 設定視窗標題\n→ Create: rate_label = tk.Label(root, text='匯率待載入...', font=('Arial', 14)) // 顯示匯率的文字標籤\n→ Pack: rate_label.pack(pady=20) // 將標籤放到視窗中\n→ Function: fetch_rate() // 定義取得匯率的函式\n   → Request: response = requests.get(api_url) // 送出 GET 請求\n   → Decision: 如果 response.status_code == 200? // 檢查回傳是否成功\n        Yes → Parse: data = response.json() // 解析 JSON\n        → Decision: 如果 'rates' in data and 'TWD' in data['rates']? // 確認資料中包含 TWD\n            Yes → Variable: rate = data['rates']['TWD'] // 取得 TWD 匯率\n            → Update: rate_label.config(text=f'1 USD = {rate:.4f} TWD') // 更新標籤文字\n            No  → Update: rate_label.config(text='TWD 匯率未找到') // 顯示錯誤訊息\n        No  → Update: rate_label.config(text='資料格式錯誤') // 顯示錯誤訊息\n   → No  → Update: rate_label.config(text='無法連線到 API') // 顯示連線錯誤\n→ Create: update_button = tk.Button(root, text='更新匯率', command=fetch_rate) // 建立更新按鈕\n→ Pack: update_button.pack(pady=10) // 放置按鈕\n→ Call: fetch_rate() // 初次載入匯率\n→ MainLoop: root.mainloop() // 啟動 GUI 事件迴圈\nEnd\n\nBut we need each line exactly with arrow and explanation. The function block lines need indentation maybe. The instruction: Each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\". We need to use arrow and structure.\n\nProbably need to keep each line on separate line. For nested lines, maybe use indentation with spaces before the arrow? The example shows arrow after indentation. We'll replicate.\n\nLet's produce with proper indentation for function and decisions.\n\nWe'll use spaces for indentation: four spaces.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Import: requests // 載入 HTTP 請求模組\n→ Import: json // 處理 JSON 資料\n→ Import: tkinter as tk // 建立 GUI\n→ Variable: api_url = 'https://api.exchangerate-api.com/v4/latest/USD' // API 端點\n→ Create: root = tk.Tk() // 建立主視窗\n→ Set: root.title('USD to TWD 匯率') // 設定視窗標題\n→ Create: rate_label = tk.Label(root, text='匯率待載入...', font=('Arial', 14)) // 顯示匯率的文字標籤\n→ Pack: rate_label.pack(pady=20) // 將標籤放到視窗中\n→ Function: fetch_rate() // 定義取得匯率的函式\n    → Request: response = requests.get(api_url) // 送出 GET 請求\n    → Decision: 如果 response.status_code == 200? // 檢查回傳是否成功\n        Yes → Parse: data = response.json() // 解析 JSON\n        → Decision: 如果 'rates' in data and 'TWD' in data['rates']? // 確認資料中包含 TWD\n            Yes → Variable: rate = data['rates']['TWD'] // 取得 TWD 匯率\n            → Update: rate_label.config(text=f'1 USD = {rate:.4f} TWD') // 更新標籤文字\n            No  → Update: rate_label.config(text='TWD 匯率未找到') // 顯示錯誤訊息\n        No  → Update: rate_label.config(text='資料格式錯誤') // 顯示錯誤訊息\n    → No  → Update: rate_label.config(text='無法連線到 API') // 顯示連線錯誤\n→ Create: update_button = tk.Button(root, text='更新匯率', command=fetch_rate) // 建立更新按鈕\n→ Pack: update_button.pack(pady=10) // 放置按鈕\n→ Call: fetch_rate() // 初次載入匯率\n→ MainLoop: root.mainloop() // 啟動 GUI 事件迴圈\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the input so that ast.literal_eval interprets it as a list of two elements\n    try:\n        ops, args = ast.literal_eval(f'[{data}]')\n    except Exception:\n        # If the input is already a list of two lists, just evaluate it directly\n        ops, args = ast.literal_eval(data)\n    res = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            sol = Solution(arg[0], arg[1])\n            res.append(None)\n        elif op == \"flip\":\n            res.append(sol.flip())\n        elif op == \"reset\":\n            sol.reset()\n            res.append(None)\n    # Output with JSON formatting so that None appears as null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start End, Decision, Yes→, No→ etc.\n\nWe design algorithm: maintain list of available indices as 1D range [0, m*n-1]. Use mapping for reservoir: when pick random r in [0, remaining-1], get value from mapping dict if exists else r. After picking, map r to last available value. Reduce remaining count. Flip. reset: clear mapping and set remaining=m*n.\n\nImplementation steps: constructor, flip, reset.\n\nNeed to use minimal random calls: each flip uses one random. Reset no random.\n\nAlso need to compute row, col: idx // n, idx % n.\n\nWe will produce virtual steps.\n\nStructure: Start, Steps, Decision maybe for mapping existence, etc.\n\nLet's craft.\n\nVirtual code lines:\n\nStart // 開始程式\n→ Step 1: 初始化 m, n, total ← m * n, remaining ← total, map ← 空映射 // 儲存矩陣尺寸與可選項目\n→ End // 初始化結束\n\nThen flip function:\n\nStart // flip() 開始\n→ Step 2: r ← random_int(0, remaining-1) // 取得一個隨機索引\n→ Decision: 是否存在 map[r]? // 檢查映射表中是否有映射\n    Yes → idx ← map[r] // 取映射對應值\n    No  → idx ← r   // 否則直接使用 r\n→ Step 3: map[r] ← (remaining-1) in map ? map[remaining-1] : remaining-1 // 將 r 映射到最後一個可選值\n→ Step 4: remaining ← remaining-1 // 減少可選項目數\n→ Step 5: row ← idx // n, col ← idx % n // 轉換為二維坐標\n→ Step 6: 返回 [row, col] // 回傳索引\n→ End // flip() 結束\n\nreset function:\n\nStart // reset() 開始\n→ Step 7: remaining ← total // 重置剩餘數\n→ Step 8: map ← 空映射 // 清空映射表\n→ End // reset() 結束\n\nBut maybe we should include Decision mapping check inside Step 3; we could separate. Let's produce each line as separate with arrows. For mapping existence we need a Decision block.\n\nAlso we might need to handle if remaining==0? But not necessary as flip only called when at least one zero.\n\nWe also need to mention that random_int uses built-in random.\n\nAlso explain mapping technique.\n\nWe can produce final answer accordingly.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: m ← 輸入的行數, n ← 輸入的列數, total ← m * n, remaining ← total, map ← 空映射 // 初始化矩陣尺寸、可選項目數與映射表\n→ End // 初始化結束\n\nStart // flip() 開始\n→ Step 2: r ← random_int(0, remaining-1) // 產生一個 0 到 remaining-1 的隨機整數\n→ Decision: 是否存在 map[r]? // 檢查映射表中是否有 r 的映射\n    Yes → idx ← map[r] // 若有，idx 取映射值\n    No  → idx ← r     // 若無，idx 取 r 本身\n→ Step 3: map[r] ← (remaining-1) in map ? map[remaining-1] : remaining-1 // 把 r 映射到最後一個未選取的索引，保持映射表大小為 remaining\n→ Step 4: remaining ← remaining - 1 // 减少剩餘可選索引數\n→ Step 5: row ← idx // n, col ← idx % n // 把一維索引轉換為二維坐標\n→ Step 6: 返回 [row, col] // 回傳隨機選中的 0 索引，並視為已翻轉為 1\n→ End // flip() 結束\n\nStart // reset() 開始\n→ Step 7: remaining ← total // 重置剩餘可選項目數為全部位置\n→ Step 8: map ← 空映射 // 清空映射表，所有位置再次可被選中\n→ End // reset() 結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb2gl1ugj.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmpb2gl1ugj.py\", line 54, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmpb2gl1ugj.py\", line 9, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef parse_input(data: str):\n    data = data.strip()\n    # Find the split point between the two lists\n    bracket_level = 0\n    split_index = None\n    for i, ch in enumerate(data):\n        if ch == '[':\n            bracket_level += 1\n        elif ch == ']':\n            bracket_level -= 1\n            if bracket_level == 0:\n                split_index = i\n                break\n    if split_index is None:\n        raise ValueError(\"Invalid input format\")\n    first_part = data[:split_index + 1]\n    second_part = data[split_index + 1:].lstrip(', \\t\\n')\n    commands = json.loads(first_part)\n    args = json.loads(second_part)\n    return commands, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    commands, args = parse_input(raw_input)\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            result.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            result.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg[0]) if isinstance(arg, list) else obj.search(arg)\n            result.append(res)\n        else:\n            # Unsupported command; append None\n            result.append(None)\n    # Output the results in JSON format, converting Python None to null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. No actual code. Steps to design data structure: maybe using hash map of patterns with wildcard. Approach: during build, for each word, replace each character by wildcard, store in map with original word count. Search: for each position replace with wildcard, check if exists in map and either matches another word or same length? Actually need exactly one character change to match any word. So if word present and we replace one character and that pattern exists in map with more than 1 occurrence or a different word. We can store patterns mapping to count of words that share that pattern. Also store set of words.\n\nImplement methods: BuildDict: iterate dictionary. For each word, add to set. For each position i, pattern = word[:i] + '*' + word[i+1:]. Map pattern to count++.\n\nSearch: if searchWord not in set? Actually we can still change one character to some other word. For each position i, pattern = searchWord[:i]+'*'+searchWord[i+1:]. If pattern in map and (map[pattern] >1 or word not in set? Actually need if any word with that pattern is not same as searchWord). So if pattern in map and (map[pattern]>1 or searchWord not in set). Return true. After loop, false.\n\nSo produce virtual code steps. Also initialization and build.\n\nWe'll produce steps with Start, Build method, Search method. Each step as line. Use arrow. Provide explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialise MagicDictionary // 建立 MagicDictionary 物件  \n→ Create an empty HashSet words // 用來存所有字典中的原始字詞  \n→ Create an empty HashMap patternCount // 存每個字母位置被改為通配符後的字母串及其出現次數  \n\n// ===========================  \n→ Method: buildDict(dictionary) // 建構字典  \n    → For each word in dictionary  \n        → Add word to words // 儲存原始字詞  \n        → For i from 0 to length(word)-1  \n            → Create pattern = word with character i replaced by '*' // 產生通配符字串  \n            → If pattern not in patternCount → patternCount[pattern] = 0  \n            → Increment patternCount[pattern] by 1 // 記錄此通配符字串出現的次數  \n\nEnd // buildDict 完成  \n\n// ===========================  \n→ Method: search(searchWord) // 搜尋是否能改一個字元匹配字典  \n    → For i from 0 to length(searchWord)-1  \n        → Create pattern = searchWord with character i replaced by '*' // 產生通配符字串  \n        → If pattern exists in patternCount  \n            → If patternCount[pattern] > 1 // 有多個不同字詞共用此模式  \n                → Return true // 能改一個字元匹配  \n            → Else // 只出現一次  \n                → If searchWord not in words // 這個字詞本身不在字典中  \n                    → Return true // 改一個字元可匹配另一個字詞  \n    → Return false // 沒有符合條件的改法  \n\nEnd // search 方法完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find K Closest Elements",
      "source_file": "Leetcode/leetcode658.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,2,3,4]'\nGot (Norm):      '[2]'\n--- (Raw) ---\nRaw Expected: '[1,2,3,4]'\nRaw Got:      '[2]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport bisect\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        找出離 x 最近的 k 個元素，並返回升序排列的子陣列。\n        \"\"\"\n        # 1. 先用二分搜尋得到第一個不小於 x 的索引\n        idx = bisect.bisect_left(arr, x)\n\n        # 2. 設定左右指標\n        if idx == len(arr):          # x 大於等於最大值\n            left, right = len(arr) - k, len(arr)\n        elif idx == 0:               # x 小於等於最小值\n            left, right = 0, k\n        else:                        # x 介於 arr[idx-1] 與 arr[idx] 之間\n            left, right = idx - 1, idx\n\n        # 3. 當區間長度大於 k 時，移除較遠的端點\n        while right - left > k:\n            if abs(arr[left] - x) <= abs(arr[right] - x):\n                # 左側更接近，丟棄右側\n                right -= 1\n            else:\n                # 右側更接近，丟棄左側\n                left += 1\n\n        # 4. 回傳結果\n        return arr[left:right]\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從輸入字串中解析出 arr、k、x。\n    \"\"\"\n    pattern = r'arr\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)\\s*,\\s*x\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, input_str)\n    if not match:\n        raise ValueError(\"Invalid input format.\")\n    arr_str, k_str, x_str = match.groups()\n    arr = ast.literal_eval(arr_str)\n    k = int(k_str)\n    x = int(x_str)\n    return arr, k, x\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    try:\n        arr, k, x = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.findClosestElements(arr, k, x)\n    # 輸出為標準列表格式\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines following format. Steps: binary search to find position, then two pointers. Let's design:\n\nStart\n→ Step 1: BinarySearch to find index where arr[idx] >= x // find insertion point\n→ Decision: If idx == len(arr) → Step 2: left = len(arr)-k; right = len(arr) // if x greater than all elements\nElse if idx == 0 → Step 3: left = 0; right = k // if x less than all\nElse → Step 4: left = idx-1; right = idx // start pointers\n→ Step 5: While (right - left) > k // shrink interval\n    Decision: if abs(arr[left] - x) <= abs(arr[right] - x) // left closer or equal\n        No? Actually we want if left closer then move left++ else right--? Wait: We want k closest. If left closer, we discard left by incrementing left? We want to keep closer ones. When interval larger than k, we drop the farther one. So:\n        Decision: if abs(arr[left] - x) <= abs(arr[right] - x)\n            Yes → left++ // discard left, it's farther? Wait condition <= means left is closer or equal, so we should discard right. Actually we want to drop the farther. If left closer, drop right: right--. If right closer, drop left: left++.\nSo:\n        Decision: if abs(arr[left] - x) <= abs(arr[right] - x)\n            Yes → right-- // discard right\n            No  → left++ // discard left\n→ Step 6: Return arr[left:right] // slice\nEnd\n\nNeed to explain each line.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: BinarySearch(arr, x) → idx // 找到第一個不小於 x 的索引，作為二分搜尋的插入點  \n→ Decision: 如果 idx == len(arr)? // x 大於等於陣列最大值  \n Yes → Step 2: left = len(arr) - k; right = len(arr) // 直接選取最後 k 個元素  \n No → Decision: 如果 idx == 0? // x 小於等於陣列最小值  \n  Yes → Step 3: left = 0; right = k // 直接選取前 k 個元素  \n  No → Step 4: left = idx - 1; right = idx // 左指標在 x 左側，右指標在 x 右側  \n→ Step 5: While (right - left) > k // 只要區間長度超過 k，就需要裁減  \n → Decision: abs(arr[left] - x) <= abs(arr[right] - x)? // 判斷左側元素是否更接近 x  \n  Yes → right-- // 左側更接近，丟棄右側較遠的元素  \n  No  → left++ // 右側更接近，丟棄左側較遠的元素  \n→ Step 6: Return arr[left : right] // 取子陣列作為答案，已升序排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqsrk28mu.py\", line 65, in <module>\n    main()\n  File \"/tmp/tmpqsrk28mu.py\", line 52, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqsrk28mu.py\", line 13, in __init__\n    self.lookup[(pref, suff)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                pref = word[:i]\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], []\n\n    # Find the first comma that is not inside brackets\n    balance = 0\n    split_index = None\n    for idx, ch in enumerate(data):\n        if ch == '[':\n            balance += 1\n        elif ch == ']':\n            balance -= 1\n        elif ch == ',' and balance == 0:\n            split_index = idx\n            break\n\n    if split_index is None:\n        parts = [data]\n    else:\n        parts = [data[:split_index], data[split_index + 1:]]\n\n    parts = [p.strip() for p in parts]\n    parts = [ast.literal_eval(p) for p in parts]\n    return parts\n\ndef main():\n    parts = parse_input()\n    if not parts:\n        return\n\n    words = parts[0]\n    queries = parts[1:] if len(parts) > 1 else []\n\n    wf = WordFilter(words)\n    outputs = []\n    for q in queries:\n        pref, suff = q\n        outputs.append(str(wf.f(pref, suff)))\n\n    # If there is only one query, print the result directly\n    if len(outputs) == 1:\n        print(outputs[0])\n    else:\n        print(','.join(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. Task: design a special dictionary searching by prefix and suffix. WordFilter class. Steps: initialization builds some data structure, maybe trie or hash map mapping prefix and suffix pairs to indices. Could use a trie for prefixes and suffixes; but we can simply store all words in a list and for each query iterate. But likely efficient solution uses dictionary mapping combined prefix+suffix key to max index.\n\nVirtual code steps: Start, Step 1: Input words array, store words list. Step 2: For each word, for each prefix length, for each suffix length, create key = prefix + '#' + suffix and map to max index. Complexity O(n*L^2). Then f method: combine pref+'#'+suff and look up. Return index or -1.\n\nWe need to generate line-by-line pseudocode with comments. Use arrows etc. Provide explanation after each line.\n\nLet's create a skeleton.\n\nStart\n→ Step 1: words ← input array // store words\n→ Step 2: indexMap ← new HashMap // map key -> max index\n→ Decision: For each word with index i // iterate words\n    Yes → Step 3: prefix ← \"\" // initialize empty prefix\n    → For each char c in word // build prefixes\n        Yes → prefix ← prefix + c // extend prefix\n        → Step 4: suffix ← \"\" // initialize empty suffix\n        → For each char d in word reversed // build suffixes\n            Yes → suffix ← d + suffix // extend suffix\n            → Step 5: key ← prefix + \"#\" + suffix // create composite key\n            → Decision: key exists in indexMap? // check\n                Yes → Step 6: indexMap[key] ← max(indexMap[key], i) // update with larger index\n                No  → Step 7: indexMap[key] ← i // set new\n→ Step 8: Store indexMap in object // finish init\nEnd\n\nMethod f:\nStart\n→ Step 9: key ← pref + \"#\" + suff // combine query\n→ Decision: key exists in indexMap? // check\n    Yes → Step 10: return indexMap[key] // return largest index\n    No  → Step 11: return -1 // not found\nEnd\n\nBut need to maintain structure: use Decision, Yes →, No →.\n\nLet's produce final lines accordingly. Use each line.\n\nWe should also note we might need to include loops, but we can represent loops as Decision with Yes/No arrow. Use generic. Provide comments.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words ← input array // 取得單詞列表  \n→ Step 2: indexMap ← new HashMap // 建立鍵值對字典，鍵為「前綴#後綴」  \n\n→ Decision: For each word with index i // 遍歷所有單詞  \n    Yes → Step 3: prefix ← \"\" // 初始化前綴空字串  \n    → For each character c in word // 建立所有可能前綴  \n        Yes → prefix ← prefix + c // 追加字符形成更長前綴  \n        → Step 4: suffix ← \"\" // 初始化後綴空字串  \n        → For each character d in word reversed // 建立所有可能後綴  \n            Yes → suffix ← d + suffix // 追加字符形成更長後綴  \n            → Step 5: key ← prefix + \"#\" + suffix // 組合鍵值  \n            → Decision: key exists in indexMap? // 檢查鍵是否已存在  \n                Yes → Step 6: indexMap[key] ← max(indexMap[key], i) // 更新為較大的索引  \n                No  → Step 7: indexMap[key] ← i // 新增鍵值對  \n\n→ Step 8: Store indexMap in object // 初始化結束，將映射保存於物件中  \nEnd // 初始化完成  \n\n---  \n\nStart // f 方法開始執行  \n→ Step 9: key ← pref + \"#\" + suff // 組合查詢鍵  \n→ Decision: key exists in indexMap? // 檢查是否有符合條件的單詞  \n    Yes → Step 10: return indexMap[key] // 回傳最大的索引  \n    No  → Step 11: return -1 // 無符合單詞，回傳 -1  \nEnd // f 方法結束"
    },
    {
      "title": "Min Cost Climbing Stairs",
      "source_file": "Leetcode/leetcode746.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '15'\nGot (Norm):      '30'\n--- (Raw) ---\nRaw Expected: '15'\nRaw Got:      '30'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef min_cost_climbing_stairs(cost):\n    n = len(cost)\n    if n == 0:\n        return 0\n    if n == 1:\n        return cost[0]\n    # dp[i] represents the minimum cost to reach step i (0-indexed)\n    dp = [0] * (n + 1)\n    dp[0] = 0                # before the first step, no cost\n    dp[1] = cost[0]          # start from step 0\n    dp[2] = cost[1]          # start from step 1\n    for i in range(3, n + 1):\n        # to reach step i, we must come from i-1 or i-2\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i - 1]\n    return dp[n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    cost = ast.literal_eval(data)\n    result = min_cost_climbing_stairs(cost)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate a virtual code algorithm for min cost climb stairs problem. Use dynamic programming. Steps: Start, compute dp[i] = min cost to reach i. dp[0] = cost[0]; dp[1] = cost[1]; For i from 2 to n-1: dp[i] = cost[i] + min(dp[i-1], dp[i-2]); Finally result = min(dp[n-1], dp[n-2])? Actually to reach top beyond last index, you can climb from last two steps: result = min(dp[n-1], dp[n-2]). But if we consider dp[n] meaning top: dp[n] = min(dp[n-1], dp[n-2]) without cost. So we can compute dp array size n+1: dp[0] = 0, dp[1] = cost[0], dp[2] = cost[1], and for i from 3 to n: dp[i] = min(dp[i-1], dp[i-2]) + cost[i-2]??? Wait typical solution: dp[i] min cost to reach step i; dp[0] = 0; dp[1] = cost[0]; For i>=2: dp[i] = min(dp[i-1], dp[i-2]) + cost[i-1]; Finally answer dp[n]. That is simpler. We'll produce virtual code accordingly.\n\nWe need to output step by step virtual code with explanation after each line. Use arrow notation.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize n = length of cost\n→ Step 2: Create array dp of size n+1 // dp[i] holds min cost to reach step i\n→ Step 3: dp[0] = 0 // starting point, no cost\n→ Step 4: dp[1] = cost[0] // start from step 0\n→ Decision: If n > 1? // handle case with only one step\n    Yes → Step 5: dp[2] = cost[1] // start from step 1\n    No  → End // if only one step, answer is dp[1]\n→ Step 6: For i from 3 to n:\n        // compute min cost to reach step i\n        // formula: dp[i] = min(dp[i-1], dp[i-2]) + cost[i-1]\n        // because to land on step i-1 (0-index) we add cost[i-1]\n→ Step 7: Result = dp[n] // min cost to reach top\n→ End\n\nBut need to adjust indexes for loop. Actually if n>=2, dp[2] is cost[1] because to reach step index 1 (0-index) which is step 2 in dp? Let's unify: dp indices correspond to steps number (starting from 0). dp[0] is before first step, dp[1] is after step 0, dp[2] after step1. So dp[2] = cost[1]. Good.\n\nBut if n == 1, answer is dp[1].\n\nIf n == 0, answer 0 but not in problem.\n\nOk produce.\n\nBut we need to follow format exactly: each line: 虛擬碼步驟 [space] // 解釋. Use arrows.\n\nAlso need to embed decision.\n\nLet's produce as per example.\n\nLet's include proper indentation maybe.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(cost) // 取得階梯數量\n→ Step 2: dp ← new array of size n+1 // dp[i] 代表到達第 i 階的最低成本\n→ Step 3: dp[0] ← 0 // 起點，無成本\n→ Step 4: dp[1] ← cost[0] // 從第 0 階開始\n→ Decision: n > 1? // 是否至少有兩個階梯\n    Yes → Step 5: dp[2] ← cost[1] // 從第 1 階開始\n    No  → End // 只有一個階梯，直接結束\n→ Step 6: For i ← 3 to n:\n        // 计算到达第 i 階的最低成本\n        // dp[i] = min(dp[i-1], dp[i-2]) + cost[i-1]\n        dp[i] ← min(dp[i-1], dp[i-2]) + cost[i-1]\n→ Step 7: result ← dp[n] // 最高階（樓面）的最低成本\n→ End // 程式結束\n\nBut the for loop step may need to be a decision block. Format:\n\n→ Step 6: For i = 3 to n:\n        // compute dp[i]\nBut in the format they used arrow at each line; for loop might be represented as:\n\n→ Step 6: For i from 3 to n: // 迭代計算 dp 值\n    dp[i] ← min(dp[i-1], dp[i-2]) + cost[i-1] // 取較小成本並加上當前階梯費用\n\nThus produce two lines inside loop.\n\nWe need to ensure arrow representation.\n\nOk.\n\nAlso at end, result variable.\n\nAlso we might include step to output result, but final step.\n\nNow produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(cost) // 取得階梯數量  \n→ Step 2: dp ← new array of size n+1 // dp[i] 代表到達第 i 階的最低成本  \n→ Step 3: dp[0] ← 0 // 起點，無成本  \n→ Step 4: dp[1] ← cost[0] // 從第 0 階開始  \n→ Decision: n > 1? // 是否至少有兩個階梯  \n Yes → Step 5: dp[2] ← cost[1] // 從第 1 階開始  \n No  → End // 只有一個階梯，直接結束  \n→ Step 6: For i ← 3 to n: // 迭代計算 dp 值  \n  dp[i] ← min(dp[i-1], dp[i-2]) + cost[i-1] // 取較小成本並加上當前階梯費用  \n→ Step 7: result ← dp[n] // 最高階（樓面）的最低成本  \n→ End // 程式結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        res = [[]]\n        for num in nums:\n            new_subsets = []\n            for subset in res:\n                new_subsets.append(subset + [num])\n            res += new_subsets\n        unique_res = []\n        seen = set()\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n        return unique_res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, nums_str = data.split('=', 1)\n    else:\n        nums_str = data\n    nums_str = nums_str.strip()\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(str(result).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for generating all subsets of an integer array that may contain duplicates, ensuring no duplicate subsets. It's basically typical subsets II problem. Use backtracking, sorting array, skip duplicates. Virtual code steps line by line.\n\nWe must not output actual code, just virtual steps. Must include Start, End, Decision, arrows, etc. Each line: virtual code + space + // explanation. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 為了方便跳過重複項目\n→ Step 2: 初始化結果集合 subsets ← empty list // 存儲所有子集\n→ Step 3: 定義遞迴函式 Backtrack(start, current) // 遞迴搜尋子集\n    → Step 4: 將 current 的拷貝加入 subsets // 每一次遞迴均將目前子集加入結果\n    → Step 5: 從 index=start 到 nums.length-1 迴圈\n        → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 檢查是否為重複元素且不是第一次\n            Yes → Continue // 跳過重複，避免產生相同子集\n        → Decision: 否? // 如果不是重複\n            No →\n                → Step 6: current ← current ∪ {nums[i]} // 加入當前元素\n                → Step 7: Backtrack(i+1, current) // 深度優先遞迴\n                → Step 8: current ← current \\ {nums[i]} // 回溯，移除最後加入的元素\n    End // 完成回朔\n→ Step 9: 呼叫 Backtrack(0, empty list) // 開始遞迴\n→ Step 10: 返回 subsets // 最終結果\nEnd // 程式結束\n\nBut must be each line one step. Use arrow and indentation. Let's craft lines accordingly. Each line ends with comment.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 為方便跳過重複項目  \n→ Step 2: 初始化 subsets 為空清單 // 用於存放所有子集  \n→ Step 3: 定義遞迴函式 Backtrack(start, current) // 進行回溯搜尋  \n    → Step 4: Append current 的拷貝至 subsets // 每一次呼叫都加入目前子集  \n    → Step 5: 從 i = start 到 nums.length - 1 迴圈  \n        → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 檢查是否為重複元素  \n            Yes → Continue // 跳過重複，避免重複子集  \n            No →  \n                → Step 6: current ← current ∪ {nums[i]} // 加入當前元素  \n                → Step 7: Backtrack(i + 1, current) // 深度遞迴  \n                → Step 8: current ← current \\ {nums[i]} // 回溯，移除最後加入的元素  \n    End // 完成當前層的迴圈  \n→ Step 9: 呼叫 Backtrack(0, empty list) // 開始遞迴搜尋  \n→ Step 10: 回傳 subsets // 回傳所有獨特子集  \nEnd // 程式結束執行"
    },
    {
      "title": "Intersection of Two Arrays",
      "source_file": "Leetcode/leetcode349.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphbonh49o.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmphbonh49o.py\", line 27, in main\n    nums2_part = parts[1].split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvx5iwtuc.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmpvx5iwtuc.py\", line 27, in main\n    nums2_part = parts[1].split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        Return the intersection of two integer lists, with each element appearing only once.\n        \"\"\"\n        # Convert both lists to sets and compute their intersection\n        return list(set(nums1) & set(nums2))\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Replace any newlines with spaces for uniform processing\n    data = data.replace('\\n', ' ')\n\n    # Expected format: \"nums1 = [...], nums2 = [...]\"\n    parts = data.split(',')\n    if len(parts) < 2:\n        return\n\n    # Extract the part after the '=' for each array and evaluate it\n    nums1_part = parts[0].split('=')[1].strip()\n    nums2_part = parts[1].split('=')[1].strip()\n    nums1 = eval(nums1_part)\n    nums2 = eval(nums2_part)\n\n    # Compute intersection and output the result\n    result = Solution().intersection(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for the problem: intersection of two arrays of integers, unique results. Approach: convert one array to set, iterate second array, add to result set if present. Then convert result set to list and return. Provide step lines with explanations. Use virtual code with arrows. Each line: `虛擬碼步驟 // 解釋`. Must start with `Start` and end with `End`. Use Decision steps for conditions. Let's craft:\n\nStart\n→ Step 1: 建立 set1 以儲存 nums1 的所有元素 // 把第一個陣列轉成集合\n→ Step 2: 建立空集合 result // 用於儲存交集且避免重複\n→ Step 3: 對 nums2 之中的每個 num 進行迴圈 // 遍歷第二個陣列\n    → Decision: num 是否在 set1? // 判斷是否屬於交集\n        Yes → Step 4: 把 num 加入 result // 若在，加入結果集合\n        No  → // 不做任何事\n→ Step 5: 把 result 轉成 list // 將集合轉為陣列\n→ Step 6: 回傳 list // 回傳交集結果\nEnd\n\nBut we need to use virtual code arrows: maybe `→` and `Yes →` `No →`. Format: each line with `虛擬碼步驟 // 解釋`. Indentation maybe optional. Provide exactly. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 set1 以儲存 nums1 的所有元素 // 把第一個陣列轉成集合，方便 O(1) 查詢  \n→ Step 2: 建立空集合 result // 用於儲存交集且自動排除重複  \n→ Step 3: 對 nums2 之中的每個 num 進行迴圈 // 遍歷第二個陣列  \n    → Decision: num 是否在 set1? // 判斷是否屬於交集  \n        Yes → Step 4: 把 num 加入 result // 若在，加入結果集合  \n        No  → // 不做任何事，直接跳到下一個 num  \n→ Step 5: 把 result 轉成 list // 將集合轉為陣列以符合回傳格式  \n→ Step 6: 回傳 list // 回傳交集結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgvrg783c.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpgvrg783c.py\", line 31, in main\n    args = json.loads(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 355, in raw_decode\n    raise JSONDecodeError(\"Expecting value\", s, err.value) from None\njson.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立 target → 所有索引的映射\n        self.index_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.index_map[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選對應 target 的索引\n        return random.choice(self.index_map[target])\n\ndef main():\n    # 讀取整行輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分成兩個陣列：操作列表與參數列表\n    # 例如： '[\"Solution\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]'\n    # 先找第一個 '],' 的位置\n    split_idx = data.find('],')\n    ops_part = data[:split_idx + 1]      # 包含第一個陣列完整\n    args_part = data[split_idx + 1:]     # 其餘的陣列\n\n    ops = json.loads(ops_part)\n    args = json.loads(args_part)\n\n    outputs = []\n    instance = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            instance = Solution(arg[0])  # arg 是包含 nums 的列表\n            outputs.append(None)         # 按 LeetCode 風格輸出 null\n        elif op == \"pick\":\n            res = instance.pick(arg[0])\n            outputs.append(res)\n        else:\n            # 若有其他方法可在此處擴充\n            outputs.append(None)\n\n    # 將結果輸出為 JSON 格式（Python 的 None 會轉成 null）\n    sys.stdout.write(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the described algorithm: The problem is \"Random Pick with Weight\" or \"Random Pick Index\" from LeetCode 384. Approach: Build a map from target to list of indices during initialization. pick: choose random index among list. We need virtual code steps.\n\nWe must output step by step virtual code with explanations after //.\n\nWe use arrows etc.\n\nLet's produce:\n\nStart\n→ Step 1: 定義類別 Solution // 宣告類別\n→ Step 2: 宣告字典 map 以 target → indicesList // 儲存索引\n→ Decision: 初始化是否已載入數組? // 這一步是構造函數\n    Yes → Step 3: 迭代 nums, 將索引加入對應 target 的 list // 建立映射\n    No → End // 不會執行\n\n→ Step 4: pick(target) 函式入口 // 接收目標值\n→ Step 5: 取出 indicesList = map[target] // 取得所有索引\n→ Decision: indicesList 是否為空? // 但題目保證存在\n    Yes → Step 6: 產生隨機數 r 介於 0 與 len(indicesList)-1 // 隨機選擇\n    → Step 7: 返回 indicesList[r] // 隨機索引\n    No → Step 8: 錯誤處理 // 不是必須\n\nEnd\n\nBut we need to follow format strictly: Each line: virtual code step + space + // explanation. Use arrow. Provide decision with Yes/No branches.\n\nLet's produce more refined steps:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類\n→ Step 2: 在類中宣告成員變數 map：Dictionary<int, List<int>> // 用來存 target 與其所有索引\n→ Step 3: 實作構造函式 Solution(nums) // 初始化\n→ Decision: 迭代 nums 並填充 map? // 建立索引映射\n    Yes → Step 4: For i in 0..nums.Length-1\n    → Step 5: target = nums[i]\n    → Step 6: 若 map 不包含 target，新增空列表\n    → Step 7: 將 i 加入 map[target] 的列表\n→ Step 8: pick(target) 函式入口 // 接收目標值\n→ Step 9: indices = map[target] // 取得對應索引列表\n→ Decision: indices 是否為空? // 確保目標存在\n    Yes → Step 10: 隨機數 r = RandomInt(0, indices.Count-1) // 生成隨機整數\n    → Step 11: Return indices[r] // 隨機回傳索引\n    No → Step 12: 把 0 回傳 // 處理錯誤 (理論上不會執行)\n\nEnd // 程式執行結束\n\nWe must use arrows '→', 'Yes →', 'No →' lines. Each step must be single line.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 宣告 Solution 類  \n→ Step 2: 在類中宣告成員變數 map：Dictionary<int, List<int>> // 用來存 target 與其所有索引  \n→ Step 3: 實作構造函式 Solution(nums) // 初始化  \n→ Decision: 迭代 nums 並填充 map? // 建立索引映射  \n Yes → Step 4: For i in 0 .. nums.Length-1  \n → Step 5: target = nums[i] // 取得目前數字  \n → Step 6: 若 map 不包含 target，新增空列表 // 初始化列表  \n → Step 7: 將 i 加入 map[target] 的列表 // 存入索引  \n→ Step 8: pick(target) 函式入口 // 接收目標值  \n→ Step 9: indices = map[target] // 取得對應索引列表  \n→ Decision: indices 是否為空? // 確保目標存在  \n Yes → Step 10: 隨機數 r = RandomInt(0, indices.Count-1) // 生成隨機整數  \n → Step 11: Return indices[r] // 隨機回傳索引  \n No → Step 12: Return 0 // 處理錯誤（理論上不會執行）  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[2,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[2, 3]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # Map reversed word to its index\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n        seen = set()\n\n        for i, word in enumerate(words):\n            length = len(word)\n            for j in range(length + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # Case 1: prefix is palindrome, look for reversed suffix\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_map:\n                        j_idx = rev_map[rev_suffix]\n                        if j_idx != i:\n                            pair = (i, j_idx)\n                            if pair not in seen:\n                                seen.add(pair)\n                                res.append([i, j_idx])\n\n                # Case 2: suffix is palindrome, look for reversed prefix\n                if j != length and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_map:\n                        j_idx = rev_map[rev_prefix]\n                        if j_idx != i:\n                            pair = (j_idx, i)\n                            if pair not in seen:\n                                seen.add(pair)\n                                res.append([j_idx, i])\n\n        # Handle empty string separately to add pairs in both directions\n        empty_idx = None\n        for idx, w in enumerate(words):\n            if w == \"\":\n                empty_idx = idx\n                break\n\n        if empty_idx is not None:\n            for idx, w in enumerate(words):\n                if idx == empty_idx:\n                    continue\n                if w == w[::-1]:\n                    pair1 = (empty_idx, idx)\n                    pair2 = (idx, empty_idx)\n                    if pair1 not in seen:\n                        seen.add(pair1)\n                        res.append([empty_idx, idx])\n                    if pair2 not in seen:\n                        seen.add(pair2)\n                        res.append([idx, empty_idx])\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list expression after '=' if present\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    words = ast.literal_eval(data)\n    solution = Solution()\n    pairs = solution.palindromePairs(words)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that finds all palindrome pairs in O(total length). Classic problem. Approach: build a map of reversed words to indices, then for each word check splits, etc. Complexity O(n * len(word)). Provide virtual code lines with explanation. No actual code, just pseudo-steps. We need to use Start, End, Decision. Provide step-by-step logic.\n\nWe'll produce steps:\n\nStart\n→ Build map revToIndex: for each word, rev=reverse(word); map[rev] = index\n→ For each word index i:\n    → For each split position k from 0 to len(word):\n        → left = word[0:k], right = word[k:]\n        → If left is palindrome:\n            → revRight = reverse(right)\n            → If revRight in map and map[revRight] != i:\n                → Record pair (map[revRight], i)\n        → If k != len(word) and right is palindrome:\n            → revLeft = reverse(left)\n            → If revLeft in map and map[revLeft] != i:\n                → Record pair (i, map[revLeft])\n→ Return list of pairs\nEnd\n\nBut need to mention O(total length) due to checking palindromes and reverse each time, but we can optimize by caching. But for virtual code, we can mention.\n\nLet's produce virtual code lines. Use \"Step\" lines. Also use \"Decision:\" lines for palindrome checks.\n\nWe'll provide line numbers? Not necessary. Just arrow and step. We'll include // explanation.\n\nWe also need to incorporate that we need to store pairs.\n\nLet's produce. Use Start, End. Use arrow \"→\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立字典 revMap，將每個字的逆序對應到其索引 // 用於快速查找匹配的逆序字\n→   Decision: 迭代 words 中的每個 word 和其索引 i\n        → Step 2: rev = reverse(word)\n        → Step 3: revMap[rev] = i\n→ Step 4: 初始化結果 list pairs = [] // 用於儲存所有符合條件的 (i, j)\n→ Decision: 迭代 words 中的每個 word 和其索引 i\n        → Step 5: len = word.length\n        → Decision: 對 k 從 0 到 len（含）進行分割\n              → Step 6: left = word[0:k]  // 前半段\n              → Step 7: right = word[k:] // 後半段\n              → Decision: 是否 left 為回文？\n                    Yes → Step 8: revRight = reverse(right)\n                    Yes → Decision: revRight 是否在 revMap 且 revMap[revRight] != i？\n                          Yes → Step 9: pairs.append((revMap[revRight], i)) // (j, i)\n                          No  → // 無對應\n                    No  → // left 不是回文，跳過\n              → Decision: k < len 并且 right 為回文？\n                    Yes → Step 10: revLeft = reverse(left)\n                    Yes → Decision: revLeft 是否在 revMap 且 revMap[revLeft] != i？\n                          Yes → Step 11: pairs.append((i, revMap[revLeft])) // (i, j)\n                          No  → // 無對應\n                    No  → // right 不是回文，跳過\n→ End // 程式執行結束，返回 pairs 结果集合\n\n// 說明：  \n// 1. revMap 允許 O(1) 查找逆序字的索引，避免重複遍歷。  \n// 2. 每個單詞的所有分割點最多 len+1 次，且檢查回文的時間為 O(len)。  \n// 3. 所有單詞長度總和為 N，故整體時間複雜度為 O(N)。  \n// 4. 記錄下來的對 (i, j) 已經滿足 i != j，且 words[i]+words[j] 為回文。"
    },
    {
      "title": "Maximum Length of Repeated Subarray",
      "source_file": "Leetcode/leetcode718.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef find_length(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_len = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                if dp[i][j] > max_len:\n                    max_len = dp[i][j]\n    return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    nums1 = []\n    nums2 = []\n    if len(lines) >= 2:\n        nums1 = list(map(int, re.findall(r'-?\\d+', lines[0])))\n        nums2 = list(map(int, re.findall(r'-?\\d+', lines[1])))\n    else:\n        parts = re.split(r'(?<=\\])\\s*,\\s*(?=\\[)', data)\n        if len(parts) == 2:\n            nums1 = list(map(int, re.findall(r'-?\\d+', parts[0])))\n            nums2 = list(map(int, re.findall(r'-?\\d+', parts[1])))\n    result = find_length(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: longest common subarray (continuous). We need to output step-by-step virtual code with arrows, etc. Probably using DP or binary search + rolling hash. Choose algorithm: Binary search length + rolling hash O((n+m) log min(n,m)). Or DP O(n*m). For simplicity produce DP approach.\n\nLet's produce steps: Start, input arrays, determine lengths, initialize dp 2 rows, iterate, track maxLen, output result, End.\n\nNeed to produce each line with explanation comment.\n\nAlso need to use \"Start\" and \"End\" tags.\n\nLet's craft:\n\nStart\n→ Step 1: Read arrays nums1, nums2 // 取得兩個整數陣列\n→ Step 2: 設定 n = length(nums1), m = length(nums2) // 取得兩陣列長度\n→ Step 3: 初始化 dp = 2D array (n+1) x (m+1) 為 0 // DP 表，用於記錄連續相同子陣列長度\n→ Step 4: 設 maxLen = 0 // 儲存目前找到的最大長度\n→ Decision: for i from 1 to n? // 循環處理 nums1\n    Yes → for j from 1 to m? // 循環處理 nums2\n        Yes → Decision: 如果 nums1[i-1] == nums2[j-1]? // 比較兩個元素\n            Yes → dp[i][j] = dp[i-1][j-1] + 1 // 連續匹配長度加 1\n                → Decision: 如果 dp[i][j] > maxLen? // 更新最大長度\n                    Yes → maxLen = dp[i][j] // 更新\n            No → dp[i][j] = 0 // 不匹配，重置為 0\n        No  → continue\n    No → continue\n→ Step 5: 輸出 maxLen // 回傳最大子陣列長度\nEnd\n\nBut must include arrow '→' before each step. For loops, we use indentation? Example earlier: They used indentation with arrow and Decision lines. So we need to indent sub-steps under decision. For loops, we might just write Decision: for i from 1 to n? then inside Yes block.\n\nLet's produce like:\n\nStart // 程式開始執行\n→ Step 1: 讀取兩個整數陣列 nums1 與 nums2 // 取得輸入資料\n→ Step 2: 設定 n = length(nums1)，m = length(nums2) // 取得陣列長度\n→ Step 3: 初始化 dp 為 2×(m+1) 的 2D 陣列，全部填 0 // DP 表，用於存連續相同子陣列長度\n→ Step 4: 設 maxLen = 0 // 儲存目前找到的最大長度\n→ Decision: i = 1 到 n? // 逐行處理 nums1\n    Yes → Decision: j = 1 到 m? // 逐列處理 nums2\n        Yes → Decision: nums1[i-1] == nums2[j-1]? // 比較對應元素\n            Yes → dp[j] = dpPrev[j-1] + 1 // 更新連續長度\n                → Decision: dp[j] > maxLen? // 是否更新最大值\n                    Yes → maxLen = dp[j] // 更新\n            No  → dp[j] = 0 // 不匹配時重置\n        No  → continue\n    No → continue\n→ Step 5: 輸出 maxLen // 回傳最大子陣列長度\nEnd // 程式執行結束\n\nBut we used dpPrev; we need dpPrev array for previous row. We can describe step: maintain two rows. Let's adjust.\n\nAlternatively, produce simple DP using 2D array. That is okay.\n\nLet's rewrite with explicit dp[i][j]. Simpler.\n\nStart\n→ Step 1: 讀取 nums1 與 nums2 // 取得輸入\n→ Step 2: n ← length(nums1)，m ← length(nums2) // 取得長度\n→ Step 3: 建立 dp 為 (n+1)×(m+1) 二維表，全部為 0 // DP表\n→ Step 4: maxLen ← 0 // 儲存最大子陣列長度\n→ Decision: i 取值 1~n? // 逐行\n    Yes → Decision: j 取值 1~m? // 逐列\n        Yes → Decision: nums1[i-1] == nums2[j-1]? // 比較元素\n            Yes → dp[i][j] ← dp[i-1][j-1] + 1 // 連續長度加 1\n                → Decision: dp[i][j] > maxLen? // 更新最大長度\n                    Yes → maxLen ← dp[i][j] // 更新\n            No  → dp[i][j] ← 0 // 重置\n        No  → continue\n    No → continue\n→ Step 5: 輸出 maxLen // 回傳結果\nEnd // 程式結束\n\nLet's output each line as specified. Ensure each line includes virtual code step then space then comment.\n\nMake sure arrow '→' used consistently. Use indenting for nested steps. Provide the entire pseudo code. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個整數陣列 nums1 與 nums2 // 取得輸入資料  \n→ Step 2: n ← length(nums1)，m ← length(nums2) // 取得陣列長度  \n→ Step 3: 建立 dp 為 (n+1)×(m+1) 的 2D 陣列，全部初始為 0 // DP 表，用於存放連續相同子陣列長度  \n→ Step 4: maxLen ← 0 // 儲存目前找到的最大子陣列長度  \n→ Decision: i 取值 1~n? // 逐行處理 nums1  \n Yes → Decision: j 取值 1~m? // 逐列處理 nums2  \n  Yes → Decision: nums1[i-1] == nums2[j-1]? // 比較對應元素是否相同  \n   Yes → dp[i][j] ← dp[i-1][j-1] + 1 // 連續匹配長度加 1  \n    → Decision: dp[i][j] > maxLen? // 是否更新最大長度  \n     Yes → maxLen ← dp[i][j] // 更新最大長度  \n   No → dp[i][j] ← 0 // 不匹配時重置為 0  \n  No → continue // j 循環結束  \n No → continue // i 循環結束  \n→ Step 5: 輸出 maxLen // 回傳最大子陣列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef findLUSlength(strs):\n    \"\"\"\n    回傳最長不常見子序列的長度。\n    如果所有字串都重複，則回傳 -1。\n    \"\"\"\n    count = Counter(strs)       # 計算每個字串出現次數\n    max_len = -1\n    for s in strs:\n        if count[s] == 1:      # 只出現一次的字串一定不會是其他字串的子序列\n            max_len = max(max_len, len(s))\n    return max_len\n\ndef main():\n    \"\"\"\n    主程式：讀取輸入、處理、輸出結果。\n    \"\"\"\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援 Python 文字列與 JSON 格式\n    try:\n        strs = ast.literal_eval(data)\n    except Exception:\n        import json\n        strs = json.loads(data)\n\n    result = findLUSlength(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines, step by step. Requirements: virtual code with arrows and Decision: etc. Provide for the problem: longest uncommon subsequence between array of strings. Known solution: if all strings equal, return -1 else return max length of string that is not present elsewhere. Actually solution: if any string appears only once, answer is its length; else -1. Because any string that is not subsequence of any other? Actually longest uncommon subsequence: any string that is not a subsequence of any other string. For strings, if a string is unique (no duplicates), then it cannot be a subsequence of other identical strings. But could it be a subsequence of other longer strings? But in typical solution, we consider unique strings and return max length among them. Because if a string is unique, but could be subsequence of another string; but for longest uncommon subsequence, we can choose that string itself if it's not subsequence of any other. But common known solution: check duplicates; if duplicates exist, you cannot use that length; answer is max length among strings that have no duplicates. Because if a string appears only once, then it's not a subsequence of another identical string, but could be subsequence of a longer string? But that longer string might not have it as subsequence? But typical problem expects answer as length of longest string that is unique. Let's produce algorithm accordingly.\n\nWe'll produce virtual code steps.\n\nWe need to include Start, End, Decision.\n\nLet's produce:\n\nStart\n→ Step 1: 讀取輸入陣列 strs // 獲取字符串陣列\n→ Step 2: 建立字典 count 以記錄每個字符串出現次數 // 用於判斷是否重複\n→ Step 3: 逐一遍歷 strs，更新 count // 統計頻率\n→ Step 4: 初始化 maxLen 為 -1 // 預設不存在\n→ Step 5: 逐一遍歷 strs：\n    → Decision: 如果 count[str] == 1 ? // 該字符串只出現一次\n        Yes → Step 6: maxLen = max(maxLen, len(str)) // 更新最大長度\n        No  → Step 7: // 忽略重複字符串\n→ Step 8: 返回 maxLen // 輸出結果\nEnd\n\nBut we also might need to check subsequence property: For unique string, it's always uncommon? Actually typical reasoning: If there is duplicate string, cannot be uncommon. If no duplicate, the longest string is answer. Because any longer string cannot be a subsequence of another identical string. But maybe it's subsequence of another longer string? But we can't guarantee. But typical solution accepted. We'll just produce that.\n\nLet's add decision for no duplicate case.\n\nLet's produce final virtual code accordingly.\n\nWe need to ensure each line with // explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 strs // 取得所有待分析的字串  \n→ Step 2: 建立字典 count 以記錄每個字串出現次數 // 方便判斷重複  \n→ Step 3: 逐一遍歷 strs，更新 count // 統計每個字串的頻率  \n→ Step 4: 初始化變數 maxLen 為 -1 // 預設沒有符合條件的子序列  \n→ Step 5: 逐一遍歷 strs  \n  → Decision: 如果 count[str] == 1? // 該字串僅出現一次  \n   Yes → Step 6: maxLen = max(maxLen, len(str)) // 更新最大長度  \n   No  → Step 7: // 忽略重複字串，因為它一定是共通子序列  \n→ Step 8: 返回 maxLen // 輸出最長不常見子序列長度（若不存在則為 -1）  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\ndef permute(nums):\n    res = []\n\n    def backtrack(start):\n        if start == len(nums):\n            res.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        l = data.index('[')\n        r = data.rindex(']')\n        nums = ast.literal_eval(data[l:r+1])\n    except Exception:\n        nums = eval(data.replace('nums =', '').strip())\n    result = permute(nums)\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for generating all permutations of array of distinct integers. Use start, decisions, steps, arrow. Provide each line. No actual code. Just virtual code. Provide explanation after each line. Let's structure. Steps: Start, input array, initialize result list, define recursive function backtrack(currentPermutation, used). In recursion: if currentPermutation length == n, add copy to result. Else iterate over each index, if not used, add to currentPermutation, mark used, recurse, then backtrack removal and unmark. After recursion, return result. End.\n\nWe need to produce each line as virtual code step with explanation.\n\nLet's write:\n\nStart // program start\n\n→ Step 1: Input array nums // get input array\n\n→ Step 2: Set n ← length(nums) // store length\n\n→ Step 3: Initialize result ← empty list // to collect permutations\n\n→ Step 4: Define Function backtrack(path, used) // recursive helper\n\n→ Decision: If length(path) == n? // check if permutation complete\n\n    Yes → Step 5: Append copy of path to result // store complete permutation\n\n    No  → Step 6: For i from 0 to n-1? // iterate indices\n\n        → Decision: If used[i] == false? // element not used\n\n            Yes → Step 7: Append nums[i] to path // add element\n\n            → Step 8: Set used[i] ← true // mark used\n\n            → Step 9: Call backtrack(path, used) // recurse\n\n            → Step 10: Set used[i] ← false // unmark\n\n            → Step 11: Remove last element from path // backtrack\n\nEnd // program end\n\nBut we need to indicate arrow for decision blocks. Also we need to indent or show arrows. Use arrow after decision: Yes → ... No → ... The \"For\" loop can be represented as a step. We need to use \"→ Step 6: For i from 0 to n-1\" but inside we need decisions for used[i] false. We can represent nested decisions.\n\nWe need each line: virtual code step [space] // explanation.\n\nThus produce lines accordingly. Use arrows.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得輸入的整數陣列\n→ Step 2: 設定 n ← length(nums) // 存儲陣列長度\n→ Step 3: 初始化 result ← 空清單 // 用於存放所有排列\n→ Step 4: 定義函式 backtrack(path, used) // 定義遞迴輔助函式\n→ Decision: 若 length(path) == n? // 檢查是否已完成排列\n    Yes → Step 5: 將 path 的副本加入 result // 完整排列加入結果\n    No  → Step 6: 循環 i ← 0 到 n-1 // 遍歷所有索引\n        → Decision: 若 used[i] 為 false? // 該元素尚未使用\n            Yes → Step 7: 將 nums[i] 加入 path // 加入當前元素\n            → Step 8: 將 used[i] 設為 true // 標記為已使用\n            → Step 9: 呼叫 backtrack(path, used) // 進行遞迴\n            → Step 10: 將 used[i] 設為 false // 取消使用標記\n            → Step 11: 從 path 移除最後一個元素 // 回溯\n\n→ Step 12: 呼叫 backtrack([], [false]*n) // 開始遞迴，初始空路徑與全未使用\n→ Step 13: 回傳 result // 回傳所有排列\nEnd // 程式執行結束\n\nBut we must keep format: Each line is \"虛擬碼步驟 // 解釋\". For decision lines we can use \"Decision:\" preceding. For nested decisions, we need to indent? Might not necessary, but can use arrow for nested. They didn't specify indentation, but we can use indentation or new lines. For readability, we can just use each line separate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得輸入的整數陣列\n→ Step 2: 設定 n ← length(nums) // 存儲陣列長度\n→ Step 3: 初始化 result ← 空清單 // 用於存放所有排列\n→ Step 4: 定義函式 backtrack(path, used) // 定義遞迴輔助函式\n→ Decision: 若 length(path) == n? // 檢查是否已完成排列\n    Yes → Step 5: 將 path 的副本加入 result // 完整排列加入結果\n    No  → Step 6: 循環 i ← 0 到 n-1 // 遍歷所有索引\n        → Decision: 若 used[i] 為 false? // 該元素尚未使用\n            Yes → Step 7: 將 nums[i] 加入 path // 加入當前元素\n            → Step 8: 將 used[i] 設為 true // 標記為已使用\n            → Step 9: 呼叫 backtrack(path, used) // 進行遞迴\n            → Step 10: 將 used[i] 設為 false // 取消使用標記\n            → Step 11: 從 path 移除最後一個元素 // 回溯\n→ Step 12: 呼叫 backtrack([], [false]*n) // 開始遞迴，初始空路徑與全未使用\n→ Step 13: 回傳 result // 回傳所有排列\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg97y20q2.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpg97y20q2.py\", line 50, in main\n    maxwidth_part = parts[1].split('=', 1)[1].strip()\n                    ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkqmg_yd0.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpkqmg_yd0.py\", line 50, in main\n    maxwidth_part = parts[1].split('=', 1)[1].strip()\n                    ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0l167ls8.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmp0l167ls8.py\", line 50, in main\n    maxwidth_part = parts[1].split('=', 1)[1].strip()\n                    ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # Determine how many words fit in the current line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            gaps = len(line_words) - 1\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n\n            # Build the line\n            if j == n or gaps == 0:\n                # Left-justify for the last line or a line with a single word\n                line = ' '.join(line_words)\n                line += ' ' * (maxWidth - len(line))\n            else:\n                # Fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line_parts = []\n                for k in range(gaps):\n                    line_parts.append(line_words[k])\n                    # Add base spaces + one extra space for the leftmost gaps\n                    line_parts.append(' ' * (space + (1 if k < extra else 0)))\n                line_parts.append(line_words[-1])\n                line = ''.join(line_parts)\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input like: words = [...], maxWidth = 16\n    parts = [part.strip() for part in data.split(',')]\n    words_part = parts[0].split('=', 1)[1].strip()\n    maxwidth_part = parts[1].split('=', 1)[1].strip()\n    words = ast.literal_eval(words_part)\n    maxWidth = int(maxwidth_part)\n\n    solution = Solution()\n    result = solution.fullJustify(words, maxWidth)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps and explanation. We should avoid actual code; use pseudocode with arrows. Should produce algorithm for text justification. Provide steps: Start, index i=0, loop until i<words length, determine line words, calculate line length, decide if last line or not, then build line string accordingly, etc.\n\nUse structure: Start, Decision, etc. Each line like \"Start // 程式開始執行\".\n\nWe need to produce virtual code that is step-by-step. The requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\"\n\nOk produce.\n\nMake sure each line has \"虛擬碼步驟\" then a space then \"// 解釋/說明\". Use arrow symbol \"→\" inside virtual code.\n\nWe need to not output actual code; just structure.\n\nLet's produce.\n\nWe will use variables: i, words, maxWidth, n, result array. Steps: Initialize result, i=0.\n\nLoop: Start block: \"Start\" etc.\n\nLet's produce.\n\nWe must produce the pseudocode lines only; no actual code. Use arrow for substeps. Indent? We can just have lines.\n\nWe can use decisions like \"Decision: Is i < words.length?\" but we might not need as we use loop.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ i = 0 // 初始索引指向第一個單詞\n→ result = [] // 儲存每行文字的結果\n→ Decision: i < words.length? // 是否還有單詞未處理\n    Yes → // 處理下一行\n        → line_start = i // 記錄行首單詞索引\n        → line_length = 0 // 本行字數總長\n        → Decision: i < words.length AND line_length + words[i].length + (i - line_start) <= maxWidth? // 加入單詞不超過寬度\n            Yes → // 加入單詞\n                → line_length += words[i].length // 更新字數總長\n                → i += 1 // 移動到下一個單詞\n                → Repeat Decision // 重新檢查是否可再加入單詞\n            No  → // 完成本行單詞收集\n                → line_end = i // 行末單詞索引\n                → Decision: i == words.length? // 是否為最後一行\n                    Yes → // 最後一行：左對齊\n                        → words_in_line = words[line_start : line_end] // 取得本行單詞\n                        → line = join words_in_line with single space // 用單一空格連接\n                        → pad_spaces = maxWidth - length(line) // 計算剩餘空格\n                        → line += repeat ' ' pad_spaces // 在右側填充空格\n                        → result.append(line) // 加入結果\n                    No  → // 非最後一行：全對齊\n                        → words_in_line = words[line_start : line_end]\n                        → total_words = line_end - line_start\n                        → If total_words == 1? // 只一個單詞\n                            Yes → // 單詞後填滿空格\n                                → line = words_in_line[0] + repeat ' ' (maxWidth - words_in_line[0].length)\n                                → result.append(line)\n                            No  → // 多個單詞\n                                → spaces_needed = maxWidth - line_length // 需分配的空格數\n                                → gaps = total_words - 1 // 空隙數\n                                → base_space = spaces_needed // gaps // 每個空隙最小空格數\n                                → extra = spaces_needed % gaps // 需要額外空格的左側空隙數\n                                → line = \"\"\n                                → For each word_index from line_start to line_end-1\n                                    → line += words[word_index] // 加入單詞\n                                    → gap_index = word_index - line_start\n                                    → If gap_index < gaps:\n                                        → spaces_to_add = base_space + (gap_index < extra ? 1 : 0) // 左側多一個空格\n                                        → line += repeat ' ' spaces_to_add // 加入空格\n                                → result.append(line)\n        → Repeat Decision: i < words.length? // 回到循環判斷\n    No  → End // 所有單詞已處理，結束\nEnd // 程式執行結束\n\nNeed to ensure format: each line with \"虛擬碼步驟\" followed by a space then \"// 解釋\". Use \"→\" inside lines. Also decisions should be lines starting with \"Decision:\" and then indent inside. The arrow can be used inside lines. Provide each line separately.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ i = 0 // 設定單詞指標為第一個單詞  \n→ result = [] // 用來儲存每行文字的結果  \n\nDecision: i < words.length? // 是否還有單詞未處理？  \n    Yes → // 開始處理一行  \n        → line_start = i // 記錄本行第一個單詞的索引  \n        → line_length = 0 // 本行字母總長度初始化為0  \n        Decision: i < words.length AND line_length + words[i].length + (i - line_start) <= maxWidth? // 檢查是否可以再加入單詞而不超過寬度？  \n            Yes → // 可加入單詞  \n                → line_length += words[i].length // 更新字母總長度  \n                → i += 1 // 移至下一個單詞  \n                → Repeat Decision // 重新檢查是否還可加入  \n            No  → // 本行單詞收集完成  \n                → line_end = i // 記錄本行最後一個單詞的索引  \n                Decision: i == words.length? // 判斷是否為最後一行？  \n                    Yes → // 最後一行：左對齊  \n                        → words_in_line = words[line_start : line_end] // 取得本行所有單詞  \n                        → line = join words_in_line with single space // 用單一空格連接單詞  \n                        → pad_spaces = maxWidth - length(line) // 計算需要填充的空格數  \n                        → line += repeat ' ' pad_spaces // 在右側填充空格  \n                        → result.append(line) // 將完成的行加入結果  \n                    No  → // 非最後一行：全對齊  \n                        → words_in_line = words[line_start : line_end] // 取得本行所有單詞  \n                        → total_words = line_end - line_start // 本行單詞數  \n                        Decision: total_words == 1? // 是否只有一個單詞？  \n                            Yes → // 單詞後填滿空格  \n                                → line = words_in_line[0] + repeat ' ' (maxWidth - words_in_line[0].length) // 填充右側空格  \n                                → result.append(line) // 加入結果  \n                            No  → // 多個單詞：計算並分配空格  \n                                → spaces_needed = maxWidth - line_length // 需要分配的空格總數  \n                                → gaps = total_words - 1 // 空隙數（單詞之間的空格個數）  \n                                → base_space = spaces_needed // gaps // 每個空隙最小空格數  \n                                → extra = spaces_needed % gaps // 需要額外空格的左側空隙數  \n                                → line = \"\" // 初始化行字串  \n                                → For each word_index from line_start to line_end-1  \n                                    → line += words[word_index] // 加入單詞  \n                                    → gap_index = word_index - line_start // 當前單詞所在的空隙位置  \n                                    → If gap_index < gaps:  \n                                        → spaces_to_add = base_space + (gap_index < extra ? 1 : 0) // 左側多一個空格  \n                                        → line += repeat ' ' spaces_to_add // 加入空格  \n                                → result.append(line) // 將完成的行加入結果  \n        → Repeat Decision: i < words.length? // 回到循環判斷是否還有未處理的單詞  \n    No  → End // 所有單詞已處理，結束程式  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        \"\"\"\n        使用 Floyd's Tortoise and Hare 演算法找出陣列中的重複數字。\n        - 每一次迭代，tortoise 向前走一步，hare 向前走兩步。\n        - 當兩者相遇時，從陣列開頭重新啟動 tortoise，兩者再以相同速度前進。\n        - 兩者再次相遇的位置即為重複數字。\n        \"\"\"\n        # 第一階段：尋找相遇點\n        tortoise = nums[0]\n        hare = nums[nums[0]]\n        while tortoise != hare:\n            tortoise = nums[tortoise]\n            hare = nums[nums[hare]]\n\n        # 第二階段：尋找入口點（重複數字）\n        tortoise = nums[0]\n        while tortoise != hare:\n            tortoise = nums[tortoise]\n            hare = nums[hare]\n\n        return hare\n\ndef parse_input() -> List[int]:\n    \"\"\"\n    從標準輸入讀取陣列資料。\n    支援類似 'nums = [1,2,3,3]' 的輸入格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n\n    # 只取 '=' 之後的部分（如果存在）\n    if '=' in data:\n        _, value_part = data.split('=', 1)\n        data = value_part.strip()\n\n    # 移除可能存在的空白與換行\n    data = data.replace('\\n', '').replace('\\r', '')\n\n    # 直接使用 eval 解析成 list，前提是輸入格式安全\n    return eval(data)\n\nif __name__ == \"__main__\":\n    nums = parse_input()\n    if nums:\n        solution = Solution()\n        result = solution.findDuplicate(nums)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for finding duplicate number in array without modifying array and O(1) extra space. Classic solution: Floyd's Tortoise and Hare (cycle detection) or binary search on value range.\n\nWe should output step-by-step with virtual code and explanation.\n\nWe need to use arrows, Decision etc. Provide step lines.\n\nProbably choose Floyd's algorithm: treat array as linked list where next pointer is value at index; due to duplicate, there is a cycle. Steps:\n\nStart\n→ Step 1: Initialize tortoise = nums[0] // start pointer\n→ Step 2: Initialize hare = nums[nums[0]] // two steps\n→ Decision: While tortoise ≠ hare? // find intersection\n    Yes → tortoise = nums[tortoise]\n    Yes → hare = nums[nums[hare]]\n→ Step 3: Move tortoise to start (index 0) // reset\n→ Decision: While tortoise ≠ hare? // find entrance\n    Yes → tortoise = nums[tortoise]\n    Yes → hare = nums[hare]\n→ Step 4: Return hare // duplicate number\n\nNeed to include Start and End. Provide explanation after each line.\n\nAlso maybe include comment about complexity.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: tortoise ← nums[0] // 以陣列第一個元素作為慢指標的起點  \n→ Step 2: hare ← nums[nums[0]] // 以陣列第一個元素所指的值作為快指標的起點（快指標走兩步）  \n→ Decision: tortoise ≠ hare? // 判斷慢快指標是否相遇  \n Yes → tortoise ← nums[tortoise] // 慢指標每次走一步  \n Yes → hare ← nums[nums[hare]] // 快指標每次走兩步  \n Yes → （重複上述直到相遇）  \n→ Step 3: tortoise ← nums[0] // 相遇後把慢指標重新指回陣列起點，準備尋找入口  \n→ Decision: tortoise ≠ hare? // 判斷慢快指標是否到達相同位置  \n Yes → tortoise ← nums[tortoise] // 慢指標再走一步  \n Yes → hare ← nums[hare] // 快指標再走一步  \n Yes → （重複上述直到相遇）  \n→ Step 4: return hare // 兩指標相遇的位置即為重複數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6i93v_64.py\", line 92, in <module>\n    main()\n  File \"/tmp/tmp6i93v_64.py\", line 63, in main\n    ops, args = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6i93v_64.py\", line 58, in parse_input\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [], [3], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # small is a max-heap (store negatives), large is a min-heap\n        self.small = []\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # push into small heap (as negative to simulate max-heap)\n        heapq.heappush(self.small, -num)\n\n        # balance if necessary: max of small > min of large\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # maintain size property: difference not more than 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return float(-self.small[0])\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that consists of two lists:\n    operations and arguments. Handles both single-line\n    and two-line formats.\n    \"\"\"\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if not lines:\n        return [], []\n    if len(lines) == 1:\n        # Might be \"ops], [args\"\n        parts = lines[0].split('],', 1)\n        if len(parts) == 2:\n            ops_str = parts[0] + ']'\n            args_str = '[' + parts[1].strip()\n            if not args_str.endswith(']'):\n                args_str += ']'\n        else:\n            # fallback: split by first comma\n            parts = lines[0].split(',', 1)\n            ops_str, args_str = parts[0], parts[1]\n    else:\n        ops_str, args_str = lines[0], lines[1]\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    data = sys.stdin.read()\n    ops, args = parse_input(data)\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            res.append(None)\n        elif op == \"addNum\":\n            # arg is a list like [num]\n            obj.addNum(arg[0])\n            res.append(None)\n        elif op == \"findMedian\":\n            res.append(obj.findMedian())\n        else:\n            # unknown operation\n            res.append(None)\n\n    # Convert result to required string format: None -> null\n    out_parts = []\n    for val in res:\n        if val is None:\n            out_parts.append('null')\n        else:\n            out_parts.append(str(val))\n    print('[' + ', '.join(out_parts) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for a MedianFinder class. Steps: use two heaps: max-heap left, min-heap right. On addNum: push to left or right balancing. findMedian: if sizes equal, average; else top of larger.\n\nWe output step by step. The virtual code will represent class methods. Use Start, End, Decision. We need to be careful to include each line with explanation. Provide code lines like:\n\nStart // Program start\n→ Step: define MedianFinder class // ...\n→ Step: declare maxHeap, minHeap // ...\n→ Step: constructor // ...\n\nAddNum method: lines.\n\nFindMedian method: lines.\n\nUse Decision: if left.size == right.size? etc.\n\nReturn. End.\n\nMake sure each line has explanation comment. Use \"→\" arrow to indicate next. Use \"Decision:\" lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 建立資料結構\n→ Step 2: 宣告 leftHeap 為最大堆 // 存放較小一半的數字\n→ Step 3: 宣告 rightHeap 為最小堆 // 存放較大一半的數字\n→ Step 4: 建構子 MedianFinder() // 初始化兩個堆\n    → Step 5: leftHeap ← 新建 MaxHeap() // 具體堆實作\n    → Step 6: rightHeap ← 新建 MinHeap()\n→ Step 7: 方法 addNum(num) // 接收新數字\n    → Decision: 左堆是否為空或 num ≤ leftHeap.peek()? // 判斷放入左堆還是右堆\n        Yes → Step 8: leftHeap.push(num) // 放入左堆\n        No  → Step 9: rightHeap.push(num) // 放入右堆\n    → Decision: leftHeap.size - rightHeap.size > 1? // 檢查左堆是否太大\n        Yes → Step 10: rightHeap.push(leftHeap.pop()) // 移動最大值到右堆\n        No  → Decision: rightHeap.size - leftHeap.size > 1? // 檢查右堆是否太大\n            Yes → Step 11: leftHeap.push(rightHeap.pop()) // 移動最小值到左堆\n            No  → Step 12: // 兩堆已平衡，無需操作\n→ Step 13: 方法 findMedian() // 回傳目前中位數\n    → Decision: leftHeap.size == rightHeap.size? // 检查堆大小是否相等\n        Yes → Step 14: median ← (leftHeap.peek() + rightHeap.peek()) / 2.0 // 兩邊平均\n        No  → Decision: leftHeap.size > rightHeap.size? // 判斷哪邊多\n            Yes → Step 15: median ← leftHeap.peek() // 左堆多，取最大值\n            No  → Step 16: median ← rightHeap.peek() // 右堆多，取最小值\n    → Step 17: return median // 返回中位數\nEnd // 程式執行結束"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[null,null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]],null,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[null, null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]], null, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        # Find the position to insert or merge\n        new_start, new_end = val, val\n        i = bisect.bisect_left(self.intervals, [val, val])\n        # Merge with left interval if overlapping or adjacent\n        if i > 0 and self.intervals[i-1][1] + 1 >= val:\n            i -= 1\n            new_start = min(new_start, self.intervals[i][0])\n            new_end = max(new_end, self.intervals[i][1])\n        # Merge with right intervals\n        j = i\n        while j < len(self.intervals) and self.intervals[j][0] - 1 <= new_end:\n            new_end = max(new_end, self.intervals[j][1])\n            j += 1\n        # Replace merged intervals with the new one\n        self.intervals[i:j] = [[new_start, new_end]]\n\n    def getIntervals(self):\n        return self.intervals\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    params = json.loads(data[1])\n\n    obj = None\n    outputs = []\n    for cmd, args in zip(commands, params):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            outputs.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(args[0])\n            outputs.append(None)\n        elif cmd == \"getIntervals\":\n            outputs.append(obj.getIntervals())\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. It's like flowchart. We'll produce steps for SummaryRanges class with methods, internal state etc. Probably use list of intervals sorted. The virtual code steps should cover initialization, addNum logic: find position, merge with neighbors. getIntervals just return copy. So produce steps with Start, etc.\n\nLet's design high-level steps:\n\nStart SummaryRanges // 初始化\n    → Step 1: intervals = empty list // 保存不相交區間\nEnd\n\naddNum(value)\n    → Step 1: if intervals empty → insert [value,value] → End\n    → Decision: find index i such that intervals[i].start <= value <= intervals[i].end? (value inside an interval)\n        Yes → Step 2: value already present → End\n        No  → Decision: find left neighbor idx where intervals[idx].end +1 == value?\n            Yes → Step 3: extend left interval's end to value\n                Decision: also check right neighbor where intervals[idx+1].start -1 == value?\n                    Yes → Step 4: merge left interval with right interval (extend end to right.end, remove right)\n                    No  → End\n            No  → Decision: find right neighbor where intervals[idx].start -1 == value?\n                Yes → Step 5: extend right interval's start to value\n                No  → Step 6: insert new interval [value,value] at correct position\n    End\n\ngetIntervals()\n    → Step 1: return copy of intervals\n\nWe need to use arrow and decisions lines.\n\nLet's produce virtual code lines. Use \"Start\" and \"End\" for each method.\n\nThe structure: \"Start SummaryRanges\" maybe not necessary but we can start with \"Start\" for constructor. But they require each line as \"虛擬碼步驟\" + space + explanation. Use \"Start\" or \"End\".\n\nLet's create:\n\nStart // SummaryRanges initialization\n→ Step 1: intervals ← empty list // 初始化區間列表\nEnd // Constructor done\n\nStart addNum(value) // 處理新增數字\n→ Step 1: if intervals is empty? // 檢查是否有區間\n    Yes → Step 2: intervals.append([value, value]) // 新增單值區間\n    No  → Decision: find i such that intervals[i].start <= value <= intervals[i].end? // 判斷值是否已在某區間\n        Yes → Step 3: return // 數字已存在，無需處理\n        No  → Decision: find left index l where intervals[l].end + 1 == value? // 判斷是否可以延伸左側\n            Yes → Step 4: intervals[l].end ← value // 延伸左側區間\n                Decision: also check right index r = l + 1 where intervals[r].start - 1 == value? // 判斷是否可合併右側\n                    Yes → Step 5: intervals[l].end ← intervals[r].end // 合併右側區間\n                        → Step 6: remove intervals[r] // 刪除合併後的右側區間\n                    No  → Step 7: return // 只延伸左側已完成\n            No  → Decision: find right index r where intervals[r].start - 1 == value? // 判斷是否可以延伸右側\n                Yes → Step 8: intervals[r].start ← value // 延伸右側區間\n                No  → Step 9: insert new interval [value, value] at correct position // 新增獨立區間\nEnd // addNum 完成\n\nStart getIntervals() // 取得當前區間\n→ Step 1: return copy of intervals // 回傳區間清單\nEnd // getIntervals 完成\n\nWe need each line as \"虛擬碼步驟 [space] // 解釋\". So format:\n\nStart // SummaryRanges 初始化\n→ Step 1: intervals ← empty list // 初始化區間列表\nEnd // 建構子完成\n\nStart addNum(value) // 處理新增數字\n→ Step 1: if intervals is empty? // 檢查是否有區間\n    Yes → Step 2: intervals.append([value, value]) // 新增單值區間\n    No  → Decision: find i such that intervals[i].start <= value <= intervals[i].end? // 判斷值是否已在某區間\n        Yes → Step 3: return // 數字已存在，無需處理\n        No  → Decision: find left index l where intervals[l].end + 1 == value? // 判斷是否可以延伸左側\n            Yes → Step 4: intervals[l].end ← value // 延伸左側區間\n                Decision: also check right index r = l + 1 where intervals[r].start - 1 == value? // 判斷是否可合併右側\n                    Yes → Step 5: intervals[l].end ← intervals[r].end // 合併右側區間\n                        → Step 6: remove intervals[r] // 刪除合併後的右側區間\n                    No  → Step 7: return // 只延伸左側已完成\n            No  → Decision: find right index r where intervals[r].start - 1 == value? // 判斷是否可以延伸右側\n                Yes → Step 8: intervals[r].start ← value // 延伸右側區間\n                No  → Step 9: insert new interval [value, value] at correct position // 新增獨立區間\nEnd // addNum 完成\n\nStart getIntervals() // 取得當前區間\n→ Step 1: return copy of intervals // 回傳區間清單\nEnd // getIntervals 完成\n\nCheck formatting: Indent lines after Decision with spaces. Should be fine.\n\nWe need to ensure each line is a single line. But indentation lines like \"Yes → Step 2:\" can be same line? Actually example shows indentation like:\n\n    Yes → Step 2: 輸出 '正數' //...\n\nSo we can write each line with appropriate indentation spaces before Yes → Step 2:. It's fine.\n\nThus produce final output.\n...done thinking.\n\nStart // SummaryRanges 初始化\n→ Step 1: intervals ← empty list // 初始化區間列表\nEnd // 建構子完成\n\nStart addNum(value) // 處理新增數字\n→ Step 1: if intervals is empty? // 檢查是否有區間\n    Yes → Step 2: intervals.append([value, value]) // 新增單值區間\n    No  → Decision: find i such that intervals[i].start <= value <= intervals[i].end? // 判斷值是否已在某區間\n        Yes → Step 3: return // 數字已存在，無需處理\n        No  → Decision: find left index l where intervals[l].end + 1 == value? // 判斷是否可以延伸左側\n            Yes → Step 4: intervals[l].end ← value // 延伸左側區間\n                Decision: also check right index r = l + 1 where intervals[r].start - 1 == value? // 判斷是否可合併右側\n                    Yes → Step 5: intervals[l].end ← intervals[r].end // 合併右側區間\n                        → Step 6: remove intervals[r] // 刪除合併後的右側區間\n                    No  → Step 7: return // 只延伸左側已完成\n            No  → Decision: find right index r where intervals[r].start - 1 == value? // 判斷是否可以延伸右側\n                Yes → Step 8: intervals[r].start ← value // 延伸右側區間\n                No  → Step 9: insert new interval [value, value] at correct position // 新增獨立區間\nEnd // addNum 完成\n\nStart getIntervals() // 取得當前區間\n→ Step 1: return copy of intervals // 回傳區間清單\nEnd // getIntervals 完成"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,5],[6,9]]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[[1,5],[6,9]]'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2],[3,10],[12,16]]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[[1,2],[3,10],[12,16]]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, new_interval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals\n        and merge if necessary.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < new_interval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= new_interval[1]:\n            new_interval[0] = min(new_interval[0], intervals[i][0])\n            new_interval[1] = max(new_interval[1], intervals[i][1])\n            i += 1\n\n        # 3. Add the merged (or original) new interval\n        result.append(new_interval)\n\n        # 4. Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse input format: intervals = [[...]], newInterval = [...]\n    pattern = r'intervals\\s*=\\s*(\\[[\\s\\[\\],]*\\])\\s*,\\s*newInterval\\s*=\\s*(\\[[\\s\\[\\],]*\\])'\n    match = re.search(pattern, data)\n    if not match:\n        # If the input does not match the expected pattern, exit\n        return\n\n    intervals = ast.literal_eval(match.group(1))\n    new_interval = ast.literal_eval(match.group(2))\n\n    sol = Solution()\n    result = sol.insert(intervals, new_interval)\n\n    # Print the result to stdout\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for insertion and merging intervals. Each line must be \"虛擬碼步驟 // 解釋\". Use arrow, Decision, etc. Let's plan steps:\n\nStart\n→ Define result array\n→ Iterate through intervals\n    → Decision: If current interval ends < newInterval.start? (non-overlap left)\n        Yes → Add current interval to result\n        No → Decision: If current interval starts > newInterval.end? (non-overlap right)\n            Yes → Add newInterval to result\n                 Add remaining intervals\n                 Go to End\n            No → Overlap found: Merge intervals\n                 Update newInterval.start = min(current.start, newInterval.start)\n                 Update newInterval.end = max(current.end, newInterval.end)\n                 Continue loop (skip adding yet)\n→ After loop, add newInterval to result\n→ End\n\nWe need to ensure no overlapping intervals remain. The pseudocode must be line by line with arrows. Use \"→\" for sequential steps, \"Decision:\" with Yes and No branches. Use \"Start\", \"End\".\n\nMake sure each line has a brief explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Result ← [] // 建立空的結果陣列\n→ NewInterval ← [start, end] // 將要插入的區間存入變數\n→ For each Interval in Intervals // 逐一遍歷已排序的區間\n    → Decision: Interval.end < NewInterval.start? // 檢查目前區間是否完全在新區間左側\n        Yes → Result ← Result + [Interval] // 若完全在左側，直接加入結果\n        No  → Decision: Interval.start > NewInterval.end? // 檢查目前區間是否完全在新區間右側\n            Yes → Result ← Result + [NewInterval] // 若完全在右側，先加入新區間\n                 → Result ← Result + [Interval] + RemainingIntervals // 再加入此區間及其後續區間\n                 → GoTo End // 完成，直接結束\n            No  → // 兩區間重疊，需要合併\n                NewInterval.start ← min(Interval.start, NewInterval.start) // 更新合併後的起始點\n                NewInterval.end   ← max(Interval.end, NewInterval.end)   // 更新合併後的結束點\n                // 不立即加入結果，繼續遍歷其他區間以合併更多重疊區間\n→ Result ← Result + [NewInterval] // 迴圈結束後若仍未加入新區間，將其加入\nEnd // 程式執行結束，返回 Result\n\n(Note: 這裡的 \"GoTo End\" 用於示意在確定新區間已被加入且所有後續區間已添加後直接跳至結束。)"
    },
    {
      "title": "Substring with Concatenation of All Words",
      "source_file": "Leetcode/leetcode30.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnuf0uzy2.py\", line 74, in <module>\n    s, words = parse_input(input_line)\n               ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnuf0uzy2.py\", line 66, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"foo\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdrpveq3i.py\", line 74, in <module>\n    s, words = parse_input(input_line)\n               ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdrpveq3i.py\", line 66, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"word\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp20ahapku.py\", line 74, in <module>\n    s, words = parse_input(input_line)\n               ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp20ahapku.py\", line 66, in parse_input\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"bar\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findSubstring(self, s: str, words) -> list[int]:\n        if not words or not s:\n            return []\n        word_len = len(words[0])\n        word_count = len(words)\n        total_len = word_len * word_count\n        if len(s) < total_len:\n            return []\n\n        # Frequency map of required words\n        word_freq = Counter(words)\n        result = []\n\n        # Slide over each possible offset within the word length\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            current_freq = {}\n            matched = 0\n\n            while right + word_len <= len(s):\n                # Extract the next word\n                word = s[right:right + word_len]\n                right += word_len\n\n                # Update current window\n                if word in word_freq:\n                    current_freq[word] = current_freq.get(word, 0) + 1\n                    if current_freq[word] == word_freq[word]:\n                        matched += 1\n                    elif current_freq[word] == word_freq[word] + 1:\n                        matched -= 1\n                else:\n                    # Word not in list, reset window\n                    current_freq.clear()\n                    matched = 0\n                    left = right\n                    continue\n\n                # Shrink window if its length exceeds total_len\n                while matched == word_count and left + total_len <= right:\n                    result.append(left)\n                    left_word = s[left:left + word_len]\n                    left += word_len\n                    if left_word in word_freq:\n                        if current_freq[left_word] == word_freq[left_word]:\n                            matched -= 1\n                        current_freq[left_word] -= 1\n\n        return result\n\ndef parse_input(line: str):\n    \"\"\"Parse input line like: s = \"barfoo\", words = [\"foo\",\"bar\"]\"\"\"\n    parts = line.split(',')\n    data = {}\n    for part in parts:\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # Safely evaluate the value\n        data[key] = ast.literal_eval(val)\n    return data['s'], data['words']\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    input_line = sys.stdin.read().strip()\n    if not input_line:\n        sys.exit()\n    s, words = parse_input(input_line)\n    solution = Solution()\n    output = solution.findSubstring(s, words)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: find starting indices of substring in s that is concatenation of all words (permutation). Classic Leetcode problem 30. Approach: sliding window with hash map. Steps: compute word count map, word length, total length. For each offset 0..wordLen-1, run sliding window over s with step wordLen. Use counts, left, right, count matched. When window size > totalLen, shift left. Output indices. Provide pseudocode lines with explanations.\n\nWe must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows: Start, → Step, Decision: etc. Provide step-by-step.\n\nWe need to output step-by-step. Let's write pseudocode lines. We'll need variable definitions, loops, decisions.\n\nLet's produce lines:\n\nStart\n→ Define wordLen = length of words[0]\n→ Define wordCount = number of words\n→ Define totalLen = wordLen * wordCount\n→ Build hashmap wordFreq from words\n→ Initialize result list\n→ For offset from 0 to wordLen-1:\n    → Set left = offset, right = offset\n    → Initialize currentFreq empty, matched = 0\n    → While right + wordLen <= length of s:\n        → Extract word = s[right: right+wordLen]\n        → right += wordLen\n        → If word in wordFreq:\n            → Increment currentFreq[word]\n            → If currentFreq[word] == wordFreq[word]:\n                → matched += 1\n            → Else if currentFreq[word] == wordFreq[word] + 1:\n                → matched -= 1\n        → Else:\n            → Reset currentFreq empty, matched = 0\n            → left = right\n        → While matched == wordCount and left + totalLen <= right:\n            → Add left to result\n            → leftWord = s[left: left+wordLen]\n            → left += wordLen\n            → If leftWord in wordFreq:\n                → If currentFreq[leftWord] == wordFreq[leftWord]:\n                    → matched -= 1\n                → Decrement currentFreq[leftWord]\n        → End While\n    → End While\n→ End For\n→ Return result\nEnd\n\nBut need to use arrow style and Decision. Also ensure each line has explanation. Also may use nested indent but keep arrow. Provide Decision lines for conditions.\n\nLet's craft carefully. Use \"Decision:\" lines for if conditions.\n\nAlso we might use \"←\" but specification says use arrows (→, Yes →, No →). We can use \"Decision:\".\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: wordLen ← length(words[0]) // 每個單字長度\n→ Step 2: wordCount ← len(words) // 單字個數\n→ Step 3: totalLen ← wordLen * wordCount // 所有單字拼接後總長度\n→ Step 4: wordFreq ← hash map counting words // 每個單字出現次數\n→ Step 5: result ← empty list // 儲存符合條件的起始索引\n→ Decision: 如果 wordLen * wordCount > len(s)? // s 太短無法匹配\n    Yes → End // 結束，返回空結果\n    No  →\n→ Step 6: For offset in 0 .. wordLen-1: // 從每個位移開始滑動窗口\n    → Step 6.1: left ← offset, right ← offset // 窗口左右指標\n    → Step 6.2: currentFreq ← empty map // 當前窗口內單字頻率\n    → Step 6.3: matched ← 0 // 符合需求的單字數\n    → While right + wordLen <= len(s): // 仍有足夠字元可取\n        → Step 6.4: word ← s[right : right+wordLen] // 取得下一個單字\n        → right ← right + wordLen // 移動右指標\n        → Decision: 如果 word ∈ wordFreq? // 該字是否在給定單字集中\n            Yes →\n                → currentFreq[word] ← currentFreq.get(word,0)+1 // 更新頻率\n                → Decision: 如果 currentFreq[word] == wordFreq[word]? // 完全匹配一次\n                    Yes → matched ← matched + 1\n                    No →\n                        → Decision: 如果 currentFreq[word] == wordFreq[word]+1? // 超過一次\n                            Yes → matched ← matched - 1\n                            No →\n            No →\n                → currentFreq ← empty map // 清空窗口統計\n                → matched ← 0\n                → left ← right // 從下一個位置重新開始\n        → While matched == wordCount and left + totalLen <= right: // 窗口已滿\n            → Step 6.5: result.append(left) // 記錄起始位置\n            → leftWord ← s[left : left+wordLen] // 移除左邊單字\n            → left ← left + wordLen // 向右移動左指標\n            → Decision: 如果 leftWord ∈ wordFreq? // 是否為有效單字\n                Yes →\n                    → Decision: 如果 currentFreq[leftWord] == wordFreq[leftWord]? // 正好等於需求\n                        Yes → matched ← matched - 1\n                        No →\n                    → currentFreq[leftWord] ← currentFreq[leftWord] - 1 // 減少頻率\n                No →\n        → End While\n    → End While\n→ End For\n→ Step 7: Return result // 回傳所有起始索引\nEnd // 程式結束\n\nMake sure each line has explanation comment.\n\nWe must not output any actual code, just virtual steps.\n\nThus final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: wordLen ← length(words[0]) // 每個單字長度\n→ Step 2: wordCount ← len(words) // 單字個數\n→ Step 3: totalLen ← wordLen * wordCount // 所有單字拼接後總長度\n→ Step 4: wordFreq ← hash map counting words // 每個單字出現次數\n→ Step 5: result ← empty list // 儲存符合條件的起始索引\n→ Decision: 如果 wordLen * wordCount > len(s)? // s 太短無法匹配\n    Yes → End // 結束，返回空結果\n    No  →\n→ Step 6: For offset in 0 .. wordLen-1: // 從每個位移開始滑動窗口\n    → Step 6.1: left ← offset, right ← offset // 窗口左右指標\n    → Step 6.2: currentFreq ← empty map // 當前窗口內單字頻率\n    → Step 6.3: matched ← 0 // 符合需求的單字數\n    → While right + wordLen <= len(s): // 仍有足夠字元可取\n        → Step 6.4: word ← s[right : right+wordLen] // 取得下一個單字\n        → right ← right + wordLen // 移動右指標\n        → Decision: 如果 word ∈ wordFreq? // 該字是否在給定單字集中\n            Yes →\n                → currentFreq[word] ← currentFreq.get(word,0)+1 // 更新頻率\n                → Decision: 如果 currentFreq[word] == wordFreq[word]? // 完全匹配一次\n                    Yes → matched ← matched + 1\n                    No →\n                        → Decision: 如果 currentFreq[word] == wordFreq[word]+1? // 超過一次\n                            Yes → matched ← matched - 1\n                            No →\n            No →\n                → currentFreq ← empty map // 清空窗口統計\n                → matched ← 0\n                → left ← right // 從下一個位置重新開始\n        → While matched == wordCount and left + totalLen <= right: // 窗口已滿\n            → Step 6.5: result.append(left) // 記錄起始位置\n            → leftWord ← s[left : left+wordLen] // 移除左邊單字\n            → left ← left + wordLen // 向右移動左指標\n            → Decision: 如果 leftWord ∈ wordFreq? // 是否為有效單字\n                Yes →\n                    → Decision: 如果 currentFreq[leftWord] == wordFreq[leftWord]? // 正好等於需求\n                        Yes → matched ← matched - 1\n                        No →\n                    → currentFreq[leftWord] ← currentFreq[leftWord] - 1 // 減少頻率\n                No →\n        → End While\n    → End While\n→ End For\n→ Step 7: Return result // 回傳所有起始索引\nEnd // 程式結束\n```"
    },
    {
      "title": "Optimal Division",
      "source_file": "Leetcode/leetcode553.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[1000,100,10,2]",
          "expected_output": "\"1000/(100/10/2)\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1000/(100/10/2)'\nGot (Norm):      '1000/(100/(10/2))'\n--- (Raw) ---\nRaw Expected: '\"1000/(100/10/2)\"'\nRaw Got:      '\"1000/(100/(10/2))\"'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef combine(left: str, right: str) -> str:\n    \"\"\"將左右子表達式組合成分式字串，必要時加入括號。\"\"\"\n    if '/' in left:\n        left = f'({left})'\n    if '/' in right:\n        right = f'({right})'\n    return f'{left}/{right}'\n\ndef optimal_division(nums):\n    n = len(nums)\n    if n == 0:\n        return \"\"\n    if n == 1:\n        return str(nums[0])\n    if n == 2:\n        return f'{nums[0]}/{nums[1]}'\n\n    # DP 表格\n    dp_max = [[0.0] * n for _ in range(n)]\n    dp_min = [[0.0] * n for _ in range(n)]\n    expr = [[\"\" for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n        dp_max[i][i] = dp_min[i][i] = nums[i]\n        expr[i][i] = str(nums[i])\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            max_val = float('-inf')\n            min_val = float('inf')\n            best_max_expr = \"\"\n            best_min_expr = \"\"\n\n            for k in range(i, j):\n                num_max = dp_max[i][k]\n                num_min = dp_min[i][k]\n                den_max = dp_max[k + 1][j]\n                den_min = dp_min[k + 1][j]\n\n                # 最大值: numerator 最大 / denominator 最小\n                val_max = num_max / den_min\n                expr_max = combine(expr[i][k], expr[k + 1][j])\n                if val_max > max_val:\n                    max_val = val_max\n                    best_max_expr = expr_max\n\n                # 最小值: numerator 最小 / denominator 最大\n                val_min = num_min / den_max\n                expr_min = combine(expr[i][k], expr[k + 1][j])\n                if val_min < min_val:\n                    min_val = val_min\n                    best_min_expr = expr_min\n\n            dp_max[i][j] = max_val\n            dp_min[i][j] = min_val\n            expr[i][j] = best_max_expr\n\n    return expr[0][n - 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = ast.literal_eval(data)\n    result = optimal_division(nums)\n    # 將結果字串加上外層雙引號輸出\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode algorithm to solve: Given array nums, need to insert parentheses to maximize value of expression of sequential division. This is classic DP problem: for each subarray [i,j], compute best value (max) and corresponding expression string with minimal parentheses. Need to consider operations of division which is not associative: a/(b/c)=a*(c/b) etc. DP: DPmax[i][j] = max over k split: DPmax[i][k] / DPmin[k+1][j] (since for division, we need maximize numerator/denominator; to maximize, we want maximize numerator and minimize denominator). Also compute DPmin for subexpressions. Also track expression string. Remove redundant parentheses: only add parentheses when needed, e.g., if subexpression not single number.\n\nImplementation details: Use recursion or DP. Keep track of string without unnecessary parentheses: if subexpression is a single number, no parentheses; else if we need to enclose due to being part of division, we may need parentheses.\n\nAlgorithm:\n- Initialize DPmax[i][i] = DPmin[i][i] = nums[i]; exprMax[i][i] = exprMin[i][i] = str(nums[i]).\n- For len from 2 to n:\n  For i from 0 to n-len:\n    j = i+len-1\n    maxVal = -inf, minVal = +inf\n    bestExprMax, bestExprMin\n    For k from i to j-1:\n      numMax = DPmax[i][k]\n      numMin = DPmin[i][k]\n      denMax = DPmax[k+1][j]\n      denMin = DPmin[k+1][j]\n      val1 = numMax / denMin  // maximize\n      expr1 = combine(exprMax[i][k], exprMin[k+1][j])\n      if val1 > maxVal: update\n      // for min\n      val2 = numMin / denMax\n      expr2 = combine(exprMin[i][k], exprMax[k+1][j])\n      if val2 < minVal: update\n- Finally return exprMax[0][n-1].\n\nCombine: if subexpression length >1, wrap parentheses; else no parentheses.\n\nEdge: use float division; numbers positive? assume positive integers.\n\nWe produce pseudocode with lines. Must use Start, End, Decision, etc. Provide explanation comment after each line.\n\nWe'll output step-by-step. Use arrows.\n\nLet's write.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums, 設定 n = nums.length // 取得陣列長度\n→ Step 2: 建立三個 n×n 表格：DPmax, DPmin, Expr // 儲存子問題的最大值、最小值及其對應字串\n\n→ Decision: 是否為單一元素子陣列? // 初始化 1 元素子陣列\n    Yes → For i in 0..n-1:\n        → Step 3: DPmax[i][i] = DPmin[i][i] = nums[i] // 單元素的值即為自身\n        → Step 4: Expr[i][i] = str(nums[i]) // 字串為該數字本身\n    No  → // 這裡不執行\n\n→ Step 5: 對子陣列長度 len 從 2 到 n 進行迭代 // 逐層構造長度較大的子問題\n    → Decision: 是否需要計算長度為 len 的子陣列? // 內層循環條件\n        Yes → For i in 0..n-len:\n            → Step 6: j = i + len - 1 // 計算子陣列結束索引\n            → Step 7: maxVal = -∞, minVal = +∞ // 初始化極值\n            → Step 8: bestExprMax = \"\", bestExprMin = \"\" // 儲存最佳字串\n\n            → Decision: 是否要分割子陣列? // 循環所有可能的分割點 k\n                Yes → For k in i..j-1:\n                    → Step 9: \n                        // 計算分割左右兩邊的最大/最小值\n                        → numMax = DPmax[i][k]\n                        → numMin = DPmin[i][k]\n                        → denMax = DPmax[k+1][j]\n                        → denMin = DPmin[k+1][j]\n\n                    → Step 10: \n                        // 為了最大化 a/(b/c) 的值，選取 numerator 最大、denominator 最小\n                        → valMax = numMax / denMin\n                        → exprMax = combine(Expr[i][k], Expr[k+1][j]) // 組合子表達式\n                        → Decision: 是否更新最大值? // 比較 valMax 與 current maxVal\n                            Yes → maxVal = valMax; bestExprMax = exprMax\n                            No  → // 不更新\n\n                    → Step 11: \n                        // 為了最小化值，選取 numerator 最小、denominator 最大\n                        → valMin = numMin / denMax\n                        → exprMin = combine(Expr[i][k], Expr[k+1][j])\n                        → Decision: 是否更新最小值? // 比較 valMin 與 current minVal\n                            Yes → minVal = valMin; bestExprMin = exprMin\n                            No  → // 不更新\n                No → // 無分割點時結束內層迴圈\n\n            → Step 12: \n                // 將計算得到的最大值、最小值及其字串存回表格\n                → DPmax[i][j] = maxVal\n                → DPmin[i][j] = minVal\n                → Expr[i][j] = bestExprMax\n        No → // 完成所有子陣列長度的處理\n\n→ Step 13: 回傳 Expr[0][n-1] // 最終得到全陣列的最大值對應字串\nEnd // 程式執行結束\n```\n\n**combine( left, right ) 定義**（在 Step 10 和 Step 11 使用）:\n```\n→ Step 0: combine(left, right):\n    → Decision: left 需要括號嗎? // 只在 left 不是單一數字時加括號\n        Yes → left = '(' + left + ')'\n        No  → // 無改動\n    → Decision: right 需要括號嗎? // 同理\n        Yes → right = '(' + right + ')'\n        No  → // 無改動\n    → Return left + '/' + right // 產生分式字串\n```\n\n*此虛擬碼以動態規劃方式計算所有子陣列的最大最小值，並在每一步結合子表達式，最終輸出能獲得最大計算結果且不含冗餘括號的表達式。*"
    },
    {
      "title": "Strange Printer",
      "source_file": "Leetcode/leetcode664.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strangePrinter(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n\n        # dp[i][j] 表示子字串 s[i:j+1] 的最少列印次數\n        dp = [[0] * n for _ in range(n)]\n\n        # 單個字元只需一次列印\n        for i in range(n):\n            dp[i][i] = 1\n\n        # 計算長度從 2 到 n 的子字串\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                # 初始假設先列印 s[i]，再列印 s[i+1:j+1]\n                dp[i][j] = 1 + dp[i + 1][j]\n\n                # 若 s[i] 與 s[k] 相同，可以在同一次列印中完成\n                for k in range(i + 1, j + 1):\n                    if s[k] == s[i]:\n                        left = dp[i + 1][k - 1] if k - 1 >= i + 1 else 0\n                        right = dp[k][j]\n                        dp[i][j] = min(dp[i][j], left + right)\n\n        return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，去除非字母字符\n    raw_input = sys.stdin.read()\n    # 只保留字母字符，這樣能處理如 's = \"aaabbb\"' 這種格式\n    s = re.sub(r'[^a-zA-Z]', '', raw_input)\n    solution = Solution()\n    result = solution.strangePrinter(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving strange printer problem. It's typical DP: dp[l][r] minimal turns to print substring s[l..r]. Recurrence: dp[l][r] = dp[l+1][r] + 1 initially. For any k in [l+1,r] where s[k]==s[l], dp[l][r] = min(dp[l][r], dp[l+1][k-1] + dp[k][r]) Because we can print s[l] along with s[k] in same turn.\n\nEdge: base case dp[i][i] = 1.\n\nReturn dp[0][n-1].\n\nWe produce virtual code step by step. Include start, input, DP initialization, loops, recurrence, output. Use arrows. Provide explanation after each line. Ensure no actual code. Use \"Start\", \"End\". Use \"Decision:\" where needed? For loops we can just list. Use indentation? We can mimic structure.\n\nLet's produce lines: \n\nStart\n→ Step 1: 讀取字串 s // 將輸入字串讀進變數\n→ Step 2: 設定 n = s.length // 取得字串長度\n→ Decision: 如果 n == 0? // 空字串特例\n    Yes → Step 3: 輸出 0 // 無需列印\n    No → \n→ Step 4: 建立 dp 二維表 n×n 並初始化為 0 // 用來儲存子問題結果\n→ Step 5: 依序處理子字串長度 len 從 1 到 n // 主迴圈\n    → Step 6: 對於每個起點 l 從 0 到 n-len\n        → Step 7: 計算終點 r = l + len - 1 // 子字串結束位置\n        → Decision: 如果 len == 1? // 單字元子字串\n            Yes → Step 8: 設定 dp[l][r] = 1 // 一個字元只需一次\n            No →\n        → Step 9: 設定 dp[l][r] = dp[l+1][r] + 1 // 先假設先列印 s[l] 再列印其餘\n        → Step 10: 對於每個 k 從 l+1 到 r\n            → Decision: 如果 s[k] == s[l]? // 能否把 s[l] 與 s[k] 同時列印\n                Yes → Step 11: 計算左側成本 left = (k-1 >= l+1) ? dp[l+1][k-1] : 0 // 列印中間部分\n                → Step 12: 計算右側成本 right = dp[k][r] // 列印從 k 到 r 的部分\n                → Step 13: 計算候選成本 cand = left + right // 合併兩部分\n                → Step 14: 更新 dp[l][r] = min(dp[l][r], cand) // 取最小\n        → Step 15: 完成 dp[l][r] 的計算\n→ Step 16: 最終結果 = dp[0][n-1] // 完整字串所需列印次數\n→ Step 17: 輸出 最終結果\nEnd\n\nNeed to ensure each line follows pattern `虛擬碼步驟 // 解釋`. Use arrow `→`. For indentation, we can just indent lines.\n\nAlso need to use `Decision:` lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s // 將輸入字串讀進變數  \n→ Step 2: 設定 n = s.length // 取得字串長度  \n→ Decision: 如果 n == 0? // 空字串特例  \n    Yes → Step 3: 輸出 0 // 無需列印  \n    No →  \n→ Step 4: 建立 dp 二維表 n×n 並初始化為 0 // 用來儲存子問題結果  \n→ Step 5: 依序處理子字串長度 len 從 1 到 n // 主迴圈  \n    → Step 6: 對於每個起點 l 從 0 到 n-len  \n        → Step 7: 計算終點 r = l + len - 1 // 子字串結束位置  \n        → Decision: 如果 len == 1? // 單字元子字串  \n            Yes → Step 8: 設定 dp[l][r] = 1 // 一個字元只需一次  \n            No →  \n        → Step 9: 設定 dp[l][r] = dp[l+1][r] + 1 // 先假設先列印 s[l] 再列印其餘  \n        → Step 10: 對於每個 k 從 l+1 到 r  \n            → Decision: 如果 s[k] == s[l]? // 能否把 s[l] 與 s[k] 同時列印  \n                Yes → Step 11: 計算左側成本 left = (k-1 >= l+1) ? dp[l+1][k-1] : 0 // 列印中間部分  \n                → Step 12: 計算右側成本 right = dp[k][r] // 列印從 k 到 r 的部分  \n                → Step 13: 計算候選成本 cand = left + right // 合併兩部分  \n                → Step 14: 更新 dp[l][r] = min(dp[l][r], cand) // 取最小  \n        → Step 15: 完成 dp[l][r] 的計算  \n→ Step 16: 最終結果 = dp[0][n-1] // 完整字串所需列印次數  \n→ Step 17: 輸出 最終結果 // 結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef parse_args(arg_str: str):\n    \"\"\"Parse comma separated integers from a string like '10, 20'.\"\"\"\n    return [int(x.strip()) for x in arg_str.split(',') if x.strip()]\n\ndef main():\n    lines = [line.strip() for line in sys.stdin.read().strip().splitlines() if line.strip()]\n    outputs = []\n    module = None\n\n    for line in lines:\n        if line.startswith('RangeModule'):\n            # Initialise the module\n            module = RangeModule()\n            outputs.append('null')\n            continue\n\n        # Remove trailing semicolon\n        if line.endswith(';'):\n            line = line[:-1].strip()\n\n        # Expect format: rangeModule.methodName(args)\n        if not line.startswith('rangeModule.'):\n            continue  # skip unknown lines\n\n        # Extract method and args\n        part = line[len('rangeModule.'):].strip()\n        if '(' not in part or not part.endswith(')'):\n            continue  # malformed\n        method_name, args_part = part.split('(', 1)\n        args_part = args_part[:-1]  # remove closing ')'\n        args = parse_args(args_part)\n\n        if method_name == 'addRange':\n            module.addRange(*args)\n            outputs.append('null')\n        elif method_name == 'removeRange':\n            module.removeRange(*args)\n            outputs.append('null')\n        elif method_name == 'queryRange':\n            result = module.queryRange(*args)\n            outputs.append('true' if result else 'false')\n        else:\n            continue  # unknown method\n\n    # Print outputs as a list\n    print('[' + ', '.join(outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for design of RangeModule data structure, with addRange, queryRange, removeRange. Provide step-by-step algorithm logic. Probably using ordered set of intervals merging. So algorithm:\n\nStart.\n\nData structure: maintain list of disjoint, sorted intervals.\n\nImplement addRange: merge overlapping intervals, insert new.\n\nImplement queryRange: check coverage by iterating intervals.\n\nImplement removeRange: split intervals.\n\nNeed to show virtual code steps, not actual code. So each line with virtual code step, explanation. Use arrows. Provide steps like Start, Step 1: initialize intervals list. Then for addRange: Step 1: find position to insert left; Step 2: merge overlaps; etc.\n\nWe'll output as per format. Use virtual code arrow style.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的有序區間列表 intervals // 用來存放所有已追蹤且互不重疊的區間  \n→ End // 初始化完成  \n\nStart // addRange 方法執行  \n→ Step 1: 進入 addRange(left, right) // 取得要加入的區間  \n→ Decision: intervals 是否為空?  \n    Yes → Step 2a: 將 [left, right) 直接加入 intervals // 空列表時直接存入  \n    No  → Step 2b: 找到第一個 intervals[i] 使 intervals[i].right ≥ left // 找到可能重疊的起始位置  \n→ Step 3: 設定 newLeft = left, newRight = right  \n→ Step 4: 從 i 開始向後掃描所有 intervals[j] 直到 intervals[j].left > right  \n  Decision: intervals[j] 與 [newLeft, newRight) 是否重疊?  \n   Yes → Step 4a: newLeft = min(newLeft, intervals[j].left)  \n     newRight = max(newRight, intervals[j].right)  \n     刪除 intervals[j] // 合併後不再保留舊區間  \n     j-- // 退回一步以便重新檢查刪除後的位置  \n   No  → Step 4b: j++ // 無重疊則繼續下一個  \n→ Step 5: 在合適的位置插入合併後的區間 [newLeft, newRight) 到 intervals // 保持有序  \n→ End // addRange 完成  \n\nStart // queryRange 方法執行  \n→ Step 1: 進入 queryRange(left, right)  \n→ Decision: intervals 是否為空?  \n  Yes → Step 2a: 回傳 False // 沒有任何區間  \n  No  → Step 2b: 找到第一個 intervals[i] 使 intervals[i].right > left // 可能覆蓋起點  \n→ Decision: intervals[i].left ≤ left AND intervals[i].right ≥ right?  \n  Yes → Step 3a: 回傳 True // 一個區間已完全覆蓋 [left, right)  \n  No  → Step 3b: 需要進一步檢查  \n   Decision: intervals[i].right < right?  \n    Yes → Step 4a: 設 newStart = intervals[i].right // 取下一個起點  \n     i++  \n     決定是否繼續檢查直到 intervals[i].right ≥ right  \n     若在任何一步 intervals[i].left > newStart 或 intervals[i].right < right → 回傳 False  \n     否則回傳 True  \n→ End // queryRange 完成  \n\nStart // removeRange 方法執行  \n→ Step 1: 進入 removeRange(left, right)  \n→ Decision: intervals 是否為空?  \n  Yes → Step 2a: 完成 // 無區間可移除  \n  No  → Step 2b: 找到第一個 intervals[i] 使 intervals[i].right > left // 可能被切割的起點  \n→ Step 3: 從 i 開始向後掃描所有 intervals[j] 直到 intervals[j].left ≥ right  \n  Decision: intervals[j] 與 [left, right) 是否重疊?  \n   Yes → Step 3a:  \n    如果 intervals[j].left < left:  \n     新增區間 [intervals[j].left, left) // 保留左半部分  \n     如果 intervals[j].right > right:  \n     新增區間 [right, intervals[j].right) // 保留右半部分  \n     刪除 intervals[j] // 原區間被移除  \n     j-- // 退回一步重新評估下一個位置  \n   No  → Step 3b: j++ // 無重疊則繼續  \n→ End // removeRange 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5frit34n.py\", line 63, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.capacity = k\n        self.buf = [0] * k\n        self.head = 0      # index of the front element\n        self.size = 0      # current number of elements\n\n    def insertFront(self, value: int) -> bool:\n        if self.size == self.capacity:\n            return False\n        self.head = (self.head - 1 + self.capacity) % self.capacity\n        self.buf[self.head] = value\n        self.size += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.size == self.capacity:\n            return False\n        idx = (self.head + self.size) % self.capacity\n        self.buf[idx] = value\n        self.size += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.size == 0:\n            return False\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.size == 0:\n            return False\n        self.size -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.size == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.size == 0:\n            return -1\n        idx = (self.head + self.size - 1) % self.capacity\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.size == 0\n\n    def isFull(self) -> bool:\n        return self.size == self.capacity\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    instance = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularDeque\":\n            instance = MyCircularDeque(*args)\n            results.append(None)\n        else:\n            method = getattr(instance, op)\n            result = method(*args)\n            results.append(result)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The class and its methods. Provide steps for initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. We should use Start, End, Decision, etc. For each method, we might show method definition and logic. Each line: \"虛擬碼步驟 // 解釋\". Use arrow, Decision. For methods, we can use \"→ Method: MyCircularDeque(k) // 初始化\". Then use Decision for full/empty checks. Let's produce a stepwise algorithm.\n\nWe need to output only virtual code lines with explanation. No actual code. Just steps. Use Chinese. Use Start and End.\n\nLet's craft:\n\nStart\n→ Initialize: create array of size k, set head=0, tail=0, size=0\n→ Method MyCircularDeque(k): // constructor\n...\n\nMaybe better: Each method as separate block: e.g.,\n\n→ Method insertFront(value): // insert at front\n    Decision: 如果 size==k? // 判斷是否已滿\n        Yes → Return false // 若已滿，返回失敗\n        No  → head = (head - 1 + k) % k // 更新 head 指標\n              array[head] = value\n              size++\n              Return true\n\nSimilarly for others.\n\nWe'll produce line by line. Ensure each line includes arrow or no arrow. Use \"→\" for steps, \"Decision:\" for decisions. Use \"End\" at end of each method or after all methods. The output must be structured lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize: 建立長度為 k 的陣列，設定 head = 0, tail = 0, size = 0 // 初始化雙端佇列結構  \n\n// ---------- MyCircularDeque 建構子 ----------\n→ Method: MyCircularDeque(k) // 建構子，設定最大容量  \n    → Set capacity = k  \n    → 建立陣列 elements[capacity]  \n    → head = 0  \n    → tail = 0  \n    → size = 0  \n    → End Method  \n\n// ---------- insertFront ----------\n→ Method: insertFront(value) // 在前端插入元素  \n    → Decision: 如果 size == capacity? // 判斷佇列是否已滿  \n        Yes → Return false // 已滿，操作失敗  \n        No  → head = (head - 1 + capacity) % capacity // 更新 head 指標  \n              elements[head] = value // 放入值  \n              size++ // 大小加一  \n              Return true // 插入成功  \n    → End Method  \n\n// ---------- insertLast ----------\n→ Method: insertLast(value) // 在後端插入元素  \n    → Decision: 如果 size == capacity? // 判斷佇列是否已滿  \n        Yes → Return false // 已滿，操作失敗  \n        No  → elements[tail] = value // 放入值  \n              tail = (tail + 1) % capacity // 更新 tail 指標  \n              size++ // 大小加一  \n              Return true // 插入成功  \n    → End Method  \n\n// ---------- deleteFront ----------\n→ Method: deleteFront() // 從前端刪除元素  \n    → Decision: 如果 size == 0? // 判斷佇列是否為空  \n        Yes → Return false // 空，刪除失敗  \n        No  → head = (head + 1) % capacity // 移動 head 指標  \n              size-- // 大小減一  \n              Return true // 刪除成功  \n    → End Method  \n\n// ---------- deleteLast ----------\n→ Method: deleteLast() // 從後端刪除元素  \n    → Decision: 如果 size == 0? // 判斷佇列是否為空  \n        Yes → Return false // 空，刪除失敗  \n        No  → tail = (tail - 1 + capacity) % capacity // 移動 tail 指標  \n              size-- // 大小減一  \n              Return true // 刪除成功  \n    → End Method  \n\n// ---------- getFront ----------\n→ Method: getFront() // 取得前端元素  \n    → Decision: 如果 size == 0? // 判斷佇列是否為空  \n        Yes → Return -1 // 空，返回 -1  \n        No  → Return elements[head] // 返回前端值  \n    → End Method  \n\n// ---------- getRear ----------\n→ Method: getRear() // 取得後端元素  \n    → Decision: 如果 size == 0? // 判斷佇列是否為空  \n        Yes → Return -1 // 空，返回 -1  \n        No  → index = (tail - 1 + capacity) % capacity // 計算後端索引  \n              Return elements[index] // 返回後端值  \n    → End Method  \n\n// ---------- isEmpty ----------\n→ Method: isEmpty() // 判斷佇列是否為空  \n    → Return size == 0 // 若 size 為 0，則為空  \n    → End Method  \n\n// ---------- isFull ----------\n→ Method: isFull() // 判斷佇列是否已滿  \n    → Return size == capacity // 若 size 等於容量，則已滿  \n    → End Method  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6z0rym3k.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmp6z0rym3k.py\", line 47, in main\n    result = multiply_complex(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6z0rym3k.py\", line 25, in multiply_complex\n    a_real, a_imag = parse_complex(a)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6z0rym3k.py\", line 16, in parse_complex\n    imag_part = int(s[sep_pos:])\n                ^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\n\ndef parse_complex(s: str):\n    \"\"\"\n    將形如 'a+bi' 或 'a-bi' 的字串轉成兩個整數 (real, imag)。\n    1. 移除末尾的 'i'。\n    2. 找到第一個位於索引 1 之後的 '+' 或 '-'，這是實部與虛部的分隔符。\n    3. 解析兩個子字串為整數。\n    \"\"\"\n    s = s.strip()\n    if s.endswith('i'):\n        s = s[:-1]\n    # 找分隔符的位置（第一個位於索引 1 之後的 + 或 -）\n    sep_pos = next(i for i, ch in enumerate(s[1:], 1) if ch in '+-')\n    real_part = int(s[:sep_pos])\n    imag_part = int(s[sep_pos:])\n    return real_part, imag_part\n\ndef multiply_complex(a: str, b: str) -> str:\n    \"\"\"\n    乘法公式：\n    (a_re + a_im i) * (b_re + b_im i) =\n        (a_re*b_re - a_im*b_im) + (a_re*b_im + a_im*b_re) i\n    \"\"\"\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n    real_res = a_real * b_real - a_imag * b_imag\n    imag_res = a_real * b_imag + a_imag * b_real\n    return f\"{real_res}+{imag_res}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 讀取兩個複數字串，假設格式為 '\"num1\", \"num2\"'\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) >= 2:\n        num1 = parts[0].strip('\"').strip(\"'\")\n        num2 = parts[1].strip('\"').strip(\"'\")\n    else:\n        # 如果沒有逗號分隔，嘗試用空白分隔\n        parts = data.split()\n        num1 = parts[0].strip('\"').strip(\"'\")\n        num2 = parts[1].strip('\"').strip(\"'\")\n\n    result = multiply_complex(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for multiplying two complex numbers represented as strings like \"a+bi\" where a,b integers between -100,100. Need parse, multiply, format. Provide step-by-step pseudocode. Follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Provide Start, End, Decision. Ensure no actual code.\n\nLet's design:\n\nStart\n→ Step: Input num1, num2 // get strings\n→ Step: Parse real1, imag1 from num1 // extract integers\n→ Step: Parse real2, imag2 from num2\n→ Step: Compute real_part = real1*real2 - imag1*imag2 // formula\n→ Step: Compute imag_part = real1*imag2 + imag1*real2\n→ Step: Format result = real_part + \"+\" + imag_part + \"i\"\n→ Step: Return result\nEnd\n\nBut also need parse algorithm. Use Decision to detect sign? Since format always a+bi, maybe negative imaginary part will be like \"3-4i\"? Actually \"real+imaginaryi\" but imaginary part could be negative. The representation might be \"3-4i\"? Not sure but typical. We'll assume input always uses '+' between real and imaginary, and imaginary part may start with '-'? Might be \"3-4i\" or \"3+-4i\"? Let's include parsing step that handles both.\n\nWe can show Decision: If second char after real contains '+' or '-'? But virtual code can just parse substring up to 'i'. Use Decision: Check if string contains '-' after real? But we can mention we split at last '+' or '-'.\n\nWe'll produce pseudocode:\n\n→ Step: Find index of 'i' // locate imaginary unit\n→ Step: Extract imaginary_str = substring up to index of 'i'\n→ Step: Find separator position = last index of '+' or '-' in imaginary_str after first character\n→ Decision: If separator found: real_str = substring(0, separator), imag_str = substring(separator)\n   else: // no separator, means imaginary part only\n→ Step: Convert real_str to integer // real part\n→ Step: Convert imag_str to integer // imaginary part\n\nOk.\n\nAlso need to handle negative real numbers: first char may be '-'.\n\nImplement parse.\n\nLet's output. Ensure each line has format. Use \"→\" arrows.\n\nWe'll need multiple lines for parsing steps. Let's produce like:\n\nStart // 程式開始執行\n→ Step: Input num1, num2 // 取得兩個複數字串\n→ Step: Parse num1 into real1, imag1 // 解析第一個複數\n    → Step: Find index of 'i' in num1 // 找到 i 的位置\n    → Step: Extract imag_part_str = substring up to 'i' // 取得實際 i 前的子字串\n    → Step: Find separator_pos = last index of '+' or '-' after first char // 分隔實部與虛部的位置\n    → Decision: separator_pos != -1? // 判斷是否找到分隔符\n        Yes → Step: real1_str = substring(0, separator_pos) // 實部字串\n        Yes → Step: imag1_str = substring(separator_pos) // 虛部字串\n        No  → Step: real1_str = \"\" // 無實部，默認 0\n        No  → Step: imag1_str = imag_part_str // 全部為虛部\n    → Step: real1 = Integer.parseInt(real1_str) // 轉成整數\n    → Step: imag1 = Integer.parseInt(imag1_str) // 轉成整數\n→ Step: Parse num2 into real2, imag2 // 解析第二個複數\n    ... same as above for num2\n→ Step: Compute real_res = real1 * real2 - imag1 * imag2 // 乘法實部\n→ Step: Compute imag_res = real1 * imag2 + imag1 * real2 // 乘法虛部\n→ Step: Format result_str = real_res + \"+\" + imag_res + \"i\" // 組合結果字串\n→ Step: Return result_str // 回傳最終字串\nEnd // 程式執行結束\n\nBut ensure each line with \"虛擬碼步驟 // 解釋\". Use indentation for nested steps but still each line separate. We'll number? Not needed.\n\nBut we must avoid actual code syntax. Use generic. Provide explanation.\n\nAlso we should mention decision for negative imaginary part: use last '+' or '-' after index 1.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Input num1, num2 // 取得兩個複數字串  \n→ Step: Parse num1 into real1, imag1 // 解析第一個複數  \n    → Step: Find index of 'i' in num1 // 找到 i 的位置  \n    → Step: Extract imag_part_str = substring of num1 up to 'i' // 取得 i 前的子字串，包含虛部符號  \n    → Step: Find separator_pos = last index of '+' or '-' after first character in imag_part_str // 分隔實部與虛部的位置  \n    → Decision: separator_pos != -1? // 判斷是否找到分隔符  \n        Yes → Step: real1_str = substring of imag_part_str from start to separator_pos // 實部字串  \n        Yes → Step: imag1_str = substring of imag_part_str from separator_pos to end // 虛部字串  \n        No  → Step: real1_str = \"\" // 無實部，默認為 0  \n        No  → Step: imag1_str = imag_part_str // 全部為虛部  \n    → Step: real1 = Convert real1_str to integer // 轉成整數  \n    → Step: imag1 = Convert imag1_str to integer // 轉成整數  \n→ Step: Parse num2 into real2, imag2 // 解析第二個複數  \n    → Step: Find index of 'i' in num2  \n    → Step: Extract imag_part_str = substring of num2 up to 'i'  \n    → Step: Find separator_pos = last index of '+' or '-' after first character in imag_part_str  \n    → Decision: separator_pos != -1?  \n        Yes → Step: real2_str = substring of imag_part_str from start to separator_pos  \n        Yes → Step: imag2_str = substring of imag_part_str from separator_pos to end  \n        No  → Step: real2_str = \"\"  \n        No  → Step: imag2_str = imag_part_str  \n    → Step: real2 = Convert real2_str to integer  \n    → Step: imag2 = Convert imag2_str to integer  \n→ Step: Compute real_res = real1 * real2 - imag1 * imag2 // 乘法實部公式  \n→ Step: Compute imag_res = real1 * imag2 + imag1 * real2 // 乘法虛部公式  \n→ Step: Format result_str = real_res + \"+\" + imag_res + \"i\" // 組合最終字串  \n→ Step: Return result_str // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\", \"root/4.txt\"]]'"
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      '[[\"root/a/1.txt\", \"root/c/3.txt\"], [\"root/a/2.txt\", \"root/c/d/4.txt\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"找出檔案內容相同的重複檔案，回傳其完整路徑群組。\"\"\"\n        content_map = defaultdict(list)\n\n        # 逐行解析每個目錄資訊字串\n        for path in paths:\n            parts = path.split()\n            root = parts[0]                     # 目錄路徑\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')   # 拆分檔名與內容\n                content = content.rstrip(')')           # 去除右括號\n                full_path = f\"{root}/{name}\"           # 組成完整檔案路徑\n                content_map[content].append(full_path) # 將路徑加入對應內容的清單\n\n        # 只保留重複的群組\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 允許輸入形如 \"paths = [...]\" 或直接是列表字串\n    if raw_input.lower().startswith(\"paths\"):\n        _, raw_input = raw_input.split(\"=\", 1)\n    raw_input = raw_input.strip()\n    # 使用 ast.literal_eval 解析為 Python 列表\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗則直接使用空列表\n        paths = []\n\n    # 執行求重複檔案\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n\n    # 輸出 JSON 格式，符合範例需求\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. It's like LeetCode problem 609: Find Duplicate File in System. Steps: iterate over each directory string, parse directory and files, create map content->list of paths, then collect groups with size>1. Virtual code line-by-line. Use Start, End, Decision, etc. Provide brief explanation each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 map contentToPaths: 空字典 // 用來儲存相同內容對應的所有檔案路徑\n→ Step 2: 針對每個 dirInfo in paths 執行 // 逐個處理輸入的目錄資訊\n    → Decision: 將 dirInfo 以空格拆分為 tokens // 以空格切割，第一個為目錄路徑，後面為檔案資訊\n        Yes → Step 3: dirPath = tokens[0] // 取得目錄路徑\n        Yes → Step 4: 針對 tokens[1:] 逐個處理 // 逐個檔案\n            → Decision: 取得檔名與內容 // 以 '(' 與 ')' 分隔\n                Yes → Step 5: fileName = partBefore '(' // 檔名\n                Yes → Step 6: fileContent = partBetween '(' 與 ')' // 檔案內容\n                Yes → Step 7: fullPath = dirPath + '/' + fileName // 組成完整檔案路徑\n                Yes → Step 8: contentToPaths[fileContent].append(fullPath) // 加入對應內容的路徑清單\n→ Step 9: 建立結果列表 groups = [] // 用來儲存所有重複檔案的組\n→ Decision: contentToPaths 內每個 content, pathsList\n    Yes → Decision: pathsList 長度 >= 2? // 是否至少兩個檔案相同\n        Yes → Step 10: groups.append(pathsList) // 加入重複組\n→ End // 程式執行結束，回傳 groups 以符合題目需求"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[4]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[4]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[10,4]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[10, 4]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[2,1,7]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[2, 1, 7]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport re\n\ndef rand7():\n    \"\"\"模擬 rand7()，回傳 1~7 的均勻隨機整數。\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        使用兩次 rand7() 生成 1~49 的均勻分佈，\n        並以 rejection sampling 過濾到 1~40，最後映射到 1~10。\n        \"\"\"\n        while True:\n            a = rand7()          # 第一次呼叫 rand7()\n            b = rand7()          # 第二次呼叫 rand7()\n            num = (a - 1) * 7 + b  # 轉換為 1~49\n            if num <= 40:        # 僅保留 1~40，確保均勻性\n                return 1 + (num - 1) % 10  # 映射到 1~10\n\ndef main():\n    \"\"\"\n    從標準輸入讀取一個整數 n，呼叫 rand10() n 次，\n    將結果以列表形式輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取第一個整數，假設格式為 \"n = 3\" 或 \"n=3\"\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for rand10() using only rand7(). Common solution: generate 49 uniform numbers using two rand7() calls to produce [1,49], reject >40 to get 40 uniform numbers, then mod 10. Or use 2 or 3 calls.\n\nWe'll produce virtual code line by line.\n\nWe must output each line with // explanation. Use Start, End, Decision. Use arrow arrow.\n\nLet's craft steps:\n\nStart\n→ Step 1: Loop forever // 將持續嘗試直到得到合法結果\n    → Step 2: Call rand7() → a // 第一個隨機數\n    → Step 3: Call rand7() → b // 第二個隨機數\n    → Step 4: Compute num = (a-1)*7 + b // 轉換為 1~49\n    → Decision: 是否 num <= 40? // 濾除超過 40 的值\n        Yes → Step 5: Return (num-1) % 10 + 1 // 生成 1~10\n        No  → Step 6: Loop back to Step 1 // 重新嘗試\n\nEnd\n\nBut we need to use virtual code syntax: \"Decision: ...\" etc. Use \"Yes →\" \"No →\". Use \"Start\" \"End\".\n\nAdd comments after each line.\n\nAlso we should not call built-in random, only rand7.\n\nAlso mention we can call rand7 multiple times.\n\nLet's output accordingly.\n\nMake sure each line includes \"虛擬碼步驟\" followed by space and comment.\n\nWe need to format: \"Start // 程式開始執行\" etc.\n\nLet's write.\n\nWe'll also optionally mention function definition: \"→ Step 0: Define rand10() // 定義函數\" maybe.\n\nWe need to gradually produce steps. Let's produce:\n\nStart\n→ Step 0: Define rand10() // 定義生成 1~10 的函數\n→ Step 1: Loop forever // 無限循環直到成功產生合法值\n    → Step 2: a ← rand7() // 取得第一個隨機數\n    → Step 3: b ← rand7() // 取得第二個隨機數\n    → Step 4: num ← (a - 1) * 7 + b // 將兩個 1~7 映射為 1~49\n    → Decision: num ≤ 40? // 濾除超過 40 的值\n        Yes → Step 5: result ← (num - 1) % 10 + 1 // 轉為 1~10\n        → Step 6: Return result // 回傳結果\n        No  → Step 7: Continue // 重新進入循環\nEnd\n\nBut must use arrow format: \"Yes → Step 5: ...\" \"No → Step 7: ...\".\n\nAlso we need to indent properly? Format maybe with indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 0: 定義函式 rand10() // 定義產生 1~10 的函式\n→ Step 1: 進入無限循環 // 只要不符合條件就重試\n    → Step 2: a ← rand7() // 取得第一個隨機數 (1~7)\n    → Step 3: b ← rand7() // 取得第二個隨機數 (1~7)\n    → Step 4: num ← (a - 1) * 7 + b // 把兩個 1~7 的結果映射到 1~49\n    → Decision: num ≤ 40? // 濾除超過 40 的值，保證均勻分佈\n        Yes → Step 5: result ← (num - 1) % 10 + 1 // 轉換為 1~10\n        → Step 6: Return result // 回傳合法結果\n        No  → Step 7: 繼續 // 重複循環，重新產生隨機數\nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpckpcf431.py\", line 43, in <module>\n    special = ast.literal_eval(re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', text).group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[3,0,5]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj35f18ws.py\", line 43, in <module>\n    special = ast.literal_eval(re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', text).group(1))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,4]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # Base cost: buy remaining items at full price\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # Try each special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:  # offer can be applied\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = [line.strip() for line in sys.stdin if line.strip()]\n    if len(data) >= 3:\n        # 解析每行的變量值\n        price = ast.literal_eval(data[0].split('=', 1)[1].strip())\n        special = ast.literal_eval(data[1].split('=', 1)[1].strip())\n        needs = ast.literal_eval(data[2].split('=', 1)[1].strip())\n    else:\n        # 若輸入格式不同，直接從整個輸入中找出列表\n        import re\n        text = \"\\n\".join(data)\n        price = ast.literal_eval(re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', text).group(1))\n        special = ast.literal_eval(re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', text).group(1))\n        needs = ast.literal_eval(re.search(r'needs\\s*=\\s*(\\[[^\\]]*\\])', text).group(1))\n\n    sol = Solution()\n    answer = sol.shoppingOffers(price, special, needs)\n    print(answer)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving LeetCode Store problem: minimum cost with special offers, like LeetCode 638. Use DFS with memo or DP. Steps: start, define DFS function with needs tuple; memo dict; if key in memo return; base cost sum of remaining items * price. Iterate offers; check if can apply offer (needs >= offer counts). If yes, compute newNeeds = needs - offer counts; cost = offer price + dfs(newNeeds); update min. Store memo; return min. Then call dfs(needs). Output min.\n\nWe need to output line by line virtual code and comment after space. Use arrows. Use indentation? Use spaces. The format: \"→ Step 1: ...\" So we need to start: Start // 程式開始執行. Then we define function etc. Use arrows.\n\nLet's produce. Use Step numbers. Use Decision nodes for base case.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 DFS(needs) 以計算剩餘需求的最低價格 // 建立遞迴求解  \n    → Step 2: 若 needs 為全零向量，返回 0 // 無需購買任何商品  \n    → Step 3: 若 needs 在 memo 中，返回 memo[needs] // 使用快取避免重複計算  \n    → Step 4: 計算直接購買的成本: baseCost = Σ (needs[i] * price[i]) // 單獨買的基礎價格  \n    → Step 5: 初始化 minCost = baseCost // 先假設不使用任何特價套裝  \n    → Decision: 是否能夠套用每一個特價套裝? // 檢查所有特價  \n        Yes → Step 6: 取特價 offer  \n            → Decision: 如果 needs[i] ≥ offer[i] (對所有 i)  \n                Yes → Step 7: 計算 newNeeds = needs - offer[:n] // 用套裝後的剩餘需求  \n                    → Step 8: cost = offer[n] + DFS(newNeeds) // 套裝價格加上剩餘需求的最小價格  \n                    → Step 9: 若 cost < minCost，更新 minCost = cost // 選擇更便宜方案  \n                No → Step 10: 跳過此 offer // 無法使用  \n    → Step 11: memo[needs] = minCost // 將結果快取  \n    → Step 12: 回傳 minCost // 返回此需求組合的最小價格  \n→ Step 13: 讀入 price, needs, special // 初始化資料  \n→ Step 14: 呼叫 DFS(tuple(needs)) 並將結果存入 answer // 主程式入口  \n→ Step 15: 輸出 answer // 顯示最低價格  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef wiggle_sort(nums):\n    \"\"\"\n    Rearranges nums in-place so that nums[0] < nums[1] > nums[2] < nums[3] ...\n    \"\"\"\n    for i in range(1, len(nums)):\n        if i % 2 == 1:          # i is odd: we need nums[i] > nums[i-1]\n            if nums[i] <= nums[i-1]:\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n        else:                   # i is even: we need nums[i] < nums[i-1]\n            if nums[i] >= nums[i-1]:\n                nums[i], nums[i-1] = nums[i-1], nums[i]\n    return nums\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list from the input string\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        raise ValueError(\"Input format must contain a list of integers.\")\n    nums_str = data[start:end+1]\n    nums = ast.literal_eval(nums_str)\n\n    # Apply wiggle sort\n    result = wiggle_sort(nums)\n\n    # Output the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for reorder array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3]... . Known solution: iterate i from 1 to n-1: if (i % 2 == 1 and nums[i] <= nums[i-1]) or (i % 2 == 0 and nums[i] >= nums[i-1]) then swap(nums[i], nums[i-1]). Provide virtual steps. We'll produce lines accordingly.\n\nStart\n→ Step 1: 取得陣列長度 n // 取得輸入陣列長度\n→ Step 2: 從 i = 1 到 n-1 執行循環 // 遍歷陣列\n    → Decision: i 是奇數? // 判斷 i 的奇偶\n        Yes → Decision: nums[i] <= nums[i-1]? // 若奇數且左側較大\n            Yes → Step 3: 交換 nums[i] 與 nums[i-1] // 交換以滿足 < >\n            No  → (無操作)\n        No  → Decision: nums[i] >= nums[i-1]? // 若偶數且左側較小\n            Yes → Step 3: 交換 nums[i] 與 nums[i-1] // 交換以滿足 < >\n            No  → (無操作)\n→ End // 完成\n\nBut need to use virtual arrow notation: \"→\" and \"Yes →\" \"No →\". Provide explanation after comment. Also we need to not output actual code but structured steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得陣列長度 n // 取得輸入陣列長度\n→ Step 2: 從 i = 1 到 n-1 執行循環 // 遍歷陣列\n    → Decision: i 是奇數? // 判斷 i 的奇偶\n        Yes → Decision: nums[i] <= nums[i-1]? // 若奇數且當前值不大於前一值\n            Yes → Step 3: 交換 nums[i] 與 nums[i-1] // 交換以滿足 nums[i-1] < nums[i]\n            No  → (無操作) // 已符合要求\n        No  → Decision: nums[i] >= nums[i-1]? // 若偶數且當前值不小於前一值\n            Yes → Step 3: 交換 nums[i] 與 nums[i-1] // 交換以滿足 nums[i-1] > nums[i]\n            No  → (無操作) // 已符合要求\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                if email not in parent:\n                    parent[email] = email\n                parent[find(email)] = find(first_email)\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    local_vars = {}\n    # 先嘗試執行整段文字，若輸入為 \"accounts = [...]\"\n    try:\n        exec(data, {}, local_vars)\n        accounts = local_vars.get('accounts')\n    except Exception:\n        accounts = None\n\n    # 若 exec 失敗，直接 eval 為列表\n    if accounts is None:\n        accounts = eval(data)\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step for merging accounts. This is the Leetcode 721 Accounts Merge problem. Need to provide virtual code with explanations, line by line. Must not output actual code but a structured pseudo-code. Use arrow notation.\n\nLet's craft algorithm: build mapping email to name and graph adjacency between emails in same account. Use union find or DFS.\n\nI'll outline using DSU.\n\nPseudo steps:\n\nStart\n→ Build email_to_name map, parent dict for DSU\n→ For each account:\n    name = account[0]\n    for each email in account[1:]:\n        if email not in parent: parent[email]=email\n        email_to_name[email]=name\n        union(first_email, email)\n→ After union all, group emails by root\n→ For each email in parent:\n    root=find(email)\n    add email to groups[root]\n→ Build result list\n    For each group:\n        emails_sorted=sorted(group)\n        result.append([name]+emails_sorted)\n→ End\n\nWe need to include Decision steps? Not many decisions but we can have for loops, union find find.\n\nLet's create step lines accordingly.\n\nNeed each line: \"虛擬碼步驟 // 解釋\"\n\nUse arrow \"→\". Decision lines: \"Decision:\" maybe used for if statements.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 email_to_name 為空字典 // 用於存儲每個 email 對應的名字  \n→ Step 2: 初始化 parent 為空字典 // 用於 DSU (Disjoint Set Union) 的父節點映射  \n→ Step 3: 定義 Find(x) 函式 // 路徑壓縮，返回 email x 的根  \n→ Step 4: 定義 Union(x, y) 函式 // 將兩個 email 合併到同一集合  \n→ Step 5: 迭代遍歷每個 account in accounts // 處理所有帳戶  \n  → Step 5.1: name ← account[0] // 帳戶擁有者姓名  \n  → Step 5.2: first_email ← account[1] // 取帳戶中第一個 email 作為基準  \n    → Step 5.2.1: If first_email not in parent → parent[first_email] ← first_email // 初始化根節點  \n    → Step 5.2.2: email_to_name[first_email] ← name // 記錄姓名  \n  → Step 5.3: 迭代遍歷其餘 emails in account[2:] // 合併所有 email  \n    → Step 5.3.1: If email not in parent → parent[email] ← email // 初始化根節點  \n    → Step 5.3.2: email_to_name[email] ← name // 記錄姓名  \n    → Step 5.3.3: Union(first_email, email) // 將 email 與基準 email 合併  \n→ Step 6: 建立 groups 為空字典 // 根節點到其所有 email 的映射  \n→ Step 7: 迭代遍歷所有 email in parent.keys() // 為每個 email 找到根並分組  \n  → Step 7.1: root ← Find(email) // 找到 email 的根  \n  → Step 7.2: 如果 root 不在 groups → groups[root] ← 空列表 // 初始化分組  \n  → Step 7.3: groups[root].append(email) // 將 email 加入對應分組  \n→ Step 8: 建立 result 為空列表 // 存放最終合併後的帳戶列表  \n→ Step 9: 迭代遍歷每個 root, emails in groups.items() // 處理每個分組  \n  → Step 9.1: sorted_emails ← sorted(emails) // 將 email 排序  \n  → Step 9.2: name ← email_to_name[sorted_emails[0]] // 取得分組的姓名（任何 email 都相同）  \n  → Step 9.3: result.append([name] + sorted_emails) // 合併姓名與排序後的 email  \n→ End // 程式執行結束，返回 result\n\n(完成虛擬碼與逐行說明)"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4cvkicoz.py\", line 49, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplz36whos.py\", line 49, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find shortest paths and record parents\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Execute the input string to get variables\n    local_vars = {}\n    exec(data, {}, local_vars)\n    beginWord = local_vars['beginWord']\n    endWord = local_vars['endWord']\n    wordList = local_vars['wordList']\n\n    sol = Solution()\n    result = sol.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for algorithm: find all shortest transformation sequences. Classic Leetcode 127 Word Ladder II. Approach: BFS to build level graph, then DFS/backtrack to collect paths. Or BFS with adjacency. We'll produce pseudo-code with steps.\n\nNeed to output line by line with arrow and explanation. Format: \"虛擬碼步驟 // 解釋\". Use arrows: Start, End, Decision. We'll produce sequence of steps. Use appropriate arrow notation \"→\". Provide indentation? In sample they use indentation with spaces to denote nested decisions. We'll replicate.\n\nWe must not produce actual code; just virtual steps. So each step will be generic like \"Start\", \"Load wordList into set\", \"If endWord not in set → End empty list\". Then BFS loop, building adjacency dict, levels, etc. Then DFS.\n\nWe'll produce thorough steps.\n\nLet's craft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Load beginWord, endWord, wordList // 取得輸入\n\nLine 3: → Create wordSet from wordList // 方便 O(1) 查找\n\nLine 4: → Decision: endWord in wordSet? // 必須存在才能有路徑\n\nLine 5: Yes → continue // 若不存在，返回空\n\nLine 6: No → End // 空列表，程式結束\n\nLine 7: → Initialize queue with beginWord // BFS 起點\n\nLine 8: → Initialize visited set with beginWord // 已訪問\n\nLine 9: → Initialize parents map: word → list of predecessors // 儲存前驅\n\nLine 10: → Initialize foundEnd False // 標記是否已找到目標\n\nLine 11: → While queue not empty AND not foundEnd: // BFS 逐層\n\nLine 12: Indent: → Determine levelSize = size of queue // 本層長度\n\nLine 13: Indent: → For i in 1..levelSize: // 處理本層每個字\n\nLine 14: Indent: Indent: → current = dequeue queue // 取字\n\nLine 15: Indent: Indent: → For each position p in current: // 逐位更改\n\nLine 16: Indent: Indent: Indent: → For each letter 'a'..'z': // 生成相鄰字\n\nLine 17: Indent: Indent: Indent: Indent: → next = current with position p replaced by letter // 新字\n\nLine 18: Indent: Indent: Indent: Indent: → If next not in wordSet: // 字典外忽略\n\nLine 19: Indent: Indent: Indent: Indent: Yes → Continue // 跳過\n\nLine 20: Indent: Indent: Indent: Indent: No → Continue\n\nLine 21: Indent: Indent: Indent: Indent: → If next == endWord: // 到達終點\n\nLine 22: Indent: Indent: Indent: Indent: Yes → Append current to parents[next] // 記錄前驅\n\nLine 23: Indent: Indent: Indent: Indent: No → Continue\n\nBut we need to record parents for all neighbors regardless of found end? Actually BFS should record parents for all neighbors, but if found end, we don't enqueue further levels after finishing current level. So need visited per level.\n\nLet's produce simpler: maintain local visited set for current level. For each neighbor: if not visited global: add to parents map, enqueue if not visited global. If neighbor not visited global, add to local visited. If neighbor==endWord, foundEnd True.\n\nOk produce pseudo-code accordingly.\n\nAfter BFS, if not foundEnd: End // no path\n\nThen Backtracking: DFS from endWord to beginWord via parents, build path reversed.\n\nImplement stack.\n\nPseudo:\n\nLine 24: → If not foundEnd: // 沒有路徑\n\nLine 25: Yes → End // 回傳空\n\nLine 26: No → continue\n\nLine 27: → Initialize result list // 存所有最短路徑\n\nLine 28: → Define recursive function dfs(word, path) // 回溯\n\nLine 29: Indent: → If word == beginWord: // 到達起點\n\nLine 30: Indent: Yes → Prepend beginWord to path // 或 path.append(beginWord)\n\nLine 31: Indent: Yes → Add reversed path to result // 轉回正向\n\nLine 32: Indent: No → Return // 結束\n\nLine 33: → For each predecessor in parents[word]: // 前驅\n\nLine 34: Indent: → dfs(predecessor, path + [word]) // 進行回溯\n\nLine 35: → Call dfs(endWord, []) // 開始回溯\n\nLine 36: → End // 程式結束\n\nBut need to maintain path reversed. We'll adapt.\n\nHowever we cannot use actual code syntax. We'll express as virtual steps: \"Define function Backtrack(currentWord, path)\". Provide explanation.\n\nWe also need to output the final result list. Not necessary to produce code; just steps.\n\nLet's craft final pseudo code with arrow and explanation. Use indentation with spaces. We'll use \"Decision:\" for decisions.\n\nLet's produce step by step lines.\n\nMake sure to use \"Start\" and \"End\".\n\nWe must include all steps. Provide explanation after each line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 讀取 beginWord、endWord、wordList // 取得輸入資料  \n→ 將 wordList 轉為 hash 集合 wordSet // 方便 O(1) 查找  \n→ Decision: endWord 在 wordSet 嗎? // 若不存在就無法完成轉換  \n Yes → 進行下一步 // 目標字存在  \n No  → End // 回傳空列表，程式結束  \n\n→ 初始化 BFS 队列 queue，加入 beginWord // BFS 的起點  \n→ 初始化已訪問集合 visited，加入 beginWord // 防止重複探索  \n→ 初始化父節點映射 parents：字 → 前驅列表 // 用來追溯最短路徑  \n→ 初始化 foundEnd 為 False // 標記是否已找到 endWord  \n\n→ Decision: queue 是否為空且未找到 endWord? // 進行 BFS  \n Yes → 進入循環  \n No  → 跳出循環  \n\n  → 設定 levelSize = queue 的長度 // 本層字數  \n  → for i in 1..levelSize: // 逐字處理本層  \n    → current = dequeue queue // 取出一個字  \n    → for each position p in current: // 逐位替換  \n      → for each letter l in 'a'..'z': // 生成相鄰字  \n        → next = current 的第 p 位改為 l // 新字  \n        → Decision: next 在 wordSet 嗎? // 必須是合法字  \n         Yes → 進行下一步 // 合法  \n         No  → Continue // 跳過非字典字  \n        → Decision: next 是否已在 visited? // 防重複  \n         Yes → Continue // 已訪問，跳過  \n         No  →  \n           → 如果 next == endWord → foundEnd = True // 找到終點  \n           → parents[next] 加入 current // 記錄前驅  \n           → enqueue next 到 queue // 下一層探索  \n           → visited 加入 next // 標記已訪問  \n\n→ Decision: foundEnd 為 False? // BFS 完結後檢查是否有路徑  \n Yes → End // 無路徑，回傳空列表  \n No  → 進行回溯尋找所有最短路徑  \n\n→ 初始化 result 為空列表 // 存儲所有最短序列  \n\n→ 定義函式 Backtrack(current, path)： // 從 endWord 回溯到 beginWord  \n  → Decision: current == beginWord? // 到達起點  \n   Yes → result 加入 [beginWord] + reverse(path) // 完成一條路徑  \n   No  →  \n    → for each pred in parents[current]: // 遍歷所有前驅  \n      → Backtrack(pred, path + [current]) // 深度優先遞歸  \n\n→ 呼叫 Backtrack(endWord, []) // 開始回溯  \n→ End // 程式執行結束，result 為所有最短轉換序列"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,4,1,1,1,0,4,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 4, 1, 1, 1, 0, 4, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 可用數字的數量\n        self.size = n - len(blacklist)\n        # 黑名單集合，方便快速查找\n        black = set(blacklist)\n        # 用於映射的字典\n        self.mapping = {}\n        # 指向右側最後一個可能合法數字\n        last = n - 1\n        # 為每個位於左半段的黑名單建立映射\n        for b in blacklist:\n            if b < self.size:\n                # 找到右側第一個不在黑名單的數字\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # 產生左側範圍內的隨機索引\n        index = random.randint(0, self.size - 1)\n        # 若該索引在映射中，返回映射後的合法數字，否則直接返回\n        return self.mapping.get(index, index)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 解析方法列表與對應參數\n    methods = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    results = []\n    obj = None\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)  # 建構子沒有返回值\n        elif method == \"pick\":\n            results.append(obj.pick())\n        else:\n            # 若未來加入其他方法，可在此處處理\n            func = getattr(obj, method)\n            results.append(func(*arg))\n\n    # 將 None 轉成 null 以符合預期輸出格式\n    output = []\n    for r in results:\n        output.append(\"null\" if r is None else str(r))\n    print(\"[\" + \", \".join(output) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, line by line. Need to reflect solution: typical approach: map blacklisted values >= m to allowed values. m = n - len(blacklist). Preprocess: create set of blacklist. Create mapping for blacklisted numbers in [0, m-1] to non-blacklisted numbers in [m, n-1]. In pick: generate random int r in [0, m-1]; if r in map then return map[r], else r.\n\nLet's produce virtual code.\n\nWe need start, end, decisions, loops.\n\nLet's write steps:\n\nStart\n→ Step 1: 初始化 m = n - len(blacklist) // 可用數量\n→ Step 2: 建立 blacklist_set = set(blacklist) // 方便查詢\n→ Step 3: 建立空字典 mapping // 用於映射\n→ Step 4: 建立 white_pointer = m // 指向右側可用數字\n→ Decision: 是否有黑名單項在 [0, m-1]? // 若無則 skip\n    Yes → Loop: For each b in blacklist where b < m:\n        → Step 5: while white_pointer in blacklist_set: white_pointer +=1 // 找到右側非黑名單\n        → Step 6: mapping[b] = white_pointer // 將 b 映射\n        → Step 7: white_pointer +=1 // 移動\n    No → Do nothing\n→ Step 8: 保存 mapping, m // 供 pick 使用\nEnd\n\nPick method:\nStart\n→ Step 9: r = random_int(0, m-1) // 產生隨機索引\n→ Decision: r 在 mapping? \n    Yes → Step 10: return mapping[r] // 替換為右側\n    No  → Step 11: return r // 直接返回\nEnd\n\nWe need to output each line with virtual code and comment. Use arrow arrows.\n\nLet's write each step as:\n\nStart // 程式開始執行\n→ Step 1: m ← n - |blacklist| // 計算可用數字總數\n→ Step 2: blacklist_set ← Set(blacklist) // 快速判斷是否為黑名單\n→ Step 3: mapping ← {} // 存放黑名單小於 m 的映射\n→ Step 4: white_pointer ← m // 指向右側第一個候選數\n→ Decision: 是否存在 b < m in blacklist? // 需要建立映射\n    Yes → For each b in blacklist:\n        → Decision: b < m? // 只處理在左半部分的黑名單\n            Yes → While white_pointer ∈ blacklist_set: white_pointer ← white_pointer + 1 // 跳過右側黑名單\n            Yes → mapping[b] ← white_pointer // 把 b 映射到一個合法的右側數字\n            Yes → white_pointer ← white_pointer + 1 // 移動指標\n        No  → Continue\n    No → // 無需映射\n→ Step 5: store mapping and m for later use // 這一步在建構子結束\nEnd // 建構完成\n\nPick method:\nStart // pick() 開始\n→ Step 6: r ← random_int(0, m-1) // 隨機產生左側索引\n→ Decision: r ∈ mapping? // 判斷是否需要映射\n    Yes → Step 7: return mapping[r] // 回傳映射後的合法數字\n    No  → Step 8: return r // 直接回傳\nEnd // pick() 結束\n\nNeed to ensure each line format exactly: virtual code step + space + comment. Use arrow symbols.\n\nWe need to ensure we use \"→\" for each step. For decision lines, use \"Decision:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← n - |blacklist| // 計算可用數字總數  \n→ Step 2: blacklist_set ← Set(blacklist) // 快速判斷是否為黑名單  \n→ Step 3: mapping ← {} // 存放黑名單小於 m 的映射  \n→ Step 4: white_pointer ← m // 指向右側第一個候選數  \n→ Decision: 是否存在 b < m in blacklist? // 需要建立映射  \n  Yes → For each b in blacklist: // 逐個處理黑名單  \n   Decision: b < m? // 只處理在左半部分的黑名單  \n    Yes → While white_pointer ∈ blacklist_set: white_pointer ← white_pointer + 1 // 跳過右側黑名單  \n    Yes → mapping[b] ← white_pointer // 把 b 映射到一個合法的右側數字  \n    Yes → white_pointer ← white_pointer + 1 // 移動指標  \n   No → Continue // 若 b ≥ m，跳過  \n  No → // 無需映射  \n→ Step 5: store mapping and m for later use // 這一步在建構子結束  \nEnd // 建構完成  \n\nStart // pick() 開始  \n→ Step 6: r ← random_int(0, m-1) // 隨機產生左側索引  \n→ Decision: r ∈ mapping? // 判斷是否需要映射  \n  Yes → Step 7: return mapping[r] // 回傳映射後的合法數字  \n  No  → Step 8: return r // 直接回傳  \nEnd // pick() 結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpczxubu8l.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpczxubu8l.py\", line 53, in main\n    args_list = json.loads('[' + parts[1])\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom typing import Dict, List\n\nclass TrieNode:\n    def __init__(self):\n        self.children: Dict[str, 'TrieNode'] = {}\n        self.sum: int = 0  # cumulative sum of all keys passing through this node\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_to_val: Dict[str, int] = {}\n\n    def insert(self, key: str, val: int) -> None:\n        \"\"\"Insert or update the key with value `val`.\"\"\"\n        old_val = self.key_to_val.get(key, 0)\n        delta = val - old_val\n        self.key_to_val[key] = val\n\n        node = self.root\n        node.sum += delta\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        \"\"\"Return the sum of all values of keys that start with `prefix`.\"\"\"\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    # Assume two lines: first is list of commands, second is list of arguments\n    if len(data) >= 2:\n        commands = json.loads(data[0])\n        args_list = json.loads(data[1])\n    else:\n        # Fallback: single line containing two JSON arrays separated by comma\n        # Example: '[\"MapSum\",\"insert\",\"sum\"],[[],[\"apple\",3],[\"ap\"]]'\n        raw = data[0]\n        parts = raw.split('],', 1)\n        commands = json.loads(parts[0] + ']')\n        args_list = json.loads('[' + parts[1])\n\n    result: List = []\n    ms: MapSum | None = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MapSum\":\n            ms = MapSum()\n            result.append(None)\n        elif cmd == \"insert\":\n            if ms is not None:\n                key, val = args\n                ms.insert(key, val)\n                result.append(None)\n        elif cmd == \"sum\":\n            if ms is not None:\n                prefix = args[0]\n                result.append(ms.sum(prefix))\n        else:\n            result.append(None)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for designing MapSum with insert and sum. Provide virtual steps: initialization, using Trie maybe, maintain prefix sums. We'll produce step by step algorithm design.\n\nWe'll use Trie nodes with children map, sum field for prefix sum, and value field for exact key.\n\nSteps: Start, initialize root, maintain hashmap for key->value to handle override.\n\nInsert: update diff = newVal - oldVal; update node sum along path.\n\nSum: traverse prefix and return node sum.\n\nLet's produce virtual code with lines and explanations. Use arrows and Decision. Let's start.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 MapSum 物件 // 建立根節點與 key-值 儲存表\n    → 子步驟 1.1: 建立 TrieNode root // 每個節點持有子節點、前綴總和與終端值\n    → 子步驟 1.2: 建立 hashMap keyToVal // 儲存目前每個 key 的實際值，方便覆寫時計算差值\n→ Step 2: insert(key, val) // 將 key 與值加入或更新 MapSum\n    → 子步驟 2.1: 取得舊值 oldVal = keyToVal.getOrDefault(key, 0) // 若 key 之前不存在，oldVal 為 0\n    → 子步驟 2.2: 計算差值 delta = val - oldVal // 需要在 Trie 上更新的差值\n    → 子步驟 2.3: 將 key 與 val 存入 keyToVal // 覆寫或新增\n    → 子步驟 2.4: 設定 node = root // 從根節點開始\n    → 子步驟 2.5: node.sum += delta // 更新根節點的前綴總和\n    → 子步驟 2.6: 逐字遍歷 key 的每個字符 c\n        → 子步驟 2.6.1: 如果 node.children 沒有 c，建立新 TrieNode 並加入子節點\n        → 子步驟 2.6.2: node = node.children[c] // 移動到下一節點\n        → 子步驟 2.6.3: node.sum += delta // 更新此節點的前綴總和\n→ Step 3: sum(prefix) // 回傳所有以 prefix 為前綴的鍵的值之和\n    → 子步驟 3.1: 設定 node = root // 從根節點開始\n    → 子步驟 3.2: 逐字遍歷 prefix 的每個字符 c\n        → 子步驟 3.2.1: 如果 node.children 沒有 c，回傳 0 // 沒有此前綴\n        → 子步驟 3.2.2: node = node.children[c] // 移動到下一節點\n    → 子步驟 3.3: 回傳 node.sum // 此節點的前綴總和即為答案\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.04021965197543438,0.9111271392228457],[0.667867480621599,0.10025249544028532],[-0.7752817106981961,-0.5301911669926008]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.04021965197543438, 0.9111271392228457], [0.667867480621599, 0.10025249544028532], [-0.7752817106981961, -0.5301911669926008]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻分布的隨機點\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 解析操作與參數\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # 建構子不回傳值，使用 None 代表 null\n        else:\n            # 取得方法並呼叫\n            method = getattr(obj, op)\n            res = method()\n            results.append(res)\n\n    # 以 JSON 形式輸出，將 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm: generate random point uniformly in circle: use polar coordinates: r = sqrt(random) * radius, theta = random*2π, x = x_center + r*cos(theta), y = y_center + r*sin(theta). Virtual code lines. Use Start, End, Decision? Not necessary but can include Decision: if any. Provide each line with comment. Use arrow and structure. Provide line by line. Ensure each line is a statement of virtual code. Format: \"虛擬碼步驟 // 解釋\". Use Chinese comments. Use arrow (→). Provide structure for class. Steps: Start, Step: define class, Step: constructor assign values, Step: randPoint method begin, Step: generate u1, u2, Step: compute r, Step: compute theta, Step: compute x,y, Step: return [x,y], End. Might include Decision? Not necessary. But we can include Decision for random? maybe not. We'll just provide linear flow.\n\nMake sure each line has comment after //.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: Solution(double radius, double x_center, double y_center) {  \n→   → Step 3: this.radius ← radius // 儲存半徑  \n→   → Step 4: this.x_center ← x_center // 儲存中心 X 座標  \n→   → Step 5: this.y_center ← y_center // 儲存中心 Y 座標  \n→ Step 6: } // 建構子結束  \n→ Step 7: randPoint() {  \n→   → Step 8: u1 ← Random() // 產生 0~1 的隨機數  \n→   → Step 9: u2 ← Random() // 產生 0~1 的隨機數  \n→   → Step 10: r ← sqrt(u1) * this.radius // 隨機半徑，確保均勻分佈  \n→   → Step 11: theta ← u2 * 2π // 隨機角度  \n→   → Step 12: x ← this.x_center + r * cos(theta) // 計算 X 座標  \n→   → Step 13: y ← this.y_center + r * sin(theta) // 計算 Y 座標  \n→   → Step 14: return [x, y] // 回傳隨機點  \n→ Step 15: } // randPoint 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[2,2,_,_]'\nGot (Norm):      '2,nums=[2,2,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [2,2,_,_]'\nRaw Got:      \"2, nums = [2, 2, '_', '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,3,0,4,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,3,0,4,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 3, 0, 4, '_', '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除所有等於 val 的元素，保持前面 k 個元素為非 val，返回 k\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums 與 val\n    \"\"\"\n    # 搜尋類似 \"nums = [3,2,2,3], val = 3\" 的格式\n    m = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*val\\s*=\\s*([-\\d]+)', data)\n    if m:\n        nums_str = m.group(1)\n        val_str = m.group(2)\n        try:\n            nums = eval(nums_str, {\"__builtins__\": None}, {})\n            val = int(val_str)\n            return nums, val\n        except Exception:\n            pass\n\n    # 若上述格式不匹配，嘗試直接 eval 成 tuple 或 list\n    try:\n        parsed = eval(data, {\"__builtins__\": None}, {})\n        if isinstance(parsed, tuple) and len(parsed) == 2:\n            return list(parsed[0]), int(parsed[1])\n    except Exception:\n        pass\n\n    raise ValueError(\"輸入格式無法解析\")\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    nums, val = parse_input(data)\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 補齊剩餘位置，使用 '_' 代表未使用元素\n    result_list = nums[:k] + ['_'] * (len(nums) - k)\n    print(f\"{k}, nums = {result_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step by step, with explanation. Use Start, Decision, etc. The algorithm: two-pointer: i and p. Or simply use count method: iterate, if not val, set nums[count++] = nums[i]. Return count. Provide virtual code with lines.\n\nWe must produce each line with format \"虛擬碼步驟 // 解釋\".\n\nLet's produce. Use Start, End. Use Decision and Yes/No arrows.\n\nExample: \nStart // 程式開始執行\n→ Step 1: 設定 count = 0 // 初始化計數器\n\nThen loop: For i from 0 to nums.length-1: // iterate all elements\n→ Decision: If nums[i] != val? // 檢查是否需要保留\nYes → Step 2: nums[count] = nums[i] // 將非 val 的元素覆蓋到前面\n→ Step 3: count = count + 1 // 移動計數器\nNo → Step 4: // 跳過該元素，直接進下一個\n\nAfter loop, End // 程式結束\n→ Return count // 回傳非 val 的個數\n\nAlso we need to include sorting? Not part of algorithm. Just return.\n\nWe must adhere to arrow syntax: `→ Step ...` and `Decision: ...` with Yes → and No → indent lines.\n\nAlso each line must have // explanation.\n\nLet's craft accordingly. Ensure each line ends with comment.\n\nMake sure each line includes \"虛擬碼步驟\" like \"Step 1\" etc. Use \"Start\", \"End\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count ← 0 // 初始化計數器，存放非 val 元素的個數  \n→ Step 2: i ← 0 // 設定迴圈起始索引  \n→ Decision: i < nums.length? // 判斷是否還有元素可處理  \n Yes → Step 3: current ← nums[i] // 取得當前元素  \n  Decision: current ≠ val? // 檢查是否為非 val  \n   Yes → Step 4: nums[count] ← current // 把非 val 元素放到前方  \n    → Step 5: count ← count + 1 // 計數器遞增  \n   No → Step 6: // 不做任何操作，直接跳過  \n   → Step 7: // 迴圈結束後繼續往下  \n  → Step 8: i ← i + 1 // 移動至下一個索引  \n  → Step 9: // 重新評估條件  \n  → Step 10: // 回到 Decision  \n   No → End // i 已超過長度，結束迴圈  \n→ Step 11: return count // 回傳不等於 val 的元素個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    \"\"\"隨機打亂數組的實現。\"\"\"\n\n    def __init__(self, nums):\n        \"\"\"\n        以給定的整數數組初始化對象。\n        - `nums`：原始整數數組。\n        \"\"\"\n        # 儲存原始數組的拷貝，便於 reset 時回復\n        self._original = list(nums)\n\n    def reset(self):\n        \"\"\"\n        重置數組回原始順序。\n        返回：原始數組的拷貝。\n        \"\"\"\n        return list(self._original)\n\n    def shuffle(self):\n        \"\"\"\n        隨機打亂數組並返回一個新數組。\n        使用 Fisher–Yates 洗牌算法確保所有排列等可能。\n        返回：打亂後的數組。\n        \"\"\"\n        arr = list(self._original)          # 先拷貝原始數組\n        n = len(arr)\n        for i in range(n - 1, 0, -1):        # 從末尾往前遍歷\n            j = random.randint(0, i)        # 隨機選擇 0~i 的索引\n            arr[i], arr[j] = arr[j], arr[i] # 交換元素\n        return arr\n\ndef main():\n    \"\"\"\n    主函數：\n    1. 從標準輸入讀取操作列表和參數列表。\n    2. 按順序執行每個操作。\n    3. 將每次操作的結果（包括 None）收集並輸出為 JSON 格式。\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析輸入。將輸入包裝成 Python 元組字面量。\n    try:\n        ops, args = ast.literal_eval('(' + raw + ')')\n    except Exception:\n        # 如果解析失敗，嘗試分行讀取\n        parts = raw.split('\\n')\n        ops = ast.literal_eval(parts[0])\n        args = ast.literal_eval(parts[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # `arg` 是一個列表，內含單一元素即原始數組\n            obj = Solution(arg[0] if isinstance(arg, list) else arg)\n            results.append(None)          # 這一步無返回值\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有未知操作，直接跳過\n            pass\n\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(results, ensure_ascii=False))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps line by line with comments. Virtual code lines include arrows, Start, End, Decision: etc. We should design algorithm for shuffling array (Fisher-Yates). Implementation of Solution class with constructor, reset, shuffle.\n\nWe need to produce lines for initialization, storing original array, resetting, shuffling algorithm. Use steps. Also show how to return array, but not actual code. Provide comments.\n\nLet's craft lines:\n\nStart\n→ Step 1: 定義 Solution 類別 // 類別封裝\n\n→ Step 2: 定義構造函數 Solution(nums) // 初始化\n\nInside constructor:\n\n→ Step 3: 令 this.original = 複製 nums // 保留原始順序\n\n→ Step 4: 令 this.array = 複製 nums // 可變陣列\n\nEnd // constructor finished\n\n→ Step 5: 定義方法 reset() // 重置\n\n→ Step 6: 令 this.array = 複製 this.original // 恢復原始陣列\n\n→ Step 7: 回傳 this.array // 返回\n\n→ Step 8: 定義方法 shuffle() // 隨機打亂\n\n→ Step 9: 令 n = 長度 of this.array // 獲取長度\n\n→ Decision: 是否 n <= 1? // 如果陣列長度小於等於1，直接返回\n\n    Yes → Step 10: 回傳 this.array // 不需要打亂\n\n    No  → Step 11: 從 i = n-1 迭代到 1 // 逆序迭代\n\n        → Step 12: 生成隨機整數 j 在 [0, i] 之間 // 隨機索引\n\n        → Step 13: 交換 this.array[i] 與 this.array[j] // 交換元素\n\n    → Step 14: 回傳 this.array // 返回打亂後陣列\n\nEnd\n\nWe need to ensure each line has arrow and comment. Use arrow for steps, Decision for branching.\n\nMake sure to include Start and End for whole algorithm or each method? The example only uses Start and End for whole program. We can use Start at the beginning of all pseudo-code. Then End at the end.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別 // 建立一個類別來封裝演算法  \n→ Step 2: 定義構造函數 Solution(nums) // 以給定陣列建立物件  \n→ Step 3: 令 this.original = 複製 nums // 儲存原始順序以備重置  \n→ Step 4: 令 this.array = 複製 nums // 建立可變陣列供後續操作  \nEnd // 結束構造函數  \n\n→ Step 5: 定義方法 reset() // 重新回到原始陣列  \n→ Step 6: 令 this.array = 複製 this.original // 將陣列重設為原始順序  \n→ Step 7: 回傳 this.array // 回傳重置後的陣列  \n\n→ Step 8: 定義方法 shuffle() // 產生隨機排列  \n→ Step 9: 令 n = 長度 of this.array // 取得陣列長度  \n→ Decision: n <= 1? // 若陣列只有一個或沒有元素則直接返回  \n    Yes → Step 10: 回傳 this.array // 直接回傳，不需要打亂  \n    No  → Step 11: 從 i = n-1 迭代至 1 // 逆向遍歷陣列  \n        → Step 12: 生成隨機整數 j 於 [0, i] 之間 // 隨機選取索引  \n        → Step 13: 交換 this.array[i] 與 this.array[j] // 交換兩個元素  \n    → Step 14: 回傳 this.array // 回傳打亂後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            res.append(path[:])          # 加入目前的子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])     # 包含 nums[i]\n                backtrack(i + 1, path)   # 繼續遞迴\n                path.pop()               # 回溯，移除 nums[i]\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read()\n    # 取出方括號中的內容並解析為列表\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums = ast.literal_eval(match.group())\n    else:\n        nums = []\n\n    # 計算子集\n    solution = Solution()\n    result = solution.subsets(nums)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for generating all subsets of unique elements array, no duplicates. Classic power set via recursion or iterative bitmask. Use recursion: function subsets(nums, index, current, result). Provide Start, End, Decision. We must produce step-by-step pseudocode line by line, each with comment. Let's produce:\n\nStart\n→ Step 1: Initialize result list with empty subset\n→ Step 2: Call recursive helper with index 0 and empty current\n→ Helper function: \n    Decision: index equals length of nums? \n        Yes → Append current to result\n        No → \n            → Step: Include nums[index] in current -> call helper with index+1\n            → Step: Exclude nums[index] from current -> call helper with index+1\n\nThen End.\n\nNeed each line with arrow and comment. Use \"Decision:\" and \"Yes →\" \"No →\" as needed. Must avoid actual code. So pseudo lines.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義變數 result 為空列表 // 用來儲存所有子集\n→ Step 2: 定義變數 current 為空列表 // 當前正在構造的子集\n→ Step 3: 呼叫 helper(0, current, result) // 從索引 0 開始遞迴\nEnd // 程式結束\n\nHelper(index, current, result) {\n→ Decision: 如果 index 等於 nums 的長度? // 檢查是否已處理完所有元素\n    Yes → Step 4: 把 current 的複本加入 result // 將完整子集加入結果\n    No  → \n        → Step 5: 把 nums[index] 加入 current // 選擇包含該元素\n        → Step 6: 呼叫 helper(index+1, current, result) // 繼續遞迴\n        → Step 7: 移除 current 中最後一個元素 // 回溯，取消包含該元素\n        → Step 8: 呼叫 helper(index+1, current, result) // 繼續不包含該元素的遞迴\n}\n\nBut need to use arrow for each line. Let's structure as lines:\n\nStart // 程式開始\n→ Step 1: result ← [] // 初始化結果列表\n→ Step 2: current ← [] // 初始化當前子集\n→ Step 3: Call helper(0) // 開始遞迴\n\nHelper(i):\n→ Decision: i == length(nums)? // 已處理所有元素？\n    Yes → Step 4: result ← result ∪ {copy of current} // 加入子集\n    No  →\n        → Step 5: current ← current ∪ {nums[i]} // 包含當前元素\n        → Step 6: helper(i+1) // 遞迴處理下一個元素\n        → Step 7: current ← current - {nums[i]} // 回溯，移除元素\n        → Step 8: helper(i+1) // 遞迴處理不包含當前元素\n\nEnd // 程式結束\n\nMake sure each line has arrow and comment. Provide as plain text. Use “→” preceding each line except start. For decision, indent? Example: Decision line with Yes →, No →. We'll indent subsequent lines. Provide comment after space. Use //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: result ← [] // 初始化結果列表，將所有子集存放於此  \n→ Step 2: current ← [] // 初始化當前子集，開始構造子集  \n→ Step 3: Call helper(0) // 從索引 0 開始遞迴遍歷整個陣列  \n\nHelper(i):  \n→ Decision: i == length(nums)? // 已經處理完所有元素？  \n  Yes → Step 4: result ← result ∪ {copy of current} // 把目前子集加入結果  \n  No  →  \n   → Step 5: current ← current ∪ {nums[i]} // 選擇包含 nums[i]  \n   → Step 6: helper(i+1) // 進一步遞迴處理下一個元素  \n   → Step 7: current ← current - {nums[i]} // 回溯，移除剛加入的元素  \n   → Step 8: helper(i+1) // 進一步遞迴處理不包含 nums[i] 的情況  \n\nEnd // 程式結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '5,nums=[1,1,2,2,3,\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      \"5, nums = [1, 1, 2, 2, 3, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7,nums=[0,0,1,1,2,3,3,_,_]'\nGot (Norm):      '7,nums=[0,0,1,1,2,3,3,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '7, nums = [0,0,1,1,2,3,3,_,_]'\nRaw Got:      \"7, nums = [0, 0, 1, 1, 2, 3, 3, '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Remove duplicates from a sorted array in-place such that each element appears at most twice.\n        Returns the new length k after removals.\n        \"\"\"\n        if not nums:\n            return 0\n        write = 0  # index where next unique element should be written\n        for read in range(len(nums)):\n            # If we have written at least two elements and the current element\n            # is the same as the element two positions back, skip it.\n            if write >= 2 and nums[read] == nums[write - 2]:\n                continue\n            nums[write] = nums[read]\n            write += 1\n        return write\n\ndef main():\n    # Read all input, e.g. 'nums = [1,1,1,2,2,3]'\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part using ast.literal_eval for safety\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums = ast.literal_eval(data[start:end + 1])\n    except (ValueError, SyntaxError):\n        # If parsing fails, exit gracefully\n        return\n\n    solution = Solution()\n    k = solution.removeDuplicates(nums)\n\n    # Build the output list: first k elements are actual numbers,\n    # the rest are underscores\n    output_list = nums[:k] + ['_'] * (len(nums) - k)\n\n    # Print in the required format\n    print(f\"{k}, nums = {output_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanation. It's a LeetCode problem \"80. Remove Duplicates from Sorted Array II\". Use two pointers. So produce steps. Let's outline: Start, initialize write pointer at 0, iterate read from 0 to n-1, compare nums[read] with nums[write-2] if write>=2 and same, skip else write value and increment write. Finally End. Provide explanations. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrows, decision, etc. Each step in plain. Ensure to follow format. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 write = 0 // write 位置指向即將寫入的新陣列位置  \n→ Decision: 如果 nums 非空? // 檢查陣列是否至少有一個元素  \n    Yes → Step 2: 讀取 read = 0 // read 位置指向目前要檢查的元素  \n    No  → Step 3: 回傳 0 // 空陣列直接返回 0  \n→ Step 4: 對於 read 從 0 到 n-1 進行迴圈 // 遍歷整個陣列  \n    Decision: write >= 2 且 nums[read] == nums[write-2]? // 檢查目前元素是否已經出現過兩次  \n        Yes → Step 5: 跳過此元素並繼續迴圈 // 已出現兩次，跳過不寫入  \n        No → Step 6: nums[write] = nums[read] // 把元素寫入 write 位置  \n                  // 保持原順序  \n        → Step 7: write++ // 移動 write 到下一個可寫位置  \n→ Step 8: 回傳 write // write 代表新陣列長度 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8ybijemo.py\", line 29, in <module>\n    data = eval(formatted, {\"__builtins__\": {}})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'candidates' is not defined"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz6pzc2ak.py\", line 29, in <module>\n    data = eval(formatted, {\"__builtins__\": {}})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'candidates' is not defined"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_3bqaec1.py\", line 29, in <module>\n    data = eval(formatted, {\"__builtins__\": {}})\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'candidates' is not defined"
        }
      ],
      "generated_code": "import sys\n\ndef combination_sum(candidates, target):\n    res = []\n\n    def backtrack(start, path, total):\n        if total == target:\n            res.append(list(path))\n            return\n        if total > target:\n            return\n        for i in range(start, len(candidates)):\n            path.append(candidates[i])\n            backtrack(i, path, total + candidates[i])\n            path.pop()\n\n    backtrack(0, [], 0)\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 將輸入格式化為字典，允許 eval 解析\n    # 範例輸入: 'candidates = [2,3,6,7], target = 7'\n    formatted = '{' + raw.replace(' = ', ':') + '}'\n    data = eval(formatted, {\"__builtins__\": {}})\n    candidates = data[\"candidates\"]\n    target = data[\"target\"]\n\n    result = combination_sum(candidates, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Problem is classic \"Combination Sum\" LeetCode 39. We need to produce virtual code steps to solve. We should write a backtracking algorithm. Use recursion to build combinations, iterate candidates, allow unlimited picks, skip duplicates by order. Provide steps: Start, Input array, target, result list, define function backtrack(start, current_sum, combination). For each index i from start to len-1: add candidate[i] to combination, if sum==target: add copy to result, else if sum<target: backtrack(i, sum+candidate[i], combination). After loop, backtrack: pop last, etc. Then call backtrack(0,0,[]). Return result. End.\n\nWe need to produce virtual code steps, each line with explanation. Let's produce a line-by-line approach. We need to structure with Start, Decision, Yes/No, etc.\n\nWe need to show algorithm steps. For backtracking, we might express recursion steps with arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 candidates 及目標值 target // 取得輸入\n→ Step 2: 建立空列表 result // 用來儲存所有符合條件的組合\n→ Step 3: 定義遞迴函式 Backtrack(start, current_sum, current_combination) // 回溯方法\n→ Decision: 是否已達到目標? // 判斷是否需要回傳結果\n    Yes → Step 4: 把 current_combination 複製後加入 result // 找到一組解\n    No  → Step 5: 迭代從 start 開始的候選數 // 探索後續可能\n        → For i from start 到 len(candidates)-1:\n            → Step 6: 加入 candidates[i] 到 current_combination // 選擇該數字\n            → Step 7: 更新 current_sum += candidates[i] // 更新累積和\n            → Decision: current_sum 是否超過 target? // 檢查是否仍可行\n                Yes → Step 8: 回復 current_combination 與 current_sum // 取消選擇，返回上一層\n                No  → Step 9: 再次呼叫 Backtrack(i, current_sum, current_combination) // 允許重複選擇同一數字\n            → Step 10: 從 current_combination 刪除最後一個元素 // 取消選擇\n            → Step 11: 回復 current_sum 減去 candidates[i] // 恢復累積和\n→ End // 回溯完成\n→ Step 12: 呼叫 Backtrack(0, 0, []) // 從第一個候選數開始\n→ Step 13: 回傳 result // 回傳所有組合\n\nBut need to use arrow notation for steps inside loops and recursion. We might use \"→\" for next line, \"Yes →\", \"No →\". But the code lines must be single lines; the indentation and loop indicated by \"→\" each step. We must show decision branches for recursion and loops.\n\nLet's produce more formal pseudo code:\n\nStart // 程式開始執行\n→ Step 1: Input candidates, target // 取得輸入\n→ Step 2: result ← [] // 用來儲存結果\n→ Step 3: 定義 Backtrack(start, sum, combo) // 回溯函式\n→ Decision: sum == target? // 檢查是否完成\n    Yes → Step 4: result ← result ∪ [combo] // 存儲組合\n    No  → Step 5: 從 i = start 到 len(candidates)-1\n        → Step 6: combo.add(candidates[i]) // 加入候選數\n        → Step 7: sum ← sum + candidates[i] // 更新和\n        → Decision: sum > target? // 是否超過\n            Yes → Step 8: combo.removeLast() // 取消選擇\n            No  → Step 9: Backtrack(i, sum, combo) // 允許重複選擇\n        → Step 10: combo.removeLast() // 回復\n        → Step 11: sum ← sum - candidates[i] // 回復和\n→ End // 回溯結束\n→ Step 12: Backtrack(0, 0, []) // 開始回溯\n→ Step 13: Return result // 回傳結果\nEnd // 程式結束\n\nBut we need to ensure each line includes explanation after \"//\". Use \"虛擬碼步驟 // 解釋\". Also we need to use arrow and Decision: as given. Provide arrow for each step.\n\nLet's output with each line separated, start with \"Start\". Each line includes \"虛擬碼步驟\" and comment. Use indentation: lines after Decision: may use \"Yes →\" etc.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input candidates, target // 取得輸入  \n→ Step 2: result ← [] // 用來儲存所有符合條件的組合  \n→ Step 3: 定義 Backtrack(start, sum, combo) // 回溯函式  \n→ Decision: sum == target? // 判斷是否已達到目標和  \n    Yes → Step 4: result ← result ∪ [combo] // 找到一組解，加入結果  \n    No  → Step 5: 從 i = start 到 len(candidates)-1 // 依序嘗試候選數  \n        → Step 6: combo.add(candidates[i]) // 把候選數加入目前組合  \n        → Step 7: sum ← sum + candidates[i] // 更新累積和  \n        → Decision: sum > target? // 檢查和是否已超過目標  \n            Yes → Step 8: combo.removeLast() // 取消選擇，回復狀態  \n            No  → Step 9: Backtrack(i, sum, combo) // 允許重複使用同一數字  \n        → Step 10: combo.removeLast() // 回復組合，準備嘗試下一個候選數  \n        → Step 11: sum ← sum - candidates[i] // 回復累積和  \n→ End // 回溯結束  \n→ Step 12: Backtrack(0, 0, []) // 從第一個候選數開始回溯  \n→ Step 13: Return result // 回傳所有符合條件的組合  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,0,0,1,0]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 0, 0, 1, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"初始化，預先計算前綴和以加速隨機選取\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機挑選索引，概率與權重成正比\"\"\"\n        # 產生 1 到 total 之間的隨機整數\n        target = random.randint(1, self.total)\n        # 找到最小的索引 i 使 prefix_sum[i] >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：兩個 JSON 陣列分別為方法名與參數\n    first_bracket = data.find(']')\n    methods_str = data[:first_bracket+1]\n    args_str = data[first_bracket+2:]  # 跳過 ', '\n\n    methods = json.loads(methods_str)\n    args = json.loads(args_str)\n\n    results = []\n    instance = None\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            instance = Solution(arg[0])  # arg 為 [w]\n            results.append(None)\n        elif method == \"pickIndex\":\n            results.append(instance.pickIndex())\n        else:\n            # 若有其他方法，直接呼叫並存入結果\n            results.append(getattr(instance, method)(*arg))\n\n    # 輸出結果，使用 JSON 格式以符合測試期望\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing pickIndex function given weights array. Steps: precompute prefix sums, total, random number between 0 and total, binary search to find index. Virtual code lines.\n\nWe need to output step-by-step virtual code, each line with explanation.\n\nWe will use Start, End, Decision, etc. Use arrow for flow.\n\nWe must not output actual code. Just virtual steps.\n\nLet's produce:\n\nStart // start\n→ Step 1: 初始化 prefixSum 為空陣列 // create empty prefix sums\n→ Step 2: totalWeight ← 0 // sum\n→ Step 3: 對每個 i 從 0 到 w.length-1 進行\n    → Step 3.1: totalWeight ← totalWeight + w[i] // accumulate weight\n    → Step 3.2: prefixSum[i] ← totalWeight // store cumulative\n→ Step 4: 定義函式 pickIndex() // create function\n    → Step 4.1: 隨機數 r ← random(0, totalWeight) // generate random\n    → Decision: r 與 prefixSum 二分搜尋找最小 index i 使 prefixSum[i] > r\n        Yes → Step 4.2: return i // 找到對應索引\n        No  → Step 4.3: return 0 // fallback\nEnd\n\nBut must use arrow format. Let's structure. Use \"Decision:\" with Yes→ and No→. Use appropriate indentation.\n\nAlso need to mention random function and binary search.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 prefixSum 陣列與 totalWeight 變數 // 初始化累積權重與總權重\n→ Step 2: totalWeight ← 0 // 設定總權重為 0\n→ Step 3: 對於每個 i 從 0 到 w.length-1 進行 // 遍歷權重陣列\n    → Step 3.1: totalWeight ← totalWeight + w[i] // 累加權重\n    → Step 3.2: prefixSum[i] ← totalWeight // 記錄累積值\n→ Step 4: 定義函式 pickIndex() // 開始實作選取邏輯\n    → Step 4.1: r ← 隨機數 0 ~ totalWeight (不含 totalWeight) // 產生隨機數\n    → Decision: 在 prefixSum 中找到最小索引 i 使 prefixSum[i] > r // 二分搜尋\n        Yes → Step 4.2: return i // 回傳對應索引\n        No  → Step 4.3: return 0 // 預備 fallback（理論上不會到此）\nEnd // 程式執行結束\n\nBut we need to ensure each line includes explanation after //. Use arrow with spaces. Use \"→\" arrow at beginning of each line. For decision block indent.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 prefixSum 陣列與 totalWeight 變數 // 初始化累積權重與總權重  \n→ Step 2: totalWeight ← 0 // 設定總權重為 0  \n→ Step 3: 對於每個 i 從 0 到 w.length-1 進行 // 遍歷權重陣列  \n → Step 3.1: totalWeight ← totalWeight + w[i] // 累加權重  \n → Step 3.2: prefixSum[i] ← totalWeight // 記錄累積值  \n→ Step 4: 定義函式 pickIndex() // 開始實作選取邏輯  \n → Step 4.1: r ← 隨機數 0 ~ totalWeight (不含 totalWeight) // 產生隨機數  \n → Decision: 在 prefixSum 中找到最小索引 i 使 prefixSum[i] > r // 二分搜尋  \n  Yes → Step 4.2: return i // 回傳對應索引  \n  No  → Step 4.3: return 0 // 預備 fallback（理論上不會到此）  \nEnd // 程式執行結束"
    }
  ]
}