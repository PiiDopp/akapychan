[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code with each line having explanation. Must use arrow →, Decision, Start, End, Yes →, No →, etc. Need to incorporate try/except.\n\nWe need to produce code lines: Start, input a, input b, Try block: parse ints? Actually user input is string. Use try: convert to int, compute division, else error. But try block may handle ValueError and ZeroDivisionError.\n\nWe need to output errors if not int or divide by zero.\n\nWe need to show step: Try block start, parse int, divide, print result. except ValueError, ZeroDivisionError: print error message. End.\n\nWe need to produce each line. Use virtual code. Use arrows.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者資料 'a' as string // 從使用者取得第一個輸入\n→ Step 2: 輸入使用者資料 'b' as string // 從使用者取得第二個輸入\n→ Step 3: 開啟 Try 區塊 // 開始錯誤處理區\n    → Step 4: 將輸入 'a' 轉換為整數 a // 解析第一個整數\n    → Step 5: 將輸入 'b' 轉換為整數 b // 解析第二個整數\n    → Step 6: 計算 a / b // 執行除法\n    → Step 7: 輸出結果 // 顯示除法結果\n    → End Try // 結束 Try 區塊\n→ Decision: 發生 ValueError 或 ZeroDivisionError? // 檢查是否捕捉到例外\n    Yes → Step 8: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n    No  → // 不會執行此分支\nEnd // 程式執行結束\n\nBut we need to reflect actual try/except structure: Usually we have try: ... except ValueError, ZeroDivisionError: ... . The Decision maybe \"例外發生?\" But we need to structure.\n\nMaybe:\n\nStart // 程式開始執行\n→ Step 1: 讀取字串輸入 a_str // 取得第一個輸入\n→ Step 2: 讀取字串輸入 b_str // 取得第二個輸入\n→ Step 3: Try // 開始嘗試區塊\n    → Step 4: a ← 轉換 a_str 為整數 // 解析為整數\n    → Step 5: b ← 轉換 b_str 為整數 // 解析為整數\n    → Step 6: result ← a / b // 進行除法\n    → Step 7: 輸出 result // 顯示結果\n    → End Try // 結束嘗試區塊\n→ Decision: 是否捕獲到 ValueError 或 ZeroDivisionError? // 檢查是否例外發生\n    Yes → Step 8: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n    No  → // 正常結束\nEnd // 程式結束\n\nBut we need to use arrow and indent. Use nested indent lines.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 a_str // 取得第一個輸入\n→ Step 2: 讀取輸入 b_str // 取得第二個輸入\n→ Step 3: Try // 嘗試區塊\n    → Step 4: a ← int(a_str) // 轉換為整數\n    → Step 5: b ← int(b_str) // 轉換為整數\n    → Step 6: result ← a / b // 進行除法\n    → Step 7: 輸出 result // 顯示結果\n    → End Try // 結束嘗試區塊\n→ Decision: 發生例外? // 檢查是否捕捉到錯誤\n    Yes → Step 8: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n    No  → // 正常結束\nEnd // 程式結束\n\nBut maybe we need to incorporate except: The structure is try ... except ValueError, ZeroDivisionError: ... . Could represent as Decision: 例外? -> Yes or No.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 a_str // 取得第一個輸入 (字串)  \n→ Step 2: 讀取輸入 b_str // 取得第二個輸入 (字串)  \n→ Step 3: Try // 開始錯誤處理區塊  \n  → Step 4: a ← int(a_str) // 嘗試將第一個輸入轉成整數  \n  → Step 5: b ← int(b_str) // 嘗試將第二個輸入轉成整數  \n  → Step 6: result ← a / b // 執行除法運算  \n  → Step 7: 輸出 result // 顯示除法結果  \n  → End Try // 結束 Try 區塊  \n→ Decision: 是否發生 ValueError 或 ZeroDivisionError? // 檢查是否捕捉到例外  \n  Yes → Step 8: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息  \n  No  → // 正常結束，無需額外處理  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    try:\n        # 讀取兩個以空格分隔的輸入並嘗試轉為整數\n        a, b = map(int, input().split())\n        # 執行除法並輸出結果\n        print(a / b)\n    except (ValueError, ZeroDivisionError):\n        # 轉換失敗或除數為 0 時顯示錯誤訊息\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a step-by-step virtual code with explanations. Each line includes code step plus comment. We must use arrow symbols →, Start, End, Decision. Use with and try/except. The code: Start, try open file with open('data.txt','r') as f: readlines, count lines. Print count. except FileNotFoundError: print message. End.\n\nWe need to format as per example. Each line must have \"虛擬碼步驟 [space] // 解釋/說明\". Use \"Start\" as first line. Use arrows. Use Decision: if file open succeed? Actually we will try/except. So maybe Decision: file opened? But with will be inside try. Might use Decision: file exists? But try handles. We can structure:\n\nStart\n→ Decision: 嘗試開啟檔案? (try)\n    Yes → Step: with open('data.txt','r') as f: ...\n    No  → Step: print('找不到檔案！')\nEnd\n\nBut we need try/except. So maybe:\n\nStart\n→ Decision: 嘗試執行? // 進入 try 區塊\n    Yes → Step: try:\n        → Decision: 嘗試開啟檔案? // with open\n            Yes → Step: with open('data.txt','r') as f:\n                → Step: lines = f.readlines()\n                → Step: count = len(lines)\n                → Step: print(count)\n            No → Step: except FileNotFoundError:\n                → Step: print('找不到檔案！')\nEnd\n\nBut we need to show with syntax. Might need to show indentation but keep arrow format.\n\nWe can keep a hierarchical structure.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 嘗試執行? // 進入 try 區塊\n    Yes → Step: try:\n        → Decision: 嘗試開啟檔案? // 使用 with 開啟\n            Yes → Step: with open('data.txt', 'r') as f:\n                → Step: lines = f.readlines() // 讀取所有行\n                → Step: count = len(lines) // 計算行數\n                → Step: print(count) // 輸出行數\n            No → Step: except FileNotFoundError:\n                → Step: print('找不到檔案！') // 檔案不存在時顯示訊息\nEnd // 程式執行結束\n\nBut need arrow for else? Use No for except? Actually Decision: 嘗試開啟檔案? Yes → with; No → except. But except is separate. Maybe use Decision: 讀取成功? But easier: use try: and except. We can show Decision: 讀取成功? but with automatically ensures file closed. But we can mimic.\n\nSimplify: Use Decision: 檔案存在? No → except. Use Yes for with block. But we can restructure:\n\nStart\n→ Decision: 開啟檔案? // 嘗試執行\n    Yes → Step: with open('data.txt', 'r') as f:\n        → Step: lines = f.readlines() // 讀取行\n        → Step: count = len(lines) // 計算\n        → Step: print(count) // 輸出\n    No  → Step: print('找不到檔案！') // 檔案不存在\nEnd\n\nBut we need with and try/except. So we could show try block containing with, then except.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Decision: 嘗試執行? // 進入 try\n    Yes → Step: try:\n        → Decision: 嘗試開啟檔案? // with 開啟\n            Yes → Step: with open('data.txt', 'r') as f:\n                → Step: lines = f.readlines() // 讀取所有行\n                → Step: count = len(lines) // 計算行數\n                → Step: print(count) // 輸出行數\n            No → Step: except FileNotFoundError:\n                → Step: print('找不到檔案！') // 檔案不存在時顯示訊息\nEnd // 程式執行結束\n\nBut we might need to show indentation. Each line we can use arrows for substeps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 嘗試執行? // 進入 try 區塊  \n&nbsp;&nbsp;Yes → Step: try:  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 嘗試開啟檔案? // 使用 with 進行檔案開啟  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step: with open('data.txt', 'r') as f:  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step: lines = f.readlines() // 讀取所有行  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step: count = len(lines) // 計算行數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step: print(count) // 輸出行數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step: except FileNotFoundError:  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step: print('找不到檔案！') // 檔案不存在時顯示訊息  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略標準輸入（符合題目要求）\n    sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f\"檔案共有 {len(lines)} 行\")\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 1 行",
          "success": true,
          "output": "檔案共有 1 行"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. Each line: 虛擬碼步驟 + space + // explanation. Use arrows and decision. Not actual code. Steps: Start, Input a,b,c, compute first expression, output, compute second expression, output, End.\n\nAdd maybe decision? No decision needed. Just linear.\n\nWe'll format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 整數 a、b、c // 從使用者取得三個整數  \n→ Step 2: 計算 a + b * c → result1 // 根據算術優先順序，先乘後加  \n→ Step 3: 輸出 result1 // 顯示 a + b * c 的結果  \n→ Step 4: 計算 (a + b) * c → result2 // 括號改變運算順序，先加後乘  \n→ Step 5: 輸出 result2 // 顯示 (a + b) * c 的結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    a, b, c = map(int, data.split())\n    expr1 = a + b * c\n    expr2 = (a + b) * c\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow, etc. For the requirement: input n and m, output each child gets how many candies, and remaining candies.\n\nSo steps: Start, Step 1: Input n, Step 2: Input m, Step 3: Compute quotient and remainder: perChild = n / m, remainder = n % m, Step 4: Output perChild and remainder. End.\n\nWe might include decision if m==0 to avoid division by zero. Should we include? The requirement didn't mention error handling, but we could add a decision for m==0. Might be optional. Provide as virtual code.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得糖果總數\n→ Step 2: 輸入 m // 取得小朋友人數\n→ Decision: 若 m == 0? // 檢查除數是否為 0\n    Yes → Step 3a: 輸出 '錯誤: 小朋友數為 0' // 防止除以零\n    No → Step 3b: 計算 perChild = n / m // 每人分到的糖果\n         → Step 3c: 計算 remainder = n % m // 未分完的糖果\n→ Step 4: 輸出 perChild, remainder // 顯示結果\nEnd // 程式執行結束\n\nWe should ensure each line has virtual code + // explanation. Provide arrow or indentation accordingly. Use arrows like \"→ Step X:\".\n\nMake sure each line ends with // explanation. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得糖果總數  \n→ Step 2: 輸入 m // 取得小朋友人數  \n→ Decision: 若 m == 0? // 檢查除數是否為 0  \n  Yes → Step 3a: 輸出 '錯誤: 小朋友數為 0' // 防止除以零  \n  No  → Step 3b: 計算 perChild = n / m // 每人分到的糖果  \n    → Step 3c: 計算 remainder = n % m // 未分完的糖果  \n→ Step 4: 輸出 perChild, remainder // 顯示每人分到的糖果數量與剩餘糖果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    if m == 0:\n        # Cannot divide by zero; maybe output 0 each and n left? Or error\n        # We'll output each=0 and left=n to avoid crash.\n        per = 0\n        left = n\n    else:\n        per = n // m\n        left = n % m\n    print(f\"每人={per} 剩下={left}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code. Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows →, Start, End, Decision:. For random module, we need import random, define function roll_dice(n), loop n times generating random int 1-6, append to list, return list.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import random module // 需要使用隨機數產生器\n→ Step 2: Define function roll_dice(n) // 宣告模擬擲 n 次六面骰的函式\n    → Step 3: Initialise empty list results // 用來儲存每一次擲骰的結果\n    → Step 4: For i from 1 to n // 進行 n 次迴圈\n        → Step 5: Roll a dice using random.randint(1,6) // 產生 1~6 的隨機整數\n        → Step 6: Append the roll to results // 將結果存入列表\n    → Step 7: Return results // 回傳所有擲骰結果的列表\nEnd // 程式執行結束",
      "generated_code": "import random\nimport sys\n\n# ----------------------------------------------------\n# 函式：模擬擲 n 次六面骰\n# ----------------------------------------------------\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果的串列。\n    :param n: 擲骰次數\n    :return: 由 n 個 1~6 隨機整數所組成的串列\n    \"\"\"\n    results = []                      # 儲存每一次擲骰的結果\n    for _ in range(n):\n        # random.randint(1, 6) 產生 1~6 的隨機整數\n        results.append(random.randint(1, 6))\n    return results\n\n# ----------------------------------------------------\n# 主程式區塊：從 stdin 讀取程式碼並執行\n# ----------------------------------------------------\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，允許使用者輸入任意 Python 程式碼\n    code = sys.stdin.read()\n\n    # 只將 roll_dice 函式暴露給 exec 的執行環境\n    local_namespace = {\"roll_dice\": roll_dice}\n\n    # 執行使用者輸入的程式碼，任何 print 會直接寫入 stdout\n    exec(code, local_namespace)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,3,4,3,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 3, 4, 3, 3]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step with explanation. Must not output actual code. So we need to write steps like Start, Step 1: Import time module, Step 2: Define function measure_time, etc. Use arrows and decisions? Not necessary, but we can show steps. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrows. Should be clear. Use '→' to indicate subsequent steps. We need to show import, definition, record start time, call func, record end time, calculate elapsed, round, return result. Use End. Also maybe input parameters. Use Step numbering or descriptive. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 Python 標準時間模組  \n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式，接受任意參數  \n→ Step 3: Record start_time = time.perf_counter() // 取得執行前的高解析度時間點  \n→ Step 4: Execute result = func(*args) // 呼叫目標函式並傳遞所有參數  \n→ Step 5: Record end_time = time.perf_counter() // 取得執行後的時間點  \n→ Step 6: Calculate elapsed = end_time - start_time // 兩個時間點相減得到秒數  \n→ Step 7: Round rounded_elapsed = round(elapsed, 3) // 四捨五入到小數點第三位  \n→ Step 8: Return rounded_elapsed // 回傳已四捨五入的秒數  \nEnd // 程式執行結束",
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"\n    Measure the execution time of a function `func` with arguments `*args`.\n    Uses time.perf_counter() for high‑resolution timing and rounds the\n    elapsed time to 3 decimal places.\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取所有輸入，這裡假設輸入的是完整的 Python 程式碼\n    code = sys.stdin.read()\n    # 執行讀入的程式碼，globals() 讓它能使用上面定義的 measure_time\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Provide lines with \"虛擬碼步驟\" and comment. Steps: Start, Input name, height, weight, compute BMI, round to 1 decimal, output. Use virtual arrows. Provide \"Decision:\" maybe not needed. Provide End.\n\nLet's generate.\n\nUse \"Start // 程式開始執行\" etc. Use \"→\" arrow. For input, maybe Step: Read Name. Step: Read Height. Step: Read Weight. Step: Convert height to meter. Step: Compute BMI. Step: Round. Step: Output.\n\nLet's produce lines accordingly.\n\nEnsure each line is: \"虛擬碼步驟 // 解釋\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取姓名 // 從使用者取得姓名字串  \n→ Step 2: 讀取身高 // 從使用者取得身高（公分）  \n→ Step 3: 讀取體重 // 從使用者取得體重（公斤）  \n→ Step 4: 轉換身高到公尺 = 身高 / 100 // 把公分轉成公尺以供 BMI 計算  \n→ Step 5: 計算 BMI = 體重 / (身高_公尺 ^ 2) // 使用 BMI 公開公式  \n→ Step 6: 四捨五入 BMI 到小數點後 1 位 // 使輸出值符合需求  \n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <BMI>\" // 顯示姓名與計算出的 BMI  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    # 讀取使用者姓名\n    name = input()\n    # 讀取身高（公分），並轉為 float\n    height_cm = float(input())\n    # 讀取體重（公斤），並轉為 float\n    weight = float(input())\n\n    # 把身高從公分轉成公尺\n    height_m = height_cm / 100.0\n    # 計算 BMI：體重 / (身高^2)\n    bmi = weight / (height_m ** 2)\n\n    # 四捨五入到小數點後 1 位並印出結果\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code that reads a line containing two integers separated by space, convert to int, compute sum, difference (first - second), product, average (to one decimal). Output format: \"和:<sum> 差:<difference> 積:<product> 平均:<average>\" with spaces between fields.\n\nWe need to output step by step pseudocode lines with comments. Use Start, End, Decision. We need to use arrows and decisions. The program seems simple, but we can include steps: read input, split, parse ints, compute results, format average to 1 decimal, print output. No need for decisions? Maybe decisions for average? Not necessary.\n\nBut we can include an optional decision for formatting average: if average has integer part? Eh.\n\nBut spec says use arrow, Decision. We should use Decision for maybe parsing or type conversion? Could include a Decision: if input line is empty? But not needed.\n\nBut requirement: use arrow (→, Yes→, No→). The example uses Decision with Yes/No.\n\nWe can produce simple pseudocode with no decision; but to satisfy format maybe we include a Decision for reading? But not required. We can still output simple steps.\n\nBut to follow guidelines, we might use Decision: If read successful? Or if average decimal needed? Let's keep simple.\n\nWe'll output each line with \"虛擬碼步驟\" followed by space then comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Read input_line // 讀取使用者輸入的一行文字\n→ Step 2: Split input_line by space into tokens // 將字串以空白分割成兩個片段\n→ Step 3: Convert tokens[0] to int as num1 // 把第一個片段轉成整數\n→ Step 4: Convert tokens[1] to int as num2 // 把第二個片段轉成整數\n→ Step 5: Compute sum = num1 + num2 // 計算兩數之和\n→ Step 6: Compute diff = num1 - num2 // 計算第一個減第二個\n→ Step 7: Compute prod = num1 * num2 // 計算積\n→ Step 8: Compute avg = (num1 + num2) / 2.0 // 計算平均值，使用浮點除法\n→ Step 9: Format avg to one decimal place as avg_str // 將平均值格式化為小數點後 1 位\n→ Step 10: Construct output = \"和:\" + sum + \" 差:\" + diff + \" 積:\" + prod + \" 平均:\" + avg_str // 組合輸出字串\n→ Step 11: Print output // 輸出結果\nEnd // 程式結束\n\nBut we need arrow syntax: \"→ Step X:\" etc. Each line ends with // comment. Use \"Start\" at top. Use \"End\".\n\nWe can optionally include Decision: maybe check if two tokens exist.\n\nBut to keep simple, we can omit decisions. But guidelines: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`).\" It says use arrow and structure. We can include Decision optional. But we can include one: after split, decision whether tokens length == 2. If not, maybe error? But not needed.\n\nMaybe simpler: Use no Decision. But guidelines mention Decision. However not mandatory. Let's maybe include a Decision: If tokens length != 2 then handle error. But still produce output? Not necessary.\n\nWe can produce minimal: no decision.\n\nBut better to satisfy requirement of using Decision. Let's incorporate a Decision after splitting: \"Decision: 是否正確讀取兩個整數?\" Yes → continue, No → exit or error. But we can just skip if not.\n\nLet's do:\n\nStart\n→ Step 1: Read input_line\n→ Step 2: Split input_line by space into tokens\n→ Decision: tokens長度是否為2? // 檢查是否成功取得兩個值\n    Yes → Step 3: Convert tokens[0] to int as num1\n    Yes → Step 4: Convert tokens[1] to int as num2\n    Yes → Step 5: Compute sum...\n    ...\n    No → Step 0: Print \"輸入格式錯誤\" // 若未讀到兩個整數則顯示錯誤並結束\n\nBut we need to maintain arrow and indent? We can indent steps under decision. For No, we can jump to End.\n\nThus produce code accordingly.\n\nLet's craft.\n\nAlso note that in Decision we can specify \"Yes →\" and \"No →\".\n\nOk. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input_line // 讀取使用者輸入的一行文字  \n→ Step 2: Split input_line by space into tokens // 將字串以空白分割成兩個片段  \n→ Decision: tokens長度是否為2? // 檢查是否成功取得兩個值  \n  Yes → Step 3: Convert tokens[0] to int as num1 // 把第一個片段轉成整數  \n  Yes → Step 4: Convert tokens[1] to int as num2 // 把第二個片段轉成整數  \n  Yes → Step 5: Compute sum = num1 + num2 // 計算兩數之和  \n  Yes → Step 6: Compute diff = num1 - num2 // 計算第一個減第二個  \n  Yes → Step 7: Compute prod = num1 * num2 // 計算積  \n  Yes → Step 8: Compute avg = (num1 + num2) / 2.0 // 計算平均值，使用浮點除法  \n  Yes → Step 9: Format avg to one decimal place as avg_str // 將平均值格式化為小數點後 1 位  \n  Yes → Step 10: Construct output = \"和:\" + sum + \" 差:\" + diff + \" 積:\" + prod + \" 平均:\" + avg_str // 組合輸出字串  \n  Yes → Step 11: Print output // 輸出結果  \n  No → Step 12: Print \"輸入格式錯誤\" // 若未讀到兩個整數則顯示錯誤訊息  \nEnd // 程式結束執行",
      "generated_code": "import sys\n\ndef main() -> None:\n    line = sys.stdin.readline().strip()\n    a_str, b_str = line.split()\n    a = int(a_str)\n    b = int(b_str)\n\n    sum_val = a + b\n    diff_val = a - b\n    prod_val = a * b\n    avg_val = (a + b) / 2\n\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations. According to requirement: we should not output actual code, just virtual code. Format: \"虛擬碼步驟 // 解釋\". Use arrows: Start, End, Decision, Yes → etc.\n\nWe need to produce steps for: define Student class with init and show_info; create two instances and call show_info.\n\nWe will produce a step-by-step flow. Probably start -> Define Class -> constructor -> attributes -> define method -> end class definition -> create objects -> call method -> End.\n\nUse arrow notation: \"→ Step 1: ...\" etc.\n\nLet's craft.\n\nRemember: Each line must contain virtual code step + space + comment. Use Start, End, Decision maybe not needed. Use arrow.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Student // 建立一個名為 Student 的類別  \n→ Step 2: 在 Student 類別內部定義 __init__(self, name, score) 方法 // 初始化建構子  \n→ Step 3: 於 __init__ 中將 name 指派給 self.name // 儲存姓名屬性  \n→ Step 4: 於 __init__ 中將 score 指派給 self.score // 儲存分數屬性  \n→ Step 5: 在 Student 類別內部定義 show_info(self) 方法 // 建立顯示資訊的方法  \n→ Step 6: 在 show_info 中輸出 f'{self.name} 的分數是 {self.score}' // 顯示姓名與分數  \n→ Step 7: 結束 Student 類別定義 // 類別結束  \n→ Step 8: 建立 Student 物件 obj1 = Student('Alice', 88) // 第一個學生實例  \n→ Step 9: 建立 Student 物件 obj2 = Student('Bob', 73) // 第二個學生實例  \n→ Step 10: 呼叫 obj1.show_info() // 顯示第一個學生資訊  \n→ Step 11: 呼叫 obj2.show_info() // 顯示第二個學生資訊  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    # 讀取所有輸入以符合「從 stdin 讀取」的要求，實際上不會使用這些資料\n    sys.stdin.read()\n\n    # 建立兩個 Student 物件\n    s1 = Student('Alice', 90)\n    s2 = Student('Bob', 80)\n\n    # 呼叫 show_info() 以輸出資訊\n    s1.show_info()\n    s2.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": true,
          "output": "Alice 的分數是 90\nBob 的分數是 80"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, each line with explanation after //. Must use arrows and structure. Need to create Start, End. Steps: define Animal class with make_sound. Define Dog subclass override. Define Cat subclass override. Instantiate Dog, Cat. Call make_sound for each.\n\nWe should format lines like:\n\nStart // 程式開始執行\n→ Step 1: Define class Animal with method make_sound // ...\n→ Step 2: Define class Dog inherits Animal, override make_sound // ...\n→ Step 3: Define class Cat inherits Animal, override make_sound // ...\n→ Step 4: Instantiate dog = Dog() // Create Dog object\n→ Step 5: Instantiate cat = Cat() // Create Cat object\n→ Step 6: Call dog.make_sound() // 呼叫 Dog 的聲音\n→ Step 7: Call cat.make_sound() // 呼叫 Cat 的聲音\nEnd // 程式結束\n\nWe need to include arrows and perhaps decision? But no decision needed.\n\nMake sure each line includes virtual code step and // explanation. Use Chinese. Provide arrow →. Use no actual code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義父類別 Animal，內含方法 make_sound // 建立基礎類別  \n→ Step 2: 定義子類別 Dog 繼承 Animal，覆寫 make_sound，輸出『汪汪！』 // Dog 的聲音  \n→ Step 3: 定義子類別 Cat 繼承 Animal，覆寫 make_sound，輸出『喵～』 // Cat 的聲音  \n→ Step 4: 建立 Dog 物件 dog = Dog() // 創建 Dog 實例  \n→ Step 5: 建立 Cat 物件 cat = Cat() // 創建 Cat 實例  \n→ Step 6: 呼叫 dog.make_sound() // 執行 Dog 的聲音方法  \n→ Step 7: 呼叫 cat.make_sound() // 執行 Cat 的聲音方法  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Animal:\n    def make_sound(self):\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    def make_sound(self):\n        print('汪汪！')\n\nclass Cat(Animal):\n    def make_sound(self):\n        print('喵～')\n\ndef main():\n    # 讀取所有輸入（此程式不依賴輸入）\n    sys.stdin.read()\n    dog = Dog()\n    cat = Cat()\n    dog.make_sound()\n    cat.make_sound()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code, with each line like \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, Yes→ etc. Provide step by step: input temperature, decisions chain. Ensure each line is one step with comment.\n\nWe need to ensure the format: each line: \"Start // 程式開始執行\" then \"→ Step 1: ... // ...\". Also Decision lines. Ensure arrow and indent for nested decisions? Format shows indent for nested but we can just keep as separate lines with arrow and spaces. We'll produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 temperature // 從使用者取得氣溫數值  \n→ Decision: 如果 temperature < 0? // 檢查氣溫是否低於冰點  \n    Yes → Step 2: 輸出『冰點以下』 // 氣溫低於 0，顯示訊息  \n    No  → Decision: 如果 temperature ≤ 29? // 氣溫不低於冰點，檢查是否在 0~29 區間  \n        Yes → Step 3: 輸出『正常範圍』 // 氣溫在 0~29，顯示訊息  \n        No  → Decision: 如果 temperature ≤ 39? // 氣溫超過 29，檢查是否在 30~39 區間  \n            Yes → Step 4: 輸出『炎熱』 // 氣溫在 30~39，顯示訊息  \n            No  → Step 5: 輸出『極端高溫』 // 氣溫大於等於 40，顯示訊息  \nEnd // 程式執行結束",
      "generated_code": "# 程式根據氣溫輸出相應訊息\ndef solve() -> None:\n    \"\"\"\n    讀取一個整數氣溫，並依規則輸出對應訊息。\n    \"\"\"\n    # 從標準輸入讀取數值，轉成整數\n    temperature = int(input().strip())\n\n    # 判斷氣溫區間並輸出訊息\n    if temperature < 0:\n        print(\"冰點以下\")\n    elif temperature < 30:\n        print(\"正常範圍\")\n    elif temperature < 40:\n        print(\"炎熱\")\n    else:\n        print(\"極端高溫\")\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each with explanation. Start, Step 1 input three ints, Step 2 assign max as first, compare with second, update if larger, compare with third, update if larger, Step 3 output max. Use Decision steps. No actual code. Follow format. Ensure to use arrow symbol for steps. Use Start, End. Use \"→ Step 1: ...\". Provide explanation comment after //.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入第一個整數 a // 從使用者取得第一個數值  \n→ Step 2: 輸入第二個整數 b // 從使用者取得第二個數值  \n→ Step 3: 輸入第三個整數 c // 從使用者取得第三個數值  \n→ Step 4: 設定 max = a // 初始化最大值為第一個數  \n→ Decision: 是否 b > max? // 比較第二個數是否比目前最大值大  \n    Yes → Step 5: max = b // 若是，將 max 更新為 b  \n    No  → Step 6: （不變） // 若否，保持原 max  \n→ Decision: 是否 c > max? // 比較第三個數是否比目前最大值大  \n    Yes → Step 7: max = c // 若是，將 max 更新為 c  \n    No  → Step 8: （不變） // 若否，保持原 max  \n→ Step 9: 輸出 max // 顯示最大的數值  \nEnd // 程式執行結束",
      "generated_code": "def find_max(a: int, b: int, c: int) -> int:\n    \"\"\"\n    找出三個整數中的最大值，不使用 Python 內建的 max()。\n    \"\"\"\n    max_val = a           # 先假設 a 為最大值\n    if b > max_val:       # 比較 b 是否比目前的最大值更大\n        max_val = b\n    if c > max_val:       # 比較 c 是否比目前的最大值更大\n        max_val = c\n    return max_val        # 回傳最終的最大值\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 讀取輸入：期望有三個整數，可能以空白或換行分隔\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        sys.exit()  # 若輸入不足三個數字，直接結束程式\n\n    a, b, c = map(int, data[:3])  # 取前三個數字作為輸入\n    print(find_max(a, b, c))      # 輸出最大值",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. Start, Step: input n, Decision: n>0? maybe. For loop 1 to 50, if i % n ==0 then output. End. Ensure each line ends with // explanation. Use virtual code syntax: Start, → Step, → Decision, Yes→, No→ etc. The output must be in Traditional Chinese. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 從使用者取得要檢查的除數  \n→ Decision: 如果 n 大於 0? // 確保輸入合法的正整數  \n  Yes → Step 2: 為 i 從 1 到 50 進行迴圈 // 逐一檢查 1~50 的數字  \n   → Step 3: 如果 i 乘以 n 等於 i? // 判斷 i 是否能被 n 整除  \n     Yes → Step 4: 輸出 i // i 能被 n 整除，顯示該數字  \n     No  → Step 5: 迴圈繼續 // i 不能被 n 整除，跳過輸出  \n  No → Step 6: 輸出錯誤訊息 // n 必須是正整數，輸入不合法  \nEnd // 程式執行結束",
      "generated_code": "# -*- coding: utf-8 -*-\n\ndef main() -> None:\n    \"\"\"\n    讀取一個正整數 n，列印 1~50 之間所有能被 n 整除的數字，數字之間以空格分隔。\n    \"\"\"\n    try:\n        # 從標準輸入讀取 n\n        n = int(input().strip())\n    except ValueError:\n        # 若輸入不是整數，直接結束\n        return\n\n    if n <= 0:\n        # n 必須為正整數，若不是則不輸出任何東西\n        return\n\n    # 建立所有符合條件的數字列表\n    divisible_numbers = [str(i) for i in range(1, 51) if i % n == 0]\n\n    # 如果列表非空，輸出以空格分隔的數字字串\n    if divisible_numbers:\n        print(' '.join(divisible_numbers))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code steps line by line with explanations. The user demands repeated password prompt until correct. Provide pseudo-code lines using arrows and decisions. Should follow format: each line \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision. Use arrows → and Yes →, No →. Let's craft.\n\nStart // 程式開始執行\n→ Step 1: 定義正確密碼 = 'python123' // 設定目標密碼\n→ Step 2: 初始化輸入變量 = 空 // 準備儲存使用者輸入\n→ Decision: 是否已輸入正確密碼? // 判斷是否終止循環\n    No → Step 3: 輸入 '請輸入密碼:' → 輸入存入變量 // 取得使用者輸入\n    No → Decision: 變量 == 正確密碼? // 檢查輸入是否正確\n        Yes → Step 4: 輸出 '登入成功' // 成功訊息\n        No  → Step 5: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n        No  → Go Back to Decision: 是否已輸入正確密碼? // 迴圈繼續\nEnd // 程式結束\n\nNeed to use arrow syntax: \"→\" for steps, \"Decision:\" for decisions, \"Yes →\", \"No →\". Also \"Start\" and \"End\". The pseudo-code must be line by line. Let's produce. We need to maintain format exactly: Each line ends with space + // explanation. Ensure arrows included. Provide the lines accordingly. We'll need to express the loop. Use \"While\" loop? But we follow arrow style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定目標密碼 = 'python123' // 定義正確的密碼  \n→ Step 2: 輸入變量 ← 空 // 初始化輸入儲存區  \n→ Decision: 變量 == 目標密碼? // 判斷是否已輸入正確密碼  \n  Yes → End // 若已正確則結束程式  \n  No  → Step 3: 輸出 '請輸入密碼:' → 輸入變量 // 讓使用者輸入密碼  \n  No  → Decision: 變量 == 目標密碼? // 再次檢查輸入是否正確  \n    Yes → Step 4: 輸出 '登入成功' // 密碼正確時顯示成功訊息  \n    No  → Step 5: 輸出 '密碼錯誤，請再試一次' // 密碼錯誤時提示訊息  \n    No  → Go Back to Decision: 變量 == 目標密碼? // 回到最初判斷，重新迴圈  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    correct_password = \"python123\"\n    while True:\n        try:\n            pwd = input()\n        except EOFError:\n            break  # 如果沒有更多輸入則結束\n        if pwd == correct_password:\n            print(\"登入成功\")\n            break\n        else:\n            print(\"密碼錯誤，請再試一次\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code with step-by-step lines and comments. Need to produce lines like \"Start // 程式開始執行\" etc. The code: create list 1-5, add element 6, delete second element, output final list.\n\nWe should output lines:\n\nStart // 程式開始執行\n→ Step 1: 建立串列 numbers = [1, 2, 3, 4, 5] // 建立初始串列\n→ Step 2: 新增元素 6 到串列尾端 numbers.append(6) // 在尾端添加 6\n→ Step 3: 刪除索引 1 的元素 numbers.pop(1) // 移除第二個元素\n→ Step 4: 輸出 numbers // 顯示最終結果\nEnd // 程式執行結束\n\nWe must use the required format: each line with 虛擬碼步驟 + space + // 解釋. The arrow \"→\" must be used for steps. Should include Start and End.\n\nWe might include Decision: but no decision needed. Just steps.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立串列 numbers = [1, 2, 3, 4, 5] // 建立初始串列\n→ Step 2: 新增元素 6 到串列尾端 numbers.append(6) // 在尾端添加 6\n→ Step 3: 刪除索引 1 的元素 numbers.pop(1) // 移除第二個元素\n→ Step 4: 輸出 numbers // 顯示最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取輸入，雖然此程式不需要任何實際輸入，但符合「必須讀取 stdin」的規定\n    sys.stdin.read()\n\n    # 建立初始串列\n    nums = [1, 2, 3, 4, 5]\n\n    # 新增元素 6 到串列尾端\n    nums.append(6)\n\n    # 刪除索引 1 的元素（即第 2 個元素）\n    del nums[1]\n\n    # 輸出最終結果\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce line by line virtual code following format. Use arrows. No actual code. Just virtual steps. Use Start, End, Decision if needed. For operations: add, update, remove, discard. Show collection initialization. Use comments after each line. Probably need to mention set literal. Provide explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增元素\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增多個元素\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除元素，若不存在會錯誤\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在元素，無錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合內容\nEnd // 程式執行結束\n\nBut we must maintain format: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow arrow. In example they used \"→ Step 1: ...\" We should follow. Provide \"Step\" maybe. Provide \"Decision\" if needed. But not needed. Also may use \"Decision\" for remove if element may not exist. But we can skip.\n\nWe should include \"Start\" line, then each step with arrow, then \"End\". Use Chinese explanations.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合並加入兩個元素  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange' 到集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'，若不存在會拋錯誤  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不會產生錯誤  \n→ Step 6: 輸出 fruits // 顯示集合的最終內容  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有輸入（即使本題不需要），以符合「不要硬編碼」的規範\n    _ = sys.stdin.read()\n\n    # 建立集合\n    fruits = {'apple', 'banana'}\n\n    # 新增單一元素\n    fruits.add('orange')\n\n    # 一次新增多個元素\n    fruits.update(['grape', 'melon'])\n\n    # 移除已存在的元素\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的元素，會被忽略\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"orange\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'orange', 'apple', 'grape'}\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, each with explanation. Use Start, End, Decision. Provide step-by-step for function is_prime(n). Steps: check n<=1 → False, then loop from 2 to sqrt(n) inclusive, if n % i == 0 → False, after loop → True. Provide function definition step. Let's produce lines.\n\nWe must include \"Start\", \"End\". Use arrow →. We need \"虛擬碼步驟\" like \"Function is_prime(n)\"? maybe \"Step 1: 定義函數 is_prime(n)\" etc. Use Chinese comments.\n\nLet's produce.\n\nLine1: Start // 程式開始\n\nLine2: → Step 1: 定義函數 is_prime(n) // 建立函式\n\nStep 2: → Decision: n <= 1? // 檢查是否小於等於1\n\nYes → Step 3: 回傳 False // 不是質數\n\nNo → Step 4: 初始化 i = 2 // 設定迴圈起始\n\nStep 5: → Decision: i * i <= n? // 判斷是否到平方根\n\nYes → Step 6: Decision: n mod i == 0? // 檢查 i 是否為因數\n\nYes → Step 7: 回傳 False // 找到因數，非質數\n\nNo → Step 8: i = i + 1 // 迭代\n\nNo → Step 9: 回傳 True // 已檢查完，為質數\n\nEnd // 程式結束\n\nBut need to include arrows after each. Let's format:\n\nStart // 程式開始執行\n→ Step 1: 定義函數 is_prime(n) // 建立函式\n→ Decision: n <= 1? // 判斷輸入是否小於等於 1\n    Yes → Step 2: 回傳 False // 不是質數\n    No  → Step 3: 設定 i = 2 // 初始化迴圈變數\n→ Decision: i * i <= n? // 迴圈條件：i 的平方不超過 n\n    Yes → Decision: n mod i == 0? // 檢查 i 是否為 n 的因數\n        Yes → Step 4: 回傳 False // 找到因數，非質數\n        No  → Step 5: i = i + 1 // 將 i 加 1，繼續檢查\n    No  → Step 6: 回傳 True // 迴圈結束，為質數\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟\" plus comment. Provide final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 is_prime(n) // 建立函式  \n→ Decision: n <= 1? // 判斷輸入是否小於等於 1  \n Yes → Step 2: 回傳 False // 不是質數  \n No  → Step 3: 設定 i = 2 // 初始化迴圈變數  \n→ Decision: i * i <= n? // 迴圈條件：i 的平方不超過 n  \n Yes → Decision: n mod i == 0? // 檢查 i 是否為 n 的因數  \n  Yes → Step 4: 回傳 False // 找到因數，非質數  \n  No  → Step 5: i = i + 1 // 將 i 加 1，繼續檢查  \n No  → Step 6: 回傳 True // 迴圈結束，為質數  \nEnd // 程式結束",
      "generated_code": "# 判斷是否為質數的函式\ndef is_prime(n):\n    # 1 以下不是質數\n    if n <= 1:\n        return False\n    # 只需檢查到 n 的平方根即可\n    for i in range(2, int(n ** 0.5) + 1):\n        # 若有因數，則不是質數\n        if n % i == 0:\n            return False\n    # 檢查完都沒有因數，則是質數\n    return True\n\n# ------------------------------------------------------------\n# 主程式：從標準輸入讀取所有程式碼並執行\n# ------------------------------------------------------------\nif __name__ == \"__main__\":\n    import sys\n    # 讀取整個輸入 (可能包含多行程式碼)\n    code = sys.stdin.read()\n    # 使用 exec 執行讀取到的程式碼，這樣就能呼叫 is_prime 並印出結果\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": true,
          "output": "True\nFalse"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations. Must not use sum(). So we iterate to sum. Accept variable args *scores. Then compute average = total / count. Then round to 2 decimals. We'll use round function? Allowed. Round to 2 decimals. Then return average. Must include Start, End, Decision maybe. Also need function definition. Use \"→\" arrow. Provide each line.\n\nLet's structure:\n\nStart\n→ Function: calc_avg(scores) // define function taking variable arguments\n→ Step 1: total = 0 // initialize sum\n→ Step 2: count = 0 // initialize counter\n→ Step 3: Decision: 如果 scores 為空? // if no scores\n    Yes → Return None // or maybe 0? but unspecified; we can return 0\n    No  → Loop: for score in scores // iterate\n        → total = total + score // accumulate\n        → count = count + 1 // increment\n→ Step 4: average = total / count // compute average\n→ Step 5: average_rounded = round(average, 2) // round to 2 decimals\n→ Return average_rounded\nEnd\n\nWe need to use arrow for function start maybe \"Start\" then \"→ Function: calc_avg(*scores)\"? Actually we need to include *scores syntax. Virtual code style: \"→ Function: calc_avg(*scores)\" fine.\n\nLet's produce each line with comment.\n\nNote: The function may need to handle zero count to avoid division by zero. We'll just check if count == 0.\n\nAdd Decision: if count == 0? Yes -> return 0 or None. We'll do return 0.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Function: calc_avg(*scores) // 定義接受任意多個分數的函式\n→ Step 1: total = 0 // 初始化總分\n→ Step 2: count = 0 // 初始化分數數量\n→ Decision: 如果 scores 為空? // 檢查是否有傳入分數\n    Yes → Return 0 // 沒有分數時回傳 0\n    No  → Loop: for score in scores // 逐一遍歷所有分數\n        → total = total + score // 累加分數\n        → count = count + 1 // 分數計數器加一\n→ Step 3: average = total / count // 計算平均值\n→ Step 4: average_rounded = round(average, 2) // 四捨五入到小數點後 2 位\n→ Return average_rounded // 回傳處理後的平均值\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef calc_avg(*scores):\n    \"\"\"計算多個分數的平均值，四捨五入到小數點後兩位。\"\"\"\n    total = 0\n    count = 0\n    for s in scores:\n        total += s\n        count += 1\n    if count == 0:          # 防止除以零\n        return 0\n    return round(total / count, 2)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入的內容\n    code = sys.stdin.read()\n    # 在包含 calc_avg 的命名空間下執行輸入的程式碼\n    exec(code, globals())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for building a list 1-20, then list comprehension to filter evens and square, then output the result. They want step-by-step virtual code lines, with comments. Use Start, End, Decision etc. Should not output actual code. Just pseudocode steps. Use arrow notation. Each line: \"虛擬碼步驟 // 解釋\". Should be clear. Let's create steps:\n\nStart\n→ Step 1: 建立空列表 numbers // 用於儲存 1 到 20 的整數\n→ Step 2: 為 i 從 1 到 20 進行迴圈 // 填入 numbers\n    → Append i to numbers // 加入整數\n→ Step 3: 使用列表生成式產生 new_list // 篩選偶數並平方\n    → new_list = [i * i for i in numbers if i % 2 == 0] // 每個偶數平方\n→ Step 4: 輸出 new_list // 顯示結果\nEnd\n\nBut must use \"虛擬碼步驟\" prefix? The example shows \"Step 1: ...\" etc. So we produce each line like:\n\nStart // 程式開始執行\n→ Step 1: 建立空列表 numbers // ...\n... etc.\n\nYes.\n\nEnsure each line ends with comment. Use \"Decision:\" only if needed. Not needed here.\n\nWe must include arrow \"→\" before each step. Use \"Start\" and \"End\".\n\nLet's craft.\n\nUse \"→\" each step. For loops use indentation. They used \"→\" before each step. For nested steps, use indentation.\n\nWe must maintain \"逐行\" output.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空列表 numbers // 用於儲存 1 到 20 的整數  \n→ Step 2: 為 i 從 1 到 20 進行迴圈 // 逐一將整數加入列表  \n  → Step 2.1: 將 i 加入 numbers // Append i to numbers  \n→ Step 3: 使用列表生成式產生 new_list // 篩選偶數並平方  \n  → Step 3.1: new_list = [i * i for i in numbers if i % 2 == 0] // 每個偶數平方後存入新列表  \n→ Step 4: 輸出 new_list // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    _ = sys.stdin.read()  # read and ignore any input\n    nums = list(range(1, 21))\n    result = [n * n for n in nums if n % 2 == 0]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with comments. Steps: Start, define list, filter, map, output. Use filter() lambda, map() lambda. Use End. Also we should show steps of filter and map with lambda. Provide explanations. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: numbers ← [3, 7, 10, 15, 20] // 初始化數字列表  \n→ Step 2: divisible_by_five ← filter( λ x: x % 5 == 0, numbers ) // 篩選能被 5 整除的數字  \n→ Step 3: multiplied ← map( λ x: x * 10, divisible_by_five ) // 將篩選結果乘以 10  \n→ Step 4: result ← list( multiplied ) // 將 map 物件轉成列表  \n→ Step 5: print( result ) // 輸出最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有標準輸入（即使不會被使用），符合「從 stdin 讀取」的要求\n    sys.stdin.read()\n\n    # 依照需求建立固定的數字列表\n    numbers = [3, 7, 10, 15, 20]\n\n    # 1. 使用 filter() 搭配 lambda 篩選能被 5 整除的數字\n    divisible_by_five = filter(lambda x: x % 5 == 0, numbers)\n\n    # 2. 使用 map() 將篩選後的數字乘以 10\n    multiplied = map(lambda x: x * 10, divisible_by_five)\n\n    # 把 map 物件轉成列表，方便輸出\n    result = list(multiplied)\n\n    # 輸出最終結果列表\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. According to format, each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision: etc. The task: create dictionary, dump to file, load, print name and city. No actual code. Provide virtual steps.\n\nWe should produce something like:\n\nStart // program starts\n→ Step 1: Define dictionary data = {...} // create dictionary\n→ Step 2: Open file data.json in write mode // open file\n→ Step 3: Use json.dump(data, file) // write dict to file\n→ Step 4: Close file // close\n→ Step 5: Open file data.json in read mode // open\n→ Step 6: Use json.load(file) → assign to loaded_data // read back\n→ Step 7: Print loaded_data['name'] // output name\n→ Step 8: Print loaded_data['city'] // output city\nEnd // program ends\n\nShould also include maybe a decision for checking file existence? Not necessary. But we can just straightforward steps.\n\nMake sure each line has \"虛擬碼步驟\" not actual code but pseudo. Use arrow lines. Should we use \"Step 1:\" or \"Step 1:\" as part of code. According to example: \"Step 1: 輸入使用者數字\". So okay.\n\nWe also need to mention arrow lines for file open? Use \"→ Step 2: 打開文件 data.json 為寫入模式\" etc. For closing file we might skip or include. For readability we can skip closing but mention it.\n\nAlso we might mention that we use json library.\n\nSo produce final answer with lines.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立資料結構  \n→ Step 2: 打開檔案 data.json 為寫入模式 // 準備寫入 JSON  \n→ Step 3: 使用 json.dump(data, file) 將字典寫入檔案 // 將資料序列化為 JSON  \n→ Step 4: 關閉檔案 // 釋放檔案資源  \n→ Step 5: 打開檔案 data.json 為讀取模式 // 準備讀取 JSON  \n→ Step 6: 使用 json.load(file) 讀取檔案並存入 loaded_data // 反序列化回字典  \n→ Step 7: 輸出 loaded_data['name'] // 顯示 name 欄位  \n→ Step 8: 輸出 loaded_data['city'] // 顯示 city 欄位  \nEnd // 程式執行結束",
      "generated_code": "import json\nimport sys\n\ndef main():\n    # 讀取 stdin，雖不使用但符合「通用」需求\n    sys.stdin.read()\n\n    # 建立字典\n    data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\n    # 寫入 JSON 檔\n    with open('data.json', 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n\n    # 讀取 JSON 檔\n    with open('data.json', 'r', encoding='utf-8') as f:\n        result = json.load(f)\n\n    # 輸出姓名與城市\n    print('姓名：', result['name'])\n    print('城市：', result['city'])\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. No actual code, just pseudocode lines with comments. Use Start, End, Decision, etc. Must include each line as \"虛擬碼步驟 // 解釋\". Provide each step. Use arrow characters. Let's outline: Start, import modules, define function fetch_rate, use requests.get, parse JSON, get TWD. Then Tkinter GUI: create root, label, button. Button command: call fetch_rate and update label. mainloop. End.\n\nNeed to maintain structure and arrow directions. Use \"→\" to denote progression. For decision branches? We may have simple error handling: if request fails, show error. So Decision: if response.status ok? Yes, update label. No, show error. So include that.\n\nLet's write. Ensure each line ends with // explanation. Use \"Start // 程式開始執行\". Then \"→ Step 1: Import requests and tkinter // 取得需要的模組\". Then \"→ Step 2: 定義函式 fetch_rate() // 用於取得匯率\". Inside fetch_rate: \"→ Step 2.1: 送出 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得匯率資料\". \"→ Step 2.2: Decision: 如果回應成功? // 檢查 HTTP 狀態碼\". Then Yes and No branches.\n\nWe'll do: Yes → Step 2.3: 解析 JSON // 取出 data['rates']['TWD'] // 取得 TWD 匯率. No → Step 2.4: 返回 None // 表示失敗.\n\nReturn rate.\n\nThen GUI steps: Step 3: Create root window. Step 4: Create label to show rate. Step 5: Create button labeled \"更新匯率\" with command update_rate. Step 6: 定義 update_rate() // 取得匯率並更新 label. Inside: \"→ Step 6.1: rate = fetch_rate()\". \"→ Step 6.2: Decision: 如果 rate 不是 None? // 檢查是否成功\". Yes → Step 6.3: Update label text to f\"USD/TWD: {rate}\". No → Step 6.4: Update label text to \"取得匯率失敗\". End.\n\nThen Step 7: 呼叫 root.mainloop().\n\nEnd.\n\nMake sure to include \"End // 程式執行結束\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter // 取得需要的模組  \n→ Step 2: 定義函式 fetch_rate() // 用於取得匯率  \n  → Step 2.1: 送出 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得匯率資料  \n  → Step 2.2: Decision: 如果回應成功? // 檢查 HTTP 狀態碼  \n    Yes → Step 2.3: 解析 JSON // 取出 data['rates']['TWD'] // 取得 TWD 匯率  \n     → Step 2.3.1: 回傳 rate // 返回匯率值  \n    No  → Step 2.4: 回傳 None // 表示取得失敗  \n→ Step 3: 創建 Tkinter 根視窗 root // 初始化 GUI 視窗  \n→ Step 4: 建立 label 用於顯示匯率 // 初始文字可為空  \n  → Step 4.1: Label = tkinter.Label(root, text=\"\")  \n→ Step 5: 建立按鈕 \"更新匯率\" 並指定 command = update_rate // 觸發匯率更新  \n  → Step 5.1: Button = tkinter.Button(root, text=\"更新匯率\", command=update_rate)  \n→ Step 6: 定義函式 update_rate() // 取得並更新匯率顯示  \n  → Step 6.1: rate = fetch_rate() // 取得最新匯率  \n  → Step 6.2: Decision: 如果 rate 不是 None? // 檢查是否成功  \n    Yes → Step 6.3: 更新 label 文本為 f\"USD/TWD: {rate}\" // 顯示匯率  \n    No  → Step 6.4: 更新 label 文本為 \"取得匯率失敗\" // 顯示錯誤訊息  \n→ Step 7: 佈局並顯示 widget // 放置 label 與按鈕並顯示視窗  \n  → Step 7.1: Label.pack()  \n  → Step 7.2: Button.pack()  \n→ Step 8: 呼叫 root.mainloop() // 開始事件循環  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"\n    從 exchangerate-api 取得 USD 對 TWD 的匯率。\n    返回匯率數值（float）或 None 表示失敗。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef main():\n    \"\"\"\n    主程式：先從標準輸入讀取指令，\n    若指令包含「更新匯率」，則呼叫 fetch_rate()\n    並將結果列印到標準輸出。\n    接著啟動 tkinter GUI，提供「更新匯率」按鈕\n    讓使用者可以在視窗中再次查詢。\n    \"\"\"\n    # 讀取 stdin（如果有輸入）\n    input_line = sys.stdin.readline().strip()\n\n    # 如果輸入包含「更新匯率」，則立即取得並輸出匯率\n    if \"更新匯率\" in input_line:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # --------- tkinter GUI ----------\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_label():\n        \"\"\"\n        按鈕觸發函式：取得最新匯率並更新標籤文字。\n        \"\"\"\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update_label).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for determining if a string is an additive number. Steps: Start, iterate splits for first two numbers, backtracking recursion to check rest. Provide step-by-step pseudocode with decisions.\n\nWe should output line by line: \"Start // 程式開始執行\", then \"→ Step 1: 定義輸入字符串 s // ...\" etc. Use \"Decision:\" for conditions, arrow \"Yes →\", \"No →\". Use \"End\".\n\nWe must not output actual code. So we just give a structured plan.\n\nWe must handle leading zeros. Provide explanation.\n\nOk, produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 取得待判斷的數字字串  \n→ Decision: s 的長度 < 3? // 加法序列至少需要三個數字  \n  Yes → Step 2: 回傳 false // 字串太短，直接結束  \n  No  → Step 3: 初始化 flag 為 false // 用來記錄是否找到有效加法序列  \n\n→ Step 4: 循環 i 從 1 到 len(s)-2 // i 為第一個數字的結束位置  \n  Decision: s[0] 為 '0' 且 i > 1? // 首位不能有前導零  \n   Yes → Step 5: 跳過此 i // 第一個數字若以 0 開頭且長度>1，無效  \n   No  → Step 6: 循環 j 從 i+1 到 len(s)-1 // j 為第二個數字的結束位置  \n    Decision: s[i] 為 '0' 且 j-i > 1? // 第二個數字同樣檢查前導零  \n     Yes → Step 7: 跳過此 j // 第二個數字若以 0 開頭且長度>1，無效  \n     No  → Step 8: 解析 num1 = s[0:i]，num2 = s[i:j] // 取前兩個數字  \n      → Step 9: 呼叫 Recursion(i, j, num1, num2) // 從第三個位置開始檢查  \n\n→ Step 10: Recursion(prev_start, curr_start, num1, num2)  \n  Decision: curr_start == len(s)? // 已走到字串結尾  \n   Yes → Step 11: flag = true // 成功找到加法序列  \n    No → Step 12: sum = num1 + num2 // 計算下一個數字  \n     Decision: s[curr_start:].開頭是否等於 sum? // 字串是否包含此和  \n      Yes → Step 13: Recursion(curr_start, curr_start+len(sum), num2, sum) // 進一步遞迴  \n      No  → Step 14: return // 這條路徑失敗，回溯  \n\n→ Step 15: 循環結束後  \n  Decision: flag 為 true? // 是否找到合法序列  \n   Yes → Step 16: 回傳 true // 結果為真  \n   No  → Step 17: 回傳 false // 未找到任何合法序列  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        # 遍歷所有可能的第一個和第二個數字切分\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                num1, num2 = num[:i], num[i:j]\n\n                # 前導零檢查\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n                    continue\n\n                k = j\n                # 循環檢查後續數字是否符合加法規則\n                while k < n:\n                    sum_str = str(int(num1) + int(num2))\n                    if not num.startswith(sum_str, k):\n                        break\n                    k += len(sum_str)\n                    num1, num2 = num2, sum_str\n                if k == n:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取輸入，移除可能存在的雙引號與空白\n    raw_input = sys.stdin.read().strip()\n    raw_input = raw_input.strip('\"').strip(\"'\")\n    solution = Solution()\n    result = solution.isAdditiveNumber(raw_input)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode739.json",
    "problem_index_in_file": 0,
    "title": "Daily Temperatures",
    "description_snippet": "Given an array of integers temperatures represents the daily temperatures, return an array answer su...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for \"daily temperatures\" problem. Provide step-by-step algorithm using stack or similar. Use virtual code lines with explanation after //.\n\nEnsure Start, End, Decision, etc.\n\nLet's craft algorithm:\n\n- Input: array temperatures.\n\n- Output: array answer same length.\n\n- Use stack storing indices of days with unresolved warmer temperatures.\n\n- Initialize answer array with zeros.\n\n- For each day i from 0 to n-1:\n\n    - While stack not empty and temperatures[i] > temperatures[stack.top()]:\n\n        - poppedIndex = stack.pop()\n\n        - answer[poppedIndex] = i - poppedIndex\n\n    - Push i onto stack.\n\n- After loop, remaining indices in stack keep answer 0.\n\nThis is typical.\n\nNow produce virtual code lines with explanation. Use Start, End. Each line has \"→ Step X:\".\n\nAlso Decision lines for while loop. Also \"If\" decisions.\n\nLet's write lines:\n\nStart\n\n→ Step 1: 初始化 answer 為全 0 // 建立答案陣列，初始值為 0\n\n→ Step 2: 初始化 stack 為空 // 用來存未解決的天數索引\n\n→ Step 3: 迭代 i 從 0 到 n-1 // 遍歷每一天\n\n    → Decision: 若 stack 非空 且 temperatures[i] > temperatures[stack.top()]? // 判斷是否有更暖的天\n\n        Yes →\n\n            → Step 4: poppedIndex = stack.pop() // 取出待解決的天\n\n            → Step 5: answer[poppedIndex] = i - poppedIndex // 計算等待天數\n\n            → Decision: 仍滿足條件? // 可能有多個待解決\n\n                Yes → 回到 Step 4 // 重複\n\n                No → // 退出 while\n\n        No → // 無更暖天，進行下一步\n\n    → Step 6: stack.push(i) // 把今天的索引放進待解決集合\n\nEnd\n\nWe must produce each line with \"→\" and \"Decision\" lines properly.\n\nAlso include indentation lines? The example shows indentation for nested decisions. We can indent using 4 spaces maybe.\n\nNeed to include \"Start\" and \"End\" lines. Use \"→ Step 1:\" etc.\n\nAlso include \"Decision:\" lines with Yes→ and No→.\n\nMake sure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 answer 為全 0 // 建立答案陣列，初始值為 0  \n→ Step 2: 初始化 stack 為空 // 用來存未解決的天數索引  \n→ Step 3: 迭代 i 從 0 到 n-1 // 遍歷每一天  \n  Decision: 若 stack 非空 且 temperatures[i] > temperatures[stack.top()]? // 判斷是否有更暖的天  \n   Yes → Step 4: poppedIndex = stack.pop() // 取出待解決的天  \n    Step 5: answer[poppedIndex] = i - poppedIndex // 計算等待天數  \n    Decision: 仍滿足條件? // 可能有多個待解決  \n     Yes → Step 4 // 重複處理下一個待解決天  \n     No → // 離開 while 迴圈  \n   No → // 無更暖天，進行下一步  \n  Step 6: stack.push(i) // 把今天的索引放進待解決集合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    \"\"\"\n    計算每天等待多少天才能遇到更暖的天氣。\n    使用單調遞減棧 (stack) 來追蹤尚未找到更暖天氣的索引。\n    \"\"\"\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        res = [0] * n          # 初始化答案為 0\n        stack = []             # 栈中存放未解決的天數索引，堆疊結構\n        for i in range(n):\n            # 當今天的溫度高於棧頂索引對應的溫度時，說明找到了更暖的天氣\n            while stack and temperatures[i] > temperatures[stack[-1]]:\n                idx = stack.pop()\n                res[idx] = i - idx   # 計算等待天數\n            stack.append(i)          # 將今天的索引放入棧中等待未來更暖天氣\n        # 其餘棧中的索引對應的天氣永遠找不到更暖天氣，答案保持 0\n        return res\n\ndef main():\n    \"\"\"\n    讀取標準輸入，預期是一行 Python 列表字串，例如：\n    [73,74,75,71,69,72,76,73]\n    解析後計算結果並輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 使用 literal_eval 安全解析輸入字串為列表\n    temperatures = ast.literal_eval(data)\n    result = Solution().dailyTemperatures(temperatures)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[73,74,75,71,69,72,76,73]",
          "expected_output": "[1,1,4,2,1,1,0,0]",
          "success": true,
          "output": "[1, 1, 4, 2, 1, 1, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "[30,40,50,60]",
          "expected_output": "[1,1,1,0]",
          "success": true,
          "output": "[1, 1, 1, 0]"
        },
        {
          "example_index": 2,
          "input": "[30,60,90]",
          "expected_output": "[1,1,0]",
          "success": true,
          "output": "[1, 1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that transform a Unix path to canonical path. Provide line-by-line virtual steps with explanation comments. Use Start, Decision, arrow, etc. Must be in Traditional Chinese. No actual code. Just pseudocode structure.\n\nWe need to show steps:\n\nStart\n→ Input path // get path string\n→ Split path by '/' // get components\n→ Initialize stack // to hold valid dirs\n→ For each component in components:\n   Decision: component empty or '.'? // skip\n      Yes → continue\n      No → Decision: component == '..'? // go up\n         Yes → If stack not empty, pop\n         No → Push component onto stack // valid dir name\n→ After loop, build result:\n   Decision: stack empty? // root\n      Yes → result = \"/\"\n      No → result = \"/\" + join stack with \"/\"\n→ Output result\nEnd\n\nAdd comments each line.\n\nAlso mention handling multiple slashes (empty components). Provide step for join.\n\nOk produce each line with virtual code and comment.\n\nNeed to be careful: \"→ Decision: ...\" lines with indentation.\n\nLet's craft.\n\nAlso include loop structure: \"→ For each component in components:\".\n\nAlso include end of loop: \"→ End For\".\n\nLet's create.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input path // 取得使用者輸入的絕對路徑  \n→ Split path by '/' // 用斜線分割路徑為各個片段  \n→ Initialize stack // 用於儲存合法的目錄名稱  \n\n→ For each component in components: // 逐一處理每個片段  \n  Decision: component is empty or component == '.'? // 空白或單點代表當前目錄  \n   Yes → Continue // 跳過此片段  \n   No → Decision: component == '..'? // 雙點代表上層目錄  \n    Yes → Decision: stack not empty? // 若堆疊非空則可回到上層  \n     Yes → Pop from stack // 移除上一個目錄  \n     No → Continue // 若已在根目錄則不做任何事  \n    No → Push component onto stack // 其餘情況視為合法目錄名稱，加入堆疊  \n→ End For // 完成所有片段的處理  \n\n→ Decision: stack is empty? // 判斷是否還在根目錄  \n  Yes → result = \"/\" // 若堆疊空，結果為根目錄  \n  No → result = \"/\" + Join(stack, \"/\") // 否則以 '/' 連結堆疊中的目錄  \n\n→ Output result // 產生簡化後的標準路徑  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef simplify_path(path: str) -> str:\n    \"\"\"\n    將給定的 Unix 風格絕對路徑簡化為標準化路徑。\n    \"\"\"\n    stack = []\n    for part in path.split('/'):\n        if part == '' or part == '.':\n            continue                      # 空字串或 '.' 略過\n        elif part == '..':\n            if stack:\n                stack.pop()              # 返回上一層\n        else:\n            stack.append(part)           # 正常目錄名稱加入堆疊\n    return '/' + '/'.join(stack)          # 重組路徑\n\ndef main():\n    \"\"\"\n    主入口：從標準輸入讀取路徑字串，進行簡化並輸出結果。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 取出第一個雙引號之間的內容作為路徑\n    m = re.search(r'\"(.*?)\"', data)\n    if m:\n        path = m.group(1)\n    else:\n        # 若輸入格式不同，直接使用整個字串\n        path = data.strip()\n    result = simplify_path(path)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "/home"
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "/home/foo"
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "/home/user/Pictures"
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "/"
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "/.../b/d"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with each line like \"Start // 程式開始執行\" etc. We need to generate algorithm steps for solving the problem: return k most frequent elements from array. Use frequency map, maybe min-heap or sort. Provide steps. Each line: virtual code step + space + // explanation.\n\nUse arrows: \"→\", \"Yes →\", \"No →\". Use Start and End.\n\nWe need to produce step-by-step algorithm. Use virtual code not actual code. Provide decision points etc.\n\nLet's design:\n\nStart\n→ Step 1: 建立頻率雜湊表 // Count frequency of each number\n→ Step 2: 建立一個空的最小堆（容量為 k） // min-heap to keep top k\n→ Decision: 遍歷頻率表每個 (number, freq) // iterate over map\n    → Step 3: 若堆大小 < k，將 (freq, number) 推入堆 // add if not full\n    → Decision: 否則 // if heap full\n        → Step 4: 若 freq > 堆頂頻率，將堆頂彈出，並將 (freq, number) 推入堆 // replace lower freq\n→ Step 5: 建立結果清單 // extract numbers from heap\n→ Decision: 是否需要逆序 // maybe output any order, just output\n    → Step 6: 返回結果 // return list\nEnd\n\nBut need more detailed steps with decisions. Use \"Decision:\" lines with Yes/No arrow.\n\nLet's produce final answer.\n\nAlso include maybe \"Step X: ...\" but format: \"Step X:\".\n\nOk. Provide each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的頻率雜湊表 // 用於統計每個數字出現的次數  \n→ Step 2: 遍歷輸入陣列 nums，對每個數字更新頻率表 // 形成 num → 次數 的對應  \n→ Step 3: 建立一個容量為 k 的最小堆 // 用於儲存目前頻率最高的 k 個數字  \n→ Decision: 遍歷頻率雜湊表中的每個 (number, freq) // 逐個處理頻率資料  \n    → Step 4: 若 堆 的大小 < k，將 (freq, number) 推入堆 // 堆還沒滿時直接加入  \n    → Decision: 否則 // 堆已滿時需要比較  \n        → Step 5: 若 freq > 堆頂的頻率，彈出堆頂並將 (freq, number) 推入堆 // 用更高頻率替換低頻  \n→ Step 6: 建立一個空的結果清單 // 用於儲存最終的 k 個最頻繁數字  \n→ Step 7: 從堆中彈出所有元素，將其 number 加入結果清單 // 堆中即為所需的 k 個數字  \n→ Step 8: 返回結果清單 // 結果順序不重要，直接輸出即可  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        Return the k most frequent elements in nums.\n        Uses a min-heap to keep track of the top k elements.\n        \"\"\"\n        # Count frequency of each number\n        freq = Counter(nums)\n        # Retrieve k items with largest frequency\n        top_k = heapq.nlargest(k, freq.items(), key=lambda x: x[1])\n        # Extract just the numbers\n        return [item for item, _ in top_k]\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse input string of the form:\n    'nums = [...], k = ...'\n    and return the corresponding nums list and k integer.\n    \"\"\"\n    parts = [p.strip() for p in input_str.split(',') if p.strip()]\n    nums = None\n    k = None\n    for part in parts:\n        if part.startswith('nums'):\n            nums = ast.literal_eval(part.split('=', 1)[1].strip())\n        elif part.startswith('k'):\n            k = int(part.split('=', 1)[1].strip())\n    if nums is None or k is None:\n        raise ValueError(\"Input must contain both 'nums' and 'k'\")\n    return nums, k\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.topKFrequent(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpqr0t1j1j.py\", line 40, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqr0t1j1j.py\", line 30, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp13gi1zur.py\", line 40, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp13gi1zur.py\", line 30, in parse_input\n    nums = ast.literal_eval(part.split('=', 1)[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode752.json",
    "problem_index_in_file": 0,
    "title": "Open the Lock",
    "description_snippet": "You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3',...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for BFS solving lock problem. Provide line-by-line with explanation. Let's design steps: Start, handle deadends set, visited set, queue. BFS loop, check target, generate neighbors by incrementing/decrementing each wheel. Use wrap-around. Return steps count or -1.\n\nWe'll produce steps with arrow. Use Decision for checks.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 deadEndSet ← Set(deadends) // 把所有死端轉成集合以便 O(1) 查詢  \n→ Step 2: 初始化 visitedSet ← Set() // 追蹤已探訪的鎖碼  \n→ Step 3: 初始化 queue ← Queue() // 用來存放 (currentCode, turns)  \n→ Step 4: Enqueue ('0000', 0) 到 queue // 從初始碼開始探索  \n→ Step 5: Add '0000' 到 visitedSet // 標記已訪問  \n\n→ Decision: queue 是否空？  \n    Yes → End // 所有可能碼已探索完畢，無法到達目標，回傳 -1  \n    No  → Step 6: Dequeue (cur, step) ← queue.front() // 取出隊首元素  \n→ Decision: cur 是否在 deadEndSet？  \n    Yes → Step 7: Continue // 若是死端，跳過此節點  \n    No  → Decision: cur 是否等於 target？  \n        Yes → End // 找到目標，回傳步數 step  \n        No  → Step 8: 為 i 從 0 到 3 做  \n            → Step 9: 生成 nextPlus ← 把 cur 的第 i 位加 1 (循環 9->0)  \n            → Step 10: 若 nextPlus 不在 visitedSet 且不在 deadEndSet  \n                → Step 11: Enqueue (nextPlus, step+1)  \n                → Step 12: Add nextPlus 到 visitedSet  \n            → Step 13: 生成 nextMinus ← 把 cur 的第 i 位減 1 (循環 0->9)  \n            → Step 14: 若 nextMinus 不在 visitedSet 且不在 deadEndSet  \n                → Step 15: Enqueue (nextMinus, step+1)  \n                → Step 16: Add nextMinus 到 visitedSet  \n→ Step 17: 重複循環 (回到 Decision: queue 是否空？)  \nEnd // 程式執行結束，若未回傳則返回 -1 (不可開鎖)",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import deque\n\nclass Solution:\n    def openLock(self, deadends, target):\n        \"\"\"\n        Use BFS to find the minimum number of turns.\n        deadends: list of forbidden codes\n        target:  string of target code\n        \"\"\"\n        dead = set(deadends)\n        # 若起始碼即為死端，直接無法開鎖\n        if '0000' in dead:\n            return -1\n\n        queue = deque([('0000', 0)])\n        visited = {'0000'}\n\n        while queue:\n            state, steps = queue.popleft()\n            if state == target:\n                return steps\n\n            # 產生四個座輪的相鄰兩個碼\n            for i in range(4):\n                digit = int(state[i])\n                for move in (-1, 1):\n                    new_digit = (digit + move) % 10\n                    new_state = state[:i] + str(new_digit) + state[i+1:]\n                    if new_state not in dead and new_state not in visited:\n                        visited.add(new_state)\n                        queue.append((new_state, steps + 1))\n\n        return -1  # 無法到達目標碼\n\ndef parse_input(text):\n    \"\"\"\n    從輸入文字中抽取 deadends 與 target。\n    允許的格式示例：\n    'deadends = [\"0201\",\"0101\"], target = \"0202\"'\n    \"\"\"\n    # 找出 deadends 的列表\n    dead_match = re.search(r'deadends\\s*=\\s*(\\[[^\\]]*\\])', text)\n    if not dead_match:\n        raise ValueError(\"無法找到 deadends 列表\")\n    dead_str = dead_match.group(1)\n    dead_list = ast.literal_eval(dead_str)\n\n    # 找出 target 的字串\n    target_match = re.search(r'target\\s*=\\s*\"([^\"]+)\"', text)\n    if not target_match:\n        raise ValueError(\"無法找到 target\")\n    target_str = target_match.group(1)\n\n    return dead_list, target_str\n\ndef main():\n    # 讀取整個 stdin\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        return\n    try:\n        deadends, target = parse_input(input_text)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    solution = Solution()\n    result = solution.openLock(deadends, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "deadends = [\"8888\"], target = \"0009\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for implementing RandomizedSet class with insert, remove, getRandom in average O(1). The output should be line-by-line virtual code with explanation. Use arrows, Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to represent algorithm: use hashmap val->index and array list of values. Insert: if val exists return false else push to array and record index. Remove: if val not exist return false else swap with last element in array, update hashmap, pop last, delete entry. getRandom: pick random index from array length.\n\nWe'll produce virtual code lines. Ensure each line includes arrow → and explanation. Use Decision: for insert existence check, remove existence check. Also need random selection.\n\nLet's craft:\n\nStart\n→ Initialize data structures: hashMap, arrayList // 建立兩個資料結構\n→ Function: RandomizedSet() // 建構子\n    → Set hashMap to empty\n    → Set arrayList to empty\n→ Function: insert(val) // 插入值\n    → Decision: If val exists in hashMap? // 檢查值是否已存在\n        Yes → Return false // 已存在，插入失敗\n        No  → Append val to arrayList // 新增值\n        → Record hashMap[val] = index of val in arrayList // 記錄索引\n        → Return true // 插入成功\n→ Function: remove(val) // 刪除值\n    → Decision: If val exists in hashMap? // 檢查是否存在\n        Yes →\n            → Get index of val from hashMap\n            → Get last element in arrayList\n            → Replace arrayList[index] with last element // 交換位置\n            → Update hashMap[last element] = index // 更新索引\n            → Remove last element from arrayList // 刪除最後一項\n            → Delete hashMap[val] // 刪除鍵值對\n            → Return true // 刪除成功\n        No  → Return false // 不存在，刪除失敗\n→ Function: getRandom() // 取得隨機值\n    → Generate random index between 0 and arrayList.size-1\n    → Return arrayList[random index] // 回傳隨機元素\nEnd\n\nWe need to format with arrows and comments. Each line includes a virtual code step and comment. Use \"→\" for continuation, \"Decision:\" for decision points. Provide each line separately.\n\nMake sure each line is separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize data structures: hashMap, arrayList // 建立兩個資料結構以支援 O(1) 操作  \n→ Function: RandomizedSet() // 建構子  \n  → Set hashMap to empty // 初始化哈希表  \n  → Set arrayList to empty // 初始化陣列  \n→ Function: insert(val) // 插入值  \n  → Decision: 如果 val 已存在於 hashMap? // 檢查值是否已存在  \n    Yes → Return false // 已存在，插入失敗  \n    No  → Append val to arrayList // 將新值加入陣列  \n      → Record hashMap[val] = index of val in arrayList // 記錄新值的索引  \n      → Return true // 插入成功  \n→ Function: remove(val) // 刪除值  \n  → Decision: 如果 val 存在於 hashMap? // 檢查值是否存在  \n    Yes →  \n      → Get index of val from hashMap // 取得欲刪除值的索引  \n      → Get last element in arrayList // 取得陣列最後一項  \n      → Replace arrayList[index] with last element // 交換位置以維持陣列連續  \n      → Update hashMap[last element] = index // 更新被交換元素的索引  \n      → Remove last element from arrayList // 刪除陣列最後一項  \n      → Delete hashMap[val] // 刪除哈希表中的鍵值對  \n      → Return true // 刪除成功  \n    No  → Return false // 不存在，刪除失敗  \n→ Function: getRandom() // 取得隨機值  \n  → Generate random index between 0 and arrayList.size-1 // 隨機選擇索引  \n  → Return arrayList[random index] // 回傳隨機元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # val -> index mapping\n        self.val_to_index = {}\n        # list of values\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # Move last element into the spot of the removed element\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # Remove last element\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef main():\n    # Read entire input and join lines to handle both single-line and multi-line inputs\n    raw = sys.stdin.read().strip().replace('\\n', ', ')\n    # Wrap the string into a tuple for safe literal evaluation\n    try:\n        ops, args = ast.literal_eval('(' + raw + ')')\n    except Exception as e:\n        # If parsing fails, exit silently\n        return\n\n    obj = RandomizedSet()\n    results = [None]  # Constructor returns null\n\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == 'insert':\n            res = obj.insert(arg[0])\n        elif op == 'remove':\n            res = obj.remove(arg[0])\n        elif op == 'getRandom':\n            res = obj.getRandom()\n        else:\n            res = None\n        results.append(res)\n\n    # Convert results to LeetCode style output\n    formatted = []\n    for r in results:\n        if r is None:\n            formatted.append('null')\n        elif isinstance(r, bool):\n            formatted.append('true' if r else 'false')\n        else:\n            formatted.append(str(r))\n    print('[' + ', '.join(formatted) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. We must not output actual code. Provide steps like Start, Decision, etc. Should include minimal calls to random. We can use reservoir? But known solution: use mapping from index to value. Approach: treat grid flattened to array of size m*n. Maintain count of remaining zeros. Randomly choose a number r in [0, remaining-1]. Map r to actual index via dictionary mapping: if r in map, actual = map[r]; else actual = r. Similarly for last = remaining-1; map[r] = last if last in map else last. Then decrement remaining. Convert actual to (i,j). This uses 1 random per flip. Reset just clear map and remaining.\n\nWe'll produce virtual steps: initialization sets total = m*n, remaining = total, map empty. flip: Decision: remaining > 0? else error. Step: randomIndex ← random(0, remaining-1). Step: actual ← if map contains randomIndex then map[randomIndex] else randomIndex. Step: last ← remaining-1. Step: map[randomIndex] ← if map contains last then map[last] else last. Step: decrement remaining. Step: compute i = actual / n, j = actual mod n. Return [i,j]. reset: clear map, remaining = total.\n\nWe should provide explanation lines.\n\nLet's format each line like:\n\nStart // 程式開始執行\n→ Step 1: Set total ← m * n // 計算矩陣大小\n→ Step 2: Set remaining ← total // 初始還有 total 個 0\n→ Step 3: Initialize map ← empty // 位置映射表\n…\n\nBut we need to produce the entire virtual algorithm including class methods.\n\nProbably produce structure:\n\nStart\n→ Step 1: Initialize class with m,n\n    → Step 1.1: Set total ← m * n\n    → Step 1.2: Set remaining ← total\n    → Step 1.3: Initialize map ← empty\n→ End\n\n→ Method flip\n    → Decision: If remaining == 0? // 檢查是否已無空位\n        No → ... // 執行隨機選取\n        Yes → Throw error or return none\n    → Step 2: randIdx ← random(0, remaining-1) // 一次隨機\n    → Step 3: actual ← map.get(randIdx, randIdx) // 若映射存在則取映射值\n    → Step 4: last ← remaining-1\n    → Step 5: map[randIdx] ← map.get(last, last) // 把最後一個位置映射到 randIdx\n    → Step 6: remaining ← remaining-1\n    → Step 7: i ← actual / n\n    → Step 8: j ← actual % n\n    → Return [i,j]\n→ End\n\n→ Method reset\n    → Step 1: map.clear()\n    → Step 2: remaining ← total\n→ End\n\nEnd // 程式結束\n\nAlso we need to ensure each line has explanation comment.\n\nWe should include arrows for decisions. Use Yes → No → formatting as specified.\n\nWe should also mention time complexity: O(1) per flip and reset O(1) space except map. But we will not output analysis.\n\nBut we need to output virtual code with explanations. Let's produce.\n\nLet's format with indentation for decisions maybe.\n\nEnsure each line ends with comment. Let's output in code block? Not required but we can show.\n\nWe'll produce lines sequentially, using arrow notation.\n\nOk.\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: Set total ← m * n // 計算矩陣的總格數\n→ Step 2: Set remaining ← total // 初始還有 total 個 0\n→ Step 3: Initialize map ← empty // 用於映射已選位置到最後可用位置\n\nEnd // 初始化結束\n\n// ──────────────────────────────────────────────────────\n//  flip() 方法\n// ──────────────────────────────────────────────────────\nStart // flip() 方法開始\n\n→ Decision: 如果 remaining == 0? // 檢查是否已無空位\n    Yes → Throw error // 所有位置已被翻轉，無法再選\n    No  → // 繼續執行隨機選取\n\n→ Step 4: randIdx ← random(0, remaining-1) // 隨機產生 0~remaining-1\n→ Step 5: actual ← map.get(randIdx, randIdx) // 若映射存在則取映射值，否則取 randIdx 本身\n→ Step 6: last ← remaining - 1 // 最後一個可用位置的索引\n→ Step 7: map[randIdx] ← map.get(last, last) // 把最後一個位置映射到 randIdx\n→ Step 8: remaining ← remaining - 1 // 減少剩餘 0 的數量\n\n→ Step 9: i ← actual / n // 計算行號\n→ Step 10: j ← actual % n // 計算列號\n→ Step 11: Return [i, j] // 回傳被翻轉的索引\n\nEnd // flip() 方法結束\n\n// ──────────────────────────────────────────────────────\n//  reset() 方法\n// ──────────────────────────────────────────────────────\nStart // reset() 方法開始\n\n→ Step 12: map.clear() // 清空映射表\n→ Step 13: remaining ← total // 重設剩餘 0 的數量\n\nEnd // reset() 方法結束\n\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到方法列表與參數列表的分隔點\n    try:\n        sep_idx = data.index('],')\n        method_part = data[:sep_idx + 1]\n        args_part = data[sep_idx + 2:]\n        method_list = ast.literal_eval(method_part)\n        args_list = ast.literal_eval(args_part.strip())\n    except ValueError:\n        # 若格式不符合預期，直接解析為元組\n        method_list, args_list = ast.literal_eval('(' + data + ')')\n\n    result = []\n    obj = None\n    for cmd, args in zip(method_list, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)\n        elif cmd == \"flip\":\n            result.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # 忽略未知方法\n            pass\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [2, 0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode735.json",
    "problem_index_in_file": 0,
    "title": "Asteroid Collision",
    "description_snippet": "We are given an array asteroids of integers representing asteroids in a row. The indices of the aste...",
    "examples_loaded": 4,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line explaining. The problem: Asteroid collision simulation. Typical solution uses stack. We need to produce virtual code steps. Use Start, Decision, etc. We need to generate virtual code and explanation each line.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty stack S // 用於存放剩餘小行星\n→ Step 2: 遍歷輸入陣列 asteroids // 逐一處理每顆小行星\n    → Decision: 如果小行星方向正 (右) → Yes → Push asteroid onto stack // 右移小行星直接入堆\n    → No → // 小行星方向負 (左)，需要檢查碰撞\n        → Step 3: 進入碰撞循環 while stack 非空 且 stack.top > 0\n            → Decision: 如果 abs(asteroid) < abs(stack.top) → Yes → // 左移小行星較小\n                → Step 4: asteroid = 0; Break // 左移小行星爆炸，結束碰撞\n            → No  → Decision: 如果 abs(asteroid) == abs(stack.top) → Yes → // 同大小\n                → Step 5: Pop stack; asteroid = 0; Break // 兩者同時爆炸\n            → No  → // 左移小行星較大\n                → Step 6: Pop stack // 右移小行星爆炸，繼續與下一個左移小行星碰撞\n        → End 循環\n        → Decision: 如果 asteroid ≠ 0 → Yes → Push asteroid onto stack // 左移小行星剩餘\n        → No → // 兩者已爆炸，什麼也不做\n→ End 遍歷\n→ Step 7: 轉換堆為結果陣列 // 將堆中元素輸出\nEnd\n\nBut must match format exactly: each line \"虛擬碼步驟 // 解釋\". Use arrow for steps. Use Start/End. Use Decision block indentation. Each line must have step plus comment.\n\nLet's produce formatted.\n\nWe must use Chinese traditional. Provide explanatory comments. Use arrow symbol.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: S ← empty stack // 初始化一個空堆疊，用於儲存仍存活的小行星\n→ Step 2: 對於每個 a in asteroids 循環 // 逐一處理輸入陣列中的小行星\n    → Decision: a > 0? // 小行星方向是向右？\n        Yes → Step 3: S.push(a) // 向右移動的小行星直接入堆，無法與後面的左移小行星相遇\n        No  → // 小行星向左，需要與堆頂右移小行星碰撞\n            → Step 4: while S 非空 且 S.top > 0 do // 只要堆頂是向右的小行星，就會相撞\n                → Decision: abs(a) < abs(S.top)? // 左移小行星比右移小行星小\n                    Yes → a ← 0; break // 左移小行星被消滅，停止此輪處理\n                    No  → Decision: abs(a) = abs(S.top)? // 相等大小\n                        Yes → S.pop(); a ← 0; break // 兩顆同時爆炸，停止此輪處理\n                        No  → S.pop() // 右移小行星被消滅，繼續與下一個右移小行星碰撞\n            → End while\n            → Decision: a ≠ 0? // 左移小行星還存活\n                Yes → S.push(a) // 將存活的左移小行星入堆\n                No  → // 兩顆已同時爆炸，無需處理\n→ End for\n→ Step 5: result ← S.toArray() // 將堆中的元素轉成陣列作為最終結果\nEnd // 程式執行結束\n\nWe should ensure each line ends with comment. Use indentation inside Decision blocks, but each line should be a separate line. Indentation might use spaces. Ensure each line uses \"→\" at start. For inner blocks we might use \"    →\" with indentation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: S ← empty stack // 初始化一個空堆疊，用於儲存仍存活的小行星  \n→ Step 2: 對於每個 a in asteroids 循環 // 逐一處理輸入陣列中的小行星  \n    → Decision: a > 0? // 小行星方向是向右？  \n        Yes → Step 3: S.push(a) // 向右移動的小行星直接入堆，無法與後面的左移小行星相遇  \n        No  → // 小行星向左，需要與堆頂右移小行星碰撞  \n            → Step 4: while S 非空 且 S.top > 0 do // 只要堆頂是向右的小行星，就會相撞  \n                → Decision: abs(a) < abs(S.top)? // 左移小行星比右移小行星小  \n                    Yes → a ← 0; break // 左移小行星被消滅，停止此輪處理  \n                    No  → Decision: abs(a) = abs(S.top)? // 相等大小  \n                        Yes → S.pop(); a ← 0; break // 兩顆同時爆炸，停止此輪處理  \n                        No  → S.pop() // 右移小行星被消滅，繼續與下一個右移小行星碰撞  \n            → End while  \n            → Decision: a ≠ 0? // 左移小行星還存活  \n                Yes → S.push(a) // 將存活的左移小行星入堆  \n                No  → // 兩顆已同時爆炸，無需處理  \n→ End for  \n→ Step 5: result ← S.toArray() // 將堆中的元素轉成陣列作為最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def asteroidCollision(self, asteroids):\n        stack = []\n        for a in asteroids:\n            while stack and a < 0 < stack[-1]:\n                if stack[-1] < -a:\n                    stack.pop()\n                    continue\n                elif stack[-1] == -a:\n                    stack.pop()\n                break\n            else:\n                stack.append(a)\n        return stack\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect input like: \"asteroids = [5,10,-5]\"\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data.strip()\n    try:\n        asteroids = ast.literal_eval(list_str)\n    except Exception:\n        # If input is not a valid Python literal, try splitting manually\n        asteroids = [int(x) for x in list_str.replace('[', '').replace(']', '').split(',') if x]\n    result = Solution().asteroidCollision(asteroids)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "asteroids = [5,10,-5]",
          "expected_output": "[5,10]",
          "success": true,
          "output": "[5, 10]"
        },
        {
          "example_index": 1,
          "input": "asteroids = [8,-8]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "asteroids = [10,2,-5]",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        },
        {
          "example_index": 3,
          "input": "asteroids = [3,5,-6,2,-1,4]",
          "expected_output": "[-6,2,4]",
          "success": true,
          "output": "[-6, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the Jump Game II problem: find minimum jumps to reach end. Use greedy approach: track current reach, next max reach. Each iteration increments jumps.\n\nWe need to output line by line: \"Start\", \"→ Step: ...\" etc. Provide explanation after //.\n\nWe must not output actual code, just virtual steps.\n\nLet's craft steps:\n\nStart\n→ Step 1: Set n = length of nums\n→ Step 2: If n <= 1 → Step 3: Return 0 // already at end\n→ Decision: 是否需要跳躍? // n>1\n    Yes → Step 4: 初始化 currEnd = 0 // furthest reachable in current jump\n    → Step 5: 初始化 currFarthest = 0 // furthest reachable with next jump\n    → Step 6: 初始化 jumps = 0 // count of jumps\n    → Step 7: for i from 0 to n-2: // iterate until second last index\n        → Step 8: 更新 currFarthest = max(currFarthest, i + nums[i]) // max reachable\n        → Decision: i == currEnd? // reached end of current jump range\n            Yes → Step 9: jumps++ // make a jump\n            → Step 10: currEnd = currFarthest // new range\n        No → (continue loop)\n    → Step 11: Return jumps\n\nBut we need virtual code lines each with explanation. Use arrow notation and Decision with Yes/No.\n\nWe need to avoid actual code but produce pseudo code.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得陣列長度 n ← length(nums) // n 為陣列長度\n→ Decision: n <= 1? // 檢查是否只需一個位置\n    Yes → Step 2: 回傳 0 // 只在起點即終點\n    No  → // 需要跳躍\n\nNow we need to initialize variables. Use arrow to indicate steps.\n\nWe might combine steps: Step 3: 初始化 currEnd, currFarthest, jumps = 0 // 目前可達最遠點、下一跳最遠點、跳躍次數\n\nThen loop: for i from 0 to n-2\n\nWe need to represent loop as Step. Eg: Step 4: 迭代 i = 0 到 n-2 // 循環訪問每個可跳索引\n\nInside loop:\n\nStep 5: 更新 currFarthest = max(currFarthest, i + nums[i]) // 觀測到最遠可達點\n\nDecision: i == currEnd? // 是否已經到達當前跳躍可達最遠點\n\nYes → Step 6: jumps++ // 進行一次跳躍\n→ Step 7: currEnd = currFarthest // 設定下一跳可達範圍\n\nNo → continue\n\nAfter loop: Step 8: 回傳 jumps // 返回最少跳躍次數\n\nAdd End.\n\nWe need to format each line with \"→\" after Start? In example they used \"Start\" then \"→ Step 1: ...\" So we should produce similar.\n\nLet's craft final lines:\n\nStart // 程式開始執行\n→ Step 1: 取得陣列長度 n ← length(nums) // n 為陣列長度\n→ Decision: n <= 1? // 檢查是否只需一個位置\n    Yes → Step 2: 回傳 0 // 只在起點即終點\n    No  → // 需要跳躍\n\n→ Step 3: 初始化 currEnd ← 0 // 目前跳躍可達最遠索引\n→ Step 4: 初始化 currFarthest ← 0 // 下一跳可達最遠索引\n→ Step 5: 初始化 jumps ← 0 // 跳躍次數計數\n\n→ Step 6: 迭代 i 從 0 到 n-2 // 只需檢查到倒數第二個位置\n    → Step 7: 更新 currFarthest ← max(currFarthest, i + nums[i]) // 更新下一跳可達範圍\n    → Decision: i == currEnd? // 判斷是否到達當前跳的終點\n        Yes → Step 8: jumps++ // 進行一次跳躍\n        → Step 9: currEnd ← currFarthest // 設定下一跳可達終點\n        No  → // 繼續循環\n\n→ Step 10: 回傳 jumps // 返回最少跳躍次數\nEnd // 程式執行結束\n\nBut we need \"虛擬碼步驟\" each line with arrow after Step maybe. Example: \"→ Step 1: ...\" So we need to keep that.\n\nAlso need to include Decision lines properly indented. For decision: \"Decision: ...\" and then \"Yes → ...\" \"No → ...\".\n\nWe need to ensure each line has a space after arrow. Provide explanation.\n\nLet's craft final output.\n\nMake sure lines after \"No →\" end with comment but no code.\n\nAlso ensure \"→\" preceding each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得陣列長度 n ← length(nums) // n 為陣列長度\n→ Decision: n <= 1? // 檢查是否只需一個位置\n    Yes → Step 2: 回傳 0 // 只在起點即終點\n    No  → // 需要跳躍\n\n→ Step 3: 初始化 currEnd ← 0 // 目前跳躍可達最遠索引\n→ Step 4: 初始化 currFarthest ← 0 // 下一跳可達最遠索引\n→ Step 5: 初始化 jumps ← 0 // 跳躍次數計數\n\n→ Step 6: 迭代 i 從 0 到 n-2 // 只需檢查到倒數第二個位置\n    → Step 7: 更新 currFarthest ← max(currFarthest, i + nums[i]) // 更新下一跳可達範圍\n    → Decision: i == currEnd? // 判斷是否到達當前跳的終點\n        Yes → Step 8: jumps++ // 進行一次跳躍\n        → Step 9: currEnd ← currFarthest // 設定下一跳可達終點\n        No  → // 繼續循環\n\n→ Step 10: 回傳 jumps // 返回最少跳躍次數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def jump(self, nums):\n        \"\"\"\n        Returns the minimum number of jumps to reach the last index of nums.\n        Uses a greedy approach to track the furthest reachable index within the\n        current number of jumps and the furthest reachable index in the next jump.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0          # Number of jumps made\n        current_end = 0    # Furthest index reachable with the current number of jumps\n        farthest = 0       # Furthest index reachable with one more jump\n\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])  # Update furthest reachable index\n            if i == current_end:                  # Reached the end of current jump range\n                jumps += 1\n                current_end = farthest            # Move to the next jump range\n\n        return jumps\n\ndef parse_input(data: str):\n    \"\"\"\n    Extracts a list of integers from the input string.\n    The input may contain extra text such as 'nums = ' before the list.\n    \"\"\"\n    data = data.strip()\n    # Find the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        # Fallback: try to evaluate the whole string\n        return ast.literal_eval(data)\n    list_str = data[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    # Read all data from stdin\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().jump(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for computing total poison duration. Use Start, Decision, etc. Provide each line with comment. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to handle input: timeSeries array non-decreasing, duration integer. Need to compute total poison time. Approach: iterate over attacks, for each attack compute effective poison duration: if next attack time - current time < duration then overlap, add duration - overlap? Actually algorithm: total = 0; prev = -1; For each attack t: if t > prev + duration: no overlap, add duration; else add t - prev; update prev = t. But need careful: prev = last attack time. Actually we can track previous attack time, compute overlap: overlap = max(0, prev + duration - t). If overlap >0, effective duration = duration - overlap else duration. So accumulate. Or simpler: total += min(duration, t - prev) if t > prev else? Actually if t > prev then difference; else difference 0. But given non-decreasing, t >= prev. So diff = t - prev. If diff >= duration then add duration else add diff. But initial prev = -infinity, so we can set prev = -1e9? simpler: use first attack separately. We'll just use previous attack time. If t > prev: diff = t - prev else diff = 0. But if t > prev, diff = t - prev; else diff=0. Add min(duration, diff). But careful for first: prev initial -1e9, diff huge, min = duration, ok.\n\nLet's produce pseudo code lines:\n\nStart\n→ Initialize total = 0 // 累計毒化秒數\n→ Initialize prevAttack = -duration // 使第一次計算正確（或使用 null）\n→ For each attackTime in timeSeries:\n    → Decision: if attackTime > prevAttack + duration? Actually we use diff = attackTime - prevAttack\n    → Compute diff = attackTime - prevAttack\n    → Compute add = min(duration, diff)\n    → total += add\n    → prevAttack = attackTime\n→ Return total\nEnd\n\nBut we need decision lines. Provide step by step.\n\nWe need to be clear: For each attackTime in timeSeries:\n    → If attackTime <= prevAttack? but series non-decreasing, so attackTime >= prevAttack. But still include decision: if attackTime <= prevAttack? then diff = 0; else diff = attackTime - prevAttack.\n\nBetter: use:\n→ For each attackTime in timeSeries:\n    → Decision: if attackTime > prevAttack + duration? Actually if last attack time plus duration < current attack time, no overlap. Then add duration. Else add attackTime - prevAttack.\n\nSimplify: diff = attackTime - prevAttack\n    → Decision: if diff >= duration? // No overlap\n        Yes → total += duration\n        No  → total += diff\n    → prevAttack = attackTime\n\nThat is clear.\n\nNow produce final pseudo code lines accordingly.\n\nWe must use arrow notation: →, Decision, Yes →, No →, End.\n\nWe'll produce lines with comment after //.\n\nLet's craft.\n\nAlso need to handle array input. So first line: \"→ Input: timeSeries, duration\" maybe not necessary. We'll start with Start.\n\nUse Start // 程式開始執行\n\nNext lines.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize total = 0 // 累計毒化秒數\n→ Initialize prevAttack = -duration // 使第一次計算正確（prevAttack + duration = 0）\n→ For each attackTime in timeSeries: // 逐一處理每一次攻擊\n    → Compute diff = attackTime - prevAttack // 與上一次攻擊的時間差\n    → Decision: diff >= duration? // 是否有重疊？\n        Yes → total += duration // 無重疊，完整 duration 時間都算毒化\n        No  → total += diff     // 有重疊，只計算從上一次攻擊結束到現在的差距\n    → prevAttack = attackTime // 更新上一次攻擊時間\n→ Return total // 將總毒化秒數返回\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration\n        return total\n\ndef parse_input(data: str):\n    # 找出時間序列的列表\n    list_match = re.search(r'\\[(.*?)\\]', data)\n    if list_match:\n        items = list_match.group(1).strip()\n        if items:\n            timeSeries = [int(x.strip()) for x in items.split(',')]\n        else:\n            timeSeries = []\n    else:\n        timeSeries = []\n\n    # 找出持續時間\n    dur_match = re.search(r'duration\\s*=\\s*(\\d+)', data)\n    duration = int(dur_match.group(1)) if dur_match else 0\n\n    return timeSeries, duration\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    timeSeries, duration = parse_input(data)\n    result = Solution().findPoisonedDuration(timeSeries, duration)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, not actual code, step by step. The problem is \"Longest Repeating Character Replacement\" typical sliding window with frequency count. We produce steps.\n\nWe need to output each line with \"虛擬碼步驟\" and explanation comment. Use arrow.\n\nWe'll produce steps:\n\nStart\n\n→ Step 1: 定義左指針 left = 0, 右指針 right = 0, 最高頻率 maxCount = 0, 最大長度 result = 0\n\n→ Step 2: 讀取輸入字符串 s, 整數 k\n\n→ Step 3: 初始化字符頻率數組 freq[26] = {0}\n\n→ Decision: right < s.length? // iterate while right < len\n\n→     Yes → Step 4: 增加 freq[s[right]]++, 更新 maxCount = max(maxCount, freq[s[right]]), right++\n\n→     Decision: (right - left) - maxCount > k? // window invalid\n\n→         Yes → Step 5: 減少 freq[s[left]]--, left++ // 移動左指針\n\n→         No → Step 6: result = max(result, right - left) // 更新最大長度\n\n→ End // 回傳 result\n\nAdd explanation after each line.\n\nMake sure formatting: Each line: \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow.\n\nWe need to use Start, End, Decision:.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義左指針 left = 0, 右指針 right = 0, 最大頻率 maxCount = 0, 結果長度 result = 0 // 初始化滑動窗口參數  \n→ Step 2: 讀取輸入字符串 s 與整數 k // 從使用者或測試環境取得必要輸入  \n→ Step 3: 建立大小為 26 的字符頻率數組 freq[26] = {0} // 用於統計窗口內每個字母的出現次數  \n→ Decision: right < s.length()？ // 判斷是否已經掃描完整個字符串  \n    Yes → Step 4: 增加 freq[s[right]]++，更新 maxCount = max(maxCount, freq[s[right]])，right++ // 進一步擴展窗口，更新頻率與最大頻率  \n    No  → Decision: (right - left) - maxCount > k？ // 判斷窗口是否合法，是否需要收縮  \n        Yes → Step 5: 減少 freq[s[left]]--，left++ // 收縮窗口，移除最左側字符  \n        No  → Step 6: result = max(result, right - left) // 計算並更新目前可達的最大相同字母子串長度  \n→ End // 回傳或輸出結果 result。",
      "generated_code": "import sys\nimport re\n\ndef character_replacement(s: str, k: int) -> int:\n    \"\"\"\n    使用滑動窗口 + 頻率統計，求在最多改變 k 次後能得到的相同字母最大子串長度。\n    \"\"\"\n    # 26 個大寫英文字母的頻率\n    freq = [0] * 26\n    max_freq = 0       # 當前窗口內出現次數最多的字母\n    left = 0           # 左指針\n    result = 0         # 最長長度\n\n    for right, ch in enumerate(s):\n        idx = ord(ch) - ord('A')\n        freq[idx] += 1\n        # 更新最大頻率\n        if freq[idx] > max_freq:\n            max_freq = freq[idx]\n\n        # 若需要改動的字母數超過 k，收縮窗口\n        while (right - left + 1) - max_freq > k:\n            left_idx = ord(s[left]) - ord('A')\n            freq[left_idx] -= 1\n            left += 1\n\n        # 更新結果\n        current_len = right - left + 1\n        if current_len > result:\n            result = current_len\n\n    return result\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支持兩種格式：\n    1. s = \"ABAB\", k = 2\n    2. 第一行字串，第二行整數\n    3. 一行「ABAB 2」\n    \"\"\"\n    # 嘗試正則匹配第一種格式\n    m = re.search(r's\\s*=\\s*\"([A-Z]+)\"\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if m:\n        return m.group(1), int(m.group(2))\n\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], int(lines[1])\n    # 最後的備用方式\n    parts = data.split()\n    return parts[0], int(parts[1])\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    answer = character_replacement(s, k)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for the algorithm: find length of last word in a string. We produce lines with \"虛擬碼步驟\" and comment. Use Start, End, Decision, arrow.\n\nWe need to treat string s, count length of last word, ignoring trailing spaces. Approach: iterate from end of string, skip spaces, then count characters until space or start. Virtual code: Start, Input string s, Initialize index = len(s)-1, Skip trailing spaces: Decision if s[index] is space? If Yes: decrement index; repeat until not space or index<0. If index<0: return 0. Else start counting: count=0; Decision if s[index] not space? Yes: increment count, decrement index; loop until index<0 or s[index] is space. Return count.\n\nLet's produce lines accordingly.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Provide arrows.\n\nWe might need to show loop via Decision and arrows. Example:\n\nStart\n→ Step 1: Input string s\n→ Step 2: index = length of s - 1\n→ Decision: index < 0? // 空字串檢查\n    Yes → Step 3: return 0 // 沒有文字\n    No  →\n→ Decision: s[index] == space? // 跳過尾部空格\n    Yes → index = index - 1 → Decision: index < 0? // 再次檢查\n        Yes → Step 4: return 0\n        No  → (loop back)\n    No  →\n→ Step 5: count = 0 // 開始計算最後單詞長度\n→ Decision: index < 0? // 句尾已到字串開始\n    Yes → Step 6: return count // 回傳長度\n    No  →\n→ Decision: s[index] == space? // 如果遇到空格，結束計算\n    Yes → Step 7: return count\n    No  → count = count + 1; index = index - 1 → (loop back)\n\nEnd.\n\nNeed to ensure each line has arrow. Use \"→\" for each step. Use \"Yes →\" and \"No →\" under decisions. The loops need to return to earlier decision. Use indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得輸入的原始字串  \n→ Step 2: index ← length(s) - 1 // 取得最後一個字元的位置  \n→ Decision: index < 0? // 檢查字串是否為空  \n Yes → Step 3: 回傳 0 // 空字串無單詞，直接結束  \n No  →  \n→ Decision: s[index] == 空格? // 跳過末尾所有空格  \n Yes → index ← index - 1 → Decision: index < 0?  \n  Yes → Step 4: 回傳 0 // 跳完後索引已走到字串開始，沒有單詞  \n  No  → (回到上一 Decision: s[index] == 空格?)  \n No  →  \n→ Step 5: count ← 0 // 初始化最後單詞長度計數  \n→ Decision: index < 0? // 已到字串開始，結束計算  \n Yes → Step 6: 回傳 count // 回傳已計算的長度  \n No  →  \n→ Decision: s[index] == 空格? // 遇到空格表示單詞結束  \n Yes → Step 7: 回傳 count // 回傳最後單詞長度  \n No  → count ← count + 1; index ← index - 1 → (回到上一 Decision: s[index] == 空格?)  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef length_of_last_word(s: str) -> int:\n    \"\"\"\n    回傳字串 s 中最後一個單字的長度。\n    以往往尾部的空格會被忽略，若整個字串都是空格則回傳 0。\n    \"\"\"\n    i = len(s) - 1\n\n    # 跳過結尾的空格\n    while i >= 0 and s[i] == ' ':\n        i -= 1\n\n    # 沒有任何字元\n    if i < 0:\n        return 0\n\n    # 計算最後一個單字的長度\n    count = 0\n    while i >= 0 and s[i] != ' ':\n        count += 1\n        i -= 1\n\n    return count\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取整個內容，處理可能的 's = \"...\"' 格式，\n    然後計算並輸出最後一個單字的長度。\n    \"\"\"\n    data = sys.stdin.read()\n    data = data.strip()\n\n    if not data:\n        return\n\n    # 若輸入中包含雙引號，則只取引號內的內容\n    if '\"' in data:\n        start = data.find('\"')\n        end = data.rfind('\"')\n        s = data[start + 1:end]\n    else:\n        s = data\n\n    result = length_of_last_word(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for searching target in rotated sorted array with binary search logic. Provide steps line by line with explanation.\n\nLet's design steps:\n\nStart\n→ Input: array nums, target\n→ Initialize left=0, right=nums.length-1\n→ Decision: while left <= right?\n    Yes → compute mid = (left+right)/2\n    → Decision: if nums[mid] == target?\n        Yes → return mid\n        No → Decision: is nums[left] <= nums[mid]? // left half sorted?\n            Yes → Decision: target between nums[left] and nums[mid]?\n                Yes → right = mid-1\n                No  → left = mid+1\n            No  → // right half sorted\n                Decision: target between nums[mid] and nums[right]?\n                    Yes → left = mid+1\n                    No  → right = mid-1\n    No → End loop\n→ return -1\n\nBut need to follow format: \"Step\" and \"Decision:\" lines etc. Use arrows. Provide explanation each line.\n\nLet's produce:\n\nStart\n→ Input: array nums, integer target // 取得輸入\n→ Initialize left = 0, right = nums.length - 1 // 設定搜尋邊界\n→ Decision: left <= right? // 判斷是否還有區間可搜尋\n    Yes → Step: mid = (left + right) // 2 // 計算中點\n    → Decision: nums[mid] == target? // 檢查中點是否為目標\n        Yes → Step: return mid // 找到目標，返回索引\n        No  → Decision: nums[left] <= nums[mid]? // 判斷左半段是否有序\n            Yes → Decision: target >= nums[left] AND target < nums[mid]? // 目標是否在左有序段\n                Yes → Step: right = mid - 1 // 調整右邊界到左半段\n                No  → Step: left = mid + 1 // 目標在右半段，調整左邊界\n            No  → Decision: target > nums[mid] AND target <= nums[right]? // 目標是否在右有序段\n                Yes → Step: left = mid + 1 // 目標在右半段，調整左邊界\n                No  → Step: right = mid - 1 // 目標在左半段，調整右邊界\n    No → End // 迴圈結束\n→ Step: return -1 // 未找到目標，返回 -1\nEnd\n\nNeed to include indentation for sub-steps, but using arrow and indentation. Use '→' for each line. Use 'Yes →' and 'No →'.\n\nWe should ensure that each line ends with // explanation. Also we need 'End' at the end.\n\nAlso we might need to include 'End // 程式執行結束'.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: array nums, integer target // 取得輸入的陣列與目標值  \n→ Initialize left = 0, right = nums.length - 1 // 設定搜尋範圍的左右邊界  \n→ Decision: left <= right? // 判斷是否還有區間可搜尋  \n Yes → Step: mid = (left + right) // 2 // 計算中點索引  \n → Decision: nums[mid] == target? // 檢查中點是否正好是目標值  \n  Yes → Step: return mid // 找到目標，直接返回索引  \n  No  → Decision: nums[left] <= nums[mid]? // 判斷左半段是否為有序區間  \n   Yes → Decision: target >= nums[left] AND target < nums[mid]? // 目標是否落在左半段  \n    Yes → Step: right = mid - 1 // 目標在左半段，縮小右邊界  \n    No  → Step: left = mid + 1 // 目標不在左半段，調整左邊界  \n   No  → Decision: target > nums[mid] AND target <= nums[right]? // 目標是否落在右半段  \n    Yes → Step: left = mid + 1 // 目標在右半段，調整左邊界  \n    No  → Step: right = mid - 1 // 目標不在右半段，調整右邊界  \n No → End // 迴圈結束，未再有可搜尋區間  \n→ Step: return -1 // 未找到目標，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:          # 左半段有序\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:                                # 右半段有序\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 找到 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        sys.exit(1)\n    nums_str = nums_match.group(1)\n    target_str = target_match.group(1)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n    result = Solution().search(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode676.json",
    "problem_index_in_file": 0,
    "title": "Implement Magic Dictionary",
    "description_snippet": "Design a data structure that is initialized with a list of different words. Provided a string, you s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants design a data structure and implement MagicDictionary with methods: buildDict and search.\n\nWe need to produce steps. Should show algorithm. Probably use dictionary of words, and search by iterating through words and checking if difference is exactly 1. Or better: use mapping of patterns with one wildcard. But simple approach: for each word in dictionary, if length matches searchWord and differCount==1 return true. Else false. So produce virtual code.\n\nWe must not output actual code, just virtual code. Format: Start, steps, Decision, End. Each line: virtual step + \" // explanation\". Need arrow and decisions.\n\nLet's produce. We'll describe steps:\n\nStart\n→ Step 1: 初始化空字典列表 // create list to store words\n→ Step 2: buildDict: 接收字串陣列 dictionary\n    → Loop for each word in dictionary:\n        → Add word to dictionary list // store\n→ End of buildDict\n→ Step 3: search(searchWord): // Called with searchWord\n    → Loop over each word in dictionary list:\n        → If length of word != length of searchWord: continue // skip\n        → diff = 0\n        → Loop i from 0 to length-1:\n            → If word[i] != searchWord[i]: diff += 1\n            → If diff > 1: break // cannot match\n        → After loop: If diff == 1: return true // found match\n    → After loop: return false // no match\nEnd\n\nWe need to represent decision branches. Use Decision: if length differ? Yes → continue. Also Decision: if diff > 1? break.\n\nLet's format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的詞彙清單 dictionary // 用來儲存所有字串  \n→ Step 2: buildDict(dictionary) // 初始化資料結構  \n    → Decision: 逐一遍歷傳入的字串陣列 dictionary  \n        Yes → Step 3: 把目前字串加入 dictionary // 儲存至資料結構  \n    → End // 建構完畢  \n→ Step 4: search(searchWord) // 開始搜尋是否能改變一個字元匹配字典  \n    → Decision: 逐一檢查 dictionary 中的每個 word  \n        Yes → Decision: 如果 word 與 searchWord 長度不等?  \n            Yes → Step 5: 跳過此 word // 只有長度相同才能改 1 個字元  \n            No → Step 6: 計算兩字串不同的位置數 diff = 0  \n            → Loop i from 0 to length-1  \n                Decision: 如果 word[i] != searchWord[i]?  \n                    Yes → Step 7: diff += 1  \n                    No → Step 8: 無變動  \n                Decision: 如果 diff > 1?  \n                    Yes → Step 9: break // 已超過 1 個差異，直接跳出內層迴圈  \n            → End Loop  \n            Decision: 如果 diff == 1?  \n                Yes → Step 10: return true // 找到符合條件的字串  \n                No → Step 11: 繼續檢查下一個 word  \n    → End Decision  \n    → Step 12: return false // 未找到任何符合條件的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse the two lists: operations and arguments\n    # Wrap the input in parentheses so that literal_eval returns a tuple\n    try:\n        ops, args = ast.literal_eval('(' + data + ')')\n    except Exception as e:\n        # Fallback for when input is split into two separate lines\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            ops = ast.literal_eval(lines[0])\n            args = ast.literal_eval(lines[1])\n        else:\n            raise ValueError(\"Invalid input format\") from e\n\n    results = []\n    magic_dict = None\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            magic_dict = MagicDictionary()\n            results.append(None)\n        elif op == \"buildDict\":\n            magic_dict.buildDict(arg[0])  # arg[0] is the list of words\n            results.append(None)\n        elif op == \"search\":\n            res = magic_dict.search(arg[0])  # arg[0] is the search word\n            results.append(res)\n        else:\n            # Unknown operation; append None as placeholder\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "success": true,
          "output": "[null, null, false, true, false, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode672.json",
    "problem_index_in_file": 0,
    "title": "Bulb Switcher II",
    "description_snippet": "There is a room with n bulbs labeled from 1 to n that all are turned on initially, and four buttons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm for counting possible statuses after exactly presses button presses. We need to output virtual code steps line by line with comments. Must not output real code. Use arrows and decision structure.\n\nWe should produce steps: initialize n, presses, define four buttons as bit masks maybe, iterate all combinations of presses (presses <= maybe small?). But need generic algorithm. Use combinatorics: each button toggles subset, overall effect depends on XOR of button presses counts mod 2. So we only care parity of each button press. Number of presses total fixed, so we need number of 4-tuples (b1,b2,b3,b4) with sum=presses, each bi>=0. For each such tuple, compute parity of each bi mod 2 to determine resulting status. Count distinct resulting statuses. We can compute number of distinct resulting patterns by enumerating all parity combinations reachable given total presses constraint. So algorithm: iterate over all possible parity combinations (2^4=16). For each, check if there exists a 4-tuple of nonnegative integers summing to presses with given parity. That is equivalent to checking if presses parity matches sum of parities. For each feasible parity, compute resulting bulb status: apply toggles to initial all on. Determine which bulbs toggled odd times (i.e., toggled if sum of selected button effects on that bulb is odd). For each bulb label i from 1 to n, compute toggled = (parity1) XOR (i%2==0?parity2:0) XOR (i%2==1?parity3:0) XOR ( (i-1)%3==0?parity4:0). Initially on, so final status off if toggled odd. We need to count distinct resulting patterns. Represent pattern maybe as binary string but we only need count, so we can store pattern as set of toggled indices? Instead, we can compute count of distinct patterns by generating patterns as boolean arrays and insert into set. But as virtual code, we can state that.\n\nSo steps: Start, read n, presses. Define button effects: toggles mask for each button (conceptually). Initialize empty set StatusSet. For each parity combination p1 in {0,1}, p2 in {0,1}, p3, p4: If (p1+p2+p3+p4) mod 2 == presses mod 2 AND (some condition that sum >= presses?) Actually need existence of nonnegative integers with given parities summing to presses. This is possible iff presses >= (p1+p2+p3+p4) and (presses - (p1+p2+p3+p4)) is even? Because we can add 2 to any bi to keep parity. So condition: presses >= sum(parities) and (presses - sum(parities)) % 2 == 0. If yes, then compute status: For each bulb i: toggled = (p1 XOR (i%2==0?p2:0) XOR (i%2==1?p3:0) XOR ((i-1)%3==0?p4:0)). If toggled==1 -> final off else on. Represent pattern as string of bits. Add to set. After loop, result = size of set. End.\n\nNow produce virtual code lines. Use arrows. Provide explanation after each line. Let's craft.\n\nWe need to include Start and End.\n\nMake steps:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n 與 presses // 取得房間燈數量及按鈕總按壓次數\n→ Step 2: 初始化 StatusSet 為空集合 // 用於存放不同的燈組合狀態\n→ Step 3: 定義四個按鈕的偶數/奇數/三倍關係 // 描述各按鈕對燈號的翻轉規則\n→ Decision: 遍歷所有 16 種 (p1,p2,p3,p4) 的二進位組合 // p1~p4 表示每個按鈕被按奇數次的標記\n    Yes → Step 4: 計算 sumParity = p1+p2+p3+p4 // 需要的最小按壓次數\n    → Decision: 如果 presses >= sumParity 且 (presses - sumParity) % 2 == 0 ?\n        Yes → Step 5: 產生燈狀態 Pattern\n            → Step 6: 對 i 從 1 到 n\n                → Decision: 判斷 i 是否被翻轉 (p1 XOR (i%2==0?p2:0) XOR (i%2==1?p3:0) XOR ((i-1)%3==0?p4:0))\n                    Yes → Step 7: 將 i 設為 OFF\n                    No  → Step 8: 將 i 設為 ON\n            → Step 9: 將完整 Pattern 加入 StatusSet\n        No → Decision: 繼續到下一個 (p1,p2,p3,p4) 组合 // 此組合無法實現\nEnd // 程式結束，返回 StatusSet 的大小作為答案\n\nNeed more explicit steps. Also need to mention converting Pattern to string. Provide explanation.\n\nLet's craft final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取 n 與 presses // 取得房間燈數量與總按鈕按壓次數\n→ Step 2: 初始化 StatusSet 為空集合 // 用於儲存所有可能的燈狀態組合\n→ Step 3: 定義按鈕翻轉規則 // Button1: 全部，Button2: 偶數，Button3: 奇數，Button4: j = 3k+1\n→ Decision: 遍歷所有 16 種 (p1,p2,p3,p4) 的二進位組合 // p1~p4 為各按鈕被按奇數次的標記\n    Yes → Step 4: 計算 sumParity = p1 + p2 + p3 + p4 // 需要的最小按壓次數\n    → Decision: 如果 presses ≥ sumParity 且 (presses - sumParity) % 2 == 0 ?\n        Yes → Step 5: 產生燈狀態 Pattern\n            → Step 6: 對 i 從 1 到 n\n                → Decision: 判斷燈 i 是否被翻轉\n                    Yes → Step 7: 將燈 i 設為 OFF // 翻轉後為關燈\n                    No  → Step 8: 將燈 i 設為 ON  // 未翻轉保持開燈\n            → Step 9: 將完整 Pattern（如「10101」）加入 StatusSet\n        No  → Decision: 繼續到下一個 (p1,p2,p3,p4) 組合 // 此組合無法實現\nEnd // 程式結束，返回 StatusSet 的大小作為答案\n```",
      "generated_code": "import sys\n\ndef flip_lights(n: int, presses: int) -> int:\n    # 如果不按任何按鈕，只有一種狀態（全部開）\n    if presses == 0:\n        return 1\n\n    # 使用按鈕按壓奇偶性決定最終狀態\n    patterns = set()\n\n    for p1 in (0, 1):\n        for p2 in (0, 1):\n            for p3 in (0, 1):\n                for p4 in (0, 1):\n                    sum_parity = p1 + p2 + p3 + p4\n                    # 能否用 presses 次按鈕得到這個奇偶組合？\n                    if presses < sum_parity or (presses - sum_parity) % 2 != 0:\n                        continue\n\n                    bits = []\n                    for i in range(1, n + 1):\n                        # 初始全部開，翻轉奇數次後為關\n                        toggle = p1\n                        if i % 2 == 0:\n                            toggle ^= p2\n                        else:\n                            toggle ^= p3\n                        if (i - 1) % 3 == 0:\n                            toggle ^= p4\n                        bits.append('0' if toggle else '1')\n                    patterns.add(''.join(bits))\n\n    return len(patterns)\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return None, None\n    if 'n' in data and 'presses' in data:\n        # 將「n = 1, presses = 2」等字串轉成兩個數字\n        cleaned = data.replace('n', '').replace('presses', '').replace('=', '').replace(',', ' ')\n        parts = cleaned.split()\n        return int(parts[0]), int(parts[1])\n    else:\n        parts = data.split()\n        return int(parts[0]), int(parts[1])\n\ndef main():\n    data = sys.stdin.read()\n    n, presses = parse_input(data)\n    if n is None or presses is None:\n        return\n    result = flip_lights(n, presses)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given n and k, return k-th permutation sequence in lexicographic order. Classic algorithm: compute factorials, find index for each position. We need to output in format lines with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision etc. No actual code.\n\nLet's craft. Steps:\n\nStart\n→ Initialize list of numbers 1..n // list of available digits\n→ Compute factorial array f[0..n] // factorials\n→ Decrement k by 1 // 0-indexed\n→ For i from 1 to n:\n    → Compute idx = k / f[n-i] // choose index in list\n    → Append number list[idx] to result // add to result\n    → Remove number list[idx] from list\n    → k = k % f[n-i] // remainder for next\nEnd\n\nAlso handle decision maybe for k within bounds. Let's output line by line with comments. Use \"Decision:\" for k> factorial. Possibly skip. Keep simple.\n\nWe'll produce virtual code lines.\n\nWe need to include arrow \"→\". For loops we can express as \"Loop i = 1 to n\" maybe. Use indentation for decision branches.\n\nWe must ensure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 建立數字列表 numbers ← [1, 2, …, n] // 準備可用的位數  \n→ 建立階乘陣列 fact[0..n]  \n  → fact[0] ← 1 // 0! = 1  \n  → Decision: 若 i ≤ n? // 計算階乘  \n    Yes → fact[i] ← fact[i-1] × i // i! = (i-1)! × i  \n    No  → End of loop // 完成階乘計算  \n→ 將 k 減 1，變成 0-indexed：k ← k - 1 // 方便使用整除  \n→ 產生結果字符串 result ← \"\"  \n→ Loop i = 1 to n  \n  → idx ← k / fact[n-i] // 選取當前位的索引  \n  → result ← result + numbers[idx] // 把選中的數字加入答案  \n  → Decision: 若 idx < length(numbers)? // 確認索引合法  \n    Yes → numbers ← numbers 移除索引 idx 的元素 // 移除已使用的數字  \n    No  → End // 超出範圍，結束 (實際不會發生)  \n  → k ← k % fact[n-i] // 更新剩餘位的 k  \nEnd // 程式執行結束，result 為第 k 個排列序列",
      "generated_code": "import sys\nimport math\nimport re\n\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        \"\"\"返回第 k 個字典序排列（從 1 開始）\"\"\"\n        numbers = list(range(1, n + 1))\n        k -= 1  # 轉為 0 索引\n        result = []\n\n        for i in range(n, 0, -1):\n            fact = math.factorial(i - 1)\n            index = k // fact\n            result.append(str(numbers.pop(index)))\n            k %= fact\n\n        return ''.join(result)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    sol = Solution()\n    print(sol.getPermutation(n, k))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "213"
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "2314"
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "123"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode744.json",
    "problem_index_in_file": 0,
    "title": "Find Smallest Letter Greater Than Target",
    "description_snippet": "You are given an array of characters letters that is sorted in non-decreasing order, and a character...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps, not actual code. The algorithm: iterate through array or binary search. We'll provide steps. Use Start, Decision. Provide explanation. Use arrow. We'll do linear scan maybe. Let's produce.\n\nUse Start, Step 1: for each char in letters, Step 2: if char > target then return char, Step 3: after loop return letters[0]. End. Add Decision.\n\nLet's produce with lines. Ensure each line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 index ← 0 // 初始化索引，準備從陣列起始處遍歷  \n→ Decision: 是否已達陣列末端? // 判斷是否已檢查完所有字元  \n    No  → Step 2: 讀取字元 current ← letters[index] // 取得目前索引位置的字元  \n    No  → Decision: current 是否大於 target? // 檢查此字元是否比目標字元更大  \n        Yes → Step 3: 回傳 current // 找到最小的大於 target 的字元，直接回傳  \n        No  → Step 4: index ← index + 1 // 該字元不符合條件，移至下一個  \n    No  → Decision: index 是否小於 length(letters)? // 判斷是否還有字元可檢查  \n        Yes → 回到 Decision: 是否已達陣列末端? // 重複檢查下一個字元  \n        No  → Step 5: 回傳 letters[0] // 沒有比 target 大的字元，回傳第一個字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nextGreatestLetter(self, letters, target):\n        left, right = 0, len(letters) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if letters[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return letters[left % len(letters)]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，取得 letters 列表與 target 字元。\n    輸入範例: 'letters = [\"c\",\"f\",\"j\"], target = \"a\"'\n    \"\"\"\n    pattern = r'letters\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*\"(.)\"'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式不符合要求\")\n    letters_str, target_char = match.group(1), match.group(2)\n    letters = eval(letters_str)  # letters 內的元素已是單字元字串\n    return letters, target_char\n\ndef main():\n    input_data = sys.stdin.read()\n    letters, target = parse_input(input_data)\n    sol = Solution()\n    result = sol.nextGreatestLetter(letters, target)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"a\"",
          "expected_output": "\"c\"",
          "success": true,
          "output": "\"c\""
        },
        {
          "example_index": 1,
          "input": "letters = [\"c\",\"f\",\"j\"], target = \"c\"",
          "expected_output": "\"f\"",
          "success": true,
          "output": "\"f\""
        },
        {
          "example_index": 2,
          "input": "letters = [\"x\",\"x\",\"y\",\"y\"], target = \"z\"",
          "expected_output": "\"x\"",
          "success": true,
          "output": "\"x\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for algorithm to solve \"Next Greater Element I\" problem. Approach: Use stack to compute next greater for each element in nums2, store mapping value->next greater. Then iterate nums1 and fill result. So steps: Start, compute next greater for nums2 using stack: for each element from right to left or left to right? Typical algorithm: iterate from right to left; but can also left to right with stack of indices. Use stack to maintain decreasing elements. For each element x in nums2, while stack not empty and stack.top <= x, pop; then nextGreater[x] = stack.top if exists else -1; push x onto stack. Then create ans array: for each element x in nums1, ans[i] = nextGreater[x]. End. Provide virtual code lines with explanations. Ensure each line with `虛擬碼步驟 // 解釋`. Use arrow etc. We'll produce something like:\n\nStart // 程式開始\n→ Step 1: 初始化空棧 S // 用於存儲可能的下一個較大元素\n→ Step 2: 初始化空映射 nextGreater // value -> next greater element\n→ Decision: 遍歷 nums2 ？ // 這裡使用迴圈\n    Yes → Step 3: 取元素 x = nums2[i] // 依序取得每個元素\n    → Decision: S 為空 或 S.top <= x? // 判斷是否需要彈出\n        Yes → → Step 4: pop S while S.top <= x // 清除不大於 x 的元素\n    → Step 5: nextGreater[x] = S.top if S 不空 else -1 // 設定對應值\n    → Step 6: push x 到 S // 把 x 放入棧中\n→ End // 完成 nums2 的遍歷\n→ Step 7: 初始化結果陣列 ans size nums1.length\n→ Decision: 遍歷 nums1\n    Yes → Step 8: ans[i] = nextGreater[nums1[i]] // 填入對應的 next greater\n→ End // 完成結果填充\nEnd // 程式結束\n\nBut need each line with arrow and explanation. Also need indentation for decision branches.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 S // 用於存放可能成為下一個較大元素的值  \n→ Step 2: 初始化空映射 nextGreater // key: 元素值, value: 下一個較大元素（或 -1）  \n→ Decision: 遍歷 nums2 中每個元素 (i 從 0 到 nums2.length-1) // 逐個處理  \n    Yes → Step 3: 取當前元素 x = nums2[i] // 取得正在處理的值  \n    → Decision: 若 S 為空 或 S.top <= x? // 判斷棧頂是否可作為下一個較大元素  \n        Yes → → Step 4: pop S while S.top <= x // 從棧中移除所有不大於 x 的元素  \n        No  → // 不需要彈出任何元素，棧頂已經是較大值  \n    → Step 5: nextGreater[x] = S.top if S 不空 else -1 // 設定 x 的下一個較大元素  \n    → Step 6: push x 到 S // 把 x 放入棧中，供後續元素使用  \n→ End // nums2 全部處理完畢  \n→ Step 7: 初始化結果陣列 ans 長度為 nums1.length // 用於存放答案  \n→ Decision: 遍歷 nums1 中每個元素 (i 從 0 到 nums1.length-1)  \n    Yes → Step 8: ans[i] = nextGreater[nums1[i]] // 直接查表取得答案  \n→ End // nums1 全部處理完畢  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        \"\"\"\n        使用單調棧計算 nums2 中每個元素的下一個較大元素，\n        並建立一個映射 value -> next_greater_value。\n        最後根據 nums1 的元素查表得到答案。\n        \"\"\"\n        stack = []                 # 單調遞減棧，棧頂元素始終比新元素大\n        next_greater = {}          # value -> next greater value\n\n        # 遍歷 nums2，填充 next_greater 映射\n        for num in nums2:\n            while stack and num > stack[-1]:\n                # num 是 stack 中元素的下一個較大值\n                next_greater[stack.pop()] = num\n            stack.append(num)\n\n        # 根據 nums1 的元素查表得到答案，若無則回傳 -1\n        return [next_greater.get(x, -1) for x in nums1]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'nums1 = [4,1,2], nums2 = [1,3,4,2]' 的輸入。\n    透過正則表達式抽取兩個列表字串，然後轉為整數列表。\n    \"\"\"\n    pattern = r'nums1\\s*=\\s*\\[(.*?)\\].*?nums2\\s*=\\s*\\[(.*?)\\]'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        return [], []\n\n    def list_from_str(s):\n        # 若字串為空則返回空列表\n        if not s.strip():\n            return []\n        return [int(num) for num in s.split(',')]\n\n    nums1_str, nums2_str = match.groups()\n    return list_from_str(nums1_str), list_from_str(nums2_str)\n\ndef main():\n    # 讀取全部標準輸入\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n\n    # 產生答案\n    sol = Solution()\n    ans = sol.nextGreaterElement(nums1, nums2)\n\n    # 輸出答案\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1, 3, -1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode658.json",
    "problem_index_in_file": 0,
    "title": "Find K Closest Elements",
    "description_snippet": "Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the ar...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: find k closest numbers to x in sorted array arr. Steps: binary search for x or insertion point, then two pointers left/right expand selecting closer values. Return subarray sorted ascending. Provide lines with arrows and comments. Let's outline steps:\n\nStart\n→ Step: Input arr, k, x\n→ Step: Binary search to find insertion index i where arr[i] >= x or i = len\n→ Step: Initialize left = i-1, right = i\n→ Step: Initialize result list\n→ Decision: While len(result) < k?\n    Yes → Step: If left <0: right++ \n        Else if right>=len: left--\n        Else if |arr[left]-x| <= |arr[right]-x|: append arr[left] to result, left--\n        Else: append arr[right] to result, right++\n    No → Step: Sort result ascending\n→ Step: Return result\nEnd\n\nBut need to output each line with // explanation. Must use virtual code arrow notation: e.g., \"→ Step 1: ...\". We may number steps for clarity. Use \"Decision:\" etc. Should use arrows for branches: \"Yes →\" etc. Let's produce a structured flow:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 arr、k、x // 取得待處理陣列及參數\n→ Step 2: 使用二分搜尋找到插入位置 i // 確定 x 在陣列中的左右分界點\n    → Decision: arr[i] >= x? // 判斷是否找到了大於等於 x 的元素\n        Yes → // i 已指向第一個 ≥ x 的索引\n        No  → // 若 i 超出陣列，表示 x 大於所有元素，i = len(arr)\n→ Step 3: 設 left = i - 1，right = i // 左右指標分別指向 x 左右兩側元素\n→ Step 4: 初始化空結果 list res // 存放已選擇的 k 個最近數\n→ Decision: len(res) < k? // 是否還需要再選擇\n    Yes →\n        → Decision: left < 0? // 左側已無可選項\n            Yes → right++ ; append arr[right] to res // 直接取右側\n            No  →\n                → Decision: right >= len(arr)? // 右側已無可選項\n                    Yes → left-- ; append arr[left] to res // 直接取左側\n                    No  →\n                        → Decision: |arr[left]-x| <= |arr[right]-x|? // 比較距離\n                            Yes → left-- ; append arr[left] to res // 取左側\n                            No  → right++ ; append arr[right] to res // 取右側\n    No  → // 已選到 k 個元素\n→ Step 5: 將 res 重新排序成升序 // 結果需為遞增順序\n→ Step 6: 輸出 res // 回傳最終答案\nEnd // 程式結束\n\nBut need to follow format: Each line starts with \"→\" or \"Decision:\" etc. Must include arrow for branches. Provide explanation after //.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 arr、k、x // 取得待處理陣列及參數  \n→ Step 2: 使用二分搜尋找到插入位置 i // 確定 x 在陣列中的左右分界點  \n→ Decision: arr[i] >= x? // 判斷是否找到了大於等於 x 的元素  \n  Yes → // i 已指向第一個 ≥ x 的索引  \n  No  → // 若 i 超出陣列，表示 x 大於所有元素，i = len(arr)  \n→ Step 3: 設 left = i - 1，right = i // 左右指標分別指向 x 左右兩側元素  \n→ Step 4: 初始化空結果 list res // 存放已選擇的 k 個最近數  \n→ Decision: len(res) < k? // 是否還需要再選擇  \n  Yes →  \n    → Decision: left < 0? // 左側已無可選項  \n      Yes → right++ ; append arr[right] to res // 直接取右側  \n      No  →  \n       → Decision: right >= len(arr)? // 右側已無可選項  \n        Yes → left-- ; append arr[left] to res // 直接取左側  \n        No  →  \n          → Decision: |arr[left]-x| <= |arr[right]-x|? // 比較距離  \n            Yes → left-- ; append arr[left] to res // 取左側  \n            No  → right++ ; append arr[right] to res // 取右側  \n  No  → // 已選到 k 個元素  \n→ Step 5: 將 res 重新排序成升序 // 結果需為遞增順序  \n→ Step 6: 輸出 res // 回傳最終答案  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findClosestElements(self, arr, k, x):\n        \"\"\"\n        Find k elements in sorted arr that are closest to x.\n        The result is also sorted in ascending order.\n        \"\"\"\n        left, right = 0, len(arr) - k\n        while left < right:\n            mid = (left + right) // 2\n            # Compare distances of the two candidates at the borders of the window\n            if x - arr[mid] > arr[mid + k] - x:\n                left = mid + 1\n            else:\n                right = mid\n        return arr[left:left + k]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        arr = [1,2,3,4,5], k = 4, x = 3\n    and return (arr, k, x).\n    \"\"\"\n    # Extract the list part between the first '[' and the last ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        raise ValueError(\"Invalid input format: array not found.\")\n    arr_str = data[start:end + 1]\n    arr = ast.literal_eval(arr_str)\n\n    # Extract k and x using regular expressions\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    x_match = re.search(r'x\\s*=\\s*(-?\\d+)', data)\n    if not k_match or not x_match:\n        raise ValueError(\"Invalid input format: k or x not found.\")\n    k = int(k_match.group(1))\n    x = int(x_match.group(1))\n    return arr, k, x\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    arr, k, x = parse_input(input_data)\n    solution = Solution()\n    result = solution.findClosestElements(arr, k, x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [1,2,3,4,5], k = 4, x = 3",
          "expected_output": "[1,2,3,4]",
          "success": true,
          "output": "[1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "arr = [1,1,2,3,4,5], k = 4, x = -1",
          "expected_output": "[1,1,2,3]",
          "success": true,
          "output": "[1, 1, 2, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: generate all possible IP addresses from string s digits. Need backtracking. Provide steps. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's design:\n\nStart\n→ Step 1: 初始化結果列表 // 儲存符合條件的IP\n→ Step 2: 呼叫 DFS(位置=0,段數=0,路徑=[]) // 進行分割搜尋\n\nDefine DFS:\n\n→ Decision: 如果段數==4且位置==len(s)? // 完成四段且已用完字串\n    Yes → Step 3: 加入連接路徑為IP到結果 // 添加IP\n    No  → Decision: 如果段數==4? // 已經四段但未用完字串\n        Yes → Step 4: 返回 // 無效\n        No  → Decision: 迭代長度為1到3\n            For each length:\n                → Step 5: 子字串 = s[pos:pos+len] // 取候選段\n                → Decision: 子字串是否有效? (無前導零或長度1、數值≤255)\n                    Yes → Step 6: 路徑加入子字串\n                    → Step 7: DFS(位置+len,段數+1,路徑)\n                    → Step 8: 路徑移除最後一段 // 回溯\n                    No → Step 9: 跳過此長度 // 進行下一個長度\n\nWe need to output in format. Use \"→ Step X:\" lines.\n\nAlso include initial variable s given. Provide explanation in Chinese.\n\nLet's produce.\n\nWe need to ensure each line includes step number? Not required, but we can include step label. Let's produce.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化一個空列表 results 用於儲存所有合法的 IP 地址 // 建立結果容器  \n→ Step 2: 呼叫 DFS(索引 = 0, 段數 = 0, 路徑 = []) // 開始遞迴搜尋  \n→ Step 3: 定義函式 DFS(索引, 段數, 路徑) // 進入遞迴體  \n\n→ Decision: 如果 段數 == 4 且 索引 == len(s)？ // 已經分割成四段且用完所有字元  \n    Yes → Step 4: 將 路徑 用 '.' 連接成字串，加入 results // 存入合法 IP  \n    No  → Decision: 如果 段數 == 4？ // 已經四段但還有未用完的字元  \n        Yes → Step 5: 返回 // 無效路徑，停止處理  \n        No  → Decision: 迭代取長度 L 從 1 到 3  \n            For 每個 L:  \n                → Step 6: 如果 索引 + L > len(s)？ // 超出字串長度  \n                    Yes → Step 7: 跳過此 L，繼續下一個長度  \n                    No  → Step 8: 子字串 seg = s[索引 : 索引 + L] // 取得候選段  \n                    → Decision: 是否為合法段？（不含前導零，數值 ≤ 255）  \n                        Yes → Step 9: 將 seg 加入 路徑  \n                        → Step 10: DFS(索引 + L, 段數 + 1, 路徑) // 進一步遞迴  \n                        → Step 11: 從 路徑 移除最後一個 seg // 回溯到上一狀態  \n                        No  → Step 12: 跳過此 L，繼續下一個長度  \n→ End // 程式執行結束，結果已存於 results 變數中，返回 results。",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def restoreIpAddresses(self, s: str):\n        res = []\n\n        def backtrack(start: int, path: list):\n            # 完成四段且已使用完全部字元\n            if start == len(s) and len(path) == 4:\n                res.append(\".\".join(path))\n                return\n            # 已經四段但還有字元，無效路徑\n            if len(path) >= 4:\n                return\n            # 嘗試取長度為 1~3 的段\n            for length in range(1, 4):\n                if start + length > len(s):\n                    break\n                part = s[start:start+length]\n                # 前導零檢查與數值上限\n                if (part.startswith('0') and len(part) > 1) or int(part) > 255:\n                    continue\n                backtrack(start+length, path + [part])\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    # 從 \"s = \"xxx\"\" 這種格式提取字串，若沒有引號直接使用整行\n    if '\"' in raw_input:\n        start = raw_input.find('\"')\n        end = raw_input.rfind('\"')\n        s = raw_input[start+1:end]\n    else:\n        s = raw_input\n    solution = Solution()\n    result = solution.restoreIpAddresses(s)\n    # 輸出符合題目範例格式的 JSON 字串\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "[\"255.255.11.135\", \"255.255.111.35\"]"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "[\"0.0.0.0\"]"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "[\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for checking valid UTF-8 encoding for an array of integers (bytes). Use virtual code with arrows, decisions, etc. Provide explanations. Each line: \"虛擬碼步驟 // 解釋/說明\". Must be line by line.\n\nLet's design algorithm:\n\nStart\n→ Step: Initialize index i = 0 // start at first byte\n→ Decision: while i < length? // iterate through bytes\n    Yes → Step: Determine number of leading 1 bits in data[i] // count leading ones\n    → Decision: if count == 0? // 1-byte char\n        Yes → i += 1 // move to next byte\n        No → Decision: if count >=2 && count <=4? // valid start byte for multi-byte\n            Yes → Step: Check if remaining bytes exist: i + count -1 < length\n            → Decision: if not enough bytes? No → End with False\n            → Step: For j = 1 to count-1:\n                     → Decision: if data[i+j] has top 2 bits 10? // check continuation byte\n                         Yes → continue\n                         No → End with False\n            → i += count // skip processed bytes\n            No → End with False // invalid start byte\n    No → End with False // invalid count (1-5 or >4 etc)\nEnd // Return True\n\nBut we need to produce step lines. Use \"Decision:\" lines and arrow with Yes/No. Provide explanation.\n\nNeed to consider how to represent loops. Use \"Decision: while i < length?\" with Yes branch and loop again. In pseudocode we might use \"→ Decision: 是否到達陣列末尾?\" etc. Use proper Chinese.\n\nLet's produce.\n\nWe should maintain clarity.\n\nAlso, need to explain bit extraction: e.g., count leading ones: maybe use function \"CountLeadingOnes(byte)\".\n\nSimplify: Step: \"計算 data[i] 的前導 1 位數\" etc.\n\nAlso include condition for continuation bytes: top two bits equal to \"10\".\n\nLet's produce.\n\nWe also need to end with True if loop completes.\n\nLet's craft.\n\nUse \"Start // 程式開始執行\".\n\nNeed to use \"End // 程式執行結束\" and maybe \"Return True\" inside.\n\nLet's produce step-by-step.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ i ← 0 // 初始化索引指向第一個位元組  \n→ Decision: i < len(data) ? // 判斷是否還有未檢查的位元組  \n    Yes → Step: n ← CountLeadingOnes(data[i]) // 計算當前位元組前導 1 的數目  \n    → Decision: n == 0 ? // 1 位元組字符  \n        Yes → i ← i + 1 // 移到下一個位元組  \n        No → Decision: 2 ≤ n ≤ 4 ? // n 為 2~4 表示多位元組字符  \n            Yes → Decision: i + n - 1 < len(data) ? // 是否有足夠的續位元組  \n                No → End // 續位元組不足，返回 False  \n                Yes → Step: j ← 1 // 進行續位元組驗證  \n                → Decision: j < n ? // 仍有續位元組待檢查  \n                    Yes → Decision: data[i + j] has top 2 bits == 10 ? // 續位元組格式檢查  \n                        Yes → j ← j + 1 // 繼續下一個續位元組  \n                        No → End // 續位元組格式錯誤，返回 False  \n                    No → i ← i + n // 所有位元組檢查完畢，跳過此字符  \n            No → End // n 為 1 或 >4，無效的起始位元組，返回 False  \n    No → End // CountLeadingOnes 超出合法範圍，返回 False  \n→ End // 所有位元組均有效，返回 True",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def validUtf8(self, data):\n        n_bytes = 0  # how many continuation bytes are expected\n\n        for num in data:\n            # keep only the least significant 8 bits\n            byte = num & 0xFF\n            if n_bytes == 0:\n                # count leading 1 bits to determine the byte length\n                leading_ones = 0\n                mask = 0x80  # 10000000b\n                while mask & byte:\n                    leading_ones += 1\n                    mask >>= 1\n                if leading_ones == 0:\n                    # 1‑byte character\n                    continue\n                if leading_ones == 1 or leading_ones > 4:\n                    # 1‑byte character cannot start with 10xxxxxx\n                    # and length > 4 is invalid\n                    return False\n                n_bytes = leading_ones - 1  # remaining continuation bytes\n            else:\n                # continuation byte must start with 10\n                if (byte & 0xC0) != 0x80:\n                    return False\n                n_bytes -= 1\n\n        return n_bytes == 0\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Extracts a list of integers from an input string of the form:\n        data = [197,130,1]\n    \"\"\"\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        return []\n    # safely evaluate the slice inside brackets\n    return ast.literal_eval(input_str[start:end+1])\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    data = parse_input(raw_input.strip())\n    sol = Solution()\n    result = sol.validUtf8(data)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: given positions of houses and heaters on a horizontal line, find minimum radius such that heaters can cover all houses. It's LeetCode 475 \"Heaters\". We need to produce steps, not code. Each line includes \"虛擬碼步驟\" and explanation. Use arrows etc. We must consider algorithm: sort heaters, for each house find nearest heater using binary search, compute distance to nearest heater, take maximum. Steps: sort heaters, initialize maxRadius=0. For each house: binary search leftmost heater >= house, compute leftDist, rightDist, nearestDist = min(...), update maxRadius. Output maxRadius.\n\nAlso handle if no heaters? Not needed.\n\nLet's produce virtual code lines accordingly. Use Start, End, Decision, Step etc.\n\nMake sure each line ends with // explanation. Use \"→\" arrow. Provide indentation for nested decisions.\n\nWe need to avoid actual code, only virtual steps. Provide each step as separate line. Should cover sorting, binary search, loop over houses.\n\nLet's craft. Use \"Start // 程式開始執行\" etc.\n\nWe'll show algorithm: Input houses array, heaters array. Sort heaters. For each house, find nearest heater via binary search. Compute distances. Update radius. Finally output radius.\n\nLet's produce steps.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得房屋位置陣列 houses 與暖氣位置陣列 heaters // 從輸入中取得兩組座標  \n→ Step 2: 對 heaters 進行升序排序 // 方便後續二分搜尋  \n→ Step 3: 設定 maxRadius ← 0 // 這個變數會保存最小必須的暖氣半徑  \n→ Step 4: 從 houses 中逐一遍歷每一個 house // 需要確保所有房屋都被覆蓋  \n  → Step 4.1: 在 heaters 中執行二分搜尋，尋找第一個 heater 位置 ≥ house // 找到最近右側暖氣  \n    → Decision: 若找不到（所有 heater 都小於 house）  \n      Yes → 設定 rightIndex ← heaters.length // 右側沒有暖氣，使用虛擬索引  \n      No → 設定 rightIndex ← 搜尋得到的索引  \n    → Step 4.2: 計算 leftDist ← house - heaters[rightIndex-1]（若 rightIndex>0） // 距離左側最近暖氣  \n    → Step 4.3: 計算 rightDist ← heaters[rightIndex] - house（若 rightIndex < heaters.length） // 距離右側最近暖氣  \n    → Decision: 若兩邊都存在  \n      Yes → nearestDist ← min(leftDist, rightDist) // 取離這個房屋最近的暖氣距離  \n      No → 若只有左側或右側  \n       Yes → nearestDist ← leftDist 或 rightDist 取現有值 // 只有一側暖氣時使用那邊距離  \n    → Step 4.4: 若 nearestDist > maxRadius  \n      Yes → maxRadius ← nearestDist // 更新目前需要的最大半徑  \n      No → 不變  \n→ Step 5: 迴圈結束後 maxRadius 就是所有房屋都被暖氣覆蓋所需的最小半徑  \n→ Step 6: 輸出 maxRadius // 將結果傳回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_radius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    res = 0\n    i = 0  # 指向目前最近的右邊暖氣\n    for house in houses:\n        # 向右移動指標，直到找到離 house 最近的暖氣\n        while i + 1 < len(heaters) and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        res = max(res, abs(heaters[i] - house))\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中擷取兩個列表字串\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        houses = ast.literal_eval(lists[0])\n        heaters = ast.literal_eval(lists[1])\n    else:\n        houses = []\n        heaters = []\n\n    radius = find_radius(houses, heaters)\n    print(radius)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode591.json",
    "problem_index_in_file": 0,
    "title": "Tag Validator",
    "description_snippet": "Given a string representing a code snippet, implement a tag validator to parse the code and return w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line, explaining. Provide steps of algorithm to validate code snippet. Must adhere to format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow.\n\nWe'll produce algorithm: parse string index, use stack. Validate tags, cdata. Provide high-level steps: Start, parse outer tag, etc. Must be step by step. Not actual code, just pseudocode steps.\n\nWe'll produce a list of steps, maybe around 20-30 lines. Include decisions for each rule. Provide arrows. Use structure.\n\nLet's draft.\n\nLine 1: Start // program start\n\nLine 2: → Step 1: Initialize index = 0, stack = empty, length = len(input) // setup\n\nLine 3: → Step 2: If not starts with '<' → End with False // must start with tag\n\nLine 4: → Decision: 是否為開始標籤? // check\n\nYes: if string[index] == '<' and next char not '!' or '/'\n\n→ Step 3: Parse start tag name until '>' // capture start tag name\n\n→ Step 4: Validate tag name length 1-9 and all uppercase // rule 3\n\n→ Decision: Tag name valid? // continue\n\nYes: push tag name to stack\n\nNo: End False // invalid\n\nThen continue scanning content until we find matching end tag for the outermost tag; but we need check entire content inside.\n\nWe can parse content recursively: when encountering '<' we determine if start tag, end tag, or cdata.\n\nWe can write Step 5: While index < length:\n\n→ Decision: current char == '<' ?\n\nYes:\n\n→ Decision: next char == '!' ?\n\nYes: // CDATA\n\n→ Step 6: Verify sequence '<![CDATA[' // rule 7\n\n→ Step 7: Find next ']]>' and consume up to it\n\n→ Continue // treat content inside as plain text\n\nNo: // not cdata\n\n→ Decision: next char == '/' ?\n\nYes: // end tag\n\n→ Step 8: Parse end tag name until '>' // capture\n\n→ Step 9: If stack empty or top != end tag name → End False // unmatched\n\n→ Pop stack\n\n→ Continue\n\nNo: // start tag\n\n→ Step 10: Parse start tag name until '>' // capture\n\n→ Step 11: Validate name as before\n\n→ Decision: name valid?\n\nYes: push onto stack\n\nNo: End False\n\n→ Continue\n\nElse (current char not '<'):\n\n→ Step 12: Move index++ // consume plain character\n\nEnd While\n\nAfter loop, Decision: stack empty? Yes -> End True else False // unclosed tags\n\nAlso need to ensure outer tag closed: we already validate that first start tag has corresponding end tag.\n\nAlso rule about unmatched <: if '<' without following '>' → End False. We should check that when parsing tags and cdata we find '>'.\n\nAlso unmatched start or end tag: we handle via stack.\n\nOk produce steps.\n\nWe need to output line by line with arrow arrows, decisions.\n\nLet's produce maybe 30 lines.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 index = 0，stack = 空，len = 輸入字串長度 // 初始化\n→ Step 2: 若輸入字串首字不是 '<' → End False // 必須以開標籤開始\n→ Decision: index 的字元是否為 '<'？ // 判斷是否為標籤開始\n    Yes → Step 3: 若字元後為 '!' 或 '/'，則為非法開標籤 → End False // 只能是開標籤\n    No  → Step 4: 從 index+1 開始，向右尋找下個 '>' 以獲取開標籤名稱 // 解析開標籤\n→ Step 5: 若未找到 '>' 或 index 超出長度 → End False // 未匹配到閉合符號\n→ Step 6: 提取 tagName = substring(index+1, pos_of_>) // 開標籤名稱\n→ Step 7: 驗證 tagName 長度 1~9 且全大寫 // 規則 3\n→ Decision: tagName 合法？\n    Yes → Step 8: push tagName 到 stack\n    No  → End False // 標籤名稱非法\n→ Step 9: index = pos_of_> + 1 // 移至開標籤後的位置\n→ Step 10: While index < len：\n    → Decision: current 字元是否為 '<'？\n        Yes →\n            → Decision: next 字元是否為 '!'？\n                Yes → // 可能為 CDATA\n                    → Step 11: 檢查是否以 \"<![CDATA[\" 開頭\n                    → Decision: 是否匹配？\n                        Yes → Step 12: 從 index+9 開始尋找 \"]]>\" 位置\n                        → Decision: 找到 \"]]>\" 吗？\n                            Yes → index = pos_of_]]> + 3 // 跳過 CDATA\n                            No  → End False // CDATA 未正確結束\n                        No  → End False // 不是 CDATA，視為非法標籤\n                No  → // 不是 CDATA，檢查是否為結束標籤\n                    → Decision: next 字元是否為 '/'？\n                        Yes →\n                            → Step 13: 從 index+2 開始尋找下個 '>' 以取得結束標籤名稱\n                            → Step 14: 若未找到 '>' → End False\n                            → Step 15: 提取 endTagName\n                            → Decision: stack 是否為空？\n                                Yes → End False // 沒有對應開標籤\n                                No  →\n                                    → Decision: stack.top() 是否等於 endTagName？\n                                        Yes → pop stack\n                                        No  → End False // 標籤名稱不匹配\n                            → index = pos_of_> + 1\n                        No  → // 為新的開標籤\n                            → Step 16: 從 index+1 開始尋找下個 '>' 以取得開標籤名稱\n                            → Step 17: 若未找到 '>' → End False\n                            → Step 18: 提取 newTagName\n                            → Step 19: 驗證 newTagName 合法性（長度 1~9、全大寫）\n                            → Decision: 合法？\n                                Yes → push newTagName 到 stack\n                                No  → End False // 標籤名稱非法\n                            → index = pos_of_> + 1\n        No  → // 不是 '<'，為普通字元\n            → Step 20: index = index + 1 // 消費字元\n→ Step 21: 迴圈結束\n→ Decision: stack 為空？\n    Yes → End True // 所有標籤都已正確配對\n    No  → End False // 仍有未關閉的標籤\nEnd // 程式執行結束",
      "generated_code": "class Solution(object):\n    def isValid(self, code):\n        stack = []\n        i = 0\n        n = len(code)\n\n        while i < n:\n            # 若已經處理完第一個標籤但堆疊已空，代表有不在標籤內的文字\n            if i > 0 and not stack:\n                return False\n\n            # 1. CDATA 區段\n            if code.startswith(\"<![CDATA[\", i):\n                j = i + 9\n                end = code.find(\"]]>\", j)\n                if end == -1:\n                    return False\n                i = end + 3\n                continue\n\n            # 2. 結束標籤\n            if code.startswith(\"</\", i):\n                j = i + 2\n                end = code.find(\">\", j)\n                if end == -1:\n                    return False\n                tag_name = code[j:end]\n                if not stack or stack[-1] != tag_name:\n                    return False\n                stack.pop()\n                i = end + 1\n                continue\n\n            # 3. 開啟標籤\n            if code[i] == \"<\":\n                j = i + 1\n                end = code.find(\">\", j)\n                if end == -1 or end == j or end - j > 9:\n                    return False\n                tag_name = code[j:end]\n                if not tag_name.isupper() or not tag_name.isalpha():\n                    return False\n                stack.append(tag_name)\n                i = end + 1\n                continue\n\n            # 4. 普通文字\n            i += 1\n\n        # 所有標籤必須已配對完畢，且程式碼必須以整個標籤包住\n        return not stack and n >= 2 and code[0] == '<' and code[-1] == '>'\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read()\n    # 取出最外層的字串（如果有 code = \"xxx\" 的形式）\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        code = data[first_quote + 1:last_quote]\n    else:\n        code = data.strip()\n    sol = Solution()\n    print(\"true\" if sol.isValid(code) else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "code = \"<DIV>This is the first line <![CDATA[<div>]]></DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "code = \"<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "code = \"<A>  <B> </A>   </B>\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode679.json",
    "problem_index_in_file": 0,
    "title": "24 Game",
    "description_snippet": "You are given an integer array cards of length 4. You have four cards, each containing a number in t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode that solves the 24 game. We output line by line, with virtual code steps and comments. Use Start, End, Decision, arrow.\n\nWe must produce algorithm: iterate over all permutations of cards, all ways to insert operators and parentheses. Use recursion to combine numbers.\n\nSimpler: recursion that takes list of numbers; if one number and close to 24 return true; else for each pair of numbers, apply each operator to produce new number, recursing with new list of numbers (size-1). Use floating point tolerance.\n\nThus produce steps. Ensure each line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft:\n\nStart\n→ Step: Sort cards? Not necessary.\n→ Step: Call solve(cards)\n→ Decision: solve(cards) returns true? Yes → Return true\n→ Decision: else → Return false\nEnd\n\nDefine solve function:\n→ Function solve(nums): // nums is list of floats\n→ Decision: length(nums) == 1? // base case\n    Yes → Decision: abs(nums[0]-24) < eps? // tolerance\n        Yes → Step: Return true\n        No  → Step: Return false\n    No → Step: For each i<j in nums: // choose pair\n→ Step: a = nums[i], b = nums[j]\n→ Step: remaining = nums except i,j\n→ Step: For each op in ['+','-','*','/']:\n    → Decision: op is '/' and b==0? // avoid division by zero\n        Yes → Continue\n        No → Step: result = compute(a,b,op)\n        → Step: newNums = remaining + [result]\n        → Step: If solve(newNums) then Return true\n→ Step: After all combos, Return false\n\nAlso compute function compute(a,b,op) returns a+b etc.\n\nWe produce these lines.\n\nMake sure to format as \"虛擬碼步驟 // 解釋\" each line. Use arrow arrows inside.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 呼叫 solve(cards) // 將原始卡片序列傳給遞迴求解\n→ Decision: solve(cards) 為 true? // 判斷是否能達到 24\n    Yes → Step: 回傳 true // 成功找到合法表達式\n    No  → Step: 回傳 false // 所有組合都無法達成 24\nEnd // 程式執行結束\n\n// ---------- solve 函式 ----------\n→ Function solve(nums) // nums 為浮點數列表，代表目前可用的數字\n→ Decision: nums.length == 1? // 基本情況：只剩一個數字\n    Yes → Decision: abs(nums[0] - 24) < eps? // 檢查是否等於 24（容忍誤差）\n        Yes → Step: 回傳 true // 找到合法表達式\n        No  → Step: 回傳 false // 不是 24\n    No → Step: // 仍有多個數字，需嘗試組合\n        → Step: for i in 0..nums.length-1 // 選取第一個數字\n            → Step: for j in i+1..nums.length-1 // 選取第二個數字\n                → Step: a = nums[i]\n                → Step: b = nums[j]\n                → Step: remaining = nums 刪除索引 i、j 的數字 // 其餘數字\n                → Step: for op in ['+','-','*','/'] // 四種運算符\n                    → Decision: op == '/' 且 b == 0? // 避免除以零\n                        Yes → Step: 繼續 // 跳過此組合\n                        No  → Step: result = compute(a, b, op) // 計算兩數結果\n                        → Step: newNums = remaining + [result] // 新列表\n                        → Decision: solve(newNums) 為 true? // 進一步遞迴\n                            Yes → Step: 回傳 true // 成功\n                            No  → Step: 繼續 // 試下一個運算符\n→ Step: // 所有組合均失敗\n→ Step: 回傳 false\n\n// ---------- compute 函式 ----------\n→ Function compute(x, y, op) // 計算兩數 x op y\n→ Decision: op == '+'? \n    Yes → Step: 回傳 x + y\n    No  → Decision: op == '-'? \n        Yes → Step: 回傳 x - y\n        No  → Decision: op == '*'? \n            Yes → Step: 回傳 x * y\n            No  → Step: 回傳 x / y // 真除法，除數非零已在前面檢查\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nfrom itertools import permutations\nimport operator\n\nclass Solution:\n    def judgePoint24(self, cards):\n        def dfs(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i == j:\n                        continue\n                    a, b = nums[i], nums[j]\n                    rest = [nums[k] for k in range(len(nums)) if k != i and k != j]\n                    for op in [operator.add, operator.sub, operator.mul, operator.truediv]:\n                        if op == operator.truediv and b == 0:\n                            continue\n                        rest.append(op(a, b))\n                        if dfs(rest):\n                            return True\n                        rest.pop()\n            return False\n\n        for perm in permutations(cards):\n            if dfs(list(perm)):\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    # Input format example: \"cards = [4,1,8,7]\"\n    try:\n        _, list_str = input_data.split('=', 1)\n        cards = ast.literal_eval(list_str.strip())\n    except Exception:\n        # Fallback: try to evaluate the whole input\n        cards = ast.literal_eval(input_data.strip())\n    solution = Solution()\n    result = solution.judgePoint24(cards)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "cards = [4,1,8,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "cards = [1,2,1,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode557.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String III",
    "description_snippet": "Given a string s, reverse the order of characters in each word within a sentence while still preserv...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reversing characters of each word in a string while preserving whitespace and word order. Use the format. Include steps: Start, Input s, maybe split by whitespace? But preserve whitespace: we can iterate over string and build words. But virtual code simple: Use regex to split preserving whitespace? Could iterate each character: if letter accumulate; on whitespace output reversed word. Provide decision: if char is whitespace or end-of-string. Provide output. End.\n\nWe produce lines with arrow and comments. Use Start, End, Decision. Provide \"→ Step 1: ...\" etc.\n\nMake sure each line: Virtual Code Step + space + // Explanation.\n\nFollow example style: Start // 程式開始執行. → Step 1: ...\n\nLet's create steps:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty result string and empty word buffer // 設定結果與暫存字元\n→ Step 2: 遍歷 s 的每個字符 // 逐字進行處理\n→ Decision: 如果字符是空白? // 判斷是否為分隔符\n    Yes → Step 3: 將 word buffer 逆序後附加到結果 // 把累積的字詞反轉並加到結果\n    Yes → Step 4: 將空白字符直接附加到結果 // 保留原始空白\n    Yes → Step 5: 清空 word buffer // 重置字詞儲存\n    No  → Step 6: 把字符加入 word buffer // 收集字詞\n→ Decision: 迴圈結束? // 完成遍歷\n    No → 回到 Step 2\n    Yes → Step 7: 迴圈結束後，將剩餘 word buffer 逆序並附加到結果 // 處理最後一個字詞\n→ Step 8: 輸出結果 // 回傳反轉後的字串\nEnd // 程式執行結束\n\nMake sure to use arrows as per format. Use \"Yes →\" \"No →\" for decisions. Provide explanation after //.\n\nWe need to maintain proper indentation? The example shows indent for nested decisions. We can do same.\n\nWe must use virtual code arrow symbols exactly. Provide \"→ Decision:\" lines. For nested decisions we indent with 4 spaces? Example shows indent with 4 spaces. We'll replicate.\n\nWe must ensure each line has virtual code and comment. Use Chinese explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字串 result 與空字元緩衝 wordBuffer // 設定結果與暫存字元  \n→ Step 2: 遍歷 s 的每個字符 ch // 逐字進行處理  \n→ Decision: 若 ch 為空白字元? // 判斷是否為分隔符  \n  Yes → Step 3: 把 wordBuffer 逆序後附加至 result // 把累積的字詞反轉並加到結果  \n  Yes → Step 4: 將空白字元直接附加至 result // 保留原始空白  \n  Yes → Step 5: 清空 wordBuffer // 重置字詞儲存  \n  No  → Step 6: 將 ch 加入 wordBuffer // 收集字詞  \n→ Decision: 是否已處理完所有字符? // 完成遍歷  \n  No → 回到 Step 2  \n  Yes → Step 7: 迴圈結束後，將剩餘 wordBuffer 逆序並附加至 result // 處理最後一個字詞  \n→ Step 8: 輸出 result // 回傳反轉後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        將句子中每個單字的字元順序反轉，保留空白與單字順序。\n        \"\"\"\n        # 用空白分割單字，對每個單字做字串反轉，最後用空白重新連接\n        return \" \".join(word[::-1] for word in s.split(\" \"))\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin，處理輸入並輸出結果。\n    預期輸入形式類似：\n        s = \"Let's take LeetCode contest\"\n    \"\"\"\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含 '='，將等號右側的字串解析為 Python 字串\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        s = ast.literal_eval(rhs.strip())\n    else:\n        # 直接將整行當成字串\n        s = ast.literal_eval(data)\n\n    # 執行解法\n    result = Solution().reverseWords(s)\n\n    # 按照範例輸出，將結果包在雙引號內\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Let's take LeetCode contest\"",
          "expected_output": "\"s'teL ekat edoCteeL tsetnoc\"",
          "success": true,
          "output": "\"s'teL ekat edoCteeL tsetnoc\""
        },
        {
          "example_index": 1,
          "input": "s = \"Mr Ding\"",
          "expected_output": "\"rM gniD\"",
          "success": true,
          "output": "\"rM gniD\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for problem: given array, find all unique non-decreasing subsequences of length>=2. It's essentially LeetCode 491. Need to generate pseudocode with steps, decisions, recursion/backtracking, set to avoid duplicates. Use virtual code lines with arrows. Provide explanation after each line.\n\nLet's produce:\n\nStart\n→ Step: Initialize result list\n→ Step: Define backtrack function(start, path)\n→ Step: For i from start to n-1\n→ Decision: If path empty or nums[i] >= last of path?\n→ Yes → Add nums[i] to path\n→ Decision: If length of path >=2 → Add copy of path to result\n→ Recursive call backtrack(i+1, path)\n→ Backtrack: Remove last element\n→ End loop\n→ End function\n→ Call backtrack(0, empty)\n→ Return result\n\nBut we need to handle duplicates: using set inside loop to skip same value at same level. We'll add a local set visited to skip duplicates. Add decision to skip duplicate.\n\nAlso maintain output order not needed.\n\nLet's produce lines with explanation.\n\nWe must use virtual arrows.\n\nWe'll produce as many lines as needed. Use \"→\" to show next step. Use \"Decision:\" lines for if.\n\nAlso need to include \"Start\" and \"End\". Let's produce.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義變數 `result` 為空列表 // 用來存放所有符合條件的子序列  \n→ Step: 定義遞迴函式 `backtrack(start, path)` // start: 當前考慮的索引，path: 當前已構建的子序列  \n→ Step: 在 `backtrack` 內部，建立局部集合 `visited` 為空集合 // 用於同一層級避免重複選擇相同數值  \n→ Step: 循環變數 `i` 從 `start` 到 `len(nums)-1`  \n→ Decision: 如果 `visited` 包含 `nums[i]`? // 同一層級已處理過此數值  \n  Yes → 跳過此迴圈迭代 // 防止重複子序列  \n  No  →  \n   → Step: 將 `nums[i]` 加入 `visited` // 記錄已使用的數值  \n   → Decision: `path` 為空 或 `nums[i] >= path[-1]`? // 判斷是否可以延續非遞減序列  \n    Yes →  \n     → Step: 把 `nums[i]` 加到 `path` // 進行擴展  \n     → Decision: `len(path) >= 2`? // 子序列長度是否達到要求  \n      Yes → Step: 把 `path` 的拷貝加入 `result` // 收集符合條件的子序列  \n      No  → // 不收集  \n     → Step: 呼叫 `backtrack(i+1, path)` // 深度優先遞迴，下一層繼續搜索  \n     → Step: 從 `path` 移除最後一個元素 // 回溯，恢復狀態  \n     → // 結束此迴圈迭代  \n→ End loop // 完成所有索引的遍歷  \n→ End function // `backtrack` 定義完成  \n→ Step: 呼叫 `backtrack(0, [])` // 從第一個元素開始搜索  \n→ Step: 返回 `result` // 輸出所有不同的非遞減子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findSubsequences(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 若已經有兩個以上元素，將副本加入結果\n            if len(path) > 1:\n                res.append(path[:])\n            used = set()          # 同層級避免重複\n            for i in range(start, len(nums)):\n                # 只考慮非遞減的情況，並且忽略本層級已使用的相同數值\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()   # 回溯\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中抓取第一個出現的方括號內部內容並轉成列表\n    match = re.search(r'\\[.*\\]', data)\n    nums = eval(match.group()) if match else []\n    sol = Solution()\n    result = sol.findSubsequences(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4, 4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for designing a TinyURL service class. Provide step-by-step pseudo code for encode and decode. Use Start, End, Decision, etc. Provide comments. Let's design algorithm: maintain counter, map from short to long, map from long to short maybe. Use base62 encoding of counter to generate short path. Domain fixed: http://tinyurl.com/. Steps: init counter to 0, maps. Encode: if longUrl already in map, return existing short. Else increment counter, convert to base62 string, store mapping both ways, return full short. Decode: parse token from shortUrl after domain, lookup map, return longUrl. Let's output pseudo-code with lines: Start, etc. Use arrow \"→\". Provide explanations. Ensure each line ends with // comment. No actual code. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化計數器 counter ← 0 // 用於生成唯一短碼  \n→ Step 2: 初始化映射 dictShortToLong ← {} // short -> long  \n→ Step 3: 初始化映射 dictLongToShort ← {} // long -> short  \n\nEncode(longUrl)  \n→ Step 4: Decision: 是否已存在長網址在 dictLongToShort? // 檢查重複  \n  Yes → Step 5: 獲取已存在 shortCode ← dictLongToShort[longUrl] // 取出已有短碼  \n  No  → Step 6: counter ← counter + 1 // 產生新序號  \n    → Step 7: shortCode ← ConvertToBase62(counter) // 轉成 62 進位字串  \n    → Step 8: dictShortToLong[shortCode] ← longUrl // 兩向儲存  \n    → Step 9: dictLongToShort[longUrl] ← shortCode // 兩向儲存  \n→ Step 10: 返回 \"http://tinyurl.com/\" + shortCode // 組合成完整短網址  \n\nDecode(shortUrl)  \n→ Step 11: 截取 shortCode ← substring(shortUrl, 域名長度) // 取得字串後綴  \n→ Step 12: longUrl ← dictShortToLong[shortCode] // 查表還原長網址  \n→ Step 13: 返回 longUrl // 回傳原始網址  \n\nConvertToBase62(number)  \n→ Step 14: 定義字符集 chars ← \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"  \n→ Step 15: 初始化 result ← \"\"  \n→ Step 16: Decision: number == 0? // 特殊情況  \n  Yes → Step 17: result ← chars[0]  \n  No  → Step 18: while number > 0:  \n    → Step 19: remainder ← number mod 62  \n    → Step 20: result ← chars[remainder] + result // 逐位累加  \n    → Step 21: number ← number / 62  \n→ Step 22: 返回 result // 生成的 62 進位短碼  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\nimport string\n\nclass Codec:\n    \"\"\"簡易 TinyURL 編碼/解碼實作。\"\"\"\n    def __init__(self):\n        # 存放短碼 -> 原網址 的對應關係\n        self.url_map = {}\n        self.base_url = \"http://tinyurl.com/\"\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"將長網址編碼成短網址。\"\"\"\n        # 產生 6 位隨機字元的短碼\n        key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))\n        # 確保短碼唯一\n        while key in self.url_map:\n            key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))\n        # 存入對應關係\n        self.url_map[key] = longUrl\n        return self.base_url + key\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"將短網址解碼回原始長網址。\"\"\"\n        # 取得短碼部分\n        key = shortUrl.replace(self.base_url, '')\n        return self.url_map.get(key, '')\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    raw_input = sys.stdin.read().strip()\n    # 去除可能存在的外部雙引號\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    # 若輸入為空則不進行處理\n    if not raw_input:\n        sys.exit(0)\n\n    codec = Codec()\n    short = codec.encode(raw_input)   # 編碼成短網址\n    decoded = codec.decode(short)     # 再解碼回長網址\n    print(decoded)                    # 輸出結果",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode745.json",
    "problem_index_in_file": 0,
    "title": "Prefix and Suffix Search",
    "description_snippet": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the W...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The algorithm: We need WordFilter class with constructor and f method. Need to handle prefix and suffix search, return largest index.\n\nWe can implement using Trie with combined prefix and suffix maybe. Simpler: use two Tries: prefix trie and suffix trie. For each word, insert all prefixes and suffixes with index. Then f: traverse prefix trie for pref, get set of indices; traverse suffix trie for suff reversed, get set. Intersect and get max. But we need efficient: we can store for each node the list of indices sorted descending.\n\nSimpler: use a hashmap mapping prefix+suffix to max index; but that would be huge. Alternative: Use trie that stores for each prefix node a map of suffixes to max index.\n\nBut we just need virtual code.\n\nWe'll design as:\n\n- Build a prefix trie where each node has a map suffixTrie root? Actually we can store in each node a list of indices of words that share that prefix. Then in f, we get list from prefix node, iterate to find word that also has suff. We can pre-process suffix trie or for each word we check.\n\nBut we can implement: store words array. In f, iterate words list from last to first, check if startswith and endswith. That's O(n) per query, but okay.\n\nBut produce virtual code accordingly.\n\nWe'll implement WordFilter with words array, and f uses loop. Provide virtual code with Start, etc.\n\nOk.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: WordFilter(words) // 初始化字典\n→ Decision: 何時完成建構? // 建構完成\nEnd\n\nFor f:\n\n→ Step 1: Define f(pref, suff)\n→ Decision: 遍歷 words 從最後到第一? // 逆序尋找最大索引\n→ Loop: for i from len(words)-1 down to 0\n    → Decision: words[i] 是否以 pref 開頭? // 檢查前綴\n        Yes →\n            → Decision: words[i] 是否以 suff 結尾? // 檢查後綴\n                Yes → Step: Return i // 找到最大索引\n                No  → Next loop iteration\n        No  → Next loop iteration\n→ Step: Return -1 // 未找到\n\nBut need to show virtual code lines each with explanation.\n\nWe'll produce.\n\nAlso include maybe \"End\" of f.\n\nLet's craft.\n\nUse arrows.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: WordFilter(words) // 初始化物件，保存原始字串陣列\n→ End // 物件建構完成\n\nNow f method:\n\n→ Step 1: f(pref, suff) // 方法入口\n→ Step 2: n = len(words) // 取得字典長度\n→ Decision: 先從最後一個索引開始遍歷? // 逆序遍歷以取得最大的索引\n    → Loop: i = n-1 到 0\n        → Decision: words[i] 是否以 pref 開頭? // 前綴檢查\n            Yes →\n                → Decision: words[i] 是否以 suff 結尾? // 後綴檢查\n                    Yes → Step: Return i // 找到符合條件的最大索引\n                    No  → Step: Continue // 不是後綴，繼續下一個\n            No  → Step: Continue // 不是前綴，繼續下一個\n→ Step: Return -1 // 所有字串都不符合條件\n\nAdd End for f.\n\nBut we need to use arrows \"→\" each line.\n\nAlso we can indent for decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ WordFilter(words) // 建構函式：將使用者提供的字串陣列存入物件  \nEnd // 物件建構完成  \n\n→ f(pref, suff) // 方法入口：接收前綴 pref 與後綴 suff  \n→ n = len(words) // 取得字典長度  \n→ Decision: 逆序遍歷字典以找尋最大的索引? // 這樣可以在第一次符合時直接回傳  \n    → Loop: i = n-1 到 0  \n        → Decision: words[i] 以 pref 開頭? // 檢查前綴  \n            Yes →  \n                → Decision: words[i] 以 suff 結尾? // 檢查後綴  \n                    Yes → Return i // 找到符合條件的最大索引，結束搜尋  \n                    No  → Continue // 不是後綴，進行下一個迴圈  \n            No  → Continue // 不是前綴，進行下一個迴圈  \n→ Return -1 // 所有字串皆不符合條件，返回 -1  \nEnd // 方法結束執行",
      "generated_code": "import sys\nimport json\nfrom typing import List, Tuple\n\nclass WordFilter:\n    def __init__(self, words: List[str]):\n        \"\"\"\n        建構時為每個單詞建立所有可能的前綴與後綴組合，並記錄對應的權重（索引）。\n        權重越大代表字典中位置越靠後，符合題目「取最大索引」的需求。\n        \"\"\"\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):            # i 為前綴長度\n                for j in range(L + 1):        # j 為後綴長度\n                    prefix = word[:i]\n                    suffix = word[j:]\n                    # 只保留最大的權重（索引）\n                    self.lookup[(prefix, suffix)] = weight\n\n    def f(self, prefix: str, suffix: str) -> int:\n        \"\"\"\n        回傳同時以給定前綴與後綴開頭與結尾的單詞最大索引。\n        若不存在符合條件的單詞，回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    \"\"\"\n    主程式：從標準輸入讀取資料，格式為：\n        words_list, [prefix, suffix]\n    例如：['apple', 'app'], ['ap', 'le']\n    讀取後建立 WordFilter 物件並輸出 f(prefix, suffix) 的結果。\n    \"\"\"\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit()\n\n    # 將整個輸入包裹成外層陣列，方便使用 json.loads\n    try:\n        data = json.loads('[' + data_str + ']')\n    except json.JSONDecodeError as e:\n        # 若格式不符合，直接終止\n        print(-1)\n        sys.exit()\n\n    words = data[0]              # 取得單詞列表\n    query = data[1]              # 取得 [prefix, suffix] 列表\n    prefix, suffix = query[0], query[1]\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp5ims6gac.py\", line 51, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5ims6gac.py\", line 19, in __init__\n    self.lookup[(prefix, suffix)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow and explanation. The user wants: \"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, \"Aa\" is not considered a palindrome.\" So we need to produce virtual code steps. Use Start, End, Decision, Step etc. Should output line by line. Each line: Virtual code step + space + // explanation.\n\nWe need to incorporate logic: Count characters, compute how many can be used, if odd count exists, can use one center. So algorithm: count freq of each letter, sum counts that are even, and for odd counts, sum counts-1, and if any odd exists, add 1. Output total.\n\nWe'll output as pseudo-steps: Start, Step 1: Initialize dictionary, Step 2: Iterate over s, Step 3: Count frequencies, Step 4: Initialize palindrome length = 0, Step 5: Iterate over counts, if count even add count, else add count-1, mark odd flag. Step 6: If odd flag add 1. Step 7: Output palindrome length. End.\n\nAlso include decisions: if char present, else etc. Use Decision for odd flag.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 建立空字典 freq // 用於統計每個字母出現次數\n→ Step 2: 對 s 中每個字元 c 迭代 // 逐個讀取字元\n    → Decision: c 是否已在 freq? // 檢查字典中是否已存在該字母\n        Yes → freq[c] = freq[c] + 1 // 先前已出現，次數加 1\n        No  → freq[c] = 1 // 首次出現，次數設為 1\n→ Step 3: 設定 palindrome_len = 0 // 初始化可建構的回文長度\n→ Step 4: 設定 has_odd = False // 標記是否存在奇數頻次字母\n→ Step 5: 對 freq 的每個 (c, cnt) 迭代 // 逐個字母計算\n    → Decision: cnt 是否為偶數? // 判斷頻次是否為偶數\n        Yes → palindrome_len = palindrome_len + cnt // 直接加入長度\n        No  → palindrome_len = palindrome_len + (cnt - 1) // 只使用偶數部分\n             → has_odd = True // 標記有奇數頻次\n→ Step 6: Decision: has_odd 是否為 True? // 判斷是否有可放中心的字母\n    Yes → palindrome_len = palindrome_len + 1 // 加入中心字母\n    No  → // 無中心字母，長度不變\n→ Step 7: 輸出 palindrome_len // 回傳最長回文長度\nEnd // 程式執行結束\n\nMake sure format: each line with step and explanation. Use arrow for indentation: Use \"→\" preceding step. Use Decision: block indentation with further arrow lines. Indentation: Use tabs or spaces? Use two spaces maybe. The example shows indent with spaces: \"    Yes →\". We'll mimic that.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立空字典 freq // 用於統計每個字母出現次數  \n→ Step 2: 對 s 中每個字元 c 迭代 // 逐個讀取字元  \n    → Decision: c 是否已在 freq? // 檢查字典中是否已存在該字母  \n        Yes → freq[c] = freq[c] + 1 // 先前已出現，次數加 1  \n        No  → freq[c] = 1 // 首次出現，次數設為 1  \n→ Step 3: 設定 palindrome_len = 0 // 初始化可建構的回文長度  \n→ Step 4: 設定 has_odd = False // 標記是否存在奇數頻次字母  \n→ Step 5: 對 freq 的每個 (c, cnt) 迭代 // 逐個字母計算  \n    → Decision: cnt 是否為偶數? // 判斷頻次是否為偶數  \n        Yes → palindrome_len = palindrome_len + cnt // 直接加入長度  \n        No  → palindrome_len = palindrome_len + (cnt - 1) // 只使用偶數部分  \n             → has_odd = True // 標記有奇數頻次  \n→ Step 6: Decision: has_odd 是否為 True? // 判斷是否有可放中心的字母  \n    Yes → palindrome_len = palindrome_len + 1 // 加入中心字母  \n    No  → // 無中心字母，長度不變  \n→ Step 7: 輸出 palindrome_len // 回傳最長回文長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\ndef longest_palindrome(s: str) -> int:\n    \"\"\"Return the length of the longest palindrome that can be built from the string s.\"\"\"\n    count = Counter(s)\n    length = 0\n    odd_found = False\n    for val in count.values():\n        if val % 2 == 0:\n            length += val\n        else:\n            length += val - 1\n            odd_found = True\n    if odd_found:\n        length += 1\n    return length\n\ndef main() -> None:\n    \"\"\"Read input from stdin, compute and print the answer.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse the input: handle formats like 's = \"abc\"' or just 'abc'\n    if '=' in data:\n        _, val = data.split('=', 1)\n        val = val.strip()\n        if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n            val = val[1:-1]\n        s = val\n    else:\n        s = data\n\n    result = longest_palindrome(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the LeetCode problem: maximize capital by picking at most k projects given profits and capital thresholds, starting with w. Classic problem: use a min-heap for capital thresholds and max-heap for profits. Steps: sort projects by capital ascending, use a pointer, for each of k iterations, add all projects whose capital <= current capital to a max-heap, then pick the project with max profit, add to capital. End.\n\nWe must produce lines in the specified format: each line: virtual code step + space + // explanation.\n\nUse arrows and decisions. We need to use \"Start\", \"End\". Use \"→\" for steps. Use \"Decision:\" where needed.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 將所有項目按資本需求升序排序 // 方便快速檢查可啟動的項目\n→ Step 2: 初始化最大堆 profitHeap 用於存放可選項目的利潤 // 從中取最大利潤\n→ Step 3: 初始化指標 idx = 0 // 指向排序後項目陣列的下個候選項目\n→ Step 4: 循環執行至 k 次或無可選項目 // 主流程\n    Decision: 是否已達到 k 次? // 判斷是否已選擇 k 個項目\n        Yes → End // 結束循環\n        No → \n    → Step 5: 在 profitHeap 中加入所有資本需求 <= currentCapital 的項目 // 把可啟動項目推進最大堆\n        → Decision: 是否有符合條件的項目? // 判斷是否可加入\n            Yes → \n            No  → \n    → Step 6: 如果 profitHeap 非空，彈出最大利潤並加到 currentCapital // 執行選擇項目\n        Decision: profitHeap 是否非空? // 判斷是否有可選項目\n            Yes → \n            No  → \n    → Step 7: 回到循環起始點 // 重複\n\nBut we need to show the arrows. Might use indentation for decisions.\n\nWe need to use \"Yes →\" \"No →\" lines. We can incorporate decisions inside steps. Might show like:\n\n→ Decision: 是否已選 k 個項目? \n    Yes → End\n    No → ...\n\nBut the instruction says use \"Decision:\" lines with indentation.\n\nWe'll produce a fairly detailed pseudo-code.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將所有項目對應的 (capital[i], profits[i]) 以 capital 升序排序 // 方便按可用資本篩選可啟動的項目  \n→ Step 2: 建立一個最大堆 profitHeap 用於存放可啟動項目的利潤 // 從中取得最大利潤  \n→ Step 3: 初始化指標 idx = 0 // 用於遍歷已排序的項目陣列  \n→ Step 4: 設定 currentCapital = w // 初始可用資本  \n→ Step 5: 重複以下步驟最多 k 次  \n    → Decision: 是否已執行 k 次? // 判斷是否已選擇 k 個項目  \n        Yes → End // 程式結束，返回最終資本  \n        No →  \n    → Step 6: 將所有 capital[idx] <= currentCapital 的項目入 profitHeap，並遞增 idx  \n        → Decision: 是否存在 such 项目？ // 判斷是否可以加入堆  \n            Yes →  \n            No  →  \n    → Step 7: Decision: profitHeap 是否非空？ // 是否有可選項目可執行  \n        Yes → Step 8: 從 profitHeap 取出最大利潤 profitMax，並更新 currentCapital += profitMax // 執行此項目  \n        No  → Step 9: 無可執行項目，提前結束循環並返回 currentCapital // 所有可選項目已被耗盡  \nEnd // 程式執行結束，currentCapital 為最終最大資本\n\n（上述虛擬碼可直接轉換為任何主流語言的實際實作，符合 LeetCode 題目需求。）",
      "generated_code": "import sys\nimport re\nimport heapq\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 k、w、profits、capital\n    支援兩種輸入格式：\n    1. 類似 'k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]'\n    2. 只包含數字，按順序 k w profits... capital...\n    \"\"\"\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    w_match = re.search(r'w\\s*=\\s*(-?\\d+)', data)\n    profits_match = re.search(r'profits\\s*=\\s*\\[([^\\]]*)\\]', data)\n    capital_match = re.search(r'capital\\s*=\\s*\\[([^\\]]*)\\]', data)\n\n    if k_match and w_match and profits_match and capital_match:\n        k = int(k_match.group(1))\n        w = int(w_match.group(1))\n        profits = list(map(int, re.findall(r'-?\\d+', profits_match.group(1))))\n        capital = list(map(int, re.findall(r'-?\\d+', capital_match.group(1))))\n        return k, w, profits, capital\n\n    # fallback: plain numbers\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        raise ValueError(\"輸入格式錯誤\")\n    k, w = nums[0], nums[1]\n    n = (len(nums) - 2) // 2\n    profits = nums[2:2 + n]\n    capital = nums[2 + n:2 + 2 * n]\n    return k, w, profits, capital\n\ndef findMaximizedCapital(k, w, profits, capital):\n    \"\"\"\n    主要演算法：先根據資本需求排序，然後使用最大堆選擇最大利潤。\n    \"\"\"\n    projects = sorted(zip(capital, profits))  # (capital, profit) 升序\n    max_heap = []  # 儲存可選項目的利潤，使用負值實現最大堆\n    idx = 0\n    n = len(projects)\n\n    for _ in range(k):\n        # 將所有可啟動的項目加入最大堆\n        while idx < n and projects[idx][0] <= w:\n            heapq.heappush(max_heap, -projects[idx][1])\n            idx += 1\n        if not max_heap:\n            break  # 沒有可選項目，提前結束\n        # 選取利潤最大的項目\n        w += -heapq.heappop(max_heap)\n    return w\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    k, w, profits, capital = parse_input(data)\n    result = findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking if t is an anagram of s. Steps: start, check lengths, create count array/dictionary, iterate over s and t, compare, output result. Provide explanation after each line. Use Start, End, Decision etc. Use arrow symbols. No real code. Let's produce stepwise. Use 虛擬碼 step names: Step 1: Input s, t. Step 2: Check lengths. Decision. If lengths differ, return false. Else, create array count[26] zero. Step 3: For each char in s, increment count. Step 4: For each char in t, decrement count. Step 5: Decision: If any count not zero, return false. Else return true. Provide End.\n\nLet's format accordingly. Use '→' before steps. For decisions use 'Decision:'. Indent decisions with 4 spaces? Not necessary but can indent. Provide explanation comments. Use // after each line. Ensure each line has virtual code step then comment.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得字串 s 與 t // 從使用者取得兩個待檢查字串  \n→ Step 2: 檢查 s 與 t 長度是否相同 // 只要長度不同就無法為字母異序  \n    Decision: 若長度不相等?  \n        Yes → Step 3: 回傳 false // 長度不同直接判定非字母異序  \n        No  → Step 4: 初始化計數表 count[26] = 0 // 用於統計每個字母出現次數  \n→ Step 5: 逐字元遍歷 s，對應字母的 count 進行 +1 // 记录 s 中每个字母的出现次数  \n→ Step 6: 逐字元遍歷 t，對應字母的 count 進行 -1 // 记录 t 中每个字母的出现次数  \n→ Step 7: 檢查 count 表中是否全為 0 // 若所有計數回到 0，即兩字串為字母異序  \n    Decision: 若任一 count ≠ 0?  \n        Yes → Step 8: 回傳 false // 有字母出現次數不匹配  \n        No  → Step 9: 回傳 true // 所有字母數量一致，為字母異序  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \"\"\"Return True if t is an anagram of s.\"\"\"\n        return Counter(s) == Counter(t)\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉成 (s, t) 兩個字串。\n    支援 's = \"anagram\", t = \"nagaram\"' 這種格式，\n    也能容錯處理其它類似輸入。\n    \"\"\"\n    # 先嘗試匹配正式格式\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\",\\s*t\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        return match.group(1), match.group(2)\n\n    # 之後嘗試從所有雙引號內提取\n    quotes = re.findall(r'\"([^\"]*)\"', data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n\n    # 若沒有雙引號，直接按空白切開\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 無法解析時回傳空字串\n    return \"\", \"\"\n\ndef main():\n    # 從標準輸入讀取整個資料\n    raw_data = sys.stdin.read()\n    s, t = parse_input(raw_data)\n\n    sol = Solution()\n    result = sol.isAnagram(s, t)\n\n    # 輸出小寫字串 'true' 或 'false'\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, no real code. The problem: remove minimum number of invalid parentheses to make string valid, return list of unique strings. It's typical BFS or DFS with pruning. Provide steps.\n\nWe output lines starting with Start, steps, decisions, etc. Need to include arrow indicators.\n\nWe'll produce steps:\n\nStart\n→ Step 1: Compute counts of parentheses to remove\n→ Step 2: Define recursive DFS function\n→ Decision: Should we prune? etc\n\nBut we need to be line-by-line. Provide unique steps, no actual code.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化 removeLeft = 0, removeRight = 0 // count invalid parentheses to remove\n→ Decision: 如果 s 中 '(' > ')'? ...\nActually count needed: For each char: if '(' count++ else if ')' and count>0 then count-- else removeRight++.\n\nWe'll produce steps accordingly.\n\nThen Step 2: 定義 DFS(currentIndex, currentString, removeL, removeR, balance, resultSet)\n\nWe'll outline decisions inside DFS: if removeL==0 and removeR==0, then check balance. If balance==0, add to set.\n\nThen iterate over characters, choose to keep or remove.\n\nUse decision arrows.\n\nFinally convert set to list, return.\n\nWe'll output steps line by line.\n\nEnsure each line includes code step and explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算需刪除的左括號數量 removeLeft 與右括號數量 removeRight // 先統計最少要刪除多少個括號  \n→ Decision: 遍歷 s  \n  Yes → Step 2a: 若字符為 '(' → removeLeft++ // 左括號累加  \n  Yes → Step 2b: 若字符為 ')'  \n    Yes → Step 2b1: 若 removeLeft > 0 → removeLeft-- // 與已存在的左括號配對，減少需要刪除的左括號  \n    No  → Step 2b2: removeRight++ // 右括號無法配對，須刪除  \n→ Step 3: 建立空集合 resultSet 以存儲唯一有效字串 // 避免重複結果  \n→ Step 4: 定義遞迴函式 DFS(index, path, remL, remR, bal) // index: 當前處理位置，path: 當前已組成字串，remL/remR: 剩餘可刪除數量，bal: 左右括號平衡計數  \n  Decision: 若 index == len(s)  \n    Yes → Step 5a: 若 bal == 0 → resultSet.add(path) // 完整遍歷且平衡，加入結果集  \n    No  → Step 6: 返回 // 未達結束，返回遞迴  \n  Decision: 取字符 c = s[index]  \n  Decision: 若 c 為 '('  \n    Yes → Decision: 可選刪除  \n      Yes → Step 5b: 若 remL > 0 → DFS(index+1, path, remL-1, remR, bal) // 刪除左括號  \n      No  → Step 5c: DFS(index+1, path+'(', remL, remR, bal+1) // 保留左括號並增加平衡  \n  Decision: 若 c 為 ')'  \n    Yes → Decision: 可選刪除  \n      Yes → Step 5d: 若 remR > 0 → DFS(index+1, path, remL, remR-1, bal) // 刪除右括號  \n      No  → Step 5e: 若 bal > 0 → DFS(index+1, path+')', remL, remR, bal-1) // 保留右括號並減少平衡  \n  Decision: 若 c 為其他字元  \n    Yes → Step 5f: DFS(index+1, path+c, remL, remR, bal) // 字母始終保留  \n→ Step 7: 呼叫 DFS(0, \"\", removeLeft, removeRight, 0) // 開始遞迴  \n→ Step 8: 轉換 resultSet 為列表 outputList // 以列表形式返回  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        Return all possible strings after removing the minimum number of invalid parentheses.\n        Uses BFS level by level to ensure minimal removals.\n        \"\"\"\n        res = set()\n        # Check if a string is valid\n        def is_valid(st):\n            count = 0\n            for ch in st:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS: start from the original string\n        level = {s}\n        while level:\n            # 找到本層中所有有效的字串\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n            # 若本層沒有有效字串，產生下一層\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        next_level.add(next_item)\n            level = next_level\n        return []\n\ndef parse_input(text):\n    \"\"\"\n    從標準輸入取得字串 s。假設輸入形如：s = \"()())()\"\n    \"\"\"\n    # 先尋找第一個雙引號\n    m = re.search(r'\\\"(.*?)\\\"', text)\n    if m:\n        return m.group(1)\n    # 若找不到雙引號，直接回傳整段文字（去除首尾空白）\n    return text.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit(0)\n    s = parse_input(raw_input)\n    solution = Solution()\n    output = solution.removeInvalidParentheses(s)\n    # 轉成 JSON 格式，確保輸出為雙引號字串\n    print(json.dumps(output))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": true,
          "output": "[\"(())()\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "[\"\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for formatting license key. No actual code. Use Start, End, Decision etc. Provide lines with explanation after //. Each step line includes \"虛擬碼步驟\" and explanation. Use arrow \"→\". We need to cover: remove dashes, uppercase, calculate length, compute groups, build result. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 s, k, cleanStr, result ← 空字串 // 取得輸入並初始化結果  \n→ Step 2: cleanStr ← 移除 s 中所有 '-' 的字元 // 先將原始字串去除分隔符  \n→ Step 3: cleanStr ← 將 cleanStr 中所有小寫字母轉成大寫 // 大寫化所有字元  \n→ Step 4: len ← 取得 cleanStr 的長度 // 用於計算第一組的長度  \n→ Decision: 如果 len mod k 為 0? // 判斷第一組是否完整  \n    Yes → firstLen ← k // 第一組等於 k 個字元  \n    No  → firstLen ← len mod k // 第一組長度為餘數，至少為 1  \n→ Step 5: result ← cleanStr 前 firstLen 個字元 // 放入第一組  \n→ Decision: 如果 firstLen < len? // 是否還有剩餘字元需要分組  \n    Yes → Step 6: 剩餘字元 ← cleanStr 從 firstLen 開始之後的字元 // 取出剩餘  \n    No  → Step 7: End // 若已無剩餘，直接結束  \n→ Step 7: currentIndex ← 0 // 用於追蹤剩餘字元的索引  \n→ Decision: 當 currentIndex < 長度(剩餘字元) 時? // 循環處理每 k 個字元  \n    Yes → Step 8: group ← 剩餘字元 從 currentIndex 開始，長度為 k // 取 k 個字元作為一組  \n    → Step 9: result ← result + '-' + group // 加入分隔符和本組  \n    → Step 10: currentIndex ← currentIndex + k // 更新索引  \n    → Decision: 回到 Decision: 當 currentIndex < 長度(剩餘字元) 時?  \n    No  → Step 11: End // 所有字元已處理完畢  \nEnd // 程式執行結束，返回 result 為重新格式化後的 license key",
      "generated_code": "import sys\nimport re\n\ndef format_license(s: str, k: int) -> str:\n    \"\"\"\n    先移除所有 '-'，轉成大寫，然後按 k 分組。\n    第一組長度可能小於 k，但至少 1。\n    \"\"\"\n    cleaned = s.replace('-', '').upper()\n    n = len(cleaned)\n    first_len = n % k or k          # 若餘數為 0，第一組長度為 k\n    groups = [cleaned[:first_len]]\n    for i in range(first_len, n, k):\n        groups.append(cleaned[i:i + k])\n    return '-'.join(groups)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 盡量從類似 \"s = \"5F3Z-2e-9-w\", k = 4\" 的輸入格式解析\n    match = re.search(r's\\s*=\\s*\"([^\"]+)\"\\s*,\\s*k\\s*=\\s*(\\d+)', data)\n    if match:\n        s = match.group(1)\n        k = int(match.group(2))\n    else:\n        # 若解析失敗，假設輸入為兩行：第一行 s，第二行 k\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            s = lines[0].strip()\n            k = int(lines[1].strip())\n        else:\n            # 其他情況，直接以空格分隔的形式解析\n            parts = data.split()\n            if len(parts) >= 2:\n                s = parts[0]\n                k = int(parts[1])\n            else:\n                return  # 無法解析輸入\n\n    result = format_license(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": true,
          "output": "5F3Z-2E9W"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": true,
          "output": "2-5G-3J"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. We should produce algorithm description: using min-heap, pointers. Steps: initialize heap, push first k pairs, pop k times. Provide explanation each line. Must follow format. We'll include decision branches for while loops, etc. Use Start, End, Decision. Provide steps with arrow. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的最小堆 minHeap // 用來儲存候選對與其和\n→ Step 2: 取得兩個陣列長度 m = nums1.length, n = nums2.length // 用於後續計算範圍\n→ Decision: 如果 k <= 0? // 若無需找對\n    No  → End // 結束程式\n    Yes → Step 3: 建立已發佈對數集合 visited // 防止重複加入堆\n→ Step 4: 將第一個元素組合 (0,0) 推入堆中 // (index in nums1, index in nums2)\n    // sum = nums1[0] + nums2[0]\n→ Step 5: 進入主循環 while k > 0 and minHeap 不為空 // 取得 k 個最小和\n    → Step 6: 從堆中取出最小元素 (i,j) // 代表 nums1[i], nums2[j]\n    → Step 7: 將 (nums1[i], nums2[j]) 加入結果列表 result // 目前最小對\n    → Step 8: k = k - 1 // 已取一對\n    → Decision: 如果 i+1 < m? // 嘗試將 nums1 的下一個元素與相同 nums2 的組合\n        Yes → Step 9: 若 (i+1, j) 未在 visited\n            → Step 10: 將 (i+1, j) 推入堆中 // sum = nums1[i+1] + nums2[j]\n            → Step 11: 將 (i+1, j) 加入 visited\n    → Decision: 如果 j+1 < n? // 嘗試將 nums2 的下一個元素與相同 nums1 的組合\n        Yes → Step 12: 若 (i, j+1) 未在 visited\n            → Step 13: 將 (i, j+1) 推入堆中 // sum = nums1[i] + nums2[j+1]\n            → Step 14: 將 (i, j+1) 加入 visited\n    → Step 15: 返回 Step 5 的開頭 // 重新檢查條件\n→ End // 程式執行結束並返回 result\n\n**說明**  \n1. `minHeap` 是最小堆，儲存的是 (i, j) 及其對應的和，用於快速取得最小和。  \n2. `visited` 集合防止同一對被多次推入堆。  \n3. 主循環中，每次取出最小和後，將其相鄰的兩個可能組合（i+1, j）和（i, j+1）加入堆，這樣能保證所有更大的組合都會在後續被考慮。  \n4. 當 `k` 個最小對已取完或堆空時結束，結果即為所求。",
      "generated_code": "import sys\nimport re\nimport heapq\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n        heap = []\n        res = []\n\n        # 初始化堆：將前 k 個 nums1 與 nums2[0] 的組合推入堆中\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n        # 取 k 個最小和的對\n        while heap and len(res) < k:\n            sum_val, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        return res\n\ndef parse_input(text):\n    \"\"\"\n    從類似 'nums1 = [1,7,11], nums2 = [2,4,6], k = 3' 的字串中\n    取出 nums1、nums2 以及 k 的值。\n    \"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', text)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', text)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', text)\n\n    if not nums1_match or not nums2_match or not k_match:\n        raise ValueError(\"輸入格式錯誤\")\n\n    nums1 = eval(nums1_match.group(1))\n    nums2 = eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n    return nums1, nums2, k\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    nums1, nums2, k = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.kSmallestPairs(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": true,
          "output": "[[1, 2], [1, 4], [1, 6]]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": true,
          "output": "[[1, 1], [1, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode732.json",
    "problem_index_in_file": 0,
    "title": "My Calendar III",
    "description_snippet": "A k-booking happens when k events have some non-empty intersection (i.e., there is some time that is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for MyCalendarThree booking logic. Likely using segment tree with lazy propagation to keep counts of overlapping intervals. So algorithm: maintain map of time points differences. When booking, add +1 at start, -1 at end. Keep track of current max while iterating sorted keys. But typical solution uses difference map and track max. However we need per book output. We can use a tree map. Virtual code steps: Start, store map, book method: insert diff, iterate sorted keys to compute max, return max. Provide explanation lines.\n\nWe need to produce step by step pseudo-code with arrows. Let's craft:\n\nStart\n→ Step 1: Initialize empty map diff // store time → delta count\n→ Step 2: Define method book(start, end)\n→ Decision: Insert +1 at start // diff[start] += 1\n    Yes → Step 3: Insert -1 at end // diff[end] -= 1\n→ Step 4: Initialize current = 0, maxCount = 0 // counters\n→ Step 5: For each time point t in sorted keys of diff\n    → Step 6: current += diff[t] // update current overlaps\n    → Decision: current > maxCount? // check new max\n        Yes → Step 7: maxCount = current // update\n→ Step 8: Return maxCount // max k-booking\nEnd\n\nAlso need to indicate class definition. Provide each line. Ensure every line has comment. Provide arrows. Use \"→\" to indent. Use \"Decision:\" lines with Yes → and No →.\n\nWe should produce lines sequentially. The initial lines for class, constructor, map. Then book method. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class MyCalendarThree // 建立 MyCalendarThree 類別  \n→ Step 2: 內部變數 diff ← 空 map // 儲存時間點對應的增減值 (time → delta)  \n\n→ Step 3: MyCalendarThree() // 建構子  \n  → End // 空建構子，僅初始化 diff  \n\n→ Step 4: int book(start, end) // book 方法入口，接收開始結束時間  \n  → Decision: 是否需要在 diff 中加入 +1? // 檢查是否已有此時間點  \n    Yes → diff[start] ← diff[start] + 1 // 在 start 時間點增加 1  \n    No  → diff[start] ← 1 // 若不存在，設定為 1  \n  → Decision: 是否需要在 diff 中加入 -1?  \n    Yes → diff[end] ← diff[end] - 1 // 在 end 時間點減少 1  \n    No  → diff[end] ← -1 // 若不存在，設定為 -1  \n\n  → Step 5: current ← 0 // 當前重疊事件數  \n  → Step 6: maxCount ← 0 // 目前找到的最大 k-booking  \n\n  → Step 7: 針對 diff 中所有時間點 t（按升序排序）進行迭代  \n    → Step 8: current ← current + diff[t] // 更新當前重疊數  \n    → Decision: current > maxCount? // 是否取得新最大值  \n      Yes → maxCount ← current // 更新最大值  \n      No  → No change // 保持原值  \n\n  → Step 9: Return maxCount // 回傳目前最大的 k-booking  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\nimport ast\nimport json\n\nclass MyCalendarThree:\n    def __init__(self):\n        # Store events as (time, delta) pairs in a sorted list\n        self.timeline = []\n\n    def book(self, start, end):\n        # Insert start and end with respective delta values\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n\n        # Find the maximum overlap by sweeping through the timeline\n        active = 0\n        max_active = 0\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    # Read entire stdin as a single string\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Convert the input string to a tuple of two lists\n    # Wrap with parentheses so it becomes a tuple literal\n    data = ast.literal_eval(\"(\" + raw_input + \")\")\n    methods, args = data\n\n    results = []\n    calendar = None\n\n    for i, method in enumerate(methods):\n        if method == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)  # constructor returns null\n        else:\n            # Call the method with its arguments\n            res = getattr(calendar, method)(*args[i])\n            results.append(res)\n\n    # Convert Python None to JSON null for the expected output format\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "success": true,
          "output": "[null, 1, 1, 2, 3, 3, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining binary search to find peak. Must be structured. Use Start, Decision, etc. Provide each line with explanation. Output in Chinese. Use arrow lines with '→'.\n\nWe need to implement binary search: low=0, high=n-1. While low<high: mid=(low+high)/2. If nums[mid] < nums[mid+1] → low=mid+1 else high=mid. Return low. Also include handling of array boundaries via imaginary -∞.\n\nAlso need to start and end. Provide line per step. Provide explanation comments.\n\nWe must not output actual code, just virtual code steps.\n\nWe can include steps: Start, Step: read array, set low, high, Decision: low<high? etc.\n\nLet's produce virtual code.\n\nRemember each line: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nUse arrows: \"→\" for steps. For decision use \"Decision:\".\n\nAlso use \"Yes →\" and \"No →\".\n\nWe'll produce lines.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 設定 low = 0, high = n-1 // 初始化搜尋範圍\n→ Decision: low < high? // 檢查是否還有多個元素未確認\n    Yes → Step 2: 計算 mid = (low + high) / 2 // 取得中間索引\n    → Decision: nums[mid] < nums[mid+1]? // 判斷右側趨勢\n        Yes → Step 3: low = mid + 1 // 若右側較大，峰值必在右半段\n        No  → Step 4: high = mid // 否則峰值在左半段或 mid\n    No  → Step 5: return low // low==high 時為峰值索引\nEnd // 程式執行結束\n\nBut need to ensure steps inside decision block. Use indentation maybe but not necessary.\n\nBut each line must contain only one virtual code step and comment. So we cannot embed multiple steps on one line. But above lines like \"Decision: nums[mid] < nums[mid+1]? // 判斷右側趨勢\" is one line.\n\nBut we need separate lines for Yes and No branches. Use \"Yes →\" etc.\n\nBut we also need to handle step 3 and step 4 inside branches. But each branch may contain steps. So we should break lines accordingly.\n\nBetter to produce as:\n\nStart // 程式開始\n→ Step 1: 設定 low = 0, high = n-1 // 初始化搜尋範圍\n→ Decision: low < high? // 是否還有多個元素待檢查\n    Yes → Step 2: 計算 mid = (low + high) / 2 // 取得中間索引\n    → Decision: nums[mid] < nums[mid+1]? // 判斷右側是否較大\n        Yes → Step 3: low = mid + 1 // 峰值在右半段\n        No  → Step 4: high = mid // 峰值在左半段或 mid\n    No  → Step 5: return low // low == high 時即為峰值索引\nEnd // 程式結束\n\nBut each line must have \"虛擬碼步驟 [space] // 解釋/說明\".\n\nNow need to ensure each line has a space between step and comment. Yes.\n\nAlso ensure \"Yes →\" and \"No →\" preceded by space. Use same style as example.\n\nNeed to use \"→\" after each line. For Decision lines, we use \"Decision:\" and arrow.\n\nFor branch lines: \"Yes → Step ...\" etc.\n\nAlso indentation: We can use spaces before \"Yes\" lines. Example: \"    Yes → Step 3: low = mid + 1 // ...\"\n\nThe example uses indentation inside decisions. So we can replicate.\n\nThus produce final answer.\n\nWe need to include all lines with explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 設定 low = 0, high = n-1 // 初始化搜尋範圍為整個陣列\n→ Decision: low < high? // 檢查是否還有多個元素未確定峰值\n    Yes → Step 2: 計算 mid = (low + high) / 2 // 取得中間索引\n    → Decision: nums[mid] < nums[mid+1]? // 判斷右鄰是否更大\n        Yes → Step 3: low = mid + 1 // 若右側更大，峰值必在右半段\n        No  → Step 4: high = mid // 否則峰值在左半段或包含 mid\n    No  → Step 5: return low // low == high 時即為峰值索引\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_peak(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入中的列表提取出來（支援 'nums = [1,2,3,1]' 或純列表格式）\n    idx = data.find('[')\n    list_str = data[idx:] if idx != -1 else data\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 如literal_eval失敗，使用eval（但此處假設輸入安全）\n        nums = eval(list_str, {})\n    print(find_peak(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode736.json",
    "problem_index_in_file": 0,
    "title": "Parse Lisp Expression",
    "description_snippet": "You are given a string expression representing a Lisp-like expression to return the integer value of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating a Lisp-like expression. The user gave description of the problem. We need to produce step-by-step virtual code, with explanation. Not actual code. We should produce a high-level algorithm.\n\nLet's outline steps: parse expression, recursion, evaluate according to type: integer, variable, let, add, mult. Use stack or recursion. Keep environment: list of scopes (stack of dicts). For variable lookup: search from top scope downwards.\n\nWe produce virtual code line by line with \"Start\", \"→ Step\", \"Decision\" etc. Each line has explanation after //.\n\nWe need to represent tokens, parsing, evaluating recursively.\n\nLet's craft a structured virtual algorithm:\n\nStart\n\n→ Step 1: Initialize global environment as empty list of scopes // root scope\n\n→ Step 2: Call Evaluate(expression, env) // parse top-level expression\n\nDefine Evaluate(expr, env):\n\n   → Decision: 如果 expr 是整數? // check if numeric literal\n\n       Yes → Step: return 整數值 // return int value\n\n       No → Decision: 如果 expr 為變數名稱? // variable\n\n           Yes → Step: 透過搜尋環境 env 找到對應值 // look up\n\n           No → Decision: expr 是否以 '(' 開頭? // must be expression\n\n               Yes → Step: 解析 '(' 內部子表達式 // parse tokens\n\n               → Step: 取得第一個 token // operator\n\n               Decision: operator 為 \"let\"? // etc.\n\n                Yes → Process let expression:\n\n                     → Step: for each pair (var, subExpr) in order:\n\n                           → Step: eval subExpr recursively\n\n                           → Step: push binding to current scope // env[-1]\n\n                     → Step: eval final expr recursively\n\n                     → Step: pop the let scope // remove variables defined in this let\n\n                No → Decision: operator 為 \"add\"? // etc\n\n                   Yes → evaluate e1, e2 recursively, return sum\n\n                No → Decision: operator 為 \"mult\"? // etc\n\n                   Yes → evaluate e1, e2 recursively, return product\n\n   End of Evaluate\n\nWe also need to handle adding a new scope for let: when encountering let, create new scope dictionary.\n\nThus we produce virtual code with indentations for nested steps.\n\nLet's format with \"Start\" etc.\n\nWe need to output line by line, each line has virtual code step plus comment.\n\nWe may not need to fully write function definitions but can represent them.\n\nLet's craft.\n\nWe may include recursion calls as \"→ Step: Call Evaluate(subExpr, env)\" etc.\n\nLet's produce a list of lines. Use arrow \"→\" for steps. Use indentation via spaces or nested.\n\nOk. Let's write:\n\nStart // 程式開始執行\n\n→ Step 1: Set env = [] // 初始化環境堆疊（每個元素為一個 scope 字典）\n\n→ Step 2: Call Evaluate(expr, env) // 解析並計算最外層表達式\n\nDefine Evaluate(expr, env):\n\n    → Decision: expr 是 整數? // 判斷是否為數字字面量\n\n        Yes → Step 3: Return 整數值 // 直接回傳\n\n        No  → Decision: expr 是 變數名稱? // 是否為變數\n\n            Yes → Step 4: Return Lookup(expr, env) // 在環境中查找變數值\n\n            No  → Decision: expr 以 '(' 開頭? // 必須是括號表達式\n\n                Yes → Step 5: tokens = Tokenize(expr) // 以空格拆分並移除外圍括號\n\n                → Step 6: op = tokens[0] // 第一個 token 為運算子\n\n                Decision: op == \"let\"? // let 表達式\n\n                    Yes → Step 7: Push new empty scope onto env // 為 let 建立新 scope\n\n                    → For i in 1..len(tokens)-2 step 2: // 遍歷每一對 (var, subExpr)\n\n                        → Step 8: val = Evaluate(tokens[i+1], env) // 計算子表達式\n\n                        → Step 9: env[-1][tokens[i]] = val // 在目前 scope 中存入變數\n\n                    → Step 10: result = Evaluate(tokens[-1], env) // 計算 let 的 expr\n\n                    → Step 11: Pop env // 移除 let 的 scope\n\n                    → Step 12: Return result // 回傳 let 的結果\n\n                No → Decision: op == \"add\"? // add 表達式\n\n                    Yes → Step 13: val1 = Evaluate(tokens[1], env) // 計算 e1\n\n                    → Step 14: val2 = Evaluate(tokens[2], env) // 計算 e2\n\n                    → Step 15: Return val1 + val2 // 回傳相加結果\n\n                No → Decision: op == \"mult\"? // mult 表達式\n\n                    Yes → Step 16: val1 = Evaluate(tokens[1], env) // 計算 e1\n\n                    → Step 17: val2 = Evaluate(tokens[2], env) // 計算 e2\n\n                    → Step 18: Return val1 * val2 // 回傳相乘結果\n\n                No → Step 19: Error // 非法運算子\n\nEnd // 程式執行結束\n\nWe also need Lookup function maybe but can mention.\n\nAdd Step 20: Function Lookup(var, env) → Search from env[-1] to env[0] for var, return value.\n\nWe can add as separate step.\n\nAlso tokenization step may include removal of parentheses and handling nested expressions? Actually tokens may be nested strings with parentheses; we need parse recursion. But virtual code can assume Tokenize splits while preserving parentheses. For simplicity, we can treat Evaluate as being called recursively on sub-expressions extracted via parentheses.\n\nSimplify: For let, subExpr tokens may contain nested parentheses; Evaluate will be called recursively, so we need to identify the sub-expression boundaries. Could be more complex.\n\nBut since we are giving pseudocode, we can assume we can extract sub-expressions properly. Or we can define a function ParseExpression to parse string into tree. But the description didn't require building AST.\n\nWe can describe that Evaluate receives an expression string; if it's a parenthesized expression, we parse it into list of tokens using a helper that respects nested parentheses. So we can note that.\n\nLet's adjust.\n\nWe'll add Step 5: parsed = Parse(expr) // returns list of subexpressions (operator and operands)\n\nThen proceed.\n\nAlso we need Lookup function defined earlier.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: env ← [] // 初始化環境堆疊（每個元素為一個 scope 字典）\n\n→ Step 2: result ← Evaluate(expr, env) // 解析並計算最外層表達式\n\n→ Step 3: Output result // 顯示最終計算結果\n\nEnd // 程式執行結束\n\n\n\nDefine Evaluate(expr, env) // 主要遞迴求值函式\n    → Decision: expr 是否為 整數字面量？ // 判斷是否為數字字面值\n        Yes → Step 4: Return 整數值 // 直接回傳\n        No  → Decision: expr 是否為 變數名稱？ // 是否為變數\n            Yes → Step 5: Return Lookup(expr, env) // 在環境中查找變數值\n            No  → Decision: expr 以 '(' 開頭？ // 必須是括號表達式\n                Yes → Step 6: parts ← Parse(expr) // 將表達式拆成 [op, sub1, sub2, …]\n                → Step 7: op ← parts[0] // 第一項為運算子\n                Decision: op == \"let\"？\n                    Yes → Step 8: Push new empty scope onto env // 為 let 建立新 scope\n                        → For i = 1 to len(parts) - 2 step 2 // 遍歷每一對 (var, subExpr)\n                            → Step 9: val ← Evaluate(parts[i+1], env) // 計算子表達式\n                            → Step 10: env[-1][parts[i]] ← val // 在目前 scope 中存入變數\n                        → Step 11: result ← Evaluate(parts[-1], env) // 計算 let 的 expr\n                        → Step 12: Pop env // 移除 let 的 scope\n                        → Step 13: Return result // 回傳 let 的結果\n                    No → Decision: op == \"add\"？\n                        Yes → Step 14: val1 ← Evaluate(parts[1], env) // 計算 e1\n                        → Step 15: val2 ← Evaluate(parts[2], env) // 計算 e2\n                        → Step 16: Return val1 + val2 // 回傳相加結果\n                        No → Decision: op == \"mult\"？\n                            Yes → Step 17: val1 ← Evaluate(parts[1], env) // 計算 e1\n                            → Step 18: val2 ← Evaluate(parts[2], env) // 計算 e2\n                            → Step 19: Return val1 * val2 // 回傳相乘結果\n                            No  → Step 20: Error // 非法運算子，輸入保證合法，理論不會到此\n                No  → Step 21: Error // 非法表達式格式，理論不會到此\n\n\n\nDefine Lookup(var, env) // 在環境堆疊中尋找變數值\n    → For scope 在 env 由內至外遍歷\n        → Decision: var 在 scope？ \n            Yes → Step 22: Return scope[var] // 找到即返回\n    → Step 23: Error // 變數未定義，理論不會到此\n\n\n\nDefine Parse(expr) // 將 \"(let v1 e1 v2 e2 … expr)\" 等拆成 [\"let\",\"v1\",\"e1\",\"v2\",\"e2\",…,\"expr\"]\n    → Step 24: Remove 最外層的 '(' 與 ')' \n    → Step 25: 使用堆疊解析子表達式，保留整個子句作為單一元素\n    → Step 26: 返回拆分後的部分列表\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def evaluate(self, expression: str) -> int:\n        def eval_expr(expr: str, env: dict) -> int:\n            # 整數或變數\n            if expr[0] != '(':\n                if expr[0].isalpha():\n                    return env[expr]\n                return int(expr)\n\n            # 去除最外層括號\n            expr = expr[1:-1]\n            tokens = []\n            balance = 0\n            start = 0\n            for i, ch in enumerate(expr):\n                if ch == '(':\n                    balance += 1\n                elif ch == ')':\n                    balance -= 1\n                elif ch == ' ' and balance == 0:\n                    tokens.append(expr[start:i])\n                    start = i + 1\n            tokens.append(expr[start:])  # 最後一個 token\n\n            op = tokens[0]\n            if op == 'add':\n                return eval_expr(tokens[1], env.copy()) + eval_expr(tokens[2], env.copy())\n            elif op == 'mult':\n                return eval_expr(tokens[1], env.copy()) * eval_expr(tokens[2], env.copy())\n            elif op == 'let':\n                new_env = env.copy()\n                i = 1\n                # 處理所有 (var expr) 配對，直到最後一個 expr\n                while i < len(tokens) - 1:\n                    var = tokens[i]\n                    val = eval_expr(tokens[i + 1], new_env)\n                    new_env[var] = val\n                    i += 2\n                return eval_expr(tokens[-1], new_env)\n            else:\n                raise ValueError(f\"Unknown operator: {op}\")\n\n        return eval_expr(expression, {})\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 解析 expression = \"(....)\" 的形式，取出雙引號中的內容\n    if '=' in data:\n        _, expr_part = data.split('=', 1)\n        expr_part = expr_part.strip()\n        if expr_part.startswith('\"') and expr_part.endswith('\"'):\n            expr = expr_part[1:-1]\n        else:\n            expr = expr_part\n    else:\n        expr = data\n\n    sol = Solution()\n    result = sol.evaluate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "success": true,
          "output": "14"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code lines with explanations. The algorithm: given two strings s1, s2, same length. Determine if s2 is a scrambled string of s1. Classic LeetCode 87 Scramble String. Use recursion with memoization. For each call, check if strings equal; if not, check character counts; then try all split positions; recursively check combinations.\n\nWe produce steps: Start, input strings, check lengths, recursion function, etc. We need to include decision steps. Use arrows. Provide one line per step. Let's structure: Start, input, if lengths differ return false (though same length by assumption). Then define recursive function Scramble(s1, s2). Then steps inside. Use Decision: check equality, check sorted equality, then loop splits. Provide recursion. Use caching map. End.\n\nWe need to not output actual code, only pseudo steps. Provide each line with // explanation. Ensure arrow formatting.\n\nWe will produce e.g.:\n\nStart // 程式開始執行\n→ Input s1, s2 // 取得兩個待比較字串\n→ Decision: s1長度≠s2長度? // 若長度不同則直接回傳false\n    Yes → Return False // 長度不同，不可能是亂碼\n    No  → →\n→ Define Cache: Map<string,string,bool> // 用於記錄已計算的子問題結果\n→ Function Scramble(a, b) // 定義遞迴判斷是否為亂碼\n    → Decision: a==b? // 兩字串相同即為亂碼\n        Yes → Return True // 直接回傳真\n        No  → →\n    → Decision: 字符統計不等? // 先做快速排除\n        Yes → Return False // 字符頻數不一致即非亂碼\n        No  → →\n    → Decision: Cache contains (a,b)? // 若已計算過，直接回傳\n        Yes → Return Cache[(a,b)]\n        No  → →\n    → For i = 1 to len(a)-1 // 嘗試所有分割點\n        → Decision: Scramble(a[0:i], b[0:i]) AND Scramble(a[i:], b[i:])? // 不交換分割\n            Yes → Cache[(a,b)] = True; Return True // 找到合法分割\n            No  → →\n        → Decision: Scramble(a[0:i], b[len(b)-i:]) AND Scramble(a[i:], b[0:len(b)-i])? // 交換分割\n            Yes → Cache[(a,b)] = True; Return True // 找到合法交換分割\n            No  → →\n    → Cache[(a,b)] = False // 所有分割都不符合\n    → Return False\n→ Return Scramble(s1, s2) // 呼叫主函式\nEnd // 程式執行結束\n\nMake sure each line preceded by arrow or start/End. Provide explanations. Ensure each line includes arrow or Start/End. Provide arrow for each step: \"→\". Indent for decisions? In example, they used indentation. But we just need to show step lines. We can indent decisions with spaces and arrow.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s1, s2 // 取得兩個待比較字串  \n→ Decision: s1長度≠s2長度? // 若長度不同則直接回傳false  \n    Yes → Return False // 長度不同，不可能是亂碼  \n    No  → →  \n→ Define Cache: Map<string,string,bool> // 用於記錄已計算的子問題結果  \n→ Function Scramble(a, b) // 定義遞迴判斷是否為亂碼  \n    → Decision: a==b? // 兩字串相同即為亂碼  \n        Yes → Return True // 直接回傳真  \n        No  → →  \n    → Decision: 字符頻數不等? // 先做快速排除  \n        Yes → Return False // 字符頻數不一致即非亂碼  \n        No  → →  \n    → Decision: Cache contains (a,b)? // 若已計算過，直接回傳  \n        Yes → Return Cache[(a,b)]  \n        No  → →  \n    → For i = 1 to len(a)-1 // 嘗試所有分割點  \n        → Decision: Scramble(a[0:i], b[0:i]) AND Scramble(a[i:], b[i:])? // 不交換分割  \n            Yes → Cache[(a,b)] = True; Return True // 找到合法分割  \n            No  → →  \n        → Decision: Scramble(a[0:i], b[len(b)-i:]) AND Scramble(a[i:], b[0:len(b)-i])? // 交換分割  \n            Yes → Cache[(a,b)] = True; Return True // 找到合法交換分割  \n            No  → →  \n    → Cache[(a,b)] = False // 所有分割都不符合  \n    → Return False  \n→ Return Scramble(s1, s2) // 呼叫主函式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import Dict, Tuple\n\nclass Solution:\n    def __init__(self):\n        self.memo: Dict[Tuple[str, str], bool] = {}\n\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if (s1, s2) in self.memo:\n            return self.memo[(s1, s2)]\n\n        if s1 == s2:\n            self.memo[(s1, s2)] = True\n            return True\n\n        if sorted(s1) != sorted(s2):\n            self.memo[(s1, s2)] = False\n            return False\n\n        n = len(s1)\n        for i in range(1, n):\n            # without swapping\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                self.memo[(s1, s2)] = True\n                return True\n            # with swapping\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                self.memo[(s1, s2)] = True\n                return True\n\n        self.memo[(s1, s2)] = False\n        return False\n\ndef parse_input(raw: str) -> Tuple[str, str]:\n    \"\"\"\n    Try to extract two string literals from the raw input.\n    Supports formats like:\n      s1 = \"great\", s2 = \"rgeat\"\n    or simple:\n      great\n      rgeat\n    \"\"\"\n    # Find quoted substrings\n    quoted = re.findall(r'[\"\\']([^\"\\']*)[\"\\']', raw)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # Fallback: split by whitespace or commas\n    tokens = re.split(r'[,\\s]+', raw.strip())\n    tokens = [t.strip('\"\\'') for t in tokens if t]\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n\n    # If still not enough, raise an error\n    raise ValueError(\"Unable to parse input strings\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    s1, s2 = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isScramble(s1, s2)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search to find first and last positions. Provide step-by-step. Use virtual code arrows, decision, etc. Each line: \"虛擬碼步驟 // 解釋\". No actual code, only pseudo.\n\nWe need Start, End. Use arrows. Also include binary search for left and right bounds. We'll produce lines: Start, Step 1: Initialize left, right, result. Then search left bound: Step 2: leftBoundSearch. Use decision loops. Provide iterative loop steps. Since it's virtual, we can describe as pseudocode. Let's craft lines.\n\nNeed to be explicit: Step 1: Input array, target. Step 2: Binary search for leftmost. Step 3: If not found, return [-1,-1]. Step 4: Binary search for rightmost. Step 5: Return result.\n\nWill structure loops with Decision: while left <= right? yes → compute mid. etc.\n\nLet's produce a clear step-by-step. Ensure each line ends with comment. Use arrow after each step. Provide \"Decision:\" lines for while loop condition. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收已排序陣列 nums 與目標值 target // 取得輸入資料  \n→ Step 2: 初始化 left = 0, right = nums.length - 1, result = [-1, -1] // 設定搜尋範圍與回傳預設值  \n→ Decision: left <= right? // 判斷是否還有區間可搜尋  \n  Yes → Step 3: mid = floor((left + right) / 2) // 計算中間索引  \n   Decision: nums[mid] < target? // 判斷中間值是否小於目標  \n    Yes → left = mid + 1 // 目標在右半區  \n    No  → Decision: nums[mid] > target? // 判斷中間值是否大於目標  \n      Yes → right = mid - 1 // 目標在左半區  \n      No  → Step 4: leftBound = mid; right = mid - 1 // 找到左邊界，繼續搜尋更左  \n       Decision: left <= right? // 再次判斷是否有更左區間  \n         Yes → (循環回到 Step 3)  \n         No  → (結束左邊界搜尋)  \n  No → (跳出 while 循環)  \n→ Decision: result[0] == -1? // 判斷是否曾找到任何目標值  \n  Yes → Step 5: Return result // 目標不存在，直接回傳 [-1, -1]  \n  No  → Step 6: 重置 left = 0, right = nums.length - 1 // 重新設定搜尋範圍以尋找右邊界  \n→ Decision: left <= right? // 判斷是否還有區間可搜尋（右邊界）  \n  Yes → Step 7: mid = floor((left + right) / 2) // 計算中間索引  \n   Decision: nums[mid] > target? // 判斷中間值是否大於目標  \n    Yes → right = mid - 1 // 目標在左半區  \n    No  → Decision: nums[mid] < target? // 判斷中間值是否小於目標  \n      Yes → left = mid + 1 // 目標在右半區  \n      No  → Step 8: rightBound = mid; left = mid + 1 // 找到右邊界，繼續搜尋更右  \n        Decision: left <= right? // 再次判斷是否有更右區間  \n         Yes → (循環回到 Step 7)  \n         No  → (結束右邊界搜尋)  \n  No → (跳出 while 循環)  \n→ Step 9: result = [leftBound, rightBound] // 更新回傳值為找到的左右邊界  \n→ Step 10: Return result // 回傳最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def searchRange(self, nums, target):\n        # 找左邊界\n        def findLeft(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        # 找右邊界\n        def findRight(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        return [findLeft(nums, target), findRight(nums, target)]\n\ndef parse_input(text: str):\n    \"\"\"解析輸入文字，返回 nums 列表和 target 整數。\"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', text)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', text)\n    if not nums_match or not target_match:\n        raise ValueError(\"Invalid input format\")\n    nums_str = nums_match.group(1)\n    target_str = target_match.group(1)\n    nums = ast.literal_eval(nums_str)          # 解析列表\n    target = int(target_str)                  # 解析整數\n    return nums, target\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n    nums, target = parse_input(data)\n    sol = Solution()\n    result = sol.searchRange(nums, target)\n    # 依題目格式輸出，無空格\n    print(f'[{result[0]},{result[1]}]')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3,4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1,-1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1,-1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode771.json",
    "problem_index_in_file": 0,
    "title": "Jewels and Stones",
    "description_snippet": "You're given strings jewels representing the types of stones that are jewels, and stones representin...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo code with each line and comment, following the format. Need to start with Start, End. Use arrow for steps. We'll produce algorithm: convert jewels string to set for fast lookup, iterate stones string, count matches. We'll use Decision to check if character is in jewels. For each char we increment count. After loop end, output count. No actual code, just pseudo. Use Chinese commentary. Need to include \"Start\" and \"End\" lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision: If. Use Yes → etc. So produce.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 JewelSet // 用於儲存所有寶石類型\n→ Decision: 是否有 jewels 字串？ // 檢查輸入是否非空\n    Yes → Step 2: 對每個字符 c 在 jewels 中加入 JewelSet // 將每種寶石加入集合\n    No  → Step 3: JewelSet 仍為空 // 若無寶石，集合保持空\n→ Step 4: 設定 count = 0 // 初始化計數器\n→ Step 5: 對每個字符 s 在 stones 中進行迭代 // 遍歷所有石頭\n    → Decision: s 是否在 JewelSet 中？ // 判斷該石頭是否為寶石\n        Yes → Step 6: count = count + 1 // 若是，計數器加一\n        No  → Step 7: 什麼都不做 // 若不是，保持不變\n→ Step 8: 輸出 count // 顯示寶石數量\nEnd // 程式執行結束\n\nBut we must use \"→\" before each line except Start/End? The example uses \"→ Step 1:\". So we should mimic that. For decisions we indent with four spaces? The example uses indentation inside Decision block. We'll replicate. Ensure each line has arrow or \"Start\" \"End\". Also each line should contain the arrow and step etc. Provide comments after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 JewelSet // 用於儲存所有寶石類型  \n→ Decision: jewels 字串是否非空？ // 檢查輸入是否存在寶石資訊  \n  Yes → Step 2: 對每個字符 c 在 jewels 中加入 JewelSet // 把每種寶石類型存入集合  \n  No  → Step 3: JewelSet 仍為空 // 若無寶石，集合保持空  \n→ Step 4: 設定 count = 0 // 初始化計數器  \n→ Step 5: 對每個字符 s 在 stones 中進行迭代 // 遍歷所有石頭  \n  Decision: s 是否在 JewelSet 中？ // 判斷該石頭是否為寶石  \n   Yes → Step 6: count = count + 1 // 若是，計數器加一  \n   No  → Step 7: 什麼都不做 // 若不是，保持不變  \n→ Step 8: 輸出 count // 顯示寶石數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input data and return jewels and stones strings.\n    Accepts various formats:\n        - two separate lines\n        - single line with space or comma separated values\n        - assignments like `jewels = \"aA\", stones = \"aAAbbbb\"`\n    \"\"\"\n    # First try to extract quoted strings\n    quotes = re.findall(r'\"(.*?)\"', data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n\n    # Split by whitespace\n    parts = data.split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # Split by comma\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) >= 2:\n        # Remove possible assignments and quotes\n        def clean(part):\n            part = part.split('=')[-1].strip()\n            return part.strip('\"')\n        return clean(parts[0]), clean(parts[1])\n\n    # Fallback: if only one part, assume it contains both separated by space\n    parts = data.strip().split()\n    if len(parts) == 2:\n        return parts[0], parts[1]\n    raise ValueError(\"Input format not recognized\")\n\ndef count_jewels(jewels: str, stones: str) -> int:\n    \"\"\"\n    Count how many characters in stones are also present in jewels.\n    \"\"\"\n    jewel_set = set(jewels)\n    return sum(1 for ch in stones if ch in jewel_set)\n\ndef main():\n    raw_data = sys.stdin.read()\n    jewels, stones = parse_input(raw_data)\n    result = count_jewels(jewels, stones)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "jewels = \"aA\", stones = \"aAAbbbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "jewels = \"z\", stones = \"ZZ\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode594.json",
    "problem_index_in_file": 0,
    "title": "Longest Harmonious Subsequence",
    "description_snippet": "We define a harmonious array as an array where the difference between its maximum value and its mini...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm. Problem: longest harmonious subsequence length where max-min=1. Approach: count frequencies of each number. For each number, if number+1 exists, sum freq[num]+freq[num+1] and keep max. Return max or 0.\n\nWe need to produce virtual code lines with arrows and explanations. Use Start, End, Decision. Provide step by step. Use 虛擬碼.\n\nWe must not output real code.\n\nLet's craft.\n\nStart // start\n\n→ Step 1: Build frequency map of nums // Count occurrences\n\n→ Step 2: Initialize maxLen = 0 // store best length\n\n→ Decision: For each key in frequency map? We'll use loop concept.\n\nWe'll use → Decision: iterate key? We'll just express.\n\nWe'll produce pseudo loops: → Step 3: For each number num in freq keys // iterate\n\n→ Decision: If num+1 exists in freq? // check pair\n\n    Yes → Step 4: currentLen = freq[num] + freq[num+1] // sum lengths\n\n    Yes → Step 5: If currentLen > maxLen? // compare\n\n            Yes → Step 6: maxLen = currentLen // update best\n\nEnd // return maxLen\n\nBut we need to output each line with explanation. We'll include the step names.\n\nLet's produce each line:\n\nStart // 程式開始執行\n→ Step 1: Initialize frequencyMap ← empty map // 用來計算每個數字出現的次數\n→ Step 2: For each number n in nums // 遍歷輸入陣列\n    → Step 2a: frequencyMap[n] ← frequencyMap.getOrDefault(n, 0) + 1 // 更新計數\n→ Step 3: maxLen ← 0 // 用於記錄目前找到的最長和諧子序列長度\n→ Step 4: For each key k in frequencyMap.keySet() // 遍歷所有不同數字\n    → Decision: If frequencyMap contains key (k + 1)? // 檢查 k+1 是否存在\n        Yes → currentLen ← frequencyMap[k] + frequencyMap[k + 1] // 兩個相鄰數字的總頻數\n        Yes → Decision: currentLen > maxLen? // 判斷是否更新最大值\n            Yes → maxLen ← currentLen // 更新最大長度\n→ End // 回傳 maxLen 作為結果\n\nBut need each line in same format. For loop lines we could embed arrows but each line separate. However we have nested lines; we can indent with arrow lines.\n\nLet's use the pattern:\n\n→ Step 2: For each n in nums\n    → Step 2a: frequencyMap[n] ← frequencyMap.getOrDefault(n, 0) + 1\n\nBut the format expects \"→ Step X: ...\" and arrow. So we can have \"→ Step 2: For each n in nums\" then \"    → Step 2a: ...\"\n\nBetter to keep as separate lines but still start with arrow. Provide indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: frequencyMap ← 空字典 // 用來統計每個數字的出現頻率  \n→ Step 2: For each n in nums // 遍歷輸入陣列  \n  → Step 2a: frequencyMap[n] ← frequencyMap.getOrDefault(n, 0) + 1 // 更新 n 的計數  \n→ Step 3: maxLen ← 0 // 儲存目前找到的最長和諧子序列長度  \n→ Step 4: For each key k in frequencyMap.keySet() // 遍歷所有不同的數字  \n  → Decision: k + 1 在 frequencyMap 中? // 檢查相鄰數字是否存在  \n   Yes → currentLen ← frequencyMap[k] + frequencyMap[k + 1] // 兩個相鄰數字的總頻數  \n   Yes → Decision: currentLen > maxLen? // 判斷是否更新最大長度  \n    Yes → maxLen ← currentLen // 更新最大長度  \n→ End // 回傳 maxLen 作為最長和諧子序列的長度",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef main() -> None:\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part from input like \"nums = [1,2,3]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        print(0)\n        return\n\n    list_str = data[start:end + 1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(0)\n        return\n\n    # Count occurrences of each number\n    count = Counter(nums)\n    max_len = 0\n\n    # For each number, check if its consecutive number exists\n    for num in count:\n        if num + 1 in count:\n            current = count[num] + count[num + 1]\n            if current > max_len:\n                max_len = current\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,2,5,2,3,7]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudo code for two-sum problem. Use arrows, decisions. Use Start, End. Provide explanation. Use each line: \"虛擬碼步驟 // 解釋\". Should be in Traditional Chinese. Provide algorithm with hash map to store complement. Steps: Start, initialize map, iterate, check complement, store index, return pair. Let's produce. Ensure no actual code, only pseudo. Use arrow symbol for steps. Provide explanation in Chinese. Use \"Start\", \"End\". Use Decision. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的映射表 `indexMap`，用於存儲已遍歷數字及其索引 // 準備儲存已見元素  \n→ Step 2: 進入迴圈，從 `i = 0` 到 `len(nums)-1` 逐個處理元素 // 開始遍歷數組  \n  → Decision: 是否已在 `indexMap` 中存在 `target - nums[i]`? // 檢查是否找到配對  \n   Yes → Step 3: 取得先前儲存的索引 `j = indexMap[target - nums[i]]`  \n    → Step 4: 回傳 `[j, i]` 作為答案並終止 // 找到配對即完成  \n   No → Step 5: 將 `nums[i]` 與索引 `i` 存入 `indexMap` // 儲存目前元素以備後續匹配  \nEnd // 程式執行結束（若未找到，則在此結束，理論上不會發生因題目保證唯一解）",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef two_sum(nums, target):\n    \"\"\"找出兩個數字的索引，使其總和為 target。\"\"\"\n    seen = {}\n    for i, val in enumerate(nums):\n        comp = target - val\n        if comp in seen:\n            return [seen[comp], i]\n        seen[val] = i\n    return []  # 理論上不會執行到這裡，因為題目保證存在唯一解\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從字串中抽取 nums 與 target\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data, re.S)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        return\n\n    nums_str = nums_match.group(1)\n    target_str = target_match.group(1)\n\n    # 安全解析 list\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n\n    result = two_sum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: max envelopes Russian doll (Russian Doll Envelopes). Standard solution: sort by width ascending, height descending for equal widths; then find longest increasing subsequence on heights. So steps: read array, sort, extract heights, compute LIS using binary search.\n\nWe need virtual code line by line with explanation. Use Start, End, Decision. Should include steps: Input array, sort, initialize heights array, for each envelope push height, compute LIS length. For LIS, maintain list tail, iterate heights, binary search on tail to find insertion position, replace or append, final tail length.\n\nLet's craft lines. Use arrow symbol.\n\nWe need not produce actual code, just pseudocode steps. Include decision for binary search. Use \"Decision: if h[i] > last tail?\" maybe.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收 2D 整數陣列 envelopes // 取得所有信封的寬高資料\n→ Step 2: 按照寬度升冪排序，寬度相同時按高度降冪 // 方便後續尋找 LIS\n→ Step 3: 建立空的陣列 heights // 用來儲存已排序後的高度序列\n→ Decision: 對於每個 envelope in envelopes? // 迭代所有信封\n    Yes → Step 4: 將 envelope.height 加入 heights // 只關心高度\n→ Step 5: 初始化空陣列 tail // 存儲 LIS 的最小尾部\n→ Decision: 對於每個 height in heights? // 逐一處理高度\n    Yes → Step 6: 用二分搜尋 tail 找到第一個 >= height 的位置 pos // 確定替換或追加\n    → Decision: pos == tail.length? // 是否需要追加\n        Yes → Step 7: 將 height 加入 tail 的末尾 // 形成更長的序列\n        No  → Step 8: 將 tail[pos] 設為 height // 替換為更小的尾部\n→ Step 9: 取得 tail.length // 代表 LIS 的長度\n→ Step 10: 回傳 tail.length // 最大可遞歸嵌套的信封數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef max_envelopes(envelopes):\n    \"\"\"計算能夠 Russian doll 的最大信封數量。\"\"\"\n    if not envelopes:\n        return 0\n    # 先按寬度升序，寬度相同時按高度降序\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []  # dp[i] 代表長度為 i+1 的 LIS 之最小尾部高度\n    for _, h in envelopes:\n        idx = bisect.bisect_left(dp, h)  # 找到第一個 >= h 的位置\n        if idx == len(dp):\n            dp.append(h)  # 追加一個更長的序列\n        else:\n            dp[idx] = h   # 用更小的高度更新\n    return len(dp)\n\ndef parse_input(data: str):\n    \"\"\"\n    將標準輸入的文字解析成信封列表。\n    支援兩種格式：\n      1. envelopes = [[w1,h1],[w2,h2],...]\n      2. [[w1,h1],[w2,h2],...]\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 如果有 'envelopes ='，則取 '=' 後面的部分\n    if '=' in data:\n        _, rest = data.split('=', 1)\n        rest = rest.strip()\n    else:\n        rest = data\n    # 使用 literal_eval 解析字面量，若失敗則退回 eval\n    try:\n        return ast.literal_eval(rest)\n    except Exception:\n        return eval(rest)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    envelopes = parse_input(raw_input)\n    result = max_envelopes(envelopes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode746.json",
    "problem_index_in_file": 0,
    "title": "Min Cost Climbing Stairs",
    "description_snippet": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for min cost to climb stairs with given cost array, can start at 0 or 1. Standard DP: min cost to reach top (index n). dp[i] min cost to reach step i. dp[0]=cost[0], dp[1]=cost[1]. For i>=2: dp[i] = cost[i] + min(dp[i-1], dp[i-2]). Then answer min(dp[n-1], dp[n-2])? Actually top is beyond last step, so cost to reach top after last step: either from n-1 or n-2. So answer min(dp[n-1], dp[n-2]). Or we can include dp[n] = min(dp[n-1], dp[n-2])? but typical solution sets dp[n] = min(dp[n-1], dp[n-2]) because we don't pay cost for top. We'll produce virtual code accordingly. We must output line by line: Start, arrow steps, decision, etc.\n\nLet's produce step-by-step algorithm: \nStart\n→ Input array cost\n→ n = length of cost\n→ Decision: if n == 0? No because array at least length 1? We'll handle n <= 2? but typical. We'll compute dp array of size n.\n→ For i in 0..n-1: compute dp[i] as described.\n→ After loop, compute result = min(dp[n-1], dp[n-2]) // min cost to reach top\n→ Output result\nEnd\n\nBut we need to use virtual code arrows, decision structure. We can include loops: Decision: If i == 0? Yes → dp[0] = cost[0] No → Decision: if i == 1? Yes → dp[1] = cost[1] No → dp[i] = cost[i] + min(dp[i-1], dp[i-2]). We must keep format. We'll output each line with comment.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀取 cost 陣列 // 從輸入取得成本列表\n→ Step 2: n ← length(cost) // 取得陣列長度\n→ Decision: 如果 n == 0? // 檢查陣列是否為空\n    Yes → Step 3: 回傳 0 // 空陣列成本為 0\n    No  →\n→ Step 4: 創建 dp 陣列長度 n // 用於存儲到每一步的最小成本\n→ For i from 0 to n-1: // 遍歷每一步\n    → Decision: 如果 i == 0? // 第一個步驟\n        Yes → dp[0] ← cost[0] // 第一步成本直接為 cost[0]\n        No  →\n            → Decision: 如果 i == 1? // 第二個步驟\n                Yes → dp[1] ← cost[1] // 第二步成本直接為 cost[1]\n                No  →\n                    → Step 5: dp[i] ← cost[i] + min(dp[i-1], dp[i-2]) // 其餘步驟成本 = 本步成本 + 前兩步最小成本\n→ Decision: 如果 n == 1? // 只有一步\n    Yes → Step 6: result ← min(dp[0], dp[1]?) but dp[1] undefined. Actually if n==1 result = dp[0]; \n    No  →\n→ Step 7: result ← min(dp[n-1], dp[n-2]) // 最小成本到達樓頂\n→ Step 8: 輸出 result // 結果輸出\nEnd // 程式結束\n\nBut we need to output in specific format: each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow for decisions and loops.\n\nAlso we need \"Start\" and \"End\" lines with comments. For loops we can use \"→ For i from 0 to n-1:\" maybe. Then inside we have decisions.\n\nLet's produce final output. We'll use the style:\n\nStart // 程式開始執行\n→ Step 1: cost ← 讀取輸入陣列 // 取得 cost 陣列\n→ Step 2: n ← length(cost) // 取得陣列長度\n→ Decision: 如果 n == 0? // 檢查陣列是否為空\n    Yes → Step 3: return 0 // 空陣列直接回傳 0\n    No  →\n→ Step 4: dp ← 建立長度為 n 的陣列 // 用來存儲到各步的最小成本\n→ For i ← 0 to n-1: // 逐步計算\n    → Decision: 如果 i == 0? // 第一個步\n        Yes → dp[0] ← cost[0] // 第一個步成本直接為 cost[0]\n        No  →\n            → Decision: 如果 i == 1? // 第二個步\n                Yes → dp[1] ← cost[1] // 第二步成本直接為 cost[1]\n                No  →\n                    → Step 5: dp[i] ← cost[i] + min(dp[i-1], dp[i-2]) // 其餘步的成本\n→ Decision: 如果 n == 1? // 只剩一個步\n    Yes → Step 6: result ← dp[0] // 直接使用第一步成本\n    No  →\n→ Step 7: result ← min(dp[n-1], dp[n-2]) // 取最後兩步中較小的成本作為到達頂部的最小成本\n→ Step 8: 輸出 result // 回傳最小成本\nEnd // 程式結束\n\nWe need to ensure each line ends with // comment.\n\nAlso we must output each line, not block. Indentation: we can use tabs or spaces? Format as per example. Use \"→\" arrow for step lines. Indent decisions with spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: cost ← 讀取輸入陣列 // 取得 cost 陣列\n→ Step 2: n ← length(cost) // 取得陣列長度\n→ Decision: 如果 n == 0? // 檢查陣列是否為空\n    Yes → Step 3: return 0 // 空陣列直接回傳 0\n    No  →\n→ Step 4: dp ← 建立長度為 n 的陣列 // 用來存儲到各步的最小成本\n→ For i ← 0 to n-1: // 逐步計算\n    → Decision: 如果 i == 0? // 第一個步\n        Yes → dp[0] ← cost[0] // 第一個步成本直接為 cost[0]\n        No  →\n            → Decision: 如果 i == 1? // 第二個步\n                Yes → dp[1] ← cost[1] // 第二步成本直接為 cost[1]\n                No  →\n                    → Step 5: dp[i] ← cost[i] + min(dp[i-1], dp[i-2]) // 其餘步的成本\n→ Decision: 如果 n == 1? // 只剩一個步\n    Yes → Step 6: result ← dp[0] // 直接使用第一步成本\n    No  →\n→ Step 7: result ← min(dp[n-1], dp[n-2]) // 取最後兩步中較小的成本作為到達頂部的最小成本\n→ Step 8: 輸出 result // 回傳最小成本\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minCostClimbingStairs(self, cost):\n        n = len(cost)\n        if n == 0:\n            return 0\n        if n == 1:\n            return cost[0]\n        dp = [0] * n\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, n):\n            dp[i] = cost[i] + min(dp[i-1], dp[i-2])\n        return min(dp[-1], dp[-2])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        cost = []\n    else:\n        cost = ast.literal_eval(data)\n    result = Solution().minCostClimbingStairs(cost)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[10,15,20]",
          "expected_output": "15",
          "success": true,
          "output": "15"
        },
        {
          "example_index": 1,
          "input": "[1,100,1,1,1,100,1,1,100,1]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode630.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule III",
    "description_snippet": "There are n different online courses numbered from 1 to n. You are given an array courses where cour...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for scheduling maximum number of courses, like Leetcode 630. Use greedy with max-heap: iterate courses sorted by lastDay. For each course, if currentTime + duration <= lastDay, take it; else if max-heap top > duration, replace.\n\nWe must output step-by-step virtual code with explanations. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe should use arrow lines: Start, → Step, Decision, Yes→, No→. Format as per example. Use line breaks for each step.\n\nLet's produce pseudocode:\n\nStart\n→ Step 1: Sort courses by lastDay ascending // Order courses by deadline\n→ Step 2: Initialize maxHeap as empty // To track longest duration taken\n→ Step 3: Initialize currentTime = 0 // Accumulated days spent\n→ Step 4: For each course in sorted list: // Iterate over courses\n    → Decision: If currentTime + course.duration <= course.lastDay? // Can finish before deadline\n        Yes → Step 5: currentTime += course.duration // Add duration\n        Yes → Step 6: maxHeap.push(course.duration) // Record duration\n    No  → Decision: If maxHeap.top() > course.duration? // Is there a longer course already taken?\n        Yes → Step 7: removed = maxHeap.pop() // Remove longest\n        Yes → Step 8: currentTime -= removed // Subtract its duration\n        Yes → Step 9: currentTime += course.duration // Add new course\n        Yes → Step 10: maxHeap.push(course.duration) // Push new duration\n        No  → Step 11: // Skip this course\n→ Step 12: Return size of maxHeap // Number of courses taken\nEnd\n\nWe should include explanations after // each line.\n\nEnsure each line has one step. Use \"Step 1:\" etc. Use arrows. Use Yes→, No→ inside decision blocks.\n\nMake sure we follow format: \"虛擬碼步驟 // 解釋\". The arrow lines start with \"→\".\n\nAlso need to keep each line separate. Use indentation or maybe just separate lines. Example shows indentation within decision block. We'll replicate.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort courses by lastDay ascending // 先按截止日期將課程排序  \n→ Step 2: Initialize maxHeap as empty // 建立最大堆疊，用來追蹤已選課程中持續時間最長的課程  \n→ Step 3: Initialize currentTime = 0 // 記錄已用的總天數  \n→ Step 4: For each course in sorted list: // 逐一檢視每個課程  \n → Decision: 如果 currentTime + course.duration ≤ course.lastDay? // 是否能在截止日期前完成  \n  Yes → Step 5: currentTime += course.duration // 加上課程所需天數  \n  Yes → Step 6: maxHeap.push(course.duration) // 把此課程的持續時間加入堆疊  \n  No → Decision: 如果 maxHeap.top() > course.duration? // 是否已選的課程中有持續時間更長的？  \n   Yes → Step 7: removed = maxHeap.pop() // 取出持續時間最長的課程  \n   Yes → Step 8: currentTime -= removed // 把該課程天數從總天數中扣除  \n   Yes → Step 9: currentTime += course.duration // 加上新課程的天數  \n   Yes → Step 10: maxHeap.push(course.duration) // 把新課程的持續時間加入堆疊  \n   No → Step 11: // 跳過此課程，因為無法在截止日期前完成且不換掉更長的課程  \n→ Step 12: Return size of maxHeap // 回傳已成功選修課程的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\ndef schedule_course(courses):\n    \"\"\"\n    以貪婪方式計算能修完的課程數量。\n    先按截止日期升序排序，使用最大堆存放已選課程的持續時間。\n    \"\"\"\n    # 按 lastDay 排序\n    courses.sort(key=lambda x: x[1])\n\n    total_time = 0          # 已花費的總天數\n    max_heap = []           # 以負值儲存，形成最大堆\n\n    for duration, last_day in courses:\n        if total_time + duration <= last_day:\n            # 直接能在截止日期前完成\n            heapq.heappush(max_heap, -duration)\n            total_time += duration\n        elif max_heap and -max_heap[0] > duration:\n            # 已選的課程中有更長的，替換掉\n            longest = -heapq.heappop(max_heap)\n            total_time = total_time - longest + duration\n            heapq.heappush(max_heap, -duration)\n        # 否則跳過此課程\n\n    return len(max_heap)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，允許「courses = ...」或直接輸入列表\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        courses = ast.literal_eval(expr.strip())\n    else:\n        courses = ast.literal_eval(data)\n\n    result = schedule_course(courses)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "courses = [[1,2]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "courses = [[3,2],[4,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of digit 1 appearing in all non-negative integers <= n. We should use virtual steps. Let's design algorithm: iterate digits from least significant to most significant, for each position count number of 1s contributed. Classic algorithm: For each position factor=1,10,100,... while n / factor != 0: lower = n - (n//factor)*factor; curr = (n//factor)%10; higher = n//(factor*10). If curr >1: count += (higher+1)*factor; if curr ==1: count += higher*factor + lower +1; else count += higher*factor. Then factor*=10. Return count.\n\nLet's produce virtual code lines. Each step with explanation. Use Start, End, Decision etc. Provide line by line.\n\nLet's outline:\n\nStart // 程式開始\n\n→ Input n // 取得輸入整數\n\n→ Initialize count = 0 // 記錄總數\n\n→ Initialize factor = 1 // 從最低位開始\n\n→ Decision: n / factor > 0? // 是否還有位數\n\n    Yes → // 計算 lower, curr, higher\n\n        → lower = n - (n / factor) * factor // 後面位數\n\n        → curr = (n / factor) % 10 // 當前位數字\n\n        → higher = n / (factor * 10) // 前面位數\n\n    → Decision: curr > 1? // 當前位大於1\n\n        Yes → // count += (higher+1)*factor\n\n            → count = count + (higher + 1) * factor\n\n        No → Decision: curr == 1? // 當前位等於1\n\n            Yes → // count += higher*factor + lower + 1\n\n                → count = count + higher * factor + lower + 1\n\n            No → // count += higher * factor\n\n                → count = count + higher * factor\n\n    → factor = factor * 10 // 移到更高位\n\n    → Go back to Decision: n / factor > 0? // 重新檢查\n\n    No → // 循環結束\n\n→ Output count // 顯示結果\n\nEnd // 程式結束\n\nNeed to follow format: each line `虛擬碼步驟 // 解釋`. Use arrows where appropriate. Provide the decision blocks with indentation. Let's produce.\n\nLet's ensure each step ends with explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 從使用者處取得整數 n  \n→ Initialize count = 0 // 用來累積出現 1 的總數  \n→ Initialize factor = 1 // 從最低位（個位）開始處理  \n→ Decision: n / factor > 0? // 是否還有未處理的位數  \n Yes → // 先計算 lower、curr、higher 三個值  \n  → lower = n - (n / factor) * factor // 低於目前位的數字  \n  → curr = (n / factor) % 10 // 目前位的數字  \n  → higher = n / (factor * 10) // 高於目前位的數字  \n  → Decision: curr > 1? // 目前位的數字是否大於 1  \n   Yes → // 這一位全都有 1，數量為 (higher + 1) * factor  \n    → count = count + (higher + 1) * factor // 累加到總數  \n   No → // 目前位為 0 或 1  \n    Decision: curr == 1? // 目前位是否正好為 1  \n     Yes → // 這一位僅部分區間有 1，計算為 higher * factor + lower + 1  \n      → count = count + higher * factor + lower + 1 // 累加  \n     No → // 目前位為 0，僅有 higher * factor 個 1  \n      → count = count + higher * factor // 累加  \n   → factor = factor * 10 // 移到下一高位  \n  → Go back to Decision: n / factor > 0? // 檢查是否還有位數  \n No → // 所有位數已處理完畢  \n→ Output count // 顯示計算得到的 1 的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_digit_one(n: int) -> int:\n    \"\"\"Count the total number of digit '1' in all non‑negative integers <= n.\"\"\"\n    if n <= 0:\n        return 0\n    count = 0\n    factor = 1  # current position: 1, 10, 100, ...\n    while factor <= n:\n        divider = factor * 10\n        higher = n // divider\n        lower = n % factor\n        curr = (n // factor) % 10\n\n        if curr > 1:\n            count += (higher + 1) * factor\n        elif curr == 1:\n            count += higher * factor + lower + 1\n        else:\n            count += higher * factor\n\n        factor *= 10\n    return count\n\nif __name__ == \"__main__\":\n    # Read entire input and extract the first integer found\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n    result = count_digit_one(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the Bulls and Cows hint calculation. Use the format with Start, arrows, Decision, etc. Provide explanation each line. No actual code, just virtual pseudocode. Let's write steps:\n\nStart\n→ Step 1: 初始化 bulls = 0, cows = 0\n→ Step 2: 初始化 freqSecret = 空字典, freqGuess = 空字典\n→ Step 3: 遍歷索引 i 從 0 到 length-1\n   → Decision: secret[i] == guess[i]?\n      Yes → bulls += 1\n      No → freqSecret[secret[i]] += 1, freqGuess[guess[i]] += 1\n→ Step 4: 遍歷所有數字 d 在 freqSecret\n   → cows += min(freqSecret[d], freqGuess.get(d, 0))\n→ End // 返回格式化結果\n\nNeed to produce each line as \"虛擬碼步驟 // 解釋\".\n\nAlso decisions and loops need indent. We can show arrow for steps and Decision lines. Use indentation with spaces.\n\nMake sure to include arrow → before steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 bulls = 0, cows = 0 // 初始化計數\n→ Step 2: 建立兩個字典 freqSecret, freqGuess // 用於記錄非牛位數字頻次\n→ Step 3: 從 i = 0 到 len(secret)-1 進行迴圈 // 逐位比對\n   → Decision: secret[i] == guess[i] ?\n      Yes → bulls += 1 // 位置相同，計入牛\n      No  → freqSecret[secret[i]] += 1, freqGuess[guess[i]] += 1 // 位置不同，記錄頻次\n→ Step 4: 對每個數字 d 在 freqSecret 中進行\n   → cows += min(freqSecret[d], freqGuess.get(d, 0)) // 取頻次最小作為奶牛數\n→ Step 5: 返回字符串 f\"{bulls}A{cows}B\" // 格式化輸出\nEnd // 程式執行結束\n\nMake sure each line includes virtual code step + space + // explanation.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 bulls = 0, cows = 0 // 初始化牛與奶牛計數\n→ Step 2: 建立兩個空字典 freqSecret, freqGuess // 用於統計非牛位數字的頻次\n→ Step 3: 從 i = 0 到 len(secret)-1 迴圈 // 逐位比對 secret 與 guess\n   → Decision: secret[i] == guess[i] ?\n      Yes → bulls += 1 // 位置正確，計入牛\n      No  → freqSecret[secret[i]] += 1, freqGuess[guess[i]] += 1 // 位置錯誤，記錄頻次\n→ Step 4: 對每個數字 d 在 freqSecret 中循環\n   → cows += min(freqSecret[d], freqGuess.get(d, 0)) // 取兩邊頻次最小作為奶牛\n→ Step 5: 返回 f\"{bulls}A{cows}B\" // 產生結果字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n        # Count digits in secret and guess\n        secret_count = Counter(secret)\n        guess_count = Counter(guess)\n\n        # First pass: find bulls and adjust counts\n        for s, g in zip(secret, guess):\n            if s == g:\n                bulls += 1\n                secret_count[s] -= 1\n                guess_count[g] -= 1\n\n        # Second pass: find cows\n        for digit in guess_count:\n            if digit in secret_count:\n                cows += min(secret_count[digit], guess_count[digit])\n\n        return f\"{bulls}A{cows}B\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to extract quoted strings first\n    quoted = re.findall(r'\"(.*?)\"', data)\n    if len(quoted) >= 2:\n        secret, guess = quoted[0], quoted[1]\n    else:\n        # Fallback: split by whitespace or commas\n        parts = re.split(r'[,\\s]+', data)\n        parts = [p for p in parts if p]\n        if len(parts) >= 2:\n            secret, guess = parts[0], parts[1]\n        else:\n            # If still not enough parts, abort\n            raise ValueError(\"Input format not recognized.\")\n\n    solution = Solution()\n    hint = solution.getHint(secret, guess)\n    print(hint)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": true,
          "output": "1A3B"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": true,
          "output": "1A1B"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step explaining dynamic programming solution to determine if player1 can win.\n\nWe should output step-by-step virtual code, each line with // explanation. Use arrow, Decision. Must be per line. Must not output actual code. Only virtual steps.\n\nLet's design algorithm: Use DP for subarray i..j: best score difference (player1 - player2) if it's player1's turn. Recurrence: dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]). Then final dp[0][n-1] >= 0 => true.\n\nSo virtual steps: start, read nums, initialize dp matrix, loop over length, compute dp values, evaluate result. End.\n\nLet's produce lines.\n\nUse arrows for decisions: Check length, if i==j base case: dp[i][i] = nums[i]. Use nested loops. At each subarray compute.\n\nAfter DP, check result.\n\nLet's output.\n\nMake sure to use \"Start\" and \"End\". Each line must include \"虛擬碼步驟\" then space then \"// 解釋/說明\".\n\nLet's craft.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 獲取輸入陣列 nums // 取得整數陣列\n→ Step 2: 設定變數 n 為 nums 長度 // 取得陣列長度\n→ Decision: 如果 n 為 0? // 檢查陣列是否為空\n    Yes → Step 3: 回傳 true // 空陣列玩家1自動勝利\n    No  → Step 4: 建立 dp 二維陣列 n × n // 初始化 DP 表\n→ Step 5: 針對 i 從 0 到 n-1 設定 dp[i][i] = nums[i] // 單元素子陣列基礎情況\n→ Decision: 如果子陣列長度 > 1? // 從長度 2 開始動態規劃\n    Yes → For len 2 到 n:\n          → For i 0 到 n-len:\n              → 計算 j = i + len - 1 // 確定子陣列結束索引\n              → Decision: 是否應選取左端? // 考慮左右兩端\n                  Yes → 計算 pickLeft = nums[i] - dp[i+1][j] // 左端取數的差值\n                  No  → // 右端計算\n              → Decision: 是否應選取右端? // \n                  Yes → 計算 pickRight = nums[j] - dp[i][j-1] // 右端取數的差值\n              → 設定 dp[i][j] 為 max(pickLeft, pickRight) // 選擇最大差值\n→ Step 6: 判斷 dp[0][n-1] ≥ 0 // 若差值非負則玩家1勝利\n→ Decision: dp[0][n-1] ≥ 0? // 判斷結果\n    Yes → Step 7: 回傳 true // 玩家1勝利\n    No  → Step 8: 回傳 false // 玩家1敗北\nEnd // 程式執行結束\n\nWe need to ensure each line is separate. Use \"Step 1:\" etc. But must use \"虛擬碼步驟\" as step description. Provide explanation after space.\n\nLet's create final output. Ensure no actual code, just pseudo.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者或呼叫處取得整數陣列  \n→ Step 2: 設定變數 n 為 nums 長度 // 紀錄陣列長度  \n→ Decision: 如果 n 為 0? // 檢查是否為空陣列  \n Yes → Step 3: 回傳 true // 空陣列時玩家1自動勝利  \n No → Step 4: 建立 dp 二維陣列 n × n // 初始化 DP 表格  \n→ Step 5: 針對 i 從 0 到 n-1 設定 dp[i][i] = nums[i] // 單元素子陣列基礎值  \n→ Decision: 是否需要處理長度 > 1? // 從子陣列長度 2 開始動態規劃  \n Yes → For len 從 2 到 n: // 子陣列長度  \n  → For i 從 0 到 n-len: // 起始索引  \n   → 計算 j = i + len - 1 // 結束索引  \n   → Decision: 左端更優? // 比較兩端取值差  \n    Yes → 計算 pickLeft = nums[i] - dp[i+1][j] // 左端取數後差值  \n    No → // 右端計算  \n   → Decision: 右端更優? //  \n    Yes → 計算 pickRight = nums[j] - dp[i][j-1] // 右端取數後差值  \n   → 設定 dp[i][j] 為 max(pickLeft, pickRight) // 取較大差值  \n→ Step 6: 判斷 dp[0][n-1] ≥ 0 // 最終差值是否非負  \n→ Decision: dp[0][n-1] ≥ 0? // 判斷玩家1是否勝利  \n Yes → Step 7: 回傳 true // 玩家1勝利  \n No → Step 8: 回傳 false // 玩家1敗北  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        if n == 0:                     # 空陣列時玩家1自動勝利\n            return True\n        # dp[i][j] 表示從 i 到 j 的區間內先手能比後手多贏多少分\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = nums[i]\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])\n        return dp[0][n - 1] >= 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print('false')\n        sys.exit(0)\n    # 取出等號右側的列表表示\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    try:\n        nums = ast.literal_eval(data)\n        if not isinstance(nums, list):\n            nums = []\n    except Exception:\n        nums = []\n    sol = Solution()\n    result = sol.predictTheWinner(nums)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm: count bits. Typical solution: dp[i] = dp[i>>1] + (i&1). We'll output steps: Start, Step: initialize ans array of size n+1, for i from 0 to n, compute ans[i] = ans[i >> 1] + (i & 1). End. Also maybe include decision? But no decision needed. Just loop. Should show virtual code arrows. Each line: virtual code + comment. Let's produce lines:\n\nStart\n→ Step 1: Create array ans of size n+1 initialized to 0 // 初始化結果陣列\n→ Step 2: For i from 0 to n do // 開始遍歷所有數字\n    → Step 3: ans[i] = ans[i >> 1] + (i & 1) // 計算二進制 1 的個數\n→ End // 完成\n\nBut need structure: Use arrow and indent maybe. Provide each line. Let's format exactly as required: Each line with virtual code then space then comment. Use arrow for steps. Use indentation for inner lines? Might use indentation spaces. For loop line: \"Step 2: For i from 0 to n do\" and inside indent lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ans ← array of size n+1, all zeros // 建立長度為 n+1 的結果陣列，初值為 0  \n→ Step 2: For i from 0 to n do // 逐個處理 0 到 n 的數字  \n  → Step 3: ans[i] ← ans[i >> 1] + (i & 1) // 將 i 的最高位向右移 1，累加上 i 的最低位 0 或 1，得到 1 的個數  \n→ End // 程式執行結束，ans 已存儲所有 i 的二進位 1 的個數",
      "generated_code": "import sys\nimport re\n\ndef count_bits(n: int) -> list[int]:\n    \"\"\"\n    以動態規劃方式計算 0~n 之每個整數的二進位中 1 的個數。\n    \"\"\"\n    res = [0] * (n + 1)           # 初始化結果陣列，長度為 n+1\n    for i in range(1, n + 1):     # 從 1 開始遍歷\n        # 右移一位可去除最低位，再加上該最低位是否為 1\n        res[i] = res[i >> 1] + (i & 1)\n    return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，支援類似 'n = 2' 的格式\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()  # 無輸入時直接結束\n\n    # 從輸入中擷取第一個數字作為 n\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        sys.exit()\n    n = int(nums[0])\n\n    # 計算並輸出答案\n    ans = count_bits(n)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0, 1, 1, 2, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode757.json",
    "problem_index_in_file": 0,
    "title": "Set Intersection Size At Least Two",
    "description_snippet": "You are given a 2D integer array intervals where intervals[i] = [starti, endi] represents all the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (algorithm) to find minimum size of a containing set for given intervals. This is classic problem: Given intervals, choose minimum number of points such that each interval contains at least two points. The solution: Sort intervals by end ascending. Then greedily add points. Approach: iterate intervals; keep track of selected points set. For each interval, count how many points already selected within that interval. If 0, add the end and end-1; if 1, add end; if >=2 skip. Need to ensure adding end-1 exists: choose end-1 maybe if end-1 > previous selected point etc. Implementation: we need to track last two selected points for efficiency. Usually we can keep a list of chosen points; we need to know the last two selected points to decide.\n\nPseudo:\n\nStart\n→ Input intervals\n→ Sort intervals by end ascending\n→ Initialize selected set empty\n→ Initialize last = -∞, second_last = -∞\n→ For each interval [s, e] in sorted:\n    → count = 0\n    → if last >= s: count += 1\n    → if second_last >= s: count += 1\n    → if count >= 2: continue\n    → if count == 1:\n         → if last == e: continue? Actually if count==1 and last<e, we need add e\n         → add e to selected; second_last = last; last = e\n    → if count == 0:\n         → add e-1 if e-1 >= s else add s? But typical approach: add e-1, e. Ensure e-1 may equal e? For intervals of length 0, but start==end? But at least two integers needed; if length 0 (start==end) impossible; assume length >=1? We'll just add e-1 and e if e-1 >= s else add s and e\n        → set second_last = e-1; last = e\n→ End\n→ Output selected size\n\nWe'll produce virtual code with comments.\n\nWe need line-by-line with arrow syntax. Provide explanation after space. Let's do it.\n\nMake sure to use Start, End. Use Decision: etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Input intervals // 取得所有區間的陣列\n→ Sort intervals by end ascending // 依結束點遞增排序，方便貪婪選取\n→ Initialize selected = empty set // 儲存已選的整數\n→ Initialize last = -∞, second_last = -∞ // 追蹤最近兩個已選點\n→ For each interval [s, e] in sorted intervals // 逐個處理區間\n    → Decision: count 已選點在 [s, e] 內？ // 判斷已有幾個點落在此區間\n        → Yes → Set count = 0\n        → Decision: if last ≥ s? // 檢查最近點\n            Yes → count = count + 1\n            No  → (do nothing)\n        → Decision: if second_last ≥ s? // 檢查次近點\n            Yes → count = count + 1\n            No  → (do nothing)\n        → Decision: count ≥ 2? // 已滿足至少兩個點\n            Yes → Continue to next interval\n            No  → (需要再加點)\n    → Decision: count == 1? // 只缺一個點\n        Yes → // 加上結束點 e\n            → Add e to selected\n            → second_last = last\n            → last = e\n        No  → // count == 0，還缺兩個點\n            → // 先嘗試加入 e-1 (若在區間內)\n            → Decision: e-1 ≥ s? \n                Yes → \n                    → Add e-1 to selected\n                    → second_last = e-1\n                    → last = e\n                No → // 區間太小，直接加入 s 和 e\n                    → Add s to selected\n                    → second_last = s\n                    → Add e to selected\n                    → last = e\n→ End // 程式執行結束\n→ Output size of selected // 回傳最小包含集合的大小",
      "generated_code": "import sys\nimport ast\n\ndef intersection_size_two(intervals):\n    \"\"\"Return the minimum size of a containing set.\"\"\"\n    # Sort by end ascending, and for equal ends by start descending\n    intervals.sort(key=lambda x: (x[1], -x[0]))\n    res = []\n    last = -10**18          # most recent chosen point\n    second_last = -10**18   # second most recent chosen point\n\n    for start, end in intervals:\n        count = 0\n        if second_last >= start:\n            count += 1\n        if last >= start:\n            count += 1\n\n        if count >= 2:\n            continue\n        elif count == 1:\n            # Need one more point: choose the end point\n            res.append(end)\n            second_last, last = last, end\n        else:  # count == 0\n            # Need two points: choose end-1 and end (if possible)\n            first = end - 1\n            if first < start:\n                first = start\n            res.extend([first, end])\n            second_last, last = first, end\n\n    return len(res)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse the input which looks like: \"intervals = [[1,3],[3,7],[8,9]]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        intervals = ast.literal_eval(expr.strip())\n    else:\n        intervals = ast.literal_eval(data)\n\n    result = intersection_size_two(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[3,7],[8,9]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,3],[1,4],[2,5],[3,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3],[2,4],[4,5]]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode647.json",
    "problem_index_in_file": 0,
    "title": "Palindromic Substrings",
    "description_snippet": "Given a string s, return the number of palindromic substrings in it.\n\nA string is a palindrome when ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that counts palindromic substrings. Use typical expand around center. Provide each line with explanation. Let's create structure: Start, loop over each center, expand left right, count. Use Decision: for each center maybe? Use variable count, left, right. Use string length n. We'll produce steps.\n\nLet's design:\n\nStart\n→ Step 1: n = length of s // get length\n→ Step 2: count = 0 // initialize counter\n→ Step 3: For i from 0 to n-1: // iterate centers\n    → Step 3a: left = i; right = i // odd-length center\n        → Decision: While left >=0 and right < n and s[left]==s[right]?\n            Yes → Step 3a1: count++ ; left--; right++ // found palindrome\n            No → end loop\n    → Step 3b: left = i; right = i+1 // even-length center\n        → Decision: While left >=0 and right < n and s[left]==s[right]?\n            Yes → Step 3b1: count++ ; left--; right++ // found palindrome\n            No → end loop\n→ Step 4: return count // output result\nEnd\n\nWe should include indentation. Provide each line as described.\n\nMake sure to have each line with \"虛擬碼步驟\" and explanation. Use the arrow lines accordingly. The format: `虛擬碼步驟 // 解釋`.\n\nLet's produce. Use Chinese explanations.\n\nEnsure no code. Use just pseudocode steps. Provide step numbering? Not required but fine. Use indent for nested steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得輸入字串長度  \n→ Step 2: count ← 0 // 初始化回文子字串計數器  \n→ Step 3: for i ← 0 to n-1 do // 以每個字元為中心  \n  → Step 3a: left ← i; right ← i // 奇數長度中心（單字元）  \n    → Decision: 左右指標有效且 s[left] = s[right]？ // 檢查是否為回文  \n      Yes → Step 3a1: count ← count + 1; left ← left - 1; right ← right + 1 // 找到一個回文子字串，擴大指標  \n      No → // 離開 while 迴圈  \n  → Step 3b: left ← i; right ← i + 1 // 偶數長度中心（相鄰兩字元）  \n    → Decision: 左右指標有效且 s[left] = s[right]？ // 檢查是否為回文  \n      Yes → Step 3b1: count ← count + 1; left ← left - 1; right ← right + 1 // 找到一個回文子字串，擴大指標  \n      No → // 離開 while 迴圈  \n→ Step 4: return count // 回傳所有回文子字串的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = [0]  # use list to mutate inside nested function\n\n        def expand(left: int, right: int) -> None:\n            while left >= 0 and right < n and s[left] == s[right]:\n                count[0] += 1\n                left -= 1\n                right += 1\n\n        for i in range(n):\n            expand(i, i)       # odd length palindromes\n            expand(i, i + 1)   # even length palindromes\n\n        return count[0]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the string value from input\n    if '=' in data:\n        # input might be like: s = \"abc\"\n        s_part = data.split('=', 1)[1].strip()\n    else:\n        s_part = data\n\n    # Remove surrounding quotes if present\n    s = s_part.strip('\\'\"')\n\n    solution = Solution()\n    result = solution.countSubstrings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"aaa\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code that implements logic: given hand array and groupSize, check if can group into groups of consecutive values of size groupSize. Classic Leetcode 846. Approach: count frequencies, then sort keys, iterate over sorted keys, for each value if count>0, try to subtract counts for consecutive values. Complexity O(n log n). We'll produce virtual code step by step with explanations.\n\nNeed to output each line as \"虛擬碼步驟 // 解釋/說明\".\n\nWe should use Start, End, Decision, etc.\n\nLet's produce something like:\n\nStart\n→ Step 1: If groupSize is zero → Return false? Actually groupSize <= 0 invalid. But we might skip.\n\n→ Step 2: Calculate total cards length = len(hand). // Get number of cards\n→ Decision: If total cards % groupSize != 0? // Check if divisible\n    Yes → Return false // cannot form groups\n\n→ Step 3: Build frequency map freq from hand // count each card value\n→ Step 4: Get sorted unique values sortedKeys = sorted keys of freq // order ascending\n\n→ Decision: For each value in sortedKeys\n   Yes → If freq[value] == 0 → continue // already used\n   No → // need to try forming group starting from this value\n     → Step 5: For i from 0 to groupSize-1\n         current = value + i\n         → Decision: If freq[current] < freq[value]? // not enough consecutive cards\n              Yes → Return false\n              No  → Continue\n         → Step 6: Subtract freq[current] by freq[value] // remove used cards\n     → End For\n   → End Decision\n\n→ Step 7: Return true // all groups formed\n\nBut we need to adhere to format: each line with \"虛擬碼步驟\" and comment. Use arrows. Provide each line separately. Must include Start and End. Use Decision: for conditions. Indentation maybe.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: total ← length(hand) // 取得卡牌總數\n→ Decision: if total mod groupSize ≠ 0? // 確認可否整除\n    Yes → Return false // 若不能整除，無法分組\n    No  → Continue // 可嘗試分組\n→ Step 2: freq ← {} // 建立頻率字典\n→ Step 3: For each card in hand\n    → freq[card] ← freq.get(card, 0) + 1 // 统计每个卡牌出现次数\n→ Step 4: keys ← sorted(freq.keys()) // 取得按升序排列的卡牌值\n→ Decision: for each start in keys\n    → Decision: if freq[start] == 0? // 已经被完全使用\n        Yes → Continue // 跳过\n        No  → // 需要以此值为起点构建一组\n          → Step 5: groupCount ← freq[start] // 该起点需要消耗的卡牌数\n          → Step 6: For i from 0 to groupSize-1\n                → current ← start + i // 计算连续值\n                → Decision: if freq.get(current, 0) < groupCount? // 检查是否足够\n                    Yes → Return false // 缺少必要卡牌\n                    No  → Continue // 继续检查下一个连续值\n                → Step 7: freq[current] ← freq[current] - groupCount // 消耗卡牌\n          → End For\n    → End Decision\n→ Step 8: Return true // 所有卡牌均已成功分组\nEnd // 程式執行結束\n\nWe need to ensure formatting: each line \"虛擬碼步驟\" + space + \"// 解釋\". Also use Decision: properly.\n\nMake sure each line uses arrows and proper indentation with tab? Provide indentation via spaces? In example, indentation used two spaces before nested lines. We'll mimic.\n\nThus produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: total ← length(hand) // 取得卡牌總數\n→ Decision: 如果 total mod groupSize ≠ 0? // 確認總數能否被 groupSize 整除\n    Yes → Return false // 若不能整除，無法分組\n    No  → // 繼續進行分組判斷\n→ Step 2: freq ← {} // 建立空的頻率字典\n→ Step 3: For 每張卡牌 card in hand\n    → freq[card] ← freq.get(card, 0) + 1 // 計算每個卡牌值的出現次數\n→ Step 4: keys ← sorted(freq.keys()) // 取得按升序排列的所有卡牌值\n→ Decision: For 每個起點 start in keys\n    → Decision: 如果 freq[start] == 0? // 這個值已被完全使用\n        Yes → // 跳過已用完的值\n        No  → // 以此值為起點嘗試構造一組\n          → Step 5: groupCount ← freq[start] // 需要消耗的卡牌數量\n          → Step 6: For i 從 0 到 groupSize-1\n                → current ← start + i // 計算需要的連續值\n                → Decision: 如果 freq.get(current, 0) < groupCount? // 連續值不足\n                    Yes → Return false // 缺少必要卡牌，直接失敗\n                    No  → // 連續值足夠，繼續檢查下一個\n                → Step 7: freq[current] ← freq[current] - groupCount // 消耗該連續值的卡牌\n          → End For\n    → End Decision\n→ Step 8: Return true // 所有卡牌均已成功分組\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        \"\"\"\n        判斷能否將手牌重新排列成大小為 groupSize 的連續牌組。\n        \"\"\"\n        if len(hand) % groupSize != 0:\n            return False\n\n        count = Counter(hand)\n        for card in sorted(count):\n            freq = count[card]\n            if freq > 0:\n                for val in range(card, card + groupSize):\n                    if count[val] < freq:\n                        return False\n                    count[val] -= freq\n        return True\n\ndef main():\n    \"\"\"\n    讀取標準輸入，執行判斷並輸出結果。\n    輸入格式示例：\n        hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n    \"\"\"\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)  # 執行輸入字串，產生 hand 與 groupSize\n    hand = local_vars['hand']\n    groupSize = local_vars['groupSize']\n    result = Solution().isNStraightHand(hand, groupSize)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmplw7oem1a.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmplw7oem1a.py\", line 30, in main\n    exec(data, {}, local_vars)  # 執行輸入字串，產生 hand 與 groupSize\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    hand = [1,2,3,6,2,3,4,7,8], groupSize = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpgtuly64p.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpgtuly64p.py\", line 30, in main\n    exec(data, {}, local_vars)  # 執行輸入字串，產生 hand 與 groupSize\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    hand = [1,2,3,4,5], groupSize = 4\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for merging two sorted arrays into nums1 in-place, using two pointers from ends. The input arrays sorted non-decreasing. Need to merge from end to avoid overwrite. Provide Start, End, Decision, etc. Provide each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce in Traditional Chinese.\n\nWe should mention initialization of i = m-1, j = n-1, k = m+n-1.\n\nThen loop while j >= 0, and inside check if i >= 0 and nums1[i] > nums2[j] then nums1[k] = nums1[i], i-- else nums1[k] = nums2[j], j--. k--.\n\nFinally End.\n\nLet's produce accordingly. Ensure each line has arrow, maybe \"→\". Use Start, End. Use Decision: if j < 0? but we can just while. We'll use Decision: if j >= 0? or while loop.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 設定 i = m - 1 // nums1 末尾有效元素索引\n→ Step 2: 設定 j = n - 1 // nums2 末尾索引\n→ Step 3: 設定 k = m + n - 1 // nums1 最後位置索引\n→ Decision: j >= 0? // 只要 nums2 還有元素\n    Yes → Step 4: Decision: i >= 0 AND nums1[i] > nums2[j]? // 比較兩個當前元素\n        Yes → Step 5: nums1[k] = nums1[i] // 把 nums1 的較大元素放到最終位置\n        No  → Step 6: nums1[k] = nums2[j] // 把 nums2 的元素放到最終位置\n    → Step 7: k = k - 1 // 移動到下一個位置\n    → Step 8: If (i >= 0) i = i - 1 // 更新 i\n    → Step 9: If (j >= 0) j = j - 1 // 更新 j\n    → Decision: j >= 0? // 重複迴圈\n        Yes → (回到 Step 4)\n        No  → End // 合併完成\n\nBut we need sequential lines; maybe better to express loop.\n\nSimpler: Use a while loop concept: Decision: j >= 0? etc.\n\nLet's produce final virtual code:\n\nStart // 程式開始\n→ Step 1: i ← m - 1 // nums1 最後有效元素位置\n→ Step 2: j ← n - 1 // nums2 最後元素位置\n→ Step 3: k ← m + n - 1 // nums1 最後位置\n→ Decision: j ≥ 0? // 只要 nums2 還有元素需要放入\n    Yes → Decision: i ≥ 0 AND nums1[i] > nums2[j]? // 比較兩邊當前元素\n        Yes → Step 4: nums1[k] ← nums1[i] // 把 nums1 中較大的元素放到最終位置\n        No  → Step 5: nums1[k] ← nums2[j] // 把 nums2 中元素放到最終位置\n    → Step 6: k ← k - 1 // 移動到下一個位置\n    → Step 7: If i ≥ 0 Then i ← i - 1 // 更新 i（若已用完不更新）\n    → Step 8: If j ≥ 0 Then j ← j - 1 // 更新 j（若已用完不更新）\n    → Decision: j ≥ 0? // 重複上述流程\n        Yes → (回到 Step 4)\n        No  → End // 合併完成\n\nBut we also need to include when i < 0 case; but the logic covers: if i < 0, condition i >= 0 AND nums1[i] > nums2[j] is false, so we go to else.\n\nThis virtual code covers all.\n\nWe should ensure each line has \"→\" arrow preceding the step.\n\nLet's format as:\n\nStart // 程式開始\n→ Step 1: i ← m - 1 // nums1 最後有效元素索引\n→ Step 2: j ← n - 1 // nums2 最後元素索引\n→ Step 3: k ← m + n - 1 // nums1 最後位置索引\n→ Decision: j ≥ 0? // 只要 nums2 還有元素\n    Yes → Decision: i ≥ 0 AND nums1[i] > nums2[j]? // 比較兩個當前元素大小\n        Yes → Step 4: nums1[k] ← nums1[i] // 把 nums1 中較大的元素放到最終位置\n        No  → Step 5: nums1[k] ← nums2[j] // 把 nums2 中元素放到最終位置\n    → Step 6: k ← k - 1 // 移動到下一個位置\n    → Step 7: If i ≥ 0 Then i ← i - 1 // 更新 i\n    → Step 8: If j ≥ 0 Then j ← j - 1 // 更新 j\n    → Decision: j ≥ 0? // 重複\n        Yes → (回到 Decision: j ≥ 0?)\n        No  → End // 合併完成\n\nBut \"回到 Decision:\" is not a step. We might just have a loop; but we can keep as:\n\n    Yes → (重複 Step 4 之後的流程)\n\nBut we need to be explicit. Maybe we can restructure to avoid confusion: Use a while loop concept:\n\n→ Decision: j ≥ 0? \n    Yes → \n        Decision: i ≥ 0 AND nums1[i] > nums2[j]?\n            Yes → nums1[k] ← nums1[i]; i ← i - 1\n            No  → nums1[k] ← nums2[j]; j ← j - 1\n        k ← k - 1\n        Repeat (回到 Decision: j ≥ 0?)\n    No → End\n\nBut we need to have step lines individually.\n\nOk final:\n\nStart // 程式開始\n→ Step 1: i ← m - 1 // nums1 最後有效元素索引\n→ Step 2: j ← n - 1 // nums2 最後元素索引\n→ Step 3: k ← m + n - 1 // nums1 最後位置索引\n→ Decision: j ≥ 0? // 只要 nums2 還有元素需要放入\n    Yes → Decision: i ≥ 0 AND nums1[i] > nums2[j]? // 比較兩邊當前元素\n        Yes → Step 4: nums1[k] ← nums1[i] // 把 nums1 中較大的元素放到最終位置\n        No  → Step 5: nums1[k] ← nums2[j] // 把 nums2 中元素放到最終位置\n    → Step 6: k ← k - 1 // 移動到下一個位置\n    → Step 7: If i ≥ 0 Then i ← i - 1 // 更新 i（若已用完則保持不變）\n    → Step 8: If j ≥ 0 Then j ← j - 1 // 更新 j（若已用完則保持不變）\n    → Decision: j ≥ 0? // 重複上述流程\n        Yes → (回到 Decision: j ≥ 0?)\n        No  → End // 合併完成\n\nBut we need each line to contain the arrow at start. For lines inside branches we also use arrow but nested indentation not necessary. But we can keep as above.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: i ← m - 1 // nums1 最後有效元素索引  \n→ Step 2: j ← n - 1 // nums2 最後元素索引  \n→ Step 3: k ← m + n - 1 // nums1 最後位置索引  \n→ Decision: j ≥ 0? // 只要 nums2 還有元素需要放入  \n Yes → Decision: i ≥ 0 AND nums1[i] > nums2[j]? // 比較兩邊當前元素  \n  Yes → Step 4: nums1[k] ← nums1[i] // 把 nums1 中較大的元素放到最終位置  \n  No  → Step 5: nums1[k] ← nums2[j] // 把 nums2 中元素放到最終位置  \n → Step 6: k ← k - 1 // 移動到下一個位置  \n → Step 7: If i ≥ 0 Then i ← i - 1 // 更新 i（若已用完則保持不變）  \n → Step 8: If j ≥ 0 Then j ← j - 1 // 更新 j（若已用完則保持不變）  \n → Decision: j ≥ 0? // 重複上述流程  \n  Yes → (回到 Decision: j ≥ 0?)  \n  No  → End // 合併完成",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1          # index of last element in the initialized part of nums1\n        j = n - 1          # index of last element in nums2\n        k = m + n - 1      # index of last position in nums1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    pattern = r'nums1\\s*=\\s*(\\[.*?\\])\\s*,\\s*m\\s*=\\s*(\\d+)\\s*,\\s*nums2\\s*=\\s*(\\[.*?\\])\\s*,\\s*n\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        return\n\n    nums1_str, m_str, nums2_str, n_str = match.groups()\n    nums1 = ast.literal_eval(nums1_str)\n    nums2 = ast.literal_eval(nums2_str)\n    m = int(m_str)\n    n = int(n_str)\n\n    Solution().merge(nums1, m, nums2, n)\n    print(nums1)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": true,
          "output": "[1, 2, 2, 3, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, explaining each step. No actual code. Just pseudo steps.\n\nWe need to compute complement of integer n: flip all bits in binary representation. However, need to consider only significant bits. Approach: Determine binary string of n, iterate through bits, flip each, build result as integer. Or use bitwise operations: while n > 0, find mask of all 1's same length, compute complement = n ^ mask. But need to consider leading zeros not considered.\n\nSimplest: convert to binary string, then for each char, flip, parse. But we should produce pseudo code. Use variable names: n, binary_str, complement_str, result. Use decision steps for loop.\n\nLet's create steps:\n\nStart\n→ Step 1: Obtain n // Input integer\n→ Step 2: Convert n to binary string without prefix // binary_str\n→ Step 3: Initialize complement_str empty // for result\n→ Step 4: For each bit in binary_str // loop\n    → Decision: If bit == '1'?\n        Yes → Append '0' to complement_str // flip\n        No  → Append '1' to complement_str // flip\n→ Step 5: Convert complement_str to integer // result\n→ Step 6: Return result\nEnd\n\nAlternatively could use bitwise mask: mask = (1 << len(binary_str)) - 1; result = n ^ mask. That might be simpler.\n\nWe'll produce virtual code accordingly.\n\nNeed to include arrows and decisions.\n\nLet's craft.\n\nStart\n→ Step 1: Input n // Receive the integer\n→ Step 2: Convert n to binary string without '0b' prefix // binaryStr\n→ Step 3: Initialize complementStr = \"\" // empty string\n→ Step 4: For each character bit in binaryStr\n    → Decision: bit == '1' ?\n        Yes → Append '0' to complementStr\n        No  → Append '1' to complementStr\n→ Step 5: Convert complementStr to integer // result\n→ Step 6: Output result // return complement\nEnd\n\nAlso include intermediate decisions for the for loop. Virtual code may use indentation for decisions.\n\nAlso we may show mask approach:\n\nAlternative pseudo: Step 2: mask = (1 << len(binaryStr)) - 1; result = n XOR mask.\n\nBut maybe stick to string method.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input n // 取得要處理的整數\n→ Step 2: Convert n to binary string without '0b' prefix // 取得 n 的二進位字串，例如 5 → \"101\"\n→ Step 3: Initialize complementStr = \"\" // 用來儲存翻轉後的二進位字串\n→ Step 4: For each character bit in binaryStr // 逐位處理\n    → Decision: bit == '1' ?\n        Yes → Append '0' to complementStr // 1 變成 0\n        No  → Append '1' to complementStr // 0 變成 1\n→ Step 5: Convert complementStr to integer // 將翻轉後的二進位字串轉回十進位整數，例如 \"010\" → 2\n→ Step 6: Output result // 回傳整數補數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        \"\"\"\n        Return the bitwise complement of a non‑negative integer n.\n        The complement is obtained by flipping all bits in the\n        binary representation of n up to its most significant bit.\n        \"\"\"\n        if n == 0:\n            # Special case: 0 is represented by a single 0 bit,\n            # so flipping it yields 1.\n            return 1\n        # Length of the binary representation without leading zeros\n        bit_length = n.bit_length()\n        # Mask with all bits set to 1 up to bit_length\n        mask = (1 << bit_length) - 1\n        # XOR with mask flips the bits\n        return n ^ mask\n\ndef main() -> None:\n    \"\"\"\n    Read an integer from standard input, compute its complement,\n    and print the result. The input may contain other text\n    (e.g., 'n = 5'), so we use a regular expression to extract\n    the first integer found.\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # No integer found; nothing to do\n        return\n    n = int(match.group())\n    result = Solution().bitwiseComplement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode712.json",
    "problem_index_in_file": 0,
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "description_snippet": "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for computing minimal ASCII delete sum to make two strings equal. That's classic DP: min cost to make equal. Steps: initialize dp matrix of size (len(s1)+1)x(len(s2)+1). dp[i][j] minimal sum for prefixes i,j. Recurrence: if s1[i-1]==s2[j-1], dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(dp[i-1][j]+ord(s1[i-1]), dp[i][j-1]+ord(s2[j-1])). After fill, result dp[len1][len2]. Provide step-by-step. Use Start, Decision, etc.\n\nWe need to output each line as virtual code step and explanation. Use arrow. Format: \"Start // ...\". Then \"→ Step X: ...\" etc. Use Decision lines for branching. We'll include loops: for i from 0..len1; for j from 0..len2. For dp initialization: set dp[0][0]=0, dp[i][0]=sum of ascii of s1[0..i-1], dp[0][j]=sum of ascii of s2[0..j-1]. Then DP. So produce virtual steps:\n\nStart\n→ Step 1: Input strings s1, s2\n→ Step 2: n = length(s1), m = length(s2)\n→ Step 3: Create matrix dp of size (n+1)x(m+1)\n→ Step 4: Initialize dp[0][0] = 0\n→ Decision: For i from 1 to n? Actually we need initialization loops\n   Yes → Loop i = 1 to n:\n       → Step 5: dp[i][0] = dp[i-1][0] + ASCII(s1[i-1])\n   Yes → Loop j = 1 to m:\n       → Step 6: dp[0][j] = dp[0][j-1] + ASCII(s2[j-1])\n→ Step 7: Loop i = 1 to n:\n   → Step 8: Loop j = 1 to m:\n        → Decision: If s1[i-1] == s2[j-1]?\n            Yes → Step 9: dp[i][j] = dp[i-1][j-1]\n            No → Step 10: cost1 = dp[i-1][j] + ASCII(s1[i-1])\n                       cost2 = dp[i][j-1] + ASCII(s2[j-1])\n                       Step 11: dp[i][j] = min(cost1, cost2)\n→ Step 12: result = dp[n][m]\n→ End // 返回結果\n\nBut we need to format with arrows. Use arrow inside each step? We can use \"→\" at beginning of step lines. For decisions, use \"Decision:\" with arrow branches.\n\nMake sure each line has explanation after //.\n\nLet's craft.\n\nWe need to ensure we use '→' at the beginning of each step, but in decisions we use \"Decision:\" with arrows inside. For loops, use \"→ Loop i = 1 to n:\" etc. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s1, s2 // 取得兩個要比較的字串  \n→ Step 2: n ← length(s1), m ← length(s2) // 計算兩個字串長度  \n→ Step 3: 建立 dp 矩陣，尺寸為 (n+1) × (m+1) // 用來儲存子問題答案  \n→ Step 4: dp[0][0] ← 0 // 空字串與空字串相等，成本為 0  \n\n→ Decision: 初始化第一行與第一列?  \n    Yes → Loop i ← 1 to n: // 計算把前 i 個 s1 字元全刪除的成本  \n        → Step 5: dp[i][0] ← dp[i-1][0] + ASCII(s1[i-1]) // 加上第 i 個字元的 ASCII 值  \n    Yes → Loop j ← 1 to m: // 計算把前 j 個 s2 字元全刪除的成本  \n        → Step 6: dp[0][j] ← dp[0][j-1] + ASCII(s2[j-1]) // 加上第 j 個字元的 ASCII 值  \n\n→ Loop i ← 1 to n: // 逐行填表  \n    → Loop j ← 1 to m: // 逐列填表  \n        → Decision: s1[i-1] == s2[j-1]? // 判斷兩個字元是否相同  \n            Yes → Step 7: dp[i][j] ← dp[i-1][j-1] // 相同則不需刪除，成本與前子問題相同  \n            No  → Step 8: cost1 ← dp[i-1][j] + ASCII(s1[i-1]) // 刪除 s1 的第 i 個字元  \n            No  → Step 9: cost2 ← dp[i][j-1] + ASCII(s2[j-1]) // 刪除 s2 的第 j 個字元  \n            No  → Step 10: dp[i][j] ← min(cost1, cost2) // 取成本較小的方案  \n\n→ Step 11: result ← dp[n][m] // 最終答案為完整字串的最小刪除成本  \n→ End // 程式執行結束，返回 result 兩個字串相等所需的最低 ASCII 刪除總和",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minimumDeleteSum(self, s1: str, s2: str) -> int:\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j] + ord(s1[i - 1]),\n                                   dp[i][j - 1] + ord(s2[j - 1]))\n        return dp[m][n]\n\ndef _parse_input(text: str):\n    # Try to extract quoted strings first\n    quoted = re.findall(r'\"(.*?)\"', text)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback: take first two non-empty lines\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    return lines[0], lines[1] if len(lines) > 1 else \"\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, s2 = _parse_input(data)\n    sol = Solution()\n    result = sol.minimumDeleteSum(s1, s2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"sea\", s2 = \"eat\"",
          "expected_output": "231",
          "success": true,
          "output": "231"
        },
        {
          "example_index": 1,
          "input": "s1 = \"delete\", s2 = \"leet\"",
          "expected_output": "403",
          "success": true,
          "output": "403"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode640.json",
    "problem_index_in_file": 0,
    "title": "Solve the Equation",
    "description_snippet": "Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The problem: Solve linear equation with '+', '-', variable x, coefficient. Return string. Cases: No solution, Infinite solutions, else single integer solution.\n\nWe produce steps: parse equation, separate left and right parts, compute coefficients sum, constant sum, bring to standard form ax + b = 0, etc.\n\nWe need to output step lines with virtual code and comment.\n\nNo actual code, just virtual.\n\nLet's craft: Start → Step 1: 取得等式 // etc.\n\nWe need to be clear. We'll do a simplified approach: split by '=' into left and right.\n\nCompute coefficient of x and constant for each side.\n\nThen bring all to left: coefficient = leftCoeff - rightCoeff, constant = rightConst - leftConst. Then equation becomes coefficient*x + constant = 0.\n\nIf coefficient == 0 and constant == 0 -> infinite. If coefficient == 0 and constant != 0 -> no solution. Else x = -constant / coefficient. Since guaranteed integer.\n\nReturn formatted string.\n\nLet's produce lines.\n\nWe'll include decision steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入等式 // 取得待解的字串  \n→ Step 2: 將等式以 '=' 分割為 leftExpr 與 rightExpr // 分成左右兩邊  \n→ Decision: 如果 leftExpr 或 rightExpr 為空? // 檢查是否完整  \n    Yes → Step 3: 回傳 \"No solution\" // 缺失部分視為無解  \n    No  →  \n→ Step 3: 定義變數 leftCoeff, leftConst, rightCoeff, rightConst 為 0 // 初始化係數與常數  \n→ Step 4: 解析 leftExpr  \n    → Decision: 是否包含 'x'? // 判斷是否有變數  \n        Yes → Step 5: 提取 x 的係數並加到 leftCoeff  \n        No  →  \n    → Step 6: 將 leftExpr 轉成單純常數表達式並加到 leftConst // 只剩常數部分  \n→ Step 5: 解析 rightExpr（同左邊的步驟）  \n    → Decision: 是否包含 'x'?  \n        Yes → Step 6: 提取 x 的係數並加到 rightCoeff  \n        No  →  \n    → Step 7: 將 rightExpr 轉成單純常數表達式並加到 rightConst  \n→ Step 8: 轉換為標準形式 ax + b = 0  \n    → Step 9: 計算 a = leftCoeff - rightCoeff // 所有 x 的係數合併  \n    → Step 10: 計算 b = rightConst - leftConst // 所有常數合併  \n→ Decision: 若 a = 0? // 檢查係數為零  \n    Yes →  \n        Decision: 若 b = 0? // 常數是否也為零  \n            Yes → Step 11: 回傳 \"Infinite solutions\" // 無限多解  \n            No  → Step 12: 回傳 \"No solution\" // 無解  \n    No  → // 有唯一解  \n→ Step 13: 計算 x = -b / a // b 與 a 為整數，商為整數  \n→ Step 14: 回傳 \"x=\" + x // 將結果轉成字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def solveEquation(self, equation: str) -> str:\n        \"\"\"Solve a linear equation containing only '+', '-', variable 'x' and its coefficient.\"\"\"\n        def parse_side(s: str):\n            \"\"\"Parse one side of the equation, returning (coeff_of_x, constant_sum).\"\"\"\n            x_coeff, const = 0, 0\n            i, n, sign = 0, len(s), 1\n            while i < n:\n                if s[i] == '+':\n                    sign = 1\n                    i += 1\n                elif s[i] == '-':\n                    sign = -1\n                    i += 1\n                else:\n                    j = i\n                    while j < n and s[j] not in '+-':\n                        j += 1\n                    token = s[i:j]\n                    if 'x' in token:\n                        coeff_part = token[:-1]  # remove trailing 'x'\n                        if coeff_part == '' or coeff_part == '+':\n                            coeff = 1\n                        elif coeff_part == '-':\n                            coeff = -1\n                        else:\n                            coeff = int(coeff_part)\n                        x_coeff += sign * coeff\n                    else:\n                        const += sign * int(token)\n                    i = j\n            return x_coeff, const\n\n        left, right = equation.split('=')\n        left_x, left_const = parse_side(left)\n        right_x, right_const = parse_side(right)\n\n        # Bring all terms to the left side: (left_x - right_x) * x + (right_const - left_const) = 0\n        a = left_x - right_x\n        b = right_const - left_const\n\n        if a == 0:\n            return \"Infinite solutions\" if b == 0 else \"No solution\"\n        return f\"x={-b // a}\"\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # If input looks like a variable assignment e.g. 'equation = \"x+5-3+x=6+x-2\"'\n    if '=' in data:\n        # Find the first '=' that separates the assignment from the value\n        assign_index = data.find('=')\n        raw_eq = data[assign_index + 1:].strip()\n        # Remove surrounding quotes if present\n        if (raw_eq.startswith('\"') and raw_eq.endswith('\"')) or (raw_eq.startswith(\"'\") and raw_eq.endswith(\"'\")):\n            raw_eq = raw_eq[1:-1]\n        equation = raw_eq\n    else:\n        equation = data\n\n    solution = Solution()\n    result = solution.solveEquation(equation)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equation = \"x+5-3+x=6+x-2\"",
          "expected_output": "x=2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): 'x=2'\nGot (Norm):      'x=-2'\n--- (Raw) ---\nRaw Expected: 'x=2'\nRaw Got:      'x=-2'"
        },
        {
          "example_index": 1,
          "input": "equation = \"x=x\"",
          "expected_output": "Infinite solutions",
          "success": true,
          "output": "Infinite solutions"
        },
        {
          "example_index": 2,
          "input": "equation = \"2x=x\"",
          "expected_output": "x=0",
          "success": true,
          "output": "x=0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (flowchart-like) for longest consecutive sequence, O(n). Use hash set. Steps: create set of nums. Iterate each number, if num-1 not in set, start count, while num+1 in set, increment. Track max. Output max. Provide Start, End, Decision, Step lines. Each line with arrow. Ensure use \"→\" for indentation. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 HashSet S 並將 nums 中所有元素加入 // 用於 O(1) 查找  \n→ Step 2: 設定 maxLen ← 0 // 儲存目前最長序列長度  \n→ Step 3: 從 nums 中逐一遍歷每個 number // 主要外層迴圈  \n→ Decision: 如果 number-1 不在 S? // 判斷是否為序列起點  \n  Yes → Step 4: 設定 current ← number // 開始新序列  \n    → Step 5: 設定 currentLen ← 1 // 序列長度初始化  \n    → Decision: 如果 current+1 在 S? // 繼續延伸序列  \n      Yes → Step 6: current ← current+1 // 移到下一個連續數  \n       → currentLen ← currentLen+1 // 更新長度  \n       → 再次判斷 current+1 是否在 S? // 迴圈至結束  \n        → No  → Step 7: maxLen ← max(maxLen, currentLen) // 更新最大值  \n         → End of while // 結束延伸  \n         → End // 回到外層循環  \n        → No  → Step 7: maxLen ← max(maxLen, currentLen) // 序列已完結，更新最大值  \n         → End // 回到外層循環  \n  No → Step 8: 繼續處理下一個 number // 不是起點，直接跳過  \n→ Step 9: 輸出 maxLen // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_consecutive(nums):\n    \"\"\"\n    回傳給定整數陣列中連續序列的最大長度。\n    時間複雜度為 O(n)，使用哈希集合做快速查找。\n    \"\"\"\n    if not nums:\n        return 0\n\n    num_set = set(nums)  # O(n) 建立集合\n    longest = 0\n\n    for num in num_set:\n        # 只有當 num-1 不在集合時，num 才是序列的起點\n        if num - 1 not in num_set:\n            cur = num\n            length = 1\n            # 向上尋找連續的數字\n            while cur + 1 in num_set:\n                cur += 1\n                length += 1\n            if length > longest:\n                longest = length\n    return longest\n\ndef parse_input(s):\n    \"\"\"\n    從標準輸入取得字串，解析出整數列表。\n    允許輸入類似 'nums = [1,2,3]' 或僅 '[1,2,3]' 的格式。\n    \"\"\"\n    s = s.strip()\n    if not s:\n        return []\n\n    # 取出第一個 '[' 到最後一個 ']' 之間的子字串\n    start = s.find('[')\n    end = s.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        list_str = s[start:end + 1]\n        try:\n            return ast.literal_eval(list_str)\n        except Exception:\n            pass\n\n    # 若上述失敗，嘗試直接解析整個字串\n    try:\n        return ast.literal_eval(s)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = longest_consecutive(nums)\n    # 將答案輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for merging intervals. The steps: sort intervals by start, iterate, merge overlapping by comparing current start with last end, etc. Must follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow →. Use Decision: with Yes → etc.\n\nWe must output step by step.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: Sort intervals by start ascending // 將區間依起始點排序\n→ Step 2: Initialize merged list with first interval // 建立合併結果，先放第一個區間\n→ Step 3: For each interval from second to end // 逐個處理剩餘區間\n    → Decision: 如果當前區間開始 ≤ 上一合併區間結束? // 判斷是否重疊\n        Yes → Step 4: 更新上一次合併區間結束為 max(結束, 當前結束) // 合併\n        No  → Step 5: 將當前區間加入 merged 列表 // 新區間不重疊\n→ Step 6: Return merged // 回傳結果\nEnd // 程式結束\n\nBut must format with arrows and Decision with Yes→ No→ indentation.\n\nAlso each line must contain \"虛擬碼步驟\" and \" // 解釋\".\n\nLet's produce.\n\nAlso maybe include \"→\" at start of each step.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by start ascending // 將所有區間依照起始點由小到大排序  \n→ Step 2: Initialize merged list with first interval // 建立合併結果列表，先將第一個區間加入  \n→ Step 3: For each interval from second to last // 逐個處理剩餘區間  \n  → Decision: 如果當前區間開始 ≤ 先前合併區間結束? // 判斷是否有重疊  \n   Yes → Step 4: 更新先前合併區間結束為 max(先前結束, 當前結束) // 合併重疊區間  \n   No  → Step 5: 將當前區間加入 merged 列表 // 新區間不重疊，直接加入  \n→ Step 6: Return merged // 回傳所有已合併且不重疊的區間  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"\n        合併重疊的區間。\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not intervals:\n            return []\n\n        # 先依起始點排序\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n\n        for current in intervals[1:]:\n            prev = merged[-1]\n            # 若起始點 <= 前一個區間的結束點，則重疊，更新結束點\n            if current[0] <= prev[1]:\n                prev[1] = max(prev[1], current[1])\n            else:\n                merged.append(current)\n\n        return merged\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        sys.exit()\n\n    # 找到第一個 '[' 以取得區間列表\n    idx = data.find('[')\n    if idx == -1:\n        # 若輸入格式不正確，直接回傳空列表\n        print([])\n        sys.exit()\n\n    list_str = data[idx:]\n    # 使用 ast.literal_eval 解析列表，避免使用 eval 的安全風險\n    try:\n        intervals = ast.literal_eval(list_str)\n    except Exception:\n        intervals = []\n\n    # 執行合併區間\n    solution = Solution()\n    result = solution.merge(intervals)\n\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": true,
          "output": "[[1, 6], [8, 10], [15, 18]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": true,
          "output": "[[1, 5]]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": true,
          "output": "[[1, 7]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: longest substring where each character appears at least k times. Classic Leetcode 395. Approach: divide and conquer using recursion; or sliding window with counts of unique characters. We'll produce pseudocode using recursion: Find frequency of all chars in string. For each char that occurs less than k, split string by that char and recursively solve each part. Then take max. If no such char, return length of string. Provide line by line virtual code with explanation.\n\nWe need to output in the format: line \"虛擬碼步驟 // 解釋\". Use arrow ->. Use Start, End, Decision:.\n\nLet's produce something like:\n\nStart // 程式開始\n→ Function longestSubstring(s, k) // 定義遞歸函式\n    → Decision: 如果 s 為空? // 檢查輸入是否為空字串\n        Yes → Return 0 // 空字串無有效子字串\n    → Step: 計算 s 中各字元頻率 // 建立頻率字典\n    → Decision: 是否存在頻率 < k 的字元? // 判斷是否有分割點\n        Yes → Step: 將 s 按頻率 < k 的字元分割成子段 // 分割字串\n            → Loop 每個子段\n                → Call longestSubstring(sub, k) // 重新遞歸\n                → Keep 最大值\n            → Return 最大值\n        No  → Return s.length // 所有字元頻率 >= k，整串有效\nEnd // 程式結束\n\nBut we need to use arrow notation exactly: \"→\" before each step. For decisions, use \"Decision: ...\" and then indentation with Yes/No arrow. Should mimic example. Use \"Step\" or \"Decision\" as tags.\n\nLet's produce detailed steps with arrow and explanation.\n\nWe also need to output \"Start\" and \"End\" lines. Each line after Start maybe no arrow? Example shows \"Start // 程式開始執行\" with no arrow. Then arrow lines for steps. Then End.\n\nSo final output: lines with Start, arrow lines, decisions.\n\nLet's produce the lines:\n\nStart // 程式開始執行\n→ Function longestSubstring(s, k) // 定義遞歸函式\n    → Decision: s 為空字串? // 檢查輸入是否為空\n        Yes → Return 0 // 空字串無效子字串\n    → Step: 建立字元頻率表 freq // 計算每個字元出現次數\n    → Decision: 是否存在 freq[char] < k 的字元? // 判斷是否需要分割\n        Yes → Step: 找到所有 freq[char] < k 的分割字元 // 取得所有不滿足頻率的字元\n            → Step: 用這些分割字元把 s 拆成子字串 segments // 以這些字元為分隔符切割\n            → Step: maxLen ← 0 // 初始化最大長度\n            → Loop 每個 segment in segments\n                → subLen ← longestSubstring(segment, k) // 重新遞歸求解子段\n                → Decision: subLen > maxLen? // 更新最大長度\n                    Yes → maxLen ← subLen\n            → Return maxLen // 回傳最大子字串長度\n        No  → Return s.length // 所有字元頻率 >= k，整串即為答案\nEnd // 程式執行結束\n\nWe need to keep indent maybe but not necessary. We just provide lines; indentation within decisions indicated by extra spaces.\n\nMake sure to put \"→\" before each step. For decision lines, we write \"→ Decision:\" and then nested Yes/No lines with arrows \"Yes →\" and \"No →\". In example, indentation is shown by spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function longestSubstring(s, k) // 定義遞歸函式  \n → Decision: s 為空字串? // 檢查輸入是否為空  \n  Yes → Return 0 // 空字串無效子字串  \n → Step: 建立字元頻率表 freq // 計算每個字元出現次數  \n → Decision: 是否存在 freq[char] < k 的字元? // 判斷是否需要分割  \n  Yes → Step: 找到所有 freq[char] < k 的分割字元 // 取得所有不滿足頻率的字元  \n   → Step: 用這些分割字元把 s 拆成子字串 segments // 以這些字元為分隔符切割  \n   → Step: maxLen ← 0 // 初始化最大長度  \n   → Loop 每個 segment in segments  \n     → subLen ← longestSubstring(segment, k) // 重新遞歸求解子段  \n     → Decision: subLen > maxLen? // 更新最大長度  \n      Yes → maxLen ← subLen  \n      No → // 不更新  \n   → Return maxLen // 回傳最大子字串長度  \n  No → Return s.length // 所有字元頻率 >= k，整串即為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        \"\"\"Return length of longest substring where every character appears at least k times.\"\"\"\n        if len(s) < k:\n            return 0\n\n        count = Counter(s)\n        for char, freq in count.items():\n            if freq < k:\n                # Split the string on this character and recursively solve each part\n                return max(\n                    self.longestSubstring(sub, k)\n                    for sub in s.split(char)\n                )\n        # All characters meet the requirement\n        return len(s)\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form: s = \"string\", k = 3 or simple two-line format.\"\"\"\n    # Try pattern with variable names and quotes\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if s_match and k_match:\n        s = s_match.group(1)\n        k = int(k_match.group(1))\n        return s, k\n\n    # Fallback: assume first non-empty line is string, second is integer\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        s = lines[0].strip('\"')\n        k = int(lines[1])\n        return s, k\n\n    # If still not parsed, raise an error\n    raise ValueError(\"Input format not recognized.\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        s, k = parse_input(raw_input)\n    except Exception:\n        # If parsing fails, default to empty string and 0\n        s, k = \"\", 0\n    solution = Solution()\n    result = solution.longestSubstring(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for checking if integer n is a power of two. Use Start, Decision, etc. No actual code, just virtual steps.\n\nWe need to include arrow, step, and comment. The steps:\n\nStart\n→ Step 1: Check if n <= 0 // if n is not positive, cannot be power of two\n→ Decision: If n <= 0? // decide\n    Yes → Step 2: Return false // negative or zero\n    No  → Step 3: While n > 1: // loop\n        → Decision: If n % 2 != 0? // check if not divisible by 2\n            Yes → Step 4: Return false // not a power of two\n            No  → Step 5: n = n / 2 // divide by two\n    → Step 6: Return true // n became 1\n\nEnd\n\nAlso could use bitwise trick: n & (n-1) == 0.\n\nWe can propose two versions: one using loop, one using bitwise.\n\nBut requirement: just produce virtual code. We'll choose loop method.\n\nMake sure each line has `虛擬碼步驟` + space + `// 解釋`.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 取得使用者傳入的數字\n→ Decision: n <= 0? // 判斷 n 是否為正數\n    Yes → Step 2: 回傳 false // 小於等於零不能是 2 的冪\n    No  → Step 3: While n > 1 // 只要 n 大於 1 就進行檢查\n        → Decision: n % 2 != 0? // 判斷 n 是否能被 2 整除\n            Yes → Step 4: 回傳 false // 不能整除，非 2 的冪\n            No  → Step 5: n = n / 2 // 能整除，將 n 除以 2\n    → Step 6: 回傳 true // n 變為 1，表示是 2 的冪\nEnd // 程式執行結束\n\nMake sure each line is formatted with arrow, maybe indenting inside decision. Use `→` for steps, `Decision:` with arrow.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者傳入的數字  \n→ Decision: n <= 0? // 判斷 n 是否為正數  \n    Yes → Step 2: 回傳 false // 小於等於零不能是 2 的冪  \n    No  → Step 3: While n > 1 // 只要 n 大於 1 就進行檢查  \n        → Decision: n % 2 != 0? // 判斷 n 是否能被 2 整除  \n            Yes → Step 4: 回傳 false // 不能整除，非 2 的冪  \n            No  → Step 5: n = n / 2 // 能整除，將 n 除以 2  \n    → Step 6: 回傳 true // n 變為 1，表示是 2 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef isPowerOfTwo(n: int) -> bool:\n    \"\"\"\n    檢查整數 n 是否為 2 的冪。\n    只要 n 為正且 (n & (n-1)) == 0 就是 2 的冪。\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，取得整數 n，判斷是否為 2 的冪，\n    並以小寫字串 'true' / 'false' 輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入文字中抓取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    result = isPowerOfTwo(n)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: assign cookies to children maximizing satisfied count. Classic greedy: sort greed and sizes, iterate both pointers.\n\nWe output step-by-step pseudo code with explanations. Use Start, Decision, etc. Must be line by line.\n\nLet's draft:\n\nStart\n→ Step 1: Input number of children N and cookie count M // get counts\n→ Step 2: Read array g[1..N] // greed factors\n→ Step 3: Read array s[1..M] // cookie sizes\n→ Decision: 如果 N==0 or M==0? // if no children or no cookies\n    Yes → Step 4: Output 0 // nothing can be satisfied\n    No → Step 5: Sort g ascending // smallest greed first\n→ Step 6: Sort s ascending // smallest cookie first\n→ Step 7: Initialize i=0, j=0, satisfied=0 // indices and counter\n→ Decision: 如果 i<N and j<M? // still children and cookies left\n    Yes → Decision: 如果 s[j] >= g[i]? // can satisfy current child\n        Yes → Step 8: satisfied++ // count satisfied\n              → i++ // move to next child\n              → j++ // cookie used\n        No → Step 9: j++ // cookie too small, try next cookie\n    No → End // done\n→ Step 10: Output satisfied // maximum satisfied count\n\nBut must format exactly as required: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nWe use arrow after Start? Sample: Start // 程式開始執行\n\nThey used arrow for subsequent steps: \"→ Step 1:\" etc. For Decision: \"Decision:\".\n\nFor nested decisions, indent? Use spaces? They used indent spaces before Yes/No branches. We'll mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入孩子數 N 與餅乾數 M // 取得輸入參數  \n→ Step 2: 讀入 greed 陣列 g[1..N] // 孩子最小可接受餅乾大小  \n→ Step 3: 讀入 size 陣列 s[1..M] // 每塊餅乾的大小  \n→ Decision: 如果 N==0 或 M==0? // 無孩子或無餅乾的特例  \n    Yes → Step 4: 輸出 0 // 無法滿足任何孩子  \n    No → Step 5: 將 g 陣列遞增排序 // 先考慮最小慾望的孩子  \n→ Step 6: 將 s 陣列遞增排序 // 先考慮最小大小的餅乾  \n→ Step 7: 初始化 i ← 0, j ← 0, satisfied ← 0 // 索引與滿足計數  \n→ Decision: 如果 i < N 且 j < M? // 仍有孩子與餅乾可處理  \n    Yes → Decision: 如果 s[j] ≥ g[i]? // 這塊餅乾能滿足當前孩子  \n        Yes → Step 8: satisfied ← satisfied + 1 // 記錄滿足數  \n                → i ← i + 1 // 移到下一個孩子  \n                → j ← j + 1 // 這塊餅乾已使用  \n        No → Step 9: j ← j + 1 // 這塊餅乾太小，嘗試下一塊  \n    No → End // 所有孩子或餅乾已處理完  \n→ Step 10: 輸出 satisfied // 最大可滿足的孩子數目  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_content_children(g, s):\n    \"\"\"使用貪心演算法計算最多能滿足的孩子數量。\"\"\"\n    g.sort()\n    s.sort()\n    i = j = 0\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1          # 當前孩子已滿足\n        j += 1              # 這塊餅乾已使用（無論是否滿足）\n    return i\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n\n    # 從輸入字串中提取兩個列表\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) < 2:\n        print(0)\n        return\n\n    try:\n        g = ast.literal_eval(lists[0])\n        s = ast.literal_eval(lists[1])\n    except Exception:\n        print(0)\n        return\n\n    # 確保兩個變數都是列表\n    if not isinstance(g, list) or not isinstance(s, list):\n        print(0)\n        return\n\n    result = find_content_children(g, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with explanation lines. The user wants design a MinStack. We need to produce step-by-step pseudocode of the methods. Use Start, End, Decision, etc. Provide for each line a brief explanation. Must use arrow syntax: → Step... etc. Let's produce the algorithm. We can use two stacks: mainStack and minStack. For push: push val to mainStack; if minStack empty or val <= minStack.top, push val to minStack. For pop: pop from mainStack; if popped value == minStack.top, pop from minStack. top: return mainStack.top. getMin: return minStack.top. The pseudocode should include initialization. Use Start and End. Also include Decision steps. For each function we can illustrate. Provide the entire class. The user wants virtual code, not actual code. Each line: virtual code step + comment. Use → arrow. For decisions, use \"Decision:\" and Yes →, No → lines. Let's produce. We'll write like:\n\nStart // program starts\n→ Step 1: Initialize mainStack, minStack // create two stacks\n→ End\n\nThen define functions:\n\n→ Step 2: Function push(val) // push element\n    → Step 3: mainStack.push(val) // push onto main stack\n    → Decision: if minStack.isEmpty or val <= minStack.top()?\n        Yes → minStack.push(val) // update min stack\n        No  → // do nothing\n→ End\n\nAnd so on. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立兩個空堆疊 mainStack, minStack // 用來儲存所有元素與當前最小值\n→ End // 初始設定完成\n\n// --------------------- push 操作 ---------------------\n→ Step 2: 定義 push(val) // 進入 push 方法\n    → Step 3: mainStack.push(val) // 把 val 放進主堆疊\n    → Decision: minStack.isEmpty() OR val ≤ minStack.top() ? // 判斷是否需要更新最小值堆疊\n        Yes → minStack.push(val) // 若是，將 val 也放進最小值堆疊\n        No  → // 不需更新，保持目前最小值\n→ End // push 完成\n\n// --------------------- pop 操作 ---------------------\n→ Step 4: 定義 pop() // 進入 pop 方法\n    → Step 5: val = mainStack.pop() // 從主堆疊取出頂部元素\n    → Decision: val == minStack.top() ? // 判斷被彈出的元素是否為最小值\n        Yes → minStack.pop() // 若是，從最小值堆疊同時彈出\n        No  → // 不是最小值，最小值堆疊保持不變\n→ End // pop 完成\n\n// --------------------- top 操作 ---------------------\n→ Step 6: 定義 top() // 進入 top 方法\n    → Step 7: return mainStack.top() // 回傳主堆疊的頂部元素\n→ End // top 完成\n\n// --------------------- getMin 操作 ---------------------\n→ Step 8: 定義 getMin() // 進入 getMin 方法\n    → Step 9: return minStack.top() // 回傳最小值堆疊的頂部，即目前最小值\n→ End // getMin 完成\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\nimport re\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the two lists. The input format is:\n    # [\"op1\",\"op2\",...],[args1, args2, ...]\n    parts = re.split(r'\\],\\s*\\[', data, maxsplit=1)\n    if len(parts) != 2:\n        raise ValueError(\"Input format incorrect\")\n\n    ops_str = parts[0] + ']'            # add the missing closing bracket\n    args_str = '[' + parts[1]          # add the missing opening bracket\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            obj = MinStack()\n            output.append(None)\n        elif op == \"push\":\n            obj.push(arg[0])  # arg is a list like [-2]\n            output.append(None)\n        elif op == \"pop\":\n            obj.pop()\n            output.append(None)\n        elif op == \"top\":\n            output.append(obj.top())\n        elif op == \"getMin\":\n            output.append(obj.getMin())\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null, null, null, null, -3, null, 0, -2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines for algorithm converting integer to Roman numeral. Use Start, End, Decision etc. Each line with explanation comment. Let's craft step-by-step:\n\nStart\n→ Define mapping arrays of values and symbols\n→ Define result string empty\n→ Loop over pairs (value, symbol) from highest to lowest\n   Decision: if number >= value?\n      Yes → Append symbol to result, subtract value, repeat current loop? But need recursion? Could do while num >= value. Might incorporate inner loop.\n\nWe can use while loop logic via repeated decision. Let's use iterative approach:\n\n→ For each pair (value, symbol) in descending order:\n    → While num >= value:\n        Append symbol to result\n        Subtract value from num\n    → For subtractive pairs: need check before regular? Actually process subtractive first.\n\nSimplify: Use array of tuples value->symbol including subtractive: 900->CM, 500->D, 400->CD, 100->C, 90->XC, 50->L, 40->XL, 10->X, 9->IX, 5->V, 4->IV, 1->I.\n\nThen iterate over this array, for each value:\n   Decision: if num >= value?\n      Yes → Append symbol, subtract value, repeat same step (while). We can use while loop.\n\nWe'll produce virtual code: Use Decision inside loop.\n\nOk produce final.\n\nLet's output lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ 定義值與符號對照表，從最大到最小排列  \n    // [{900,'CM'}, {500,'D'}, {400,'CD'}, {100,'C'}, {90,'XC'}, {50,'L'}, {40,'XL'}, {10,'X'}, {9,'IX'}, {5,'V'}, {4,'IV'}, {1,'I'}]  \n→ 初始化結果字串為空  \n    // result = \"\"  \n→ 從對照表第一個元素開始  \n    // idx = 0  \n→ Decision: 是否已到最後一個對照項?  \n    No → 進入當前對照項處理  \n        → Decision: 數值 num 是否大於等於對照值 value?  \n            Yes → 追加符號到結果並減去該值  \n                // result += symbol ; num -= value  \n                → 再次進入同一個對照項的 Decision  \n            No → 移動到下一個對照項  \n                // idx += 1  \n    Yes → 跳出循環  \n→ Decision: 是否已處理完所有對照項?  \n    No → 重複上述流程  \n        // 迴圈結束標記  \n    Yes → 完成轉換  \n→ Output結果  \n    // print(result)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intToRoman(self, num: int) -> str:\n        \"\"\"將十進制整數轉換成羅馬數字。\"\"\"\n        # 值與對應符號，從大到小排列\n        values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n        roman_parts = []                     # 用於存放轉換後的字串片段\n        for val, sym in zip(values, symbols):\n            if num == 0:                     # 數值已經被完全轉換\n                break\n            count = num // val              # 這個符號可以出現的次數\n            roman_parts.append(sym * count)\n            num -= val * count              # 把已轉換的部分從 num 中減去\n        return \"\".join(roman_parts)          # 合併所有片段得到最終結果\n\n\ndef main() -> None:\n    \"\"\"主程式：從標準輸入讀取數字，輸出對應的羅馬數字。\"\"\"\n    data = sys.stdin.read()                     # 讀取整個輸入\n    match = re.search(r\"\\d+\", data)             # 找出第一個連續的數字字串\n    if not match:\n        return                                 # 若無數字，直接結束\n    num = int(match.group())\n    solution = Solution()\n    print(solution.intToRoman(num))             # 將結果寫回標準輸出\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanations, according to the format. The requirement: \"Given two version strings... compare them\". So algorithm: split strings by '.', iterate with index up to max length of splits, parse each part to int (strip leading zeros implicitly by integer conversion), compare. If difference, return -1 or 1. After loop, return 0.\n\nAlso need to handle missing revisions as 0.\n\nWe need to output with Start, End, Decision, etc. Use arrow →. Provide short explanation per line.\n\nLet's produce code steps. Let's use Start, then Step: split strings, compute lengths, index loop, inside loop convert, compare, decisions, return.\n\nUse \"Decision:\" for comparisons.\n\nLet's produce.\n\nExample:\n\nStart // 程式開始\n→ Step 1: split version1 by '.' into listA // 取得 version1 的修訂清單\n→ Step 2: split version2 by '.' into listB // 取得 version2 的修訂清單\n→ Step 3: maxLen = max(length of listA, length of listB) // 找出較長的修訂數\n→ Step 4: index = 0 // 初始化索引\n→ Decision: index < maxLen? // 迴圈直到比對完所有修訂\n    Yes → Step 5: revA = integer value of listA[index] if exists else 0 // 取得版本1該位修訂，缺則為0\n    Yes → Step 6: revB = integer value of listB[index] if exists else 0 // 取得版本2該位修訂，缺則為0\n    Yes → Decision: revA < revB? // 比較兩個修訂值\n        Yes → Step 7: return -1 // 版本1較小\n        No  → Decision: revA > revB? // 另一方向\n            Yes → Step 8: return 1 // 版本1較大\n            No  → Step 9: index = index + 1 // 兩者相同，進入下一位\n    Yes → Step 10: index = index + 1 // 若index >= maxLen，迴圈結束\n→ Step 11: return 0 // 所有修訂相等\nEnd // 程式執行結束\n\nBut ensure arrows align.\n\nWe need each line: \"虛擬碼步驟 [space] // 解釋\". The arrow symbol \"→\" used. Use \"Decision:\" lines with indent? In example they indent Yes → etc.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: listA = split(version1, '.') // 將 version1 按 '.' 分割成修訂清單\n→ Step 2: listB = split(version2, '.') // 將 version2 按 '.' 分割成修訂清單\n→ Step 3: maxLen = max(length(listA), length(listB)) // 獲取較長修訂數\n→ Step 4: index = 0 // 初始化索引\n→ Decision: index < maxLen? // 循環遍歷所有修訂\n    Yes → Step 5: revA = (index < length(listA)) ? int(listA[index]) : 0 // 取得版本1該位修訂，缺則為 0\n    Yes → Step 6: revB = (index < length(listB)) ? int(listB[index]) : 0 // 取得版本2該位修訂，缺則為 0\n    Yes → Decision: revA < revB? // 比較兩修訂\n        Yes → Step 7: return -1 // 版本1小於版本2\n        No  → Decision: revA > revB? // 版本1是否大於版本2\n            Yes → Step 8: return 1 // 版本1大於版本2\n            No  → Step 9: index = index + 1 // 修訂相等，遞增索引\n    Yes → Step 10: index = index + 1 // 繼續下一位\n→ Step 11: return 0 // 所有修訂相等\nEnd // 程式執行結束\n\nWe should maintain the indentation as shown. That should satisfy. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: listA = split(version1, '.') // 將 version1 按 '.' 分割成修訂清單  \n→ Step 2: listB = split(version2, '.') // 將 version2 按 '.' 分割成修訂清單  \n→ Step 3: maxLen = max(length(listA), length(listB)) // 獲取較長修訂數  \n→ Step 4: index = 0 // 初始化索引  \n→ Decision: index < maxLen? // 循環遍歷所有修訂  \n    Yes → Step 5: revA = (index < length(listA)) ? int(listA[index]) : 0 // 取得版本1該位修訂，缺則為 0  \n    Yes → Step 6: revB = (index < length(listB)) ? int(listB[index]) : 0 // 取得版本2該位修訂，缺則為 0  \n    Yes → Decision: revA < revB? // 比較兩修訂  \n        Yes → Step 7: return -1 // 版本1小於版本2  \n        No  → Decision: revA > revB? // 版本1是否大於版本2  \n            Yes → Step 8: return 1 // 版本1大於版本2  \n            No  → Step 9: index = index + 1 // 修訂相等，遞增索引  \n    Yes → Step 10: index = index + 1 // 繼續下一位  \n→ Step 11: return 0 // 所有修訂相等  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        v1 = [int(x) for x in version1.split('.')]\n        v2 = [int(x) for x in version2.split('.')]\n        max_len = max(len(v1), len(v2))\n        for i in range(max_len):\n            num1 = v1[i] if i < len(v1) else 0\n            num2 = v2[i] if i < len(v2) else 0\n            if num1 < num2:\n                return -1\n            elif num1 > num2:\n                return 1\n        return 0\n\ndef parse_input(data: str):\n    \"\"\"Parse input like: version1 = \"1.2\", version2 = \"1.10\".\"\"\"\n    # Use regex to find values; support quoted or unquoted\n    v1_match = re.search(r'version1\\s*=\\s*\"([^\"]*)\"|version1\\s*=\\s*([^\\s,]+)', data)\n    v2_match = re.search(r'version2\\s*=\\s*\"([^\"]*)\"|version2\\s*=\\s*([^\\s,]+)', data)\n    if not v1_match or not v2_match:\n        raise ValueError(\"Input format is incorrect.\")\n    v1 = v1_match.group(1) or v1_match.group(2)\n    v2 = v2_match.group(1) or v2_match.group(2)\n    return v1, v2\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    try:\n        ver1, ver2 = parse_input(raw_input)\n    except Exception:\n        # Fallback: try simple split by comma if regex fails\n        parts = raw_input.split(',')\n        ver1 = parts[0].split('=')[1].strip().strip('\"')\n        ver2 = parts[1].split('=')[1].strip().strip('\"')\n    solution = Solution()\n    result = solution.compareVersion(ver1, ver2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps, line by line, with explanation. Let's craft algorithm: Count frequencies, create list of (word, freq). Sort by freq descending, then lex ascending. Take first k words. Return list. Steps: Start, Input words and k, Step 1: Count frequencies using dictionary, Step 2: Convert to list of pairs, Step 3: Sort with custom comparator, Step 4: Initialize result list, Step 5: Iterate over sorted list up to k, add word to result, Step 6: Return result, End. Use Decision for if word list empty etc? Not necessary. Provide virtual code with arrow etc.\n\nWe need to output each line: \"Start // 程式開始執行\" etc. Use arrow symbol →. Provide indentation for decision branches? Not necessary.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input words, k // 取得輸入的字串陣列與 k\n→ Step 1: freqMap ← new Map() // 建立頻率字典\n→ For each word in words:\n    → freqMap[word] ← freqMap.get(word, 0) + 1 // 更新頻率\n→ Step 2: freqList ← [] // 建立頻率列表\n→ For each (word, count) in freqMap:\n    → freqList.append((word, count)) // 將字串與頻率加入列表\n→ Step 3: freqList.sort( (a,b) => b.count - a.count || a.word.localeCompare(b.word) ) // 依頻率降序、字典序升序排序\n→ Step 4: result ← [] // 建立結果列表\n→ For i in 0 to k-1:\n    → result.append(freqList[i].word) // 取前 k 個字串\n→ Return result // 回傳結果\nEnd // 程式執行結束\n\nBut need to use virtual code arrow \"→\". Also use \"Decision:\" only if condition. Here no decision needed except maybe if k > list length? But we can skip. Provide explanation after each line.\n\nLet's craft final answer accordingly. Ensure each line ends with \"// 解釋/說明\". Use Chinese. Provide line numbering? Not necessary. Just each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input words, k // 取得輸入的字串陣列與整數 k  \n→ Step 1: freqMap ← new Map() // 建立一個空的頻率字典  \n→ For each word in words: // 逐一遍歷所有字串  \n    → freqMap[word] ← freqMap.get(word, 0) + 1 // 若字串已存在則加 1，否則初始化為 1  \n→ Step 2: freqList ← [] // 建立一個空的頻率列表  \n→ For each (word, count) in freqMap: // 迭代頻率字典中的所有項目  \n    → freqList.append((word, count)) // 將 (字串, 頻率) 轉為元組加入列表  \n→ Step 3: freqList.sort( (a,b) => b.count - a.count || a.word.localeCompare(b.word) ) // 先依頻率降序排序，頻率相同則按字典序升序  \n→ Step 4: result ← [] // 建立結果列表  \n→ For i in 0 to k-1: // 取前 k 個最高頻的字串  \n    → result.append(freqList[i].word) // 將字串加入結果  \n→ Return result // 回傳最終的 k 個字串結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        \"\"\"返回最常見的 k 個單字，按頻率降序，頻率相同按字典序升序。\"\"\"\n        count = Counter(words)\n        # 先按頻率降序 (-freq)，再按字典序升序\n        sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n        return [word for word, _ in sorted_words[:k]]\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中提取 words 列表和 k 整數\n    words_match = re.search(r'words\\s*=\\s*(\\[.*\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n\n    if not words_match or not k_match:\n        raise ValueError(\"輸入格式不正確，請使用 'words = [...] , k = ...'\")\n\n    words_str = words_match.group(1)\n    k_str = k_match.group(1)\n\n    # 使用 ast.literal_eval 解析列表字串，避免 eval 的風險\n    import ast\n    words = ast.literal_eval(words_str)\n    k = int(k_str)\n\n    # 取得結果\n    sol = Solution()\n    result = sol.topKFrequent(words, k)\n\n    # 輸出 JSON 格式的列表（符合範例輸出）\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "[\"i\", \"love\"]"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "[\"the\", \"is\", \"sunny\", \"day\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode728.json",
    "problem_index_in_file": 0,
    "title": "Self Dividing Numbers",
    "description_snippet": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: given left, right, list self-dividing numbers in range. Provide step-by-step pseudo code, each line with comment. Use Start, Decision, etc. Avoid actual code. Just virtual. We'll describe algorithm: iterate numbers from left to right, check each number's digits: if any digit zero, skip; else if number divisible by each digit, include in result list. After loop, return list. Also handle input maybe. Use virtual arrows.\n\nWe need to output line by line with `虛擬碼步驟 // 解釋`.\n\nLet's produce.\n\nMake sure to use structure: Start, Step, Decision. Use arrow `→`. For each iteration, we need to check digits. We'll use nested loops.\n\nWe can break algorithm:\n\nStart\n→ Step 1: Initialize result list // empty\n→ Step 2: For num from left to right // iterate\n→ Decision: Does num contain digit zero? // check\n    Yes → Continue // skip to next num\n    No  → Step 3: Check divisibility by each digit // inner loop\n        → Decision: Is num divisible by current digit? // check\n            Yes → Continue loop\n            No  → Decision: Skip this num // set flag false\n        → End inner loop\n→ Decision: If num is self-dividing? // flag true\n    Yes → Step 4: Append num to result // add\n→ End for loop\n→ Step 5: Return result // output\n\nWe need to maintain flags. We'll represent inner loop.\n\nAlso we need to indicate while or for loops using arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 result // 用於存放符合條件的數字  \n→ Step 2: 從 left 到 right 逐個取整數 num // 進行範圍遍歷  \n→ Decision: num 是否包含數字 0? // 先排除不允許的數字  \n  Yes → Step 3: 跳過本次循環 // 直接進下一個 num  \n  No  → Step 4: 設定 flag = true // 假設目前 num 仍為自除數  \n   → Step 5: 將 num 轉為字串 digits，逐位處理 // 取得每一個數位  \n    → Step 6: 對於每個字符 digit in digits  \n     → Decision: digit 是否為 '0'? // 這裡已排除，但再檢查安全  \n       Yes → flag = false // 若有 0 就不是自除數  \n       No  → Step 7: 轉換 digit 為整數 d  \n        → Decision: num % d == 0? // 檢查除盲\n          Yes → 進行下一個 digit  \n          No  → flag = false // 若不整除即不是自除數  \n           → Step 8: 跳出內層迴圈 // 不需要再檢查  \n            → Step 9: 進入下個 num  \n     → End 循環 digits  \n   → Decision: flag 為 true? // 完全檢查後是否仍為自除數  \n    Yes → Step 10: 把 num 加入 result // 收集符合條件的數字  \n    No  → 何也不做 // 跳過  \n→ End for num  \n→ Step 11: 返回 result // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef self_dividing_numbers(left: int, right: int) -> list[int]:\n    \"\"\"\n    Return all self‑dividing numbers in the inclusive range [left, right].\n    A self‑dividing number is divisible by every one of its digits\n    and cannot contain the digit 0.\n    \"\"\"\n    result = []\n    for num in range(left, right + 1):\n        temp = num\n        is_dividing = True\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0 or num % digit != 0:\n                is_dividing = False\n                break\n            temp //= 10\n        if is_dividing:\n            result.append(num)\n    return result\n\nif __name__ == \"__main__\":\n    # Read entire stdin, extract all integers (handles formats like\n    # \"left = 1, right = 22\" or just \"1 22\").\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 2:\n        raise ValueError(\"Input must contain at least two integers: left and right.\")\n    left, right = numbers[0], numbers[1]\n    # Ensure left <= right; if not, swap to maintain inclusive range.\n    if left > right:\n        left, right = right, left\n    result = self_dividing_numbers(left, right)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 1, right = 22",
          "expected_output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]",
          "success": true,
          "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]"
        },
        {
          "example_index": 1,
          "input": "left = 47, right = 85",
          "expected_output": "[48,55,66,77]",
          "success": true,
          "output": "[48, 55, 66, 77]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: Given array nums, positive integer k, determine if possible to split into groups of k consecutive numbers. Classic problem: \"Divide Array in Sets of K Consecutive Numbers\" Leetcode. Approach: frequency map, sort unique values. For each number in sorted order, if count>0, use it as start of group, decrement counts of next k-1 consecutive numbers. If any fails return false.\n\nWe need to produce step-by-step virtual code with explanations.\n\nWe need to be careful: \"虛擬碼步驟\" per line, with arrow and comments. Use \"Start\", \"Decision:\", \"End\". Provide each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". No actual code.\n\nLet's outline steps:\n\nStart\n→ Step 1: 建立頻率地圖 freq 將每個數字對應出現次數 // 先統計每個元素出現頻次\n→ Step 2: 取得所有鍵並排序 uniqueSorted // 需要按升序處理\n→ Decision: 如果 nums 長度不是 k 的倍數? // 必須滿足總數可被 k 整除\n    Yes → Step 3: 返回 false // 無法分組\n    No  → // 進一步檢查\n→ Step 4: 對於每個 num in uniqueSorted:\n        Decision: freq[num] 為 0? // 若已被用完，跳過\n            Yes → // 跳過\n            No  → Step 5: 將 count = freq[num] // 這個數字會作為多個組的起始\n                    → Step 6: 對 offset 0..k-1:\n                        ← Decision: freq[num + offset] < count? // 需要足夠個數\n                            Yes → Step 7: 返回 false // 不足，無法分組\n                            No  → // 減去 count\n                                → Step 8: freq[num + offset] -= count // 移除這些元素\n→ End // 若完成全部，返回 true\n\nAlso we need to consider that after loop, if no false, return true. So Step 9: return true // 成功分組\n\nAlso need to handle early return false if any freq insufficient.\n\nAlso need to use \"Yes →\", \"No →\" for decisions.\n\nAlso we may need to check that after loop we return true.\n\nSo we will produce lines accordingly.\n\nWe need to include \"Start\" and \"End\". Use \"→\" arrow.\n\nLet's write lines. Each line has \"虛擬碼步驟\" followed by space and \"// 解釋\". Example:\n\nStart // 程式開始執行\n→ Step 1: ... // 解釋\n\nNeed to ensure consistent indentation for nested decisions. Use tab or space. We'll use indentation by 4 spaces before nested lines? In example, nested lines start with spaces. We'll just use spaces. Use e.g.:\n\n→ Decision: 如果 nums 長度不是 k 的倍數? // ...\n    Yes → Step 3: 返回 false // ...\n    No  → // 進一步檢查\n\nWe'll produce accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立頻率地圖 freq，將 nums 中每個整數對應到其出現次數 // 先統計每個元素的出現頻率\n→ Step 2: 取得 freq 的所有鍵並按升序排序為 uniqueSorted // 以升序順序處理，方便檢查連續數列\n→ Decision: 如果 nums 的長度不等於 k 的整數倍? // 必須滿足總數可被 k 整除，否則無法完全分組\n    Yes → Step 3: 返回 false // 數量不匹配，直接失敗\n    No  → // 進一步檢查每個可能的起始數字\n→ Step 4: 對每個 num 在 uniqueSorted 逐一處理：\n        Decision: 如果 freq[num] 為 0? // 已經被前面的組完全消耗，跳過\n            Yes → // 跳過此數字\n            No  → Step 5: 設 count ← freq[num] // 這個數字會作為多個組的起始，且每組需要 count 個\n                    → Step 6: 對 offset 從 0 到 k-1 做如下判斷：\n                        Decision: 如果 freq[num + offset] < count? // 後續連續數字的可用數量不足\n                            Yes → Step 7: 返回 false // 不能組成連續序列，失敗\n                            No  → Step 8: freq[num + offset] ← freq[num + offset] - count // 將這些數字從頻率表中減去\n→ Step 9: 所有數字都已成功處理，返回 true // 能夠完整分成 k 個連續數字的組\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k):\n        # 必須整除 k，否則無法分組\n        if len(nums) % k != 0:\n            return False\n\n        # 先統計每個數字的頻率\n        count = Counter(nums)\n\n        # 按升序處理每個可能的起始數字\n        for num in sorted(count):\n            freq = count[num]\n            if freq == 0:\n                continue  # 已被前面的組消耗\n\n            # 嘗試用 freq 個數作為多個組的起始\n            for i in range(num, num + k):\n                if count[i] < freq:\n                    return False  # 無法得到足夠的連續數字\n                count[i] -= freq\n\n        return True\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 把所有整數找出來，最後一個是 k\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if not numbers:\n        print(\"false\")\n        sys.exit()\n\n    k = numbers[-1]\n    nums = numbers[:-1]\n\n    solution = Solution()\n    result = solution.isPossibleDivide(nums, k)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, line by line, following format. No actual code, just pseudo steps.\n\nThe problem: product except self, O(n), no division. Standard solution: compute prefix products and suffix products, store in answer. Steps: initialize answer array with 1, compute left product iterating, then right product.\n\nWe need to output step by step.\n\nWe need to follow formatting: Each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nStart, End, Decision. But this is an algorithm; we may include loops as steps. We can use \"Loop: i from 1 to n-1\" or \"Step: compute left product\".\n\nWe must not output actual code but just steps.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化答案陣列 answer 為長度 n 且所有元素為 1 // 每個位置預設為 1\n→ Step 2: 初始化左乘積 left = 1 // 用於累積前綴乘積\n→ Loop: for i in 0 to n-1\n    → Step 3: 將 answer[i] 設為左乘積 // 當前位置存入前綴乘積\n    → Step 4: 更新左乘積 ← left * nums[i] // 更新左乘積為前綴乘積\n→ End Loop\n→ Step 5: 初始化右乘積 right = 1 // 用於累積後綴乘積\n→ Loop: for i in n-1 downto 0\n    → Step 6: 將 answer[i] 乘以右乘積 // 合併前後乘積\n    → Step 7: 更新右乘積 ← right * nums[i] // 更新右乘積\n→ End Loop\n→ Step 8: 回傳 answer // 完成結果\n\nBut need to use \"Decision:\" maybe not needed. But we can include a decision for loop conditions.\n\nLet's format each line accordingly.\n\nMake sure each line has 虛擬碼步驟, then space, then // 解釋.\n\nLet's produce.\n\nAlso we need to use arrow '→'. Each line begins with '→' or not? Format example: \"Start // 程式開始執行\" and then \"→ Step 1:\" etc. So we need to use 'Start' line without arrow. Then subsequent lines start with '→'. For loops, we can embed loops as separate lines: \"→ Loop: for i from 0 to n-1\" then indent steps inside? But we can't indent. But we can use nested arrows: \"→ Loop: for i from 0 to n-1\" then next line \"→ Step ...\" Actually the example uses \"Decision:\" with indentation inside. So we can use \"→ Loop:\" maybe.\n\nAlternatively use \"Decision:\" to check condition. But easier to just present steps sequentially.\n\nWe'll provide each line as separate with arrow. Use \"→ Loop: i in 0..n-1\" then next lines starting with \"→\" again.\n\nBut need to show the step inside loop? Use indent like spaces before arrow? The example shows indent with spaces after Decision. But not mandatory. We'll follow example: indentation for nested lines using spaces before arrow.\n\nExample:\n\nDecision: ... \n    Yes → Step ...\n\nSo we need indent lines within loop: use spaces before arrow.\n\nSo for loop: \"→ Loop: i from 0 to n-1\" then inside indent.\n\nBut example didn't show loop but we can mimic: \"→ Loop: i from 0 to n-1\" then indent 4 spaces before next arrow.\n\nLet's produce.\n\nOk.\n\nAlso after loops we end.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化答案陣列 answer 為長度 n 且所有元素皆為 1 // 先把所有位置設為 1，作為未來乘積的基底  \n→ Step 2: 設定左乘積變數 left = 1 // 用來累積前綴乘積  \n→ Loop: i 從 0 迭代到 n-1  \n  → Step 3: 將 answer[i] 設為 left // 把目前前綴乘積存入答案陣列  \n  → Step 4: 更新 left ← left × nums[i] // 更新左乘積為新的前綴乘積  \n→ End Loop  \n→ Step 5: 設定右乘積變數 right = 1 // 用來累積後綴乘積  \n→ Loop: i 從 n-1 迭代到 0  \n  → Step 6: 將 answer[i] 乘以 right // 把後綴乘積合併進答案陣列  \n  → Step 7: 更新 right ← right × nums[i] // 更新右乘積為新的後綴乘積  \n→ End Loop  \n→ Step 8: 回傳 answer // 最終得到除自身以外所有元素乘積的結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef product_except_self(nums):\n    n = len(nums)\n    res = [1] * n\n    left = 1\n    for i in range(n):\n        res[i] = left\n        left *= nums[i]\n    right = 1\n    for i in range(n - 1, -1, -1):\n        res[i] *= right\n        right *= nums[i]\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        start = data.find('[')\n        end = data.rfind(']')\n        if start != -1 and end != -1 and end > start:\n            nums = ast.literal_eval(data[start:end + 1])\n        else:\n            nums = []\n        result = product_except_self(nums)\n        print('[' + ','.join(map(str, result)) + ']')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24,12,8,6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0,0,9,0,0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: create maximum number of length k from two sequences preserving order. Classic problem \"Create Maximum Number\" from Leetcode 321. Approach: choose i digits from nums1 (0..k) and k-i from nums2, get max subsequence of length i from nums1, of length k-i from nums2, merge them to produce maximum number, track best.\n\nSo we produce steps: Start, read inputs, for i from max(0,k-n) to min(k,m), compute subsequence1 = maxSubsequence(nums1,i), subsequence2 = maxSubsequence(nums2,k-i), merged = merge(subseq1,subseq2). If merged > best: best = merged. End return best.\n\nNeed virtual code with arrows and decision, etc. Provide step-by-step. No actual code. Use virtual code style. Provide each line with explanation comment.\n\nLet's craft.\n\nWe also need definitions of maxSubsequence: use stack to pick largest subsequence of given length, maintaining order.\n\nmerge: choose lexicographically larger remaining sequences.\n\nLet's produce.\n\nAlso need decisions: For loop, if better.\n\nLet's craft.\n\nUse pseudo lines: Start, → Step 1: Initialize best as empty list, etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 m ← length(nums1), n ← length(nums2) // 取得兩個陣列長度  \n→ Step 2: best ← 空陣列 // 用來儲存目前最優的 k 位數字  \n→ Decision: 如果 k <= 0? // 確認 k 有效  \n  Yes → End // k 為非正數，直接結束（不需要進一步處理）  \n  No  →  \n   → Step 3: i_min ← max(0, k - n) // 從 nums1 中取至少這個數字才能滿足 k  \n   → Step 4: i_max ← min(k, m) // 從 nums1 中最多取這個數字  \n   → For i 從 i_min 到 i_max: // 嘗試所有可能的分配  \n     → Step 5: sub1 ← maxSubsequence(nums1, i) // 取得 nums1 中長度為 i 的最大子序列  \n     → Step 6: sub2 ← maxSubsequence(nums2, k - i) // 取得 nums2 中長度為 k-i 的最大子序列  \n     → Step 7: merged ← merge(sub1, sub2) // 合併兩個子序列得到長度為 k 的數字  \n     → Decision: 如果 merged > best? // 比較字典序是否更大  \n       Yes → best ← merged // 更新最優答案  \n       No  → // 保持現有 best  \n           \n    → End For  \n   → Step 8: Return best // 回傳最終得到的 k 位數字  \nEnd // 程式執行結束  \n\n// 虛擬函式定義：  \n→ Function maxSubsequence(arr, t): // 從 arr 取長度為 t 的最大子序列  \n  → stack ← 空堆疊  \n  → drop ← length(arr) - t // 允許刪除的字元數  \n  → For 每個 num in arr:  \n    → While drop > 0 AND stack 不是空 AND stack.top() < num:  \n       drop ← drop - 1  \n       pop stack  \n    → push num 至 stack  \n   → 截取 stack 前 t 個元素作為結果  \n  → Return 結果  \n\n→ Function merge(a, b): // 合併兩個子序列得到最大的字典序  \n  → res ← 空陣列  \n  → While a 不是空 OR b 不是空:  \n    → If a > b? // 直接字典序比較  \n       Yes → append a[0] 至 res, 移除 a[0]  \n       No  → append b[0] 至 res, 移除 b[0]  \n  → Return res",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        def pick_max(nums, t):\n            \"\"\"Return the maximum subsequence of length t from nums.\"\"\"\n            drop = len(nums) - t\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]\n\n        def merge(a, b):\n            \"\"\"Merge two subsequences into the largest possible sequence.\"\"\"\n            i = j = 0\n            res = []\n            while i < len(a) or j < len(b):\n                # Compare the remaining parts lexicographically\n                if a[i:] > b[j:]:\n                    res.append(a[i])\n                    i += 1\n                else:\n                    res.append(b[j])\n                    j += 1\n            return res\n\n        best = []\n        # i digits from nums1, k-i digits from nums2\n        for i in range(max(0, k - len(nums2)), min(k, len(nums1)) + 1):\n            sub1 = pick_max(nums1, i)\n            sub2 = pick_max(nums2, k - i)\n            candidate = merge(sub1, sub2)\n            if candidate > best:\n                best = candidate\n        return best\n\n\ndef parse_input() -> tuple[list[int], list[int], int]:\n    \"\"\"Parse the stdin input of the form:\n       nums1 = [...], nums2 = [...], k = ...\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract the two lists\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) < 2:\n        raise ValueError(\"Input must contain two lists for nums1 and nums2.\")\n    nums1 = eval(lists[0])\n    nums2 = eval(lists[1])\n    # Extract k\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Input must contain k value.\")\n    k = int(k_match.group(1))\n    return nums1, nums2, k\n\n\nif __name__ == \"__main__\":\n    nums1, nums2, k = parse_input()\n    result = Solution().maxNumber(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": true,
          "output": "[9, 8, 6, 5, 3]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": true,
          "output": "[6, 7, 6, 0, 4]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": true,
          "output": "[9, 8, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: integer break problem maximize product. Standard solution: dynamic programming or greedy: for integer n >= 2. Use DP: max product for each i. DP[0]=0, DP[1]=1? Actually product of split at least 2 parts, so DP[1]=1? But for n=2, answer 1. Use DP[0]=0? We can compute DP[i] = max of j*(i-j) and j*DP[i-j] for j from 1 to i-1. But we can produce greedy: break into 3's as many as possible, except when remainder 1 adjust. Let's produce algorithm: if n <= 3 return n-1. else compute result. So implement virtual code.\n\nWe output step lines with explanations. Use structure: Start, Decision, etc. Need to be step by step.\n\nLet's design:\n\nStart\n→ Step 1: Receive integer n\n→ Decision: n <= 3?\n    Yes → Step 2: Return n-1 // base cases\n    No  → Step 3: Initialize result = 1 // product accumulator\n           Initialize countThree = 0 // number of 3's\n           → Step 4: While n > 4:\n               // keep breaking into 3's\n               → Step 5: result = result * 3\n               → Step 6: n = n - 3\n               → Step 7: countThree = countThree + 1\n           → Decision: n == 4?\n               Yes → Step 8: result = result * 4 // 2*2 product\n               No  → Step 9: result = result * n // remaining 2 or 3\n           → Step 10: Return result\n\nBut also need to include explanation comments after each line.\n\nWe can use arrow arrows. Use \"→\". For loops, we can express as \"Decision: n > 4?\" then Yes loop.\n\nLet's create virtual code lines.\n\n1. Start // 程式開始執行\n2. → Step 1: Input n // 取得輸入整數\n3. → Decision: n <= 3? // 判斷是否為基礎情況\n4.    Yes → Step 2: Return n-1 // n=2 回 1, n=3 回 2\n5.    No  → Step 3: result = 1 // 初始乘積\n6.    No  → Step 4: countThree = 0 // 3 的個數\n7.    No  → Decision: n > 4? // 需要多次拆 3\n8.        Yes → Step 5: result = result * 3 // 加入一個 3\n9.        Yes → Step 6: n = n - 3 // 减去 3\n10.       Yes → Step 7: countThree = countThree + 1 // 3 的數量加一\n11.       Yes → Decision: n > 4? // 仍然大於 4 循環\n12.           No → Step 8: Decision: n == 4? // 特殊處理 4\n13.               Yes → Step 9: result = result * 4 // 4 = 2*2\n14.               No  → Step 10: result = result * n // 其餘為 2 或 3\n15.               No → Step 11: Return result // 最終結果\n\nBut need to maintain correct structure. Actually after loop we just proceed to process remainder.\n\nSimplify: Use a while loop concept: while n > 4: result *=3; n -=3. After loop: result *= n; return result. And base case.\n\nLet's produce virtual code accordingly.\n\nWe must maintain each line with \"→\" after Start? Start is separate.\n\nStart\n→ Step 1: Input n //取得整數\n→ Decision: n <= 3? //判斷基礎情況\n   Yes → Step 2: Return n-1 // n=2或3時的答案\n   No  → Step 3: result = 1 // 初始化乘積\n   No  → Step 4: While n > 4? // 需要拆成多個3\n        Yes → Step 5: result = result * 3 // 加入一個3\n        Yes → Step 6: n = n - 3 // 將n減去3\n        Yes → Step 7: Repeat While n > 4\n        No  → Step 8: result = result * n // 最後剩餘的2或3或4\n   No  → Step 9: Return result // 回傳最大乘積\n\nBut we need to express loop in decision structure. Use Decision: n > 4? Yes then steps.\n\nBetter to structure: After Step 3, we set result, then go to Decision: n > 4? If Yes, we execute Steps 5,6, and then loop back to Decision. If No, proceed to Step 8.\n\nLet's write lines:\n\nStart\n→ Step 1: Input n\n→ Decision: n <= 3?\n    Yes → Step 2: Return n-1\n    No  → Step 3: result = 1\n    No  → Decision: n > 4?\n        Yes → Step 4: result = result * 3\n        Yes → Step 5: n = n - 3\n        Yes → Decision: n > 4? // loop back\n        No  → Step 6: result = result * n\n        No  → Step 7: Return result\n\nBut we need to ensure indentation. Provide indent lines using spaces? Not required but can show indent. Just maintain arrows and decisions. For loop, we can use repeated decisions.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input n // 取得輸入整數  \n→ Decision: n <= 3? // 判斷是否為基礎情況  \n  Yes → Step 2: Return n-1 // n=2 或 3 時的答案 (2 → 1, 3 → 2)  \n  No  → Step 3: result = 1 // 初始化乘積  \n  No  → Decision: n > 4? // 需要將 n 拆成多個 3  \n    Yes → Step 4: result = result * 3 // 加入一個 3  \n    Yes → Step 5: n = n - 3 // 將 n 減去 3  \n    Yes → Decision: n > 4? // 重新檢查是否仍 > 4，形成迴圈  \n    No  → Step 6: result = result * n // 最後剩餘的 2、3 或 4  \n    No  → Step 7: Return result // 回傳最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef integer_break(n: int) -> int:\n    \"\"\"\n    最大化將整數 n 拆成至少兩個正整數相加後的乘積。\n    \"\"\"\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n\n    result = 1\n    # 盡量拆成 3，因為 3 的乘積最大\n    while n > 4:\n        result *= 3\n        n -= 3\n    # 最後剩餘 2、3 或 4 時直接乘上\n    return result * n\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取數據，輸出最大乘積。\n    支援形如「n = 10」或「10」等輸入。\n    \"\"\"\n    data = sys.stdin.read()\n    # 找出第一個正整數\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(integer_break(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations. It's a sliding window algorithm: count frequencies of p, window of size len(p), compare.\n\nWe produce steps: Start, Step 1: initialize variables, Step 2: create freq map for p, Step 3: create window map, Step 4: iterate, etc. Use Decision.\n\nWe need to use virtual code arrows and structure. Provide each line: virtual code step [space] // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: sLen ← length of s, pLen ← length of p // 取得兩個字串長度\n→ Step 2: If pLen > sLen → End // 若 p 長度大於 s，無法找到任何排列\n→ Decision: 需要的字元頻率表？ // 建立 p 的字元頻率表\n    → Step 3: targetCount ← array[26] initialized to 0\n    → Step 4: For each character c in p: targetCount[ c - 'a' ] ← targetCount[ c - 'a' ] + 1 // 填入 p 的頻率\n→ Decision: 滑動視窗初始化？ // 建立 s 的滑動視窗頻率表\n    → Step 5: windowCount ← array[26] initialized to 0\n    → Step 6: For i = 0 to pLen-1: windowCount[ s[i] - 'a' ] ← windowCount[ s[i] - 'a' ] + 1 // 初始視窗填充\n→ Step 7: result ← empty list // 儲存所有符合的起始索引\n→ Decision: 第一個視窗是否匹配？ // 檢查初始視窗是否為 p 的排列\n    Yes → Step 8: Append 0 to result // 若匹配，將起始位置 0 加入結果\n    No  → // 何也不做\n→ Step 9: For i = pLen to sLen-1: // 滑動視窗移動\n    → Step 10: enterChar ← s[i] // 新進入字元\n    → Step 11: exitChar ← s[i - pLen] // 從視窗移出的字元\n    → Step 12: windowCount[ enterChar - 'a' ] ← windowCount[ enterChar - 'a' ] + 1 // 加入新字元\n    → Step 13: windowCount[ exitChar - 'a' ] ← windowCount[ exitChar - 'a' ] - 1 // 移除舊字元\n    → Decision: 當前視窗是否匹配？ // 比較兩個頻率表是否相同\n        Yes → Step 14: Append (i - pLen + 1) to result // 匹配，加入起始索引\n        No  → // 何也不做\n→ Step 15: Return result // 回傳所有找到的起始索引\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> list[int]:\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        # 目標頻率表 (p 的字元頻率)\n        target = [0] * 26\n        for ch in p:\n            target[ord(ch) - 97] += 1\n\n        # 滑動視窗頻率表 (目前視窗 s[0:np] 的字元頻率)\n        window = [0] * 26\n        for i in range(np):\n            window[ord(s[i]) - 97] += 1\n\n        result = []\n        # 第一個視窗是否符合\n        if window == target:\n            result.append(0)\n\n        # 從 np 開始滑動窗口，每次進一個字元，移除一個字元\n        for i in range(np, ns):\n            # 新進字元\n            window[ord(s[i]) - 97] += 1\n            # 從視窗移出的字元\n            window[ord(s[i - np]) - 97] -= 1\n            if window == target:\n                result.append(i - np + 1)\n\n        return result\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得字串中的兩個 quoted 字串\n    strings = re.findall(r'\"([^\"]*)\"', data)\n    if len(strings) < 2:\n        # 若輸入格式不是預期的 quoted 形式，嘗試直接分割\n        parts = [part.strip() for part in data.split(',')]\n        if len(parts) >= 2:\n            s = parts[0].split('=')[-1].strip()\n            p = parts[1].split('=')[-1].strip()\n        else:\n            # 無法解析，直接結束\n            return\n    else:\n        s, p = strings[0], strings[1]\n\n    sol = Solution()\n    res = sol.findAnagrams(s, p)\n    print(res)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is a problem: given string s, count unique non-empty substrings that appear in infinite wraparound string of alphabet. Known solution: use DP array of length 26 to record longest substring ending with each char. For each char in s, maintain current length, update dp. At the end, sum dp. So we produce pseudocode steps.\n\nWe should output each line as \"虛擬碼步驟 // 解釋\" with arrow syntax. Use Start, End, Decision, etc.\n\nLet's produce stepwise: \nStart\n→ Initialize array dp[26] = 0 // length of longest substring ending with each letter\n→ current_len = 0 // current consecutive length\n→ For each character c in s // iterate over s\n    → prev_char = previous character (if exists)\n    → if prev_char exists and (c == prev_char +1 mod 26) // consecutive in alphabet\n        → current_len = current_len + 1\n        → Decision: If current_len > dp[c]?\n            Yes → dp[c] = current_len\n    → else\n        → current_len = 1\n        → Decision: If 1 > dp[c]?\n            Yes → dp[c] = 1\n→ sum = 0\n→ For each value in dp\n    → sum = sum + value\n→ Return sum // number of unique substrings\n\nWe need to show decisions with Yes/No arrows. Also loops.\n\nAlso we need to consider wraparound: mapping char to index. Use modulo 26.\n\nAdd \"Decision: If previous character is consecutive?\".\n\nWe need to maintain prev_char for each iteration.\n\nLet's produce pseudocode lines accordingly.\n\nAlso include comment after each line.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize dp[26] = 0 // 每個字母對應的最大連續子字串長度  \n→ current_len = 0 // 目前相鄰字母連續長度  \n→ index = 0 // 用於遍歷 s  \n→ Decision: 如果 index < s.length? // 仍有字元可處理?  \n  Yes → current_char = s[index] // 取出目前字元  \n   → prev_char = (index > 0) ? s[index-1] : null // 前一個字元  \n   → Decision: 若 prev_char 且 (current_char 接續 prev_char?）  \n    Yes → current_len = current_len + 1 // 連續，長度加 1  \n     Decision: 若 current_len > dp[current_char]?  \n      Yes → dp[current_char] = current_len // 更新最大長度  \n      No → // 目前長度已經不大於已存最大，保持不變  \n    No → current_len = 1 // 不連續，重新開始長度  \n     Decision: 若 1 > dp[current_char]?  \n      Yes → dp[current_char] = 1 // 更新為 1  \n      No → // 既有更長子字串，保持不變  \n   → index = index + 1 // 移到下一個字元  \n   → Decision: index < s.length?  \n    Yes → 跳回上一決策  \n    No → // 所有字元已處理完  \n→ sum = 0 // 用於累加所有最大長度  \n→ For i = 0 to 25 // 遍歷所有字母  \n  → sum = sum + dp[i] // 累加當前字母的最大長度  \n→ Return sum // 回傳唯一子字串數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_wrap_substrings(s: str) -> int:\n    \"\"\"\n    Count the number of unique non‑empty substrings of `s` that appear in the\n    infinite wraparound string of the alphabet.\n    \"\"\"\n    # dp[i] stores the longest substring ending with the i‑th letter\n    dp = [0] * 26\n    current_len = 0\n\n    for i, ch in enumerate(s):\n        # Check if current character continues the alphabetic sequence\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            current_len += 1\n        else:\n            current_len = 1\n\n        idx = ord(ch) - ord('a')\n        if current_len > dp[idx]:\n            dp[idx] = current_len\n\n    return sum(dp)\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, process it, and output the result.\n    Accepts input in the form of a plain string or a line like\n    's = \"yourstring\"'.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to extract the string inside double quotes\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # If no quotes, take all alphabetic characters from the input\n        s = ''.join(filter(str.isalpha, data))\n\n    result = count_wrap_substrings(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. The task: given integer array nums and integer k, return true if there exist two distinct indices i and j such that nums[i] == nums[j] and abs(i - j) <= k. Essentially, check for duplicates within distance k. We must produce virtual code steps, using arrow notation. Must not output actual code. Just structure.\n\nWe need to include Start, End, Decision, Steps, arrow. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce lines such as: Start // 程式開始執行. → Step 1: 初始化空集合 visitedIndices? Actually we need to track last seen index of each number, so we can check distance <= k. Steps: Initialize hash map lastIndex. For each index i from 0 to len(nums)-1: get current number. If number in map, check difference: if i - lastIndex[number] <= k: return true. Else update map[number] = i. After loop, return false. We need to produce virtual steps: Step 1: Initialize hash map // map number to last seen index. Step 2: 循環遍歷 nums // for each index. Step 3: 檢查數字是否已存在 // if exists. Step 4: 判斷距離 <= k // if yes return true. Step 5: 更新索引 // set last index. Step 6: 完成遍歷後 return false.\n\nWe must include decisions and arrows. Use arrow for each step? Format: \"Start // ...\". Then \"→ Step 1: ... // ...\". But also we need to show decisions with indentation? The example shows Decision: If number > 0? Then Yes →, No →. For our algorithm, we have a Decision: if number in map? Yes → then Decision: if distance <= k? Yes → return true, No → update index. No → update index. After loop, return false.\n\nThus produce a structured flow. We'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 lastIndex // 用來記錄每個數字最近一次出現的索引\n→ Step 2: 循環遍歷 nums，索引 i // 逐個檢查數組中的元素\n    → Decision: nums[i] 是否已在 lastIndex? // 判斷該數字是否已出現\n        Yes → Decision: i - lastIndex[nums[i]] 是否 <= k? // 判斷距離是否在允許範圍\n            Yes → Step 3: 返回 true // 找到符合條件的重複元素\n            No  → Step 4: 更新 lastIndex[nums[i]] = i // 更新最近索引\n        No  → Step 5: 設定 lastIndex[nums[i]] = i // 第一次遇到該數字\n→ Step 6: 返回 false // 循環結束後未找到符合條件的元素\nEnd // 程式執行結束\n\nNeed to ensure each line contains a space between virtual code and comment. Use \"→\" arrow for each line, including inside decision branches. Must not output actual code, just description.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use Chinese.\n\nWill produce exactly as required.\n\nCheck format: Each line should be \"虛擬碼步驟 // 解釋\". For example \"Start // 程式開始執行\". Use arrow \"→\". For nested lines, we can indent with spaces but it's optional. The example shows indenting by spaces. We'll indent inside Decision branches.\n\nWe should include decision lines with \"Decision: ...\" and inside branches \"Yes → ...\" and \"No → ...\". Yes, use arrow for each branch. The decision lines themselves also start with arrow? In example, \"→ Decision: 如果數字大於 0? // 檢查數值是否為正\". Then indent branches: \"    Yes → Step 2: 輸出 '正數'\". So follow that.\n\nThus produce lines accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 lastIndex // 用來記錄每個數字最近一次出現的索引  \n→ Step 2: 循環遍歷 nums，索引 i // 逐個檢查數組中的元素  \n → Decision: nums[i] 是否已在 lastIndex? // 判斷該數字是否已出現  \n  Yes → Decision: i - lastIndex[nums[i]] 是否 <= k? // 判斷距離是否在允許範圍  \n   Yes → Step 3: 返回 true // 找到符合條件的重複元素  \n   No  → Step 4: 更新 lastIndex[nums[i]] = i // 更新最近索引  \n  No  → Step 5: 設定 lastIndex[nums[i]] = i // 第一次遇到該數字  \n→ Step 6: 返回 false // 循環結束後未找到符合條件的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and i - index_map[num] <= k:\n                return True\n            index_map[num] = i\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*([-\\d]+)', data)\n\n    if not nums_match or not k_match:\n        return\n\n    try:\n        nums = eval(nums_match.group(1))\n        k = int(k_match.group(1))\n    except Exception:\n        return\n\n    solution = Solution()\n    result = solution.containsNearbyDuplicate(nums, k)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the candies problem. Use standard algorithm: two-pass (left-to-right and right-to-left). Provide steps. Use Start, Decision, etc. Provide each line with explanation. Must be line-by-line, each line with virtual code step + comment.\n\nWe should produce steps like:\n\nStart // begin\n→ Input n, ratings // get number and array\n→ Initialize candies array with 1s // each child at least one candy\n→ For i from 1 to n-1: // left-to-right pass\n    Decision: ratings[i] > ratings[i-1]? // check higher rating\n        Yes → candies[i] = candies[i-1] + 1 // assign more candy\n        No  → candies[i] remains 1\n→ For i from n-2 downto 0: // right-to-left pass\n    Decision: ratings[i] > ratings[i+1]?\n        Yes → candies[i] = max(candies[i], candies[i+1]+1)\n        No  → unchanged\n→ Sum candies array // compute total\n→ Return total // output\n\nWe need to use virtual code style: e.g., \"→ Step 1: Input n, ratings\" and \"→ Decision: ratings[i] > ratings[i-1]?\" etc. We should not use actual code. Each line should have virtual step + comment. Must not output actual code. Just pseudo steps. Must be line-by-line.\n\nWe should maintain proper indenting? Example uses indentation. But each line we need to show indentation to indicate decision branches. We can use indent levels with spaces or maybe tabs. We'll just use spaces.\n\nAlso need to produce in Traditional Chinese. Use Chinese explanation. Use \"Start\", \"End\".\n\nLet's produce.\n\nEnsure each line has: virtual code step + space + comment. Use '→' arrow for steps. 'Decision:' for conditions. Use 'Yes →', 'No →'.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n 與 ratings 陣列 // 取得孩子數量與評分  \n→ Step 2: 建立 candies 陣列，所有元素初值為 1 // 每位孩子至少拿一顆糖  \n→ Step 3: 從左至右遍歷子陣列 (i = 1 到 n-1)  \n  Decision: ratings[i] > ratings[i-1] ? // 左邊孩子評分較低？  \n   Yes → candies[i] = candies[i-1] + 1 // 右邊孩子多拿一顆  \n   No  → candies[i] 保持 1 // 右邊孩子評分不高，保持原值  \n→ Step 4: 從右至左遍歷子陣列 (i = n-2 到 0)  \n  Decision: ratings[i] > ratings[i+1] ? // 右邊孩子評分較低？  \n   Yes → candies[i] = max(candies[i], candies[i+1] + 1) // 右邊多一顆，若更大則更新  \n   No  → candies[i] 保持目前值 // 右邊評分不高，保持原值  \n→ Step 5: 計算 candies 陣列所有元素之總和 total // 取得最少所需糖果數  \n→ Step 6: 回傳 total // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expect input like \"ratings = [1,0,2]\" or just \"[1,0,2]\"\n    if '=' in data:\n        _, value = data.split('=', 1)\n    else:\n        value = data\n\n    # Safely parse the list of ratings\n    ratings = ast.literal_eval(value.strip())\n\n    n = len(ratings)\n    candies = [1] * n\n\n    # Left to right pass\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    # Right to left pass\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    total = sum(candies)\n    print(total)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for shortest transformation sequence length, classic Word Ladder problem. Use BFS from beginWord, track levels. If endWord not in list return 0. Use set for wordList. For each word, generate all one-letter variants and if present, enqueue. Use visited set. Count steps. Output number of words in sequence: include beginWord and endWord, so steps = level+1.\n\nWe need to output line by line, each with virtual code and comment. Use Start, End, Decision etc. We must not output actual code, only virtual steps. We need to show steps like: Start, Step 1: If endWord not in wordList -> return 0. Step 2: Initialize queue with beginWord and level 1. Step 3: visited set. Step 4: BFS loop. Step 5: Dequeue word, level. Step 6: If word == endWord -> return level. Step 7: For each position i, for each letter 'a' to 'z', generate new word. Step 8: If new word in wordList and not visited -> enqueue newWord, level+1, mark visited. Step 9: End BFS. Step 10: Return 0.\n\nWe should use virtual arrows and Decision nodes.\n\nLet's produce. Use \"→\" to indicate next step. Use indentation for decisions. Use \"Yes →\", \"No →\".\n\nEnsure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 判斷 endWord 是否存在於 wordList // 若不存在則無法完成轉換  \n    Decision: endWord 於 wordList?  \n        Yes → Step 2: 建立 wordSet 為 wordList 的集合 // 方便 O(1) 查詢  \n        No  → Step 3: 回傳 0 // 無法到達目標單詞  \n→ Step 4: 建立 visited 集合並加入 beginWord // 防止重複訪問  \n→ Step 5: 建立 BFS 隊列並將 beginWord 與深度 1 入列 // 深度表示序列長度  \n→ Step 6: 開始 BFS 循環  \n    Decision: 隊列非空?  \n        Yes → Step 7: 取出目前 word 與其 depth  \n        No  → Step 8: 回傳 0 // 未找到目標，結束  \n→ Step 9: Decision: word 等於 endWord?  \n        Yes → Step 10: 回傳 depth // 找到最短序列長度  \n        No  → Step 11: 進行字母替換探索  \n→ Step 12: 迴圈 i 從 0 到 word.length-1  \n    → Step 13: 迴圈 c 從 'a' 到 'z'  \n        Decision: c 與 word[i] 不同?  \n            Yes → Step 14: 生成 newWord = 替換位置 i 為 c  \n            No  → Step 15: 跳過 // 避免自我替換  \n→ Step 16: Decision: newWord 於 wordSet 且未被 visited?  \n        Yes → Step 17: 將 newWord 與 depth+1 入列  \n        No  → Step 18: 跳過 // 不合法或已訪問  \n→ Step 19: 重複至 Step 12 結束  \n→ Step 20: 回傳 0 // 所有路徑探索完仍未到達 endWord  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 beginWord、endWord 與 wordList。\n    允許輸入格式類似:\n        beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\"]\n    \"\"\"\n    begin_match = re.search(r'beginWord\\s*=\\s*\"([^\"]+)\"', data)\n    end_match = re.search(r'endWord\\s*=\\s*\"([^\"]+)\"', data)\n    wl_match = re.search(r'wordList\\s*=\\s*\\[([^\\]]*)\\]', data)\n\n    beginWord = begin_match.group(1) if begin_match else \"\"\n    endWord = end_match.group(1) if end_match else \"\"\n\n    word_list_str = wl_match.group(1) if wl_match else \"\"\n    # 先把逗號分割，再去除多餘的空白和引號\n    wordList = [w.strip().strip('\"').strip(\"'\") for w in word_list_str.split(',') if w.strip()]\n    return beginWord, endWord, wordList\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        \"\"\"\n        使用 BFS 找到最短轉換序列長度。\n        若無法達到 endWord，回傳 0。\n        \"\"\"\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # (目前單字, 目前序列長度)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n\n            # 逐字生成所有可能的一字變化\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)          # 標記已訪問\n                        queue.append((new_word, length + 1))\n        return 0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    beginWord, endWord, wordList = parse_input(data)\n    sol = Solution()\n    result = sol.ladderLength(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Use Start, Decision, etc. Provide each line with explanation. Should be generic solution of Minimum Window Substring problem. Use sliding window, frequency map. Steps: build tCount map, initialize window count, left,right pointers, formed count, required unique char types, ans array. Iterate right pointer, update counts, check formed. Then shrink while formed==required. Update ans. At end if ans[0]==INF return \"\". Else return substring from ans[1] to ans[2]. Provide pseudo steps line by line. Ensure each line with // explanation. Use arrows. Let's create lines like:\n\nStart // 程式開始\n→ Step 1: 建立字典 tCount 記錄 t 中各字元及其需求數量 // 先計算 t 的頻率\n→ Step 2: 設定 required = tCount.size() // 需要滿足的獨特字元數\n→ Step 3: 初始化 left = 0, right = 0 // 窗口左右指標\n→ Step 4: 初始化 formed = 0 // 目前窗口已滿足的字元類別數\n→ Step 5: 初始化 windowCounts = 空字典 // 追蹤窗口內字元頻率\n→ Step 6: 初始化 ans = [∞, 0, 0] // 儲存最佳窗口長度與位置\n→ Decision: 右指標小於 s.length? // 開始滑動\n    Yes → Step 7: 取 s[right] 作為 char c // 右指標移動到新字元\n    → Step 8: 增加 windowCounts[c] // 更新窗口字元頻率\n    → Decision: windowCounts[c] 等於 tCount[c] ？ // 判斷是否滿足此字元需求\n        Yes → Step 9: formed++ // 這個字元類別已滿足\n        No  → No // 不變\n    → Step 10: right++ // 右指標往右移\n    → Decision: formed == required? // 檢查窗口是否滿足所有需求\n        Yes → Decision: 左指標 <= right? // 開始嘗試收縮\n            Yes → Step 11: 取 s[left] 作為 char leftChar // 左指標指向的字元\n            → Step 12: 若 ans[0] > right - left: // 若更小窗口\n                Yes → Step 13: ans = [right - left, left, right] // 更新最佳窗口\n                No  → No\n            → Step 14: windowCounts[leftChar]-- // 收縮窗口，減少左字元頻率\n            → Decision: windowCounts[leftChar] < tCount[leftChar]？ // 失去需求\n                Yes → Step 15: formed-- // 這個字元類別不再滿足\n                No  → No\n            → Step 16: left++ // 左指標往右移\n            → Decision: formed == required? // 仍滿足，繼續收縮\n                Yes → 回到上一步 Decision\n                No  → 回到外部 Decision\n        No  → 回到外部 Decision\n→ End // 迴圈結束\n\nAfter loop:\n→ Decision: ans[0] == ∞? // 是否找到合法窗口\n    Yes → Step 17: return \"\" // 沒有窗口\n    No  → Step 18: return s.substring(ans[1], ans[2]) // 返回最短窗口\n\nWe need to keep the lines in the exact format: each line with code + space + // explanation. Use arrows for steps. Use indentation for decisions maybe.\n\nMake sure to follow format example: \"Start // 程式開始執行\". Use \"→ Step ...\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 tCount 記錄 t 中各字元及其需求數量 // 先計算 t 的頻率  \n→ Step 2: 設定 required = tCount.size() // 需要滿足的獨特字元數  \n→ Step 3: 初始化 left = 0, right = 0 // 窗口左右指標  \n→ Step 4: 初始化 formed = 0 // 目前窗口已滿足的字元類別數  \n→ Step 5: 初始化 windowCounts = 空字典 // 追蹤窗口內字元頻率  \n→ Step 6: 初始化 ans = [∞, 0, 0] // 儲存最佳窗口長度與位置  \n\n→ Decision: right < s.length()？ // 開始滑動窗口  \n    Yes → Step 7: 取 s[right] 為字元 c // 右指標移動到新字元  \n    → Step 8: 增加 windowCounts[c] // 更新窗口字元頻率  \n    → Decision: windowCounts[c] == tCount[c]？ // 判斷此字元是否已滿足需求  \n        Yes → Step 9: formed++ // 這個字元類別已滿足  \n        No  → No // 不變  \n    → Step 10: right++ // 右指標往右移  \n    → Decision: formed == required？ // 檢查窗口是否滿足所有需求  \n        Yes → Decision: left <= right？ // 開始嘗試收縮窗口  \n            Yes → Step 11: 取 s[left] 為字元 leftChar // 左指標指向的字元  \n            → Step 12: 若 ans[0] > right - left { // 若找到更小窗口  \n                Yes → Step 13: ans = [right - left, left, right] // 更新最佳窗口  \n                No  → No  \n            }  \n            → Step 14: windowCounts[leftChar]-- // 收縮窗口，減少左字元頻率  \n            → Decision: windowCounts[leftChar] < tCount[leftChar]？ // 失去需求  \n                Yes → Step 15: formed-- // 這個字元類別不再滿足  \n                No  → No  \n            → Step 16: left++ // 左指標往右移  \n            → Decision: formed == required？ // 仍滿足，繼續收縮  \n                Yes → 回到上一步 Decision  \n                No  → 回到外部 Decision  \n        No  → 回到外部 Decision  \n→ End // 迴圈結束  \n\n→ Decision: ans[0] == ∞？ // 是否找到合法窗口  \n    Yes → Step 17: return \"\" // 沒有窗口  \n    No  → Step 18: return s.substring(ans[1], ans[2]) // 返回最短窗口\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l = r = 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None\n\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                l += 1\n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    s = t = \"\"\n    # Try to parse pattern like: s = \"string\", t = \"string\"\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*t\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        s, t = match.group(1), match.group(2)\n    else:\n        # Fallback: assume first line is s, second line is t\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            s, t = lines[0], lines[1]\n    sol = Solution()\n    result = sol.minWindow(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "BANC"
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for algorithm to compute minimum steps to make password strong. We should break into steps: count missing types, find repeats, calculate deletions/inserts/ replacements. Classic Leetcode 420. Steps: compute missing types = 3 - (has lower? + has upper? + has digit?). Count repeats groups of length >=3. For overlength >20: need deletions. Optimize deletions to reduce replacements needed by targeting repeats mod 3. After deletions, compute needed replacements for remaining repeats. Then if length<6: need insertions, max of missing types and insertions to reach 6. Finally answer = deletions + max(missingTypes, replacements) or insertions etc. Let's produce line-by-line pseudocode with explanations. Use Start, End, Decision, arrow.\n\nWe should not write actual code, but virtual steps. Each line with explanation. Ensure format. Let's write.\n\nWe'll need variables: n = length(password). missingTypes, repeats array, totalReplacements, deletionsNeeded. Steps: Count types. Then for each run of same char, compute len. If len>=3, add to repeats. Also categorize by len%3 for deletion strategy.\n\nIf n > 20: deletionsNeeded = n - 20. For each repeat group sorted by len%3 ascending, reduce length by deletions while reducing replacement count.\n\nThen compute replacements after deletions: sum over remaining repeat lengths: len/3.\n\nIf n < 6: insertionsNeeded = 6 - n. answer = max(missingTypes, replacements, insertionsNeeded)? Actually formula: if n<6, answer = max(missingTypes, 6-n, replacements). But replacements maybe need to be counted after insertions? Usually for short passwords, replacements don't help; we can replace within repeats; but insertions may fix length and reduce repeats. The known formula: if n < 6: return max(missingTypes, 6-n). But replacements for repeats not needed? Actually need to replace repeats to fix. But if length short, replacements still needed to remove repeats? For length <6, any repeats count to missing types? Wait typical algorithm: If n<6: we need at least (6-n) insertions. Each insertion can also fix a missing type or a repeat by inserting between duplicates. But min steps = max(missingTypes, 6-n). Because replacements to fix repeats may be counted as part of insertions? In known solution: For n<6, answer = max(missingTypes, 6-n). Because each insertion can address both length and missing types. Replacements not needed separately. Good.\n\nFor n between 6 and 20: answer = max(missingTypes, replacements). For n>20: answer = deletions + max(missingTypes, replacementsAfterDeletion).\n\nWe'll produce steps accordingly. Let's write pseudo code lines:\n\nStart\n→ Step: Let n ← length(password)\n→ Step: Initialize missing ← 3 // number of missing types\n→ Step: If password has lowercase: missing ← missing -1\n→ Step: If password has uppercase: missing ← missing -1\n→ Step: If password has digit: missing ← missing -1\n→ Step: Initialize repeats ← empty list // store lengths of each run >=3\n→ Step: Initialize i ← 0\n→ Decision: while i < n? // iterate over string\n    Yes → Step: j ← i\n    → Step: While j < n and password[j] == password[i] : j ← j +1\n    → Step: lenRun ← j - i\n    → Decision: if lenRun >=3?\n        Yes → Step: Append lenRun to repeats\n    → Step: i ← j\n→ Step: If n > 20:\n    → Step: deletionsNeeded ← n - 20\n    → Step: Sort repeats by lenRun % 3 ascending\n    → Step: For each len in repeats:\n        → Decision: while len >=3 and deletionsNeeded >0:\n            Yes → Step: len ← len -1\n            → Step: deletionsNeeded ← deletionsNeeded -1\n            → Decision: if len <3: remove from repeats\n    → Step: replacementsAfterDeletion ← sum over len/3 for each remaining len in repeats\n    → Step: answer ← (n - 20) + max(missing, replacementsAfterDeletion)\n→ Decision: else if n < 6:\n    → Step: insertionsNeeded ← 6 - n\n    → Step: answer ← max(missing, insertionsNeeded)\n→ Else:\n    → Step: replacementsNeeded ← sum over len/3 for each len in repeats\n    → Step: answer ← max(missing, replacementsNeeded)\n→ End // output answer\n\nWe need to provide explanation after each line. Use \"→\" arrow for steps. Provide explanation. Let's format accordingly. Ensure each line ends with comment. Use Start, End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Let n ← length(password) // 取得密碼長度  \n→ Step: Initialize missing ← 3 // 先假設三種類型都缺失  \n→ Decision: 如果 password 包含小寫字母? // 檢查小寫  \n    Yes → Step: missing ← missing - 1 // 小寫存在，缺失數減一  \n    No  → Step: // 仍缺小寫  \n→ Decision: 如果 password 包含大寫字母? // 檢查大寫  \n    Yes → Step: missing ← missing - 1 // 大寫存在，缺失數減一  \n    No  → Step: // 仍缺大寫  \n→ Decision: 如果 password 包含數字? // 檢查數字  \n    Yes → Step: missing ← missing - 1 // 數字存在，缺失數減一  \n    No  → Step: // 仍缺數字  \n→ Step: Initialize repeats ← empty list // 用於存放連續重複字元的長度  \n→ Step: Initialize i ← 0 // 從字符串首位開始  \n→ Decision: while i < n? // 逐段掃描密碼  \n    Yes → Step: j ← i  \n    → Step: while j < n and password[j] == password[i] : j ← j + 1 // 找到同一字元段尾  \n    → Step: lenRun ← j - i // 該段長度  \n    → Decision: if lenRun ≥ 3? // 需要處理的重複段  \n        Yes → Step: Append lenRun to repeats // 加入待處理列表  \n    → Step: i ← j // 移到下一段  \n→ Decision: if n > 20? // 密碼太長  \n    Yes → Step: deletionsNeeded ← n - 20 // 需要刪除的字符數  \n    → Step: Sort repeats by lenRun mod 3 ascending // 先處理 remainder 0、1、2 的段  \n    → Step: For each len in repeats:  \n        → Decision: while len ≥ 3 and deletionsNeeded > 0?  \n            Yes → Step: len ← len - 1 // 用一次刪除減少重複段長度  \n            → Step: deletionsNeeded ← deletionsNeeded - 1  \n            → Decision: if len < 3?  \n                Yes → Step: Remove len from repeats // 重複段已不足 3，移除  \n    → Step: replacementsAfterDeletion ← sum of (len // 3) for each remaining len in repeats // 需要的替換數  \n    → Step: answer ← (n - 20) + max(missing, replacementsAfterDeletion) // 刪除 + 後續最小操作  \n→ Decision: else if n < 6? // 密碼太短  \n    Yes → Step: insertionsNeeded ← 6 - n // 需要插入的字符數  \n    → Step: answer ← max(missing, insertionsNeeded) // 插入即可同時解決長度與類型缺失  \n→ Else // 6 ≤ n ≤ 20  \n    → Step: replacementsNeeded ← sum of (len // 3) for each len in repeats // 需要的替換數  \n    → Step: answer ← max(missing, replacementsNeeded) // 最小步驟為類型缺失與重複修正的較大值  \nEnd // 程式執行結束，輸出 answer 為最小步驟數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strongPasswordChecker(self, s: str) -> int:\n        n = len(s)\n        # check character types\n        has_lower = has_upper = has_digit = 0\n        for c in s:\n            if c.islower(): has_lower = 1\n            elif c.isupper(): has_upper = 1\n            elif c.isdigit(): has_digit = 1\n        missing_types = 3 - (has_lower + has_upper + has_digit)\n\n        # find repeating sequences and count replacements needed\n        replace = 0\n        one_mod = two_mod = 0\n        i = 2\n        while i < n:\n            if s[i] == s[i - 1] == s[i - 2]:\n                length = 2\n                while i < n and s[i] == s[i - 1]:\n                    length += 1\n                    i += 1\n                replace += length // 3\n                if length % 3 == 0:\n                    one_mod += 1\n                elif length % 3 == 1:\n                    two_mod += 1\n            else:\n                i += 1\n\n        # handle length constraints\n        if n < 6:\n            return max(6 - n, missing_types)\n        if n <= 20:\n            return max(replace, missing_types)\n\n        # n > 20: need deletions\n        delete = n - 20\n        # delete from groups with mod 0 first\n        reduce = min(delete, one_mod)\n        replace -= reduce\n        delete -= reduce\n\n        # delete from groups with mod 1 next\n        reduce = min(max(delete, 0), two_mod * 2) // 2\n        replace -= reduce\n        delete -= reduce * 2\n\n        # delete from remaining groups\n        replace -= max(delete, 0) // 3\n\n        return (n - 20) + max(missing_types, replace)\n\ndef extract_password(line: str) -> str:\n    \"\"\"Extract password string from input like 'password = \"a\"'.\"\"\"\n    match = re.search(r'\"([^\"]*)\"', line)\n    if match:\n        return match.group(1)\n    # fallback: split by = and strip quotes\n    if '=' in line:\n        part = line.split('=', 1)[1].strip()\n        return part.strip('\"').strip(\"'\")\n    return line.strip('\"').strip(\"'\")\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    password = extract_password(data)\n    sol = Solution()\n    result = sol.strongPasswordChecker(password)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode643.json",
    "problem_index_in_file": 0,
    "title": "Maximum Average Subarray I",
    "description_snippet": "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm: given array nums, integer k, find subarray of length k with max average. Typical sliding window. So virtual code lines: Start, Step: read input, compute sum of first k, set maxSum, iterate i from k to n-1, adjust sum, update maxSum, after loop compute maxAvg = maxSum / k, End.\n\nNeed each line virtual code step with explanation comment. Use arrow →, Decision. Keep structure.\n\nLet's produce lines. Each line includes virtual code and comment. Use Start, End. Use Step numbering maybe optional. Provide indentation for decision branches but simple.\n\nWe'll produce:\n\nStart // 開始\n\n→ Step 1: 讀取 nums 與 k // 取得輸入\n\n→ Step 2: 計算前 k 個元素總和 sum = Σ nums[0..k-1] // 初始窗口和\n\n→ Step 3: maxSum ← sum // 初始最大和\n\n→ Decision: 是否還有剩餘元素? // 檢查是否需要滑動窗口\n    Yes → Step 4: for i from k to nums.length-1\n        → Step 5: sum ← sum - nums[i-k] + nums[i] // 移除左邊元素並加入右邊元素\n        → Step 6: if sum > maxSum then maxSum ← sum // 更新最大和\n    No  → // 無剩餘元素\n→ Step 7: maxAvg ← maxSum / k // 轉換為平均值\n→ Step 8: 輸出 maxAvg // 回傳結果\nEnd // 結束\n\nBut the format requires each line with virtual code and comment. For loop we need separate lines. But we can combine but each line separate. For decision branch, indent. Need to use \"→ Decision:\" etc. Use Yes → Step ... No →.\n\nLet's write lines accordingly. Ensure each line ends with comment. Also include arrow for decision. For for loop, we can embed step within. But requirement: each line must have \"虛擬碼步驟\" and comment. So we need each line separately. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 nums 與 k // 取得輸入陣列與子陣列長度\n→ Step 2: sum ← 0 // 初始化滑動窗口總和\n→ Step 3: for i from 0 to k-1 do sum ← sum + nums[i] // 計算前 k 個元素的總和\n→ Step 4: maxSum ← sum // 設定初始最大和\n→ Decision: 是否有剩餘元素? // 檢查是否需要滑動窗口\n    Yes → Step 5: for i from k to nums.length-1 do\n        → Step 6: sum ← sum - nums[i-k] + nums[i] // 移除最左元素並加入新元素\n        → Step 7: if sum > maxSum then maxSum ← sum // 若新窗口和更大則更新\n    No  → // 無剩餘元素，直接跳過\n→ Step 8: maxAvg ← maxSum / k // 計算最大平均值\n→ Step 9: 輸出 maxAvg // 回傳結果\nEnd // 程式執行結束\n\nNeed to ensure each line has \"→\" except Start and End. For loops and decisions, use indent lines. Ensure no real code. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 nums 與 k // 取得輸入陣列與子陣列長度  \n→ Step 2: sum ← 0 // 初始化滑動窗口總和  \n→ Step 3: for i from 0 to k-1 do sum ← sum + nums[i] // 計算前 k 個元素的總和  \n→ Step 4: maxSum ← sum // 設定初始最大和  \n→ Decision: 是否有剩餘元素? // 檢查是否需要滑動窗口  \n Yes → Step 5: for i from k to nums.length-1 do  \n  → Step 6: sum ← sum - nums[i-k] + nums[i] // 移除最左元素並加入新元素  \n  → Step 7: if sum > maxSum then maxSum ← sum // 若新窗口和更大則更新  \n No  → // 無剩餘元素，直接跳過  \n→ Step 8: maxAvg ← maxSum / k // 計算最大平均值  \n→ Step 9: 輸出 maxAvg // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_max_average(nums, k):\n    \"\"\"計算長度為 k 的子陣列中平均值的最大值。\"\"\"\n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i - k]  # 滑動窗口\n        if window_sum > max_sum:\n            max_sum = window_sum\n    return max_sum / k\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中提取 nums 列表與 k 整數。\n    例：'nums = [1,12,-5,-6,50,3], k = 4'\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*([-\\d]+)', data)\n    if not nums_match or not k_match:\n        raise ValueError(\"輸入格式錯誤，無法解析 nums 或 k\")\n    nums_str = nums_match.group(1)\n    k_str = k_match.group(1)\n    nums = ast.literal_eval(nums_str)   # 安全解析列表\n    k = int(k_str)\n    return nums, k\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    result = find_max_average(nums, k)\n    # 以 5 位小數輸出\n    print(f\"{result:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,12,-5,-6,50,3], k = 4",
          "expected_output": "12.75000",
          "success": true,
          "output": "12.75000"
        },
        {
          "example_index": 1,
          "input": "nums = [5], k = 1",
          "expected_output": "5.00000",
          "success": true,
          "output": "5.00000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for the problem: \"Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.\" So basically digital root problem. Need to produce virtual code line by line with explanation, using Start, End, Decision, Yes/No arrows. Each line: virtual step + space + // explanation. No actual code.\n\nWe need to produce a structured flowchart in text. Use virtual code arrow →, Decision: etc. Provide each step.\n\nLet's outline:\n\nStart\n\n→ Step 1: Initialize result = num // set current result\n\n→ Decision: If result has only one digit? // check if result < 10\n\n    Yes → Step 2: Return result // output the single digit\n\n    No → Step 3: Compute sum of digits of result → result = sum of digits // compute new result\n\n        → Step 4: Go back to Decision // loop\n\nEnd\n\nWe need to ensure each line has explanation.\n\nLet's produce with proper indentation.\n\nWe may need to show loops: we can use \"Repeat\" step or go back arrow. But format: we can use \"→\" lines.\n\nUse \"→ Step X\" etc. Use \"Decision:\".\n\nAlso we need \"Repeat\" maybe. But can just go back to decision.\n\nWe should also include step to convert result to string or digit extraction? But we can mention \"Compute sum of digits\".\n\nWe'll produce:\n\nStart // 程式開始\n\n→ Step 1: result = num // 將輸入的整數存入 result\n\n→ Decision: result < 10? // 檢查 result 是否已是單一位數\n\n    Yes → Step 2: Return result // 如果是單位數，直接回傳\n\n    No  → Step 3: result = sum of digits of result // 若不是，計算各位數字之和\n\n        → Step 4: Go back to Decision // 重新檢查新的 result\n\nEnd // 程式結束\n\nBut we need to show arrow back: use \"→\" back to decision. For clarity we can use \"→ Decision: ...\". The \"Go back\" line should go back.\n\nWe'll produce like:\n\n→ Step 3: result = sum of digits of result // 計算數字各位之和\n\n→ Step 4: 再次檢查 result 是否為單一位數 // 迴圈回到 Decision\n\nBut better to use:\n\n→ Step 3: result = sum of digits of result // 計算各位數字之和\n\n    → Step 4: Go back to Decision // 迴圈\n\nBut formatting: each line separate. The indentation for nested actions. Provide explanation.\n\nOk. We'll output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = num // 將輸入的整數存入 result  \n→ Decision: result < 10? // 檢查 result 是否已是單一位數  \n  Yes → Step 2: Return result // 如果是單一位數，直接回傳  \n  No  → Step 3: result = sum of digits of result // 若不是，計算各位數字之和  \n   → Step 4: Go back to Decision // 重新檢查新的 result  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addDigits(self, num: int) -> int:\n        \"\"\"Repeatedly sum the digits of num until it becomes a single digit.\"\"\"\n        while num >= 10:\n            num = sum(int(d) for d in str(num))\n        return num\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return  # No integer found; nothing to output\n    num = int(numbers[0])\n    # Compute the digital root\n    result = Solution().addDigits(num)\n    # Output the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode696.json",
    "problem_index_in_file": 0,
    "title": "Count Binary Substrings",
    "description_snippet": "Given a binary string s, return the number of non-empty substrings that have the same number of 0's ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm. Problem: count substrings with equal number of 0s and 1s and grouped consecutively. Standard approach: count consecutive groups of same character; the answer is sum over min(len_i, len_{i+1}) for consecutive groups. We need to produce virtual code steps, not actual code, but steps. Use Start, End, Decision, etc. Each line with explanation. Should produce algorithm steps: iterate string, count group lengths in list; then iterate adjacent pairs, sum min; output. Also handle multiple substrings: each pair of groups yields min length. Provide virtual code lines accordingly.\n\nWe must produce each line of virtual code and explanation. Use arrow for each step. Should be in Chinese. Use virtual arrows: →, Yes →, No →. Should produce stepwise. Let's craft.\n\nLine1: Start // program start\n\nLine2: → Step 1: 初始化空列表 group_lengths // 用來存儲連續相同字符的長度\n\nLine3: → Step 2: 設置指標 i = 0 // 索引遍歷字串\n\nLine4: → Decision: i < s.length? // 是否還有字符未處理\n\nLine5: Yes → Step 3: 讀取當前字符 cur = s[i] // 紀錄目前字符\n\nLine6: → Step 4: 設置計數 count = 0 // 為當前組計數\n\nLine7: → Decision: i < s.length AND s[i] == cur? // 繼續計算同組字符\n\nLine8: Yes → Step 5: count++ ; i++ // 計數加1，移動索引\n\nLine9: No  → Step 6: group_lengths.add(count) // 組計完，加入列表\n\nLine10: → Decision: i < s.length? // 是否還有字符待處理\n\nLine11: Yes → 回到 Step 3 // 重新開始下一組\n\nLine12: No  → Step 7: 檢查是否至少兩組 // 若 group_lengths size >=2\n\nLine13: Decision: group_lengths.size < 2? // 判斷是否足夠計算\n\nLine14: Yes → Step 8: return 0 // 沒有足夠組，返回 0\n\nLine15: No  → Step 9: 初始化結果 count_substrings = 0 // 結果累加\n\nLine16: → Step 10: 迭代索引 j from 0 to group_lengths.size-2 // 逐對相鄰組\n\nLine17: → Step 11: result += min(group_lengths[j], group_lengths[j+1]) // 加入最小長度\n\nLine18: → Step 12: return count_substrings // 返回總數\n\nLine19: End // 程式結束\n\nWe also need to include decision lines properly formatted: \"Decision: ...\". We need to use Yes →, No → arrows for decision branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 group_lengths // 用來存儲連續相同字符的長度  \n→ Step 2: 設置指標 i = 0 // 索引遍歷字串  \n→ Decision: i < s.length? // 是否還有字符未處理  \n&nbsp;&nbsp;Yes → Step 3: 讀取當前字符 cur = s[i] // 紀錄目前字符  \n&nbsp;&nbsp;→ Step 4: 設置計數 count = 0 // 為當前組計數  \n&nbsp;&nbsp;→ Decision: i < s.length AND s[i] == cur? // 繼續計算同組字符  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: count++ ; i++ // 計數加1，移動索引  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: group_lengths.add(count) // 組計完，加入列表  \n&nbsp;&nbsp;→ Decision: i < s.length? // 是否還有字符待處理  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → 回到 Step 3 // 重新開始下一組  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: 檢查是否至少兩組 // 若 group_lengths size >=2  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: group_lengths.size < 2? // 判斷是否足夠計算  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: return 0 // 沒有足夠組，返回 0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: 初始化結果 count_substrings = 0 // 結果累加  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: 迭代索引 j from 0 to group_lengths.size-2 // 逐對相鄰組  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 11: count_substrings += min(group_lengths[j], group_lengths[j+1]) // 加入最小長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 12: return count_substrings // 返回總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def countBinarySubstrings(self, s: str) -> int:\n        groups = []\n        count = 1\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                count += 1\n            else:\n                groups.append(count)\n                count = 1\n        groups.append(count)\n\n        result = 0\n        for i in range(1, len(groups)):\n            result += min(groups[i], groups[i-1])\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取輸入，去除可能的首尾空白與引號\n    raw_input = sys.stdin.read().strip()\n    if raw_input and raw_input[0] in (\"'\", '\"') and raw_input[-1] == raw_input[0]:\n        s = raw_input[1:-1]\n    else:\n        s = raw_input\n\n    solution = Solution()\n    print(solution.countBinarySubstrings(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"00110011\"",
          "expected_output": "6",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "s = \"10101\"",
          "expected_output": "4",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '10'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '10'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation. Not actual code. Virtual code steps using arrows and decisions.\n\nWe need to handle algorithm for isomorphic strings. Approach: if lengths differ, false. Use two dictionaries mapping char to char. Iterate over pairs of characters. Check mapping consistency.\n\nWe should produce step-by-step pseudocode with decisions. Use \"Start\", \"End\". Use \"Decision:\" lines.\n\nEach line: \"虛擬碼步驟 // 解釋\"\n\nWe'll output lines.\n\nLet's craft:\n\nStart\n→ Step 1: Receive strings s, t // Input\n→ Decision: if length(s) ≠ length(t)? // Check lengths\n    Yes → Step 2: Return False // Length mismatch\n    No  → Step 3: Initialize mapS, mapT // Maps\n→ Step 4: For each index i from 0 to length(s)-1 // Iterate\n    → Step 4a: Let c = s[i], d = t[i] // Current chars\n    → Decision: if c in mapS? // Check mapping for s char\n        Yes → Decision: mapS[c] ≠ d? // Consistency\n            Yes → Step 5: Return False\n            No  → Step 6: Continue\n        No  → Decision: d in mapT? // Check target already mapped\n            Yes → Step 7: Return False\n            No  → Step 8: mapS[c] = d; mapT[d] = c // Create mapping\n→ Step 9: Return True // All ok\nEnd\n\nBut we need each line separated. For loops we need to indicate start of loop. Use \"Loop\" maybe. Use arrow. Provide explanation.\n\nLet's output as:\n\nStart // 程式開始執行\n→ Step 1: 取得字串 s、t // 取得輸入\n→ Decision: s.length ≠ t.length? // 長度不相等\n    Yes → Step 2: 回傳 False // 長度不等即非同構\n    No  → Step 3: 建立 mapS、mapT // 分別儲存映射\n→ Step 4: 針對 i 從 0 到 s.length-1 迴圈 // 遍歷每個字符\n    → Step 4a: c ← s[i] ; d ← t[i] // 取得對應字符\n    → Decision: c 已存在於 mapS? // s 字符已有映射\n        Yes → Decision: mapS[c] ≠ d? // 映射是否一致\n            Yes → Step 5: 回傳 False // 不一致則非同構\n            No  → Step 6: 迴圈繼續 // 符合則繼續\n        No  → Decision: d 已存在於 mapT? // t 字符已被映射\n            Yes → Step 7: 回傳 False // 兩字符映射到同一個\n            No  → Step 8: mapS[c] ← d ; mapT[d] ← c // 建立雙向映射\n→ Step 9: 回傳 True // 所有檢查通過\nEnd // 程式結束\n\nBut we need to maintain virtual code arrows properly. Format each line with \"→\". For nested decisions we indent. Use \"Yes →\" and \"No →\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 取得字串 s、t // 取得輸入\n→ Decision: s.length ≠ t.length? // 長度不相等\n    Yes → Step 2: 回傳 False // 長度不等即非同構\n    No  → Step 3: 建立 mapS、mapT // 分別儲存映射\n→ Step 4: 針對 i 從 0 到 s.length-1 迴圈 // 遍歷每個字符\n    → Step 4a: c ← s[i] ; d ← t[i] // 取得對應字符\n    → Decision: c 已存在於 mapS? // s 字符已有映射\n        Yes → Decision: mapS[c] ≠ d? // 映射是否一致\n            Yes → Step 5: 回傳 False // 不一致則非同構\n            No  → Step 6: 迴圈繼續 // 符合則繼續\n        No  → Decision: d 已存在於 mapT? // t 字符已被映射\n            Yes → Step 7: 回傳 False // 兩字符映射到同一個\n            No  → Step 8: mapS[c] ← d ; mapT[d] ← c // 建立雙向映射\n→ Step 9: 回傳 True // 所有檢查通過\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        map_s_t = {}\n        map_t_s = {}\n        for c1, c2 in zip(s, t):\n            if c1 in map_s_t and map_s_t[c1] != c2:\n                return False\n            if c2 in map_t_s and map_t_s[c2] != c1:\n                return False\n            map_s_t[c1] = c2\n            map_t_s[c2] = c1\n        return True\n\ndef parse_input(data: str):\n    # Try to extract strings inside double quotes\n    matches = re.findall(r'\"(.*?)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # Fallback: split by whitespace\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    raise ValueError(\"Invalid input format\")\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    s, t = parse_input(data)\n    sol = Solution()\n    result = sol.isIsomorphic(s, t)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. No real code. Use Start, End, Decision, etc. For FizzBuzz. Provide steps. Provide explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立答案陣列 answer，長度為 n + 1 // 用於儲存 1 到 n 的結果，索引 0 處不使用  \n→ Step 2: 將 i 從 1 到 n 進行迭代 // 循環遍歷每個整數  \n  → Decision: i 是否同時被 3 與 5 整除? // 檢查是否滿足 FizzBuzz 條件  \n   Yes → Step 3: answer[i] = \"FizzBuzz\" // 同時可被 3 和 5 整除，設定為 \"FizzBuzz\"  \n   No  → Decision: i 是否被 3 整除? // 若不是 FizzBuzz，則檢查是否只能被 3 整除  \n    Yes → Step 4: answer[i] = \"Fizz\" // 只被 3 整除，設定為 \"Fizz\"  \n    No  → Decision: i 是否被 5 整除? // 若不是 Fizz，也不是 FizzBuzz，則檢查是否只能被 5 整除  \n     Yes → Step 5: answer[i] = \"Buzz\" // 只被 5 整除，設定為 \"Buzz\"  \n     No  → Step 6: answer[i] = i.toString() // 以上條件都不符合，轉為字串存入答案  \n→ Step 7: 回傳 answer 陣列 // 完成所有填寫後返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def fizzBuzz(self, n: int):\n        \"\"\"Return FizzBuzz list for numbers 1..n.\"\"\"\n        result = []\n        for i in range(1, n + 1):\n            if i % 15 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract first integer from the input (handles \"n = 5\" or just \"5\")\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        raise ValueError(\"Input must contain an integer.\")\n    n = int(match.group())\n    sol = Solution()\n    answer = sol.fizzBuzz(n)\n    # Print as a JSON array to match the expected format\n    print(json.dumps(answer))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\"]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps line by line with explanations. Virtual code, not actual code. Use Start, End, Decision, arrow. The requirement: use Chinese, specifically Traditional Chinese. Provide explanation after space. Each line has \"虛擬碼步驟\" then a space then \"// 解釋/說明\". Must use arrow symbols. We need to produce algorithm for evaluating RPN using stack. Steps: Start, iterate through tokens, if token is operator do pop two, compute, push result. Finally return stack top. Use Decision to check token type. Also we need division truncating toward zero. Need to handle sign. We'll include explanation about truncation. Use integer division. Also handle negative numbers. Use stack. Use push/pop. Provide End.\n\nLet's craft step-by-step:\n\nStart\n→ Iterate over each token in tokens // loop through input\n    → Decision: 是否為運算子? // check if token is one of '+', '-', '*', '/'\n        Yes → Step: Pop second operand (b) from stack // second popped value\n        → Step: Pop first operand (a) from stack // first popped value\n        → Step: 计算 a op b // perform operation\n        → Step: Push 结果到栈 // push result\n        No  → Step: 将 token 转换为整数并推入栈 // push operand\nAfter loop\n→ Step: 取栈顶值作为结果 // final result\nEnd\n\nNeed to include division truncation. So step computing division should mention truncating toward zero. Provide explicit step.\n\nAlso we might use Decision for division operator to handle truncation, but we can just compute using integer division. Might include step.\n\nAlso we need to use \"Decision:\" properly indent. The example uses indentation. We should indent sub-steps under Decision. Provide the arrow lines under Decision. Use \"Yes →\", \"No →\" etc. Provide comments.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Iterate over each token in tokens // 逐一處理反向波斯式表達式中的每個項目  \n    → Decision: token 是否為運算子? // 判斷目前項目是算術運算符還是數值  \n        Yes → Step: Pop second operand (b) from stack // 從堆疊取出右側操作數  \n        → Step: Pop first operand (a) from stack // 取出左側操作數  \n        → Step: 依 token 執行 a op b // 根據 '+', '-', '*', '/' 執行相應計算  \n            → Decision: token 是 '/'? // 需要特殊處理除法截斷  \n                Yes → Step: result = trunc(a / b) towards zero // 除法結果向 0 截斷  \n                No → Step: result = a op b // 其他運算直接計算  \n        → Step: Push result onto stack // 將計算結果重新推入堆疊  \n        No → Step: Convert token to integer and push onto stack // 數值直接入堆疊  \n→ Step: result = top of stack // 堆疊頂端即為最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:  # token == '/'\n                    # 除法結果向 0 截斷\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 期望輸入格式為 tokens = [\"...\"]\n    parts = data.split('=', 1)\n    expr = parts[1].strip() if len(parts) == 2 else data\n    tokens = ast.literal_eval(expr)\n    result = Solution().evalRPN(tokens)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets (power set) from an array that may contain duplicates. We need to avoid duplicate subsets. Typical approach: sort array, then use backtracking, skip duplicates when building subsets by only including the first occurrence or using condition skip if nums[i]==nums[i-1] and not used before.\n\nWe need to produce step-by-step virtual code with arrows. Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Must not output actual code. Should include steps: sort array, define result, define backtrack function, call backtrack, return result.\n\nEach line must be preceded by arrow? Format: \"Start // 程式開始執行\". Then \"→ Step 1: ...\". Then Decision: \"Decision: ...\". Inside, indent with Yes →, No →.\n\nWe need to produce all steps for backtracking: choose element, add to current subset, recursive call with next index, after recursion, remove element (backtrack), loop continues. Also skip duplicates: In loop, if i>start and nums[i]==nums[i-1] then skip.\n\nWe must include a step to copy current subset to result. We'll produce generic steps.\n\nWe need to ensure each line includes // explanation. Use Chinese explanations.\n\nWe must not output actual code. Only the structure with \"Step X: ...\".\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者或函式參數取得數字陣列\n→ Step 2: 將 nums 依升序排序 // 方便後續去重\n→ Step 3: 建立空陣列 result // 用來存所有子集\n→ Step 4: 定義遞迴函式 backtrack(start, current) // backtrack 會從 start 開始選取元素\n→ Decision: 是否已達到陣列結束？ // 判斷是否已遍歷完所有元素\n    Yes → Step 5: 把 current 複製到 result // 目前選取的子集加入結果\n    No  → Decision: 迴圈遍歷 index i 從 start 到 nums.length-1 // 為每個位置嘗試加入子集\n        → Step 6: 判斷 i>start 且 nums[i]==nums[i-1]？ // 判斷是否為重複元素\n            Yes → Step 7: 跳過此 i // 避免重複子集\n            No  → Step 8: 把 nums[i] 加入 current // 選取此元素\n                → Step 9: backtrack(i+1, current) // 進一步遞迴選取後續元素\n                → Step 10: 移除 current 最後一個元素 // 回溯\n→ End // 程式執行結束\n\nBut we need to structure with arrows. The decision for \"是否已達到陣列結束\" might not be necessary because we add current to result regardless. The typical algorithm: at each call, add current to result. Then loop over i from start to n-1: skip duplicates, choose element, recursion, backtrack.\n\nThus we can simplify: start function; add current to result; for loop. Provide steps accordingly.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者或函式參數取得數字陣列\n→ Step 2: 將 nums 依升序排序 // 方便後續去重\n→ Step 3: 建立空陣列 result // 用來存所有子集\n→ Step 4: 定義遞迴函式 backtrack(start, current) // 回傳所有子集\n→ Decision: 執行 backtrack(0, 空陣列) // 開始遞迴\nEnd\n\nBut we need inside backtrack function: add current to result, loop, skip duplicates, choose element, recursion, backtrack. So we need to detail steps inside.\n\nWe might structure as:\n\nStep 4: 定義遞迴函式 backtrack(start, current) // 定義回傳子集的遞迴\n    → Step 4.1: 把 current 複製到 result // 每次呼叫都把目前子集加入結果\n    → Step 4.2: 迴圈 i 從 start 到 nums.length-1 // 為每個位置嘗試加入子集\n        → Decision: i>start 且 nums[i]==nums[i-1]？ // 判斷是否為重複元素\n            Yes → Step 4.3: 跳過此 i // 避免重複子集\n            No  → Step 4.4: 把 nums[i] 加入 current // 選取此元素\n                → Step 4.5: backtrack(i+1, current) // 進一步遞迴\n                → Step 4.6: 移除 current 最後一個元素 // 回溯\n\nThen after defining backtrack, we call it.\n\nThus final output lines with arrow and explanation.\n\nBe careful: each line needs to have \"虛擬碼步驟\" and // explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者或函式參數取得數字陣列  \n→ Step 2: 將 nums 依升序排序 // 方便後續去除重複子集  \n→ Step 3: 建立空陣列 result // 用來存所有子集  \n→ Step 4: 定義遞迴函式 backtrack(start, current) // 回傳所有子集  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.1: 把 current 複製到 result // 每次呼叫都把目前子集加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.2: 迴圈 i 從 start 到 nums.length-1 // 為每個位置嘗試加入子集  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: i>start 且 nums[i]==nums[i-1]? // 判斷是否為重複元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4.3: 跳過此 i // 避免產生重複子集  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4.4: 把 nums[i] 加入 current // 選取此元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.5: backtrack(i+1, current) // 進一步遞迴選取後續元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4.6: 移除 current 最後一個元素 // 回溯至上一層  \n→ Decision: 執行 backtrack(0, 空陣列) // 開始遞迴以產生所有子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        res = [[]]\n        for num in nums:\n            new_subsets = []\n            for subset in res:\n                new_subsets.append(subset + [num])\n            res += new_subsets\n        unique_res = []\n        seen = set()\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n        return unique_res\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中抽取整數列表.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 找到第一個 '[' 與最後一個 ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n    return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[], [0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for adding two big integers represented as strings, no big integer library, no converting to integer. Use string manipulation: iterate from end, add digits with carry. Provide step-by-step virtual code with explanation per line. Use Start, End, Decision, etc. Must be in Traditional Chinese. Provide lines of virtual code.\n\nWe need to ensure we cover input reading, initialize result string builder, loop through indices, digit conversion char->int, sum with carry, produce new digit char, etc. At end reverse or build backwards. We can build result by appending to front or building in list then reverse. Use decision for carry at each step, and at end if carry remains add to front. Use loop for i and j. Provide step by step.\n\nLet's craft.\n\nWe need to output each line as: \"虛擬碼步驟 // 解釋\". Use arrow characters. Example: \"→ Step 1: ...\". Use Decision lines.\n\nLet's produce.\n\nWe must start with Start, End. Use arrows for next steps. For loops we might express as Decision: \"i>=0 or j>=0?\" with Yes/No.\n\nLet's produce about maybe 25 lines.\n\nLet's craft.\n\nNeed to mention we don't convert entire string to int, only char to digit via subtract '0'.\n\nAlso, we must use string builder like List<char> to store result digits in reverse then at end reverse.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 i ← length(num1) - 1 // 指向 num1 的最後一位  \n→ Step 2: 設定 j ← length(num2) - 1 // 指向 num2 的最後一位  \n→ Step 3: 設定 carry ← 0 // 初始化進位  \n→ Step 4: 建立空列表 resultDigits // 用於暫存反向結果  \n→ Decision: i >= 0 或 j >= 0? // 檢查是否還有剩餘位數  \n Yes → Step 5: 取 digit1 ← (i >= 0) ? (num1[i] - '0') : 0 // 若有剩餘位取對應數字，否則為 0  \n     取 digit2 ← (j >= 0) ? (num2[j] - '0') : 0 // 同理對 num2  \n     設定 sum ← digit1 + digit2 + carry // 計算當前位的總和  \n     設定 carry ← sum / 10 // 更新進位  \n     設定 newDigit ← sum % 10 // 當前位實際數字  \n     附加 newDigit 為字元到 resultDigits // 暫存反向結果  \n     取 i ← i - 1 // 移動到前一位  \n     取 j ← j - 1 // 移動到前一位  \n     重新進入 Decision  \n No  → Decision: carry > 0? // 檢查最後是否還有進位  \n  Yes → Step 6: 附加 carry 為字元到 resultDigits // 加入最後進位  \n     取 carry ← 0 // 清除進位  \n     重新進入 Decision  \n  No  → Step 7: 反轉 resultDigits 並轉為字串 // 將反向結果正向  \n     取 output ← join(resultDigits) // 生成最終字串  \n→ End // 程式執行結束，output 為兩個大整數相加的結果字符串。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # 尝试在输入中提取双引号中的数字字符串\n    nums = re.findall(r'\"([^\"]*)\"', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # 如果没有双引号，直接按空格或换行分割\n        parts = re.split(r'[\\s,]+', data)\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            # 仅剩一个数，另一个默认为 \"0\"\n            num1 = parts[0] if parts else \"0\"\n            num2 = \"0\"\n\n    result = Solution().addStrings(num1, num2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": true,
          "output": "134"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": true,
          "output": "533"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that given n and k returns kth lexicographically smallest integer in [1, n]. This is a known problem: lexicographic order traversal on a number tree, counting how many numbers under a prefix. The algorithm: start with current=1, count numbers between current and current+1. While k>1: count = countSteps(current, current+1, n). If count < k: k -= count; current +=1; else: current*=10; k -=1; end. Return current. Steps explanation. We need to output lines with arrows. Each line with // explanation. Use structure: Start, Decision. We need virtual code, not actual code. Use step names like \"Step: 计算范围内的数目\". Use decision \"如果 count < k?\" etc.\n\nWe need to output sequential lines. Let's design:\n\nStart\n→ Step 1: Initialize current = 1, k = k // Setup variables\n→ Step 2: While k > 1 // Main loop\n    → Decision: 计算在 prefix current 下的数目 count = countSteps(current, current+1, n) // 计算范围\n        Yes → Decision: 如果 count < k? // 判断是否跳过\n            Yes → Step 3: k = k - count // 减去已跳过的数\n                 → Step 4: current = current + 1 // 移到下一个兄弟节点\n            No  → Step 5: k = k - 1 // 减去当前节点本身\n                 → Step 6: current = current * 10 // 进入子节点\n→ Step 7: Return current // kth number found\nEnd\n\nBut we need to keep the format: each line with arrow arrow? We can represent nested with indentations. The example shows nested decisions with indentations. Use \"→\" for steps, and \"Decision:\" with indentation. Use \"Yes →\" and \"No →\". Provide explanation after //.\n\nWe need to include countSteps function? Might define as separate step: \"Step: 计算 countSteps\". But we can incorporate it inside decision explanation. Could also add separate step for function definition.\n\nLet's produce final virtual code.\n\nMake sure each line ends with // explanation. Use \"虛擬碼步驟\" then space then // explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: current = 1, k = k // 初始化起始指標和目標索引\n→ Step 2: while k > 1 // 進入主循環，直到找到第 k 個\n    → Decision: count = countSteps(current, current + 1, n) // 計算以 current 為前綴的所有數字個數\n        Yes → Decision: 如果 count < k? // 判斷是否跳過整個前綴區塊\n            Yes → Step 3: k = k - count // 先減去跳過的數量\n                 → Step 4: current = current + 1 // 移動到同一層的下一個兄弟節點\n            No  → Step 5: k = k - 1 // 减去当前节点本身\n                 → Step 6: current = current * 10 // 进入下一层子节点\n→ Step 7: return current // 返回第 k 个字典序数字\nEnd // 程式執行結束\n\nWe need to ensure \"Decision:\" line starts with \"Decision:\" not \"Decision:\". Also include indent.\n\nBut the example: \n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2...\n    No → Decision: ...\n\nSo we must mimic that. Use the same indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: current = 1, k = k // 初始化起始指標 current 與目標索引 k  \n→ Step 2: while k > 1 // 進入主循環，直到找到第 k 個  \n  → Decision: count = countSteps(current, current + 1, n) // 計算以 current 為前綴的所有數字個數  \n   Yes → Decision: 如果 count < k? // 判斷是否跳過整個前綴區塊  \n     Yes → Step 3: k = k - count // 先減去跳過的數量  \n      → Step 4: current = current + 1 // 移動到同一層的下一個兄弟節點  \n     No  → Step 5: k = k - 1 // 减去当前节点本身  \n      → Step 6: current = current * 10 // 進入下一層子節點  \n→ Step 7: return current // 返回第 k 個字典序數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_kth_number(n: int, k: int) -> int:\n    \"\"\"Return the k-th lexicographically smallest integer in [1, n].\"\"\"\n    def count_prefix(prefix: int, n: int) -> int:\n        \"\"\"Count how many numbers in [1, n] start with the given prefix.\"\"\"\n        cur, nxt = prefix, prefix + 1\n        cnt = 0\n        while cur <= n:\n            cnt += min(n + 1, nxt) - cur\n            cur *= 10\n            nxt *= 10\n        return cnt\n\n    current = 1\n    k -= 1                     # reduce because we start counting from 1\n    while k > 0:\n        cnt = count_prefix(current, n)\n        if k >= cnt:\n            # skip the whole block under this prefix\n            k -= cnt\n            current += 1\n        else:\n            # go deeper into the next level of this prefix\n            k -= 1\n            current *= 10\n    return current\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all integers from the input, regardless of formatting\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) >= 2:\n        n, k = numbers[0], numbers[1]\n        result = find_kth_number(n, k)\n        print(result)\n    else:\n        # If the input format is unexpected, do nothing\n        pass",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode steps for solving combination sum II: given array candidates (could have duplicates) and target, find all unique combinations where each number used at most once. Need to generate pseudocode line by line with explanation. Use Start, End, Decision, etc. Use virtual code arrow. Should not output actual code. Should include comments. Format exactly: each line: `虛擬碼步驟 // 解釋`. Use arrows, decision, etc. Likely steps: sort candidates to handle duplicates, backtracking function with index, current combination, remaining target. Check base cases. For each i from start to length: skip duplicates if i > start and candidates[i]==candidates[i-1] to avoid duplicates. If candidates[i] > remaining, break. Add to combination, call recursion with i+1. After recursion, pop. At end collect results. Provide high-level steps: Start, Sort candidates, Define backtrack function, etc. Provide line-by-line.\n\nLet's produce maybe 15-20 lines.\n\nWe must produce each line with arrow? They said use arrows (→, Yes→, No→) and structure. So each step line may start with arrow. For functions, maybe we write Step: Define backtrack. But we need arrow.\n\nLet's design:\n\nStart // 程式開始\n→ Step 1: Sort candidates ascending // 為了方便處理重複元素\n→ Step 2: Initialize results list // 用來存放所有符合條件的組合\n→ Step 3: Define Backtrack(startIndex, currentCombination, remainingTarget) // 進行遞迴搜尋\n    → Decision: remainingTarget == 0? // 若剩餘目標為零\n        Yes → Step 4: Append copy of currentCombination to results // 找到合法組合，加入結果\n        No → Step 5: Decision: startIndex == length of candidates? // 若已經走到最後\n            Yes → No more candidates, return // 結束此路徑\n            No  → Step 6: For i from startIndex to length-1\n                → Decision: i > startIndex AND candidates[i] == candidates[i-1]? // 避免重複選項\n                    Yes → Continue // 跳過重複\n                    No  → Step 7: Decision: candidates[i] > remainingTarget? // 若大於剩餘，因已排序可直接跳出\n                        Yes → Break // 之後所有元素都更大，結束循環\n                        No  → Step 8: Append candidates[i] to currentCombination // 選擇此數字\n                        → Step 9: Call Backtrack(i+1, currentCombination, remainingTarget - candidates[i]) // 進入下一層\n                        → Step 10: Remove last element from currentCombination // 回溯，恢復狀態\nEnd // 程式執行結束\n\nNeed each line with `// 解釋`. For lines with nested, we can indent using spaces? The example shows indent for nested lines. We'll replicate indentation.\n\nMake sure each line is separate. We'll include arrow at start of each line. For indentation, maybe 4 spaces before each nested line.\n\nWe need to maintain the format. Let's craft.\n\nWe might also include Step labels: Step 1, Step 2, etc. Provide explanation.\n\nWe'll keep lines count.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort candidates ascending // 先排序，方便後續排除重複組合  \n→ Step 2: Initialize results list // 用來收集所有符合條件的組合  \n→ Step 3: Define Backtrack(startIndex, currentCombination, remainingTarget) // 定義遞迴搜尋函式  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: remainingTarget == 0? // 檢查是否已達到目標值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: Append copy of currentCombination to results // 成功組合加入結果  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: startIndex == length of candidates? // 檢查是否已走到陣列尾部  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → No more candidates, return // 路徑結束  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 5: For i from startIndex to length-1 // 遍歷剩餘候選數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: i > startIndex AND candidates[i] == candidates[i-1]? // 避免重複使用同一數值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Continue // 跳過重複項  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Decision: candidates[i] > remainingTarget? // 若大於剩餘，已排序可直接停止  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Break // 之後所有元素更大，結束循環  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: Append candidates[i] to currentCombination // 選擇此數字  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: Call Backtrack(i+1, currentCombination, remainingTarget - candidates[i]) // 進行下一層遞迴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: Remove last element from currentCombination // 回溯，恢復上一層狀態  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            prev = None\n            for i in range(start, len(candidates)):\n                if prev is not None and candidates[i] == prev:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 candidates 列表和 target 整數。\"\"\"\n    candidates_match = re.search(r'candidates\\s*=\\s*(\\[.*?\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not candidates_match or not target_match:\n        return None, None\n    candidates = ast.literal_eval(candidates_match.group(1))\n    target = int(target_match.group(1))\n    return candidates, target\n\ndef format_output(result):\n    \"\"\"將結果列表格式化成不帶空格的字串。\"\"\"\n    inner = ','.join('[' + ','.join(map(str, combo)) + ']' for combo in result)\n    return '[' + inner + ']'\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    candidates, target = parse_input(input_data)\n    if candidates is None or target is None:\n        print(\"[]\")\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n    print(format_output(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1,2,2],[5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to design algorithm for serializing and deserializing BST. We output virtual code steps line by line with explanations. Must be concise. Provide algorithm: Use preorder traversal to serialize, store values separated by commas; use recursion. For deserialization, parse numbers and reconstruct BST by inserting into tree in order or using bounds recursion. For compactness, we can store as string of numbers with separator. Use pre-order and reconstruct using bounds.\n\nLet's produce pseudocode steps.\n\nWe need start, end, decision arrows. Provide steps: Start, Step 1: Preorder traversal produce list, join with commas, etc. Step 2: Deserialize: parse tokens to array, use helper with bounds: recursion with lower/upper to build tree. Provide steps for that.\n\nMake sure each line includes virtual code step and // explanation. Use arrows: → Step. For decisions: Decision: If tree empty? etc.\n\nLet's write.\n\nWe need to output in Chinese.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 計算 BST 的前序序列 // 以深度優先前序方式遍歷節點\n→ Step 2: 將節點值轉成字串並以逗號分隔 // 產生緊湊的序列字串\n→ Step 3: 回傳該字串 // 完成序列化\n→ Step 4: 解析輸入字串為整數列表 // 將字串拆分為數值\n→ Decision: 如果列表為空? // 檢查是否有節點\n    Yes → Step 5: 返回空樹 // 空 BST\n    No → Step 6: 初始化指標 idx = 0 // 用於追蹤目前處理的節點\n→ Step 7: 定義遞迴函式 build(lower, upper) // 在給定值域內建樹\n→ Decision: idx 已超過列表長度 或 current_value 不在 [lower, upper] ？ // 判斷是否可放入節點\n    Yes → Step 8: 返回空節點 // 無效區域或已全部處理\n    No  → Step 9: 建立新節點值為 nums[idx] // 創建節點\n→ Step 10: idx += 1 // 前進到下一個值\n→ Step 11: node.left = build(lower, node.val) // 建左子樹，值必小於節點\n→ Step 12: node.right = build(node.val, upper) // 建右子樹，值必大於節點\n→ Step 13: 返回 node // 完成子樹\n→ Step 14: root = build(-∞, +∞) // 從整個值域開始建樹\n→ Step 15: 返回 root // 完成反序列化\nEnd // 程式執行結束\n\nNeed to format each line: \"虛擬碼步驟 // 解釋\" and use arrows. Provide indent? Should we indent for Decision branches? In example they used indent for branch lines. We can use similar. Provide \"Decision:\" lines. Use \"Yes →\" \"No →\". We'll produce with indentation. Must keep virtual code and arrow. Let's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 BST 的前序序列 // 以深度優先前序方式遍歷節點  \n→ Step 2: 將節點值轉成字串並以逗號分隔 // 產生緊湊的序列字串  \n→ Step 3: 回傳該字串 // 完成序列化  \n\n→ Step 4: 解析輸入字串為整數列表 // 將字串拆分為數值  \n→ Decision: 如果列表為空? // 檢查是否有節點  \n  Yes → Step 5: 返回空樹 // 空 BST  \n  No  → Step 6: 初始化指標 idx = 0 // 用於追蹤目前處理的節點  \n\n→ Step 7: 定義遞迴函式 build(lower, upper) // 在給定值域內建樹  \n  Decision: idx 已超過列表長度 或 nums[idx] 不在 [lower, upper] ？ // 判斷是否可放入節點  \n   Yes → Step 8: 返回空節點 // 無效區域或已全部處理  \n   No  → Step 9: 建立新節點值為 nums[idx] // 創建節點  \n    Step 10: idx += 1 // 前進到下一個值  \n    Step 11: node.left = build(lower, node.val) // 建左子樹，值必小於節點  \n    Step 12: node.right = build(node.val, upper) // 建右子樹，值必大於節點  \n    Step 13: 返回 node // 完成子樹  \n\n→ Step 14: root = build(-∞, +∞) // 從整個值域開始建樹  \n→ Step 15: 返回 root // 完成反序列化  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a list-like string.\"\"\"\n        res = []\n\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n\n        preorder(root)\n        # Return in list format for compatibility with the judge examples\n        return '[' + ','.join(res) + ']'\n\n    def deserialize(self, data):\n        \"\"\"Decodes a list-like string to tree.\"\"\"\n        if not data or data == '[]':\n            return None\n        # Strip the brackets and split\n        nums = list(map(int, data.strip('[]').split(',')))\n        idx = 0\n\n        def build(lower, upper):\n            nonlocal idx\n            if idx >= len(nums) or nums[idx] < lower or nums[idx] > upper:\n                return None\n            val = nums[idx]\n            idx += 1\n            node = TreeNode(val)\n            node.left = build(lower, val - 1)\n            node.right = build(val + 1, upper)\n            return node\n\n        return build(float('-inf'), float('inf'))\n\ndef insert_bst(root, val):\n    \"\"\"Insert a value into a BST and return the root.\"\"\"\n    if root is None:\n        return TreeNode(val)\n    if val < root.val:\n        root.left = insert_bst(root.left, val)\n    else:\n        root.right = insert_bst(root.right, val)\n    return root\n\ndef build_tree_from_list(values):\n    \"\"\"Build a BST from a list of values.\"\"\"\n    root = None\n    for v in values:\n        root = insert_bst(root, v)\n    return root\n\ndef main():\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Extract the list part after '='\n    try:\n        list_str = raw_input.split('=', 1)[1].strip()\n        values = ast.literal_eval(list_str)\n    except Exception:\n        # If parsing fails, assume empty list\n        values = []\n\n    # Build BST\n    root = build_tree_from_list(values)\n\n    # Serialize\n    codec = Codec()\n    serialized = codec.serialize(root)\n\n    # Output result\n    print(serialized)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": true,
          "output": "[2,1,3]"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for algorithm: find intersection of two integer arrays, unique. We can use set intersection. Steps: convert nums1 to set, iterate nums2, add to result set if in set1. Or use two sets then intersection. Provide virtual steps with Start, Decision etc.\n\nWe need each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows: Start, → Step, Decision, Yes →, No →, End.\n\nWe must produce each line separately. For example:\n\nStart // program start\n→ Step 1: 將 nums1 轉為 SetA // create set of first array\n→ Step 2: 初始化空 SetResult // result set\n→ Decision: 若 nums2 不是空? // check if second array has elements\n    Yes → For each num in nums2:\n          → Decision: num 是否在 SetA? // check membership\n                Yes → Step 3: 將 num 加入 SetResult // add unique intersection\n                No  → // nothing\n    No → // skip\n→ Step 4: 將 SetResult 轉為 Array returnArray // convert to array\n→ Step 5: 返回 returnArray // output result\nEnd // end\n\nBut we need to use arrow and structure. Perhaps use loops: For each. We can use Decision: for each num in nums2? maybe not need decision. Use Step 3 with loop.\n\nLet's produce:\n\nStart\n→ Step 1: 建立 SetA = nums1 的集合 // unique elements of first array\n→ Step 2: 建立空集合 ResultSet // 存放交集\n→ Decision: nums2 是否非空? // 檢查第二個陣列\n    Yes → Step 3: 對 nums2 中每個 num 執行\n          → Decision: num 是否在 SetA? // 判斷是否屬於交集\n                Yes → Step 4: 把 num 加入 ResultSet // 添加至結果\n                No  → // 跳過\n    No  → // 若空則不做任何操作\n→ Step 5: 將 ResultSet 轉為陣列 returnArray // 將集合轉回陣列\n→ Step 6: 返回 returnArray // 結果輸出\nEnd\n\nWe need to maintain the arrow syntax: use → for steps. Decision lines include Yes →, No →. Need to indent? The example shows indentation but it's not required. But keep formatting similar.\n\nWe need to include a comment after space. Provide short explanation. Use Traditional Chinese. Provide each line as separate line. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 SetA = nums1 的集合 // 取出 nums1 的唯一元素  \n→ Step 2: 建立空集合 ResultSet // 用來儲存交集元素  \n→ Decision: nums2 是否非空? // 檢查第二個陣列是否有資料  \n  Yes → Step 3: 對 nums2 中每個 num 執行  \n   → Decision: num 是否在 SetA? // 判斷該元素是否屬於交集  \n    Yes → Step 4: 把 num 加入 ResultSet // 添加至結果集合  \n    No  → // 若不在 SetA，則略過  \n  No  → // 若 nums2 為空，直接跳過  \n→ Step 5: 將 ResultSet 轉為陣列 returnArray // 把集合轉回陣列格式  \n→ Step 6: 返回 returnArray // 將交集結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef intersection(nums1, nums2):\n    \"\"\"回傳兩個整數陣列的交集（唯一且順序不重要）\"\"\"\n    return list(set(nums1) & set(nums2))\n\ndef main():\n    # 從標準輸入讀取整個資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式：例如 \"nums1 = [1,2,2,1], nums2 = [2,2]\"\n    # 取出兩個括號內的字串，再使用 ast.literal_eval 轉成 list\n    try:\n        start1 = data.index('[')\n        end1   = data.index(']', start1)\n        nums1 = ast.literal_eval(data[start1:end1+1])\n    except ValueError:\n        nums1 = []\n\n    try:\n        start2 = data.index('[', end1+1)\n        end2   = data.index(']', start2)\n        nums2 = ast.literal_eval(data[start2:end2+1])\n    except ValueError:\n        nums2 = []\n\n    # 計算交集並輸出\n    result = intersection(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": true,
          "output": "[9, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the subset sum / partition problem. Provide step by step with decision, loops, etc. Not actual code. Use Start, Decision, etc. Provide explanation. Should be in Traditional Chinese. Ensure each line: 虛擬碼步驟 + space + // 解釋. Use arrow → etc.\n\nLet's produce a dynamic programming approach: compute total sum; if odd, return false; target = sum/2; use DP boolean array of size target+1. Iterate over numbers, update dp from target down to num. After loop, dp[target] indicates.\n\nLet's output steps: Start, compute total sum, Decision if odd -> False. Else compute target. Initialize dp[0] = true. Loop over each num. For each, update dp[j] = dp[j] or dp[j-num] for j from target down to num. After loop, Decision if dp[target] -> True else False. End.\n\nAlso include decisions for early break if dp[target] becomes true early.\n\nLet's produce lines accordingly.\n\nMake sure to follow format. Each line starts with \"Start\" or \"→\". Use arrow.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列 nums 的總和 total // 取得所有元素之和  \n→ Decision: 如果 total 為奇數? // 若總和為奇數則無法分成相等子集  \n    Yes → Step 2: 回傳 false // 直接結束，無法分割  \n    No  → Step 3: 設定目標 sum = total / 2 // 目標子集和  \n→ Step 4: 初始化布林陣列 dp[0…sum]，並將 dp[0] 設為 true // dp[j] 表示是否能達到和 j  \n→ For each number num in nums: // 逐個遍歷數字  \n    → For j from sum down to num: // 從目標和回退到 num，避免重複使用同一個數  \n        → Decision: 如果 dp[j-num] 為 true? // 可否透過前一個子集和加上 num 得到 j  \n            Yes → Set dp[j] = true // 更新能達到和 j  \n            No  → 保持 dp[j] 不變 // 無法達到  \n→ Decision: 如果 dp[sum] 為 true? // 是否能得到目標和  \n    Yes → Step 5: 回傳 true // 成功分割  \n    No  → Step 6: 回傳 false // 無法分割  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，支援 \"nums = [1,5,11,5]\" 或直接 \"[1,5,11,5]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    try:\n        nums = eval(expr, {}, {})\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        print(\"false\")\n        sys.exit(0)\n\n    result = Solution().canPartition(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the described solution. Provide step-by-step. Need to include Start, End, Decision, arrows. We need to think algorithm: given array nums. In constructor, store array. For pick, we need to use reservoir sampling to pick random index among all occurrences of target. Or we can precompute mapping from target to list of indices, but that may be heavy. Let's implement reservoir sampling: iterate over array, maintain count of target occurrences seen, when see target, generate random number between 1 and count, if it's 1, record index as chosen. At end return chosen index. So algorithm:\n\nSolution constructor: store nums. (Optionally store length). pick(target): initialize chosenIndex = -1, count = 0; for i from 0 to nums.length-1: if nums[i]==target: count++; if randomInt(1, count)==1: chosenIndex = i; return chosenIndex.\n\nVirtual code steps: Start; Step: store array; etc.\n\nAlso need explanation each line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Store input array nums into member variable // Constructor\n→ End // Done with initialization\n\nBut need also pick method steps.\n\nWe might separate methods: Start → Constructor block → End; Start → pick method block → End.\n\nMake each line with virtual code step and explanation.\n\nUse arrow syntax: Start, → Step 1, etc. For loops we can use \"→ Loop i from 0 to nums.length-1\" etc. For random: \"→ Generate random number r = random(1, count)\". For Decision: \"Decision: r == 1?\".\n\nWe should also include End for pick method.\n\nMake sure each line has '//' explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式執行入口\n\n→ Step 1: Store the input array `nums` in a member variable `this.nums` // 於建構子內將陣列保存在物件中\n→ Step 2: Record the length `this.n = this.nums.length` // 方便後續迴圈使用\nEnd // 建構子完成\n\nStart // pick 方法開始執行\n\n→ Step 3: Initialize `chosenIndex` to -1 // 預設沒有選到任何位置\n→ Step 4: Initialize `count` to 0 // 記錄目前遇到的 target 數量\n→ Loop i from 0 to this.n - 1 // 逐個檢查陣列中的元素\n    → Decision: if this.nums[i] == target? // 判斷是否為目標值\n        Yes → Step 5: Increment `count` by 1 // 新增一次符合條件的項目\n        → Step 6: Generate random integer `r` between 1 and `count` // 產生一個 1~count 的隨機數\n        → Decision: if r == 1? // 以 1/count 的機率選擇目前索引\n            Yes → Step 7: Set `chosenIndex` to i // 把當前索引記錄為選中的位置\n            No  → // 不做任何改變，繼續迴圈\n        No  → // 當 nums[i] 不是 target，直接跳過\n→ End Loop // 完成所有元素的檢查\n→ Step 8: Return `chosenIndex` // 回傳隨機選到的索引\nEnd // pick 方法結束\n\nEnd // 程式結束執行",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"把原始陣列保存在實例變數，供後續 pick 使用。\"\"\"\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        隨機選取所有符合 target 的索引，且每個索引被選到的機率相等。\n        使用 reservoir sampling：遍歷一次陣列，遇到 target 時以 1/count 的機率選擇它。\n        \"\"\"\n        chosen_index = -1\n        count = 0\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                # 產生 1~count 的隨機數，若為 1 則更新 chosen_index\n                if random.randint(1, count) == 1:\n                    chosen_index = i\n        return chosen_index\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 把輸入分成兩部分：操作序列和參數序列\n    # 例子：'[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]'\n    split_index = raw_input.find('],')\n    ops_json = raw_input[:split_index + 1]\n    args_json = raw_input[split_index + 2:]\n\n    ops = json.loads(ops_json)\n    args = json.loads(args_json)\n\n    results = []\n    instance = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # 建構子參數為單一列表：[[1, 2, 3, 3, 3]]\n            instance = Solution(args[i][0])\n            results.append(None)          # 第一個結果為 null\n        elif op == \"pick\":\n            # pick 只需要 target，參數為單一元素列表，例如 [3]\n            result = instance.pick(args[i][0])\n            results.append(result)\n\n    # 輸出結果，保持 JSON 格式（None 會被轉成 null）\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nThe task: produce virtual code steps for Word Break problem. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to generate algorithm steps in virtual pseudocode, line by line. Probably dynamic programming approach.\n\nLet's outline steps:\n\nStart\n\n→ Initialize DP array of size len(s)+1, DP[0] = true // base case.\n\n→ For i from 1 to len(s) inclusive // iterate over string\n\n   → For each word in wordDict\n\n      → If i >= len(word) AND DP[i - len(word)] == true AND s.substring(i - len(word), i) == word\n\n          → Set DP[i] = true\n\n          → Break inner loop\n\n→ End loop\n\n→ Return DP[len(s)]\n\nThat's the pseudocode.\n\nWe need to format with arrow and decision maybe.\n\nWe need to use decision steps like \"Decision: if DP[i] is true?\" but we can also do loops as steps.\n\nWe need to ensure each line includes code and explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 計算字符串長度 n ← length(s) // 取得 s 的長度\n\n→ Step 2: 初始化布林陣列 dp[n+1]，dp[0] ← true // DP 用來記錄子字串是否可切分\n\n→ Step 3: For i from 1 to n 循環 // 遍歷所有可能的子字串結尾\n\n    → Decision: 如果 dp[i] 已經為 true? // 已經找到切分方式則跳過\n\n        Yes → Continue to next i // 已可切分，直接進下一個\n\n        No → Step 4: For each word in wordDict 循環 // 嘗試使用字典中的每個單字\n\n            → Decision: 如果 i ≥ len(word) 且 dp[i-len(word)] 為 true 且 s 子字串 i-len(word) 到 i == word? // 檢查是否能以此單字結尾\n\n                Yes → Step 5: dp[i] ← true // 設定此位置可切分\n\n                Yes → Break // 找到一個切分就可停止內層循環\n\n→ Step 6: 返回 dp[n] // 若整個字串可切分則為 true，否則 false\n\nEnd // 程式執行結束\n\nNeed to check formatting: Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step. For decision branches, indent appropriately. The sample uses indentation like 4 spaces. Use similar.\n\nMake sure each line ends with // 解釋. For decisions, \"Decision:\" etc.\n\nWe need to maintain structure:\n\nStart // 程式開始執行\n\n→ Step 1: n ← length(s) // 取得 s 的長度\n\n→ Step 2: dp[0..n] ← false; dp[0] ← true // 初始化 DP 陣列\n\n→ Step 3: For i = 1 to n // 循環檢查每個子字串結尾\n\n    → Decision: if dp[i] == true? // 已有切分方法，跳過\n\n        Yes → Continue // 直接進下一個 i\n\n        No  → For each word in wordDict // 逐一嘗試字典單字\n\n            → Decision: if i ≥ len(word) AND dp[i-len(word)] == true AND s.substring(i-len(word), i) == word? // 能否以此單字結尾\n\n                Yes → dp[i] ← true // 設定可切分\n\n                Yes → Break // 找到一個就停止\n\n→ Step 4: return dp[n] // 若整個字串可切分則為 true\n\nEnd // 程式結束\n\nBut we need to maintain the requirement: \"虛擬碼步驟 [空格] // 解釋\" each line.\n\nLet's produce each line exactly. Use Chinese comments.\n\nAlso, for loops we might need \"→ For i from 1 to n\" etc.\n\nLet's produce.\n\nNote: Use '→' at start of each line.\n\nMake sure indentation: For nested lines, indent with 4 spaces before the arrow. Eg: \"    → Decision:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得字串 s 的長度  \n→ Step 2: dp[0..n] ← false; dp[0] ← true // 初始化 DP 陣列，dp[i] 表示前 i 個字可否切分  \n→ Step 3: For i = 1 to n // 逐個檢查每個可能的子字串結尾  \n  → Decision: 如果 dp[i] == true? // 已有切分方式，直接跳過  \n   Yes → Continue // 進行下一個 i  \n   No → For each word in wordDict // 逐一嘗試字典中的單字  \n     → Decision: 如果 i ≥ length(word) AND dp[i - length(word)] == true AND s.substring(i - length(word), i) == word? // 檢查是否能以此單字結尾  \n      Yes → dp[i] ← true // 設定此位置可切分  \n      Yes → Break // 找到一個切分就停止內層循環  \n→ Step 4: return dp[n] // 若整個字串可切分則為 true，否則為 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入字串轉為可 eval 的程式碼\n    data = data.replace('s =', 's=').replace('wordDict =', 'wordDict=')\n    namespace = {}\n    exec(data, {}, namespace)\n    s = namespace['s']\n    wordDict = namespace['wordDict']\n    result = Solution().wordBreak(s, wordDict)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpm4kkz2d0.py\", line 22, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    s= \"leetcode\", wordDict= [\"leet\",\"code\"]\n    ^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmplmezd06a.py\", line 22, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    s= \"applepenapple\", wordDict= [\"apple\",\"pen\"]\n    ^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpli0vnklr.py\", line 22, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    s= \"catsandog\", wordDict= [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\n    ^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode. Each line: \"虛擬碼步驟 // 解釋\" with arrow etc. Must use Start, End, Decision:, etc. We will produce algorithm: Two pointers: fast and slow. Iterate array with fast, if nums[fast]!=0, swap nums[slow] and nums[fast], increment slow. After loop, zeros are at the end.\n\nWe need to produce each step. Format: \"Start // 程式開始執行\" then \"→ Step 1: 定義兩個指標 slow = 0 // 初始化慢指標\" etc. Use \"Decision:\" lines. We need to use arrow \"→\" before each line. For decision, indent maybe but example shows indentation. We'll produce similar. Use \"→ Decision: if nums[fast] == 0? // 判斷元素是否為零\" etc. Use \"Yes →\" etc. Use \"No →\".\n\nMake sure to include End line.\n\nWe have to generate in Traditional Chinese. Provide explanation after each step.\n\nWe should not output actual code, only virtual steps.\n\nLet's craft.\n\nLines:\n\nStart\n→ Step 1: 定義兩個指標 slow = 0, fast = 0 // 初始化慢指標和快指標\n→ Step 2: 進入迴圈，當 fast < nums.length 時 // 循環遍歷整個陣列\n→ Decision: 是否到達陣列結尾? // 判斷是否完成遍歷\n   No → Step 3: 判斷 nums[fast] 是否為 0? // 檢查目前元素\n   Yes → End // 遍歷完成，結束程式\n\nBut need more detail: Actually decision if fast >= length.\n\nWithin non-end: Step 3: if nums[fast] != 0? Yes → Step 4: 交換 nums[slow] 和 nums[fast] // 移動非零元素到慢指標位置\n   Yes → Step 5: slow++ // 指標前進\n   No → Step 6: 只將 fast++ // 零元素不動，快指標前進\n\nBut we need to increment fast at end of loop. So maybe Step 7: fast++ // 前進快指標\n\nWe must ensure no actual code, just steps.\n\nLet's create structure.\n\nAlso we can skip swap if indices same? But fine.\n\nWe need each line: \"→\" arrow before step, then \"Decision:\" lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定慢指標 slow = 0, 快指標 fast = 0 // 初始化兩個指標  \n→ Step 2: 進入主迴圈，條件 fast < nums.length // 遍歷整個陣列  \n→ Decision: fast 是否已達陣列結尾? // 判斷是否完成遍歷  \n  Yes → End // 所有元素已檢查完畢，結束程式  \n  No → Step 3: 檢查 nums[fast] 是否為 0? // 判斷目前元素是否為零  \n   Yes → Step 4: fast++ // 零元素保持位置，直接移動快指標  \n   No → Step 5: 交換 nums[slow] 與 nums[fast] // 將非零元素移至慢指標位置  \n    No → Step 6: slow++ // 慢指標往前移動以備下個非零元素  \n     → Step 7: fast++ // 快指標往前移動，繼續檢查下一個元素  \n      → 回到 Step 2 // 重複迴圈判斷  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        Move all zeros to the end of the list in-place while preserving\n        the order of non-zero elements.\n        \"\"\"\n        zero_pos = 0  # Index where the next non-zero element should be placed\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[zero_pos], nums[i] = nums[i], nums[zero_pos]\n                zero_pos += 1\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract the list representation from the input (handles inputs like \"nums = [0,1,0]\")\n    nums_match = re.search(r'\\[.*\\]', data)\n    if nums_match:\n        nums_str = nums_match.group(0)\n        try:\n            nums = eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list):\n        nums = []\n\n    # Apply the algorithm\n    solution = Solution()\n    solution.moveZeroes(nums)\n\n    # Output the resulting list\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode650.json",
    "problem_index_in_file": 0,
    "title": "2 Keys Keyboard",
    "description_snippet": "There is only one character 'A' on the screen of a notepad. You can perform one of two operations on...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: minimal steps to reach n As using copy-paste. Classic DP: dp[i] minimal steps to achieve i As. For each i, for each j from 1 to i-1: dp[i] = min(dp[i], dp[j] + i/j + 1) or dp[i] = dp[i] = dp[i - k] + 2? Actually algorithm: dp[i] = min over k < i where k divides i: dp[k] + i/k + 1. Because we copy at k, then paste i/k times. Complexity O(n^2). Alternatively use prime factorization: sum of prime factors. But produce generic DP.\n\nLet's craft virtual steps: Start, input n, initialize array dp[1..n], set dp[1] = 0. For i from 2 to n: set dp[i] = Infinity. For j from 1 to i-1: if i % j == 0: temp = dp[j] + i/j + 1; if temp < dp[i] then dp[i] = temp. After loops, result dp[n]. End.\n\nWe should also include decisions, loops. Use arrow notation.\n\nOk produce each line.\n\nLet's produce as per format: each line: virtual step + comment.\n\nWe need to maintain arrow for loops: maybe use \"→\" at start of step, and indent for nested loops: \"→ Decision:\" etc.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Input n // 讀取目標 A 數量\n→ Initialize dp[1] = 0 // 1 個 A 需要 0 步\n→ For i = 2 to n: // 逐個計算 dp 值\n    → Set dp[i] = ∞ // 先設為無限大\n    → For j = 1 to i-1: // 檢查所有可能的分割點\n        → Decision: if i mod j == 0? // 只有整除才可用 j 作為 Copy 時點\n            Yes → temp = dp[j] + i/j + 1 // dp[j] 步 + 1 次 Copy + (i/j) 次 Paste\n            Yes → If temp < dp[i] Then dp[i] = temp // 更新最小步數\nEnd // 程式結束\n\nBut we need to keep each line separate; nested lines each separate line. Use arrow for indent? We'll just indent with spaces and \"→\" as per sample. In sample they indent for nested actions but still show arrow at each step. Use indent spaces for clarity.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input n // 讀取目標 A 數量\n→ Initialize dp[1] = 0 // 1 個 A 需要 0 步\n→ For i = 2 to n: // 從 2 到 n 計算最小步數\n    → Set dp[i] = ∞ // 初始為無限大\n    → For j = 1 to i-1: // 嘗試所有前置值\n        → Decision: if i mod j == 0? // 只有 j 能整除 i 才是有效的 Copy 時點\n            Yes → temp = dp[j] + i/j + 1 // 先在 j 時進行 Copy，然後 Paste (i/j) 次\n            Yes → Decision: if temp < dp[i]? // 檢查是否更新\n                Yes → dp[i] = temp // 更新為更小的步數\nEnd // 程式結束\n\nCheck formatting: Each line separated, arrow at start of each step. Provide comments. Should use \"Yes\" or \"No\" for Decision. For No branch we may skip, no line needed. Sample uses \"No → ...\" for No. We can show No with nothing. For brevity we can omit No branch.\n\nMake sure to include \"Yes →\" for each branch. Provide explanation. That's fine.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 讀取目標 A 數量  \n→ Initialize dp[1] = 0 // 1 個 A 需要 0 步  \n→ For i = 2 to n: // 從 2 到 n 計算最小步數  \n    → Set dp[i] = ∞ // 初始為無限大  \n    → For j = 1 to i-1: // 嘗試所有前置值  \n        → Decision: if i mod j == 0? // 只有 j 能整除 i 才是有效的 Copy 時點  \n            Yes → temp = dp[j] + i/j + 1 // 先在 j 時進行 Copy，然後 Paste (i/j) 次  \n            Yes → Decision: if temp < dp[i]? // 檢查是否更新  \n                Yes → dp[i] = temp // 更新為更小的步數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef min_steps(n: int) -> int:\n    \"\"\"Return the minimum number of operations to get exactly n 'A's.\"\"\"\n    res = 0\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            res += d\n            n //= d\n        d += 1\n    return res\n\ndef main() -> None:\n    # 讀取全部輸入，從中提取第一個整數\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    # 計算並輸出結果\n    print(min_steps(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that represent algorithm to find min operations to reduce n to 1 using these operations. This is classic problem \"Integer Replacement\" (LeetCode 397). Minimal operations. Approach: use recursion + memoization (DP). For n even: n/2. For n odd: choose min between replacing with n+1 or n-1. But careful: for large n might overflow for n+1? But we can use 64-bit. Virtual pseudocode.\n\nWe should produce step-by-step virtual code lines with comments. Use Start, Decision, etc. We should handle base case n==1. Use recursion function solve(n). Use memoization map. Use Decision for even? odd? For odd: compute both options and take min+1. Provide steps.\n\nWe need each line like: `Start // 程式開始執行` etc. Let's produce pseudo-code lines.\n\nWe'll need a global map: memo: map[int]int. But can also mention.\n\nPseudo-code structure:\n\nStart\n→ Define function MinOps(n)\n    → Decision: if n == 1? \n        Yes → Return 0 // already 1, no ops\n        No → Decision: if n is even? \n            Yes → Return 1 + MinOps(n/2) // one operation then solve half\n            No → // odd case\n                → Compute ops1 = 1 + MinOps(n+1)\n                → Compute ops2 = 1 + MinOps(n-1)\n                → Return min(ops1, ops2)\nEnd\n\nBut also memoization:\n\n→ Initialize memo map\n→ Define function with memo check: if n in memo, return memo[n]\n→ After computing, memo[n]=result\n→ Return result\n\nWe need to produce each line. Use arrow and indentation.\n\nLet's produce virtual code line by line.\n\nMake sure each line contains code and comment. Use spaces accordingly.\n\nWe also need to indicate that the recursion may cause overflow for n+1 if using 32-bit, but we can assume 64-bit.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialise memo // 建立一個全域快取表，用來記錄已計算過的 n 與對應的最小步數\n    → memo ← {} // 空字典\n→ 定義函式 MinOps(n) // 主要遞迴函式，回傳 n 變為 1 所需的最小步數\n    → Decision: 如果 memo 包含 n? // 檢查快取\n        Yes → Return memo[n] // 若已計算，直接回傳結果\n        No  →\n            → Decision: 如果 n 等於 1? // 基礎情況：已達目標\n                Yes → result ← 0 // 需要 0 步即可\n                No →\n                    → Decision: 如果 n 為偶數? // n%2==0\n                        Yes →\n                            → result ← 1 + MinOps(n / 2) // 取一次除 2 的操作，遞迴計算剩餘步數\n                        No → // n 為奇數\n                            → opsPlus ← 1 + MinOps(n + 1) // 嘗試將 n+1 後再遞迴\n                            → opsMinus ← 1 + MinOps(n - 1) // 嘗試將 n-1 後再遞迴\n                            → result ← min(opsPlus, opsMinus) // 選擇步數較少的一種\n            → memo[n] ← result // 將結果存入快取，供未來重複使用\n            → Return result // 回傳計算結果\n→ Call MinOps(n) // 啟動遞迴計算，傳入初始正整數 n\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\n# ---------- 主要計算邏輯 ----------\n@lru_cache(maxsize=None)\ndef min_ops(n: int) -> int:\n    \"\"\"\n    回傳將正整數 n 變為 1 所需的最小操作步數。\n    1. 若 n 為偶數，直接做一次除 2。\n    2. 若 n 為奇數，嘗試 n+1 或 n-1，取兩者步數較少的一種。\n    \"\"\"\n    if n == 1:\n        return 0                # 已達目標，無需任何操作\n    if n % 2 == 0:              # n 為偶數\n        return 1 + min_ops(n // 2)\n    # n 為奇數\n    return 1 + min(min_ops(n + 1), min_ops(n - 1))\n\n# ---------- 進入點 ----------\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取數字 n，計算並輸出最小步數。\n    允許輸入形式如 'n = 8'、'8' 或包含其他文字的情況。\n    \"\"\"\n    data = sys.stdin.read()\n    # 使用正則表達式提取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = min_ops(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines. The task: given string s, find first non-repeating character index else -1. Provide virtual code line by line, each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows. Let's plan algorithm: First pass count frequency using dictionary. Second pass find first char with freq 1, return index. If none, return -1.\n\nWe produce virtual steps:\n\nStart\n→ Step 1: Initialize freq map // create empty map\n→ Step 2: For each character in s with index i // iterate string\n    → Step 2a: freq[char] = freq.get(char, 0) + 1 // count\n→ Step 3: For each character in s with index i // second pass\n    → Decision: If freq[char] == 1? // check uniqueness\n        Yes → Return i // first non-repeating index\n→ Step 4: Return -1 // none found\nEnd\n\nWe need to be careful with structure: using Decision. Provide arrows.\n\nWe need to ensure each line is in format \"虛擬碼步驟 // 解釋\".\n\nAdd \"Start // 程式開始執行\". \"End // 程式執行結束\".\n\nAlso arrow \"→\" indicates flow. Indent decisions. Use indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率表 freq ← {} // 建立空字典來存儲每個字元的出現次數  \n→ Step 2: 遍歷字符串 s，對於每個字符 ch 及其索引 i  \n  → Step 2a: freq[ch] ← freq.get(ch, 0) + 1 // 對頻率表進行累加  \n→ Step 3: 再次遍歷字符串 s，對於每個字符 ch 及其索引 i  \n  → Decision: 如果 freq[ch] 等於 1? // 判斷是否為唯一出現的字元  \n    Yes → Return i // 返回第一個非重複字符的索引  \n→ Step 4: Return -1 // 若沒有找到非重複字符，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"\n        Return the index of the first non‑repeating character in s.\n        If all characters repeat, return -1.\n        \"\"\"\n        if not s:\n            return -1\n\n        # Count occurrences of each character\n        freq = Counter(s)\n\n        # Find first character with frequency 1\n        for idx, ch in enumerate(s):\n            if freq[ch] == 1:\n                return idx\n        return -1\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    Extract the string value from an input line that may look like:\n    s = \"leetcode\"\n    or just \"leetcode\"\n    \"\"\"\n    # Search for the first pair of double quotes\n    m = re.search(r'\"(.*?)\"', line)\n    if m:\n        return m.group(1)\n    # Fallback: if no quotes, assume the whole line is the string\n    return line.strip()\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    input_line = sys.stdin.read().strip()\n    # Parse the string value from the input\n    s = parse_input(input_line)\n\n    solution = Solution()\n    result = solution.firstUniqChar(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode697.json",
    "problem_index_in_file": 0,
    "title": "Degree of an Array",
    "description_snippet": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the ma...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for solution. Provide each line with explanation. We'll include Start, steps: iterate over array to record first index, last index, count. Then compute degree, then compute min length among elements with degree. Output length. Use decisions, loops. Provide explanation per line. Use arrow lines with indentation. Use decision lines where needed. Use Start and End. Ensure no actual code.\n\nLet's produce: Start, Step 1: Initialize dictionaries counts, firstIndex, lastIndex. Then for each element with index i: If not in firstIndex, record. Always update lastIndex. Increment counts.\n\nThen after loop: Compute degree = max(counts). Then initialize minLen = infinity.\n\nThen iterate over keys of counts: if counts[key]==degree: compute len = lastIndex[key]-firstIndex[key]+1. If len<minLen, update.\n\nEnd // output minLen.\n\nBut we need decision arrow lines for degree computation maybe. Use Decision: find max? Or we can compute while iterating. We'll produce simpler steps.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 空字典 Count, First, Last // 用於記錄每個元素的出現頻率、第一次出現位置與最後一次出現位置\n→ Step 2: 針對陣列 nums 的每個索引 i 進行迴圈 // 逐一掃描所有元素\n    → Decision: 是否已在 First 中記錄元素 nums[i]? // 判斷是否為首次出現\n        Yes → Step 3a: 記錄 First[nums[i]] = i // 记录第一次出现的位置\n        No  → Step 3b: 何事不改 // 第一次已记录，无需更新\n    → Step 3c: 更新 Last[nums[i]] = i // 记录最新一次出现的位置\n    → Step 3d: Count[nums[i]] = Count.get(nums[i], 0) + 1 // 计数加一\n→ Step 4: Degree = 最大的 Count 值 // 找出整个数组的度\n→ Step 5: 初始化 minLen = 無限大 // 用于记录满足度的最短子数组长度\n→ Step 6: 針對 Count 的每個元素 key 進行迴圈 // 遍历所有出现过的数字\n    → Decision: Count[key] 是否等於 Degree? // 只考虑度相同的元素\n        Yes → Step 7a: 计算长度 len = Last[key] - First[key] + 1 // 子数组长度\n        → Decision: len 是否小於 minLen? // 选择最短的\n            Yes → Step 7b: minLen = len // 更新最短长度\n            No  → Step 7c: 何事不改 // 当前长度更长，保持原值\n        No  → Step 7d: 何事不改 // 该元素不满足度条件，跳过\n→ End // 程式執行結束，minLen 為所求最短子数组长度",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_shortest_subarray(nums):\n    \"\"\"\n    找出最短子陣列長度，其度等於整個陣列的度。\n    \"\"\"\n    left = {}   # 每個元素第一次出現的索引\n    right = {}  # 每個元素最後一次出現的索引\n    count = defaultdict(int)  # 每個元素的出現頻率\n\n    # 逐一掃描陣列，紀錄第一次、最後一次索引及頻率\n    for i, num in enumerate(nums):\n        if num not in left:\n            left[num] = i\n        right[num] = i\n        count[num] += 1\n\n    # 整個陣列的度：最大頻率\n    degree = max(count.values())\n    # 初始化最短長度為無限大\n    min_length = float('inf')\n\n    # 只考慮度等於 degree 的元素\n    for num in count:\n        if count[num] == degree:\n            length = right[num] - left[num] + 1\n            if length < min_length:\n                min_length = length\n\n    return min_length\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，預期格式類似於 'nums = [1,2,2,3,1]'\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 找出第一個 '['，從那裡開始解析列表\n    bracket_index = raw_input.find('[')\n    if bracket_index == -1:\n        nums = []\n    else:\n        nums_str = raw_input[bracket_index:]\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n\n    result = find_shortest_subarray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,2,3,1,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving \"Next Greater Element II\" problem. Use stack approach. Provide steps line by line. Virtual code lines with arrows, decisions. Provide explanation comment. No actual code.\n\nWe must follow the format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use → arrows. Provide steps: Start, initialize n, result array, stack, iterate from 2n-1 to 0, etc.\n\nMake sure to include loops, conditions, decisions.\n\nLet's produce maybe 20 lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: result ← new array of size n, all -1 // 初始化回傳陣列，預設為 -1  \n→ Step 3: stack ← empty list // 建立堆疊用來存儲候選的「下一個更大數」  \n→ Step 4: for i ← 2*n-1 downto 0 // 從最後一個元素往前走兩圈，模擬循環  \n  → Decision: 如果 i < n? // 只在第一圈更新結果  \n    Yes → Step 5: result[i] ← stack.top() if stack not empty else -1 // 取堆疊頂端為下一個更大數  \n    No  → Skip // 第一圈不更新，只做堆疊準備  \n  → Decision: 如果 nums[i mod n] >= stack.top()? // 堆疊頂端是否已經比當前數小  \n    Yes → Step 6: while stack not empty and stack.top() <= nums[i mod n] do stack.pop() // 去除不合適的候選  \n    No  → Skip // 堆疊頂端已經更大，保持不變  \n  → Step 7: stack.push(nums[i mod n]) // 將當前數加入堆疊，成為未來元素的候選  \nEnd // 程式執行結束，result 即為答案\n\n---  \n說明：  \n- Step 4 迴圈跑 2n 次，確保每個元素都能搜尋到可能的更大數（循環）。  \n- Decision 在 i < n 時只更新結果，因為只有在第一圈才需要回傳對應位置。  \n- Step 6 中的 while 迴圈移除所有小於等於當前數的堆疊元素，因為它們不可能是任何前面元素的下一個更大。  \n- Step 7 把當前數加入堆疊，為左邊元素提供候選。  \n- 結果初始化為 -1，若堆疊為空則保持 -1。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElements(self, nums):\n        n = len(nums)\n        res = [-1] * n\n        stack = []  # store indices\n\n        for i in range(2 * n):\n            # when a greater element is found, fill the result\n            while stack and nums[stack[-1]] < nums[i % n]:\n                res[stack.pop()] = nums[i % n]\n            # only push indices from the first pass (original array)\n            if i < n:\n                stack.append(i)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"Parse input that may look like 'nums = [1,2,1]' or just '[1,2,1]'.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        return ast.literal_eval(expr)\n    except Exception:\n        # fallback: try eval in a safe namespace\n        return eval(expr, {\"__builtins__\": None}, {})\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = Solution().nextGreaterElements(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2, -1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2, 3, 4, -1, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: minimum path sum in triangle. Classic DP.\n\nWe output line by line virtual code with explanation comments. Must use virtual code arrows and structure. Provide algorithm steps: Start, maybe create dp array of length n, iterate rows bottom-up or top-down. Let's choose bottom-up: initialize dp with last row, then for i from n-2 to 0: for j from 0 to i: dp[j] = triangle[i][j] + min(dp[j], dp[j+1]); at end return dp[0].\n\nWe need step-by-step. Provide decision? maybe not many decisions; just loops.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 取得三角形長度 n // 取得行數\n→ Decision: 如果 n 為 0? // 檢查是否為空\n    Yes → Step 2: 回傳 0 // 空三角形返回 0\n    No  → \n→ Step 3: 初始化 dp 為 triangle[n-1] // 將最後一行拷貝到 dp\n→ Decision: i 從 n-2 降到 0? // 外層迴圈\n    Yes → \n        → Step 4: 對 j 從 0 到 i 迭代 // 內層迴圈\n            → Step 5: dp[j] = triangle[i][j] + min(dp[j], dp[j+1]) // 更新最小路徑\n    No  → \n→ Step 6: 回傳 dp[0] // 返回最小總和\nEnd // 結束\n\nBut must use \"Decision:\" etc. Also use Yes → and No →.\n\nNeed arrow formatting: For loops we can use Decision: i> =0? maybe. Let's structure:\n\nDecision: i >= 0? for loop.\n\nBut we also need to show loops. Use Decision for loop condition.\n\nSo:\n\nDecision: i >= 0? // 外層迴圈條件\n    Yes → Step 4: i = i - 1 // 更新\n    No  → Step 6: 回傳 dp[0] // 結束\n\nBut we need to show j loop similarly.\n\nLet's produce final with proper format.\n\nAlso we need to mention variable names.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(triangle) // 取得三角形的行數  \n→ Decision: n == 0? // 檢查是否為空三角形  \n  Yes → Step 2: return 0 // 若空，直接返回 0  \n  No  →  \n→ Step 3: dp ← copy(triangle[n-1]) // 用最後一行初始化 dp  \n→ Decision: i = n-2 ≥ 0? // 外層迴圈條件（從倒數第二行往上）  \n  Yes →  \n    → Step 4: i ← i - 1 // 每次迭代前遞減 i  \n    → Decision: j = 0 ≤ i? // 內層迴圈條件（遍歷當前行的每個元素）  \n      Yes →  \n        → Step 5: dp[j] ← triangle[i][j] + min(dp[j], dp[j+1]) // 更新 dp[j] 為最小路徑和  \n        → Step 6: j ← j + 1 // j 進位  \n        → Decision: j ≤ i?  \n          Yes → repeat Step 5-6  \n          No  → exit j-loop  \n    → Step 7: repeat Step 4-6 for next i  \n    → Decision: i ≥ 0?  \n      Yes → repeat Step 4-7  \n      No  →  \n→ Step 8: return dp[0] // 回傳最小路徑總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef minimum_total(triangle):\n    \"\"\"\n    計算三角形從頂部到底部的最小路徑和。\n    使用自底向上的動態規劃。\n    \"\"\"\n    if not triangle:          # 空三角形直接回傳 0\n        return 0\n    # 用最後一行初始化 dp，dp[j] 代表從 j 處往下的最小路徑和\n    dp = triangle[-1][:]      # 先複製，避免修改原本資料\n    # 從倒數第二行往上迭代\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            # dp[j] 取兩條可能路徑的最小值再加上本層數值\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n    # dp[0] 就是整體最小路徑和\n    return dp[0]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去掉可能的「triangle =」前綴\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    if raw_input.startswith(\"triangle\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    try:\n        triangle = ast.literal_eval(raw_input)\n    except Exception:\n        triangle = []  # 若解析失敗則視為空三角形\n    result = minimum_total(triangle)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution. Outline: Start, create list of (score, index), sort descending, iterate assign rank string, fill answer array, End. Provide each line with explanation. Use arrows, decision maybe. Provide sequential steps. No actual code. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空清單 pairs 來存放 (score, 原始索引) // 用於後續排序  \n→ Decision: 逐個遍歷 score 並加入 pairs // 為每位選手存入其分數與位置  \n    Yes → Step 2: pairs.add( (score[i], i) ) // 將分數和索引配對存入列表  \n→ Step 3: 按 score 降序排序 pairs // 最高分先排在前面，確定名次  \n→ Step 4: 建立空陣列 answer 長度 n // 用於儲存最終排名字串  \n→ Decision: 從 pairs 的第一項開始遍歷，並為每個位置 i 計算 rank  \n    Yes → SubStep 1: rank = i + 1 // 名次（因為索引從 0 開始）  \n    Yes → SubStep 2: If rank == 1? // 判斷是否為金牌  \n        Yes → SubStep 2a: answer[pairs[i].index] = \"Gold Medal\" // 金牌輸出  \n        No  → Decision: rank == 2? // 判斷是否為銀牌  \n            Yes → SubStep 2b: answer[pairs[i].index] = \"Silver Medal\" // 銀牌輸出  \n            No  → Decision: rank == 3? // 判斷是否為銅牌  \n                Yes → SubStep 2c: answer[pairs[i].index] = \"Bronze Medal\" // 銅牌輸出  \n                No  → SubStep 2d: answer[pairs[i].index] = str(rank) // 其他名次輸出數字  \n→ Step 5: 回傳 answer // 完成所有選手的排名結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Solution:\n    def findRelativeRanks(self, score):\n        if not score:\n            return []\n        # 將分數按降序排序，取得排名順序\n        sorted_scores = sorted(score, reverse=True)\n        rank_map = {}\n        for i, s in enumerate(sorted_scores):\n            if i == 0:\n                rank_map[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_map[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_map[s] = \"Bronze Medal\"\n            else:\n                rank_map[s] = str(i + 1)\n        # 根據原始順序還原排名\n        return [rank_map[s] for s in score]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，格式為類似 [5,4,3,2,1] 的字串\n    data = sys.stdin.read().strip()\n    if not data:\n        # 若沒有輸入，直接結束\n        sys.exit(0)\n    # 使用 ast.literal_eval 安全解析輸入字串成 list\n    score_list = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.findRelativeRanks(score_list)\n\n    # 使用 json.dumps 產生符合範例的雙引號格式，並去除預設逗號後的空格\n    output = json.dumps(result, separators=(\",\", \":\"))\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for sorting string by decreasing frequency. Steps: count frequencies, sort characters by freq descending, build result string. Use dictionary. Need to consider duplicates. Could use array of pairs sorted. Use stable sorting? Not needed.\n\nWe need to output step-by-step with arrow lines and comments. Must not output actual code. Use \"Start\", \"End\". Use \"Decision:\" if needed. But algorithm is straightforward. Could include a decision for when frequencies equal? Might not need. We can include \"Decision: If char frequency ties?\" but not necessary.\n\nWe should produce multiple steps: input string, count freq, convert to list of (char, freq), sort descending, build string by repeating char freq times.\n\nWe can produce loops with pseudo loops. Use \"Loop: for each char in string\".\n\nUse arrow: \"→\". We need each line preceded by \"虛擬碼步驟\". But not necessary, we just output code lines. The format: each line \"虛擬碼步驟 // 解釋\". So produce lines like \"Start // 程式開始\". Next: \"→ Input s // 取得輸入字串\". Next: \"→ Initialize freq_map // 建立字元頻率映射\". Then loop: \"→ For each char c in s // 逐字遍歷\". Inside: \"→ freq_map[c] += 1 // 更新頻率\". Then \"→ Convert freq_map to list of pairs // 轉成列表方便排序\". Then \"→ Sort pairs by freq descending // 依頻率降序排列\". Then \"→ Initialize result string // 準備結果\". Then loop over sorted pairs: \"→ For each (char, freq) in sorted_pairs // 逐對處理\". Inside: \"→ Append char * freq to result // 將字元重複 freq 次\". After loop: \"→ Return result // 結果\". End.\n\nWe may not need decisions. But could include \"Decision: If sorted list empty?\" but not needed.\n\nWe should ensure each line uses \"→\" or \"Start\". No indentation? In example, indent shows nested decision branches. We can just linear flow. Might include a \"Decision:\" if freq_map empty. But okay.\n\nWe should output all lines. Provide explanations in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 取得輸入字串  \n→ Initialize freq_map // 建立字元頻率映射表  \n→ For each char c in s // 逐字遍歷字串  \n    → freq_map[c] += 1 // 將字元頻率加 1  \n→ Convert freq_map to list_of_pairs // 轉成可排序的 (字元,頻率) 列表  \n→ Sort list_of_pairs by freq descending // 依頻率降序排列，頻率相同時可任意順序  \n→ Initialize result // 準備結果字串  \n→ For each (char, freq) in list_of_pairs // 逐對處理已排序的項目  \n    → Append char repeated freq times to result // 把字元連續寫入結果  \n→ Return result // 回傳排序後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        # 計算每個字元的頻率\n        freq = Counter(s)\n        # 依頻率從高到低排序，若頻率相同可任意順序\n        sorted_chars = freq.most_common()\n        # 產生結果字串\n        return ''.join(char * cnt for char, cnt in sorted_chars)\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取出引號內的字串\n    try:\n        # 若格式為 s = \"...\"\n        start = data.index('\"')\n        end = data.rindex('\"')\n        s = data[start+1:end]\n    except ValueError:\n        # 若直接輸入字串本身\n        s = data\n    # 呼叫解法並輸出結果\n    result = Solution().frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "success": true,
          "output": "eetr"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "success": true,
          "output": "cccaaa"
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "bbAa"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Algorithm: build trie of reversed words, for each word, split into prefix/suffix, check palindrome suffix/prefix, use trie to find matches. Steps: build trie nodes map char to child, store index. Then for each word index i, iterate splits, if suffix palindrome, search prefix reversed in trie for j != i, add pair. Similarly if prefix palindrome and not empty, search suffix reversed. Use dictionary mapping. Complexity linear.\n\nWe need to produce pseudo-code line by line with explanations. Should include Start, End, Decision etc. We'll produce lines describing building trie, then for each word scanning splits. Use arrow. Use decision. Ensure unique pairs. Also use visited set. Provide pseudo steps only. Let's craft.\n\nWe'll create structures: TrieNode with children dict, idx -1. Build function. Then main loop.\n\nWe'll include comments in Chinese. Ensure each line is virtual code with explanation. We'll keep each line simple. Use arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 TrieNode // 建立樹結構節點\n→ Decision: Node.hasChildren? // 以便後續操作\n    Yes → No  // 這裡不需要特殊處理，直接用字典存 child\n\n→ Step 2: 建立根節點 root = TrieNode() // 初始化 Trie\n\n→ Step 3: 建立字典 reverseIndex = {} // 方便快速查找索引\n\n→ Step 4: For each word with index i in words\n    → Decision: i < words.length? // 遍歷所有單字\n        Yes → Step 5: 插入 reversed(word) 到 Trie\n            → Step 5a: current = root\n            → For each char c in reverse(word)\n                → Decision: current.children[c] exists?\n                    Yes → current = current.children[c]\n                    No  → current.children[c] = TrieNode(); current = current.children[c]\n            → current.idx = i // 將索引存於終端節點\n            → Step 5b: reverseIndex[word] = i // 對應表\n        No  → // 完成 Trie 建構\n\n→ Step 6: 建立結果 list pairs = []\n\n→ Step 7: For each word with index i in words\n    → Step 7a: For split position k from 0 to len(word)\n        → Step 7b: prefix = word[:k]\n        → Step 7c: suffix = word[k:]\n        → Decision: isPalindrome(suffix)? // 檢查後半部分是否為回文\n            Yes →\n                → Step 7b1: target = reverse(prefix)\n                → Step 7b2: 查詢 Trie 以找到索引 j\n                    → Decision: Trie contains target?\n                        Yes →\n                            → Step 7b2a: j = index of target in Trie\n                            → Decision: j != i? // 避免自我配對\n                                Yes → Step 7b3: pairs.append([i, j])\n                                No  → // 跳過\n                        No  → // 無對應\n            No  → // 省略\n        → Decision: k > 0 and isPalindrome(prefix)? // 避免空前綴重複\n            Yes →\n                → Step 7c1: target = reverse(suffix)\n                → Step 7c2: 查詢 Trie 以找到索引 j\n                    → Decision: Trie contains target?\n                        Yes →\n                            → Step 7c2a: j = index of target in Trie\n                            → Decision: j != i?\n                                Yes → Step 7c3: pairs.append([j, i])\n                                No  → // 跳過\n                        No  → // 無對應\n            No  → // 省略\n\n→ Step 8: Return pairs // 結果輸出\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        \"\"\"\n        尋找所有可以拼成回文的 (i, j) 對。\n        利用字典將單字的逆序映射到索引，進而在 O(總字長) 時間內完成。\n        \"\"\"\n        # 建立逆序單字到索引的映射\n        rev_index = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            n = len(word)\n            # 對每個分割位置 j (0 ~ n) 產生前綴和後綴\n            for j in range(n + 1):\n                prefix, suffix = word[:j], word[j:]\n\n                # 情況 1：後綴是回文，前綴的逆序存在於字典中\n                if suffix == suffix[::-1] and prefix in rev_index:\n                    j_idx = rev_index[prefix]\n                    if j_idx != i:\n                        res.append([i, j_idx])\n\n                # 情況 2：前綴是回文，且 j != 0（避免重複空前綴）\n                #      同時後綴的逆序存在於字典中\n                if j != 0 and prefix == prefix[::-1] and suffix in rev_index:\n                    j_idx = rev_index[suffix]\n                    if j_idx != i:\n                        res.append([j_idx, i])\n\n        return res\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 解析輸入為 Python 列表\n    # 允許輸入形式類似 'words = [\"abcd\",\"dcba\"]' 或直接列表字面量\n    try:\n        if '=' in raw_input:\n            # 只取等號右邊的部分\n            raw_input = raw_input.split('=', 1)[1].strip()\n        words = ast.literal_eval(raw_input)\n    except Exception as e:\n        print(f\"輸入格式錯誤: {e}\")\n        return\n\n    solution = Solution()\n    pairs = solution.palindromePairs(words)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": true,
          "output": "[[0, 1], [1, 0], [3, 2], [2, 4]]"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, no real code. Need to produce algorithm for lexicographic order numbers 1..n, with O(n) time, O(1) space. That's essentially the \"lexicographical numbers\" problem. We can implement DFS traversal of a virtual tree. Since we cannot use extra space, we can just output sequentially using iteration with next number calculation.\n\nThe algorithm: start at 1, while count <= n, output current. Then if current*10 <= n: current*=10; else while current%10==9 or current+1 > n: current//=10; current+=1. This iterates lexicographically.\n\nSo we will produce pseudocode line by line. Let's produce steps with virtual code. Use Start, End, Decision, etc. Let's craft steps:\n\nStart // Program starts\n→ Step 1: input n // Read upper bound\n→ Step 2: current ← 1 // Initialize current number\n→ Step 3: count ← 0 // Initialize output counter\n→ Decision: 如果 count < n? // Check if we need more numbers\n    Yes → Step 4: 輸出 current // Output current number\n    Yes → Step 5: count ← count + 1 // Increment counter\n    Yes → Decision: 如果 current * 10 <= n? // Try go deeper in tree\n        Yes → Step 6: current ← current * 10 // Go to first child\n        No → Decision: 如果 current % 10 = 9 or current + 1 > n? // Cannot go deeper, need to backtrack\n            Yes → Step 7: current ← current // 從現在的節點往右移動 (but need while loop)\n            ... we need loops: maybe use while loops as steps.\n\nBut need to produce linear algorithm steps. Use while loops inside.\n\nWe can produce pseudocode with loops.\n\nLet's structure:\n\nStart\n→ Input n\n→ current ← 1\n→ output ← []\n→ While count < n:\n    → Output current\n    → count ← count + 1\n    → If current * 10 <= n:\n        → current ← current * 10\n      Else:\n        → While current % 10 == 9 or current + 1 > n:\n            → current ← current / 10\n        → current ← current + 1\n\nEnd\n\nBut we must maintain O(1) space, so output is not stored; we just output directly. So we can just \"Print current\". So we don't need output array.\n\nLet's produce pseudocode steps using Start, Decision, etc. We need to use arrow \"→\" for steps.\n\nLet's produce each line with explanation.\n\nAlso we need to abide by \"逐行輸出\" and each line must contain \"虛擬碼步驟\" + \" \" + \"// 解釋\". So each line: e.g., \"Start // 程式開始執行\".\n\nWe must not output real code; just pseudocode steps. So use minimal code-like syntax.\n\nThus produce:\n\nStart // 程式開始\n→ Step 1: 輸入 n // 讀入最大值\n→ Step 2: current ← 1 // 設定首個要輸出的數字\n→ Step 3: count ← 0 // 初始化已輸出數量\n→ Decision: 如果 count < n? // 還未輸出完所有數字\n    Yes → Step 4: 輸出 current // 印出目前數字\n    Yes → Step 5: count ← count + 1 // 取得下一個待輸出數字\n    Yes → Decision: 如果 current * 10 ≤ n? // 先嘗試進入更深層的子節點\n        Yes → Step 6: current ← current * 10 // 跳到子節點的第一個數字\n        No → Decision: 如果 current % 10 = 9 或 current + 1 > n? // 無法進一步向左，需回溯或右移\n            Yes → Step 7: current ← current // (此處實際為回溯過程開始)\n            ... but we need while loop: while current % 10 == 9 or current + 1 > n: current ← current / 10\n            Then current ← current + 1\n            No → Step 8: current ← current + 1 // 直接右移到下一個兄弟節點\n    No → ... ??? Actually the decision chain should end and loop back to Decision: count < n? So we need to structure loops.\n\nWe can restructure:\n\nStart\n→ Input n\n→ current ← 1\n→ count ← 0\n→ While count < n:\n    → Output current\n    → count ← count + 1\n    → If current * 10 <= n:\n        → current ← current * 10\n    → Else:\n        → While current % 10 == 9 OR current + 1 > n:\n            → current ← current / 10\n        → current ← current + 1\n\nEnd\n\nWe'll convert to step lines.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 讀入上限\n→ Step 2: current ← 1 // 先從 1 開始\n→ Step 3: count ← 0 // 已輸出數量\n→ Decision: 如果 count < n? // 還有數字要輸出\n    Yes → Step 4: 輸出 current // 印出目前數字\n    Yes → Step 5: count ← count + 1 // 更新已輸出數量\n    Yes → Decision: 如果 current * 10 ≤ n? // 可以往子節點進一步\n        Yes → Step 6: current ← current * 10 // 進入子節點\n        No → Decision: 如果 current % 10 = 9 或 current + 1 > n? // 不能再進一步\n            Yes → Step 7: current ← current // 進入回溯循環\n            ... This is messy. Instead maybe we break into while loops. But each line must be a step. We can include a nested while as a step.\n\nMaybe we write a separate step: \"→ Step 7: While current % 10 = 9 或 current + 1 > n: current ← current / 10 // 回溯到可右移的節點\". But that line would represent a while loop; we can include comment.\n\nOk.\n\nLet's structure more cleanly:\n\nStart\n→ Input n\n→ current ← 1\n→ count ← 0\n→ While count < n:\n    → Output current\n    → count ← count + 1\n    → If current * 10 ≤ n:\n        → current ← current * 10\n      Else:\n        → While current % 10 = 9 或 current + 1 > n:\n            → current ← current / 10\n        → current ← current + 1\nEnd\n\nThus we produce lines like:\n\nStart // 程式開始\n→ Step 1: 輸入 n // 讀入上限\n→ Step 2: current ← 1 // 初始化首個數字\n→ Step 3: count ← 0 // 已輸出數量\n→ Decision: 如果 count < n? // 判斷是否還有數字要輸出\n    Yes → Step 4: 輸出 current // 印出目前數字\n    Yes → Step 5: count ← count + 1 // 迭代已輸出數量\n    Yes → Decision: 如果 current * 10 ≤ n? // 是否能進一步深度遍歷\n        Yes → Step 6: current ← current * 10 // 前進到子節點\n        No → Decision: 如果 current % 10 = 9 或 current + 1 > n? // 無法進一步\n            Yes → Step 7: current ← current // 進入回溯環節（實際為 while 迴圈）\n            ... Actually we need to express while. We'll create a step for while loop: \"→ Step 7: While current % 10 = 9 或 current + 1 > n: current ← current / 10 // 回溯到能右移的節點\". \nThen \"→ Step 8: current ← current + 1 // 往右移動到下一個兄弟節點\".\n\nBut the decision chain is complicated. We can instead express outer loop as while. So we produce:\n\nStart\n→ Step 1: 輸入 n // 讀入上限\n→ Step 2: current ← 1 // 初始化\n→ Step 3: count ← 0 // 计数\n→ Decision: 如果 count < n? // 主循環條件\n    Yes → Step 4: 輸出 current\n    Yes → Step 5: count ← count + 1\n    Yes → Decision: 如果 current * 10 ≤ n?\n        Yes → Step 6: current ← current * 10\n        No → Step 7: While current % 10 = 9 或 current + 1 > n: current ← current / 10 // 回溯\n        No → Step 8: current ← current + 1\n    No → End\n\nBut the indentation is confusing. It's okay as long as each line is separate.\n\nWe need to keep each line as single step, not nested within other steps. So we need to linearize.\n\nAlternate: Write algorithm as:\n\nStart\n→ Input n\n→ current ← 1\n→ count ← 0\n→ While count < n:\n    → Output current\n    → count ← count + 1\n    → If current * 10 ≤ n:\n        → current ← current * 10\n      Else:\n        → While current % 10 = 9 或 current + 1 > n:\n            → current ← current / 10\n        → current ← current + 1\nEnd\n\nNow each line:\n\n1. Start // 程式開始執行\n2. → Step 1: 輸入 n // 讀入上限值\n3. → Step 2: current ← 1 // 初始從 1 開始\n4. → Step 3: count ← 0 // 追蹤已輸出數量\n5. → Decision: 如果 count < n? // 主迴圈是否仍有數字要輸出\n    Yes → Step 4: 輸出 current // 印出目前數字\n    Yes → Step 5: count ← count + 1 // 增加已輸出計數\n    Yes → Decision: 如果 current * 10 ≤ n? // 能否往子節點深入\n        Yes → Step 6: current ← current * 10 // 進入子節點\n        No → Step 7: While current % 10 = 9 或 current + 1 > n: current ← current / 10 // 回溯到可右移的節點\n        No → Step 8: current ← current + 1 // 右移到下一個兄弟節點\n    No → End // 所有數字已輸出\n\nBut need each line individually, not nested. Might be okay. But they want each line has \"虛擬碼步驟\" and \"解釋\". So maybe easier: just produce sequential steps:\n\nStart // 程式開始\n→ Step 1: 輸入 n // 讀入上限\n→ Step 2: current ← 1 // 初始化從 1 開始\n→ Step 3: count ← 0 // 初始化已輸出數量\n→ Decision: count < n? // 仍需輸出?\n    Yes → Step 4: 輸出 current // 印出\n    Yes → Step 5: count ← count + 1 // 更新\n    Yes → Decision: current * 10 ≤ n? // 可進一步深度?\n        Yes → Step 6: current ← current * 10 // 深入子節點\n        No → Step 7: While current % 10 = 9 或 current + 1 > n: current ← current / 10 // 回溯\n        No → Step 8: current ← current + 1 // 右移\n    No → End\n\nBut this uses nested Decision with Yes/No. It's okay.\n\nHowever, the while loop is expressed as a step. Maybe they want to break each step.\n\nSimplify: Provide algorithm using while loop as steps; it's okay to have a line that says \"While current % 10 = 9 或 current + 1 > n: current ← current / 10\". That is a step.\n\nLet's produce final answer accordingly.\n\nAlso note O(1) space: only using variables.\n\nNow produce output accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 讀入上限值  \n→ Step 2: current ← 1 // 初始從 1 開始  \n→ Step 3: count ← 0 // 已輸出數量計數器  \n→ Decision: count < n? // 是否還有數字需要輸出？  \n    Yes → Step 4: 輸出 current // 印出目前數字  \n    Yes → Step 5: count ← count + 1 // 更新已輸出數量  \n    Yes → Decision: current * 10 ≤ n? // 能否往子節點更深？  \n        Yes → Step 6: current ← current * 10 // 前往子節點的第一個數字  \n        No → Step 7: While current % 10 = 9 或 current + 1 > n: current ← current / 10 // 回溯到能右移的節點  \n        No → Step 8: current ← current + 1 // 右移到下一個兄弟節點  \n    No → End // 所有數字已輸出，程式結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"Return numbers 1..n in lexicographical order.\"\"\"\n    result = []\n    current = 1          # start from 1\n    count = 0            # how many numbers have been output\n\n    while count < n:\n        result.append(current)\n        count += 1\n\n        if current * 10 <= n:\n            # go deeper to the first child\n            current *= 10\n        else:\n            # cannot go deeper: backtrack until we can move to the next sibling\n            while current % 10 == 9 or current + 1 > n:\n                current //= 10\n            current += 1\n\n    return result\n\ndef main():\n    data = sys.stdin.read()\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group())\n    result = lexical_order(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for regex matching with '.' and '*' support, entire string coverage. We'll output line by line, each line has \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Provide start, steps, decision, etc. Should not output actual code, just pseudocode. Use structure.\n\nWe need to design algorithm. Typical approach: dynamic programming DP or recursion with memoization. Let's produce DP solution: define DP[i][j] whether s[i:] matches p[j:].\n\nSimpler pseudocode: Start, compute lengths, create 2D boolean DP array of size (len(s)+1) x (len(p)+1). Initialize DP[len(s)][len(p)] = true. Iterate from end to start. For each i from len(s) down to 0: for j from len(p)-1 down to 0: compute firstMatch = (i < len(s)) && (p[j]==s[i] or p[j]=='.'). Then if (j+1 < len(p) && p[j+1]=='*'): DP[i][j] = firstMatch && DP[i+1][j] OR DP[i][j+2] ??? Wait: standard recurrence: DP[i][j] = firstMatch && DP[i+1][j+2] OR firstMatch && DP[i+1][j] OR DP[i][j+2]? Actually the usual DP uses: if p[j+1]=='*': DP[i][j] = DP[i][j+2] || (firstMatch && DP[i+1][j]) else: DP[i][j] = firstMatch && DP[i+1][j+1]. We'll implement accordingly.\n\nAt end return DP[0][0].\n\nWe produce pseudocode with loops and decisions. Also explain steps.\n\nLet's craft lines:\n\nStart // Start algorithm\n→ Step 1: Set m = length of s, n = length of p // 获得输入长度\n→ Step 2: Create 2D boolean array dp of size (m+1) x (n+1) // dp[i][j]表示s[i:]是否匹配p[j:]\n→ Step 3: Initialize all dp values to false // 默认不匹配\n→ Step 4: Set dp[m][n] = true // 空字符串匹配空模式\n→ Step 5: For i from m down to 0: // 逐行处理字符串索引\n    → Decision: If i == m? // 当i为字符串尾部\n        Yes → Step 5a: For j from n-1 down to 0: // 处理模式剩余部分\n            → Decision: If (j+1 < n && p[j+1]=='*')? // 模式中出现 * 之后\n                Yes → Step 5a1: dp[i][j] = dp[i][j+2] // * 表示零次\n                No  → Step 5a2: dp[i][j] = false // 不能匹配\n        No  → Step 5b: For j from n-1 down to 0: // 普通循环\n            → Step 5b1: firstMatch = (p[j]==s[i] or p[j]=='.') // 检查首字符是否匹配\n            → Decision: If (j+1 < n && p[j+1]=='*')? // 下一字符为 *\n                Yes → Step 5b1a: dp[i][j] = dp[i][j+2] // * 表示零次\n                Yes → Step 5b1b: dp[i][j] = dp[i][j+2] OR (firstMatch AND dp[i+1][j]) // * 表示一次或多次\n                No  → Step 5b1c: dp[i][j] = firstMatch AND dp[i+1][j+1] // 普通匹配\n→ Step 6: Return dp[0][0] // 判断完整匹配结果\n\nBut the structure may be messy. We can simplify: We'll have a nested loop for i from m to 0, j from n-1 to 0. Inside we compute firstMatch etc.\n\nLet's craft lines accordingly:\n\nStart // 程式開始執行\n→ Step 1: Let m = length of s, n = length of p // 取得輸入字串長度\n→ Step 2: Create 2D boolean array dp of size (m+1) x (n+1) // dp[i][j] 表示 s[i:] 是否與 p[j:] 匹配\n→ Step 3: Initialize all dp[i][j] = false // 預設不匹配\n→ Step 4: Set dp[m][n] = true // 空字串匹配空模式\n→ Step 5: For i from m down to 0: // 反向遍歷字串位置\n    → Decision: If i == m? // 字串已到結尾\n        Yes → Step 5a: For j from n-1 down to 0: // 只考慮模式剩餘\n            → Decision: If (j+1 < n && p[j+1] == '*')? // 模式中有 * 後綴\n                Yes → Step 5a1: dp[i][j] = dp[i][j+2] // * 代表 0 次\n                No  → Step 5a2: dp[i][j] = false // 無法匹配\n        No → Step 5b: For j from n-1 down to 0: // 常規處理\n            → Step 5b1: firstMatch = (p[j] == s[i] or p[j] == '.') // 判斷首字符是否匹配\n            → Decision: If (j+1 < n && p[j+1] == '*')? // 下一字符為 *\n                Yes → Step 5b1a: dp[i][j] = dp[i][j+2] // * 代表 0 次\n                Yes → Step 5b1b: dp[i][j] = dp[i][j+2] OR (firstMatch AND dp[i+1][j]) // * 代表 1 次以上\n                No  → Step 5b1c: dp[i][j] = firstMatch AND dp[i+1][j+1] // 普通匹配\n→ Step 6: Return dp[0][0] // 判斷整個字串是否完全匹配\n\nBut we can simplify the decision for i==m case; we can just handle inside loop: for i from m down to 0, j from n-1 down to 0: compute firstMatch only if i<m. When i==m, firstMatch false, and dp[i][j] will rely on pattern with * representing zero times.\n\nLet's produce simpler pseudocode:\n\nStart // 程式開始執行\n→ Step 1: m = len(s), n = len(p) // 取得輸入長度\n→ Step 2: dp[0..m][0..n] = false // 初始化 DP 表\n→ Step 3: dp[m][n] = true // 空字串匹配空模式\n→ Step 4: For i from m down to 0:\n    → For j from n-1 down to 0:\n        → firstMatch = (i < m) AND (p[j] == s[i] OR p[j] == '.') // 判斷首字符是否匹配\n        → Decision: If (j+1 < n AND p[j+1] == '*')? // 下一個字符為 *\n            Yes → dp[i][j] = dp[i][j+2] OR (firstMatch AND dp[i+1][j]) // * 代表 0 次 或 1 次以上\n            No  → dp[i][j] = firstMatch AND dp[i+1][j+1] // 普通匹配\n→ Step 5: Return dp[0][0] // 判斷整個字串是否匹配\n\nThis is cleaner.\n\nAdd explanation comments for each line. Use arrow lines with indentation for loops, decisions. Use the syntax: \"→ Step ...\" and indentation for nested lines. Use \"Decision:\" lines with Yes→ and No→.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m = len(s) , n = len(p) // 取得輸入字串與模式的長度  \n→ Step 2: dp[0..m][0..n] = false // 建立 (m+1)×(n+1) 的布林 DP 表，預設皆為 false  \n→ Step 3: dp[m][n] = true // 空字串與空模式相符  \n→ Step 4: For i from m down to 0: // 從字串結尾向前遍歷  \n    → For j from n-1 down to 0: // 逐字元處理模式  \n        → firstMatch = (i < m) AND (p[j] == s[i] OR p[j] == '.') // 判斷 s[i] 是否與 p[j]（或 .）匹配  \n        → Decision: (j+1 < n AND p[j+1] == '*')? // 下一個模式字元是否為 '*'  \n            Yes → dp[i][j] = dp[i][j+2] OR (firstMatch AND dp[i+1][j]) // '*' 代表 0 次或 1 次以上  \n            No  → dp[i][j] = firstMatch AND dp[i+1][j+1] // 普通字符匹配，遞進至下一對位置  \n→ Step 5: Return dp[0][0] // 判斷整個字串是否完全匹配模式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # handle patterns that can match an empty string\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]\n\ndef parse_input(text: str):\n    # extract quoted strings, e.g., 's = \"aa\", p = \"a\"'\n    parts = re.findall(r'\"([^\"]*)\"', text)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # fallback: space separated\n    tokens = text.strip().split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s, p = parse_input(data)\n    result = Solution().isMatch(s, p)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for coin change combinations problem. We must produce steps line by line with explanation. Use Start, End, Decision, etc. Use arrow. Each line: \"虛擬碼步驟 // 解釋\". Use \"→\" to denote steps. Provide DP solution: 1D array dp[amount+1] initial dp[0]=1; iterate over coins, for each coin iterate amount from coin to target, dp[j]+=dp[j-coin]. At end return dp[amount]. Also handle zero amount.\n\nWe'll produce virtual steps: Start, Step 1: initialize dp array, Step 2: set dp[0]=1, Step 3: iterate each coin, Step 3a: for j from coin to amount, dp[j] += dp[j-coin], etc. Decision: if amount<0? but given amount integer non-negative? Could include check.\n\nWe'll produce output lines with arrows: \"Start // 程式開始執行\". \"→ Step 1: 建立長度為 amount+1 的整數陣列 dp 且全部初始化為 0 // 初始化 DP 陣列\" etc.\n\nWe must not output actual code. Just pseudo steps.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立長度為 amount+1 的整數陣列 dp 且全部初始化為 0 // 初始化 DP 陣列，dp[i] 代表能組成金額 i 的組合數  \n→ Step 2: 設定 dp[0] = 1 // 只有一種方式組成金額 0，即不拿任何硬幣  \n→ Step 3: Decision: 如果 coins 陣列為空? // 檢查是否有硬幣可用  \n  Yes → Step 4: Return 0 // 沒有硬幣無法組成任何非零金額，直接回傳 0  \n  No  → Step 5: 進入硬幣迴圈 // 有硬幣可用，開始動態規劃  \n→ Step 5: For each coin in coins: // 逐一處理每種硬幣  \n  → Decision: coin > amount? // 若硬幣面額大於目標金額，可略過  \n   Yes → Continue to next coin // 跳過此硬幣  \n   No  → Step 6: For j from coin to amount: // 從該硬幣面額開始累加到目標金額  \n    → Step 7: dp[j] = dp[j] + dp[j - coin] // 將使用此硬幣後能組成 j 的方式加到現有計數  \n→ Step 8: Decision: amount < 0? // 目標金額為負數（理論上不會發生）  \n  Yes → Step 9: Return 0 // 直接回傳 0  \n  No  → Step 10: Return dp[amount] // 回傳能組成金額 amount 的組合數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def change(self, amount, coins):\n        # dp[i] = number of ways to make amount i\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n        return dp[amount]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 期望的輸入格式類似 \"5, [1,2,5]\"\n    amount_str, coins_str = data.split(',', 1)\n    amount = int(amount_str.strip())\n    coins = ast.literal_eval(codestring := coins_str.strip())\n    solution = Solution()\n    result = solution.change(amount, coins)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. We need to consider input string s. Count segments defined as contiguous sequence of non-space characters. So algorithm: iterate through characters, keep flag insideSegment. When encountering non-space and not insideSegment, increment count and set insideSegment true. When encountering space, set insideSegment false. End. Output count.\n\nWe produce line by line. Use Start, Decision, etc.\n\nWe need to not output real code but virtual code with arrow.\n\nMake steps like:\n\nStart // program start\n→ Step 1: Set count = 0 // 初始化計數\n→ Step 2: Set inSegment = false // 標記是否在段中\n→ Step 3: For each char c in s // 逐字元處理\n→ Decision: If c is not space? // 判斷是否為非空白\n    Yes → Decision: If inSegment is false? // 是否已經在段中\n        Yes → Step 4: count = count + 1 // 新段開始，計數加一\n        No  → Step 5: // 已在段中，繼續\n    No  → Step 6: inSegment = false // 遇空白，結束段\n→ Step 7: End for\n→ Step 8: Output count // 返回結果\n\nBut we need to use \"Decision:\" and arrows properly. And each line includes explanation after //.\n\nAlso we need to use arrows \"→\" before each step.\n\nProbably need to structure nested decisions.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 設定 count = 0 // 初始化段數計數\nLine 3: → Step 2: 設定 inSegment = false // 標記是否在段中\nLine 4: → Step 3: 對每個字元 c 進行迭代 // 遍歷字串\nLine 5: → Decision: c 是否為非空白? // 判斷字元是否為字母或符號\nLine 6:     Yes → Decision: inSegment 為 false? // 檢查是否已經進入段\nLine 7:         Yes → Step 4: count = count + 1 // 新段開始，計數加一\nLine 8:         No  → // 已在段中，無需改變計數\nLine 9:     No  → Step 5: inSegment = false // 遇空白，結束任何正在進行的段\nLine 10: → Step 6: inSegment = true // 若是非空白且未在段中，標記為已進入段\nWait: Actually Step 6: should set inSegment = true if non-space and after check. So we need to place inside Yes branch after count step: set inSegment = true. Let's reorganize.\n\nBetter structure:\n\nDecision: c is not space?\n    Yes → Decision: inSegment = false?\n        Yes → Step 4: count++ // start new segment\n            → Step 5: inSegment = true // mark as inside segment\n        No  → // already inside, nothing else\n    No  → Step 6: inSegment = false // end segment\n\nSo we need to include step 5 inside Yes branch. So we need to indent accordingly.\n\nLet's rewrite lines:\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 設定 count = 0 // 初始化段數計數\nLine 3: → Step 2: 設定 inSegment = false // 標記是否在段中\nLine 4: → Step 3: 對每個字元 c 進行迭代 // 遍歷字串\nLine 5: → Decision: c 是否為非空白? // 判斷字元是否為字母或符號\nLine 6:     Yes → Decision: inSegment 是否為 false? // 檢查是否已經在段中\nLine 7:         Yes → Step 4: count = count + 1 // 新段開始，計數加一\nLine 8:             → Step 5: inSegment = true // 標記已進入段\nLine 9:         No  → // 已在段中，繼續不變\nLine 10:     No  → Step 6: inSegment = false // 遇空白，結束任何正在進行的段\nLine 11: → Step 7: // 迭代結束\nLine 12: → Step 8: 輸出 count // 返回段數\n\nBut we need each line must include \"虛擬碼步驟\" + space + explanation. And use arrow symbol \"→\" before each step. Indentation can be with spaces.\n\nLet's ensure arrow usage: The example uses \"→\" at beginning of each step. Indent decisions with spaces before arrow maybe. They use \"→ Decision:\" then indent Yes → Step. We'll follow that style.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 count = 0 // 初始化段數計數\n→ Step 2: 設定 inSegment = false // 標記是否在段中\n→ Step 3: 對每個字元 c 進行迭代 // 遍歷字串\n→ Decision: c 是否為非空白? // 判斷字元是否為字母或符號\n    Yes → Decision: inSegment 是否為 false? // 檢查是否已經在段中\n        Yes → Step 4: count = count + 1 // 新段開始，計數加一\n            → Step 5: inSegment = true // 標記已進入段\n        No  → // 已在段中，繼續不變\n    No  → Step 6: inSegment = false // 遇空白，結束任何正在進行的段\n→ Step 7: // 迭代結束\n→ Step 8: 輸出 count // 返回段數\nEnd // 程式執行結束\n\nNeed End line. Good.\n\nMake sure each line uses \"虛擬碼步驟\" text. The step names \"Step X\" etc. Provide explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 count = 0 // 初始化段數計數  \n→ Step 2: 設定 inSegment = false // 標記是否在段中  \n→ Step 3: 對每個字元 c 進行迭代 // 遍歷字串  \n→ Decision: c 是否為非空白? // 判斷字元是否為字母或符號  \n  Yes → Decision: inSegment 是否為 false? // 檢查是否已經在段中  \n    Yes → Step 4: count = count + 1 // 新段開始，計數加一  \n      → Step 5: inSegment = true // 標記已進入段  \n    No → // 已在段中，繼續不變  \n  No  → Step 6: inSegment = false // 遇空白，結束任何正在進行的段  \n→ Step 7: // 迭代結束  \n→ Step 8: 輸出 count // 返回段數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countSegments(self, s: str) -> int:\n        \"\"\"計算字串中非空白字符的連續區塊數量\"\"\"\n        # 以單一空格切分，過濾掉空字串即可得到段數\n        return len([segment for segment in s.split(' ') if segment])\n\ndef main() -> None:\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取得實際字串\n    # 若輸入中包含 \"s = \\\"...\\\"\" 的形式，則抽取雙引號中的內容\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n\n    solution = Solution()\n    result = solution.countSegments(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for given integer n represented as string. Find smallest base k >= 2 such that representation of n in base k consists only of '1's digits. This is known problem: given n string possibly large (up to 64-bit maybe). Find smallest base. Known solution: if n is all 1s in base n-1? Wait. For representation all 1's: n = (k^m-1)/(k-1) where m >= 2 (since at least two digits of 1). Solve for m and k. For m from largest possible downwards (log2(n)), try to find integer k via binary search. If no such base, answer is n-1 (since representation of n in base n-1 is '11'). But we want smallest base; we search for minimal k. The algorithm: For m from floor(log2(n)) down to 2, find integer k satisfying k^m-1)/(k-1)=n. Use binary search k from 2 to n^(1/(m-1)). Actually k is between 2 and n^(1/(m-1)). Compute using big integer to avoid overflow.\n\nEdge case: n string length 1? For n = \"1\" maybe no base. But assume n>=2.\n\nWe'll produce virtual code lines following requested format. Each step with explanation. Provide Start, End, Decision, etc. Use arrow →.\n\nLet's craft steps:\n\nStart\n\n→ Step 1: Convert input string n_str to integer N using big integer // read n\n\n→ Step 2: If N <= 3, output N-1 // minimal base for 2 and 3\n\n→ Decision: Is N a power of 2? // maybe not needed but we can skip\n\nWe will compute maximum exponent m_max = floor(log2(N)) because for base 2, number of digits m = floor(log2(N))+1. So exponent m ranges from m_max down to 2.\n\n→ Step 3: Set ans = N-1 // default answer\n\n→ Decision: For m from m_max down to 2 // iterate exponents\n\nBut we need loop. We can represent loop as Decision maybe. Use Decision with Yes/No.\n\nBut maybe simpler: Use a loop pseudo-step: For m = m_max down to 2: // iterate exponents\n\nWithin loop: compute k using binary search between 2 and pow(N, 1/(m-1)).\n\nWe need sub-steps: compute low=2, high=pow(N, 1/(m-1)). Use big integer pow approximation.\n\n→ Step: Compute high as integer floor(pow(N, 1/(m-1))) + 1 // upper bound\n\n→ While low <= high: // binary search\n\n→ Decision: mid^m == N*(mid-1)+1? Wait formula: N = (mid^m - 1)/(mid-1). So mid^m - 1 == N*(mid-1). So check compare.\n\nBut we can compute sum = 1 + mid + mid^2 + ... + mid^(m-1). Use big integer accumulation with early break if >N.\n\nSimpler: compute value = 1, pow_mid=1; for i=1 to m-1: pow_mid *= mid; value += pow_mid; if value > N: break.\n\nIf value == N, found k=mid, set ans=mid and break out of loops.\n\nAfter loops, output ans.\n\nWe need to provide virtual code step-by-step. Each line with arrow.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Read input string n_str // 取得 n 的字串表示\n→ Step 2: Convert n_str to big integer N // 將字串轉為大整數\n→ Step 3: If N <= 3, Output N-1 and End // 特殊情況，最小基底即 N-1\n→ Step 4: Compute m_max = floor(log2(N)) + 1 // 最高可能的位數\n→ Step 5: ans = N-1 // 預設答案為 n-1（表示 '11'）\n→ Decision: For m from m_max down to 2? // 迭代可能的位數\n\nWe'll need to show loop: Use Decision for each m. Provide arrow.\n\nSimplify: Use loop step:\n\n→ Step 6: For m = m_max down to 2: // 逐一嘗試長度 m\n    → Step 6a: low = 2 // 最小基底\n    → Step 6b: high = floor(N^(1/(m-1))) + 1 // 上限基底\n    → While low <= high: // 二分搜尋\n        → Decision: Compute value of sum of geometric series with base mid // 檢查是否等於 N\n            ... etc\n\nBut we need each step on separate line with arrow. We'll need indentation maybe but not required.\n\nWe should output a clear algorithm.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 n_str // 取得 n 的字串表示  \n→ Step 2: 將 n_str 轉換成大整數 N // 方便後續計算  \n→ Decision: N <= 3? // 特殊情況，n 只能為 2 或 3  \n  Yes → Step 3: 輸出 N-1 並 End // n=2 → base 1（無效），最小基底為 1；n=3 → base 2  \n  No  → Step 4: 計算 m_max = floor(log2(N)) + 1 // n 在最小基底 2 下的最大位數  \n→ Step 5: ans = N-1 // 預設答案，表示 n 在 base N-1 時為 '11'  \n→ Decision: 迭代 m 從 m_max 降至 2  \n  Yes → For m = m_max downto 2: // 嘗試每一個可能的位數  \n    → Step 6a: low = 2 // 最小可能的基底  \n    → Step 6b: high = floor(N^(1/(m-1))) + 1 // 上限基底（保證 k^(m-1) <= N）  \n    → While low <= high: // 二分搜尋基底 k  \n      → Step 7a: mid = (low + high) // 2 // 取中間基底  \n      → Step 7b: sum = 1; term = 1; // 用於計算 1 + mid + … + mid^(m-1)  \n      → For i = 1 to m-1:  \n        → term *= mid  \n        → sum += term  \n        → If sum > N: Break // 超過則不可能  \n      → Decision: sum == N? // 判斷是否符合 n 的所有位皆為 1  \n        Yes → ans = mid; break 循環所有 m // 找到最小基底後結束搜尋  \n        No → If sum < N: low = mid + 1 else high = mid - 1 // 調整二分搜尋範圍  \n    → Step 8: // 迴圈結束，若已找到答案則已更新 ans  \n→ Step 9: 輸出 ans // 輸出最小 good base  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef smallest_good_base(n_str: str) -> str:\n    n = int(n_str)\n    if n <= 3:\n        return str(n - 1)\n\n    max_m = n.bit_length()  # maximum possible number of digits\n    for m in range(max_m, 1, -1):\n        low, high = 2, n - 1\n        while low <= high:\n            mid = (low + high) // 2\n            # Compute 1 + mid + mid^2 + ... + mid^(m-1) with early stop\n            total = 1\n            term = 1\n            for _ in range(1, m):\n                term *= mid\n                total += term\n                if total > n:\n                    break\n            if total == n:\n                return str(mid)\n            elif total < n:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return str(n - 1)\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the first sequence of digits (may be inside quotes)\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n_str = nums[0]\n    result = smallest_good_base(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the function: given integer n, return true if it's power of 3 else false. Should provide step-by-step virtual code lines with explanation. Use Start, End, Decision: etc.\n\nWe should cover negative n, zero. Implementation: if n <= 0 return false; else while n % 3 == 0: n/=3; if n==1 return true else false.\n\nBut in virtual code, we can also check if n == 1? Then return true; else if n%3 != 0 -> false; else loop. But easier: Decision on n <= 0? If Yes return false. Next loop while true? Use decision: while n%3==0? etc.\n\nWe must produce each line with comment. Use arrow for steps: Start, → Step 1: 取 n // get input n; but we might treat as argument.\n\nBetter: Step 1: Initialize current = n; // store n\n\n→ Decision: 如果 current <= 0? // negative or zero not power of 3\n\nYes → Step 2: Return false // not power\n\nNo → Decision: 如果 current == 1? // n is 1 (3^0)\n\nYes → Step 3: Return true // power of 3\n\nNo → Step 4: while current % 3 == 0 // divide by 3 until not divisible\n\n    → Step 5: current = current / 3\n\n    → Decision: 如果 current == 1? // reached 1\n\n        Yes → Step 6: Return true\n\n        No  → Decision: 如果 current % 3 == 0? // still divisible\n\n            Yes → 回到 Step 5 (loop) [but need to represent loop properly]. We can use loop arrow.\n\nSimplify: Use loop block: while current % 3 == 0: current = current / 3. After loop, Decision: current == 1? return true else false.\n\nRepresent loop: we can show arrow to loop label.\n\nLet's create lines:\n\nStart // 程式開始執行\n→ Step 1: current ← n // 將輸入 n 存入 current 變數\n→ Decision: 如果 current ≤ 0? // 檢查是否為非正數\n    Yes → Step 2: 返回 false // 非正數不可能是 3 的冪\n    No  → Decision: 如果 current = 1? // 3^0 = 1\n        Yes → Step 3: 返回 true // n 是 3 的冪\n        No  → Step 4: 開始除以 3 的循環 // 循環除以 3 直到不能整除\n            → Decision: 如果 current % 3 == 0? // 還能被 3 整除\n                Yes → Step 5: current ← current / 3 // 除以 3\n                No  → Step 6: 退出循環 // 完成除法循環\n→ Decision: 如果 current = 1? // 循環結束後檢查是否為 1\n    Yes → Step 7: 返回 true // 是 3 的冪\n    No  → Step 8: 返回 false // 不是 3 的冪\nEnd // 程式結束\n\nBut we need to be precise with loop: The loop should keep dividing until not divisible. In pseudocode we might have:\n\n→ Decision: current % 3 == 0?\n    Yes → Step 5: current ← current / 3\n    No → Step 6: 退出循環\n\nWe need a loop label: Let's add Step 4: 循環開始 // label.\n\nSimplify: Use while loop representation: while current % 3 == 0 { current = current / 3 }\n\nBut we need step-by-step. Use Start, then step, decision, loop arrow back.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: current ← n // 接收輸入\n→ Decision: current ≤ 0? // 非正數排除\n    Yes → Step 2: 返回 false\n    No  → Decision: current = 1? // 3^0\n        Yes → Step 3: 返回 true\n        No  → Step 4: 循環開始 // 分隔點\n            → Decision: current % 3 == 0? // 仍能整除\n                Yes → Step 5: current ← current / 3 // 除以 3\n                No  → Step 6: 循環結束 // 跳出循環\n→ Decision: current = 1? // 最後判斷\n    Yes → Step 7: 返回 true\n    No  → Step 8: 返回 false\nEnd // 程式結束\n\nBut we didn't indicate loop back arrow; maybe we can add a line: Yes → 回到 Step 4 (loop). That would indicate repeating.\n\nLet's rewrite with loop back:\n\nStart\n→ Step 1: current ← n\n→ Decision: current ≤ 0?\n    Yes → Step 2: 返回 false\n    No  → Decision: current = 1?\n        Yes → Step 3: 返回 true\n        No  → Step 4: 循環開始\n            → Decision: current % 3 == 0?\n                Yes → Step 5: current ← current / 3\n                      → 回到 Step 4 // 重複循環\n                No  → Step 6: 循環結束\n→ Decision: current = 1?\n    Yes → Step 7: 返回 true\n    No  → Step 8: 返回 false\nEnd\n\nThis seems fine. Let's ensure each line has arrow (→) except Start and End maybe also arrow? The sample uses Start and End on separate lines. We'll follow that.\n\nWe need to put explanation after //.\n\nLet's craft final output with each line accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: current ← n // 取得輸入值 n，並存入 current  \n→ Decision: current ≤ 0? // 檢查是否為非正數  \n    Yes → Step 2: 返回 false // 不是 3 的冪  \n    No  → Decision: current = 1? // 3⁰ = 1  \n        Yes → Step 3: 返回 true // n 是 3 的冪  \n        No  → Step 4: 循環開始 // 進入除以 3 的循環  \n            → Decision: current % 3 == 0? // 仍能被 3 整除  \n                Yes → Step 5: current ← current / 3 // 除以 3  \n                      → 回到 Step 4 // 重複循環  \n                No  → Step 6: 循環結束 // 無法再整除，跳出循環  \n→ Decision: current = 1? // 循環結束後判斷是否為 1  \n    Yes → Step 7: 返回 true // 成功找到 3 的冪  \n    No  → Step 8: 返回 false // 不是 3 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_power_of_three(n: int) -> bool:\n    \"\"\"判斷 n 是否為 3 的冪.\"\"\"\n    if n <= 0:\n        return False\n    while n % 3 == 0:\n        n //= 3\n    return n == 1\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取資料，輸出結果.\"\"\"\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個整數（允許負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = is_power_of_three(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving largest number arrangement. Steps: sort with custom comparator that compares a+b vs b+a. Edge case all zeros -> return \"0\". Steps: convert to string list, sort descending using comparator, join. Virtual code lines: Start, Step 1: convert to strings, Step 2: define comparator, Step 3: sort list, Step 4: join, Step 5: handle leading zero, End.\n\nUse arrow notation: \"→\". Provide explanation each line. Use decision: if all zeros. Provide Yes/No.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 把 nums 轉成字串陣列 strs // 方便字串比較  \n→ Step 2: 定義比較函式 cmp(a, b) // 判斷 a+b 與 b+a 的字串大小  \n  Decision: 如果 a+b 大於 b+a? // 比較兩種排列的大小  \n   Yes → Return 1 // a 應排在前面  \n   No  → Decision: 如果 a+b 等於 b+a? // 若相等則順序無關  \n    Yes → Return 0  \n    No  → Return -1 // b 應排在前面  \n→ Step 3: 用 cmp 以降序排列 strs // 讓能組成最大數的排列先出現  \n→ Step 4: 用 join() 把排序後的 strs 合併成一個字串 result // 形成最終數字  \n→ Step 5: Decision: result 是否以 '0' 為首? // 檢查全為零的情況  \n  Yes → result ← '0' // 全零時直接回傳單一 '0'  \n  No  → // 其它情況保持 result 不變  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        # 轉成字串\n        nums_str = list(map(str, nums))\n\n        # 比較兩個字串組合的大小\n        def compare(x, y):\n            if x + y > y + x:\n                return -1  # x 應排在前面\n            elif x + y < y + x:\n                return 1   # y 應排在前面\n            else:\n                return 0   # 相等時順序無關\n\n        # 降序排列，能產生最大的數字\n        nums_str.sort(key=cmp_to_key(compare))\n\n        # 合併成結果字串\n        result = ''.join(nums_str)\n\n        # 若全部為 0，只回傳單一 '0'\n        return '0' if result[0] == '0' else result\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取 nums 列表。\n    假設輸入格式類似 'nums = [10,2]'。\n    \"\"\"\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n    else:\n        rhs = data\n    return ast.literal_eval(rhs.strip())\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 取得 nums\n    nums = parse_input(raw_input)\n\n    # 計算結果\n    sol = Solution()\n    largest_num = sol.largestNumber(nums)\n\n    # 按範例輸出，將結果包成雙引號\n    print(f'\"{largest_num}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "\"210\""
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "\"9534330\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with each line: \"虛擬碼步驟 // 解釋\". Must use arrow and Decision, Start, End. The virtual code should implement a queue using two stacks. So need to illustrate steps: have two stacks: stack_in, stack_out. push: push onto stack_in. peek/pop: if stack_out empty, transfer all from stack_in to stack_out by popping from stack_in and pushing to stack_out. Then peek/pop from stack_out top. empty: if both empty.\n\nWe need to produce step-by-step pseudo code. Use Start, End, Decision. Provide each line with explanation.\n\nWe should include class definition, constructor, push, pop, peek, empty. We'll break each into virtual steps.\n\nLet's write:\n\nStart // 程式開始\n→ Step: 定義 MyQueue 類別 // 建立隊列類別\n→ Step: 宣告兩個空 stack_in, stack_out // 用來模擬隊列\n\nPush(x):\n→ Step: stack_in.push(x) // 將元素入堆疊\n\nPeek():\n→ Decision: 如果 stack_out.isEmpty()? // 檢查輸出堆疊是否為空\n    Yes → Step: While !stack_in.isEmpty() { stack_out.push(stack_in.pop()); } // 將所有元素從輸入堆疊轉移到輸出堆疊\n    No  → // 無需轉移\n→ Step: return stack_out.peek() // 取得最前面元素\n\nPop():\n→ Decision: 如果 stack_out.isEmpty()? // 檢查輸出堆疊是否為空\n    Yes → Step: While !stack_in.isEmpty() { stack_out.push(stack_in.pop()); } // 轉移\n    No  → // 無需轉移\n→ Step: return stack_out.pop() // 移除並返回\n\nEmpty():\n→ Decision: 如果 stack_in.isEmpty() AND stack_out.isEmpty()? // 判斷兩個堆疊是否都空\n    Yes → Step: return true // 队列为空\n    No  → Step: return false // 非空\n\nEnd // 程式結束\n\nWe need each line separate.\n\nMake sure each line ends with // 解釋. Use arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 MyQueue 類別 // 建立隊列類別  \n→ Step: 宣告兩個空 stack_in, stack_out // 用來模擬隊列的兩個堆疊  \n\n// ── push(x) ──  \n→ Step: stack_in.push(x) // 將元素 x 入堆疊 stack_in  \n\n// ── peek() ──  \n→ Decision: 如果 stack_out.isEmpty()? // 檢查輸出堆疊是否為空  \n  Yes → Step: While !stack_in.isEmpty() { stack_out.push(stack_in.pop()); } // 將所有元素從輸入堆疊轉移到輸出堆疊  \n  No  → // 無需轉移  \n→ Step: return stack_out.peek() // 取得並返回最前面的元素  \n\n// ── pop() ──  \n→ Decision: 如果 stack_out.isEmpty()? // 檢查輸出堆疊是否為空  \n  Yes → Step: While !stack_in.isEmpty() { stack_out.push(stack_in.pop()); } // 將所有元素從輸入堆疊轉移到輸出堆疊  \n  No  → // 無需轉移  \n→ Step: return stack_out.pop() // 移除並返回最前面的元素  \n\n// ── empty() ──  \n→ Decision: 如果 stack_in.isEmpty() AND stack_out.isEmpty()? // 判斷兩個堆疊是否都空  \n  Yes → Step: return true // 队列为空  \n  No  → Step: return false // 队列非空  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip() != '']\n    if not lines:\n        return\n\n    # If the first line is literally \"Input\", ignore it\n    if lines[0] == 'Input':\n        lines = lines[1:]\n\n    # Parse operations and arguments\n    ops = ast.literal_eval(lines[0])\n    args_list = ast.literal_eval(lines[1])\n\n    results = []\n    queue = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"MyQueue\":\n            queue = MyQueue()\n            results.append(None)          # constructor returns null\n        elif op == \"push\":\n            queue.push(args[0])\n            results.append(None)          # push returns null\n        elif op == \"pop\":\n            results.append(queue.pop())\n        elif op == \"peek\":\n            results.append(queue.peek())\n        elif op == \"empty\":\n            results.append(queue.empty())\n        else:\n            # In case of unexpected operation\n            results.append(None)\n\n    # Convert Python None/True/False to JSON-style null/true/false\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": true,
          "output": "[null, null, null, 1, 1, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode718.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Repeated Subarray",
    "description_snippet": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in bo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step for problem: Longest Common Subarray between two arrays. We should produce a high-level algorithm, maybe using DP sliding window or DP matrix. Let's choose DP where dp[i][j] = length of common suffix ending at nums1[i-1], nums2[j-1], compute max. Complexity O(m*n). Let's produce virtual steps.\n\nWe need start, steps, decisions, end. We can also include loops.\n\nPseudo steps:\n\nStart\n\n→ Step 1: Obtain lengths m, n from nums1, nums2 // get array sizes\n\n→ Step 2: Initialize 2D array dp with (m+1)x(n+1) zeros // dp matrix for suffix lengths\n\n→ Step 3: Initialize variable maxLen = 0 // keep track of maximum\n\n→ Step 4: Loop i from 1 to m // iterate over nums1\n\n    → Step 5: Loop j from 1 to n // iterate over nums2\n\n        → Decision: If nums1[i-1] == nums2[j-1]?\n\n            Yes → Step 6: dp[i][j] = dp[i-1][j-1] + 1 // extend common suffix\n\n                → Step 7: If dp[i][j] > maxLen → maxLen = dp[i][j] // update max\n\n            No  → Step 8: dp[i][j] = 0 // no match\n\n→ Step 9: Return maxLen // output maximum length\n\nEnd\n\nThis is straightforward. Provide each line with comment. Use arrow formatting.\n\nNeed to include decisions and branches correctly. We need \"→ Decision:\" line with condition and \"Yes →\" and \"No →\" lines.\n\nLet's produce. Use \"Start\", \"End\".\n\nEnsure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nUse appropriate Chinese explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← length(nums1) // 取得陣列 nums1 的長度  \n→ Step 2: n ← length(nums2) // 取得陣列 nums2 的長度  \n→ Step 3: dp ← matrix(m+1, n+1, 0) // 初始化 (m+1)×(n+1) 的 0 矩陣，用於記錄相等子陣列的長度  \n→ Step 4: maxLen ← 0 // 用於儲存目前找到的最大相等子陣列長度  \n→ Step 5: Loop i from 1 to m // 遍歷 nums1 的每個位置  \n    → Step 6: Loop j from 1 to n // 遍歷 nums2 的每個位置  \n        → Decision: 如果 nums1[i-1] == nums2[j-1]? // 檢查兩個位置的元素是否相等  \n            Yes → Step 7: dp[i][j] ← dp[i-1][j-1] + 1 // 以前一個相等子陣列為基礎，延長長度  \n                → Step 8: If dp[i][j] > maxLen? // 若新的長度比目前最大還大  \n                    Yes → maxLen ← dp[i][j] // 更新最大長度  \n                No → // 什麼也不做，保持 maxLen 不變  \n            No → Step 9: dp[i][j] ← 0 // 兩個位置不相等，子陣列長度重置為 0  \n→ Step 10: Return maxLen // 回傳找到的最大相等子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findLength(self, nums1, nums2):\n        \"\"\"\n        使用動態規劃求兩個陣列的最大公共子陣列長度。\n        dp[i][j] 表示 nums1 前 i 個元素與 nums2 前 j 個元素最後一個元素相等的公共子陣列長度。\n        \"\"\"\n        m, n = len(nums1), len(nums2)\n        # 建立 (m+1) x (n+1) 的 DP 表格，初始值為 0\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        max_len = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if nums1[i - 1] == nums2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    if dp[i][j] > max_len:\n                        max_len = dp[i][j]\n                else:\n                    dp[i][j] = 0\n        return max_len\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取兩個整數陣列。\n    假設輸入格式為：nums1 = [a,b,c], nums2 = [x,y,z]\n    \"\"\"\n    # 取得所有方括號內的內容\n    parts = re.findall(r'\\[([^\\]]*)\\]', data)\n    if len(parts) < 2:\n        return [], []\n\n    nums1 = [int(x.strip()) for x in parts[0].split(',') if x.strip() != '']\n    nums2 = [int(x.strip()) for x in parts[1].split(',') if x.strip() != '']\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.findLength(nums1, nums2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting reverse pairs. Approach: use merge sort divide and count. Steps: define function countReversePairs(nums). Use helper mergeSort with indices. At each merge step, count pairs across left/right: for each i in left, while j<right and left[i]>2*right[j] count. Then merge.\n\nWe need to output line by line with virtual code arrows and explanations. Use Start, End. We need to reflect recursion and loops.\n\nLet's craft:\n\nStart\n→ Step 1: 定義主函式 CountReversePairs(nums) // 入口\n→ Step 2: 呼叫 mergeSort(nums, 0, len(nums)-1) // 進行分治\n→ End\n\nBut need to detail mergeSort recursion:\n\nDefine mergeSort(arr, left, right):\n→ Decision: if left >= right? // 基本情況\n    Yes → Step: return 0 // 小於等於1個元素不會有逆序對\n    No → Step: mid = (left+right)//2\n→ Step: leftCount = mergeSort(arr, left, mid)\n→ Step: rightCount = mergeSort(arr, right, mid+1)\n→ Step: crossCount = countCrossPairs(arr, left, mid, right) // cross pairs\n→ Step: merge(arr, left, mid, right) // 合併排序\n→ Step: return leftCount + rightCount + crossCount\n\ncountCrossPairs:\n→ Step: count = 0; j = mid+1\n→ Loop i from left to mid:\n    while j <= right and arr[i] > 2*arr[j]: j++ ; count += j - (mid+1)\n→ return count\n\nmerge function: standard merge.\n\nWe'll produce lines accordingly with explanations.\n\nWe need each line as `虛擬碼步驟 // 解釋`.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義主函式 CountReversePairs(nums) // 入口函式，接收整數陣列\n→ Decision: 若 nums 為空? // 檢查輸入是否為空\n    Yes → Step 2: 回傳 0 // 空陣列沒有逆序對\n    No  → Step 3: 呼叫 mergeSort(nums, 0, len(nums)-1) // 進行分治排序並計數\n→ End // 主函式結束\n\n// ---------------------------\n//  mergeSort 函式：分治並計算逆序對\nStart // mergeSort 開始\n→ Step 4: 定義函式 mergeSort(arr, left, right)\n→ Decision: left >= right? // 基本情況：子陣列長度為 1 或 0\n    Yes → Step 5: 回傳 0 // 沒有逆序對\n    No  → Step 6: mid = (left + right) // 2 // 計算中點\n→ Step 7: leftCount = mergeSort(arr, left, mid) // 右子陣列左側遞迴\n→ Step 8: rightCount = mergeSort(arr, mid+1, right) // 右子陣列右側遞迴\n→ Step 9: crossCount = countCrossPairs(arr, left, mid, right) // 計算跨子陣列的逆序對\n→ Step 10: merge(arr, left, mid, right) // 合併兩個已排序的子陣列\n→ Step 11: 回傳 leftCount + rightCount + crossCount // 返還總逆序對數\nEnd // mergeSort 結束\n\n// ---------------------------\n//  countCrossPairs 函式：計算跨子陣列的逆序對\nStart // countCrossPairs 開始\n→ Step 12: 定義函式 countCrossPairs(arr, left, mid, right)\n→ Step 13: count = 0\n→ Step 14: j = mid + 1\n→ Decision: i = left 直到 mid? // 逐一遍歷左子陣列\n    Yes → Step 15: while j <= right 且 arr[i] > 2 * arr[j]: // 判斷逆序對條件\n            → Step 16: j = j + 1 // 尋找符合條件的右子陣列指標\n            → Step 17: count = count + (j - (mid + 1)) // 加上符合條件的個數\n        → Step 18: i = i + 1 // 移動左子陣列指標\n    No  → Step 19: 回傳 count // 完成跨子陣列計數\nEnd // countCrossPairs 結束\n\n// ---------------------------\n//  merge 函式：合併兩個已排序的子陣列\nStart // merge 開始\n→ Step 20: 定義函式 merge(arr, left, mid, right)\n→ Step 21: temp = [] // 臨時儲存合併結果\n→ Step 22: i = left, j = mid + 1\n→ Decision: i <= mid 且 j <= right? // 兩個子陣列均有元素\n    Yes → Step 23: 若 arr[i] <= arr[j]: temp.append(arr[i]); i = i + 1\n            → Step 24: 否則: temp.append(arr[j]); j = j + 1\n    No  → Step 25: 若 i <= mid: temp.extend(arr[i:mid+1]) // 將剩餘左子陣列拷入\n            → Step 26: 若 j <= right: temp.extend(arr[j:right+1]) // 將剩餘右子陣列拷入\n→ Step 27: 將 temp 內容複製回 arr[left:right+1] // 覆蓋原陣列區段\nEnd // merge 結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reversePairs(self, nums):\n        \"\"\"\n        使用分治 merge sort 方式計算逆序對\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def merge_sort(start, end):\n            # 基本情況：子陣列長度 0 或 1 時不會有逆序對\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            # 分別遞迴左、右子陣列\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n\n            # 計算跨子陣列的逆序對\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n\n            # 合併兩個已排序的子陣列\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n            nums[start:end + 1] = temp\n            return count\n\n        return merge_sort(0, len(nums) - 1)\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從字串中抓取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # 如果沒有數字，直接輸出 0\n    if not nums:\n        print(0)\n        return\n    solution = Solution()\n    result = solution.reversePairs(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, no real code, just structure with arrows and steps. Use Start, End, Decision etc. Provide line by line. Use Chinese explanation. Should reflect algorithm: compress array in-place with constant space. Steps: pointers i for reading, j for writing. Count run length. Write char and optionally digits. Return j. Also handle digits >9 into multiple characters.\n\nSo produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化讀指標 i = 0, 寫指標 j = 0 // 設定讀寫位置\n→ Step 2: While i < len(chars): // 遍歷整個陣列\n    → Step 3: char = chars[i] // 取得目前字符\n    → Step 4: count = 0 // 初始化計數\n    → Decision: 以 i 為起點, count++ 直到下個字符不同或結束 // 計算連續重複數量\n        Yes → (loop)\n    → Step 5: chars[j] = char; j++ // 寫入字符\n    → Decision: 如果 count > 1? // 是否需要寫入長度\n        Yes → Step 6: Convert count to string digits\n            → Step 7: For each digit d in digits:\n                → chars[j] = d; j++ // 寫入每個數字\n        No  → // 不寫入任何數字\n    → Step 8: i += count // 移動到下一段\n→ End // 完成壓縮\n→ Return j // 返回新長度\n\nBut need to use the specified syntax: 虛擬碼步驟 + [space] + // 解釋. And use arrows like →, Decision: etc.\n\nLet's craft line by line.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: i ← 0, j ← 0 // 初始化讀寫指標\nLine 3: → Decision: i < len(chars)? // 判斷是否已遍歷完陣列\nLine 4: Yes → Step 2: cur_char ← chars[i] // 取得當前字符\nLine 5: Yes → Step 3: count ← 0 // 初始化重複次數\nLine 6: → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\nLine 7: Yes → Step 4: count ← count + 1 // 連續字符數增1\nLine 8: No → Step 5: chars[j] ← cur_char; j ← j + 1 // 將字符寫入輸出\nLine 9: No → Decision: count > 1? // 是否需要寫入長度\nLine 10: Yes → Step 6: digits_str ← str(count) // 將數量轉成字串\nLine 11: Yes → For each d in digits_str: // 逐個寫入每個數字\nLine 12: Yes → chars[j] ← d; j ← j + 1 // 寫入數字\nLine 13: No → // 不寫入長度\nLine 14: → Step 7: i ← i + count // 移動到下一個不同字符\nLine 15: → Decision: i < len(chars)? // 回到主迴圈判斷\nLine 16: No → End // 完成壓縮\nLine 17: → Return j // 回傳新長度\n\nBut need to follow the arrow formatting: The syntax for Decision: should be `Decision: 如果條件? // ...` and then indent Yes → ... No → ... within. Use spaces.\n\nAlso we should maintain the structure: start, decisions nested. Provide clear indentation.\n\nLet's create:\n\nStart // 程式開始執行\n→ Decision: i < len(chars)? // 是否還有字符可處理\n    Yes → Step 1: cur_char ← chars[i] // 取得當前字符\n    Yes → Step 2: count ← 0 // 重複次數初始為0\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 計數加一\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 是否需要寫入長度\n            Yes → Step 5: digits_str ← str(count) // 轉成字串\n            Yes → For each d in digits_str: // 逐字寫入\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 不寫入長度\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 回到主迴圈\n    No  → // 迴圈結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度\n\nBut the indentation might not be clear. The spec requires each line to start with 虛擬碼步驟 and include arrow etc. Might need to maintain line order. We need to show each step as separate line, but the decision branches need to be nested lines. The example shows indentation: they used tabs or spaces? They used spaces and indentation for Yes/No lines under Decision. We can replicate that.\n\nAlso include `Decision:` lines.\n\nLet's produce final output with each line as:\n\nStart // 程式開始執行\n→ Decision: i < len(chars)? // 判斷是否還有字符可處理\n    Yes → Step 1: cur_char ← chars[i] // 取得當前字符\n    Yes → Step 2: count ← 0 // 初始化重複次數\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 連續字符數增加\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 是否寫入長度\n            Yes → Step 5: digits_str ← str(count) // 把數量轉成字串\n            Yes → For each d in digits_str: // 逐個寫入數字\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 不寫入長度\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 返回主迴圈\n    No  → // 迴圈結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度\n\nBut the \"No → // 返回主迴圈\" might not be correct; maybe we need to go back to Decision i < len(chars). The \"No\" branch after Step 3? Actually after Step 7 we should go back to start of while loop. The outer Decision covers the while loop. So after Step 7 we go back to outer Decision. In structure, we need to close inner decisions properly.\n\nBetter to use clear structure:\n\nStart // 程式開始執行\n→ Decision: i < len(chars)? // 是否還有字符可處理\n    Yes → Step 1: cur_char ← chars[i] // 取得當前字符\n    Yes → Step 2: count ← 0 // 初始化重複次數\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 計數加一\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 是否寫入長度\n            Yes → Step 5: digits_str ← str(count) // 轉成字串\n            Yes → For each d in digits_str: // 逐字寫入\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 不寫入長度\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 回到外層 Decision\n    No  → // 外層決策結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度\n\nBut the \"No → // 回到外層 Decision\" is ambiguous. Perhaps we should simply not include that line; instead we rely on control flow: after Step 7 we go back to outer Decision. So we could put `No → // 返回外層 while 循環` but it's fine.\n\nBut we also need to close inner Decision properly: after No branch we wrote steps and decisions; we need to indent accordingly.\n\nBetter to create a more systematic representation:\n\nStart // 程式開始執行\n→ Decision: i < len(chars)? // 主要迴圈判斷\n    Yes → Step 1: cur_char ← chars[i] // 取得目前字符\n    Yes → Step 2: count ← 0 // 初始化重複計數\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 計數加 1\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 判斷是否需要寫入長度\n            Yes → Step 5: digits_str ← str(count) // 將長度轉為字串\n            Yes → For each d in digits_str: // 逐個寫入\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 長度為 1 時不寫入\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 迴圈繼續\n    No  → // 內層 Decision 結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度\n\nBut we lost the outer loop; we need to return to Decision i < len(chars). So after Step 7 we go back to outer Decision; this is implicit. Maybe we need to add `No → // 返回外層 Decision` after Step 7.\n\nAlso need to account for the fact that after inner Decision we go back to outer Decision.\n\nLet's produce a consistent structure:\n\nStart // 程式開始執行\n→ Decision: i < len(chars)? // 迴圈判斷\n    Yes → Step 1: cur_char ← chars[i] // 取得當前字符\n    Yes → Step 2: count ← 0 // 初始化重複計數\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 檢查是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 增加計數\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 判斷是否需要寫入長度\n            Yes → Step 5: digits_str ← str(count) // 轉成字串\n            Yes → For each d in digits_str: // 逐字寫入\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 長度為1時不寫入\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 回到外層 Decision\n    No  → // 內層 Decision 結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度\n\nThis seems okay. But the indentation may not be perfect. We can add tabs to show nested levels, but the spec didn't mention using tabs, but the example uses spaces and indentation. We'll use spaces for indentation.\n\nAlso we should not use comments for 'No → // 回到外層 Decision', as it's not a step but just flow. But it's fine to include.\n\nThe spec says each line must have `虛擬碼步驟` + space + `// 解釋`. So each line must have a comment. So we need to provide comment for each line. For No branches we also need comments. The sample shows `No  → Decision: ...` line with comment. So we follow.\n\nThus for each line we need the arrow and step or decision. The arrow at beginning of line? In example: `→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值`. So we need to start each line after Start and before End with arrow.\n\nHence:\n\nStart // 程式開始執行\n→ Decision: i < len(chars)? // 是否還有字符可處理\n    Yes → Step 1: cur_char ← chars[i] // 取得當前字符\n    Yes → Step 2: count ← 0 // 初始化重複計數\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 計數加 1\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 是否需要寫入長度\n            Yes → Step 5: digits_str ← str(count) // 轉成字串\n            Yes → For each d in digits_str: // 逐字寫入\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 長度為 1 時不寫入\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 返回外層 Decision\n    No  → // 內層 Decision 結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度\n\nBut note indentation: we used multiple spaces. The example uses indentation for Yes/No lines. We'll keep similar style.\n\nNow produce final answer with only lines as above. Ensure each line ends with comment. Use Chinese comments.\n\nAlso need to include the step for initialization j = 0. We didn't include that. We need to add Step 0: j ← 0 before main loop.\n\nAlso we need to handle i initialization at 0. We have Step 1 for cur_char; we didn't initialize i. So we should add Step 0: i ← 0; j ← 0 before loop. So include before outer Decision.\n\nThus:\n\nStart // 程式開始執行\n→ Step 0: i ← 0; j ← 0 // 初始化讀寫指標\n→ Decision: i < len(chars)? // 主要迴圈判斷\n    Yes → Step 1: cur_char ← chars[i] // 取得目前字符\n    Yes → Step 2: count ← 0 // 初始化重複計數\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 計數加 1\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 判斷是否需要寫入長度\n            Yes → Step 5: digits_str ← str(count) // 轉成字串\n            Yes → For each d in digits_str: // 逐字寫入\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 長度為 1 時不寫入\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 返回外層 Decision\n    No  → // 內層 Decision 結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度\n\nNow check: The outer Decision line is at line 3; but we had Step 0 already. Good.\n\nMake sure we don't miss the j increment for length >1. Already in Step 6.\n\nAlso need to ensure we write digits for length >=10 properly. The For each d loop handles each digit.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 0: i ← 0; j ← 0 // 初始化讀寫指標\n→ Decision: i < len(chars)? // 主要迴圈判斷\n    Yes → Step 1: cur_char ← chars[i] // 取得目前字符\n    Yes → Step 2: count ← 0 // 初始化重複計數\n    → Decision: (i + count) < len(chars) AND chars[i + count] == cur_char? // 判斷是否還有相同字符\n        Yes → Step 3: count ← count + 1 // 計數加 1\n        No  → Step 4: chars[j] ← cur_char; j ← j + 1 // 寫入字符\n        No  → Decision: count > 1? // 判斷是否需要寫入長度\n            Yes → Step 5: digits_str ← str(count) // 轉成字串\n            Yes → For each d in digits_str: // 逐字寫入\n                → Step 6: chars[j] ← d; j ← j + 1 // 寫入數字\n            No  → // 長度為 1 時不寫入\n        No  → Step 7: i ← i + count // 移動到下一段\n        No  → // 返回外層 Decision\n    No  → // 內層 Decision 結束\n→ End // 完成壓縮\n→ Return j // 回傳新長度",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def compress(self, chars):\n        write = 0\n        left = 0\n        n = len(chars)\n        \n        while left < n:\n            right = left\n            while right < n and chars[right] == chars[left]:\n                right += 1\n            chars[write] = chars[left]\n            write += 1\n            count = right - left\n            if count > 1:\n                for c in str(count):\n                    chars[write] = c\n                    write += 1\n            left = right\n        \n        return write\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data.startswith(\"chars\"):\n        expr = data.split(\"=\", 1)[1].strip()\n        chars = ast.literal_eval(expr)\n    else:\n        chars = ast.literal_eval(data)\n    result = Solution().compress(chars)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode674.json",
    "problem_index_in_file": 0,
    "title": "Longest Continuous Increasing Subsequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest continuous increasing sub...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanation lines, following format. Use Start, → Step, Decision, etc.\n\nWe need to solve longest continuous increasing subsequence length.\n\nWe produce algorithm: iterate array, keep current length, max length.\n\nPseudo:\n\nStart\n→ Step 1: If nums empty → 0\n→ Step 2: Initialize maxLen = 1, curLen = 1\n→ For i from 1 to nums.length-1\n→ Decision: nums[i] > nums[i-1]?\n    Yes → curLen++ \n    No → curLen = 1\n    → Update maxLen = max(maxLen, curLen)\n→ Step 3: Return maxLen\nEnd\n\nWe need to produce lines with explanations.\n\nEdge case: empty array: return 0.\n\nLet's output each line as per requirement.\n\nMake sure each line is \"虛擬碼步驟\" + space + \"// 解釋\".\n\nExamples earlier show indentation for nested decisions. We'll indent decisions with spaces.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Check if nums is empty // 判斷陣列是否為空\n    Yes → Step 1a: Return 0 // 空陣列長度為 0\n→ Step 2: 初始化 maxLen = 1, curLen = 1 // 設定最大長度與目前連續子序列長度\n→ For i from 1 to nums.length - 1 // 循環遍歷陣列\n    → Decision: nums[i] > nums[i-1]? // 判斷是否仍為單調遞增\n        Yes → curLen = curLen + 1 // 若遞增，累加目前長度\n        No  → curLen = 1 // 否則重置目前長度為 1\n    → maxLen = max(maxLen, curLen) // 更新最大長度\n→ Step 3: Return maxLen // 回傳最長長度\nEnd // 程式執行結束\n\nNeed to keep arrow \"→\" before Step lines, and indent inside For. The For line also has \"→\" maybe. In example they used \"→ Step 1:\" etc.\n\nWe must ensure each line includes \"虛擬碼步驟\" with arrow maybe. Use arrow before each step.\n\nAlso \"Yes →\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 檢查 nums 是否為空 // 判斷陣列是否為空\n    Yes → Step 1a: 回傳 0 // 空陣列長度為 0，直接結束\n→ Step 2: 初始化 maxLen = 1, curLen = 1 // 設定最大長度與目前連續子序列長度\n→ For i from 1 到 nums.length - 1 // 循環遍歷陣列\n    → Decision: nums[i] > nums[i-1]? // 判斷是否仍為單調遞增\n        Yes → curLen = curLen + 1 // 若遞增，累加目前長度\n        No  → curLen = 1 // 否則重置目前長度為 1\n    → maxLen = max(maxLen, curLen) // 更新最大長度\n→ Step 3: 回傳 maxLen // 回傳最長連續遞增子序列長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLengthOfLCIS(self, nums):\n        if not nums:\n            return 0\n        max_len = 1\n        cur_len = 1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i - 1]:\n                cur_len += 1\n                max_len = max(max_len, cur_len)\n            else:\n                cur_len = 1\n        return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 支援「nums = [1,2,3]」或僅為陣列字串\n    if data.startswith(\"nums\"):\n        eq_index = data.find('=')\n        if eq_index != -1:\n            list_str = data[eq_index + 1 :].strip()\n        else:\n            list_str = data\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = eval(list_str, {})\n\n    solution = Solution()\n    result = solution.findLengthOfLCIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines step by step for this problem. Let's design algorithm:\n\nStart\n→ Input s, k\n→ Set n = length of s\n→ Initialize result = empty\n→ Initialize i = 0\n→ Decision: i < n? while loop\n    Yes → Set end = min(i + k, n)\n    → Substring s[i:end] reversed → append to result\n    → Decision: i + 2k <= n? If there are at least 2k chars left\n        Yes → Set mid = min(i + 2k, n)\n            → Append s[end:mid] unchanged to result\n            → Set i = mid\n        No → Append s[end:n] unchanged to result\n            → Set i = n\n    No → End\n\nBut need iterative style: using Decision and loops.\n\nLet's produce virtual code with step names like \"Step 1: 初始化\", etc.\n\nMake sure each line: Virtual Code Step + // explanation.\n\nInclude arrow \"→\" for next steps. Use Decision:.\n\nImplement loop with Decision: i < n? and then branch.\n\nWithin branch: compute end, etc.\n\nOk produce lines.\n\nLet's craft.\n\nAlso mention that string operations: reverse substring.\n\nBe careful to include \"End\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s 與整數 k // 取得使用者輸入\n→ Step 2: 設定 n = s.length() // 字串長度\n→ Step 3: 初始化 result = \"\" // 儲存結果\n→ Step 4: 設定 i = 0 // 目前處理位置\n→ Decision: i < n? // 檢查是否還有未處理的字元\n    Yes → Step 5: end = min(i + k, n) // 第 k 個字元的索引（不超過字串結束）\n    → Step 6: 取 s[i:end] 的子字串並反轉 → append 到 result // 反轉前 k 個字元\n    → Decision: i + 2k <= n? // 是否至少還有 2k 個字元剩餘\n        Yes → Step 7: mid = min(i + 2k, n) // 兩段結束索引\n        → Step 8: 取 s[end:mid] 的子字串不變 → append 到 result // 留下後 k 個字元原樣\n        → Step 9: i = mid // 移至下一段起點\n        No  → Step 10: 取 s[end:n] 的子字串不變 → append 到 result // 只剩少於 2k 個字元，保留後面部分\n        → Step 11: i = n // 走完全部字元\n    No  → End // 沒有足夠字元，程式結束\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        \"\"\"Reverse first k characters for every 2k characters in the string.\"\"\"\n        s_list = list(s)\n        for i in range(0, len(s_list), 2 * k):\n            # Reverse the sublist from i to i+k (or to the end of the string)\n            s_list[i:i + k] = reversed(s_list[i:i + k])\n        return \"\".join(s_list)\n\ndef parse_input(input_text: str):\n    \"\"\"\n    Parse input of the form:\n        \"<string>\", <k>\n    \"\"\"\n    pattern = r'\\s*(?P<str>\\\".*?\\\"\\S*)\\s*,\\s*(?P<k>\\d+)\\s*'\n    match = re.fullmatch(pattern, input_text)\n    if not match:\n        raise ValueError(\"Input format must be: \\\"<string>\\\", <k>\")\n    string_literal = match.group('str')\n    k_value = int(match.group('k'))\n    # Safely evaluate the string literal (handles escaped quotes, etc.)\n    string_value = ast.literal_eval(string_literal)\n    return string_value, k_value\n\nif __name__ == \"__main__\":\n    # Read entire stdin, strip surrounding whitespace\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    s, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.reverseStr(s, k)\n\n    # Output with surrounding double quotes as in the examples\n    print(f\"\\\"{result}\\\"\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "\"bacdfeg\""
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "\"bacd\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm that finds maximum profit with at most k transactions, given array prices.\n\nWe need to output line by line with \"虛擬碼步驟 // 解釋\". Use arrows and decision.\n\nWe need to generate a high-level algorithm in pseudocode: DP solution: dp[t][i] maximum profit up to day i with at most t transactions. Compute using nested loops.\n\nBut we need to produce a step-by-step algorithm, not actual code.\n\nWe need to include Start, End, Decision, etc.\n\nWe need to produce lines such as:\n\nStart // program begins\n\n→ Input prices array, k // read input\n\n→ Initialize dp array of size (k+1) x n // dp[t][i]...\n\n→ Decision: n == 0? // if no days\n\nYes → End // nothing\n\nNo → Step 1: For t from 1 to k // outer loop\n\n→ Step 2: Set maxDiff = -prices[0] // variable to track best previous state\n\n→ For i from 1 to n-1 // inner loop\n\n→ Update maxDiff = max(maxDiff, dp[t-1][i-1] - prices[i]) // compute\n\n→ Update dp[t][i] = max(dp[t][i-1], prices[i] + maxDiff) // compute\n\n… After loops, result = dp[k][n-1] // output profit\n\nBut we need to output as a list of steps, each with explanation.\n\nLet's craft step lines.\n\nWe need arrow \"→\". For loops we can denote steps: Step: For t in 1..k // explanation\n\nBut the requirement: each line must include \"虛擬碼步驟\" and comment after space. Use arrow for transitions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input: prices array, k // 讀取股票價格序列與最大交易次數\n→ Decision: 若 prices 為空? // 檢查是否有交易日\n    Yes → End // 沒有日子，直接結束\n    No  →\n→ Step: n ← length(prices) // 獲取日子數\n→ Step: 建立 dp 表，尺寸 (k+1) x n，全部初始化為 0 // dp[t][i] 表示前 i 天完成 t 次交易的最大利潤\n→ Decision: 若 k == 0? // 無交易次數\n    Yes → End // 直接結束，利潤為 0\n    No  →\n→ Step: For t = 1 to k // 外層迴圈處理每一筆交易次數\n    → Step: maxDiff ← -prices[0] // 初始最大差值，代表在第 0 天購買\n    → For i = 1 to n-1 // 內層迴圈遍歷每一天\n        → Decision: 是否已經計算過 dp[t][i-1]? // 確保前一天結果可用\n            Yes →\n            No  →\n        → Step: maxDiff ← max(maxDiff, dp[t-1][i-1] - prices[i]) // 更新最大差值，代表最佳買入點\n        → Step: dp[t][i] ← max(dp[t][i-1], prices[i] + maxDiff) // 取「不交易」或「今日賣出」的最大值\n→ Step: Result ← dp[k][n-1] // 最後一天完成 k 次交易的最大利潤\n→ Output Result // 顯示最終利潤\nEnd // 程式結束\n\nBut we need to ensure each line is separate, and arrow for steps. Might need to show nested loops with indentation? The example uses indentation for Decision branch. We can indent but must keep same format: `Decision:` line, then `Yes →` lines and `No →` lines. For loops we can write `Step: For t = 1 to k` etc.\n\nBut the format: Each line: \"虛擬碼步驟 [space] // 解釋\". The arrow arrow inside steps? For loops we can show arrow inside but maintain as single line. Eg `→ Step: For t = 1 to k // outer loop`.\n\nBut inside loops we need inner steps: They can be further lines with arrow? But need to keep each line separate. We can indent lines inside loops but maintain the arrow.\n\nLet's produce properly:\n\nStart // 程式開始執行\n→ Input prices, k // 讀入價格序列與最大交易次數\n→ Decision: 若 prices 為空? // 檢查是否有交易日\n    Yes → End // 無日子，結束\n    No  →\n→ Step: n ← length(prices) // 取得日子數\n→ Step: 建立 dp[0..k][0..n-1] = 0 // 初始化 DP 表\n→ Decision: 若 k == 0? // 無交易次數\n    Yes → End // 利潤為 0\n    No  →\n→ Step: For t = 1 to k // 處理每一筆交易\n    → Step: maxDiff ← -prices[0] // 初始化最大差值\n    → For i = 1 to n-1 // 遍歷每一天\n        → Decision: 已經有 dp[t][i-1]? // 確保前一天結果可用\n            Yes →\n            No  →\n        → Step: maxDiff ← max(maxDiff, dp[t-1][i-1] - prices[i]) // 更新最大差值\n        → Step: dp[t][i] ← max(dp[t][i-1], prices[i] + maxDiff) // 計算最大利潤\n→ Step: Result ← dp[k][n-1] // 取得最終利潤\n→ Output Result // 顯示結果\nEnd // 程式結束\n\nBut we need each line with a single arrow at start. For loops, we need nested arrow maybe like \"→ Step: For t...\" and inside we use \"→ Step:\" again, but indentation indicates nested. Example uses \"→ Decision:\" then indent \"Yes →\". So for loops we can use same style: \"→ Step: For t...\" then inside, we indent \"→ Step: maxDiff ...\" etc.\n\nThus produce lines accordingly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input prices, k // 讀入股票價格序列與最大交易次數  \n→ Decision: 若 prices 為空? // 檢查是否有交易日  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → End // 無日子，結束  \n&nbsp;&nbsp;&nbsp;&nbsp;No  →  \n→ Step: n ← length(prices) // 取得日子數  \n→ Step: 建立 dp[0..k][0..n-1] = 0 // 初始化 DP 表  \n→ Decision: 若 k == 0? // 無交易次數  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → End // 利潤為 0  \n&nbsp;&nbsp;&nbsp;&nbsp;No  →  \n→ Step: For t = 1 to k // 處理每一筆交易  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step: maxDiff ← -prices[0] // 初始化最大差值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ For i = 1 to n-1 // 遍歷每一天  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 已經有 dp[t][i-1]? // 確保前一天結果可用  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step: maxDiff ← max(maxDiff, dp[t-1][i-1] - prices[i]) // 更新最大差值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step: dp[t][i] ← max(dp[t][i-1], prices[i] + maxDiff) // 計算最大利潤  \n→ Step: Result ← dp[k][n-1] // 取得最終利潤  \n→ Output Result // 顯示結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, k: int, prices: list[int]) -> int:\n        n = len(prices)\n        if n == 0:\n            return 0\n        # If k is large enough, treat as unlimited transactions\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        # DP table: dp[t][i] = max profit up to day i with at most t transactions\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]  # best value of dp[t-1][i-1] - prices[i]\n            for d in range(1, n):\n                # Option 1: no transaction on day d\n                # Option 2: sell on day d using best previous buy\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                # Update max_diff for next day\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # Extract all integers (handles formats like 'k = 2, prices = [2,4,1]')\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        print(0)\n        return\n    k = nums[0]\n    prices = nums[1:]\n    sol = Solution()\n    result = sol.maxProfit(k, prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code, step by step. Need to handle algorithm: longest uncommon subsequence length. Known solution: If any string is unique in array, answer = length of that string. Else -1. Because LUS is a string itself not a subsequence? Actually longest uncommon subsequence is a string that is subsequence of one string but not any other. The longest such string is the longest string that is not repeated. Because the string itself is a subsequence of itself, and if no other string equals it, then it cannot be a subsequence of others? Wait if other string contains it as subsequence? For uniqueness of strings, but if one string is a subsequence of another longer string, then the shorter unique string is a subsequence of the longer string, so not uncommon. So need check: if there exists a string that does not appear as a subsequence in any other string. Usually solution: if any string is unique, return its length. Because if two equal strings, they cannot be uncommon. But uniqueness ensures that it's not present as subsequence in others? Actually if a string is unique but is subsequence of another, then it fails. Example: strs=[\"aba\",\"cdc\",\"eae\"] all unique. None is subsequence of others. So longest is max length. For uniqueness but subsequence: e.g., strs=[\"a\",\"a\",\"aa\"]? 'aa' contains 'a' as subsequence. Unique 'aa' is not subsequence of others? 'aa' not subsequence of 'a', fine. So return 2. So algorithm: for each string s, check if s appears as subsequence in any other string t. If no, candidate. Then answer max length. If none, -1. Implementation uses O(n^2 * len). Provide virtual code.\n\nWe must produce virtual code lines with explanation.\n\nLet's produce steps: Start, Input array, Initialize result = -1. For each i, set flag = True. For each j != i, if isSubsequence(strs[i], strs[j]), flag = False break. If flag, result = max(result, len(strs[i])). After loops, if result==-1 return -1 else result.\n\nDefine isSubsequence(a,b): iterate over b pointer, iterate over a pointer, if chars match move a pointer, if reach end of a return True else False.\n\nNow produce virtual code accordingly.\n\nLet's output each line with explanation. Use arrows.\n\nMake sure each line has virtual code step then // explanation. Use indentation for decisions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義輸入陣列 strs // 取得所有字串  \n→ Step 2: 初始化 result ← -1 // 預設為不存在最長不常見子序列  \n\n→ Step 3: 針對每個索引 i 在 0 到 strs.length-1  \n    → Decision: i 為當前檢查字串 index?  \n        Yes → Step 4: 設 flag ← True // 假設 i 字串不會出現在其他字串中  \n        → Step 5: 針對每個索引 j 在 0 到 strs.length-1  \n            → Decision: j ≠ i?  \n                Yes → Step 6: 呼叫 isSubsequence(strs[i], strs[j]) // 判斷 i 是否為 j 的子序列  \n                → Decision: 結果為 True?  \n                    Yes → Step 7: flag ← False // 找到 i 在另一個字串中出現  \n                    → Step 8: 跳出內層迴圈 // 進入下一個 i  \n                    No  → Step 9: 繼續檢查下個 j  \n            No  → Step 10: 繼續檢查下個 j  \n        → Decision: flag 為 True?  \n            Yes → Step 11: result ← max(result, len(strs[i])) // 更新最大長度  \n            No  → Step 12: 繼續檢查下個 i  \n→ Step 13: End 循環結束  \n\n→ Step 14: Decision: result 仍為 -1?  \n    Yes → Step 15: 回傳 -1 // 沒有找到任何不常見子序列  \n    No  → Step 16: 回傳 result // 返回最長不常見子序列長度  \n\n→ End // 程式結束  \n\nStart isSubsequence(a, b) // 子程式開始  \n→ Step 17: 初始化指標 p_a ← 0, p_b ← 0  \n→ Step 18: 迴圈當 p_b < len(b)  \n    → Decision: p_a < len(a) 且 a[p_a] == b[p_b]?  \n        Yes → Step 19: p_a ← p_a + 1 // 字元相符，移動 a 指標  \n        No  → Step 20: p_b ← p_b + 1 // 字元不符，僅移動 b 指標  \n→ Step 21: Decision: p_a == len(a)?  \n    Yes → Step 22: 回傳 True // a 完全匹配為 b 的子序列  \n    No  → Step 23: 回傳 False // 未匹配完成  \n→ End isSubsequence // 子程式結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findLUSlength(self, strs):\n        # 先按長度遞減排序，方便找到最大長度的字串\n        strs.sort(key=len, reverse=True)\n        for i, s in enumerate(strs):\n            # 判斷 s 是否是任何其他字串的子序列\n            if all(not self.is_subsequence(s, t) for j, t in enumerate(strs) if i != j):\n                return len(s)\n        return -1\n\n    def is_subsequence(self, s, t):\n        # 使用迭代器檢查 s 是否為 t 的子序列\n        it = iter(t)\n        return all(c in it for c in s)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 轉換為 Python list，假設輸入格式為 JSON 陣列字串\n    try:\n        strs = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 若解析失敗，直接輸出 -1\n        print(-1)\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Problem: count number of arithmetic subarrays (subarrays length>=3) in array. Approach: For each index i starting from 2, compute diff between nums[i]-nums[i-1] and compare to previous diff. Keep running length of current arithmetic sequence. When diff same, increment current_len; else reset. Each time current_len >=2? Actually counting subarrays: For each position i, if current_len>=2, then add current_len-1 to answer. Explanation: current_len counts number of consecutive equal diff pairs; length of arithmetic subarray ending at i is current_len+2? Actually if we have diff same over k consecutive pairs, we have k+1 elements. Number of subarrays ending at i that are arithmetic = k. So answer += k. Where k = current_len (after increment). So code: ans=0; current=0; for i in 1..n-1: if i>=2 and diff==prev_diff: current++ else current=0; if current>0: ans+=current; return ans.\n\nLet's produce virtual code line by line.\n\nWe need Start, Decision, etc. Provide comments.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 ans = 0 // 儲存總數\n→ Step 2: 初始化 prevDiff = null // 前一個差值\n→ Step 3: 初始化 currentLen = 0 // 當前相同差值的連續個數\n→ Decision: nums 長度 < 3? // 無法形成長度≥3的子陣列\n    Yes → Step 4: 回傳 0 // 結束\n    No  →\n→ For i 從 1 到 nums.length-1 迭代 // 比較相鄰元素\n    → Decision: i < 2? // 第一次無法計算 diff\n        Yes → Step 5: 設置 prevDiff = nums[i] - nums[i-1] // 設定差值\n        No  →\n            → Step 6: 計算 diff = nums[i] - nums[i-1] // 當前差值\n            → Decision: diff == prevDiff? // 差值是否相同\n                Yes → Step 7: currentLen = currentLen + 1 // 連續相同差值加一\n                No  → Step 8: currentLen = 0 // 重置\n            → Decision: currentLen > 0? // 是否形成算術子陣列\n                Yes → Step 9: ans = ans + currentLen // 累加新子陣列數\n                No  →\n            → Step 10: prevDiff = diff // 更新前一差值\n→ Step 11: 回傳 ans // 結束\nEnd\n\nBut we need each line as single virtual code line with // comment. We need arrow, but we can include indentation by tabs? Use arrow \"→\" before each step. The decision lines have nested steps with indentation. The code lines include Step number and comment.\n\nEnsure each line includes virtual code + space + // explanation.\n\nWe need to maintain formatting.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ans = 0 // 初始化總計算結果  \n→ Step 2: prevDiff = null // 前一個相鄰差值  \n→ Step 3: currentLen = 0 // 連續相同差值的計數  \n→ Decision: nums.length < 3? // 是否能形成長度≥3的子陣列  \n    Yes → Step 4: return ans // 直接回傳 0，結束  \n    No  →  \n→ For i = 1 to nums.length - 1: // 遍歷陣列  \n    → Decision: i < 2? // 第一次沒有足夠的元素計算差值  \n        Yes → Step 5: prevDiff = nums[i] - nums[i-1] // 設定初始差值  \n        No  →  \n            → Step 6: diff = nums[i] - nums[i-1] // 計算當前差值  \n            → Decision: diff == prevDiff? // 差值是否相同  \n                Yes → Step 7: currentLen = currentLen + 1 // 連續相同差值加一  \n                No  → Step 8: currentLen = 0 // 重置計數  \n            → Decision: currentLen > 0? // 是否形成新的算術子陣列  \n                Yes → Step 9: ans = ans + currentLen // 累加子陣列數量  \n                No  →  \n            → Step 10: prevDiff = diff // 更新前一差值為當前差值  \n→ Step 11: return ans // 回傳最終計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\n# 解析輸入字串，提取方括號中的數字列表\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'nums = [1,2,3,4]' 或 '[1,2,3,4]' 的字串。\n    若無法找到合法的列表，回傳空列表。\n    \"\"\"\n    data = data.strip()\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1 or right < left:\n        return []\n    list_str = data[left:right+1]           # 取出完整的 [1,2,3,4]\n    try:\n        return ast.literal_eval(list_str)   # 安全解析為 Python 列表\n    except Exception:\n        return []\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        計算 nums 中長度至少為 3 的等差子陣列數量。\n        \"\"\"\n        n = len(nums)\n        if n < 3:                       # 不能形成長度≥3的子陣列\n            return 0\n\n        total = 0          # 總計算結果\n        curr = 0           # 以 nums[i] 結尾的等差子陣列數量\n\n        # 從第三個元素開始檢查\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                curr += 1         # 延長等差子陣列\n                total += curr     # 新增 curr 個新的等差子陣列\n            else:\n                curr = 0           # 差值不相同，重置計數\n\n        return total\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有資料\n    raw_input = sys.stdin.read()\n    # 解析得到 nums 列表\n    nums = parse_input(raw_input)\n    # 計算並輸出結果\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines, no actual code, using arrows. Steps: start, input s, maybe two pointers left and right, move left until vowel, move right until vowel, swap, continue until left<right, end. Provide explanation comments. Use Start, End, Decision, etc. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收字串 s // 取得要處理的字串\n→ Step 2: 初始化兩個指標 left = 0, right = length(s)-1 // 左右指標分別指向字串開頭與結尾\n→ Decision: 左右指標是否交錯？ // 判斷是否還有未處理的字元\n    Yes → Step 3: 從左側尋找第一個元音 // 逐步向右移動左指標直到碰到元音\n        → Decision: s[left] 是否為元音？ // 檢查左指標所指字元\n            Yes → Step 4: 從右側尋找第一個元音 // 逐步向左移動右指標直到碰到元音\n                → Decision: s[right] 是否為元音？ // 檢查右指標所指字元\n                    Yes → Step 5: 交換 s[left] 與 s[right] // 交換兩個元音的位置\n                    No  → Step 6: right ← right - 1 // 若右側不是元音，右指標左移一格\n                → Decision: 右側仍非元音？ // 檢查是否還需要繼續左移右指標\n                    Yes → Step 6 // 重新檢查右側\n                    No  → Step 7: left ← left + 1 // 左指標右移一格\n            No  → Step 7: left ← left + 1 // 左側非元音，左指標右移一格\n    No  → Step 8: 輸出結果 s // 所有元音已交換完成，輸出最終字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        \"\"\"Reverse only the vowels in the input string.\"\"\"\n        vowels = set(\"aeiouAEIOU\")\n        chars = list(s)\n        left, right = 0, len(chars) - 1\n\n        while left < right:\n            # Move left pointer to next vowel\n            while left < right and chars[left] not in vowels:\n                left += 1\n            # Move right pointer to previous vowel\n            while left < right and chars[right] not in vowels:\n                right -= 1\n            # Swap the two vowels\n            if left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n        return \"\".join(chars)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Extract the string value from input that may look like:\n    s = \"SomeString\"\n    or just SomeString\n    \"\"\"\n    # Find text inside double quotes if present\n    match = re.search(r'\"(.*?)\"', data)\n    if match:\n        return match.group(1)\n    # Remove possible prefix 's ='\n    data = data.strip()\n    if data.lower().startswith(\"s =\"):\n        data = data[3:].strip()\n    # Strip surrounding quotes if any\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        data = data[1:-1]\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.reverseVowels(s)\n    # Output the result surrounded by double quotes as shown in the examples\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "\"AceCreIm\""
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "\"leotcede\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve this problem: Two players, numbers 1..maxChoosableInteger, no replacement. Determine if first player can force win for desiredTotal. Classic Leetcode 464. Approach: recursion with memoization using bitmask for used numbers. If sum of all numbers < desiredTotal then false. Use DFS: if any number chosen leads opponent cannot win, current player can win.\n\nNeed to output in required format: each line \"虛擬碼步驟 // 解釋\". Include arrows etc. Use structure Start, End, Decision: etc. Provide step by step. Probably include helper functions.\n\nLet's craft. We'll show high-level steps: Input, check sum, initialize memo map, define recursive function canWin(usedMask, currentTotal). Use bit operations. Steps inside function: iterate over numbers 1..max, if not used; if currentTotal + i >= desiredTotal return true; else if !canWin(newMask, currentTotal + i) return true; after loop return false. Memoization. Then in main: return canWin(0,0).\n\nWe need to output each step line. Use virtual code like:\n\nStart // start program\n→ Step 1: 讀取 maxChoosableInteger, desiredTotal // input\n→ Decision: if sum of 1..max < desiredTotal? // check impossible\n   Yes → Step 2: 返回 False // cannot reach\n   No  → Step 3: 初始化 memo // map from mask to bool\n→ Function Define canWin(usedMask, currentTotal) // recursion\n   ...\nEnd\n\nWe need to indent decisions properly. Provide each step. Use arrow at beginning of each line. The arrow after decisions can be \"Yes →\" etc. Provide concise explanation after //.\n\nLet's craft. We'll use indentation for nested decisions. Use consistent formatting. Provide all steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 maxChoosableInteger 與 desiredTotal // 取得題目給定的兩個整數  \n→ Decision: 若 1 + 2 + … + maxChoosableInteger < desiredTotal? // 先檢查是否能達到目標  \n  Yes → Step 2: 返回 False // 整體總和不足，第一玩家無法勝利  \n  No  → Step 3: 建立記憶表 memo (鍵為已使用數字的位元組合) // 用於快取子問題結果  \n→ Function Define canWin(usedMask, currentTotal) // 递归判定当前玩家能否获胜  \n  Step 4: 若 memo 已存有 usedMask 的結果, 直接返回 memo[usedMask] // 避免重複計算  \n  Step 5: For i 從 1 到 maxChoosableInteger  \n    Decision: 若 i 已在 usedMask? // 检查该数字是否已被取走  \n      Yes → Continue // 跳过已使用的数字  \n      No  → Step 6: 若 currentTotal + i ≥ desiredTotal? // 直接达到或超过目标  \n        Yes → Step 7: memo[usedMask] ← True, 返回 True // 当前玩家立刻赢得比赛  \n        No  → Step 8: newMask ← usedMask 加入 i 的位标记  \n         Decision: 若 !canWin(newMask, currentTotal + i)? // 检查对手是否无路可逃  \n           Yes → Step 9: memo[usedMask] ← True, 返回 True // 选择 i 可以迫使对手失败  \n           No  → Continue // 继续尝试其它数字  \n  Step 10: memo[usedMask] ← False, 返回 False // 所有选择都无法获胜  \n→ Step 11: 返回 canWin(0, 0) // 从空位元组和总数 0 开始递归  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # 直接贏得遊戲的情況\n        if desiredTotal <= 0:\n            return True\n\n        # 所有數字的總和不足以達到目標，第一個玩家無法贏\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\n            return False\n\n        memo = {}\n\n        def can_win(used: int, remaining: int) -> bool:\n            if remaining <= 0:\n                return True\n            if used in memo:\n                return memo[used]\n\n            for i in range(maxChoosableInteger):\n                bit = 1 << i\n                if not (used & bit):\n                    num = i + 1\n                    # 若本次選擇即可達到目標，或對手無法在此基礎上勝利\n                    if remaining <= num or not can_win(used | bit, remaining - num):\n                        memo[used] = True\n                        return True\n\n            memo[used] = False\n            return False\n\n        return can_win(0, desiredTotal)\n\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，提取兩個整數\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(numbers) >= 2:\n        max_choosable, desired_total = numbers[0], numbers[1]\n    else:\n        # 若輸入格式不符，使用預設值（可自行調整）\n        max_choosable, desired_total = 0, 0\n\n    sol = Solution()\n    result = sol.canIWin(max_choosable, desired_total)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for max profit problem. Use Start, Decision, etc. Outline: iterate days, track holding and not holding. Classic DP: hold, notHold. For each day: newHold = max(oldHold, oldNotHold - price) ; newNotHold = max(oldNotHold, oldHold + price). But we can also think simple: profit sum of all positive differences. Because unlimited transactions. So algorithm: profit=0; for i in 1..n-1: if prices[i]>prices[i-1]: profit+=prices[i]-prices[i-1]. Output profit. That's simpler.\n\nLet's produce virtual code steps. Use Start, Step, Decision. Let's produce lines:\n\nStart\n→ Step 1: Initialize profit = 0 // start profit\n→ Step 2: For i from 1 to len(prices)-1 // iterate over days after first\n    → Decision: if prices[i] > prices[i-1] ?\n        Yes → Step 3: profit = profit + (prices[i] - prices[i-1]) // add gain\n        No  → Step 4: // do nothing\n→ Step 5: Output profit // maximum profit\nEnd\n\nWe must include arrow lines. The \"→\" should precede each line.\n\nNeed to use virtual code arrow symbol for decision and sub-steps.\n\nWe also include indentation for nested steps. Use spaces.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 profit = 0 // 用來累積總利潤  \n→ Step 2: 從第二天開始遍歷價格 (i = 1 到 len(prices)-1) // 每天檢查是否能賣出賺錢  \n  → Decision: 如果 prices[i] > prices[i-1] ? // 當天價格高於前一天  \n   Yes → Step 3: profit = profit + (prices[i] - prices[i-1]) // 加入今日漲幅至總利潤  \n   No  → Step 4: // 什麼也不做，繼續下一天  \n→ Step 5: 輸出 profit // 回傳最大的可得利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    \"\"\"計算最大利潤：累加所有正向漲幅。\"\"\"\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            profit += prices[i] - prices[i - 1]\n    return profit\n\ndef main():\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read().strip()\n    # 取得第一個 '[' 到最後一個 ']' 的子字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        print(0)\n        return\n    list_str = data[start:end + 1]\n    try:\n        prices = ast.literal_eval(list_str)\n    except Exception:\n        prices = []\n    # 輸出計算得到的最大利潤\n    print(max_profit(prices))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find shortest palindrome by adding characters in front of string s. Classic solution: find longest prefix which is palindrome? Actually we can use KMP on s + \"#\" + reverse(s) to find longest palindromic prefix? Wait: To add characters in front, we find longest prefix of s that is a palindrome? Actually we want to add characters to front so resulting string is palindrome. Equivalent to find longest suffix of s that is palindrome? Let's think: If we add characters in front, we keep suffix unchanged. The added part must be reverse of the prefix that doesn't match. Standard solution: compute longest palindromic prefix? Wait typical problem LeetCode 214 Shortest Palindrome: find longest palindromic prefix of s, then add reverse of the remaining suffix in front. So algorithm: Compute longest prefix which is palindrome. Then prepend reverse of remaining part. Implementation via KMP on s + \"#\" + reverse(s). So virtual code lines: compute rev, build combined string, run KMP to get longest palindrome prefix length, build result.\n\nWe'll produce steps with virtual code arrows. Let's craft.\n\nSteps:\n\n1. Start\n2. Input string s\n3. Compute rev = reverse(s)\n4. Build combined = s + \"#\" + rev\n5. Compute lps array for combined (failure function)\n6. After KMP, lps[last] gives length of longest palindrome prefix\n7. Remaining = s[lps_last:]\n8. Prepend reverse(Remaining) to s\n9. Return result\n10. End\n\nWe need to show virtual code lines with explanations. Use arrow style.\n\nWe also might add decision? But straightforward.\n\nLet's produce each line with virtual code and explanation.\n\nWe'll include step numbers optionally but not necessary; each line is step.\n\nUse \"Step X:\" maybe.\n\nLet's produce.\n\nAlso include Start and End.\n\nMake sure to follow format: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者處取得待處理的字串  \n→ Step 2: 計算 rev = 逆序(s) // 取 s 的反轉字串，用於後續比對  \n→ Step 3: 建立 combined = s + \"#\" + rev // 形成主串 + 分隔符 + 逆序，用於 KMP 失敗函數  \n→ Step 4: 初始化 lps 陣列長度為 combined 的長度，全部設為 0 // LPS 用於存放 KMP 失敗函數  \n→ Step 5: 為 i 從 1 到 combined.length-1  \n    → Decision: 若 combined[i] == combined[length] ? // 判斷是否能延伸前綴  \n      Yes → length++ ; lps[i] = length ; i++ // 成功延伸，更新 LPS  \n      No  → Decision: 若 length == 0? // 失敗時是否需要回溯  \n        Yes → lps[i] = 0 ; i++ // 直接置 0  \n        No  → length = lps[length-1] // 回溯至上一個可能的長度，重試  \n→ Step 6: palindromeLen = lps[combined.length-1] // LPS 最後一個值即為 s 的最大回文前綴長度  \n→ Step 7: suffix = s.substring(palindromeLen) // 從該長度開始的子字串需要補齊  \n→ Step 8: prepend = reverse(suffix) // 將缺失的部分倒序作為前綴  \n→ Step 9: result = prepend + s // 把前綴加到原字串前面形成最短回文  \n→ Step 10: 輸出 result // 回傳或顯示最短回文字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        \"\"\"Return the shortest palindrome by adding characters in front of s.\"\"\"\n        if not s:\n            return \"\"\n\n        # Build string for KMP: original + '#' + reversed(original)\n        rev = s[::-1]\n        combined = s + '#' + rev\n\n        n = len(combined)\n        lps = [0] * n  # longest prefix-suffix array\n\n        # Build LPS array\n        for i in range(1, n):\n            length = lps[i - 1]\n            while length > 0 and combined[i] != combined[length]:\n                length = lps[length - 1]\n            if combined[i] == combined[length]:\n                length += 1\n            lps[i] = length\n\n        # Length of longest palindromic prefix\n        palin_len = lps[-1]\n        # Characters to add in front are the reverse of the remaining suffix\n        to_add = s[palin_len:][::-1]\n        return to_add + s\n\ndef _parse_input(raw: str) -> str:\n    \"\"\"Parse the input string to extract the value of s.\"\"\"\n    raw = raw.strip()\n    if not raw:\n        return \"\"\n    # If the input contains an assignment like \"s = '...'\" extract the value\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        value = value.strip()\n    else:\n        value = raw\n    # Remove surrounding quotes if present\n    if (value.startswith(\"'\") and value.endswith(\"'\")) or (value.startswith('\"') and value.endswith('\"')):\n        value = value[1:-1]\n    return value\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    s = _parse_input(raw_input)\n    solution = Solution()\n    result = solution.shortestPalindrome(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "aaacecaaa"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "dcbabcd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode713.json",
    "problem_index_in_file": 0,
    "title": "Subarray Product Less Than K",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for sliding window approach to count subarrays with product < k. In Chinese. Must be line-by-line. Each line: virtual code + // explanation.\n\nUse Start, End, Decision:, arrows. Let's craft.\n\nWe'll include steps: if k <=1 return 0.\n\nInitialize product=1, left=0, count=0.\n\nFor right from 0 to n-1: product*=nums[right]; while product>=k and left<=right: product/=nums[left]; left++; After while, count += right-left+1. End.\n\nLet's write lines accordingly.\n\nAlso mention array length etc. Provide comments.\n\nMake sure each line ends with // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 k <= 1? // 檢查乘積是否可能小於 k  \n    Yes → Step 1: 回傳 0 // k 為 0 或 1 時不存在滿足條件的子陣列  \n    No  → Step 2: 初始化 product = 1, left = 0, count = 0 // 設定滑動窗口參數  \n→ Step 3: 從 right = 0 到 n-1 迴圈 // 依次考慮每個元素作為右端點  \n    → Step 4: product = product * nums[right] // 更新乘積加入新元素  \n    → Decision: 當 product >= k 且 left <= right? // 需要縮小窗口以降低乘積  \n        Yes → Step 5: product = product / nums[left] // 移除左端點元素的乘積  \n        → Step 6: left = left + 1 // 右移左端點  \n        → Decision: product >= k 且 left <= right? // 仍然超過限制，重複縮小窗口  \n            Yes → repeat Step 5-6  \n            No  → 回到 Step 7  \n        No  → 回到 Step 7  \n    No  → Step 7: count = count + (right - left + 1) // 新增所有合法子陣列  \n→ End // 程式執行結束，回傳 count\n\n(Note：虛擬碼中「repeat Step 5-6」代表在 while 條件內持續執行，確保乘積回到 k 之下。)",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numSubarrayProductLessThanK(self, nums, k):\n        # 若 k <= 1，任何正整數子陣列乘積都至少為 1，無法小於 k\n        if k <= 1:\n            return 0\n        prod = 1          # 當前滑動窗口的乘積\n        left = 0          # 左邊界\n        result = 0        # 合法子陣列總數\n        for right, val in enumerate(nums):\n            prod *= val\n            # 當乘積大於等於 k 時，縮小窗口直到符合條件\n            while prod >= k and left <= right:\n                prod //= nums[left]\n                left += 1\n            # 以 right 為右邊界的所有合法子陣列數量\n            result += right - left + 1\n        return result\n\ndef parse_input(input_text: str):\n    \"\"\"\n    解析形如 'nums = [10,5,2,6], k = 100' 的字串，\n    返回 (nums, k) 的元組。\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', input_text)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', input_text)\n    if not nums_match or not k_match:\n        raise ValueError(\"Invalid input format.\")\n    nums_str = nums_match.group(1).strip()\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    ans = sol.numSubarrayProductLessThanK(nums, k)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,5,2,6], k = 100",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3], k = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format. Steps: read string s, find all substrings length 10, track counts, output those >1.\n\nWe must use Start, End, Decision, etc. We'll produce algorithm: use hash map, loop i from 0 to len-10, substring, increment count, after loop iterate over map and collect keys where count>1.\n\nWe'll follow step by step. Use arrows.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定字串 s // 接收 DNA 序列\n→ Step 2: 初始化空字典 freq // 用於紀錄每個 10 字符長子字串出現次數\n→ Step 3: 設定變數 n = len(s) // 序列長度\n→ Decision: n 是否小於 10? // 若長度不足 10 無法形成子字串\n    Yes → End // 程式結束\n    No  →\n→ Step 4: 循環 i 從 0 到 n-10 // 遍歷所有可能的起始位置\n        → Step 5: sub = s[i:i+10] // 取得長度 10 的子字串\n        → Step 6: freq[sub] = freq.get(sub,0)+1 // 更新出現次數\n→ Step 7: 初始化空列表 result // 儲存重複出現的子字串\n→ Step 8: 循環 sub, cnt 在 freq.items() // 遍歷字典\n        → Decision: cnt 是否大於 1? // 判斷是否重複\n            Yes → Step 9: result.append(sub) // 加入結果\n            No  → // 不做任何事\n→ Step 10: 輸出 result // 回傳所有重複的 10 字符長子字串\nEnd // 程式執行結束\n\nCheck format: each line with //.\n\nAlso include arrows. Use \"Yes →\" and \"No →\".\n\nMake sure indentation and arrows consistent. Provide exactly as requested.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定字串 s // 接收 DNA 序列\n→ Step 2: 初始化空字典 freq // 用於紀錄每個 10 字符長子字串出現次數\n→ Step 3: 設定變數 n = len(s) // 序列長度\n→ Decision: n 是否小於 10? // 若長度不足 10 無法形成子字串\n    Yes → End // 程式結束\n    No  →\n→ Step 4: 循環 i 從 0 到 n-10 // 遍歷所有可能的起始位置\n        → Step 5: sub = s[i:i+10] // 取得長度 10 的子字串\n        → Step 6: freq[sub] = freq.get(sub,0)+1 // 更新出現次數\n→ Step 7: 初始化空列表 result // 儲存重複出現的子字串\n→ Step 8: 循環 sub, cnt 在 freq.items() // 遍歷字典\n        → Decision: cnt 是否大於 1? // 判斷是否重複\n            Yes → Step 9: result.append(sub) // 加入結果\n            No  → // 不做任何事\n→ Step 10: 輸出 result // 回傳所有重複的 10 字符長子字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if '=' in data:\n        _, _, rest = data.partition('=')\n        rest = rest.strip()\n        if rest and rest[0] in (\"'\", '\"') and rest[-1] in (\"'\", '\"'):\n            dna = rest[1:-1]\n        else:\n            dna = rest\n    else:\n        dna = data.strip(\"'\\\"\")\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(dna)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "[\"AAAAAAAAAA\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for problem: longest increasing subsequence length. We must output each line with 虛擬碼步驟 + space + // explanation. Use Start, Decision, etc. Not actual code. So we need algorithm: dynamic programming O(n^2) or patience sorting O(n log n). Likely simple DP. We'll produce steps:\n\nStart\n→ Step 1: Initialize dp array of length n with 1 // Each element at least length 1\n→ Step 2: For i from 1 to n-1\n→ Step 3: For j from 0 to i-1\n→ Decision: If nums[j] < nums[i]? // Check increasing\n→ Step 4: Update dp[i] = max(dp[i], dp[j] + 1) // Extend subsequence\n→ Decision: After loops\n→ Step 5: Return max(dp) // Longest length\n\nAlso need to handle empty array.\n\nAlso we can do using binary search O(n log n) but DP is fine.\n\nWe need to produce each step line. Use arrow for each new line: \"→\" indicates next step. For decisions: \"Decision:\" with arrow for Yes/No.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: If nums is empty then Return 0 // 空陣列直接返回0\n→ Step 2: n ← length(nums) // 獲取陣列長度\n→ Step 3: dp ← array of size n, all elements = 1 // 初始化 dp，最短子序列長度為 1\n→ Decision: For i from 1 to n-1? // 檢查是否需要遍歷\n    Yes → Step 4: For j from 0 to i-1 // 比較前面的元素\n        → Decision: If nums[j] < nums[i]? // 判斷是否可以延長子序列\n            Yes → Step 5: dp[i] ← max(dp[i], dp[j] + 1) // 更新 dp[i]\n            No  → // 什麼也不做\n    No → // i 循環結束\n→ Step 6: maxLen ← 0 // 初始化最大長度\n→ Decision: For each val in dp? // 找出最大值\n    Yes → Step 7: maxLen ← max(maxLen, val) // 更新最大值\n    No  → // 完成\n→ Step 8: Return maxLen // 返回最長子序列長度\nEnd // 程式執行結束\n\nBut we need proper formatting with arrows. We should indent decisions.\n\nWe need \"Decision:\" lines with Yes → and No →. Use spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 如果 nums 為空則 Return 0 // 空陣列直接回傳長度 0  \n→ Step 2: n ← length(nums) // 取得陣列長度  \n→ Step 3: dp ← 數組長度 n，全部元素初始化為 1 // 每個位置至少能成為長度 1 的子序列  \n→ Decision: i 是否小於 n? // 是否需要進行外層迴圈  \n Yes → Step 4: i ← 1  \n  → Decision: i < n? // 外層迴圈條件  \n   Yes → Step 5: j ← 0  \n    → Decision: j < i? // 內層迴圈條件  \n     Yes → Step 6: 如果 nums[j] < nums[i]? // 判斷能否延長子序列  \n      Yes → Step 7: dp[i] ← max(dp[i], dp[j] + 1) // 更新 dp[i]  \n      No  → // 無操作  \n     No → // j 迴圈結束  \n      → Step 8: j ← j + 1  \n      → 回到 Decision: j < i?  \n    No → // i 迴圈結束  \n     → Step 9: i ← i + 1  \n     → 回到 Decision: i < n?  \n No  → // 外層迴圈結束  \n→ Step 10: maxLen ← 0 // 初始化最大長度  \n→ Decision: val 是否存在於 dp? // 遍歷 dp 找最大值  \n Yes → Step 11: maxLen ← max(maxLen, val) // 更新最大長度  \n  → // 下一個 val  \n No  → // 完成遍歷  \n→ Step 12: Return maxLen // 返回最長遞增子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef lengthOfLIS(nums):\n    \"\"\"計算最長遞增子序列的長度（使用 patience sorting）\"\"\"\n    tails = []\n    for num in nums:\n        idx = bisect.bisect_left(tails, num)\n        if idx == len(tails):\n            tails.append(num)\n        else:\n            tails[idx] = num\n    return len(tails)\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取方括號內的列表字串\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = []\n    else:\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)  # 安全解析列表\n\n    result = lengthOfLIS(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all permutations of an array of distinct integers. Should be step-by-step, using decision, Start, End, etc. Each line: virtual code step + space + // explanation. Use arrows.\n\nWe need to generate a backtracking algorithm. So start: Start. Step: Input array nums. Then maybe convert to list, etc. But we need to produce a generic algorithm: use recursion/backtracking to generate permutations. Steps: maintain current permutation, visited flags, result list. Use recursion function backtrack(level). At each step, iterate over nums, if not visited, add to current, mark visited, rec backtrack(level+1), then backtrack (unmark, pop). When level==len(nums), add copy to result.\n\nWe need to produce each step line. Each line may be a \"Step\" description. Use decision arrow for loops? But loops may not be decision. But we can express decisions like \"Decision: If index visited?\" etc. Use Yes and No branches. We'll produce the algorithm.\n\nLet's think of lines: \n1. Start\n2. Step 1: Store nums length n // store length\n3. Step 2: Initialize result list res empty // result holder\n4. Step 3: Initialize visited array of size n all false // track used elements\n5. Step 4: Initialize current permutation list cur empty // partial perm\n6. Step 5: Call backtrack(0) // start recursion\n\nDefine backtrack function:\n7. Decision: If depth == n? // if we've chosen n numbers\n   - Yes → Step: Add copy of cur to res // add permutation\n   - No → Loop over i in 0..n-1\n          Decision: If visited[i] == false? // if element unused\n             Yes → Step: Append nums[i] to cur // add to partial\n                    Step: Mark visited[i] true\n                    Step: Call backtrack(depth+1)\n                    Step: Unmark visited[i] false\n                    Step: Remove last element from cur\n\nEnd // after backtrack returns.\n\nEnd // final result.\n\nBut we need to produce step lines as virtual code. Use arrow and decisions with Yes → and No →.\n\nLet's produce lines accordingly. Each line is \"虛擬碼步驟 // 解釋\". We can include indentation with arrow. For decisions we need indentation. We need to use \"Decision:\" lines and then indentation with Yes →, No →.\n\nUse Start, End.\n\nOk produce.\n\nMake sure each line is separate.\n\nLet's draft.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 將使用者提供的整數陣列存入變數\n→ Step 2: 計算陣列長度 n = nums.length // 確定排列數量\n→ Step 3: 初始化結果列表 res = [] // 用於存放所有排列\n→ Step 4: 初始化訪問標誌 visited = [false] * n // 標記哪些元素已被使用\n→ Step 5: 初始化目前排列 cur = [] // 用於構造部分排列\n→ Step 6: 定義遞迴函式 backtrack(depth) // depth 表示已選取的元素數\n→ Step 7: 呼叫 backtrack(0) // 開始從空排列進行回溯\n\nNow inside backtrack function:\n\n→ Decision: depth == n? // 判斷是否已經選到 n 個元素\n    Yes → Step 8: res.append(cur.copy()) // 完整排列加入結果\n    No  → Step 9: for i in range(n): // 遍歷所有元素索引\n              → Decision: visited[i] == false? // 檢查該元素是否未被使用\n                  Yes → Step 10: cur.append(nums[i]) // 加入目前排列\n                       → Step 11: visited[i] = true // 標記已使用\n                       → Step 12: backtrack(depth + 1) // 進行下一層遞迴\n                       → Step 13: visited[i] = false // 回溯，恢復標記\n                       → Step 14: cur.pop() // 移除最後一個元素，恢復部分排列\n                  No  → // 若已被使用，跳過\n\nEnd // 遞迴結束後返回\n\nEnd // 程式執行結束\n\nBut we need each line in separate lines. We also need to indent the substeps.\n\nLet's write each line as separate.\n\nAlso ensure each line ends with comment.\n\nCheck format: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nLet's write final.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 將使用者提供的整數陣列存入變數\n→ Step 2: 計算陣列長度 n = nums.length // 確定排列數量\n→ Step 3: 初始化結果列表 res = [] // 用於存放所有排列\n→ Step 4: 初始化訪問標誌 visited = [false] * n // 標記哪些元素已被使用\n→ Step 5: 初始化目前排列 cur = [] // 用於構造部分排列\n→ Step 6: 定義遞迴函式 backtrack(depth) // depth 表示已選取的元素數\n→ Step 7: 呼叫 backtrack(0) // 開始從空排列進行回溯\n\n→ Decision: depth == n? // 判斷是否已經選到 n 個元素\n    Yes → Step 8: res.append(cur.copy()) // 完整排列加入結果\n    No  → Step 9: for i in range(n): // 遍歷所有元素索引\n              → Decision: visited[i] == false? // 檢查該元素是否未被使用\n                  Yes → Step 10: cur.append(nums[i]) // 加入目前排列\n                       → Step 11: visited[i] = true // 標記已使用\n                       → Step 12: backtrack(depth + 1) // 進行下一層遞迴\n                       → Step 13: visited[i] = false // 回溯，恢復標記\n                       → Step 14: cur.pop() // 移除最後一個元素，恢復部分排列\n                  No → // 若已被使用，跳過\n\nEnd // 遞迴結束後返回\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(path, visited):\n            if len(path) == len(nums):\n                res.append(path.copy())\n                return\n            for i in range(len(nums)):\n                if not visited[i]:\n                    visited[i] = True\n                    path.append(nums[i])\n                    backtrack(path, visited)\n                    path.pop()\n                    visited[i] = False\n\n        backtrack([], [False] * len(nums))\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list of numbers from the input string\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        nums = []\n    else:\n        nums_str = data[start:end+1]\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code steps. Problem: number of ways to represent n as sum of consecutive positive integers. Approach: For each starting point i from 1 to n, find if sum of consecutive starting from i equals n. But more efficient: count number of odd divisors of n. Classic solution: Number of ways equals number of odd divisors of n. So algorithm: Count odd divisors of n. Steps: Start, Input n, Set count=0, For each i from 1 to sqrt(n): if n mod i ==0 then check divisor d1=i, d2=n/i. For each divisor, if odd increase count. Then End. Output count. Use virtual steps.\n\nWe need each line with arrow etc. Use Start, Decision etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者處取得目標數字  \n→ Step 2: 設定變數 count ← 0 // 用於計數合法分解個數  \n→ Step 3: 設定變數 i ← 1 // 迴圈起始索引  \n→ Decision: i * i ≤ n? // 判斷是否已檢查完所有可能除數  \n    Yes → Step 4: 如果 n mod i == 0? // i 是否為 n 的除數  \n        Yes → Step 5: 設定變數 d1 ← i // 第一個除數  \n        Yes → Step 6: 如果 d1 mod 2 == 1? // d1 是否為奇數  \n            Yes → Step 7: count ← count + 1 // 奇數除數數目加一  \n        Yes → Step 8: 設定變數 d2 ← n / i // 第二個除數  \n        Yes → Step 9: 如果 d2 ≠ d1 且 d2 mod 2 == 1? // d2 與 d1 不同且奇數  \n            Yes → Step 10: count ← count + 1 // 奇數除數數目加一  \n        No  → (跳過 Step 8-10)  \n    No  → (跳過 Step 4-10)  \n    → Step 11: i ← i + 1 // 迴圈索引加一  \n    → 回到 Decision: i * i ≤ n?  \nEnd // 程式執行結束  \n→ Step 12: 輸出 count // 顯示能表示為連續正整數和的組合個數",
      "generated_code": "import sys\nimport re\n\ndef count_consecutive_sums(n: int) -> int:\n    \"\"\"\n    計算 n 可以寫成連續正整數之和的方式數量。\n    這個數量等於 n 的奇數因子個數。\n    \"\"\"\n    count = 0\n    i = 1\n    # 只需檢查到 sqrt(n)\n    while i * i <= n:\n        if n % i == 0:\n            d1 = i\n            d2 = n // i\n            if d1 % 2 == 1:\n                count += 1\n            if d2 != d1 and d2 % 2 == 1:\n                count += 1\n        i += 1\n    return count\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中抽取整數，忽略任何文字\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = count_consecutive_sums(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Each line: virtual code step + space + // explanation.\n\nUse arrow \"→\" etc. Need Start End. Decision lines with Yes → and No →.\n\nWe must not output actual code, just pseudo.\n\nWe need algorithm: compute sum of squares digits, loop until 1 or repeat. We need a set to detect cycle. So steps: Start, set current = n, set seen empty, Decision: if current==1? Yes→ return true; No→ if current in seen? Yes→ return false; No→ add current to seen, compute sum of squares digits → update current and loop back.\n\nWe need to indicate loop. Use Decision lines and arrows.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Set current = n // 初始化目前數字\n→ Step 2: Set seen = empty set // 用於記錄已出現的數字\n→ Decision: current 等於 1? // 判斷是否已達 1\n    Yes → Step 3: 回傳 true // 是幸運數\n    No → Decision: current 是否已存在於 seen? // 檢查是否重複\n        Yes → Step 4: 回傳 false // 出現循環，非幸運數\n        No  → Step 5: 加入 current 至 seen // 記錄本次數字\n            → Step 6: 計算 current = sum of squares of its digits // 產生下一個數字\n            → Step 7: 回到 Decision: current 等於 1? // 重新檢查\nEnd // 程式結束\n\nNeed to include arrow for each. Let's ensure each line has arrow or step. Step 6 arrow. Step 7 arrow. End.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Set current = n // 初始化目前數字\n→ Step 2: Set seen = empty set // 用於記錄已出現的數字\n→ Decision: current 等於 1? // 判斷是否已達 1\n    Yes → Step 3: 回傳 true // 是幸運數\n    No → Decision: current 是否已存在於 seen? // 檢查是否重複\n        Yes → Step 4: 回傳 false // 出現循環，非幸運數\n        No  → Step 5: 加入 current 至 seen // 記錄本次數字\n            → Step 6: 計算 current = sum of squares of its digits // 產生下一個數字\n            → Step 7: 回到 Decision: current 等於 1? // 重新檢查\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef is_happy(n: int) -> bool:\n    \"\"\"\n    判斷數字 n 是否為「幸運數」。\n    \"\"\"\n    def get_next(number: int) -> int:\n        \"\"\"回傳 number 的各位數字平方和。\"\"\"\n        total = 0\n        while number > 0:\n            digit = number % 10\n            total += digit * digit\n            number //= 10\n        return total\n\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = get_next(n)\n    return n == 1\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，輸出對應的結果。\n    例：輸入 'n = 19' 會輸出 'true'。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 從輸入字串中抽取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        print(\"false\")  # 若無合法數字，視為 false\n        return\n    n = int(match.group())\n\n    result = is_happy(n)\n    # Python 會輸出 True/False，需轉成小寫字串\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line, with explanations, for rotating array right by k steps. Should not output actual code, only pseudo steps.\n\nWe need to include Start, End, Decision, etc.\n\nLet's craft algorithm: we need to compute k = k % len(nums). Then reverse whole array, reverse first k, reverse rest.\n\nAlternatively we could copy to new array, but typical approach is reverse.\n\nWe produce steps:\n\nStart // start\n\n→ Step 1: n ← length of nums // get array length\n\n→ Decision: if n == 0? // check empty\n\n    Yes → End // nothing to rotate\n\n    No  →\n\n→ Step 2: k ← k mod n // normalize steps\n\n→ Step 3: reverse(nums, 0, n-1) // reverse entire array\n\n→ Step 4: reverse(nums, 0, k-1) // reverse first k elements\n\n→ Step 5: reverse(nums, k, n-1) // reverse remaining elements\n\n→ End // finished\n\nWe should also maybe include error handling, but it's enough.\n\nMake sure each line has the format: \"虛擬碼步驟 // 解釋\". Use arrow arrow etc.\n\nWe also need to use \"Start\" and \"End\". And \"Decision:\" lines with Yes→ and No→.\n\nLet's produce.\n\nNote: Need to put arrow '→' after Start and End? In example they had \"Start // 程式開始執行\" no arrow. The arrow is used in steps after.\n\nThus:\n\nStart // 程式開始執行\n\n→ Step 1: n ← length(nums) // 取得陣列長度\n\n→ Decision: n == 0? // 檢查是否為空陣列\n\n    Yes → End // 若陣列為空，結束程式\n\n    No  →\n\n→ Step 2: k ← k mod n // 將移動步數規範到 0~n-1\n\n→ Step 3: reverse(nums, 0, n-1) // 先將整個陣列倒轉\n\n→ Step 4: reverse(nums, 0, k-1) // 再將前 k 個元素倒轉\n\n→ Step 5: reverse(nums, k, n-1) // 最後將剩下的 n-k 個元素倒轉\n\n→ End // 程式執行結束\n\nMake sure \"Decision:\" line indent with spaces? Example had indent, but not mandatory. Provide exactly as example.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: n == 0? // 檢查陣列是否為空  \n    Yes → End // 若陣列為空，直接結束程式  \n    No  →  \n→ Step 2: k ← k mod n // 將移動步數規範到 0~n-1  \n→ Step 3: reverse(nums, 0, n-1) // 先將整個陣列倒轉  \n→ Step 4: reverse(nums, 0, k-1) // 再將前 k 個元素倒轉  \n→ Step 5: reverse(nums, k, n-1) // 最後將剩下的 n-k 個元素倒轉  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    @staticmethod\n    def rotate(nums, k):\n        \"\"\"將陣列右移 k 步，使用切片實作。\"\"\"\n        n = len(nums)\n        if n == 0:\n            return nums\n        k %= n  # 規範到 0~n-1\n        nums[:] = nums[-k:] + nums[:-k]\n        return nums\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試使用正則表達式擷取「nums = [...]」與「k = ...」\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*([-\\d]+)', data)\n    if nums_match and k_match:\n        nums_str = nums_match.group(1)\n        k_str = k_match.group(1)\n        nums = ast.literal_eval(nums_str)   # 轉成 list\n        k = int(k_str)\n    else:\n        # 失敗時，嘗試以逗號分隔的簡易解析\n        nums = []\n        k = 0\n        parts = re.split(r',\\s*', data)\n        for part in parts:\n            if part.startswith('['):\n                nums = ast.literal_eval(part)\n            elif part.startswith('k'):\n                k = int(part.split('=')[1].strip())\n\n    # 執行旋轉\n    Solution.rotate(nums, k)\n    # 將結果輸出為 Python list 的字串格式\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5, 6, 7, 1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3, 99, -1, -100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Input: target area. Find integer dimensions L>=W, area = area, minimize difference L-W. We need algorithm: iterate W from sqrt(area) downwards? Actually W <= L. For given area, choose factors. Approach: iterate w from sqrt(area) down to 1, find if area%w==0, then l=area/w, ensure l>=w, difference minimal because w close to sqrt. Break. Return [l,w]. Steps: start, input area, compute sqrt, set bestL, bestW, iterate w from floor(sqrt(area)) downto 1, if area%w==0, l=area/w, check l>=w, set bestL=l, bestW=w, break. Output array. End. Add decisions. Use virtual code arrow.\n\nNeed to include explanation after each line. Use \"虛擬碼步驟 // 解釋\". Use Start, End. Use arrow. Use Decision etc. We'll produce line by line. Let's generate.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得目標面積 A // 從使用者取得整數面積值\n→ Step 2: 計算 sqrtA = floor(√A) // 獲取面積平方根的下限，作為寬度的初始搜尋上界\n→ Step 3: 初始化 bestL = 0, bestW = 0 // 用於存儲找到的最佳長寬\n→ Decision: 是否從 w = sqrtA 開始遞減到 1? // 檢查搜尋範圍是否正確\n    Yes → Loop 1: for w = sqrtA downto 1 // 從接近平方根的值向下尋找可整除的寬度\n        → Step 4: Decision: 若 A mod w = 0? // 判斷當前寬度是否能整除面積\n            Yes → Step 5: 計算 l = A / w // 找到相應的長度\n            → Decision: 是否滿足 l >= w? // 確保長度不小於寬度\n                Yes → Step 6: 設定 bestL = l, bestW = w // 找到符合條件的最佳解\n                → Step 7: 跳出 Loop 1 // 因為從平方根往下遞減，第一次符合條件即為差距最小\n            No  → Step 8: 繼續下一個 w // 若 l < w，則忽略此組合\n        No  → Step 9: 繼續下一個 w // 若不是因子，跳過\n→ Step 10: Output [bestL, bestW] // 回傳長度與寬度的陣列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\nclass Solution:\n    def constructRectangle(self, area: int):\n        \"\"\"\n        Find integer length L and width W such that:\n        - L * W == area\n        - L >= W\n        - L - W is minimal\n        Returns the pair as [L, W].\n        \"\"\"\n        # Start from the integer square root of area\n        w = int(math.isqrt(area))\n        # Decrease w until we find a divisor\n        while area % w != 0:\n            w -= 1\n        # Corresponding length\n        l = area // w\n        return [l, w]\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read()\n    # Extract the integer area value using a regular expression\n    match = re.search(r'\\d+', data)\n    if not match:\n        print(\"[]\")\n        return\n    area = int(match.group())\n    sol = Solution()\n    result = sol.constructRectangle(area)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37, 1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427, 286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line with arrow or Start/End etc, no actual code. Use virtual code like:\n\nStart\n→ Step 1: 初始化字母頻率計數器 // 建立 26 個字母計數\n→ Step 2: 迭代 magazine 字符並更新頻率 // 以每個字母增加計數\n→ Decision: 如果 ransomNote 內每個字母頻率大於等於對應計數? // 檢查是否足夠\n   Yes → Step 3: 返回 true\n   No → Step 4: 返回 false\nEnd\n\nBut also need to handle generic strings with any characters, not just lowercase? Might use map. So produce more detailed steps.\n\nWe should produce each line with arrow arrow for decision branches.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 建立字典 letterCount // 用來記錄 magazine 內各字母出現次數\n→ Step 2: 對每個字符 ch 在 magazine 中，若 ch 存在於字典，則 letterCount[ch] += 1；否則 letterCount[ch] = 1 // 計算每個字母的頻率\n→ Decision: 是否所有 ransomNote 中的字符都在 letterCount 且次數足夠? // 檢查能否構造\n   Yes → Step 3: 返回 true // 所有字母足夠，能構造\n   No  → Step 4: 返回 false // 缺少必要字母\nEnd // 程式結束\n\nAdd explanation after each line.\n\nLet's ensure formatting: each line: \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nSo lines:\n\nStart // 程式開始\n→ Step 1: 建立字典 letterCount // 用來記錄 magazine 內各字母出現次數\n→ Step 2: 對每個字符 ch 在 magazine 中，若 ch 存在於字典，則 letterCount[ch] += 1；否則 letterCount[ch] = 1 // 計算每個字母的頻率\n→ Decision: 是否所有 ransomNote 中的字符都在 letterCount 且次數足夠? // 檢查能否構造\n    Yes → Step 3: 返回 true // 所有字母足夠，能構造\n    No  → Step 4: 返回 false // 缺少必要字母\nEnd // 程式結束\n\nCheck indentation: After Decision line, we indent Yes and No branches. Should follow example format: each branch with arrow inside indentation.\n\nAlso ensure that \"虛擬碼步驟\" part is before arrow? Example shows \"→ Step 1: ...\" So we replicate.\n\nAll good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立字典 letterCount // 用來記錄 magazine 內各字母出現次數  \n→ Step 2: 對每個字符 ch 在 magazine 中，若 ch 存在於字典，則 letterCount[ch] += 1；否則 letterCount[ch] = 1 // 計算每個字母的頻率  \n→ Decision: 是否所有 ransomNote 中的字符都在 letterCount 且次數足夠? // 檢查能否構造  \n  Yes → Step 3: 返回 true // 所有字母足夠，能構造  \n  No  → Step 4: 返回 false // 缺少必要字母  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport collections\n\ndef can_construct(ransom_note: str, magazine: str) -> bool:\n    \"\"\"判斷 ransom_note 能否用 magazine 的字母構成。\"\"\"\n    ransom_cnt = collections.Counter(ransom_note)\n    magazine_cnt = collections.Counter(magazine)\n    for ch, cnt in ransom_cnt.items():\n        if cnt > magazine_cnt.get(ch, 0):\n            return False\n    return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 先嘗試從雙引號中抓取兩個字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) < 2:\n        # 若沒抓到，再嘗試單引號\n        matches = re.findall(r\"'([^']*)'\", data)\n\n    if len(matches) >= 2:\n        ransom_note, magazine = matches[0], matches[1]\n    else:\n        # 若以上皆無，使用簡單分隔方式處理\n        parts = data.split(',')\n        ransom_note = parts[0].split('=')[1].strip().strip('\"\\'')\n        magazine = parts[1].split('=')[1].strip().strip('\"\\'')\n    \n    result = can_construct(ransom_note, magazine)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, for the problem: longest wiggle subsequence length. Standard DP: keep up[i], down[i] meaning longest wiggle ending at i with last diff positive (up) or negative (down). Complexity O(n). But we can produce simpler: iterate, maintain up, down.\n\nPseudo: if nums[i] > nums[i-1] then up = down +1 else if < then down = up+1. Finally max(up, down).\n\nEdge cases: length <=1 -> length.\n\nImplement virtual code with Start, Step 1: input array. Step 2: if len <=1 return len. Step 3: initialize up=1, down=1. Step 4: loop i from 1 to n-1: compare nums[i] vs nums[i-1], update accordingly. Step 5: result = max(up,down). Step 6: output result.\n\nNeed virtual code with arrows and decisions.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: 讀入 nums // 取得輸入陣列\n→ Decision: 如果 nums 長度 <=1? // 判斷是否為最小情況\n    Yes → Step 2: 輸出 nums 長度 // 一個或兩個元素自動是 wiggle\n    No  → Step 3: 初始化 up = 1, down = 1 // 起始長度為1\n→ Step 4: 從 i = 1 到 len(nums)-1 迴圈 // 遍歷後續元素\n    → Decision: 如果 nums[i] > nums[i-1]? // 上升差\n        Yes → up = down + 1 // 更新上升狀態\n        No  → Decision: 如果 nums[i] < nums[i-1]? // 下降差\n            Yes → down = up + 1 // 更新下降狀態\n            No  → // 差為0，忽略\n→ Step 5: 結果 = max(up, down) // 最長 wiggle 長度\n→ Step 6: 輸出 結果 // 回傳答案\nEnd // 程式結束\n\nWe need to ensure each line includes `虛擬碼步驟 [space] // 解釋`.\n\nAlso use arrow style: `→ Step 1:` etc.\n\nWe need to output in that exact format, no actual code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 讀入 nums // 取得輸入陣列  \n→ Decision: 如果 nums 長度 <=1? // 判斷是否為最小情況  \n  Yes → Step 2: 輸出 nums 長度 // 一個或兩個元素自動是 wiggle  \n  No  → Step 3: 初始化 up = 1, down = 1 // 起始長度為1  \n→ Step 4: 從 i = 1 到 len(nums)-1 迴圈 // 遍歷後續元素  \n  → Decision: 如果 nums[i] > nums[i-1]? // 上升差  \n    Yes → up = down + 1 // 更新上升狀態  \n    No  → Decision: 如果 nums[i] < nums[i-1]? // 下降差  \n      Yes → down = up + 1 // 更新下降狀態  \n      No  → // 差為0，忽略  \n→ Step 5: 結果 = max(up, down) // 最長 wiggle 長度  \n→ Step 6: 輸出 結果 // 回傳答案  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\ndef wiggle_max_length(nums):\n    \"\"\"Return the length of the longest wiggle subsequence.\"\"\"\n    if not nums:\n        return 0\n    up = down = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(0)\n        sys.exit(0)\n\n    # 尋找 '[' 開始的子字串，並使用 ast.literal_eval 解析成列表\n    start_idx = raw_input.find('[')\n    if start_idx == -1:\n        print(0)\n        sys.exit(0)\n    nums_str = raw_input[start_idx:]\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        print(0)\n        sys.exit(0)\n\n    # 確保得到的是列表\n    if not isinstance(nums, list):\n        print(0)\n        sys.exit(0)\n\n    result = wiggle_max_length(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps that solve the problem: remove minimal parentheses to make string valid. Approach: Use stack to record indices of unmatched parentheses. First pass left-to-right, push '(' indices onto stack, when encountering ')' if stack not empty pop else mark this ')' to remove. After first pass, stack has unmatched '(' indices to remove. Build a set of indices to delete. Then build result by iterating string and skipping those indices. Complexity O(n). Provide steps.\n\nNeed to output each line as \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Provide steps with arrow.\n\nLet's craft:\n\nStart\n→ Step 1: 定義空棧 stack // 用來儲存未匹配 '(' 的索引\n→ Step 2: 定義空集合 removeIdx // 用來記錄需要刪除的括號索引\n→ Step 3: 迭代字符串 s，索引 i\n    → Decision: s[i] 是 '('? // 判斷左括號\n        Yes → stack push i // 存儲左括號索引\n        No  → Decision: s[i] 是 ')'?\n            Yes → Decision: stack 不是空?\n                Yes → stack pop() // 找到匹配的 '('，不刪除\n                No  → removeIdx add i // 沒有匹配，標記此右括號刪除\n            No  → // s[i] 為小寫字母，忽略\n→ Step 4: 從 stack 取出所有剩餘索引，將它們加入 removeIdx // 這些未匹配的 '(' 需要刪除\n→ Step 5: 建構結果字符串 result = 空\n→ Step 6: 再次迭代字符串 s，索引 i\n    → Decision: i 在 removeIdx?\n        Yes → // 跳過，刪除該括號\n        No  → result += s[i] // 保留字符\n→ End // 回傳 result\n\nWe can include arrow lines. Use proper indentation. Provide each line with comment. Use virtual code. Use '→' arrow before each step. Ensure each line ends with comment. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空棧 stack // 用來儲存未匹配 '(' 的索引  \n→ Step 2: 定義空集合 removeIdx // 用來記錄需要刪除的括號索引  \n→ Step 3: 迭代字符串 s，索引 i  \n  → Decision: s[i] 是 '('? // 判斷左括號  \n    Yes → stack push i // 將左括號索引加入棧  \n    No  → Decision: s[i] 是 ')'? // 判斷右括號  \n      Yes → Decision: stack 不是空? // 是否有未匹配的左括號  \n        Yes → stack pop() // 找到匹配的左括號，兩者都保留  \n        No  → removeIdx add i // 沒有匹配的左括號，標記此右括號刪除  \n      No  → // s[i] 為小寫字母，直接忽略  \n→ Step 4: 從 stack 取出所有剩餘索引，將它們加入 removeIdx // 未匹配的左括號也需要刪除  \n→ Step 5: 建構結果字符串 result = 空  \n→ Step 6: 再次迭代字符串 s，索引 i  \n  → Decision: i 在 removeIdx? // 判斷此索引是否需刪除  \n    Yes → // 跳過，刪除該括號  \n    No  → result += s[i] // 保留字符  \n→ End // 程式執行結束，返回 result",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \"\"\"移除最少數量的括號使字符串有效\"\"\"\n        # 轉成可修改的列表\n        chars = list(s)\n        stack = []  # 存放未匹配 '(' 的索引\n\n        # 第一遍掃描，標記多餘的 ')'\n        for i, c in enumerate(chars):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if stack:\n                    stack.pop()          # 找到匹配的 '('，不刪除\n                else:\n                    chars[i] = ''        # 無法匹配的 ')'\n\n        # 第二遍掃描，刪除剩餘未匹配的 '('\n        for i in stack:\n            chars[i] = ''\n\n        return ''.join(chars)\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n\n    # 若輸入形如 s = \"...\"，則提取引號內的字串\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        s = raw_input  # 直接使用輸入本身\n\n    solution = Solution()\n    result = solution.minRemoveToMakeValid(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "lee(t(c)o)de"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "ab(c)d"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code step-by-step with explanations. Must adhere to format. Should produce logic for sliding window maximum using deque.\n\nWill produce steps: Start, input array, input k, initialize deque, loop over array, maintain deque, output result array.\n\nMake sure each line ends with // explanation. Use virtual arrows → etc. Include decisions for emptiness, front expiration, etc.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums 與滑動窗口大小 k // 從使用者處取得資料  \n→ Step 2: 初始化空雙端佇列 dq 以及結果陣列 res // 用於存放窗口中的索引與最終答案  \n→ Step 3: 循環 i 從 0 到 nums.length-1 // 遍歷整個陣列  \n  → Decision: 若 dq 非空且 dq[0] <= i-k? // 判斷窗口左邊界是否已離開  \n    Yes → Step 4: 從 dq 前端移除 dq[0] // 移除已不在窗口的索引  \n    No  → // 何無操作  \n  → Decision: 若 dq 非空且 nums[dq[-1]] <= nums[i]? // 判斷右端索引對應值是否小於等於當前值  \n    Yes → Step 5: 從 dq 後端移除 dq[-1] // 移除所有不可能成為最大值的索引  \n    No  → // 何無操作  \n  → Step 6: 將 i 加入 dq 後端 // 將當前索引加入窗口  \n  → Decision: i >= k-1? // 判斷是否已形成完整窗口  \n    Yes → Step 7: 將 nums[dq[0]] 加入 res // dq[0] 為當前窗口最大值的索引  \n    No  → // 何無操作  \n→ Step 8: 回傳 res // 輸出滑動窗口最大值序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\ndef max_sliding_window(nums, k):\n    \"\"\"Return list of maximums for each sliding window of size k.\"\"\"\n    if not nums or k == 0:\n        return []\n\n    deq = deque()   # store indices of useful elements\n    res = []\n\n    for i, val in enumerate(nums):\n        # Remove indices that are out of the current window\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n\n        # Remove indices whose values are less than current value\n        while deq and nums[deq[-1]] < val:\n            deq.pop()\n\n        deq.append(i)\n\n        # When the first window is ready, record the maximum\n        if i >= k - 1:\n            res.append(nums[deq[0]])\n\n    return res\n\ndef parse_input(input_str):\n    \"\"\"Parse input string of the form 'nums = [...], k = ...'.\"\"\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, input_str, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format incorrect. Expected: nums = [...], k = ...\")\n    nums_str, k_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n    return nums, k\n\ndef main():\n    # Read entire input from stdin\n    input_data = sys.stdin.read().strip()\n    nums, k = parse_input(input_data)\n    result = max_sliding_window(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": true,
          "output": "[3, 3, 5, 5, 6, 7]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode628.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Three Numbers",
    "description_snippet": "Given an integer array nums, find three numbers whose product is maximum and return the maximum prod...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the problem: given array of integers, find three numbers whose product is maximum, return max product.\n\nWe need to produce step-by-step virtual code, line by line with arrow notation and explanation. Must not output actual code.\n\nSo we can outline algorithm: sort array. Max product could be from top three largest positive numbers, or two smallest negatives and largest positive. So steps: sort array, compute candidate1 = last three product, candidate2 = first two * last one. Return max of both.\n\nBut need to handle length <3? Usually at least 3.\n\nWe'll produce virtual steps.\n\nLet's produce Start, Step 1: Input array. Step 2: Sort ascending. Step 3: Determine candidate1 = product of last three elements. Step 4: Determine candidate2 = product of first two elements and last element. Step 5: Determine maxCandidate = maximum of candidate1 and candidate2. Step 6: Output maxCandidate. End.\n\nAdd Decision maybe to handle array size? but we can assume length >=3. Let's include a Decision: if length<3? Not needed.\n\nWe can also add if array all negative? But algorithm covers.\n\nWe should produce lines with arrow.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得整數陣列 nums // 從使用者或資料來源取得整數陣列  \n→ Step 2: 對 nums 進行升冪排序 // 方便找出最大與最小的數值  \n→ Step 3: 計算 candidate1 = nums[-1] × nums[-2] × nums[-3] // 取三個最大正數的乘積  \n→ Step 4: 計算 candidate2 = nums[0] × nums[1] × nums[-1] // 取兩個最小（可能為負）數與最大數的乘積  \n→ Step 5: 決定 maxProduct = Max(candidate1, candidate2) // 選擇較大的乘積  \n→ Step 6: 輸出 maxProduct // 回傳最終的最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maximumProduct(self, nums):\n        \"\"\"\n        Calculate the maximum product of any three numbers in the list.\n        \"\"\"\n        nums.sort()\n        # 兩種候選乘積：前三大數或兩個最小（可能為負）數乘以最大數\n        candidate1 = nums[-1] * nums[-2] * nums[-3]\n        candidate2 = nums[0] * nums[1] * nums[-1]\n        return max(candidate1, candidate2)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部內容\n    raw_input = sys.stdin.read().strip()\n    # 嘗試找出類似 \"nums = [1,2,3]\" 的格式\n    match = re.search(r'nums\\s*=\\s*(\\[.*\\])', raw_input)\n    if match:\n        nums_str = match.group(1)\n    else:\n        # 若直接給的是列表字串，直接使用整個輸入\n        nums_str = raw_input\n    try:\n        nums = eval(nums_str)\n    except Exception:\n        # 若解析失敗，使用空列表\n        nums = []\n\n    # 若輸入的不是列表，嘗試從空格分隔的數字中建立列表\n    if not isinstance(nums, list):\n        try:\n            nums = [int(x) for x in re.findall(r'-?\\d+', raw_input)]\n        except Exception:\n            nums = []\n\n    # 確保至少有三個元素，否則直接計算所有數字的乘積\n    if len(nums) < 3:\n        product = 1\n        for num in nums:\n            product *= num\n        result = product\n    else:\n        sol = Solution()\n        result = sol.maximumProduct(nums)\n\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "24",
          "success": true,
          "output": "24"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-2,-3]",
          "expected_output": "-6",
          "success": true,
          "output": "-6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for text justification problem. Use Start, Decision, arrows, etc. Each line with comment. Provide virtual code lines only, no real code. Should be detailed.\n\nWe need to output lines like:\n\nStart // 程式開始執行\n→ Step 1: words, maxWidth input // etc.\n\nShould include loops: gather words for line, compute spaces, build line, handle last line, etc.\n\nMake sure each line has comment after a space. Use arrow '→', 'Decision:', etc.\n\nLet's design.\n\nStart\n→ Initialize i = 0 // index of current word\n→ Initialize result = [] // list of justified lines\n→ While i < len(words) // process all words\n    → Determine lineWords and lineLength // collect words for current line\n        → Set j = i\n        → Set lineLen = 0\n        → While j < len(words) and lineLen + len(words[j]) + (j-i) <= maxWidth\n             → lineLen += len(words[j])\n             → j += 1\n        → lineWords = words[i:j]\n        → lineLenWords = lineLen\n        → If j == len(words) // last line\n            → line = leftJustify(lineWords, lineLenWords, maxWidth)\n        → Else\n            → line = fullyJustify(lineWords, lineLenWords, maxWidth)\n        → Append line to result\n        → i = j\n→ Return result // finished\n\nDefine functions leftJustify and fullyJustify:\n\nleftJustify:\n    → Join words with single space // combine words\n    → Append spaces to reach maxWidth\n    → Return line\n\nfullyJustify:\n    → If len(lineWords) == 1 // single word\n        → Append spaces after word to reach maxWidth\n        → Return line\n    → totalSpaces = maxWidth - lineLenWords\n    → slots = len(lineWords) - 1\n    → spacePerSlot = totalSpaces // slots\n    → extraSpaces = totalSpaces % slots\n    → line = \"\"\n    → For idx, word in enumerate(lineWords)\n        → Append word\n        → If idx < slots\n            → spaces = spacePerSlot + (1 if idx < extraSpaces else 0)\n            → Append ' ' * spaces\n    → Return line\n\nNeed to present these steps. Use Decision: For last line? etc.\n\nWe should produce virtual code only, no actual code.\n\nLet's craft.\n\nWe must be careful to format each line: \"虛擬碼步驟 [space] // 解釋\". Use arrow etc.\n\nLet's produce.\n\nAlso include comments for each step.\n\nWe need to use arrow \"→\". We can use sub-steps indentation.\n\nWe can use lines like:\n\n→ Step 1: words, maxWidth input // 從使用者處取得字串清單與最大寬度\n\nBut we may just assume input given.\n\nLet's start.\n\nI will produce:\n\nStart // 程式開始執行\n→ Initialize i = 0 // 目前正在處理的單字索引\n→ Initialize result = [] // 儲存已排版好的行\n→ While i < len(words) // 仍有未處理的單字\n    → Set j = i // j 為本行最右邊單字索引\n    → Set lineLen = 0 // 本行已佔用字元數（不含空格）\n    → While j < len(words) and lineLen + len(words[j]) + (j-i) <= maxWidth\n        → lineLen += len(words[j]) // 加入單字長度\n        → j += 1 // 進入下一個單字\n    → lineWords = words[i:j] // 本行的所有單字\n    → If j == len(words) // 本行為最後一行\n        → line = leftJustify(lineWords, lineLen, maxWidth)\n    → Else\n        → line = fullyJustify(lineWords, lineLen, maxWidth)\n    → Append line to result\n    → i = j // 移動到下一行的第一個單字\n→ Return result // 所有行已排版完成\n\nDefine leftJustify:\n→ Function leftJustify(words, lenWords, width)\n    → line = words[0]\n    → For each w in words[1:]\n        → line += ' ' + w // 單一空格分隔\n    → spacesToAdd = width - len(line)\n    → line += ' ' * spacesToAdd // 右側填充空格\n    → Return line\n\nDefine fullyJustify:\n→ Function fullyJustify(words, lenWords, width)\n    → If len(words) == 1 // 只有一個單字\n        → Return words[0] + ' ' * (width - lenWords)\n    → totalSpaces = width - lenWords\n    → slots = len(words) - 1\n    → spacePerSlot = totalSpaces // slots\n    → extraSpaces = totalSpaces % slots\n    → line = ''\n    → For idx, w in enumerate(words)\n        → line += w\n        → If idx < slots\n            → spaces = spacePerSlot + (1 if idx < extraSpaces else 0)\n            → line += ' ' * spaces\n    → Return line\n\nBut we must express in virtual code. Each line with arrow etc. Indentation not necessary but use indentation.\n\nMake sure each line comment. Use 'Decision:' for if. So we should use Decision lines.\n\nLet's convert.\n\nFor while loops: use \"While\". For if, use Decision:.\n\nWe can structure:\n\nStart // 程式開始執行\n→ Initialize i = 0 // 目前處理的單字索引\n→ Initialize result = [] // 存放排版後的行\n→ While i < len(words) // 有未處理的單字\n    → Decision: 將 j 設為 i 並計算 lineLen // 準備本行的單字\n        Yes → Set j = i\n        No  → // (not needed)\nBut maybe we can just use simple statements.\n\nLet's produce more concise but still step-by-step.\n\nLet's produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Initialize i = 0 // 目前處理的單字索引\n→ Initialize result = [] // 用來儲存已排版好的行\n→ While i < len(words) // 仍有未處理的單字\n    → Set j = i // 本行最右邊單字的起始索引\n    → Set lineLen = 0 // 本行已佔用的字元數（不含空格）\n    → While j < len(words) and lineLen + len(words[j]) + (j - i) <= maxWidth\n        → lineLen += len(words[j]) // 加入單字長度\n        → j += 1 // 進入下一個單字\n    → lineWords = words[i:j] // 本行的所有單字\n    → Decision: j == len(words) // 本行是最後一行嗎？\n        Yes → line = leftJustify(lineWords, lineLen, maxWidth) // 左對齊\n        No  → line = fullyJustify(lineWords, lineLen, maxWidth) // 完全對齊\n    → Append line to result // 加入結果\n    → i = j // 移動到下一行的第一個單字\n→ Return result // 所有行已排版完成\n\n// 左對齊函式\n→ Function leftJustify(words, lenWords, width)\n    → line = words[0] // 第一道字\n    → For each w in words[1:]\n        → line += ' ' + w // 單一空格分隔\n    → spacesToAdd = width - len(line) // 需要補齊的空格數\n    → line += ' ' * spacesToAdd // 右側填充空格\n    → Return line // 返回左對齊的行\n\n// 完全對齊函式\n→ Function fullyJustify(words, lenWords, width)\n    → Decision: len(words) == 1 // 只有一個單字\n        Yes → Return words[0] + ' ' * (width - lenWords) // 右側填充空格\n        No  → // 進一步計算空格分布\n    → totalSpaces = width - lenWords // 本行需要的總空格數\n    → slots = len(words) - 1 // 單字之間的空格槽數\n    → spacePerSlot = totalSpaces // slots // 每個槽的最小空格數\n    → extraSpaces = totalSpaces % slots // 左側槽多得的空格數\n    → line = ''\n    → For idx, w in enumerate(words)\n        → line += w // 加入單字\n        → Decision: idx < slots // 是否還需要空格？\n            Yes → spaces = spacePerSlot + (1 if idx < extraSpaces else 0)\n            No  → // 最後一個單字後不加空格\n            → line += ' ' * spaces // 加入相應數量的空格\n    → Return line // 返回完全對齊的行\n```",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words)\n                line += ' ' * (maxWidth - len(line))\n            else:\n                # fully justify\n                spaces_needed = maxWidth - sum(len(w) for w in line_words)\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    pattern = r'words\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*maxWidth\\s*=\\s*(\\d+)'\n    m = re.search(pattern, data)\n    if not m:\n        return\n    words_str, width_str = m.group(1), m.group(2)\n    words = ast.literal_eval(words_str)\n    maxWidth = int(width_str)\n    solution = Solution()\n    result = solution.fullJustify(words, maxWidth)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "['This    is    an', 'example  of text', 'justification.  ']"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "['What   must   be', 'acknowledgment  ', 'shall be        ']"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "['Science  is  what we', 'understand      well', 'enough to explain to', 'a  computer.  Art is', 'everything  else  we', 'do                  ']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. The algorithm: generate count-and-say sequence iteratively. Start with \"1\". For i from 2 to n, process previous string: iterate characters, count runs, append count and digit to result. Return result. Include Start, End, Decision, loops.\n\nLet's produce lines:\n\nStart\n→ Step 1: Input n // read integer n\n→ Decision: If n <= 0? // check validity\n    Yes → Step 2: Output error // invalid\n    No  → Step 3: Set current = \"1\" // base case\n→ Decision: If n == 1? // if only first element\n    Yes → Step 4: Output current // return \"1\"\n    No  → Step 5: Set counter = 2 // start from second term\n→ Loop: While counter <= n\n    → Step 6: Initialize next = \"\" // string for next term\n    → Step 7: Set index = 0 // position in current\n    → Step 8: While index < length(current)\n        → Step 9: Set count = 1 // at least one occurrence\n        → Step 10: While index+1 < length(current) AND current[index] == current[index+1]\n            → Step 11: Increment count\n            → Step 12: Increment index\n        → Step 13: Append count + current[index] to next // rle\n        → Step 14: Increment index\n    → Step 15: Set current = next // move to next term\n    → Step 16: Increment counter\n→ Step 17: Output current // after loop, current holds nth term\nEnd\n\nMake sure each line has // explanation. Provide arrow indentation for decisions. Use \"Decision:\" lines with Yes and No branches.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入正整數 n // 取得輸入的 n  \n→ Decision: n 是否小於等於 0? // 檢查輸入是否合法  \n    Yes → Step 2: 輸出 '錯誤: n 必須為正整數' // 無效輸入，終止程式  \n    No  → Step 3: 設定 current = \"1\" // 以第一項為基礎  \n→ Decision: n 等於 1? // 若只要求第一項  \n    Yes → Step 4: 輸出 current // 回傳 \"1\"  \n    No  → Step 5: 設定 counter = 2 // 從第二項開始產生  \n→ Loop: counter <= n // 迭代至第 n 項  \n    → Step 6: 初始化 next = \"\" // 用於儲存下一項的字串  \n    → Step 7: 設定 index = 0 // 從 current 的開頭開始掃描  \n    → Step 8: index < length(current) // 仍有字符未處理  \n        → Step 9: 設定 count = 1 // 至少一個相同字符  \n        → Decision: index + 1 < length(current) 且 current[index] == current[index + 1]? // 判斷是否有連續相同字符  \n            Yes → Step 10: count = count + 1 // 次數加一  \n            Yes → Step 11: index = index + 1 // 移到下一個位置  \n            No  → Step 12: 退出內層 while  \n        → Step 13: next = next + count + current[index] // 將「數量+字符」追加到 next  \n        → Step 14: index = index + 1 // 前進到下個不同字符的起點  \n    → Step 15: current = next // 把 newly 生成的字串設為新的 current  \n    → Step 16: counter = counter + 1 // 進到下一個序號  \n→ Step 17: 輸出 current // 迴圈結束後 current 即為第 n 項  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"\n        Return the nth term of the count-and-say sequence.\n        The algorithm iteratively builds each term from the previous one.\n        \"\"\"\n        if n <= 0:\n            return \"\"\n\n        # Base case: the first term is always \"1\".\n        current = \"1\"\n\n        # Build terms from 2 to n.\n        for _ in range(2, n + 1):\n            next_term = []\n            i = 0\n            while i < len(current):\n                count = 1  # at least one occurrence\n                # Count how many times the current digit repeats consecutively.\n                while i + 1 < len(current) and current[i] == current[i + 1]:\n                    count += 1\n                    i += 1\n                # Append the run-length encoding of this block.\n                next_term.append(str(count))\n                next_term.append(current[i])\n                i += 1\n            # Prepare for the next iteration.\n            current = \"\".join(next_term)\n\n        return current\n\ndef main():\n    \"\"\"\n    Read an integer n from standard input, compute the nth count-and-say term,\n    and print the result to standard output.\n    \"\"\"\n    # Read all input and extract the first integer found.\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    result = sol.countAndSay(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "1211"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: find duplicate in array of n+1 integers range 1..n, only one duplicate, no modification, constant extra space. Classic Floyd's Tortoise and Hare (linked list cycle detection). Virtual code step by step.\n\nWe produce lines:\n\nStart\n→ Step: define function findDuplicate(nums)\n→ Step: initialize tortoise = nums[0]\n→ Step: initialize hare = nums[0]\n→ Decision: while true? maybe loop until detection. Use While tortoise != hare? Actually algorithm: first phase: do {tortoise = nums[tortoise]; hare = nums[nums[hare]]; } while(tortoise != hare);\n\nThen second phase: reset tortoise = nums[0]; while(tortoise != hare) { tortoise = nums[tortoise]; hare = nums[hare]; }\n\nReturn tortoise.\n\nWe need to obey format with Start and End. Provide each step with explanation.\n\nImportant: Use \"Start\" and \"End\". Use arrows. Use \"Decision:\" where needed. Provide code lines.\n\nWe'll produce virtual code:\n\nStart // 程式開始執行\n→ Step: 定義函式 findDuplicate(nums) // 接收整數陣列\n→ Step: tortoise ← nums[0] // tortoise 初始位置\n→ Step: hare ← nums[0] // hare 初始位置\n→ Decision: 進入第一階段尋找交點? // 循環找 tortoise 與 hare 交點\n    → While tortoise ≠ hare\n        → tortoise ← nums[tortoise] // tortoise 移動一步\n        → hare ← nums[nums[hare]] // hare 移動兩步\n    // 交點找到\n→ Step: tortoise ← nums[0] // 重置 tortoise 以尋找入口\n→ Decision: 進入第二階段尋找重複數? // 循環直到兩指標相遇\n    → While tortoise ≠ hare\n        → tortoise ← nums[tortoise] // tortoise 移動一步\n        → hare ← nums[hare] // hare 移動一步\n    // 重複數即為 tortoise 或 hare\n→ Step: return tortoise // 回傳重複數\nEnd // 程式執行結束\n\nBut we must keep each line as separate line with arrow. For While loops, we can indent. However format says arrow '→' for each step. We can embed loop as Decision block. But \"Decision:\" is used for if. We can also use \"Loop:\" but not specified. Use \"Decision:\" with Yes/No? For loops maybe just use \"While\". But requirement: Use virtual code arrows and structure like Start, End, Decision. It didn't say loop is prohibited. We can include \"While\" as Step. Let's format each line with arrow.\n\nWe need to maintain each line includes explanation after //.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 定義函式 findDuplicate(nums) // 接收整數陣列\n→ Step: tortoise ← nums[0] // tortoise 初始位置\n→ Step: hare ← nums[0] // hare 初始位置\n→ Decision: 開始第一階段尋找交點? // 循環直到 tortoise 和 hare 相遇\n    → While tortoise ≠ hare\n        → tortoise ← nums[tortoise] // tortoise 前進一步\n        → hare ← nums[nums[hare]] // hare 前進兩步\n→ Step: tortoise ← nums[0] // 重置 tortoise 到陣列起點\n→ Decision: 開始第二階段尋找重複數? // 循環直到 tortoise 和 hare 再次相遇\n    → While tortoise ≠ hare\n        → tortoise ← nums[tortoise] // tortoise 前進一步\n        → hare ← nums[hare] // hare 前進一步\n→ Step: return tortoise // 重複數即為 tortoise\nEnd // 程式執行結束\n\nBut we must keep each line separate, including lines inside while loops as separate lines. Use indentation? Not required.\n\nLet's produce each line with arrow. We'll put indentation by spaces before arrow? Maybe not necessary. We'll just include the arrow and then lines. For nested while we might use arrow inside.\n\nBut the format example shows indentation of decision block inside the arrow. But we can keep same.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義函式 findDuplicate(nums) // 接收整數陣列  \n→ Step: tortoise ← nums[0] // tortoise 初始位置  \n→ Step: hare ← nums[0] // hare 初始位置  \n→ Decision: 開始第一階段尋找交點? // 循環直到 tortoise 和 hare 相遇  \n    → While tortoise ≠ hare  \n        → tortoise ← nums[tortoise] // tortoise 前進一步  \n        → hare ← nums[nums[hare]] // hare 前進兩步  \n→ Step: tortoise ← nums[0] // 重置 tortoise 到陣列起點  \n→ Decision: 開始第二階段尋找重複數? // 循環直到 tortoise 和 hare 再次相遇  \n    → While tortoise ≠ hare  \n        → tortoise ← nums[tortoise] // tortoise 前進一步  \n        → hare ← nums[hare] // hare 前進一步  \n→ Step: return tortoise // 重複數即為 tortoise  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        使用 Floyd's Tortoise and Hare 演算法找到重複數字\n        \"\"\"\n        slow = fast = nums[0]\n        # 第一階段：尋找相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # 第二階段：尋找入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 只保留陣列部分，例如將 'nums = [1,3,4,2,2]' 轉成 [1,3,4,2,2]\n    if raw_input.lower().startswith('nums'):\n        # 分割等號，取等號右邊\n        parts = raw_input.split('=', 1)\n        raw_input = parts[1].strip()\n\n    # 使用 ast.literal_eval 解析字串為 Python 物件，避免 eval 的安全問題\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 如果解析失敗，直接輸出錯誤提示\n        print(\"Invalid input format\")\n        return\n\n    # 確保輸入是一個列表\n    if not isinstance(nums, list):\n        print(\"Input should be a list of integers\")\n        return\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.findDuplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode714.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Transaction Fee",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode steps for solving max profit with fee, standard DP. We'll outline steps. Provide line by line. Use Start, Decision, etc. Let's produce.\n\nWe'll include steps: initialize buy= -prices[0]-fee? Actually typical: hold profit when holding stock, sell profit when not holding. dp0 = 0 (no stock), dp1 = -prices[0] (hold). Then iterate. For each price: new_dp0 = max(dp0, dp1+price - fee); new_dp1 = max(dp1, dp0 - price). End. Output dp0.\n\nLet's produce lines with explanation.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列 prices 與交易費用 fee // 從輸入取得價格與費用  \n\n→ Step 2: 若 prices 为空則輸出 0 并结束 // 处理空数组情况  \n\n→ Step 3: 初始化 dp0 = 0 // 代表「不持有股票時的最大利潤」  \n→ Step 4: 初始化 dp1 = -prices[0] // 代表「持有股票時的最大利潤」  \n\n→ Decision: 從 i = 1 到 prices.length-1 循環  \n    → Step 5: 計算 temp0 = max(dp0, dp1 + prices[i] - fee) // 賣出或不賣出的最優選擇  \n    → Step 6: 計算 temp1 = max(dp1, dp0 - prices[i]) // 買入或不買入的最優選擇  \n    → Step 7: 更新 dp0 = temp0 // 保存不持股的狀態  \n    → Step 8: 更新 dp1 = temp1 // 保存持股的狀態  \nEnd // 迴圈結束  \n\n→ Step 9: 輸出 dp0 // dp0 即為在所有天數結束時不持股時的最大利潤，為最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef max_profit(prices, fee):\n    \"\"\"使用 DP 計算最多利潤，支出一次手續費。\"\"\"\n    if not prices:\n        return 0\n    # hold：持有股票時的最大利潤\n    # cash：不持有股票時的最大利潤\n    hold = -prices[0]\n    cash = 0\n    for price in prices[1:]:\n        cash = max(cash, hold + price - fee)   # 卖出或不卖\n        hold = max(hold, cash - price)        # 买入或不买\n    return cash\n\ndef parse_input(data: str):\n    \"\"\"\n    解析输入格式：\n    prices = [1,3,2,8,4,9], fee = 2\n    只支持整数列表和整数手續費。\n    \"\"\"\n    pattern = r\"prices\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*fee\\s*=\\s*(-?\\d+)\"\n    match = re.search(pattern, data, re.IGNORECASE)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    prices_str, fee_str = match.groups()\n    prices = eval(prices_str)           # 解析列表\n    fee = int(fee_str)                  # 解析手續費\n    return prices, fee\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    prices, fee = parse_input(data)\n    result = max_profit(prices, fee)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,3,2,8,4,9], fee = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "prices = [1,3,7,5,10,3], fee = 3",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the problem: reconstruct queue given height and k values. Classic solution: sort people by height descending, k ascending, then insert each into result at index k. Provide steps line by line with comments. Use Start, End, Decision, etc.\n\nWe should include steps: start, sort, initialize empty list, loop, insert. Use Decision? Maybe no decisions inside loop except insertion. We'll produce explanation.\n\nMake sure to adhere to format: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow \"→\". Use Start, End, Decision:.\n\nLet's write:\n\nStart // start\n\n→ Step 1: Sort people array by height descending, and for equal heights by k ascending // pre-sort\n\n→ Step 2: Create empty list queue // result\n\n→ Step 3: For each person in sorted people: // iterate\n\n    → Decision: 需要將 person 插入 queue 的哪個位置？ // decide\n\n        Yes → Step 4: 在 queue 中插入 person 在索引 k 位置 // insert\n\nEnd // finished\n\nBut we need to reflect actual algorithm: insertion at index k.\n\nWe can simplify: No decision inside loop; just insert at index.\n\nWe can represent loops and insert.\n\nUse arrow for loop: → Step 3: For each person in sorted list // loop\n\n   → Step 4: Insert person at index k in queue // insert\n\nBut they want \"逐行\" steps, we can break the loop into step per iteration? but we can keep one step for loop body.\n\nWe'll produce a series of steps.\n\nWe should use \"Decision:\" maybe to handle if k within length; but it's always within.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 將 people 依照身高 h 由大到小排序；若身高相同則 k 由小到大排序 // 排序前置\n→ Step 2: 初始化空列表 queue // 用於存放最終隊列\n→ Step 3: 迭代排序後的每個人 person // 逐一處理\n    → Step 4: 在 queue 中插入 person，插入位置為 person 的 k 值 // 依 k 插入\nEnd // 程式執行結束\n\nWe need to ensure we use virtual code arrow formatting. The arrow \"→\" for steps, \"Decision:\" for decision nodes.\n\nAlso maybe we should include a decision for k out of range? But not necessary.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 people 依照身高 h 由大到小排序；若身高相同則 k 由小到大排序 // 先整理順序  \n→ Step 2: 初始化空列表 queue // 用來儲存最終的隊列  \n→ Step 3: 迭代排序後的每個人 person // 逐一處理  \n  → Step 4: 在 queue 中插入 person，插入位置為 person 的 k 值 // 依 k 值定位  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reconstructQueue(self, people):\n        \"\"\"\n        將人依照身高從高到低排序，若身高相同則 k 從小到大。\n        再依照排序後的順序將每個人插入結果隊列中，插入位置為 k。\n        \"\"\"\n        people.sort(key=lambda x: (-x[0], x[1]))\n        res = []\n        for p in people:\n            res.insert(p[1], p)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    \n    # 解析輸入資料，輸入可能是 'people = [[...]]' 或直接列表字串\n    if 'people' in data:\n        idx = data.find('=')\n        expr = data[idx + 1:].strip()\n        people = ast.literal_eval(expr)\n    else:\n        people = ast.literal_eval(data)\n    \n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.reconstructQueue(people)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps describing algorithm for RandomizedCollection with insert, remove, getRandom in O(1). Use array/list + hashmap mapping value to set of indices. Provide step-by-step pseudocode.\n\nNeed to output each line with \"→\" arrow, Decision, etc.\n\nWe must not output actual code, just virtual code with explanation.\n\nLet's produce:\n\nStart\n→ Initialize empty list nums and hashmap valIndices: map int → set of indices\n→ Define insert(val):\n    → Add val to nums list at end index i\n    → Add i to valIndices[val] set\n    → If valIndices[val] size was 1? // check if val existed before\n        Yes → Return false? Actually if it was present before, insert returns false. But after insertion, size >1, so return false if existed before else true. So decision:\n    → Decision: if val existed before?\n        Yes → Return false\n        No  → Return true\n→ Define remove(val):\n    → Decision: if valIndices[val] is empty? // not present\n        Yes → Return false\n        No  → \n            → Pick any index idx from valIndices[val]\n            → Remove idx from valIndices[val]\n            → Get last element lastVal and lastIndex len(nums)-1\n            → Overwrite nums[idx] = lastVal\n            → Update valIndices[lastVal] set: remove lastIndex, add idx\n            → Remove last element from nums list\n            → If valIndices[val] now empty? // optional clean up\n                → Delete valIndices[val]\n            → Return true\n→ Define getRandom():\n    → Randomly pick index r between 0 and len(nums)-1\n    → Return nums[r]\nEnd\n\nWe must provide virtual code lines with explanations. Use arrow \"→\" at start of each step. Use Decision with Yes →, No →. Include Start, End.\n\nWe should break into multiple lines: initialization, functions definitions, etc.\n\nWe need each line \"虛擬碼步驟 [space] // 解釋\". Provide each line.\n\nLet's produce the output.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize nums ← [] // 空陣列儲存所有元素\n→ Initialize valIndices ← {} // map: value → 集合(indices) 在 nums 中的所有位置\n\n→ Define insert(val) // 插入元素\n    → Append val 到 nums 的末尾，index ← len(nums)-1 // 取得新位置\n    → If val 不在 valIndices, 則 valIndices[val] ← empty set // 建立集合\n    → Add index 到 valIndices[val] // 記錄位置\n    → Decision: 若 valIndices[val] 原本為空? // 判斷該值是否首次插入\n        Yes → Return true // 新元素，回傳 true\n        No  → Return false // 已存在，回傳 false\n\n→ Define remove(val) // 刪除一個元素\n    → Decision: 若 val 不在 valIndices 或 valIndices[val] 為空? // 元素不存在\n        Yes → Return false // 無法刪除，回傳 false\n        No  →\n            → Pick 任意 index idx 從 valIndices[val] 中\n            → Remove idx 從 valIndices[val] // 刪除該位置\n            → lastIndex ← len(nums)-1\n            → lastVal ← nums[lastIndex] // 取得最後一個元素\n            → nums[idx] ← lastVal // 將最後一個元素覆蓋到要刪除的位置\n            → Remove lastIndex 從 valIndices[lastVal] // 移除舊位置\n            → Add idx 到 valIndices[lastVal] // 加入新位置\n            → Remove nums[lastIndex] // 從陣列刪除最後一個元素\n            → Decision: 若 valIndices[val] 為空? // 若該值已無剩餘\n                Yes → Delete valIndices[val] // 清除佔用空間\n                No  → Do nothing\n            → Return true // 刪除成功，回傳 true\n\n→ Define getRandom() // 取得隨機元素\n    → r ← RandomInteger(0, len(nums)-1) // 隨機索引\n    → Return nums[r] // 回傳該位置的元素\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport random\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []                 # 存放所有元素的列表\n        self.idx_map = {}              # value -> set of indices in data\n\n    def insert(self, val):\n        if val not in self.idx_map:\n            self.idx_map[val] = set()\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若首次插入才回傳 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        if val not in self.idx_map or not self.idx_map[val]:\n            return False\n        # 取得任意一個出現在 data 的位置\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 若該值已無剩餘，移除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\ndef main():\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n    # 分離兩個列表\n    m = re.search(r'\\[(.*?)\\],\\s*\\[(.*?)\\]', input_data, re.S)\n    if not m:\n        return\n    commands_str = '[' + m.group(1) + ']'\n    args_str = '[' + m.group(2) + ']'\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    rc = RandomizedCollection()\n    results = [None]  # constructor returns null\n\n    for cmd, arg in zip(commands[1:], args[1:]):\n        if cmd == 'insert':\n            res = rc.insert(arg[0])\n        elif cmd == 'remove':\n            res = rc.remove(arg[0])\n        elif cmd == 'getRandom':\n            res = rc.getRandom()\n        else:\n            res = None\n        results.append(res)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpenv003c7.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmpenv003c7.py\", line 53, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: given string s, partition into palindromic substrings, return min cuts. Classic DP: precompute palindrome table and dp cuts. We need step-by-step pseudocode.\n\nWe produce steps:\n\nStart\n→ Input string s\n→ n = length of s\n→ Initialize palindrome table P[n][n] to False\n→ Fill P table: for i from n-1 downto 0: for j from i to n-1: P[i][j] = (s[i]==s[j]) and (j-i<2 or P[i+1][j-1])\n→ Initialize dp[n] where dp[i] = min cuts for substring s[0..i-1]; dp[0] = -1 (no cuts before first char)\n→ For i from 1 to n:\n   → Set dp[i] = big number\n   → For j from 0 to i-1:\n       → If P[j][i-1] then dp[i] = min(dp[i], dp[j]+1)\n→ Return dp[n]\nEnd\n\nNeed each line with explanation. We'll format as required. Use arrows and decision? Might not need decisions except loops. We can represent loops with steps.\n\nLet's produce. Use Start, End.\n\nWe'll produce lines: Start // etc.\n\nWe need \"→ Step X:\" style.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Input s // 讀取輸入字串\n→ n ← length(s) // 取得字串長度\n→ P ← 2D array n×n initialized false // 建立是否為回文的表\n→ Decision: 迴圈 i 從 n-1 降至 0? // 用倒序建立回文表\n    Yes → Loop j 從 i 升至 n-1:\n          → P[i][j] ← (s[i]==s[j]) ∧ (j-i<2 ∨ P[i+1][j-1]) // 判斷子字串是否回文\n→ P 表填好 // 完成回文判斷表\n→ dp ← array n+1\n→ dp[0] ← -1 // 前一個位置不需要切割\n→ Decision: 迴圈 i 從 1 到 n? // 計算最小切割\n    Yes → dp[i] ← ∞ // 初始值\n    → Loop j 從 0 到 i-1:\n          → Decision: P[j][i-1] 為真? // 子字串回文?\n              Yes → dp[i] ← min(dp[i], dp[j]+1) // 更新切割數\n→ End // 結束計算\n→ Return dp[n] // 輸出最小切割數\n\nBut must each line: virtual step + comment. We can't combine loops inside lines? The example uses Decision with nested Yes/No. For loops we can use \"Loop\" steps.\n\nLet's format:\n\nStart // 程式開始執行\n→ Input s // 讀取輸入字串\n→ n ← length(s) // 取得字串長度\n→ P ← 2D array n×n initialized false // 建立回文判斷表\n→ Decision: i ← n-1 至 0? // 反向遍歷索引建立表\n    Yes → Loop j ← i 至 n-1:\n          → P[i][j] ← (s[i]==s[j]) ∧ (j-i<2 ∨ P[i+1][j-1]) // 判斷是否為回文\n→ dp ← array n+1 // 產生動態規劃陣列\n→ dp[0] ← -1 // 初始化，前置位置不需要切割\n→ Decision: i ← 1 至 n? // 計算每個前綴的最小切割\n    Yes → dp[i] ← ∞ // 設定初始最大值\n    → Loop j ← 0 至 i-1:\n          → Decision: P[j][i-1] 為真? // 子字串是否回文\n              Yes → dp[i] ← min(dp[i], dp[j]+1) // 更新切割數\n→ Return dp[n] // 回傳最小切割數\nEnd // 程式結束\n\nNeed each line separate; nested decisions indent? The example uses indentation. We'll produce similar.\n\nLet's output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input s // 讀取輸入字串\n→ n ← length(s) // 取得字串長度\n→ P ← 2D array n×n initialized false // 建立回文判斷表\n→ Decision: i ← n-1 至 0? // 反向遍歷索引建立表\n    Yes → Loop j ← i 至 n-1:\n          → P[i][j] ← (s[i]==s[j]) ∧ (j-i<2 ∨ P[i+1][j-1]) // 判斷是否為回文\n→ dp ← array n+1 // 產生動態規劃陣列\n→ dp[0] ← -1 // 初始化，前置位置不需要切割\n→ Decision: i ← 1 至 n? // 計算每個前綴的最小切割\n    Yes → dp[i] ← ∞ // 設定初始最大值\n    → Loop j ← 0 至 i-1:\n          → Decision: P[j][i-1] 為真? // 子字串是否回文\n              Yes → dp[i] ← min(dp[i], dp[j]+1) // 更新切割數\n→ Return dp[n] // 回傳最小切割數\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            min_cut = i\n            for j in range(i + 1):\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    if j == 0:\n                        min_cut = 0\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n\n        return dp[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Try to extract the string inside double quotes\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: take the part after '=' if present\n        parts = data.split('=', 1)\n        s = parts[1].strip() if len(parts) > 1 else parts[0].strip()\n\n    solution = Solution()\n    print(solution.minCut(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: given two strings a and b, return length of longest uncommon subsequence between them. Uncommon subsequence defined as subsequence that is a subsequence of exactly one of them. Classic LeetCode problem: if a == b return -1 else max(len(a), len(b)). So virtual steps: check equality, if equal return -1, else return longer length. So produce steps: Start, Input strings a,b, Decision: If a equals b? Yes→ return -1 No→ compute length of a, length of b, Decision: if len(a) > len(b)? Yes → return len(a) No → return len(b). End. Each line with explanation. Use arrow syntax. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 a、b // 從使用者或輸入獲取兩個字串  \n→ Decision: 若 a 與 b 相等? // 檢查兩字串是否完全相同  \n  Yes → Step 2: 回傳 -1 // 若相等，表示無不常子序列  \n  No  → Step 3: 計算 lenA = 長度(a) // 取得字串 a 的長度  \n     → Step 4: 計算 lenB = 長度(b) // 取得字串 b 的長度  \n     → Decision: 若 lenA 大於 lenB? // 比較兩個長度  \n      Yes → Step 5: 回傳 lenA // a 更長，為不常子序列的最大長度  \n      No  → Step 6: 回傳 lenB // b 更長或相等時，取長度較長者  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        \"\"\"\n        Return the length of the longest uncommon subsequence between a and b.\n        If a and b are identical, no uncommon subsequence exists, so return -1.\n        Otherwise, the longest uncommon subsequence is simply the longer string.\n        \"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n\ndef _strip_quotes(s: str) -> str:\n    \"\"\"\n    Remove surrounding single or double quotes from a string if present.\n    \"\"\"\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        return s[1:-1]\n    return s\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, process it, and output the result to stdout.\n    The input may be provided in one of the following forms:\n      1. Two lines, each containing one string.\n      2. A single line in the format: \"string1\", \"string2\"\n    \"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    # Case 1: two separate lines\n    if len(data) >= 2:\n        a = _strip_quotes(data[0].strip())\n        b = _strip_quotes(data[1].strip())\n    # Case 2: one line with comma-separated strings\n    else:\n        line = data[0]\n        parts = line.split(\",\")\n        if len(parts) != 2:\n            raise ValueError(\"Invalid input format\")\n        a = _strip_quotes(parts[0].strip())\n        b = _strip_quotes(parts[1].strip())\n\n    solution = Solution()\n    result = solution.findLUSlength(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines, not actual code. The algorithm: dynamic programming: dp[0]=0; for amount from 1..target: dp[i]=min(dp[i-coin]+1). If dp[amount]==inf return -1. We need to produce step-by-step pseudocode with arrow style. Use Start, End, Decision. Provide explanation after //.\n\nLet's produce. Ensure each line: Virtual code step + space + // explanation. Use arrow \"→\". For loops: we can indicate \"Loop i from 1 to amount\". Use Decision: If coin <= i then compute. Also need Infinity sentinel. We'll use \"∞\". Use decisions inside loops.\n\nWe need step-by-step pseudocode. Let's start:\n\nStart // 開始\n→ Step 1: 定義 dp 陣列長度 amount+1 並全部設為 ∞ // 建立 DP 表\n→ Step 2: dp[0] ← 0 // 0 元不需要任何硬幣\n→ Step 3: Loop i from 1 to amount // 逐個計算每個金額\n    → Decision: 是否有可用硬幣? // 檢查是否存在合法硬幣\n        Yes → Step 4: Loop 每枚硬幣 c in coins // 遍歷每種硬幣\n            → Decision: 如果 c ≤ i? // 確認硬幣能用於此金額\n                Yes → Step 5: temp ← dp[i - c] + 1 // 使用該硬幣後的硬幣數\n                → Decision: temp < dp[i]? // 比較是否更少\n                    Yes → Step 6: dp[i] ← temp // 更新為更少硬幣\n                    No  → // 不更新\n                No  → // 不考慮此硬幣\n        No → // 仍保持 dp[i] 為 ∞\n→ Decision: 如果 dp[amount] == ∞? // 判斷是否能組合成目標金額\n    Yes → Step 7: return -1 // 無法組合\n    No  → Step 8: return dp[amount] // 返回最少硬幣數\nEnd // 程式結束\n\nWe need to ensure each line has a virtual step and explanation. Also need arrow indent? They used spaces. We'll format like example. Each line after Start: \"→ Step 1: ...\" For nested decisions we indent. Ensure each line has comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 dp 陣列長度 amount+1 並全部設為 ∞ // 建立 DP 表格  \n→ Step 2: dp[0] ← 0 // 零元不需要任何硬幣  \n→ Step 3: Loop i from 1 to amount // 逐個計算每個金額  \n  → Decision: 有無可用硬幣? // 檢查是否存在合法硬幣  \n   Yes → Step 4: Loop 每枚硬幣 c in coins // 遍歷所有硬幣  \n     → Decision: c ≤ i? // 確認硬幣能否用於此金額  \n      Yes → Step 5: temp ← dp[i - c] + 1 // 使用此硬幣後的硬幣數  \n       → Decision: temp < dp[i]? // 是否更少硬幣  \n        Yes → Step 6: dp[i] ← temp // 更新為更少硬幣數  \n        No  → // 不更新  \n      No  → // 跳過此硬幣  \n   No → // 無合法硬幣，dp[i] 仍為 ∞  \n→ Decision: dp[amount] == ∞? // 判斷是否能組成目標金額  \n  Yes → Step 7: return -1 // 無法達成，返回 -1  \n  No  → Step 8: return dp[amount] // 返回最少硬幣數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # dp[i] 表示湊成金額 i 所需最少硬幣數，初始值為無限大\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                # 若使用這枚硬幣後的硬幣數更少，則更新 dp[x]\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\ndef parse_input(text):\n    \"\"\"從輸入文字中提取 coins 列表和 amount 整數。\"\"\"\n    coins_match = re.search(r'coins\\s*=\\s*(\\[[^\\]]*\\])', text)\n    amount_match = re.search(r'amount\\s*=\\s*(-?\\d+)', text)\n    if not coins_match or not amount_match:\n        raise ValueError('Invalid input format')\n    coins = eval(coins_match.group(1))          # 例如 [1,2,5]\n    amount = int(amount_match.group(1))        # 例如 11\n    return coins, amount\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    try:\n        coins, amount = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    solver = Solution()\n    result = solver.coinChange(coins, amount)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode with explanations. Problem is classic House Robber II. Approach: DP with circular constraint. We can split into two cases: rob houses 0..n-2 (exclude last) and 1..n-1 (exclude first). Compute max of both. Edge cases: n==1 return nums[0]; else run dp for linear array. DP: dp[i] = max(dp[i-1], dp[i-2]+nums[i]) with base dp[0]=nums[0], dp[1]=max(nums[0],nums[1]). We can implement function RobLinear(start,end). Use loop. Output steps. Use Start, End. Provide lines accordingly.\n\nWe should not output actual code, only virtual code steps with arrow. Let's produce steps.\n\nWe'll have main algorithm: Start, if n==0 return 0, if n==1 return nums[0], else compute case1 = RobLinear(0,n-2), case2 = RobLinear(1,n-1), result=max(case1,case2), output result, End.\n\nRobLinear function steps: Start, initialize prev2=0, prev1=0, for i from start to end: curr = max(prev1, prev2+nums[i]), update prev2=prev1, prev1=curr, End return prev1.\n\nWe need to structure with arrow. Provide each line.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Decision: 若 nums 空? // 判斷陣列是否為空\n    Yes → Step 1: 輸出 0 // 空陣列無錢\n    No  → Decision: nums 長度為 1? // 檢查是否只有一棟房子\n        Yes → Step 2: 輸出 nums[0] // 只有一棟，直接拿\n        No  → Step 3: 執行主流程 // 多於一棟，進行循環處理\n\n主流程:\n→ Step 4: 設定 n = nums.Length // 取得房子總數\n→ Step 5: 執行函式 RobLinear(0, n-2) → case1 // 計算排除最後一棟\n→ Step 6: 執行函式 RobLinear(1, n-1) → case2 // 計算排除第一棟\n→ Step 7: 計算 max(case1, case2) → result // 取兩種情況最大值\n→ Step 8: 輸出 result // 回傳最大可獲利\nEnd // 程式結束\n\nDefine RobLinear:\nStart // RobLinear 開始\n→ Step 1: prev2 = 0 // 前前一棟收益\n→ Step 2: prev1 = 0 // 前一棟收益\n→ Step 3: 對 i 從 start 到 end 做 // 逐一遍歷房子\n    → Step 4: curr = max(prev1, prev2 + nums[i]) // 決定是否偷取\n    → Step 5: prev2 = prev1 // 更新前前一棟\n    → Step 6: prev1 = curr // 更新前一棟\nEnd // RobLinear 結束\n→ Return prev1 // 迴圈結束後 prev1 為最大收益\n\nBut must format with arrows and indentation? The example shows indenting using spaces. Provide each line as separate. Use \"→\" for next step, \"Decision:\" etc. Indent decisions accordingly.\n\nMake sure each line has virtual code and comment. We'll output as text lines.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums 是否為空? // 判斷輸入陣列是否為空  \n  Yes → Step 1: 輸出 0 // 空陣列無可偷取之財  \n  No → Decision: nums.Length 是否等於 1? // 檢查是否只有一棟房子  \n   Yes → Step 2: 輸出 nums[0] // 只有一棟，直接拿走  \n   No → Step 3: 執行主流程 // 多於一棟，進行循環處理  \n\n主流程  \n→ Step 4: 設定 n = nums.Length // 取得房子總數  \n→ Step 5: 執行 RobLinear(0, n-2) → case1 // 計算排除最後一棟的最大收益  \n→ Step 6: 執行 RobLinear(1, n-1) → case2 // 計算排除第一棟的最大收益  \n→ Step 7: 計算 max(case1, case2) → result // 取兩種情況中較大的收益  \n→ Step 8: 輸出 result // 回傳最終答案  \nEnd // 程式執行結束  \n\nRobLinear 函式  \nStart // RobLinear 開始  \n→ Step 1: prev2 = 0 // 前前一棟的最大收益  \n→ Step 2: prev1 = 0 // 前一棟的最大收益  \n→ Step 3: 對 i 從 start 到 end 做 // 逐一遍歷指定區間的房子  \n  → Step 4: curr = max(prev1, prev2 + nums[i]) // 決定是否偷取當前房子  \n  → Step 5: prev2 = prev1 // 更新前前一棟的收益  \n  → Step 6: prev1 = curr // 更新前一棟的收益  \nEnd // RobLinear 結束  \n→ Return prev1 // 迴圈結束後 prev1 為區間內的最大可偷收益",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def rob(self, nums):\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n\n        def rob_linear(houses):\n            prev, curr = 0, 0\n            for num in houses:\n                prev, curr = curr, max(curr, prev + num)\n            return curr\n\n        return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n\n\ndef main():\n    data = sys.stdin.read()\n    # 找到第一個 '[' 和對應的 ']'，提取列表字串\n    match = re.search(r'\\[.*?\\]', data, re.S)\n    if not match:\n        nums = []\n    else:\n        list_str = match.group(0)\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n\n    sol = Solution()\n    result = sol.rob(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for removing k digits to get smallest possible integer. Standard greedy stack algorithm: iterate digits, while stack not empty and top > current digit and k>0: pop, decrement k. Then push current. After loop, if k>0, pop last k digits. Finally, build result from stack, strip leading zeros, if empty return \"0\". Also ensure string. Provide line-by-line virtual code with explanation.\n\nWe must adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrows and structure.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty stack S // 用於儲存選擇的數字\n→ Step 2: For each digit d in num from left to right // 逐個處理輸入數字\n    → Decision: S not empty AND top(S) > d AND k > 0? // 是否能刪除較大的前面數字\n        Yes → Step 3: Pop top of S // 刪除較大的數字\n        Yes → Step 4: Decrement k // 刪除一次\n        No  → Step 5: Push d onto S // 將當前數字保留\n→ Decision: k > 0? // 若仍有未刪除的位數\n    Yes → Step 6: Remove last k digits from S // 刪除最末尾的多餘位數\n→ Step 7: Build result string R from S in order // 重新組合剩餘數字\n→ Step 8: Remove leading zeros from R // 去除前導零\n    → Decision: R is empty? // 若全部被去除\n        Yes → Step 9: Set R = \"0\" // 回傳 0\n        No  → No action\nEnd // 返回最小數字\n\nNeed to use arrows: Start, End, Decision, Yes →, No →.\n\nEnsure each line ends with // 解釋. Use step numbers? Not necessary but fine. Use \"Step 1:\" etc. Provide indentation? The example uses indentation for decisions. We'll mimic that.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 S // 用於儲存目前保留的數字  \n→ Step 2: 從左至右遍歷 num 的每個數字 d // 逐位處理  \n  → Decision: S 非空 且 top(S) > d 且 k > 0? // 判斷是否可刪除較大的前面數字  \n   Yes → Step 3: 從 S 彈出 top // 刪除較大的數字  \n   Yes → Step 4: k ← k - 1 // 刪除一次，更新 k  \n   No  → Step 5: 將 d 推入 S // 保留當前數字  \n→ Decision: k > 0? // 檢查是否還有位數需刪除  \n  Yes → Step 6: 從 S 移除最後 k 個元素 // 刪除最末尾的多餘位數  \n→ Step 7: 從 S 的內容按順序組合成字符串 R // 重新構造剩餘數字  \n→ Step 8: 從 R 前面去除所有 '0' // 去除前導零  \n  → Decision: R 為空? // 判斷所有數字是否已被去除  \n   Yes → Step 9: R ← \"0\" // 若結果為空，設為 0  \n   No  → No action  \nEnd // 程式執行結束，返回 R 為最小可能的整數。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"\n        使用棧（stack）實現贪心演算法，將多餘的較大數字刪除，\n        使剩餘數字按升序排列，最終得到最小整數。\n        \"\"\"\n        stack = []\n        # 逐位遍歷數字，對於每個 digit\n        for digit in num:\n            # 若還有可刪除數量，且棧頂元素比當前 digit 大，則刪除棧頂\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # 若遍歷完仍有未刪除的數量，則從尾部刪除\n        while k > 0:\n            stack.pop()\n            k -= 1\n\n        # 轉換為字串並去除前導零\n        result = ''.join(stack).lstrip('0')\n        # 若結果為空，返回 \"0\"\n        return result if result else \"0\"\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（可能包含多行）\n    raw_input = sys.stdin.read().strip()\n\n    # 解析形如：num = \"1432219\", k = 3 的輸入\n    pattern = r'num\\s*=\\s*\"(?P<num>[^\"]+)\"\\s*,\\s*k\\s*=\\s*(?P<k>\\d+)'\n    match = re.search(pattern, raw_input)\n\n    if match:\n        num_str = match.group('num')\n        k_val = int(match.group('k'))\n    else:\n        # 若輸入不符合上述格式，嘗試簡單分割（如 \"1432219 3\"）\n        parts = raw_input.split()\n        if len(parts) >= 2:\n            num_str = parts[0]\n            k_val = int(parts[1])\n        else:\n            # 無效輸入，直接結束\n            sys.exit(0)\n\n    solver = Solution()\n    result = solver.removeKdigits(num_str, k_val)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "1219"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "200"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking palindrome ignoring non-alphanumeric and case. Provide line by line with arrow. Should not produce actual code. Provide each line with explanation.\n\nLet's design algorithm:\n\nStart\n→ Step 1: Initialize left index = 0, right index = length-1 // set pointers\n→ Decision: If left >= right? // all chars processed\n    Yes → Step 2: Return true // palindrome\n    No → Step 3: Skip non-alphanumeric at left // while left < right and s[left] not alnum\n        → Decision: If left >= right? // maybe after skip\n            Yes → Step 2: Return true\n            No → Continue\n    → Step 4: Skip non-alphanumeric at right // similar\n    → Step 5: Convert chars at left and right to lowercase\n    → Decision: If chars equal?\n        Yes → Step 6: Increment left, decrement right, goto Step 3 loop\n        No → Step 7: Return false\nEnd\n\nWe need virtual steps. Use Start, End, Decision. Each line has virtual code followed by // explanation. Let's produce. Use arrow '→'.\n\nBe careful to keep line numbers maybe but not necessary. Provide arrows.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = s.length - 1 // 兩指標分別指向字串首尾  \n→ Decision: 若 left >= right? // 是否已處理完所有字元  \n    Yes → Step 2: 回傳 true // 所有字元已相等，為迴文  \n    No  → Step 3: 從 left 開始跳過非字母數字 // 以確保只比較有效字元  \n        → Decision: 若 left >= right?  \n            Yes → Step 2: 回傳 true  \n            No  → 進行下一步  \n    → Step 4: 從 right 開始跳過非字母數字  \n        → Decision: 若 left >= right?  \n            Yes → Step 2: 回傳 true  \n            No  → 進行下一步  \n    → Step 5: 取得 s[left] 與 s[right] 的小寫形式 // 轉成小寫進行比較  \n    → Decision: 若 s[left] == s[right]? // 兩端字元是否相等  \n        Yes → Step 6: left += 1, right -= 1 // 移動指標，繼續檢查下一對字元  \n            → 回到 Decision: 若 left >= right?  \n        No  → Step 7: 回傳 false // 有不相等，非迴文  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"\n    判斷字串 s 是否為迴文。\n    先將所有字母轉為小寫，並去除非字母數字，\n    再檢查結果是否對稱。\n    \"\"\"\n    filtered = [c.lower() for c in s if c.isalnum()]\n    return filtered == filtered[::-1]\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin 的輸入，預期格式為：\n        s = \"文字\"\n    或直接輸入文字。解析出文字後判斷是否為迴文，\n    並將結果以小寫字串 (true/false) 輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析出文字，假設文字被雙引號包住\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and start < end:\n        s = data[start + 1:end]\n    else:\n        # 若沒有引號，直接使用整行內容\n        s = data\n\n    result = is_palindrome(s)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for majority element using probably Boyer-Moore algorithm. Provide line by line with explanation. Use Start, End, Decision. Each line: virtual code step + space + // explanation.\n\nLet's create steps:\n\nStart\n→ Step 1: Initialize candidate = nums[0], count = 1 // set first element as candidate\n→ For i from 1 to n-1: // iterate rest\n   → Decision: if nums[i] == candidate? \n        Yes → count = count + 1 // same as candidate\n        No  → count = count - 1 // decrement count\n        → Decision: if count == 0? \n            Yes → candidate = nums[i]; count = 1 // new candidate\n            No  → (nothing)\nEnd // candidate is majority\n\nBut need to format each step line separately.\n\nWe need to use virtual arrows and indentation maybe. Provide each line separately. Use Start and End. Use Decision with Yes →, No →. Provide explanation after //. Each line must be single line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: candidate ← nums[0] // 初始化候選元素為陣列第一個元素\n→ Step 2: count ← 1 // 初始化計數器為 1\n→ Step 3: For i ← 1 to n-1 // 從第二個元素開始遍歷整個陣列\n    → Decision: nums[i] == candidate? // 判斷當前元素是否與候選相同\n        Yes → count ← count + 1 // 同為候選，計數器加 1\n        No  → count ← count - 1 // 與候選不同，計數器減 1\n        → Decision: count == 0? // 需要檢查計數器是否為 0\n            Yes → candidate ← nums[i]; count ← 1 // 設置新的候選，計數器重置為 1\n            No  → // 什麼也不做，繼續下一個元素\nEnd // candidate 即為多數元素\n\nBut each line must be separate. The For loop might be one line. The Decision and nested lines need separate lines too. Let's restructure each line:\n\nStart // 程式開始執行\n→ Step 1: candidate ← nums[0] // 初始化候選元素為陣列第一個元素\n→ Step 2: count ← 1 // 初始化計數器為 1\n→ Step 3: For i ← 1 to n-1 // 從第二個元素開始遍歷整個陣列\n    → Decision: nums[i] == candidate? // 判斷當前元素是否與候選相同\n        Yes → count ← count + 1 // 同為候選，計數器加 1\n        No  → count ← count - 1 // 與候選不同，計數器減 1\n        → Decision: count == 0? // 需要檢查計數器是否為 0\n            Yes → candidate ← nums[i]; count ← 1 // 設置新的候選，計數器重置為 1\n            No  → // 什麼也不做，繼續下一個元素\nEnd // candidate 即為多數元素\n\nBut need each line with '//' after step. Each line ends with // explanation. For decision nested lines, we may indent. That's acceptable.\n\nMake sure we use \"→\" for arrows. For loops maybe \"→ Step 3: For i ← 1 to n-1\" then indentation.\n\nLet's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: candidate ← nums[0] // 初始化候選元素為陣列第一個元素  \n→ Step 2: count ← 1 // 初始化計數器為 1  \n→ Step 3: For i ← 1 to n-1 // 從第二個元素開始遍歷整個陣列  \n  → Decision: nums[i] == candidate? // 判斷當前元素是否與候選相同  \n   Yes → count ← count + 1 // 同為候選，計數器加 1  \n   No  → count ← count - 1 // 與候選不同，計數器減 1  \n   → Decision: count == 0? // 檢查計數器是否為 0  \n    Yes → candidate ← nums[i]; count ← 1 // 設置新的候選，計數器重置為 1  \n    No  → // 什麼也不做，繼續下一個元素  \nEnd // candidate 即為多數元素，演算法結束。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        # Boyer-Moore majority vote algorithm\n        count = 0\n        candidate = None\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list part from a string like \"nums = [3,2,3]\"\n    lbr = data.find('[')\n    rbr = data.rfind(']')\n    if lbr == -1 or rbr == -1 or lbr > rbr:\n        # If no brackets found, try to interpret the whole input as a list\n        try:\n            nums = ast.literal_eval(data)\n        except Exception:\n            print(\"Invalid input\")\n            sys.exit(1)\n    else:\n        list_str = data[lbr:rbr+1]\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            print(\"Invalid input\")\n            sys.exit(1)\n\n    # Ensure nums is a list\n    if not isinstance(nums, list):\n        print(\"Input must be a list of integers\")\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.majorityElement(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. It's a typical problem: validate IP address. Provide step-by-step virtual code with arrow and decision. Must be in Traditional Chinese. Provide each line: \"虛擬碼步驟 // 解釋/說明\".\n\nWe must include Start, End, Decision, Yes/No branches, arrow \"→\".\n\nWe must produce a sequence of lines that cover algorithm: split by '.' and ':', check count, check each part.\n\nAlso handle empty parts, leading zeros for IPv4, length, numeric range, hex for IPv6, length 1-4, allowed chars.\n\nAlso handle trailing spaces? Not needed.\n\nWe need to produce a pseudo-code algorithm.\n\nLet's design:\n\nStart\n→ Input queryIP // Get the input string\n→ Decision: Contains '.'? // Check if string contains '.' to consider IPv4 possibility\n    Yes → Step: Split by '.' into partsIPv4 // Split into 4 parts\n        Decision: partsIPv4 count == 4? // Must be 4 parts\n            Yes → Decision: All parts valid IPv4? // Validate each part\n                Yes → Return 'IPv4'\n                No → Decision: Contains ':'? // If IPv4 invalid, maybe IPv6\n                    Yes → Go to IPv6 check\n                    No → Return 'Neither'\n            No → Decision: Contains ':'? // If count wrong, maybe IPv6\n                Yes → Go to IPv6 check\n                No → Return 'Neither'\n    No → Decision: Contains ':'? // No '.' -> maybe IPv6\n        Yes → Step: Split by ':' into partsIPv6\n            Decision: partsIPv6 count == 8? // Must be 8 parts\n                Yes → Decision: All parts valid IPv6? // Validate each part\n                    Yes → Return 'IPv6'\n                    No → Return 'Neither'\n                No → Return 'Neither'\n        No → Return 'Neither'\n\nBut need to integrate. Might be better: first split by '.'; if 4 parts, attempt IPv4; else split by ':' and check IPv6. But careful: string might contain both '.' and ':', treat as neither. According to problem, IPv6 uses ':', IPv4 uses '.', so if contains both, invalid. We'll include a check: if string contains both '.' and ':', return Neither.\n\nSimplify: Step: if '.' in queryIP and ':' in queryIP → Return 'Neither'. That handles both.\n\nLet's design final pseudo-code:\n\nStart\n→ Step: queryIP := input string\n→ Decision: queryIP contains both '.' and ':'? // If contains both, invalid\n    Yes → Return 'Neither'\n    No →\n        Decision: queryIP contains '.'? // Might be IPv4\n            Yes →\n                Step: parts := split queryIP by '.'\n                Decision: len(parts) != 4? // Must be 4 parts\n                    Yes → Go to IPv6 check\n                    No →\n                        Decision: all parts valid IPv4? // Check each part\n                            Yes → Return 'IPv4'\n                            No → Go to IPv6 check\n            No →\n                Step: parts := split queryIP by ':'\n                Decision: len(parts) != 8? // Must be 8 parts\n                    Yes → Return 'Neither'\n                    No →\n                        Decision: all parts valid IPv6? // Check each part\n                            Yes → Return 'IPv6'\n                            No → Return 'Neither'\n\nBut we need separate branch for IPv6. Let's embed IPv6 check after IPv4 fails. We'll need function-like steps: ValidateIPv4(parts), ValidateIPv6(parts). Provide in lines.\n\nLet's craft virtual code lines accordingly.\n\nImportant: Each line must be single step with arrow. Use \"→\" to indicate continuation. For decisions, we need \"Decision:\" lines and then Yes/No branches.\n\nAlso use indentation like the example.\n\nWe should produce code lines: \"→ Decision: ...\" then indent lines for Yes and No.\n\nLet's produce.\n\nWe need to mention Start and End. Also Step: ValidateIPv4(part) and ValidateIPv6(part). We'll break into separate substeps.\n\nLet's produce final pseudo-code. Ensure Traditional Chinese explanations. Use // after code.\n\nLet's craft step-by-step.\n\nWe might need to represent functions but we can inline validation logic.\n\nLet's write.\n\nAlso note that leading zeros for IPv4 are not allowed unless part is exactly \"0\". So rule: if part has length > 1 and starts with '0' → invalid. Also must be numeric only, no other chars. Then int(part) between 0 and 255.\n\nFor IPv6: each part length 1-4, characters 0-9, a-f, A-F. Leading zeros allowed. So check each char is hex digit.\n\nNow produce pseudo-code lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: queryIP := input string // 取得使用者輸入的 IP 字串  \n→ Decision: queryIP 內同時含有 '.' 與 ':'? // 同時含有兩種分隔符號，必定不是合法 IP  \n    Yes → Return 'Neither' // 同時有 '.' 與 ':'，直接回傳 Neither  \n    No →  \n        Decision: queryIP 內含 '.'? // 可能是 IPv4  \n            Yes →  \n                Step: parts4 := split queryIP by '.' // 以 '.' 分割成 4 部分  \n                Decision: len(parts4) ≠ 4? // 必須恰好 4 個部份  \n                    Yes → Go to IPv6Check // 部份數不對，嘗試判斷為 IPv6  \n                    No →  \n                        Decision: all parts4 都為合法 IPv4? // 檢查每個部份是否符合 IPv4 規則  \n                            Yes → Return 'IPv4' // 所有部份合法，回傳 IPv4  \n                            No → Go to IPv6Check // 有部份不合法，嘗試判斷為 IPv6  \n            No → Go to IPv6Check // 沒有 '.'，可能是 IPv6  \n\nIPv6Check:  \n→ Step: parts8 := split queryIP by ':' // 以 ':' 分割成 8 部分  \n→ Decision: len(parts8) ≠ 8? // 必須恰好 8 個部份  \n    Yes → Return 'Neither' // 部份數不對，非合法 IP  \n    No →  \n        Decision: all parts8 都為合法 IPv6? // 檢查每個部份是否符合 IPv6 規則  \n            Yes → Return 'IPv6' // 所有部份合法，回傳 IPv6  \n            No → Return 'Neither' // 有部份不合法，回傳 Neither  \n\n// 檢查是否為合法 IPv4 部份  \n→ Function: isValidIPv4Part(part) →  \n    Decision: part 為空字串? // 空部份不合法  \n        Yes → False  \n        No →  \n            Decision: part 含非數字字符? // 只能為 0-9  \n                Yes → False  \n                No →  \n                    Decision: part 長度 > 1 且首字元為 '0'? // 不能有前導零（除非是單獨的 '0'）  \n                        Yes → False  \n                        No →  \n                            Decision: 整數 part > 255? // 需在 0-255 之間  \n                                Yes → False  \n                                No → True  \n\n// 檢查是否為合法 IPv6 部份  \n→ Function: isValidIPv6Part(part) →  \n    Decision: part 空字串? // 空部份不合法  \n        Yes → False  \n        No →  \n            Decision: 1 ≤ len(part) ≤ 4? // 長度必須 1 到 4  \n                Yes →  \n                    Decision: part 中有非十六進位字符? // 只允許 0-9, a-f, A-F  \n                        Yes → False  \n                        No → True  \n                No → False  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        # 檢查 IPv4\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                if not part.isdigit():                 # 只能是數字\n                    return False\n                if not 0 <= int(part) <= 255:          # 數值範圍\n                    return False\n                if part[0] == '0' and len(part) != 1:   # 前導零不允許\n                    return False\n            return True\n\n        # 檢查 IPv6\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = \"0123456789abcdefABCDEF\"\n            for part in parts:\n                if not 1 <= len(part) <= 4:                # 長度 1~4\n                    return False\n                for c in part:\n                    if c not in hexdigits:                 # 只能是十六進位\n                        return False\n            return True\n\n        # 主邏輯\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        if queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        return \"Neither\"\n\ndef main() -> None:\n    # 讀取全部輸入\n    raw = sys.stdin.read().strip()\n    # 從字串中提取第一個被雙引號包住的內容，若無則直接使用整行\n    match = re.search(r'\"([^\"]+)\"', raw)\n    queryIP = match.group(1) if match else raw.strip('\"').strip()\n    solution = Solution()\n    result = solution.validIPAddress(queryIP)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The requirement: \"逐行產生虛擬碼\" with arrow and structure. Provide a BFS approach. Let's write steps:\n\nStart\n→ 初始化 visited set = {startGene}\n→ Queue ← [(startGene, 0)] // start gene with 0 mutations\n→ While Queue not empty\n    → Dequeue currentGene, currentSteps\n    → If currentGene == endGene → Return currentSteps // found minimal\n    → For each position 0..7\n        → For each char in ['A','C','G','T']\n            → newGene = replace currentGene at pos with char\n            → If newGene in bank and not visited\n                → Add to visited\n                → Enqueue (newGene, currentSteps+1)\n→ Return -1 // no path\n\nWe'll produce in virtual code. Use Decision and Yes/No. Provide explanations after each line. Let's craft.\n\nAlso ensure we have Start and End. We'll include bank list variable.\n\nWe may include \"bankSet = set(bank)\" for quick lookup.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ bankSet ← Convert bank to Set // 快速查詢是否為合法基因  \n→ visited ← Set(startGene) // 記錄已訪問的基因，避免重複  \n→ queue ← [(startGene, 0)] // BFS佇列，元素為 (基因, 變異步數)  \n→ Decision: queue 非空? // 若佇列還有待處理項目  \n    Yes → Step 1: (current, steps) ← Dequeue(queue) // 取出最早加入的基因  \n    → Decision: current == endGene? // 是否已到達目標  \n        Yes → Return steps // 找到最短變異數，直接返回  \n        No → Step 2: For pos from 0 to 7 // 遍歷每個位置  \n            → Step 3: For char in ['A','C','G','T'] // 嘗試四種可能的字母  \n                → newGene ← Replace current[pos] with char // 產生新的基因  \n                → Decision: newGene 在 bankSet 且 newGene 未在 visited? // 檢查合法且未訪問  \n                    Yes → visited.add(newGene) // 標記為已訪問  \n                    → Enqueue(queue, (newGene, steps+1)) // 將新基因加入佇列，步數加一  \n                    No  → Skip // 不是合法基因或已處理，忽略  \n    → Go back to Decision: queue 非空? // 繼續處理下一個項目  \n→ Return -1 // 無法從 startGene 變異到 endGene，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        \"\"\"計算最小突變步數，若無法突變則回傳 -1\"\"\"\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue: deque[tuple[str, int]] = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            for i in range(len(current)):\n                for g in genes:\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef parse_input(data: str) -> tuple[str, str, list[str]]:\n    \"\"\"從輸入字串解析 startGene、endGene 與 bank 列表\"\"\"\n    pattern = (\n        r'startGene\\s*=\\s*\"(?P<start>[^\"]+)\"\\s*,\\s*'\n        r'endGene\\s*=\\s*\"(?P<end>[^\"]+)\"\\s*,\\s*'\n        r'bank\\s*=\\s*\\[(?P<bank>[^]]*)\\]'\n    )\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式不正確\")\n\n    start = match.group('start')\n    end = match.group('end')\n    bank_raw = match.group('bank').strip()\n    if bank_raw:\n        bank = [item.strip().strip('\"') for item in bank_raw.split(',') if item.strip()]\n    else:\n        bank = []\n    return start, end, bank\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    start_gene, end_gene, bank_list = parse_input(raw_input)\n    solution = Solution()\n    result = solution.minMutation(start_gene, end_gene, bank_list)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line with explanations. It's converting a number to Excel column title. Standard algorithm: while columnNumber > 0: columnNumber--; char = 'A' + (columnNumber % 26); prepend; columnNumber/=26. Need to produce pseudo code steps with Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe should produce steps:\n\nStart\n→ Step 1: 初始化 result = \"\" // 空字串\n→ Step 2: while columnNumber > 0 // 迴圈條件\n   → Step 2.1: columnNumber ← columnNumber - 1 // 先減一\n   → Step 2.2: remainder ← columnNumber mod 26 // 取餘數\n   → Step 2.3: char ← chr('A' + remainder) // 對應字母\n   → Step 2.4: result ← char + result // 前綴\n   → Step 2.5: columnNumber ← columnNumber // integer division by 26\nBut need to include integer division. Let's do columnNumber ← columnNumber // 26\n\n→ Step 3: Return result // 結果\n\nBut need to show Decision maybe: while loop is decision. Let's produce as decision.\n\nAlso need to show the End. Let's craft each line.\n\nWe must use arrow '→', 'Yes →', 'No →' as appropriate. For while loop, we can use Decision: While columnNumber > 0? Yes → (loop body). No → End.\n\nBut the End is after return? Might use End after return. Provide simple pseudocode.\n\nWe need to produce each line separately.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: Set result = \"\" // 初始化結果字串\n→ Decision: columnNumber > 0? // 檢查是否還有數位需要處理\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一以配合 0~25 的索引\n    → Step 3: remainder ← columnNumber mod 26 // 取得目前位數的餘數\n    → Step 4: char ← chr('A' + remainder) // 對應字母\n    → Step 5: result ← char + result // 將字母加到結果前面\n    → Step 6: columnNumber ← columnNumber // 26 的整除 (columnNumber = columnNumber / 26)\n    → Decision: columnNumber > 0? // 再次檢查是否還有剩餘\n        Yes → repeat from Step 2\n        No  → Step 7: Return result // 回傳完成的標題\nEnd // 程式執行結束\n\nBut we need to ensure syntax: each line must be \"虛擬碼步驟 // 解釋\".\n\nWe need to avoid actual code, use pseudocode. We can keep like \"Set result = \"\"\". Use quotes? It's pseudocode, not real code. That's fine.\n\nBut we need to include arrow lines properly. For Decision we use \"Decision: columnNumber > 0?\" with arrow.\n\nIn pseudocode we can use indent. Use \"→\" for each step line.\n\nAlso we need to handle nested decisions: After step 6, we need to decide again.\n\nBut we might simplify: While loop as repeated decision: Decision: columnNumber > 0? Yes → ... No → ... The inside body includes steps, after body we go back to decision. So we can express as:\n\nDecision: columnNumber > 0?\n    Yes → Step 2: columnNumber ← columnNumber - 1\n    → Step 3: remainder ← columnNumber mod 26\n    → Step 4: char ← chr('A' + remainder)\n    → Step 5: result ← char + result\n    → Step 6: columnNumber ← columnNumber / 26\n    → Decision: columnNumber > 0? ... but that loops again. We can express as loop.\n\nBut we might not need nested decisions; we can just use while loop as single decision and loop.\n\nLet's craft final.\n\nWe need each line with the arrow and explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Set result = \"\" // 初始化結果字串\n→ Decision: columnNumber > 0? // 判斷是否還有數位要處理\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一，使 1 對應 A\n    → Step 3: remainder ← columnNumber mod 26 // 取得餘數 0~25\n    → Step 4: char ← chr('A' + remainder) // 對應字母\n    → Step 5: result ← char + result // 把字母加到前面\n    → Step 6: columnNumber ← columnNumber // 26 的整除 (columnNumber = columnNumber / 26)\n    → Decision: columnNumber > 0? // 重新判斷是否還需要再處理\n        Yes → jump back to Decision: columnNumber > 0? // 這裡表示迴圈重複\n        No  → Step 7: Return result // 回傳最終標題\nEnd // 程式執行結束\n\nBut need \"Yes →\" and \"No →\" syntax: Each decision has Yes → ... and No → ... Each branch is a line.\n\nAlso the \"jump back\" can be indicated as \"→ Decision: columnNumber > 0? // 回到迴圈開始\". But the syntax: \"Yes → ...\" but the branch should start with arrow again. We can use \"Yes → // 迴圈繼續\" but we need step inside. It's fine to indicate \"Yes → // 迴圈繼續\" but we need a step. We could do \"Yes → // 迴圈回到 Decision\" and then \"→ Decision: columnNumber > 0?\"? That may duplicate.\n\nAlternatively, we can express the while loop simply:\n\nWhile columnNumber > 0\n    columnNumber ← columnNumber - 1\n    remainder ← columnNumber mod 26\n    char ← chr('A' + remainder)\n    result ← char + result\n    columnNumber ← columnNumber // 26\n\nBut we need to use Decision syntax: Decision: columnNumber > 0? Yes → (loop body) No → Return result.\n\nInside loop body we don't need nested Decision; after body we just loop back to top. Represent by \"Yes → // 執行迴圈內部\" then arrow to next Decision? We can use \"Yes → // 執行迴圈內部\" then \"→ Decision: columnNumber > 0?\".\n\nBut we also need to show the repeated decision.\n\nMaybe simpler: Use recursion style? Not necessary.\n\nOk produce final pseudocode lines:\n\nStart // 程式開始執行\n→ Step 1: Set result = \"\" // 初始化結果字串\n→ Decision: columnNumber > 0? // 檢查是否還有位數需要處理\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一以配合 0~25 的索引\n    → Step 3: remainder ← columnNumber mod 26 // 取得目前位數的餘數\n    → Step 4: char ← chr('A' + remainder) // 對應字母\n    → Step 5: result ← char + result // 把字母加到結果前面\n    → Step 6: columnNumber ← columnNumber // 26 的整除 (columnNumber = columnNumber / 26)\n    → Decision: columnNumber > 0? // 再次檢查是否還有剩餘\n        Yes → // 迴圈繼續\n        No  → Step 7: Return result // 回傳完成的標題\nEnd // 程式執行結束\n\nBut each line must have arrow. For the nested Decision lines, we should keep arrow at start. For the nested decision inside Yes branch, we need \"Yes → // 迴圈繼續\". But that line has no step after arrow. The requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must have some virtual code. So we cannot have just comment. So we can express \"Yes → // 迴圈繼續\" but no step. Maybe better to represent as \"Yes → // 迴圈回到 Decision\". But still no virtual code after arrow. But requirement: each line must contain virtual code step. So we need something like \"Yes → GoToDecision\" but not actual code. Could use \"Yes → Repeat\" but still not real code. We can just say \"Yes → // 迴圈繼續\" and treat \"Repeat\" as virtual code step? It's ambiguous. But I think it's okay to have a line with arrow but only comment? The requirement says \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". That means the virtual code step must exist. So we need some placeholder.\n\nWe can use \"Yes → Continue\" as step. That is a step. Then explanation comment.\n\nSo modify:\n\n    Yes → Continue // 迴圈回到 Decision\n\nThen the nested decision remains.\n\nBut we also need to show the decision after the loop.\n\nLet's rewrite:\n\nStart // 程式開始執行\n→ Step 1: Set result = \"\" // 初始化結果字串\n→ Decision: columnNumber > 0? // 檢查是否還有位數需要處理\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一以配合 0~25 的索引\n    → Step 3: remainder ← columnNumber mod 26 // 取得目前位數的餘數\n    → Step 4: char ← chr('A' + remainder) // 對應字母\n    → Step 5: result ← char + result // 把字母加到結果前面\n    → Step 6: columnNumber ← columnNumber // 26 的整除 (columnNumber = columnNumber / 26)\n    → Decision: columnNumber > 0? // 再次檢查是否還有剩餘\n        Yes → Continue // 迴圈繼續\n        No  → Step 7: Return result // 回傳完成的標題\nEnd // 程式執行結束\n\nBut the nested decision still inside \"Yes → Continue\"? Wait \"Continue\" is a step. Then after Continue we go back to top of outer decision. But we still need to indicate that we go back. We can add \"Continue\" and then arrow to outer Decision? Not necessary.\n\nBut to satisfy the formatting, maybe easier to use a while loop representation:\n\nStart // 程式開始執行\n→ Step 1: Set result = \"\" // 初始化結果字串\n→ Decision: columnNumber > 0? // 判斷是否還有數位\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一\n    → Step 3: remainder ← columnNumber mod 26 // 取得餘數\n    → Step 4: char ← chr('A' + remainder) // 對應字母\n    → Step 5: result ← char + result // 將字母加到結果前面\n    → Step 6: columnNumber ← columnNumber // 26 的整除\n    → Decision: columnNumber > 0? // 重新判斷\n        Yes → // 迴圈回到上面 Decision\n        No  → Step 7: Return result // 回傳結果\nEnd // 程式結束\n\nBut the \"Yes → // 迴圈回到上面 Decision\" lacks a step.\n\nBetter to use a label and goto.\n\nWe can use \"Yes → GoToLoopStart\" as step, then comment.\n\nThus:\n\nDecision: columnNumber > 0?\n    Yes → GoToLoopStart // 迴圈回到開始\n    No  → Step 7: Return result\n\nBut the loop start is just the decision again, so we need to show that. It's okay.\n\nLet's produce final pseudocode:\n\nStart // 程式開始執行\n→ Step 1: Set result = \"\" // 初始化結果字串\n→ Decision: columnNumber > 0? // 判斷是否還有位數需要處理\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一以配合 0~25 的索引\n    → Step 3: remainder ← columnNumber mod 26 // 取得餘數\n    → Step 4: char ← chr('A' + remainder) // 對應字母\n    → Step 5: result ← char + result // 把字母加到結果前面\n    → Step 6: columnNumber ← columnNumber // 26 的整除 (columnNumber = columnNumber / 26)\n    → Decision: columnNumber > 0? // 再次檢查是否還有剩餘\n        Yes → GoToLoopStart // 迴圈回到 Decision\n        No  → Step 7: Return result // 回傳完成的標題\n→ GoToLoopStart // 迴圈入口 (回到 Decision)\nEnd // 程式執行結束\n\nBut the \"GoToLoopStart\" defined after is before we use it. It's okay.\n\nHowever, the \"GoToLoopStart\" step is not defined earlier, but we treat as label. That's fine.\n\nBut we still need to maintain the requirement of each line has arrow and explanation. Let's produce final answer with each line following the format exactly.\n\nWe'll produce the pseudocode lines sequentially:\n\nStart // 程式開始執行\n→ Step 1: Set result = \"\" // 初始化結果字串\n→ Decision: columnNumber > 0? // 判斷是否還有位數需要處理\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一以配合 0~25 的索引\n    → Step 3: remainder ← columnNumber mod 26 // 取得餘數\n    → Step 4: char ← chr('A' + remainder) // 對應字母\n    → Step 5: result ← char + result // 把字母加到結果前面\n    → Step 6: columnNumber ← columnNumber // 26 的整除 (columnNumber = columnNumber / 26)\n    → Decision: columnNumber > 0? // 再次檢查是否還有剩餘\n        Yes → GoToLoopStart // 迴圈回到 Decision\n        No  → Step 7: Return result // 回傳完成的標題\n→ GoToLoopStart // 迴圈入口 (回到 Decision)\nEnd // 程式執行結束\n\nBut the nested indentation maybe not required; we can just show each line with arrow. But the format example uses indentation for decisions. We can follow that.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set result = \"\" // 初始化結果字串  \n→ Decision: columnNumber > 0? // 判斷是否還有位數需要處理  \n Yes → Step 2: columnNumber ← columnNumber - 1 // 先減一以配合 0~25 的索引  \n  → Step 3: remainder ← columnNumber mod 26 // 取得目前位數的餘數  \n  → Step 4: char ← chr('A' + remainder) // 對應字母  \n  → Step 5: result ← char + result // 把字母加到結果前面  \n  → Step 6: columnNumber ← columnNumber // 26 的整除 (columnNumber = columnNumber / 26)  \n  → Decision: columnNumber > 0? // 再次檢查是否還有剩餘  \n   Yes → GoToLoopStart // 迴圈回到 Decision  \n   No  → Step 7: Return result // 回傳完成的標題  \n→ GoToLoopStart // 迴圈入口 (回到 Decision)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"\n        把正整數 columnNumber 轉成 Excel 的欄位標題。\n        \"\"\"\n        res = ''\n        while columnNumber > 0:\n            columnNumber -= 1                 # 先減 1，讓 0 對應 'A'\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取輸入、計算並輸出結果。\n    允許輸入的格式為「columnNumber = X」或直接為 X。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從「=」分割取得數字\n    if '=' in data:\n        _, num_str = data.split('=', 1)\n        num_str = num_str.strip()\n    else:\n        num_str = data.strip()\n\n    # 若仍無法轉成整數，使用正規表達式找第一個數字\n    try:\n        columnNumber = int(num_str)\n    except ValueError:\n        match = re.search(r'\\d+', data)\n        if not match:\n            return\n        columnNumber = int(match.group())\n\n    solution = Solution()\n    title = solution.convertToTitle(columnNumber)\n\n    # 按範例輸出，需包含引號\n    print(f'\"{title}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step, in Chinese (繁體). Provide lines with \"Start\", \"End\", steps, decisions. We need to merge k sorted linked lists into one sorted linked list. Standard approach: use min-heap. Or merge pairwise. We'll use min-heap. Steps: initialize min-heap with first nodes of each list. While heap not empty, pop smallest, attach to result, push next node from that list. Build dummy head. Provide explanations. Each line must contain virtual code step + space + // explanation. Use arrow symbols. Use Start, End, Decision: etc.\n\nWe need to produce pseudo code with line numbers? Not required. Just each line sequentially. Provide arrow for steps. Let's write.\n\nFirst line: Start // 程式開始\n\nNext: → Step 1: 建立空的優先佇列 (min-heap) // 用來存放目前各鏈表的最小節點\n\nThen: → Step 2: 建立 dummy head 與 current 指標 // 用於組裝結果鏈表\n\nThen: → Step 3: 將每個鏈表的首節點加入 min-heap // 初始將所有 k 個鏈表的第一個節點放進 heap\n\nThen: → Decision: min-heap 是否為空? // 檢查是否還有節點可處理\n\nInside Yes/No: No → Step 4: 取出 heap 中最小節點 node // 取得目前最小值\n\n→ Step 5: 把 node 附加到 current.next 並移動 current // 組裝結果鏈表\n\n→ Step 6: 如果 node.next 不為空 → Push node.next 到 heap // 將該鏈表的下一個節點加入 heap\n\n→ Decision: 是否繼續? // 循環到決策點\n\nYes -> loop back to Decision: min-heap 是否為空?\n\nAt the end: → Step 7: 回傳 dummy.head.next // 返回合併後的鏈表\n\nEnd // 程式結束\n\nNeed to ensure each line uses arrow symbol. Also \"Decision:\" with sub-lines. Use indentation for nested.\n\nWe need to produce each line as:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n...\n\nFor Decision: we indent sub-lines. Eg:\n\n→ Decision: min-heap 是否為空? // 檢查是否還有節點可處理\n    No  → Step 4: ... // explanation\n    Yes → End // heap 為空，結束\n\nBut we still have End at the end. Maybe better to use a loop representation: Use Decision at start of loop. But we also need to produce explicit End after returning.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空的優先佇列 (min-heap) // 用來存放目前各鏈表的最小節點\n→ Step 2: 建立 dummy head 與 current 指標 // 用於組裝結果鏈表\n→ Step 3: 將每個鏈表的首節點加入 min-heap // 初始將所有 k 個鏈表的第一個節點放進 heap\n→ Decision: min-heap 是否為空? // 檢查是否還有節點可處理\n    No  → Step 4: 取出 min-heap 中最小節點 node // 取得目前最小值\n    No  → Step 5: 把 node 附加到 current.next 並移動 current // 組裝結果鏈表\n    No  → Step 6: 如果 node.next 不為空 → Push node.next 到 min-heap // 將該鏈表的下一個節點加入 heap\n    No  → Decision: min-heap 是否為空? // 重複循環\n    Yes → Step 7: 回傳 dummy.head.next // 返回合併後的鏈表\nEnd // 程式執行結束\n\nBut indentation and arrow may not be correct. We should use the pattern:\n\n→ Decision: min-heap 是否為空? // 檢查是否還有節點可處理\n    No → Step 4: ...\n    No → Step 5: ...\n    No → Step 6: ...\n    No → Decision: min-heap 是否為空?\n    Yes → Step 7: 回傳 dummy.head.next\n\nBut this seems repetitive. Alternatively we can use loop notation:\n\n→ Decision: min-heap 是否為空? // 檢查是否還有節點可處理\n    No → Step 4: 取出 min-heap 中最小節點 node\n    No → Step 5: 把 node 附加到 current.next 並移動 current\n    No → Step 6: 如果 node.next 不為空 → Push node.next 到 min-heap\n    No → Goto Decision: min-heap 是否為空? // 循環\n    Yes → Step 7: 回傳 dummy.head.next\n\nBut the spec says use arrow arrows and structure, maybe we can use:\n\n→ Decision: min-heap 是否為空? // 檢查是否還有節點可處理\n    No → \n        Step 4: 取出 min-heap 中最小節點 node // 取得目前最小值\n        Step 5: 把 node 附加到 current.next 並移動 current // 組裝結果鏈表\n        Step 6: 如果 node.next 不為空 → Push node.next 到 min-heap // 將該鏈表的下一個節點加入 heap\n        → Decision: min-heap 是否為空? // 重複循環\n    Yes → Step 7: 回傳 dummy.head.next // 返回合併後的鏈表\n\nThis seems good.\n\nLet's produce final pseudo-code accordingly.\n\nRemember to start with Start, end with End.\n\nMake sure each line has `// 解釋/說明` style.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的優先佇列 (min-heap) // 用來存放目前各鏈表的最小節點  \n→ Step 2: 建立 dummy head 與 current 指標 // 用於組裝結果鏈表  \n→ Step 3: 將每個鏈表的首節點加入 min-heap // 初始將所有 k 個鏈表的第一個節點放進 heap  \n→ Decision: min-heap 是否為空? // 檢查是否還有節點可處理  \n    No → Step 4: 取出 min-heap 中最小節點 node // 取得目前最小值  \n    No → Step 5: 把 node 附加到 current.next 並移動 current // 組裝結果鏈表  \n    No → Step 6: 如果 node.next 不為空 → Push node.next 到 min-heap // 將該鏈表的下一個節點加入 heap  \n    No → Decision: min-heap 是否為空? // 重複循環直到 heap 為空  \n    Yes → Step 7: 回傳 dummy.head.next // 返回合併後的鏈表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n\n        # Build a min-heap with the first node of each list\n        heap = []\n        for idx, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, idx, node))\n\n        dummy = ListNode(0)\n        curr = dummy\n\n        while heap:\n            val, idx, node = heapq.heappop(heap)\n            curr.next = node\n            curr = curr.next\n            if node.next:\n                heapq.heappush(heap, (node.next.val, idx, node.next))\n\n        return dummy.next\n\ndef list_to_linked(lst):\n    \"\"\"Convert a Python list to a singly linked list.\"\"\"\n    dummy = ListNode()\n    cur = dummy\n    for val in lst:\n        cur.next = ListNode(val)\n        cur = cur.next\n    return dummy.next\n\ndef linked_to_list(node):\n    \"\"\"Convert a singly linked list to a Python list.\"\"\"\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\nif __name__ == \"__main__\":\n    # Read all input\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Extract the part after '=' and parse it\n    try:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n        raw_lists = ast.literal_eval(expr)\n    except Exception:\n        # If parsing fails, assume empty input\n        raw_lists = []\n\n    # Convert each sublist to a linked list\n    linked_lists = [list_to_linked(sub) for sub in raw_lists]\n\n    # Merge k lists\n    sol = Solution()\n    merged_head = sol.mergeKLists(linked_lists)\n\n    # Convert result back to list and print\n    merged_list = linked_to_list(merged_head)\n    print(merged_list)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for MedianFinder with addNum and findMedian. We need to design algorithm: use two heaps (max-heap left, min-heap right). Maintain sizes difference <=1. In addNum, push to appropriate heap. In findMedian, if sizes equal, median = (maxLeft + minRight)/2. Else the larger heap's top.\n\nWe need to output each line of virtual code with explanation. Provide Start, End, Decision, etc. Must be step-by-step. Use arrow formatting. Each line: \"虛擬碼步驟 // 解釋\". We need to not output actual code but pseudocode. We can use high-level constructs. Let's produce a linear algorithm representation. Also we need to mention initialization.\n\nSo produce:\n\nStart\n→ Step 1: 初始化兩個堆：左堆（最大堆）和右堆（最小堆） // 用於儲存小半和大半數字\n→ Step 2: 定義 addNum(num) 方法 // 添加新數字\n   → Decision: 若左堆為空或 num <= 左堆頂? // 判斷應放入左堆\n      Yes → 左堆入堆 num // 把數字插入左堆\n      No  → 右堆入堆 num // 否則插入右堆\n   → Decision: 左堆大小 > 右堆大小 + 1? // 檢查左堆是否過大\n      Yes → 右堆入堆 左堆頂並將左堆頂移除 // 平衡兩堆\n      No  → Decision: 右堆大小 > 左堆大小 + 1? // 檢查右堆是否過大\n           Yes → 左堆入堆 右堆頂並將右堆頂移除 // 平衡兩堆\n   → End // addNum 完成\n→ Step 3: 定義 findMedian() 方法 // 計算中位數\n   → Decision: 左堆大小 = 右堆大小? // 數量相等時\n      Yes → Return (左堆頂 + 右堆頂) / 2.0 // 取平均\n      No  → Decision: 左堆大小 > 右堆大小? // 左堆較大\n           Yes → Return 左堆頂 // 左堆頂即為中位數\n           No  → Return 右堆頂 // 右堆頂即為中位數\n→ End // MedianFinder 完成\n\nWe need to include \"Start\" and \"End\" for the whole program and for methods maybe.\n\nBut the format example shows Start/End for program. We can show Start, then the steps, then End. For each method, we can use indentation but not necessary.\n\nLet's produce each line with \"虛擬碼步驟 // 解釋\". Ensure arrow formatting.\n\nWe also might include \"MedianFinder\" initialization step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個堆：左堆（最大堆）和右堆（最小堆） // 用於分別儲存較小與較大的一半數值  \n→ Step 2: 定義方法 addNum(num) // 新增一個整數到資料結構  \n  → Decision: 左堆是否為空 或 num <= 左堆頂？ // 判斷新數字應放入左堆  \n   Yes → 左堆入堆 num // 把數字插入左堆  \n   No  → 右堆入堆 num // 否則插入右堆  \n  → Decision: 左堆大小 > 右堆大小 + 1？ // 檢查左堆是否過大  \n   Yes → 右堆入堆 左堆頂 並將左堆頂移除 // 將左堆最大的數轉移到右堆以平衡  \n   No  → Decision: 右堆大小 > 左堆大小 + 1？ // 檢查右堆是否過大  \n    Yes → 左堆入堆 右堆頂 並將右堆頂移除 // 將右堆最小的數轉移到左堆以平衡  \n  → End // addNum 完成  \n→ Step 3: 定義方法 findMedian() // 取得目前所有數字的中位數  \n  → Decision: 左堆大小 = 右堆大小？ // 數量相等時  \n   Yes → Return (左堆頂 + 右堆頂) / 2.0 // 取兩堆頂值的平均  \n   No  → Decision: 左堆大小 > 右堆大小？ // 左堆較大  \n    Yes → Return 左堆頂 // 左堆頂即為中位數  \n    No  → Return 右堆頂 // 右堆頂即為中位數  \n→ End // MedianFinder 完成程式執行",
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"使用兩個堆來維護中位數，左堆為最大堆，右堆為最小堆。\"\"\"\n    def __init__(self):\n        self.left = []   # max-heap (以負值存儲)\n        self.right = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # 先把數字放到左堆（最大堆）\n        heapq.heappush(self.left, -num)\n\n        # 如果左堆頂比右堆頂大，兩堆順序錯亂，調整一下\n        if self.left and self.right and (-self.left[0] > self.right[0]):\n            val = -heapq.heappop(self.left)\n            heapq.heappush(self.right, val)\n\n        # 保持兩堆大小差不超過 1\n        if len(self.left) > len(self.right) + 1:\n            val = -heapq.heappop(self.left)\n            heapq.heappush(self.right, val)\n        elif len(self.right) > len(self.left):\n            val = heapq.heappop(self.right)\n            heapq.heappush(self.left, -val)\n\n    def findMedian(self) -> float:\n        if len(self.left) > len(self.right):\n            return -self.left[0]\n        return (-self.left[0] + self.right[0]) / 2.0\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入包裝成一個 JSON 列表，方便解析\n    data = json.loads('[' + raw + ']')\n    ops, args = data[0], data[1]\n\n    results = []\n    mf = None\n    for op, arg in zip(ops, args):\n        if op == 'MedianFinder':\n            mf = MedianFinder()\n            results.append(None)\n        elif op == 'addNum':\n            mf.addNum(arg[0])\n            results.append(None)\n        elif op == 'findMedian':\n            median = mf.findMedian()\n            results.append(median)\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing the SummaryRanges class. Need to produce step-by-step pseudo-code with explanation after each line. Use arrow syntax. Should handle initialization, addNum, getIntervals. Might need data structure: store intervals list. Steps: check if value in any interval, extend, merge.\n\nWe will produce a high-level algorithm. Since it's virtual code, can mention operations like \"if value already present\". We'll output each line with explanation.\n\nWe must ensure each line ends with // explanation.\n\nLet's craft.\n\nStart → Step 1: 初始化 intervals 為空 list // 初始化空的區間列表\n\n→ Step 2: addNum(value) // 添加數字的流程\n\n→ Decision: 值是否已在區間內? // 判斷 value 是否已存在\n\nYes → Step 3: 返回 // 已存在，無需改變\n\nNo → Step 4: 找到插入位置 i // 確定 value 與現有區間的相對位置\n\n→ Decision: value 與前一個區間接觸? // 判斷是否與前一個區間連接\n\nYes → Step 5: 擴展前一個區間的 end 為 value // 合併前一個區間\n\nElse → Decision: value 與後一個區間接觸? // 判斷是否與後一個區間連接\n\n    Yes → Step 6: 擴展後一個區間的 start 為 value // 合併後一個區間\n\n    No  → Step 7: 插入新區間 [value, value] 在 i 位置 // 新增單一區間\n\n→ Decision: 前後兩區間是否都接觸並可合併? // 判斷是否需要合併兩區間\n\n    Yes → Step 8: 合併前後區間為 [prev_start, next_end] 並刪除中間區間 // 形成大區間\n\n    No  → Step 9: 無需合併，保持已更新區間 // 保持現狀\n\n→ End // addNum 結束\n\n→ Step 10: getIntervals() // 返回目前區間列表\n\n→ Step 11: 返回 intervals 的深拷貝 // 為防止外部修改，返回拷貝\n\n→ End // getIntervals 結束\n\nWe also need class definition. Might add Start at class.\n\nLet's structure:\n\nStart // 程式開始執行\n\n→ Start SummaryRanges // 建立 SummaryRanges 類別\n\n→ Step 1: intervals ← 空列表 // 用來存儲 disjoint intervals\n\n→ End SummaryRanges // 類別初始化完成\n\nThen addNum method.\n\n→ Start addNum(value) // 方法開始\n\n→ Decision: value 已存在於 intervals? // 檢查是否重複\n\nYes → Step 2: return // 直接返回\n\nNo → Step 3: 找到第一個 intervals[i] 使 intervals[i].start > value // 找插入點\n\n→ Decision: i > 0 且 intervals[i-1].end + 1 == value? // 與前區間相鄰\n\n    Yes → Step 4: intervals[i-1].end ← value // 延伸前區間\n\nElse → Decision: i < len(intervals) 且 intervals[i].start - 1 == value? // 與後區間相鄰\n\n    Yes → Step 5: intervals[i].start ← value // 延伸後區間\n\n    No  → Step 6: intervals.insert(i, [value, value]) // 新增新區間\n\n→ Decision: i > 0 且 intervals[i-1].end + 1 >= intervals[i].start? // 前後區間相連\n\n    Yes → Step 7: intervals[i-1].end ← intervals[i].end // 合併為一個\n\n    No  → Step 8: // 無需合併\n\n→ End addNum // 方法結束\n\nSimilarly for getIntervals.\n\nBut the output requires each line with arrow and explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Start SummaryRanges // 建立 SummaryRanges 類別\n→ Step 1: intervals ← [] // 用空列表儲存所有 disjoint interval\n→ End SummaryRanges // 初始化完成\n\n→ Start addNum(value) // addNum 方法開始\n→ Decision: value 已存在於 intervals? // 檢查重複數值\n    Yes → Step 2: return // 已存在，無需更動\n    No  → // 進行插入或合併\n→ Step 3: i ← 找到首個 intervals[i] 使 intervals[i].start > value // 確定插入位置\n→ Decision: i > 0 且 intervals[i-1].end + 1 == value? // 與前一個 interval 相鄰\n    Yes → Step 4: intervals[i-1].end ← value // 延伸前 interval 的結束\n    No  → // 不與前 interval 相鄰\n        → Decision: i < len(intervals) 且 intervals[i].start - 1 == value? // 與後 interval 相鄰\n            Yes → Step 5: intervals[i].start ← value // 延伸後 interval 的開始\n            No  → Step 6: intervals.insert(i, [value, value]) // 插入新的單一 interval\n→ Decision: i > 0 且 intervals[i-1].end + 1 >= intervals[i].start? // 前後 interval 之間有重疊或相鄰\n    Yes → Step 7: intervals[i-1].end ← intervals[i].end // 合併為一個更大的 interval\n    No  → // 前後 interval 已保持 disjoint\n→ End addNum // addNum 方法結束\n\n→ Start getIntervals() // getIntervals 方法開始\n→ Step 8: return copy_of(intervals) // 以拷貝的方式返回目前所有 interval，避免外部修改\n→ End getIntervals // getIntervals 方法結束\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport json\n\nclass SummaryRanges:\n    def __init__(self):\n        # 用於儲存所有 disjoint 的 interval，格式為 [start, end]\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        # 先找到第一個 end < val-1 的區間位置 i，該位置是 val 可能插入或合併的地方\n        i = 0\n        n = len(self.intervals)\n        while i < n and self.intervals[i][1] < val - 1:\n            i += 1\n\n        # 若 val 已經落在已有區間內，直接返回\n        if i < n and self.intervals[i][0] <= val <= self.intervals[i][1]:\n            return\n\n        # 檢查是否可與前後區間相鄰合併\n        left_adjacent = i > 0 and self.intervals[i-1][1] + 1 == val\n        right_adjacent = i < n and self.intervals[i][0] - 1 == val\n\n        if left_adjacent and right_adjacent:\n            # 同時相鄰於前後區間，合併成一個更大的區間\n            self.intervals[i-1][1] = self.intervals[i][1]\n            del self.intervals[i]\n        elif left_adjacent:\n            # 只相鄰於前區間，延伸前區間結束點\n            self.intervals[i-1][1] = max(self.intervals[i-1][1], val)\n        elif right_adjacent:\n            # 只相鄰於後區間，延伸後區間開始點\n            self.intervals[i][0] = val\n        else:\n            # 兩側都不相鄰，插入一個新的單一區間\n            self.intervals.insert(i, [val, val])\n\n    def getIntervals(self):\n        # 直接回傳目前的區間列表\n        return self.intervals\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    commands = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            results.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif cmd == \"getIntervals\":\n            results.append(obj.getIntervals())\n\n    # 使用 json.dumps 會把 None 轉成 null，符合題目輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[null,null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]],null,[[2,2],[1,1],[3,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[null, null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]], null, [[2, 2], [1, 1], [3, 3], [6, 7]]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode717.json",
    "problem_index_in_file": 0,
    "title": "1-bit and 2-bit Characters",
    "description_snippet": "We have two special characters:\\n- The first character can be represented by one bit 0.\\n- The secon...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: given binary array bits ends with 0, return true if last character must be one-bit character. Known LeetCode problem. The algorithm: iterate until second last index. If bits[i]==1 then skip next bit (i+=2). Else i++.\n\nWe need virtual code lines with arrows and decisions. Provide step-by-step.\n\nMake sure to start: Start, then Step 1: initialize index i=0. Then Decision: while i < length-1? because we need stop before last bit. Use Decision: i < len-1? Yes → ... etc. But need structure.\n\nWe need to output each line with virtual code and comment. Use arrows. Use \"Decision:\".\n\nWe'll produce something like:\n\nStart\n→ Step 1: i = 0 // 初始化索引\n→ Decision: i < len(bits) - 1? // 只要還有下一個位元可處理\n    Yes → Decision: bits[i] == 1? // 判斷當前位元\n        Yes → Step 2: i = i + 2 // 一位元符號，跳過兩個位元\n        No  → Step 3: i = i + 1 // 零位元符號，僅跳過一個位元\n    No → End // 迴圈結束，i 已停在最後一個 0 的位置\n→ Decision: i == len(bits) - 1? // 確認指標正好在最後一個 0\n    Yes → Return true // 必然為一位元符號\n    No  → Return false // 不是一位元符號\nEnd\n\nBut need to output each line with \"→\" for steps and decisions. Use indentation maybe.\n\nAlso after each line provide comment after //.\n\nEnsure each line is a separate line.\n\nWe must use the virtual code arrow syntax exactly: \"→\" before each step or decision line, maybe indent within decision. They used example with indentation for sub-branches. We'll mimic.\n\nAlso final Return lines can be Steps.\n\nLet's produce.\n\nAlso use \"Start // 程式開始執行\" etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化索引，從第一個位元開始  \n→ Decision: i < len(bits) - 1? // 只要還有下一個位元可處理  \n    Yes → Decision: bits[i] == 1? // 判斷當前位元是否為 1  \n        Yes → Step 2: i = i + 2 // 一位元符號，跳過兩個位元  \n        No  → Step 3: i = i + 1 // 零位元符號，僅跳過一個位元  \n    No → End // 迴圈結束，i 已停在最後一個 0 的位置  \n→ Decision: i == len(bits) - 1? // 確認指標正好在最後一個 0  \n    Yes → Step 4: Return true // 必然為一位元符號  \n    No  → Step 5: Return false // 不是一位元符號  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isOneBitCharacter(self, bits):\n        \"\"\"\n        Determine whether the last character in the bit array is a one‑bit character.\n        The array always ends with a 0.\n        \"\"\"\n        i = 0\n        n = len(bits)\n        # Iterate until the last bit (which must be 0)\n        while i < n - 1:\n            if bits[i] == 1:\n                # '10' or '11' consumes two bits\n                i += 2\n            else:\n                # '0' consumes one bit\n                i += 1\n        # If we end exactly at the last index, it is a one‑bit character\n        return i == n - 1\n\ndef parse_bits_from_input(s: str):\n    \"\"\"\n    Parse a string of the form 'bits = [1,0,0]' or just '[1,0,0]'\n    and return the corresponding list of integers.\n    \"\"\"\n    # Find the first '[' and the last ']'\n    start = s.find('[')\n    end = s.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        return []  # malformed input\n    content = s[start + 1:end]\n    if not content.strip():\n        return []  # empty list\n    # Split by comma and convert to int\n    return [int(part.strip()) for part in content.split(',')]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Parse the bits list from the input\n    bits = parse_bits_from_input(raw_input)\n    # Instantiate the solution and compute the result\n    result = Solution().isOneBitCharacter(bits)\n    # Output 'true' or 'false' as required\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "bits = [1,0,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "bits = [1,1,1,0]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all unique permutations of a list of numbers that may contain duplicates. Provide virtual code lines with explanations. Use arrows, Start, End, Decision. Must be line-by-line. Not actual code, just pseudocode. Need to handle duplicates: typical backtracking with used flags, skip duplicates when same number as previous and not used.\n\nWe should describe: Start, sort nums to group duplicates. Define result list. Define backtrack function. Steps: for each index, if used skip; if index>0 and nums[i]==nums[i-1] and not used[i-1], skip (to avoid duplicate permutations). Mark used, add to current permutation, recursion, pop, unmark. After recursion, when permutation length equals nums length, add to result.\n\nBut since we only output virtual code lines with explanations, we need to produce steps like:\n\nStart\n→ Sort nums // 排序以便識別重複元素\n→ Initialize result list // 儲存所有唯一排列\n→ Initialize used boolean array // 標記哪些元素已被使用\n→ Define backtrack(currentPermutation) // 回溯函式\n    → Decision: currentPermutation長度 == nums長度? // 完成一個排列\n        Yes → Step: 添加 currentPermutation 的副本到 result // 將完整排列加入結果\n        No  → Step: For i from 0 to nums長度-1 // 嘗試每個元素\n            → Decision: used[i] == true? // 已使用則跳過\n                Yes → Continue // 跳到下一個\n                No  → Decision: i>0 且 nums[i]==nums[i-1] 且 used[i-1]==false? // 避免重複\n                    Yes → Continue // 跳過此重複\n                    No  → Step: used[i] = true // 標記使用\n                        → Step: 添加 nums[i] 到 currentPermutation // 加入排列\n                            → Step: backtrack(currentPermutation) // 递归\n                        → Step: 移除 currentPermutation 中最後一個元素 // 回溯\n                        → Step: used[i] = false // 取消標記\n    End // 回溯結束\n→ 呼叫 backtrack(empty list) // 開始回溯\n→ Return result // 回傳所有唯一排列\nEnd\n\nBut we need arrow and structure: Start, Decision: etc.\n\nWe need to output line by line. Each line: \"虛擬碼步驟 // 解釋\". Must use arrow → before steps. Use Decision lines.\n\nWe also need Start, End lines.\n\nMake sure to indent properly? The sample shows indentation inside decisions. Use the same pattern.\n\nWe should produce each line separate with newline.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: Sort nums ascending // 先排序以方便偵測重複元素\n→ Step: result ← empty list // 用於儲存所有唯一排列\n→ Step: used ← array of false with length nums.length // 標記每個索引是否已被加入當前排列\n→ Decision: 定義 backtrack(currentPermutation) // 開始回溯函式\n    → Step: backtrack(currentPermutation) // 定義內容\n        → Decision: currentPermutation.length == nums.length? // 判斷是否已形成完整排列\n            Yes → Step: Append a copy of currentPermutation to result // 將完整排列加入結果\n            No  → Step: For i from 0 to nums.length-1 // 嘗試每個可能的索引\n                → Decision: used[i] == true? // 該索引已被使用\n                    Yes → Step: Continue // 跳過此索引\n                    No  → Decision: i > 0 AND nums[i] == nums[i-1] AND used[i-1] == false? // 避免重複排列\n                        Yes → Step: Continue // 跳過此重複索引\n                        No  → Step: used[i] ← true // 標記此索引為已使用\n                            → Step: Append nums[i] to currentPermutation // 加入當前元素\n                                → Step: backtrack(currentPermutation) // 進一步深層回溯\n                            → Step: Remove last element from currentPermutation // 回溯：撤銷選擇\n                            → Step: used[i] ← false // 取消標記，供其他分支使用\nEnd // 程式執行結束\n\nBut need to ensure indentation and arrow formatting consistent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Sort nums ascending // 先排序以方便偵測重複元素  \n→ Step: result ← empty list // 用於儲存所有唯一排列  \n→ Step: used ← array of false with length nums.length // 標記每個索引是否已被加入當前排列  \n→ Decision: 定義 backtrack(currentPermutation) // 開始回溯函式  \n    → Step: backtrack(currentPermutation) // 定義內容  \n        → Decision: currentPermutation.length == nums.length? // 判斷是否已形成完整排列  \n            Yes → Step: Append a copy of currentPermutation to result // 將完整排列加入結果  \n            No  → Step: For i from 0 to nums.length-1 // 嘗試每個可能的索引  \n                → Decision: used[i] == true? // 該索引已被使用  \n                    Yes → Step: Continue // 跳過此索引  \n                    No  → Decision: i > 0 AND nums[i] == nums[i-1] AND used[i-1] == false? // 避免重複排列  \n                        Yes → Step: Continue // 跳過此重複索引  \n                        No  → Step: used[i] ← true // 標記此索引為已使用  \n                            → Step: Append nums[i] to currentPermutation // 加入當前元素  \n                                → Step: backtrack(currentPermutation) // 進一步深層回溯  \n                            → Step: Remove last element from currentPermutation // 回溯：撤銷選擇  \n                            → Step: used[i] ← false // 取消標記，供其他分支使用  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permuteUnique(self, nums):\n        \"\"\"\n        Generate all unique permutations of a list that may contain duplicates.\n        \"\"\"\n        res = []\n        nums.sort()  # Sorting helps in skipping duplicates\n        used = [False] * len(nums)\n\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])  # Add a copy of the current permutation\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                # Skip duplicates: if the current number is the same as the previous\n                # one and the previous one hasn't been used in this recursion path,\n                # then using the current one would produce a duplicate permutation.\n                if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                    continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n        backtrack([])\n        return res\n\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Remove any leading variable assignment like \"nums =\"\n    if raw_input.startswith(\"nums\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n\n    # Evaluate the list safely\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # If parsing fails, exit silently\n        sys.exit(0)\n\n    # Compute unique permutations\n    solution = Solution()\n    permutations = solution.permuteUnique(nums)\n\n    # Format output without spaces to match the expected format\n    output = \"[\" + \",\".join(\n        \"[\" + \",\".join(str(x) for x in sublist) + \"]\" for sublist in permutations\n    ) + \"]\"\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1,1,2],[1,2,1],[2,1,1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode719.json",
    "problem_index_in_file": 0,
    "title": "Find K-th Smallest Pair Distance",
    "description_snippet": "The distance of a pair of integers a and b is defined as the absolute difference between a and b.\\nG...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations for algorithm: find kth smallest distance among pairs. Classic problem: use binary search on distance and count pairs <= mid. Steps: sort array, binary search low=0 high=max-min. For each mid count pairs using two pointers. If count>=k then high=mid else low=mid+1. Return low.\n\nWe produce virtual code lines step by step, using Start, End, Decision, etc. Each line: Virtual step then // explanation.\n\nLet's craft lines:\n\nStart\n→ Step 1: Sort nums ascending // prepare for two-pointer counting\n→ Step 2: low = 0 // minimum possible distance\n→ Step 3: high = nums[-1] - nums[0] // maximum possible distance\n→ Decision: while low < high? // binary search loop condition\n    Yes → Step 4: mid = (low + high) // 2 // middle distance guess\n    → Step 5: count = 0 // reset pair counter\n    → Step 6: left = 0 // two-pointer left index\n    → Step 7: for right from 1 to nums.length-1 // iterate right index\n        → Decision: while nums[right] - nums[left] > mid? // shrink window\n            Yes → left = left + 1 // move left pointer\n        → Step 8: count = count + (right - left) // add pairs with current right\n    → Decision: if count >= k? // enough pairs with distance <= mid\n        Yes → high = mid // search lower half\n        No  → low = mid + 1 // search upper half\n→ Decision: low == high? // loop termination condition\n    Yes → Step 9: result = low // kth smallest distance found\nEnd\n\nWe need to output in that format. Let's produce exactly. Ensure each line has arrow. Use \"Yes →\" etc. Use indentation? In example, indentation shown. We'll do similar.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將陣列排序，方便兩指標計算距離  \n→ Step 2: low = 0 // 最小可能距離  \n→ Step 3: high = nums[-1] - nums[0] // 最大可能距離  \n→ Decision: while low < high? // 進行二分搜尋  \n Yes → Step 4: mid = (low + high) // 2 // 計算中間距離猜測值  \n → Step 5: count = 0 // 重新設定計數器  \n → Step 6: left = 0 // 左指標起點  \n → Step 7: for right from 1 to nums.length-1 // 右指標遍歷  \n  → Decision: while nums[right] - nums[left] > mid? // 右左距離大於 mid 時收縮窗口  \n   Yes → left = left + 1 // 左指標右移  \n  → Step 8: count = count + (right - left) // 將以 right 為右端點的所有符合距離的對數加入計數  \n → Decision: if count >= k? // 判斷已計算的符合條件對數是否足夠  \n  Yes → high = mid // 若足夠，將搜尋範圍縮至左半邊  \n  No  → low = mid + 1 // 若不足，將搜尋範圍縮至右半邊  \n→ Decision: low == high? // 循環結束條件  \n Yes → Step 9: result = low // 二分搜尋結束，low 為第 k 小距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def smallestDistancePair(self, nums, k):\n        nums.sort()\n\n        def count_pairs(mid):\n            count = 0\n            left = 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count_pairs(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    lines = data.splitlines()\n    nums = []\n    k = None\n\n    if len(lines) == 1:\n        # Single line like \"nums = [1,3,1], k = 1\"\n        all_ints = list(map(int, re.findall(r'-?\\d+', lines[0])))\n        if len(all_ints) >= 2:\n            k = all_ints[-1]\n            nums = all_ints[:-1]\n    else:\n        # First line contains the array, second line contains k\n        nums = list(map(int, re.findall(r'-?\\d+', lines[0])))\n        if len(lines) > 1:\n            k = int(re.findall(r'-?\\d+', lines[1])[-1])\n        else:\n            k = 0\n\n    if k is None or not nums:\n        print(0)\n    else:\n        sol = Solution()\n        result = sol.smallestDistancePair(nums, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: minimum number of arrows to burst balloons represented by intervals on x-axis. Classic problem: minimum number of arrows to burst balloons equals number of non-overlapping intervals after sorting by end. Use greedy: sort by x_end ascending. Count arrows. For each interval, if current arrow position x_end of previous arrow < interval start, need new arrow; else continue.\n\nWe must output line-by-line pseudocode with explanation. Use arrow format. We'll produce steps: Start, Step 1: Sort points by x_end, Step 2: Initialize arrowCount=0, currentEnd = -inf, iterate intervals, etc.\n\nLet's produce. Use \"→\" for lines. Include decision steps. Provide comments.\n\nEnsure no actual code. Provide virtual code only.\n\nWe need to output only the pseudocode lines with explanation after space.\n\nOk. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort the array points by x_end ascending // 將所有氣球按右邊界遞增排序，方便後續贈送  \n→ Step 2: Set arrowCount = 0 // 初始化已發射的箭數  \n→ Step 3: Set currentEnd = -∞ // 記錄上一次射出的箭擊中的右邊界  \n→ Decision: 是否還有未處理的氣球? // 判斷是否完成所有氣球  \n    Yes → Step 4: 取出下一個氣球的區間 [x_start, x_end] // 逐個檢視氣球  \n    → Decision: 是否 x_start > currentEnd? // 檢查此氣球是否與上一箭無重疊  \n        Yes → Step 5: arrowCount += 1 // 需要新箭射擊  \n        → Step 6: currentEnd = x_end // 將新箭的擊中點設為此氣球的右邊界  \n        No  → Step 7: // 此氣球被上一次箭擊中，無需新增箭，直接跳過  \n    → Go back to Decision: 是否還有未處理的氣球?  \n→ End // 所有氣球均已被擊中，程式執行結束  \n→ Return arrowCount // 回傳最小箭數。",
      "generated_code": "import sys\nimport ast\n\ndef find_min_arrow_shots(points):\n    if not points:\n        return 0\n    # Sort intervals by their ending coordinate\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    current_end = points[0][1]\n    # Greedily place arrows\n    for start, end in points[1:]:\n        if start > current_end:\n            arrows += 1\n            current_end = end\n    return arrows\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the list part of the input\n    start_idx = data.find('[')\n    if start_idx == -1:\n        points = []\n    else:\n        points = ast.literal_eval(data[start_idx:])\n    result = find_min_arrow_shots(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code line by line, with arrow etc. Problem: max profit with at most two transactions. Classic DP: keep track of profits: first buy1, sell1, buy2, sell2. We can use variables: l1, l2, r1, r2. But pseudo code: Iterate array once.\n\nPseudo steps:\n\nStart\n→ Step 1: Initialize variables:\n    - leftBuy = Infinity\n    - leftSell = 0\n    - rightBuy = Infinity\n    - rightSell = 0\n// Initialize trackers for first and second transaction\n\n→ Step 2: Iterate i from 0 to n-1:\n    // process forward pass for first transaction\n    leftBuy = min(leftBuy, prices[i])\n    leftSell = max(leftSell, prices[i] - leftBuy)\n    // process backward pass for second transaction\n    rightBuy = min(rightBuy, prices[n-1-i])\n    rightSell = max(rightSell, prices[n-1-i] - rightBuy)\n// but better separate loops. We'll produce two loops.\n\nAlternatively:\n\n→ Step 2: Forward pass: For each price:\n    minPrice1 = min(minPrice1, price)\n    profit1 = max(profit1, price - minPrice1)\n\n→ Step 3: Backward pass: For each price from end:\n    minPrice2 = min(minPrice2, price)\n    profit2 = max(profit2, price - minPrice2)\n\n→ Step 4: Result = profit1 + profit2\nEnd\n\nBut we need two transactions possibly overlapping? Actually we cannot hold simultaneously but the two profits are independent because we can sell before buy again. We can also compute DP with array of 4 states.\n\nSimpler: use DP states: dp[t][k] for max profit with t transactions processed, k holding state. But pseudo: easier to show loops.\n\nLet's produce pseudo with forward and backward loops.\n\nSteps:\n\nStart // program start\n\n→ Step 1: Let n = length of prices // number of days\n\n→ Step 2: // forward pass to compute max profit up to each day for 1 transaction\n    → Initialize minPrice1 = Infinity\n    → Initialize profit1 = 0\n    → For i from 0 to n-1:\n        → minPrice1 = min(minPrice1, prices[i]) // track lowest price so far\n        → profit1 = max(profit1, prices[i] - minPrice1) // max profit ending at day i\n// After loop profit1 holds best profit for 1 transaction\n\n→ Step 3: // backward pass to compute max profit from each day to end for 1 transaction\n    → Initialize minPrice2 = Infinity\n    → Initialize profit2 = 0\n    → For i from n-1 downto 0:\n        → minPrice2 = min(minPrice2, prices[i]) // track lowest price from right\n        → profit2 = max(profit2, prices[i] - minPrice2) // max profit starting at day i\n// After loop profit2 holds best profit for 1 transaction on suffix\n\n→ Step 4: Result = profit1 + profit2 // at most two transactions\n\nEnd\n\nBut we might double count if the two transactions overlap? Actually profit1 is best profit using first transaction before day i, profit2 uses last transaction after day i. But the algorithm above might produce sum of two profits each computed separately not guaranteeing disjoint. Wait typical solution: compute leftProfits[i] and rightProfits[i] arrays, then max over split. But our simple approach of separate forward and backward loops yields overall max of two independent transactions (but might double count overlapping?). Actually compute forward and backward separately but each is independent; if we sum them, they may overlap. But the classic approach: compute max profit for 1 transaction on prefix and suffix and combine. However the simple DP with states will handle. Let's use DP approach to be safe.\n\nDP approach:\n\nState 1: hold first buy: hold1 = -∞; sell1 = 0; hold2 = -∞; sell2 = 0\n\nFor each price p:\n    hold1 = max(hold1, -p) // max profit holding first stock\n    sell1 = max(sell1, hold1 + p) // profit after first sell\n    hold2 = max(hold2, sell1 - p) // buy second after first sold\n    sell2 = max(sell2, hold2 + p) // final profit after second sell\n\nResult = sell2\n\nThis ensures at most two transactions, no overlap.\n\nLet's produce pseudo lines for that.\n\nYes that is clearer.\n\nSo produce:\n\nStart\n→ Step 1: Initialize variables:\n    → hold1 = -Infinity\n    → sell1 = 0\n    → hold2 = -Infinity\n    → sell2 = 0\n// Set initial state for two transactions\n\n→ Step 2: For each price p in prices:\n    → hold1 = max(hold1, -p) // max profit after buying first stock\n    → sell1 = max(sell1, hold1 + p) // profit after selling first stock\n    → hold2 = max(hold2, sell1 - p) // max profit after buying second stock\n    → sell2 = max(sell2, hold2 + p) // profit after selling second stock\n// Update states for each day\n\n→ Step 3: Result = sell2 // maximum profit with at most two transactions\n\nEnd\n\nBut we need step-by-step each line, with arrow and explanation after //.\n\nAlso we might want to show the loop syntax.\n\nLet's produce with arrow for each step.\n\nWe need to obey format: each line: virtual code step + space + // explanation. Use arrow →, Start, End. Use Decision? not needed.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化變數 hold1 = -∞, sell1 = 0, hold2 = -∞, sell2 = 0\n// 用於追蹤兩筆交易的買進與賣出狀態\n\n→ Step 2: For 每個價格 p 在 prices 中\n// 逐日處理價格，更新四個狀態\n\n→ Sub-step: hold1 = max(hold1, -p) // 若以今天價格買入第一筆，取得最大持有利潤\n→ Sub-step: sell1 = max(sell1, hold1 + p) // 若以今天價格賣出第一筆，取得最大已完成利潤\n→ Sub-step: hold2 = max(hold2, sell1 - p) // 若以今天價格買入第二筆，取得最大持有利潤（已完成第一筆）\n→ Sub-step: sell2 = max(sell2, hold2 + p) // 若以今天價格賣出第二筆，取得最大已完成利潤\n\n→ Step 3: Result = sell2 // 兩筆交易的最大總利潤\n// sell2 代表已完成最多兩筆交易的最終利潤\n\nEnd // 程式執行結束\n\nBut need to maintain formatting: each line start with arrow or Start etc. Sub-step lines also use arrow but not \"Sub-step:\"? But we can keep arrow. Use \"→\" for each step, but we need indentation? Not required but can show.\n\nBetter to show:\n\nStart // 程式開始執行\n→ Step 1: hold1 = -∞; sell1 = 0; hold2 = -∞; sell2 = 0 // 初始化交易狀態\n→ For price in prices: // 逐日迭代\n    → hold1 = max(hold1, -price) // 以今天價格買入第一筆的最大利潤\n    → sell1 = max(sell1, hold1 + price) // 以今天價格賣出第一筆的最大利潤\n    → hold2 = max(hold2, sell1 - price) // 以今天價格買入第二筆的最大利潤\n    → sell2 = max(sell2, hold2 + price) // 以今天價格賣出第二筆的最大利潤\n→ Result = sell2 // 兩筆交易的最終最大利潤\nEnd // 程式執行結束\n\nBut must maintain format: each line must have \"虛擬碼步驟\" + space + \"// 解釋/說明\". So lines with arrow should have that. For nested lines, we still have \"→\" at start. Let's produce like:\n\nStart // 程式開始執行\n→ Step 1: hold1 = -∞; sell1 = 0; hold2 = -∞; sell2 = 0 // 初始化四個交易狀態\n→ Step 2: For price in prices: // 逐日迭代\n    → hold1 = max(hold1, -price) // 若今天買入第一筆，更新持有利潤\n    → sell1 = max(sell1, hold1 + price) // 若今天賣出第一筆，更新已完成利潤\n    → hold2 = max(hold2, sell1 - price) // 若今天買入第二筆，更新持有利潤\n    → sell2 = max(sell2, hold2 + price) // 若今天賣出第二筆，更新已完成利潤\n→ Step 3: Result = sell2 // 最大總利潤即為 sell2\nEnd // 程式執行結束\n\nCheck: each line uses arrow for steps inside loop too. Indentation: we might not need indentation, but it's okay to show.\n\nThe requirement: \"逐行輸出\" meaning each line separate. So each step line is separate. For loop body, each line separate. So we have:\n\nStart // ...\n→ Step 1: hold1 = -∞; sell1 = 0; hold2 = -∞; sell2 = 0 // ...\n→ Step 2: For price in prices: // ...\n→ hold1 = max(hold1, -price) // ...\n→ sell1 = max(sell1, hold1 + price) // ...\n→ hold2 = max(hold2, sell1 - price) // ...\n→ sell2 = max(sell2, hold2 + price) // ...\n→ Step 3: Result = sell2 // ...\nEnd // ...\n\nYes, each line separate. But we used \"Step 2:\" and \"Step 3:\" etc. The \"For price in prices:\" line is also a step. But we can keep arrow for it.\n\nBut we might want to use \"Decision:\"? Not necessary.\n\nMake sure to follow arrow for each line. Use \"→\" or \"Start\", \"End\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: hold1 = -∞; sell1 = 0; hold2 = -∞; sell2 = 0 // 初始化四個交易狀態（第一次買、第一次賣、第二次買、第二次賣）\n→ Step 2: For price in prices: // 逐日迭代價格\n→ hold1 = max(hold1, -price) // 若今天以 price 購買第一筆，更新持有利潤\n→ sell1 = max(sell1, hold1 + price) // 若今天以 price 賣出第一筆，更新已完成利潤\n→ hold2 = max(hold2, sell1 - price) // 若今天以 price 購買第二筆，更新持有利潤（已完成第一筆）\n→ sell2 = max(sell2, hold2 + price) // 若今天以 price 賣出第二筆，更新已完成利潤\n→ Step 3: Result = sell2 // 兩筆交易的最大總利潤即為 sell2\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef max_profit(prices):\n    if not prices:\n        return 0\n    buy1 = float('-inf')\n    sell1 = 0\n    buy2 = float('-inf')\n    sell2 = 0\n    for price in prices:\n        buy1 = max(buy1, -price)\n        sell1 = max(sell1, buy1 + price)\n        buy2 = max(buy2, sell1 - price)\n        sell2 = max(sell2, buy2 + price)\n    return sell2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list of integers from the input string\n    match = re.search(r'\\[(.*?)\\]', data)\n    if match:\n        prices = [int(x.strip()) for x in match.group(1).split(',') if x.strip()]\n    else:\n        prices = []\n    result = max_profit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line with explanation. Problem: Insert interval into sorted non-overlapping intervals, merging as necessary.\n\nWe need steps: Start, maybe variable definitions: result array, iterate intervals, three phases: before new interval, overlap, after.\n\nWe'll produce pseudocode using decision branches. Ensure arrow notation.\n\nLet's produce lines:\n\nStart // Begin algorithm\n→ Initialize result array // empty list to store merged intervals\n→ Initialize i = 0 // index for traversal\n→ Decision: While i < len(intervals) and intervals[i].end < newInterval.start? // intervals before new\n    Yes → Append intervals[i] to result // add non-overlapping before\n    i = i + 1\n→ Decision: While i < len(intervals) and intervals[i].start <= newInterval.end? // overlapping\n    Yes → Update newInterval.start = min(newInterval.start, intervals[i].start)\n         Update newInterval.end = max(newInterval.end, intervals[i].end)\n         i = i + 1\n→ Append newInterval to result // add merged interval\n→ Decision: While i < len(intervals)?\n    Yes → Append intervals[i] to result // remaining after\n    i = i + 1\nEnd // return result\n\nBut need arrow style lines with comments. Use Yes→, No→? In our steps we use loops as decision. Use Decision with conditions, inside Yes branch do actions. Since loops need iteration, maybe treat as while decisions.\n\nWe should produce each step as a line. Provide explanation after comment.\n\nLet's craft:\n\nStart // 程式開始\n→ Initialize result = [] // 儲存最終區間\n→ Initialize i = 0 // 迭代索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前面不重疊的區間\n    i = i + 1\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊段\n        Yes → // 合併區間\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n        No → // no more overlapping, go to append newInterval\n→ Append newInterval to result // 加入合併後的新區間\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後面不重疊的區間\n    i = i + 1\n    No → End // 完成\n\nBut we need sequential lines. Maybe better to split loops explicitly. Provide loops as Decision: while.\n\nLet's produce more formal:\n\nStart // 程式開始\n→ result = [] // 初始化結果列表\n→ i = 0 // 迭代指標\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段區間\n    i = i + 1\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊段\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n        No → // 無重疊，直接後續\n→ Append newInterval to result // 加入合併後區間\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段\n    i = i + 1\n    No → End // 結束\n\nBut we need proper loop over while. Provide repeated decision until condition false.\n\nLet's produce final pseudocode lines:\n\nStart // 程式開始\n→ result = [] // 儲存合併後的區間\n→ i = 0 // 初始化索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 處理前段不重疊區間\n    Yes → Append intervals[i] to result // 將前段區間加入結果\n    i = i + 1\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 處理重疊區間\n        Yes → // 合併區間\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n        No → // 無重疊，跳至後段\n→ Append newInterval to result // 加入合併後的新區間\n→ Decision: i < len(intervals)? // 處理後段不重疊區間\n    Yes → Append intervals[i] to result // 加入後段區間\n    i = i + 1\n    No → End // 程式結束\n\nBut this doesn't fully loop over all intervals before merging and after merging. Should be while loops. Provide iterative steps.\n\nLet's produce with while decisions:\n\nStart // 程式開始\n→ result = [] // 儲存結果\n→ i = 0 // 索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: (same condition again) // 迴圈\n            Yes → ...\n            No → ...\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: (same overlap condition again) // 迴圈\n                Yes → ...\n                No → ...\n        No → // 跳至後段\n→ Append newInterval to result // 加入合併後\n→ Decision: i < len(intervals)? // 後段\n    Yes → Append intervals[i] to result // 加入\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → ...\n            No → ...\n    No → End\n\nBut the output format expects each line as separate; we can include loops as nested Decision: Yes→.\n\nSimplify: Provide pseudocode with loops:\n\nStart // 程式開始\n→ result = [] // 儲存結果\n→ i = 0 // 索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → … (repeat) ...\n            No → … // exit loop\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → … repeat …\n                No → … exit\n        No → // no overlap\n→ Append newInterval to result // 合併後加入\n→ Decision: i < len(intervals)? // 後段\n    Yes → Append intervals[i] to result // 加入\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → … repeat …\n            No → …\n    No → End\n\nThis is too many lines. The requirement: \"逐行\" but we can condense loops into steps like \"While\". They didn't forbid using While but they want arrow notation. Could use \"While i < len(intervals) and intervals[i].end < newInterval.start:\" but they want Decision.\n\nMaybe simpler: use 5 steps: Append non-overlap before, merge overlapping, append new, append remaining. But need loops inside each.\n\nLet's produce concise pseudocode:\n\nStart // 程式開始\n→ result = [] // 初始化結果\n→ i = 0 // 索引\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → ... (repeat) ...\n            No → … // exit\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → … repeat\n                No → … exit\n        No → … // no overlap\n→ Append newInterval to result // 合併後加入\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → … repeat …\n            No → … exit\n    No → End // 結束\n\nThis is verbose.\n\nMaybe acceptable but the format requires each line as \"虛擬碼步驟 [space] // 解釋\". We can have nested indent by indenting spaces? But spec not mention indent. Might just list each line sequentially.\n\nSimpler approach: Use explicit loop constructs like \"While\" as virtual steps. That is still a decision but we can label as \"While\".\n\nMaybe we can use:\n\n→ While i < len(intervals) and intervals[i].end < newInterval.start:\n    Append intervals[i] to result\n    i = i + 1\n\nBut the spec uses arrow and Decision. Might accept while loops as lines. Provide:\n\nStart // 程式開始\n→ result = [] // 儲存結果\n→ i = 0 // 索引\n→ While i < len(intervals) and intervals[i].end < newInterval.start: // 前段不重疊\n    Append intervals[i] to result\n    i = i + 1\n→ While i < len(intervals) and intervals[i].start <= newInterval.end: // 重疊段\n    newInterval.start = min(newInterval.start, intervals[i].start)\n    newInterval.end = max(newInterval.end, intervals[i].end)\n    i = i + 1\n→ Append newInterval to result // 合併後加入\n→ While i < len(intervals): // 後段不重疊\n    Append intervals[i] to result\n    i = i + 1\nEnd // 完成\n\nBut spec: use Decision with Yes→ No→. Maybe this still accepted because we use while. But they emphasise arrow, but we can use while as step. Might be okay.\n\nLet's craft final answer with each line as:\n\nStart // 程式開始\n→ result = [] // 初始化結果區間\n→ i = 0 // 設定索引為 0\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 將前段加入結果\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → … repeat …\n            No → … exit …\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊段\n        Yes → // 合併區間\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → … repeat …\n                No → … exit …\n        No → … // no overlap\n→ Append newInterval to result // 將合併後的新區間加入結果\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段區間\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → … repeat …\n            No → … exit …\n    No → End // 完成\n\nBut too many ellipses. Might not be acceptable. Let's produce concise final pseudocode with loops as while.\n\nI'll produce:\n\nStart // 程式開始\n→ result = [] // 儲存最終區間\n→ i = 0 // 設定迭代指標\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 前段不重疊\n    Yes → Append intervals[i] to result // 加入前段\n        i = i + 1\n        → Decision: i < len(intervals) and intervals[i].end < newInterval.start? // 迴圈\n            Yes → ... repeat\n            No → ...\n    No → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 重疊\n        Yes → // 合併\n            newInterval.start = min(newInterval.start, intervals[i].start)\n            newInterval.end = max(newInterval.end, intervals[i].end)\n            i = i + 1\n            → Decision: i < len(intervals) and intervals[i].start <= newInterval.end? // 迴圈\n                Yes → ... repeat\n                No → ...\n        No → ...\n→ Append newInterval to result // 加入合併後區間\n→ Decision: i < len(intervals)? // 後段不重疊\n    Yes → Append intervals[i] to result // 加入後段\n        i = i + 1\n        → Decision: i < len(intervals)? // 迴圈\n            Yes → ... repeat\n            No → ...\n    No → End\n\nBut maybe the expected answer is simpler.\n\nLet's produce final answer using while loops but with clear explanations.\n\nWe'll output each line exactly as spec: \"虛擬碼步驟 [space] // 解釋\".\n\nLet's write:\n\nStart // 程式開始\n→ result = [] // 初始化結果區間列表\n→ i = 0 // 設定索引為 0\n→ While i < len(intervals) and intervals[i].end < newInterval.start: // 處理前段不重疊區間\n    Append intervals[i] to result // 加入前段區間\n    i = i + 1\n→ While i < len(intervals) and intervals[i].start <= newInterval.end: // 處理重疊區間\n    newInterval.start = min(newInterval.start, intervals[i].start) // 合併起始點\n    newInterval.end = max(newInterval.end, intervals[i].end) // 合併結束點\n    i = i + 1\n→ Append newInterval to result // 加入合併後的新區間\n→ While i < len(intervals): // 處理後段不重疊區間\n    Append intervals[i] to result // 加入後段區間\n    i = i + 1\nEnd // 程式結束\n\nBut we need arrow '→' before each line, except maybe Start and End? They didn't specify, but earlier example used 'Start' and 'End' as separate lines. So we can keep them same.\n\nWe need to put '→' before 'While' lines, and 'Append' lines etc. The 'While' line ends with colon in some pseudocode, but we can keep.\n\nWe need each line separate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ result = [] // 初始化結果區間列表\n→ i = 0 // 設定索引為 0\n→ While i < len(intervals) and intervals[i].end < newInterval.start: // 處理前段不重疊區間\n    Append intervals[i] to result // 加入前段區間\n    i = i + 1\n→ While i < len(intervals) and intervals[i].start <= newInterval.end: // 處理重疊區間\n    newInterval.start = min(newInterval.start, intervals[i].start) // 合併起始點\n    newInterval.end = max(newInterval.end, intervals[i].end) // 合併結束點\n    i = i + 1\n→ Append newInterval to result // 加入合併後的新區間\n→ While i < len(intervals): // 處理後段不重疊區間\n    Append intervals[i] to result // 加入後段區間\n    i = i + 1\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a list of sorted, non-overlapping intervals,\n        merging where necessary.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Append all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged new interval\n        result.append(newInterval)\n\n        # Append the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract the two lists from the input string\n    m_intervals = re.search(r'intervals\\s*=\\s*(\\[.*\\])', data)\n    m_new      = re.search(r'newInterval\\s*=\\s*(\\[.*\\])', data)\n\n    if not m_intervals or not m_new:\n        return\n\n    intervals  = eval(m_intervals.group(1))\n    newInterval = eval(m_new.group(1))\n\n    sol = Solution()\n    result = sol.insert(intervals, newInterval)\n\n    # Print result in JSON-like format (no spaces)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdgowe0eg.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpdgowe0eg.py\", line 48, in main\n    intervals  = eval(m_intervals.group(1))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,3],[6,9]], newInterval = [2,5]\n                               ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpz02quhd8.py\", line 58, in <module>\n    main()\n  File \"/tmp/tmpz02quhd8.py\", line 48, in main\n    intervals  = eval(m_intervals.group(1))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n                                                    ^\nSyntaxError: invalid syntax"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode592.json",
    "problem_index_in_file": 0,
    "title": "Fraction Addition and Subtraction",
    "description_snippet": "Given a string expression representing an expression of fraction addition and subtraction, return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for evaluating a string expression with fraction addition/subtraction, returning irreducible fraction string, converting integer to /1. No actual code, just virtual steps. Each line with \"虛擬碼步驟\" and comment.\n\nWe need to use arrows etc. Provide logic: parse expression, handle plus minus, evaluate fractions, maintain numerator/denominator, compute GCD, reduce, format string. Also need to consider negative signs. Possibly handle parentheses? Not specified. Only addition/subtraction. So expression like \"1/3-1/2+1/6\". So parse tokens separated by + or -. We'll treat the first token sign + by default.\n\nWe need to produce pseudocode with Start, End, Decision nodes. Provide steps: Tokenize, iterate tokens, parse fraction string, convert to numerator and denominator. Keep running sum as rational. At end, reduce by GCD. Format output.\n\nWe need to produce line-by-line with arrow arrow. Use \"→\" to show flow.\n\nLet's craft pseudocode:\n\nStart\n→ Step 1: Initialize result numerator = 0, result denominator = 1 // start with zero\n→ Step 2: Normalize expression by adding '+' before first token if missing // to simplify parsing\n→ Step 3: Split expression into list of tokens using '+' and '-' as delimiters, keeping signs // parse tokens with sign\n→ Step 4: For each token in tokens:\n    → Decision: token starts with '-'\n        No  → Set sign = +1\n        Yes → Set sign = -1\n    → Step 5: Remove leading sign from token to get fraction part // e.g., '1/2'\n    → Step 6: Split fraction part by '/' into num_str and den_str\n    → Step 7: Convert num_str, den_str to integers num, den\n    → Step 8: Multiply num by sign // apply sign to numerator\n    → Step 9: Update result numerator = result_num * den + num * result_den\n    → Step 10: Update result denominator = result_den * den\n    → Step 11: Reduce result fraction by GCD of numerator and denominator\n→ Step 12: After loop, ensure denominator positive // if negative, multiply both by -1\n→ Step 13: Convert final numerator and denominator to string format \"num/den\"\nEnd\n\nAlso need to handle zero result -> 0/1.\n\nInclude decisions for sign.\n\nWe need each line as separate line: \"Start // ...\"\n\nWe need indentation for decisions? The format example shows indentation with spaces before sub-lines. We can mimic: Use indentation spaces before sub-lines.\n\nWe'll produce the pseudocode lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化結果分子 result_num = 0, 分母 result_den = 1 // 先設定總和為 0/1\n→ Step 2: 若 expression 第一個字符不是 '+' 或 '-'，則在前面加上 '+' 以統一處理 // 方便後續帶符號拆分\n→ Step 3: 使用正則表達式或遍歷，將 expression 拆成 token 列表，保持 '+' 或 '-' 作為每個 token 的首字符 // 例如 \"+1/3-1/2+1/6\" -> [\"+1/3\",\"-1/2\",\"+1/6\"]\n→ Step 4: 依序處理 token 列表\n    → Decision: token 是否以 '-' 開頭?\n        No  → Step 5a: 設置 sign = +1 // 正號\n        Yes → Step 5b: 設置 sign = -1 // 負號\n    → Step 6: 去除 token 首字符，得到 fraction_str // 例如 \"1/3\"\n    → Step 7: 把 fraction_str 用 '/' 分割成 num_str, den_str // 取得分子、分母字串\n    → Step 8: 將 num_str, den_str 轉為整數 num, den // 解析為數值\n    → Step 9: 把符號應用於分子: num = num * sign\n    → Step 10: 更新總和\n        result_num = result_num * den + num * result_den // 分子更新\n        result_den = result_den * den // 分母更新\n    → Step 11: 计算 current_gcd = GCD( |result_num|, result_den ) // 取得最大公因数\n    → Step 12: 将 result_num, result_den 除以 current_gcd // 约简分数\n→ Step 13: 若 result_den < 0，則將 result_num, result_den 乘以 -1 // 保证分母为正\n→ Step 14: 若 result_num == 0，則將 result_den 設為 1 // 0 必为 0/1\n→ Step 15: 生成輸出字串 output = result_num + \"/\" + result_den // 合成字符串格式\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom fractions import Fraction\n\ndef fraction_addition(expression: str) -> str:\n    \"\"\"計算分數加減表達式，並回傳最簡分數字串。\"\"\"\n    # 取得所有形如 +1/2、-3/4 或 5/6 的子字串\n    tokens = re.findall(r'[+-]?\\d+/\\d+', expression)\n    # 使用 fractions.Fraction 進行計算，內部自動約簡\n    result = sum(Fraction(tok) for tok in tokens)\n    return f\"{result.numerator}/{result.denominator}\"\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，支援多行或單行\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n\n    # 先嘗試尋找「expression = '...'」的格式\n    match = re.search(r'expression\\s*=\\s*[\"\\']([^\"\\']*)[\"\\']', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # 若找不到，則假設整行就是表達式\n        expr = data.strip()\n\n    print(fraction_addition(expr))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"-1/2+1/2\"",
          "expected_output": "0/1",
          "success": true,
          "output": "0/1"
        },
        {
          "example_index": 1,
          "input": "expression = \"-1/2+1/2+1/3\"",
          "expected_output": "1/3",
          "success": true,
          "output": "1/3"
        },
        {
          "example_index": 2,
          "input": "expression = \"1/3-1/2\"",
          "expected_output": "-1/6",
          "success": true,
          "output": "-1/6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode624.json",
    "problem_index_in_file": 0,
    "title": "Maximum Distance in Arrays",
    "description_snippet": "You are given m arrays, where each array is sorted in ascending order.\nYou can pick up two integers ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code. The requirement: \"You are given m arrays, where each array is sorted in ascending order. You can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a - b|. Return the maximum distance.\"\n\nWe need to generate pseudocode step by step, each line with \"→\" or \"Start\" etc, and after each line a comment // explanation.\n\nWe need to handle algorithm: find maximum absolute difference between any two elements from different arrays. Since arrays sorted ascending, maximum difference is either between max of one array and min of another. So algorithm: compute global minimum among all arrays (from the first element of each sorted array) and global maximum (last element). Then maximum distance = max - min, but need to ensure they come from different arrays. If arrays can have same min and max from same array? But we need different arrays. If min and max come from same array, then need next min or max from other arrays. Simpler: For each pair of arrays, compute abs(max of one - min of another). But we can just compute min value of each array and max value. Then maximum distance is max of max_i - min_j for i≠j. So we can take global max among all arrays and global min among all arrays, but if they are from same array, we need second min or second max. Approach: For each array, track min_i, max_i. Then overall minVal, minArrayIdx; overall maxVal, maxArrayIdx. If they are from different arrays, answer = maxVal - minVal. If same array, then consider second min among all arrays and second max. So compute second global min among other arrays (not same idx) and second global max similarly. Then answer = max( maxVal - secondMin, secondMax - minVal ). Implementation steps.\n\nWe will produce pseudocode accordingly. Provide steps: Start, read arrays, compute min and max per array, find global min/max and indices, decision whether same array, compute second min/max if needed, compute result, output.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 m 個已升序排列的陣列 // 收集所有輸入陣列  \n→ Step 2: 初始化 minVal = +∞, minIdx = -1, maxVal = -∞, maxIdx = -1 // 用於儲存全域最小值與最大值及其陣列索引  \n→ Step 3: 建立兩個空列表 secondMins, secondMaxs 用於存第二小值和第二大值  \n→ Step 4: For each array i in 0..m-1 // 遍歷每個陣列  \n    → SubStep: currentMin = arr[i][0] // 第一個元素即最小值  \n    → SubStep: currentMax = arr[i][arr[i].size-1] // 最後一個元素即最大值  \n    → Decision: 如果 currentMin < minVal? // 更新全域最小值  \n      Yes → minVal = currentMin, minIdx = i  \n      No → No change  \n    → Decision: 如果 currentMax > maxVal? // 更新全域最大值  \n      Yes → maxVal = currentMax, maxIdx = i  \n      No → No change  \n    → SubStep: 把 currentMin 加入 secondMins，currentMax 加入 secondMaxs // 收集所有最小值和最大值供後續比較  \n→ End For // 完成所有陣列的掃描  \n→ Step 5: 排序 secondMins 並去重，取第一個不等於 minVal 的值作為 secondMin；若不存在則設 secondMin = minVal  \n→ Step 6: 排序 secondMaxs 並去重，取第一個不等於 maxVal 的值作為 secondMax；若不存在則設 secondMax = maxVal  \n→ Decision: 如果 minIdx ≠ maxIdx? // 全域最小值與最大值來自不同陣列  \n    Yes → Step 7: result = maxVal - minVal // 直接計算最大距離  \n    No → Step 8: result = max( maxVal - secondMin, secondMax - minVal ) // 取兩種跨陣列的最大差值  \n→ Step 9: 輸出 result // 回傳最遠距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def maxDistance(self, arrays):\n        # 初始化全域最小值和最大值為第一個陣列的端點\n        min_val = arrays[0][0]\n        max_val = arrays[0][-1]\n        res = 0\n\n        # 從第二個陣列開始遍歷\n        for arr in arrays[1:]:\n            # 比較目前陣列最大值與全域最小值、以及全域最大值與目前陣列最小值的差距\n            res = max(res, abs(arr[-1] - min_val), abs(max_val - arr[0]))\n            # 更新全域最小值與最大值\n            min_val = min(min_val, arr[0])\n            max_val = max(max_val, arr[-1])\n\n        return res\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析輸入字串，支持以下兩種格式：\n    1. 直接給出陣列列表，例如 [[1,2,3],[4,5]]\n    2. 變數指派，例如 arrays = [[1,2,3],[4,5]]\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n    if raw.lower().startswith(\"arrays\"):\n        # 去除變數名稱與等號\n        _, _, expr = raw.partition(\"=\")\n        raw = expr.strip()\n    # 安全地解析列表字串\n    return eval(raw, {\"__builtins__\": None}, {})\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    arrays = parse_input(data)\n    if not arrays:\n        print(0)\n    else:\n        sol = Solution()\n        print(sol.maxDistance(arrays))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arrays = [[1,2,3],[4,5],[1,2,3]]",
          "expected_output": " 4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": " arrays = [[1],[1]]",
          "expected_output": " 0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with comments. The user gave problem description: check if parentheses string is valid. We should produce a virtual code algorithm: Use stack. Steps: Start, input string s, iterate each char, if open push, if close check top, etc. Provide explanation. Use the required format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows and Decision structures.\n\nNeed to include the Start, End, etc. Use indent for decisions. Use \"Yes →\" and \"No →\".\n\nLet's produce. Ensure each line is separate. Use \"→\" for steps, \"Decision:\" for conditions. Use \"Start // 程式開始執行\" etc.\n\nWe must not output actual code, only virtual steps. Provide short explanation.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者或檔案取得要驗證的字串  \n→ Step 2: 初始化空堆疊 stack // 用來存放未配對的開括號  \n→ Step 3: 針對字串 s 的每一個字元 c 做迭代 // 開始逐字符檢查  \n  Decision: c 為 '(' 或 '[' 或 '{'? // 判斷是否為開括號  \n   Yes → Step 4: 將 c 推入 stack // 將開括號記錄於堆疊  \n   No → Decision: c 為 ')' 或 ']' 或 '}'? // 判斷是否為關括號  \n    Yes → Step 5: 若 stack 為空? // 沒有對應的開括號  \n     Yes → End: 回傳 False // 無法配對，輸入無效  \n     No → Step 6: 從 stack 彈出 top // 取得最近的開括號  \n     Decision: top 與 c 是否為相同型別? // 比對括號類型  \n      Yes → Step 7: 繼續迭代 // 配對成功，繼續檢查後續字元  \n      No → End: 回傳 False // 類型不符，輸入無效  \n    No → End: 回傳 False // 不是有效的括號字元，輸入無效  \n→ Step 8: 迭代結束後，判斷 stack 是否為空? // 所有開括號是否已配對  \n  Decision: stack 為空?  \n   Yes → End: 回傳 True // 所有括號均已正確配對  \n   No → End: 回傳 False // 有未配對的開括號  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        \"\"\"\n        使用堆疊來判斷括號是否有效。\n        - 遍歷每個字元。\n        - 若是開括號，推入堆疊。\n        - 若是閉括號，檢查堆疊頂端是否為對應的開括號。\n          若不符或堆疊為空，立即回傳 False。\n        - 遍歷結束後，若堆疊為空則回傳 True，否則 False。\n        \"\"\"\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n        for char in s:\n            if char in mapping:  # 可能是閉括號\n                top = stack.pop() if stack else None\n                if mapping[char] != top:\n                    return False\n            elif char in '({[':  # 開括號\n                stack.append(char)\n            else:\n                # 忽略非括號字元（若有）\n                pass\n        return not stack\n\ndef main():\n    \"\"\"\n    主程式入口：從標準輸入讀取資料，解析出需要驗證的字串，\n    再呼叫 Solution.isValid 判斷結果並輸出 'true' 或 'false'。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 嘗試從輸入中提取第一組單引號或雙引號內的字串\n    match = re.search(r'[\"\\']([^\"\\']*)[\"\\']', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data  # 直接使用整個輸入\n\n    solution = Solution()\n    result = solution.isValid(s)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code for computing number of primes less than n. Use simple algorithm: Sieve of Eratosthenes. Steps: Start, input n, if n <=2 -> output 0. Else create boolean array of size n initialized true. Mark 0,1 as false. For i from 2 to sqrt(n-1): if prime[i] true, mark multiples. Count primes. Output count. End. Provide virtual code with arrows and comments. Need to be line by line. Use `Start`, `End`, `Decision:`, `→ Step ...`. Use spaces accordingly. Also maybe use `→ Decision: if n <= 2?`. Use `Yes → Step ...`, `No →`. Provide explanation after each line. Provide only virtual code. Ensure formatting as specified. Use Chinese explanations. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者處取得上限值  \n→ Decision: n 是否小於等於 2? // 若 n 小於等於 2 則不存在小於 n 的素數  \n  Yes → Step 2: 輸出 0 // 直接回傳 0  \n  No  → Step 3: 建立布林陣列 isPrime[0..n-1] 全部設為 true // 用於標記素數  \n→ Step 4: isPrime[0] ← false // 0 不是素數  \n→ Step 5: isPrime[1] ← false // 1 不是素數  \n→ Step 6: 計算 limit ← ⌊√(n-1)⌋ // 只需要檢查到 sqrt(n-1)  \n→ Step 7: 迴圈 i 從 2 到 limit  \n  → Decision: isPrime[i] 是否為 true? // 若 i 本身是素數  \n    Yes → Step 8: 迴圈 j 從 i*i 到 n-1 步進 i  \n      → isPrime[j] ← false // 將 i 的倍數標記為非素數  \n      End // 結束 j 迴圈  \n    No  → 直接跳過 // i 不是素數，無需標記倍數  \n→ Step 9: 計算 count ← 0 // 素數個數  \n→ Step 10: 迴圈 k 從 2 到 n-1  \n  → Decision: isPrime[k] 是否為 true? // 判斷 k 是否為素數  \n    Yes → count ← count + 1 // 累加素數個數  \n    No  → 跳過 // k 不是素數  \n→ Step 11: 輸出 count // 回傳小於 n 的素數總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_primes(n: int) -> int:\n    \"\"\"Return the number of prime numbers strictly less than n.\"\"\"\n    if n <= 2:\n        return 0\n\n    # is_prime[i] == True 表示 i 可能是素數\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        if is_prime[i]:\n            # 把 i 的所有倍數標記為非素數\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    # 只計算 2 ~ n-1 的素數個數\n    return sum(is_prime)\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有文字，並尋找第一個整數作為 n\n    data = sys.stdin.read()\n    numbers = re.findall(r\"-?\\d+\", data)\n    n = int(numbers[0]) if numbers else 0\n    print(count_primes(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for nth ugly number. Use DP approach. We'll output step by step. Provide explanation after each line. Use Start, Decision, End. Ensure each line has code plus comment. Use arrow \"→\". Let's craft:\n\nStart\n→ Step 1: initialize i2, i3, i5 to 1 // index pointers\n→ Step 2: initialize ugly[1] to 1 // first ugly number\n→ Step 3: loop k from 2 to n // generate ugly numbers\n→ Decision: compute next2 = ugly[i2] * 2, next3 = ugly[i3] * 3, next5 = ugly[i5] * 5 // candidates\n    → Step 4: next = min(next2, next3, next5) // choose smallest\n    → Step 5: ugly[k] = next\n    → Decision: if next == next2? // update pointers\n        Yes → i2 = i2 + 1\n    → Decision: if next == next3?\n        Yes → i3 = i3 + 1\n    → Decision: if next == next5?\n        Yes → i5 = i5 + 1\nEnd // Return ugly[n]\n\nNeed to keep each line separate. We need to embed decision branching lines after each step. Use \"Decision:\" with Yes → or No →.\n\nLet's structure:\n\nStart\n→ Step 1: i2 = 1 // pointer for factor 2\n→ Step 2: i3 = 1 // pointer for factor 3\n→ Step 3: i5 = 1 // pointer for factor 5\n→ Step 4: ugly[1] = 1 // first ugly number\n→ Step 5: for k from 2 to n // generate remaining ugly numbers\n    → Step 6: next2 = ugly[i2] * 2 // candidate from factor 2\n    → Step 7: next3 = ugly[i3] * 3 // candidate from factor 3\n    → Step 8: next5 = ugly[i5] * 5 // candidate from factor 5\n    → Step 9: next = min(next2, next3, next5) // choose smallest candidate\n    → Step 10: ugly[k] = next // store kth ugly number\n    → Decision: next == next2? // update pointer i2 if used\n        Yes → i2 = i2 + 1\n    → Decision: next == next3? // update pointer i3 if used\n        Yes → i3 = i3 + 1\n    → Decision: next == next5? // update pointer i5 if used\n        Yes → i5 = i5 + 1\nEnd // 返回 ugly[n]\n\nNeed to keep each line as separate. Ensure arrow syntax. We also need to include \"→\" after each line except maybe the first line. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i2 = 1 // 指標 i2 從 1 開始，對應 2 的倍數  \n→ Step 2: i3 = 1 // 指標 i3 從 1 開始，對應 3 的倍數  \n→ Step 3: i5 = 1 // 指標 i5 從 1 開始，對應 5 的倍數  \n→ Step 4: ugly[1] = 1 // 第一個丑數固定為 1  \n→ Step 5: for k from 2 to n // 依序產生第二到第 n 個丑數  \n → Step 6: next2 = ugly[i2] * 2 // 從指標 i2 取得候選值 2 的倍數  \n → Step 7: next3 = ugly[i3] * 3 // 從指標 i3 取得候選值 3 的倍數  \n → Step 8: next5 = ugly[i5] * 5 // 從指標 i5 取得候選值 5 的倍數  \n → Step 9: next = min(next2, next3, next5) // 選取最小的候選值作為第 k 個丑數  \n → Step 10: ugly[k] = next // 存入結果陣列  \n → Decision: next == next2? // 判斷是否使用了 2 的倍數  \n  Yes → i2 = i2 + 1 // 若使用，將指標 i2 前進  \n → Decision: next == next3? // 判斷是否使用了 3 的倍數  \n  Yes → i3 = i3 + 1 // 若使用，將指標 i3 前進  \n → Decision: next == next5? // 判斷是否使用了 5 的倍數  \n  Yes → i5 = i5 + 1 // 若使用，將指標 i5 前進  \nEnd // 程式執行結束，返回 ugly[n] 為第 n 個丑數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        ugly = [1]\n        i2 = i3 = i5 = 0\n        while len(ugly) < n:\n            next2, next3, next5 = ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5\n            next_ugly = min(next2, next3, next5)\n            ugly.append(next_ugly)\n            if next_ugly == next2:\n                i2 += 1\n            if next_ugly == next3:\n                i3 += 1\n            if next_ugly == next5:\n                i5 += 1\n        return ugly[-1]\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    solution = Solution()\n    print(solution.nthUglyNumber(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: remove duplicate letters, smallest lexicographical order. Classic Leetcode 316. Approach: count remaining occurrences, stack, visited set. Pseudocode line by line with explanations. Use structure Start, End, Decision. Ensure each line with 虛擬碼步驟 followed by // explanation. Use arrows. Provide step lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化字母出現次數字典 count[26] ← 0 // 記錄每個字母在字串中剩餘的出現次數\n→ Step 2: 初始化結果棧 stack ← 空棧 // 用來構建最終字串\n→ Step 3: 初始化已加入集合 visited ← 空集合 // 防止重複加入字母\n→ Step 4: 遍歷字串 s 中每個字母 ch // 循環處理每個字符\n    → Decision: 減少 count[ch] ← count[ch] - 1 // 將此字母的剩餘次數減 1\n    → Decision: 如果 ch 已經在 visited? // 檢查此字母是否已經加入結果\n        Yes → Continue // 如果已在結果，直接跳過此字符\n        No  → Decision: 迴圈: 當 stack 不是空且 stack.top() > ch 且 count[stack.top()] > 0? // 需要移除比 ch 大且後面還有可用的字母\n            Yes → Step 5: popTop ← stack.pop() // 移除堆疊頂部字母\n            → Step 6: visited.remove(popTop) // 從已加入集合移除\n            → Go to 迴圈起點 // 重新評估堆疊頂部是否仍需移除\n            No  → Step 7: stack.push(ch) // 把 ch 放入堆疊\n            → Step 8: visited.add(ch) // 標記 ch 已加入\n→ Step 9: 將 stack 中的字母依序組成字串 result ← ''.join(stack) // 生成最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def removeDuplicateLetters(self, s: str) -> str:\n        # Count remaining occurrences of each character\n        count = {c: 0 for c in s}\n        for ch in s:\n            count[ch] += 1\n\n        stack = []          # 用來構建最終字串的棧\n        visited = set()     # 已經加入棧中的字母集合\n\n        for ch in s:\n            # 此字符已經處理完一次，剩餘次數減 1\n            count[ch] -= 1\n\n            # 如果已經加入過，跳過\n            if ch in visited:\n                continue\n\n            # 移除比 ch 大且後面還會再次出現的字母\n            while stack and stack[-1] > ch and count[stack[-1]] > 0:\n                removed = stack.pop()\n                visited.remove(removed)\n\n            # 把 ch 加入棧\n            stack.append(ch)\n            visited.add(ch)\n\n        return ''.join(stack)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出雙引號內的字串，如果沒有雙引號則使用整個輸入\n    if '\"' in data:\n        first = data.find('\"')\n        last = data.rfind('\"')\n        s = data[first + 1:last]\n    else:\n        s = data\n\n    result = Solution().removeDuplicateLetters(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for AllOne data structure, with O(1) operations. Classic design uses doubly linked list of buckets (count nodes) with keys sets, and hashmap from key to node.\n\nWe'll produce steps:\n\nStart\n→ Step 1: 定義 Node: count, keySet, prev, next\n→ Step 2: AllOne init: create dummy head and tail, empty hashmap\n→ inc(key): if key exists get node; else create new node with count=1\n   Remove key from current node's keySet; if keySet empty remove node\n   Find or create node for count+1 (next bucket). If next node count != count+1 then insert new node between current and next\n   Add key to node\n   Update keyMap[key] = node\n   Return\n→ dec(key): similar but decrement, remove if 0\n→ getMaxKey(): if head.next is tail return \"\", else return any key from tail.prev.keySet\n→ getMinKey(): if head.next is tail return \"\", else return any key from head.next.keySet\n\nNeed to output step-by-step with arrow and explanation.\n\nWe need each line to contain virtual code step and comment. We must maintain structure: Start, End, Decision. We may use sub steps.\n\nWe need to produce a list of steps.\n\nLet's craft.\n\nStart // 程式開始\n\n→ Step 1: 定義 Node 類別，含 count, keySet, prev, next // 定義桶結構\n\n→ Step 2: AllOne 初始函式 // 建立空資料結構\n\n    → Step 2.1: head ← 新 Node(count=0) // 虛擬頭節點\n    → Step 2.2: tail ← 新 Node(count=0) // 虛擬尾節點\n    → Step 2.3: head.next ← tail\n    → Step 2.4: tail.prev ← head\n    → Step 2.5: keyMap ← 空字典 // key → Node\n\n→ Step 3: inc(key) // 增加 key 的計數\n\n    → Decision: key 是否存在於 keyMap?\n        Yes → Step 3.1: node ← keyMap[key] // 取得目前桶\n            → Step 3.1.1: node.keySet.remove(key) // 從原桶移除\n            → Decision: node.keySet 是否為空？\n                Yes → Step 3.1.2: node.prev.next ← node.next\n                       Step 3.1.3: node.next.prev ← node.prev\n                       // 刪除空桶\n                No  → // 保持原桶\n        No  → Step 3.2: node ← head.next // 可能的 1 倍桶\n            → Decision: node.count != 1?\n                Yes → Step 3.2.1: 新建 newNode(count=1)\n                        Step 3.2.2: 新建 newNode.keySet ← {key}\n                        Step 3.2.3: 插入 newNode 在 head 和 head.next 之間\n                        Step 3.2.4: keyMap[key] ← newNode\n                        → Return\n                No  → Step 3.2.4: node.keySet.add(key)\n                      keyMap[key] ← node\n                      → Return\n\n    // 若 key 已存在，處理下一桶\n    → Step 3.3: targetCount ← node.count + 1\n    → Step 3.4: nextNode ← node.next\n    → Decision: nextNode.count != targetCount ?\n        Yes → Step 3.4.1: 新建 newNode(count=targetCount)\n                Step 3.4.2: newNode.keySet ← {key}\n                Step 3.4.3: 插入 newNode 在 node 與 nextNode 之間\n                Step 3.4.4: keyMap[key] ← newNode\n        No  → Step 3.4.1: nextNode.keySet.add(key)\n              keyMap[key] ← nextNode\n\n→ Step 4: dec(key) // 減少 key 的計數\n\n    → Step 4.1: node ← keyMap[key]\n    → Step 4.2: node.keySet.remove(key)\n    → Decision: node.keySet 是否為空？\n        Yes → Step 4.2.1: node.prev.next ← node.next\n               Step 4.2.2: node.next.prev ← node.prev\n        No  → // 保持桶\n\n    → Decision: node.count == 1 ?\n        Yes → Step 4.3: 移除 keyMap[key] // key count 0, 刪除\n        No  → Step 4.4: targetCount ← node.count - 1\n               prevNode ← node.prev\n               Decision: prevNode.count != targetCount ?\n                   Yes → Step 4.4.1: 新建 newNode(count=targetCount)\n                          Step 4.4.2: newNode.keySet ← {key}\n                          Step 4.4.3: 插入 newNode 在 prevNode 與 node 之間\n                          Step 4.4.4: keyMap[key] ← newNode\n                   No  → Step 4.4.1: prevNode.keySet.add(key)\n                         keyMap[key] ← prevNode\n\n→ Step 5: getMaxKey() // 取得最大計數的 key\n\n    → Decision: head.next == tail ?\n        Yes → Step 5.1: return \"\" // 無元素\n        No  → Step 5.2: return 任意一個 head.next.prev.keySet 的元素 // 取得最大\n\n→ Step 6: getMinKey() // 取得最小計數的 key\n\n    → Decision: head.next == tail ?\n        Yes → Step 6.1: return \"\" // 無元素\n        No  → Step 6.2: return 任意一個 head.next.keySet 的元素 // 取得最小\n\nEnd // 程式結束\n\nBut we need to ensure each line includes a code step and comment, with arrow. Also substeps lines maybe indent but still each line.\n\nWe need to ensure the structure uses \"Start\", \"End\", \"Decision:\".\n\nAlso \"→\" arrow before steps. Use consistent format.\n\nLet's produce final output accordingly. Use proper indentation to reflect nested steps but still each line separate. Use Chinese comments.\n\nWe need to avoid using actual code; use virtual code.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義 Node 類別，含 count、keySet、prev、next // 建立桶節點結構  \n→ Step 2: AllOne 初始化函式 // 建立資料結構  \n → Step 2.1: head ← 新 Node(count=0) // 虛擬頭節點  \n → Step 2.2: tail ← 新 Node(count=0) // 虛擬尾節點  \n → Step 2.3: head.next ← tail  \n → Step 2.4: tail.prev ← head  \n → Step 2.5: keyMap ← 空字典 // key → Node 映射  \n\n→ Step 3: inc(key) // 增加 key 的計數  \n → Decision: key 是否存在於 keyMap?  \n  Yes → Step 3.1: node ← keyMap[key] // 取得目前桶  \n   → Step 3.1.1: node.keySet.remove(key) // 從原桶移除  \n   → Decision: node.keySet 是否為空？  \n    Yes → Step 3.1.2: node.prev.next ← node.next  \n     → Step 3.1.3: node.next.prev ← node.prev // 刪除空桶  \n    No → // 保持原桶  \n  No → Step 3.2: node ← head.next // 可能的 1 倍桶  \n   → Decision: node.count != 1?  \n    Yes → Step 3.2.1: 新建 newNode(count=1)  \n     → Step 3.2.2: newNode.keySet ← {key}  \n     → Step 3.2.3: 插入 newNode 在 head 與 head.next 之間  \n     → Step 3.2.4: keyMap[key] ← newNode // 新增 key  \n     → Return  \n    No → Step 3.2.4: node.keySet.add(key)  \n     → keyMap[key] ← node  \n     → Return  \n  // 若 key 已存在，處理下一桶  \n → Step 3.3: targetCount ← node.count + 1  \n → Step 3.4: nextNode ← node.next  \n → Decision: nextNode.count != targetCount?  \n  Yes → Step 3.4.1: 新建 newNode(count=targetCount)  \n   → Step 3.4.2: newNode.keySet ← {key}  \n   → Step 3.4.3: 插入 newNode 在 node 與 nextNode 之間  \n   → Step 3.4.4: keyMap[key] ← newNode  \n  No → Step 3.4.1: nextNode.keySet.add(key)  \n   → keyMap[key] ← nextNode  \n\n→ Step 4: dec(key) // 減少 key 的計數  \n → Step 4.1: node ← keyMap[key]  \n → Step 4.2: node.keySet.remove(key)  \n → Decision: node.keySet 是否為空？  \n  Yes → Step 4.2.1: node.prev.next ← node.next  \n    → Step 4.2.2: node.next.prev ← node.prev // 刪除空桶  \n  No → // 保持桶  \n → Decision: node.count == 1?  \n  Yes → Step 4.3: 移除 keyMap[key] // key count 0，刪除  \n  No → Step 4.4: targetCount ← node.count - 1  \n   → prevNode ← node.prev  \n   → Decision: prevNode.count != targetCount?  \n    Yes → Step 4.4.1: 新建 newNode(count=targetCount)  \n     → Step 4.4.2: newNode.keySet ← {key}  \n     → Step 4.4.3: 插入 newNode 在 prevNode 與 node 之間  \n     → Step 4.4.4: keyMap[key] ← newNode  \n    No → Step 4.4.1: prevNode.keySet.add(key)  \n     → keyMap[key] ← prevNode  \n\n→ Step 5: getMaxKey() // 取得最大計數的 key  \n → Decision: head.next == tail?  \n  Yes → Step 5.1: return \"\" // 無元素  \n  No  → Step 5.2: return 任意一個 head.next.prev.keySet 的元素 // 取得最大  \n\n→ Step 6: getMinKey() // 取得最小計數的 key  \n → Decision: head.next == tail?  \n  Yes → Step 6.1: return \"\" // 無元素  \n  No  → Step 6.2: return 任意一個 head.next.keySet 的元素 // 取得最小  \n\nEnd // 程式結束",
      "generated_code": "import sys\nimport json\n\nclass Node:\n    def __init__(self, count=0):\n        self.count = count\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()  # dummy head\n        self.tail = Node()  # dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node(count)\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_count = node.count + 1\n            if node.next == self.tail or node.next.count > next_count:\n                new_node = self._insert_after(node, next_count)\n            else:\n                new_node = node.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                new_node = self._insert_after(self.head, 1)\n            else:\n                new_node = self.head.next\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n\n    def dec(self, key):\n        node = self.key_to_node[key]\n        node.keys.remove(key)\n        prev_count = node.count - 1\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < prev_count:\n                new_node = self._insert_after(node.prev, prev_count)\n            else:\n                new_node = node.prev\n            new_node.keys.add(key)\n            self.key_to_node[key] = new_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    # Remove any empty lines\n    data = [line.strip() for line in data if line.strip()]\n    # Skip a leading \"Input\" line if present\n    if data and data[0].lower() == \"input\":\n        data = data[1:]\n    if len(data) < 2:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"AllOne\":\n            obj = AllOne()\n            outputs.append(None)\n        elif op == \"inc\":\n            obj.inc(arg[0])\n            outputs.append(None)\n        elif op == \"dec\":\n            obj.dec(arg[0])\n            outputs.append(None)\n        elif op == \"getMaxKey\":\n            outputs.append(obj.getMaxKey())\n        elif op == \"getMinKey\":\n            outputs.append(obj.getMinKey())\n    print(\"Output\")\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for reversing string in-place with O(1) memory. Use Start, End, Decision, arrows. Provide step-by-step pseudocode, with each line having \"虛擬碼步驟\" then space then \"// 解釋\". Use arrows →, Yes →, No →. For reversing, we can do two-pointer swap. So steps: Start, Set left=0, right=length-1, while left<right, swap s[left] and s[right], left++, right--, End. Provide decision for while condition. Include comments. Provide in Traditional Chinese. Each line \"虛擬碼步驟\" + space + comment. Use \"Step\" maybe \"Step 1\". Use arrow \"→\". For decision, \"Decision: 左指標 < 右指標?\" then \"Yes → ...\", \"No → End\". Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = s.length - 1 // 初始化左右指標  \n→ Decision: 左指標 < 右指標? // 檢查是否還需要交換  \n    Yes → Step 2: 暫存 temp = s[left] // 暫存左邊字元  \n    Yes → Step 3: s[left] = s[right] // 把右邊字元放到左邊  \n    Yes → Step 4: s[right] = temp // 把左邊字元放到右邊  \n    Yes → Step 5: left = left + 1 // 左指標右移  \n    Yes → Step 6: right = right - 1 // 右指標左移  \n    Yes → Decision: 左指標 < 右指標? // 重新判斷是否繼續迴圈  \n    No → End // 左右指標相遇或交叉，結束反轉  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def reverseString(self, s):\n        \"\"\"\n        In-place reverse of the character list s using two‑pointer technique.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            # 交換左右兩端的字元\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取字元列表。\n    期望格式類似:  s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        raise ValueError(\"輸入格式錯誤，找不到 '[' 或 ']'\")\n    list_str = data[start:end+1]\n    # 使用 ast.literal_eval 以避免 eval 的安全問題\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    try:\n        s = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    # 執行反轉\n    Solution().reverseString(s)\n\n    # 輸出為符合範例的 JSON 格式（無空格）\n    print(json.dumps(s, separators=(\",\", \":\")))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations for algorithm to compute minimum bit flips between start and goal. We need step by step. Probably algorithm: compute XOR of start and goal, then count set bits. Explanation: bit flips required equals number of differing bits. So we produce pseudocode lines: Start, compute xor, count bits, output count, End. Use decision? Might include loop for counting bits. Use binary representation. Provide minimal steps. Should use arrow lines. Use \"→\" to indicate next step. Use \"Decision:\" where needed. Provide short explanation. Provide each line: virtual code step + space + // explanation. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算差異位元 = start XOR goal // 取得兩數不同位元的位元組  \n→ Step 2: 設定 flipCount = 0 // 初始化需要翻轉的位元數  \n→ Decision: 差異位元是否為 0? // 判斷是否已相等，無需翻轉  \n    Yes → Step 3: 輸出 flipCount // 若相等，直接輸出 0  \n    No  → Loop  \n        → Step 4: 若差異位元最低位為 1? // 檢查最低位是否不同  \n            Yes → Step 5: flipCount = flipCount + 1 // 這一位需要翻轉  \n        → Step 6: 差異位元 = 差異位元 >> 1 // 右移一位，準備檢查下一位  \n        → Step 7: 重複 Loop，直到差異位元為 0  \n→ Step 8: 輸出 flipCount // 輸出最終計算出的翻轉數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        \"\"\"Return the minimum number of bit flips needed to transform start into goal.\"\"\"\n        xor = start ^ goal          # XOR gives bits that differ\n        flips = 0\n        while xor:                  # Count set bits in xor\n            flips += xor & 1\n            xor >>= 1\n        return flips\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Find all integers in the input (handles negative numbers as well)\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(numbers) < 2:\n        raise ValueError(\"Input must contain two integers: start and goal.\")\n    start, goal = numbers[0], numbers[1]\n    result = Solution().minBitFlips(start, goal)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, line by line, with comments after space. The pseudocode should solve the problem: rearrange string so that adjacent characters are not same. Classic algorithm: use max heap of character counts, pick top two, append, decrement, push back if count>0. If only one char left, check if its count is 1; else impossible.\n\nWe produce virtual code lines, using arrows, Decision, etc. Provide explanation comments. Use Start, End. Use '→' arrow. Use Decision blocks with Yes and No lines.\n\nWe need to not output real code. Use pseudocode syntax: Start, Step 1: Build frequency map, Step 2: Build max heap, etc.\n\nAlso we need to be careful with format: each line `虛擬碼步驟` + space + `// 解釋/說明`.\n\nOk. Let's craft.\n\nWe need to handle input string s. Steps:\n\n1. Start\n2. Step 1: Initialize frequency map\n3. Step 2: Build max heap of (count, char)\n4. Step 3: Initialize result string\n5. Step 4: While heap has more than 1 element:\n   - Decision: heap size >1?\n     Yes → Step 4a: Pop top two chars\n     Step 4b: Append first char to result\n     Step 4c: Append second char to result\n     Step 4d: Decrement counts\n     Step 4e: Push back if counts remain\n     No → Decision: heap size ==1?\n        Yes → Step 4f: Check remaining char count\n          Decision: count ==1?\n             Yes → Step 4g: Append remaining char to result\n             No → Step 4h: Return \"\" // impossible\n        No → (nothing, loop ends)\n6. Step 5: Return result\n\nEdge: also if input empty return \"\"? But we can just return \"\".\n\nWe must use arrows appropriately.\n\nLet's write with lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty frequency map freq // 建立字元頻率表\n→ Step 2: For each character c in s: freq[c]++ // 計算每個字元出現次數\n→ Step 3: Initialize empty max-heap heap // 用於取出最高頻率字元\n→ Step 4: For each (char, count) in freq: push (count, char) to heap // 將頻率放進堆疊\n→ Step 5: Initialize empty string result // 用於儲存重新排列後的字串\n→ Decision: heap size > 1? // 判斷堆中是否有兩個以上字元\n    Yes → Step 6: Pop (count1, char1) from heap // 取出最高頻率字元\n    → Step 7: Pop (count2, char2) from heap // 取出第二高頻率字元\n    → Step 8: Append char1 to result // 將第一個字元加入結果\n    → Step 9: Append char2 to result // 將第二個字元加入結果\n    → Step 10: Decrement count1, count2 by 1 // 各字元使用一次\n    → Step 11: If count1 > 0: push (count1, char1) back to heap // 若仍有剩餘，重新加入堆\n    → Step 12: If count2 > 0: push (count2, char2) back to heap // 同上\n    → Step 13: Continue // 重新進入 Decision 判斷\n    No  → Decision: heap size == 1? // 只剩一個字元時的判斷\n        Yes → Step 14: Pop (count, char) from heap // 取出唯一剩餘字元\n        → Decision: count == 1? // 該字元僅剩一次可合法插入\n            Yes → Step 15: Append char to result // 加入最後一個字元\n            No  → Step 16: Return \"\" // 不能排列，回傳空字串\n        No  → // 堆為空，結束迴圈\n\n→ Step 17: Return result // 回傳重新排列後的字串\nEnd // 程式執行結束\n\nBut we need to follow strict format: each line \"虛擬碼步驟\" + space + \"// 解釋\".\n\nAlso must use arrows properly: For Decision, indent lines.\n\nWe should use \"Decision: ...?\".\n\nLet's craft final answer with proper indentation. Use arrow \"→\" for each step inside Decision. Use Yes → and No → inside nested Decision.\n\nMake sure each line has a comment after a space. Let's produce.\n\nAlso note we should include line numbers? Not necessary.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize empty frequency map freq // 建立字元頻率表\n→ Step 2: For each character c in s: freq[c]++ // 計算每個字元出現次數\n→ Step 3: Initialize empty max-heap heap // 用於取出最高頻率字元\n→ Step 4: For each (char, count) in freq: push (count, char) to heap // 將頻率放進堆疊\n→ Step 5: Initialize empty string result // 用於儲存重新排列後的字串\n→ Decision: heap size > 1? // 判斷堆中是否有兩個以上字元\n    Yes → Step 6: Pop (count1, char1) from heap // 取出最高頻率字元\n    → Step 7: Pop (count2, char2) from heap // 取出第二高頻率字元\n    → Step 8: Append char1 to result // 將第一個字元加入結果\n    → Step 9: Append char2 to result // 將第二個字元加入結果\n    → Step 10: Decrement count1, count2 by 1 // 各字元使用一次\n    → Step 11: If count1 > 0: push (count1, char1) back to heap // 若仍有剩餘，重新加入堆\n    → Step 12: If count2 > 0: push (count2, char2) back to heap // 同上\n    → Step 13: Continue // 重新進入 Decision 判斷\n    No  → Decision: heap size == 1? // 只剩一個字元時的判斷\n        Yes → Step 14: Pop (count, char) from heap // 取出唯一剩餘字元\n        → Decision: count == 1? // 該字元僅剩一次可合法插入\n            Yes → Step 15: Append char to result // 加入最後一個字元\n            No  → Step 16: Return \"\" // 不能排列，回傳空字串\n        No  → // 堆為空，結束迴圈\n→ Step 17: Return result // 回傳重新排列後的字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nfrom collections import Counter\nimport re\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        # Count frequency of each character\n        count = Counter(s)\n        # Build a max-heap using negative frequencies\n        max_heap = [(-freq, ch) for ch, freq in count.items()]\n        heapq.heapify(max_heap)\n\n        prev_freq, prev_char = 0, ''  # Previous character to avoid adjacency\n        result = []\n\n        while max_heap:\n            freq, ch = heapq.heappop(max_heap)\n            result.append(ch)\n\n            # If there was a previous character with remaining count, push it back\n            if prev_freq < 0:\n                heapq.heappush(max_heap, (prev_freq, prev_char))\n\n            # Update previous character info (decrement frequency)\n            prev_freq, prev_char = freq + 1, ch  # freq is negative, +1 moves toward 0\n\n        # If we used all characters successfully, return the string\n        reorganized = ''.join(result)\n        return reorganized if len(reorganized) == len(s) else \"\"\n\nif __name__ == \"__main__\":\n    # Read entire input (could be just the string or include assignment syntax)\n    raw_input = sys.stdin.read().strip()\n\n    # Extract the string value if input contains quotes\n    match = re.search(r'[\"\\'](.*?)[\"\\']', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        s = raw_input\n\n    solution = Solution()\n    print(solution.reorganizeString(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "aba"
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for the algorithm of bursting balloons to maximize coins. This is classic DP problem: maximize coins by bursting balloons. Use DP over subarrays, with added 1 boundaries. We can do DP[i][j] max coins from bursting balloons in (i, j) exclusive of boundaries, where nums extended to include 1 at ends. Recurrence: DP[i][j] = max over k from i+1 to j-1: DP[i][k] + DP[k][j] + nums[i]*nums[k]*nums[j]. Complexity O(n^3). The algorithm steps: preprocess array with 1 boundaries; initialize DP table; iterate length; compute DP; return DP[0][n+1]. Virtual code lines accordingly. Provide explanation after each line.\n\nWe must output line by line: \"Start // 程式開始執行\" etc. Use arrows.\n\nWe need to produce code in virtual pseudo with arrows. Provide step names. Use \"→\" arrow lines. Also include Decision sections for loops.\n\nWe can design:\n\nStart\n→ Step 1: Create array A = [1] + nums + [1] // extend with 1 boundaries\n→ Step 2: n = length of A // total size\n→ Step 3: Initialize DP table of size n x n with 0 // DP[i][j] max coins from i+1..j-1\n→ Step 4: For len from 2 to n-1 // subarray length\n    → Decision: if len > n-1? No // continue\n        → For i from 0 to n - len -1 // start index\n            → j = i + len // end index\n            → MaxCoins = 0 // temporary max\n            → For k from i+1 to j-1 // last balloon to burst\n                → Coins = DP[i][k] + DP[k][j] + A[i]*A[k]*A[j] // compute coins\n                → Decision: if Coins > MaxCoins? Yes → MaxCoins = Coins // update\n            → DP[i][j] = MaxCoins // store result\n→ Step 5: Return DP[0][n-1] // maximum coins\n\nWe need to ensure arrow formatting. Provide Explanation after each line.\n\nLet's format as:\n\nStart // 程式開始執行\n→ Step 1: A ← [1] + nums + [1] // 建立包含兩端 1 的新陣列\n→ Step 2: n ← length(A) // 取得新陣列長度\n→ Step 3: DP ← n×n matrix initialized to 0 // DP[i][j] 儲存子問題答案\n→ Step 4: for len from 2 to n-1 // 依子陣列長度遞增\n    → Decision: 是否 len <= n-1? Yes → for i from 0 to n-len-1\n        → j ← i + len // 子陣列右端索引\n        → MaxCoins ← 0 // 初始化本子陣列最佳值\n        → for k from i+1 to j-1 // 選擇最後被砸掉的氣球\n            → Coins ← DP[i][k] + DP[k][j] + A[i]*A[k]*A[j] // 計算此方案\n            → Decision: Coins > MaxCoins? Yes → MaxCoins ← Coins // 更新最佳\n        → DP[i][j] ← MaxCoins // 存回 DP\n→ Step 5: Return DP[0][n-1] // 回傳整體最大硬幣數\n\nWe need to make each line with \"→\" arrow. Use indent? Possibly use spaces to indicate hierarchy.\n\nMake sure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: A ← [1] + nums + [1] // 建立包含兩端 1 的新陣列，方便邊界處理  \n→ Step 2: n ← length(A) // 取得新陣列長度  \n→ Step 3: DP ← n×n matrix initialized to 0 // DP[i][j] 儲存從 i+1 到 j-1 的氣球全部被砸時可獲得的最大硬幣數  \n→ Step 4: for len from 2 to n-1 // 依子陣列長度遞增  \n  → Decision: len <= n-1? Yes → for i from 0 to n-len-1 // 開始索引  \n    → j ← i + len // 子陣列右端索引  \n    → MaxCoins ← 0 // 初始化本子陣列最佳值  \n    → for k from i+1 to j-1 // 選擇最後被砸掉的氣球  \n      → Coins ← DP[i][k] + DP[k][j] + A[i]*A[k]*A[j] // 計算此方案可獲得硬幣數  \n      → Decision: Coins > MaxCoins? Yes → MaxCoins ← Coins // 更新最佳  \n    → DP[i][j] ← MaxCoins // 存回 DP  \n→ Step 5: Return DP[0][n-1] // 回傳整體最大硬幣數  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                for i in range(left + 1, right):\n                    dp[left][right] = max(\n                        dp[left][right],\n                        nums[left] * nums[i] * nums[right] + dp[left][i] + dp[i][right]\n                    )\n        return dp[0][n - 1]\n\n\nif __name__ == \"__main__\":\n    import sys\n    import re\n\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    result = Solution().maxCoins(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each with explanation, per spec. We must not output real code. Provide steps: Start, input numerator and denominator, handle zero denominator, compute sign, use absolute values, integer part division, remainder, if remainder zero output integer part, else build decimal part with map of remainder to position, loop division, detect repeat, build result string, output. Use Start, End. Use Decision lines. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow. Use \"Yes →\" \"No →\". Let's craft.\n\nRemember to keep each line separate, no blank lines? It says each line must contain virtual code step + space + comment. Use arrow. Example: \"Start // 程式開始執行\". Good.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 numerator, denominator // 取得分子與分母  \n→ Decision: 如果 denominator 為 0? // 防止除以零  \n  Yes → Step 2: 輸出 'Undefined' // 顯示錯誤訊息  \n  No → Step 3: 進行後續計算 // 繼續  \nStep 3: 計算 sign = (numerator < 0) XOR (denominator < 0) // 確定結果符號  \n→ Step 4: numerator = |numerator|, denominator = |denominator| // 取正值進行運算  \n→ Step 5: 整數部分 = numerator ÷ denominator // 得到整數位  \n→ Decision: 如果 numerator mod denominator == 0? // 檢查是否為整數  \n  Yes → Step 6: 如果 sign 為負則前置 '-'  \n    → Step 7: 輸出 整數部分 // 完成  \n  No → Step 8: 初始化 decimal = \"\" // 開始小數部分構造  \n    → Step 9: remainder = numerator mod denominator // 初始餘數  \n    → Step 10: 建立 map remainderPosition = {} // 用於檢測循環  \n    → Decision: remainder == 0? // 若餘數為 0 則小數結束  \n      Yes → Step 11: 如果 sign 為負則前置 '-'  \n       → Step 12: 輸出 整數部分 + \".\" + decimal // 完成  \n      No → Step 13: 循環開始 // 進入小數循環  \nStep 13: 循環  \n  → Decision: remainder 在 remainderPosition? // 檢查是否重複  \n    Yes → Step 14: repeatStart = remainderPosition[remainder] // 取得重複起始位置  \n      → Step 15: decimal = decimal[:repeatStart] + \"(\" + decimal[repeatStart:] + \")\" // 插入括號  \n      → Step 16: 如果 sign 為負則前置 '-'  \n       → Step 17: 輸出 整數部分 + \".\" + decimal // 完成  \n    No → Step 18: remainderPosition[remainder] = len(decimal) // 記錄位置  \n      → Step 19: remainder *= 10 // 將餘數放大十倍  \n      → Step 20: digit = remainder ÷ denominator // 取下一位小數  \n      → Step 21: decimal += digit // 將該位加入 decimal  \n      → Step 22: remainder = remainder mod denominator // 更新餘數  \n      → Step 23: 跳回 Step 13 // 重複循環  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n        res = []\n        # determine the sign\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n        numerator, denominator = abs(numerator), abs(denominator)\n        # integer part\n        res.append(str(numerator // denominator))\n        remainder = numerator % denominator\n        if remainder == 0:\n            return \"\".join(res)\n        res.append(\".\")\n        # map to store first position of each remainder\n        seen = {}\n        while remainder != 0:\n            if remainder in seen:\n                idx = seen[remainder]\n                res.insert(idx, \"(\")\n                res.append(\")\")\n                break\n            seen[remainder] = len(res)\n            remainder *= 10\n            res.append(str(remainder // denominator))\n            remainder %= denominator\n        return \"\".join(res)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出兩個整數（允許負號）\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) < 2:\n        print(\"0\")\n    else:\n        numerator, denominator = nums[0], nums[1]\n        # 直接處理分母為 0 的情況\n        if denominator == 0:\n            print(\"Undefined\")\n        else:\n            sol = Solution()\n            result = sol.fractionToDecimal(numerator, denominator)\n            print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "0.5"
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": true,
          "output": "0.(012)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve LeetCode problem \"Substring with Concatenation of All Words\". Provide step-by-step logic in virtual code with explanation comments. Use Start, End, Decision. Should not output actual code. Use steps. Need to handle s, words array.\n\nWe can outline algorithm: use sliding window with hash map of word counts, word length, number of words. For each offset 0..wordLen-1, iterate through s, moving window of size totalLen, keep counts.\n\nProvide pseudocode lines.\n\nLet's produce.\n\nAlso need to include explanations in comments after space.\n\nWe must include arrow \"→\". Indentation for decisions.\n\nWe need each line separate.\n\nWe'll produce Start, then steps like:\n\n→ Input: s, words\n\n→ Compute wordLen, totalWords, totalLen\n\n→ Initialize result list\n\n→ For offset from 0 to wordLen-1:\n\n→   Initialize left = offset\n\n→   Initialize right = offset\n\n→   Initialize seen map empty\n\n→   Initialize count = 0\n\n→   While right + wordLen <= s.length:\n\n→     currentWord = substring right..right+wordLen\n\n→     right += wordLen\n\n→     If currentWord in wordCount:\n\n→       Increment seen[currentWord]\n\n→       If seen <= wordCount: count++\n\n→       Else:\n\n→         While seen[currentWord] > wordCount[currentWord]:\n\n→           leftWord = substring left..left+wordLen\n\n→           left += wordLen\n\n→           Decrement seen[leftWord]\n\n→           If seen[leftWord] < wordCount[leftWord]: count--\n\n→     Else:\n\n→       Reset seen map, count=0, left=right\n\n→     If count == totalWords:\n\n→       Append left to result\n\n→ End loops\n\n→ End // Output result\n\nBut need line per step with comments.\n\nAlso maybe break out functions for readability but keep simple.\n\nLet's produce.\n\nNeed to ensure each line has \"虛擬碼步驟\" and comment. Use Chinese comments.\n\nLet's craft.\n\nRemember to include \"Start\" and \"End\" with comments.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input s, words // 取得字串 s 與單字陣列 words  \n→ Step 2: wordLen ← words[0].length // 每個單字長度  \n→ Step 3: wordCount ← Map of word → frequency in words // 建立單字出現頻率表  \n→ Step 4: totalWords ← words.length // 單字總數  \n→ Step 5: totalLen ← wordLen × totalWords // 需要匹配的子字串總長度  \n→ Step 6: result ← empty list // 用於存放所有符合的起始索引  \n→ Decision: 如果 s.length < totalLen? // s 太短無法匹配  \n    Yes → Step 7: Return result // 直接回傳空列表  \n    No  → // 繼續進行滑動窗口查找  \n→ For offset from 0 to wordLen-1: // 每個起始偏移都單獨處理  \n→   Step 8: left ← offset // 窗口左邊界  \n→   Step 9: right ← offset // 窗口右邊界  \n→   Step 10: seen ← empty Map // 目前窗口內單字出現頻率  \n→   Step 11: count ← 0 // 目前已符合的單字數量  \n→   While right + wordLen ≤ s.length: // 右邊界還能擴展  \n→     Step 12: currentWord ← s.substring(right, right + wordLen) // 取下一個單字  \n→     right ← right + wordLen // 右邊界向右移動一個單字長度  \n→     Decision: currentWord 存在於 wordCount? // 是否是合法單字  \n        Yes →  \n            Step 13: seen[currentWord] ← seen.getOrDefault(currentWord,0) + 1 // 計數  \n            Decision: seen[currentWord] ≤ wordCount[currentWord]? // 是否超過頻率  \n                Yes → count ← count + 1 // 成功新增一個符合的單字  \n                No  → // 超過頻率，需要縮窗口  \n                    While seen[currentWord] > wordCount[currentWord]:  \n                        Step 14: leftWord ← s.substring(left, left + wordLen) // 左端單字  \n                        left ← left + wordLen // 左邊界向右移動  \n                        seen[leftWord] ← seen.get(leftWord) - 1 // 減少左端單字計數  \n                        Decision: seen[leftWord] < wordCount[leftWord]? // 左端單字被減少後是否不再超過頻率  \n                            Yes → count ← count - 1 // 失去一個符合的單字  \n                            No  → // 仍超過頻率，繼續縮窗口  \n                    // loop 結束  \n        No → // 當前單字不合法，重置窗口  \n            Step 15: seen ← empty Map  \n            Step 16: count ← 0  \n            Step 17: left ← right // 重新以右端作為新的左邊界  \n→     Decision: count == totalWords? // 是否已經匹配到全部單字  \n        Yes → Step 18: result.add(left) // 將左邊界加入結果  \n        No  → // 需要繼續擴展窗口  \n→ End While  \n→ End For  \n→ Step 19: Return result // 回傳所有起始索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\n        if not s or not words:\n            return []\n\n        word_len = len(words[0])\n        word_count = len(words)\n        total_len = word_len * word_count\n        if len(s) < total_len:\n            return []\n\n        # Frequency map of required words\n        required = Counter(words)\n        result = []\n\n        # Iterate over all possible starting offsets\n        for offset in range(word_len):\n            left = offset\n            right = offset\n            seen = defaultdict(int)\n            matched = 0\n\n            while right + word_len <= len(s):\n                word = s[right:right + word_len]\n                right += word_len\n\n                if word in required:\n                    seen[word] += 1\n                    if seen[word] <= required[word]:\n                        matched += 1\n                    else:\n                        # Reduce window from left until this word count is valid\n                        while seen[word] > required[word]:\n                            left_word = s[left:left + word_len]\n                            left += word_len\n                            seen[left_word] -= 1\n                            if seen[left_word] < required[left_word]:\n                                matched -= 1\n\n                    if matched == word_count:\n                        result.append(left)\n                else:\n                    # Reset window when encountering an invalid word\n                    seen.clear()\n                    matched = 0\n                    left = right\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    Attempts to extract 's' and 'words' from the input data.\n    Supports formats like:\n        s = \"text\", words = [\"a\",\"b\"]\n    or simpler:\n        text\n        a b\n    \"\"\"\n    # Try regex extraction\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    words_match = re.search(r'words\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    if s_match and words_match:\n        s = s_match.group(1)\n        words_raw = words_match.group(1)\n        words = re.findall(r'\"([^\"]*)\"', words_raw)\n        return s, words\n\n    # Fallback: split by whitespace\n    parts = data.strip().splitlines()\n    if len(parts) == 2:\n        s = parts[0].strip()\n        words = parts[1].strip().split()\n        return s, words\n\n    # As a last resort, assume entire data is one line with comma separation\n    parts = data.replace('s =', '').replace('words =', '').split(',')\n    s = parts[0].strip().strip('\"')\n    words_part = ','.join(parts[1:]).strip()\n    words = re.findall(r'\"([^\"]*)\"', words_part)\n    return s, words\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    s, words = parse_input(input_data)\n    sol = Solution()\n    ans = sol.findSubstring(s, words)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode553.json",
    "problem_index_in_file": 0,
    "title": "Optimal Division",
    "description_snippet": "You are given an integer array nums. The adjacent integers in nums will perform the float division.\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm to find expression with maximum value by adding parentheses to maximize division result.\n\nWe need to output step by step pseudo-code lines with arrow and decision, each line has comment.\n\nWe need not actual code.\n\nWe need to think algorithm: For maximizing division of sequence with all positive integers. Known problem: For max value, you should divide first number by product of rest (put parentheses after first). So expression: nums[0] / (nums[1] * nums[2] * ...). That's maximum. For n=1 just return string. For n=2 return \"a/b\". For n>2 return \"a/(b*c*...)\" no parentheses for product. So algorithm: handle cases.\n\nThus pseudo-code steps: start, input array, if length==1 return number string, else if length==2 return \"num0/num1\", else build string: result = num0 + \"/(\" + num1, then for i=2 to n-1 append \"*\" + nums[i], end with \")\". Return result. No redundant parentheses. Also handle negative? But array given integers, could negative? Not specified but likely positive. But algorithm known.\n\nWe need produce virtual code lines with decisions. We can use decisions for length check.\n\nLet's produce lines:\n\nStart\n→ Step 1: Retrieve nums array // Get input array\n→ Decision: 若 nums長度 == 1? // Check single element\n    Yes → Step 2: Return string of nums[0] // Return number\n    No  → Decision: 若 nums長度 == 2? // Check two elements\n        Yes → Step 3: Return nums[0] + \"/\" + nums[1] // Build simple division\n        No  → Step 4: Initialize result = nums[0] + \"/(\" + nums[1] // Start expression with division and opening parenthesis\n        → Decision: 從索引2 到 n-1 是否有剩餘元素? // Check if more elements exist\n            Yes → Step 5: For each nums[i] (i≥2) append \"*\" + nums[i] // Concatenate multiplication\n            No  → Step 6: // no action\n        → Step 7: Append \")\" to result // Close parenthesis\n        → Step 8: Return result // Output expression\n\nBut need each line \"虛擬碼步驟 // 解釋\". Use arrows and decisions.\n\nLet's format each line exactly.\n\nWe need \"Start\" line. Then arrow lines.\n\nUse Chinese. Use \"Start\" or \"Start // 程式開始\".\n\nWe'll produce like:\n\nStart // 程式開始執行\n→ Step 1: Retrieve nums array // 取得輸入的整數陣列\n→ Decision: nums長度 == 1? // 檢查是否只有一個元素\n    Yes → Step 2: Return string(nums[0]) // 直接回傳那個數字\n    No  → Decision: nums長度 == 2? // 檢查是否只有兩個元素\n        Yes → Step 3: Return string(nums[0]) + \"/\" + string(nums[1]) // 直接輸出 a/b\n        No  → Step 4: result = string(nums[0]) + \"/(\" + string(nums[1]) // 開始表達式，放入第一個數字與打開括號\n        → Decision: 是否存在索引 2 以後的元素? // 檢查是否還有剩餘元素\n            Yes → Step 5: For i from 2 to nums.length-1: result += \"*\" + string(nums[i]) // 逐一連接乘號與數字\n            No  → Step 6: // 無剩餘元素，跳過\n        → Step 7: result += \")\" // 關閉括號\n        → Step 8: Return result // 回傳最終表達式\n\nEnd // 程式執行結束\n\nBut we need each line to have arrow or decision and comment. For decision branches we indent and separate lines accordingly. In example they indent after decision with spaces. Use same style.\n\nWe must not output actual code, only pseudo steps.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Retrieve nums array // 取得輸入的整數陣列\n→ Decision: nums長度 == 1? // 檢查是否只有一個元素\n    Yes → Step 2: Return string(nums[0]) // 直接回傳那個數字\n    No  → Decision: nums長度 == 2? // 檢查是否只有兩個元素\n        Yes → Step 3: Return string(nums[0]) + \"/\" + string(nums[1]) // 直接輸出 a/b\n        No  → Step 4: result = string(nums[0]) + \"/(\" + string(nums[1]) // 開始表達式，放入第一個數字與打開括號\n        → Decision: 是否存在索引 2 以後的元素? // 檢查是否還有剩餘元素\n            Yes → Step 5: For i from 2 to nums.length-1: result += \"*\" + string(nums[i]) // 逐一連接乘號與數字\n            No  → Step 6: // 無剩餘元素，跳過\n        → Step 7: result += \")\" // 關閉括號\n        → Step 8: Return result // 回傳最終表達式\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def optimalDivision(self, nums):\n        \"\"\"\n        Build the expression that yields the maximum value by placing\n        parentheses only after the first element.\n        \"\"\"\n        if len(nums) == 1:\n            return str(nums[0])\n        if len(nums) == 2:\n            return f\"{nums[0]}/{nums[1]}\"\n        # For three or more numbers, divide the first by the result of\n        # sequentially dividing the rest of the numbers.\n        rest = \"/\".join(map(str, nums[1:]))\n        return f\"{nums[0]}/({rest})\"\n\nif __name__ == \"__main__\":\n    # Read the entire input; it should be a list representation like \"[2,3,4]\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # Safely parse the list from the input string\n    nums = ast.literal_eval(raw_input)\n    sol = Solution()\n    result = sol.optimalDivision(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1000,100,10,2]",
          "expected_output": "\"1000/(100/10/2)\"",
          "success": true,
          "output": "1000/(100/10/2)"
        },
        {
          "example_index": 1,
          "input": "[2,3,4]",
          "expected_output": "\"2/(3/4)\"",
          "success": true,
          "output": "2/(3/4)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for algorithm: Largest divisible subset. Standard DP: sort nums, dp[i] length ending at i, parent. Complexity O(n^2). We produce virtual code lines step by step. Ensure each line with comment. Use Start, End, Decision. Provide steps: input, sort, init arrays, nested loops, update dp and parent, find max index, reconstruct subset. Provide decisions: if divisible. So produce lines.\n\nLet's design:\n\nStart\n→ Step 1: 接收輸入陣列 nums // 取得使用者給定的整數集合\n→ Step 2: 如果 nums 為空則回傳空集合 // 防止空輸入\n→ Step 3: 將 nums 依升序排序 // 方便判斷可除關係\n→ Step 4: 初始化 dp[0..n-1] 為 1 // 每個元素至少可作一個子集\n→ Step 5: 初始化 prev[0..n-1] 為 -1 // 追蹤前驅\n→ Step 6: 對 i 從 0 到 n-1 進行\n→ Step 7:   對 j 從 0 到 i-1 進行\n→ Step 8:     Decision: 如果 nums[i] % nums[j] == 0? // 判斷可除\n→ Step 9:         Yes → Step 10: 更新 dp[i] 與 prev[i] 如 dp[j]+1 > dp[i] // 更長子集\n→ Step 11: End 循環 j\n→ Step 12: End 循環 i\n→ Step 13: 找出 dp 中最大值的索引 maxIdx // 最大子集終點\n→ Step 14: 初始化 result 為空列表 // 存儲答案\n→ Step 15: 從 maxIdx 開始追蹤 prev 直至 -1\n→ Step 16:   將 nums[maxIdx] 加入 result // 加入子集\n→ Step 17:   maxIdx = prev[maxIdx] // 移到前驅\n→ Step 18: End 循環\n→ Step 19: 逆轉 result 以得到遞增順序 // 逆序為原始順序\n→ Step 20: 回傳 result // 回傳最長可除子集\nEnd\n\nBut we need each line with explanation after //. Ensure arrow formatting: Use \"→\" arrow for steps and decisions. Use \"Decision:\" for decision. Use \"Yes →\" \"No →\" but for no path maybe not required.\n\nLet's produce each line accordingly. Use indentation? Not required but maybe indent decisions lines.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者處取得整數集合  \n→ Decision: 若 nums 為空? // 防止空輸入  \n Yes → Step 2: 回傳空集合 // 若沒有數字直接回傳  \n No  → Step 3: 將 nums 依升序排序 // 方便判斷可除關係  \n→ Step 4: 初始化 dp[0..n-1] 為 1 // 每個元素至少可作一個子集  \n→ Step 5: 初始化 prev[0..n-1] 為 -1 // 用於追蹤子集前驅  \n→ Step 6: 對 i 從 0 到 n-1 進行 // 主循環遍歷每個元素  \n → Step 7: 對 j 從 0 到 i-1 進行 // 子循環比較前面的元素  \n  → Decision: 若 nums[i] % nums[j] == 0? // 判斷是否可被整除  \n   Yes → Step 8: 若 dp[j] + 1 > dp[i]，則  \n     → Step 9: 更新 dp[i] 為 dp[j] + 1  \n     → Step 10: 設定 prev[i] 為 j // 記錄前驅  \n   No → Step 11: // 不可整除，保持現狀  \n → End 循環 j  \n→ End 循環 i  \n→ Step 12: 找出 dp 中最大值的索引 maxIdx // 最大子集的終點  \n→ Step 13: 初始化 result 為空列表 // 用於存放答案  \n→ Step 14: 從 maxIdx 開始，重複直到 -1 // 追蹤前驅鏈  \n  → Step 15: 將 nums[maxIdx] 加入 result // 加入子集元素  \n  → Step 16: maxIdx = prev[maxIdx] // 移動到前驅  \n→ End 循環  \n→ Step 17: 逆轉 result 以得到遞增順序 // 逆序為原始順序  \n→ Step 18: 回傳 result // 傳回最大可除子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n          # dp[i] = longest subset ending at i\n        prev = [-1] * n       # prev[i] = previous index in the subset\n        max_index = 0\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        res = []\n        while max_index >= 0:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n        return res[::-1]  # reverse to ascending order\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list part (handles \"nums = [1,2,3]\" or just \"[1,2,3]\")\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = []\n    if not isinstance(nums, list):\n        nums = []\n\n    solution = Solution()\n    answer = solution.largestDivisibleSubset(nums)\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode705.json",
    "problem_index_in_file": 0,
    "title": "Design HashSet",
    "description_snippet": "Design a HashSet without using any built-in hash table libraries.\n\nImplement MyHashSet class:\n\nvoid ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation, no real code. Must design a hash set using array of buckets, chaining, etc. We'll output Start, decisions, steps, etc. Each line \"虛擬碼步驟 // 解釋\". Must use arrow symbols, Start, End. We'll produce design of MyHashSet with operations.\n\nNeed to include the design: choose number of buckets (e.g., 769 prime). Each bucket holds list of keys. Provide methods add, contains, remove. Use hashing: key mod bucketCount. Steps for each method: compute index, then traverse list.\n\nLet's produce code steps like:\n\nStart // 程式開始執行\n→ Step 1: 定義常數 BUCKET_SIZE = 769 // 使用素數作為桶數，減少碰撞\n→ Step 2: 創建陣列 buckets[BUCKET_SIZE] // 每個桶為空列表\n\nThen methods:\n\n→ Step 3: Method add(key) // 將 key 加入集合\n    → Step 3.1: idx = key mod BUCKET_SIZE // 計算桶索引\n    → Step 3.2: Decision: if key already exists in buckets[idx]? // 防止重複\n        Yes → End // 已存在，無需操作\n        No  → Step 3.3: Append key to buckets[idx] // 加入新鍵\n    → End // add 完成\n\nSimilarly for contains and remove.\n\nMake sure each line uses the arrow, indentation for decision branches. Provide explanation after //. Use brackets etc. Let's write carefully.\n\nAlso use virtual code arrow like \"→\". For decisions, use \"Decision:\" line and branches.\n\nLet's output as required.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義常數 BUCKET_SIZE = 769 // 選用素數作為桶數，降低碰撞機率  \n→ Step 2: 創建陣列 buckets[BUCKET_SIZE] // 每個桶初始化為空列表  \n\n// ---------- add 方法 ----------\n→ Step 3: 方法 add(key) // 把 key 插入集合  \n  → Step 3.1: idx = key mod BUCKET_SIZE // 計算 key 所在桶索引  \n  → Decision: key 已存在於 buckets[idx]? // 防止重複加入  \n    Yes → End // 已存在，直接結束  \n    No  → Step 3.2: buckets[idx].append(key) // 將 key 加入桶中  \n  → End // add 完成  \n\n// ---------- contains 方法 ----------\n→ Step 4: 方法 contains(key) // 判斷 key 是否存在  \n  → Step 4.1: idx = key mod BUCKET_SIZE // 計算桶索引  \n  → Step 4.2: Decision: key 在 buckets[idx] 中? // 在桶中搜尋  \n    Yes → Step 4.3: Return True // 找到，返回真  \n    No  → Step 4.4: Return False // 未找到，返回假  \n  → End // contains 完成  \n\n// ---------- remove 方法 ----------\n→ Step 5: 方法 remove(key) // 從集合移除 key  \n  → Step 5.1: idx = key mod BUCKET_SIZE // 計算桶索引  \n  → Step 5.2: Decision: key 在 buckets[idx] 中? // 若存在才移除  \n    Yes → Step 5.3: buckets[idx].remove(key) // 從桶中刪除  \n    No  → End // 不存在，無需操作  \n  → End // remove 完成  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyHashSet:\n    def __init__(self):\n        # 使用素數作為桶數，減少碰撞\n        self.size = 769\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        \"\"\"簡單的哈希函數：取模桶數。\"\"\"\n        return key % self.size\n\n    def add(self, key: int) -> None:\n        \"\"\"將 key 插入集合，若已存在則不重複。\"\"\"\n        h = self._hash(key)\n        if key not in self.buckets[h]:\n            self.buckets[h].append(key)\n\n    def remove(self, key: int) -> None:\n        \"\"\"若 key 存在於集合中，則移除。\"\"\"\n        h = self._hash(key)\n        if key in self.buckets[h]:\n            self.buckets[h].remove(key)\n\n    def contains(self, key: int) -> bool:\n        \"\"\"判斷 key 是否存在於集合中。\"\"\"\n        h = self._hash(key)\n        return key in self.buckets[h]\n\ndef main() -> None:\n    # 讀取兩行輸入：操作列表與對應參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyHashSet\":\n            obj = MyHashSet()\n            results.append(None)\n        elif op == \"add\":\n            obj.add(arg[0])\n            results.append(None)\n        elif op == \"remove\":\n            obj.remove(arg[0])\n            results.append(None)\n        elif op == \"contains\":\n            results.append(obj.contains(arg[0]))\n\n    # 輸出結果，Python 的 None 會轉成 JSON 的 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"]\n[[], [1], [2], [1], [3], [2], [2], [2], [2]]",
          "expected_output": "[null, null, null, true, false, null, true, null, false]",
          "success": true,
          "output": "[null, null, null, true, false, null, true, null, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode645.json",
    "problem_index_in_file": 0,
    "title": "Set Mismatch",
    "description_snippet": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Task: Given nums array with numbers 1..n, one duplicated, one missing. Find duplicate and missing. We need algorithm, likely using sum and sum of squares, or bitwise. Let's produce steps: compute n, compute expected sum, compute actual sum, difference gives dup - missing. Also compute sum of squares difference gives dup^2 - missing^2 = (dup - missing)(dup + missing). Then compute sum of numbers: dup + missing = diffSquares / diff. Then solve. Steps: Start, compute n = len(nums), sumExpected = n*(n+1)/2, sumActual = sum(nums), diff = sumActual - sumExpected (dup - missing). sumSqExpected = n*(n+1)*(2n+1)/6, sumSqActual = sum(x*x for x in nums), diffSq = sumSqActual - sumSqExpected (dup^2 - missing^2). sumDuplMiss = diffSq / diff. dup = (diff + sumDuplMiss)/2, miss = dup - diff. Return [dup, miss]. Then End.\n\nWe need virtual code with arrows. Use Step numbers. Provide explanation.\n\nAlso we need to ensure integer division results integer.\n\nLet's produce. Use variable names like n, sum_expected, sum_actual, diff, sum_sq_expected, sum_sq_actual, diff_sq, sum_dup_missing, duplicate, missing.\n\nLet's generate lines.\n\nUse indentation for decisions? None needed. But we might include decision if diff==0? Not needed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 n = nums 的長度 // 取得集合中元素個數  \n→ Step 2: 計算期望總和 sum_expected = n * (n + 1) / 2 // 所有 1~n 的總和  \n→ Step 3: 計算實際總和 sum_actual = sum(nums) // 現有數字的總和  \n→ Step 4: 計算差 diff = sum_actual - sum_expected // 兩個數相差 (重複 - 缺失)  \n→ Step 5: 計算期望平方和 sum_sq_expected = n * (n + 1) * (2n + 1) / 6 // 1~n 的平方和  \n→ Step 6: 計算實際平方和 sum_sq_actual = sum(x * x for x in nums) // 現有數字平方和  \n→ Step 7: 計算平方差 diff_sq = sum_sq_actual - sum_sq_expected // (重複² - 缺失²)  \n→ Step 8: 計算重複與缺失之和 sum_dup_missing = diff_sq / diff // (重複² - 缺失²) / (重複 - 缺失)  \n→ Step 9: 計算重複數 duplicate = (diff + sum_dup_missing) / 2 // (差 + 和) / 2  \n→ Step 10: 計算缺失數 missing = duplicate - diff // 重複數減去差得到缺失數  \n→ Step 11: 回傳 [duplicate, missing] // 結果陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys, re\n\ndef findErrorNums(nums):\n    n = len(nums)\n    unique = set(nums)\n    duplicate = sum(nums) - sum(unique)\n    missing = n*(n+1)//2 - sum(unique)\n    return duplicate, missing\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    duplicate, missing = findErrorNums(nums)\n    print(f'[{duplicate},{missing}]')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,4]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2,3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1,2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that computes minimal pigs given buckets, minutesToDie, minutesToTest. Classic problem: number of tests = minutesToTest / minutesToDie + 1? Wait formula: number of rounds = minutesToTest / minutesToDie. Actually pigs can be reused across rounds: each pig can represent base- (rounds+1) digits. Number of states per pig = rounds+1. Minimum pigs = ceil(log(buckets)/log(rounds+1)). But if only 1 round: rounds=1? Actually minutesToTest / minutesToDie gives number of times you can feed and wait. Each pig can give rounds+1 possible outcomes: die at each round or survive all rounds. So states per pig = rounds+1. So compute pigCount = ceil(log(buckets)/log(rounds+1)). We'll produce virtual code with steps.\n\nWe need to output line by line. Provide virtual code steps. Each line: \"Step X: description\" then comment. Use arrow and decision. Provide Start, End. We'll need to compute integer division etc. Provide algorithmic steps.\n\nLet's produce something like:\n\nStart\n→ Step 1: Compute rounds = minutesToTest / minutesToDie // integer division gives number of feeding rounds possible\n→ Step 2: Compute statesPerPig = rounds + 1 // each pig can have that many distinct outcomes\n→ Decision: 如果 statesPerPig <= 1? // avoid divide by zero, handle special case\n    Yes → Step 3: Return buckets // need as many pigs as buckets if no rounds\n    No → Step 4: Compute logBuckets = log(buckets) // natural log or log base 10\n    → Step 5: Compute logStates = log(statesPerPig)\n    → Step 6: Compute requiredPigs = ceil(logBuckets / logStates) // minimal integer >= ratio\n→ End\n\nBut we need to show virtual code steps with arrow and decision. Let's structure properly.\n\nUse \"→\" before each step. Use \"Decision:\" lines with Yes/No arrow.\n\nLet's produce steps. Use maybe \"Start\" no arrow.\n\nAlso we might need to handle integer division rounding down: rounds = minutesToTest // minutesToDie.\n\nLet's produce final.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 rounds = minutesToTest // minutesToDie // 可重複進行測試的輪數  \n→ Step 2: 計算 statesPerPig = rounds + 1 // 每隻豬能產生的獨立結果數  \n→ Decision: 如果 statesPerPig <= 1? // 若無法多次測試，需特殊處理  \n  Yes → Step 3: 返回 buckets // 只一輪時，每桶都需一隻豬  \n  No  → Step 4: 計算 logBuckets = log(buckets) // 取自然對數或任何底數  \n     → Step 5: 計算 logStates = log(statesPerPig) // 取同樣底數的對數  \n     → Step 6: 計算 requiredPigs = ceil(logBuckets / logStates) // 最小整數以上的比例  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        # 每隻豬能產生的不同結果數：測試輪數 + 1 (死在不同輪次或全部存活)\n        rounds = minutesToTest // minutesToDie\n        states_per_pig = rounds + 1\n        # 需要的豬數為最小整數，使得 (states_per_pig) ** pigs >= buckets\n        pigs = 0\n        while states_per_pig ** pigs < buckets:\n            pigs += 1\n        return pigs\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並找出所有整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 3:\n        sys.exit(1)  # 若輸入不足，直接退出\n    buckets, minutesToDie, minutesToTest = nums[0], nums[1], nums[2]\n\n    solution = Solution()\n    result = solution.poorPigs(buckets, minutesToDie, minutesToTest)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The task: group anagrams from array of strings. Typical algorithm: use dictionary mapping sorted string or char count to list. So produce steps: Start, iterate each string, compute key by sorting characters, add to map, after loop iterate over map values, collect lists. End.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for steps. Use Decision? maybe none. We can show Start, loop, etc. Use \"Start // 程式開始執行\". \"→ Step 1: 初始化字典 groups // 用於存儲各組 anagram\" etc. \"→ Step 2: 對每個字串 s 在 strs 進行迭代\" inside we need to compute key. \"→ Step 3: 取得 s 的排序後的字串 key // 排序作為唯一標識\". \"→ Step 4: 如果 key 不在 groups, 則 groups[key] = 空列表\". \"→ Step 5: 將 s 加入 groups[key]\". After loop \"→ Step 6: 將 groups 的所有值轉為結果列表\". \"→ Step 7: 返回結果\". \"End // 程式結束\".\n\nShould we include Decision steps? Not necessary but can include if key not in map. Use Decision block.\n\nUse arrow for nested? Provide indentation? Format example shows indentation of decision branches. We can mimic. For \"Decision: if key not in groups?\" Use \"Decision: key 不在 groups?\" Then Yes → Step 4: groups[key] = [] else skip. But easier: step 4 includes initialization only if absent.\n\nSimpler: use one step with conditional inside. But guidelines allow Decision. We'll produce a Decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 groups 為空字典 // 用於存儲各組 anagram\n→ Step 2: 對每個字串 s 在 strs 進行迭代 // 逐個處理輸入字串\n    → Step 3: 產生 key 為 s 的字元排序後結果 // 排序後作為分組鍵\n    → Decision: key 是否已存在於 groups? // 判斷是否已有此組\n        Yes → Step 4: 將 s 加入 groups[key] // 已有，直接加入\n        No  → Step 5: groups[key] ← [s] // 沒有，建立新列表並加入\n→ Step 6: result ← groups 的所有 value 列表 // 收集所有分組\n→ Step 7: 回傳 result // 返回分組結果\nEnd // 程式執行結束\n\nMake sure each line includes virtual code step plus explanation. Use appropriate arrows and indentation. Provide \"→\" before each step. For decisions, include \"Decision: key 是否已存在於 groups?\" with Yes/No branches.\n\nWe need to ensure each line has arrow and explanation. Provide as per format. Use Chinese explanation.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 groups 為空字典 // 用於存儲各組 anagram\n→ Step 2: 對每個字串 s 在 strs 進行迭代 // 逐個處理輸入字串\n    → Step 3: 產生 key 為 s 的字元排序後結果 // 排序後作為分組鍵\n    → Decision: key 是否已存在於 groups? // 判斷是否已有此組\n        Yes → Step 4: 將 s 加入 groups[key] // 已有，直接加入\n        No  → Step 5: groups[key] ← [s] // 沒有，建立新列表並加入\n→ Step 6: result ← groups 的所有 value 列表 // 收集所有分組\n→ Step 7: 回傳 result // 返回分組結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        Group anagrams from the list of strings.\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))  # 排序後作為鍵\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 解析輸入為字串列表\n    if raw_input.startswith(\"strs\"):\n        _, _, rest = raw_input.partition(\"=\")\n        rest = rest.strip()\n        strs = ast.literal_eval(rest)\n    else:\n        strs = ast.literal_eval(raw_input)\n\n    solution = Solution()\n    result = solution.groupAnagrams(strs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "success": true,
          "output": "[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[['']]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode546.json",
    "problem_index_in_file": 0,
    "title": "Remove Boxes",
    "description_snippet": "You are given several boxes with different colors represented by different positive numbers.\n\nYou ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step, not actual code, but a high-level algorithm description. This is the classic \"Remove Boxes\" DP problem. We'll produce pseudocode with steps, using decision arrows. Need to include virtual code and explanations. Use Start, End, Decision:, arrow arrows.\n\nWe should break into high-level steps: initialize DP 3D, recursion function, base cases, loops. Use recursion with memoization.\n\nWe need to show steps line by line. Let's structure: Start, Input boxes array, Define DP array, Call recursive function solve(l,r,k), explain. Inside function: if l>r return 0. While r>l and boxes[r]==boxes[r-1], reduce r-- and k++. Then compute result1= (k+1)^2 + solve(l,r-1,0). Then loop i from l to r-1: if boxes[i]==boxes[r], compute temp = solve(l,i,k+1)+solve(i+1,r-1,0). Take max. Store DP[l][r][k]. Return DP[l][r][k].\n\nWe will produce each step as a line: \"Start\", \"→ Step: input boxes\", etc. Use arrow '→' before each step. For loops, show decision branches. For example:\n\n→ Step: 讀取 boxes 列表 // Input array\n→ Step: 初始化 3D DP // DP array\n→ Step: 定義遞迴函式 solve(l,r,k) // Recursion\n\nInside solve, we need steps.\n\nWe'll produce a pseudo-code with indentation using arrow.\n\nLet's produce lines.\n\nWe must adhere to format: Each line: virtual code step + space + // explanation.\n\nUse '→' for step lines. 'Decision:' for condition. Use 'Yes →', 'No →' for branches.\n\nWe need to include loops: maybe \"→ For i from l to r-1: ...\" but loops not arrowed; but can show '→ For i = l to r-1:'\n\nWe must keep each line separate.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step: 讀取 boxes 列表 // Input the list of box colors\n→ Step: 取得 n = boxes.length // Number of boxes\n→ Step: 建立三維 memo 以存 DP[l][r][k] // Memoization table\n→ Step: 定義遞迴函式 solve(l, r, k) // Define recursive solver\n→ Decision: 如果 l > r? // Check if no boxes left\n    Yes → Step: return 0 // No points\n    No  → Step: // Continue computation\n→ Step: // 合併右邊相同顏色連續盒子到 k\n→ Decision: 如果 r > l 且 boxes[r] == boxes[r-1]? // Check for same color\n    Yes → Step: r ← r - 1 // Move left\n    Yes → Step: k ← k + 1 // Increase count\n    Yes → Decision: 再次檢查? // Repeat\n        Yes → … // loop until condition false\n→ Step: // 計算直接刪除 r 位置盒子組合的分數\n→ Step: temp ← (k + 1) * (k + 1) + solve(l, r-1, 0) // Remove current group\n→ Step: maxScore ← temp // Initialize max score\n→ Step: // 嘗試將 r 位置盒子合併到左側相同顏色盒子\n→ For i = l to r-1:\n    → Decision: 如果 boxes[i] == boxes[r]? // Find same color\n        Yes → Step: leftScore ← solve(l, i, k+1) // 合併到 i\n        Yes → Step: rightScore ← solve(i+1, r-1, 0) // 右側剩餘\n        Yes → Step: temp ← leftScore + rightScore // 合計分數\n        Yes → Step: maxScore ← max(maxScore, temp) // 更新最大值\n→ Step: memo[l][r][k] ← maxScore // 記錄結果\n→ Step: return memo[l][r][k] // 回傳\n→ Step: Call solve(0, n-1, 0) // 啟動遞迴\n→ Step: output結果 // 印出最大分數\nEnd // 程式執行結束\n\nWe need to use \"→\" for each line. The For loop line can be prefixed with \"→\" as well.\n\nWe need to use Decision: for condition. And Yes →.\n\nAlso inside the while merging loop we can just show steps. But keep simple.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取 boxes 列表 // Input the list of box colors  \n→ Step: 取得 n = boxes.length // Number of boxes  \n→ Step: 建立三維 memo 以存 DP[l][r][k] // Memoization table  \n→ Step: 定義遞迴函式 solve(l, r, k) // Define recursive solver  \n→ Decision: 如果 l > r? // Check if no boxes left  \n  Yes → Step: return 0 // No points  \n  No  → Step: // 進行計算  \n→ Step: // 合併右邊相同顏色連續盒子到 k  \n→ Decision: 如果 r > l 且 boxes[r] == boxes[r-1]? // Check for same color  \n  Yes → Step: r ← r - 1 // 移動左側  \n  Yes → Step: k ← k + 1 // 增加計數  \n  Yes → Decision: 再次檢查? // 重複直到不同顏色  \n    Yes → … // 迴圈體  \n→ Step: // 計算直接刪除 r 位置盒子組合的分數  \n→ Step: temp ← (k + 1) * (k + 1) + solve(l, r-1, 0) // 刪除目前組合  \n→ Step: maxScore ← temp // 初始化最大值  \n→ Step: // 嘗試將 r 位置盒子合併到左側相同顏色盒子  \n→ Step: For i = l to r-1:  \n  Decision: 如果 boxes[i] == boxes[r]? // 找到相同顏色  \n   Yes → Step: leftScore ← solve(l, i, k+1) // 合併到 i  \n   Yes → Step: rightScore ← solve(i+1, r-1, 0) // 右側剩餘  \n   Yes → Step: temp ← leftScore + rightScore // 合計分數  \n   Yes → Step: maxScore ← max(maxScore, temp) // 更新最大值  \n→ Step: memo[l][r][k] ← maxScore // 記錄結果  \n→ Step: return memo[l][r][k] // 回傳  \n→ Step: Call solve(0, n-1, 0) // 啟動遞迴  \n→ Step: output結果 // 印出最大分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef remove_boxes(boxes):\n    sys.setrecursionlimit(10000)          # 避免遞迴深度過大導致崩潰\n    memo = {}\n    n = len(boxes)\n\n    def dp(l, r, k):\n        \"\"\"回傳 [l, r] 之間剩餘盒子，加上右端連續相同顏色盒子數量 k 時可獲得的最高分\"\"\"\n        if l > r:\n            return 0\n        key = (l, r, k)\n        if key in memo:\n            return memo[key]\n\n        # 把右端連續相同顏色的盒子合併到 k 中\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n\n        # 直接刪除右端組合\n        best = dp(l, r - 1, 0) + (k + 1) * (k + 1)\n\n        # 嘗試把右端盒子合併到左側相同顏色盒子\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                best = max(best,\n                           dp(l, i, k + 1) + dp(i + 1, r - 1, 0))\n\n        memo[key] = best\n        return best\n\n    return dp(0, n - 1, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 若輸入形如 \"boxes = [1,2,3]\"，則移除前綴\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n\n    boxes = ast.literal_eval(data)      # 安全地解析為列表\n    result = remove_boxes(boxes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "boxes = [1,3,2,2,2,3,4,3,1]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        },
        {
          "example_index": 1,
          "input": "boxes = [1,1,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "boxes = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: minimum insertions to clear Zuma board. We must produce line-by-line pseudocode with comments. The problem is known: Zuma Game, typical solution using DFS/backtracking with memoization or recursion. Steps: compress board, count hand counts. Use recursion to try each color insertion at positions. Evaluate removal cascade. Use BFS or DFS with memoization. Need to output minimal moves.\n\nWe must produce pseudocode steps: Start, define function minInsertions(board, handCounts). Use recursion: if board empty return 0. If no balls left in hand return INF. Memoize states: key = board + hand string.\n\nWe must compress board into runs of colors and counts. When inserting, we can consider positions between runs or ends. In each attempt, choose a color that has balls in hand. Find where to insert to create group >=3. If insertion doesn't create group, skip. If group formed, compute removal: simulate chain reaction: remove group, collapse neighbors, repeat until stable.\n\nUse helper function removeChain(board) -> new board string after removing all groups of >=3.\n\nIn recursion, decrement hand count for used ball. For each insertion that leads to chain removal, get moves from recursion on new board. Keep min.\n\nReturn min if found else INF -> -1.\n\nWe need to output pseudocode in required format: each line with \"虛擬碼步驟 // 解釋\".\n\nNeed to include arrows and decisions. Use \"Start\", \"End\". Provide steps.\n\nWe must be careful to represent pseudo-code, not actual code. Use high-level steps. Use recursion steps. Provide decision points. Use arrow lines.\n\nWe should show top-level main procedure and recursive function.\n\nLet's outline:\n\nStart\n→ Input board, hand\n→ Count hand frequencies into handCount[5]\n→ Call DFS(board, handCount)\n→ If result == INF then Output -1 else Output result\nEnd\n\nDFS(board, handCount):\n→ If board empty then return 0\n→ Generate key = board + sorted hand counts string // for memo\n→ If key in memo then return memo[key]\n→ minMoves = INF\n→ For each color c in colors:\n    → If handCount[c] == 0 continue\n    → For each position pos in [0..len(board)]:\n        → Insert c at pos -> newBoard\n        → After insertion, compress and chain remove: newBoardAfter = removeChain(newBoard)\n        → If newBoardAfter == board then continue // no effect\n        → Decrease handCount[c]\n        → moves = DFS(newBoardAfter, handCount)\n        → If moves != INF:\n            → minMoves = min(minMoves, moves + 1)\n        → Restore handCount[c]\n→ memo[key] = minMoves\n→ return minMoves\n\nremoveChain(board):\n→ While true:\n    → Find groups of >=3 consecutive same color\n    → If none, break\n    → Remove all such groups from board\n→ return board\n\nBut we also can optimize by not exploring all positions: only positions where insertion adjacent to same color or at ends.\n\nBut we can keep simpler.\n\nWe'll produce pseudocode accordingly.\n\nNeed to use arrow for each step, include decisions.\n\nLet's craft.\n\nWe'll include \"Decision:\" lines for loops and conditions.\n\nWe'll number steps implicitly.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: `board`（字串），`hand`（字串） // 取得棋盤與手牌  \n→ Step 1: 轉換手牌為顏色數量表 `handCount` // 例如{'R':2,'Y':0,'B':1,'G':0,'W':1}  \n→ Step 2: 呼叫 `DFS(board, handCount)` 取得最小插入數 // 進行深度優先搜尋  \n→ Decision: 如果返回值為 `INF`? // 代表無法清除全部球  \n    Yes → Output -1 // 無法完成  \n    No  → Output 返回值 // 最小插入數  \n\nEnd // 程式執行結束  \n\n---  \n\nDFS(board, handCount) // 回溯求最小插入數  \n→ Decision: 如果 `board` 為空? // 已清除所有球  \n    Yes → Return 0 // 無需再插入  \n    No  → Continue  \n\n→ Step 3: 生成鍵 `key = board + \"|\" + handCountToString(handCount)` // 用於記錄已計算的狀態  \n→ Decision: 如果 `memo` 中存在 `key`?  \n    Yes → Return `memo[key]` // 直接回傳已知結果  \n    No  → Continue  \n\n→ Step 4: `minMoves = INF` // 初始化最小值  \n\n→ Decision: 對每個顏色 `c` in ['R','Y','B','G','W']? // 嘗試所有可用顏色  \n    For each `c`:  \n        → Decision: 如果 `handCount[c] == 0`?  \n            Yes → `continue` // 沒有這種顏色的手牌，跳過  \n            No  → 進一步  \n\n        → Step 5: 針對所有插入位置 `pos` 在 0..len(board)  \n            For pos from 0 to len(board):  \n                → Step 6: `newBoard = board[:pos] + c + board[pos:]` // 在位置插入球  \n                → Step 7: `removedBoard = RemoveChain(newBoard)` // 連鎖移除  \n                → Decision: 如果 `removedBoard == board`? // 插入沒產生消除  \n                    Yes → `continue` // 無效操作，跳過  \n                    No  →  \n\n                → Step 8: `handCount[c] -= 1` // 使用一顆手牌  \n                → Step 9: `moves = DFS(removedBoard, handCount)` // 進行遞迴  \n                → Decision: 如果 `moves != INF`?  \n                    Yes → `minMoves = min(minMoves, moves + 1)` // 更新最小插入數  \n                    No  → // 這條路徑不可行，忽略  \n                → Step 10: `handCount[c] += 1` // 回溯，恢復手牌  \n\n→ Step 11: `memo[key] = minMoves` // 記錄本狀態結果  \n→ Return `minMoves` // 回傳最小插入數  \n\n---  \n\nRemoveChain(board) // 連鎖消除所有 3+ 同色組  \n→ Step 12: `changed = True`  \n→ Decision: 當 `changed` 為 True?  \n    While `changed`:  \n        → `changed = False`  \n        → Step 13: 搜尋 `board` 中所有連續相同顏色且長度 ≥ 3 的區段  \n        → Decision: 若找到任一區段?  \n            Yes →  \n                → Step 14: 刪除所有此類區段（一次性刪除）  \n                → Step 15: `changed = True` // 仍有可能產生新區段  \n            No  → `break` // 無更多可消除區段  \n→ Return `board` // 返還已消除後的棋盤  \n\n---  \n\nhandCountToString(handCount) // 將手牌數量表轉成字串，便於作為 memo key  \n→ Step 16: `return \"|\" + str(handCount['R']) + \"|\" + str(handCount['Y']) + \"|\" + str(handCount['B']) + \"|\" + str(handCount['G']) + \"|\" + str(handCount['W'])`  \n\n---  \n\n此虛擬碼描述了使用深度優先搜尋與記憶化（memoization）來尋找最小插入數的流程，並包含連鎖消除的邏輯。",
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\nclass Solution:\n    def findMinStep(self, board: str, hand: str) -> int:\n        colors = ['R', 'Y', 'B', 'G', 'W']\n        hand_counts = [hand.count(c) for c in colors]\n        INF = 10 ** 9\n\n        def remove_chain(s: str) -> str:\n            while True:\n                i = 0\n                removed = False\n                parts = []\n                while i < len(s):\n                    j = i\n                    while j < len(s) and s[j] == s[i]:\n                        j += 1\n                    if j - i >= 3:\n                        removed = True\n                    else:\n                        parts.append(s[i:j])\n                    i = j\n                if not removed:\n                    break\n                s = ''.join(parts)\n            return s\n\n        @lru_cache(maxsize=None)\n        def dfs(curr_board: str, hand_tuple: tuple) -> int:\n            if not curr_board:\n                return 0\n            min_moves = INF\n            hand_list = list(hand_tuple)\n            for idx, c in enumerate(colors):\n                if hand_list[idx] == 0:\n                    continue\n                # try all insertion positions\n                for pos in range(len(curr_board) + 1):\n                    new_board = curr_board[:pos] + c + curr_board[pos:]\n                    after = remove_chain(new_board)\n                    if after == curr_board:\n                        continue  # no change, skip\n                    hand_list[idx] -= 1\n                    moves = dfs(after, tuple(hand_list))\n                    hand_list[idx] += 1\n                    if moves != -1:\n                        min_moves = min(min_moves, moves + 1)\n            return -1 if min_moves == INF else min_moves\n\n        return dfs(board, tuple(hand_counts))\n\ndef main():\n    data = sys.stdin.read()\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        board, hand = parts[0], parts[1]\n    else:\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            board, hand = lines[0].strip(), lines[1].strip()\n        elif lines:\n            board, hand = lines[0].strip(), ''\n        else:\n            board, hand = '', ''\n    sol = Solution()\n    ans = sol.findMinStep(board, hand)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode564.json",
    "problem_index_in_file": 0,
    "title": "Find the Closest Palindrome",
    "description_snippet": "Given a string n representing an integer, return the closest integer (not including itself), which i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. Need to handle input string n, find nearest palindrome integer excluding itself, tie choose smaller. Virtual code: Start, parse string to integer maybe? But keep string? Approach: generate palindromes around n, check difference, choose best.\n\nSimplify: Generate palindrome candidates by mirroring prefix, adjusting, maybe plus/minus 1. But we can produce generic algorithm: iterate difference d from 1 upward, check n-d and n+d for palindrome, choose first found with minimal difference; if tie difference equal, pick smaller (n-d). That is simpler and meets requirement but might be large if n is big (10^18). But virtual code not actual algorithm constraints.\n\nWe just produce virtual code steps.\n\nPseudo:\n\nStart // start\n→ Step 1: Convert input string n to integer target // parse integer\n→ Step 2: Initialize minDiff = infinity; result = None // variables\n→ Step 3: For d from 1 to infinity // loop indefinitely\n    → Decision: Check target - d != target and isPalindrome(target - d)? // candidate lower\n        Yes → Decision: If minDiff > d? // better difference\n            Yes → Step: result = target - d; minDiff = d\n            No → Do nothing\n    → Decision: Check target + d != target and isPalindrome(target + d)? // candidate higher\n        Yes → Decision: If minDiff > d? // same difference not possible? but if equal difference, choose smaller so we keep existing lower\n            Yes → Step: result = target + d; minDiff = d\n            No → Do nothing\n    → Decision: If minDiff != infinity? // found\n        Yes → Break loop // exit\nEnd // output result\n\nBut need to output result as string.\n\nAdd step to convert result to string.\n\nAlso we need function isPalindrome(x). Could be separate step.\n\nWe need to follow formatting: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Start, End, Decision: etc.\n\nMake sure each line with code step. Use spaces. Let's write.\n\nWe can structure:\n\nStart // 程式開始\n\n→ Step 1: target ← Convert string n to integer // 將輸入字串轉為整數\n\n→ Step 2: minDiff ← ∞ // 初始化最小差距\n\n→ Step 3: result ← null // 初始化結果\n\n→ Step 4: d ← 1 // 差距起始\n\n→ Decision: 是否已找到最佳? // 檢查是否已找到最近回文\n\n    No → → Step 5: lower ← target - d // 低於目標的候選\n\n    → Decision: lower ≠ target AND isPalindrome(lower)? // 檢查是否回文\n\n        Yes → Decision: d < minDiff? // 更近\n\n            Yes → → Step 6: result ← lower // 更新結果\n\n            Yes → → Step 7: minDiff ← d // 更新差距\n\n        No → // 無操作\n\n    → Step 8: higher ← target + d // 高於目標的候選\n\n    → Decision: higher ≠ target AND isPalindrome(higher)? // 檢查是否回文\n\n        Yes → Decision: d < minDiff? // 更近\n\n            Yes → → Step 9: result ← higher\n\n            Yes → → Step 10: minDiff ← d\n\n        No → // 無操作\n\n    → Step 11: d ← d + 1 // 增加差距\n\n    → Decision: 已找到最佳? // 若已找到，則跳出\n\n        Yes → → Step 12: Break // 退出迴圈\n\n    No → // 回到判斷\n\nEnd // 結束並輸出結果\n\nBut we need to produce virtual code with arrows. Format example uses:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // ...\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: ...\n\nWe can follow similar indentation.\n\nLet's produce final output with each line.\n\nNeed to include function isPalindrome(x). We can inline or separate step: define function. Let's add at start: Function isPalindrome(x): // returns bool\n\nBut we can't create function definitions inside the flow? We can include step.\n\nAdd:\n\n→ Step 0: Function isPalindrome(x) // 檢查整數是否為回文\n    → Step 0.1: strX ← Convert x to string // 轉成字串\n    → Decision: strX == Reverse(strX)? // 比較\n        Yes → → Step 0.2: Return True\n        No  → → Step 0.3: Return False\n\nBut we need to adhere to format.\n\nSimplify: We'll just mention that we have a function isPalindrome(x). Provide explanation after step.\n\nLet's produce final output with each line.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 0: Function isPalindrome(x) // 檢查整數是否為回文\n    → Step 0.1: strX ← Convert x to string // 先轉成字串\n    → Decision: strX == Reverse(strX)? // 判斷字串是否鏡像相等\n        Yes → Step 0.2: Return True // 是回文\n        No  → Step 0.3: Return False // 不是回文\n→ Step 1: target ← Convert string n to integer // 把輸入字串轉為整數\n→ Step 2: minDiff ← ∞ // 設定最小差距為無限大\n→ Step 3: result ← null // 先把答案設為空\n→ Step 4: d ← 1 // 差距從 1 開始遞增\n→ Decision: result ≠ null? // 是否已找到最近回文\n    No →\n        → Step 5: lower ← target - d // 低於目標的候選\n        → Decision: lower ≠ target AND isPalindrome(lower)? // 檢查是否回文\n            Yes →\n                → Decision: d < minDiff? // 比較差距\n                    Yes →\n                        → Step 6: result ← lower // 更新答案\n                        → Step 7: minDiff ← d // 更新最小差距\n                    No → // 已經比目前差距更小，不做任何事\n            No → // 不是回文，忽略\n        → Step 8: higher ← target + d // 高於目標的候選\n        → Decision: higher ≠ target AND isPalindrome(higher)? // 檢查是否回文\n            Yes →\n                → Decision: d < minDiff? // 比較差距\n                    Yes →\n                        → Step 9: result ← higher // 更新答案\n                        → Step 10: minDiff ← d // 更新最小差距\n                    No → // 已經比目前差距更小，不做任何事\n            No → // 不是回文，忽略\n        → Step 11: d ← d + 1 // 差距加一，繼續尋找\n        → Decision: result ≠ null? // 再次檢查是否已找到答案\n            Yes →\n                → Step 12: Break // 找到最近回文後跳出循環\n            No → // 回到 Decision: result ≠ null? 重新評估\nEnd // 程式執行結束，輸出 result 為最近回文整數。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nearestPalindromic(self, n: str) -> str:\n        length = len(n)\n        num = int(n)\n        candidates = set()\n\n        # Special edge cases\n        candidates.add(str(10 ** length + 1))          # 100...001\n        candidates.add(str(10 ** (length - 1) - 1))    # 99...99\n\n        # Prefix manipulation\n        prefix_len = (length + 1) // 2\n        prefix = int(n[:prefix_len])\n\n        for delta in (-1, 0, 1):\n            new_prefix = str(prefix + delta)\n            if length % 2 == 0:\n                palin = new_prefix + new_prefix[::-1]\n            else:\n                palin = new_prefix + new_prefix[:-1][::-1]\n            candidates.add(palin)\n\n        # Remove the original number itself\n        candidates.discard(n)\n\n        # Find the best candidate\n        best = None\n        for cand in candidates:\n            cand_int = int(cand)\n            diff = abs(cand_int - num)\n            if best is None:\n                best = cand\n                continue\n            best_int = int(best)\n            best_diff = abs(best_int - num)\n            if diff < best_diff or (diff == best_diff and cand_int < best_int):\n                best = cand\n\n        return best\n\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the first continuous digit sequence (handles formats like n = \"123\")\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = match.group()\n    sol = Solution()\n    result = sol.nearestPalindromic(n)\n    # Output the result surrounded by double quotes, as per the examples\n    print(f'\"{result}\"')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"123\"",
          "expected_output": "\"121\"",
          "success": true,
          "output": "\"121\""
        },
        {
          "example_index": 1,
          "input": "n = \"1\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for algorithm that finds duplicates in array with constraints. Must run O(n), constant extra space. Use negative marking or index mapping. Provide steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrow. Provide Start, End, Decision etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空列表 duplicates // 用於儲存所有重複的數字  \n→ Step 2: 迭代 i 從 0 到 n-1 // 遍歷整個陣列  \n  Decision: 如果 abs(nums[i]) 在 nums[abs(nums[i]) - 1] 的值已為負? // 判斷該位置是否已被標記  \n   Yes → Step 3: 把 abs(nums[i]) 加入 duplicates // 已標記代表此數字已出現第二次  \n   No → Step 4: 把 nums[abs(nums[i]) - 1] 設為負 // 第一遍遇到時標記此位置為負，表示已見過  \n→ End // 程式執行結束  \nReturn duplicates // 輸出重複的數字列表",
      "generated_code": "import sys\nimport ast\n\ndef find_duplicates(nums):\n    \"\"\"\n    找出 nums 中所有出現兩次的數字。\n    使用負號標記技巧：遍歷一次陣列，對於每個數字 num\n    1. 取得對應的索引 idx = abs(num) - 1\n    2. 若 nums[idx] 已經是負數，表示此 num 已經出現過一次，加入結果\n    3. 否則將 nums[idx] 改為負號，標記已經看到過\n    \"\"\"\n    res = []\n    for num in nums:\n        idx = abs(num) - 1\n        if nums[idx] < 0:\n            res.append(abs(num))\n        else:\n            nums[idx] = -nums[idx]\n    return res\n\ndef main():\n    \"\"\"\n    從標準輸入讀取數組，格式示例：\n        nums = [4,3,2,7,8,2,3,1]\n    解析後呼叫 find_duplicates，將結果印出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取等號右側的部分作為數組表達式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # 以 ast.literal_eval 解析，安全性較高\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，直接 eval\n        nums = eval(expr, {})\n\n    result = find_duplicates(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step explaining. Should design LRU cache with hash map + doubly linked list. Provide virtual code lines with explanation. Ensure use of arrow notation. Should be sequential. Use Start End. Use Decision lines. Provide each step with explanation. No actual code. Use plain text. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 宣告類別 LRUCache // 定義 LRUCache 類別\n→ Step 2: 宣告成員變數 capacity, map, head, tail // 容量、哈希表、雙向鏈表頭尾\n→ Step 3: 實作建構子 LRUCache(capacity) // 初始化容量與資料結構\n    → Decision: capacity 是否為正? // 檢查容量合法性\n        Yes → Step 4: 設定 this.capacity ← capacity // 存儲容量\n        No  → Step 4: throw IllegalArgumentException // 錯誤處理\n    → Step 5: map ← 新 HashMap<Integer, Node>() // key 到節點的映射\n    → Step 6: head ← new Node() // 虛擬頭節點\n    → Step 7: tail ← new Node() // 虛擬尾節點\n    → Step 8: head.next ← tail // 連接頭尾\n    → Step 9: tail.prev ← head // 連接尾頭\nEnd // 建構子結束\n\nStart // get 方法開始\n→ Step 10: get(key) // 取得指定 key\n    → Decision: map 是否包含 key? // 檢查 key 是否存在\n        Yes → Step 11: node ← map.get(key) // 取得節點\n            → Step 12: moveToHead(node) // 將節點移至最近使用\n            → Step 13: return node.value // 返回值\n        No  → Step 14: return -1 // 未找到返回 -1\nEnd // get 方法結束\n\nStart // put 方法開始\n→ Step 15: put(key, value) // 插入或更新 key\n    → Decision: map 是否包含 key? // 檢查 key 是否存在\n        Yes → Step 16: node ← map.get(key) // 取得節點\n            → Step 17: node.value ← value // 更新值\n            → Step 18: moveToHead(node) // 更新後移至頭部\n        No  → Step 19: node ← new Node(key, value) // 新建節點\n            → Step 20: addNode(node) // 插入到頭部\n            → Step 21: map.put(key, node) // 更新哈希表\n            → Step 22: if (map.size() > capacity) // 超過容量檢查\n                Yes → Step 23: tailNode ← popTail() // 移除最舊節點\n                    → Step 24: map.remove(tailNode.key) // 從哈希表移除\n                No  → No action // 容量未超過\nEnd // put 方法結束\n\nStart // 私有輔助方法 addNode\n→ Step 25: addNode(node) // 把節點加入到 head 後\n    → Step 26: node.prev ← head\n    → Step 27: node.next ← head.next\n    → Step 28: head.next.prev ← node\n    → Step 29: head.next ← node\nEnd // addNode 結束\n\nStart // 私有輔助方法 removeNode\n→ Step 30: removeNode(node) // 從鏈表中移除節點\n    → Step 31: prev ← node.prev\n    → Step 32: next ← node.next\n    → Step 33: prev.next ← next\n    → Step 34: next.prev ← prev\nEnd // removeNode 結束\n\nStart // 私有輔助方法 moveToHead\n→ Step 35: moveToHead(node) // 先移除再加入\n    → Step 36: removeNode(node)\n    → Step 37: addNode(node)\nEnd // moveToHead 結束\n\nStart // 私有輔助方法 popTail\n→ Step 38: popTail() // 取得並移除最舊節點\n    → Step 39: res ← tail.prev\n    → Step 40: removeNode(res)\n    → Step 41: return res\nEnd // popTail 結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"\n    LRU Cache implemented with OrderedDict for O(1) get and put.\n    \"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move key to the end to mark it as recently used\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Remove old entry\n            self.cache.pop(key)\n        self.cache[key] = value\n        # Evict least recently used if over capacity\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\ndef main() -> None:\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # The input is two lists separated by a comma\n    # Wrap in parentheses so ast.literal_eval returns a tuple of two lists\n    ops, args = ast.literal_eval('(' + raw_input + ')')\n\n    res = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"LRUCache\":\n            # Constructor\n            obj = LRUCache(args[i][0])\n            res.append(\"null\")\n        elif op == \"put\":\n            key, value = args[i]\n            obj.put(key, value)\n            res.append(\"null\")\n        elif op == \"get\":\n            key = args[i][0]\n            val = obj.get(key)\n            res.append(str(val))\n        else:\n            # Unknown operation – ignore or raise error\n            res.append(\"null\")\n\n    # Format output as required: [null, null, ...]\n    print(\"[\" + \", \".join(res) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for the algorithm: check if integer is palindrome. Use steps: start, convert to string, compare with reverse, or use math. Let's use string method for simplicity.\n\nVirtual code lines:\nStart // 程式開始\n→ Step 1: Input x // 取得整數\n→ Step 2: Convert x to string s // 轉成字串\n→ Step 3: Reverse s to r // 取得反轉字串\n→ Decision: s equals r? // 檢查正序與反序是否相同\n    Yes → Step 4: Return true // 是回文\n    No  → Step 5: Return false // 不是回文\nEnd\n\nInclude explanations. Ensure each line ends with // explanation. Use arrow syntax exactly.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 x // 從使用者或函式取得待檢查的整數  \n→ Step 2: 轉換 x 為字串 s // 把整數轉成字串以便比較  \n→ Step 3: 產生 s 的反轉字串 r // 以相同字元順序倒轉字串  \n→ Decision: s 等於 r? // 判斷原字串與反轉字串是否相同  \n    Yes → Step 4: 回傳 true // 若相同則為回文，返回真  \n    No  → Step 5: 回傳 false // 若不同則非回文，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        \"\"\"\n        判斷整數 x 是否為回文數。\n        若 x 為負數，直接回傳 False。\n        \"\"\"\n        if x < 0:\n            return False\n        s = str(x)\n        return s == s[::-1]\n\ndef main() -> None:\n    # 讀取整個輸入，去除首尾空白\n    data = sys.stdin.read().strip()\n    # 從輸入中尋找第一個整數（含負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        # 若無整數，視為錯誤輸入，直接結束\n        return\n    x = int(match.group())\n    result = Solution().isPalindrome(x)\n    # 按題目要求輸出小寫的 true/false\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for problem: Given integer array nums, return maximum XOR of any two numbers. Classic solution uses Trie bitwise.\n\nWe need step-by-step pseudocode with explanations, following format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows, Decision, etc.\n\nWe must not output actual code. Provide structured steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化二進制長度為 31 (最高位)\n→ Step 2: 建立空 Trie 根節點\n→ Step 3: 定義函式 Insert(number) // 插入到 Trie\n→ Step 4: 定義函式 Query(number) // 取得最大 XOR 與已有數字\n→ Decision: if nums array empty? // 若無數字則返回 0\n    Yes → Step 5: Return 0\n    No  → proceed\n→ Step 6: 對 nums[0] 執行 Insert\n→ Step 7: 初始化 maxXor = 0\n→ Step 8: 從 i = 1 到 n-1 迭代\n    → Step 8.1: current = nums[i]\n    → Step 8.2: bestXor = Query(current) // 找最大 XOR\n    → Decision: if bestXor > maxXor? // 更新最大值\n        Yes → Step 8.3: maxXor = bestXor\n    → Step 8.4: Insert(current) // 將當前數字加入 Trie\n→ Step 9: Return maxXor\nEnd\n\nBut we need to show decisions properly with Yes/No arrows. Also we need to show function definitions maybe separate.\n\nWe must show each step as a line, not nested inside loops? But we can use indentation for loops.\n\nThe format requires \"虛擬碼步驟 // 解釋/說明\".\n\nLet's produce lines accordingly.\n\nWe'll include functions as steps. Each function can be defined with sub-steps maybe. We'll use Decision for loop.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set bitLen = 31 // 以 31 為最高位，因為 int 最大為 2^31-1  \n→ Step 2: Create empty Trie node root // 建立 Trie 的根節點  \n→ Step 3: Define Function Insert(number) // 將數字插入 Trie  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3.1: node ← root  \n&nbsp;&nbsp;&nbsp;&nbsp;→ For bit from bitLen down to 0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ bitVal ← (number >> bit) & 1 // 取該位  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: if node.child[bitVal] exists?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → node ← node.child[bitVal]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → node.child[bitVal] = new TrieNode(); node ← node.child[bitVal]  \n&nbsp;&nbsp;&nbsp;&nbsp;→ End Function // Insert 結束  \n→ Step 4: Define Function Query(number) → // 找出已插入數字中能使 XOR 最大的值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ bestXor ← 0  \n&nbsp;&nbsp;&nbsp;&nbsp;→ node ← root  \n&nbsp;&nbsp;&nbsp;&nbsp;→ For bit from bitLen down to 0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ bitVal ← (number >> bit) & 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ preferred ← 1 - bitVal // 期望取相反位以使 XOR 為 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: if node.child[preferred] exists?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → bestXor ← (bestXor << 1) | 1; node ← node.child[preferred]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → bestXor ← (bestXor << 1); node ← node.child[bitVal]  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Return bestXor // 返回與已有數字 XOR 最大的值  \n→ Step 5: If nums array is empty? // 沒有數字時直接返回 0  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return 0 // 空陣列無法計算 XOR  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → Continue  \n→ Step 6: Insert(nums[0]) // 將第一個數字放進 Trie  \n→ Step 7: maxXor ← 0 // 初始化最大 XOR 結果  \n→ Step 8: For i from 1 to n-1 // 從第二個數字開始處理  \n&nbsp;&nbsp;&nbsp;&nbsp;→ current ← nums[i]  \n&nbsp;&nbsp;&nbsp;&nbsp;→ candidate ← Query(current) // 找到與現有數字的最大 XOR  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: if candidate > maxXor?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → maxXor ← candidate // 更新全局最大值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Insert(current) // 將此數字加入 Trie，供後續比較使用  \n→ Step 9: Return maxXor // 回傳最終最大 XOR 值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.child = [None, None]  # child[0] -> bit 0, child[1] -> bit 1\n\nclass Solution:\n    def findMaximumXOR(self, nums):\n        if not nums:\n            return 0\n\n        root = TrieNode()\n        self._insert(root, nums[0])\n        max_xor = 0\n\n        for num in nums[1:]:\n            max_xor = max(max_xor, self._query(root, num))\n            self._insert(root, num)\n\n        return max_xor\n\n    def _insert(self, root, num):\n        node = root\n        for i in range(30, -1, -1):          # 31 bits for 32-bit signed integer\n            bit = (num >> i) & 1\n            if node.child[bit] is None:\n                node.child[bit] = TrieNode()\n            node = node.child[bit]\n\n    def _query(self, root, num):\n        node = root\n        curr_xor = 0\n        for i in range(30, -1, -1):\n            bit = (num >> i) & 1\n            toggled = 1 - bit            # prefer opposite bit for maximizing XOR\n            if node.child[toggled]:\n                curr_xor = (curr_xor << 1) | 1\n                node = node.child[toggled]\n            else:\n                curr_xor = curr_xor << 1\n                node = node.child[bit]\n        return curr_xor\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list of numbers; supports both \"nums = [..]\" and just \"[..]\"\n    if '=' in data:\n        nums_part = data.split('=', 1)[1].strip()\n    else:\n        nums_part = data.strip()\n    nums = ast.literal_eval(nums_part)\n    solution = Solution()\n    result = solution.findMaximumXOR(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with explanations. The user wants the algorithm to find the longest word in dictionary that can be formed by deleting some characters of s. If multiple longest, choose lexicographically smallest. If none, return empty string. So we must produce pseudocode. Must be line-by-line, with each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows and decision structure.\n\nWe need to design the algorithm. Usually we iterate over dictionary words sorted by length descending, then lexicographically ascending for same length. For each word, check if it's a subsequence of s by two-pointer scan. Keep best word. If dictionary empty or no subsequence, return empty string.\n\nAlternatively we can sort dictionary accordingly. Or we can just iterate unsorted but maintain best.\n\nWe'll produce pseudocode: Start, Sort dictionary by length descending, then lexicographically ascending? Actually we want longest first, then lexicographically smallest among same length. Sorting by length descending and lexicographically ascending will yield correct order. So we can iterate sorted dictionary, find first subsequence; that's answer. Else empty string.\n\nBut we can also process unsorted but keep best.\n\nSimpler: Sort dictionary by (-length, word). Then for each word, if isSubsequence(s, word), return word; else continue; after loop, return empty.\n\nNeed function isSubsequence(s, word): two pointers i for s, j for word. while i<|s| and j<|word|: if s[i]==word[j] j++ ; i++ ; after loop return j==|word|.\n\nWe need to provide pseudocode line by line with arrow etc.\n\nLet's create steps:\n\nStart\n→ Step 1: 定義函式 isSubsequence(s, word) // 判斷 word 是否為 s 的子序列\n    → Decision: if s 為空? // 處理 s 為空的特殊情況\n        Yes → Return word 為空 ? true : false // 空 s 只可匹配空字串\n        No → Step 2: 初始化 i=0, j=0 // s 的指標和 word 的指標\n            → Decision: 當 i < len(s) 且 j < len(word)? // 迭代匹配\n                Yes → Decision: s[i] == word[j]? // 字符相等\n                    Yes → i++ ; j++ // 同時前進\n                    No  → i++ // 只前進 s 的指標\n                No  → Exit loop // 結束迴圈\n            → Step 3: Return j == len(word) // 成功時 j 等於 word 長度\nEnd // 函式結束\n\nThen main algorithm:\n\nStart // 程式開始執行\n→ Step 1: 將 dictionary 按字典序升序排序 // 先排字典序\n→ Step 2: 將 dictionary 按長度降序排序 // 再按長度排序，保持字典序不變\n→ Step 3: 初始化 result = \"\" // 最佳結果\n→ Step 4: 對於每個 word 在 dictionary 之中\n    → Decision: isSubsequence(s, word)? // 檢查是否為子序列\n        Yes → result = word ; Break // 找到第一個符合條件的，直接返回\n        No  → Continue // 進行下一個字\n→ Step 5: Return result // 若無匹配，返回空字串\nEnd // 程式結束\n\nBut the sorting step: need stable sorting: sort by length descending, if equal, by lexicographic ascending. So we could combine: Step 1: 將 dictionary 依照 (長度降序, 字典序升序) 排序 // 確保優先長度，長度相同時字典序最小\n\nBetter: We can implement custom sort.\n\nLet's produce pseudocode with this sorting step. We can use stable sort but we can just specify that we sort accordingly.\n\nLet's produce the lines.\n\nWe must ensure each line uses \"→\" for steps, \"Decision:\" for decisions. The top Start and End are at top-level. The function may be separate, but we can incorporate in same code. Usually we can put function definition after Start maybe.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isSubsequence(s, word) // 判斷 word 是否為 s 的子序列\n    → Decision: len(word) == 0? // 空字串總是符合\n        Yes → Return true\n        No → Step 2: i = 0 ; j = 0 // 初始化指標\n            → Decision: i < len(s) AND j < len(word)? // 迭代\n                Yes → Decision: s[i] == word[j]? // 字符比對\n                    Yes → i++ ; j++ // 同時移動\n                    No  → i++ // 只移動 s\n                No  → Exit loop\n            → Step 3: Return j == len(word) // 判斷是否完整匹配\n→ Step 4: 將 dictionary 依照 (長度降序, 字典序升序) 排序 // 確保先檢查最長且字典序最小的字\n→ Step 5: result = \"\" // 儲存最終答案\n→ Step 6: 對於每個 word 在 dictionary 中\n    → Decision: isSubsequence(s, word)? // 檢查是否能由 s 形成\n        Yes → result = word ; Break // 找到符合條件的第一個，即為答案\n        No  → Continue // 檢查下一個字\n→ Step 7: Return result // 若沒找到，返回空字串\nEnd // 程式執行結束\n\nBut we need to include \"Start\" and \"End\" at outermost. The function definition should be after Start, but not inside other steps? It's fine.\n\nBut we need to maintain proper indentation? The user didn't specify indentation but arrow indicates. We can just indent with tab or spaces. Example:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isSubsequence(s, word) // 判斷 word 是否為 s 的子序列\n    → Decision: ...\n\nBut we need to use \"→\" for steps. The function is step? We can treat \"Step 1\" as function definition. Then inside the function, decisions.\n\nWe need to include \"End\" for function? They didn't ask to produce End for function. Might not be needed. But we can add \"End\" after function. It's optional.\n\nBetter: Provide separate block for function. Eg:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isSubsequence(s, word) // 判斷 word 是否為 s 的子序列\n    → Decision: len(word) == 0? // 空字串總是符合\n        Yes → Return true\n        No  → i = 0 ; j = 0\n            → Decision: i < len(s) AND j < len(word)? // 迭代\n                Yes → Decision: s[i] == word[j]? \n                    Yes → i++ ; j++\n                    No  → i++\n                No  → Exit loop\n            → Step 2: Return j == len(word) // 判斷是否完整匹配\n→ Step 3: 將 dictionary 依照 (長度降序, 字典序升序) 排序 // 確保先檢查最長且字典序最小的字\n→ Step 4: result = \"\" // 儲存最終答案\n→ Step 5: 對於每個 word 在 dictionary 中\n    → Decision: isSubsequence(s, word)? // 檢查是否能由 s 形成\n        Yes → result = word ; Break // 找到符合條件的第一個，即為答案\n        No  → Continue // 檢查下一個字\n→ Step 6: Return result // 若沒找到，返回空字串\nEnd // 程式執行結束\n\nBut we may need a \"End\" for function after Step 2. They didn't specify. However to keep consistency, we can add \"End\" after Step 2. But \"Step 2\" is inside function, so we may call it \"End\" for function. But it's optional.\n\nBetter to just include \"End\" at the bottom for the program. We'll keep function definition inside steps.\n\nWe also need to ensure we use the \"Decision:\" prefix for decisions. Yes.\n\nThe arrow usage: \"→\" for steps. \"Yes →\" and \"No →\" for branches inside decisions. We should indent those accordingly. Also use \"Decision:\" preceding decisions.\n\nThe arrow lines for \"Yes →\" and \"No →\" maybe we should indent a bit.\n\nOk.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 isSubsequence(s, word) // 判斷 word 是否為 s 的子序列  \n  Decision: len(word) == 0? // 空字串總是符合  \n   Yes → Return true  \n   No  → i = 0 ; j = 0 // 初始化指標  \n    Decision: i < len(s) AND j < len(word)? // 迭代匹配  \n     Yes → Decision: s[i] == word[j]?  \n       Yes → i++ ; j++ // 同時前進指標  \n       No  → i++ // 只前進 s 的指標  \n     No  → Exit loop // 結束迴圈  \n    Step 2: Return j == len(word) // 成功時 j 等於 word 長度  \n→ Step 3: 將 dictionary 依照 (長度降序, 字典序升序) 排序 // 確保先檢查最長且字典序最小的字  \n→ Step 4: result = \"\" // 儲存最終答案  \n→ Step 5: 對於每個 word 在 dictionary 中  \n  Decision: isSubsequence(s, word)? // 檢查是否能由 s 形成  \n   Yes → result = word ; Break // 找到符合條件的第一個，即為答案  \n   No  → Continue // 檢查下一個字  \n→ Step 6: Return result // 若沒找到，返回空字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestWord(self, s: str, dictionary: list[str]) -> str:\n        # 先按長度降序，再按字典序升序排序\n        dictionary.sort(key=lambda x: (-len(x), x))\n        for word in dictionary:\n            it = iter(s)\n            if all(ch in it for ch in word):\n                return word\n        return \"\"\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入格式：<s>, <dictionary>\n    其中 s 為被引號包裹的字串，dictionary 為 Python 風格列表。\n    \"\"\"\n    text = text.strip()\n    depth = 0\n    split_idx = None\n    for i, ch in enumerate(text):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_idx = i\n            break\n    if split_idx is None:\n        raise ValueError(\"Invalid input format\")\n\n    s_part = text[:split_idx].strip()\n    dict_part = text[split_idx + 1 :].strip()\n\n    # 去掉 s 前後的雙引號\n    if s_part.startswith('\"') and s_part.endswith('\"'):\n        s_part = s_part[1:-1]\n\n    # 解析 dictionary\n    dictionary = ast.literal_eval(dict_part)\n    return s_part, dictionary\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, dictionary = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLongestWord(s, dictionary)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "\"apple\""
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "\"a\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode599.json",
    "problem_index_in_file": 0,
    "title": "Minimum Index Sum of Two Lists",
    "description_snippet": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n\nA co...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code with steps. Must include decision arrows, Start, End, Decision lines. Provide line-by-line with explanation. Must not output actual code. Use virtual code style. Let's think of algorithm: store indices of list1 in hash map, iterate list2 to compute sum. Keep min sum and list of strings. Return list. Let's produce steps: Input arrays list1, list2. Build map. Initialize minSum large. result list empty. Iterate over list2 with index j. For each string s: if s in map, compute sum = i + j. If sum < minSum: minSum = sum, clear result, add s. Else if sum == minSum: add s. After loop, return result. Steps with decisions: check if s exists in map. Check if sum < minSum. etc. Let's produce pseudo-code with arrows. We'll use \"→\" for next step, indentation maybe for decisions.\n\nLet's craft lines.\n\nStart\n→ Step 1: Build mapIndex from list1 // map each string to its index\n→ Step 2: Initialize minSum = Infinity // hold minimum index sum\n→ Step 3: Initialize result = [] // list for answer\n→ Step 4: For each string s in list2 with index j // iterate over second list\n    → Decision: if s in mapIndex? // check existence\n        Yes → Step 5: Compute sum = mapIndex[s] + j // index sum\n        → Decision: sum < minSum? // compare with current min\n            Yes → Step 6: minSum = sum // update min\n            → Step 7: result = [s] // reset result with current string\n            No  → Decision: sum == minSum? // check equal\n                Yes → Step 8: result.append(s) // add to result\n                No  → Step 9: // do nothing\n    No  → Step 10: // s not common, skip\nEnd // return result\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". Provide in Traditional Chinese. Let's write. Ensure indentation with spaces. Use arrows. Provide each line separately. Use Start, End. Use Decision. Provide explanation. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 mapIndex，將 list1 中每個字串映射到其索引 // 用 hash map 快速查找字串在 list1 的位置  \n→ Step 2: 設定 minSum = ∞ // 用來儲存目前找到的最小索引和  \n→ Step 3: 初始化 result = [] // 用來收集所有符合最小索引和的字串  \n→ Step 4: 依序遍歷 list2，取得字串 s 與其索引 j // 逐一檢查 list2 中的字串  \n  → Decision: s 是否存在於 mapIndex? // 判斷是否為 common string  \n   Yes → Step 5: 計算 sum = mapIndex[s] + j // 取得該字串在兩個陣列中的索引和  \n    → Decision: sum < minSum? // 與目前最小值比較  \n     Yes → Step 6: minSum = sum // 更新最小索引和  \n      → Step 7: result = [s] // 清空結果並加入新的最小字串  \n    No  → Decision: sum == minSum? // 判斷是否與最小值相等  \n     Yes → Step 8: result.append(s) // 將等值字串加入結果  \n     No  → Step 9: // sum 大於 minSum，無需處理  \n   No  → Step 10: // s 不在 list1，跳過  \nEnd // 程式執行結束，回傳 result 其中包含所有最小索引和的 common string",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef find_restaurant(list1, list2):\n    \"\"\"找到在兩個列表中索引和最小的公共字串。\"\"\"\n    index_map = {name: i for i, name in enumerate(list1)}\n    min_sum = float('inf')\n    res = []\n\n    for j, name in enumerate(list2):\n        if name in index_map:\n            total = j + index_map[name]\n            if total < min_sum:\n                min_sum = total\n                res = [name]\n            elif total == min_sum:\n                res.append(name)\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出兩個方括號內的子字串，預期為 list1 與 list2\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        try:\n            list1 = ast.literal_eval(lists[0])\n            list2 = ast.literal_eval(lists[1])\n        except Exception:\n            list1 = []\n            list2 = []\n    else:\n        list1, list2 = [], []\n\n    result = find_restaurant(list1, list2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "success": true,
          "output": "['Shogun']"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "success": true,
          "output": "['sad', 'happy']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode629.json",
    "problem_index_in_file": 0,
    "title": "K Inverse Pairs Array",
    "description_snippet": "For an integer array nums, an inverse pair is a pair of integers [i, j] where 0 <= i < j < nums.leng...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for this DP problem: count arrays of length n with numbers 1..n (permutations) having exactly k inversions. Classic problem: number of permutations of n with k inversions. Use DP: dp[i][j] = number of permutations of i elements with j inversions. recurrence: dp[i][j] = sum_{x=0}^{min(j,i-1)} dp[i-1][j-x]. Use prefix sums to optimize. Then answer dp[n][k] mod MOD.\n\nWe need to produce step-by-step pseudocode line by line, with comments. Use arrows etc. Provide Start, etc. Probably include initializations, loops. Use variable names: n, k, MOD. Use dp array sized (n+1) x (k+1). Use prefix sum array.\n\nLet's produce pseudocode lines.\n\nWe'll start: Start // program starts.\n\n→ Input n, k // read input values\n\n→ Initialize MOD = 1000000007 // modulo constant\n\n→ Create 2D array dp[n+1][k+1] // dp table\n\n→ For i from 0 to n: dp[i][0] = 1 // 0 inversions with any i: 1 way (sorted)\n\n→ For i from 1 to n: // compute dp[i] from dp[i-1]\n\n    → For j from 1 to k:\n\n        → dp[i][j] = dp[i][j-1] + dp[i-1][j] // but careful? Use prefix sum method: dp[i][j] = dp[i][j-1] + dp[i-1][j] - (j>=i ? dp[i-1][j-i] : 0)\n\n        → dp[i][j] = (dp[i][j] + MOD) % MOD // ensure positive\n\nBut we also need base dp[0][0] = 1.\n\nOk.\n\nBut we must use the prefix sum logic properly.\n\nLet's write pseudocode with that recurrence.\n\nPseudo code:\n\nStart // program start\n\n→ Read n, k\n\n→ Set MOD = 1000000007\n\n→ Create 2D array dp[n+1][k+1] // all 0\n\n→ dp[0][0] = 1 // 0 elements, 0 inversions\n\n→ For i from 1 to n: // fill rows\n\n    → dp[i][0] = 1 // one sorted permutation\n\n    → For j from 1 to k:\n\n        → dp[i][j] = dp[i][j-1] + dp[i-1][j] // add permutations where new element inserted at end\n\n        → If j >= i: dp[i][j] = dp[i][j] - dp[i-1][j-i] // subtract those exceeding i-1\n\n        → dp[i][j] = (dp[i][j] + MOD) % MOD // mod and keep positive\n\n→ Output dp[n][k] // answer\n\n→ End\n\nAdd comments. Use arrow structure.\n\nLet's produce final answer with each line as \"→ Step: ... // explanation\".\n\nAlso include decision if j >= i? We can use conditional.\n\nWe might also incorporate 2D DP.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Read n, k // 取得給定的 n 與 k  \n→ Set MOD = 1000000007 // 定義模數常數  \n→ Create 2D array dp[n+1][k+1] // 初始化 dp 表，所有值預設為 0  \n→ dp[0][0] = 1 // 零個元素只有一種排列，且逆序對數為 0  \n→ For i from 1 to n: // 依序計算 i 個元素的排列數  \n    → dp[i][0] = 1 // 任何 i 個元素若逆序對數為 0，只有完全升序排列  \n    → For j from 1 to k: // 依序計算逆序對數 j  \n        → dp[i][j] = dp[i][j-1] + dp[i-1][j] // 將 i-1 個元素的排列加入第 i 個位置，累加前一個逆序對數的結果  \n        → If j >= i: dp[i][j] = dp[i][j] - dp[i-1][j-i] // 若 j 大於等於 i，需扣除超過 i-1 的情況  \n        → dp[i][j] = (dp[i][j] + MOD) % MOD // 取模，並確保數值非負  \n→ Output dp[n][k] // 取出長度為 n、逆序對數為 k 的排列數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 10**9 + 7\n\ndef count_permutations_with_k_inversions(n: int, k: int) -> int:\n    \"\"\"\n    Count the number of permutations of 1..n that contain exactly k inverse pairs.\n    Uses dynamic programming with prefix sums to achieve O(n*k) time.\n    \"\"\"\n    # dp[i][j] = number of permutations of i elements with j inversions\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # base case: empty permutation\n\n    for i in range(1, n + 1):\n        dp[i][0] = 1  # only one way to have zero inversions: sorted order\n        for j in range(1, k + 1):\n            val = dp[i][j - 1] + dp[i - 1][j]\n            if j >= i:\n                val -= dp[i - 1][j - i]\n            dp[i][j] = val % MOD\n    return dp[n][k]\n\nif __name__ == \"__main__\":\n    # Read entire input and extract all integers regardless of format\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n    else:\n        # Fallback: assume two numbers separated by whitespace\n        parts = data.strip().split()\n        n, k = int(parts[0]), int(parts[1])\n    result = count_permutations_with_k_inversions(n, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode693.json",
    "problem_index_in_file": 0,
    "title": "Binary Number with Alternating Bits",
    "description_snippet": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step with explanation, per format. We need to cover checking alternating bits for a positive integer. Steps: start, input integer, maybe compute binary string or bit manipulation. Use decision: if number is 0? maybe treat as not alternating? but spec says positive integer. So steps: compute mask pattern maybe.\n\nSimpler: While number > 0: take last bit; shift; compare with next. If same -> not alternating. Use flag.\n\nWe produce virtual code lines:\n\nStart\n→ Step 1: input n // get positive integer\n→ Step 2: lastBit = n & 1 // extract least significant bit\n→ Step 3: n = n >> 1 // shift right\n→ Step 4: while n > 0 // loop through remaining bits\n    → Decision: If n & 1 equals lastBit? // compare current bit to previous\n        Yes → Step 5: result = false // consecutive bits same\n        Yes → End // break loop early\n        No  → Step 6: lastBit = n & 1 // update previous bit\n        No  → Step 7: n = n >> 1 // shift right\n    (But we need proper arrow structure)\nWe need to show arrow indentation for nested decisions.\n\nBetter to structure:\n\nStart\n→ Step 1: Input n // 取得正整數\n→ Decision: If n == 0? // 處理零的情況\n    Yes → Step 2: Output False // 零不算有交替位\n    No  → Step 3: lastBit = n & 1 // 取最低位\n    No  → Step 4: n = n >> 1 // 右移移除已處理位\n    No  → Step 5: result = True // 預設為交替\n    No  → → Step 6: while n > 0 // 遍歷其餘位\n        No  → Decision: If (n & 1) == lastBit? // 檢查相鄰位是否相同\n            Yes → Step 7: result = False // 相同則不是交替\n            Yes → Step 8: Break // 結束迴圈\n            No  → Step 9: lastBit = n & 1 // 更新上一位\n            No  → Step 10: n = n >> 1 // 右移\n    No  → Step 11: Output result // 輸出判斷結果\nEnd\n\nWe must ensure formatting: each line starts with arrow symbol, and decisions nested. For nested arrows, maybe indent with spaces. Use \"→\" and \"Decision:\" with indentation.\n\nNeed to follow format: \"虛擬碼步驟 [空格] // 解釋\".\n\nThus each line like:\n\nStart // 程式開始執行\n\n→ Step 1: Input n // 取得正整數\n\n→ Decision: 如果 n 等於 0? // 處理零的情況\n\n    Yes → Step 2: Output False // 零不算交替位\n\n    No  → Step 3: lastBit = n & 1 // 取最低位\n\n    No  → Step 4: n = n >> 1 // 右移\n\n    No  → Step 5: result = True // 預設為交替\n\n    No  → → Step 6: while n > 0 // 開始循環\n\n        No  → Decision: 如果 (n & 1) == lastBit? // 檢查相鄰位\n\n            Yes → Step 7: result = False // 相同則不是交替\n\n            Yes → Step 8: Break // 結束循環\n\n            No  → Step 9: lastBit = n & 1 // 更新上一位\n\n            No  → Step 10: n = n >> 1 // 右移\n\n    No  → Step 11: Output result // 輸出結果\n\nEnd // 程式結束\n\nBut we need to use \"Yes →\" \"No →\" arrow formatting properly. Use 4 spaces indentation? The example shows indentation of 4 spaces before Yes/No lines. We should mimic that.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: Input n // 取得正整數\n→ Decision: 如果 n 等於 0? // 處理零的情況\n    Yes → Step 2: Output False // 零不算交替位\n    No  → Step 3: lastBit = n & 1 // 取最低位\n    No  → Step 4: n = n >> 1 // 右移\n    No  → Step 5: result = True // 預設為交替\n    No  → → Step 6: while n > 0 // 開始循環\n        No  → Decision: 如果 (n & 1) == lastBit? // 檢查相鄰位\n            Yes → Step 7: result = False // 相同則不是交替\n            Yes → Step 8: Break // 結束循環\n            No  → Step 9: lastBit = n & 1 // 更新上一位\n            No  → Step 10: n = n >> 1 // 右移\n    No  → Step 11: Output result // 輸出結果\nEnd // 程式結束\n\nNeed to ensure arrow on step6 is nested: \"→ → Step 6\" maybe with two arrows? The example uses \"→ Step 2\" etc. For nested, they use indentation and then \"→ Step 2\". For nested inside decision, they indent and use \"Yes →\" etc. For nested step after decision, you can use \"→\" as well. So Step 6: \"→ Step 6: while n > 0\" under No. So we need to indent one level deeper, with 4 spaces before \"→ Step 6\".\n\nThen inside that while, we need a decision again. So indent further 8 spaces before \"Decision:\". And then Yes/No lines indented 12 spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input n // 取得正整數  \n→ Decision: 如果 n 等於 0? // 處理零的情況  \n    Yes → Step 2: Output False // 零不算交替位  \n    No  → Step 3: lastBit = n & 1 // 取最低位  \n    No  → Step 4: n = n >> 1 // 右移移除已處理位  \n    No  → Step 5: result = True // 預設為交替  \n    No  → → Step 6: while n > 0 // 開始循環遍歷其餘位  \n        No  → Decision: 如果 (n & 1) == lastBit? // 檢查相鄰位是否相同  \n            Yes → Step 7: result = False // 相同則不是交替  \n            Yes → Step 8: Break // 結束循環  \n            No  → Step 9: lastBit = n & 1 // 更新上一位  \n            No  → Step 10: n = n >> 1 // 右移  \n    No  → Step 11: Output result // 輸出判斷結果  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hasAlternatingBits(self, n: int) -> bool:\n        \"\"\"\n        檢查整數 n 是否為交替位\n        \"\"\"\n        # 取最低位作為上一個位\n        prev_bit = n & 1\n        # 右移一位，移除已處理的位\n        n >>= 1\n        while n > 0:\n            # 取目前位\n            curr_bit = n & 1\n            # 若相鄰位相同，則不是交替位\n            if curr_bit == prev_bit:\n                return False\n            # 更新上一個位\n            prev_bit = curr_bit\n            # 右移繼續檢查\n            n >>= 1\n        return True\n\ndef parse_input(input_str: str) -> int:\n    \"\"\"\n    從輸入字串中抽取第一個整數\n    \"\"\"\n    match = re.search(r'-?\\d+', input_str)\n    if not match:\n        raise ValueError(\"未找到整數輸入\")\n    return int(match.group())\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 解析出整數 n\n    n = parse_input(raw_input)\n    # 呼叫解法\n    solution = Solution()\n    result = solution.hasAlternatingBits(n)\n    # 將結果輸出為小寫字串 'true' 或 'false'\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Use Start, Decision etc. Provide step-by-step algorithm for converting Roman numeral string to integer. Must be line by line with comment after each line. Must not output actual code. Just virtual steps. Ensure to cover input string, mapping, loop over characters, subtract logic, etc. Provide decisions: if current value < next value then subtract else add. Probably steps:\n\nStart\n→ Step 1: 定義映射表 symbol_to_value // mapping roman symbols to integer\n→ Step 2: 初始化 total = 0 // 儲存結果\n→ Step 3: 初始化 prev_value = 0 // 上一個符號的數值\n→ Step 4: 循環遍歷字符串中的每個字符（從左到右） // 逐字符處理\n→ Decision: 如果 current_value > prev_value? // 判斷是否需要減法\n    Yes → Step 5: total = total + current_value - 2 * prev_value // 減去之前已加的值並減去一次\n    No  → Step 6: total = total + current_value // 直接加\n→ Step 7: 更新 prev_value = current_value // 設置為本次值\n→ End // 完成\n\nBut also need to handle when no next symbol; but this algorithm works. Provide comments. Also need to mention string length. Provide virtual steps accordingly. Use arrows and decisions.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立符號與數值對照表 symbol_to_value = {I:1, V:5, X:10, L:50, C:100, D:500, M:1000} // 用於查表  \n→ Step 2: 取得輸入字串 roman // 需要轉換的羅馬數字  \n→ Step 3: 初始化 total = 0 // 用於累加結果  \n→ Step 4: 初始化 prev_value = 0 // 上一次處理的數值  \n→ Step 5: 從左到右遍歷 roman 的每個字符 current_char // 逐字符處理  \n→ Decision: 若 symbol_to_value[current_char] > prev_value? // 判斷是否為減法情形  \n  Yes → Step 6: total = total + symbol_to_value[current_char] - 2 * prev_value // 先把之前已加的 prev_value 復原，然後加本值  \n  No  → Step 7: total = total + symbol_to_value[current_char] // 直接加  \n→ Step 8: 設定 prev_value = symbol_to_value[current_char] // 更新為本次數值  \n→ End // 完成，total 即為對應的整數值",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        將羅馬數字字串轉換為整數。\n        \"\"\"\n        # 字符與其對應值的對照表\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0          # 結果累加器\n        prev_value = 0     # 前一個符號的數值\n\n        # 從左到右遍歷字串\n        for ch in s:\n            cur_value = roman_map[ch]          # 本符號的數值\n            if cur_value > prev_value:         # 需要減法\n                total += cur_value - 2 * prev_value\n            else:                              # 直接相加\n                total += cur_value\n            prev_value = cur_value             # 更新前一個值\n\n        return total\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    解析輸入，從 's = \"XXX\"' 形式中提取 XXX。\n    若沒有引號，直接回傳輸入內容（去除空白）。\n    \"\"\"\n    match = re.search(r'\"([^\"]*)\"', raw)\n    if match:\n        return match.group(1)\n    # 若未找到引號，可能直接是數值字串\n    return raw.strip().strip('\"').strip(\"'\")\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 解析得到羅馬數字字串\n    roman_str = parse_input(raw_input)\n    # 轉換並輸出結果\n    solution = Solution()\n    result = solution.romanToInt(roman_str)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "s = \"MCMXCIV\"",
          "expected_output": "1994",
          "success": true,
          "output": "1994"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The task: Given gas and cost arrays, find starting station index if possible to complete circuit. Classic problem: Gas station. Approach: Compute total_tank = sum(gas)-sum(cost). If negative return -1. Else track current_tank, start=0; for i 0..n-1: current_tank += gas[i] - cost[i]; if current_tank <0: start = i+1; current_tank=0. After loop, return start.\n\nWe need virtual code step by step. Provide explanation after each line. Must follow format: `Start //` etc. Use arrows. Each line: \"虛擬碼步驟 // 解釋\". Use `→` for next step.\n\nLet's produce.\n\nStart\n→ Step 1: 計算總氣量差 total = sum(gas) - sum(cost) // 先判斷是否整體氣量足夠\n    Decision: 如果 total < 0? // 若不足，無法完成一圈\n        Yes → Step 2: 回傳 -1 // 直接結束\n        No  → Step 3: 初始化變數 start = 0, current = 0 // 準備從首站開始搜尋\n→ Step 4: 從 i=0 迭代到 n-1\n    Decision: 對於每個 i，更新 current += gas[i] - cost[i] // 計算到下一站時餘氣量\n    Decision: 如果 current < 0? // 如果在此站無法往下走\n        Yes → Step 5: start = i + 1 // 將起點設為下一站\n        Yes → Step 6: current = 0 // 重置餘氣量\n        No  → No action // 如果能往下走，繼續循環\n→ Step 7: 完成循環後，回傳 start // start 為唯一可行起點\nEnd\n\nBut need to match format with each line as separate line.\n\nUse indentation for decisions and Yes/No lines.\n\nWe need to produce each line with `→` arrow maybe preceding step. For decision lines: `Decision: ...` with indentation.\n\nFollow format example. Use Start and End lines.\n\nMake sure to use Chinese.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 計算總氣量差 total = sum(gas) - sum(cost) // 先判斷整體氣量是否足夠\n    Decision: 如果 total < 0? // 若總氣量不足，無法完成一圈\n        Yes → Step 2: 回傳 -1 // 結束程式，返回 -1\n        No  → Step 3: 初始化 start = 0, current = 0 // 準備搜尋可能的起點\n→ Step 4: 從 i = 0 到 n-1 迭代\n    Decision: 更新 current += gas[i] - cost[i] // 累計從起點到 i 的剩餘氣量\n    Decision: 如果 current < 0? // 若在 i 無法往下一站\n        Yes → Step 5: start = i + 1 // 把起點移到 i 的下一站\n        Yes → Step 6: current = 0 // 重置剩餘氣量\n        No  → // 繼續迭代\n→ Step 7: 迴圈結束後，回傳 start // start 為唯一可行的起點\nEnd // 程式執行結束\n\nNeed to make sure lines are separate. Provide each line separately.\n\nWe might need to indent decision lines with spaces. But keep format similar.\n\nReturn.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算總氣量差 total = sum(gas) - sum(cost) // 先判斷整體氣量是否足夠\n    Decision: 如果 total < 0? // 若總氣量不足，無法完成一圈\n        Yes → Step 2: 回傳 -1 // 結束程式，返回 -1\n        No  → Step 3: 初始化 start = 0, current = 0 // 準備搜尋可能的起點\n→ Step 4: 從 i = 0 到 n-1 迭代\n    Decision: 更新 current += gas[i] - cost[i] // 累計從起點到 i 的剩餘氣量\n    Decision: 如果 current < 0? // 若在 i 無法往下一站\n        Yes → Step 5: start = i + 1 // 把起點移到 i 的下一站\n        Yes → Step 6: current = 0 // 重置剩餘氣量\n        No  → // 繼續迭代\n→ Step 7: 迴圈結束後，回傳 start // start 為唯一可行的起點\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        # 若總氣量不足，無法完成一圈\n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        tank = 0\n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            # 若此站無法往下走，將起點移至下一站\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中擷取 gas 與 cost 的兩個列表。\n    支援輸入類似於：\n        gas = [1,2,3,4,5], cost = [3,4,5,1,2]\n    \"\"\"\n    gas_match = re.search(r'gas\\s*=\\s*(\\[[^\\]]*\\])', text)\n    cost_match = re.search(r'cost\\s*=\\s*(\\[[^\\]]*\\])', text)\n    if not gas_match or not cost_match:\n        raise ValueError(\"輸入格式不正確\")\n    gas_str = gas_match.group(1)\n    cost_str = cost_match.group(1)\n    # 使用 ast.literal_eval 以安全方式轉成列表\n    gas = ast.literal_eval(gas_str)\n    cost = ast.literal_eval(cost_str)\n    return gas, cost\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read().strip()\n    if input_text:\n        gas_list, cost_list = parse_input(input_text)\n        solution = Solution()\n        result = solution.canCompleteCircuit(gas_list, cost_list)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for binary search to find single element. Provide step-by-step lines with comments. Ensure each line: 虛擬碼步驟 + space + // explanation. Use arrow → for steps, Decision: for conditions. Use Start, End. We need to describe algorithm in O(log n) time, O(1) space. Use binary search on index parity.\n\nLet's design pseudocode:\n\nStart\n→ Step 1: set low = 0, high = len(nums)-1\n→ Decision: 如果 low == high? // single element found\n    Yes → Step 2: return nums[low] // return the only element\n    No → Step 3: compute mid = (low + high) // 2; adjust mid to even index if odd\n→ Step 4: If nums[mid] == nums[mid+1] then pair is at mid-mid+1 else pair at mid-1-mid\n→ Decision: If pair at mid-mid+1? // left side has odd number of elements\n    Yes → Step 5: low = mid + 2 // move right\n    No  → Step 6: high = mid - 1 // move left\n→ Repeat until low == high\n\nEnd\n\nBut must produce virtual code lines with arrows. Use `→ Decision:` etc. Provide explanation each line.\n\nLet's write lines:\n\nStart // 程式開始\n→ Step 1: low = 0, high = length(nums) - 1 // 初始化搜尋區間\n→ Decision: low == high? // 若只有一個元素，已是唯一值\n    Yes → Step 2: return nums[low] // 回傳唯一元素\n    No  → Step 3: mid = (low + high) // 2 // 取得中點\n→ Decision: mid % 2 == 1? // 若 mid 為奇數，將 mid 調整為偶數\n    Yes → Step 4: mid = mid - 1 // 使 mid 為偶數\n    No  → // 直接使用 mid\n→ Decision: nums[mid] == nums[mid + 1]? // 比較偶數位與其右鄰是否相同\n    Yes → Step 5: low = mid + 2 // 唯一元素在右半部\n    No  → Step 6: high = mid - 1 // 唯一元素在左半部\n→ Go back to Decision low == high? // 重複迴圈\n\nBut need to reflect loop. We can use Start then while.\n\nBetter structure: Start, → Step: low = 0, high = n-1, → Decision: low == high? else loop.\n\nLet's craft lines sequentially. Each line includes the step or decision.\n\nWe also need to mention \"loop\" maybe using `→ Decision: low <= high?` or `→ While low < high:`. But we use arrows for each step inside loop. We can show \"→ Decision: low < high?\" then inside we do steps; after steps go back to Decision. Provide loop structure.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: low = 0, high = len(nums) - 1 // 設定搜尋範圍\n→ Decision: low == high? // 檢查是否已找到唯一元素\n    Yes → Step 2: return nums[low] // 回傳唯一元素\n    No  → // 進入搜尋迴圈\n→ Decision: low < high? // 只要範圍還有多個元素\n    Yes → Step 3: mid = (low + high) // 2 // 取中點\n→ Decision: mid % 2 == 1? // 若 mid 為奇數\n    Yes → Step 4: mid = mid - 1 // 調整為偶數\n    No  → // 保持 mid\n→ Decision: nums[mid] == nums[mid + 1]? // 判斷偶數位與右鄰是否相等\n    Yes → Step 5: low = mid + 2 // 唯一元素在右半部\n    No  → Step 6: high = mid - 1 // 唯一元素在左半部\n→ Go back to Decision: low < high? // 迴圈重複\nEnd // 程式結束\n\nBut we need to maintain loop: After Step 6, we go back to Decision low < high? The flow is correct. Provide arrow to indicate loop.\n\nLet's finalize with each line.\n\nAlso include \"→\" before each step or decision.\n\nOk produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: low = 0, high = len(nums) - 1 // 設定搜尋範圍\n→ Decision: low == high? // 檢查是否已找到唯一元素\n    Yes → Step 2: return nums[low] // 回傳唯一元素\n    No  → // 進入搜尋迴圈\n→ Decision: low < high? // 只要範圍還有多個元素就繼續\n    Yes → Step 3: mid = (low + high) // 2 // 取中點\n→ Decision: mid % 2 == 1? // 若 mid 為奇數\n    Yes → Step 4: mid = mid - 1 // 調整為偶數\n    No  → // 保持 mid\n→ Decision: nums[mid] == nums[mid + 1]? // 判斷偶數位與右鄰是否相等\n    Yes → Step 5: low = mid + 2 // 唯一元素在右半部\n    No  → Step 6: high = mid - 1 // 唯一元素在左半部\n→ Go back to Decision: low < high? // 迴圈重複檢查\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNonDuplicate(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if mid % 2 == 1:\n                mid -= 1\n            if nums[mid] == nums[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid\n        return nums[left]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    nums = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.singleNonDuplicate(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode622.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Queue",
    "description_snippet": "Design your implementation of the circular queue. The circular queue is a linear data structure in w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. It's a design of a circular queue. So virtual code: Start, initialize array size k, front=0, rear=0, count=0? Use size variable maybe. Implementation typical. Need steps: Start, Step: init array of size k, set front=0, rear=0, count=0, size=k. Then methods: isEmpty: count==0, isFull: count==size. enQueue: if full return false; else arr[rear]=value; rear=(rear+1)%size; count++ ; return true. deQueue: if empty return false; front=(front+1)%size; count-- ; return true. Front: if empty return -1 else arr[front]. Rear: if empty return -1 else arr[(rear-1+size)%size]. Also maybe a helper to mod. We need each step line. Let's produce stepwise pseudocode lines. Use Start, End. Include Decision nodes. Might include separate steps for each method but maybe treat them as separate blocks. But requirement: \"逐行地產生對應的虛擬碼\" for implementation. Probably include initialization and each method's logic. We'll present in a linear order: Start, Step 1 init, then separate method definitions? The output might be a list of steps, but might combine as code. We'll produce a linear representation of class and methods.\n\nLet's structure:\n\nStart\n→ Step 1: Create array arr[0..k-1] // 內部儲存空間\n→ Step 2: Set front = 0 // 指向隊首\n→ Step 3: Set rear = 0 // 指向隊尾\n→ Step 4: Set count = 0 // 現有元素數\n→ Step 5: Set size = k // 最大容量\n\nNow methods:\n\n// isEmpty\n→ Decision: 如果 count == 0? // 判斷空\n    Yes → Step 6: Return true // 空\n    No  → Step 7: Return false // 非空\n\n// isFull\n→ Decision: 如果 count == size? // 判斷滿\n    Yes → Step 8: Return true // 滿\n    No  → Step 9: Return false // 未滿\n\n// enQueue(value)\n→ Decision: 如果 isFull()? // 檢查是否滿\n    Yes → Step 10: Return false // 無法入列\n    No  → \n        Step 11: arr[rear] = value // 放值\n        Step 12: rear = (rear + 1) mod size // 更新後端\n        Step 13: count = count + 1 // 增加計數\n        Step 14: Return true // 成功\n\n// deQueue()\n→ Decision: 如果 isEmpty()? // 檢查是否空\n    Yes → Step 15: Return false // 無法出列\n    No  →\n        Step 16: front = (front + 1) mod size // 更新前端\n        Step 17: count = count - 1 // 減少計數\n        Step 18: Return true // 成功\n\n// Front()\n→ Decision: 如果 isEmpty()? \n    Yes → Step 19: Return -1 // 空\n    No  → Step 20: Return arr[front] // 返回首元素\n\n// Rear()\n→ Decision: 如果 isEmpty()? \n    Yes → Step 21: Return -1 // 空\n    No  →\n        Step 22: index = (rear - 1 + size) mod size // 取得尾索引\n        Step 23: Return arr[index] // 返回尾元素\n\nEnd // 程式結束\n\nWe need each line with \"虛擬碼步驟\" and comment. So each step line. Use appropriate formatting. Use arrow \"→\". Provide explanation comment after //.\n\nEnsure each line begins with either Start, Step, Decision, Yes →, No →, End. Use arrows as per sample. For decisions, indent? But just sequential lines.\n\nWe'll produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化陣列 arr[0…k-1] // 內部儲存空間  \n→ Step 2: 設定 front = 0 // 指向隊首  \n→ Step 3: 設定 rear = 0 // 指向隊尾  \n→ Step 4: 設定 count = 0 // 目前元素數量  \n→ Step 5: 設定 size = k // 最大容量  \n\n// 判斷是否為空  \n→ Decision: 如果 count == 0? // 判斷隊列是否為空  \n    Yes → Step 6: 回傳 true // 空  \n    No  → Step 7: 回傳 false // 非空  \n\n// 判斷是否已滿  \n→ Decision: 如果 count == size? // 判斷隊列是否已滿  \n    Yes → Step 8: 回傳 true // 滿  \n    No  → Step 9: 回傳 false // 未滿  \n\n// 插入元素  \n→ Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Step 10: 回傳 false // 無法入列  \n    No  →  \n        Step 11: arr[rear] = value // 將值放入隊尾位置  \n        Step 12: rear = (rear + 1) mod size // 更新 rear 為新尾  \n        Step 13: count = count + 1 // 增加元素數量  \n        Step 14: 回傳 true // 成功插入  \n\n// 刪除元素  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Step 15: 回傳 false // 無法出列  \n    No  →  \n        Step 16: front = (front + 1) mod size // 更新 front 為新頭  \n        Step 17: count = count - 1 // 減少元素數量  \n        Step 18: 回傳 true // 成功刪除  \n\n// 取得隊首元素  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Step 19: 回傳 -1 // 空  \n    No  → Step 20: 回傳 arr[front] // 回傳隊首值  \n\n// 取得隊尾元素  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Step 21: 回傳 -1 // 空  \n    No  →  \n        Step 22: index = (rear - 1 + size) mod size // 計算實際尾索引  \n        Step 23: 回傳 arr[index] // 回傳隊尾值  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyCircularQueue:\n    def __init__(self, k: int):\n        self.queue = [0] * k\n        self.head = -1\n        self.tail = -1\n        self.size = k\n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        if self.isEmpty():\n            self.head = 0\n        self.tail = (self.tail + 1) % self.size\n        self.queue[self.tail] = value\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        if self.head == self.tail:\n            self.head = self.tail = -1\n        else:\n            self.head = (self.head + 1) % self.size\n        return True\n\n    def Front(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self):\n        if self.isEmpty():\n            return -1\n        return self.queue[self.tail]\n\n    def isEmpty(self) -> bool:\n        return self.head == -1\n\n    def isFull(self) -> bool:\n        return (self.tail + 1) % self.size == self.head\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit(0)\n\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularQueue\":\n            obj = MyCircularQueue(arg[0])\n            results.append(None)\n        else:\n            method = getattr(obj, op)\n            if arg:\n                res = method(*arg)\n            else:\n                res = method()\n            results.append(res)\n\n    # Convert results to JSON-like string\n    output_parts = []\n    for r in results:\n        if r is None:\n            output_parts.append(\"null\")\n        elif isinstance(r, bool):\n            output_parts.append(\"true\" if r else \"false\")\n        else:\n            output_parts.append(str(r))\n    output_str = \"[\" + \", \".join(output_parts) + \"]\"\n    print(output_str)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"enQueue\", \"Rear\", \"isFull\", \"deQueue\", \"enQueue\", \"Rear\"]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 3, true, true, true, 4]",
          "success": true,
          "output": "[null, true, true, true, false, 3, true, true, true, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, decisions. It's like a flowchart. We need to generate combinations of well-formed parentheses. So algorithm: backtracking. Steps: Start, define function generateParenthesis(n). Inside, result list. Define backtrack(s, open, close). If open==n and close==n: add s. Else: if open < n: backtrack(s+'(', open+1, close). If close < open: backtrack(s+')', open, close+1). End. Return result. End. Also maybe call with n. We'll output as virtual code.\n\nWe need to keep line numbering? Not required, but each line separate. Use arrows. Let's craft. Use \"Start\", \"End\". For recursion, use \"→\" arrows.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Function: generateParenthesis(n) // 定義主函式，接收括號數 n\n    → 初始化 result 為空列表 // 存儲所有合法組合\n    → 定義回溯函式 backtrack(s, open, close) // s 為目前串，open close 計數\n        → Decision: 若 open==n AND close==n? // 是否已用完所有括號\n            Yes → Append s 到 result // 完整合法組合加入結果\n            No → Decision: 若 open < n? // 還可以加入 '('\n                Yes → backtrack(s+'(', open+1, close) // 加 '(' 進行遞迴\n                No  → Decision: 若 close < open? // 可以加入 ')'\n                    Yes → backtrack(s+')', open, close+1) // 加 ')' 進行遞迴\n                    No  → // 兩條路均不可行，回溯結束\n        // 回溯結束後返回上層\n    → 呼叫 backtrack(\"\", 0, 0) // 開始回溯\n    → Return result // 回傳所有組合\nEnd // 程式結束\n\nBut we need arrow lines. Use \"→\" at each step. For nested we indent. Let's produce.\n\nMake sure each line ends with // 解釋. Use Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function: generateParenthesis(n) // 定義主函式，輸入括號對數 n  \n → Initialize result ← [] // 建立結果列表  \n → Define backtrack(s, open, close) // s 為目前字串，open/close 為已使用 '(' 與 ')' 的數量  \n  → Decision: open == n AND close == n? // 檢查是否已使用完所有括號  \n   Yes → Append s to result // 若完整，加入結果  \n   No → Decision: open < n? // 還可再加 '('  \n    Yes → backtrack(s + '(', open + 1, close) // 加 '(' 並遞迴  \n    No  → Decision: close < open? // 可否加 ')'  \n     Yes → backtrack(s + ')', open, close + 1) // 加 ')' 並遞迴  \n     No  → // 兩條路都不可行，回溯結束  \n → Call backtrack(\"\", 0, 0) // 開始回溯  \n→ Return result // 回傳所有合法組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\ndef generate_parentheses(n: int) -> list[str]:\n    \"\"\"\n    產生 n 組括號的所有合法排列。\n    \"\"\"\n    result = []\n\n    def backtrack(s: str = \"\", left: int = 0, right: int = 0) -> None:\n        \"\"\"\n        透過遞迴回溯建構所有合法字串。\n        s      : 當前已構造的字串\n        left   : 已放置 '(' 的數量\n        right  : 已放置 ')' 的數量\n        \"\"\"\n        if left == n and right == n:          # 已完成所有括號\n            result.append(s)\n            return\n        if left < n:                          # 還可以再加 '('\n            backtrack(s + \"(\", left + 1, right)\n        if right < left:                      # 只有左括號多時才可加 ')'\n            backtrack(s + \")\", left, right + 1)\n\n    backtrack()\n    return result\n\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取 n，計算結果並輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取第一個整數作為 n，支援 'n = 3'、'3' 等多種輸入格式\n    numbers = re.findall(r\"\\d+\", data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    combos = generate_parentheses(n)\n    # 以 JSON 方式輸出，符合範例的雙引號與無空格格式\n    print(json.dumps(combos))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "[\"()\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step. Requirements: each line \"虛擬碼步驟\" then space then comment. Use arrow notation. Should reflect algorithm to check duplicates. Approach: Use a set, iterate, check existence. Pseudocode. Each line step. Let's produce. Use Start, End, Decision. Let's produce lines:\n\nStart // ...\n→ Step 1: 建立空集合 seen // ...\n→ Step 2: 對於 nums 中每個元素 num // ...\n→ Decision: 若 num 已在 seen? // ...\n    Yes → Return true // 有重複\n    No  → Step 3: 加入 num 至 seen // ...\n→ Step 4: 迴圈結束 // ...\n→ Step 5: Return false // 無重複\nEnd // ...\n\nBut need to be line by line. Ensure each line has \"虛擬碼步驟\" maybe like \"→ Step ...\". Let's format each line as:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 seen // 初始化空集合以儲存已見過的元素\n→ Step 2: 對於每個元素 num 於 nums // 遍歷整個陣列\n    → Decision: 若 num 已存在於 seen? // 檢查是否已見過\n        Yes → Step 3: 回傳 true // 找到重複，直接回傳\n        No  → Step 4: 將 num 加入 seen // 未見過，加入集合\n→ Step 5: 迴圈結束 // 所有元素已檢查\n→ Step 6: 回傳 false // 沒有重複，回傳假\nEnd // 程式執行結束\n\nBut ensure each line separate. Indent decisions maybe within line? The example shows indentation. Let's replicate.\n\nWe need to put each line separate. Let's produce as:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 seen // 初始化空集合以儲存已見過的元素\n→ Step 2: 對於每個元素 num 於 nums // 遍歷整個陣列\n    → Decision: 若 num 已存在於 seen? // 檢查是否已見過\n        Yes → Step 3: 回傳 true // 找到重複，直接回傳\n        No  → Step 4: 將 num 加入 seen // 未見過，加入集合\n→ Step 5: 迴圈結束 // 所有元素已檢查\n→ Step 6: 回傳 false // 沒有重複，回傳假\nEnd // 程式執行結束\n\nMake sure each line has a comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 seen // 初始化空集合以儲存已見過的元素  \n→ Step 2: 對於每個元素 num 於 nums // 遍歷整個陣列  \n    → Decision: 若 num 已存在於 seen? // 檢查是否已見過  \n        Yes → Step 3: 回傳 true // 找到重複，直接回傳  \n        No  → Step 4: 將 num 加入 seen // 未見過，加入集合  \n→ Step 5: 迴圈結束 // 所有元素已檢查  \n→ Step 6: 回傳 false // 沒有重複，回傳假  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def containsDuplicate(self, nums):\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    start = data.find('[')\n    if start == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[start:])\n    result = Solution().containsDuplicate(nums)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, explaining. Use the format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. The logic: find added letter. Approach: XOR all char codes, or count frequency. Virtual code: start, compute sum XOR of s and t, etc. But we should produce step-by-step explanation.\n\nWe need to use Start, End, Decision. Let's craft:\n\nStart // Begin\n→ Step 1: Initialize variable added = 0 // store XOR result\n→ Decision: Iterate over string s and t? We can compute XOR across both.\n\nWe can create steps: compute XOR of all characters in s and t. Then the result is the added letter. Explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Set added = 0 // 用來累積 XOR 結果\n→ Step 2: For each character ch in s: added ← added XOR ch // 把 s 的每個字元 XOR 進結果\n→ Step 3: For each character ch in t: added ← added XOR ch // 把 t 的每個字元 XOR 進結果\n→ Step 4: The variable added now holds the ASCII code of the extra character // XOR 兩個相同字元相抵消，剩下新增字元\n→ Decision: If added == 0? // 檢查是否有錯誤\n    Yes → Step 5: Return error // 沒有新增字元或輸入錯誤\n    No  → Step 6: Convert added to character and return it // 將 ASCII 轉成字元輸出\nEnd // 程式執行結束\n\nBut we need to follow format with arrow lines. Use \"→\". Use \"Decision:\" lines with Yes →, No →. Let's produce.\n\nAlso maybe use loop structure: \"Decision: 迴圈結束?\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定變數 added ← 0 // 用來累積 XOR 結果  \n→ Step 2: Decision: 是否已遍歷完 s?  \n    No  → Step 3: 取得 s 的下一個字元 ch  \n    → Step 4: added ← added XOR ch // 把 s 的字元加入 XOR  \n    → Step 5: 回到 Decision: 是否已遍歷完 s?  \n→ Decision: 是否已遍歷完 t?  \n    No  → Step 6: 取得 t 的下一個字元 ch  \n    → Step 7: added ← added XOR ch // 把 t 的字元加入 XOR  \n    → Step 8: 回到 Decision: 是否已遍歷完 t?  \n→ Step 9: added 目前是多出字元的 ASCII 代碼 // XOR 兩相同字元會抵消  \n→ Decision: added 等於 0? // 檢查是否有錯誤  \n    Yes → Step 10: 回傳錯誤訊息 // 沒有新增字元或輸入不符  \n    No  → Step 11: 將 added 轉為字元並回傳 // 取得多出的字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_the_difference(s: str, t: str) -> str:\n    \"\"\"\n    以 XOR 的方式找出在 t 中多出的那一個字元。\n    因為 s 的字元在 t 中恰好出現一次，兩個相同的字元 XOR 會抵消。\n    最終 XOR 的結果就是新增字元的 ASCII 代碼。\n    \"\"\"\n    xor_val = 0\n    for ch in s:\n        xor_val ^= ord(ch)\n    for ch in t:\n        xor_val ^= ord(ch)\n    return chr(xor_val)\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：\n    1. 讀取整個標準輸入。\n    2. 從輸入字串中解析出 s 與 t。\n    3. 呼叫 find_the_difference 取得答案。\n    4. 將答案以「\"字元\"」的形式印出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n\n    # 先嘗試匹配「s = \"abcd\", t = \"abcde\"」格式\n    pattern = r's\\s*=\\s*\"([^\"]*)\",\\s*t\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n\n    if not match:\n        # 如果輸入中沒有空格，也嘗試去除空格後再匹配\n        stripped = data.replace(\" \", \"\")\n        match = re.search(pattern, stripped)\n\n    if match:\n        s, t = match.group(1), match.group(2)\n    else:\n        # 若以上都失敗，假設輸入是兩行或簡化格式\n        # 先按逗號切割，然後取等號右邊的字串\n        parts = [p.strip() for p in data.split(',')]\n        s = parts[0].split('=')[1].strip().strip('\"')\n        t = parts[1].split('=')[1].strip().strip('\"')\n\n    result = find_the_difference(s, t)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "\"e\""
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "\"y\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudocode for Dutch national flag problem. They want step-by-step lines with comments. Use the specified format. Let's produce steps. We'll use pointers low, mid, high. Let's create algorithm. Use \"Start\" and \"End\". We'll use decision statements with Yes and No arrows.\n\nWe'll write in Chinese. Provide brief explanations. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low = 0, mid = 0, high = n-1 // 設定三個指標，分別指向紅色、白色、藍色區域的邊界  \n→ Decision: 是否 mid <= high? // 判斷是否還有未處理的元素  \n    Yes → Decision: nums[mid] 的值  \n        0 → Step 2: 交換 nums[low] 與 nums[mid] // 把紅色放到左側  \n            → low = low + 1 // 移動紅色區域右邊界  \n            → mid = mid + 1 // 繼續向右處理  \n        1 → Step 3: mid = mid + 1 // 白色保持在中間，直接向右移動  \n        2 → Step 4: 交換 nums[mid] 與 nums[high] // 把藍色放到右側  \n            → high = high - 1 // 移動藍色區域左邊界  \n            // mid 不變，因為交換後的元素還未被分類  \n    No → End // 所有元素已分類，程式執行結束\n\nEnd // 程式結束。",
      "generated_code": "import sys\nimport ast\n\ndef sort_colors(nums):\n    \"\"\"\n    Rearrange nums in-place so that 0s come first, then 1s, then 2s.\n    This is the Dutch national flag algorithm.\n    \"\"\"\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:  # nums[mid] == 2\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1\n\nif __name__ == \"__main__\":\n    # Read the whole input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Find the list part between '[' and ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        # Invalid format\n        sys.exit()\n\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        sys.exit()\n\n    # Ensure we have a list of integers\n    if not isinstance(nums, list):\n        sys.exit()\n\n    sort_colors(nums)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0, 0, 1, 1, 2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding kth smallest element in sorted matrix. Approach: binary search on value range, counting <= mid by scanning each row starting from bottom left. Complexity O(n^2 log(max-min)). Memory O(1). We'll write virtual code steps line by line.\n\nNeed to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure.\n\nWe need to include Start, End, Decision.\n\nLet's outline:\n\nStart\n→ Step 1: 初始化 low = matrix[0][0], high = matrix[n-1][n-1] // min and max\n→ Decision: low < high? // loop\n    Yes → Step 2: mid = (low + high) // 2 // mid value\n    → Step 3: count = 0, row = n-1, col = 0 // start bottom-left\n    → While row >= 0 AND col < n: // count numbers <= mid\n        If matrix[row][col] <= mid:\n            count += row + 1\n            col += 1\n        Else:\n            row -= 1\n    → Decision: count >= k? // if enough elements <= mid\n        Yes → high = mid\n        No  → low = mid + 1\n    → Decision: low < high? // repeat\n        Yes → (loop)\n        No  → Step 4: return low // kth smallest\nEnd\n\nNeed to use arrow syntax: \"→\" for steps, \"Decision:\" with Yes→, No→.\n\nAlso incorporate while loop inside steps. Use indentation maybe. Format examples show indentation under Decision. We'll follow same.\n\nWe'll produce lines with \"Step X: ...\" etc.\n\nWe should not output code but virtual code. So use generic names: \"Step X\". We'll produce as described.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← matrix[0][0] // 設定最小值為矩陣左上角  \n→ Step 2: high ← matrix[n-1][n-1] // 設定最大值為矩陣右下角  \n→ Decision: low < high? // 檢查是否還需要進一步搜尋  \n  Yes → Step 3: mid ← (low + high) / 2 // 取目前範圍中間值  \n  → Step 4: count ← 0, row ← n-1, col ← 0 // 初始化計數器與指標（從左下角開始）  \n  → While row ≥ 0 AND col < n: // 遍歷矩陣以計算 ≤ mid 的元素個數  \n    If matrix[row][col] ≤ mid:  \n      count ← count + row + 1 // 本列所有元素 ≤ mid，累加行號+1  \n      col ← col + 1 // 移到下一列的同一列號  \n      Else:  \n       row ← row - 1 // 移到上一列  \n  → Decision: count ≥ k? // 判斷目前 mid 是否足夠包含 k 個元素  \n    Yes → high ← mid // 需要更小的上界，縮小範圍  \n    No  → low ← mid + 1 // 需要更大的下界，調整下界  \n  → Decision: low < high? // 再次判斷是否完成  \n    Yes → (回到 Decision)  \n    No  → Step 5: return low // low 為第 k 小的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef kth_smallest(matrix, k):\n    \"\"\"Return the k-th smallest element in a sorted matrix using value binary search.\"\"\"\n    n = len(matrix)\n    low = matrix[0][0]\n    high = matrix[-1][-1]\n\n    while low < high:\n        mid = (low + high) // 2\n        # Count numbers <= mid\n        count = 0\n        row, col = n - 1, 0\n        while row >= 0 and col < n:\n            if matrix[row][col] <= mid:\n                count += row + 1\n                col += 1\n            else:\n                row -= 1\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\ndef main():\n    data = sys.stdin.read()\n    # Extract matrix and k using regex\n    matrix_match = re.search(r'matrix\\s*=\\s*(\\[[\\s\\[\\],\\-0-9]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not matrix_match or not k_match:\n        raise ValueError(\"Input format incorrect. Expected 'matrix = ... , k = ...'\")\n    matrix_str = matrix_match.group(1)\n    k = int(k_match.group(1))\n    matrix = ast.literal_eval(matrix_str)\n\n    result = kth_smallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": true,
          "output": "13"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": true,
          "output": "-5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps, line by line with // explanation. Algorithm: Use bucket sort approach to find max gap in linear time. Steps: handle less than 2 elements; find min and max; compute bucket size; allocate buckets with min and max; fill buckets; compute max gap by iterating over buckets. Use linear extra space.\n\nWe must produce step lines with arrow →, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End.\n\nLet's outline:\n\nStart\n→ Decision: if length(nums) < 2? // check\n    Yes → Step: return 0 // less than 2 elements\n    No → Step: Find min, max // compute min, max\n→ Decision: if min == max? // all equal\n    Yes → Step: return 0\n    No → Step: bucket_size = max(1, (max - min) // (n-1)) // compute bucket size\n→ Step: bucket_count = (max - min) // bucket_size + 1 // number of buckets\n→ Step: Create arrays bucket_min[bucket_count] init INF, bucket_max[bucket_count] init -INF, bucket_has[bucket_count] init false // bucket info\n→ Step: For each num in nums:\n    idx = (num - min) // bucket_size // bucket index\n    bucket_has[idx] = true\n    bucket_min[idx] = min(num, bucket_min[idx]) // update\n    bucket_max[idx] = max(num, bucket_max[idx]) // update\n→ Step: max_gap = 0, prev = min // prev max of previous non-empty bucket\n→ Step: For i from 0 to bucket_count-1:\n    If bucket_has[i]:\n        gap = bucket_min[i] - prev\n        max_gap = max(max_gap, gap)\n        prev = bucket_max[i]\n→ End return max_gap\n\nNeed to format each line.\n\nLet's produce lines: Start // ... ; → Decision: ... ; Yes → ... ; No → ... ; etc.\n\nAlso after each line, explanation.\n\nWe need to use virtual code arrow format. Each line separate.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Decision: nums.length < 2? // 檢查陣列是否少於兩個元素\n    Yes → Step: return 0 // 直接返回 0\n    No  → Step: Compute min and max of nums // 找出最小值和最大值\n→ Decision: min == max? // 判斷所有元素是否相同\n    Yes → Step: return 0 // 若相同則最大間距為 0\n    No  → Step: bucketSize = max(1, (max - min) // (n-1)) // 計算桶的大小\n→ Step: bucketCount = (max - min) // bucketSize + 1 // 計算桶的數量\n→ Step: Create arrays bucketMin[bucketCount] 初始化為 +∞, bucketMax[bucketCount] 初始化為 -∞, bucketHas[bucketCount] 初始化為 false // 初始化桶資訊\n→ Step: For each num in nums:\n    idx = (num - min) // bucketSize // 取得 num 所屬的桶索引\n    bucketHas[idx] = true // 標記該桶已被填充\n    bucketMin[idx] = min(num, bucketMin[idx]) // 更新桶內最小值\n    bucketMax[idx] = max(num, bucketMax[idx]) // 更新桶內最大值\n→ Step: maxGap = 0, prev = min // 設置初始前一個桶的最大值為 min\n→ Step: For i from 0 to bucketCount-1:\n    If bucketHas[i]:\n        gap = bucketMin[i] - prev // 計算當前桶與前一桶之間的距離\n        maxGap = max(maxGap, gap) // 更新最大間距\n        prev = bucketMax[i] // 將 prev 更新為當前桶的最大值\n→ End // 結束程式\n\nNeed to maintain format: each line with 虛擬碼步驟 + // explanation. For decision, we must indent Yes / No lines properly.\n\nMake sure each line is separate. Use \"→ Decision: ...\" then indent Yes/No lines. Use \"Yes → ...\" \"No  → ...\".\n\nAlso inside For loops, we can use \"→ Step: For each num in nums:\" etc. Then lines inside loop indented with spaces.\n\nWe should produce exactly lines. Ensure \"Start\" \"End\" lines too.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums.length < 2? // 檢查陣列是否少於兩個元素  \n Yes → Step: return 0 // 直接返回 0  \n No  → Step: Compute min and max of nums // 找出最小值和最大值  \n→ Decision: min == max? // 判斷所有元素是否相同  \n Yes → Step: return 0 // 若相同則最大間距為 0  \n No  → Step: bucketSize = max(1, (max - min) // (n-1)) // 計算桶的大小  \n→ Step: bucketCount = (max - min) // bucketSize + 1 // 計算桶的數量  \n→ Step: Create arrays bucketMin[bucketCount] 初始化為 +∞, bucketMax[bucketCount] 初始化為 -∞, bucketHas[bucketCount] 初始化為 false // 初始化桶資訊  \n→ Step: For each num in nums: // 遍歷所有元素  \n  idx = (num - min) // bucketSize // 取得 num 所屬的桶索引  \n  bucketHas[idx] = true // 標記該桶已被填充  \n  bucketMin[idx] = min(num, bucketMin[idx]) // 更新桶內最小值  \n  bucketMax[idx] = max(num, bucketMax[idx]) // 更新桶內最大值  \n→ Step: maxGap = 0, prev = min // 設置初始前一個桶的最大值為 min  \n→ Step: For i from 0 to bucketCount-1: // 遍歷所有桶  \n  If bucketHas[i]: // 若該桶非空  \n   gap = bucketMin[i] - prev // 計算當前桶與前一桶之間的距離  \n   maxGap = max(maxGap, gap) // 更新最大間距  \n   prev = bucketMax[i] // 將 prev 更新為當前桶的最大值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maximumGap(self, nums):\n        n = len(nums)\n        if n < 2:\n            return 0\n\n        min_val = min(nums)\n        max_val = max(nums)\n        if min_val == max_val:\n            return 0\n\n        # Bucket size (ceil of average gap)\n        bucket_size = max(1, (max_val - min_val) // (n - 1))\n        bucket_count = (max_val - min_val) // bucket_size + 1\n\n        bucket_min = [float('inf')] * bucket_count\n        bucket_max = [float('-inf')] * bucket_count\n        bucket_has = [False] * bucket_count\n\n        # Place each number into a bucket\n        for num in nums:\n            idx = (num - min_val) // bucket_size\n            bucket_has[idx] = True\n            if num < bucket_min[idx]:\n                bucket_min[idx] = num\n            if num > bucket_max[idx]:\n                bucket_max[idx] = num\n\n        # Scan buckets to find maximum gap\n        max_gap = 0\n        prev_max = min_val\n        for i in range(bucket_count):\n            if not bucket_has[i]:\n                continue\n            gap = bucket_min[i] - prev_max\n            if gap > max_gap:\n                max_gap = gap\n            prev_max = bucket_max[i]\n\n        return max_gap\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Input format may be like \"nums = [3,6,9,1]\"\n    if '=' in data:\n        _, nums_part = data.split('=', 1)\n    else:\n        nums_part = data\n    nums_part = nums_part.strip()\n    try:\n        nums = ast.literal_eval(nums_part)\n    except Exception:\n        nums = []\n\n    result = Solution().maximumGap(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanations. Use arrow lines, Start, End, Decision.\n\nWe need to solve intersection of two integer arrays with duplicates count. Steps: Build frequency map of nums1, iterate nums2, reduce count, collect result.\n\nWe should produce each line of virtual code, e.g., Start, then Step 1: Build frequency map for nums1. Use Map/Hash. Then Step 2: Iterate nums2, check if element in map > 0, then add to result and decrement. Then End.\n\nNeed to use arrows: →, Decision: ... Yes→ etc.\n\nLet's produce virtual code accordingly. Use 'Step X: ...' format. Provide explanation after //. Should be one line per step. Include decisions? For checking if element exists. Provide Decision line.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化一個空字典 freq // 用於存放 nums1 中每個數字的出現次數\n→ Step 2: 對 nums1 的每個元素 val\n    → Decision: 是否已在 freq? // 檢查字典中是否已有此鍵\n        Yes → freq[val] = freq[val] + 1 // 已有，次數加一\n        No  → freq[val] = 1           // 沒有，新增鍵並設為 1\n→ Step 3: 初始化空列表 result // 用於儲存交集元素\n→ Step 4: 對 nums2 的每個元素 val\n    → Decision: freq[val] > 0? // 檢查該元素在 nums1 中是否還有剩餘\n        Yes → result.add(val) // 添加到結果\n              freq[val] = freq[val] - 1 // 次數減一\n        No  → // 跳過，該元素不在交集中\n→ End\n\nWe need to use arrow indentation maybe? In example, they used indentation for nested decisions. Provide that. Each line must be a single line with arrow and step. But nested lines maybe considered separate lines? They had indentation with arrows: \n```\nDecision: ...\n    Yes → Step ...\n    No → Decision: ...\n```\nThus we should produce similar structure: Indent nested lines. Use spaces before arrows for clarity.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 freq // 用來記錄 nums1 中每個數字出現的次數  \n→ Step 2: 對 nums1 的每個元素 val  \n    → Decision: freq 中是否已存在 key val? // 檢查此數字是否已被統計  \n        Yes → freq[val] = freq[val] + 1 // 已存在，次數加一  \n        No  → freq[val] = 1           // 未存在，新增鍵並設為 1  \n→ Step 3: 初始化空列表 result // 用來儲存最終的交集元素  \n→ Step 4: 對 nums2 的每個元素 val  \n    → Decision: freq[val] > 0? // 判斷 nums1 中是否還有此數字可用  \n        Yes → result.add(val)        // 加入交集  \n              freq[val] = freq[val] - 1 // 次數減一，避免重複使用  \n        No  → // 此數字不在交集中，跳過  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # 建立 nums1 每個元素的頻率字典\n        freq = Counter(nums1)\n        result = []\n\n        # 遍歷 nums2，若 freq 內仍有該元素，加入結果並遞減頻率\n        for num in nums2:\n            if freq.get(num, 0) > 0:\n                result.append(num)\n                freq[num] -= 1\n\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    從輸入文字中擷取兩個列表。\n    例：'nums1 = [1,2,2,1], nums2 = [2,2]' 會回傳 ([1,2,2,1], [2,2])\n    \"\"\"\n    # 找出兩個方括號內的子字串\n    brackets = re.findall(r'\\[.*?\\]', text)\n    if len(brackets) != 2:\n        raise ValueError(\"輸入格式不正確，無法找到兩個列表。\")\n    nums1 = ast.literal_eval(brackets[0])\n    nums2 = ast.literal_eval(brackets[1])\n    return nums1, nums2\n\ndef main():\n    # 讀取標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    nums1, nums2 = parse_input(raw_input)\n\n    solution = Solution()\n    intersection = solution.intersect(nums1, nums2)\n\n    # 輸出結果\n    print(intersection)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode691.json",
    "problem_index_in_file": 0,
    "title": "Stickers to Spell Word",
    "description_snippet": "We are given n different types of stickers. Each sticker has a lowercase English word on it.\nYou wou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to solve this problem: Minimum number of stickers to form target. Classic LeetCode problem \"Stickers to Spell Word\". Approach: Use DP over subsets or BFS with memoization, or recursion with bitmasking. But since target can be up to maybe 15 letters (two random words), we can do DP over bitmask of letters positions. But simpler: Use DFS with memo, try each sticker to reduce target string. Use character counts. Approach: For each sticker, subtract counts from target, produce new remaining string; recursion; memoization.\n\nWe need virtual code steps line by line, each line with explanation comment. Use arrow syntax. Start, End, Decision. Should produce step by step algorithm description.\n\nWe'll produce pseudo-code steps:\n\nStart\n→ Step 1: Preprocess stickers to array of count maps // convert each sticker word to 26-letter frequency\n→ Step 2: Define recursive function solve(rem) // rem is string\n    → Decision: If rem empty? // base case\n        Yes → Return 0 // no more stickers needed\n    → Decision: If rem in memo? // reuse\n        Yes → Return memo[rem]\n    → Initialize minStickers to INF\n    → For each stickerCount in stickerCounts:\n        → Decision: Does sticker contain at least one char of rem? // skip if no effect\n            Yes → Construct newRem by removing chars of stickerCount from rem // compute remaining string\n            → Recursively call solve(newRem) → If result != -1:\n                → Update minStickers = min(minStickers, 1 + result)\n    → After loop:\n        → Decision: If minStickers == INF? // no sticker can help\n            Yes → memo[rem] = -1\n            No  → memo[rem] = minStickers\n    → Return memo[rem]\n→ Call solve(target) // get answer\n→ End\n\nBut we need to break into lines with arrows and decision lines. Let's produce each step as line.\n\nWe must keep format: \"虛擬碼步驟 [space] // 解釋\". Use Start, End. Decision lines with \"Decision: ...\". Indent with tab? Not required. Use \"→\" arrow for normal steps, \"Decision:\" lines separate. For loops maybe we use \"→ For each ...\". Use \"→ If\" lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ 虛擬碼: 將 stickers 轉成 26 個字母頻率陣列 // 方便後續計算\n→ 虛擬碼: 建立空 memo 以備遞迴快取 // 避免重複計算\n→ 虛擬碼: 定義遞迴函式 solve(rem) // 參數 rem 為剩餘未完成的目標字串\n    → Decision: rem 是否為空？ // 基本情況\n        Yes → Return 0 // 已拼完，無需再用貼紙\n    → Decision: rem 是否已在 memo？ // 快取\n        Yes → Return memo[rem] // 直接回傳已計算結果\n    → 虛擬碼: minStickers = INF // 初始化最小貼紙數\n    → 虛擬碼: 對每一張貼紙的頻率陣列 sticker\n        → Decision: sticker 是否能減少 rem？ // 至少有一個字母可被使用\n            Yes → 虛擬碼: newRem = rem 減去 sticker 的字母頻率 // 計算剩餘字串\n            → 虛擬碼: res = solve(newRem) // 進一步遞迴\n            → Decision: res 是否可行？ // res != -1\n                Yes → minStickers = min(minStickers, 1 + res) // 更新最小貼紙數\n    → Decision: minStickers 是否仍為 INF？ // 無貼紙能進行\n        Yes → memo[rem] = -1 // 標記為不可完成\n        No  → memo[rem] = minStickers // 儲存最小貼紙數\n    → Return memo[rem]\n→ 虛擬碼: result = solve(target) // 取得最終答案\n→ 虛擬碼: 如果 result == -1? // 代表無法拼出\n    Yes → 輸出 -1\n    No  → 輸出 result\nEnd // 程式結束\n\nBut we need each line separately, including decision lines as separate lines. The arrows at each step. Also indent the decision branches? The sample uses indentation for branches. We can mimic that. Use tab or spaces before sub-lines. Use \"→\" arrow for each statement. For decision we write \"→ Decision: ...\". For branch lines we indent with tab and use \"Yes →\" or \"No →\" then step.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ 虛擬碼: stickersFreq ← 空陣列 // 用於儲存每張貼紙的 26 字母頻率  \n→ 虛擬碼: for each sticker in stickers  \n  → 虛擬碼: freq ← 26 整數陣列全部為 0 // 初始化字母計數  \n  → 虛擬碼: for each char c in sticker  \n    → 虛擬碼: freq[c]++ // 計算該貼紙字母出現次數  \n  → 虛擬碼: stickersFreq.append(freq) // 加入頻率陣列  \n→ 虛擬碼: memo ← 空字典 // 用於快取子問題結果  \n→ 虛擬碼: 定義函式 solve(rem) // rem 為尚未完成的目標字串  \n  → Decision: rem 是否為空？  \n    Yes → Return 0 // 已完成，無需貼紙  \n    No →  \n     → Decision: rem 是否存在於 memo？  \n      Yes → Return memo[rem] // 回傳快取結果  \n      No →  \n       → 虛擬碼: minStickers ← ∞ // 初始化最小貼紙數  \n       → 虛擬碼: for each freq in stickersFreq  \n         → Decision: freq 能否幫助 rem？（至少有一個字母可減少）  \n          Yes →  \n            → 虛擬碼: newRem ← rem 減去 freq 的字母頻率  \n            → 虛擬碼: res ← solve(newRem) // 進一步遞迴  \n            → Decision: res 是否可行？（res ≠ -1）  \n             Yes → minStickers ← min(minStickers, 1 + res) // 更新最小貼紙數  \n             No → // 無效貼紙，略過  \n           No → // 這張貼紙對 rem 沒有效用，略過  \n        → Decision: minStickers 是否仍為 ∞？  \n         Yes → memo[rem] ← -1 // 代表無法完成  \n         No  → memo[rem] ← minStickers // 儲存最小貼紙數  \n       → Return memo[rem]  \n→ 虛擬碼: result ← solve(target) // 取得最終答案  \n→ Decision: result 是否為 -1？  \n  Yes → 虛擬碼: 輸出 -1 // 目標字串不可拼出  \n  No  → 虛擬碼: 輸出 result // 最小貼紙數  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def minStickers(self, stickers, target):\n        sticker_counts = [Counter(st) for st in stickers]\n        memo = {}\n\n        def dp(t):\n            if t == \"\":\n                return 0\n            if t in memo:\n                return memo[t]\n            t_count = Counter(t)\n            best = float(\"inf\")\n            for sc in sticker_counts:\n                if t[0] not in sc:\n                    continue\n                # 將貼紙 sc 用一次後剩下的字串\n                remaining = []\n                for ch in t_count:\n                    left = t_count[ch] - sc.get(ch, 0)\n                    if left > 0:\n                        remaining.append(ch * left)\n                new_t = \"\".join(remaining)\n                sub = dp(new_t)\n                if sub != -1:\n                    best = min(best, 1 + sub)\n            memo[t] = -1 if best == float(\"inf\") else best\n            return memo[t]\n\n        return dp(target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，支援 stickers = [\"a\",\"b\"], target = \"c\" 或 stickers = ['a','b'], target = 'c'\n    m = re.search(r'stickers\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*[\"\\']([^\"\\']*)[\"\\']', data)\n    if not m:\n        # 若格式不符，嘗試直接 eval 兩個變數\n        try:\n            parts = eval(data, {}, {})\n            stickers = parts.get('stickers', [])\n            target = parts.get('target', '')\n        except Exception:\n            print(-1)\n            return\n    else:\n        stickers = ast.literal_eval(m.group(1))\n        target = m.group(2)\n\n    sol = Solution()\n    ans = sol.minStickers(stickers, target)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stickers = [\"with\",\"example\",\"science\"], target = \"thehat\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "stickers = [\"notice\",\"possible\"], target = \"basicbasic\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode583.json",
    "problem_index_in_file": 0,
    "title": "Delete Operation for Two Strings",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and wor...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing edit distance where only deletions allowed. Equivalent to find longest common subsequence length L, then steps = (len(word1)-L)+(len(word2)-L). So steps = len1+len2-2*L. L can be computed via DP LCS.\n\nWe need to produce step by step virtual code with arrows and decisions. Each line: \"Step X: ...\" plus explanation. Start, End, Decision etc.\n\nLet's produce algorithm:\n\nStart\n→ Input word1, word2\n→ Compute len1, len2\n→ Initialize DP table of size (len1+1) x (len2+1) to zeros\n→ For i from 1 to len1:\n    → For j from 1 to len2:\n        → Decision: word1[i-1] == word2[j-1]?\n            Yes → DP[i][j] = DP[i-1][j-1] + 1\n            No → DP[i][j] = max(DP[i-1][j], DP[i][j-1])\n→ L = DP[len1][len2] // length of longest common subsequence\n→ steps = len1 + len2 - 2*L\n→ Output steps\nEnd\n\nBut we need each line as \"Step n: ...\" and explanation. Also include decisions with arrows Yes →, No →.\n\nLet's format: \n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 word1、word2 // 從使用者或函式參數取得兩個字串\n→ Step 2: 計算 len1 = length of word1, len2 = length of word2 // 取得兩字串長度\n→ Step 3: 初始化 DP 表 (len1+1) × (len2+1) 為 0 // 建立動態規劃表格\n→ Step 4: 從 i=1 到 len1 逐行處理 // 外層迴圈遍歷 word1\n    → Step 5: 從 j=1 到 len2 逐列處理 // 內層迴圈遍歷 word2\n        → Decision: word1[i-1] == word2[j-1]? // 檢查當前字符是否相同\n            Yes → Step 6: DP[i][j] = DP[i-1][j-1] + 1 // 若相同，遞增 LCS 長度\n            No  → Step 7: DP[i][j] = max(DP[i-1][j], DP[i][j-1]) // 若不同，取最大子問題解\n→ Step 8: L = DP[len1][len2] // LCS 長度\n→ Step 9: steps = len1 + len2 - 2 * L // 計算最小刪除步數\n→ Step 10: 輸出 steps // 回傳結果\nEnd // 程式執行結束\n\nNeed to keep arrow formatting: \"→\" etc. Use spaces.\n\nAlso for decisions inside loops, indent? They didn't specify indent but can show nested indentation with spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 word1、word2 // 從使用者或函式參數取得兩個字串\n→ Step 2: 計算 len1 = length of word1, len2 = length of word2 // 取得兩字串長度\n→ Step 3: 初始化 DP 表 (len1+1) × (len2+1) 為 0 // 建立動態規劃表格\n→ Step 4: 從 i=1 到 len1 逐行處理 // 外層迴圈遍歷 word1\n    → Step 5: 從 j=1 到 len2 逐列處理 // 內層迴圈遍歷 word2\n        → Decision: word1[i-1] == word2[j-1]? // 檢查當前字符是否相同\n            Yes → Step 6: DP[i][j] = DP[i-1][j-1] + 1 // 若相同，遞增 LCS 長度\n            No  → Step 7: DP[i][j] = max(DP[i-1][j], DP[i][j-1]) // 若不同，取最大子問題解\n→ Step 8: L = DP[len1][len2] // LCS 長度\n→ Step 9: steps = len1 + len2 - 2 * L // 計算最小刪除步數\n→ Step 10: 輸出 steps // 回傳結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"計算最小刪除步數，使兩字串相同。\"\"\"\n    m, n = len(word1), len(word2)\n    # 建立 (m+1) x (n+1) 的 DP 表，初始值為 0\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # 依照 LCS 動態規劃公式填表\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    # LCS 長度\n    lcs_len = dp[m][n]\n    # 最小步數 = (len1 - LCS) + (len2 - LCS)\n    return m + n - 2 * lcs_len\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取兩個字串，支援\n    - word1 = \"sea\", word2 = \"eat\"\n    - 兩行各一個字串\n    - 兩個空白分隔的字串\n    \"\"\"\n    # 先尋找雙引號中的字串\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n\n    # 若沒有雙引號，嘗試逐行讀取\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n\n    # 再試試空白分隔\n    tokens = data.split()\n    if len(tokens) >= 2:\n        return tokens[0], tokens[1]\n\n    # 最後的兜底，若還是無法取得，返回空字串\n    return \"\", \"\"\n\ndef main():\n    raw_input = sys.stdin.read()\n    word1, word2 = parse_input(raw_input)\n    result = min_distance(word1, word2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Should describe algorithm to find first occurrence of needle in haystack. Could be naive substring search. Steps: start, get lengths, iterate i from 0 to len(haystack)-len(needle). For each i, check match via nested loop j. If full match return i. After loop return -1. Use Decision, Start, End. Provide explanation each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 haystack 長度為 m，needle 長度為 n // 獲取兩個字串的長度  \n→ Decision: 如果 n > m? // 檢查 needle 是否比 haystack 長  \n  Yes → Step 2: 輸出 -1 // 若長度大，直接返回 -1  \n  No → Decision: 如果 n == 0? // 針對空 needle 的特例  \n    Yes → Step 3: 輸出 0 // 空字串始終在最前面  \n    No → Step 4: 從 i = 0 到 i ≤ m - n 進行外層迴圈 // 正式開始搜尋  \n→ Decision: 迴圈 i 是否小於等於 m - n?  \n  Yes → Step 5: 設 flag 為 true // 假設當前起始位置為匹配  \n    → Step 6: 從 j = 0 到 j < n 進行內層迴圈 // 逐字符比對  \n      Decision: haystack[i + j] 是否等於 needle[j]?  \n        Yes → Step 7: 進行下一個 j // 匹配成功，繼續比對  \n        No → Step 8: flag = false → No → Step 9: 跳出內層迴圈 // 失配，結束內層  \n        （若 j 完成，則判斷 flag）  \n     Decision: flag 為 true?  \n       Yes → Step 10: 輸出 i // 找到第一個匹配位置，返回  \n       No → Step 11: i = i + 1 → 回到外層迴圈  \n  No → Step 12: 輸出 -1 // 迴圈結束仍未匹配，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"Return the index of the first occurrence of needle in haystack, or -1.\"\"\"\n        # Empty needle always matches at position 0\n        if needle == \"\":\n            return 0\n\n        n, m = len(haystack), len(needle)\n        # Only need to check up to the point where the remaining substring is long enough\n        for i in range(n - m + 1):\n            if haystack[i:i + m] == needle:\n                return i\n        return -1\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find all quoted strings; assume the first is haystack and the second is needle\n    quotes = re.findall(r'\"(.*?)\"', data)\n    if len(quotes) >= 2:\n        haystack, needle = quotes[0], quotes[1]\n    else:\n        # Fallback: split by commas and strip spaces\n        parts = [part.strip() for part in data.split(',')]\n        haystack = parts[0].split('=')[1].strip().strip('\"')\n        needle = parts[1].split('=')[1].strip().strip('\"')\n\n    solution = Solution()\n    result = solution.strStr(haystack, needle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode605.json",
    "problem_index_in_file": 0,
    "title": "Can Place Flowers",
    "description_snippet": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line with explanation. Must follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows etc. Not real code. Provide algorithm for planting flowers. Let's design: iterate through array, count possible planting spots. For each position i: if flowerbed[i]==0 and (i==0 or flowerbed[i-1]==0) and (i==len-1 or flowerbed[i+1]==0) then plant (set to 1) and decrement n. If n <= 0 break. After loop, return n <= 0. Virtual code representation: Start, Step: Initialize count etc. Use decision. Provide lines with arrows: \"→ Step 1: Initialize count = n // required flowers\" but better: we use n variable. Let's write: Start // begin\n\n→ Step 1: Set index i = 0 // start at first plot\n\n→ Decision: i < len(flowerbed)? // iterate until end\n\nYes → Decision: flowerbed[i] == 0? // empty plot?\n\nYes → Decision: (i == 0 OR flowerbed[i-1] == 0) AND (i == len-1 OR flowerbed[i+1] == 0)? // adjacent free?\n\nYes → Step 2: plant flower: set flowerbed[i] = 1 // plant\n\n→ Step 3: n = n - 1 // one less needed\n\n→ Decision: n <= 0? // all planted?\n\nYes → End // return true\n\nNo → Continue // go to next index\n\nNo → No action (cannot plant) // just continue\n\nNo → End of loop? // after index loop, check n\n\n→ Decision: n <= 0? // all planted?\n\nYes → Step 4: return true\n\nNo → Step 5: return false\n\nEnd // finish\n\nNeed to include explanation after each line. Let's write properly with indentation: But each line is a separate line. Use \"→\" to indicate steps. Provide explanation after space.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set i = 0 // 初始化索引，從第一個花園格子開始  \n→ Decision: i < len(flowerbed)? // 是否還有格子要檢查？  \n    Yes → Decision: flowerbed[i] == 0? // 當前格子是否為空？  \n        Yes → Decision: (i == 0 OR flowerbed[i-1] == 0) AND (i == len(flowerbed)-1 OR flowerbed[i+1] == 0)? // 左右鄰居是否都為空？  \n            Yes → Step 2: Set flowerbed[i] = 1 // 在空格子種花  \n            → Step 3: n = n - 1 // 需要種植的花數減 1  \n            → Decision: n <= 0? // 是否已經種完所有花？  \n                Yes → End // 程式結束，回傳 true  \n                No  → Continue // 繼續檢查下一格  \n            No  → No action // 無法種植，跳過此格  \n        No  → No action // 此格已被佔用，跳過  \n    No  → No action // 索引已超出範圍，結束循環  \n→ Step 4: Return n <= 0 // 檢查剩餘需要種植的花數，若為 0 或負則可滿足  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        length = len(flowerbed)\n        i = 0\n        while i < length:\n            if flowerbed[i] == 0:\n                empty_prev = (i == 0) or (flowerbed[i-1] == 0)\n                empty_next = (i == length - 1) or (flowerbed[i+1] == 0)\n                if empty_prev and empty_next:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n:\n                        return True\n                    i += 1  # skip next plot because we just planted here\n            i += 1\n        return count >= n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract flowerbed list\n    flowerbed_match = re.search(r'flowerbed\\s*=\\s*(\\[.*?\\])', data, re.S)\n    if not flowerbed_match:\n        print(\"false\")\n        sys.exit(0)\n    flowerbed_str = flowerbed_match.group(1)\n    # Extract n value\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n    if not n_match:\n        print(\"false\")\n        sys.exit(0)\n    n = int(n_match.group(1))\n    # Evaluate flowerbed list safely\n    try:\n        flowerbed = eval(flowerbed_str, {\"__builtins__\": None}, {})\n    except Exception:\n        print(\"false\")\n        sys.exit(0)\n    sol = Solution()\n    result = sol.canPlaceFlowers(flowerbed, n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "flowerbed = [1,0,0,0,1], n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "flowerbed = [1,0,0,0,1], n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode768.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted II",
    "description_snippet": "You are given an integer array arr.\n\nWe split arr into some number of chunks (i.e., partitions), and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the problem of largest number of chunks to sort array. Problem known: Largest Number of \"chunks to make sorted\" (LeetCode 768). For array of unique integers from 0 to n-1? The problem description might be generic integer array but typical solution uses max so far equals i. The largest number of chunks such that sorting each chunk and concatenating equals sorted array. For any array, we can count positions where max so far equals the index of sorted? Actually algorithm: sort a copy of arr, then iterate and compare prefix sorted and prefix original sorted? For unique values: keep max, when max == i (for 0-index). For general values with duplicates, use sorted version and compare counts. But typical solution: Use hashmap counts to track difference between prefix of arr and sorted arr. When counts all zero, chunk.\n\nBut requirement: produce virtual code. Let's produce a generic algorithm using a dictionary difference. Use a variable count_diff map: key -> difference between counts in arr prefix and sorted prefix. When map empty -> chunk.\n\nImplementation:\n\n1. Make sorted copy sorted_arr.\n2. Initialize diff_map empty.\n3. Initialize chunks = 0.\n4. For i from 0 to n-1:\n   - Increment count of arr[i] in diff_map.\n   - Increment count of sorted_arr[i] in diff_map (decrement).\n   - If count becomes 0 remove key.\n   - If diff_map is empty: chunks++.\n\nReturn chunks.\n\nExplain each line.\n\nLet's produce virtual code step by step with arrows. Use \"→\" for each step. Use Decision. No loops? We can use a loop structure indicated with \"→\" as part of a for loop.\n\nWe need to output each line. Let's design:\n\nStart // start\n→ Step 1: Make a sorted copy of arr as sorted_arr // create sorted version\n→ Step 2: Initialize diff_map as empty map // to track count differences\n→ Step 3: Initialize chunks = 0 // count of chunks\n→ Step 4: For each index i from 0 to length-1 // iterate over array\n    → Step 4.1: Increment diff_map[arr[i]] by 1 // add element from original\n    → Step 4.2: Decrement diff_map[sorted_arr[i]] by 1 // subtract element from sorted\n    → Step 4.3: If diff_map value becomes 0 remove key // keep map clean\n    → Decision: Is diff_map empty? // check if prefix matches\n        Yes → Step 4.4: Increment chunks by 1 // found a chunk\n        No  → Step 4.5: Continue // continue loop\n→ Step 5: Return chunks // result\nEnd\n\nWe need to provide comments after each line.\n\nMake sure format: Each line: \"虛擬碼步驟 // 解釋\". Use spaces. Use arrow \"→\". Use Decision blocks indent. Provide indentation? Use spaces. We must match example. In example, they used indentation inside Decision with 4 spaces indent. We'll follow.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Make a sorted copy of arr as sorted_arr // 建立陣列 arr 的升冪排序版本  \n→ Step 2: Initialize diff_map as empty map // 用於追蹤原始前綴與排序後前綴的數量差異  \n→ Step 3: Initialize chunks = 0 // 儲存可拆分的最大區塊數  \n→ Step 4: For each index i from 0 to length-1 // 遍歷陣列的每個位置  \n  → Step 4.1: Increment diff_map[arr[i]] by 1 // 將原陣列中該元素的計數加一  \n  → Step 4.2: Decrement diff_map[sorted_arr[i]] by 1 // 從計數中減去排序後陣列中對應位置的元素  \n  → Step 4.3: If diff_map value becomes 0 remove key // 清除零值鍵，保持映射乾淨  \n  → Decision: Is diff_map empty? // 判斷目前前綴是否已經完全匹配排序後前綴  \n   Yes → Step 4.4: Increment chunks by 1 // 找到一個可獨立排序的區塊，累加計數  \n   No  → Step 4.5: Continue // 否則繼續迴圈，等待下一個可能的區塊  \n→ Step 5: Return chunks // 回傳最大可拆分區塊數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_chunks_to_sorted(arr):\n    n = len(arr)\n    right_min = [0] * n\n    right_min[-1] = arr[-1]\n    for i in range(n - 2, -1, -1):\n        right_min[i] = min(arr[i], right_min[i + 1])\n\n    chunks = 0\n    left_max = float('-inf')\n    for i in range(n - 1):\n        left_max = max(left_max, arr[i])\n        if left_max <= right_min[i + 1]:\n            chunks += 1\n    return chunks + 1\n\ndef parse_input(data):\n    \"\"\"Extract the list of integers from a string like 'arr = [5,4,3]'.\"\"\"\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1 or l > r:\n        return []\n    sub = data[l:r + 1]\n    return ast.literal_eval(sub)\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    arr = parse_input(raw)\n    print(max_chunks_to_sorted(arr))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [5,4,3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [2,1,3,4,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode664.json",
    "problem_index_in_file": 0,
    "title": "Strange Printer",
    "description_snippet": "There is a strange printer with the following two special properties:\n\nThe printer can only print a ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps line by line, with explanation after comment, no actual code. The problem: Strange printer. Classic DP: dp[i][j] minimal turns to print substring i..j. Recurrence: dp[i][j] = dp[i][j-1] + 1 initially, then for k from i to j-1 if s[k]==s[j], dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]). But we must produce pseudocode steps.\n\nWe need to output step by step pseudocode: Start, Step 1, etc. Use arrows. Explanation after //.\n\nLet's produce: Start, Step: Read string s, n = len(s). Initialize dp matrix n x n to 0. For i from n-1 downto 0, set dp[i][i] = 1. For length from 2 to n, for i from 0 to n-length, j=i+length-1, compute dp[i][j] via formula. Then answer dp[0][n-1]. End.\n\nWe must use arrow syntax: \"→\". Indent decisions: not many. But maybe Decision: if n==0? For empty string? But we can ignore.\n\nWe'll produce straightforward loops. Use arrow indentation: \"→\" for each line after Start, then \"→\" each subsequent step. For loops, use \"→ For i = ...\" etc. We need to put \"Decision:\" for conditions.\n\nLet's create pseudocode lines:\n\nStart\n→ Step 1: Input string s\n→ Step 2: Let n = length of s\n→ Decision: if n == 0? // handle empty string\n    Yes → Step 3: Output 0 // no turns needed\n    No → Step 4: Initialize dp as n×n array of zeros // dp[i][j] minimal turns\n\nThen loops: For i from n-1 downto 0:\n    dp[i][i] = 1 // single character needs one turn\n\nFor len from 2 to n:\n    For i from 0 to n-len:\n        j = i+len-1\n        dp[i][j] = dp[i][j-1] + 1 // worst case: print s[j] separately\n        For k from i to j-1:\n            if s[k] == s[j]:\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]) // merge prints\n\nAfter loops: Output dp[0][n-1] // answer\n\nEnd\n\nWe should use arrow notation for loops and decisions. Also, for the if inside inner loop: \"Decision: s[k] == s[j]?\" with Yes arrow.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Input string s // 取得要印刷的字串\n→ Step 2: Let n = length of s // 取得字串長度\n→ Decision: n == 0? // 檢查字串是否為空\n    Yes → Step 3: Output 0 // 空字串不需要任何印刷回合\n    No  → Step 4: Initialize dp as n×n array of zeros // 建立 DP 二維表格\n→ Step 5: For i = n-1 downto 0 // 依序處理子字串長度為 1 的情況\n    → dp[i][i] = 1 // 單一字元只需一次印刷\n→ Step 6: For len = 2 to n // 從長度 2 開始處理更長子字串\n    → For i = 0 to n-len\n        → j = i + len - 1 // 子字串的結束索引\n        → dp[i][j] = dp[i][j-1] + 1 // 最壞情況：將 s[j] 單獨印刷\n        → For k = i to j-1 // 嘗試合併相同字元的印刷\n            → Decision: s[k] == s[j]?\n                Yes → dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j-1]) // 合併後的最小回合數\n                No  → // 不合併，保持現有 dp[i][j]\n→ Step 7: Output dp[0][n-1] // 回傳整個字串所需的最小印刷回合數\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 抽取引號內的字串，若無引號則直接使用整行字串\n    m = re.search(r'\"([^\"]*)\"', data)\n    s = m.group(1) if m else data\n\n    n = len(s)\n    if n == 0:\n        print(0)\n        return\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            dp[i][j] = 1 + dp[i + 1][j]\n            for k in range(i + 1, j + 1):\n                if s[k] == s[i]:\n                    if k + 1 <= j:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1] + dp[k + 1][j])\n                    else:\n                        dp[i][j] = min(dp[i][j], dp[i][k - 1])\n\n    print(dp[0][n - 1])\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabbb\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting number of combinations summing to target with distinct integers. It's typical coin change order matters? Problem likely from Leetcode 377? That one returns number of combinations where order matters. Distinct integers. So algorithm: DP array dp[0..target], dp[0]=1; For each coin in nums: for sum from coin to target: dp[sum] += dp[sum-coin]. That counts combinations where order matters? Actually coin change 2 (combinations where order matters) uses dp sum loops outer sum inner coin? Wait for order matters, we iterate sum outer, coin inner. For coin change 2, order matters, we do for sum in 1..target: for coin in nums: if coin<=sum: dp[sum]+=dp[sum-coin]. That ensures permutations counted. So we need to clarify. We'll produce algorithm using dp 1D. Provide steps.\n\nAlso consider initial explanation: given array distinct integers, target. Count combinations sum to target. Use DP.\n\nProvide virtual code lines: Start, Input nums and target, initialize dp[0]=1, iterate sum, inner loop coin, update dp[sum], final output dp[target], End.\n\nNeed to use arrows and decision if any. No decisions needed.\n\nBut we may add validation of empty array? Not necessary.\n\nLet's produce steps:\n\nStart\n→ Step 1: Input array nums and integer target // Get inputs\n→ Step 2: Initialize array dp of size target+1 with all 0 // DP table\n→ Step 3: Set dp[0] = 1 // One way to reach sum 0 (empty combination)\n→ Step 4: For sum from 1 to target: // iterate over all possible sums\n    → Step 5: For each coin in nums: // consider each available integer\n        → Decision: If coin <= sum? // can use this coin\n            Yes → Step 6: dp[sum] = dp[sum] + dp[sum - coin] // add ways\n            No → Step 7: Continue // skip coin larger than current sum\n→ Step 8: Output dp[target] // number of combinations\nEnd\n\nWe can collapse decision lines: but we follow arrow format. Provide explanation after each line.\n\nMake sure each line ends with // explanation.\n\nAlso we can show indentation? Use spaces or tab. Provide \"→\" arrow for each step. For decision we use \"Decision: ...\". Use \"Yes →\" etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums 與目標值 target // 取得使用者給定的數字集合和目標和  \n→ Step 2: 建立 dp 陣列長度為 target+1，並全部初始化為 0 // dp[i] 代表能達到總和 i 的組合數量  \n→ Step 3: 設定 dp[0] = 1 // 只有一種方式達到 0（不選取任何數字）  \n→ Step 4: Decision: 迴圈 sum 從 1 到 target // 逐個檢查所有可能的總和  \n    Yes → Step 5: 迴圈 coin 在 nums // 逐個嘗試每個可用的數字  \n        → Decision: 如果 coin <= sum? // 只能使用不大於目前總和的數字  \n            Yes → Step 6: dp[sum] = dp[sum] + dp[sum - coin] // 把先前能達到 sum-coin 的組合加入本總和  \n            No  → Step 7: Continue // 這個 coin 太大，跳過  \n→ Step 8: 輸出 dp[target] // 回傳符合條件的組合總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef combination_sum_4(nums, target):\n    \"\"\"計算組合數，順序重要，使用動態規劃。\"\"\"\n    dp = [0] * (target + 1)\n    dp[0] = 1  # 基本情況：有一種方式到達 0（不取任何數字）\n    for total in range(1, target + 1):\n        for num in nums:\n            if total - num >= 0:\n                dp[total] += dp[total - num]\n    return dp[target]\n\ndef parse_input(input_str):\n    \"\"\"從輸入字串中抽取 nums 列表與 target 整數。\"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', input_str)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', input_str)\n    if not nums_match or not target_match:\n        raise ValueError(\"輸入格式不正確\")\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    return nums, target\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    nums, target = parse_input(raw_input)\n    result = combination_sum_4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode726.json",
    "problem_index_in_file": 0,
    "title": "Number of Atoms",
    "description_snippet": "Given a string formula representing a chemical formula, return the count of each atom.\n\nThe atomic e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines for algorithm to parse chemical formula and output sorted atom counts. We'll produce line by line with comments. We'll need stack to handle parentheses, parsing numbers, building counts dictionary. Outline: Start, parse from left to right with stack of maps. When encountering '(', push new empty map onto stack. When encountering element name, read name, then number (if any). Add to current map. When encountering ')', pop top map, read number after ')', multiply counts, merge into previous map. After parsing, have final map. Sort keys, build output string accordingly. Ensure 32-bit. Provide pseudocode.\n\nLet's produce lines. Use \"→ Step ...\". Use \"Decision:\" for if conditions.\n\nWe'll produce something like:\n\nStart\n→ Initialize stack with empty map // stack of atom counts\n→ Set index = 0\n→ While index < length of formula\n    → Decision: If current char is '('\n        Yes → Push new empty map onto stack // start new group\n        No  → Decision: If current char is ')'\n            Yes → Pop top map into groupMap\n                 → Read number after ')'\n                 → If number missing, count=1\n                 → For each atom in groupMap\n                     → Multiply by count and add to previous map on stack\n            No  → // must be element start\n                → Parse element name starting at index (uppercase + following lowercase)\n                → Advance index accordingly\n                → Parse digits following name into number (default 1)\n                → Add to current top map\n    → Increment index appropriately (handled within parsing)\n→ End while\n→ After loop, top of stack is final map\n→ Sort keys alphabetically\n→ Build result string\n→ End\n\nBut need line by line. Use arrow and indentation. Let's produce detailed pseudocode:\n\nStart\n→ Set stack ← [empty map] // stack[0] is current context\n→ Set i ← 0\n→ While i < len(formula)\n    → Decision: formula[i] == '('\n        Yes → stack.append(empty map)\n              → i ← i + 1\n        No  → Decision: formula[i] == ')'\n            Yes → i ← i + 1\n                  → Read number starting at i; if none, num ← 1; else num ← parsed integer; update i accordingly\n                  → group ← stack.pop()\n                  → For atom, cnt in group\n                      → stack[-1][atom] ← stack[-1].get(atom,0) + cnt * num\n            No  → // parse element\n                  → name ← formula[i] // uppercase\n                  → i ← i + 1\n                  → While i < len(formula) and formula[i] is lowercase\n                        → name ← name + formula[i]\n                        → i ← i + 1\n                  → Read number starting at i; if none, num ← 1; else num ← parsed integer; update i accordingly\n                  → stack[-1][name] ← stack[-1].get(name,0) + num\n→ End While\n→ resultMap ← stack[0]\n→ keys ← sorted(resultMap.keys())\n→ result ← \"\"\n→ For each key in keys\n        → result ← result + key\n        → If resultMap[key] > 1\n            → result ← result + str(resultMap[key])\n→ End For\n→ Return result\nEnd\n\nBut we need each line as \"虛擬碼步驟 [空格] // 解釋\". Use proper indentation arrow.\n\nWe'll produce lines with \"→\" and indent sub-steps with extra arrows? The sample uses indentation for nested decisions. We can mimic.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Set stack ← [empty map] // 用堆疊儲存目前層級的原子計數\n→ Set i ← 0 // 公式的索引指標\n→ While i < len(formula) // 逐字解析整個公式\n    → Decision: formula[i] == '(' // 開啟括號\n        Yes → stack.append(empty map) // 推入新層級的計數表\n              → i ← i + 1 // 移至括號內的第一個字符\n        No  → Decision: formula[i] == ')' // 關閉括號\n            Yes → i ← i + 1 // 移至括號結束後的字符\n                  → Read number starting at i; if none, num ← 1 // 取得括號後的乘數\n                  → group ← stack.pop() // 把括號內的計數表彈出\n                  → For atom, cnt in group // 逐個原子更新上一層計數表\n                      → stack[-1][atom] ← stack[-1].get(atom,0) + cnt * num\n            No  → // 解析元素名稱與其個數\n                → name ← formula[i] // 取大寫字母作為元素首字母\n                → i ← i + 1\n                → While i < len(formula) and formula[i] is lowercase // 循環讀取後續小寫字母\n                    → name ← name + formula[i]\n                    → i ← i + 1\n                → Read number starting at i; if none, num ← 1 // 取得元素個數\n                → stack[-1][name] ← stack[-1].get(name,0) + num // 加入到目前層級\n→ End While // 公式解析完成\n→ resultMap ← stack[0] // 堆疊底部即為最終計數表\n→ keys ← sorted(resultMap.keys()) // 按字典序排序所有元素名稱\n→ result ← \"\" // 準備輸出字串\n→ For each key in keys // 依序組成輸出\n    → result ← result + key // 加入元素名稱\n    → If resultMap[key] > 1 // 若個數大於 1，加入數字\n        → result ← result + str(resultMap[key])\n→ End For\n→ Return result // 傳回最終格式化字串\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def countOfAtoms(self, formula: str) -> str:\n        n = len(formula)\n        self.i = 0  # current parsing index\n\n        def parse() -> Counter:\n            cnt = Counter()\n            while self.i < n and formula[self.i] != ')':\n                if formula[self.i] == '(':\n                    self.i += 1                      # skip '('\n                    inner = parse()                   # parse inside parentheses\n                    self.i += 1                      # skip ')'\n                    mult = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        mult = mult * 10 + int(formula[self.i])\n                        self.i += 1\n                    if mult == 0:\n                        mult = 1\n                    for atom, num in inner.items():\n                        cnt[atom] += num * mult\n                else:\n                    # parse element name\n                    start = self.i\n                    self.i += 1\n                    while self.i < n and formula[self.i].islower():\n                        self.i += 1\n                    name = formula[start:self.i]\n                    # parse optional number\n                    num = 0\n                    while self.i < n and formula[self.i].isdigit():\n                        num = num * 10 + int(formula[self.i])\n                        self.i += 1\n                    if num == 0:\n                        num = 1\n                    cnt[name] += num\n            return cnt\n\n        counts = parse()\n        parts = []\n        for atom in sorted(counts.keys()):\n            parts.append(atom + (str(counts[atom]) if counts[atom] > 1 else \"\"))\n        return \"\".join(parts)\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the formula string from something like: formula = \"H2O\"\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        formula = match.group(1)\n    else:\n        formula = data.strip()\n    solver = Solution()\n    result = solver.countOfAtoms(formula)\n    # Print the result surrounded by double quotes, as shown in the examples\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "formula = \"H2O\"",
          "expected_output": "\"H2O\"",
          "success": true,
          "output": "\"H2O\""
        },
        {
          "example_index": 1,
          "input": "formula = \"Mg(OH)2\"",
          "expected_output": "\"H2MgO2\"",
          "success": true,
          "output": "\"H2MgO2\""
        },
        {
          "example_index": 2,
          "input": "formula = \"K4(ON(SO3)2)2\"",
          "expected_output": "\"K4N2O14S4\"",
          "success": true,
          "output": "\"K4N2O14S4\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode575.json",
    "problem_index_in_file": 0,
    "title": "Distribute Candies",
    "description_snippet": "Alice has n candies, where the i^th candy is of type candyType[i]. Alice noticed that she started to...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: given array candyType of length n (even), want max distinct types among n/2 candies. Solution: distinct types count = number of unique values. The answer is min(distinct_count, n/2). So virtual code: Start, Step1 input array, Step2 compute n, Step3 compute half, Step4 compute unique set, Step5 compute unique count, Step6 compute answer = min(unique_count, half), Step7 output answer, End. Also maybe handle duplicates. Use set.\n\nWe need to format each line as \"虛擬碼步驟 // 解釋\". Use arrow. For decisions: maybe Decision for n/2 > unique? But just min. Could use Decision: If unique > half? then answer = half else answer = unique. Use Decision.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 讀取 candyType 數列 // 從輸入取得所有糖果類型\n→ Step 2: 計算 n = 數列長度 // 確定糖果總數\n→ Step 3: 計算 half = n / 2 // 只能吃的一半數量\n→ Step 4: 建立空集合 uniqueTypes // 用於儲存不同類型\n→ Step 5: 對 candyType 中每個類型 t:\n    → Step 5a: 將 t 加入 uniqueTypes // 收集所有不同類型\n→ Step 6: 計算 uniqueCount = uniqueTypes 的大小 // 獲取不同類型的數量\n→ Decision: uniqueCount > half? // 判斷不同類型是否多於可吃數量\n    Yes → Step 7: answer = half // 只能吃 half 種不同\n    No  → Step 7: answer = uniqueCount // 可以吃所有不同\n→ Step 8: 輸出 answer // 回傳最大不同類型數\nEnd // 程式執行結束\n\nNeed to format each line: arrow. For nested lines, we can indent with spaces? The example shows indent. We'll use indentation with four spaces before each nested step. For the loop and decision.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 candyType 數列 // 從輸入取得所有糖果類型  \n→ Step 2: 計算 n = 數列長度 // 確定糖果總數  \n→ Step 3: 計算 half = n / 2 // 只能吃的一半數量  \n→ Step 4: 建立空集合 uniqueTypes // 用於儲存不同類型  \n→ Step 5: 對 candyType 中每個類型 t:  \n  → Step 5a: 將 t 加入 uniqueTypes // 收集所有不同類型  \n→ Step 6: 計算 uniqueCount = uniqueTypes 的大小 // 獲取不同類型的數量  \n→ Decision: uniqueCount > half? // 判斷不同類型是否多於可吃數量  \n  Yes → Step 7: answer = half // 只能吃 half 種不同  \n  No  → Step 7: answer = uniqueCount // 可以吃所有不同  \n→ Step 8: 輸出 answer // 回傳最大不同類型數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef distribute_candies(candy_type):\n    \"\"\"\n    計算 Alice 可以吃到的最多不同種類糖果數。\n    她只能吃 n/2 個糖果，其中 n 為總數。\n    只要把所有不同種類的數量算出來，\n    然後取與 n/2 的較小值即可。\n    \"\"\"\n    n = len(candy_type)\n    half = n // 2\n    unique_count = len(set(candy_type))\n    return min(unique_count, half)\n\ndef main():\n    # 讀取所有輸入內容（可能包含多行）\n    raw = sys.stdin.read()\n    # 從輸入字串中擷取所有整數（負數也支持）\n    numbers = list(map(int, re.findall(r'-?\\d+', raw)))\n    # 整數列表即為 candyType\n    candy_type = numbers\n    # 計算答案\n    result = distribute_candies(candy_type)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candyType = [1,1,2,2,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "candyType = [1,1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "candyType = [6,6,6,6]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line-by-line with explanations, following the format. Each line: \"虛擬碼步驟 // 解釋\". Use arrows for decisions and flow.\n\nThe algorithm: count unique k-diff pairs. Typical approach: use hash set of numbers. If k==0, count numbers that appear at least twice. If k>0, for each unique number x, check if x+k exists. Count. Use set to avoid duplicates. We need pseudocode steps.\n\nOutline:\n\nStart\n→ Step: Create frequency map (or set)\n→ Decision: if k < 0? No pair possible, return 0. // but k is int; usually non-negative. We'll handle k<0.\n→ Decision: if k == 0? // special case\n    → Step: For each number in map, if freq>=2, increment count\n    → End // return count\n    No → Step: For each number in map, if number+k in map, increment count\n→ End // return count\n\nWe need to use structure Start, End, Decision, etc. Provide step numbers? Not necessary but can use Step labels.\n\nLet's craft each line with explanation. Must be in Traditional Chinese.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" with arrow \"→\".\n\nWe must include Start and End.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立一個哈希表 freq 以統計每個數字出現次數 // 方便快速查詢\n→ Decision: 如果 k < 0? // 任何負差值無法滿足 |a-b|=k，直接返回 0\n    Yes → Step 2: 回傳 0 // k 為負值時無合法對\n    No  → Decision: k 是否等於 0? // 特殊處理重複數字\n        Yes → Step 3: 初始化 count 為 0\n        → Step 4: 對於每個 (num, cnt) 在 freq 中\n            → Decision: cnt >= 2? // 至少出現兩次才能組成 |a-b|=0 的對\n                Yes → Step 5: count += 1\n                No  → Step 5: 不執行\n        → Step 6: 回傳 count // k=0 時的對數\n        No  → Step 7: 初始化 count 為 0\n        → Step 8: 取所有唯一數字 num\n            → Decision: (num + k) 是否在 freq 中? // 若存在則形成一個對\n                Yes → Step 9: count += 1\n                No  → Step 9: 不執行\n        → Step 10: 回傳 count // k>0 時的對數\nEnd // 程式執行結束\n\nWe need to maintain proper indentation? The format uses arrow indent to show hierarchy. Use spaces.\n\nWe can use \"Yes →\" and \"No →\" lines after decisions.\n\nEnsure each line includes the arrow at start, but only if it's part of flow. For Start and End, no arrow. For steps, include arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個哈希表 freq 以統計每個數字出現次數 // 方便快速查詢  \n→ Decision: 如果 k < 0? // 任何負差值無法滿足 |a-b|=k，直接返回 0  \n  Yes → Step 2: 回傳 0 // k 為負值時無合法對  \n  No  → Decision: k 是否等於 0? // 特殊處理重複數字  \n   Yes → Step 3: 初始化 count 為 0  \n    → Step 4: 對於每個 (num, cnt) 在 freq 中  \n      Decision: cnt >= 2? // 至少出現兩次才能組成 |a-b|=0 的對  \n       Yes → Step 5: count += 1  \n       No  → Step 5: 不執行  \n      → Step 6: 回傳 count // k=0 時的對數  \n   No  → Step 7: 初始化 count 為 0  \n    → Step 8: 取所有唯一數字 num  \n      Decision: (num + k) 是否在 freq 中? // 若存在則形成一個對  \n       Yes → Step 9: count += 1  \n       No  → Step 9: 不執行  \n      → Step 10: 回傳 count // k>0 時的對數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        if k < 0:\n            return 0\n        count = Counter(nums)\n        if k == 0:\n            return sum(v > 1 for v in count.values())\n        return sum(n + k in count for n in count)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Find the position of the closing bracket of the list\n    end_bracket = data.find(']')\n    list_part = data[:end_bracket + 1]\n    k_part = data[end_bracket + 2:].strip()  # skip '],'\n    nums = ast.literal_eval(list_part)\n    k = int(k_part)\n    result = Solution().findPairs(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode611.json",
    "problem_index_in_file": 0,
    "title": "Valid Triangle Number",
    "description_snippet": "Given an integer array nums, return the number of triplets chosen from the array that can make trian...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting triangle triplets. Steps: sort array, iterate i, j, k with two pointers. Provide explanation after each line. Use the specified format. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort the array nums in non‑decreasing order // 先排序方便後續使用兩指標法  \n→ Step 2: Initialize count = 0 // 用於累計可成三角形的三元組數  \n→ Decision: 是否已遍歷完所有 i? // 循環 i 從 0 到 n‑3  \n    No → Step 3: Set i = 0 // 第一條邊的索引  \n→ Decision: 是否已遍歷完所有 i?  \n    No → Step 4: Set k = i + 2 // 第三條邊的起始索引，至少比 j 大  \n→ Decision: 是否已遍歷完所有 j? // j 從 i+1 到 n‑2  \n    No → Step 5: Set j = i + 1 // 第二條邊的索引  \n→ Decision: 是否已遍歷完所有 j?  \n    No → Step 6: While k < n and nums[i] + nums[j] > nums[k] // 找到最大合法 k  \n        → k = k + 1 // k 向右移動，尋找最遠可行的第三條邊  \n→ Decision: 迴圈結束後 k 已超過合法範圍？  \n    Yes → Step 7: count = count + (k - j - 1) // 這些 k 值都能組成三角形  \n→ Decision: 是否已遍歷完所有 j?  \n    Yes → Step 8: i = i + 1 // 移動到下一個第一條邊  \n→ Decision: 是否已遍歷完所有 i?  \n    Yes → End // 所有三元組已檢查完畢，輸出結果  \n→ Output count // 回傳可組成三角形的三元組數量",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def triangleNumber(self, nums):\n        \"\"\"計算能成三角形的三元組數量。\"\"\"\n        nums.sort()                # 先排序，方便兩指標判斷\n        count = 0\n        n = len(nums)\n        # k 為最大的邊索引，從後往前遍歷\n        for k in range(n - 1, 1, -1):\n            i, j = 0, k - 1      # i 是最小邊索引，j 是中間邊索引\n            while i < j:\n                # 若兩小邊之和大於最大邊，則 (i, i+1, ..., j-1, j) 全部皆可\n                if nums[i] + nums[j] > nums[k]:\n                    count += j - i\n                    j -= 1      # 將 j 向左移動，尋找更小的中間邊\n                else:\n                    i += 1      # 將 i 向右移動，增大小邊\n        return count\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取所有整數，忽略其他文字。\"\"\"\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n    return numbers\n\nif __name__ == \"__main__\":\n    # 讀取所有標準輸入\n    raw_data = sys.stdin.read()\n    # 解析為整數列表\n    nums = parse_input(raw_data)\n    # 計算結果\n    result = Solution().triangleNumber(nums)\n    # 輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, following format:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n…\n\nWe need algorithm: longest substring without repeating characters. Common sliding window approach. Use dictionary or array to store last index of char. We'll produce virtual code in that style. Ensure we use arrow → and Decision: etc.\n\nWe must not output actual code, but pseudo-code steps. Provide line-by-line with explanation.\n\nWe'll produce steps:\n\nStart\n→ Initialize maxLen = 0 // longest length found\n→ Initialize left = 0 // left pointer of window\n→ Initialize charIndexMap = empty map // store last index of each char\n→ For i from 0 to length(s)-1 // iterate over string\n    → Decision: if s[i] in charIndexMap and charIndexMap[s[i]] >= left? // duplicate within window\n        Yes → left = charIndexMap[s[i]] + 1 // move left past duplicate\n        No  → (no action)\n    → Update charIndexMap[s[i]] = i // record latest index\n    → Update maxLen = max(maxLen, i - left + 1) // current window length\n→ Output maxLen // result\nEnd\n\nWe need to include Explanation for each line.\n\nMake sure each line is separate with // explanation. Use arrow for steps.\n\nAlso maybe include \"Decision:\" block with Yes → and No → lines indented.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 maxLen = 0 // 儲存目前已發現的最大不重複子字串長度  \n→ Step 2: 設定 left = 0 // 子字串窗口左邊界指標  \n→ Step 3: 建立空字典 charIndexMap // 用於記錄每個字元最後一次出現的位置  \n→ Step 4: 循環 i 從 0 到 s.length-1 // 逐字元遍歷整個字串  \n  Decision: 若 s[i] 在 charIndexMap 且 charIndexMap[s[i]] >= left? // 字元在當前窗口內重複  \n   Yes → left = charIndexMap[s[i]] + 1 // 把左邊界移到重複字元的下一個位置  \n   No  → (不做任何調整) // 字元未重複或已不在窗口內  \n  → Step 5: 更新 charIndexMap[s[i]] = i // 記錄此字元最新的位置  \n  → Step 6: 更新 maxLen = max(maxLen, i - left + 1) // 計算當前窗口長度並更新最大值  \n→ Step 7: 輸出 maxLen // 回傳最長不重複子字串的長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    Return the length of the longest substring without duplicate characters.\n    Uses a sliding window with a dictionary to track the last seen index of each character.\n    \"\"\"\n    last_seen = {}\n    left = 0\n    max_len = 0\n\n    for right, char in enumerate(s):\n        if char in last_seen and last_seen[char] >= left:\n            # Move left pointer past the previous occurrence of this character\n            left = last_seen[char] + 1\n        last_seen[char] = right\n        # Update maximum length found so far\n        max_len = max(max_len, right - left + 1)\n\n    return max_len\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Attempt to extract the string value inside double quotes\n    start_quote = raw_input.find('\"')\n    end_quote = raw_input.rfind('\"')\n    if start_quote != -1 and end_quote != -1 and end_quote > start_quote:\n        s = raw_input[start_quote + 1:end_quote]\n    else:\n        # Fallback: treat the whole input as the string if no quotes are found\n        s = raw_input\n\n    # Compute and print the result\n    result = length_of_longest_substring(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode715.json",
    "problem_index_in_file": 0,
    "title": "Range Module",
    "description_snippet": "A Range Module is a module that tracks ranges of numbers. Design a data structure to track the range...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for RangeModule with add, query, remove. Probably using interval tree, or sorted list. We'll output step-by-step logic. Probably use TreeMap to store intervals. Use pseudo-code for operations. Let's produce steps.\n...done thinking.\n\nStart // 初始化程式\n→ Step 1: 初始化空有序區間集合 intervals // 以左端點排序，存放已追蹤的 [l, r) 區間\n→ Step 2: 定義函式 addRange(left, right) // 新增區間\n    → Decision: 若 left >= right? // 檢查區間合法性\n        Yes → End // 無效區間，直接結束\n        No  →\n            → Step 3: 找到 intervals 中第一個左端點大於等於 left 的區間 indexStart\n            → Step 4: 從 indexStart 開始向前遍歷，合併任何與 [left, right) 重疊或相連的區間\n                → Decision: 若 intervals[i].right < left? // 與 left 不相連\n                    Yes → Break // 跳出迴圈\n                    No  →\n                        → Step 5: 更新 left = min(left, intervals[i].left)\n                        → Step 6: 更新 right = max(right, intervals[i].right)\n                        → Step 7: 刪除 intervals[i] // 已被合併\n            → Step 8: 插入新合併後的區間 [left, right) 到 intervals\n→ Step 9: 定義函式 queryRange(left, right) // 查詢區間\n    → Decision: 若 left >= right? // 檢查合法性\n        Yes → Return True // 空區間總是被追蹤\n        No  →\n            → Step 10: 找到 intervals 中左端點最接近但小於等於 left 的區間 index\n            → Decision: 若 index 為不存在? 或 intervals[index].right < right? // 沒有足夠覆蓋\n                Yes → Return False\n                No  → Return True\n→ Step 11: 定義函式 removeRange(left, right) // 刪除區間\n    → Decision: 若 left >= right? // 檢查合法性\n        Yes → End // 無效區間，直接結束\n        No  →\n            → Step 12: 找到 intervals 中第一個左端點大於等於 left 的區間 indexStart\n            → Step 13: 從 indexStart 向前遍歷，處理與 [left, right) 重疊的區間\n                → Decision: 若 intervals[i].right <= left? // 與左邊不重疊\n                    Yes → Continue // 跳過\n                    No  →\n                        → Step 14: 若 intervals[i].left < left? // 区间左端在左侧\n                            → Step 15: 插入新的區間 [intervals[i].left, left)\n                        → Step 16: 若 intervals[i].right > right? // 区间右端在右侧\n                            → Step 17: 插入新的區間 [right, intervals[i].right)\n                        → Step 18: 刪除 intervals[i] // 已被截斷或完全移除\n            → Step 19: 完成刪除操作\nEnd // 程式結束\n\nExplanation of key steps:\n- intervals 以左端點排序，可用 BST 或有序陣列存放，方便搜尋重疊區間。\n- addRange 合併所有相交或相連的區間，確保 intervals 始終保持非重疊、非連續。\n- queryRange 只需檢查一個區間是否足以覆蓋查詢區間即可。\n- removeRange 切斷或拆分重疊區間，維持 intervals 的完整性。",
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i - 1][0] <= left and right <= self.ranges[i - 1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef fmt(val):\n    if val is None:\n        return 'null'\n    if val is True:\n        return 'true'\n    if val is False:\n        return 'false'\n    return str(val)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    obj = None\n    outputs = []\n\n    for line in lines:\n        if line.endswith(';'):\n            line = line[:-1]\n        # Skip empty lines\n        if not line:\n            continue\n\n        # Initialization\n        if line.startswith('RangeModule'):\n            obj = RangeModule()\n            outputs.append(None)\n            continue\n\n        # Method call\n        if obj is None:\n            # No object created yet; skip\n            continue\n\n        try:\n            before_dot, after_dot = line.split('.', 1)\n            method, args_part = after_dot.split('(', 1)\n            args_part = args_part.rstrip(')')\n            args = [int(a.strip()) for a in args_part.split(',')] if args_part else []\n        except ValueError:\n            continue  # Malformed line\n\n        if method == 'addRange':\n            obj.addRange(*args)\n            outputs.append(None)\n        elif method == 'removeRange':\n            obj.removeRange(*args)\n            outputs.append(None)\n        elif method == 'queryRange':\n            res = obj.queryRange(*args)\n            outputs.append(res)\n        else:\n            # Unknown method; ignore\n            continue\n\n    print('[' + ', '.join(fmt(v) for v in outputs) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode641.json",
    "problem_index_in_file": 0,
    "title": "Design Circular Deque",
    "description_snippet": "Design your implementation of the circular double-ended queue (deque).\n\nImplement the MyCircularDequ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with \"虛擬碼步驟\" and \"// 解釋\" and use arrows, Start, End, Decision. The requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋\". So each line: e.g., \"Start // 程式開始執行\". Use the arrow arrow notation. Need to design implementation of MyCircularDeque. We need to cover initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. The virtual code should illustrate logic. Use steps: Start, Decision, etc. We can outline the structure: Start -> Step 1: Initialize array of size k and head, tail pointers -> Decision: check if full etc. Then insertFront: check isFull? If no, adjust head pointer etc. For each method, we can write as separate functions.\n\nThe virtual code likely should be top-level pseudo algorithm: Start, define class, then methods.\n\nWe need to output each line with arrow arrow? It says \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we should use arrows to indicate flow.\n\nLet's produce something like:\n\nStart // 程式開始\n→ Step 1: 定義 MyCircularDeque 類 // 定義類別\n→ Step 2: 建立容量為 k 的陣列 buffer // 初始化儲存\n→ Step 3: 初始化 head = 0, tail = 0, size = 0 // 初始化指標\n→ Decision: 之後可根據需求執行不同方法\n\nThen we can outline each method:\n\n→ Method insertFront(value) // 方法開始\n    → Decision: 如果 isFull? // 檢查是否已滿\n        Yes → Return false // 已滿則失敗\n        No  → head = (head - 1 + k) % k // 往前移動 head\n             → buffer[head] = value // 存入值\n             → size++ // 大小加一\n             → Return true // 成功\n→ Method insertLast(value)\n    … similarly\n\nWe need to produce each line separately. Use \"Step\" maybe with number. Use \"Decision:\" lines with Yes → and No →. Use \"End\" at end of each method? Probably not necessary but can include. They didn't say to wrap each method in Start/End, but we can.\n\nWe should ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\". So we need to keep consistent. Use \"Start\" line first. Then \"→\" lines.\n\nLet's produce. We'll treat each method as separate block, but within we use arrows.\n\nAlso need to mention getFront: return buffer[head] if size>0 else -1. getRear: compute index (tail-1+k)%k.\n\nImplement isEmpty: size==0. isFull: size==k.\n\nLet's produce the virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類 // 建立類別容器  \n→ Step 2: 建立容量為 k 的陣列 buffer // 用於儲存元素  \n→ Step 3: 初始化 head = 0, tail = 0, size = 0 // 指標與計數器  \n→ Decision: 之後可呼叫各個方法進行操作 // 接下來執行具體方法  \n\n// ---------- insertFront ----------\n→ Method insertFront(value) // 開始 insertFront 方法  \n    → Decision: 如果 isFull()? // 檢查是否已滿  \n        Yes → Return false // 已滿則插入失敗  \n        No  → head = (head - 1 + k) % k // head 往前移動  \n             → buffer[head] = value // 存入新值  \n             → size++ // 大小 +1  \n             → Return true // 插入成功  \n→ End // insertFront 方法結束  \n\n// ---------- insertLast ----------\n→ Method insertLast(value) // 開始 insertLast 方法  \n    → Decision: 如果 isFull()? // 檢查是否已滿  \n        Yes → Return false // 已滿則插入失敗  \n        No  → buffer[tail] = value // 存入新值  \n             → tail = (tail + 1) % k // tail 往後移動  \n             → size++ // 大小 +1  \n             → Return true // 插入成功  \n→ End // insertLast 方法結束  \n\n// ---------- deleteFront ----------\n→ Method deleteFront() // 開始 deleteFront 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return false // 空則刪除失敗  \n        No  → head = (head + 1) % k // head 往後移動  \n             → size-- // 大小 -1  \n             → Return true // 刪除成功  \n→ End // deleteFront 方法結束  \n\n// ---------- deleteLast ----------\n→ Method deleteLast() // 開始 deleteLast 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return false // 空則刪除失敗  \n        No  → tail = (tail - 1 + k) % k // tail 往前移動  \n             → size-- // 大小 -1  \n             → Return true // 刪除成功  \n→ End // deleteLast 方法結束  \n\n// ---------- getFront ----------\n→ Method getFront() // 開始 getFront 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return -1 // 空則返回 -1  \n        No  → Return buffer[head] // 返回前端值  \n→ End // getFront 方法結束  \n\n// ---------- getRear ----------\n→ Method getRear() // 開始 getRear 方法  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Return -1 // 空則返回 -1  \n        No  → rearIndex = (tail - 1 + k) % k // 計算後端指標  \n             → Return buffer[rearIndex] // 返回後端值  \n→ End // getRear 方法結束  \n\n// ---------- isEmpty ----------\n→ Method isEmpty() // 開始 isEmpty 方法  \n    → Return size == 0 // 若大小為 0 則為空  \n→ End // isEmpty 方法結束  \n\n// ---------- isFull ----------\n→ Method isFull() // 開始 isFull 方法  \n    → Return size == k // 若大小等於容量則為滿  \n→ End // isFull 方法結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k          # 資料儲存區\n        self.head = 0               # 指向前端位置\n        self.count = 0              # 目前元素個數\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:     # 檢查是否已滿\n            return False\n        self.head = (self.head - 1) % self.k   # 往前移動 head\n        self.buf[self.head] = value            # 放入新值\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k  # 計算插入位置\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k   # 移動 head\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1                         # 只需減少計數，插入時會依照 count 重新定位\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(arg[0])\n            output.append(None)                     # constructor -> null\n        elif op == \"insertFront\":\n            output.append(obj.insertFront(arg[0]))\n        elif op == \"insertLast\":\n            output.append(obj.insertLast(arg[0]))\n        elif op == \"deleteFront\":\n            output.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            output.append(obj.deleteLast())\n        elif op == \"getFront\":\n            output.append(obj.getFront())\n        elif op == \"getRear\":\n            output.append(obj.getRear())\n        elif op == \"isEmpty\":\n            output.append(obj.isEmpty())\n        elif op == \"isFull\":\n            output.append(obj.isFull())\n        else:\n            # 不支援的操作，略過\n            output.append(None)\n\n    print(json.dumps(output))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpghu6va2v.py\", line 62, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: splitting array into k parts minimizing largest sum; classic problem LeetCode 410. Approach: binary search on answer; check feasibility using greedy.\n\nThus we produce pseudo steps line by line. Should be in Chinese. Provide explanation after //.\n\nWe need each line with virtual code step plus explanation.\n\nLet's craft steps: Start, input array nums, k. Determine lower bound (max(nums)), upper bound (sum(nums)). Binary search loop: while low < high. mid = (low+high)/2. Check(mid). If feasible (need <=k subarrays) then high = mid else low = mid+1. After loop return low.\n\nCheck function: count subarrays when splitting with max allowed sum. Iterate nums; accumulate; if exceed mid, start new subarray count++ and reset sum to current num. At end count++ for last. Return count <=k.\n\nLet's produce pseudo code lines:\n\nStart\n→ Step 1: Input nums array and integer k\n→ Decision: Determine minSum = max(nums) // lower bound\n    → Step 2: minSum ← max(nums) // minimal possible largest sum\n→ Decision: Determine maxSum = sum(nums) // upper bound\n    → Step 3: maxSum ← sum(nums) // maximal possible largest sum\n→ Decision: While minSum < maxSum\n    → Step 4: mid ← (minSum + maxSum) / 2 // candidate largest sum\n    → Step 5: If feasible(mid) ≤ k\n        Yes → Step 6: maxSum ← mid // can try smaller\n        No  → Step 7: minSum ← mid + 1 // need larger\n→ End // minSum == maxSum is answer\n→ Step 8: Return minSum // minimized largest sum\n\nFunction feasible(limit)\n→ Start\n→ Step 9: count ← 1 // at least one subarray\n→ Step 10: currentSum ← 0\n→ Decision: For each num in nums\n    → Step 11: If currentSum + num ≤ limit\n        Yes → currentSum ← currentSum + num\n        No  → Step 12: count ← count + 1\n              → Step 13: currentSum ← num\n→ End // loop\n→ Step 14: Return count // number of subarrays needed\n\nWe need each line formatted as per requirement: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" preceding lines after start. For decisions indent accordingly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數陣列 nums 與整數 k // 取得輸入資料\n→ Decision: 計算最小可能最大子陣列和  \n  Yes → Step 2: minSum ← max(nums) // 下界：至少為陣列中最大元素\n→ Decision: 計算最大可能最大子陣列和  \n  Yes → Step 3: maxSum ← sum(nums) // 上界：整個陣列和\n→ Decision: 只要 minSum < maxSum 就持續搜尋  \n  Yes → Step 4: mid ← (minSum + maxSum) / 2 // 取中間值作為候選最大和\n  Decision: 檢查以 mid 為上限能否將 nums 分成 ≤ k 個子陣列  \n   Yes → Step 5: maxSum ← mid // 可行，嘗試更小的最大和  \n   No → Step 6: minSum ← mid + 1 // 不可行，需增大最大和\n→ End // minSum == maxSum 時已找到最小可行最大和\n→ Step 7: Return minSum // 回傳最小化的最大子陣列和\n\nFunction feasible(limit)\n→ Start // 函式開始\n→ Step 8: count ← 1 // 至少一個子陣列\n→ Step 9: currentSum ← 0 // 當前子陣列和\n→ Decision: 對 nums 中每個 num 做迴圈  \n  Yes → Step 10: If currentSum + num ≤ limit  \n    Yes → currentSum ← currentSum + num // 繼續累加\n    No → Step 11: count ← count + 1 // 開新子陣列  \n     → Step 12: currentSum ← num // 將本數字作為新子陣列首項\n→ End // 完成遍歷\n→ Step 13: Return count // 需要的子陣列數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def splitArray(self, nums, m):\n        # Greedy check if we can split into at most m subarrays\n        def can_split(mid):\n            count, curr_sum = 1, 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= m\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef main():\n    data = sys.stdin.read()\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if not nums_match or not k_match:\n        return\n    nums = eval(nums_match.group(1))\n    k = int(k_match.group(1))\n    result = Solution().splitArray(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm computing h-index. We will output line by line with \"Start\" etc. Provide steps: input array, sort descending, iterate until citations[i] < i+1, return i. Use 1-indexed. Provide explanation. Use arrow. Provide each line with comment. Must not output actual code. Just pseudocode. Use arrow arrow. Provide \"→\" lines. Use indentation with 4 spaces? Example uses 4 spaces indentation. We'll produce something similar. We'll maintain \"Decision:\" for checks. Use \"Yes →\" \"No →\" as required. Provide final \"End\".\n\nLet's write:\n\nStart // begin\n→ Step 1: 將 citations 陣列依降序排序 // 排序\n→ Step 2: 初始化 counter h = 0 // 计数器\n→ Step 3: 迭代每個排序後的數值 idx, cite // 循環\n    → Decision: 若 cite >= h+1? // 判斷是否滿足 h+1 次引用\n        Yes → h ← h+1 // h+1 成功，h 加 1\n        No  → Break // 不滿足，結束循環\n→ Step 4: 回傳 h // 返回 h-index\nEnd\n\nNeed to incorporate decisions. Use \"Decision:\" lines. Provide arrows accordingly. Provide indentation of 4 spaces. Let's format. Use \"→ Decision: ...\" lines. Use Yes → and No → inside the block. Use \"Break\" action maybe separate step. Provide explanation comments. Provide \"End\". That should satisfy.\n\nWe must not output any actual code but virtual steps. Good.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 citations 陣列依降序排序 // 先把所有引用次數從大到小排列，方便後續判斷\n→ Step 2: 初始化 counter h = 0 // h 用來記錄目前符合 h‑index 的數量\n→ Step 3: 迭代每個排序後的數值 idx, cite // 逐一檢查每篇論文的引用數\n    → Decision: cite >= h+1? // 判斷此論文是否至少有 h+1 次引用\n        Yes → h ← h+1 // 符合條件，將 h 加 1\n        No  → Break // 不符合條件，跳出迴圈\n→ Step 4: 回傳 h // h 即為最大的 h‑index\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    \"\"\"計算 h-index 的核心函式。\"\"\"\n    citations.sort(reverse=True)      # 降序排列\n    h = 0\n    for i, c in enumerate(citations):\n        if c >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 若輸入形如 \"citations = [3,0,6,1,5]\"，去掉前綴\n    if '=' in raw_input:\n        _, raw_input = raw_input.split('=', 1)\n\n    raw_input = raw_input.strip()\n\n    # 使用 literal_eval 解析成 list；若失敗則透過正則抓數字\n    try:\n        citations = ast.literal_eval(raw_input)\n    except Exception:\n        import re\n        nums = re.findall(r'-?\\d+', raw_input)\n        citations = [int(n) for n in nums]\n\n    # 計算並輸出 h-index\n    print(h_index(citations))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: Given an integer array, return minimum number of moves to make all elements equal, where each move increment/decrement by 1. Classic problem: minimize sum of absolute deviations to median. So algorithm: find median of array, sum abs differences. Steps: sort array, find median (middle). If n odd: median = arr[n/2]. If even: any value between two middle works; choose lower or upper median, sum differences. Provide virtual code lines accordingly. Need step by step: Input array, compute n, sort, compute median, compute total moves, output. Use virtual code format: Start, → Step, Decision etc. Provide explanation comments. Need to ensure each line is separate.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: Read integer array nums // 取得輸入陣列\nLine 3: → Step 2: Let n = length(nums) // 取得陣列長度\nLine 4: → Decision: Is n = 0? // 檢查是否為空陣列\n    Yes → Step 3: Return 0 // 空陣列不需要移動\n    No  → Step 4: Sort nums in non-decreasing order // 排序以便取中位數\nLine 5: → Step 5: If n is odd Then\nLine 6:     → Step 6: median = nums[n/2] // 中位數為中間元素\nLine 7: Else\nLine 8:     → Step 8: median = nums[(n-1)/2] // 取較低的中位數，任一中位數皆可\nLine 9: End of Decision\nLine 10: → Step 9: Initialize totalMoves = 0 // 用於累加所需步數\nLine 11: → For each value v in nums Do\nLine 12:     → Step 10: totalMoves = totalMoves + abs(v - median) // 加上此元素到中位數的差距\nLine 13: End For\nLine 14: → Step 11: Return totalMoves // 回傳最小步數\nLine 15: End // 程式執行結束\n\nNeed proper indentation of decisions and loops. Use \"Decision:\" lines and indent following steps. In sample, they used indentation with spaces. Provide same style. Use \"Yes →\" and \"No →\" with proper indentation. For loops, maybe \"For each value v in nums Do\" and indent inside. End For. Let's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer array nums // 取得輸入陣列  \n→ Step 2: Let n = length(nums) // 取得陣列長度  \n→ Decision: Is n = 0? // 檢查是否為空陣列  \n Yes → Step 3: Return 0 // 空陣列不需要移動  \n No  → Step 4: Sort nums in non-decreasing order // 排序以便取中位數  \n→ Decision: Is n odd? // 判斷陣列長度為奇數還是偶數  \n Yes → Step 5: median = nums[n/2] // 奇數時中位數是中間元素  \n No  → Step 6: median = nums[(n-1)/2] // 偶數時取較低的中位數，任一中位數皆可  \n→ Step 7: Initialize totalMoves = 0 // 用於累加所需步數  \n→ For each value v in nums Do // 遍歷所有元素  \n  → Step 8: totalMoves = totalMoves + abs(v - median) // 加上此元素到中位數的差距  \n→ End For  \n→ Step 9: Return totalMoves // 回傳最小步數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minMoves2(self, nums):\n        if not nums:\n            return 0\n        nums.sort()\n        median = nums[len(nums)//2]\n        moves = 0\n        for num in nums:\n            moves += abs(num - median)\n        return moves\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.minMoves2(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Use sliding window. Steps: Start, input nums, target, initialize variables, loop over right, accumulate sum, while sum>=target, update answer and shrink left. End. Output answer or 0. Need to format with virtual code arrows and comments. Ensure each line ends with // 解釋. Use \"→\" for step lines. Use Decision: lines. Use indent for nested decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums 與目標值 target // 取得使用者輸入的數值  \n→ Step 2: 設定 left = 0, right = 0, sum = 0, ans = ∞ // 初始化滑動視窗指標、累積和及最小長度  \n→ Decision: 是否已遍歷完陣列? // 檢查是否需要進行滑動窗口迴圈  \n    No → Step 3: 將 nums[right] 加入 sum // 右指標所在元素加入累積和  \n    No → Step 4: 右指標右移 (right = right + 1) // 右指標向右移動  \n    No → Decision: sum >= target? // 檢查目前累積和是否達到目標  \n        Yes → Step 5: 更新 ans = min(ans, right - left) // 記錄最小子陣列長度  \n        Yes → Step 6: 將 nums[left] 從 sum 中扣除 // 收縮左指標以尋找更短子陣列  \n        Yes → Step 7: 左指標右移 (left = left + 1) // 左指標向右移動  \n        No  → Decision: 仍未遍歷完陣列? // 若未達目標，繼續向右擴展  \n            Yes → 回到 Step 3  \n            No  → End // 迴圈結束，所有可能已檢查完畢  \n→ Step 8: Decision: ans 仍為 ∞? // 判斷是否找到合法子陣列  \n    Yes → Step 9: 回傳 0 // 沒有符合條件的子陣列  \n    No  → Step 10: 回傳 ans // 回傳最小長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nimport math\n\ndef min_subarray_len(target: int, nums: list[int]) -> int:\n    \"\"\"\n    找到最小長度的子陣列，使其和大於等於 target。\n    若不存在，回傳 0。\n    \"\"\"\n    left = 0\n    total = 0\n    min_len = math.inf\n\n    for right in range(len(nums)):\n        total += nums[right]\n\n        while total >= target:\n            # 更新最小長度\n            min_len = min(min_len, right - left + 1)\n            # 收縮左側\n            total -= nums[left]\n            left += 1\n\n    return 0 if min_len == math.inf else min_len\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從輸入字串中解析 target 與 nums。\n    支援類似 'target = 7, nums = [2,3,1]' 的格式。\n    \"\"\"\n    target_match = re.search(r\"target\\s*=\\s*(\\d+)\", input_str)\n    nums_match = re.search(r\"nums\\s*=\\s*(\\[[^\\]]*\\])\", input_str)\n\n    if not target_match or not nums_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    target = int(target_match.group(1))\n    nums = ast.literal_eval(nums_match.group(1))\n    return target, nums\n\ndef main():\n    # 讀取所有標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    target, nums = parse_input(raw_input)\n    result = min_subarray_len(target, nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode633.json",
    "problem_index_in_file": 0,
    "title": "Sum of Square Numbers",
    "description_snippet": "Given a non-negative integer c, decide whether there're two integers a and b such that a^2 + b^2 = c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to determine whether a given non-negative integer c can be expressed as sum of two squares a^2 + b^prime. We need to provide a step-by-step algorithm.\n\nWe need to generate pseudo-code lines with arrow syntax. Need to include decision branches.\n\nPossible algorithm: iterate a from 0 to sqrt(c), compute b2 = c - a^2, check if b2 is perfect square. If yes return true else false.\n\nWe'll write Start, input c, compute max = floor(sqrt(c)), for loop index a from 0 to max, inside compute b2, check if perfect square. Need decision: if is perfect square then output true, else continue. After loop output false.\n\nWe need to follow format: each line has virtual code step + space + // explanation. Use arrow symbol \"→\".\n\nAlso need decision branches inside for loop. Use \"Decision:\" lines.\n\nOk. We'll produce lines like:\n\nStart // 程式開始執行\n\n→ Input: c // 取得非負整數\n\n→ Set max = floor(sqrt(c)) // 計算 a 的上限\n\n→ For a from 0 to max: // 遍歷所有可能的 a\n\n   → Compute b2 = c - a^2 // 取得 b 的平方值\n\n   → Decision: b2 為非負? // 確保 b2 有意義\n\n       Yes → Decision: 是否為完全平方? // 檢查 b2 是否是平方\n\n           Yes → Return true // 找到 a, b，結束\n\n           No  → Continue // 繼續下一個 a\n\n   No  → Continue // 若 b2 負值，跳過\n\n→ Return false // 未找到任何 a, b\n\nEnd // 程式結束\n\nBut we need to format each line with arrow and explanation. Also need indentation maybe with spaces? The example uses indentation for nested decisions. We can indent by 4 spaces.\n\nWe should maintain \"→\" before each step. For nested decisions we use \"    Yes → ...\" etc.\n\nNeed to use `Decision:` lines to denote if condition.\n\nThus final answer in Chinese. Let's produce.\n\nAlso ensure no code block markers? The example shows code block but with backticks. But we need to output just the lines. It's okay to wrap in code fences? The instruction didn't say no fences. But example shows code block. We can output as code block for readability. I'll output inside triple backticks. Each line within.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input c // 取得非負整數\n→ Set max = floor(sqrt(c)) // 計算 a 的上限\n→ For a = 0 to max: // 遍歷所有可能的 a\n    → Compute b2 = c - a^2 // 取得 b 的平方值\n    → Decision: b2 >= 0? // 確保 b2 為非負\n        Yes → Decision: b2 是否為完全平方? // 檢查 b2 是否可以寫成 b^2\n            Yes → Return true // 找到符合條件的 a, b，結束\n            No  → Continue // 不是完全平方，繼續下一個 a\n        No  → Continue // b2 為負，跳過\n→ Return false // 未找到任何 a, b\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport math\nimport re\n\nclass Solution:\n    def judgeSquareSum(self, c: int) -> bool:\n        # 兩指標法：左指標從 0 開始，右指標從 sqrt(c) 開始\n        left, right = 0, int(math.isqrt(c))\n        while left <= right:\n            total = left * left + right * right\n            if total == c:\n                return True\n            elif total < c:\n                left += 1\n            else:\n                right -= 1\n        return False\n\ndef parse_input(data: str) -> int:\n    \"\"\"\n    從輸入字串中提取第一個非負整數。\n    支援「c = 5」或單獨「5」等格式。\n    \"\"\"\n    match = re.search(r'(-?\\d+)', data)\n    if match:\n        return int(match.group(1))\n    raise ValueError(\"無法解析輸入中的整數\")\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read()\n    try:\n        c = parse_input(raw_input)\n    except ValueError:\n        # 若無法解析，直接終止\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.judgeSquareSum(c)\n    # 按題目要求輸出小寫字串\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "c = 5",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "c = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode667.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement II",
    "description_snippet": "Given two integers n and k, construct a list answer that contains n different positive integers rang...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem. Not actual code, but a step-by-step pseudocode with explanations. Should be line by line, using arrows, etc.\n\nWe need to produce steps: Start, maybe Input n,k, create answer list, produce pattern such that differences have exactly k distinct values.\n\nWe need to design algorithm: There is known solution: Use array of 1..n but reorder such that the differences produce exactly k distinct values. Approach: Start with array [1,2,3,...,n] gives differences all 1 distinct. To increase distinct count, we can use a pattern: For k=1, just sorted list. For larger k, we can interleave extremes: produce sequence: 1, n, 2, n-1, 3, n-2, ... until we have n elements. This yields differences: n-1, n-2, n-3,... which distinct counts equal n-1. For general k, we can produce first 2k elements using pattern of extremes to get k distinct differences? Let's recall typical solution: For given n,k produce array: 1, n, 2, n-1, 3, ... until we have k+1 elements? Wait.\n\nWe need exactly k distinct differences. Known approach: For k=1: 1..n.\n\nFor k>1: produce array: first 2k elements using pattern: low=1, high=n; produce low, high, low+1, high-1, ... until k elements? Actually we need k distinct differences; by constructing pattern of extremes, we get differences: n-1, n-2, ... etc giving distinct differences up to k? Let's analyze.\n\nSuppose we construct array of length k+1 using pattern: 1, n, 2, n-1, ... This will produce differences: n-1, n-2, n-3, ...? For example n=10, k=4, pattern: 1,10,2,9 -> differences:9,8,7. Distinct 3 only. Need 4 distinct? maybe need k+1 elements to get k distinct differences? For differences between consecutive elements. If we have sequence with 5 elements: 1,10,2,9,3 -> differences:9,8,7,6 -> 4 distinct. So we need k+1 elements. So general approach: first part length k+1 produce k distinct differences. Then fill remaining numbers in increasing order from k+2 to n (or remaining unused numbers). These additional numbers will produce difference 1 (or maybe difference 1 if we append sorted). But they might introduce new distinct values? We need ensure they don't add new distinct values beyond k. If we append numbers that are consecutive, difference 1 may already exist? In the first part, differences are descending from n-1 to n-k. That set does not include 1 unless n-k=1? For n>k+1, n-k>=? If k <= n-1, n-k >=1. For n>k+1, n-k >1. So 1 is not present. So appending sorted numbers may introduce difference 1, adding new distinct value. So we need to avoid adding new differences. So we need to arrange the rest to produce differences from the existing set. A known solution: After the first k+1 elements, continue with remaining numbers in natural order from k+2 to n (or from something). Let's test: n=10, k=4, first part 1,10,2,9,3. Differences:9,8,7,6. Remaining numbers: 4,5,6,7,8? Wait used numbers:1,10,2,9,3. Remaining:4,5,6,7,8. Append in increasing order: ...3,4,5,6,7,8. Differences after 3 to 4 is 1 (new). Not good.\n\nAlternate approach: After first k+1, we can append remaining numbers in a way that differences are from existing set. Known solution: Append numbers in increasing order from k+2 to n? That gives difference maybe 1 again. Another known pattern: For remaining numbers, just continue with numbers from k+2 to n in natural order but start from something that difference equals previous difference? Wait.\n\nI think known official solution: Construct array by placing first k+1 numbers alternating from left and right: 1, n, 2, n-1, ... until we have k+1 numbers. Then fill remaining numbers from k+2 to n in natural order. But need to check difference distinct count.\n\nLet's test with n=10,k=4: first 5 numbers: 1,10,2,9,3. Differences:9,8,7,6. Now remaining numbers 4,5,6,7,8. Append: 4: diff=1 (new). So total distinct becomes 5.\n\nBut maybe we don't need to include 4..8; we could just fill the rest with numbers that produce difference from existing set? For example, after 3, we can append 8,7,6,5,4 (descending). Let's test: sequence: 1,10,2,9,3,8,7,6,5,4. Differences:9,8,7,6,5,1,1,1,1. Distinct:9,8,7,6,5,1 -> 6 distinct >k.\n\nAnother method: After the first k+1 elements, just append the remaining numbers in natural order but skip the ones that cause new difference? Hmm.\n\nLet's recall known solutions: For this problem \"Construct Array With K Distinct Differences\" on LeetCode, typical solution: Build answer by alternating from left and right for first k+1 elements, then fill the rest with remaining numbers increasing. That actually yields exactly k distinct differences, because the first k+1 differences are distinct descending values from k to 1? Wait maybe they are descending from k to 1, not from n-1. Let's compute: For n=10,k=4: We want differences {1,2,3,4}. Sequence produced by algorithm: start=1, end=n, left=1,right=n. For i=0..k: if i%2==0: append left; left++; else: append right; right--. After k+1=5 elements: 1,10,2,9,3. Differences:9,8,7,6 -> not 1..k. So not correct.\n\nBut known trick: Use numbers from 1 to k+1 to produce differences k, k-1, ... 1. Example: n=10,k=4: Use 1..5: 1,5,2,4,3 differences:4,3,2,1. Then append remaining numbers 6..10 in order: 6,7,8,9,10. Differences after 3 to 6 is 3? 3? 3? Let's compute: 1,5,2,4,3,6,7,8,9,10. Differences:4,3,2,1,3,1,1,1,1. Distinct:1,2,3,4 -> exactly 4. Good! So algorithm: use first k+1 numbers 1..k+1 but rearranged to create descending differences. Then append rest numbers k+2..n in increasing order.\n\nThus we need to construct first part: Use low=1, high=k+1; alternate between low, high, low+1, high-1, etc. This yields differences: k, k-1, k-2, ..., 1. Then fill rest numbers ascending.\n\nEdge case: k=1 -> first part 1,2 differences 1; rest numbers 3..n appended. Works.\n\nEdge case: k=n-1 -> first part 1..n rearranged produce differences n-1...1; rest none.\n\nAlgorithm steps:\n\n1. Read n,k.\n2. Initialize empty answer list.\n3. low=1, high=k+1.\n4. While low <= high:\n    - if count even: append low; low++.\n    - else: append high; high--.\n5. Append remaining numbers from k+2 to n in ascending order.\n\nReturn answer.\n\nNow produce virtual code line by line.\n\nLet's produce step list.\n\nWe need to use arrows.\n\nLet's produce like:\n\nStart\n→ Step 1: Input integers n, k // 取得 n 與 k\n→ Step 2: Initialize answer as empty list // 建立空結果列表\n→ Step 3: Set low = 1, high = k + 1 // 設定首尾指標\n→ Step 4: Set flag = 0 // 用於交替決定加入 low 或 high\n→ Decision: 低 ≤ 高? // 是否仍有未加入的數字\n    Yes → Decision: flag 為偶數? // 判斷應加入 low 或 high\n        Yes → Step 5: Append low to answer // 加入低端數字\n        Yes → Step 6: low = low + 1 // 移動低端\n        No  → Step 7: Append high to answer // 加入高端數字\n        No  → Step 8: high = high - 1 // 移動高端\n        → Step 9: flag = flag + 1 // 更新交替標記\n        → Decision: 再次檢查 低 ≤ 高? // 迴圈判斷\n            Yes → 回到 Decision: flag 為偶數? // 重新進行交替\n            No  → End of first part // 結束首部構造\n    No  → End of first part // 若 low > high\n→ Step 10: For num from k + 2 to n // 追加剩餘數字\n    → Step 11: Append num to answer // 加入遞增數字\n→ End // 返回答案\n\nNeed to make sure indentation and arrow format.\n\nLet's produce in required format.\n\nNeed each line: \"虛擬碼步驟 // 解釋\"\n\nAlso use arrows for decisions: \"Decision:\" lines, with \"Yes →\" etc.\n\nNeed to maintain structure.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入兩個整數 n, k // 從使用者取得 n 與 k  \n→ Step 2: 建立空的答案列表 answer // 用於儲存結果  \n→ Step 3: 設定 low = 1, high = k + 1 // 定義首尾指標  \n→ Step 4: 設定 flag = 0 // 交替判斷使用 low 或 high  \n→ Decision: 是否還有未加入的數字 (low ≤ high)?  \n Yes → Decision: flag 是否為偶數 (flag mod 2 == 0)?  \n  Yes → Step 5: 把 low 加入 answer // 加入左端數字  \n  Yes → Step 6: low = low + 1 // 移動左端指標  \n  No → Step 7: 把 high 加入 answer // 加入右端數字  \n  No → Step 8: high = high - 1 // 移動右端指標  \n  → Step 9: flag = flag + 1 // 更新交替標記  \n  → Decision: 再次檢查 low ≤ high?  \n   Yes → 回到 Decision: flag 是否為偶數?  \n   No → End of first part // 首部構造完成  \n No → End of first part // low 已超過 high，跳出循環  \n→ Step 10: 從 num = k + 2 到 n 依序執行  \n → Step 11: 把 num 加入 answer // 追加剩餘遞增數字  \n→ End // 程式執行結束，返回 answer",
      "generated_code": "import sys\nimport re\n\ndef construct_array(n: int, k: int) -> list[int]:\n    \"\"\"\n    Build an array of length n that contains each number from 1 to n exactly once,\n    such that the list of absolute differences between consecutive elements\n    has exactly k distinct values.\n    \"\"\"\n    result = []\n    left, right = 1, k + 1\n\n    # 先用 1 ~ k+1 生成 k 個不同的差值\n    for i in range(k + 1):\n        if i % 2 == 0:\n            result.append(left)\n            left += 1\n        else:\n            result.append(right)\n            right -= 1\n\n    # 再把剩下的數字遞增放進去\n    for num in range(k + 2, n + 1):\n        result.append(num)\n\n    return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if len(numbers) >= 2:\n        n, k = numbers[0], numbers[1]\n        answer = construct_array(n, k)\n        print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 1",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 1,
          "input": "n = 3, k = 2",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The algorithm: binary search on integer range 0 to x inclusive. Need to find largest integer mid such that mid*mid <= x. Edge case x=0. No exponent.\n\nSo steps: Start, handle x=0, else low=1, high=x, while low <= high: mid=(low+high)//2, square=mid*mid. Decision: if square==x -> return mid. Else if square < x: low=mid+1; else high=mid-1. After loop, return high (largest mid whose square <=x). End.\n\nWe need to produce lines with \"→ Step\" etc. Let's structure:\n\nStart // 程式開始\n\n→ Step 1: If x == 0 → return 0 // 特殊情況\n\n→ Step 2: low = 1 // 初始化搜索範圍\n\n→ Step 3: high = x\n\n→ Step 4: While low <= high\n\n   → Step 5: mid = (low + high) // 2 // 計算中點\n\n   → Step 6: square = mid * mid // 計算平方\n\n   → Decision: if square == x ?\n\n       Yes → Step 7: return mid // 完整平方，直接回傳\n\n       No → Decision: if square < x ?\n\n           Yes → Step 8: low = mid + 1 // 仍小於x，向右擴\n\n           No → Step 9: high = mid - 1 // 大於x，向左縮\n\nEnd // 程式結束\n\nBut we also need to return high after loop. Add Step 10: return high // 最終答案\n\nBut ensure that Step 10 is after loop. Let's incorporate loop structure. Use indentation maybe not required but we can show nested steps.\n\nBut formatting: Each line must be \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nUse arrows '→' before step lines, and 'Decision:' lines. For loops: maybe use '→ While ...' and then indent following lines? The sample shows indentation within decisions. We can replicate.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Decision: 如果 x == 0? // 檢查特殊情況\n\n    Yes → Step 1: 回傳 0 // x 為零，平方根為零\n\n    No  → Step 2: low = 1 // 初始化下界\n\n→ Step 3: high = x // 初始化上界\n\n→ While low <= high // 進行二分搜尋\n\n    → Step 4: mid = (low + high) // 2 // 計算中點\n\n    → Step 5: square = mid * mid // 計算平方\n\n    → Decision: 如果 square == x? // 檢查是否正好等於 x\n\n        Yes → Step 6: 回傳 mid // 完整平方，回傳中點\n\n        No  → Decision: 如果 square < x? // 小於 x，向右擴\n\n            Yes → Step 7: low = mid + 1 // 設定新下界\n\n            No  → Step 8: high = mid - 1 // 設定新上界\n\n→ Step 9: 回傳 high // 搜尋結束後 high 為平方根下取整\n\nEnd // 程式結束\n\nNeed to add comments: // 解釋/說明.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n\n→ Decision: 如果 x == 0? // 檢查特殊情況  \n    Yes → Step 1: 回傳 0 // x 為零，平方根為零  \n    No  → Step 2: low = 1 // 初始化下界  \n\n→ Step 3: high = x // 初始化上界  \n\n→ While low <= high // 進行二分搜尋  \n    → Step 4: mid = (low + high) // 2 // 計算中點  \n    → Step 5: square = mid * mid // 計算平方  \n    → Decision: 如果 square == x? // 檢查是否正好等於 x  \n        Yes → Step 6: 回傳 mid // 完整平方，回傳中點  \n        No  → Decision: 如果 square < x? // 小於 x，向右擴  \n            Yes → Step 7: low = mid + 1 // 設定新下界  \n            No  → Step 8: high = mid - 1 // 設定新上界  \n\n→ Step 9: 回傳 high // 搜尋結束後 high 為平方根下取整  \n\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef sqrt_floor(x: int) -> int:\n    \"\"\"Return the integer part of the square root of x.\"\"\"\n    if x < 2:\n        return x\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2\n        prod = mid * mid\n        if prod == x:\n            return mid\n        elif prod < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中擷取第一個整數\n    m = re.search(r'-?\\d+', data)\n    if not m:\n        return\n    x = int(m.group())\n    result = sqrt_floor(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for parsing nested list serialization into NestedInteger. No real code, just steps.\n\nThe input string s like \"123\" or \"[123,[456,[789]]]\" etc.\n\nWe need to produce virtual code with steps: start, for each char, push/pop stack, etc. Then return top-level NestedInteger.\n\nWe produce steps line by line with comments.\n\nWe need to ensure use of arrow symbols and decisions.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化空堆疊 `stack` 用於存放 NestedInteger // create stack\n\n→ Decision: 如果 s 為單個整數 (不含 '[')? // Check if string has no '['\n\n   Yes → Step 2: 轉成整數, 包裝成 NestedInteger 並返回 // return result\n\n   No  → Step 3: 解析整個序列 // else parse\n\n→ Step 4: 建立空 NestedInteger `current` 並 push 進 stack // push root\n\n→ Loop: 遍歷 s 的每個字符 (index i) // iterate\n\n   → Decision: 字符是 '['? // start list\n\n      Yes → Step 5: 建立新空 NestedInteger `newList`, push 進 stack // push new list\n\n      No → Decision: 字符是 ']'? // end list\n\n         Yes → Step 6: pop stack, 得到 `finishedList` // pop finished list\n\n            → If stack not empty: 把 `finishedList` 加到 stack.top() 的子列表中 // add to parent\n\n            → Else: set `current` = `finishedList` // root list\n\n         No → Decision: 字符是 ','? // separator\n\n            Yes → Skip // ignore comma\n\n            No → Decision: 字符是數字或負號? // number start\n\n               Yes → Step 7: 解析完整數字 (直到非數字) // parse number\n\n                  → Step 8: 創建 NestedInteger 整數, 加到 stack.top() 的子列表中 // add number\n\n               No → Skip // other chars (should not happen)\n\n→ End // 程式結束\n\n→ Step 9: 返回 `current` // return root\n\nAdd comments in Traditional Chinese.\n\nLet's write each step with arrow and comment.\n\nWe need to use virtual arrow '→' before each step.\n\nWe must include decisions lines with indentation.\n\nLet's craft.\n\nAlso we might need Step numbers but optional. Use descriptive names.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空堆疊 `stack` 用來存放 NestedInteger 物件 // 建立堆疊以協助遞歸解析  \n→ Decision: 如果輸入字串 `s` 中不含 '['，代表它是一個單純的整數? // 檢查是否為單一整數  \n    Yes → Step 2: 將字串轉為整數後包裝成 NestedInteger，並直接回傳 // 結束，返回結果  \n    No  → Step 3: 進入複雜結構解析流程 // 否則繼續解析複雜序列  \n→ Step 4: 建立一個空的 NestedInteger `root`，將其 push 到 `stack` 中 // 初始化根節點  \n→ Loop: 逐字符遍歷字串 `s`（使用索引 i）  \n    → Decision: 字符是 '['? // 開始一個新子列表  \n        Yes → Step 5: 建立新的空 NestedInteger `newList`，push 到 `stack` 中 // 推進子列表  \n        No → Decision: 字符是 ']'? // 結束當前子列表  \n            Yes → Step 6: pop `stack`，得到 `finishedList` // 取出完成的子列表  \n                → Decision: `stack` 仍非空? // 是否還有父層存在  \n                    Yes → Step 7: 把 `finishedList` 加到 `stack.top()` 的子列表中 // 加入父節點  \n                    No  → Step 8: 把 `finishedList` 設為 `root` // 完整序列解析完畢，設為根節點  \n            No → Decision: 字符是 ','? // 逗號是分隔符，忽略  \n                Yes → Step 9: 直接跳過 // 不做任何處理  \n                No → Decision: 字符是數字或負號? // 數字開頭  \n                    Yes → Step 10: 解析完整數字（直到遇到非數字為止）  \n                        → Step 11: 建立 NestedInteger 整數，並加入 `stack.top()` 的子列表中 // 把數字加入父節點  \n                    No → Step 12: 跳過（這裡不會發生，但保持健全）  \n→ End // 所有字符已處理完畢  \n→ Step 13: 回傳 `root` // 返回最終解析得到的 NestedInteger 結構",
      "generated_code": "class NestedInteger:\n    \"\"\"A minimal implementation of LeetCode's NestedInteger for this problem.\"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._integer = None\n        else:\n            self._integer = value\n            self._list = None\n\n    def isInteger(self):\n        return self._integer is not None\n\n    def add(self, ni):\n        if self._list is None:\n            self._list = []\n        self._list.append(ni)\n\n    def setInteger(self, value):\n        self._integer = value\n        self._list = None\n\n    def getInteger(self):\n        return self._integer\n\n    def getList(self):\n        return self._list\n\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        \"\"\"Deserialize a string into a NestedInteger structure.\"\"\"\n        if not s:\n            return NestedInteger()\n\n        # If the string does not start with '[', it is a single integer.\n        if s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []          # Stack to hold NestedInteger objects.\n        num = ''            # Current number being parsed as a string.\n        negative = False    # Flag to indicate a negative number.\n\n        for c in s:\n            if c == '-':\n                negative = True\n            elif c.isdigit():\n                num += c\n            elif c == '[':\n                stack.append(NestedInteger())\n            elif c in ',]':\n                # Finish a number when we encounter a separator or closing bracket.\n                if num:\n                    value = int(num)\n                    if negative:\n                        value = -value\n                    stack[-1].add(NestedInteger(value))\n                    num = ''\n                    negative = False\n\n                # If we hit a closing bracket, pop the finished list and\n                # add it to its parent (if there is one).\n                if c == ']' and len(stack) > 1:\n                    finished = stack.pop()\n                    stack[-1].add(finished)\n\n        # The root of the nested structure is the only item left on the stack.\n        return stack[0]\n\n\ndef nested_integer_to_str(ni: NestedInteger) -> str:\n    \"\"\"Convert a NestedInteger back to its string representation.\"\"\"\n    if ni.isInteger():\n        return str(ni.getInteger())\n    return '[' + ','.join(nested_integer_to_str(x) for x in ni.getList()) + ']'\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # Read entire input from stdin.\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Extract the string inside quotes if present.\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = raw_input[first_quote + 1:last_quote]\n    else:\n        # If no quotes are found, assume the whole input is the string.\n        s = raw_input\n\n    solution = Solution()\n    nested_obj = solution.deserialize(s)\n    output = nested_integer_to_str(nested_obj)\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": true,
          "output": "[123,[456,[789]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for sum of Hamming distances of all pairs. Provide line by line with arrow. We'll implement efficient method: For each bit position 0-31, count number of numbers with bit 1 and bit 0; contribution to sum is count1 * count0 * 2? Actually each pair counted once, not directed. For all unordered pairs, each pair contributes 1 if bits differ. For each bit, number of pairs differing = count1 * count0. Sum over bits. Complexity O(n*32). Provide pseudocode. Use Start, Decision etc.\n\nLet's craft lines:\n\nStart\n→ Step 1: 初始化 sum = 0 // 用於累計 Hamming 距離\n→ Step 2: for bit = 0 to 31 // 逐位檢查\n    → Step 3: 初始化 count1 = 0 // 計算當前位為 1 的數量\n    → Step 4: for each num in nums\n        → Decision: 若 (num >> bit) & 1 == 1?\n            Yes → Step 5: count1 = count1 + 1 // 增加 1 位數量\n            No  → Step 6: /* do nothing */ // 1 位為 0 的數量可通過總數減 count1\n    → Step 7: count0 = nums.length - count1 // 0 位數量\n    → Step 8: sum = sum + count1 * count0 // 將此位的貢獻加入總和\n→ Step 9: return sum // 回傳結果\nEnd\n\nAdd explanation comments each line. Ensure arrow formatting. Also need to ensure Decision blocks with Yes and No arrows.\n\nLet's write.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: sum ← 0 // 用於累計所有數對的 Hamming 距離\n→ Step 2: for bit ← 0 to 31 // 逐位檢查 32 位整數\n    → Step 3: count1 ← 0 // 當前位為 1 的數量\n    → Step 4: for each num in nums // 逐個數字判斷該位\n        → Decision: 若 (num >> bit) & 1 == 1? // 檢查 bit 位是否為 1\n            Yes → Step 5: count1 ← count1 + 1 // 若為 1，累加計數\n            No  → Step 6: /* do nothing */ // 若為 0，無需處理\n    → Step 7: count0 ← nums.length - count1 // 該位為 0 的數量\n    → Step 8: sum ← sum + count1 * count0 // 此位對所有數對的貢獻\n→ Step 9: return sum // 回傳總 Hamming 距離\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def totalHammingDistance(self, nums):\n        total = 0\n        n = len(nums)\n        for i in range(32):  # 32 位整數\n            count_ones = sum((num >> i) & 1 for num in nums)\n            count_zeros = n - count_ones\n            total += count_ones * count_zeros\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中尋找第一個 '[' 和最後一個 ']'，並將中間的字串解析為列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        nums = ast.literal_eval(data[start:end+1])\n    else:\n        nums = []\n\n    result = Solution().totalHammingDistance(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step for counting distinct subsequences of s that equal t. That's classic DP: dp[i][j] = number of subseqs of s[:i] that equal t[:j]. Use 1-indexing: dp[0][0]=1, dp[0][j>0]=0. Recurrence: if s[i-1]==t[j-1]: dp[i][j] = dp[i-1][j] + dp[i-1][j-1]; else dp[i][j] = dp[i-1][j]. Or use 1D dp: iterate i over s, j over t reversed. Implementation details.\n\nWe need to produce virtual code lines with explanations. Should include Start, End, Decision, Step lines. We'll produce algorithm: initialize dp array of length t+1, set dp[0] = 1. Iterate over each char in s, update dp in reverse order j from len(t) down to 1: if s_char == t[j-1], dp[j] += dp[j-1]. Finally return dp[len(t)].\n\nAlso handle edge cases: if t longer than s => 0.\n\nWe need to format exactly: each line \"虛擬碼步驟 // 解釋\" etc. Use arrow syntax.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Decision: t長度 > s長度? // 檢查是否可能有子序列\n    Yes → Step: 回傳 0 // 如果t更長，無法匹配\n    No → Step: 建立 dp陣列長度 |t|+1, 並將 dp[0] 設為 1 // 初始化\n→ Step: 對於每個字元 s[i] 從前到後\n    → 迴圈: j 由 |t| 到 1\n        → Decision: s[i] == t[j-1]?\n            Yes → Step: dp[j] = dp[j] + dp[j-1] // 匹配時累加\n            No  → Step: dp[j] 不變 // 不匹配不改變\n→ Step: 回傳 dp[|t|] // 最後結果\nEnd // 程式執行結束\n\nBut we need to ensure each line is separate: start, arrow decisions and steps. Use proper indentation maybe. Use \"→\" for sequential steps. Provide explanations in Chinese.\n\nLet's produce. Ensure no extra text.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: t長度 > s長度? // 檢查 t 是否長於 s，若長則無法匹配  \n  Yes → Step: 回傳 0 // t 長於 s 時立即回傳 0  \n  No  → Step: 建立 dp 陣列長度 |t|+1，並將 dp[0] 設為 1 // 初始化 DP，dp[0] 代表空子序列  \n→ Step: 對 s 中每個字元 s_char 逐一處理  \n  → 迴圈: j 由 |t| 下降到 1  \n    → Decision: s_char == t[j-1]? // 判斷當前字元是否與 t 的第 j 個字元相符  \n     Yes → Step: dp[j] = dp[j] + dp[j-1] // 匹配時把前一個位置的計數累加進來  \n     No  → Step: dp[j] 保持不變 // 不匹配時 dp[j] 不變  \n→ Step: 回傳 dp[|t|] // dp 最後一個位置即為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_distinct(s: str, t: str) -> int:\n    \"\"\"計算 s 的子序列中等於 t 的數量。\"\"\"\n    m, n = len(s), len(t)\n    # dp[j] 代表前 i 個 s 的字元中，能匹配到 t[:j] 的子序列數量\n    dp = [0] * (n + 1)\n    dp[0] = 1  # 空字串總是能匹配\n    for ch_s in s:\n        # 逆向更新，避免覆蓋前一個字元的結果\n        for j in range(n, 0, -1):\n            if ch_s == t[j - 1]:\n                dp[j] += dp[j - 1]\n    return dp[n]\n\ndef parse_input(data: str):\n    \"\"\"從輸入資料中抽取 s 與 t。\"\"\"\n    # 先尋找被雙引號包起來的字串\n    quotes = re.findall(r'\"([^\"]*)\"', data)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n    # 再嘗試空白分隔\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 最後回退到兩行輸入\n    lines = data.strip().splitlines()\n    s = lines[0].strip()\n    t = lines[1].strip() if len(lines) > 1 else ''\n    return s, t\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s, t = parse_input(raw)\n    result = num_distinct(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (flowchart style) describing the data structure: a WordDictionary class with addWord and search, with dot support. We need line by line with explanations. Use Start, End, Decision, etc. Must not produce actual code. We need a step-by-step representation: e.g., start, initialize root, addWord logic (insert into trie), search logic (DFS). Use arrows and decisions.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\".\n\nWe should keep concise. Provide structure:\n\nStart\n→ Step 1: WordDictionary() // 初始化空字典\n→ Step 2: 建立 TrieNode root // 根節點\n→ End // 初始化完成\n\nBut that's not typical. Instead, maybe a main flow for adding and searching. We can show generic usage: adding word and searching. Or we can present the logic for methods. The prompt: \"Implement the WordDictionary class\" so likely we need to produce algorithm steps for addWord and search, with dot support.\n\nThus we can produce a virtual code that includes:\n\nStart\n→ Class WordDictionary\n    → Constructor: create root node\n→ End\n\nThen separate flows for addWord and search.\n\nFor addWord:\n    → Step 1: current = root\n    → For each char in word\n        → If child not exist create\n        → current = child\n    → Mark end of word at current node\n\nFor search:\n    → Define recursive function searchHelper(node, word, index)\n    → If index == len(word) return node.is_end\n    → char = word[index]\n    → If char != '.':\n        → child = node.children.get(char)\n        → If child null return False\n        → return searchHelper(child, word, index+1)\n    → Else:\n        → For each child in node.children.values():\n            → If searchHelper(child, word, index+1) True return True\n        → return False\n    → Call searchHelper(root, word, 0)\n\nWe need to format using arrows, decisions. For each step, explain.\n\nAlso need Start/End for each method? We can use decision: If char== '.'? etc.\n\nLet's craft the virtual code. Use arrow lines for each step. Provide explanation after //.\n\nWe must output each line with \"虛擬碼步驟 // 解釋\" but not actual code. Use Chinese.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: WordDictionary() // 建構子：建立根節點\n\n→ Step 2: 根節點初始化 children={}，is_end=False // 為 Trie 節點設定空字典與終止標記\n\nEnd // WordDictionary 初始化完成\n\nThen addWord:\n\nStart // addWord 進程開始\n\n→ Step 1: current ← root // 從根節點開始\n\n→ Decision: 迭代每個字元 c in word // 逐字插入\n\n    → Yes → Step 2: 若 current.children 不含 c 則創建新節點 // 新字元需新節點\n\n    → Step 3: current ← current.children[c] // 移動到該子節點\n\n→ Step 4: current.is_end ← True // 標記單詞結束\n\nEnd // addWord 完成\n\nThen search:\n\nStart // search 進程開始\n\n→ Step 1: 呼叫 searchHelper(root, word, 0) // 從根開始深度優先搜尋\n\n→ Function searchHelper(node, word, idx) // 定義遞迴協助函式\n\n    → Decision: idx == len(word)？ // 是否已到字串末尾\n\n        → Yes → Return node.is_end // 若是，檢查是否為單詞結束\n\n        → No  → Decision: word[idx] == '.'？ // 是否為通配符\n\n            → Yes → Step 2: 對每個子節點 child in node.children.values()\n\n                → Decision: searchHelper(child, word, idx+1) 為 True？ // 進一步匹配\n\n                    → Yes → Return True // 找到匹配\n\n                → End for\n\n                → Return False // 所有子節點均不匹配\n\n            → No  → Step 3: child ← node.children.get(word[idx]) // 獲取對應子節點\n\n                → Decision: child 為 Null？\n\n                    → Yes → Return False // 該字元不存在\n\n                    → No  → Return searchHelper(child, word, idx+1) // 進一步遞迴\n\nEnd // search 進程結束\n\nReturn value of searchHelper returned to search\n\nReturn boolean\n\nEnd\n\nBut we must keep each line separate. Use the arrow notation \"→\" or \"→ Step\" etc. Provide explanation after //.\n\nMake sure to use the required structure: each line must contain 虛擬碼步驟 + space + // 解釋/說明.\n\nAlso we need to include Decision: ... and Yes→, No→ lines.\n\nLet's produce the output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class WordDictionary // 定義單詞字典類  \n  → Constructor: Create root TrieNode // 初始化根節點  \n   → Step 1: root.children ← {} // 子節點字典  \n   → Step 2: root.is_end ← False // 結束標記  \n  End // WordDictionary 構造完成  \nEnd // 程式結束  \n\n---  \n\nStart // addWord 方法開始  \n→ Step 1: current ← root // 從根節點開始  \n→ Decision: For each character c in word? // 逐字插入  \n  Yes → Step 2: 若 current.children 沒有 c 則 new TrieNode() // 新字元需新節點  \n   → current.children[c] ← new_node  \n  Yes → Step 3: current ← current.children[c] // 移到該子節點  \n→ Step 4: current.is_end ← True // 標記單詞結束  \nEnd // addWord 完成  \n\n---  \n\nStart // search 方法開始  \n→ Step 1: Return searchHelper(root, word, 0) // 從根節點深度優先搜尋  \n→ Function searchHelper(node, word, idx) // 定義遞迴輔助函式  \n  → Decision: idx == len(word)? // 是否到字串結尾  \n   Yes → Return node.is_end // 若是，檢查是否為單詞結束  \n   No → Decision: word[idx] == '.'? // 是否為通配符  \n    Yes → Step 2: For each child in node.children.values() // 遍歷所有子節點  \n      → Decision: searchHelper(child, word, idx+1) == True? // 進一步匹配  \n       Yes → Return True // 找到匹配  \n      End for  \n      Return False // 所有子節點均不匹配  \n    No  → Step 3: child ← node.children.get(word[idx]) // 取對應子節點  \n      → Decision: child is None?  \n       Yes → Return False // 該字元不存在  \n       No  → Return searchHelper(child, word, idx+1) // 進一步遞迴  \nEnd // search 方法結束\n\n---  \n\nStart // 使用範例  \n→ Step 1: dict ← WordDictionary() // 建立字典實例  \n→ Step 2: dict.addWord(\"bad\") // 加入單詞  \n→ Step 3: dict.addWord(\"dad\") // 加入單詞  \n→ Step 4: dict.addWord(\"mad\") // 加入單詞  \n→ Step 5: dict.search(\"pad\") // 例：搜尋「pad」 → False  \n→ Step 6: dict.search(\"bad\") // 例：搜尋「bad」 → True  \n→ Step 7: dict.search(\".ad\") // 例：搜尋「.ad」 → True  \n→ Step 8: dict.search(\"b..\") // 例：搜尋「b..」 → True  \nEnd // 範例執行完畢",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node, idx):\n            if idx == len(word):\n                return node.is_end\n            ch = word[idx]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, idx + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], idx + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit()\n    # Wrap the two arrays into a single JSON array for parsing\n    try:\n        data = json.loads(\"[\" + data_str + \"]\")\n    except json.JSONDecodeError:\n        # Fallback to eval if json fails (handles single quotes etc.)\n        data = ast.literal_eval(\"[\" + data_str + \"]\")\n    ops, args = data[0], data[1]\n    results = []\n    word_dict = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            word_dict = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            word_dict.addWord(arg[0])\n            results.append(None)\n        elif op == \"search\":\n            res = word_dict.search(arg[0])\n            results.append(res)\n    # Convert results to JSON for correct null/true/false formatting\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": true,
          "output": "[null, null, null, null, false, true, true, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode556.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element III",
    "description_snippet": "Given a positive integer n, find the smallest integer which has exactly the same digits existing in ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The requirement: start with Start, End. We need to solve \"next greater number with same digits\" typical problem. Steps: check if n > 2^31-1? but n input is positive integer presumably fits. Approach: Convert to list of digits. Find pivot from right where digits[i] < digits[i+1]. If none, return -1. Then find rightmost successor > pivot. Swap. Then reverse suffix. Check if result > 2^31-1. If yes return -1 else result.\n\nWe need to output each line: virtual code step and comment.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: digits ← Convert n to list of characters // 轉換為字元陣列\n→ Step 2: pivot ← -1 // 記錄 pivot 位置\n→ Step 3: For i from len(digits)-2 downto 0: // 從倒數第二個往前找\n    → Decision: If digits[i] < digits[i+1]? // 判斷是否可做 pivot\n        Yes → pivot ← i // 記錄 pivot\n        No → Continue // 仍往前\n→ Decision: If pivot = -1? // 無法找到更大的排列\n    Yes → Step 4: Return -1 // 無解\n    No →\n→ Step 5: successor ← -1 // 記錄 successor 位置\n→ Step 6: For j from len(digits)-1 downto pivot+1:\n    → Decision: If digits[j] > digits[pivot]? // 找到右邊最小且 > pivot\n        Yes → successor ← j // 記錄\n        No → Continue\n→ Step 7: Swap digits[pivot] 和 digits[successor] // 交換\n→ Step 8: Reverse subarray digits[pivot+1 … end] // 將尾部反轉得到最小\n→ Step 9: result ← Convert digits to integer // 重新組成數字\n→ Decision: If result > 2^31-1? // 檢查是否超出 32 位\n    Yes → Step 10: Return -1 // 超出限制\n    No  → Step 11: Return result // 回傳答案\nEnd // 程式執行結束\n\nAdd appropriate comments.\n\nWe need to use virtual arrows: → Step, Decision: Yes →, No → etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: digits ← Convert n to list of characters // 轉換整數為字元列表\n→ Step 2: pivot ← -1 // 初始化 pivot 位置\n→ Step 3: For i from len(digits)-2 downto 0: // 從倒數第二位往前遍歷\n    → Decision: If digits[i] < digits[i+1]? // 判斷是否可作為 pivot\n        Yes → pivot ← i // 記錄 pivot\n        No → Continue // 仍往前\n→ Decision: If pivot = -1? // 若無可交換位置\n    Yes → Step 4: Return -1 // 無更大排列\n    No → // 進一步處理\n→ Step 5: successor ← -1 // 初始化 successor 位置\n→ Step 6: For j from len(digits)-1 downto pivot+1:\n    → Decision: If digits[j] > digits[pivot]? // 找右邊最小且大於 pivot\n        Yes → successor ← j // 記錄\n        No → Continue\n→ Step 7: Swap digits[pivot] 與 digits[successor] // 交換 pivot 與 successor\n→ Step 8: Reverse subarray digits[pivot+1 … end] // 將尾部反轉以取得最小遞增序\n→ Step 9: result ← Convert digits to integer // 重新組成整數\n→ Decision: If result > 2^31-1? // 檢查 32 位整數上限\n    Yes → Step 10: Return -1 // 超出範圍\n    No  → Step 11: Return result // 回傳答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef next_greater_element(n: int) -> int:\n    \"\"\"\n    找到比 n 大且由 n 的所有位數組成的最小整數。\n    若不存在或結果超出 32 位整數上限，返回 -1。\n    \"\"\"\n    digits = list(str(n))\n    # 從右往左找第一個「升序」的位置\n    i = len(digits) - 2\n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    if i == -1:\n        return -1  # 已是最大排列，無法得到更大的數字\n\n    # 在右側找到最小且比 digits[i] 大的數字\n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n\n    # 交換 pivot 與 successor\n    digits[i], digits[j] = digits[j], digits[i]\n    # 將 pivot 右側的子序列反轉得到最小遞增順序\n    digits[i + 1:] = reversed(digits[i + 1:])\n\n    result = int(\"\".join(digits))\n    # 檢查是否超出 32 位整數上限\n    return result if result < 2 ** 31 else -1\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，尋找第一個出現的整數\n    data = sys.stdin.read()\n    match = re.search(r\"-?\\d+\", data)\n    if match:\n        n = int(match.group())\n        print(next_greater_element(n))\n    else:\n        # 若輸入中沒有數字，直接輸出 -1\n        print(-1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "21",
          "success": true,
          "output": "21"
        },
        {
          "example_index": 1,
          "input": "n = 21",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking perfect number. Steps: Start, Input n, if n <= 1 return false because 1's divisors sum excluding itself is 0. Compute sumDivisors=1; iterate i from 2 to sqrt(n) inclusive. For each i dividing n, add i and n/i if distinct. After loop, compare sumDivisors==n, return. End. Use virtual arrows. Provide explanation each line. Use \"Start\" and \"End\". Use \"Decision:\" etc. Ensure each line ends with // explanation. Use \"Yes →\" \"No →\". Use \"Step\" or \"Decision\". Provide code lines accordingly. Use \"Return true/false\" steps. Provide explanation.\n\nLet's craft:\n\nStart\n→ Step 1: 讀取整數 n // 從輸入取得 n\n→ Decision: 如果 n <= 1? // 檢查 n 是否小於等於 1\n    Yes → Step 2: 回傳 false // n 不是完美數\n    No  →\n→ Step 3: 初始化 sumDiv = 1 // 起始加 1 為 1 的因子\n→ Step 4: 計算 max = floor(sqrt(n)) // 用於迭代\n→ Decision: 如果 max < 2? // n 為 2 或 3 之類\n    Yes → Step 5: 比較 sumDiv 與 n 並回傳結果 // 直接判斷\n    No  →\n→ Step 6: For i 從 2 到 max 逐步遞增\n    → Decision: 如果 n % i == 0? // i 是否為 n 的因子\n        Yes →\n            → Decision: 如果 i == n/i? // i 是否是平方根\n                Yes → Step 7: sumDiv = sumDiv + i // 加一次平方根\n                No  → Step 8: sumDiv = sumDiv + i + n/i // 加兩個因子\n        No  → // 不是因子，跳過\n→ Step 9: Decision: 如果 sumDiv == n? // 判斷是否為完美數\n    Yes → Step 10: 回傳 true // 是完美數\n    No  → Step 11: 回傳 false // 不是完美數\nEnd\n\nNeed each line: \"→ Step x:\" or \"Decision:\" with Yes/No branches. Also use \"Start\" and \"End\". Ensure each line ends with // explanation.\n\nWe need to maintain consistent indentation? Not required but good.\n\nWe must ensure each line is a single line of virtual code plus explanation. For branching lines, we may need multiple lines inside.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 從輸入取得 n  \n\n→ Decision: 如果 n <= 1? // 檢查 n 是否小於等於 1  \n    Yes → Step 2: 回傳 false // n 不是完美數  \n    No  → // 繼續後續流程  \n\n→ Step 3: 初始化 sumDiv = 1 // 起始加 1 為 1 的因子  \n\n→ Step 4: 計算 max = floor(sqrt(n)) // 用於迭代的上限  \n\n→ Decision: 如果 max < 2? // n 為 2 或 3 之類的特殊情況  \n    Yes → Step 5: 比較 sumDiv 與 n 並回傳結果 // 直接判斷是否為完美數  \n    No  → // 進入迴圈檢查因子  \n\n→ Step 6: For i 從 2 到 max 逐步遞增  \n    → Decision: 如果 n % i == 0? // i 是否為 n 的因子  \n        Yes →  \n            → Decision: 如果 i == n/i? // i 是否是平方根  \n                Yes → Step 7: sumDiv = sumDiv + i // 加一次平方根  \n                No  → Step 8: sumDiv = sumDiv + i + n/i // 加兩個因子  \n        No  → // 不是因子，跳過  \n\n→ Decision: 如果 sumDiv == n? // 判斷是否為完美數  \n    Yes → Step 9: 回傳 true // 是完美數  \n    No  → Step 10: 回傳 false // 不是完美數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\nclass Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        if num < 2:\n            return False\n        s = 1\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                s += i\n                if i != num // i:\n                    s += num // i\n            i += 1\n        return s == num\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    n = int(data)\n    sol = Solution()\n    result = sol.checkPerfectNumber(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Traditional Chinese, step-by-step, with comments. The task: compute complement of integer in binary: flip bits of its binary representation (no leading zeros? Usually complement of binary representation: flip all bits of binary representation of number (no leading zeros). So algorithm: find binary representation, flip bits, convert back to integer. Implementation: get bit length of num, compute mask of (1 << bitlen)-1, then complement = mask ^ num. Return complement. Also handle num==0? Then binary '0', complement '1'? Some definitions say 0's complement is 1. We can mention that.\n\nSo produce virtual code:\n\nStart\n→ Step 1: 如果 num 等於 0? // 处理特殊情况\n→ Decision: ...\nYes → Step 2: 返回 1 // 0 的补码是 1\nNo → Step 3: 计算位数 bitLen = 计算 num 的二进制长度 // 取得二进制位数\n→ Step 4: 生成掩码 mask = (1 << bitLen) - 1 // 所有位为1的掩码\n→ Step 5: 结果 complement = num XOR mask // 逐位翻转\n→ Step 6: 返回 complement\nEnd\n\nAdd comments accordingly.\n\nAlso include explanation after each line. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 如果 num 等於 0? // 先判斷輸入是否為 0，因為 0 的二進位表示為 0  \n    Yes → Step 2: 返回 1 // 0 的補碼通常定義為 1  \n    No  → Decision: 計算 num 的二進位長度 bitLen = 取得 num 的位數 // 取得有效位數，去除前導 0  \n        → Step 3: 生成掩碼 mask = (1 << bitLen) - 1 // 產生 all-1 掩碼，長度等於 bitLen  \n        → Step 4: 结果 complement = num XOR mask // 逐位翻轉得到補碼  \n        → Step 5: 返回 complement // 將結果返回給呼叫者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_complement(num: int) -> int:\n    \"\"\"\n    取得整數 num 的二進位補碼。\n    先計算有效位數，再用全 1 掩碼取 XOR 進行翻轉。\n    \"\"\"\n    if num == 0:                  # 0 的補碼特殊處理\n        return 1\n    bit_length = num.bit_length() # 取得 num 的二進位長度\n    mask = (1 << bit_length) - 1  # 產生長度相同的全 1 掩碼\n    return num ^ mask             # 逐位翻轉得到補碼\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取數值，計算補碼，並輸出結果。\n    支援輸入格式「num = 5」或「5」等，只需提取第一個整數即可。\n    \"\"\"\n    data = sys.stdin.read()                      # 讀取全部輸入\n    match = re.search(r'-?\\d+', data)            # 找出第一個整數\n    if not match:                                # 若沒有數字，直接結束\n        return\n    num = int(match.group())\n    result = find_complement(num)                # 計算補碼\n    print(result)                                # 輸出結果\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the KthLargest class. We should produce pseudo steps: initialization, maintaining a min-heap of size k, add method. Provide step by step. We need to obey format: each line \"虛擬碼步驟 // 解釋\". Use arrows: Start, End, Decision:. So we need to describe the class, its constructor, and add method. Use decision steps: If heap size < k then push val, else compare val with heap min. If val > min, replace. Then return heap min.\n\nWe'll produce the pseudocode line by line. Let's structure:\n\nStart // program start\n→ Define class KthLargest // declare class\n→ Constructor: KthLargest(k, nums) // initialize k and heap\n→ Decision: if nums length > 0? // if initial array\n    Yes → for each num in nums: call add(num) // populate heap\n    No → do nothing\n→ End constructor\n→ Method: add(val) // add new score\n→ Decision: heap size < k? // need to fill heap\n    Yes → push val into heap // add element\n    No → Decision: val > heap min? // compare\n        Yes → replace min with val // pop min and push val\n        No → do nothing\n→ Return heap min // kth largest\n→ End add method\nEnd // program end\n\nNeed to include virtual arrows. Use \"→\" for sequence. Use Decision lines. Include indented steps under Decision. Provide each line with explanation.\n\nWe must not output actual code. Just steps.\n\nLet's produce.\n\nMake sure each line contains virtual code step and comment. Indent for decisions? The example shows indentation but we can include spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class KthLargest // 宣告 KthLargest 類別  \n→ Constructor: KthLargest(k, nums) // 初始化 k 與測試分數串流  \n  Decision: nums 是否非空? // 檢查是否有初始分數  \n   Yes → For each score in nums: call add(score) // 用 add 方法將初始分數加入資料結構  \n   No → // 若沒有初始分數則不執行任何操作  \n→ End constructor // 建構子結束  \n→ Method: add(val) // 新增一筆分數並回傳目前的第 k 大分數  \n  Decision: HeapSize < k? // 檢查堆疊大小是否還未達 k 個  \n   Yes → Push val into MinHeap // 堆疊未滿，直接加入  \n   No → Decision: val > MinHeap.Min? // 堆疊已滿，判斷是否需要取代最小值  \n    Yes → Replace MinHeap.Min with val // val 大於目前第 k 大，替換最小值  \n    No → // val 不大於第 k 大，保持不變  \n  Return MinHeap.Min // 回傳第 k 大的分數  \n→ End add method // add 方法結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nimport ast\nimport json\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # split into commands list and arguments list\n    idx = data.find('],')\n    if idx == -1:\n        return\n    commands_str = data[:idx+1]   # includes the closing bracket of the first list\n    args_str = data[idx+2:].strip()  # skip the '],' and any following whitespace\n\n    try:\n        commands = ast.literal_eval(commands_str)\n        args = ast.literal_eval(args_str)\n    except Exception:\n        return\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"KthLargest\":\n            obj = KthLargest(arg[0], arg[1])\n            result.append(None)\n        else:\n            res = obj.add(arg[0])\n            result.append(res)\n\n    # json.dumps will convert None to null automatically\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": true,
          "output": "[null, 4, 5, 5, 8, 8]"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": true,
          "output": "[null, 7, 7, 7, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Given an integer array nums, return counts where counts[i] is number of smaller elements to right of nums[i].\n\nWe need to output step-by-step algorithm using virtual code lines. Use virtual code arrows →, Yes →, No →. Provide explanation comments. We should decide algorithm: typical approach: use Binary Indexed Tree (Fenwick tree) or balanced BST. Could also do divide and conquer. We'll choose Fenwick tree after coordinate compression. Steps:\n\n1. Start\n2. Input nums\n3. Compute sorted unique list to map to ranks\n4. Initialize BIT with size = len(unique)\n5. Initialize result array same length\n6. Iterate nums from right to left:\n   a. For each num, get its rank\n   b. Query BIT for sum of ranks less than current rank (i.e., count smaller)\n   c. Set result[i] = that count\n   d. Update BIT at current rank by 1\n7. End return result\n\nBut we need to produce virtual code lines with explanation.\n\nWe need to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrow →. Use Decision if any.\n\nWe may need to include loops, conditions, etc. But can be generic.\n\nLet's craft.\n\nStart // Program begins\n\n→ Step 1: Input array nums // 取得輸入數列\n\n→ Step 2: 建立 nums 的唯一值並排序為 sortedVals // 用於座標壓縮\n\n→ Step 3: 為每個值建立對應的 rankMap (value → index+1) // 座標壓縮\n\n→ Step 4: 初始化 BIT[1..len(sortedVals)] 為 0 // 方便查詢小於等於某 rank 的個數\n\n→ Step 5: 建立 result array counts 同樣長度 // 存放答案\n\n→ Step 6: 從右至左遍歷 nums，index i 從 len-1 到 0\n\n    → Decision: 迴圈是否結束? // 判斷是否已處理完所有元素\n        Yes → End // 迴圈結束，返回結果\n        No  → \n            → Step 7: current = nums[i] // 取得當前元素\n            → Step 8: rank = rankMap[current] // 找到其座標\n            → Step 9: smallerCount = BIT.query(rank-1) // 取得比 rank 小的元素數量\n            → Step 10: counts[i] = smallerCount // 存入結果\n            → Step 11: BIT.update(rank, 1) // 在 BIT 中增加該元素的計數\n\nEnd // 程式結束，輸出 counts\n\nBut we need to include arrow for each line. Use → for steps. For Decision: we need to format like \"Decision: ...\". Use Yes →, No →.\n\nMake sure each line includes // comment.\n\nWe might need to show BIT operations: query and update.\n\nWe might not need to show detailed internal of BIT; just mention.\n\nWe need to keep it as \"虛擬碼\" lines, each line with arrow or decision. Should we use \"→\" as arrow at beginning? Format example shows each line starts with \"→ Step ...\". For Decision, start with \"Decision:\"? Format sample shows \"Decision: 如果數字大於 0? // 檢查數值是否為正\". We'll do similar: \"Decision: 迴圈是否結束?\".\n\nBut maybe simpler: Use \"Decision:\" inside loop. But we can just list loop lines sequentially without explicit decision, but still we can include \"Decision\" to satisfy.\n\nSimplify: use loop with \"→ Step\" lines. Use \"→ Step\" and we can skip decision lines. But requirement says use Decision arrow maybe optional. But we can include to show loop condition. So incorporate \"Decision:\".\n\nOk final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums // 取得輸入數列  \n→ Step 2: 建立 nums 的唯一值並排序為 sortedVals // 用於座標壓縮  \n→ Step 3: 為每個值建立對應的 rankMap (value → index+1) // 賦予每個數字唯一的序號  \n→ Step 4: 初始化 BIT[1..len(sortedVals)] 為 0 // 位階樹用於快速查詢前綴和  \n→ Step 5: 建立 result array counts 同樣長度 // 存放最終答案  \n→ Step 6: 從右至左遍歷 nums，index i 從 len(nums)-1 到 0  \n    → Decision: 是否已遍歷完所有元素? // 判斷迴圈是否結束  \n        Yes → End // 所有元素已處理，返回結果  \n        No  →  \n            → Step 7: current = nums[i] // 取得目前元素  \n            → Step 8: rank = rankMap[current] // 取得其座標壓縮後的序號  \n            → Step 9: smallerCount = BIT.query(rank-1) // 查詢比該序號小的元素個數  \n            → Step 10: counts[i] = smallerCount // 將計數存入結果陣列  \n            → Step 11: BIT.update(rank, 1) // 在 BIT 中新增此元素的計數  \nEnd // 程式執行結束，輸出 counts",
      "generated_code": "import sys\nimport ast\n\nclass BIT:\n    def __init__(self, size: int):\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index: int, delta: int) -> None:\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index: int) -> int:\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\nclass Solution:\n    def countSmaller(self, nums):\n        sorted_unique = sorted(set(nums))\n        ranks = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(ranks))\n        res = []\n\n        for num in reversed(nums):\n            rank = ranks[num]\n            res.append(bit.query(rank - 1))\n            bit.update(rank, 1)\n\n        return res[::-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n    solution = Solution()\n    result = solution.countSmaller(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2, 1, 1, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for multiplying two complex numbers given as strings \"a+bi\". Steps: parse string into real and imag ints. Multiply using (a+bi)(c+di)= (ac - bd) + (ad+bc)i. Then build string output. Edge cases: signs. Strings may have negative real or imaginary parts: e.g., \"-1+-2i\"? Usually format \"real+imaginaryi\" but imaginary can be negative: e.g., \"1-2i\". So we need parse with + or - before imaginary. Simplify: split on '+' or '-' preceding imaginary part but careful with negative real. Approach: use regex or manual: find index of last '+' or '-' that separates real and imaginary parts (but skip the first sign). Then substring. Then parse ints. Then compute result. Then build output string: if imag >=0 then \"real+imag i\" else \"real-abs(imag)i\". But ensure proper formatting: e.g., if imag negative, use '-'+abs. For zero imag? still add \"0i\"? Problem maybe expects sign? Probably \"real+0i\" or \"real-0i\"? We'll use \"+0i\".\n\nReturn string.\n\nNow produce virtual code line by line. Use arrows.\n\nLet's craft steps:\n\nStart\n→ Step 1: 定義函數 multiplyComplex(num1, num2) // 入口\n→ Step 2: 解析 num1 為 real1, imag1 // 提取實部、虛部\n→ Step 3: 解析 num2 為 real2, imag2\n→ Step 4: 計算 realResult = real1 * real2 - imag1 * imag2 // 實部乘法\n→ Step 5: 計算 imagResult = real1 * imag2 + imag1 * real2 // 虛部乘法\n→ Step 6: 構建結果字符串 resultStr\n    Decision: 如果 imagResult >= 0 ?\n        Yes → resultStr = realResult + \"+\" + imagResult + \"i\"\n        No  → resultStr = realResult + \"-\" + abs(imagResult) + \"i\"\n→ End // 返回 resultStr\n\nWe need include parse step details. So Step 2 and 3: parse using split.\n\nWe'll add substeps maybe.\n\nUse virtual arrows.\n\nLet's produce.\n\nMake sure each line has // explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 multiplyComplex(num1, num2) // 進入複數相乘的主流程  \n→ Step 2: 解析 num1 為 real1, imag1 // 從字串中取得實部與虛部  \n  Decision: num1 是否包含 '-' 作為虛部分隔符？ // 判斷負虛部  \n   Yes → real1 = substring前一個 '+' 或 '-' 後的數字； imag1 = 整數(後面 'i' 前的數字)  \n   No  → real1 = substring前一個 '+' 或 '-' 後的數字； imag1 = 整數(後面 'i' 前的數字)  \n→ Step 3: 解析 num2 為 real2, imag2 // 同樣方式提取第二個複數的實部與虛部  \n→ Step 4: 計算 realResult = real1 * real2 - imag1 * imag2 // 根據 (a+bi)(c+di)=ac-bd 為實部  \n→ Step 5: 計算 imagResult = real1 * imag2 + imag1 * real2 // 根據 (a+bi)(c+di)=ad+bc 為虛部  \n→ Step 6: 構建結果字符串 resultStr  \n  Decision: imagResult >= 0? // 判斷虛部正負  \n   Yes → resultStr = realResult + \"+\" + imagResult + \"i\" // 正虛部用 '+' 連接  \n   No  → resultStr = realResult + \"-\" + abs(imagResult) + \"i\" // 負虛部用 '-' 連接  \n→ End // 返回 resultStr 並結束程式",
      "generated_code": "import sys\n\ndef parse_complex(s: str):\n    \"\"\"\n    將形如 \"real+imaginaryi\" 的字串解析成整數 (real, imag)。\n    由於 real 可能為負，且 imag 部分在字串中始終以 '+' 隔開，\n    因此直接以 '+' 只拆一次即可。\n    \"\"\"\n    real_str, imag_str = s.split('+', 1)           # 只分割一次\n    real = int(real_str)\n    imag = int(imag_str[:-1])                     # 去掉末尾的 'i'\n    return real, imag\n\ndef multiply_complex(a: str, b: str) -> str:\n    \"\"\"\n    計算兩個複數相乘，輸回 \"real+imaginaryi\" 的字串。\n    \"\"\"\n    r1, i1 = parse_complex(a)\n    r2, i2 = parse_complex(b)\n    real_part = r1 * r2 - i1 * i2\n    imag_part = r1 * i2 + i1 * r2\n    # 直接使用 '+' 後跟 imag_part，哪怕 imag_part 為負\n    return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取兩個複數字串，計算相乘後輸出結果。\n    允許輸入格式為\n        \"a+bi\", \"c+di\"\n    或\n        \"a+bi\"\n        \"c+di\"\n    兩行分別放一個字串。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試以逗號分隔\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) != 2:\n        # 若未以逗號分隔，則視為逐行輸入\n        parts = [p.strip() for p in data.splitlines()]\n\n    # 去除兩端的單雙引號\n    a = parts[0].strip('\"').strip(\"'\")\n    b = parts[1].strip('\"').strip(\"'\")\n\n    result = multiply_complex(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "0+2i"
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": true,
          "output": "0+-2i"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode609.json",
    "problem_index_in_file": 0,
    "title": "Find Duplicate File in System",
    "description_snippet": "Given a list paths of directory info, including the directory path, and all the files with contents ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for algorithm: given list of directory strings, parse, map content->list of file paths, then collect groups with size>1. Use steps: Start, for each dirInfo string, split by space, first part is path, rest are fileInfo. For each fileInfo, parse name(content). Build full path. Use map. Then after all, iterate map and collect groups with >1. Output list. End.\n\nReturn groups.\n\nMake sure to use the arrow notation. Let's produce lines. Use Start, End, Decision, etc.\n\nLet's craft:\n\nStart // begin\n→ Step 1: 初始化 map<string, list<string>> contentToPaths // 存储内容到路径列表\n→ For each dirInfo in paths: // 遍历每个目录信息字符串\n    → Step 2: 將 dirInfo 以空格分割為 parts // 将字符串拆分为目录路径和文件信息\n    → Step 3: 取 parts[0] 作為 dirPath // 目录路径\n    → For each fileInfo in parts[1:]: // 处理每个文件\n        → Step 4: 找到 '(' 前的文件名 → filename // 取得文件名\n        → Step 5: 找到 '(' 后和 ')' 之间的内容 → fileContent // 取得文件内容\n        → Step 6: 拼接 fullPath = dirPath + \"/\" + filename // 完整文件路径\n        → Step 7: 如果 contentToPaths 没有 fileContent 键，則初始化空列表 // 创建键\n        → Step 8: 把 fullPath 加入 contentToPaths[fileContent] // 记录路径\n→ Decision: 是否存在内容对应的路径列表长度大于 1? // 检查是否有重复\n    Yes → Step 9: 创建结果列表 result = [] // 初始化结果\n    → For each key, pathsList in contentToPaths:\n        → Decision: 如果 pathsList 长度 > 1? // 只取重复组\n            Yes → Step 10: 把 pathsList 加入 result // 收集重复组\n        → No → 继续 // 跳过单个文件\n    → Step 11: 返回 result // 输出重复文件路径组\n    No → Step 12: 返回空列表 // 没有重复文件\nEnd // 程序结束\n\nNeed to ensure each line with arrow, explanation comment. Use proper indentation? Might use indentation in comments but not necessary. Use arrows per step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 map contentToPaths 為字典 (內容 → 其相關檔案路徑列表) // 用於儲存每個內容對應的所有檔案路徑  \n→ For each dirInfo in paths: // 逐一處理輸入的每條目錄資訊  \n → Step 2: 將 dirInfo 以空格切割為 parts // 將字串拆成「目錄路徑」與「檔案資訊」  \n → Step 3: 取 parts[0] 作為 dirPath // 取得此條目所屬的目錄路徑  \n → For each fileInfo in parts[1:]: // 處理此目錄下的每個檔案資訊  \n  → Step 4: 找到 '(' 前的文字作為 filename // 取得檔名（例如 \"f1.txt\"）  \n  → Step 5: 找到 '(' 後到 ')' 之間的文字作為 fileContent // 取得檔案內容（例如 \"f1_content\"）  \n  → Step 6: 以 dirPath + \"/\" + filename 組成 fullPath // 完整檔案路徑  \n  → Step 7: 若 contentToPaths 沒有 key fileContent，則新增空列表 // 建立內容對應的列表  \n  → Step 8: 把 fullPath 加入 contentToPaths[fileContent] // 記錄此檔案路徑  \n→ Decision: 是否存在 contentToPaths 中任意鍵對應的列表長度 > 1? // 判斷是否有重複檔案  \n Yes → Step 9: 初始化 result 為空列表 // 用於儲存所有重複檔案的路徑組  \n  → For each key, pathsList in contentToPaths: // 遍歷所有內容對應的路徑列表  \n   Decision: pathsList 長度 > 1? // 只保留重複的組別  \n    Yes → Step 10: 把 pathsList 加入 result // 收集重複檔案路徑組  \n    No → 直接跳過 // 單一檔案不算重複  \n  → Step 11: 回傳 result // 輸出所有重複檔案的路徑組  \n No → Step 12: 回傳空列表 // 沒有任何重複檔案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        content_map = defaultdict(list)\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]  # 去掉末尾的 ')'\n                content_map[content].append(f\"{root}/{name}\")\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 允許輸入形如: paths = [\"root/a 1.txt(abcd) ...\"]\n    if raw_input.startswith('paths'):\n        _, rest = raw_input.split('=', 1)\n        raw_input = rest.strip()\n    # 解析列表字面量\n    try:\n        paths = ast.literal_eval(raw_input)\n    except Exception:\n        paths = eval(raw_input, {})\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, with explanation after space. Need to generate steps for Trie class with methods: constructor, insert, search, startsWith. Provide algorithm steps. Use arrow structure. Let's produce pseudocode: Start, initialize root node, node structure: map children, end flag. Then each method: insert: iterate chars, add nodes, mark end. search: iterate, check, return flag. startsWith: iterate, return true if prefix found. End. Use Decision nodes for checking. Let's produce.\n\nMake sure to follow format: each line \"虛擬碼步驟 // 解釋\" with spaces.\n\nLet's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類型，包含 children 映射和 isEnd 布林值 // 建立節點結構  \n→ Step 2: Trie() ← new Node() // 初始化 Trie，根節點不代表任何字元  \n→ Step 3: insert(word) // 開始插入單字  \n  → Decision: word 是否為空? // 空字元不插入  \n    Yes → Return // 結束插入  \n    No  → Step 4: current ← root // 從根節點開始  \n      → For 每個字元 c in word: // 逐字元遍歷  \n        Decision: current.children 中是否存在 c? // 字元已存在？  \n         Yes → current ← current.children[c] // 跳到已存在節點  \n         No  → current.children[c] ← new Node() // 新增節點  \n            → current ← current.children[c] // 進入新節點  \n            → Continue // 繼續下一個字元  \n            → End For  \n      → current.isEnd ← true // 標記單字結束位置  \n→ Step 5: search(word) // 查找完整單字  \n  → Decision: word 是否為空? // 空字串不可能存在  \n    Yes → Return false // 返回 false  \n    No  → Step 6: current ← root // 從根節點開始  \n      → For 每個字元 c in word: // 逐字元遍歷  \n        Decision: current.children 中是否存在 c? // 字元存在？  \n         Yes → current ← current.children[c] // 跳到下一節點  \n         No  → Return false // 找不到字元，單字不存在  \n            → End For  \n      → Decision: current.isEnd? // 目前節點是否標記為單字結束  \n        Yes → Return true // 單字存在  \n        No  → Return false // 只是前綴，非完整單字  \n→ Step 7: startsWith(prefix) // 判斷前綴是否存在  \n  → Decision: prefix 是否為空? // 空前綴即始終為 true  \n    Yes → Return true  \n    No  → Step 8: current ← root // 從根節點開始  \n      → For 每個字元 c in prefix: // 逐字元遍歷  \n        Decision: current.children 中是否存在 c? // 字元存在？  \n         Yes → current ← current.children[c] // 前進到下一節點  \n         No  → Return false // 前綴不存在  \n            → End For  \n      → Return true // 所有字元皆存在，前綴成立  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    \"\"\"Trie 树的節點。\"\"\"\n    def __init__(self):\n        # 儲存子節點的字典，key 為字元，value 為 TrieNode\n        self.children = {}\n        # 標記此節點是否為單字結束的位置\n        self.is_end = False\n\nclass Trie:\n    \"\"\"前綴樹實作。\"\"\"\n    def __init__(self):\n        # 根節點不代表任何字元\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        \"\"\"將單字插入前綴樹。\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        \"\"\"若前綴樹中存在完整單字 word，則回傳 True。\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"若前綴樹中存在至少一個單字以 prefix 為前綴，則回傳 True。\"\"\"\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把兩個 list 包裝成 tuple 方便 literal_eval 解析\n    try:\n        ops, args = ast.literal_eval(f\"({data})\")\n    except Exception as e:\n        print(f\"Input format error: {e}\")\n        return\n\n    trie = None\n    results = [None]  # 第一次建構 Trie 會回傳 null\n\n    for op, arg in zip(ops[1:], args[1:]):  # 跳過第一個 'Trie' 操作\n        if op == 'insert':\n            trie.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie.search(arg[0]))\n        elif op == 'startsWith':\n            results.append(trie.startsWith(arg[0]))\n        else:\n            # 如有其他操作可在此處擴充\n            results.append(None)\n\n    # 使用 json.dumps 以符合題目示例輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpvf7x_enb.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpvf7x_enb.py\", line 63, in main\n    trie.insert(arg[0])\n    ^^^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'insert'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: find missing number in array of n distinct numbers in range [0,n]. Approach: use XOR of all numbers and indices. Provide steps. Output line by line with \"虛擬碼步驟\" and comment. Use arrow, Decision, etc.\n\nEnsure each line has \"虛擬碼步驟 // 解釋/說明\". We should write in Traditional Chinese. Let's produce steps:\n\nStart\n→ Step 1: initialize result = 0 // 初始結果為0\n→ Step 2: 遍歷索引 i 從 0 到 n-1 // 為了把數字和索引全部加入 XOR\n    → result = result XOR i // 將索引加入 XOR\n    → result = result XOR nums[i] // 將對應元素加入 XOR\n→ Step 3: result = result XOR n // 將最後一個數字 n 加入 XOR\n→ Step 4: 返回 result // result 就是缺失的數字\nEnd\n\nBut we might also show XOR loop differently.\n\nBetter to have decision? Not needed.\n\nLet's format each line accordingly.\n\nWe should start with \"Start // 程式開始執行\". Then steps lines.\n\nUse arrow notation. Provide each step.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化 XOR 結果為 0  \n→ Step 2: 針對索引 i 從 0 到 n-1 進行迴圈 // 將所有索引與對應元素加入 XOR  \n  → result ← result XOR i // 將索引 i 加入 XOR  \n  → result ← result XOR nums[i] // 將 nums[i] 加入 XOR  \n→ Step 3: result ← result XOR n // 將範圍最後一個數字 n 加入 XOR  \n→ Step 4: 返回 result // result 為缺失的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef missing_number(nums):\n    \"\"\"\n    利用 XOR 的性質找到缺失的數字\n    \"\"\"\n    result = 0\n    n = len(nums)\n    # 將所有索引和元素都 XOR 起來\n    for i in range(n):\n        result ^= i\n        result ^= nums[i]\n    # 將範圍最後一個數字 n 也 XOR\n    result ^= n\n    return result\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 取出所有整數，支援負數但題目只有非負\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # 計算缺失的數字\n    ans = missing_number(nums)\n    # 輸出結果\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for generating rand10 from rand7. Classic solution: use two rand7 to create a range 1-49; if <=40, use (value-1)%10+1; else reject and repeat. Or use 7*7*7? But simple is fine. Must output step-by-step lines with virtual code arrow. Each line: 虛擬碼步驟 + // 解釋. Use Start, Decision, etc. Should include loops. Provide explanation for each line. Let's create:\n\nStart\n→ Step 1: repeat loop // 重複生成隨機數直到得到合法範圍\n    → Step 2: r1 ← rand7() // 生成第一個 1-7\n    → Step 3: r2 ← rand7() // 生成第二個 1-7\n    → Step 4: val ← (r1 - 1) * 7 + r2 // 將兩個數合併為 1-49\n    → Decision: 如果 val ≤ 40? // 只接受前40個數\n        Yes → Step 5: result ← (val - 1) mod 10 + 1 // 轉換為 1-10\n        Yes → Step 6: return result // 回傳隨機數\n        No  → Step 7: // 如果 val > 40，重新進入循環\nEnd\n\nAlso we might mention rejection step.\n\nLet's write accordingly. Use proper formatting.\n\nNeed each line with 虛擬碼步驟 + space + // explanation. Use arrow symbols: →, Yes →, No →. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: repeat loop // 重複生成隨機數直到得到合法範圍  \n    → Step 2: r1 ← rand7() // 產生第一個 1~7 的隨機數  \n    → Step 3: r2 ← rand7() // 產生第二個 1~7 的隨機數  \n    → Step 4: val ← (r1 - 1) * 7 + r2 // 將兩個隨機數合併成 1~49 的值  \n    → Decision: 如果 val ≤ 40? // 只接受前 40 個數（40 能被 10 整除）  \n        Yes → Step 5: result ← (val - 1) mod 10 + 1 // 將 1~40 映射為 1~10  \n        Yes → Step 6: return result // 回傳生成的 rand10 數值  \n        No  → Step 7: // val > 40 時丟棄，重新進入循環  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\nimport re\n\n# API: generate a uniform random integer in [1, 7]\ndef rand7() -> int:\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        Generate a uniform random integer in [1, 10] using only rand7().\n        \"\"\"\n        while True:\n            # Combine two rand7 calls to get a uniform range [1, 49]\n            num = (rand7() - 1) * 7 + rand7()\n            # Accept only the first 40 values (40 is divisible by 10)\n            if num <= 40:\n                # Map 1~40 to 1~10\n                return 1 + (num - 1) % 10\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, generate n rand10 values, and print them.\n    Expected input format: \"n = X\" where X is an integer.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    solver = Solution()\n    results = [solver.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,4]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 4]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[9,9,10]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[9, 9, 10]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step, with explanation. Must adhere to format. Must not output actual code, only virtual steps. Use arrows and decisions. Need to implement reverse integer algorithm without 64-bit. So we handle overflow by checking before multiplying. Approach: Use 32-bit limits. Use sign variable. Use loop to reverse digits. At each iteration, pop last digit, push onto result after checking if overflow. Overflow check: if result > INT_MAX/10 or result == INT_MAX/10 and digit > 7, etc. For negative also. Use 32-bit constants: INT_MAX = 2147483647, INT_MIN = -2147483648.\n\nAlso must handle environment doesn't allow 64-bit storage. Use 32-bit ints only.\n\nLet's produce virtual steps:\n\nStart\n→ Step: 獲取輸入 x\n→ Decision: x < 0?  // 判斷符號\n    Yes → Step: sign = -1; x = -x; // 取負數為正\n    No  → Step: sign = 1\n→ Step: result = 0 // 初始化反轉結果\n→ Decision: x == 0? // 直接返回 0\n    Yes → Step: return 0\n    No  → ...\n→ Step: INT_MAX = 2147483647; INT_MIN = -2147483648; // 定義極限\n→ Loop: While x != 0\n    → Step: digit = x % 10 // 取最後一位\n    → Step: x = x / 10 // 去掉最後一位\n    → Decision: result > INT_MAX/10?  // 檢查乘10後是否溢出\n        Yes → Step: return 0\n        No  → Decision: result == INT_MAX/10 && digit > 7? // 檢查最後一位超過 7\n            Yes → Step: return 0\n            No  → Step: result = result * 10 + digit\n→ Step: result = result * sign // 乘回符號\n→ Decision: result < INT_MIN || result > INT_MAX? // 最後再檢查範圍\n    Yes → Step: return 0\n    No  → Step: return result\n\nEnd\n\nBut we need to use the virtual arrow format.\n\nUse \"Start // 程式開始執行\" etc.\n\nWe need to include arrows \"→\" each step, and decisions with Yes → and No →.\n\nLet's produce.\n\nRemember: \"Step: ...\" after arrow.\n\nAlso for loop: We'll express as \"Loop: While x != 0\" then indent inside? We can use arrows inside. Format example shows indentation? In example, they indent nested decisions. We'll use similar.\n\nWe need to include each line. We must maintain indentation with spaces. In the example, after Decision, they indent next lines with 4 spaces? Eg: \nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n    No  → Decision: 如果數字等於 0? // ...\n\nSo use 4 spaces before Yes / No lines. Also for Loop maybe we indent inside too. Let's replicate.\n\nWe'll produce virtual code lines:\n\nStart // 程式開始執行\n→ Step: 讀取輸入 x // 取得待反轉的整數\n→ Decision: x < 0? // 判斷是否為負數\n    Yes → Step: sign = -1; x = -x; // 取正值並記錄符號\n    No  → Step: sign = 1; // 正數，符號為正\n→ Step: result = 0 // 初始化反轉結果\n→ Decision: x == 0? // 直接返回 0\n    Yes → Step: return 0 // 若輸入為 0，結果即為 0\n    No  → Step: // 進行後續處理\n→ Step: INT_MAX = 2147483647; INT_MIN = -2147483648; // 定義 32 位整數極限\n→ Loop: While x != 0 // 逐位取出並反轉\n    → Step: digit = x % 10 // 取最低位\n    → Step: x = x / 10 // 去掉最低位\n    → Decision: result > INT_MAX / 10? // 檢查乘 10 會不會溢出\n        Yes → Step: return 0 // 溢出，直接返回 0\n        No  → Decision: result == INT_MAX / 10 && digit > 7? // 最後一位超過 7 會溢出\n            Yes → Step: return 0 // 溢出，返回 0\n            No  → Step: result = result * 10 + digit // 正常累積\n→ Step: result = result * sign // 乘回符號\n→ Decision: result < INT_MIN || result > INT_MAX? // 最終檢查是否在範圍內\n    Yes → Step: return 0 // 超出範圍，返回 0\n    No  → Step: return result // 正常返回\nEnd // 程式執行結束\n\nMake sure each line ends with comment. Use // after step and explanation. For Decision lines, also comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取輸入 x // 取得待反轉的整數  \n→ Decision: x < 0? // 判斷是否為負數  \n    Yes → Step: sign = -1; x = -x; // 取正值並記錄符號  \n    No  → Step: sign = 1; // 正數，符號為正  \n→ Step: result = 0 // 初始化反轉結果  \n→ Decision: x == 0? // 直接返回 0  \n    Yes → Step: return 0 // 若輸入為 0，結果即為 0  \n    No  → Step: // 進行後續處理  \n→ Step: INT_MAX = 2147483647; INT_MIN = -2147483648; // 定義 32 位整數極限  \n→ Loop: While x != 0 // 逐位取出並反轉  \n    → Step: digit = x % 10 // 取最低位  \n    → Step: x = x / 10 // 去掉最低位  \n    → Decision: result > INT_MAX / 10? // 檢查乘 10 會不會溢出  \n        Yes → Step: return 0 // 溢出，直接返回 0  \n        No  → Decision: result == INT_MAX / 10 && digit > 7? // 最後一位超過 7 會溢出  \n            Yes → Step: return 0 // 溢出，返回 0  \n            No  → Step: result = result * 10 + digit // 正常累積  \n→ Step: result = result * sign // 乘回符號  \n→ Decision: result < INT_MIN || result > INT_MAX? // 最終檢查是否在範圍內  \n    Yes → Step: return 0 // 超出範圍，返回 0  \n    No  → Step: return result // 正常返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef reverse_int(x: int) -> int:\n    \"\"\"Return x with its digits reversed, or 0 if overflow occurs.\"\"\"\n    sign = -1 if x < 0 else 1\n    x_abs = abs(x)\n    res = 0\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n\n    while x_abs:\n        digit = x_abs % 10\n        x_abs //= 10\n\n        # 檢查乘 10 後是否會溢出 32 位整數\n        if res > INT_MAX // 10 or (res == INT_MAX // 10 and digit > 7):\n            return 0\n\n        res = res * 10 + digit\n\n    res *= sign\n\n    if res < INT_MIN or res > INT_MAX:\n        return 0\n    return res\n\ndef main() -> None:\n    \"\"\"Read an integer from stdin and output its reversed form.\"\"\"\n    data = sys.stdin.read()\n    # 從輸入中尋找第一個整數（可能有符號）\n    m = re.search(r'(-?\\d+)', data)\n    if not m:\n        return\n    x = int(m.group(1))\n    print(reverse_int(x))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": true,
          "output": "-321"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. We need to handle binary addition: strings a and b. Likely reverse iterate, sum bits plus carry, build result string. Steps: start, set i = len(a)-1, j = len(b)-1, carry=0, result=\"\" (or list). Loop while i>=0 or j>=0 or carry. Inside loop: bitA = int(a[i]) if i>=0 else 0; bitB = int(b[j]) if j>=0 else 0; sum = bitA+bitB+carry; result_bit = sum %2; carry = sum //2; prepend result_bit to result string (or push to list). Decrement i, j. After loop, return result.\n\nWe need to provide each step as virtual code with explanation. Use arrows and decisions.\n\nWe need to adhere to format: each line: virtual code step + space + // explanation. Use Start, End, Decision. Use arrow.\n\nLet's craft.\n\nStart // program start\n\n→ Step 1: Initialize i ← length(a) - 1 // 指向 a 最後一位\n\n→ Step 2: Initialize j ← length(b) - 1 // 指向 b 最後一位\n\n→ Step 3: Initialize carry ← 0 // 初始進位為 0\n\n→ Step 4: Initialize result ← \"\" // 儲存結果\n\n→ Decision: While i >= 0 or j >= 0 or carry > 0? // 是否還有位元或進位待處理\n\n    Yes → Step 5: If i >= 0 then bitA ← int(a[i]) else bitA ← 0 // 取得 a 的當前位\n\n    → Step 6: If j >= 0 then bitB ← int(b[j]) else bitB ← 0 // 取得 b 的當前位\n\n    → Step 7: sum ← bitA + bitB + carry // 計算總和\n\n    → Step 8: resultBit ← sum % 2 // 目前位元\n\n    → Step 9: carry ← sum // 2 // 更新進位\n\n    → Step 10: result ← str(resultBit) + result // 將位元加到結果前面\n\n    → Step 11: i ← i - 1 // 移動到前一位\n\n    → Step 12: j ← j - 1 // 移動到前一位\n\n    No → Step 13: Return result // 返回最終二進制字串\n\nEnd // 程式結束\n\nBut we need to ensure proper indentation in virtual code? Example uses indentation with spaces maybe. Use arrow lines. Provide each line with arrow and explanation. Use \"→\" for next step, \"Yes →\" \"No →\" inside decisions. Use \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← length(a) - 1 // 設定 a 的索引指向最後一位  \n→ Step 2: j ← length(b) - 1 // 設定 b 的索引指向最後一位  \n→ Step 3: carry ← 0 // 初始進位為 0  \n→ Step 4: result ← \"\" // 儲存計算出的二進制字串  \n→ Decision: i ≥ 0 or j ≥ 0 or carry > 0? // 是否還有位元或進位要處理？  \n  Yes → Step 5: If i ≥ 0 then bitA ← int(a[i]) else bitA ← 0 // 取得 a 的當前位元（若已越界則為 0）  \n  → Step 6: If j ≥ 0 then bitB ← int(b[j]) else bitB ← 0 // 取得 b 的當前位元（若已越界則為 0）  \n  → Step 7: sum ← bitA + bitB + carry // 計算兩位元與進位的總和  \n  → Step 8: resultBit ← sum % 2 // 取餘數作為此位元  \n  → Step 9: carry ← sum // 2 // 取整數除以 2 作為新的進位  \n  → Step 10: result ← str(resultBit) + result // 把結果位元加到前面  \n  → Step 11: i ← i - 1 // 移動到 a 的前一位  \n  → Step 12: j ← j - 1 // 移動到 b 的前一位  \n  No → Step 13: Return result // 回傳最終的二進制字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j = len(a) - 1, len(b) - 1\n        carry = 0\n        result = []\n\n        while i >= 0 or j >= 0 or carry:\n            total = carry\n            if i >= 0:\n                total += int(a[i])\n                i -= 1\n            if j >= 0:\n                total += int(b[j])\n                j -= 1\n            result.append(str(total % 2))\n            carry = total // 2\n\n        return ''.join(reversed(result))\n\ndef main():\n    data = sys.stdin.read()\n\n    # 優先搜尋引號中的字串，符合範例輸入格式\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        a, b = quoted[0], quoted[1]\n    else:\n        # 若沒有引號，直接以空白分隔\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            a, b = parts[0], parts[1]\n        else:\n            a, b = parts[0] if parts else '', ''\n\n    solution = Solution()\n    result = solution.addBinary(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "100"
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "10101"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code algorithm. The requirement: given two integers a and b, return sum without using + and -. Typical bitwise addition algorithm: while b != 0: carry = a & b; a = a ^ b; b = carry << 1; return a. In virtual code, we must use steps, decisions, arrow. We'll include Start, End. Each line must have `虛擬碼步驟` then space then `// 解釋/說明`. Use arrows →. For decision lines, use `Decision: 如果 b != 0?` etc. Provide no actual code. Use Chinese. Provide step by step. Also mention initialization of carry. Probably use variable names a, b. Provide line for while loop, but represent as decision loop. We'll show steps within the loop: compute carry, update a, update b. Use `→` to go to next step. Ensure each line ends with explanation. Let's craft.\n\nWe should be careful: The virtual code lines: Start, → Step 1: 輸入 a, b, // ...\nBut we can assume a, b already given as input.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 是否 b != 0? // 判斷是否還有進位需要處理\n    Yes → Step 1: carry = a & b // 取得所有進位位\n    → Step 2: a = a ^ b // 進位消除後的位值\n    → Step 3: b = carry << 1 // 進位位左移一位作為下一輪的進位\n    → Decision: 是否 b != 0? // 重新判斷是否還有進位\n        Yes → 回到 Step 1 // 重複循環\n        No → Step 4: return a // 無進位時，a 即為最終和\nEnd // 程式執行結束\n\nBut we need to use `→` arrow properly. The structure may need indentation but we can keep simple.\n\nLet's format:\n\nStart // 程式開始執行\n→ Decision: b ≠ 0? // 判斷是否還有進位需要處理\n    Yes → Step 1: carry = a & b // 取得所有進位位\n    → Step 2: a = a ^ b // 計算不含進位的和\n    → Step 3: b = carry << 1 // 將進位左移一位作為下一次迴圈的進位\n    → Decision: b ≠ 0? // 重新檢查進位\n        Yes → 回到 Step 1 // 進行下一輪\n        No → Step 4: return a // 進位結束，返回結果\nEnd // 程式執行結束\n\nWe need arrow after each step. We must include \"→\" after the line. Each line must contain arrow before or after? The format sample uses \"→ Step 1: ...\" etc. For decisions, \"Decision:\" line has arrow? In sample: \"Decision: 如果數字大於 0? // 檢查數值是否為正\". Then \"Yes → Step 2: ...\" etc. So decisions lines don't have arrow before but are preceded by indentation? We can mimic.\n\nLet's output each line with `→` at start for steps, decision lines with no arrow. Use indentation for nested decision branches: we can prefix spaces. Provide explanation after each line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: b ≠ 0? // 判斷是否還有進位需要處理  \n Yes → Step 1: carry = a & b // 取得所有進位位  \n  → Step 2: a = a ^ b // 計算不含進位的和  \n  → Step 3: b = carry << 1 // 將進位左移一位作為下一輪的進位  \n  → Decision: b ≠ 0? // 重新檢查進位  \n   Yes → 回到 Step 1 // 進行下一輪  \n   No  → Step 4: return a // 進位結束，返回最終和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef add(a: int, b: int) -> int:\n    \"\"\"\n    使用位運算實現兩個整數相加，避免直接使用 + 或 -。\n    透過 32 位元兩補數（two's complement）來處理正負數。\n    \"\"\"\n    MASK = 0xFFFFFFFF      # 取 32 位元\n    MAX_INT = 0x7FFFFFFF   # 最大正整數（2^31 - 1）\n\n    while b != 0:\n        # 取得進位位\n        carry = (a & b) & MASK\n        # 不含進位的和\n        a = (a ^ b) & MASK\n        # 進位位左移一位，作為下一輪的進位\n        b = (carry << 1) & MASK\n\n    # 若 a 為正數（<= MAX_INT）直接回傳，否則轉換為負數\n    return a if a <= MAX_INT else ~(a ^ MASK)\n\ndef main() -> None:\n    \"\"\"\n    主程式：從 stdin 讀取輸入，解析兩個整數，計算並輸出結果。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取出所有整數（包含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        a, b = nums[0], nums[1]\n        result = add(a, b)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode593.json",
    "problem_index_in_file": 0,
    "title": "Valid Square",
    "description_snippet": "Given the coordinates of four points in 2D space p1, p2, p3 and p4, return true if the four points c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm to determine if four points form a square. Steps: compute pairwise distances, sort, check first four equal non-zero, last two equal (diagonals). Use distance squared to avoid sqrt. Use 6 distances. Use set or sorted list.\n\nVirtual code lines: Start, Step 1: compute distances, Step 2: sort, Decision: check lengths, etc. Provide explanation.\n\nWe must not output actual code, only virtual code steps. Use arrows.\n\nLet's create steps:\n\nStart\n\n→ Step 1: Calculate squared distances between all 6 pairs of points (p1-p2, p1-p3, p1-p4, p2-p3, p2-p4, p3-p4) // generate distances\n\n→ Step 2: Store distances in list D // list of 6 squared distances\n\n→ Step 3: Sort D ascending // order distances\n\n→ Decision: Check if D[0] == 0? // ensure no zero distance (distinct points)\n\n    Yes → Step 4: Return false // points coincide\n\n    No  → Step 4: Check if D[0] == D[1] == D[2] == D[3] // four equal sides\n\n        Yes → Step 5: Check if D[4] == D[5] // two equal diagonals\n\n            Yes → Step 6: Return true // it's a square\n\n            No  → Step 7: Return false // diagonals not equal\n\n        No  → Step 8: Return false // sides not equal\n\nEnd\n\nBut need to fit format: each line \"虛擬碼步驟 // 解釋\". Use arrows. For decisions indent. Use \"Decision:\" and \"Yes →\", \"No →\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算所有 6 組點對之間的距離平方值  \n&nbsp;&nbsp;p1-p2, p1-p3, p1-p4, p2-p3, p2-p4, p3-p4 // 取得每對點之距離平方，避免開根號  \n→ Step 2: 將六個距離平方存入列表 D // D[0..5] 保存所有距離  \n→ Step 3: 對列表 D 進行升序排序 // 使相同長度的邊和對角線依次排列  \n→ Decision: D[0] == 0? // 檢查是否有重複點，距離為 0 表示相同  \n&nbsp;&nbsp;Yes → Step 4: Return false // 至少兩個點相同，無法構成正方形  \n&nbsp;&nbsp;No  → Step 4: 判斷前四個距離是否相等且 > 0  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: D[0] == D[1] && D[1] == D[2] && D[2] == D[3] && D[0] > 0? // 四邊相等且正長  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: 判斷最後兩個距離是否相等  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: D[4] == D[5]? // 對角線相等  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: Return true // 四邊相等且對角線相等，為正方形  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 7: Return false // 對角線不等，非正方形  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 8: Return false // 四邊不相等，非正方形  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] == 2 * dists[0]\n        )\n\ndef parse_points(input_str):\n    # 找出所有 [x,y] 形式的座標\n    coords = re.findall(r'\\[(-?\\d+),(-?\\d+)\\]', input_str)\n    points = [(int(x), int(y)) for x, y in coords]\n    if len(points) != 4:\n        raise ValueError(\"輸入中必須包含四個座標點\")\n    return points\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    try:\n        p1, p2, p3, p4 = parse_points(data)\n    except Exception as e:\n        print(\"false\")\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.validSquare(p1, p2, p3, p4)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for binary search insert position. Must use specified format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Decision, Start, End. Provide line by line. The algorithm: Start, set low=0 high=length-1, while low <= high, mid, compare, adjust. After loop return low as insertion index. Provide explanation for each line. Use arrow to denote progression. Provide decisions.\n\nLet's write:\n\nStart\n→ Initialize low=0 // start index\n→ Initialize high=length-1 // end index\n→ Decision: low <= high? // check loop condition\n    Yes → Step: mid = (low + high) / 2 // calculate mid\n          Decision: arr[mid] == target? // check equality\n              Yes → Step: return mid // found\n              No  → Decision: arr[mid] < target? // determine direction\n                  Yes → Step: low = mid + 1 // target right side\n                  No  → Step: high = mid - 1 // target left side\n          (loop back) → Decision: low <= high? // continue\n            (repeat)\n    No → Step: return low // insertion position\nEnd\n\nNeed each line as single line? The decision branches may have multiple lines inside. But spec: each line must be \"虛擬碼步驟 [space] // 解釋\". For indentation of decision branches maybe use tab? But not necessary. The example uses indentation. We can keep same style.\n\nLet's produce lines with proper indentation and arrows. We'll use arrow for each step. For decisions we use \"Decision: ...\". For Yes→ etc.\n\nWe need to ensure each line ends with // 解釋.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize low = 0 // 設定搜尋起始索引  \n→ Initialize high = length - 1 // 設定搜尋結束索引  \n→ Decision: low <= high? // 檢查是否還有區間可搜尋  \n  Yes → Step: mid = (low + high) / 2 // 計算中間索引  \n   Decision: arr[mid] == target? // 檢查中間值是否等於目標  \n    Yes → Step: return mid // 找到目標，返回其索引  \n    No  → Decision: arr[mid] < target? // 目標在右半區間？  \n      Yes → Step: low = mid + 1 // 目標位於右側，更新 low  \n      No  → Step: high = mid - 1 // 目標位於左側，更新 high  \n      // 之後回到最外層判斷條件  \n      // 進行下一輪循環  \n      // (會再次檢查 low <= high)  \n      Yes → (循環回到 Decision: low <= high?)  \n      No  → Step: return low // no 区间，返回插入位置  \n  No  → Step: return low // 初始区间已空，返回插入位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        Find the index where target should be inserted in sorted array nums.\n        Uses binary search with O(log n) time complexity.\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse input of the form 'nums = [1,3,5,6], target = 5'\n    and return the list of integers and the target integer.\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', text)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', text)\n    if not nums_match or not target_match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums = eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    return nums, target\n\nif __name__ == \"__main__\":\n    # Read the entire standard input\n    input_text = sys.stdin.read().strip()\n    # Parse the input into nums list and target value\n    nums, target = parse_input(input_text)\n    # Create solution instance and compute the result\n    result = Solution().searchInsert(nums, target)\n    # Output the result to standard output\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, step-by-step, with explanations, no actual code. The requirement: produce algorithm for finding minimum in rotated sorted array with duplicates, minimizing operations.\n\nWe need to output virtual code: Start, decisions, loops. Probably binary search with modifications for duplicates.\n\nWe need to show steps like:\n\nStart\n→ Step 1: Initialize left=0, right=n-1 // ...\n→ Decision: left==right? // ...\n    Yes → Step 2: return nums[left]\n    No → Decision: nums[left] < nums[right]? // array not rotated\n        Yes → Step 3: return nums[left]\n        No → Step 4: while left < right // binary search\n            ...\nWe need to handle duplicates: if nums[left]==nums[mid]==nums[right], we cannot decide, so left++ or right--. So typical algorithm:\n\nwhile left < right:\n    mid = left + (right-left)//2\n    if nums[mid] > nums[right]:\n        left = mid+1\n    elif nums[mid] < nums[right]:\n        right = mid\n    else:\n        right -= 1\nReturn nums[left]\n\nBut we need to minimize operations: So we can early exit if nums[left] < nums[right], return nums[left]. Also if left==right, return nums[left].\n\nSo we produce virtual code accordingly.\n\nNeed to provide line-by-line with arrow.\n\nAlso we need to consider array length n.\n\nSo let's produce.\n\nUse Step 1: Input array nums // etc.\n\nWe also need to mention n = length(nums).\n\nOk produce.\n\nWe must use \"→\" arrow to indicate steps. Also Decision: lines with Yes→ and No→.\n\nWe need to show Start and End.\n\nLet's produce about 20 lines.\n\nWe should include explanation after each line.\n\nLet's craft.\n\nWe'll use:\n\nStart\n→ Step 1: let left = 0, right = n-1 // 初始化左右指標\n→ Decision: if left == right? // 如果只剩一個元素\n    Yes → Step 2: return nums[left] // 那就是最小值\n    No  → Decision: if nums[left] < nums[right]? // 若首尾已升序\n        Yes → Step 3: return nums[left] // 未旋轉，首元素最小\n        No  → Step 4: while left < right // 進入二分搜尋\n→ Step 5: compute mid = left + (right - left) // 取中點\n→ Decision: if nums[mid] > nums[right]? // 中點大於右端\n    Yes → Step 6: left = mid + 1 // 最小值在右側\n    No  → Decision: if nums[mid] < nums[right]? // 中點小於右端\n        Yes → Step 7: right = mid // 最小值在左側包括mid\n        No  → Step 8: right = right - 1 // nums[mid]==nums[right]，無法確定，縮小右端\n→ Step 9: loop back to Step 5\n→ Step 10: return nums[left] // 循環結束後left指向最小值\nEnd\n\nBut need to ensure virtual code lines each line has explanation.\n\nAlso include the decision indentations.\n\nUse 4 spaces? Format? In example they used tab indentation but we can use simple indentation.\n\nMake sure each line ends with // Explanation.\n\nWe also need to indicate arrows after decisions? In example: Yes → Step X: ...\n\nOk.\n\nAlso we need to show that Step 5 inside loop? We'll indent loop.\n\nBut to keep simple, we can use while loop.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = n-1 // 設定左右指標\n→ Decision: 如果 left == right? // 只剩一個元素時直接返回\n    Yes → Step 2: return nums[left] // 返回唯一元素作為最小值\n    No  → Decision: 如果 nums[left] < nums[right]? // 整個陣列未旋轉\n        Yes → Step 3: return nums[left] // 首元素即為最小值\n        No  → Step 4: while left < right // 開始二分搜尋\n            → Step 5: mid = left + (right - left) // 取得中間位置\n            → Decision: 如果 nums[mid] > nums[right]? // 最小值在右側\n                Yes → Step 6: left = mid + 1 // 移動左指標至 mid+1\n                No  → Decision: 如果 nums[mid] < nums[right]? // 最小值在左側\n                    Yes → Step 7: right = mid // 移動右指標至 mid\n                    No  → Step 8: right = right - 1 // 無法決定，縮小右端\n            → Decision: 循環條件 left < right? // 判斷是否繼續\n                Yes → 回到 Step 5\n                No  → Step 9: return nums[left] // 循環結束，left指向最小值\nEnd // 程式執行結束\n\nNeed to make sure indentation consistent: In virtual code, they use arrows and indentation.\n\nWe must ensure every line has explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = n-1 // 設定左右指標  \n→ Decision: 如果 left == right? // 只剩一個元素時直接返回  \n Yes → Step 2: return nums[left] // 返回唯一元素作為最小值  \n No → Decision: 如果 nums[left] < nums[right]? // 整個陣列未旋轉  \n  Yes → Step 3: return nums[left] // 首元素即為最小值  \n  No → Step 4: while left < right // 開始二分搜尋  \n   → Step 5: mid = left + (right - left) // 取得中間位置  \n   → Decision: 如果 nums[mid] > nums[right]? // 最小值在右側  \n    Yes → Step 6: left = mid + 1 // 移動左指標至 mid+1  \n    No → Decision: 如果 nums[mid] < nums[right]? // 最小值在左側  \n     Yes → Step 7: right = mid // 移動右指標至 mid  \n     No → Step 8: right = right - 1 // 無法決定，縮小右端  \n   → Decision: 循環條件 left < right? // 判斷是否繼續  \n    Yes → 回到 Step 5  \n    No → Step 9: return nums[left] // 循環結束，left 指向最小值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list part from input like 'nums = [1,3,5]'\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n    nums = ast.literal_eval(list_part)\n    result = Solution().findMin(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode638.json",
    "problem_index_in_file": 0,
    "title": "Shopping Offers",
    "description_snippet": "In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for solving this LeetCode problem: \"Shopping Offers\" typical DP/backtracking with memo. We'll produce virtual code step-by-step with explanation. Use Start, Decision, End. Provide each line with arrow and comment. Should reflect algorithm: recursive function dfs(needs) returns min cost, use memo map. For each offer, check if can apply (needs >= offer counts), if yes, recursively compute cost of needs-usage + offer price. Also compute cost of buying remaining items at full price. Use loops.\n\nWe'll produce steps sequentially.\n\nNeed to mention data structures: price array, special offers list, needs array, memo map keyed by tuple of needs.\n\nWill provide steps: Start, Define function solve, initialize memo, call dfs(needs), return result, End.\n\nIn dfs: compute key from needs; if in memo return. Compute minCost = sum(need_i * price_i). For each offer: check if offer applicable: for all i need >= offer[i]; if yes: newNeeds = need_i - offer_i; cost = dfs(newNeeds)+offer_price; update minCost. After loop, memo[key] = minCost; return minCost.\n\nWill produce line-by-line. Use arrows to indicate transitions.\n\nWe will not output actual code, just pseudocode lines with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義價格陣列 price, 需求陣列 needs, 特別優惠陣列 special // 取得問題輸入  \n→ Step 2: 初始化快取 Map memo // 用於記錄已計算過的需求組合  \n→ Step 3: 呼叫 dfs(needs) 並回傳結果 // 進行深度優先搜索求最低價格  \n→ End // 程式執行結束  \n\n---  \n\nStart // 定義遞迴函式 dfs  \n→ Step 4: Function dfs(currentNeeds)  \n→ Step 5: 生成 key = currentNeeds 轉成字串 // 用於快取索引  \n→ Step 6: Decision: key 是否在 memo?  \n  Yes → Step 7: 回傳 memo[key] // 快取命中，直接回傳  \n  No  → Step 8: 計算不使用優惠時的價格  \n    → Step 9: baseCost = Σ currentNeeds[i] * price[i] // 逐項單價相加  \n→ Step 10: 初始化 minCost = baseCost // 目前已知的最低價格  \n→ Step 11: 迭代每個 offer in special  \n→ Step 12: Decision: 是否可以套用此 offer（對所有 i: currentNeeds[i] >= offer[i]）  \n  Yes → Step 13: 計算 newNeeds[i] = currentNeeds[i] - offer[i] for 所有項目  \n    → Step 14: cost = dfs(newNeeds) + offer[最後一個元素] // 套用優惠後遞迴求價  \n    → Step 15: Decision: cost 是否小於 minCost  \n      Yes → Step 16: minCost = cost // 更新最低價格  \n  No  → Step 17: 跳過此 offer // 無法套用，繼續下一個  \n→ Step 18: memo[key] = minCost // 記錄快取  \n→ Step 19: 回傳 minCost // 結束此遞迴層  \n→ End // dfs 函式結束  \n\n---  \n\nStart // 程式執行結束  \n→ End // 完成所有步驟，輸出最終最低價格",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def shoppingOffers(self, price, special, needs):\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs):\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without any special offers\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            for offer in special:\n                # check if the offer can be applied\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return None\n    # Try to convert the input into a dictionary string\n    try:\n        dict_str = '{' + data.replace('=', ':') + '}'\n        data_dict = eval(dict_str, {})\n        price = data_dict['price']\n        special = data_dict['special']\n        needs = data_dict['needs']\n    except Exception:\n        # Fallback: use regex extraction\n        price = ast.literal_eval(\n            re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n        )\n        special = ast.literal_eval(\n            re.search(r'special\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n        )\n        needs = ast.literal_eval(\n            re.search(r'needs\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n        )\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    parsed = parse_input()\n    if parsed:\n        price, special, needs = parsed\n        sol = Solution()\n        result = sol.shoppingOffers(price, special, needs)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp7zxd78ai.py\", line 36, in parse_input\n    data_dict = eval(dict_str, {})\n                ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'price' is not defined. Did you mean: 'print'?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp7zxd78ai.py\", line 54, in <module>\n    parsed = parse_input()\n             ^^^^^^^^^^^^^\n  File \"/tmp/tmp7zxd78ai.py\", line 43, in parse_input\n    re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n    ^^\nNameError: name 're' is not defined. Did you forget to import 're'?"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpw2k9aej_.py\", line 36, in parse_input\n    data_dict = eval(dict_str, {})\n                ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'price' is not defined. Did you mean: 'print'?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpw2k9aej_.py\", line 54, in <module>\n    parsed = parse_input()\n             ^^^^^^^^^^^^^\n  File \"/tmp/tmpw2k9aej_.py\", line 43, in parse_input\n    re.search(r'price\\s*=\\s*(\\[[^\\]]*\\])', data).group(1)\n    ^^\nNameError: name 're' is not defined. Did you forget to import 're'?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode709.json",
    "problem_index_in_file": 0,
    "title": "To Lower Case",
    "description_snippet": "Given a string s, return the string after replacing every uppercase letter with the same lowercase l...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output a virtual code step-by-step with explanation, following format. For this requirement: given string s, return string after replacing every uppercase letter with same lowercase letter.\n\nThus algorithm: iterate over each character, if uppercase convert to lowercase, else keep. Build result. Return.\n\nWe'll produce steps: Start, Step 1: 初始化空字符串 result, Step 2: for each char in s, Step 3: if char is uppercase, convert to lowercase and append, else append original, Step 4: return result, End.\n\nAdd decision for uppercase check.\n\nLet's produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字串 result = \"\" // 建立用於儲存轉換後字元的字串  \n→ Step 2: 從 s 中逐一取得字元 ch // 逐字檢查輸入字串  \n→ Decision: 如果 ch 為大寫字母? // 判斷是否需要轉換  \n  Yes → Step 3: 將 ch 轉成小寫 ch = toLowerCase(ch) // 執行大小寫轉換  \n  No  → Step 3: 不做任何改動 ch = ch // 保持原字元  \n→ Step 4: 將 ch 附加至 result // 將處理後字元加入結果字串  \n→ Step 5: 重複步驟 2-4 直至遍歷完 s // 完成所有字元的處理  \n→ Step 6: 回傳 result // 回傳完成的全部字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def toLowerCase(self, s: str) -> str:\n        \"\"\"將字串中的所有大寫字母轉成小寫字母。\"\"\"\n        result = []\n        for c in s:\n            # ASCII 大寫範圍是 65~90，對應的小寫是加 32\n            if 'A' <= c <= 'Z':\n                result.append(chr(ord(c) + 32))\n            else:\n                result.append(c)\n        return ''.join(result)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    解析 stdin 的內容，支援：\n    - 直接輸入字串，例如 Hello\n    - 帶變數名的寫法，例如 s = \"Hello\"\n    - 包含引號或不包含引號皆可處理\n    回傳純字串值。\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return ''\n    # 如果包含等號，取等號右側\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        raw = value.strip()\n    # 移除首尾可能存在的單雙引號\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.toLowerCase(s)\n    # 按題目範例，輸出時保留雙引號\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello\"",
          "expected_output": "\"hello\"",
          "success": true,
          "output": "\"hello\""
        },
        {
          "example_index": 1,
          "input": "s = \"here\"",
          "expected_output": "\"here\"",
          "success": true,
          "output": "\"here\""
        },
        {
          "example_index": 2,
          "input": "s = \"LOVELY\"",
          "expected_output": "\"lovely\"",
          "success": true,
          "output": "\"lovely\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find minimum in rotated sorted array O(log n). Use binary search approach. Steps: start, left=0, right=n-1, while left<right: mid=(left+right)//2; if nums[mid] > nums[right] then left=mid+1 else right=mid. End loop, answer nums[left]. Provide each step with explanation. Use virtual code with arrows. Use Start, End. Provide decisions. Use binary search steps. Ensure no actual code, just virtual. Each line: \"虛擬碼步驟 // 解釋\". Use Chinese.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始化左右指標\n→ Decision: 是否 left < right? // 判斷是否還需要搜尋\n    Yes → Step 2: 計算 mid = (left + right) // 2 // 取中點\n    → Decision: nums[mid] > nums[right]? // 判斷中點元素是否在升序段的右側\n        Yes → Step 3: left = mid + 1 // 最小值在右半段\n        No  → Step 4: right = mid // 最小值在左半段（含 mid）\n    No  → Step 5: answer = nums[left] // 循環結束，left 指向最小值\nEnd // 程式執行結束\n\nMake sure each line with \"//\". Add arrows for decisions. Use indentation. Ensure formatting exactly as required. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = nums.length - 1 // 初始化左右指標  \n→ Decision: 是否 left < right? // 判斷是否還需要搜尋  \n&nbsp;&nbsp;Yes → Step 2: 計算 mid = (left + right) // 2 // 取中點  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: nums[mid] > nums[right]? // 判斷中點元素是否在升序段的右側  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: left = mid + 1 // 最小值在右半段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4: right = mid // 最小值在左半段（含 mid）  \n&nbsp;&nbsp;No  → Step 5: answer = nums[left] // 循環結束，left 指向最小值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        # If the array is not rotated, the first element is the minimum.\n        if nums[left] <= nums[right]:\n            return nums[left]\n\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                # Minimum must be in the right half (excluding mid)\n                left = mid + 1\n            else:\n                # Minimum is in the left half (mid might be the minimum)\n                right = mid\n        return nums[left]\n\ndef parse_input(raw: str):\n    \"\"\"\n    將原始輸入字串轉換成整數列表。\n    支援「nums = [3,4,5,1,2]」或直接 \"[3,4,5,1,2]\" 等格式。\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n\n    # 尋找第一個 '[' 與最後一個 ']'\n    l = raw.find('[')\n    r = raw.rfind(']')\n    if l == -1 or r == -1:\n        # 若沒有找到方括號，直接嘗試 literal_eval\n        return ast.literal_eval(raw)\n\n    list_str = raw[l:r+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    solution = Solution()\n    result = solution.findMin(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve this DP problem. Provide line-by-line with explanations. Must not output actual code. Use arrows, decisions. We need to produce steps describing algorithm. The steps: Start, initialize DP arrays, iterate over positions, handle states: number of As used (0 or 1), streak of consecutive L (0,1,2). Use DP[i][a][l]. Use modulo. At end sum all states. Provide algorithmic steps. Must output each line with \"虛擬碼步驟 // 解釋\". Use Start, End. Use Decision. Use arrow. Ensure each line separate. Use \"→\". Provide structure.\n\nLet's draft.\n\nStart // 程式開始執行\n→ Initialize MOD = 1e9 + 7 // 定義取模常數\n→ Initialize DP[0][0][0] = 1 // 長度0時，缺席0天，連續遲到0天的唯一狀態\n→ For i from 0 to n-1 // 逐日遍歷\n    → For a in 0..1 // 已經缺席天數 (只能0或1，因為>1不合法)\n        → For l in 0..2 // 連續遲到天數 (只能0,1,2，因為3不合法)\n            → current = DP[i][a][l] // 目前狀態計數\n            → If current == 0 → Continue // 若無此狀態，跳過\n            → // 添加 Present\n                → DP[i+1][a][0] = (DP[i+1][a][0] + current) % MOD // Present 會把遲到連續數清零\n            → // 添加 Late\n                → If l < 2 // 確保不會形成3連遲\n                    → DP[i+1][a][l+1] = (DP[i+1][a][l+1] + current) % MOD // Late 並累積連續遲到\n            → // 添加 Absent\n                → If a == 0 // 只允許一次缺席\n                    → DP[i+1][1][0] = (DP[i+1][1][0] + current) % MOD // Absent 並重置遲到連續數\n← End of loops\n→ result = 0\n→ For a in 0..1\n    → For l in 0..2\n        → result = (result + DP[n][a][l]) % MOD // 將所有合法終態加總\n→ Output result // 回傳符合條件的記錄數\nEnd // 程式執行結束\n\nNeed to use proper format with arrow and indentation maybe. Each line \"虛擬碼步驟 // 解釋\". Let's craft exactly as required.\n\nWe should use \"Start // 程式開始執行\" etc. For loops we can indent but keep line format. Example: \"→ For i from 0 to n-1 // 逐日遍歷\". Inside loops we can have \"    → For a in 0..1 // ...\" etc.\n\nMake sure each line is separate and has the format. Use arrow inside nested loops. Use \"Decision:\" maybe not needed. But we can incorporate \"Decision:\" for if. But can just use \"If\". The requirement says use Decision arrow for decision? It says use 虛擬碼的箭頭 (`→`, `Yes →`, `No →`) and 結構 (`Start`, `End`, `Decision:`). We can use \"Decision:\" for if. Use \"Decision:\" lines.\n\nLet's restructure:\n\nStart // 程式開始執行\n→ Set MOD = 10^9 + 7 // 定義取模\n→ Initialize DP[0][0][0] = 1 // 起始狀態\n→ For i from 0 to n-1 // 逐日\n    → For a in 0..1 // 缺席數\n        → For l in 0..2 // 連續遲到數\n            → Decision: DP[i][a][l] == 0? // 若此狀態無效\n                Yes → Continue // 跳過\n                No  → // 有效\n                    → // 加上 Present\n                        → DP[i+1][a][0] = (DP[i+1][a][0] + DP[i][a][l]) % MOD\n                    → Decision: l < 2? // 是否允許 Late\n                        Yes → DP[i+1][a][l+1] = (DP[i+1][a][l+1] + DP[i][a][l]) % MOD\n                        No  →\n                    → Decision: a == 0? // 是否允許 Absent\n                        Yes → DP[i+1][1][0] = (DP[i+1][1][0] + DP[i][a][l]) % MOD\n                        No  →\n← End loops\n→ result = 0\n→ For a in 0..1\n    → For l in 0..2\n        → result = (result + DP[n][a][l]) % MOD\n→ Output result // 回傳答案\nEnd // 程式結束\n\nNow each line must have \"虛擬碼步驟 // 解釋\". We must include comment. Use // after code.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set MOD = 10^9 + 7 // 定義取模常數  \n→ Initialize DP[0][0][0] = 1 // 起始時長度為 0，缺席 0 天且連續遲到 0 天的唯一合法狀態  \n→ For i from 0 to n-1 // 逐日遍歷每一天  \n    → For a in 0..1 // 目前已缺席天數（只能 0 或 1 天）  \n        → For l in 0..2 // 目前連續遲到天數（最多 2 天）  \n            → Decision: DP[i][a][l] == 0? // 若此狀態不存在  \n                Yes → Continue // 跳過此組合  \n                No  → // 有效的狀態，處理三種可能的下一個字符  \n                    → // 1. 加上 Present（P）  \n                    → DP[i+1][a][0] = (DP[i+1][a][0] + DP[i][a][l]) % MOD // Present 會重置連續遲到計數  \n                    → Decision: l < 2? // 只允許在連續遲到未達 3 天時添加 Late（L）  \n                        Yes → DP[i+1][a][l+1] = (DP[i+1][a][l+1] + DP[i][a][l]) % MOD // Late 並累計連續遲到  \n                        No  → // 已達 2 天連續遲到，不能再加 Late  \n                    → Decision: a == 0? // 只允許一次缺席（A）  \n                        Yes → DP[i+1][1][0] = (DP[i+1][1][0] + DP[i][a][l]) % MOD // A 會重置連續遲到並把缺席數改為 1  \n                        No  → // 已缺席一次，不能再加 A  \n← End loops // 完成所有長度 n 的 DP 狀態填充  \n→ result = 0 // 初始化答案  \n→ For a in 0..1  \n    → For l in 0..2  \n        → result = (result + DP[n][a][l]) % MOD // 把所有合法終態加總得到答案  \n→ Output result // 回傳符合條件的考勤紀錄數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\ndef count_records(n: int) -> int:\n    # dp[a][l] = number of sequences of current length with a 'A's (0 or 1)\n    #            and ending with l consecutive 'L's (0,1,2)\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1  # empty string\n\n    for _ in range(n):\n        new_dp = [[0] * 3 for _ in range(2)]\n        for a in range(2):\n            for l in range(3):\n                val = dp[a][l]\n                if val == 0:\n                    continue\n                # Add 'P'\n                new_dp[a][0] = (new_dp[a][0] + val) % MOD\n                # Add 'A' if we haven't used one yet\n                if a == 0:\n                    new_dp[1][0] = (new_dp[1][0] + val) % MOD\n                # Add 'L' if we are not at 2 consecutive 'L's\n                if l < 2:\n                    new_dp[a][l + 1] = (new_dp[a][l + 1] + val) % MOD\n        dp = new_dp\n\n    # Sum all valid ending states\n    return sum(dp[a][l] for a in range(2) for l in range(3)) % MOD\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    n = int(data)\n    print(count_records(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines. The problem is to find increasing triple subsequence of length 3. Use two variables first and second, iterate through array. Complexity O(n). We'll produce virtual code accordingly. Include Start, Decision, Yes/No arrow. Provide explanation after //.\n\nLet's craft lines:\n\nStart\n→ Step 1: Initialize first ← +∞, second ← +∞ // Set markers for smallest and second smallest values found so far\n→ Step 2: For each num in nums // Iterate over array\n→ Decision: If num <= first? // Check if current number can update first\n    Yes → first ← num // Update smallest value\n    No → Decision: If num <= second? // Check if current number can update second\n        Yes → second ← num // Update second smallest value\n        No → Decision: If first < second < num? // Found increasing triple\n            Yes → Return true // Triple exists\n            No  → // Continue loop\n→ Step 3: Return false // No triple found after loop\nEnd\n\nBut need arrow formatting and each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\". For decisions, use \"Decision:\" and \"Yes →\", \"No →\". Also need to use brackets? Just \"Decision:\".\n\nEnsure each line separate. Provide for loops maybe \"→ Step 2: For each num in nums\". That's fine.\n\nNeed to ensure each line after virtual code includes // explanation. For decision branches, each line include // explanation.\n\nLet's craft.\n\nNote: Use \"Start\" and \"End\". For \"Return true/false\" use \"→ Step X: Return true\". Ok.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 first ← +∞, second ← +∞ // 設定兩個指標，分別記錄目前為止最小與次小的數值  \n→ Step 2: 對於陣列 nums 中的每個元素 num // 逐一檢查每個數字  \n→ Decision: 是否 num ≤ first? // 判斷 num 是否比目前最小值還小  \n  Yes → first ← num // 若是，更新 first 為更小的數值  \n  No → Decision: 是否 num ≤ second? // 若不是，檢查 num 是否比目前次小值還小  \n   Yes → second ← num // 若是，更新 second 為更小的數值  \n   No → Decision: 是否 first < second < num? // 若不是，檢查是否已經形成升序三元組  \n    Yes → Step 3: Return true // 找到符合條件的三元組，直接回傳 true  \n    No → // 沒有形成三元組，繼續迴圈  \n→ Step 4: Return false // 迴圈結束後仍未找到，回傳 false  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def increasingTriplet(self, nums):\n        \"\"\"Return True if there exists an increasing triple subsequence.\"\"\"\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                # Found a number greater than both first and second\n                return True\n        return False\n\ndef parse_nums(input_str):\n    \"\"\"Extract the list of integers from a string like 'nums = [1,2,3]'.\"\"\"\n    # Find the first '[' and the last ']' to isolate the list representation\n    match = re.search(r'\\[.*\\]', input_str, re.S)\n    if not match:\n        return []\n    list_repr = match.group(0)\n    # Safely evaluate the list representation\n    try:\n        nums = eval(list_repr, {\"__builtins__\": None}, {})\n    except Exception:\n        nums = []\n    return nums\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = parse_nums(data)\n    sol = Solution()\n    result = sol.increasingTriplet(nums)\n    # Output 'true' or 'false' in lowercase\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line with explanation for the described algorithm. We should not output actual code, just steps. Need to produce something like:\n\nStart\n→ Step: Initialize arr = [1..n]\n→ Step: direction = left-to-right\n→ Loop until arr length == 1\n    → Decision: direction?\n        Yes → Step: remove first element and every other thereafter // ...\n        No → Step: remove last element and every other thereafter // ...\n    → Step: reverse direction // toggle\n→ Step: return arr[0] // single remaining number\nEnd\n\nBut we need to follow output format: \"虛擬碼步驟 [空格] // 解釋\". Use arrow symbols and Decision. Provide each line.\n\nShould use \"Start\" and \"End\".\n\nAlso need to incorporate list removal logic: when removing from left-to-right: remove index 0,2,4,... from current arr. For right-to-left: remove last index and then every other from the end: basically remove indices len-1, len-3, len-5, ... So can use a step: filter indices based on parity.\n\nWe can provide more explicit: \"Filter arr: keep elements where index parity matches start parity\".\n\nLet's produce lines:\n\nStart\n→ Step: arr ← [1, 2, ..., n] // 建立整齊遞增列表\n→ Step: direction ← LEFT_TO_RIGHT // 初始方向為左到右\n→ Loop: while length(arr) > 1 // 重複直到只剩一個\n    → Decision: direction == LEFT_TO_RIGHT? // 判斷方向\n        Yes → Step: arr ← [arr[i] for i in range(len(arr)) if i % 2 == 0] // 左到右刪除首位及每隔一個\n        No  → Step: arr ← [arr[i] for i in range(len(arr)) if (len(arr)-1 - i) % 2 == 0] // 右到左刪除尾部及每隔一個\n    → Step: direction ← toggle(direction) // 方向交替\n→ Step: return arr[0] // 最後剩餘的數字\nEnd\n\nWe need to maintain the format exactly: each line with \"虛擬碼步驟 // 解釋\". Use \"Start\" and \"End\" as lines.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step: arr ← [1, 2, ..., n] // 建立從1到n的遞增序列\n→ Step: direction ← LEFT_TO_RIGHT // 初始方向設定為左至右\n→ Decision: length(arr) > 1? // 只要列表長度大於1就繼續\n    Yes → Step: arr ← filter(arr, index parity) // 根據方向刪除元素\n    No  → Step: // 結束迴圈\n→ Decision: direction == LEFT_TO_RIGHT? // 判斷當前方向\n    Yes → Step: arr ← [arr[i] for i in 0..len(arr)-1 if i % 2 == 0] // 左至右刪除\n    No  → Step: arr ← [arr[i] for i in 0..len(arr)-1 if (len(arr)-1 - i) % 2 == 0] // 右至左刪除\n→ Step: direction ← toggle(direction) // 方向反轉\n→ Step: return arr[0] // 最後剩下的數\nEnd // 程式結束\n\nBut need to follow exactly the format: each line must be \"虛擬碼步驟 [space] // 解釋\". So \"Start\" line should be \"Start // 程式開始\".\n\n\"→ Step:\" lines. The decision lines: \"→ Decision: ...\". Indentation? In example they used spaces after arrow to indent. We can follow that style:\n\nStart // 程式開始\n→ Step: arr ← [1, 2, ..., n] // 建立遞增列表\n→ Step: direction ← LEFT_TO_RIGHT // 設定初始方向\n→ Loop: while length(arr) > 1 // 只要還有多於一個元素就繼續\n    → Decision: direction == LEFT_TO_RIGHT? // 判斷方向\n        Yes → Step: arr ← [arr[i] for i in 0..len(arr)-1 if i % 2 == 0] // 左至右刪除首項及每隔一個\n        No  → Step: arr ← [arr[i] for i in 0..len(arr)-1 if (len(arr)-1 - i) % 2 == 0] // 右至左刪除尾項及每隔一個\n    → Step: direction ← toggle(direction) // 方向反轉\n→ Step: return arr[0] // 回傳最後剩餘的數\nEnd // 程式結束\n\nBut the example didn't use \"Loop:\"; they used only \"Decision:\" with Yes→ and No→ lines. For loop, we might use \"Loop:\"? They didn't give example for loops but we can incorporate \"Loop:\".\n\nBut maybe better to follow pattern: Use \"Decision:\" for loop condition too: \"Decision: length(arr) > 1?\" with Yes → ... No → End.\n\nLet's produce:\n\nStart // 程式開始\n→ Step: arr ← [1, 2, ..., n] // 建立遞增序列\n→ Step: direction ← LEFT_TO_RIGHT // 初始方向為左至右\n→ Decision: length(arr) > 1? // 只要列表長度大於1就繼續\n    Yes → Decision: direction == LEFT_TO_RIGHT? // 判斷方向\n        Yes → Step: arr ← [arr[i] for i in 0..len(arr)-1 if i % 2 == 0] // 左至右刪除首項及每隔一個\n        No  → Step: arr ← [arr[i] for i in 0..len(arr)-1 if (len(arr)-1 - i) % 2 == 0] // 右至左刪除尾項及每隔一個\n    No  → Step: // 退出循環\n→ Step: direction ← toggle(direction) // 方向反轉\n→ Step: return arr[0] // 最後剩餘數字\nEnd // 程式結束\n\nBut the arrow indentation: After the outer decision, we need to go back to start of loop after toggling direction. The \"No\" branch of outer decision would just end loop, so we need to go back to Step after loop? It's confusing.\n\nBetter to use explicit Loop structure: \"Loop:\" as start of loop, then at end of loop we go back to condition. Example earlier didn't show loops, but we can adapt.\n\nLet's design:\n\nStart // 程式開始\n→ Step: arr ← [1, 2, ..., n] // 建立遞增序列\n→ Step: direction ← LEFT_TO_RIGHT // 初始方向為左至右\n→ Loop: while length(arr) > 1 // 重複直到只剩一個元素\n    → Decision: direction == LEFT_TO_RIGHT? // 判斷當前方向\n        Yes → Step: arr ← [arr[i] for i in 0..len(arr)-1 if i % 2 == 0] // 左至右刪除首項及每隔一個\n        No  → Step: arr ← [arr[i] for i in 0..len(arr)-1 if (len(arr)-1 - i) % 2 == 0] // 右至左刪除尾項及每隔一個\n    → Step: direction ← toggle(direction) // 方向反轉\n→ Step: return arr[0] // 最後剩餘數字\nEnd // 程式結束\n\nYes. That seems clear.\n\nWe need to keep each line separated.\n\nWe must include \"Loop:\" line. They didn't mention but it's okay.\n\nWe need to maintain the format \"虛擬碼步驟 [space] // 解釋\". So each line should have \"→\" before the step if inside loop? But we used \"Loop:\" not preceded by arrow. Might be okay. Use arrow for each step. Example: \"Loop:\" maybe preceded by arrow too.\n\nLet's produce final answer with each line starting with \"Start\" or \"→\" etc.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始  \n→ Step: arr ← [1, 2, ..., n] // 建立從 1 到 n 的遞增序列  \n→ Step: direction ← LEFT_TO_RIGHT // 初始方向設為左至右  \n→ Loop: while length(arr) > 1 // 只要列表長度大於 1 就重複以下步驟  \n  → Decision: direction == LEFT_TO_RIGHT? // 判斷目前方向  \n    Yes → Step: arr ← [arr[i] for i in 0 .. len(arr)-1 if i % 2 == 0] // 左至右：保留索引為偶數的元素（即刪除首項及每隔一個）  \n    No  → Step: arr ← [arr[i] for i in 0 .. len(arr)-1 if (len(arr)-1 - i) % 2 == 0] // 右至左：保留從尾部算起索引為偶數的元素（即刪除尾項及每隔一個）  \n  → Step: direction ← toggle(direction) // 方向交替  \n→ Step: return arr[0] // 最後剩餘的唯一數字  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lastRemaining(self, n: int) -> int:\n        head = 1          # current first number\n        step = 1          # distance between remaining numbers\n        remaining = n     # how many numbers are still in the list\n        left = True       # direction flag: True = left-to-right\n\n        while remaining > 1:\n            # If we are moving left-to-right, or the count of remaining\n            # numbers is odd, the head moves forward.\n            if left or remaining % 2 == 1:\n                head += step\n            # After each round, half the numbers are removed\n            remaining //= 2\n            step *= 2\n            left = not left\n\n        return head\n\ndef main() -> None:\n    # Read the whole input; it may contain lines like \"n = 9\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first integer from the input\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group())\n\n    sol = Solution()\n    print(sol.lastRemaining(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for detecting 132 pattern in array. Use typical stack algorithm: iterate from right, maintain maxK. Complexity O(n). Provide line-by-line steps with explanation. Use virtual code syntax: Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Provide arrow formatting. Let's craft:\n\nStart\n→ Step 1: Initialize empty stack S // stack to store potential nums[j] candidates\n→ Step 2: Set variable third = -∞ // will hold nums[k] (the middle number)\n→ Step 3: For i from n-1 downto 0 // iterate from end\n→ Decision: Is nums[i] < third? // check if current could be nums[i]\n   Yes → Return true // found 132 pattern\n   No → Decision: While stack not empty and stack.top <= nums[i] // pop smaller nums[j] candidates\n        → Pop top // remove from stack\n   No (after popping) → Decision: If stack not empty? // check if any candidate > nums[i]\n        Yes → Set third = stack.top // update nums[k] candidate\n   End of Decision\n→ Step 4: Push nums[i] onto stack // current element could be nums[j]\nEnd // loop finished\n→ Return false // no pattern found\n\nWe need to use the arrow \"→\" and structure. Ensure each line is in the format. Provide explanation after space. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空棧 S // 用來儲存可能的 nums[j] 值  \n→ Step 2: 設定 third = -∞ // 代表目前找到的 nums[k]（中間數）  \n→ Step 3: 從 i = n-1 迭代到 0 // 從陣列尾部向前掃描  \n→ Decision: 如果 nums[i] < third? // 能否成為 nums[i] 且小於已知的 nums[k]  \n    Yes → Return true // 找到 132 模式，直接返回  \n    No → Decision: 當 S 非空且 S.top ≤ nums[i]? // 移除所有不可能成為 nums[j] 的較小值  \n        Yes → S.pop() // 從棧頂移除  \n    End // 移除完畢後繼續判斷  \n→ Decision: 如果 S 非空? // 是否還有大於 nums[i] 的候選 nums[j]  \n    Yes → third = S.top // 更新 nums[k] 為最新能夠符合條件的值  \n    No  → // 沒有可用的 nums[j]，保持 third 不變  \n→ Step 4: S.push(nums[i]) // 把目前元素視作潛在的 nums[j] 推入棧  \nEnd // 迴圈結束  \n→ Return false // 未發現任何 132 模式，返回 false",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def find132pattern(self, nums):\n        stack = []\n        s3 = float('-inf')\n        for num in reversed(nums):\n            if num < s3:\n                return True\n            while stack and stack[-1] < num:\n                s3 = stack.pop()\n            stack.append(num)\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取所有整數（含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    result = sol.find132pattern(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants to convert a string to a zigzag pattern and read line by line. We need to output virtual code step by step, each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure. The user didn't specify input specifics. We'll assume typical Leetcode ZigZag Conversion problem: given string s and numRows, convert. Provide algorithm steps. Use Start, End, Decision, etc.\n\nLet's produce lines. We can use steps like: Start, Step 1: initialize arrays, Step 2: iterate, Step 3: build result, Decision for row movement, etc.\n\nNeed to include arrow → and decisions Yes → No →.\n\nOk. We'll write something like:\n\nStart // 程式開始執行\n→ Step 1: If numRows <= 1 或 s length <= numRows, return s // 簡單情況\n→ Step 2: 建立 numRows 個空字串集合 rows // 用來儲存各行內容\n→ Step 3: 設定 currentRow = 0, direction = -1 // 初始化行號與方向\n→ Step 4: 對每個字元 c in s 迴圈\n    → Decision: 是否已經到第一行或最後一行? // 判斷是否改變方向\n        Yes → direction = -direction // 反轉上下方向\n    → rows[currentRow] += c // 將字元加入對應行\n    → currentRow += direction // 移動到下一行\n→ Step 5: 轉換 rows 為結果字符串 result = \"\" // 初始化結果\n→ Decision: 遍歷 rows 是否有元素? // 連接所有行\n    Yes → result += rows[i] // 累加每行\n→ End // 程式執行結束\n\nBut need to use proper arrows for each line. Also each line must have virtual code and explanation. So we need to format each line with \"虛擬碼步驟 // 解釋\". For decision we need indentation. Use \"Decision: ...\" and indent Yes → and No → lines.\n\nLet's structure.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: If numRows <= 1 or length(s) <= numRows, return s // 直接回傳原字串\n→ Step 2: rows = array of numRows empty strings // 用於儲存每一行的字元\n→ Step 3: currentRow = 0 // 目前所在行號\n→ Step 4: direction = -1 // 初始方向為向下\n→ Step 5: For each char c in s do // 逐字元處理\n    → Decision: currentRow == 0 or currentRow == numRows-1? // 是否到邊界\n        Yes → direction = -direction // 反轉方向\n    → rows[currentRow] += c // 把字元加入對應行\n    → currentRow += direction // 移動到下一行\n→ Step 6: result = \"\" // 初始化結果字串\n→ Decision: for i from 0 to numRows-1? // 遍歷所有行\n    Yes → result += rows[i] // 把行字串連接到結果\n→ End // 程式執行結束\n\nBut we need to have each line separately. For loops and decisions, each line counts. We can use indentation.\n\nWe can use \"Step 5: For each char c in s do\" then indent lines inside.\n\nMake sure each line has arrow and explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If numRows ≤ 1 或 s.length ≤ numRows, return s // 直接回傳原字串，因為無需 zig‑zag  \n→ Step 2: rows = array of numRows empty strings // 用於儲存每一行的字元  \n→ Step 3: currentRow = 0 // 目前所在的行號  \n→ Step 4: direction = -1 // 初始方向為向下（-1 表示向上，+1 表示向下）  \n→ Step 5: For each char c in s do // 逐字元處理  \n  → Decision: currentRow == 0 或 currentRow == numRows-1? // 是否到達最上或最下行  \n   Yes → direction = -direction // 反轉上下方向  \n   No  →  // 方向不變  \n  → rows[currentRow] += c // 把字元加入對應行  \n  → currentRow += direction // 移動到下一行  \n→ Step 6: result = \"\" // 初始化結果字串  \n→ Decision: 迭代 i 從 0 到 numRows-1? // 將所有行連接起來  \n  Yes → result += rows[i] // 把每行的字串加入結果  \n  No  →  // 迴圈結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n        rows = [''] * numRows\n        idx, step = 0, 1\n        for ch in s:\n            rows[idx] += ch\n            if idx == 0:\n                step = 1\n            elif idx == numRows - 1:\n                step = -1\n            idx += step\n        return ''.join(rows)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Try to parse format like: s = 'PAYPALISHIRING', numRows = 3\n    pattern = r\"s\\s*=\\s*'([^']*)'\\s*,\\s*numRows\\s*=\\s*(\\d+)\"\n    match = re.search(pattern, data)\n    if match:\n        s = match.group(1)\n        num_rows = int(match.group(2))\n    else:\n        # Fallback: first line string, second line integer\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            s = lines[0].strip()\n            num_rows = int(lines[1].strip())\n        else:\n            # Fallback: single line \"string number\"\n            parts = data.split()\n            s = parts[0]\n            num_rows = int(parts[1]) if len(parts) > 1 else 1\n    solution = Solution()\n    result = solution.convert(s, num_rows)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "PAHNAPLSIIGYIR"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for word break II problem. Provide steps: Start, input string s, dictionary wordDict. Need to use recursion + memoization to build all sentences. Provide steps like: Start, Step: preprocess dict into set, Step: Define recursive function backtrack(start). Decision: if start == len(s) return [\"\"]. Decision: if start in memo -> return memo[start]. Else result list = []. Iterate i from start+1 to len(s). Decision: if substring in dict, recursively get list for i, then for each sentence, append substring + (space if not empty). Append to result. Memoize. Return result. Finally call backtrack(0). Step: Output result. End.\n\nNeed to produce each line with arrow and comment. Use \"→\" for steps, \"Decision:\" for decisions. Use \"Yes →\" and \"No →\" for decision branches.\n\nMake sure each line is self-contained. Provide explanation after comment.\n\nLet's craft the virtual code.\n\nWe should include Start, define variables, decision nodes, recursion etc.\n\nProbably also include \"Function: backtrack(start):\" etc. Use arrow notation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: s ← 輸入字串 // 取得要切割的原始字串  \n→ Step 2: wordDict ← 輸入字典 // 取得合法單字集合  \n→ Step 3: dictSet ← 轉成 Set(wordDict) // 方便 O(1) 斷言  \n\n// ----------------------------------------------  \n// 定義遞迴函式：回傳從 index 開始可切割出的所有句子  \n→ Function backtrack(start)  \n    → Decision: 如果 start == len(s)? // 是否已達結尾  \n        Yes → Step 4: 回傳 [\"\"} // 空字串代表已完整切割  \n        No  → Step 5: memo ← 檢查 memo 是否已有結果 // 用於快取  \n            Decision: 如果 memo[start] 存在?  \n                Yes → Step 6: 回傳 memo[start] // 直接取快取  \n                No  → Step 7: result ← 空列表 // 存放此 index 的所有句子  \n\n                → For i from start+1 to len(s)  \n                    → Decision: s[start:i] 是否在 dictSet?  \n                        Yes → Step 8: sub ← s[start:i] // 取得合法單字  \n                            → 子句 = backtrack(i) // 取得後續切割  \n                            → For each tail in 子句  \n                                → Decision: tail 为空?  \n                                    Yes → Step 9: result.add(sub) // 單字本身即可  \n                                    No  → Step 10: result.add(sub + \" \" + tail) // 加空格連接  \n\n                    No → // 不是合法單字，跳過  \n\n            → Step 11: memo[start] ← result // 記錄快取  \n            → Step 12: 回傳 result // 將此 index 的結果回傳  \n// ----------------------------------------------  \n\n→ Step 13: sentences ← backtrack(0) // 從頭開始尋找所有切割  \n→ Step 14: return sentences // 輸出所有合法句子集合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> list[str]:\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start: int) -> list[str]:\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub in backtrack(end):\n                        if sub:\n                            res.append(word + \" \" + sub)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    s = None\n    wordDict = None\n\n    # 用正則表達式提取 s 與 wordDict\n    s_match = re.search(r\"s\\s*=\\s*(['\\\"])(.*?)\\1\", data, re.S)\n    if s_match:\n        s = s_match.group(2)\n\n    wd_match = re.search(r\"wordDict\\s*=\\s*(\\[[^\\]]*\\])\", data, re.S)\n    if wd_match:\n        try:\n            wordDict = ast.literal_eval(wd_match.group(1))\n        except Exception:\n            wordDict = None\n\n    # 若上述方法失敗，嘗試直接執行整段文字\n    if s is None or wordDict is None:\n        try:\n            local_vars = {}\n            exec(data, {}, local_vars)\n            s = local_vars.get(\"s\")\n            wordDict = local_vars.get(\"wordDict\")\n        except Exception:\n            pass\n\n    # 若仍無法解析，結束程式\n    if s is None or wordDict is None:\n        return\n\n    solution = Solution()\n    result = solution.wordBreak(s, wordDict)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": true,
          "output": "['cat sand dog', 'cats and dog']"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": true,
          "output": "['pine apple pen apple', 'pine applepen apple', 'pineapple pen apple']"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to compute maximum rotation function. Classic problem: O(n) solution using formula: F(k) = F(k-1) + sum(nums) - n*nums[n-k]. Actually formula: F(k) = F(k-1) + sum(nums) - n*nums[n-k]. We'll generate algorithm: compute sum, initial F0, iterate k from1 to n-1 update cur using formula, keep max. Output. Provide virtual code lines with explanations. Use structure Start, Decision etc. Should be \"逐行\". We need each line with virtual code and // explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 計算 n = nums.length, sum = 0, cur = 0 // 初始化長度、總和與 F(0)\n→ Loop i=0 to n-1: sum += nums[i] // 計算總和\n→ Loop i=0 to n-1: cur += i * nums[i] // 計算 F(0)\n→ Set max = cur // 設定最大值為 F(0)\n→ Step 2: For k = 1 to n-1:\n    → cur = cur + sum - n * nums[n - k] // 根據遞推公式更新 F(k)\n    → If cur > max: max = cur // 更新最大值\n→ End // 回傳 max\n\nBut need virtual code with arrow syntax: Use Start, End, Decision: lines. Use arrows for steps. Provide decision inside loop for update.\n\nLet's format each line: \"→ Step X: ...\" etc.\n\nWe can include nested loops: Use decision for if cur > max. For loops we just state \"→ For k = 1 to n-1:\". Might need sub-steps inside loop. Use indent? Example format uses spaces and nested indents with Yes/No arrows. We'll mimic.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: sum ← 0; cur ← 0 // 初始化總和與 F(0)\n→ Step 3: For i ← 0 to n-1: sum ← sum + nums[i] // 計算總和\n→ Step 4: For i ← 0 to n-1: cur ← cur + i * nums[i] // 計算 F(0)\n→ Step 5: max ← cur // 設定最大值為 F(0)\n→ Step 6: For k ← 1 to n-1:\n    → cur ← cur + sum - n * nums[n - k] // 使用遞推公式更新 F(k)\n    → Decision: cur > max? // 判斷是否更新最大值\n        Yes → max ← cur // 更新最大值\n        No  → // 不更新\n→ End // 回傳 max\n\nNeed to return max. So add \"→ Return max // 傳回最大旋轉函數值\".\n\nLet's incorporate that.\n\nAlso we might want to use \"→ Step 7: Return max\" before End. Ok.\n\nReturn before End.\n\nAlso we may need \"→ Step 7: Return max\" then End.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: sum ← 0; cur ← 0 // 初始化總和與 F(0)  \n→ Step 3: For i ← 0 to n-1: sum ← sum + nums[i] // 計算所有元素之和  \n→ Step 4: For i ← 0 to n-1: cur ← cur + i * nums[i] // 計算 F(0)  \n→ Step 5: max ← cur // 初始最大值為 F(0)  \n→ Step 6: For k ← 1 to n-1: // 從 1 到 n-1 逐步旋轉  \n    → cur ← cur + sum - n * nums[n - k] // 根據遞推公式更新 F(k)  \n    → Decision: cur > max? // 判斷是否為新最大值  \n        Yes → max ← cur // 更新最大值  \n        No  → // 保持現有 max  \n→ Step 7: Return max // 回傳最高的旋轉函數值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        cur = sum(i * num for i, num in enumerate(nums))\n        max_val = cur\n        for i in range(1, n):\n            cur = cur + total - n * nums[n - i]\n            if cur > max_val:\n                max_val = cur\n        return max_val\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n    try:\n        l = data.find('[')\n        r = data.rfind(']')\n        if l == -1 or r == -1:\n            return []\n        list_str = data[l:r+1]\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\ndef main():\n    nums = parse_input()\n    sol = Solution()\n    print(sol.maxRotateFunction(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": true,
          "output": "26"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a data structure with update and range sum. Likely using a Binary Indexed Tree or Segment Tree. We can choose a Fenwick tree. The code should include initialization, update, sumRange functions. We produce steps like Start, step to initialize BIT, update: adjust BIT, sumRange: query prefix sums. Use virtual code lines with explanations. Each line must have code step and comment.\n\nWe should structure like:\n\nStart\n→ Step 1: Initialize BIT with size n+1 // Build Fenwick tree\n→ Step 2: For i from 0 to n-1: update BIT with nums[i] // build tree\nEnd\n\nBut we need to define class and methods. We need virtual code with arrows and decisions? Not necessary.\n\nWe should show: Start // program starts\n→ Step 1: Define class NumArray // create class\n→ Step 2: Declare array nums, tree, size\n→ Step 3: Constructor: copy nums, build BIT\n→ Step 4: update method: difference, adjust BIT\n→ Step 5: sumRange method: prefix sums\n\nAdd decision? Not needed.\n\nWe need to maintain structure like arrow lines.\n\nWe also need \"逐行\" output, each line one step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Define class NumArray // 定義類別\n→ Step 2: Declare variables: nums[], tree[], size // 儲存原始陣列與樹\n→ Step 3: NumArray(nums) // 建構子\n    → Step 4: size ← length of nums // 記錄長度\n    → Step 5: tree ← new int[size+1] // Fenwick 樹\n    → Step 6: For i from 0 to size-1: // 初始化樹\n        → Step 7: treeUpdate(i, nums[i]) // 加入初始值\n→ Decision: update(index, val) // 更新方法\n    → Step 8: diff ← val - nums[index] // 計算差值\n    → Step 9: nums[index] ← val // 更新陣列\n    → Step 10: treeUpdate(index, diff) // 更新樹\n→ Decision: sumRange(left, right) // 查詢範圍和\n    → Step 11: return prefixSum(right) - prefixSum(left-1) // 兩個前綴和差\n→ Step 12: treeUpdate(idx, delta) // 更新 Fenwick 樹\n    → Step 13: i ← idx + 1\n    → Step 14: While i ≤ size:\n        → Step 15: tree[i] ← tree[i] + delta // 更新節點\n        → Step 16: i ← i + (i & -i) // 移動到父節點\n→ Step 17: prefixSum(idx) // 前綴和\n    → Step 18: sum ← 0\n    → Step 19: i ← idx + 1\n    → Step 20: While i > 0:\n        → Step 21: sum ← sum + tree[i] // 累加\n        → Step 22: i ← i - (i & -i) // 移動到父節點\n    → Step 23: return sum\nEnd // 程式執行結束\n\nWe also need to ensure each line has comment. Use // in Chinese. The arrow lines. Ensure indenting for nested steps? The format might allow indentation but not necessary.\n\nWe need to include decisions? Not necessary but we can include Decision lines for methods. But each method could be step lines.\n\nBetter to use \"Decision:\" for if statements only. No if in code except maybe inside methods? No.\n\nThus produce list.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class NumArray // 定義 NumArray 類別  \n→ Step 2: Declare variables: nums[], tree[], size // 儲存原始陣列、Fenwick 樹與大小  \n→ Step 3: NumArray(nums) // 建構子，傳入原始陣列  \n    → Step 4: size ← length of nums // 記錄陣列長度  \n    → Step 5: tree ← new int[size+1] // 初始化 Fenwick 樹 (大小+1)  \n    → Step 6: For i from 0 to size-1: // 建構樹  \n        → Step 7: treeUpdate(i, nums[i]) // 將每個元素加入樹中  \n→ Step 8: update(index, val) // 更新指定位置的值  \n    → Step 9: diff ← val - nums[index] // 計算增量  \n    → Step 10: nums[index] ← val // 更新原始陣列  \n    → Step 11: treeUpdate(index, diff) // 在樹中反映差值  \n→ Step 12: sumRange(left, right) // 取得區間 [left, right] 的總和  \n    → Step 13: return prefixSum(right) - prefixSum(left-1) // 兩個前綴和之差即為區間和  \n→ Step 14: treeUpdate(idx, delta) // Fenwick 樹的更新輔助函式  \n    → Step 15: i ← idx + 1 // Fenwick 樹索引從 1 開始  \n    → Step 16: While i ≤ size: // 逐層更新至根節點  \n        → Step 17: tree[i] ← tree[i] + delta // 加上差值  \n        → Step 18: i ← i + (i & -i) // 移至下一個需要更新的節點  \n→ Step 19: prefixSum(idx) // 取得前綴和輔助函式  \n    → Step 20: sum ← 0 // 初始化累加器  \n    → Step 21: i ← idx + 1 // 索引調整  \n    → Step 22: While i > 0: // 逐層往回累加  \n        → Step 23: sum ← sum + tree[i] // 累加節點值  \n        → Step 24: i ← i - (i & -i) // 移至父節點  \n    → Step 25: return sum // 回傳前綴和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Split the two JSON lists\n    first_end = data.find(']')\n    ops_str = data[:first_end + 1]\n    args_str = data[first_end + 2:].strip()\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])\n            result.append(None)\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            result.append(None)\n        elif op == \"sumRange\":\n            result.append(obj.sumRange(arg[0], arg[1]))\n        else:\n            result.append(None)\n\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": true,
          "output": "[null, 9, null, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. For checking power of four. Use steps: Start, check n>0, check bit pattern: only one bit set and position multiple of 2. Or iterative dividing by 4. Let's create simple algorithm: while n%4==0 n/=4; after loop if n==1 then true else false. Provide virtual code lines. Include Decision, loops maybe using Decision. Virtual code style: use \"While\" or \"Decision\" to check. Use arrow. We'll produce steps. Ensure each line has \"// explanation\". Use Start and End. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否 n ≤ 0? // 檢查輸入是否為正整數  \n  Yes → Return false // 不是正數則非四的冪  \n  No  → → Step 1: 初始化 temp = n // 將輸入值暫存於 temp  \n→ Step 2: 循環判斷 temp 是否能被 4 整除  \n  Decision: temp % 4 == 0? // 檢查是否可被 4 整除  \n   Yes → temp = temp / 4 → 前往 Step 2 // 繼續除以 4  \n   No  → → Step 3: 判斷 temp 是否等於 1  \n→ Step 3: Decision: temp == 1? // 判斷除完後是否剩下 1  \n  Yes → Return true // 成功減至 1，表示是 4 的冪  \n  No  → Return false // 不是 1，則不是 4 的冪  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        \"\"\"\n        檢查 n 是否為 4 的冪:\n        1. 必須是正整數\n        2. 二進制中只能有一個 1 (n & (n-1)) == 0\n        3. 這個 1 必須位於偶數位置，等價於 (n-1) % 3 == 0\n        \"\"\"\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中抓取第一個出現的整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # 沒有找到數字，直接退出\n    n = int(match.group())\n    solution = Solution()\n    result = solution.isPowerOfFour(n)\n    # 輸出符合範例格式的布林值\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code (pseudo code) that solves the problem: given integer array nums, and lower and upper bounds, return the number of range sums within [lower, upper] inclusive. This is the LeetCode problem \"Range Sum Count\" (#327). The standard solution uses prefix sums and divide & conquer (merge sort) or Fenwick tree / BIT with coordinate compression. We can produce a virtual code algorithm with divide & conquer using merge sort to count pairs of prefix sums difference in [lower, upper].\n\nWe need to produce step-by-step pseudo code with arrows and comments. Each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use Start, End, Decision: etc. Should be line by line, no actual code.\n\nWe should outline algorithm:\n\nStart: compute prefix sums array pref of length n+1 with pref[0] = 0.\n\nDefine recursive function countWhileMerge(lo, hi) returning count for subarray pref[lo..hi] (inclusive). Base case hi - lo <= 0: return 0.\n\nElse mid = (lo+hi)/2.\n\nCount left = countWhileMerge(lo, mid).\n\nCount right = countWhileMerge(mid+1, hi).\n\nThen count cross pairs: for each i in lo..mid, find number of j in mid+1..hi such that pref[j] - pref[i] in [lower, upper]. Use two pointers to count l and r.\n\nAdd cross count to result.\n\nMerge the two halves sorted.\n\nReturn total count.\n\nFinally return countWhileMerge(0, n) from main.\n\nWe need to produce virtual code step by step, with arrows. Use \"Start // 程式開始執行\" etc.\n\nWe need to incorporate function calls. Also we need to produce lines like \"→ Step: 初始化前綴和陣列 pref // 產生前綴和陣列\" etc.\n\nLet's produce lines:\n\nStart\n→ Step 1: 計算前綴和 pref // 建立 pref[0]=0, pref[i+1]=pref[i]+nums[i]\n→ Step 2: 調用 countWhileMerge(0, n) // 以 pref 整體範圍統計符合條件的對\n→ Step 3: Return result // 結果回傳\n\nDefine function countWhileMerge(lo, hi)\n→ Decision: 是否 hi <= lo? // 判斷子陣列大小\n    Yes → Step 4: Return 0 // 子陣列只有一個元素或空\n    No  → Step 5: mid = (lo+hi) // 計算中點 // ...\n...\n\nBut we should follow the format: Each line is \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nBetter to produce lines for main procedure, then separate function block maybe with \"→ Function: countWhileMerge(lo, hi)\". However the requirement says each line must include arrow, etc. We can start with \"→ Function: countWhileMerge(lo, hi) // 定義遞歸函式\".\n\nLet's craft entire pseudo code:\n\nStart // 程式開始執行\n→ Step 1: 初始化前綴和陣列 pref[0] = 0 // 前綴和起始值\n→ Step 2: 對於 i in 0..n-1, pref[i+1] = pref[i] + nums[i] // 計算累積和\n→ Step 3: 呼叫 countWhileMerge(0, n) // 從整個前綴和陣列統計\n→ Step 4: 返回計數結果 // 結束主流程\n\n→ Function: countWhileMerge(lo, hi) // 定義遞歸函式\n    → Decision: hi <= lo? // 子陣列大小判斷\n        Yes → Step 5: 返回 0 // 子陣列空或單元素無跨範圍\n        No  → Step 6: mid = (lo + hi) // 計算中點\n        → Step 7: leftCount = countWhileMerge(lo, mid) // 左半邊遞歸\n        → Step 8: rightCount = countWhileMerge(mid+1, hi) // 右半邊遞歸\n        → Step 9: crossCount = 0 // 初始化跨範圍計數\n        → Step 10: l = mid+1, r = mid+1 // 指標初始化\n        → Decision: for i from lo to mid? // 遍歷左半邊\n            Yes → Step 11: while l <= hi and pref[l] - pref[i] < lower? // l 往右移\n                    l += 1 // 移動 l\n                 // 之後 l 為首個滿足差 >= lower\n            No\n            → Step 12: while r <= hi and pref[r] - pref[i] <= upper? // r 往右移\n                    r += 1 // 移動 r\n                 // r 為首個差 > upper\n            No\n            → Step 13: crossCount += (r - l) // 所有符合差範圍的 j\n        → Step 14: merge pref[lo..mid] 與 pref[mid+1..hi] // 合併排序\n        → Step 15: 返回 leftCount + rightCount + crossCount // 返回總計\nEnd // 程式執行結束\n\nBut we need to maintain format exactly: each line with arrow \"→\" or \"Start\", etc. Use \"Start\" and \"End\" lines. Indentation not required but we can use spaces. For function block, we can indent lines with spaces. But each line must be \"虛擬碼步驟 [空格] // 解釋\". So we can produce:\n\nStart // 程式開始執行\n→ Step 1: ... //...\n...\n\nWe need to be careful with \"→ Decision:\" lines for loops maybe not necessary. But we can use \"Decision:\" for if conditions.\n\nHowever, for loops, we can use \"→ For i from lo to mid:\". Might be okay. But the format requires \"Decision:\" for branching. For loops, we can just write \"→ For i from lo to mid:\". It's okay.\n\nBut the requirement: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:).\" So we should include arrow before each step. For \"Decision:\", we need to indent substeps. Use \"Yes →\" and \"No →\".\n\nLet's produce final answer. Ensure it's in Traditional Chinese.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化前綴和陣列 pref[0] = 0 // 前綴和起始值\n→ Step 2: 對於 i 從 0 到 n-1，pref[i+1] = pref[i] + nums[i] // 逐步累加形成前綴和\n→ Step 3: result = countWhileMerge(0, n) // 以整個前綴和陣列統計符合條件的範圍和\n→ Step 4: Return result // 結束主流程\n\n→ Function: countWhileMerge(lo, hi) // 定義遞歸函式\n    → Decision: hi <= lo? // 子陣列大小判斷\n        Yes → Step 5: Return 0 // 空或單元素子陣列不產生跨範圍\n        No  → Step 6: mid = (lo + hi) // 計算中點\n        → Step 7: leftCount = countWhileMerge(lo, mid) // 左半邊遞歸\n        → Step 8: rightCount = countWhileMerge(mid+1, hi) // 右半邊遞歸\n        → Step 9: crossCount = 0 // 初始化跨範圍計數\n        → Step 10: l = mid + 1, r = mid + 1 // 指標初始化\n        → Step 11: For i from lo to mid: // 遍歷左半邊\n            → Step 12: While l <= hi and pref[l] - pref[i] < lower: l += 1 // 移動 l 直至差 >= lower\n            → Step 13: While r <= hi and pref[r] - pref[i] <= upper: r += 1 // 移動 r 直至差 > upper\n            → Step 14: crossCount += r - l // 所有 j 使 pref[j] - pref[i] 落在 [lower, upper]\n        → Step 15: merge pref[lo..mid] 與 pref[mid+1..hi] // 合併兩半排序以便後續計算\n        → Step 16: Return leftCount + rightCount + crossCount // 回傳此段總計\nEnd // 程式執行結束\n\nCheck formatting: each line starts with arrow or \"Start\" or \"End\". Use indent for nested steps but each line still starts with \"→\". For nested inside Decision, we used \"Yes →\" and \"No →\". That matches.\n\nBut maybe we need to have \"Decision:\" line before nested? The example shows:\n\nDecision: 如果數字大於 0? \n    Yes → Step 2 ...\n    No  → Decision: 如果數字等於 0? ...\n\nSo we might include a \"Decision:\" line. So in our code we can add \"→ Decision: hi <= lo?\" then nested \"Yes →\" \"No →\". Similarly for while loops? Not necessary.\n\nBut we had \"Decision:\" line earlier. Actually we wrote \"→ Decision: hi <= lo?\" but the format expects \"Decision:\" without arrow? The example had \"Decision:\" preceded by arrow? The example shows:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n\nSo \"Decision:\" line has arrow and \"Decision:\". Good.\n\nSo we should change Step 6 to \"→ Decision: hi <= lo?\" Then nested lines. But we also used \"Yes →\" etc.\n\nLet's restructure:\n\n→ Decision: hi <= lo? // 子陣列大小判斷\n    Yes → Step 5: Return 0 // 空或單元素子陣列不產生跨範圍\n    No  → Step 6: mid = (lo + hi) // 計算中點\n    → Step 7: leftCount = countWhileMerge(lo, mid) // 左半邊遞歸\n    ...\n\nThus we need to indent the lines after \"No\" accordingly.\n\nLet's produce final answer with correct formatting.\n\nAlso we need to consider that the function block should start after \"→ Function: countWhileMerge(lo, hi)\" maybe not necessary but okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化前綴和陣列 pref[0] = 0 // 前綴和起始值  \n→ Step 2: 對於 i 從 0 到 n-1，pref[i+1] = pref[i] + nums[i] // 逐步累加形成前綴和  \n→ Step 3: result = countWhileMerge(0, n) // 以整個前綴和陣列統計符合條件的範圍和  \n→ Step 4: Return result // 結束主流程  \n\n→ Function: countWhileMerge(lo, hi) // 定義遞歸函式  \n    → Decision: hi <= lo? // 子陣列大小判斷  \n        Yes → Step 5: Return 0 // 空或單元素子陣列不產生跨範圍  \n        No  → Step 6: mid = (lo + hi) // 計算中點  \n        → Step 7: leftCount = countWhileMerge(lo, mid) // 左半邊遞歸  \n        → Step 8: rightCount = countWhileMerge(mid+1, hi) // 右半邊遞歸  \n        → Step 9: crossCount = 0 // 初始化跨範圍計數  \n        → Step 10: l = mid + 1, r = mid + 1 // 指標初始化  \n        → Step 11: For i from lo to mid: // 遍歷左半邊  \n            → Step 12: While l <= hi and pref[l] - pref[i] < lower: l += 1 // 移動 l 直至差 >= lower  \n            → Step 13: While r <= hi and pref[r] - pref[i] <= upper: r += 1 // 移動 r 直至差 > upper  \n            → Step 14: crossCount += r - l // 所有 j 使 pref[j] - pref[i] 落在 [lower, upper]  \n        → Step 15: merge pref[lo..mid] 與 pref[mid+1..hi] // 合併兩半排序以便後續計算  \n        → Step 16: Return leftCount + rightCount + crossCount // 回傳此段總計  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef count_range_sum(nums, lower, upper):\n    \"\"\"計算符合 [lower, upper] 的範圍和數量。\"\"\"\n    prefix = [0]\n    for num in nums:\n        prefix.append(prefix[-1] + num)\n\n    def sort_and_count(lo, hi):\n        \"\"\"遞歸地計算並排序 prefix[lo:hi]。\"\"\"\n        if hi - lo <= 1:\n            return 0\n        mid = (lo + hi) // 2\n        count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n        i = j = mid\n        for left_val in prefix[lo:mid]:\n            while i < hi and prefix[i] - left_val < lower:\n                i += 1\n            while j < hi and prefix[j] - left_val <= upper:\n                j += 1\n            count += j - i\n\n        # 將左半段與右半段合併為排序好的子陣列\n        prefix[lo:hi] = sorted(prefix[lo:hi])\n        return count\n\n    return sort_and_count(0, len(prefix))\n\ndef parse_input(s):\n    \"\"\"從輸入字串中解析 nums、lower、upper。\"\"\"\n    # 先嘗試搜尋「nums = [...]」等模式\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', s)\n    if nums_match:\n        nums = ast.literal_eval(nums_match.group(1))\n    else:\n        nums = []\n\n    lower_match = re.search(r'lower\\s*=\\s*(-?\\d+)', s)\n    lower = int(lower_match.group(1)) if lower_match else 0\n\n    upper_match = re.search(r'upper\\s*=\\s*(-?\\d+)', s)\n    upper = int(upper_match.group(1)) if upper_match else 0\n\n    return nums, lower, upper\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums, lower, upper = parse_input(data)\n    result = count_range_sum(nums, lower, upper)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. The problem: given sorted unique array, produce list of ranges. Implementation: iterate, track start and prev, if current != prev+1, close range. At end push last. Format output. Virtual code steps. Use Start, Decision, etc.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化變數 start = nums[0]，prev = nums[0]，ranges = 空列表 // 設定起始值\n\n→ Step 2: 從索引 1 開始遍歷 nums // 循環處理剩餘元素\n\n→ Decision: 當前數字與 prev 是否連續? // 判斷是否屬於同一範圍\n\n    Yes → Step 3: prev = nums[i] // 更新 prev 為當前值，繼續同一範圍\n\n    No → Step 4: 將 [start, prev] 轉為字串並加入 ranges // 結束上一個範圍\n\n        → Step 5: start = prev = nums[i] // 開啟新範圍\n\nEnd Loop // 結束遍歷\n\n→ Step 6: 將最後一個範圍 [start, prev] 加入 ranges // 處理最後區段\n\n→ Step 7: 回傳 ranges // 輸出結果\n\nBut need to incorporate arrow notation and Decision: etc. Also need to produce output like \"a->b\" if a != b else \"a\". So conversion step.\n\nLet's format each line as \"虛擬碼步驟 // 解釋\". Use arrows.\n\nProbably like:\n\nStart // 程式開始執行\n\n→ Step 1: Set start = nums[0], prev = nums[0], ranges = [] // 初始化\n\n→ Step 2: For i from 1 to length(nums)-1 // 開始遍歷\n\n→ Decision: nums[i] == prev + 1? // 檢查是否為連續\n\n    Yes → Step 3: prev = nums[i] // 連續，更新 prev\n\n    No → Step 4: Append formatRange(start, prev) to ranges // 結束上一區間\n\n        → Step 5: start = prev = nums[i] // 新起始\n\nEnd For // 結束遍歷\n\n→ Step 6: Append formatRange(start, prev) to ranges // 處理最後區間\n\n→ Step 7: Return ranges // 輸出結果\n\nNow, include explanation in each line. Provide formatRange pseudo step.\n\nWe can add Step 0 maybe.\n\nLet's produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Set start = nums[0], prev = nums[0], ranges = [] // 初始化起始值與暫存變數\n→ Step 2: For i from 1 to length(nums)-1 // 從第二個元素開始遍歷\n→ Decision: nums[i] == prev + 1? // 判斷目前數字是否與前一個連續\n    Yes → Step 3: prev = nums[i] // 連續，更新 prev 為目前數字\n    No  → Step 4: Append formatRange(start, prev) to ranges // 將已完成的區間加入結果\n        → Step 5: start = prev = nums[i] // 重新設定新的區間起點\nEnd For // 遍歷結束\n→ Step 6: Append formatRange(start, prev) to ranges // 處理最後一個區間\n→ Step 7: Return ranges // 回傳最終的區間清單\n``` \n\n其中 `formatRange(a, b)` 為虛擬碼步驟，實現為：\n```\n→ Step 0: If a == b then return string(a) else return string(a) + \"->\" + string(b)\n```\n\n這樣即可得到符合題目要求的最小化區間列表。",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        res = []\n        start = end = nums[0]\n        for n in nums[1:]:\n            if n == end + 1:\n                end = n\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{end}\")\n                start = end = n\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{end}\")\n        return res\n\ndef parse_input(data: str):\n    \"\"\"Extract the list of integers from the input string.\"\"\"\n    # Remove whitespace\n    data = data.strip()\n    # Find the first '[' and the last ']'\n    start_idx = data.find('[')\n    end_idx = data.rfind(']')\n    if start_idx == -1 or end_idx == -1 or end_idx < start_idx:\n        # If no brackets found, try to eval the whole string\n        return ast.literal_eval(data)\n    list_str = data[start_idx:end_idx + 1]\n    return ast.literal_eval(list_str)\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    nums = parse_input(raw_input)\n    result = Solution().summaryRanges(nums)\n    # Output using JSON format to match the required double‑quoted strings\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "[\"0->2\", \"4->5\", \"7\"]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "[\"0\", \"2->4\", \"6\", \"8->9\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode731.json",
    "problem_index_in_file": 0,
    "title": "My Calendar II",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for MyCalendarTwo class with book method. Use Start, End, Decision. Provide line by line virtual code. Not actual code, but structured steps. Each line: \"虛擬碼步驟 // 解釋\". We should cover initialization, data structures, booking logic: maintain list of intervals and overlapping count. Use events list and overlapped intervals list? Standard solution uses two lists: events and overlaps. Approach: on book, check for triple overlap: for each existing interval, if overlap, create overlapping interval. Check if that overlap intersects with any existing overlap. If yes, triple booking -> reject. Else add event to events, add new overlap intervals to overlaps list. Return true.\n\nLet's produce stepwise pseudocode. Use decisions for overlapping detection. Use loop over events. Use loop over overlaps. Represent intervals as objects with start, end.\n\nWe'll produce lines like:\n\nStart // 程式開始\n→ Step 1: 初始化 events 為空列表 // 用於存放所有已預約的事件\n→ Step 2: 初始化 overlaps 為空列表 // 用於存放已經存在的雙重重疊區間\nEnd // 類別初始化完成\n\nThen for book method:\n\nStart // book 方法開始\n→ Step 3: 將輸入的 startTime 與 endTime 包裝成 interval // 代表新事件\n→ Decision: 是否存在 triple booking? // 檢查新事件與現有事件及 overlaps 的關係\n   → Yes → Step 4: 返回 false // 不能加入\n   → No → Step 5: 將 interval 加入 events // 將新事件加入列表\n   → Step 6: 計算與所有 events 的重疊區間\n       → Loop over events\n           → Decision: 事件 interval 與 events[i] 有重疊? // 判斷\n               → Yes → Step 7: 建立 overlap interval = [max(start1,start2), min(end1,end2)] // 兩個事件重疊的區間\n               → Step 8: 將 overlap interval 加入 tempOverlaps 列表\n   → Step 9: 將 tempOverlaps 加入 overlaps 列表\n→ Step 10: 返回 true // 成功加入\nEnd // book 方法結束\n\nNeed to include triple booking detection: while computing overlaps, check if new overlap interval intersects any existing overlap interval. So inside loop over events, after computing newOverlap, we need to check for intersection with overlaps list: decision: does newOverlap intersect any overlaps? If yes -> triple booking -> reject before adding event. So we need steps:\n\nInside loop:\n- compute newOverlap\n- Decision: 是否與 overlaps 任一重疊? // triple booking check\n   - Yes → Step 4: 返回 false\n   - No → Step 8: add to tempOverlaps\n\nWe need to break out of loops properly but pseudocode can just flow.\n\nAlso need to add new overlaps into overlaps after adding event.\n\nLet's craft each line.\n\nNumbering not required, but we can provide sequential steps.\n\nUse arrows: \"→\" and decisions with \"Yes →\", \"No →\".\n\nMake sure each line includes // 解釋.\n\nLet's craft.\n\nAlso mention that intervals stored as [start, end).\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化 events 為空列表 // 用於存放所有已預約的事件  \n→ Step 2: 初始化 overlaps 為空列表 // 用於存放已經存在的雙重重疊區間  \nEnd // MyCalendarTwo 物件初始化完成  \n\n---  \n\nStart // book 方法開始  \n→ Step 3: 將輸入的 startTime 與 endTime 包裝成 newInterval // 代表即將新增的事件  \n→ Decision: 先檢查是否會產生三重重疊? // 如果有，直接拒絕  \n    Yes → Step 4: 返回 false // 無法加入  \n    No  → Step 5: 將 newInterval 加入 events // 將新事件加入列表  \n→ Step 6: 建立 tempOverlaps 為空列表 // 用於暫存此次新增事件與現有事件產生的重疊區間  \n→ Step 7: 循環遍歷 events 列表 (不含新加入的 interval)  \n    → Decision: newInterval 與 events[i] 有重疊? // 判斷兩個事件是否有共同區間  \n        Yes → Step 8: 計算 overlapStart = max(newInterval.start, events[i].start)  \n        → Step 9: 計算 overlapEnd = min(newInterval.end, events[i].end)  \n        → Step 10: 產生 newOverlap = [overlapStart, overlapEnd] // 兩事件重疊區間  \n        → Decision: newOverlap 是否與 overlaps 任一區間重疊? // 檢查是否已存在雙重重疊  \n            Yes → Step 11: 返回 false // 會形成三重重疊，拒絕加入  \n            No  → Step 12: 將 newOverlap 加入 tempOverlaps // 收集此次新增事件產生的重疊區間  \n        No  → // 新事件與 events[i] 無重疊，跳過  \n→ Step 13: 將 tempOverlaps 中的所有區間加入 overlaps 列表 // 更新全局雙重重疊集合  \n→ Step 14: 返回 true // 成功加入事件，無三重重疊  \nEnd // book 方法結束",
      "generated_code": "import sys\nimport json\n\nclass MyCalendarTwo:\n    \"\"\"\n    MyCalendarTwo 使用兩個列表來跟踪已預約的事件和已存在的雙重重疊區間。\n    1. booked   : 存放所有已成功加入的事件 (start, end)。\n    2. overlaps : 存放所有雙重重疊區間，這些區間代表已經存在兩個事件重疊的範圍。\n    \"\"\"\n    def __init__(self):\n        self.booked = []\n        self.overlaps = []\n\n    def book(self, start: int, end: int) -> bool:\n        # 先檢查新事件與現有的雙重重疊區間是否再次重疊，若有則會形成三重重疊\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n\n        # 計算新事件與已存在事件的所有重疊區間，並將這些區間加入 overlaps\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n\n        # 最後把新事件加入 booked\n        self.booked.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 由於輸入格式為兩個 JSON 列表以逗號分隔，非單一合法 JSON\n    # 先找到第一個 ']'，將前後兩部分分開解析\n    pos = data.find(']')\n    ops_str = data[:pos+1]\n    args_str = data[pos+1:].strip()\n    if args_str.startswith(','):\n        args_str = args_str[1:].strip()\n\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    output = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarTwo\":\n            obj = MyCalendarTwo()\n            output.append(None)          # 按照 LeetCode 風格，constructor 的返回為 null\n        elif op == \"book\":\n            start, end = arg\n            res = obj.book(start, end)\n            output.append(res)\n        else:\n            # 若出現未知操作，略過或拋出錯誤\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # 將結果轉成 JSON，Python 的 True/False 會自動轉成 true/false，None 轉成 null\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "success": true,
          "output": "[null, true, true, true, false, true, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode560.json",
    "problem_index_in_file": 0,
    "title": "Subarray Sum Equals K",
    "description_snippet": "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: count subarrays with sum equal to k. Use prefix sum + hash map. So steps: Start, initialize count, prefixSum=0, map with {0:1}. For each num in nums: prefixSum += num; needCount = prefixSum - k; if map contains needCount then count += map[needCount]; then increment map[prefixSum] count. After loop End. Also output result. Provide line-by-line with arrows and decisions? The algorithm has no decisions except map lookups. Could include decision: if needCount exists? Yes/No. We'll provide. Ensure no actual code. Use virtual steps. We'll do:\n\nStart\n→ Initialize count = 0 // total subarrays\n→ Initialize prefixSum = 0 // running sum\n→ Initialize map = {0:1} // prefix sum count\n→ For each element num in nums // iterate array\n    → prefixSum = prefixSum + num // update running sum\n    → needCount = prefixSum - k // required previous sum\n    → Decision: map contains needCount? // check if a prefix sum exists\n        Yes → count = count + map[needCount] // add occurrences\n        No  → // do nothing\n    → Decision: map contains prefixSum? // update map\n        Yes → map[prefixSum] = map[prefixSum] + 1\n        No  → map[prefixSum] = 1\n→ Output count // return result\nEnd\n\nMake sure to follow format: \"虛擬碼步驟 [space] // 解釋\". Use Start, End etc. Provide arrow for nested steps? They used \"→ Decision:\" with indent. We'll indent using spaces. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0 // 用來累計符合條件的子陣列數量  \n→ Step 2: 初始化 prefixSum = 0 // 用來儲存目前為止的前綴和  \n→ Step 3: 初始化 map = {0:1} // 前綴和 0 出現一次，方便計算整個子陣列等於 k  \n→ Step 4: 逐一遍歷 nums 中的每個元素 num  \n  → Step 4.1: prefixSum = prefixSum + num // 更新目前為止的前綴和  \n  → Step 4.2: needCount = prefixSum - k // 需要的前綴和值以符合子陣列總和為 k  \n  → Decision: map 中是否存在 needCount? // 判斷是否已有相同前綴和  \n    Yes → Step 4.3: count = count + map[needCount] // 若存在，累加該前綴和出現的次數  \n    No  → // 若不存在，則不做任何操作  \n  → Decision: map 中是否存在 prefixSum? // 判斷目前前綴和是否已經出現過  \n    Yes → Step 4.4: map[prefixSum] = map[prefixSum] + 1 // 若已存在，次數加一  \n    No  → Step 4.5: map[prefixSum] = 1 // 若不存在，建立並設為 1  \n→ Step 5: 輸出 count // 回傳符合條件的子陣列總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def subarraySum(self, nums, k):\n        count = 0\n        prefix_sum = 0\n        sum_map = {0: 1}\n\n        for num in nums:\n            prefix_sum += num\n            need = prefix_sum - k\n            if need in sum_map:\n                count += sum_map[need]\n            sum_map[prefix_sum] = sum_map.get(prefix_sum, 0) + 1\n\n        return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the array inside brackets\n    array_match = re.search(r'\\[(.*?)\\]', data)\n    nums = ast.literal_eval('[' + array_match.group(1) + ']') if array_match else []\n\n    # Extract the integer after 'k ='\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    solution = Solution()\n    result = solution.subarraySum(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,1], k = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3], k = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode600.json",
    "problem_index_in_file": 0,
    "title": "Non-negative Integers without Consecutive Ones",
    "description_snippet": "Given a positive integer n, return the number of the integers in the range [0, n] whose binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The algorithm: count numbers <= n with no consecutive ones. Classic DP. Approach: find binary representation bits of n, iterate from MSB to LSB building count using Fibonacci. For each bit 1, add fib[i+2] where i is index from LSB? But we will explain generically. Use DP: fib[0]=1, fib[1]=2 etc. Then traverse bits. Use variable prev_bit=0. If bit is 1: add fib[remaining_bits+1], and if prev_bit also 1: break. After loop, if no break, add 1 (include n itself). So produce virtual code lines.\n\nNeed to output virtual code step-by-step with arrow, decision etc. Use Start, End. Provide line by line explanation. Should be understandable. Let's craft.\n\nUse steps:\n\nStart // begin\n→ Step 1: Get binary array bits of n from most significant to least // convert n to binary list\n→ Step 2: Initialize fib array up to length bits+2 // precompute Fibonacci counts\n    → Step 2a: fib[0] = 1\n    → Step 2b: fib[1] = 2\n    → Step 2c: For i from 2 to bits+1: fib[i] = fib[i-1] + fib[i-2]\n→ Step 3: Set count = 0, prev_bit = 0\n→ Step 4: For each bit index i from 0 to bits-1 (MSB to LSB)\n    → Decision: If bit[i] == 1?\n        Yes → Step 4a: count += fib[bits - i] // add combinations for remaining positions\n        Yes → Decision: If prev_bit == 1?\n            Yes → Step 4b: Return count // consecutive ones found, terminate\n            No  → Step 4c: prev_bit = 1 // set prev for next iteration\n        No  → Step 4d: prev_bit = 0 // reset prev\n→ Step 5: After loop, count += 1 // include n itself\n→ End // return count\n\nBut we need line by line. Let's create each line with step label, arrow. Provide explanation comment after //.\n\nWe need to maintain indentation for decisions. Use \"Decision:\" and Yes→ etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 n 轉成二進位位元陣列 bits (從最高位到最低位) // 取得 n 的二進位表示  \n→ Step 2: 建立 Fibonacci 陣列 fib，長度為 bits.length + 2 // 事先算出無連續 1 的組合數  \n    → Step 2a: fib[0] = 1 // 只有 0 的排列方式  \n    → Step 2b: fib[1] = 2 // 0 或 1 的排列方式  \n    → Step 2c: For i = 2 到 bits.length + 1: fib[i] = fib[i-1] + fib[i-2] // 斐波那契遞迴  \n→ Step 3: 設 count = 0, prev_bit = 0 // count 先儲存已計算的數量  \n→ Step 4: For i = 0 到 bits.length-1 (從最高位開始)  \n    → Decision: 如果 bits[i] == 1? // 判斷目前位是否為 1  \n        Yes → Step 4a: count += fib[bits.length - i] // 加上剩餘位元組合的數量  \n        Yes → Decision: 如果 prev_bit == 1? // 檢查前一位是否也為 1  \n            Yes → Step 4b: Return count // 發現連續 1，結束計算  \n            No  → Step 4c: prev_bit = 1 // 記錄目前為 1，供下一位判斷  \n        No  → Step 4d: prev_bit = 0 // 目前為 0，重設 prev_bit  \n→ Step 5: count += 1 // 包含 n 本身（已檢查無連續 1）  \n→ End // 程式執行結束，回傳 count",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findIntegers(self, n: int) -> int:\n        \"\"\"\n        計算在 [0, n] 範圍內，二進位表示中不含連續 1 的數字個數。\n        \"\"\"\n        # dp[i] 表示長度為 i 的二進位字串（前導 0 允許）且不含連續 1 的組合數\n        dp = [0] * 32\n        dp[0] = 1          # 空字串\n        dp[1] = 2          # \"0\", \"1\"\n        for i in range(2, 32):\n            dp[i] = dp[i - 1] + dp[i - 2]   # 斐波那契遞推\n\n        ans = 0\n        prev_bit = 0\n        # 逐位從高到低檢查\n        for i in reversed(range(31)):\n            if n & (1 << i):\n                ans += dp[i]      # 當前位為 1 時，前 i 位可任意填寫且不含連續 1\n                if prev_bit:      # 若前一位也為 1，則已超出限制，直接返回\n                    return ans\n                prev_bit = 1\n            else:\n                prev_bit = 0\n\n        # 如果迴圈結束沒有遇到連續 1，則 n 本身符合條件\n        return ans + 1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並從中提取第一個整數\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        sys.exit()\n    n = int(nums[0])\n\n    solution = Solution()\n    result = solution.findIntegers(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem of adding binary operators to achieve target. It's basically Leetcode 282. We produce step-by-step pseudocode lines. Need to output lines like \"Start // 程式開始執行\". Use arrow notation. Each line after arrow \"→\" plus step description. Include decision blocks. No real code, just virtual. Provide explanation after //.\n\nWe need to output algorithm: use DFS/backtracking, handle leading zeros, track current value, previous operand for multiplication. Also need to store expression string.\n\nSo produce steps:\n\nStart\n→ Initialize result list\n→ Call DFS(index=0, path=\"\", eval=0, prev=0)\n→ DFS definition: if index==len(num) ...\n→ Decision: if index==len(num) → compare eval==target → add path to result\n→ Decision: else loop i from index to len(num)-1:\n    Build current number string curStr = num[index:i+1]\n    if curStr has leading zeros and length>1 skip\n    cur = int(curStr)\n    if index==0: // first operand\n        DFS(i+1, curStr, cur, cur)\n    else:\n        // plus\n        DFS(i+1, path+'+'+curStr, eval+cur, cur)\n        // minus\n        DFS(i+1, path+'-'+curStr, eval-cur, -cur)\n        // multiply\n        DFS(i+1, path+'*'+curStr, eval-prev+prev*cur, prev*cur)\nEnd\n\nExplain each.\n\nWe must produce per line. Use arrow. Provide short explanation after //. Use Chinese. Let's output lines with correct arrow. For decision blocks we indent with spaces? Example shows indentation. We'll use similar.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ 初始化 result 為空串列 // 用來儲存符合目標的表達式\n→ 呼叫 DFS(0, \"\", 0, 0) // 從數字起始位置開始遞迴，path 目前路徑，eval 已計算值，prev 上一個數字（用於乘法）\n\nDFS(index, path, eval, prev) // 定義遞迴函式\n    → Decision: 如果 index == len(num) // 已經處理完所有數字\n        Yes → Decision: 如果 eval == target // 計算結果等於目標值\n            Yes → 把 path 加入 result // 這個表達式符合要求\n            No  → 什麼也不做 // 不符合目標，回到上一層遞迴\n        No  → 什麼也不做 // index 還沒到結尾，繼續處理\n    → for i from index to len(num)-1 // 依次嘗試不同長度的子數字\n        → 取子串 curStr = num[index:i+1] // 當前考慮的數字字串\n        → Decision: 如果 curStr 長度 > 1 且首字元為 '0' // 防止前導零\n            Yes → Continue // 跳過這個子串，進行下一個\n            No  → // 允許繼續\n        → 轉換 cur = int(curStr) // 將子串轉成整數\n        → Decision: 如果 index == 0 // 第一個數字，無需加運算子\n            Yes → DFS(i+1, curStr, cur, cur) // 直接以 cur 為初始值\n            No  →\n                // 加上加號\n                → DFS(i+1, path + \"+\" + curStr, eval + cur, cur)\n                // 加上減號\n                → DFS(i+1, path + \"-\" + curStr, eval - cur, -cur)\n                // 加上乘號（需考慮優先級）\n                → DFS(i+1, path + \"*\" + curStr, eval - prev + prev * cur, prev * cur)\nEnd // 程式執行結束，result 即為所有符合條件的表達式集合",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # skip numbers with leading zeros\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 解析輸入格式：num = \"123\", target = 6\n    m = re.search(r'num\\s*=\\s*\"([^\"]+)\"\\s*,\\s*target\\s*=\\s*(-?\\d+)', data)\n    if not m:\n        # 支援沒有雙引號的情況\n        m = re.search(r'num\\s*=\\s*([0-9]+)\\s*,\\s*target\\s*=\\s*(-?\\d+)', data)\n    if not m:\n        raise ValueError(\"Invalid input format\")\n    num_str = m.group(1)\n    target_val = int(m.group(2))\n\n    solution = Solution()\n    result = solution.addOperators(num_str, target_val)\n    # 使用 json.dumps 以得到雙引號包圍的字串\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "success": true,
          "output": "[\"1+2+3\", \"1*2*3\"]"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "success": true,
          "output": "[\"2+3*2\", \"2*3+2\"]"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem is classic two sum with sorted array, using two pointers. Provide line-by-line virtual code with explanation.\n\nFormat: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. Use \"→\" to indicate step. Should be clear.\n\nLet's craft:\n\nStart // start\n→ Step 1: 設定 left = 1, right = numbers.length // 初始化左右指標\n→ Step 2: 進入 while (left < right) // 只要左右未交叉\n    → Decision: sum = numbers[left] + numbers[right] // 計算目前兩數之和\n        Yes → Decision: sum == target? // 檢查是否等於目標\n            Yes → Step 3: 返回 [left, right] // 找到解\n            No → Decision: sum < target? // 小於目標\n                Yes → Step 4: left = left + 1 // 左指標右移\n                No  → Step 5: right = right - 1 // 右指標左移\nEnd // 程式結束\n\nBut need to use 1-indexed. In code, but we can note that left/right start at 1 and indices are 1-based. When accessing array, we use numbers[left] etc.\n\nAlso need to emphasize constant extra space: we only use two indices and some variables.\n\nWe should produce virtual code accordingly.\n\nMake sure each line has the arrow and explanation.\n\nAlso need to indicate decision blocks properly with indentation maybe.\n\nThe example shows indentation: Step lines inside Decision. Use \"→ Decision:\" with indent.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 1, right = numbers.length // 初始化左右指標，左指標指向最小值，右指標指向最大值\n→ Step 2: 進入 while (left < right) // 當左指標仍在右指標左側時持續迴圈\n    → Decision: sum = numbers[left] + numbers[right] // 取得目前兩個數字的和\n        Yes → Decision: sum == target? // 判斷和是否等於目標值\n            Yes → Step 3: 返回 [left, right] // 找到符合條件的兩個索引，直接回傳\n            No  → Decision: sum < target? // 若和小於目標值\n                Yes → Step 4: left = left + 1 // 左指標向右移動，尋找更大的數字\n                No  → Step 5: right = right - 1 // 右指標向左移動，尋找更小的數字\nEnd // 程式執行結束，結束時已返回答案且使用常數額外空間",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n\n    # 取得 numbers 列表\n    numbers_match = re.search(r'numbers\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not numbers_match:\n        raise ValueError(\"Invalid input: numbers not found\")\n    numbers = eval(numbers_match.group(1))\n\n    # 取得 target 整數\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not target_match:\n        raise ValueError(\"Invalid input: target not found\")\n    target = int(target_match.group(1))\n\n    # 呼叫解法並輸出結果\n    result = Solution().twoSum(numbers, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": true,
          "output": "[1, 3]"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode682.json",
    "problem_index_in_file": 0,
    "title": "Baseball Game",
    "description_snippet": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code lines. Start, loop over operations. Use stack to store scores. For each op: if digit: push int; else if '+': sum top two and push; else if 'D': double top and push; else if 'C': pop. After loop, sum stack and return. Provide each line with // explanation. Use arrows. Must be line-by-line. Use 'Start', 'End'. Use Decision constructs.\n\nWe'll produce steps:\n\nStart\n→ Initialize stack = empty // 用於儲存分數\n→ For each op in operations // 逐一處理操作\n    → Decision: op is integer?\n        Yes → Convert op to int x; push x onto stack // 記錄新分數\n        No → Decision: op == '+'\n            Yes → sum = top + second top; push sum // 記錄前兩分數之和\n            No → Decision: op == 'D'\n                Yes → double = top * 2; push double // 記錄前一分數兩倍\n                No → Decision: op == 'C'\n                    Yes → pop top; // 刪除最近分數\n                    No → // 無效操作 (不會出現)\n→ Sum all elements in stack // 計算總分\n→ Return sum // 結果\nEnd\n\nWe should ensure arrow formatting consistent. Use tab or spaces? They show indent with tabs maybe. Use spaces.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 stack 為空列表 // 用來儲存所有有效分數  \n→ Step 2: 對 operations 中的每個 op 進行迭代 // 逐一處理操作  \n    → Decision: op 為數字? // 判斷是否為新分數  \n        Yes → Step 3: 把 op 轉成整數 x，並 push 到 stack // 記錄新分數  \n        No → Decision: op == '+'? // 判斷是否為前兩分數之和  \n            Yes → Step 4: sum = stack[top] + stack[top-1]，push sum 到 stack // 記錄 + 操作  \n            No → Decision: op == 'D'? // 判斷是否為前一分數的兩倍  \n                Yes → Step 5: double = stack[top] * 2，push double 到 stack // 記錄 D 操作  \n                No → Decision: op == 'C'? // 判斷是否為刪除最近分數  \n                    Yes → Step 6: pop stack[top] // 刪除最近分數  \n                    No → Step 7: // 無效操作，實際測試不會發生  \n→ Step 8: 計算 stack 中所有元素的總和 sum // 得到最終得分  \n→ Step 9: 返回 sum // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def calPoints(self, ops):\n        stack = []\n        for op in ops:\n            if op == \"C\":\n                stack.pop()\n            elif op == \"D\":\n                stack.append(2 * stack[-1])\n            elif op == \"+\":\n                stack.append(stack[-1] + stack[-2])\n            else:\n                stack.append(int(op))\n        return sum(stack)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract strings inside double quotes\n    ops = re.findall(r'\"([^\"]*)\"', data)\n    result = Solution().calPoints(ops)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]",
          "expected_output": "30",
          "success": true,
          "output": "30"
        },
        {
          "example_index": 1,
          "input": "ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
          "expected_output": "27",
          "success": true,
          "output": "27"
        },
        {
          "example_index": 2,
          "input": "ops = [\"1\",\"C\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Virtual code includes arrows, decision nodes, Start, End. We need to design a TimeMap data structure. Steps: initialize map of key to list of (timestamp, value). Set: append to list. Get: binary search for largest timestamp <= given. If not found return \"\". So virtual steps. Probably start, Step 1: initialize data structure. Then operations set/get. We'll produce generic pseudocode for each method.\n\nWe must output line by line: each line \"虛擬碼步驟 // 解釋\". Use arrow arrows, decisions.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立一個全域資料結構 map // 用於存放 key -> (timestamp, value) 清單\n→ Decision: 有無使用者請求? // 判斷是否收到 set 或 get 指令\n    Yes → Step 2: 讀取指令類型 (set/get) // 從輸入取得操作類別\n    No  → End // 無操作，結束\n→ Decision: 指令為 set? // 判斷要進行哪種操作\n    Yes → Step 3: 取得 key, value, timestamp // 從參數中提取值\n    → Step 4: 若 map 不包含 key, 則初始化空清單 // 確保 key 有資料結構\n    → Step 5: 將 (timestamp, value) 加入 key 對應清單末尾 // 保持時間遞增順序\n    No  → Decision: 指令為 get? // 若不是 set，則是 get\n        Yes → Step 6: 取得 key, timestamp // 讀取查詢參數\n        → Step 7: 若 map 不包含 key, 立即回傳 \"\" // 沒有任何存儲\n        → Step 8: 取得 key 對應清單 L // 讀取該 key 的時間序列\n        → Decision: L 為空? // 檢查是否有任何時間戳\n            Yes → Step 9: 回傳 \"\" // 無資料\n            No  → Step 10: 執行二分搜尋以找到最大 ≤ timestamp 的索引 // 找到合適的時間點\n            → Decision: 找到有效索引? // 確認是否存在合法的時間戳\n                Yes → Step 11: 取得該索引對應的 value 並回傳 // 返回最近的值\n                No  → Step 12: 回傳 \"\" // 沒有可用時間戳\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport bisect\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        # 每個 key 對應一個時間戳與值的列表，保持時間遞增順序\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接把 (timestamp, value) 加入列表，列表已經是遞增的\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        # 若 key 未存在，直接回傳空字串\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 在 (timestamp, chr(127)) 位置找右側插入點\n        # chr(127) 保證比任何字串都大，找到第一個 > timestamp 的位置\n        idx = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if idx == 0:\n            return \"\"\n        # 回傳最接近但不超過 timestamp 的值\n        return arr[idx - 1][1]\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 解析成兩個列表：操作名與對應參數\n    ops, params = json.loads(raw)\n    results = []\n    obj = None\n\n    for op, p in zip(ops, params):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            results.append(None)          # constructor 返回 null\n        elif op == \"set\":\n            obj.set(*p)                   # 參數為 [key, value, timestamp]\n            results.append(None)          # set 返回 null\n        elif op == \"get\":\n            res = obj.get(*p)             # 參數為 [key, timestamp]\n            results.append(res)\n        else:\n            # 若遇到未知操作，仍加入 None 以保持輸出長度\n            results.append(None)\n\n    # 輸出為 JSON 以符合題目期望的格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp1v4yc6n9.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp1v4yc6n9.py\", line 34, in main\n    ops, params = json.loads(raw)\n                  ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for next permutation: standard algorithm: find first decreasing from end, if none swap whole reverse; else swap with next greater element, then reverse suffix.\n\nWe must output line-by-line with comments. Use virtual code syntax: Start, → Step, Decision. Let's craft steps.\n\nExample:\n\nStart // start\n→ Step 1: n = length(nums)\n→ Decision: 找到最大索引 i 使 nums[i] < nums[i+1]? // 寻找首个下降点\n   Yes → Step 2: i = found index\n   No  → Step 3: 反转整个数组 nums[0...n-1]; End // 逆序为最小排列\n\nIf found:\n→ Step 4: 找到最小索引 j>i 使 nums[j] > nums[i] // 右侧最小大于nums[i]\n→ Step 5: 交换 nums[i] 与 nums[j]\n→ Step 6: 反转 nums[i+1...n-1] // 使后缀升序\n\nEnd\n\nAlso need to indicate decisions with Yes → and No →. Provide explanation comment after each.\n\nLet's produce.\n\nEnsure each line: virtual code step + space + // explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: 找到最大的 i 使 nums[i] < nums[i+1]？ // 搜尋第一個遞減位置  \n  Yes → Step 2: i ← 該位置的索引 // 取得遞減點  \n  No  → Step 3: 反轉 nums[0 … n-1] // 重新排列為最小排列",
      "generated_code": "import sys\nimport ast\n\ndef next_permutation(nums):\n    \"\"\"修改 nums 為下一個字典序排列，原地操作，使用常數額外空間。\"\"\"\n    n = len(nums)\n    i = n - 2                         # 從尾端尋找第一個遞減位置\n    while i >= 0 and nums[i] >= nums[i + 1]:\n        i -= 1\n\n    if i >= 0:                        # 找到遞減點後的處理\n        j = n - 1                     # 從尾端尋找比 nums[i] 大的最小元素\n        while nums[j] <= nums[i]:\n            j -= 1\n        nums[i], nums[j] = nums[j], nums[i]   # 交換\n\n    # 反轉後半段使其升序\n    left, right = i + 1, n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\ndef main():\n    \"\"\"從標準輸入讀取陣列，計算下一排列後輸出。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 處理類似 \"nums = [1,2,3]\" 的輸入\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    nums = ast.literal_eval(expr)     # 安全解析 Python 表達式\n    next_permutation(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode678.json",
    "problem_index_in_file": 0,
    "title": "Valid Parenthesis String",
    "description_snippet": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is va...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps. The requirement: Virtual code steps, each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure: Start, End, Decision:.\n\nWe need to provide a solution algorithm for string s containing parentheses and '*', validate.\n\nStandard approach: track minOpen and maxOpen while scanning: '*' can be 0, +1 or -1. If maxOpen <0 -> invalid. At end minOpen==0 -> valid.\n\nWe need to produce virtual code lines accordingly.\n\nThe virtual code lines: Start, Step 1: Initialize minOpen=0, maxOpen=0. Step 2: Iterate over each character c in s. Decision: if c == '(' ... etc. Provide arrow and steps. Also need to handle final decision: if minOpen==0 then return true else false. End.\n\nWe must not output actual code, just pseudo. Use Chinese explanation.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 minOpen = 0, maxOpen = 0 // 初始化左括號可能數量範圍\n→ Step 2: 對 s 的每個字元 c 進行迴圈 // 遍歷整個字串\n    → Decision: 如果 c 為 '('? // 看到左括號\n        Yes → minOpen = minOpen + 1; maxOpen = maxOpen + 1 // 左括號至少多一個，最大也多一個\n        No  → Decision: 如果 c 為 ')' ? // 右括號\n            Yes → minOpen = max(minOpen - 1, 0); maxOpen = maxOpen - 1 // 右括號至少減一，最大減一\n            No  → Decision: 如果 c 為 '*'? // 星號\n                Yes → minOpen = max(minOpen - 1, 0); maxOpen = maxOpen + 1 // 星號可視為 ')' 或 '('\n                No  → // 其它字符（理論上不會出現）\n    → Decision: 如果 maxOpen < 0? // 右括號過多\n        Yes → Return False // 直接判定無效\n        No  → // 繼續迴圈\n→ Decision: 如果 minOpen == 0? // 所有左括號已配對\n    Yes → Return True // 有效\n    No  → Return False // 仍有未配對的左括號\nEnd // 程式執行結束\n\nWe need to output each line separately, each line with \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe also need to handle indentation: In example they had indentation lines inside Decision. But we should include indentation with spaces? The example had 4 spaces indent inside Decision. We'll do similar.\n\nThus produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 設定 minOpen = 0, maxOpen = 0 // 初始化左括號可能數量範圍\n→ Step 2: 對 s 的每個字元 c 進行迴圈 // 遍歷整個字串\n    → Decision: 如果 c 為 '('? // 看到左括號\n        Yes → minOpen = minOpen + 1; maxOpen = maxOpen + 1 // 左括號至少多一個，最大也多一個\n        No  → Decision: 如果 c 為 ')' ? // 右括號\n            Yes → minOpen = max(minOpen - 1, 0); maxOpen = maxOpen - 1 // 右括號至少減一，最大減一\n            No  → Decision: 如果 c 為 '*'? // 星號\n                Yes → minOpen = max(minOpen - 1, 0); maxOpen = maxOpen + 1 // 星號可視為 ')' 或 '('\n                No  → // 其它字符（理論上不會出現）\n    → Decision: 如果 maxOpen < 0? // 右括號過多\n        Yes → Return False // 直接判定無效\n        No  → // 繼續迴圈\n→ Decision: 如果 minOpen == 0? // 所有左括號已配對\n    Yes → Return True // 有效\n    No  → Return False // 仍有未配對的左括號\nEnd // 程式執行結束\n\nCheck each line has arrow etc. The \"Start\" line is separate. The \"End\" line is separate.\n\nNeed to ensure each line ends with // 解釋. In the example they had \"End // 程式執行結束\". So for End, we should include the explanation.\n\nAlso we should use \"→\" arrow for each step line, but the \"Start\" and \"End\" are separate with no arrow.\n\nAlso each \"Decision:\" line must have \"Decision:\" after arrow and indent.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 minOpen = 0, maxOpen = 0 // 初始化左括號可能數量範圍  \n→ Step 2: 對 s 的每個字元 c 進行迴圈 // 遍歷整個字串  \n  → Decision: 如果 c 為 '('? // 看到左括號  \n    Yes → minOpen = minOpen + 1; maxOpen = maxOpen + 1 // 左括號至少多一個，最大也多一個  \n    No → Decision: 如果 c 為 ')' ? // 右括號  \n      Yes → minOpen = max(minOpen - 1, 0); maxOpen = maxOpen - 1 // 右括號至少減一，最大減一  \n      No → Decision: 如果 c 為 '*'? // 星號  \n        Yes → minOpen = max(minOpen - 1, 0); maxOpen = maxOpen + 1 // 星號可視為 ')' 或 '('  \n        No → // 其它字符（理論上不會出現）  \n  → Decision: 如果 maxOpen < 0? // 右括號過多  \n    Yes → Return False // 直接判定無效  \n    No → // 繼續迴圈  \n→ Decision: 如果 minOpen == 0? // 所有左括號已配對  \n  Yes → Return True // 有效  \n  No → Return False // 仍有未配對的左括號  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def checkValidString(self, s: str) -> bool:\n        low = 0   # 最少還未匹配的 '(' 數\n        high = 0  # 最多還未匹配的 '(' 數\n\n        for c in s:\n            if c == '(':\n                low += 1\n                high += 1\n            elif c == ')':\n                if low > 0:\n                    low -= 1\n                high -= 1\n            else:  # c == '*'\n                if low > 0:\n                    low -= 1\n                high += 1\n\n            # 如果最大可能還未匹配的 '(' 少於 0，直接不可能匹配\n            if high < 0:\n                return False\n\n        # 最後需要最少還未匹配的 '(' 為 0 才有效\n        return low == 0\n\n\ndef main() -> None:\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中抽取字串，例如 \"s = \\\"()\\\"\" 或直接是 \"()\"\n    if '\"' in data:\n        first_quote = data.find('\"')\n        last_quote = data.rfind('\"')\n        s = data[first_quote + 1 : last_quote]\n    else:\n        s = data.strip()\n\n    sol = Solution()\n    result = sol.checkValidString(s)\n    print('true' if result else 'false')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"(*)\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(*))\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for climbing stairs problem. Provide line-by-line pseudocode with comments. Use Start, Decision, End. Use virtual arrow. Should not output actual code, just virtual code steps.\n\nLet's create algorithm: Use DP, loop 1 to n, base cases. Or recursion. Provide explanation. Use variable i, ways[i] = ways[i-1]+ways[i-2]. Provide steps: initialize array or variables. Let's produce.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: Input n // get number of steps\n→ Decision: 如果 n <= 0? // invalid\n    Yes → Step 2: 輸出 0 // no ways\n    No → Decision: 如果 n == 1? // single step\n        Yes → Step 3: 輸出 1 // only one way\n        No  → Decision: 如果 n == 2? // two steps\n            Yes → Step 4: 輸出 2 // two ways\n            No  → Step 5: 設定 ways[0] = 1 // base case: one way to stay at ground\n                → Step 6: 設定 ways[1] = 1 // one way to reach step1\n                → Step 7: 循環 i 從 2 到 n\n                    → Step 8: 計算 ways[i] = ways[i-1] + ways[i-2] // 1步或2步的組合\n                → Step 9: 輸出 ways[n] // 最終答案\nEnd\n\nNeed to ensure each line is virtual step. Use arrows properly. Provide in Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得需要爬升的階梯總數  \n→ Decision: 如果 n <= 0? // 檢查輸入是否有效  \n Yes → Step 2: 輸出 0 // 若步數為 0 或負數，沒有合法的爬法  \n No → Decision: 如果 n == 1? // 單步情況  \n  Yes → Step 3: 輸出 1 // 只能一次爬到頂點  \n  No → Decision: 如果 n == 2? // 兩步情況  \n   Yes → Step 4: 輸出 2 // 兩種方式：1+1 或 2  \n   No → Step 5: 設定 ways[0] = 1 // 起點：離開階梯前一個位置的方式數為 1  \n    → Step 6: 設定 ways[1] = 1 // 只需一步即可達到第一階  \n    → Step 7: 循環 i 從 2 到 n // 逐步計算更高階的方式數  \n     → Step 8: 計算 ways[i] = ways[i-1] + ways[i-2] // 1 步或 2 步的組合  \n    → Step 9: 輸出 ways[n] // 顯示總共的爬法數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef climb_stairs(n: int) -> int:\n    \"\"\"計算從 0 爬到 n 步的不同方式數量。\"\"\"\n    if n <= 2:\n        return n  # n==1 -> 1 種，n==2 -> 2 種\n    first, second = 1, 2\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n    return second\n\ndef main() -> None:\n    # 從 stdin 讀取所有資料，尋找第一個出現的整數\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n    result = climb_stairs(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for computing a^b mod 1337, where a positive integer a, b is large represented as array (like digits). This is typical problem: compute power with exponent given as array of digits (like LeetCode 355). Approach: fast exponentiation with exponent mod φ(1337)=? 1337 = 7 * 191. φ(1337) = 1337*(1-1/7)*(1-1/191) = 1337*(6/7)*(190/191)=? compute: 1337*6/7 = 1337*0.857142857=1146? Actually 1337/7=191, times 6 = 1146. Then 1146*190/191 = 1146*(0.9948)=? 1146*190=217,740; divide by191=1140? Wait let's compute: φ(1337) = 1337 * (1-1/7)*(1-1/191) = 1337 * (6/7) * (190/191). Simplify: 1337 * 6 * 190 / (7*191). 1337 = 7*191. So numerator: 7*191*6*190 = 7*6*190*191 = 7*6*190*191. Denominator: 7*191. Cancel: 6*190 = 1140. So φ(1337)=1140. Good. We can use exponent mod 1140. But also handle a multiple of 1337? Actually a may be >1337, but we compute a mod 1337 first. For exponent array, we need compute exponent modulo φ(1337) (1140). But we also need to add φ(1337) if exponent is large and a and 1337 not coprime? Since 1337's factorization has prime factors 7 and 191. For Euler theorem we need a and 1337 coprime. If not coprime, we need to handle differently. But typical solution: compute exponent modulo 1140, but if exponent is large (i.e., array length >1 or >0), we can compute exponent modulo 1140 + 1140 to handle case of exponent being 0? Usually solution uses exponent = (exponent mod 1140) + 1140 to avoid exponent 0 causing a^0=1. Because if exponent is 0, result should be 1 mod 1337. But we can treat exponent as large. Implementation: compute exponentMod = 0; for each digit d in b: exponentMod = (exponentMod *10 + d) % 1140; After loop, exponentMod += 1140; Then compute result = modPow(a%1337, exponentMod, 1337). modPow uses binary exponentiation. Also we need to compute a%1337. So produce pseudocode. Steps:\n\n1. Compute base = a % 1337.\n2. Compute exponentMod = 0.\n3. For each digit in b array:\n   exponentMod = (exponentMod * 10 + digit) % 1140.\n4. exponentMod += 1140.\n5. result = 1\n6. currentPower = base\n7. while exponentMod > 0:\n   if exponentMod % 2 == 1: result = (result * currentPower) % 1337\n   currentPower = (currentPower * currentPower) % 1337\n   exponentMod = exponentMod // 2\n8. return result.\n\nNeed to include virtual code with arrow and decisions.\n\nWe need to output line by line with // explanation. Use Start, End, Decision. Use arrow. Format example: \"Start // 程式開始執行\". Provide each step line. Use arrows \"→\" to indicate flow.\n\nLet's craft.\n\nWe'll need steps:\n\nStart\n→ Step 1: base ← a mod 1337 // 計算基底模 1337\n→ Step 2: exponentMod ← 0 // 初始化指數模\n→ Step 3: For each digit d in b array: // 逐位處理指數\n    exponentMod ← (exponentMod * 10 + d) mod 1140 // 取模 1140\n→ Step 4: exponentMod ← exponentMod + 1140 // 加上 φ(1337) 以避免 0 的情況\n→ Step 5: result ← 1 // 初始化結果\n→ Step 6: power ← base // 當前底數\n→ Decision: 指數是否大於 0? // 判斷是否還有位需要處理\n    Yes → Step 7: 如果 exponentMod mod 2 = 1? // 低位奇數\n        Yes → Step 8: result ← (result * power) mod 1337 // 乘入結果\n        No  → \n    Step 9: power ← (power * power) mod 1337 // 底數平方\n    Step 10: exponentMod ← exponentMod // 2 // 右移\n    → 回到 Decision\n→ End // 回傳結果\n\nBut we need to be more explicit: Use \"While\" maybe: Decision: exponentMod > 0? ; Yes -> process loop.\n\nAlso we need to include \"→ Step\" lines for loop. Use \"Decision:\" as arrow? In example, they used \"Decision:\" with sub-indents. We'll mimic.\n\nLet's produce.\n\nWe'll produce each line with \"→\" arrow before each step except Start and End. Use indentation to indicate nested Decision branches.\n\nMake sure each line has \" // explanation\".\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: base ← a mod 1337 // 計算 a 的餘數，作為模 1337 的基底\n→ Step 2: exponentMod ← 0 // 初始化指數模值\n→ Step 3: For each digit d in array b: // 逐位遍歷大數指數\n    → SubStep: exponentMod ← (exponentMod * 10 + d) mod 1140 // 更新指數模 1140\n→ Step 4: exponentMod ← exponentMod + 1140 // 加上 φ(1337) 以避免指數為 0 的特例\n→ Step 5: result ← 1 // 結果初始化為 1\n→ Step 6: power ← base // current power 初始化為基底\n→ Decision: exponentMod > 0? // 是否還有位需要處理\n    Yes → Step 7: If exponentMod mod 2 = 1? // 判斷最低位是否為 1\n        Yes → Step 8: result ← (result * power) mod 1337 // 將當前底數乘入結果\n        No  → \n    Step 9: power ← (power * power) mod 1337 // 底數平方\n    Step 10: exponentMod ← exponentMod // 2 // 右移指數\n    → 回到 Decision\n→ End // 回傳結果\n\nBut we need each line as separate line. For nested steps, each line is separate, but we may indent lines with spaces. For example:\n\n→ Decision: exponentMod > 0? \n    Yes → ... \n\nWe must use proper format: \"→ Decision: ...\", then \"    Yes → ...\", \"    No → ...\" but not needed \"No\" branch for loop? In loop we only need Yes to iterate. So No branch leads to End? We can skip No. But to be consistent, we might include \"No → End\" but End is outside loop. It's okay to just not include.\n\nBetter produce:\n\n→ Decision: exponentMod > 0? // 判斷指數是否已歸零\n    Yes → Step 7: If exponentMod mod 2 = 1? // 檢查最低位\n        Yes → Step 8: result ← (result * power) mod 1337 // 乘入結果\n        No  → \n    Step 9: power ← (power * power) mod 1337 // 底數平方\n    Step 10: exponentMod ← exponentMod // 2 // 指數右移\n    → 回到 Decision\n\n→ End // 回傳結果\n\nAlso need to mention returning result? We can add Step 11: return result // 回傳最終值\n\nBut End can include return. It's fine.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: base ← a mod 1337 // 先把 a 取模 1337，作為後續計算的基底  \n→ Step 2: exponentMod ← 0 // 初始化指數的模值  \n→ Step 3: For each digit d in array b: // 逐位遍歷長整數指數  \n  → SubStep: exponentMod ← (exponentMod * 10 + d) mod 1140 // 將指數更新為模 1140 的值  \n→ Step 4: exponentMod ← exponentMod + 1140 // 加上 φ(1337)=1140，避免指數為 0 時的特例  \n→ Step 5: result ← 1 // 結果初始為 1（任何數的 0 次方）  \n→ Step 6: power ← base // 當前底數初始化為基底  \n→ Decision: exponentMod > 0? // 是否還有位需要處理  \n  Yes → Step 7: If exponentMod mod 2 = 1? // 檢查最低位是否為 1  \n   Yes → Step 8: result ← (result * power) mod 1337 // 乘入結果  \n   No  →  \n  Step 9: power ← (power * power) mod 1337 // 底數平方  \n  Step 10: exponentMod ← exponentMod // 2 // 將指數右移一位  \n  → 回到 Decision  \n→ Step 11: return result // 回傳最終模 1337 的結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 1337\n\ndef super_pow(a, b):\n    \"\"\"計算 a^b mod 1337，其中 b 為由各位數字組成的陣列。\"\"\"\n    result = 1\n    for digit in b:\n        # (result^10 mod MOD) * (a^digit mod MOD) mod MOD\n        result = (pow(result, 10, MOD) * pow(a, digit, MOD)) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並抽取所有整數\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n\n    if not numbers:\n        sys.exit(0)\n\n    a = int(numbers[0])\n    b = [int(x) for x in numbers[1:]]\n\n    answer = super_pow(a, b)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps. Problem: Given s1, n1, s2, n2. str1 is s1 repeated n1 times. str2 is s2 repeated n2 times. Need maximum m such that str2 repeated m times can be obtained from str1 (i.e., as subsequence). This is known Leetcode 466. Approach: simulate matching s2 within repetitions of s1, keep track of how many s2 are matched per s1 repetition. Use cycle detection.\n\nPseudo-code:\n\nStart\n→ Input s1, n1, s2, n2\n→ Initialize variables: indexInS1=0, indexInS2=0, countS2=0, dict = {} // map indexInS1 to (countS2, indexInS2)\n→ For i in 1 to n1:\n    → While indexInS1 < len(s1):\n        → if s1[indexInS1] == s2[indexInS2]: \n            → indexInS2 += 1\n            → if indexInS2 == len(s2):\n                → countS2 += 1\n                → indexInS2 = 0\n        → indexInS1 += 1\n    // after processing one s1 repetition\n    → If indexInS1 in dict:\n        → Retrieve prevCountS2, prevIndexInS2\n        → cycleCount = countS2 - prevCountS2\n        → cycleLength = i - prevIndexInS2? Actually we track repetition count? We need mapping from repetition index to state. So key is indexInS2? Use repetition index? Let's define key = indexInS2; but that may not be unique. Actually typical solution: key = indexInS2. But need also repetition index? Use mapping from indexInS2 to (i, countS2). Yes.\n\n    → If key exists:\n        → prevI, prevCountS2 = dict[key]\n        → preCycleCount = prevCountS2\n        → postCycleCount = countS2 - prevCountS2\n        → preCycleLength = prevI\n        → postCycleLength = i - prevI\n        → remainingReps = n1 - i\n        → times = remainingReps // postCycleLength\n        → countS2 += times * postCycleCount\n        → i += times * postCycleLength\n    → dict[indexInS2] = (i, countS2)\n→ result = countS2 // n2\n\nBut we need simpler pseudo-code. Provide steps with decisions.\n\nWe'll produce step-by-step pseudo-code lines.\n\nNeed to output each line as: \"虛擬碼步驟 // 解釋\"\n\nOk.\n\nLet's craft.\n\nWe'll produce Start, read input, initialize variables, loop through n1, inside loop match s2 char by char, increment counters, check cycle, etc. Use decision branches.\n\nRemember to use arrow → etc.\n\nLet's craft lines.\n\nMake sure to include End.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Read s1, n1, s2, n2 // 取得輸入資料  \n→ Initialize lenS1 = length of s1, lenS2 = length of s2 // 計算字串長度  \n→ Set indexS1 = 0, indexS2 = 0 // s1 與 s2 的索引  \n→ Set countS2 = 0 // 已完整匹配到的 s2 次數  \n→ Create empty map Record // 用來偵測重複週期  \n→ For repeat from 1 to n1: // 逐一處理每一個 s1 重複  \n  → While indexS1 < lenS1: // 逐字符遍歷一個 s1  \n    → Decision: s1[indexS1] == s2[indexS2]? // 判斷是否匹配  \n      Yes → indexS2 += 1 // 匹配到，移動到 s2 下一個字符  \n       Decision: indexS2 == lenS2? // 判斷是否完成一個 s2  \n        Yes → countS2 += 1 // 完成一次 s2，計數加一  \n         indexS2 = 0 // 重置到 s2 開頭  \n        No → // 尚未完成，繼續  \n      No → // 不匹配，什麼都不做  \n      → indexS1 += 1 // 移動到 s1 下一個字符  \n  → // 一個完整的 s1 已經遍歷完，回到索引起點  \n  → indexS1 = 0 // 重新開始 s1  \n  → // 檢查是否出現相同的 s2 索引，以偵測週期  \n  → If Record contains key indexS2: // 已經遇到過相同的 s2 索引  \n    → Retrieve (prevRepeat, prevCount) from Record[indexS2]  \n    → Set cycleLen = repeat - prevRepeat // 週期長度（s1 重複次數）  \n    → Set cycleCount = countS2 - prevCount // 週期內完成的 s2 數量  \n    → Set remaining = n1 - repeat // 還剩下多少個 s1 循環可處理  \n    → Set times = remaining // cycleLen // 能夠完整覆蓋的週期數  \n    → countS2 += times * cycleCount // 加上多個週期得到的 s2 數量  \n    → repeat += times * cycleLen // 把重複次數往前跳過已經處理的週期  \n  → Record[indexS2] = (repeat, countS2) // 記錄目前的重複次數和 s2 計數  \n→ // 所有 s1 重複都已處理完畢  \n→ Set result = countS2 // n2 // 將完成的 s2 數量除以每個 str2 需要的 s2 數量  \n→ Output result // 回傳最大可取得的 m  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0 or n2 == 0:\n            return 0\n\n        s1_len, s2_len = len(s1), len(s2)\n        s1_count = 0          # 已處理的 s1 次數\n        s2_count = 0          # 已完整匹配到的 s2 次數\n        idx_s2 = 0            # s2 當前指標\n        recall = dict()       # 以 s2 指標作為鍵，記錄 (s1_count, s2_count)\n\n        while s1_count < n1:\n            # 遍歷一整個 s1\n            for ch in s1:\n                if ch == s2[idx_s2]:\n                    idx_s2 += 1\n                    if idx_s2 == s2_len:\n                        idx_s2 = 0\n                        s2_count += 1\n            s1_count += 1\n\n            # 如果相同的 s2 指標再次出現，說明出現週期\n            if idx_s2 in recall:\n                prev_s1, prev_s2 = recall[idx_s2]\n                # 前段\n                pre_loop_s1 = prev_s1\n                pre_loop_s2 = prev_s2\n                # 循環段\n                loop_s1 = s1_count - prev_s1\n                loop_s2 = s2_count - prev_s2\n\n                # 先計算前段能得到多少 s2\n                total_s2 = pre_loop_s2\n\n                # 接著計算能完整覆蓋的循環數\n                remaining_s1 = n1 - s1_count\n                times = remaining_s1 // loop_s1\n                total_s2 += times * loop_s2\n\n                # 處理剩下的 s1\n                rest_s1 = remaining_s1 % loop_s1\n                for _ in range(rest_s1):\n                    for ch in s1:\n                        if ch == s2[idx_s2]:\n                            idx_s2 += 1\n                            if idx_s2 == s2_len:\n                                idx_s2 = 0\n                                total_s2 += 1\n                return total_s2 // n2\n            else:\n                recall[idx_s2] = (s1_count, s2_count)\n\n        # 如果整個過程沒有發現週期，直接計算\n        return s2_count // n2\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入字串中抽取 s1, n1, s2, n2。\n    支援類似 's1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2' 的格式。\n    \"\"\"\n    # 匹配字串\n    s1_match = re.search(r's1\\s*=\\s*\"([^\"]*)\"', text)\n    s2_match = re.search(r's2\\s*=\\s*\"([^\"]*)\"', text)\n    # 匹配整數\n    n1_match = re.search(r'n1\\s*=\\s*(-?\\d+)', text)\n    n2_match = re.search(r'n2\\s*=\\s*(-?\\d+)', text)\n\n    if not (s1_match and s2_match and n1_match and n2_match):\n        raise ValueError(\"Input format error\")\n\n    s1 = s1_match.group(1)\n    s2 = s2_match.group(1)\n    n1 = int(n1_match.group(1))\n    n2 = int(n2_match.group(1))\n    return s1, n1, s2, n2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, n1, s2, n2 = parse_input(data)\n    sol = Solution()\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve problem: count beautiful arrangements. Classic Leetcode 1353: Beautiful Arrangement. Approach: backtracking with bitmask or recursion, using DFS to assign numbers to positions. Use visited set or bitmask. Complexity O(n!). We need to produce steps line by line, each line \"虛擬碼步驟 // 解釋\".\n\nWe must output the virtual code, not actual code. Format with Start, End, Decision, arrow lines.\n\nWe need to explain each step. We'll produce a generic algorithm.\n\nWe can structure:\n\nStart\n→ Initialize count to 0\n→ Define DFS function with position i and visited mask\n→ Decision: if i > n? -> End recursion, increment count\n→ Else iterate number from 1 to n\n→ Decision: if number not visited and (number % i == 0 or i % number == 0)\n    → Mark visited\n    → Recursively call DFS(i+1)\n    → Unmark visited\nEnd\n\nWe can also optimize using list of candidate numbers per position or bitmask.\n\nAlso we should maybe include main entry call.\n\nLet's produce virtual code lines.\n\nRemember to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows '→', 'Yes →', 'No →', 'Decision:'.\n\nWe can indent with spaces? In sample they indent 4 spaces before nested lines. We'll replicate similar.\n\nLet's craft steps:\n\nStart // 程式開始執行\n→ Initialize n, count = 0 // 設定 n 與美麗排列計數\n→ 定義 DFS(位置 i, 已使用數字集合 visited) // 從位置 1 開始遞迴\n    → Decision: 如果 i > n? // 檢查是否已安排完所有位置\n        Yes → count++ // 完成一個美麗排列，計數加一\n        No  → Decision: 遍歷所有數字 1~n // 為當前位置尋找符合條件的數字\n            → For number in 1~n\n                → Decision: 如果 number 未使用 且 (number % i == 0 或 i % number == 0)?\n                    Yes → Mark number 為已使用\n                    → DFS(i+1, visited) // 進入下一個位置\n                    → Unmark number // 回溯\nEnd // 程式結束，返回 count\n\nBut we must include the initial call.\n\nAdd line after defining DFS: → 呼叫 DFS(1, 空集合) // 開始遞迴\n\nThen after that: → 返回 count // 結果輸出\n\nAlso we may include optimization: precompute valid numbers per position. But not necessary.\n\nLet's produce final virtual code accordingly.\n\nAlso note to use '→' arrow after each line.\n\nMake sure each line has one space after step before comment. Use the arrow.\n\nAlso maybe indent nested lines with 4 spaces. Use '→' preceding each line. For Decision lines, use \"Decision:\" and indent Yes/No.\n\nWe must produce step-by-step code.\n\nLet's produce.\n\nAlso need to include 'End' line at end.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化變數 n、count ← 0 // 設定輸入 n 與美麗排列計數器  \n→ 定義函式 DFS(位置 i, 已使用集合 visited) // 從位置 1 開始遞迴搜尋  \n  Decision: i > n? // 是否已安排完所有位置  \n   Yes → count ← count + 1 // 成功找到一個美麗排列，計數加一  \n   No  → Decision: 為 i 位置找符合條件的數字 // 檢查 1~n 的數字  \n     For num 在 1 到 n  \n      Decision: num 未被使用 且 (num % i == 0 或 i % num == 0)?  \n        Yes → visited ← visited ∪ {num} // 標記為已使用  \n         DFS(i + 1, visited) // 進入下一個位置  \n         visited ← visited \\ {num} // 回溯，取消標記  \n→ 呼叫 DFS(1, 空集合) // 開始遞迴搜尋  \n→ 返回 count // 輸出美麗排列總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom functools import lru_cache\n\ndef countArrangement(n: int) -> int:\n    # 為每個位置預先找出能夠配對的數字\n    valid = [[] for _ in range(n + 1)]\n    for pos in range(1, n + 1):\n        for num in range(1, n + 1):\n            if num % pos == 0 or pos % num == 0:\n                valid[pos].append(num)\n\n    @lru_cache(None)\n    def dfs(pos: int, mask: int) -> int:\n        # 所有位置都已安排完畢，找到一種美麗排列\n        if pos > n:\n            return 1\n        total = 0\n        for num in valid[pos]:\n            bit = 1 << (num - 1)\n            if not mask & bit:          # num 還未被使用\n                total += dfs(pos + 1, mask | bit)\n        return total\n\n    return dfs(1, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data:\n        n = int(data)\n        result = countArrangement(n)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, no actual code. The requirement: reorder array into wiggle pattern. Need algorithm: sort array, then swap adjacent elements from end? Common solution: sort, then for i=1 to n-1 step 2, swap nums[i] and nums[i+1] if i+1<n. Or use median method. Simplest: sort, then for i=1 to n-2 step 2, swap nums[i] and nums[i+1]. Let's produce virtual code lines accordingly.\n\nStructure: Start, Step 1: Sort nums ascending. Step 2: for i from 1 to length-2 step 2: swap nums[i] with nums[i+1]. End.\n\nNeed each line with explanation. Use arrows. Include Decision? not necessary.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort array nums in non‑decreasing order // 先把陣列排好序\n→ Step 2: For index i from 1 to length(nums)-2 with step 2: // 只處理奇數索引位置\n    → Decision: If i+1 < length(nums)? // 確保有下一個元素可交換\n        Yes → Step 3: Swap nums[i] and nums[i+1] // 交換奇偶位置以滿足 < > < > 模式\n        No  → Step 4: Continue // 不需要交換，跳過\nEnd // 程式執行結束\n\nBut we need virtual code line by line, not nested? We can indent. Provide each line as separate line with arrow and explanation. Use Yes → and No → lines.\n\nBetter: Use loop structure: For i from 1 to length-2 step 2: swap nums[i] and nums[i+1]. We can represent as:\n\n→ Step 2: For i = 1 to length(nums)-2 step 2: // 迴圈遍歷奇數索引\n    → Step 3: Swap nums[i] and nums[i+1] // 交換相鄰元素\n\nSimpler. Let's produce.\n\nAlso we might want to mention that final array satisfies wiggle property.\n\nLet's craft output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort array nums in non‑decreasing order // 先把陣列排好序，方便後續交換  \n→ Step 2: For index i = 1 to length(nums) - 2 with step 2: // 只遍歷奇數索引（1、3、5…）  \n    → Step 3: Swap nums[i] and nums[i+1] // 交換相鄰元素，使 nums[i-1] < nums[i] > nums[i+1]  \nEnd // 程式執行結束，得到 nums[0] < nums[1] > nums[2] < nums[3] … 的波浪排列",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        # Step 1: Sort the array in non‑decreasing order\n        nums.sort()\n        # Step 2: Swap every pair of adjacent elements starting from index 1\n        for i in range(1, len(nums) - 1, 2):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\ndef main():\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Extract the list part, e.g. from 'nums = [1,5,1,1,6,4]' get '[1,5,1,1,6,4]'\n    if '=' in raw_input:\n        raw_input = raw_input.split('=', 1)[1].strip()\n    # Safely parse the list using ast.literal_eval\n    nums = ast.literal_eval(raw_input)\n    # Apply the wiggle sort algorithm\n    Solution().wiggleSort(nums)\n    # Output the resulting list\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,1,1,5,4,6]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 1, 1, 5, 4, 6]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,2,1,3,2,3]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 2, 1, 3, 2, 3]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm that finds longest valid parentheses substring. Standard approach: stack or DP. We'll produce steps. Provide line by line with explanation. We'll need Start, Decision, etc.\n\nWe'll produce algorithm using stack approach: push -1 as base. Iterate over characters, if '(' push index, else pop. If stack empty push current index. Else compute length: current index - top of stack. Keep max.\n\nWe'll produce virtual code step by step. Use arrow, decisions. Provide explanation per line.\n\nLet's produce.\n\nAlso maybe include initialization. Use variables: maxLen, stack.\n\nWe need to ensure each line includes \"虛擬碼步驟 [space] // 解釋\".\n\nWe'll output in Traditional Chinese.\n\nLet's craft lines:\n\nStart\n→ Initialize maxLen = 0 // 最大長度\n→ Initialize stack with -1 // 基準索引\n→ For i from 0 to len(s)-1 // 遍歷每個字符\n    → If s[i] == '(' // 遇到左括號\n        Yes → Push i onto stack // 存儲索引\n    → Else // 遇到右括號\n        Yes → Pop from stack // 試圖配對\n        Yes → If stack is empty // 無匹配\n            Yes → Push i onto stack // 設置新的基準\n        No  → Compute currentLen = i - top_of_stack // 計算有效長度\n        No  → Update maxLen = max(maxLen, currentLen) // 更新最大值\nEnd\n\nNeed proper formatting for Decision lines.\n\nUse \"Decision:\" lines with Yes→ and No→.\n\nWe'll need indent for nested decisions. Use arrow accordingly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize maxLen = 0 // 設定最大長度為 0  \n→ Initialize stack with -1 // 把 -1 作為基準索引推入堆疊  \n→ For i from 0 to len(s)-1 // 逐一檢查每個字符  \n  Decision: s[i] == '('? // 判斷是否為左括號  \n   Yes → Push i onto stack // 左括號時把索引推進堆疊  \n   No → Decision: 右括號? // 不是左括號則為右括號  \n    Yes → Pop from stack // 先嘗試配對，移除上一個索引  \n     Decision: 堆疊為空? // 判斷配對是否成功  \n      Yes → Push i onto stack // 沒有匹配，將此索引作為新的基準  \n      No  → Compute currentLen = i - top_of_stack // 取得有效子串長度  \n      No  → Update maxLen = max(maxLen, currentLen) // 更新最大長度  \nEnd // 程式執行結束，maxLen 即為答案\n\n---  \n\n說明：  \n- 以 -1 作為基準能處理從開頭開始的合法子串。  \n- 每遇到右括號，若堆疊非空則代表成功配對，利用目前索引與堆疊頂部索引之差得到長度。  \n- 若堆疊空，說明前面沒有可配對的左括號，這時將目前右括號索引作為新的基準。  \n- 最後回傳 `maxLen` 即為最長有效括號子串長度。",
      "generated_code": "import sys\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"Return the length of the longest valid parentheses substring.\"\"\"\n        stack = [-1]          # 堆疊存放索引，-1 作為基準\n        max_len = 0           # 目前已知的最大長度\n\n        for i, char in enumerate(s):\n            if char == '(':\n                stack.append(i)  # 左括號時把索引推進堆疊\n            else:\n                stack.pop()      # 右括號先嘗試配對\n                if not stack:    # 沒有可配對的左括號\n                    stack.append(i)  # 這個右括號成為新的基準\n                else:\n                    # 右括號與最近未匹配的左括號配對，計算長度\n                    max_len = max(max_len, i - stack[-1])\n\n        return max_len\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：若格式為 s = \"…\", 取中間的字串；否則直接使用整個輸入\n    start_quote = data.find('\"')\n    end_quote = data.rfind('\"')\n    if start_quote != -1 and end_quote != -1 and start_quote < end_quote:\n        s = data[start_quote + 1:end_quote]\n    else:\n        s = data\n\n    solution = Solution()\n    result = solution.longestValidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode565.json",
    "problem_index_in_file": 0,
    "title": "Array Nesting",
    "description_snippet": "You are given an integer array nums of length n where nums is a permutation of the numbers in the ra...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code to solve problem: Given array nums permutation of 0..n-1, for each k compute set following sequence until duplicate. Need longest length. That's cycle detection problem: length of longest cycle. Because permutation forms disjoint cycles. So algorithm: visited array bool; for each i if not visited: traverse cycle count len; mark visited; update max. Complexity O(n). Virtual code lines with explanation. Use Start, Decision, End, etc. Provide step-by-step.\n\nLet's craft lines:\n\nStart // 程式開始\n\n→ Step 1: Initialize maxLen ← 0 // 儲存目前最大的集合長度\n\n→ Step 2: Initialize visited array of size n with False // 標記每個索引是否已經被處理\n\n→ Decision: 是否存在未被訪問的索引 i? // 檢查是否還有節點未處理\n\nYes → Step 3: 設定 currentLen ← 0 // 新循環的長度計數器\n\n→ Step 4: 設定 currentIndex ← i // 從未訪問的索引開始\n\n→ Decision: currentIndex 是否已被訪問? // 檢查當前節點是否已經處理\n\nYes → Step 5:  // 這個節點已在上一個循環中被處理，跳過\n\nNo → Step 6: 設定 visited[currentIndex] ← True // 標記為已訪問\n\n→ Step 7: 增加 currentLen ← currentLen + 1 // 統計本循環長度\n\n→ Step 8: 設定 currentIndex ← nums[currentIndex] // 移動到下一個索引\n\n→ Decision: currentIndex 是否已被訪問? // 判斷是否已進入重複元素\n\nYes → Step 9: 設定 maxLen ← max(maxLen, currentLen) // 更新最大長度\n\n→ Step 10:  // 退出循環並返回上一層 Decision\n\n→ Decision: 是否存在未被訪問的索引 i? // 迴圈繼續\n\n... continue until all visited\n\nEnd // 程式結束\n\nNeed to include proper arrows and indentation. Use \"→\" lines. For decisions, include \"Decision:\" then Yes→ ... No→ . In this case we have two decisions nested: outer loop over unvisited i, inner loop over currentIndex until visited.\n\nSimplify: Outer Decision: 是否存在未訪問的索引 i? (Yes → start new cycle; No → End). Inside cycle: Decision: currentIndex 已被訪問? (Yes → end cycle; No → process). Provide explanation lines.\n\nAlso include Step for finding next i: maybe iterate i from 0 to n-1: for i in range(n): if not visited[i]: ... But using decision we can emulate.\n\nLet's craft.\n\nWill produce lines:\n\nStart // 程式開始執行\n→ Step 1: maxLen ← 0 // 初始化最大集合長度\n→ Step 2: visited ← array of n False // 標記是否已被訪問\n→ Step 3: i ← 0 // 索引起始位置\n→ Decision: i < n? // 檢查是否還有索引未處理\n    Yes → Decision: visited[i]? // 該索引是否已被訪問\n        Yes → Step 4: i ← i + 1 // 已訪問，移動到下一個索引\n        No → Step 5: currentLen ← 0 // 新循環長度初始化\n            → Step 6: currentIndex ← i // 從 i 開始\n            → Decision: visited[currentIndex]? // 目前節點是否已訪問\n                Yes → Step 7: maxLen ← max(maxLen, currentLen) // 更新最大長度\n                    → Step 8: i ← i + 1 // 完成本循環，回到外層決策\n                No → Step 9: visited[currentIndex] ← True // 標記為已訪問\n                    → Step 10: currentLen ← currentLen + 1 // 長度累加\n                    → Step 11: currentIndex ← nums[currentIndex] // 移動到下一個\n                    → Decision: visited[currentIndex]? // 再次判斷是否重複\n                        Yes → Step 12: maxLen ← max(maxLen, currentLen)\n                            → Step 13: i ← i + 1\n                        No → 回到 Decision 內部 (continue cycle)\n    No → End // 所有索引已處理，結束程式\n\nBut maybe need to be clearer. Use recursion style: In outer loop, for each i if not visited, traverse cycle; after cycle, go back to outer loop. We can represent using Decision and Yes/No.\n\nLet's craft final output with each line properly formatted. Use consistent indent and arrow.\n\nWill produce around 30 lines. Ensure each line ends with // explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: maxLen ← 0 // 儲存目前最大的集合長度  \n→ Step 2: visited ← array of n False // 標記每個索引是否已被處理  \n→ Step 3: i ← 0 // 從索引 0 開始遍歷  \n→ Decision: i < n? // 是否還有索引未處理  \n  Yes → Decision: visited[i]? // 該索引是否已被訪問  \n    Yes → Step 4: i ← i + 1 // 已處理，移至下一個索引  \n    No → Step 5: currentLen ← 0 // 新循環長度初始化  \n     → Step 6: currentIndex ← i // 從此索引開始循環  \n     → Decision: visited[currentIndex]? // 目前節點是否已被訪問  \n       Yes → Step 7: maxLen ← max(maxLen, currentLen) // 更新最大長度  \n        → Step 8: i ← i + 1 // 完成此循環，回到外層決策  \n       No → Step 9: visited[currentIndex] ← True // 標記為已訪問  \n        → Step 10: currentLen ← currentLen + 1 // 長度累加  \n        → Step 11: currentIndex ← nums[currentIndex] // 移動到下一個索引  \n        → Decision: visited[currentIndex]? // 再次判斷是否重複  \n          Yes → Step 12: maxLen ← max(maxLen, currentLen) // 更新最大長度  \n           → Step 13: i ← i + 1 // 結束本循環，回到外層決策  \n          No → 回到 Decision: visited[currentIndex]? (繼續循環)  \n  No → End // 所有索引已處理，程式結束。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def arrayNesting(self, nums):\n        \"\"\"\n        依照題目描述，對每個未被處理的索引 i，\n        追蹤 nums 的循環，計算循環長度，並找出最大長度。\n        \"\"\"\n        n = len(nums)\n        visited = [False] * n\n        max_len = 0\n\n        for i in range(n):\n            if not visited[i]:\n                current_len = 0\n                j = i\n                # 追蹤此循環直到遇到已訪問的索引\n                while not visited[j]:\n                    visited[j] = True\n                    current_len += 1\n                    j = nums[j]\n                max_len = max(max_len, current_len)\n\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行文字\n    raw_input = sys.stdin.read().strip()\n\n    # 若輸入包含 \"nums =\"，將其移除\n    if raw_input.startswith(\"nums\"):\n        # 只保留中括號內的內容\n        start = raw_input.find('[')\n        end = raw_input.rfind(']')\n        if start != -1 and end != -1:\n            raw_input = raw_input[start:end+1]\n\n    # 轉成列表；若輸入不合法則直接終止\n    try:\n        nums = ast.literal_eval(raw_input)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        sys.exit(\"輸入格式不正確，請提供合法的數字列表\")\n\n    solution = Solution()\n    result = solution.arrayNesting(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,4,0,3,1,6,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode706.json",
    "problem_index_in_file": 0,
    "title": "Design HashMap",
    "description_snippet": "Design a HashMap without using any built-in hash table libraries.\n\nImplement the MyHashMap class:\n\nM...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with comments, no actual code. Use Start, End, Decision etc. Should design a hash map without built-in libraries. We'll describe initialization, bucket array, linked list for separate chaining, hash function. Implement put, get, remove. Need to use virtual code. Let's create steps.\n\nWe must produce in Traditional Chinese. Provide steps as per format. Let's craft.\n\nStructure:\n\nStart\n→ Step: 初始化 bucket 數組大小為 1000 // 初始化固定大小的 bucket\n→ Step: 取出 key 的 hash 值 -> bucket index // 計算 key 的索引\n→ Decision: 檢查 bucket 是否為空? // 查看 bucket\n   Yes → Step: 如果空則建立新節點 // 建立鏈表節點\n   No  → Step: 在鏈表中搜尋 key\n       → Decision: 找到 key? // 是否已存在\n           Yes → Step: 更新 value // 更新\n           No  → Step: 將新節點插入鏈表頭 // 插入\n\nSimilarly for get and remove.\n\nLet's produce final output with each line. Use 虛擬碼步驟 + comment. We'll use arrow '→', 'Yes →', 'No →'. Ensure each line ends with comment. No code actual. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化 bucket 數組大小為 1000 // 建立固定大小的桶陣列作為底層儲存\n→ Step: 設定 hashFunction(key) = key % 1000 // 簡易 hash 函式將 key 映射到 0-999\n→ Step: 定義 Node { key, value, next } // 每個桶使用鏈表節點處理碰撞\n\n// ---------- MyHashMap() ----------\n→ Step: MyHashMap() // 建構子\n    → Step: 產生空桶陣列 buckets[1000] // 初始時所有桶皆為空\n\n// ---------- put(key, value) ----------\n→ Step: put(key, value) // 插入或更新鍵值對\n    → Step: index = hashFunction(key) // 取得鍵的桶索引\n    → Step: current = buckets[index] // 取得該桶頭節點\n    → Decision: current 為空? // 檢查桶是否已有節點\n        Yes → Step: buckets[index] = Node(key, value, null) // 直接放入新節點\n        No  → Step: prev = null\n              → While current ≠ null // 遍歷鏈表尋找相同鍵\n                  → Decision: current.key == key? // 找到相同鍵\n                      Yes → Step: current.value = value // 更新已有值\n                          → Step: 返回 // 退出\n                      No  → Step: prev = current; current = current.next // 進一步搜尋\n              → Step: prev.next = Node(key, value, null) // 未找到，將新節點插入尾端\n\n// ---------- get(key) ----------\n→ Step: get(key) // 取得鍵對應值\n    → Step: index = hashFunction(key) // 取得鍵的桶索引\n    → Step: current = buckets[index] // 取得該桶頭節點\n    → While current ≠ null // 遍歷鏈表尋找鍵\n        → Decision: current.key == key? // 找到鍵\n            Yes → Step: 返回 current.value // 返回對應值\n            No  → Step: current = current.next // 繼續搜尋\n    → Step: 返回 -1 // 未找到鍵時返回 -1\n\n// ---------- remove(key) ----------\n→ Step: remove(key) // 刪除鍵對應的節點\n    → Step: index = hashFunction(key) // 取得鍵的桶索引\n    → Step: current = buckets[index] // 取得該桶頭節點\n    → Step: prev = null\n    → While current ≠ null // 遍歷鏈表尋找鍵\n        → Decision: current.key == key? // 找到鍵\n            Yes → Decision: prev 為空? // 是否是頭節點\n                Yes → Step: buckets[index] = current.next // 刪除頭節點\n                No  → Step: prev.next = current.next // 刪除中間或尾端節點\n                → Step: 返回 // 完成刪除\n            No  → Step: prev = current; current = current.next // 繼續搜尋\n    → Step: // 未找到鍵，無操作\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyHashMap:\n    def __init__(self):\n        # 初始化桶數，使用 10000 個桶\n        self.size = 10000\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key: int) -> int:\n        # 簡單哈希函式：取餘數\n        return key % self.size\n\n    def put(self, key: int, value: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        # 檢查是否已有相同 key，若有則更新\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                return\n        # 若沒有，加入新的 key-value 對\n        bucket.append((key, value))\n\n    def get(self, key: int):\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return -1\n\n    def remove(self, key: int) -> None:\n        h = self._hash(key)\n        bucket = self.buckets[h]\n        for i, (k, _) in enumerate(bucket):\n            if k == key:\n                bucket.pop(i)\n                return\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    hashmap = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyHashMap\":\n            hashmap = MyHashMap()\n            results.append(None)\n        elif op == \"put\":\n            hashmap.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            res = hashmap.get(arg[0])\n            results.append(res)\n        elif op == \"remove\":\n            hashmap.remove(arg[0])\n            results.append(None)\n\n    # 將 None 轉換為 null，其他保持原樣\n    out = \"[\" + \",\".join(\"null\" if r is None else str(r) for r in results) + \"]\"\n    print(out)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]",
          "expected_output": "[null, null, null, 1, -1, null, 1, null, -1]",
          "success": true,
          "output": "[null,null,null,1,-1,null,1,null,-1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for solving the problem of evaluating division queries. This is the standard LeetCode problem: evaluate division. Approach: build graph of variables, weighted edges with ratios. Then for each query, run DFS/BFS to find ratio, return -1 if not connected or variable missing. So pseudocode lines: Start, Step1: build adjacency map, Step2: iterate queries, call DFS, etc. Use decisions for variable existence. Provide explanation.\n\nWe should not output actual code, just virtual steps. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrows and Decision.\n\nLet's produce. Use Chinese explanation. Let's start.\n\nWe must use the required format: Start, → Step..., Decision..., End.\n\nWe need to cover building graph, handling queries, DFS with memo, etc.\n\nLet's craft.\n\nAlso note: each step line may refer to nested decisions. We can use indentation.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化鄰接表 graph ← 空字典 // 建立一個字典，鍵為變數，值為鄰接變數與比值的列表\n→ Decision: 是否有任何方程式? // 檢查 equations 陣列是否為空\n    Yes → Step 2: 對每一個方程式 (Ai, Bi, values[i]) 進行以下操作\n        → Step 2a: 若 Ai 不在 graph 中，新增 Ai → 空列表 // 確保 Ai 有對應的列表\n        → Step 2b: 若 Bi 不在 graph 中，新增 Bi → 空列表 // 確保 Bi 有對應的列表\n        → Step 2c: 在 graph[Ai] 加入 (Bi, values[i]) // Ai → Bi 的比值\n        → Step 2d: 在 graph[Bi] 加入 (Ai, 1 / values[i]) // Bi → Ai 的逆比值\n    No → Step 3: graph 保持空，因為沒有給定任何關係\n→ Step 4: 定義函式 DFS(current, target, visited, acc) → 返回比值或 -1.0 // 透過深度優先搜尋計算比值\n    → Decision: 是否 current 等於 target? // 如果已到目標變數\n        Yes → Return acc // 返回累積比值\n        No → Decision: 是否 current 已訪問? // 避免循環\n            Yes → Return -1.0\n            No → 設置 visited ← visited ∪ {current}\n                → Step 4a: 對每一個 (neighbor, ratio) 在 graph[current] 中進行以下操作\n                    → Step 4a1: Result ← DFS(neighbor, target, visited, acc * ratio) // 更新累積比值\n                    → Decision: 是否 Result ≠ -1.0? // 找到合法路徑\n                        Yes → Return Result\n                        No → 繼續尋找下一個 neighbor\n                → Return -1.0 // 所有路徑嘗試後仍未找到\n→ Step 5: 初始化答案列表 answers ← 空列表\n→ Decision: 是否有任何查詢? // 檢查 queries 陣列是否為空\n    Yes → Step 6: 對每一個查詢 (Cj, Dj) 進行以下操作\n        → Decision: 是否 Cj 與 Dj 都存在於 graph? // 若有任一不存在，無法計算\n            Yes → Step 6a: Result ← DFS(Cj, Dj, 空集合, 1.0) // 從 Cj 開始搜尋\n            No → Step 6b: Result ← -1.0 // 未定義的變數\n        → Step 6c: 將 Result 加入 answers // 存入此查詢的答案\n    No → Step 7: answers 保持空，因為沒有查詢\n→ Step 8: 返回 answers // 給出所有查詢的計算結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef extract_list(s, start_keyword):\n    \"\"\"Return the substring of the first outermost list after start_keyword.\"\"\"\n    start = s.find(start_keyword)\n    if start == -1:\n        return None\n    # Find the first '[' after the keyword\n    idx = s.find('[', start)\n    if idx == -1:\n        return None\n    count = 0\n    for i in range(idx, len(s)):\n        if s[i] == '[':\n            count += 1\n        elif s[i] == ']':\n            count -= 1\n            if count == 0:\n                return s[idx:i+1]\n    return None\n\ndef parse_input(data):\n    \"\"\"Parse the input string and return equations, values, queries.\"\"\"\n    eq_str = extract_list(data, 'equations')\n    val_str = extract_list(data, 'values')\n    qu_str = extract_list(data, 'queries')\n    if eq_str is None or val_str is None or qu_str is None:\n        raise ValueError(\"Input format not recognized\")\n    equations = ast.literal_eval(eq_str)\n    values = ast.literal_eval(val_str)\n    queries = ast.literal_eval(qu_str)\n    return equations, values, queries\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    equations, values, queries = parse_input(raw)\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n    formatted = '[' + ','.join(f\"{x:.5f}\" for x in results) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": true,
          "output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": true,
          "output": "[3.75000,0.40000,5.00000,0.20000]"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": true,
          "output": "[0.50000,2.00000,-1.00000,-1.00000]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode707.json",
    "problem_index_in_file": 0,
    "title": "Design Linked List",
    "description_snippet": "Design your implementation of the linked list. You can choose to use a singly or doubly linked list....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for MyLinkedList implementation. They didn't specify singly or doubly, choose one. Let's choose singly linked list. Provide steps: class definition, Node, constructor, methods. Each line with arrow. Use Start, End. Provide explanation. No actual code. Just virtual steps. Let's generate.\n\nWe need to output lines:\n\nStart\n→ Class MyLinkedList // 定義鏈表類\n    → Step: Define Node class with val, next // 節點結構\n    → Step: Initialize head, size // 成員變量\n→ MyLinkedList() // 建構子\n    → Assign head = null, size = 0\n→ int get(int index)\n    → Decision: If index<0 or index>=size? // 檢查合法\n        No → Return -1\n        Yes → Traverse from head index steps // 找到目標節點\n        → Return node.val\n→ void addAtHead(int val)\n    → Create new node\n    → newNode.next = head\n    → head = newNode\n    → size++\n→ void addAtTail(int val)\n    → If size==0? // 空列表\n        Yes → addAtHead(val)\n        No → Traverse to last node\n        → last.next = newNode\n        → size++\n→ void addAtIndex(int index, int val)\n    → Decision: If index>size? // 不能插入\n        Yes → Return\n        No →\n            If index==0? // 插入頭\n                Yes → addAtHead(val)\n                No →\n                    If index==size? // 尾部\n                        Yes → addAtTail(val)\n                        No → Traverse to node at index-1\n                            → newNode.next = current.next\n                            → current.next = newNode\n                            → size++\n→ void deleteAtIndex(int index)\n    → Decision: If index<0 or index>=size? // 無效\n        Yes → Return\n        No →\n            If index==0? // 刪除頭\n                Yes → head = head.next\n                No →\n                    Traverse to node at index-1\n                    → current.next = current.next.next\n                    → size--\n→ End\n\nBut must adhere to format: each line with arrow and comment. Use '→' and indentation for decisions. Let's produce nicely.\n\nAlso start and end lines. Provide comments in Chinese.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MyLinkedList // 定義鏈表類  \n&nbsp;&nbsp;→ Class Node // 節點結構  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Attribute val // 節點儲存值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Attribute next // 指向下一節點的指標  \n&nbsp;&nbsp;→ Attribute head // 鏈表頭指標  \n&nbsp;&nbsp;→ Attribute size // 鏈表長度  \n\n→ MyLinkedList() // 建構子  \n&nbsp;&nbsp;→ head = null // 初始頭節點為空  \n&nbsp;&nbsp;→ size = 0 // 初始長度為 0  \n\n→ int get(int index) // 取得指定索引的值  \n&nbsp;&nbsp;→ Decision: 如果 index < 0 或 index >= size? // 檢查索引是否合法  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return -1 // 無效索引  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step: current = head // 從頭節點開始  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ For i = 0 到 index - 1: current = current.next // 前進到目標節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Return current.val // 回傳值  \n\n→ void addAtHead(int val) // 在頭部新增節點  \n&nbsp;&nbsp;→ Step: newNode = Node(val) // 建立新節點  \n&nbsp;&nbsp;→ newNode.next = head // 新節點指向舊頭  \n&nbsp;&nbsp;→ head = newNode // 更新頭為新節點  \n&nbsp;&nbsp;→ size++ // 長度加一  \n\n→ void addAtTail(int val) // 在尾部新增節點  \n&nbsp;&nbsp;→ Decision: 如果 size == 0? // 空列表處理  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → addAtHead(val) // 空表直接加頭  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Step: current = head // 從頭開始  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ While current.next != null: current = current.next // 前進至最後節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ current.next = Node(val) // 尾部指向新節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ size++ // 長度加一  \n\n→ void addAtIndex(int index, int val) // 在指定索引前新增節點  \n&nbsp;&nbsp;→ Decision: 如果 index > size? // 超出範圍  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return // 不插入  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 index == 0? // 插入頭部  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → addAtHead(val) // 直接加頭  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 index == size? // 插入尾部  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → addAtTail(val) // 加尾  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step: current = head // 前置節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ For i = 0 到 index - 2: current = current.next // 前進到前置節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ newNode = Node(val) // 建立新節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ newNode.next = current.next // 新節點指向原後節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ current.next = newNode // 前置節點指向新節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ size++ // 長度加一  \n\n→ void deleteAtIndex(int index) // 刪除指定索引的節點  \n&nbsp;&nbsp;→ Decision: 如果 index < 0 或 index >= size? // 無效索引  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return // 不刪除  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 index == 0? // 刪除頭部  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → head = head.next // 更新頭為下一節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step: current = head // 前置節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ For i = 0 到 index - 2: current = current.next // 前進到前置節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ current.next = current.next.next // 跳過要刪除的節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ size-- // 長度減一  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyLinkedList:\n    class Node:\n        def __init__(self, val=0):\n            self.val = val\n            self.next = None\n\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        curr = self.head\n        for _ in range(index):\n            curr = curr.next\n        return curr.val\n\n    def addAtHead(self, val: int) -> None:\n        node = self.Node(val)\n        node.next = self.head\n        self.head = node\n        self.size += 1\n\n    def addAtTail(self, val: int) -> None:\n        node = self.Node(val)\n        if not self.head:\n            self.head = node\n        else:\n            curr = self.head\n            while curr.next:\n                curr = curr.next\n            curr.next = node\n        self.size += 1\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index < 0 or index > self.size:\n            return\n        if index == 0:\n            self.addAtHead(val)\n            return\n        node = self.Node(val)\n        curr = self.head\n        for _ in range(index - 1):\n            curr = curr.next\n        node.next = curr.next\n        curr.next = node\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n        if index == 0:\n            self.head = self.head.next\n        else:\n            curr = self.head\n            for _ in range(index - 1):\n                curr = curr.next\n            curr.next = curr.next.next\n        self.size -= 1\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = ast.literal_eval(data[0].strip())\n    params = ast.literal_eval(data[1].strip())\n    result = []\n    obj = None\n    for op, arg in zip(ops, params):\n        if op == \"MyLinkedList\":\n            obj = MyLinkedList()\n            result.append(None)\n        elif op == \"addAtHead\":\n            obj.addAtHead(arg[0])\n            result.append(None)\n        elif op == \"addAtTail\":\n            obj.addAtTail(arg[0])\n            result.append(None)\n        elif op == \"addAtIndex\":\n            obj.addAtIndex(arg[0], arg[1])\n            result.append(None)\n        elif op == \"deleteAtIndex\":\n            obj.deleteAtIndex(arg[0])\n            result.append(None)\n        elif op == \"get\":\n            val = obj.get(arg[0])\n            result.append(val)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyLinkedList\", \"addAtHead\", \"addAtTail\", \"addAtIndex\", \"get\", \"deleteAtIndex\", \"get\"]\n[[], [1], [3], [1, 2], [1], [1], [1]]",
          "expected_output": "[null, null, null, null, 2, null, 3]",
          "success": true,
          "output": "[null, null, null, null, 2, null, 3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for computing number of 1s in first n numbers of the magical string s. Classic problem: \"magical string\" or \"look-and-say\"? It's known problem from Leetcode 375. Approach: generate string until length n, count ones. Use array s with initial 1,2,2. Maintain pointer idx to position for next value to add (starting at 2). And count ones. While len < n: repeat times = s[idx]; for j in range(times): append s[-1] + 1? Actually we append the opposite of last element: if last element is 1, next is 2, else 1. Count ones. Move idx++. Complexity O(n). We'll produce virtual steps.\n\nWe must output each line of virtual code with explanation.\n\nLet's design steps:\n\nStart\n→ Initialize list magical[0]=1, magical[1]=2, magical[2]=2 // starting sequence\n→ Set count1 = 1 if magical[0]==1 else 0 // count ones\n→ Set idx = 2 // index of the element whose value indicates how many times to repeat next number\n→ While len(magical) < n:\n    → times = magical[idx] // number of times to repeat\n    → last = magical[-1] // last element\n    → next = 1 if last==2 else 2 // opposite value\n    → For i in 1..times:\n        → Append next to magical\n        → If next==1: count1 +=1\n    → idx +=1 // move to next control value\n→ Return count1 // answer\n\nEdge cases: if n==1 or n==2 etc.\n\nWe'll write each line.\n\nAlso need to mention that we use array/list.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize s ← [1, 2, 2] // 先放入已知的魔法字串開頭  \n→ count1 ← 1 // 目前已知的 '1' 個數（s[0] 為 1）  \n→ idx ← 2 // idx 指向 s 中控制接續填充次數的元素，初始為第三個位置  \n→ While length(s) < n: // 只要字串長度不足 n，就持續生成  \n  → times ← s[idx] // 這個位置的值告訴我們接下來要重複多少次  \n  → last ← s[-1] // 取目前字串最後一個字符  \n  → next ← 1 if last == 2 else 2 // 取相反的字符作為接續填充的數字  \n  → For i from 1 to times: // 依照 times 重複填充  \n    → Append next to s // 把下一個字符加入字串  \n    → If next == 1: count1 ← count1 + 1 // 若為 1，則計數器加一  \n  → idx ← idx + 1 // 指向下一個控制元素  \n→ Return count1 // 回傳前 n 個數字中 1 的總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef magical_string_count_ones(n: int) -> int:\n    \"\"\"Return the number of 1's in the first n elements of the magical string.\"\"\"\n    if n == 0:\n        return 0\n\n    # 初始化魔法字串為 [1, 2, 2]\n    s = [1, 2, 2]\n    idx = 2          # 指向決定後續重複次數的元素\n    num = 1          # 下一個要加入的數字（1 或 2，開始時為 1）\n\n    while len(s) < n:\n        # 根據 s[idx] 的值決定接下來要重複加入多少個 num\n        s.extend([num] * s[idx])\n        # num 交替為 1 或 2\n        num ^= 3\n        idx += 1\n\n    # 只取前 n 個元素，計算其中 1 的個數\n    return s[:n].count(1)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中提取第一個整數，不論輸入格式為 \"n = 6\" 或僅為 \"6\"\n    match = re.search(r'-?\\d+', data)\n    n = int(match.group()) if match else 0\n\n    result = magical_string_count_ones(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting islands in a binary grid. Use virtual code with arrows, Start, Decision etc. Each line with \"虛擬碼步驟 // 解釋\". The code must be stepwise, not actual code. Use typical DFS or BFS. We'll produce a step-by-step algorithm. Use pseudo steps like \"Start\", \"Set count = 0\", \"Loop over all cells\", \"Decision: cell is 1 and not visited?\", then if yes do DFS marking visited, increment count. DFS: mark visited, push neighbors if inside and 1 and not visited.\n\nWe need to output each step. Format: \"虛擬碼步驟 // 解釋\". Example: \"Start // 程式開始執行\". Use arrows \"→\" for next steps, \"Decision:\" for branching.\n\nWe should produce multi-line steps. Each step may have indentation.\n\nLet's create steps:\n\nStart\n→ Initialize visited set // 追蹤已訪問的土地\n→ Initialize count = 0 // 存儲島嶼數量\n→ For each row r in grid:\n    → For each column c in grid[r]:\n        → Decision: grid[r][c] == '1' and not visited?\n            Yes → count += 1 // 發現新島，計數\n            Yes → Call DFS(r, c) // 探索整個島\n            No → // 跳過水或已訪問\n\nDefine DFS function steps:\n→ Function DFS(row, col)\n    → Mark visited(row, col)\n    → For each neighbor in [(row-1,col),(row+1,col),(row,col-1),(row,col+1)]:\n        → Decision: neighbor inside bounds AND grid[neighbor] == '1' AND not visited?\n            Yes → DFS(neighbor) // 深度優先遞歸\n\nEnd // 完成\n\nBut need to use \"Decision:\" and \"Yes →\" \"No →\". Also use \"End\" for each function maybe.\n\nSo produce steps like:\n\nStart // 程式開始\n→ Initialize visited set // 建立一個集合來記錄已掃描的土地座標\n→ Initialize count = 0 // 用來記錄島嶼數量\n→ For row = 0 to m-1:\n    → For col = 0 to n-1:\n        → Decision: grid[row][col] == '1' 且 (row,col) 未在 visited? // 判斷是否為新的未掃描土地\n            Yes → count += 1 // 新島被找到，數量加一\n            Yes → DFS(row, col) // 從這個位置開始遞歸探索整個島\n            No → // 不是新島，直接跳過\n\nDefine DFS:\n→ Function DFS(row, col) // 進入遞歸探索\n    → Mark visited (row, col) // 記錄此座標已被掃描\n    → For each (nr, nc) in [(row-1,col),(row+1,col),(row,col-1),(row,col+1)]:\n        → Decision: nr, nc 在範圍內 AND grid[nr][nc] == '1' 且未訪問? // 判斷相鄰土地\n            Yes → DFS(nr, nc) // 進一步遞歸\n            No → // 不進一步\n\nEnd // 結束遞歸\n\nEnd // 程式結束\n\nWe need to format each line with arrow \"→\" for steps and \"Decision:\" etc. Also we need to keep each line separate with \"// 解釋\". Use \"Start\" and \"End\". Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 visited 為空集合 // 用來標記已掃描過的土地座標  \n→ 初始化 count 為 0 // 用來儲存島嶼數量  \n\n→ 循環遍歷每個 row 0~m-1  \n    → 循環遍歷每個 col 0~n-1  \n        → Decision: grid[row][col] == '1' 且 (row,col) 未在 visited? // 判斷是否為新島的起點  \n            Yes → count += 1 // 發現新島，數量加一  \n            Yes → DFS(row, col) // 從此座標開始深度優先搜尋整個島  \n            No → // 不是新島或已掃描，直接跳過  \n\n→ Function DFS(row, col) // 進行遞歸探索  \n    → 標記 visited 中加入 (row, col) // 這個座標已被處理  \n    → 對每個相鄰座標 (nr, nc) ∈ {(row-1,col),(row+1,col),(row,col-1),(row,col+1)}  \n        → Decision: nr, nc 在邊界內 AND grid[nr][nc] == '1' 且 (nr,nc) 未在 visited? // 判斷相鄰是否為土地且未被掃描  \n            Yes → DFS(nr, nc) // 進一步遞歸  \n            No → // 不進一步  \n\nEnd // DFS 函式結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if grid[i][j] == '0' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    count += 1\n        return count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the grid literal after '=' if present\n    idx = data.find('=')\n    grid_str = data[idx + 1:].strip() if idx != -1 else data\n    try:\n        grid = ast.literal_eval(grid_str)\n    except Exception:\n        # If parsing fails, assume the whole input is the grid\n        grid = ast.literal_eval(data)\n    solution = Solution()\n    result = solution.numIslands(grid)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode762.json",
    "problem_index_in_file": 0,
    "title": "Prime Number of Set Bits in Binary Representation",
    "description_snippet": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format, step by step.\n\nWe need to output the algorithm: iterate from left to right inclusive, count set bits, check if prime, increment result. Need helper to count set bits, helper to check prime. Also produce prime list maybe. Since range could be large, but not specified. We'll assume left, right up to maybe 1e9? but we only need count set bits <= 31. So prime numbers among 0-31: 2,3,5,7,11,13,17,19,23,29,31. We'll implement isPrime function: if n in set.\n\nAlgorithm steps:\n\nStart\n→ Input left, right\n→ Initialize result = 0\n→ For number from left to right: (Iteration)\n    → Count bits: bitCount = countSetBits(number)\n    → If isPrime(bitCount): result = result + 1\n→ Return result\n→ End\n\nNeed helper functions: countSetBits(n) -> loop while n>0: count += n & 1; n >>= 1; return count\n\nisPrimeSetBits(b) -> return b in primeSet\n\nWe'll show virtual code lines for functions too. But the requirement: \"逐行產生對應的虛擬碼\" meaning line by line.\n\nWe need to output each line with \"→\" or \"Start\" etc.\n\nAlso for loops, we need arrow indentation maybe? We can use indentation to represent nested steps: for loop body, if block.\n\nWe need to show decisions with Yes → and No →.\n\nAlso each line should have comment.\n\nWe'll produce code like:\n\nStart // 程式開始執行\n→ Input left, right // 取得輸入範圍\n→ Set result = 0 // 初始化計數\n→ For number = left; number <= right; number++ // 遍歷範圍\n    → Set bitCount = 0 // 內部計數變數\n    → temp = number // 用於位元計數\n    → While temp > 0 // 逐位計算\n        → bitCount = bitCount + (temp & 1) // 若最低位為 1，則累加\n        → temp = temp >> 1 // 右移一位\n    → Decision: bitCount 是否為質數? // 判斷 set bits 是否為質數\n        Yes → result = result + 1 // 是質數則計數加一\n        No  → // 不是質數不做任何事\n→ Return result // 回傳最終計數\nEnd // 程式結束\n\nBut we also need isPrime helper. We could incorporate logic within Decision. But better to show separate helper steps.\n\nWe can show:\n\n→ Function countSetBits(n): ... etc.\n\nBut the requirement: \"逐行產生對應的虛擬碼\" meaning the algorithm. We can include function definitions as separate steps.\n\nWe should include primeSet array maybe.\n\nSimplify: Use Decision: if bitCount in {2,3,5,7,11,13,17,19,23,29,31}. We can write a function isPrimeSetBits(b) that returns boolean. We can call it.\n\nSo:\n\n→ Function isPrimeSetBits(b):\n    → Decision: b in primeSet? // check membership\n        Yes → Return True\n        No  → Return False\n\nBut how to express Return? Use \"Return\" step. Use arrow. Let's format.\n\nAlso we might want to show primeSet initialization.\n\nGiven the format, each line should have \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe'll indent nested steps by spaces or tabs? We can just indent lines with spaces for readability. In the example, they used indentation for nested steps. We'll mimic that.\n\nWe need to use \"Decision:\" lines for if statements.\n\nWe'll include:\n\n→ Function isPrimeSetBits(b): // 定義檢查質數的函式\n    → Decision: b in {2,3,5,7,11,13,17,19,23,29,31}? // 判斷是否為質數\n        Yes → Return True // 是質數返回真\n        No  → Return False // 否則返回假\n\nBut we cannot use \"Return\" in the same line as arrow? We'll put \"→ Return True\" maybe.\n\nThe \"Return\" line: \"→ Return True // 返回真\" etc.\n\nAlso we need countSetBits function:\n\n→ Function countSetBits(n):\n    → Set count = 0 // 初始化計數\n    → Set temp = n // 用於位元計算\n    → While temp > 0:\n        → count = count + (temp & 1) // 累加最低位\n        → temp = temp >> 1 // 右移\n    → Return count // 回傳位元數\n\nWe need to produce Start, End for main flow. For function definitions, maybe no Start/End, but we can still use them? Example didn't show for functions. We'll just list the function definitions as separate block.\n\nBut we need to ensure each line has comment.\n\nLet's produce final output with proper formatting. We'll use tabs or spaces indentation: maybe two spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input left, right // 取得輸入範圍  \n→ Set result = 0 // 初始化計數  \n→ For number = left; number <= right; number++ // 遍歷 [left, right] 範圍  \n  → Set bitCount = countSetBits(number) // 計算 number 的 set bits 數量  \n  → Decision: isPrimeSetBits(bitCount)? // 判斷 set bits 數量是否為質數  \n      Yes → result = result + 1 // 若為質數則計數加一  \n      No  → // 若不是質數則不變  \n→ Return result // 回傳最終計數  \nEnd // 程式結束  \n\nFunction countSetBits(n) // 定義計算 set bits 數量的函式  \n  → Set count = 0 // 初始位元數  \n  → Set temp = n // 用於位元運算的暫存變數  \n  → While temp > 0 // 只要有位元剩餘  \n      → count = count + (temp & 1) // 若最低位為 1，則累加  \n      → temp = temp >> 1 // 右移一位以處理下一位  \n  → Return count // 回傳計算得到的 set bits 數量  \n\nFunction isPrimeSetBits(b) // 定義判斷是否為質數的函式  \n  → Decision: b in {2,3,5,7,11,13,17,19,23,29,31}? // 只需檢查這些質數  \n      Yes → Return True // 是質數返回真  \n      No  → Return False // 不是質數返回假",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countPrimeSetBits(self, left: int, right: int) -> int:\n        # 集合形式的質數集合，最多到 31\n        primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}\n        count = 0\n        for num in range(left, right + 1):\n            # 計算 num 的 set bits 數量\n            bits = bin(num).count('1')\n            if bits in primes:\n                count += 1\n        return count\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中擷取所有整數\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    left, right = nums[0], nums[1]\n    solution = Solution()\n    result = solution.countPrimeSetBits(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 6, right = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 10, right = 15",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding kth largest without sorting. Classic: use min-heap of size k. Steps: create heap, iterate, maintain size k. At end, top is kth largest. Provide steps line by line with arrows and decisions. No actual code. Use Start, End, Decision. Provide explanation.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化最小堆 Heap // 用來儲存目前最小的 k 個最大值  \n→ Step 2: 對 nums 中每個元素 num 做迴圈  \n    → Decision: 堆大小 < k? // 堆還未滿 k 個元素  \n      Yes → Step 3: 把 num 插入 Heap // 直接放進堆中  \n      No  → Decision: num > Heap.最小值? // 檢查新元素是否比目前堆中最小的大  \n        Yes → Step 4: 把 Heap.最小值移除，然後插入 num // 用 num 替換最小，保持堆大小 k  \n        No  → Step 5: 跳過 // num 不足以進入前 k 大，保持堆不變  \n→ Step 6: 循環結束後，Heap.最小值即為第 k 大元素 // 堆頂即為 kth largest  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\n\ndef find_kth_largest(nums, k):\n    \"\"\"返回 nums 中第 k 大的元素（不排除重复）\"\"\"\n    # 先把前 k 个元素放到最小堆\n    heap = nums[:k]\n    heapq.heapify(heap)\n    # 遍歷剩下的元素\n    for num in nums[k:]:\n        if num > heap[0]:            # 如果比堆中最小值大\n            heapq.heappop(heap)      # 把最小值移除\n            heapq.heappush(heap, num)  # 插入新元素\n    # 堆頂即為第 k 大的元素\n    return heap[0]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入文字中提取數字陣列與 k。\n    支援兩種常見格式：\n    1. 'nums = [3,2,1,5,6,4], k = 2'\n    2. 第一行是數字列表（逗號或空格分隔），第二行是 k\n    \"\"\"\n    # 嘗試搜尋列表\n    list_match = re.search(r'\\[(.*?)\\]', data)\n    if list_match:\n        nums = [int(x.strip()) for x in list_match.group(1).split(',') if x.strip()]\n    else:\n        # 沒有方括號，假設第一行是數字，第二行是 k\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            nums = [int(x) for x in lines[0].replace(',', ' ').split() if x.strip()]\n        else:\n            nums = []\n\n    # 找出 k\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if k_match:\n        k = int(k_match.group(1))\n    else:\n        # 可能第二行直接是 k\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            try:\n                k = int(lines[1].strip())\n            except ValueError:\n                k = None\n        else:\n            k = None\n\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    if not nums or k is None or k <= 0 or k > len(nums):\n        print(\"Invalid input\")\n    else:\n        result = find_kth_largest(nums, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, no actual code. We must output line by line: each line: virtual code step + space + // explanation. Must use Start, End, Decision, etc. Provide algorithm: iterate over pairs, check common letters, compute max product. But no actual code; it's pseudo steps.\n\nWe must describe algorithm: Input words array. For each word compute bitmask of letters. Then loop over pairs, if bitmask[i] & bitmask[j] == 0 then product = len[i]*len[j], update max. Return max. If no pair, max remains 0.\n\nWe need step-by-step. Let's produce steps:\n\nStart\n→ Step 1: Initialize max_product = 0 // store maximum product found\n→ Step 2: For each word in words, compute its letter bitmask and store in masks array // each bit represents a letter a-z\n→ Step 3: For i from 0 to n-1\n    → Step 4: For j from i+1 to n-1\n        → Decision: If masks[i] & masks[j] == 0? // words share no common letters\n            Yes → Step 5: Compute product = length[i] * length[j]\n            Yes → Step 6: If product > max_product, set max_product = product\n        No  → (skip to next pair)\n→ End // after all pairs processed\n→ Step 7: Return max_product // result (0 if none found)\n\nBut we must ensure each line includes arrow. For nested loops and decisions, indent with spaces maybe. Use format:\n\nStart // 程式開始執行\n→ Step 1: 初始化 max_product 為 0 // 用於存儲最大乘積\n→ Step 2: 為每個單詞計算字母位掩碼並儲存於 masks 陣列 // 每個位對應 a-z\n→ Step 3: 從 i = 0 到 n-1\n    → Step 4: 從 j = i+1 到 n-1\n        → Decision: 若 masks[i] & masks[j] == 0? // 無共同字母\n            Yes → Step 5: 計算 product = len[i] * len[j] // 乘積\n            Yes → Step 6: 若 product > max_product，更新 max_product = product\n        No  → (略過此對)\n\n→ End // 所有對已處理\n→ Step 7: 回傳 max_product // 若無符合條件則為 0\n\nMake sure each line is separate. The nested indentation uses spaces. Each line ends with comment. Provide explanation in Chinese.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 max_product 為 0 // 用於存儲目前發現的最大乘積  \n→ Step 2: 為每個單詞計算字母位掩碼並儲存於 masks 陣列 // 每個位代表 a-z，方便快速判斷是否共有字母  \n→ Step 3: 從 i = 0 到 n-1  \n    → Step 4: 從 j = i+1 到 n-1  \n        → Decision: 若 masks[i] & masks[j] == 0? // 兩單詞是否沒有共同字母  \n            Yes → Step 5: 計算 product = len[i] * len[j] // 兩字長度乘積  \n            Yes → Step 6: 若 product > max_product，更新 max_product = product // 取得更大的乘積  \n        No → (略過此對) // 有共同字母，直接跳過  \n→ End // 所有單詞對已處理完畢  \n→ Step 7: 回傳 max_product // 若沒有符合條件的對，值保持為 0，否則為最大乘積值",
      "generated_code": "import sys\nimport ast\n\ndef maxProduct(words):\n    \"\"\"回傳兩個不共用字母的單詞長度乘積的最大值。\"\"\"\n    n = len(words)\n    masks = [0] * n  # 以 26 個位元表示單詞中包含的字母\n    for i, word in enumerate(words):\n        mask = 0\n        for ch in word:\n            mask |= 1 << (ord(ch) - ord('a'))\n        masks[i] = mask\n\n    max_prod = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if masks[i] & masks[j] == 0:          # 兩個單詞沒有共同字母\n                prod = len(words[i]) * len(words[j])\n                if prod > max_prod:\n                    max_prod = prod\n    return max_prod\n\ndef main():\n    \"\"\"從標準輸入讀取 words，計算並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 移除可能的前綴，例如 \"words = \"\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        data = rhs.strip()\n    try:\n        words = ast.literal_eval(data)  # 安全解析字串成 list\n    except Exception:\n        words = []\n    result = maxProduct(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode698.json",
    "problem_index_in_file": 0,
    "title": "Partition to K Equal Sum Subsets",
    "description_snippet": "Given an integer array nums and an integer k, return true if it is possible to divide this array int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for partitioning array into k subsets equal sum. Classic problem: Partition to K equal sum subsets. Approach: backtracking with bitmask or recursive search. Provide pseudocode with steps, decisions. Need to produce step-by-step lines with arrow notation. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide lines like \"Start // 程式開始執行\". Use arrows \"→\".\n\nWe'll produce algorithm:\n\nStart\n→ Compute total sum; if total % k != 0 -> return false\n→ target = total / k\n→ sort nums descending (optional)\n→ Initialize array visited bool\n→ Define recursive function backtrack(k_remaining, current_sum, start_index)\n   Decision: If k_remaining == 1 -> return true // last subset automatically correct\n   Decision: If current_sum == target -> return backtrack(k_remaining-1, 0, 0) // start next subset\n   → Loop i from start_index to n-1\n       Decision: If visited[i] or current_sum + nums[i] > target -> continue\n       visited[i] = true\n       If backtrack(k_remaining, current_sum + nums[i], i+1) -> return true\n       visited[i] = false\n   → return false\n→ Call backtrack(k, 0, 0)\n→ End\n\nWe need to produce step lines. Use arrow \"→\" before each line after Start. Also include Decision lines.\n\nMake sure each line has a short explanation. Use Chinese. Provide at least 20 lines? Let's count: Start, compute sum, check mod, compute target, sort, init visited, define function start, decision if k_remaining==1, decision if current_sum==target, loop start, decision if visited or sum>target, visited assign, recursive call, visited reset, return false, call function, End. We'll write each as separate line.\n\nNote: In pseudocode, function definition may be separate lines: \"→ Function backtrack(k_remaining, current_sum, start_index) // 定義遞迴函式\". Inside, we need to indent decisions; maybe use \"Decision:\" lines with \"Yes →\", \"No →\" etc. We need to embed decision branches. For example:\n\nDecision: 如果 k_remaining == 1? // 檢查是否只剩一組\n    Yes → Return true // 剩餘部分自動符合\n    No  → ...\n\nSimilarly for sum==target. For loop, we need \"→ For i from start_index to n-1\" etc. Decision inside loop.\n\nWe must keep each line as a single line, no code block. Each line must have a single line of pseudocode followed by space and comment. Use arrows only at beginning, maybe indentation not necessary but arrow indicates step. Use \"→\" for each line after Start. Use \"Decision:\" lines with \"Yes →\" \"No →\".\n\nLet's craft.\n\nAlso need to mention we sort nums descending. We'll provide \"→ Sort nums descending // 為了更快剪枝\" etc.\n\nReturn boolean value. We'll produce final pseudocode lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Compute total sum of nums // 計算數組所有元素的總和  \n→ If total % k ≠ 0 → Return false // 若無法整除則不可能分割  \n→ target = total / k // 每組子集需要達到的目標和  \n→ Sort nums in descending order // 先降序排列以利剪枝  \n→ visited = array of False with length n // 標記每個元素是否已被使用  \n→ Function backtrack(k_remaining, current_sum, start_index) // 定義遞迴函式  \n → Decision: 如果 k_remaining == 1? // 檢查是否只剩最後一組  \n  Yes → Return true // 最後一組自動符合條件  \n  No  → Decision: 如果 current_sum == target? // 現有子集已達目標和  \n   Yes → Return backtrack(k_remaining - 1, 0, 0) // 開始下一個子集  \n   No  →  \n    → For i from start_index to n-1 // 從起始位置嘗試放入元素  \n     Decision: 如果 visited[i] 或 current_sum + nums[i] > target? // 已使用或超過目標  \n      Yes → Continue // 跳過此元素  \n      No  →  \n       visited[i] = True // 標記為已使用  \n       Decision: 如果 backtrack(k_remaining, current_sum + nums[i], i + 1)? // 進一步遞迴  \n        Yes → Return true // 成功找到合法分組  \n        No  → visited[i] = False // 回溯，取消標記  \n       → Return false // 所有嘗試均失敗  \n→ Return backtrack(k, 0, 0) // 開始遞迴搜索  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def canPartitionKSubsets(self, nums, k):\n        total = sum(nums)\n        if total % k != 0:\n            return False\n        target = total // k\n        nums.sort(reverse=True)\n        n = len(nums)\n        visited = [False] * n\n\n        def backtrack(k_remaining, current_sum, start_index):\n            if k_remaining == 1:  # last group will automatically match\n                return True\n            if current_sum == target:\n                return backtrack(k_remaining - 1, 0, 0)\n            for i in range(start_index, n):\n                if visited[i] or current_sum + nums[i] > target:\n                    continue\n                visited[i] = True\n                if backtrack(k_remaining, current_sum + nums[i], i + 1):\n                    return True\n                visited[i] = False\n            return False\n\n        return backtrack(k, 0, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*([0-9]+)', data)\n    if not nums_match or not k_match:\n        print(\"false\")\n        sys.exit(0)\n    nums_str = nums_match.group(1)\n    k_str = k_match.group(1)\n    nums = ast.literal_eval(nums_str)\n    k = int(k_str)\n    sol = Solution()\n    result = sol.canPartitionKSubsets(nums, k)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,3,5,2,1], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode740.json",
    "problem_index_in_file": 0,
    "title": "Delete and Earn",
    "description_snippet": "You are given an integer array nums. You want to maximize the number of points you get by performing...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code solution in pseudo-code for the \"Delete and Earn\" problem. They want line-by-line pseudo-code with explanation after //.\n\nWe need to produce a pseudo-code algorithm: Use frequency map, DP akin to House Robber.\n\nPseudo-code lines: Start, step 1: Build frequency map. Step 2: Build sorted unique values or array of points. Step 3: DP.\n\nWe need to maintain lines with arrow. Use 'Start', 'End', 'Decision:'. Use 'Yes →' 'No →' for decisions.\n\nAlso we need to handle mapping and DP iterative.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Compute frequency map freq[nums[i]] // count occurrences of each value\n→ Step 2: Create sorted list uniqueVals from freq keys // sorted unique numbers\n→ Step 3: Initialize prev1 = 0, prev2 = 0 // DP previous two results\n→ Decision: If uniqueVals is empty? // check empty\n    Yes → Step 4: Return 0 // no numbers\n    No  → Step 5: For each val in uniqueVals:\n        → Step 6: points = val * freq[val] // total points if take this value\n        → Decision: If val == prevVal + 1? // if consecutive\n            Yes → Step 7: cur = max(prev1, prev2 + points) // choose skip or take\n            No  → Step 8: cur = prev1 + points // no conflict\n        → Step 9: Update prev2 = prev1\n        → Step 10: Update prev1 = cur\n        → Update prevVal = val\n→ Step 11: Return prev1 // maximum points\nEnd\n\nNeed to be line-by-line. Include arrow arrows. Use \"→\" to indicate next step. Provide decisions.\n\nMake sure each line ends with // explanation.\n\nLet's craft.\n\nAlso need to show initial prevVal maybe set to -inf.\n\nWe'll structure:\n\nStart // 程式開始\n→ Step 1: Build frequency map freq from nums // Count each number's occurrences\n→ Step 2: Extract sorted unique values sortedVals from freq keys ascending // Ensure order\n→ Step 3: Initialize dpPrev2 = 0, dpPrev1 = 0, prevVal = -1 // DP placeholders\n→ Decision: If sortedVals is empty? // Check no numbers\n    Yes → Step 4: Return 0 // 無數字可選，回傳 0\n    No  → Step 5: For each val in sortedVals:\n        → Step 6: points = val * freq[val] // 點數等於數值乘以其頻率\n        → Decision: If val == prevVal + 1? // 是否相鄰\n            Yes → Step 7: cur = max(dpPrev1, dpPrev2 + points) // 取或不取\n            No  → Step 8: cur = dpPrev1 + points // 無衝突可直接加\n        → Step 9: dpPrev2 = dpPrev1 // 更新 DP\n        → Step 10: dpPrev1 = cur\n        → Step 11: prevVal = val\n→ Step 12: Return dpPrev1 // 最大點數\nEnd // 程式結束\n\nNeed to include arrows and each line must include \"虛擬碼步驟\" + space + \"// 解釋\". Provide pseudo-code text.\n\nAlso note use arrow after \"Start\" maybe \"→\". Should we prefix each step with arrow? Example: \"→ Step 1: ...\" Yes.\n\nAlso decision indentation: maybe indent with spaces. For clarity.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Build frequency map freq from nums // 建立每個數字出現次數的映射  \n→ Step 2: Extract sorted unique values sortedVals from freq keys ascending // 取得已排序的唯一數值列表  \n→ Step 3: Initialize dpPrev2 = 0, dpPrev1 = 0, prevVal = -1 // 設定動態規劃的前兩個結果與上一個處理的數值  \n→ Decision: If sortedVals is empty? // 檢查是否沒有可處理的數字  \n  Yes → Step 4: Return 0 // 若無數字，直接回傳 0  \n  No  → Step 5: For each val in sortedVals: // 逐一遍歷已排序的數值  \n    → Step 6: points = val * freq[val] // 計算選擇該數字時可獲得的總分  \n    → Decision: If val == prevVal + 1? // 判斷當前數字是否與上一個相鄰  \n      Yes → Step 7: cur = max(dpPrev1, dpPrev2 + points) // 若相鄰，選擇不取或取並加上非相鄰的前值  \n      No  → Step 8: cur = dpPrev1 + points // 若不相鄰，可直接將分數加入  \n    → Step 9: dpPrev2 = dpPrev1 // 更新動態規劃的前兩個狀態  \n    → Step 10: dpPrev1 = cur  \n    → Step 11: prevVal = val // 設置當前為下一個迭代的 prevVal  \n→ Step 12: Return dpPrev1 // 返回最大可獲得的分數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef delete_and_earn(nums):\n    \"\"\"Return maximum points that can be earned by repeatedly deleting numbers.\"\"\"\n    if not nums:\n        return 0\n\n    count = Counter(nums)           # frequency of each number\n    max_num = max(nums)\n\n    # dp[i] stores max points using numbers up to i\n    dp = [0] * (max_num + 1)\n    dp[0] = 0\n    dp[1] = count.get(1, 0) * 1\n\n    for i in range(2, max_num + 1):\n        # Option 1: skip i\n        # Option 2: take i (cannot take i-1)\n        dp[i] = max(dp[i - 1], dp[i - 2] + count.get(i, 0) * i)\n\n    return dp[max_num]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        # The input is expected to be a list literal, e.g. \"[3,4,2]\"\n        nums = ast.literal_eval(data)\n    result = delete_and_earn(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,4,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for incrementing an integer represented as array digits. Follow format: each line: virtual step + space + // explanation. Use Start, End, Decision, etc. No actual code. Use arrows. Provide each line. Let's craft.\n\nStart\n→ Step 1: 設定 index = length(digits) - 1 // 取得最右邊的索引\n→ Decision: 是否需要進位? // 從右往左逐位檢查\n    Yes → Step 2: digits[index] += 1 // 將當前位加 1\n    No  → Step 3: digits[index] = (digits[index] + 1) mod 10 // 先加1再模 10\n    No  → Step 4: 是否為 10? // 檢查是否溢出\n        Yes → Step 5: digits[index] = 0 // 將位數設為 0\n        Yes → Step 6: index -= 1 // 移到下一個更高位\n        Yes → Decision: 是否 index >= 0? // 檢查是否還有更高位\n            Yes → Step 7: 回到 Decision: 是否需要進位? // 重複流程\n            No  → Step 8: 前面所有位已處理完畢，若還未進位，則跳出\n        No  → Step 9: 程序結束 // 若不溢出，直接結束\n→ Decision: index < 0 且有進位? // 檢查是否還需要在最前面插入 1\n    Yes → Step 10: 建立新陣列 result = [1] + digits // 在最前面插入 1\n    Yes → Step 11: return result // 回傳結果\n    No  → Step 12: return digits // 回傳已更新的 digits\nEnd\n\nBut need to be careful with structure and arrows. Ensure each line separate. Use \"Yes →\" and \"No →\". Provide explanation in Chinese. Ensure no code. Provide \"Start\" and \"End\". Provide arrow lines. Let's craft more coherent pseudocode:\n\nStart // 程式開始執行\n→ Step 1: index = digits.length - 1 // 取得最右邊數字的位置\n→ Decision: index >= 0? // 是否還有位數可處理\n    Yes → Step 2: digits[index] += 1 // 將當前位加 1\n    Yes → Decision: digits[index] == 10? // 檢查是否溢出\n        Yes → Step 3: digits[index] = 0 // 溢出則設為 0\n        Yes → Step 4: index -= 1 // 移到更高位\n        Yes → Decision: index >= 0? // 是否還有更高位需要處理\n            Yes → Jump back to Step 1 // 重複處理下一位\n            No  → Step 5: // 所有位已處理完畢\n        No  → Step 6: // 沒有溢出，直接完成\n    No  → Step 7: // index < 0，所有位已處理完畢\n→ Decision: index < 0 且 digits[0] == 0? // 是否需要在最前面插入 1\n    Yes → Step 8: digits = [1] + digits // 在最前面插入 1\n    Yes → Step 9: return digits // 回傳結果\n    No  → Step 10: return digits // 回傳已更新的 digits\nEnd // 程式結束\n\nBut we need each line with \"虛擬碼步驟\" + \" // 解釋\". Let's ensure each line is one step.\n\nAlso need to include arrow \"→\". Use \"Yes →\" and \"No →\" lines. Use \"Decision:\" lines. Provide indentation maybe optional.\n\nLet's create final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: index = digits.length - 1 // 取得最右邊數字的位置  \n→ Decision: index >= 0? // 是否還有位數可處理  \n  Yes → Step 2: digits[index] += 1 // 將當前位加 1  \n  Yes → Decision: digits[index] == 10? // 檢查是否溢出  \n    Yes → Step 3: digits[index] = 0 // 溢出則設為 0  \n    Yes → Step 4: index -= 1 // 移到更高位  \n    Yes → Decision: index >= 0? // 是否還有更高位需要處理  \n      Yes → Step 1 // 重複處理下一位  \n      No → Step 5: // 所有位已處理完畢  \n    No → Step 6: // 沒有溢出，直接完成  \n  No → Step 7: // index < 0，所有位已處理完畢  \n→ Decision: index < 0 且 digits[0] == 0? // 是否需要在最前面插入 1  \n  Yes → Step 8: digits = [1] + digits // 在最前面插入 1  \n  Yes → Step 9: return digits // 回傳結果  \n  No → Step 10: return digits // 回傳已更新的 digits  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"Increment the integer represented by digits by one.\"\"\"\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits\n\ndef parse_input(data):\n    \"\"\"Parse input of the form 'digits = [1,2,3]' or just a list literal.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if data.startswith('digits'):\n        # Split on the first '=' and parse the part after it\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        return ast.literal_eval(expr)\n    except Exception:\n        # Fallback: try eval if literal_eval fails\n        return eval(expr, {})\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    digits = parse_input(raw)\n    result = Solution().plusOne(digits)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1, 2, 4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4, 3, 2, 2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode646.json",
    "problem_index_in_file": 0,
    "title": "Maximum Length of Pair Chain",
    "description_snippet": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.\n\nA pair...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving longest chain of pairs problem. Provide step-by-step algorithm: sort pairs by right endpoint, then dynamic programming greedy? Actually longest chain is like longest increasing subsequence on right endpoints after sorting by left? Known solution: sort by right ascending, then greedily pick next with left > current right. That gives maximum chain length. So algorithm: sort pairs by right. Initialize count=0, current_end=-inf. For each pair (l,r): if l > current_end: count++ and current_end=r. Return count.\n\nWe need virtual code lines with explanation. Use structure: Start, Step, Decision, etc. Provide each line. Let's produce steps: 1) Input pairs. 2) Sort pairs by right. 3) Initialize count=0, current_end=-∞. 4) Iterate each pair. 5) Decision: if pair.left > current_end? 6) Yes: count++ and current_end=pair.right. 7) End. 8) Output count.\n\nMake sure use virtual code arrow formatting. Use indentation for nested decisions. Provide concise explanations. Ensure each line ends with comment. Use correct syntax: `→ Step 1: ...`. Provide arrow. For decision lines: `→ Decision: ...`. Indent subsequent lines with spaces or tabs? Provide indentation. Use maybe two spaces for nested lines. Use `Yes →` and `No →`. In this algorithm, no else needed. So just decision with Yes branch. We can still include No branch doing nothing.\n\nLet's craft.\n\nUse `Start` and `End`. Provide each line. Provide short comment after `//`.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 array pairs // 取得所有長度為 n 的二元組列表  \n→ Step 2: Sort pairs 依照 right 值升序排列 // 使得右端點最小的對先被處理  \n→ Step 3: 設定 count ← 0, current_end ← -∞ // count 用來記錄目前最大鏈長，current_end 為目前鏈最後一個對的 right  \n→ Step 4: 迭代每個 pair (left, right) in pairs // 按排序順序檢查每個對  \n    → Decision: if left > current_end? // 只有在左端點大於前一個對的右端點時才能連接  \n        Yes → Step 5: count ← count + 1 // 連接成功，鏈長增一  \n        Yes → Step 6: current_end ← right // 更新鏈最後一個對的右端點  \n        No  → Step 7: /* 跳過此 pair */ // 無法連接，保持目前鏈不變  \n→ Step 8: 輸出 count // 返回可得到的最大鏈長  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestChain(self, pairs):\n        \"\"\"\n        找出最長的鏈長度。\n        思路：先按右端點升序排序，然後從左到右贪心地挑選每個可以連接的對。\n        \"\"\"\n        pairs.sort(key=lambda x: x[1])          # 依右端點排序\n        curr_end = float('-inf')                # 目前鏈中最後一個對的右端點\n        count = 0                               # 鏈長\n\n        for left, right in pairs:               # 逐一檢查每個對\n            if left > curr_end:                 # 能連接\n                curr_end = right                # 更新右端點\n                count += 1                      # 鏈長 + 1\n        return count\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 處理類似 \"pairs = [[1,2],[2,3]]\" 的輸入\n    if raw_input.lower().startswith(\"pairs\"):\n        _, _, expr = raw_input.partition(\"=\")\n        pairs = ast.literal_eval(expr.strip())\n    else:\n        pairs = ast.literal_eval(raw_input)\n\n    solution = Solution()\n    result = solution.findLongestChain(pairs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pairs = [[1,2],[2,3],[3,4]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "pairs = [[1,2],[7,8],[4,5]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanations. Must avoid actual code, just pseudocode steps. We need to handle: given array words, find all concatenated words composed of at least two shorter words from the array. Use typical algorithm: sort words by length, use a set for dictionary, for each word check if can be segmented using DP referencing set of shorter words.\n\nVirtual code must use arrows, Start, End, Decision:, Yes →, No →.\n\nLet's design steps: Start, Sort words by length ascending, Initialize empty set dictionary, Initialize empty list result.\n\nThen iterate over each word w in sorted words: If w is empty, skip.\n\nCall function canForm(word, dictionary) returning bool: Use DP array of length+1. For i from 0 to len: if dp[i] true, try j from i+1 to len: substring w[i:j] in dictionary? if yes set dp[j] true. At end check dp[len] true and w length >0? but we need at least two words. Since dictionary contains previous words only (shorter words). So if dp[len] true, add to result. Then add w to dictionary.\n\nBut the pseudocode should reflect logic. Use Decision: if word length 0? else.\n\nAlso can call canForm as nested subroutine. Use pseudo code steps with arrow.\n\nNeed to maintain \"逐行\" with each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Sort words by ascending length // 方便先處理短字詞\n\n→ Initialize dictionary = empty set // 儲存已處理且可用於組合的字詞\n\n→ Initialize result = empty list // 儲存所有拼接字詞\n\n→ For each word in words: // 逐一檢查每個字詞\n\n    → Decision: 如果 word 为空? // 避免空字串\n\n        Yes → Continue // 跳過\n\n        No  → Decision: 是否能用字典中的字詞拼出? // 判斷是否為拼接字詞\n\n            Yes → Step: result.add(word) // 加入結果\n\n            No  → // 什麼都不做\n\n    → Step: dictionary.add(word) // 把當前字詞加入字典以供後續使用\n\nEnd // 程式結束\n\nBut we need to specify canForm logic. Might create subroutine.\n\nDefine Subroutine canForm(word, dictionary):\n\nStart // 子程序開始\n\n→ Initialize dp[0] = true // 基本情況\n\n→ For i from 0 to len(word)-1:\n\n    → Decision: 如果 dp[i] == false? // 如果到此位置無法到達\n\n        Yes → Continue // 跳過\n\n        No  → For j from i+1 to len(word):\n\n            → Decision: 如果 substring(word, i, j) in dictionary? // 子字詞是否已存在\n\n                Yes → Step: dp[j] = true // 可以到達位置 j\n\n                No  → // 什麼都不做\n\n→ Decision: dp[len(word)] == true? // 是否能完全拼接\n\n    Yes → Return true\n\n    No  → Return false\n\nEnd // 子程序結束\n\nThen in main loop use Decision: If canForm(word, dictionary) → yes.\n\nBut our format: each line with arrow. For nested loops, indent with arrow?\n\nWe can use \"→\" for next step inside loop. Indentation might be shown with spaces or indent markers. The example uses nested with spaces before Yes →. We'll use 4 spaces indentation for nested steps.\n\nLet's produce final pseudocode.\n\nBe careful: lines must be each \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow for transitions.\n\nLet's construct.\n\n1. Start // 程式開始\n\n2. → Sort words by ascending length // 先把字詞按長度排序\n\n3. → Initialize dictionary = empty set // 用來存已處理且可作拼接的字詞\n\n4. → Initialize result = empty list // 存儲所有拼接字詞\n\n5. → For each word in words: // 逐個字詞檢查\n\n    5.1 Decision: 如果 word 為空? // 避免空字串\n\n        Yes → Continue // 跳過\n\n        No  → Decision: 如果 canForm(word, dictionary) 為真? // 判斷是否能拼接\n\n            Yes → Step: result.add(word) // 加入結果\n\n            No  → // 不加入\n\n    5.2 Step: dictionary.add(word) // 把字詞加入字典，供後續使用\n\n6. End // 程式結束\n\nDefine canForm subroutine after End? But we need to specify within code.\n\nWe could place Subroutine before main loop. Let's reorder: Define Subroutine canForm before main loop.\n\nBut to keep structure, start with Subroutine definition then main.\n\nThus lines:\n\nStart // 程式開始\n\n→ Subroutine canForm(word, dictionary) // 判斷字詞是否能由字典中的字詞拼出\n\n    → Initialize dp[0] = true // 基本情況\n\n    → For i from 0 to len(word)-1: // 遍歷位置\n\n        → Decision: 如果 dp[i] == false? // 位置不可達\n\n            Yes → Continue // 跳過\n\n            No  → For j from i+1 to len(word): // 嘗試延伸子字串\n\n                → Decision: 如果 substring(word, i, j) in dictionary? // 子字串是否可用\n\n                    Yes → Step: dp[j] = true // 可到達位置 j\n\n                    No  → // 無操作\n\n    → Decision: dp[len(word)] == true? // 能否完全拼接\n\n        Yes → Return true\n\n        No  → Return false\n\nEnd // 子程序結束\n\nBut we also need main loop after.\n\nHowever, we must keep \"End\" for main? The example uses End at the end of program. So after main loop, End.\n\nLet's produce final.\n\nWe need each line of code with comment. Use \"→\" arrow for next step. For nested we indent with 4 spaces.\n\nAlso for decisions we write: Decision: ... and then Yes → ... No → ... lines.\n\nMake sure each line ends with comment.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n\n→ Subroutine canForm(word, dictionary) // 判斷字詞是否能由字典中的字詞拼出  \n    → Initialize dp[0] = true // 基本情況，位置 0 可達  \n    → For i from 0 to len(word)-1: // 從左至右遍歷字詞位置  \n        → Decision: 如果 dp[i] == false? // 若位置 i 無法到達  \n            Yes → Continue // 跳過此位置  \n            No  → For j from i+1 to len(word): // 嘗試以 j 為結束點的子字串  \n                → Decision: 如果 substring(word, i, j) in dictionary? // 子字串是否可用  \n                    Yes → Step: dp[j] = true // 可到達位置 j  \n                    No  → // 無操作  \n    → Decision: dp[len(word)] == true? // 是否能完全拼接  \n        Yes → Return true // 成功拼接  \n        No  → Return false // 失敗拼接  \nEnd // 子程序結束  \n\n→ Sort words by ascending length // 先處理短字詞，確保字典中已存在較短字詞  \n→ Initialize dictionary = empty set // 儲存已處理且可用於組合的字詞  \n→ Initialize result = empty list // 存儲所有拼接字詞  \n\n→ For each word in words: // 逐一檢查每個字詞  \n    → Decision: 如果 word 為空? // 避免空字串  \n        Yes → Continue // 跳過此字詞  \n        No  → Decision: 如果 canForm(word, dictionary) 為真? // 判斷是否能拼接  \n            Yes → Step: result.add(word) // 加入結果  \n            No  → // 什麼也不做  \n    → Step: dictionary.add(word) // 把當前字詞加入字典，供後續使用  \n\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        word_set = set(words)\n        memo = {}\n\n        def canForm(word):\n            if word in memo:\n                return memo[word]\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in word_set:\n                    if suffix in word_set or canForm(suffix):\n                        memo[word] = True\n                        return True\n            memo[word] = False\n            return False\n\n        res = []\n        for word in words:\n            if not word:          # skip empty string\n                continue\n            word_set.remove(word) # avoid using the word itself\n            if canForm(word):\n                res.append(word)\n            word_set.add(word)\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read()\n    data = data.strip()\n    if not data:\n        words = []\n    else:\n        # Extract the list part of the input\n        match = re.search(r'\\[.*\\]', data, re.S)\n        if match:\n            list_str = match.group(0)\n        else:\n            # If input is just a plain list without \"words =\" prefix\n            list_str = data\n        words = ast.literal_eval(list_str)\n\n    sol = Solution()\n    result = sol.findAllConcatenatedWordsInADict(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": true,
          "output": "['catsdogcats', 'dogcatsdog', 'ratcatdogcat']"
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "['catdog']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like algorithm steps) for implementing a nested list iterator. We must provide step by step, each line: virtual code step + comment. Use Start, End, Decision, arrow. Must be in Traditional Chinese. Use virtual code steps, not actual code. Provide explanation for each line. Each line should have the format: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce algorithm for NestedIterator. Common approach: stack of iterators or list and index. We'll produce algorithm that uses a stack of iterators over nested lists. Or use stack of indices. We'll produce pseudo steps: initialize stack with nestedList; while stack not empty: peek top; if it's integer, return; else push its sublist onto stack.\n\nWe'll produce the algorithm steps.\n\nAlso include the constructor and methods.\n\nLet's produce:\n\nStart\n→ Step 1: 建立空棧 stack // 用於儲存還未處理的子列表與索引\n→ Step 2: 把整個 nestedList 作為迭代器入棧 // 初始化\n→ Decision: stack 为空? // 判斷是否有更多元素\n    Yes → End // 結束\n    No  → Step 3: 取得 stack 顶部 // 取最上層迭代器或索引\n        Decision: 顶部元素是整数? // 判斷頂部是否為整數\n            Yes → Step 4: 返回整数 // next() 的結果\n            No  → Step 5: 如果顶部是列表, 推入其迭代器 // 若列表, 则展平\n... Actually we need next() and hasNext() methods.\n\nBut we must produce virtual code step by step, not separate functions? Could produce like:\n\nStart\n→ Step: NestedIterator(nestedList) 初始化 // 初始化\n   → Step: stack = 空棧\n   → Step: push(nestedList.iterator) // push iterator of root list\nEnd\n\nThen for hasNext:\n→ Function hasNext() // 判斷是否有下一個整數\n   → Decision: stack 为空? // 如果棧空則沒有\n       Yes → return False\n       No  → Step: 處理頂部\n           → Decision: stack.top() 是整數? // 如果頂部是整數\n               Yes → return True\n               No  → Step: stack.pop()\n               → Step: push(iterator of list) // etc\n\nBut better to flatten using while loop: while stack not empty and top is not integer, pop or push its children.\n\nOk let's produce algorithm:\n\nStart\n→ Step 1: 定義 stack 為空棧 // 用於儲存迭代器或索引\n→ Step 2: 把 nestedList 的迭代器 push 到 stack // 初始化\nEnd\n\nhasNext:\n→ Decision: stack 为空? // 若棧空\n    Yes → return False\n    No  → Step 3: while stack not empty and stack.top() 指向整數? \n        No → // 顶部是列表\n            Step 4: 把顶层迭代器的下一個元素取出\n            Decision: 该元素是整数?\n                Yes → push integer onto stack // 用于 next()\n                No  → push its iterator onto stack // 继续展平\n        Yes → // 顶部是整数\n            return True\n\nnext:\n→ Step: integer = stack.pop() // 弹出整数\n→ return integer\n\nHowever we need more precise pseudo.\n\nLet's produce the following lines:\n\nStart\n→ Step 1: NestedIterator 初始化 // 建構子\n   → Step 2: stack = 空棧 // 用於儲存待處理的項目\n   → Step 3: push(nestedList) // 把整個列表作為一個項目入棧\nEnd\n\nhasNext() // 判斷是否還有未處理的整數\n   → Decision: stack 为空? // 若棧空，沒有更多元素\n       Yes → return False\n       No  → Step 4: 處理頂部項目\n           → Decision: stack.top() 是整數? // 若頂部是整數\n               Yes → return True\n               No  → Step 5: 取出頂部列表\n                   → Step 6: 若列表非空，將其元素倒序 push 到棧 // 以保持順序\n                   → Step 7: 從堆棧中取出新頂部\n                   → Jump to Step 4 // 重新判斷\n\nnext() // 返回下一個整數\n   → Step 8: integer = stack.pop() // 取出頂部整數\n   → return integer\n\nBut we also need to include that after each push we must push the elements in reverse order to maintain order because stack pops last pushed first.\n\nLet's produce the final steps accordingly. Use 虛擬碼步驟 plus comment.\n\nLet's write them line by line, using the arrow notation: \"→\". Also include \"Decision:\".\n\nAlso we should have \"Start\" and \"End\". Let's produce:\n\nStart\n→ Step 1: NestedIterator(nestedList) 初始化 // 建立迭代器，將根列表入棧\n    → Step 1a: stack = 空棧 // 用於儲存待處理的項目\n    → Step 1b: push(nestedList) // 根列表作為整個項目入棧\nEnd\n\nBut we need to produce code lines sequentially. For readability, we can indent the nested lines with arrow. We'll keep consistent.\n\nAlso each line ends with // comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: NestedIterator(nestedList) // 建構子，初始化\n    → Step 1a: stack = 空棧 // 用來保存待處理的項目\n    → Step 1b: push(nestedList) // 把整個列表作為一個項目入棧\nEnd // 程式結束\n\nBut we may also need to show the methods separately. However the problem wants virtual code lines and explanations. It's fine to present the steps as a whole algorithm: start, constructor, hasNext, next, end.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: NestedIterator(nestedList) // 建構子，初始化\n    → Step 1a: stack = 空棧 // 用來保存待處理的項目\n    → Step 1b: push(nestedList) // 把整個列表作為一個項目入棧\n→ Function hasNext() // 判斷是否還有未處理的整數\n    → Decision: stack 为空? // 若棧空，沒有更多元素\n        Yes → return False\n        No  → Step 2: // 處理頂部項目\n            → Decision: stack.top() 是整數? // 如果頂部已是整數\n                Yes → return True\n                No  → Step 3: // 顶部是列表\n                    → Step 3a: list = stack.pop() // 取出列表\n                    → Decision: list 非空? // 確保列表中有元素\n                        Yes → Step 3b: // 將列表元素倒序 push 到棧\n                            → For each element in list from last to first:\n                                → push(element) // 以保持順序\n                        No  → // 空列表，直接繼續循環\n                    → Jump to Step 2 // 重新判斷頂部\n→ Function next() // 返回下一個整數\n    → Step 4: integer = stack.pop() // 取出頂部整數\n    → return integer\nEnd // 程式結束\n\nBut the instructions require each line be a virtual code step, with // explanation. We can flatten into single lines:\n\nStart // 程式開始執行\n→ Step 1: NestedIterator(nestedList) // 建構子，初始化\n    → Step 1a: stack = 空棧 // 用來儲存待處理項目\n    → Step 1b: push(nestedList) // 把整個列表作為一個項目入棧\n→ Decision: stack 为空? // 判斷棧是否為空\n    Yes → End // 沒有元素，結束\n    No  → // 繼續處理\nBut this merges logic incorrectly.\n\nWe need to produce algorithm for next() and hasNext() separately.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: NestedIterator(nestedList) // 建構子，初始化\n    → Step 1a: stack = 空棧\n    → Step 1b: push(nestedList)\n→ Function hasNext() // 判斷是否有下一個整數\n    → Decision: stack 为空? // 如果棧空則沒有更多元素\n        Yes → return False\n        No  → Step 2: // 處理棧頂\n            → Decision: stack.top() 是整數? // 棧頂是否為整數\n                Yes → return True\n                No  → Step 3: // 棧頂是列表\n                    → Step 3a: list = stack.pop() // 取出列表\n                    → Decision: list 非空? // 列表是否有元素\n                        Yes → Step 3b: // 把列表元素倒序 push 到棧\n                            → For i from list.size()-1 downto 0:\n                                → push(list[i])\n                        No  → // 空列表，直接忽略\n                    → Jump to Step 2 // 重新檢查棧頂\n→ Function next() // 返回下一個整數\n    → Step 4: integer = stack.pop() // 取出棧頂整數\n    → return integer\nEnd // 程式結束\n\nBut each line must be a virtual code step and comment. We need to break the For loop into multiple lines as well. The instruction says \"逐行\" and \"每行虛擬碼必須包含虛擬碼步驟 + 空格 + // 解釋/說明\". So each line must be separate. So we need to write each line individually. But we can't embed loops inside a line. So we need to produce lines for the loop. We'll need to break into separate steps: e.g.,\n\n→ Step 3b: For i from list.size()-1 downto 0 // 逆序遍歷列表\n    → push(list[i]) // 將每個元素推入棧\n\nBut we need separate lines for the for loop start and body.\n\nSimplify: We can represent the loop as:\n\n→ Step 3b: for each element in list from last to first:\n    → push(element)\n\nBut that might be considered a single line. But we need each line separately.\n\nLet's produce:\n\n→ Step 3b: start for-loop over list in reverse order // 逆序遍歷列表\n→ Step 3b-1: push(current element) // 將元素推入棧\n→ Step 3b-2: end for-loop // 迴圈結束\n\nBut we can just produce:\n\n→ Step 3b: push all elements of list in reverse order // 逆序推入\n\nBut we want more detailed.\n\nHowever, the instruction may not require extremely detailed internal loops; it's acceptable to have a single line for pushing all elements in reverse order. The comment can explain.\n\nSo we can keep that simpler.\n\nAlso the decision steps: we need to indent properly.\n\nLet's craft final output accordingly.\n\nRemember to include \"Start\" and \"End\". Provide each line with arrow and comment.\n\nAlso use \"Decision:\" lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: NestedIterator(nestedList) // 建構子，初始化迭代器\n    → Step 1a: stack = 空棧 // 用於儲存待處理項目\n    → Step 1b: push(nestedList) // 把整個列表作為一個項目入棧\n→ Function hasNext() // 判斷是否還有未處理的整數\n    → Decision: stack 为空? // 棧空則沒有更多元素\n        Yes → return False\n        No  → Step 2: // 處理棧頂\n            → Decision: stack.top() 是整數? // 棧頂是否為整數\n                Yes → return True\n                No  → Step 3: // 棧頂是列表\n                    → Step 3a: list = stack.pop() // 取出列表\n                    → Decision: list 非空? // 列表是否有元素\n                        Yes → Step 3b: push all elements of list in reverse order // 逆序推入棧\n                        No  → // 空列表，直接忽略\n                    → Jump to Step 2 // 重新檢查棧頂\n→ Function next() // 返回下一個整數\n    → Step 4: integer = stack.pop() // 取出棧頂整數\n    → return integer\nEnd // 程式結束\n\nBut each line must contain the virtual code step + comment. The above uses nested lines with arrow but some lines have \"→ Step 1: ...\". Then sublines also start with \"→ Step 1a:\" etc. This matches the format.\n\nNow we need to ensure each line ends with comment. Yes.\n\nLet's format accordingly with each line as separate.\n\nCheck: \"Start // 程式開始執行\" Good.\n\n\"→ Step 1: NestedIterator(nestedList) // 建構子，初始化迭代器\" Good.\n\nThen indent sub-steps:\n\n\"    → Step 1a: stack = 空棧 // 用於儲存待處理項目\"\n\nYes.\n\nSimilarly for other sub-steps.\n\nThe decision lines:\n\n\"    → Decision: stack 为空? // 棧空則沒有更多元素\"\n\nYes.\n\nNow the \"Yes → return False\" line: It should be \"        Yes → return False // 結束\" maybe.\n\nBut we need the format: arrow and comment. So \"Yes → return False // 棧空則沒有更多元素\" is okay.\n\nBut we need to indent properly: The \"Yes →\" is a step itself. Should we include arrow? The sample uses \"Yes →\" as part of the line. So we need to have \"Yes →\". So we need to put arrow before Yes. Let's adopt:\n\n\"        Yes → return False // 棧空則沒有更多元素\"\n\nYes.\n\nSimilarly for No lines.\n\nOk.\n\nThe \"Jump to Step 2\" line: we can write \"        → Jump to Step 2 // 重新檢查棧頂\". But we need \"→\" before. Actually \"Jump to Step 2\" is not a decision; it's a step. So we can write \"        → Jump to Step 2 // 重新檢查棧頂\".\n\nWe might need to maintain consistent indentation.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: NestedIterator(nestedList) // 建構子，初始化迭代器  \n    → Step 1a: stack = 空棧 // 用於儲存待處理項目  \n    → Step 1b: push(nestedList) // 把整個列表作為一個項目入棧  \n→ Function hasNext() // 判斷是否還有未處理的整數  \n    → Decision: stack 为空? // 棧空則沒有更多元素  \n        Yes → return False // 沒有下一個整數  \n        No  → Step 2: // 處理棧頂項目  \n            → Decision: stack.top() 是整數? // 棧頂是否為整數  \n                Yes → return True // 類型已是整數，可直接返回  \n                No  → Step 3: // 棧頂是列表  \n                    → Step 3a: list = stack.pop() // 取出列表  \n                    → Decision: list 非空? // 列表是否有元素  \n                        Yes → Step 3b: push all elements of list in reverse order // 逆序推入棧，保持順序  \n                        No  → // 空列表，直接忽略  \n                    → Jump to Step 2 // 重新檢查棧頂  \n→ Function next() // 返回下一個整數  \n    → Step 4: integer = stack.pop() // 取出棧頂整數  \n    → return integer  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    def __init__(self, nestedList):\n        # 初始化：將整個列表倒序放入棧中\n        self.stack = nestedList[::-1]\n\n    def next(self):\n        # 直接取棧頂的整數\n        return self.stack.pop()\n\n    def hasNext(self):\n        # 當棧不空時，檢查棧頂是否為整數\n        while self.stack:\n            top = self.stack[-1]\n            if isinstance(top, int):\n                return True\n            # 若不是整數，則將其展開並倒序加入棧中\n            self.stack.pop()\n            self.stack.extend(top[::-1])\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 若輸入帶有 'nestedList ='，去除前置文字\n    if data.startswith('nestedList'):\n        idx = data.find('=')\n        if idx != -1:\n            data = data[idx + 1:].strip()\n    # 安全解析輸入為 Python 資料結構\n    try:\n        nested_list = ast.literal_eval(data)\n    except Exception:\n        nested_list = eval(data)\n\n    it = NestedIterator(nested_list)\n    result = []\n    while it.hasNext():\n        result.append(it.next())\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1, 1, 2, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1, 4, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation. The requirement: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows and structure. Should reflect algorithm: iterate array, track current streak, max streak. Probably start with Start, Step: set max=0, current=0, iterate i from 0 to length-1, if nums[i]==1 then current++, else current=0. After each, update max. End.\n\nNeed to follow arrow notation: \"→ Step X: ...\" or \"→ Decision: ...\". Use \"Yes →\" \"No →\". Provide explanation after each line.\n\nShould be plain text lines. Let's construct:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxCount = 0, currentCount = 0 // 設定最大連續 1 的長度和當前連續 1 的長度\n→ Step 2: 取得 nums 的長度 len // 用於迴圈遍歷\n→ Decision: 若 len == 0? // 檢查陣列是否為空\n    Yes → Step 3: 回傳 0 // 空陣列直接回傳 0\n    No  → Step 4: 進入迴圈 for i = 0 到 len-1 // 遍歷所有元素\n        → Decision: nums[i] == 1? // 判斷當前元素是否為 1\n            Yes → Step 5: currentCount = currentCount + 1 // 連續 1 增加\n            No  → Step 6: currentCount = 0 // 遇到 0 重置當前計數\n        → Decision: currentCount > maxCount? // 比較更新最大值\n            Yes → Step 7: maxCount = currentCount // 更新最大連續 1 長度\n            No  → // 不做改變\n→ Step 8: 回傳 maxCount // 返回最終結果\nEnd // 程式執行結束\n\nCheck each line includes \"虛擬碼步驟\" plus \" // 解釋\". Must include arrow for decisions and steps. Each line must be separate. Use \"→\" at beginning of each step except maybe Decision lines. For Decision lines, \"→ Decision:\".\n\nNeed to ensure formatting: Each line \"虛擬碼步驟\" + space + \"// 解釋\". E.g.:\n\nStart // 程式開始執行\n→ Step 1: ... // ...\n\nYes, must include arrow \"→\". For decisions, \"→ Decision:\".\n\nAlso \"Yes →\" and \"No →\" lines inside decisions. They also need explanation comment.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxCount = 0, currentCount = 0 // 設定最大連續 1 的長度和當前連續 1 的長度\n→ Step 2: 取得 nums 的長度 len // 用於迴圈遍歷\n→ Decision: 若 len == 0? // 檢查陣列是否為空\n    Yes → Step 3: 回傳 0 // 空陣列直接回傳 0\n    No  → Step 4: 進入迴圈 for i = 0 到 len-1 // 遍歷所有元素\n        → Decision: nums[i] == 1? // 判斷當前元素是否為 1\n            Yes → Step 5: currentCount = currentCount + 1 // 連續 1 增加\n            No  → Step 6: currentCount = 0 // 遇到 0 重置當前計數\n        → Decision: currentCount > maxCount? // 比較更新最大值\n            Yes → Step 7: maxCount = currentCount // 更新最大連續 1 長度\n            No  → // 不做改變\n→ Step 8: 回傳 maxCount // 返回最終結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums):\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                if count > max_count:\n                    max_count = count\n            else:\n                count = 0\n        return max_count\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Remove possible leading 'nums = '\n    if data.startswith('nums'):\n        try:\n            _, _, rest = data.partition('=')\n            nums_str = rest.strip()\n        except ValueError:\n            nums_str = data\n    else:\n        nums_str = data\n    # Use literal_eval to safely parse the list\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # If parsing fails, assume empty list\n        nums = []\n    result = Solution().findMaxConsecutiveOnes(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation after each. The algorithm: to equalize array by incrementing n-1 elements by 1 is equivalent to decrementing one element by 1. So minimal moves is sum(nums) - n*min(nums). Steps: read array, find min, compute sum, compute moves, output. Let's produce. Use structure Start, Step lines, Decision, End. Probably no decision needed. We'll just produce steps.\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// 解釋\". Provide arrow for transitions.\n\nLet's produce lines:\n\nStart\n→ Step 1: 輸入陣列 nums // 取得輸入的整數陣列\n→ Step 2: 計算 n = 長度(nums) // 獲取陣列長度\n→ Step 3: 計算 total = sum(nums) // 求陣列元素總和\n→ Step 4: 計算 min_val = 最小值(nums) // 找到陣列中的最小值\n→ Step 5: 計算 moves = total - n * min_val // 透過減法得到最小移動次數\n→ Step 6: 輸出 moves // 將結果顯示給使用者\nEnd\n\nNeed to ensure format exactly. Use arrow → before each step. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums // 取得輸入的整數陣列  \n→ Step 2: 計算 n = 長度(nums) // 獲取陣列長度  \n→ Step 3: 計算 total = sum(nums) // 求陣列元素總和  \n→ Step 4: 計算 min_val = 最小值(nums) // 找到陣列中的最小值  \n→ Step 5: 計算 moves = total - n * min_val // 透過減法得到最小移動次數  \n→ Step 6: 輸出 moves // 將結果顯示給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minMoves(self, nums):\n        \"\"\"\n        計算將所有元素變成相同所需的最少步驟。\n        在一次移動中，可以把 n-1 個元素各自加 1，等價於把\n        其中一個元素減 1。最少步驟即為總和減去 n 倍的最小值。\n        \"\"\"\n        return sum(nums) - min(nums) * len(nums)\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析出陣列 nums，並輸出最少移動步數。\n    允許輸入類似於 'nums = [1,2,3]' 的格式，亦可處理多行輸入。\n    \"\"\"\n    # 讀取所有輸入資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從文字中擷取所有整數（含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # 計算並輸出結果\n    solution = Solution()\n    result = solution.minMoves(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. For implementing a stack with two queues. We need to output lines: each line has \"虛擬碼步驟 // 解釋\". Use arrows etc. We'll start with Start, define queues, push, pop, top, empty. Provide algorithm: use queue1 primary, queue2 temporary. For push: enqueue to q1. For pop: move all but last from q1 to q2, then dequeue last from q1 and return. Swap queues. For top: similar but after retrieving last, we need to push it to q2. Use decisions. Provide structure. We'll produce in Chinese. Let's craft.\n\nNeed to keep each line separated, use arrow \"→\". Provide decision steps. For example:\n\nStart // 程式開始\n\n→ 初始化 q1, q2 // 兩個空隊列\n\n→ Function: push(x) // 推入元素\n\n    → q1.Enqueue(x) // 加入後端\n\n→ Function: pop() // 取出頂部\n\n    → Decision: q1.isEmpty()? // 若空則錯誤\n\n        Yes → Return error\n\n        No  → While q1.size > 1\n\n            → temp = q1.Dequeue()\n\n            → q2.Enqueue(temp)\n\n        → topElement = q1.Dequeue() // 取最後一個\n\n        → Swap q1 and q2 // 重新設為主隊列\n\n        → Return topElement\n\n... etc.\n\nWe must follow the format. Provide all functions. We might have separate lines for each step. For decision we use indent. We'll produce a linear representation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Initialize q1, q2 // 兩個空隊列，q1 為主隊列  \n→ Function: push(x) // 推入元素到堆疊頂部  \n → q1.Enqueue(x) // 將 x 加入 q1 的尾端  \n\n→ Function: pop() // 從堆疊頂部取出元素並回傳  \n → Decision: 如果 q1.isEmpty()? // 判斷堆疊是否為空  \n  Yes → Return error // 若空則回傳錯誤值  \n  No  → While q1.size > 1 // 將 q1 除最後一個之外的元素全部轉移  \n    → temp = q1.Dequeue() // 從 q1 前端取出  \n    → q2.Enqueue(temp) // 將其放入 q2 的尾端  \n  → topElement = q1.Dequeue() // 取出最後一個元素，為堆疊頂部  \n  → Swap q1, q2 // 交換 q1 與 q2，使 q1 成為新的主隊列  \n  → Return topElement // 回傳剛剛取出的頂部元素  \n\n→ Function: top() // 回傳堆疊頂部元素但不移除  \n → Decision: 如果 q1.isEmpty()? // 判斷堆疊是否為空  \n  Yes → Return error // 若空則回傳錯誤值  \n  No  → While q1.size > 1 // 與 pop 類似將元素轉移  \n    → temp = q1.Dequeue()  \n    → q2.Enqueue(temp)  \n  → topElement = q1.Dequeue() // 取出最後一個元素  \n  → q2.Enqueue(topElement) // 再將它放回 q2，保持原順序  \n  → Swap q1, q2 // 交換，使 q1 再次為主隊列  \n  → Return topElement // 回傳頂部元素  \n\n→ Function: empty() // 判斷堆疊是否為空  \n → Return q1.isEmpty() // 若主隊列為空即堆疊為空  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        # 將新元素加入主隊列 q1 的尾端\n        self.q1.append(x)\n\n    def pop(self):\n        if not self.q1:\n            return None\n        # 把 q1 除最後一個外的所有元素轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 最後一個元素即為堆疊頂部\n        top = self.q1.popleft()\n        # 交換 q1 與 q2，使 q1 再次成為主隊列\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def top(self):\n        if not self.q1:\n            return None\n        # 把 q1 除最後一個外的所有元素轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # 取出頂部元素\n        top = self.q1.popleft()\n        # 再把頂部元素放回 q2，保持原順序\n        self.q2.append(top)\n        # 交換 q1 與 q2\n        self.q1, self.q2 = self.q2, self.q1\n        return top\n\n    def empty(self):\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式：[\"MyStack\", \"push\", ...], [[], [1], ...]\n    # 找出 '], [' 的分割點\n    split_point = data.find('], [')\n    if split_point == -1:\n        # 直接解析整體為兩個列表\n        ops, args = ast.literal_eval(data)\n    else:\n        ops_str = data[:split_point + 2]  # 包含前兩個括號\n        args_str = '[' + data[split_point + 3:]  # 加上左括號\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            results.append(None)  # null in LeetCode style\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpytjc1qzq.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmpytjc1qzq.py\", line 56, in main\n    ops = ast.literal_eval(ops_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 90, in _convert\n    return tuple(map(_convert, node.elts))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x71c0281fbb10>"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Task: Given integer n, return least number of perfect squares that sum to n. Classic problem: Number of squares, solution using BFS or DP or Lagrange's theorem. We need to produce step-by-step pseudocode, not actual code. Use Start, End, Decision: with arrows.\n\nWe need to output line by line. We must include \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows → and decisions. Provide the algorithm.\n\nWe can propose algorithm: BFS from 0 to n, subtract squares. Or DP: dp[0]=0; for i=1..n: dp[i]=min(dp[i - square] + 1). Use for each square <= i. Provide pseudocode accordingly.\n\nWe'll choose DP approach. Let's craft pseudocode:\n\nStart\n→ Initialize array dp[0..n] with Infinity // 用來記錄每個數的最小個數\n→ Set dp[0] = 0 // 0 需要 0 個平方數\n→ For i from 1 to n:\n    → Set minCount = Infinity\n    → For each square s = k*k where k^2 <= i:\n        → If dp[i - s] + 1 < minCount:\n            → minCount = dp[i - s] + 1\n    → dp[i] = minCount\n→ Return dp[n]\nEnd\n\nBut we need to use Decision: maybe check if square <= i. We'll include decision loops.\n\nWe need to format with arrows.\n\nLet's write step lines:\n\nStart // 程式開始執行\n→ 初始化 dp 陣列長度 n+1，所有值設為無窮大 // 用來存每個數字的最小平方數個數\n→ 設定 dp[0] = 0 // 0 需要 0 個平方數\n→ Decision: 是否已經處理完所有 i? // 循環 i 1~n\n    No  → Step: i = 1 // 開始處理第 1 個數\n    // Actually we need loop structure; use for loop style with decision.\n\nMaybe better:\n\n→ For i from 1 to n: // 依序處理每個目標數\n    → Step: minCount = Infinity // 先設定目前 i 的最小個數為無窮大\n    → For k from 1 while k*k <= i: // 產生所有可用的平方數\n        → Set square = k*k\n        → Decision: dp[i - square] + 1 < minCount?\n            Yes → minCount = dp[i - square] + 1 // 更新最小個數\n            No  → // 不更新\n    → dp[i] = minCount // 把最小個數存回 dp\n→ End // 循環結束\n→ Return dp[n] // 回傳結果\n\nNeed to format with arrows and decisions.\n\nWe need each line as \"虛擬碼步驟 // 解釋\". Let's craft.\n\nAlso we need Start, End markers.\n\nLet's produce:\n\nStart // 程式開始執行\n→ 初始化 dp[0..n] 為 Infinity // 記錄每個數所需最少平方數\n→ 設定 dp[0] = 0 // 0 需要 0 個平方數\n→ For i = 1 to n:\n    → 設定 minCount = Infinity // 初始化 i 的最小個數\n    → For k = 1 while k*k <= i:\n        → 計算 square = k*k // 取得當前平方數\n        → Decision: dp[i - square] + 1 < minCount?\n            Yes → minCount = dp[i - square] + 1 // 更新最小個數\n            No  → // 保持原值\n    → dp[i] = minCount // 存入最小個數\n→ End // 完成所有計算\n→ Return dp[n] // 輸出結果\n\nWe need to ensure arrow formatting. Use \"→\". Indent or just keep as lines.\n\nAlso we need to label decisions properly. Use \"Decision: ...\" then Yes →, No →.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 dp[0..n] 為 Infinity // 記錄每個數所需最少平方數  \n→ 設定 dp[0] = 0 // 0 需要 0 個平方數  \n→ For i = 1 to n: // 逐個處理目標數  \n → 設定 minCount = Infinity // 初始化 i 的最小個數  \n → For k = 1 while k*k <= i: // 產生所有可用的平方數  \n  → 計算 square = k*k // 取得當前平方數  \n  → Decision: dp[i - square] + 1 < minCount? // 檢查是否能減少個數  \n   Yes → minCount = dp[i - square] + 1 // 更新最小個數  \n   No  → // 保持原值  \n → dp[i] = minCount // 存入 i 的最小個數  \n→ End // 完成所有計算  \n→ Return dp[n] // 輸出 n 所需的最少平方數個數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        \"\"\"Return the least number of perfect square numbers that sum to n.\"\"\"\n        # dp[i] represents the minimal count of perfect squares summing to i\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n\n        for i in range(1, n + 1):\n            j = 1\n            while j * j <= i:\n                square = j * j\n                dp[i] = min(dp[i], dp[i - square] + 1)\n                j += 1\n\n        return dp[n]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin and extract the first integer value\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        sys.exit(0)  # No integer found, nothing to do\n    n = int(numbers[0])\n\n    solution = Solution()\n    result = solution.numSquares(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem, step by step, following format. It's typical Leetcode 330 problem \"Patching Array\". Need to explain algorithm: greedy: maintain coverage up to current reachable sum, start with 0; iterate until coverage >= n. While current coverage + 1 <= n, if next number in array <= coverage+1, add it to coverage; else patch with coverage+1. Count patches. We'll produce lines with \"Start\", \"Decision\", etc.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrows →. We can include loops, conditions, increments.\n\nLet's craft steps:\n\nStart\n→ Initialize idx = 0, patches = 0, currentCoverage = 0 // set pointers and counters\n→ While currentCoverage < n // need more coverage\n    → Decision: if idx < nums.length AND nums[idx] <= currentCoverage + 1 // next number can be used\n        Yes → currentCoverage += nums[idx] // extend coverage\n        idx += 1 // move to next element\n        No → currentCoverage += currentCoverage + 1 // patch with missing number\n        patches += 1 // record a patch\nEnd\n\nWe need to ensure virtual code lines include each arrow. Use indentation for nested.\n\nMake sure each line ends with comment. Provide explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ idx = 0, patches = 0, currentCoverage = 0 // 初始化索引、補丁計數與已覆蓋範圍  \n→ While currentCoverage < n // 只要還沒覆蓋到 n 就繼續  \n    → Decision: idx < nums.length AND nums[idx] <= currentCoverage + 1 // 下一個已排序元素是否可直接使用  \n        Yes → currentCoverage += nums[idx] // 加入該元素擴大覆蓋範圍  \n        → idx += 1 // 進到下一個數字  \n        No → currentCoverage += currentCoverage + 1 // 補丁：使用最小缺口 (currentCoverage+1)  \n        → patches += 1 // 記錄已新增補丁  \nEnd // 程式執行結束，回傳 patches 的最小數量",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minPatches(self, nums, n):\n        patches = 0\n        miss = 1          # the smallest sum that cannot be formed yet\n        i = 0\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss          # patch with the smallest missing number\n                patches += 1\n        return patches\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract nums list and n value from input like: \"nums = [1,3], n = 6\"\n    match = re.search(r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*n\\s*=\\s*(-?\\d+)', data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums_str, n_str = match.group(1), match.group(2)\n    nums = eval(nums_str)   # safe because input is controlled in the judge environment\n    n = int(n_str)\n\n    solution = Solution()\n    result = solution.minPatches(nums, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for topological sorting problem. Provide step-by-step pseudocode with explanations. Use Start, End, Decision, arrows, etc.\n\nWe need to produce per line: \"虛擬碼步驟 // 解釋\". For loops and conditionals use Decision, Yes →, No →.\n\nWe need to ensure we cover reading inputs, building graph, in-degree array, queue, processing, cycle detection.\n\nWe'll produce lines such as:\n\nStart // 程式開始執行\n→ Step 1: 建立 adjacency list for numCourses // 產生鄰接表\n→ Step 2: 初始化 inDegree 陣列為 0 // 計算入度\n\nThen for each prereq pair: (a,b). Add a to adjacency list of b. Increment inDegree[a].\n\nThen queue all courses with inDegree==0.\n\nThen while queue not empty: pop, add to result, for each neighbor, decrement inDegree, if becomes 0, enqueue.\n\nAfter loop, if result size == numCourses return result else return empty.\n\nAlso provide decision nodes for cycle detection: after loop, Decision: 是否所有課程都已安排? etc.\n\nNeed to produce virtual code lines with arrows.\n\nWe need to use \"Yes →\" and \"No →\" where relevant.\n\nMake sure each line ends with \"// 解釋\".\n\nMake use of indentations? The example shows indent levels. We'll produce similar indentation.\n\nWe also need to handle \"Return\" lines.\n\nWe should produce a full flow.\n\nLet's outline:\n\nStart // 程式開始執行\n→ Step 1: 建立 adjacency list G 為 empty list array of size numCourses // 初始化圖\n→ Step 2: 建立 inDegree 陣列長度 numCourses 且全為 0 // 用於計算入度\n\n→ Step 3: 對於 prerequisites 中每一對 (a, b): // 讀取前置課程\n    → Add a 到 G[b] // b 之後可以修 a\n    → inDegree[a] += 1 // a 的入度加一\n\n→ Step 4: 建立 queue 空列 // 用於儲存入度為 0 的課程\n→ Decision: 是否有課程入度為 0?\n    Yes → For 每個課程 i if inDegree[i]==0:\n        → Enqueue i // 將入度為 0 的課程加入佇列\n    No  → // 這種情況會在後續檢查\n\n→ Step 5: 建立 result list // 存儲課程排序\n→ Decision: 佇列是否非空?\n    Yes → 循環:\n        → Dequeue cur // 取出佇列首項\n        → Append cur 到 result // 加入結果\n        → 對於 G[cur] 中的每個 neighbor:\n            → inDegree[neighbor] -= 1 // 入度減一\n            → Decision: inDegree[neighbor]==0?\n                Yes → Enqueue neighbor // 入度為 0 的加入佇列\n                No  → // 仍有其他前置課程\n    No  → // 佇列已空，結束循環\n\n→ Step 6: Decision: result.size == numCourses?\n    Yes → Return result // 成功取得拓撲排序\n    No  → Return empty list // 無法完成所有課程，存在循環\n\nEnd // 程式執行結束\n\nBut we need to incorporate loops in pseudocode. Use \"While\" loops. Example: \"While queue not empty:\" then inside.\n\nLet's refine with pseudocode:\n\nStart // 程式開始執行\n→ Step 1: G ← ArrayList of List(numCourses) // 建立鄰接表\n→ Step 2: inDegree ← Array(numCourses) with 0 // 入度計數\n\n→ Step 3: For each pair [a,b] in prerequisites:\n    → G[b].add(a) // b → a\n    → inDegree[a] += 1 // a 的入度加一\n\n→ Step 4: queue ← empty queue\n→ Decision: 是否有入度為0的課程?\n    Yes → For i in 0..numCourses-1:\n        → Decision: inDegree[i] == 0?\n            Yes → queue.enqueue(i) // 加入佇列\n            No  → // 跳過\n    No  → // 佇列保持空\n\n→ Step 5: result ← empty list\n→ Decision: queue.isEmpty()?\n    No → While queue not empty:\n        → cur ← queue.dequeue()\n        → result.add(cur)\n        → For each neighbor in G[cur]:\n            → inDegree[neighbor] -= 1\n            → Decision: inDegree[neighbor] == 0?\n                Yes → queue.enqueue(neighbor)\n                No  → // 未就緒\n    Yes → // queue 空，直接結束\n\n→ Step 6: Decision: result.size == numCourses?\n    Yes → Return result // 有效順序\n    No  → Return [] // 無法完成\n\nEnd // 程式結束\n\nWe need to include arrow lines like \"→ Step ...\".\n\nAlso indent Decision blocks. Example formatting:\n\n→ Decision: 入度為0的課程存在?\n    Yes → For i ...\n    No  → // 佇列保持空\n\nAnd inside For loops we might indent further.\n\nThe example used indentation: \"→ Decision: ...\", then lines starting with \"Yes →\" or \"No  →\".\n\nWe need to produce consistent indent. Use spaces. We'll produce e.g.:\n\n→ Step 1: G ← ArrayList of List(numCourses) // 建立鄰接表\n\nUse \"Step\" for assignment.\n\nUse \"Decision:\" for if statements.\n\nAlso include \"While\" loops as \"While queue not empty:\" but we can keep as \"While queue not empty:\" but it's not specified. We can treat while as a step.\n\nBut the requirement: Use virtual code's arrow and structure: Start, End, Decision: etc. It didn't mention While explicitly, but we can use it as Step.\n\nWe could do:\n\n→ Step 5: While queue not empty: // 只要佇列非空，就持續處理\n\nBut maybe better to treat as Step 5: Start processing loop. Then inside Decision: queue.isEmpty()? etc.\n\nAlternatively we can use \"Decision: queue is empty?\" with Yes and No branch.\n\nLet's keep simpler: Use Decision: queue is empty? No -> process.\n\nWe'll produce:\n\n→ Decision: queue.isEmpty()?\n    No → While queue not empty:\n        → cur ← queue.dequeue()\n        → result.add(cur)\n        → For each neighbor in G[cur]:\n            → inDegree[neighbor] -= 1\n            → Decision: inDegree[neighbor] == 0?\n                Yes → queue.enqueue(neighbor)\n                No  → // 仍有前置課程\n\nBut inside While we might indent more.\n\nWe also need to treat For loops as Step.\n\nThe sample didn't show For loops but they used Step. We can embed For loops inside Step with indent.\n\nLet's produce:\n\n→ Step 5: 處理佇列中的課程\n    → Decision: queue.isEmpty()?\n        No  → While queue not empty:\n            → cur ← queue.dequeue()\n            → result.add(cur)\n            → For each neighbor in G[cur]:\n                → inDegree[neighbor] -= 1\n                → Decision: inDegree[neighbor] == 0?\n                    Yes → queue.enqueue(neighbor)\n                    No  → // 仍有前置課程\n        Yes → // 佇列已空，結束\n\nYes.\n\nOk.\n\nFinally output End.\n\nNow produce lines.\n\nWe must ensure each line includes a single space after code and before //.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: G ← ArrayList of List(numCourses) // 建立鄰接表，儲存每門課的後續課程  \n→ Step 2: inDegree ← Array(numCourses) with 0 // 建立入度計數器，初始皆為 0  \n\n→ Step 3: For each pair [a,b] in prerequisites: // 讀取前置課程  \n    → G[b].add(a) // 從 b 連向 a，表示 b 必先修  \n    → inDegree[a] += 1 // a 的入度加一  \n\n→ Step 4: queue ← empty queue // 用於存放入度為 0 的課程  \n→ Decision: 有無入度為 0 的課程?  \n    Yes → For i in 0 .. numCourses-1:  \n        → Decision: inDegree[i] == 0?  \n            Yes → queue.enqueue(i) // 入度為 0 的課程加入佇列  \n            No  → // 跳過  \n\n→ Step 5: result ← empty list // 儲存最終課程排序  \n    → Decision: queue.isEmpty()?  \n        No  → While queue not empty:  \n            → cur ← queue.dequeue() // 取出佇列首項  \n            → result.add(cur) // 加入結果  \n            → For each neighbor in G[cur]:  \n                → inDegree[neighbor] -= 1 // 入度減一  \n                → Decision: inDegree[neighbor] == 0?  \n                    Yes → queue.enqueue(neighbor) // 入度為 0 時加入佇列  \n                    No  → // 仍有未滿足的前置課程  \n        Yes → // 佇列已空，處理結束  \n\n→ Step 6: Decision: result.size == numCourses?  \n    Yes → Return result // 成功取得拓撲排序  \n    No  → Return [] // 仍存在循環，無法完成所有課程  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        \n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n        \n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n        \n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return order if len(order) == numCourses else []\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(num_match.group(1)) if num_match else 0\n    prereq_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data, re.S)\n    prerequisites = eval(prereq_match.group(1), {}) if prereq_match else []\n\n    sol = Solution()\n    order = sol.findOrder(numCourses, prerequisites)\n    print(order)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "success": true,
          "output": "[0, 1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Need to use arrows Start, End, Decision. Use no real code. We need to produce the algorithm: find longest palindromic subsequence length in string s. Use dynamic programming.\n\nSo steps: Start, Input s, define n = length of s, create 2D array dp[n][n], initialize dp[i][i] = 1. For substrings of length 2..n: loop i from n-1 downto 0, j from i+1 to n-1: if s[i]==s[j] then dp[i][j] = dp[i+1][j-1]+2 else dp[i][j] = max(dp[i+1][j], dp[i][j-1]). Finally output dp[0][n-1]. End.\n\nWe need to express as virtual steps with arrow. Each line: \"→ Step X: ...\" followed by // explanation. Use arrow and maybe Decision lines? Not necessary, but can incorporate decisions.\n\nWe need to output each line.\n\nLet's craft steps:\n\nStart\n→ Step 1: Read string s // 获得输入字符串\n→ Step 2: Set n = length of s // 计算字符串长度\n→ Step 3: Create 2D array dp[n][n] // 用于存储子问题答案\n→ Decision: 任何 i = 0..n-1? // 初始化单字符回文\n    Yes → Step 4: For each i, set dp[i][i] = 1 // 单字符本身为回文长度1\n→ Step 5: For len from 2 to n // 处理子串长度\n    → Decision: len <= n? // 确保长度范围\n        Yes → Step 6: For i from 0 to n-len // 子串起始位置\n            → Step 7: Let j = i + len - 1 // 子串结束位置\n            → Decision: s[i] == s[j]? // 比较首尾字符\n                Yes → Step 8: If i+1 > j-1? // 处理长度2的情况\n                        Yes → Step 9: dp[i][j] = 2 // 两字符相同，长度为2\n                        No  → Step 10: dp[i][j] = dp[i+1][j-1] + 2 // 中间子串+2\n                No  → Step 11: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取较大子问题\n→ Step 12: Output dp[0][n-1] // 结果为整个字符串的最长回文子序列长度\nEnd\n\nWe must ensure each line is in format: \"虛擬碼步驟 // 解釋\". So we need to start with Start. Then each line prefixed by arrow etc.\n\nWe can combine decisions inside indent. Use indentation with tabs? But not needed, but show indentation maybe with spaces.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s // 取得使用者輸入的字串  \n→ Step 2: 設定 n = s.length // 取得字串長度  \n→ Step 3: 建立 2D 陣列 dp[n][n] // 用來存放子問題答案  \n→ Decision: 是否有 i 取值 0~n-1? // 初始化單字符回文  \n  Yes → Step 4: 對每個 i, 設 dp[i][i] = 1 // 單個字符本身即為回文，長度為 1  \n→ Step 5: 依子串長度 len 從 2 到 n 逐一處理 // 以 DP 填表  \n  → Decision: len ≤ n? // 確保長度在合法範圍  \n   Yes → Step 6: 對 i 從 0 到 n-len 迭代 // 子串起始位置  \n    → Step 7: 設定 j = i + len - 1 // 子串結束位置  \n    → Decision: s[i] == s[j]? // 比較首尾字符是否相同  \n     Yes → Step 8: 若 i+1 > j-1? // 子串長度為 2 時的特例  \n       Yes → Step 9: dp[i][j] = 2 // 兩字符相同，長度直接為 2  \n      No → Step 10: dp[i][j] = dp[i+1][j-1] + 2 // 加上中間子序列長度  \n     No → Step 11: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取較大的子問題答案  \n→ Step 12: 輸出 dp[0][n-1] // 最長回文子序列長度為整個字串的答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    # 若兩端相同，兩端各加 1，再加上中間子序列\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    # 取刪除左端或右端的較大回文長度\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，取第一行作為字串\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # 取第一行\n    s = raw_input.splitlines()[0].strip()\n    # 去除可能存在的單雙引號\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n    sol = Solution()\n    result = sol.longestPalindromeSubseq(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding median of two sorted arrays using binary search with O(log(m+n)). Provide step-by-step lines with explanations. Use Start, End, Decision. Use arrows. Provide each line. No actual code. Let's produce the algorithm.\n\nOutline: We want to find median of two sorted arrays using binary search on the smaller array. Steps:\n\n- Ensure nums1 is smaller array, else swap.\n- Set m, n sizes.\n- Set imin = 0, imax = m, halfLen = (m+n+1)/2.\n- While imin <= imax:\n    i = (imin+imax)/2\n    j = halfLen - i\n    If i < m and nums2[j-1] > nums1[i] → i too small, increase imin.\n    Else if i > 0 and nums1[i-1] > nums2[j] → i too big, decrease imax.\n    Else: i is perfect:\n        maxLeft = if i==0 then nums2[j-1] else if j==0 then nums1[i-1] else max(nums1[i-1], nums2[j-1])\n        If (m+n) is odd → median = maxLeft\n        Else:\n            minRight = if i==m then nums2[j] else if j==n then nums1[i] else min(nums1[i], nums2[j])\n            median = (maxLeft + minRight)/2\n        return median\n\nThat's the algorithm.\n\nWe'll produce pseudocode line by line. Use Start, End, Decision. Use arrows. Provide explanation comments. Use Chinese.\n\nWe need each line with virtual code and comment. Let's produce.\n\nLet's number lines implicitly with arrow. Each line can have indentation to show nested decisions.\n\nWe need to represent decisions with \"Decision:\" lines. Use indentation.\n\nExample format:\n\nStart // 程式開始\n→ Step 1: ... // Explanation\n\nIf using nested decisions, show indentation.\n\nWe must ensure no actual code syntax like brackets, but we can use pseudo-code style like \"if\" but still fine.\n\nLet's produce.\n\nWe will not use actual code but we can write \"If i < m and nums2[j-1] > nums1[i]\" as a decision.\n\nOk. Let's produce.\n\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 取得兩個陣列 nums1, nums2 以及其長度 m, n // 讀取輸入\n\n→ Decision: 如果 m > n? // 確保 nums1 為較短陣列\n    Yes → Step 2: 交換 nums1 與 nums2, 同時交換 m 與 n // 使搜尋範圍最小化\n    No  → Step 2: 保持原陣列不變\n\n→ Step 3: 設定 imin = 0, imax = m, halfLen = (m + n + 1) / 2 // 準備二分搜尋\n\n→ While imin <= imax: // 開始二分搜尋迴圈\n    → Step 4: i = (imin + imax) / 2 // i 為 nums1 的分割點\n    → Step 5: j = halfLen - i // j 為 nums2 的分割點\n\n    → Decision: 如果 i < m 且 nums2[j-1] > nums1[i]? // i 太小，需要往右移\n        Yes → Step 6: imin = i + 1 // 調整搜尋區間\n        No  → Decision: 如果 i > 0 且 nums1[i-1] > nums2[j]? // i 太大，需要往左移\n            Yes → Step 7: imax = i - 1 // 調整搜尋區間\n            No  → Step 8: // i 已經是合適的分割點\n\n            → Step 9: maxLeft = if i == 0 then nums2[j-1] else if j == 0 then nums1[i-1] else max(nums1[i-1], nums2[j-1]) // 左半邊最大的值\n            → Decision: 如果 (m + n) 是奇數? // 判斷總長度奇偶\n                Yes → Step 10: median = maxLeft // 奇數時中位數即左邊最大值\n                No  → Step 11: minRight = if i == m then nums2[j] else if j == n then nums1[i] else min(nums1[i], nums2[j]) // 右半邊最小值\n                        → Step 12: median = (maxLeft + minRight) / 2 // 偶數時取平均\n\n            → Step 13: return median // 找到中位數後結束\n\n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        Find median of two sorted arrays in O(log(m+n)) time.\n        \"\"\"\n        # Make nums1 the shorter array to minimize binary search range\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n        while imin <= imax:\n            i = (imin + imax) // 2\n            j = half_len - i\n\n            # Check if i is too small; need to move right\n            if i < m and j > 0 and nums2[j - 1] > nums1[i]:\n                imin = i + 1\n            # Check if i is too big; need to move left\n            elif i > 0 and j < n and nums1[i - 1] > nums2[j]:\n                imax = i - 1\n            else:\n                # i is perfect; compute max of left side\n                if i == 0:\n                    max_left = nums2[j - 1]\n                elif j == 0:\n                    max_left = nums1[i - 1]\n                else:\n                    max_left = max(nums1[i - 1], nums2[j - 1])\n\n                # If total length is odd, median is max_left\n                if (m + n) % 2 == 1:\n                    return float(max_left)\n\n                # Compute min of right side\n                if i == m:\n                    min_right = nums2[j]\n                elif j == n:\n                    min_right = nums1[i]\n                else:\n                    min_right = min(nums1[i], nums2[j])\n\n                return (max_left + min_right) / 2.0\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read()\n    # Find the two lists in the input\n    lists = re.findall(r'\\[([^\\]]*)\\]', data)\n    if len(lists) != 2:\n        raise ValueError(\"Input must contain two list definitions.\")\n    # Convert found strings to integer lists\n    nums1 = [int(x) for x in re.findall(r'-?\\d+', lists[0])]\n    nums2 = [int(x) for x in re.findall(r'-?\\d+', lists[1])]\n\n    solution = Solution()\n    median = solution.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": true,
          "output": "2.00000"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for bitwise AND of all numbers in range [left,right]. Classic problem: find common prefix bits. Steps: While left<right, shift right one bit right, left one bit right; count shifts. Then result = left << shifts. Or directly compute: result = left & right; while result!= (left & (result-1))? But standard approach: find highest common bits. Implementation:\n\nStart\n→ Step: Initialize shift=0\n→ Decision: while left < right\n    Yes → Step: right = right >> 1; left = left >> 1; shift = shift + 1\n    No → end loop\n→ Step: result = left << shift\n→ Step: return result\nEnd\n\nExplain each line. Use virtual code with arrow. Ensure each line includes explanation after comment.\n\nAlso maybe include Start and End. Use \"Decision: left < right?\" as decision block.\n\nLet's produce each line.\n\nNeed to adhere to format: each line: virtual code step [space] // explanation\n\nWe can use \"Start\" line, \"End\" line. Indent decisions. Provide arrow and decision with Yes/No.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: left ← input_left // 取得左端數值\n→ Step 2: right ← input_right // 取得右端數值\n→ Step 3: shift ← 0 // 初始化右移計數器\n→ Decision: left < right? // 判斷範圍是否仍有多於一個數字\n    Yes → Step 4: right ← right >> 1 // 將右端右移一位\n    Yes → Step 5: left ← left >> 1 // 將左端右移一位\n    Yes → Step 6: shift ← shift + 1 // 記錄已右移位數\n    No  → // 退出循環，左端與右端已相等\n→ Step 7: result ← left << shift // 將共同前綴左移回原位置\n→ Step 8: return result // 回傳區間的位元 AND\nEnd // 程式執行結束\n\nBut need each line separate. Indentation: use spaces maybe.\n\nHowever we need to include decision block lines with Yes and No. The format example used indent under Decision and Yes/No lines. Let's mimic:\n\nStart // ...\n→ Step 1: ...\n...\n→ Decision: left < right? // ...\n    Yes → Step 4: ...\n    Yes → Step 5: ...\n    Yes → Step 6: ...\n    No  → // ...\n\nNeed to make sure each line is separate. Provide comments for each.\n\nAlso maybe include reading inputs lines. It's fine.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← input_left // 取得左端數值  \n→ Step 2: right ← input_right // 取得右端數值  \n→ Step 3: shift ← 0 // 初始化右移計數器  \n→ Decision: left < right? // 判斷範圍內還有多個數字  \n    Yes → Step 4: right ← right >> 1 // 右端數右移一位  \n    Yes → Step 5: left ← left >> 1 // 左端數右移一位  \n    Yes → Step 6: shift ← shift + 1 // 記錄已右移的位數  \n    No  → // 退出循環，左端與右端相等  \n→ Step 7: result ← left << shift // 把共同前綴左移回原位置  \n→ Step 8: return result // 回傳區間的位元 AND  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef range_bitwise_and(left: int, right: int) -> int:\n    \"\"\"Return bitwise AND of all numbers in [left, right].\"\"\"\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n\ndef main() -> None:\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    left, right = nums[0], nums[1]\n    result = range_bitwise_and(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for computing nth super ugly number given n and array primes. We need to output step-by-step pseudocode lines with \"虛擬碼步驟 // 解釋\". Use arrow syntax. Should be in Chinese. Provide algorithm. Typically we use DP with pointers method. Steps: initialize ugly[1] = 1, pointers index for each prime. For i from 2 to n: compute next_ugly = min(primes[j]*ugly[pointers[j]]) for all j. Ugly[i] = next_ugly. For each j where primes[j]*ugly[pointers[j]] == next_ugly, increment pointers[j]. Finally output ugly[n]. So produce pseudocode. Use \"Start\" and \"End\". Use decisions. So each line must contain arrow. We need to incorporate decision nodes for loop, min, etc. Provide explanation for each. Let's produce lines:\n\nStart // 程式開始\n\n→ Step 1: Input n, primes array // 取得輸入\n\n→ Step 2: Let k = length of primes // 取得素數個數\n\n→ Step 3: Initialize ugly array of size n+1 with ugly[1] = 1 // 產生超醜數序列\n\n→ Step 4: Initialize idx array of size k with all 0 // 指標指向ugly數列的起始\n\n→ Step 5: For i = 2 to n loop // 逐一計算第 i 個超醜數\n\n    → Decision: Compute candidate list // 取得所有候選值\n\n        Yes → Step 5.1: For each j in 0..k-1: candidate[j] = primes[j] * ugly[idx[j]] // 生成候選\n\n    → Step 5.2: next_ugly = min(candidate) // 找出最小候選\n\n    → Step 5.3: ugly[i] = next_ugly // 記錄\n\n    → Decision: For each j in 0..k-1: if candidate[j] == next_ugly then idx[j]++ // 更新指標\n\nEnd // 程式結束\n\n→ Step 6: Output ugly[n] // 回傳結果\n\nBut need to follow format: each line separate. Use arrow \"→\" at each step. Need to show decisions with Yes/No. Could embed loops as steps.\n\nLet's format carefully. Use Chinese explanations. Each line: \"虛擬碼步驟 // 解釋\". Example: \"Start // 程式開始\". Then \"→ Step 1: 輸入 n, primes // 取得輸入\". And so on.\n\nMake sure to use \"Decision:\" lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 輸入整數 n 與素數陣列 primes // 取得輸入參數\n→ Step 2: 設 k ← primes.length // 紀錄素數個數\n→ Step 3: 建立長度為 n+1 的陣列 ugly，並設定 ugly[1] ← 1 // 超醜數列的第一項\n→ Step 4: 建立長度為 k 的指標陣列 idx，所有元素初始化為 0 // 每個素數的候選指標\n→ Step 5: 從 i ← 2 到 n 進行迴圈 // 逐一計算第 i 個超醜數\n    → Decision: 生成所有候選值 // 取得每個素數乘以對應指標所指的 ugly\n        Yes → Step 5.1: 對每個 j 從 0 到 k-1，計算 candidate[j] ← primes[j] × ugly[idx[j]] // 產生候選\n    → Step 5.2: next_ugly ← min(candidate) // 取最小候選值\n    → Step 5.3: ugly[i] ← next_ugly // 將最小值寫入 ugly 列表\n    → Decision: 更新所有與 next_ugly 相等的候選指標 // 防止重複\n        Yes → Step 5.4: 對每個 j 從 0 到 k-1，若 candidate[j] = next_ugly，則 idx[j] ← idx[j] + 1 // 指標前移\n→ Step 6: 輸出 ugly[n] // 回傳第 n 個超醜數\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthSuperUglyNumber(self, n, primes):\n        ugly = [1]\n        indices = [0] * len(primes)\n        vals = list(primes)\n\n        for _ in range(1, n):\n            next_ugly = min(vals)\n            ugly.append(next_ugly)\n\n            for i in range(len(primes)):\n                if vals[i] == next_ugly:\n                    indices[i] += 1\n                    vals[i] = ugly[indices[i]] * primes[i]\n\n        return ugly[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r\"-?\\d+\", data)))\n    if not nums:\n        sys.exit()\n    n = nums[0]\n    primes = nums[1:]\n    solution = Solution()\n    result = solution.nthSuperUglyNumber(n, primes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for the problem: Given array nums of n ints 1..n, find missing numbers. We need to output line-by-line virtual code with explanation. Virtual code uses arrows, decisions, etc.\n\nWe need to produce steps. Probably algorithm: Use a hash set or bitset or marking. A known solution: mark presence by negative marking: for each num, mark index abs(num)-1 as negative. Then iterate to collect positive indices+1.\n\nSo pseudocode: Start, input nums, n = length. For each num in nums: idx = abs(num)-1; nums[idx] = -abs(nums[idx]). Then result = empty. For i=0..n-1: if nums[i] > 0: add i+1. End. Output result.\n\nWe must follow the specified output format: Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow lines. For decision steps: maybe no decision needed. But we might include a decision for checking positivity.\n\nWe can include Start, End.\n\nWe need to output line by line, with arrow. Let's produce:\n\nStart\n→ Step 1: Set n = length(nums) // 獲取陣列長度\n→ Step 2: For each num in nums // 逐一處理每個元素\n    → Step 2a: idx = abs(num) - 1 // 將數值映射到索引\n    → Step 2b: nums[idx] = -abs(nums[idx]) // 標記索引已出現\n→ Step 3: result = [] // 初始化結果空陣列\n→ Step 4: For i = 0 to n-1 // 再次遍歷索引\n    → Decision: 如果 nums[i] > 0? // 判斷是否未被標記\n        Yes → Step 4a: result.append(i + 1) // 將未出現的數加入結果\n→ End // 結束\n\nBut they want each line with \"虛擬碼步驟\" maybe like \"→ Step 1: ...\" etc. Use arrows for decisions and substeps. Use indentation or separate lines.\n\nWe need to ensure each line ends with // 解釋/說明. Use proper punctuation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度 n  \n→ Step 2: For each num in nums // 逐一處理每個元素  \n  → Step 2a: idx ← abs(num) - 1 // 將數值映射到對應索引  \n  → Step 2b: nums[idx] ← -abs(nums[idx]) // 用負號標記該索引已出現  \n→ Step 3: result ← [] // 初始化結果空陣列  \n→ Step 4: For i ← 0 to n-1 // 再次遍歷所有索引  \n  → Decision: 如果 nums[i] > 0? // 判斷該索引是否未被標記  \n   Yes → Step 4a: result.append(i + 1) // 將未出現的數字加入結果  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef findDisappearedNumbers(nums):\n    n = len(nums)\n    for num in nums:\n        idx = abs(num) - 1\n        nums[idx] = -abs(nums[idx])\n    return [i + 1 for i in range(n) if nums[i] > 0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入中的列表提取出來\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        list_str = data[start:end+1]\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n        if not isinstance(nums, list):\n            nums = []\n    except Exception:\n        nums = []\n\n    result = findDisappearedNumbers(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code (flowchart style) that converts non-negative integer to English words. Provide line by line. No actual code. Just virtual code steps. Need explanation each line.\n\nLet's think: Steps: Start, define arrays for ones, teens, tens, thousands, etc. Then if num==0, output \"Zero\". Else, split number into chunks of 3 digits. For each chunk from highest to lowest, convert to words with hundreds, tens, ones. Build result. Finally output.\n\nSo we need decision nodes: if num == 0, Yes -> output \"Zero\". No -> proceed.\n\nThen maybe loop over chunks: while num > 0: get chunk = num % 1000; prepend to words if chunk >0; etc.\n\nBut virtual code line by line: maybe like:\n\nStart\n→ Decision: num == 0?\n    Yes → Output \"Zero\"\n    No → Step: Initialize result = \"\"\n    Step: Define arrays: ones, teens, tens, thousands\n\n→ While num > 0:\n    Step: chunk = num mod 1000\n    Step: num = num / 1000\n    Step: if chunk > 0:\n        Step: words_chunk = convertChunk(chunk)\n        Step: if result != \"\": result = words_chunk + \" \" + thousand[i] + \" \" + result\n        else: result = words_chunk + \" \" + thousand[i]\n    Step: i += 1\n\n→ Output result\nEnd\n\nDefine convertChunk(chunk):\n    Step: if chunk == 0: return \"\"\n    Step: word = \"\"\n    Step: hundreds = chunk / 100\n    Step: remainder = chunk % 100\n    Step: if hundreds > 0: word += ones[hundreds] + \" Hundred\"\n    Step: if remainder > 0:\n        Step: if remainder < 10: word += ones[remainder]\n        Step: else if remainder < 20: word += teens[remainder-10]\n        Step: else:\n            tens = remainder / 10\n            ones_digit = remainder % 10\n            word += tensWord[tens]\n            if ones_digit > 0: word += \" \" + ones[ones_digit]\n    Step: return word\n\nWe need to produce virtual code line by line. Each line: \"Step:\" or \"Decision:\" or \"Yes →\" etc. Use arrows. Provide explanation.\n\nMake sure each line includes step and comment.\n\nWe should produce a single flowchart of the algorithm. Might need to indent decisions.\n\nLet's produce.\n\nStart\n→ Decision: num == 0? // 檢查數字是否為 0\n    Yes → Output \"Zero\" // 若為 0，直接輸出\n    No  → Step 1: result ← \"\" // 初始化結果字串\n    No  → Step 2: i ← 0 // 記錄千級位\n    No  → Step 3: Define arrays: ones, teens, tens, thousands // 定義單位字串\n→ While num > 0? // 仍有位數未處理\n    Yes → Step 4: chunk ← num mod 1000 // 取最低三位\n    Yes → Step 5: num ← num / 1000 // 去除已處理三位\n    Yes → Decision: chunk > 0? // 這段是否需要轉換\n        Yes → Step 6: words_chunk ← convertChunk(chunk) // 將三位數轉成英文\n        Yes → Decision: result ≠ \"\"? // 是否已有前面的字串\n            Yes → Step 7: result ← words_chunk + \" \" + thousands[i] + \" \" + result // 加上千級後拼接\n            No  → Step 7: result ← words_chunk + \" \" + thousands[i] // 第一次拼接\n        No  → Step 6: // 若 chunk 為 0，直接略過\n    Yes → Step 8: i ← i + 1 // 移到下一千級\n→ Output result // 輸出完整英文表達\nEnd // 程式結束\n\nNow need to define convertChunk virtual steps.\n\nWe could include a subroutine definition.\n\n→ Subroutine: convertChunk(chunk)\n    Step 1: if chunk == 0: return \"\" // 空三位不輸出\n    Step 2: word ← \"\" // 初始化\n    Step 3: hundreds ← chunk / 100 // 取百位\n    Step 4: remainder ← chunk % 100 // 取百位以下\n    Step 5: if hundreds > 0: word ← word + ones[hundreds] + \" Hundred\" // 加上百位詞\n    Step 6: if remainder > 0:\n        Decision: remainder < 10?\n            Yes → word ← word + \" \" + ones[remainder] // 0-9\n            No  → Decision: remainder < 20?\n                Yes → word ← word + \" \" + teens[remainder-10] // 10-19\n                No  → Step 7: tens ← remainder / 10 // 十位\n                    Step 8: ones_digit ← remainder % 10 // 末位\n                    Step 9: word ← word + \" \" + tensWord[tens] // 加上十位詞\n                    Step 10: if ones_digit > 0: word ← word + \" \" + ones[ones_digit] // 加上個位詞\n    Step 11: return word // 回傳三位轉換結果\n\nNeed tensWord array too.\n\nMaybe we should define tensWord array in Step 2.\n\nBut we can just refer.\n\nLet's incorporate.\n\nAdd Step: tensWord array.\n\nOk produce final answer.\n\nEnsure each line ends with comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: num == 0? // 檢查輸入是否為 0\n    Yes → Output \"Zero\" // 若為 0，直接輸出\n    No  → Step 1: result ← \"\" // 初始化結果字串\n    No  → Step 2: i ← 0 // 記錄千級位索引\n    No  → Step 3: Define arrays: ones, teens, tens, thousands // 定義單位、十位及千級對應字串\n→ While num > 0? // 仍有未處理的位數\n    Yes → Step 4: chunk ← num mod 1000 // 取最低三位數\n    Yes → Step 5: num ← num / 1000 // 去除已處理的三位\n    Yes → Decision: chunk > 0? // 本段數值是否為 0\n        Yes → Step 6: words_chunk ← convertChunk(chunk) // 將三位數轉成英文詞\n        Yes → Decision: result ≠ \"\"? // 是否已有前面的字串\n            Yes → Step 7: result ← words_chunk + \" \" + thousands[i] + \" \" + result // 加上千級詞後拼接\n            No  → Step 7: result ← words_chunk + \" \" + thousands[i] // 第一個三位段\n        No  → // 若 chunk 為 0，直接略過\n    Yes → Step 8: i ← i + 1 // 進入下一千級\n→ Output result // 輸出完整英文表示\nEnd // 程式結束\n\nSubroutine: convertChunk(chunk) // 轉換單個三位數\n    Step 1: if chunk == 0: return \"\" // 零段不輸出任何字串\n    Step 2: word ← \"\" // 初始化字串\n    Step 3: hundreds ← chunk / 100 // 取得百位\n    Step 4: remainder ← chunk % 100 // 取得百位以下\n    Step 5: if hundreds > 0: word ← word + ones[hundreds] + \" Hundred\" // 加上百位詞\n    Step 6: if remainder > 0:\n        Decision: remainder < 10? // 0-9\n            Yes → word ← word + \" \" + ones[remainder] // 直接加單位詞\n            No  → Decision: remainder < 20? // 10-19\n                Yes → word ← word + \" \" + teens[remainder-10] // 加上特殊十位詞\n                No  → Step 7: tens ← remainder / 10 // 取得十位\n                    Step 8: ones_digit ← remainder % 10 // 取得個位\n                    Step 9: word ← word + \" \" + tensWord[tens] // 加上十位詞\n                    Step 10: if ones_digit > 0: word ← word + \" \" + ones[ones_digit] // 加上個位詞\n    Step 11: return word // 回傳三位數轉換結果\n\nDefinitions (在主流程外):\n    ones = [\"Zero\",\"One\",\"Two\",\"Three\",\"Four\",\"Five\",\"Six\",\"Seven\",\"Eight\",\"Nine\"]\n    teens = [\"Ten\",\"Eleven\",\"Twelve\",\"Thirteen\",\"Fourteen\",\"Fifteen\",\"Sixteen\",\"Seventeen\",\"Eighteen\",\"Nineteen\"]\n    tensWord = [\"\",\"\",\"Twenty\",\"Thirty\",\"Forty\",\"Fifty\",\"Sixty\",\"Seventy\",\"Eighty\",\"Ninety\"]\n    thousands = [\"\",\"Thousand\",\"Million\",\"Billion\",\"Trillion\"]",
      "generated_code": "import sys\nimport re\n\n# ---------- Helper functions ----------\nones = [\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n        \"Seven\", \"Eight\", \"Nine\"]\nteens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\",\n         \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\ntens_word = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n             \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\nthousands = [\"\", \"Thousand\", \"Million\", \"Billion\", \"Trillion\"]\n\ndef convert_three(num: int) -> str:\n    \"\"\"Convert a number less than 1000 into words.\"\"\"\n    if num == 0:\n        return \"\"\n    result = []\n\n    hundreds = num // 100\n    rest = num % 100\n\n    if hundreds:\n        result.append(ones[hundreds])\n        result.append(\"Hundred\")\n\n    if rest:\n        if rest < 10:\n            result.append(ones[rest])\n        elif 10 <= rest < 20:\n            result.append(teens[rest - 10])\n        else:\n            t = rest // 10\n            o = rest % 10\n            result.append(tens_word[t])\n            if o:\n                result.append(ones[o])\n\n    return \" \".join(result)\n\ndef number_to_words(num: int) -> str:\n    \"\"\"Main conversion routine.\"\"\"\n    if num == 0:\n        return \"Zero\"\n\n    parts = []\n    i = 0\n    while num > 0:\n        chunk = num % 1000\n        if chunk:\n            chunk_words = convert_three(chunk)\n            if thousands[i]:\n                chunk_words += \" \" + thousands[i]\n            parts.append(chunk_words)\n        num //= 1000\n        i += 1\n\n    # Parts are built from lowest to highest, reverse them\n    return \" \".join(reversed(parts))\n\n# ---------- Main block ----------\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(0)  # No number found\n    num = int(match.group())\n    print(number_to_words(num))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "One Hundred Twenty Three"
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "Twelve Thousand Three Hundred Forty Five"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode632.json",
    "problem_index_in_file": 0,
    "title": "Smallest Range Covering Elements from K Lists",
    "description_snippet": "You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce pseudocode. Use Start, End, Decision. Steps: maintain pointers, min-heap. Outline algorithm: initialize heap with first element of each list; track current max. Loop while all lists have elements. Pop min, update best range if current max-min smaller. Advance pointer of popped list. Update max. If list exhausted break. Complexity. Provide explanation.\n\nWe need to produce each line with virtual code and comment. Use '→' arrow for steps. Ensure each line is separate. Use indentation for nested steps. Should use 'Decision:' lines. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立一個大小為 k 的最小堆，初始時將每個列表的第一個數字加入堆中，同時記錄其屬於哪個列表 // 將每個列表的起始元素納入堆，以便快速取得最小值\n→ Step 2: 設定 currentMax 為堆中所有元素的最大值 // 追蹤目前已經加入堆中的最大數字，將用於計算範圍長度\n→ Step 3: 設定 bestRange 為 [−∞, +∞] 或 (大範圍值) // 儲存目前找到的最佳（最小）範圍\n→ Decision: 所有堆中的元素均已被處理完? // 判斷是否還有任何列表有剩餘元素可進一步擴展範圍\n    No → Step 4: 從堆中移除最小元素 (minVal, listIdx, elemIdx) // 取得目前最小的數字以及其來源列表和索引\n    → Step 5: 計算 currentRange = currentMax - minVal // 以目前的最小值和最大值計算範圍長度\n    → Decision: currentRange < bestRangeLength OR (currentRange == bestRangeLength AND minVal < bestRangeStart)? // 判斷是否比目前最佳範圍更小，或長度相同但起點更小\n        Yes → Step 6: 更新 bestRange 為 [minVal, currentMax] // 將新的更小範圍保存為最佳\n        No → No action // 若不符合條件，保持舊的最佳範圍\n    → Step 7: 若 listIdx 的下一個索引 elemIdx+1 仍在列表範圍內\n        → Step 8: 將該列表的下一個元素 (nextVal, listIdx, elemIdx+1) 加入堆中 // 將下一個候選值推入堆\n        → Step 9: 若 nextVal > currentMax，則更新 currentMax = nextVal // 可能會擴大最大值\n        → Step 10: 若 listIdx 的下一個索引超出列表長度，則標記該列表已結束 // 之後無法再從此列表獲得新值\n    → Step 11: 回到 Decision: 所有堆中的元素均已被處理完? // 重複主迴圈\n    Yes → End // 所有列表均已耗盡，結束迴圈\nEnd // 程式執行結束，bestRange 為最小範圍答案\n\nNote: 以上虛擬碼採用最小堆與兩指標策略，時間複雜度為 O(N log k)，其中 N 為所有列表元素總數，k 為列表數量。",
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def smallestRange(self, nums):\n        # 初始堆與目前最大值\n        heap = []\n        max_val = float('-inf')\n        for i, lst in enumerate(nums):\n            heapq.heappush(heap, (lst[0], i, 0))  # (值, 列表索引, 元素索引)\n            max_val = max(max_val, lst[0])\n\n        # 最佳範圍長度與起點終點\n        best_len = float('inf')\n        best_start = best_end = None\n\n        while True:\n            min_val, list_idx, elem_idx = heapq.heappop(heap)\n\n            # 更新最佳範圍\n            cur_len = max_val - min_val\n            if cur_len < best_len or (cur_len == best_len and min_val < best_start):\n                best_len = cur_len\n                best_start, best_end = min_val, max_val\n\n            # 若此列表還有下一個元素，加入堆並更新最大值\n            if elem_idx + 1 < len(nums[list_idx]):\n                next_val = nums[list_idx][elem_idx + 1]\n                heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))\n                if next_val > max_val:\n                    max_val = next_val\n            else:\n                # 該列表已無更多元素，無法繼續\n                break\n\n        return [best_start, best_end]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 讀取形如 \"nums = [[...],[...]]\" 的輸入\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    nums = eval(expr.strip())\n    sol = Solution()\n    result = sol.smallestRange(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]",
          "expected_output": "[20,24]",
          "success": true,
          "output": "[20, 24]"
        },
        {
          "example_index": 1,
          "input": "nums = [[1,2,3],[1,2,3],[1,2,3]]",
          "expected_output": "[1,1]",
          "success": true,
          "output": "[1, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode567.json",
    "problem_index_in_file": 0,
    "title": "Permutation in String",
    "description_snippet": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for the algorithm: check if s2 contains a permutation of s1 as substring. Classic sliding window with char count arrays.\n\nWe must output line by line, with \"虛擬碼步驟\" and // explanation. Use arrow syntax: \"→ Step 1:\" etc. Use Start, End, Decision: lines. Let's structure:\n\nStart // start\n→ Step 1: Determine lengths len1, len2 // get lengths\n→ Decision: If len1 > len2? // if pattern longer than text\n    Yes → Step 2: Return false // cannot be substring\n    No → ...\nSet up count arrays of size 26 for s1 and window\n→ Step 3: Build count1 from s1 // freq\n→ Step 4: Build countWindow from first len1 chars of s2 // freq\n→ Step 5: Set matchCount to number of positions where count1[i] == countWindow[i] // could maintain difference\n→ Decision: If matchCount == 26? // all counts match\n    Yes → Step 6: Return true // found\n    No → ...\n→ Step 7: For i from len1 to len2-1: // slide window\n        → Step 7a: char newChar = s2[i], oldChar = s2[i-len1]\n        → Step 7b: Update countWindow for newChar and oldChar\n        → Step 7c: Update matchCount accordingly: if before update equal and after not -> decrement; if before not equal and after equal -> increment\n        → Decision: If matchCount == 26? // all match\n            Yes → Step 7d: Return true\n→ Step 8: Return false // no permutation found\n\nWe need to use virtual code lines.\n\nWe have to keep each line as \"虛擬碼步驟 // explanation\".\n\nUse \"→\" arrow to denote steps. For decisions, use \"Decision: ...\".\n\nAlso must include \"Yes →\" and \"No →\" after Decision lines. For loops, we can show a \"→ Step: Loop start\".\n\nSimplify: Use \"Step 1:\" etc. We'll include all steps.\n\nLet's produce the lines:\n\nStart // 程式開始執行\n\n→ Step 1: Calculate len1 = length of s1, len2 = length of s2 // 取得兩字串長度\n\n→ Decision: If len1 > len2? // 若 s1 長度大於 s2\n    Yes → Step 2: Return false // 直接回傳 false\n    No  → // 繼續執行\n\n→ Step 3: Initialize array countS1[26] to zeros // s1 字母頻率表\n→ Step 4: Initialize array countWindow[26] to zeros // s2 滑動窗頻率表\n\n→ Step 5: For each character c in s1: increment countS1[c - 'a'] // 填充 s1 的頻率表\n\n→ Step 6: For i from 0 to len1-1: increment countWindow[s2[i] - 'a'] // 填充 s2 前 len1 個字元的頻率表\n\n→ Step 7: Initialize matchCount = 0 // 兩個頻率表相等的字母數\n→ Step 8: For i from 0 to 25: if countS1[i] == countWindow[i] then matchCount++ // 計算相同字母數\n\n→ Decision: If matchCount == 26? // 先前窗口已完全匹配\n    Yes → Step 9: Return true // 找到排列\n    No  → // 繼續滑動\n\n→ Step 10: For i from len1 to len2-1: // 滑動窗口\n        → Step 10a: newChar = s2[i]\n        → Step 10b: oldChar = s2[i - len1]\n        → Step 10c: Update countWindow for newChar: \n            → Step 10c1: If countWindow[newChar-'a'] == countS1[newChar-'a'] then matchCount-- // 失去一次匹配\n            → Step 10c2: Increment countWindow[newChar-'a'] // 新字元進入\n            → Step 10c3: If countWindow[newChar-'a'] == countS1[newChar-'a'] then matchCount++ // 重新匹配\n        → Step 10d: Update countWindow for oldChar:\n            → Step 10d1: If countWindow[oldChar-'a'] == countS1[oldChar-'a'] then matchCount-- // 失去一次匹配\n            → Step 10d2: Decrement countWindow[oldChar-'a'] // 舊字元移除\n            → Step 10d3: If countWindow[oldChar-'a'] == countS1[oldChar-'a'] then matchCount++ // 重新匹配\n        → Decision: If matchCount == 26? // 新窗口是否匹配\n            Yes → Step 10e: Return true // 找到排列\n        // loop continues\n\n→ Step 11: Return false // 未找到任何排列\n\nEnd // 程式執行結束\n\nWe need to ensure each line has the virtual code step and explanation after //. Use correct arrow formatting: \"→\" at start of lines. For decisions, \"Decision:\" line. For Yes/No lines, \"Yes →\" or \"No →\" followed by the step.\n\nWe must not produce actual code but pseudocode. The steps can be in Chinese. Provide each line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 len1 = s1 的長度, len2 = s2 的長度 // 取得兩字串長度  \n→ Decision: len1 > len2? // 若 s1 長度大於 s2  \n Yes → Step 2: 回傳 false // 直接回傳 false  \n No  → // 繼續執行  \n→ Step 3: 初始化陣列 countS1[26] 為 0 // s1 的字母頻率表  \n→ Step 4: 初始化陣列 countWindow[26] 為 0 // s2 滑動窗頻率表  \n→ Step 5: 對 s1 中每個字元 c: countS1[c-'a']++ // 填充 s1 的頻率表  \n→ Step 6: 對 i 從 0 到 len1-1: countWindow[s2[i]-'a']++ // 填充 s2 前 len1 個字元的頻率表  \n→ Step 7: 設定 matchCount = 0 // 兩個頻率表相等的字母數  \n→ Step 8: 對 i 從 0 到 25: 若 countS1[i] == countWindow[i] 則 matchCount++ // 計算相同字母數  \n→ Decision: matchCount == 26? // 初始窗口是否已完全匹配  \n Yes → Step 9: 回傳 true // 找到排列  \n No  → // 繼續滑動  \n→ Step 10: 對 i 從 len1 到 len2-1: // 滑動窗口  \n  → Step 10a: newChar = s2[i]  \n  → Step 10b: oldChar = s2[i-len1]  \n  → Step 10c: // 新字元進入窗口  \n    → Step 10c1: 若 countWindow[newChar-'a'] == countS1[newChar-'a'] 則 matchCount-- // 失去一次匹配  \n    → Step 10c2: countWindow[newChar-'a']++ // 新字元進入  \n    → Step 10c3: 若 countWindow[newChar-'a'] == countS1[newChar-'a'] 則 matchCount++ // 重新匹配  \n  → Step 10d: // 舊字元離開窗口  \n    → Step 10d1: 若 countWindow[oldChar-'a'] == countS1[oldChar-'a'] 則 matchCount-- // 失去一次匹配  \n    → Step 10d2: countWindow[oldChar-'a']-- // 舊字元移除  \n    → Step 10d3: 若 countWindow[oldChar-'a'] == countS1[oldChar-'a'] 則 matchCount++ // 重新匹配  \n  → Decision: matchCount == 26? // 新窗口是否匹配  \n    Yes → Step 10e: 回傳 true // 找到排列  \n    No  → // 繼續滑動  \n→ Step 11: 回傳 false // 未找到任何排列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        len1, len2 = len(s1), len(s2)\n        if len1 > len2:\n            return False\n\n        # frequency arrays for 26 lowercase letters\n        cnt1 = [0] * 26\n        window = [0] * 26\n        for ch in s1:\n            cnt1[ord(ch) - 97] += 1\n        for ch in s2[:len1]:\n            window[ord(ch) - 97] += 1\n\n        # number of letters whose counts match\n        match = sum(1 for i in range(26) if cnt1[i] == window[i])\n\n        if match == 26:\n            return True\n\n        for i in range(len1, len2):\n            new_c = ord(s2[i]) - 97\n            old_c = ord(s2[i - len1]) - 97\n\n            # add new character\n            if window[new_c] == cnt1[new_c]:\n                match -= 1\n            window[new_c] += 1\n            if window[new_c] == cnt1[new_c]:\n                match += 1\n\n            # remove old character\n            if window[old_c] == cnt1[old_c]:\n                match -= 1\n            window[old_c] -= 1\n            if window[old_c] == cnt1[old_c]:\n                match += 1\n\n            if match == 26:\n                return True\n\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Try to extract quoted strings first\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        s1, s2 = quoted[0], quoted[1]\n    else:\n        # Fallback: split by whitespace\n        tokens = data.split()\n        if len(tokens) >= 2:\n            s1, s2 = tokens[0], tokens[1]\n        else:\n            # Not enough input\n            s1, s2 = '', ''\n\n    sol = Solution()\n    result = sol.checkInclusion(s1, s2)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"ab\", s2 = \"eidbaooo\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"ab\", s2 = \"eidboaoo\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines following the format. The user wants a virtual algorithm for generating an n-bit Gray code sequence. We should produce step-by-step virtual code: Start, then steps. We should include decision branches where needed. We should use arrow syntax and comments. The algorithm: Use recursive construction or iterative: For n=1: [0,1]. For general: Take n-1 Gray code sequence, then prefix 0 to each, then prefix 1 to reversed sequence. Or iterative using binary representation: for i from 0 to 2^n-1: yield i ^ (i>>1). That may be simpler: For each i, compute gray = i ^ (i >> 1). But we need to produce virtual code lines that reflect that. We must output step by step, not actual code. Use Start, End. Use decision if n==1 maybe. We can include decision: if n==1? else. Also decision: For i from 0 to 2^n-1? We can use loops, but we must maintain arrow lines. We'll use a loop structure: Step 1: Initialize sequence empty. Step 2: For i = 0 to 2^n-1: compute gray = i ^ (i >> 1); append to sequence. Step 3: Return sequence.\n\nBetter to use recursion: Step 1: Define function generateGray(n). Step 2: Decision: if n==0? Actually for n==0 return [0] maybe. For n==1 return [0,1]. Else: seq = generateGray(n-1). Then build new_seq: prefix 0 to each element of seq. Then reverse seq and prefix 1 to each reversed element. Append. Return new_seq.\n\nLet's produce virtual code: \nStart // program starts\n→ Step 1: Define function generateGray(n) // recursively generate n-bit Gray code\n    → Decision: If n == 0? // base case for zero bits\n        Yes → Step 2: Return [0] // single value 0\n        No → Decision: If n == 1? // next base case\n            Yes → Step 3: Return [0, 1] // 1-bit gray code\n            No → Step 4: seq = generateGray(n-1) // recursive call for n-1 bits\n                → Step 5: new_seq = [] // initialize new list\n                → Step 6: For each value in seq: // prepend 0\n                    → Step 7: Append value to new_seq // unchanged\n                → Step 8: reversed_seq = reverse(seq) // reverse order\n                → Step 9: For each value in reversed_seq: // prepend 1\n                    → Step 10: Append (value | (1 << (n-1))) to new_seq // set highest bit\n                → Step 11: Return new_seq // final n-bit sequence\n→ Step 12: result = generateGray(n) // call with input n\n→ Step 13: Output result // return sequence\nEnd // program ends\n\nNeed to ensure each line has virtual code step and comment. Use arrow for steps inside function. Use decision indent. Use Yes→, No→. Also need to use arrow after Decision? Actually we can format as example. We'll use indentation via lines, but not essential. Provide each line as separate line.\n\nMake sure not to output actual code. Provide only virtual steps. We'll also include a note that the base case for n==0 returns [0] or maybe [0] ensures Gray code length 1. But Gray code defined for n bits with first integer 0, length 2^n, so for n=0, sequence length 1 and 0. That's okay.\n\nAlternatively use iterative bit hack: For i from 0 to 2^n -1, gray = i ^ (i >>1). That's simpler. Provide steps: Step 1: length = 1 << n; Step 2: seq = [] ; Step 3: For i=0 to length-1: gray = i ^ (i >> 1); seq.append(gray); Step 4: return seq. Provide decision if n < 0? maybe not needed.\n\nI'll choose iterative approach for clarity. Provide decision maybe if n <=0? But problem says integer n. We can include decision: if n < 0? No. But we can skip. Let's produce iterative.\n\nSo final virtual code:\n\nStart // program starts\n→ Step 1: Calculate total = 1 << n // 2^n, number of codewords\n→ Step 2: Initialize result = [] // empty list to store Gray codes\n→ Step 3: For i = 0 to total - 1: // iterate through all integers in range\n    → Step 4: gray = i ^ (i >> 1) // compute Gray code of i\n    → Step 5: Append gray to result // store in sequence\n→ Step 6: Return result // final n-bit Gray code sequence\nEnd // program ends\n\nWe must adhere to format: \"虛擬碼步驟 [space] // 解釋\". Use \"→\" at start of each step. Indentation may not be required. Each line separate. Let's produce with decisions? We don't need decisions. But we could include decision if n==0? but maybe not needed. It's optional. Provide simple iterative.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Calculate total = 1 << n // 2^n，決定 Gray code 序列長度\n→ Step 2: Initialize result = [] // 建立空列表，用於儲存 Gray code 數值\n→ Step 3: For i = 0 to total - 1: // 逐個遍歷所有可能的整數\n    → Step 4: gray = i ^ (i >> 1) // 計算 i 的 Gray code（左移一位後 XOR）\n    → Step 5: Append gray to result // 將計算出的 Gray code 加入序列\n→ Step 6: Return result // 回傳完整的 n 位 Gray code 序列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def grayCode(self, n: int):\n        \"\"\"Generate n‑bit Gray code sequence.\"\"\"\n        total = 1 << n          # 2^n\n        result = []\n        for i in range(total):\n            gray = i ^ (i >> 1)  # Gray code of i\n            result.append(gray)\n        return result\n\nif __name__ == \"__main__\":\n    # Read entire input and extract the integer n\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    seq = sol.grayCode(n)\n    print(seq)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0, 1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode) line by line with arrow and explanation. For this typical problem: 3Sum Closest. Approach: sort array, loop i, then two pointers left/right, update best sum. So produce steps.\n\nNeed to start with Start. Then maybe Step 1: sort nums. Step 2: initialize bestSum. Step 3: for i from 0 to n-3. Step 4: left = i+1, right = n-1. Step 5: while left < right. Step 6: currentSum = nums[i]+nums[left]+nums[right]. Step 7: if abs(currentSum-target) < abs(bestSum-target) update bestSum. Step 8: if currentSum > target left++ else if currentSum < target right-- else return target. End.\n\nWe should produce with arrows for each step. Use Decision arrow for condition checks. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use \"Start\" and \"End\". Use \"→\" and \"Yes →\", \"No →\" for decision branching.\n\nWe need to be careful: each line is separate, with indentation for nested decisions. Use \"Decision:\" lines.\n\nLet's produce.\n\nProbably lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 對陣列進行升序排序\n→ Step 2: Set bestSum = nums[0] + nums[1] + nums[2] // 初始化最接近的和\n→ Step 3: For i = 0 to n-3 // 以三重循環中的第一個指標遍歷\n    → Step 4: left = i + 1 // 左指標初始位置\n    → Step 5: right = n - 1 // 右指標初始位置\n    → Decision: While left < right? // 檢查是否還有可配對的左右指標\n        Yes → Step 6: currentSum = nums[i] + nums[left] + nums[right] // 計算目前三數之和\n        → Decision: abs(currentSum - target) < abs(bestSum - target)? // 判斷是否更接近目標\n            Yes → Step 7: bestSum = currentSum // 更新最佳答案\n            No → Step 8: // 不更新\n        → Decision: currentSum > target? // 決定左右指標移動方向\n            Yes → left = left + 1 // 右移左指標\n            No  → Decision: currentSum < target?\n                Yes → right = right - 1 // 左移右指標\n                No  → Return target // 完全相等，直接回傳\n        // loop continues\n    // for loop continues\nReturn bestSum // 返回最接近目標的和\nEnd // 程式執行結束\n\nNeed to add explanation after each line. Ensure each line has \"虛擬碼步驟\" maybe \"Step 1:\" etc.\n\nWe need to maintain \"虛擬碼步驟\" + \" // 解釋\" at each line. Use arrow \"→\" preceding. For decisions use \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 對陣列進行升序排序\n→ Step 2: Set bestSum = nums[0] + nums[1] + nums[2] // 初始化最接近的和\n→ Step 3: For i = 0 to n-3 // 以第一個指標遍歷至倒數第三個元素\n    → Step 4: left = i + 1 // 左指標初始位置\n    → Step 5: right = n - 1 // 右指標初始位置\n    → Decision: While left < right? // 是否仍有左右指標可配對？\n        Yes → Step 6: currentSum = nums[i] + nums[left] + nums[right] // 計算目前三數之和\n        → Decision: abs(currentSum - target) < abs(bestSum - target)? // 是否更接近目標？\n            Yes → Step 7: bestSum = currentSum // 更新最佳答案\n            No  → // 保持現有最佳答案\n        → Decision: currentSum > target? // 決定左右指標移動方向\n            Yes → left = left + 1 // 右移左指標以減少總和\n            No  → Decision: currentSum < target?\n                Yes → right = right - 1 // 左移右指標以增加總和\n                No  → Return target // 完全等於目標，直接返回\n    // While 迴圈結束\n// For 迴圈結束\n→ Step 8: Return bestSum // 返回最接近目標的三數之和\nEnd // 程式執行結束",
      "generated_code": "import sys, re\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        closest = float('inf')\n        for i in range(n-2):\n            left, right = i+1, n-1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if abs(total - target) < abs(closest - target):\n                    closest = total\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    return total\n        return closest\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        return\n    nums = eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    sol = Solution()\n    result = sol.threeSumClosest(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode747.json",
    "problem_index_in_file": 0,
    "title": "Largest Number At Least Twice of Others",
    "description_snippet": "You are given an integer array nums where the largest integer is unique.\n\nDetermine whether the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for this algorithm. The input: array nums. We find max, second max. Then check condition. Return index of max if max >= 2*second max. Else -1.\n\nWe need to output line by line with arrows and explanations. Each line: virtual code + space + // explanation.\n\nWe need to use arrows, Start, End, Decision.\n\nWe need to not output real code, just pseudo steps. We should include steps like: Start, Step 1: Determine length n. Step 2: Initialize max1, max2. Step 3: Loop over array. Step 4: Compare. Step 5: Decision: if max >= 2*max2? Yes-> return index. No-> return -1. End.\n\nInclude index variable. Also mention array index tracking.\n\nLet's produce. We'll use \"→\" arrows. Use \"Decision:\" with Yes→ and No→ lines.\n\nWe need to ensure each line is \"虛擬碼步驟 [space] // 解釋\".\n\nWe must use \"Start\" at top and \"End\" at bottom.\n\nLet's craft lines.\n\n1. Start // 程式開始執行\n2. → Step 1: 輸入整數陣列 nums // 從使用者或函式參數取得陣列\n3. → Step 2: 取得陣列長度 n // 用於迴圈限制\n4. → Step 3: 初始化最大值 max1 = -∞, 第二大值 max2 = -∞, maxIndex = -1 // 用於追蹤最大值、第二大值與其索引\n5. → Step 4: 從索引 i = 0 開始迭代至 i < n // 逐個檢查每個元素\n6. → Step 5: 若 nums[i] > max1? // 判斷是否為新的最大值\n7. → Yes → Step 6: 設定 max2 = max1, max1 = nums[i], maxIndex = i // 更新最大值與第二大值及其索引\n8. → No → Decision: 若 nums[i] > max2? // 若不是最大值，檢查是否為新的第二大值\n9. → Yes → Step 7: 設定 max2 = nums[i] // 更新第二大值\n10. → No → Step 8: 繼續迴圈 // 若既不是最大也不是第二大，無須改變\n11. → Step 9: 結束迴圈 // 所有元素已檢查完畢\n12. → Decision: 是否 max1 >= 2 * max2? // 檢查最大值是否至少是其他值的兩倍\n13. → Yes → Step 10: 回傳 maxIndex // 最大值滿足條件，回傳其索引\n14. → No → Step 11: 回傳 -1 // 否則回傳 -1\n15. End // 程式執行結束\n\nNeed to ensure correct indentation for decisions. Use tab or spaces? Use 4 spaces for indentation after Decision lines. Provide arrows.\n\nWe need each line with \"虛擬碼步驟\" then space then explanation. The step lines include \"→\".\n\nWe need to be consistent: use \"→\" before each step. For decision, we need \"Decision:\" line, then indent Yes → and No → lines. Use indentation like 4 spaces before Yes →.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 從使用者或函式參數取得陣列  \n→ Step 2: 取得陣列長度 n // 用於迴圈限制  \n→ Step 3: 初始化最大值 max1 = -∞, 第二大值 max2 = -∞, maxIndex = -1 // 用於追蹤最大值、第二大值與其索引  \n→ Step 4: 從索引 i = 0 開始迭代至 i < n // 逐個檢查每個元素  \n→ Step 5: 若 nums[i] > max1? // 判斷是否為新的最大值  \n    Yes → Step 6: 設定 max2 = max1, max1 = nums[i], maxIndex = i // 更新最大值與第二大值及其索引  \n    No → Decision: 若 nums[i] > max2? // 若不是最大值，檢查是否為新的第二大值  \n        Yes → Step 7: 設定 max2 = nums[i] // 更新第二大值  \n        No → Step 8: 繼續迴圈 // 若既不是最大也不是第二大，無須改變  \n→ Step 9: 結束迴圈 // 所有元素已檢查完畢  \n→ Decision: 是否 max1 >= 2 * max2? // 檢查最大值是否至少是其他值的兩倍  \n    Yes → Step 10: 回傳 maxIndex // 最大值滿足條件，回傳其索引  \n    No → Step 11: 回傳 -1 // 否則回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef dominant_index(nums):\n    \"\"\"\n    Returns the index of the largest element if it is at least\n    twice every other element; otherwise returns -1.\n    \"\"\"\n    if not nums:                         # Empty list edge case\n        return -1\n\n    max_val = max(nums)\n    max_index = nums.index(max_val)      # Unique maximum\n\n    for i, num in enumerate(nums):\n        if i != max_index and max_val < 2 * num:\n            return -1\n    return max_index\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # No input provided\n        sys.exit()\n\n    # Parse the input string into a Python list\n    try:\n        nums = ast.literal_eval(raw_input)\n        if not isinstance(nums, list):\n            raise ValueError\n    except Exception:\n        print(-1)\n        sys.exit()\n\n    # Compute and print the result\n    result = dominant_index(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,6,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that checks if a string is a valid number as defined. We must output step-by-step virtual code lines with explanation comments. Use Start, Decision, etc. Provide logical flow.\n\nWe need to parse string, handle optional leading/trailing spaces? Not mentioned, so maybe ignore. Provide simple algorithm: use state machine, or check patterns: use flags: seenDigit, seenDot, seenExp, etc.\n\nWe'll produce lines:\n\nStart\n→ Strip whitespace\n→ If empty return False\n→ Parse sign\n→ While char digit: mark seenDigit true\n→ If dot: process\n→ etc\n→ If exp: process exp part\n→ After loop check seenDigit and after exp check exp digits etc.\n\nWill produce line-by-line steps.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize index i=0, length n = len(s) // start index\n→ Decision: 是否有前置符號? // check '+' or '-'\n   Yes → i++ // skip sign\n→ Step 2: While i<n and s[i] is digit: i++; seenDigit=True // consume integer part\n→ Decision: 是否遇到 '.'? // check decimal point\n   Yes →\n        → i++ // skip dot\n        → While i<n and s[i] is digit: i++; seenDigit=True // consume fractional part\n→ Decision: 是否遇到 'e' 或 'E'? // check exponent\n   Yes →\n        → i++ // skip e/E\n        → Decision: 是否有符號? // check optional sign in exponent\n            Yes → i++ // skip sign\n        → While i<n and s[i] is digit: i++; expDigit=True // consume exponent digits\n        → Decision: 是否有 exponent digits? // ensure at least one\n            No → End False // invalid exponent\n→ Decision: 是否已走完全部字串? // index at end\n   Yes →\n        → Decision: 是否至少有一個數字前面? // seenDigit true\n            Yes → End True\n            No → End False\n   No → End False\n\nBut we also need to handle case where string starts with '.' and digits after. In algorithm above, if no digits before dot but dot present, we still process fractional digits; seenDigit will be true if digits after dot.\n\nAlso need to ensure that after decimal point but no digits before or after? Eg \".\" invalid. Our algorithm: if dot encountered, we skip dot and then process digits, but if none, seenDigit may be false. But we need at least one digit overall either before or after dot. So after dot, we must allow digits optional but ensure at least one digit somewhere. Our algorithm with seenDigit flag works.\n\nAlso need to handle exponent after digits or decimal; we need to ensure seenDigit true before exp. But maybe \"e3\" invalid because no digits before exp. Our algorithm would skip digits (none), seenDigit false, then encounter 'e', skip exp, but seenDigit still false -> will eventually return False. Good.\n\nEdge cases: \"2e\" no digits after exponent -> we set expDigit false -> return False. Good.\n\nNeed to include decision for seenDigit before exp to allow exponent only if previous digits exist.\n\nAlso we might need to check if '.' occurs after exponent? We will not allow because we exit loop after exp digits and check index end.\n\nAlso need to handle \"5.\" digits before dot but none after: valid. Our algorithm: seenDigit true before dot, after dot no digits but seenDigit remains true. Accept.\n\nCase \".9\" digits before dot none but after dot one: seenDigit becomes true when processing digits after dot. Accept.\n\nCase \" 2 \" maybe not considered; ignore.\n\nOk produce final lines.\n\nLet's format each line with arrow \"→\" and comment.\n\nUse 'Decision:' lines with indent? Example sample had indent inside decision. We'll mimic: after Decision line we can indent Yes/No lines with 4 spaces and arrow.\n\nBut simpler: just show each line sequentially; the sample uses indentation to show branches, but we can maintain but each line separate. They asked to use arrow and structure. We'll show like:\n\nStart // 程式開始執行\n→ Step 1: i = 0, n = len(s) // 初始化索引\n→ Decision: s[i] 為 '+' 或 '-'? // 檢查前置符號\n    Yes → i++ // 跳過符號\n→ Step 2: while i < n and s[i] 為數字: i++ // 讀取整數部分\n    seenDigit = True\n→ Decision: s[i] 為 '.'? // 檢查小數點\n    Yes →\n        → i++ // 跳過小數點\n        → while i < n and s[i] 為數字: i++ // 讀取小數部分\n            seenDigit = True\n→ Decision: s[i] 為 'e' 或 'E'? // 檢查指數符號\n    Yes →\n        → i++ // 跳過 e/E\n        → Decision: s[i] 為 '+' 或 '-'? // 指數可有符號\n            Yes → i++ // 跳過指數符號\n        → while i < n and s[i] 為數字: i++ // 讀取指數數字\n            expDigit = True\n        → Decision: expDigit 是否為 True? // 確認至少一個指數數字\n            No → End False // 指數部分缺失數字\n→ Decision: i 是否等於 n? // 是否已讀完整個字串\n    Yes →\n        → Decision: seenDigit 是否為 True? // 至少有一個數字\n            Yes → End True\n            No → End False\n    No → End False // 有多餘字符\n\nAdd final End lines.\n\nBut need to keep structure of decision branches properly. Each Decision block's Yes/No lines should be indented.\n\nWe also need to note that step for while loops might be expressed as \"while\" lines.\n\nOk produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: i = 0, n = len(s) // 初始化索引\n→ Decision: s[i] 為 '+' 或 '-'? // 檢查前置符號\n    Yes → i++ // 跳過符號\n→ Step 2: while i < n and s[i] 為數字: i++ // 讀取整數部分\n    seenDigit = True\n→ Decision: s[i] 為 '.'? // 檢查小數點\n    Yes →\n        → i++ // 跳過小數點\n        → while i < n and s[i] 為數字: i++ // 讀取小數部分\n            seenDigit = True\n→ Decision: s[i] 為 'e' 或 'E'? // 檢查指數符號\n    Yes →\n        → i++ // 跳過 e/E\n        → Decision: s[i] 為 '+' 或 '-'? // 指數可有符號\n            Yes → i++ // 跳過指數符號\n        → while i < n and s[i] 為數字: i++ // 讀取指數數字\n            expDigit = True\n        → Decision: expDigit 是否為 True? // 確認至少一個指數數字\n            No → End False // 指數部分缺失數字\n→ Decision: i 是否等於 n? // 是否已讀完整個字串\n    Yes →\n        → Decision: seenDigit 是否為 True? // 至少有一個數字\n            Yes → End True\n            No → End False\n    No → End False // 有多餘字符\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isNumber(self, s: str) -> bool:\n        \"\"\"\n        判斷字串 s 是否為合法的數字。使用標誌位來追蹤已經出現的數字、點和指數。\n        \"\"\"\n        s = s.strip()  # 去除首尾空白\n        if not s:\n            return False\n\n        num_seen = False   # 至少已經出現過數字\n        dot_seen = False   # 已經遇到小數點\n        e_seen = False     # 已經遇到指數符號\n\n        for i, char in enumerate(s):\n            if char.isdigit():\n                num_seen = True\n            elif char == '.':\n                if dot_seen or e_seen:     # 小數點已經出現或在指數內出現\n                    return False\n                dot_seen = True\n            elif char in ('e', 'E'):\n                if e_seen or not num_seen: # 指數已經出現或前面沒有數字\n                    return False\n                e_seen = True\n                num_seen = False           # 指數部分還需要再出現數字\n            elif char in ('+', '-'):\n                # 符號只能出現在字串開始或 e/E 後面\n                if i != 0 and s[i-1] not in ('e', 'E'):\n                    return False\n            else:\n                return False\n        return num_seen\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 嘗試從形如 s = \"value\" 的格式中擷取實際值\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整行作為輸入\n        s = raw_input\n\n    solution = Solution()\n    result = solution.isNumber(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with explanations. Should not output real code. Use arrows, decisions etc. Provide steps: initialize min_price, max_profit; loop over prices, update min_price and max_profit; after loop return max_profit. Also handle empty array. Provide each step line with virtual code comment.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 min_price = 無限大 // 將最小價格設為無限大\n→ Step 2: 初始化 max_profit = 0 // 初始最大利潤為0\n→ Step 3: 針對每個 price 在 prices 中迭代 // 遍歷所有股價\n    → Decision: price < min_price? // 判斷是否是新的最低價\n        Yes → Step 4: min_price = price // 更新最低價格\n        No  → Decision: price - min_price > max_profit? // 不是最低價，檢查是否能獲得更大利潤\n            Yes → Step 5: max_profit = price - min_price // 更新最大利潤\n            No  → Step 6: 何不做任何事 // 保持現有最大利潤\nEnd // 迴圈結束\n→ Step 7: 返回 max_profit // 回傳最大的可得利潤\n\nNeed each line virtual code step with comment.\n\nLet's format as lines with virtual code step plus // comment.\n\nBe careful with indentation maybe using tabs.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 min_price = ∞ // 將最低價格設為正無窮大，為了後續能正確更新  \n→ Step 2: 初始化 max_profit = 0 // 初始最大利潤為 0，若無利潤則回傳 0  \n→ Step 3: 針對每個 price 在 prices 中迭代 // 循環遍歷所有天的股價  \n  → Decision: price < min_price? // 判斷目前股價是否為新的最低點  \n   Yes → Step 4: min_price = price // 若是，更新 min_price 為本日股價  \n   No → Decision: price - min_price > max_profit? // 否則，檢查以本日為賣日能否得到更大利潤  \n    Yes → Step 5: max_profit = price - min_price // 若能，更新 max_profit 為本次利潤  \n    No → Step 6: 什麼也不做 // 否則保留現有的 max_profit  \nEnd // 迴圈結束，所有股價已處理完  \n→ Step 7: 返回 max_profit // 輸出能得到的最大利潤值，若無利潤則為 0",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, prices):\n        # 若股價列表為空，直接回傳 0\n        if not prices:\n            return 0\n\n        # 初始化最低價格為第一天價格\n        min_price = prices[0]\n        # 初始最大利潤為 0\n        max_profit = 0\n\n        # 從第二天開始遍歷\n        for price in prices[1:]:\n            # 若本日賣出能獲得更大利潤，更新最大利潤\n            max_profit = max(max_profit, price - min_price)\n            # 更新最低價格\n            min_price = min(min_price, price)\n\n        return max_profit\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出所有整數（支持負數）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    # nums 就是 prices 列表\n    prices = nums\n\n    solution = Solution()\n    result = solution.maxProfit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for wildcard matching DP algorithm. Provide line by line. Use Start, End, Decision, Steps. Use arrow \"→\". For loops maybe represent as Step 1: Initialize DP table etc. Should be concise. We can show DP table dp[i][j] bool. Provide algorithm in steps.\n\nWe need to show: Start, Step 1: initialize dp[0][0]=true; Step 2: fill first row for '*' in pattern; Step 3: iterate i from 1 to m, j from 1 to n; Decision: if p[j-1]=='*' then dp[i][j]=dp[i][j-1] or dp[i-1][j]; else if p[j-1]=='?' or s[i-1]==p[j-1] then dp[i][j]=dp[i-1][j-1]; else dp[i][j]=false. Step final: return dp[m][n]. End.\n\nAdd explanation after each line.\n\nNeed to include arrow \"→\" before each step? Format: \"Start // 程式開始執行\". Then \"→ Step 1: ... // ...\".\n\nUse indentation for Decision branches with Yes →, No →. For loops we can denote Step 1.1 etc but just simple.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 m = s 的長度, n = p 的長度 // 取得輸入字串與模式長度  \n→ Step 2: 建立 dp 表格 (m+1) x (n+1) 並初始化為 false // dp[i][j] 表示 s 前 i 個字元與 p 前 j 個字元是否匹配  \n→ Step 3: 設定 dp[0][0] = true // 空字串與空模式相符  \n→ Step 4: 對 j 從 1 到 n 做以下:  \n  Decision: 如果 p[j-1] 為 '*'? // 第一行處理模式開頭為 '*' 的情況  \n   Yes → dp[0][j] = dp[0][j-1] // '*' 可以匹配空字串  \n   No  → dp[0][j] = false // 其它符號不能匹配空字串  \n→ Step 5: 對 i 從 1 到 m 做以下:  \n  對 j 從 1 到 n 做以下:  \n   Decision: 如果 p[j-1] 為 '*'? // '*' 可以匹配零或多個字元  \n    Yes → dp[i][j] = dp[i][j-1] 或 dp[i-1][j] // 前一個模式位置或上一個字串位置的匹配結果  \n    No → Decision: 如果 p[j-1] 為 '?' 或 p[j-1] == s[i-1]? // '?' 匹配任意單一字元，或兩字元相同  \n      Yes → dp[i][j] = dp[i-1][j-1] // 前一個位置也要匹配成功  \n      No  → dp[i][j] = false // 不匹配  \n→ Step 6: 回傳 dp[m][n] // 判斷整個字串是否完全匹配  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        \"\"\"Wildcard pattern matching with '?' and '*'. \"\"\"\n        m, n = len(s), len(p)\n        # dp[i][j] 表示 s[:i] 是否能匹配 p[:j]\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # 第一行：只有 '*' 能匹配空字串\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        # 主迴圈\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    # '*' 可以匹配空或多個字元\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n                elif p[j - 1] == '?' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = False\n        return dp[m][n]\n\n\ndef parse_input(text: str):\n    \"\"\"從輸入文字中解析出 s 與 p。\"\"\"\n    text = text.strip()\n    # 先嘗試匹配「s = \"xx\", p = \"yy\"」的格式\n    m = re.search(r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*p\\s*=\\s*\"([^\"]*)\"', text)\n    if m:\n        return m.group(1), m.group(2)\n    # 若是多行分開寫\n    lines = [line.strip() for line in text.splitlines() if line.strip()]\n    s = lines[0].split('=')[1].strip().strip('\"')\n    p = lines[1].split('=')[1].strip().strip('\"')\n    return s, p\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s, p = parse_input(data)\n    solution = Solution()\n    result = solution.isMatch(s, p)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. It's essentially the combination sum problem but with numbers 1-9 unique. Return all combinations. So need algorithm: backtracking. Steps: Start, define result list, define helper function backtrack(start, target, path). For i from start to 9: if i>target skip; else choose i, append to path, backtrack(i+1, target-i, path). When target==0, add copy of path to result. End.\n\nWe need to produce step-by-step pseudocode lines with arrows and explanations. Also include decision points. Should reflect the algorithm.\n\nWe must adhere to output format: each line: \"虛擬碼步驟 // 解釋\". Lines starting with \"Start\" or \"End\". Use arrows \"→\" for continuation, \"Decision:\" for if, \"Yes →\", \"No →\".\n\nLet's create steps:\n\nStart // 程式開始執行\n→ Step 1: 定義結果集合 results // 儲存所有有效組合\n→ Step 2: 定義遞迴函式 backtrack(start, target, path) // 從 start 開始搜尋\n    → Decision: target 是否等於 0? // 檢查是否找到一組有效組合\n        Yes → Step 3: 把 path 的複製加入 results // 將組合加入結果\n        No  → Decision: start 是否大於 9? // 檢查是否還有可選數字\n            Yes → Step 4: 返回 // 走到末端無法選取更多數字，結束此分支\n            No  → Step 5: 從 i = start 到 9 做循環 // 選擇下個數字\n                → Decision: i > target? // 若數字已大於剩餘和則跳過\n                    Yes → Step 6: 跳過此 i // 不再考慮此數字\n                    No  → Step 7: path 加 i // 暫時選擇此數字\n                        → Step 8: backtrack(i+1, target-i, path) // 深入下一層\n                        → Step 9: 從 path 移除最後一個 i // 回溯，恢復狀態\n← (back to Step 5 loop)\n\nAfter defining backtrack, call backtrack(1, n, []) // 從 1 開始尋找和為 n\n→ Step 10: 返回 results // 傳回所有組合\n\nEnd // 程式執行結束\n\nBut we need to ensure each line has a single \"虛擬碼步驟\". We can nest decisions but each line should be separate. We can write nested with indentation maybe. Use arrow for steps. Let's structure properly.\n\nWe need to produce each step as a separate line. Use \"→\" at each step line. For decision blocks, we can write \"Decision: ...\". Indentation maybe via spaces? The example shows indentation using spaces before Yes/No lines. We'll replicate.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果集合 results = [] // 用於儲存所有符合條件的組合  \n→ Step 2: 定義遞迴函式 backtrack(start, target, path) // 從 start 開始搜尋  \n  Decision: target 是否等於 0? // 檢查是否已完成一組合法組合  \n   Yes → Step 3: 把 path 的複製加入 results // 將找到的組合加入結果集  \n   No  → Decision: start 是否大於 9? // 檢查是否還有可選的數字  \n    Yes → Step 4: 返回 // 沒有更多數字可選，結束此分支  \n    No  → Step 5: 從 i = start 到 9 做循環 // 嘗試每一個可能的數字  \n     Decision: i > target? // 若選取的數字已超過剩餘和，跳過  \n      Yes → Step 6: 跳過此 i // 不再考慮此數字  \n      No  → Step 7: 把 i 加到 path // 暫時選擇此數字  \n       → Step 8: backtrack(i+1, target-i, path) // 進一步搜尋剩餘和  \n       → Step 9: 從 path 移除最後一個 i // 回溯，恢復原狀  \n← (回到 Step 5 循環)  \n→ Step 10: 呼叫 backtrack(1, n, []) // 從數字 1 開始尋找和為 n 的組合  \n→ Step 11: 返回 results // 傳回所有符合條件的組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def combinationSum3(self, k, n):\n        res = []\n\n        def backtrack(start, path, total):\n            if len(path) == k and total == n:\n                res.append(path[:])\n                return\n            if len(path) > k or total > n:\n                return\n            for i in range(start, 10):\n                path.append(i)\n                backtrack(i + 1, path, total + i)\n                path.pop()\n\n        backtrack(1, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        k, n = nums[0], nums[1]\n    else:\n        k = n = 0\n    solution = Solution()\n    result = solution.combinationSum3(k, n)\n    print(json.dumps(result, separators=(',', ':')))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1,2,4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1,2,6],[1,3,5],[2,3,4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode721.json",
    "problem_index_in_file": 0,
    "title": "Accounts Merge",
    "description_snippet": "Given a list of accounts where each element accounts[i] is a list of strings, where the first elemen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for merging accounts. Use virtual code style. Provide line-by-line steps. Use decision nodes. We'll produce algorithm: build graph of emails, union find, mapping email to name, DFS to collect groups, sort emails, output.\n\nLet's produce steps:\n\nStart\n→ Step: 初始化 email_to_name 映射和 graph (adjacency list)\n→ Step: 建立圖，將相同帳戶中的每個 email 與第一個 email 連接\n→ Decision: 若 accounts 列表为空? -> End\nBut we may skip such check.\n\nThen DFS each email not visited to collect group.\n\nLet's produce lines.\n\nAlso need arrow formatting: \"→ Step ... // explanation\". For decisions, indent lines.\n\nWe can incorporate \"Decision:\" lines. Example:\n\n→ Decision: accounts 是否为空? // 若無帳戶則直接結束\n    Yes → End // 無帳戶\n\nBut maybe keep simple.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 創建空字典 email_to_name // 用於存儲每個 email 對應的姓名\n→ Step 2: 創建空字典 graph // 用於存儲 email 之間的連接\n→ Step 3: 對於每個帳戶在 accounts 之中進行遍歷 // 主循環\n    → Step 3.1: 取帳戶名稱 name = account[0] // 取得姓名\n    → Step 3.2: 取帳戶電子郵件列表 emails = account[1:] // 取得所有 email\n    → Step 3.3: 對於每個 email 在 emails 中進行遍歷\n        → Step 3.3.1: 若 email 未在 email_to_name 中，將 email_to_name[email] = name // 記錄姓名\n        → Step 3.3.2: 若 email 未在 graph 中，將 graph[email] = 空集合 // 初始化集合\n    → Step 3.4: 若 emails 非空，將第一個 email 作為基準\n        → Step 3.4.1: 基準基 email0 = emails[0]\n        → Step 3.4.2: 對於其餘 email 在 emails[1:] 中\n            → Step 3.4.2.1: 在 graph 中將 email0 與 email 互相加入集合 // 建立邊\n            → Step 3.4.2.2: 在 graph 中將 email 與 email0 互相加入集合\n→ Step 4: 創建空集合 visited // 用於標記已訪問的 email\n→ Step 5: 創建空列表 result // 用於存放合併後的帳戶\n→ Step 6: 對於每個 email 在 graph 的鍵中進行遍歷\n    → Decision: email 是否已在 visited? // 判斷是否已處理\n        Yes → Skip // 已處理則跳過\n        No  → Step 6.1: 初始化空列表 group_emails // 用於收集同一個帳戶的 email\n        → Step 6.2: 執行 DFS 或 BFS 從 email 開始\n            → Step 6.2.1: 將 email 入棧/佇列 // 開始搜尋\n            → Step 6.2.2: 取出頂端節點 cur\n            → Step 6.2.3: 若 cur 已在 visited 則繼續\n            → Step 6.2.4: 否則將 cur 加入 visited 並加入 group_emails\n            → Step 6.2.5: 對於每個相鄰節點 nei 在 graph[cur]\n                → Step 6.2.5.1: 若 nei 未在 visited，將其加入棧/佇列\n        → Step 6.3: 對 group_emails 進行排序 // 以字典序排列\n        → Step 6.4: 取得任意一個 group_emails 中的 email 對應的姓名 name = email_to_name[group_emails[0]]\n        → Step 6.5: 建立帳戶列表 merged = [name] + group_emails // 將姓名放在首位\n        → Step 6.6: 將 merged 加入 result\n→ End // 程式執行結束\n\nAdd explanation comments.\n\nWe need to ensure each line is preceded by arrow and comment. Use \"Decision:\" line indent. Need to maintain indentation with tabs? In example, indentation for sub-steps is 4 spaces. We can mimic.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建空字典 email_to_name // 用於存儲每個 email 對應的姓名  \n→ Step 2: 創建空字典 graph // 用於存儲 email 之間的連接  \n→ Step 3: 對於每個帳戶在 accounts 之中進行遍歷 // 主循環  \n    → Step 3.1: 取帳戶名稱 name = account[0] // 取得姓名  \n    → Step 3.2: 取帳戶電子郵件列表 emails = account[1:] // 取得所有 email  \n    → Step 3.3: 對於每個 email 在 emails 中進行遍歷  \n        → Step 3.3.1: 若 email 未在 email_to_name 中，將 email_to_name[email] = name // 記錄姓名  \n        → Step 3.3.2: 若 email 未在 graph 中，將 graph[email] = 空集合 // 初始化集合  \n    → Step 3.4: 若 emails 非空，將第一個 email 作為基準  \n        → Step 3.4.1: 基準基 email0 = emails[0] // 基準 email  \n        → Step 3.4.2: 對於其餘 email 在 emails[1:] 中  \n            → Step 3.4.2.1: 在 graph 中將 email0 與 email 互相加入集合 // 建立邊  \n            → Step 3.4.2.2: 在 graph 中將 email 與 email0 互相加入集合  \n→ Step 4: 創建空集合 visited // 用於標記已訪問的 email  \n→ Step 5: 創建空列表 result // 用於存放合併後的帳戶  \n→ Step 6: 對於每個 email 在 graph 的鍵中進行遍歷  \n    → Decision: email 是否已在 visited? // 判斷是否已處理  \n        Yes → Skip // 已處理則跳過  \n        No  → Step 6.1: 初始化空列表 group_emails // 用於收集同一個帳戶的 email  \n        → Step 6.2: 執行 DFS 從 email 開始  \n            → Step 6.2.1: 將 email 入棧 // 開始搜尋  \n            → Step 6.2.2: 取出棧頂節點 cur  \n            → Step 6.2.3: 若 cur 已在 visited 則繼續  \n            → Step 6.2.4: 否則將 cur 加入 visited 並加入 group_emails  \n            → Step 6.2.5: 對於每個相鄰節點 nei 在 graph[cur]  \n                → Step 6.2.5.1: 若 nei 未在 visited，將其加入棧  \n        → Step 6.3: 對 group_emails 進行排序 // 以字典序排列  \n        → Step 6.4: 取得 group_emails[0] 對應的姓名 name = email_to_name[group_emails[0]] // 所有 email 同名  \n        → Step 6.5: 建立帳戶列表 merged = [name] + group_emails // 將姓名放在首位  \n        → Step 6.6: 將 merged 加入 result // 收集合併後的帳戶  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        \"\"\"\n        使用「合併集合」(Union‑Find) 來把相同 email 的帳號合併。\n        \"\"\"\n        parent = {}\n\n        # ---------- 1. 先找出某個 email 的根節點 ----------\n        def find(x):\n            parent.setdefault(x, x)          # 如果還沒出現在字典中，先初始化\n            if parent[x] != x:               # 迭代尋找根節點\n                parent[x] = find(parent[x])  # 路徑壓縮\n            return parent[x]\n\n        # email -> name 的映射，方便最後取姓名\n        email_to_name = {}\n\n        # ---------- 2. 建立合併關係 ----------\n        for acc in accounts:\n            name = acc[0]\n            emails = acc[1:]\n            if not emails:\n                continue\n            first = emails[0]\n            for email in emails:\n                # 記錄姓名\n                email_to_name[email] = name\n                # 合併操作：把 email 與第一個 email 合併\n                root_first = find(first)\n                root_email = find(email)\n                if root_first != root_email:\n                    parent[root_email] = root_first\n\n        # ---------- 3. 把同一個根節點的 email 收集在一起 ----------\n        groups = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            groups[root].append(email)\n\n        # ---------- 4. 準備回傳結果 ----------\n        merged = []\n        for root, em_list in groups.items():\n            merged.append([email_to_name[root]] + sorted(em_list))\n        return merged\n\ndef main():\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 可能會有 'accounts = ' 這樣的字串，先把它剔除\n    if raw_input.startswith('accounts'):\n        eq_index = raw_input.find('=')\n        if eq_index != -1:\n            raw_input = raw_input[eq_index + 1:].strip()\n\n    # 解析成 Python 物件（安全解析）\n    try:\n        accounts = ast.literal_eval(raw_input)\n    except Exception:\n        # 若 literal_eval 失敗，使用 eval（較不安全，但能處理更複雜情況）\n        accounts = eval(raw_input, {})\n\n    # 執行合併邏輯\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n\n    # 輸出結果，Python 內建的 print 會直接轉成文字表達式\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "expected_output": "[[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]",
          "success": true,
          "output": "[['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], ['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com']]"
        },
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode763.json",
    "problem_index_in_file": 0,
    "title": "Partition Labels",
    "description_snippet": "You are given a string s. We want to partition the string into as many parts as possible so that eac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation per line, following the format. Need to explain algorithm for partition string into maximum parts where each letter appears in at most one part. This is standard problem: for each character, track last occurrence. Then sweep, maintain max last index seen; when current index equals max last, we cut. Output sizes.\n\nSo steps: compute last index map; iterate; maintain current part start; maintain furthest last; when i==furthest, record length.\n\nNeed to produce lines with virtual code and comment. Use arrows as needed. Example:\n\nStart // Program start\n→ Step 1: Create map lastPos of char to int // store last index of each char\n→ For each index i, char c in s: lastPos[c] = i // record last occurrence\n→ Step 2: Initialize currentStart = 0, maxEnd = 0, result = [] // prepare variables\n→ For each index i, char c in s:\n    → maxEnd = max(maxEnd, lastPos[c]) // update furthest end\n    → If i == maxEnd:\n        → Append i - currentStart + 1 to result // partition size\n        → currentStart = i + 1 // start next part\n→ End // end of algorithm\n\nAdd explanation after each line. Also use Decision lines: maybe use Decision to check if i==maxEnd.\n\nNeed to be line-by-line.\n\nLet's produce lines as per format:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 lastPos // 用來記錄每個字母最後出現的位置\n→ Decision: 遍歷字符串 s 的每個索引 i 與字符 c? // 進行一次遍歷\n    Yes → Step 2: 設置 lastPos[c] = i // 更新字母最後位置\n→ End // 完成最後位置的填寫\n→ Step 3: 設定 currentStart = 0, maxEnd = 0, result = [] // 準備分割變數\n→ Decision: 遍歷字符串 s 的每個索引 i 與字符 c? // 再次遍歷來確定分割點\n    Yes →\n        → Step 4: maxEnd = max(maxEnd, lastPos[c]) // 更新目前已知的最遠結束位置\n        → Decision: i == maxEnd? // 判斷是否到達分割點\n            Yes →\n                → Step 5: result.append(i - currentStart + 1) // 記錄本段長度\n                → Step 6: currentStart = i + 1 // 移動到下一段的起點\n            No → // 繼續遍歷\n→ End // 演算法完成\n→ Step 7: 輸出 result // 返回所有段長度\n\nMake sure each line has the format \"虛擬碼步驟 // 解釋/說明\". Use Chinese.\n\nWe need arrows and structure. Use \"→\" and \"Decision:\" lines. Also \"Yes →\" etc.\n\nEnsure proper indentation: For decisions we indent following lines? Not necessary but show structure.\n\nWe need to produce final answer with lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 lastPos // 用來記錄每個字母最後出現的位置  \n→ Decision: 遍歷字符串 s 的每個索引 i 與字符 c? // 進行一次遍歷  \n    Yes → Step 2: 設置 lastPos[c] = i // 更新字母最後位置  \n→ End // 完成最後位置的填寫  \n→ Step 3: 設定 currentStart = 0, maxEnd = 0, result = [] // 準備分割變數  \n→ Decision: 遍歷字符串 s 的每個索引 i 與字符 c? // 再次遍歷來確定分割點  \n    Yes →  \n        → Step 4: maxEnd = max(maxEnd, lastPos[c]) // 更新目前已知的最遠結束位置  \n        → Decision: i == maxEnd? // 判斷是否到達分割點  \n            Yes →  \n                → Step 5: result.append(i - currentStart + 1) // 記錄本段長度  \n                → Step 6: currentStart = i + 1 // 移動到下一段的起點  \n            No → // 繼續遍歷  \n→ End // 演算法完成  \n→ Step 7: 輸出 result // 返回所有段長度",
      "generated_code": "import sys\nimport re\n\ndef partition_labels(s: str):\n    \"\"\"\n    Partition string s into maximum number of parts such that each letter\n    appears in at most one part. Return list of part sizes.\n    \"\"\"\n    # 1. 取得每個字母最後一次出現的位置\n    last = {c: i for i, c in enumerate(s)}\n    partitions = []\n    start = end = 0\n    # 2. 遍歷字串，確定分割點\n    for i, c in enumerate(s):\n        end = max(end, last[c])            # 更新已知的最遠結束位置\n        if i == end:                       # 目前位置即為分割點\n            partitions.append(i - start + 1)  # 記錄本段長度\n            start = i + 1                    # 移動到下一段起點\n    return partitions\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，解析字串 s，計算分割結果並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入中抓取被雙引號包住的字串\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整個輸入\n        s = data.strip()\n    result = partition_labels(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "expected_output": "[9,7,8]",
          "success": true,
          "output": "[9, 7, 8]"
        },
        {
          "example_index": 1,
          "input": "s = \"eccbbbbdec\"",
          "expected_output": "[10]",
          "success": true,
          "output": "[10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm. Problem is Word Ladder II. We need to output all shortest transformation sequences. We can use BFS to build graph level by level, then DFS or backtracking from end to start to reconstruct paths. Use adjacency map from word to neighbors. Steps: Input: beginWord, endWord, wordList. Build set. If endWord not in set return empty. BFS to compute distance from beginWord to each word, also build predecessors. Then DFS from endWord to beginWord to build paths. Output list of paths reversed.\n\nWe must produce virtual code lines, each line \"虛擬碼步驟 // 解釋\". Must use arrows and Decision. Use Start, End. Each step can be \"→\" with action. Should cover BFS loop, neighbor generation, distance mapping, predecessor mapping. Then DFS/backtrack recursion. Provide explanations. We'll produce step-by-step pseudocode. Use variable names: wordSet, distance map, graph map, queue.\n\nLet's craft lines:\n\nStart // 程式開始\n\n→ Step 1: 初始化 wordSet = Set(wordList) // 將字典轉為集合\n\n→ Decision: 若 endWord 不在 wordSet? // 檢查目標字是否存在\n\n    Yes → Step 2: 返回空列表 // 沒有路徑，直接結束\n\n    No → Step 3: 初始化 distance = {beginWord:0} // 開始 BFS 的距離字典\n\n    No → Step 4: 初始化 graph = {} // 還未連結的鄰接關係\n\n    No → Step 5: 初始化 queue = [beginWord] // BFS 緩衝\n\n→ Decision: queue 是否為空? // 只做一次循環檢查\n\n    Yes → Step 6: 跳出循環 // BFS 完成\n\n    No → Step 7: 取出 front = queue.pop(0) // 取隊首\n\n    No → Step 8: 取得 front 的 distance curDist = distance[front] // 目前距離\n\n    No → Step 9: for each i from 0 to len(front)-1 // 遍歷每個字母位置\n\n        No → Step 10: 生成字母範圍('a'..'z') // 可能替換的字母\n\n            No → Step 11: 若 newChar == front[i] 則 continue // 跳過相同字\n\n            No → Step 12: newWord = front[:i]+newChar+front[i+1:] // 替換字\n\n            No → Step 13: 若 newWord 在 wordSet? // 確認字在字典\n\n                Yes → Step 14: 若 newWord 尚未在 distance? // 第一次訪問\n\n                    Yes → Step 15: distance[newWord] = curDist + 1 // 記錄距離\n\n                    Yes → Step 16: queue.append(newWord) // 加入隊列\n\n                No → Step 17: 若 distance[newWord] != curDist + 1? // 不在同一層\n\n                    Yes → Step 18: 跳過 // 只處理最短層\n\n                    No → Step 19: // 處理同層相鄰\n\n                Yes → Step 20: graph.setdefault(front, []).append(newWord) // 建立前往新單字的邊\n\n                Yes → Step 21: graph.setdefault(newWord, []).append(front) // 建立反向邊\n\n    No → Step 22: // BFS 迴圈結束\n\n→ Decision: endWord 是否在 distance? // 是否找到目標\n\n    Yes → Step 23: 初始化 paths = [] // 儲存所有最短路徑\n\n    Yes → Step 24: 定義函式 backtrack(current, path)\n\n        No → Step 25: 若 current == beginWord // 到達起點\n\n            No → Step 26: paths.append([beginWord]+path[::-1]) // 將路徑反轉並加入\n\n            No → Step 27: 返回\n\n        No → Step 28: for neighbor in graph[current] // 遍歷前一層的鄰居\n\n            No → Step 29: 若 distance[neighbor] == distance[current] - 1\n\n                No → Step 30: backtrack(neighbor, path+[current]) // 進一步遞歸\n\n    No → Step 31: 呼叫 backtrack(endWord, []) // 從終點開始回溯\n\n    No → Step 32: 返回 paths // 結果\n\n    No → Step 33: 返回空列表 // 沒有路徑\n\nEnd // 程式結束\n\nBut we need to use arrow notation: \"→ Step\" lines and Decision lines with Yes→ and No→ etc. Must be consistent.\n\nLet's format properly. Use indentation maybe.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 wordSet = Set(wordList) // 將字典轉為集合\n→ Decision: 若 endWord 不在 wordSet? // 檢查目標字是否存在\n    Yes → Step 2: 返回空列表 // 沒有路徑，直接結束\n    No  → Step 3: 初始化 distance = {beginWord:0} // 開始 BFS 的距離字典\n    No  → Step 4: 初始化 graph = {} // 還未連結的鄰接關係\n    No  → Step 5: 初始化 queue = [beginWord] // BFS 緩衝\n→ Decision: queue 是否為空? // 只做一次循環檢查\n    Yes → Step 6: 跳出循環 // BFS 完成\n    No  → Step 7: 取出 front = queue.pop(0) // 取隊首\n    No  → Step 8: 取得 front 的 distance curDist = distance[front] // 目前距離\n    No  → Step 9: for 每個 i 從 0 到 len(front)-1 // 遍歷每個字母位置\n        No  → Step 10: 生成字母範圍('a'..'z') // 可能替換的字母\n            No → Step 11: 若 newChar == front[i] 則 continue // 跳過相同字\n            No → Step 12: newWord = front[:i]+newChar+front[i+1:] // 替換字\n            No → Step 13: 若 newWord 在 wordSet? // 確認字在字典\n                Yes → Step 14: 若 newWord 尚未在 distance? // 第一次訪問\n                    Yes → Step 15: distance[newWord] = curDist + 1 // 記錄距離\n                    Yes → Step 16: queue.append(newWord) // 加入隊列\n                No  → Step 17: 若 distance[newWord] != curDist + 1? // 不在同一層\n                    Yes → Step 18: 跳過 // 只處理最短層\n                    No  → Step 19: // 處理同層相鄰\n                Yes → Step 20: graph.setdefault(front, []).append(newWord) // 建立前往新單字的邊\n                Yes → Step 21: graph.setdefault(newWord, []).append(front) // 建立反向邊\n    No  → Step 22: // BFS 迴圈結束\n→ Decision: endWord 是否在 distance? // 是否找到目標\n    Yes → Step 23: 初始化 paths = [] // 儲存所有最短路徑\n    Yes → Step 24: 定義函式 backtrack(current, path)\n        No  → Step 25: 若 current == beginWord // 到達起點\n            No  → Step 26: paths.append([beginWord]+path[::-1]) // 將路徑反轉並加入\n            No  → Step 27: 返回\n        No  → Step 28: for neighbor in graph[current] // 遍歷前一層的鄰居\n            No  → Step 29: 若 distance[neighbor] == distance[current] - 1\n                No  → Step 30: backtrack(neighbor, path+[current]) // 進一步遞歸\n    No  → Step 31: 呼叫 backtrack(endWord, []) // 從終點開始回溯\n    No  → Step 32: 返回 paths // 結果\n    No  → Step 33: 返回空列表 // 沒有路徑\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list) -> list:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find shortest distances and build parent links\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        # DFS to build all paths from endWord back to beginWord\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input() -> tuple:\n    data = sys.stdin.read()\n    bw_match = re.search(r'beginWord\\s*=\\s*\"([^\"]+)\"', data)\n    ew_match = re.search(r'endWord\\s*=\\s*\"([^\"]+)\"', data)\n    wl_match = re.search(r'wordList\\s*=\\s*(\\[.*\\])', data, re.S)\n\n    beginWord = bw_match.group(1) if bw_match else ''\n    endWord = ew_match.group(1) if ew_match else ''\n    wordList = ast.literal_eval(wl_match.group(1)) if wl_match else []\n    return beginWord, endWord, wordList\n\nif __name__ == \"__main__\":\n    beginWord, endWord, wordList = parse_input()\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": true,
          "output": "[['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese, step-by-step, following format. The requirement: input is array of intervals with unique starts. Need to find for each interval i the index j where start_j >= end_i and start_j minimized. If none, -1.\n\nWe need to produce virtual code that likely sorts intervals by start, uses binary search to find right interval for each original index, etc.\n\nWe need to produce virtual code lines:\n\nStart\n→ Step: Build list of intervals with start and original index\n→ Step: Sort list by start\n→ Step: For each interval in original order: binary search in sorted starts for minimal start >= end\n→ Step: If found, record sorted index's original index; else -1\n→ Step: Compile result array\nEnd\n\nWe need to add decision steps if needed.\n\nBut we must produce \"虛擬碼步驟\" per line.\n\nLet's produce lines accordingly.\n\nRemember to add [空格] and // 解釋/說明. Use arrow arrows '→'.\n\nWe must not output actual code, only pseudo code steps.\n\nLet's create lines.\n\nWe might start with \"Start\".\n\nThen arrow lines.\n\nWe need to incorporate decision: e.g., if binary search found index less than length.\n\nWe need to maybe use \"Decision:\".\n\nLet's produce.\n\nAlso must mention \"每行必須包含：`虛擬碼步驟` + [空格] + `// 解釋/說明`\".\n\nLet's do it.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 取得 intervals 並為每個 interval 標記其原始索引 // 將資料與索引對應起來\n→ Step 2: 建立 sortedIntervals = intervals 按 start 升序排序 // 為後續二分搜尋做準備\n→ Step 3: 取出 sortedStarts = sortedIntervals 的 start 列表 // 用於二分搜尋\n→ Decision: 是否存在 interval? // 確認輸入不為空\n    Yes → For i in 0..len(intervals)-1: // 逐個處理原始順序\n        → Step: end_i = intervals[i][1] // 取得當前 interval 的結束值\n        → Step: pos = BinarySearch(sortedStarts, end_i) // 找到第一個 start >= end_i 的位置\n        → Decision: pos < len(sortedStarts) ? // 判斷是否找到符合條件的 interval\n            Yes → Step: result[i] = sortedIntervals[pos].originalIndex // 記錄對應的原始索引\n            No  → Step: result[i] = -1 // 沒有符合條件的 interval\n→ Step 4: 回傳 result // 完成所有 interval 的右 interval 判定\nEnd // 程式執行結束\n\nWe need to incorporate binary search logic maybe as decision. But this is fine.\n\nWe need to add step for binary search function maybe. We can include a separate function.\n\nBetter to add:\n\n→ Step: BinarySearch(sortedStarts, target) // 透過二分搜尋取得最小索引\n\nBut we might skip function definition.\n\nWe can include as pseudo code.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 intervals 並為每個 interval 標記其原始索引 // 將資料與索引對應起來  \n→ Step 2: 建立 sortedIntervals = intervals 按 start 升序排序 // 為後續二分搜尋做準備  \n→ Step 3: 取出 sortedStarts = sortedIntervals 的 start 列表 // 用於二分搜尋  \n→ Decision: 是否存在 interval? // 確認輸入不為空  \n&nbsp;&nbsp;Yes → For i in 0..len(intervals)-1: // 逐個處理原始順序  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step: end_i = intervals[i][1] // 取得當前 interval 的結束值  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step: pos = BinarySearch(sortedStarts, end_i) // 找到第一個 start >= end_i 的位置  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: pos < len(sortedStarts) ? // 判斷是否找到符合條件的 interval  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step: result[i] = sortedIntervals[pos].originalIndex // 記錄對應的原始索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step: result[i] = -1 // 沒有符合條件的 interval  \n→ Step 4: 回傳 result // 完成所有 interval 的右 interval 判定  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport bisect\nfrom ast import literal_eval\n\nclass Solution:\n    def findRightInterval(self, intervals):\n        # 建立開始時間對應索引的列表，並排序\n        starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n        res = []\n        for interval in intervals:\n            # 找到 >= interval[1] 的最小開始時間\n            idx = bisect.bisect_left(starts, (interval[1],))\n            if idx < len(starts):\n                res.append(starts[idx][1])\n            else:\n                res.append(-1)\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，假設格式為 'intervals = [[...], ...]'\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 取得等號右側的表達式並解析成 Python 列表\n    try:\n        _, expr = data.split('=', 1)\n    except ValueError:\n        # 如果沒有等號，直接解析整行\n        expr = data\n    intervals = literal_eval(expr.strip())\n    solution = Solution()\n    result = solution.findRightInterval(intervals)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps explaining algorithm. The problem: equal number of dresses across n washing machines. Known solution: Check if total dresses % n == 0 else -1. Then compute prefix sums and find max of abs(prefix) and difference between current count and avg. The answer is max(max_abs_prefix, max_diff). Implementation steps: compute avg. iterate, track balance and max moves. Virtual code.\n\nWe need to output line by line, each with // explanation. Use virtual arrows. Let's produce steps:\n\nStart\n→ Step 1: Let n = length of machines // Determine number of machines\n→ Step 2: total = sum(machines) // Sum dresses\n→ Step 3: If total % n != 0, return -1 // Unequal distribution impossible\n→ Step 4: avg = total / n // Target dresses per machine\n→ Step 5: balance = 0 // Accumulated surplus/deficit up to current machine\n→ Step 6: maxMoves = 0 // Track minimal moves required\n→ Step 7: For each machine i from 0 to n-1:\n    → Step 7a: balance += machines[i] - avg // Update balance\n    → Step 7b: maxMoves = max(maxMoves, abs(balance), machines[i] - avg) // Update moves\n→ Step 8: Return maxMoves // Minimum moves required\n\nWe need to use Decision maybe? There's if. Use Decision for total % n != 0. Also loop. Provide explanations.\n\nLet's format each line. Use arrows. The loop step maybe: Step 7: For i in 0..n-1 // iterate. Inside.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: n = length of machines // 取得洗衣機數量\n→ Step 2: total = sum(machines) // 計算總衣物數\n→ Decision: 如果 total mod n ≠ 0? // 檢查是否可平均分配\n    Yes → Step 3: return -1 // 不可能，直接回傳\n    No  → Step 3: avg = total / n // 每台洗衣機應有的衣物數\n→ Step 4: balance = 0 // 以往多餘或不足的衣物累積值\n→ Step 5: maxMoves = 0 // 目前需要的最大移動次數\n→ Step 6: For i = 0 to n-1 // 遍歷每台洗衣機\n    → Step 6a: balance += machines[i] - avg // 更新累積差額\n    → Step 6b: temp = max(abs(balance), machines[i] - avg) // 取此台需要的移動次數\n    → Step 6c: maxMoves = max(maxMoves, temp) // 更新答案\n→ Step 7: return maxMoves // 最終答案\n\nBut need each line with `→` arrow? Start uses Start. Use arrow for each step. For decision, show Yes → and No →.\n\nNeed each line ends with `// 解釋`. Use Chinese.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length of machines // 取得洗衣機總數  \n→ Step 2: total = sum(machines) // 計算所有衣物總數  \n→ Decision: 如果 total mod n ≠ 0? // 檢查是否能平均分配  \n    Yes → Step 3: return -1 // 無法平衡，直接回傳  \n    No  → Step 3: avg = total / n // 計算每台洗衣機理想的衣物數  \n→ Step 4: balance = 0 // 用於累積前面機器的盈餘或不足  \n→ Step 5: maxMoves = 0 // 儲存目前需要的最大移動次數  \n→ Step 6: For i = 0 to n-1 // 逐一檢視每台洗衣機  \n    → Step 6a: balance += machines[i] - avg // 更新累積差額  \n    → Step 6b: temp = max(abs(balance), machines[i] - avg) // 此台機器所需的移動量  \n    → Step 6c: maxMoves = max(maxMoves, temp) // 取最大值作為答案  \n→ Step 7: return maxMoves // 回傳最小移動次數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_min_moves(machines):\n    total = sum(machines)\n    n = len(machines)\n    if total % n != 0:\n        return -1\n    avg = total // n\n    res = 0\n    cum_diff = 0\n    for load in machines:\n        diff = load - avg\n        cum_diff += diff\n        res = max(res, abs(cum_diff), diff)\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    machines = ast.literal_eval(data)\n    result = find_min_moves(machines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode657.json",
    "problem_index_in_file": 0,
    "title": "Robot Return to Origin",
    "description_snippet": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for the described problem. Each line must contain virtual code step followed by // explanation. Use arrows and structure.\n\nWe need to start with Start, then steps: initialize x,y to 0, iterate over string moves, update coordinates, after loop check if x==0 and y==0 return true else false. Then End.\n\nWe must not output actual code, just virtual steps. Each step is \"→ Step N: ...\" etc.\n\nWe need to incorporate decisions, loops. Use Decision: for each move char maybe use switch or if else. For loop: \"→ Loop over moves: for each char in moves\". But we might need to show loop as step, then inside update.\n\nSimplify: Step 1: Initialize x, y. Step 2: For each move in moves: Decision: if move == 'R'? etc. Update coordinates. Step 3: After loop, Decision: if x == 0 and y == 0? Yes -> return true, No -> return false. End.\n\nWe must use \"Yes →\" and \"No →\" for decisions.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化座標 x, y 為 0 // 設定起點為原點\n→ Step 2: 對 moves 中的每一個字元進行迭代 // 逐步處理每一步移動\n    → Decision: 是否為 'R'? // 判斷目前步驟\n        Yes → Step 3a: x ← x + 1 // 向右移動\n        No  → Decision: 是否為 'L'? \n            Yes → Step 3b: x ← x - 1 // 向左移動\n            No  → Decision: 是否為 'U'?\n                Yes → Step 3c: y ← y + 1 // 向上移動\n                No  → Decision: 是否為 'D'?\n                    Yes → Step 3d: y ← y - 1 // 向下移動\n                    No  → Step 3e: // 無效字符，忽略\n→ Step 4: 完成所有移動後，檢查是否回到原點 // 判斷最終座標\n    → Decision: x == 0 且 y == 0? \n        Yes → Step 5: 返回 true // 成功回到原點\n        No  → Step 6: 返回 false // 未回到原點\nEnd\n\nMake sure each line has the arrow and explanation. Need to maintain indentation maybe with spaces. Provide exactly as format. Use \"→\" before each step. For decisions we use \"Decision: ...\". For Yes and No branches use \"Yes →\" and \"No →\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化座標 x, y 為 0 // 設定起點為原點  \n→ Step 2: 對 moves 中的每一個字元進行迭代 // 逐步處理每一步移動  \n  → Decision: 是否為 'R'? // 判斷目前步驟  \n   Yes → Step 3a: x ← x + 1 // 向右移動  \n   No → Decision: 是否為 'L'?  \n    Yes → Step 3b: x ← x - 1 // 向左移動  \n    No → Decision: 是否為 'U'?  \n     Yes → Step 3c: y ← y + 1 // 向上移動  \n     No → Decision: 是否為 'D'?  \n      Yes → Step 3d: y ← y - 1 // 向下移動  \n      No → Step 3e: // 無效字符，忽略  \n→ Step 4: 完成所有移動後，檢查是否回到原點 // 判斷最終座標  \n  → Decision: x == 0 且 y == 0?  \n   Yes → Step 5: 返回 true // 成功回到原點  \n   No → Step 6: 返回 false // 未回到原點  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'U':\n                y += 1\n            elif move == 'D':\n                y -= 1\n            elif move == 'L':\n                x -= 1\n            elif move == 'R':\n                x += 1\n        return x == 0 and y == 0\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # If the input contains an assignment like 'moves = \"UD\"'\n    if '=' in data:\n        moves_part = data.split('=', 1)[1]\n    else:\n        moves_part = data\n    moves = moves_part.strip().strip('\"\\'')\n    solution = Solution()\n    result = solution.judgeCircle(moves)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "moves = \"UD\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "moves = \"LL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode738.json",
    "problem_index_in_file": 0,
    "title": "Monotone Increasing Digits",
    "description_snippet": "An integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisf...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find largest number <= n with monotone increasing digits (digits non-decreasing). Approach: convert to string, iterate, find first place where digits decrease (prev > curr). Then decrement digit at that place by 1, set all following digits to 9, and then ensure previous digits may still violate monotonicity, so backtrack while previous > current.\n\nStandard solution: convert to list of digits, iterate from left to right: for i in 1..len-1, if digits[i] < digits[i-1], then we found violation. We decrement digits[i-1] by 1, set all following digits to 9, then while i-2 >=0 and digits[i-1] < digits[i-2], adjust similarly. But easier: after decrement, set all following to 9, then while the sequence is not monotone, we adjust previous. Standard algorithm: after find i where digits[i] < digits[i-1], set digits[i-1] -=1, set all j>=i to 9. Then set i = i-1, while i>0 and digits[i] < digits[i-1], repeat decrement and set following to 9. Then return number.\n\nWe need to produce virtual code step by step with explanations.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Use arrows. We'll produce start, step to convert, etc.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 將 n 轉成字元陣列 digits // 方便逐位操作\n→ Step 2: 設 i = 1 // 從第二位開始檢查\n→ Decision: 是否存在 i < len(digits) 且 digits[i] < digits[i-1]? // 找出第一個下降點\n    Yes → Step 3: digits[i-1] ← digits[i-1] - 1 // 將前一位減 1\n    → Step 4: 對 j 從 i 到 len-1, digits[j] ← 9 // 後續位全設為 9\n    → Step 5: i ← i - 1 // 退回到前一位\n    → Decision: i > 0 且 digits[i] < digits[i-1]? // 仍可能不單調\n        Yes → 重複 Step 3-5 // 迴圈\n        No  → 跳出循環\n    No  → 跳過\n→ Step 6: 將 digits 轉回整數 result // 回傳結果\nEnd // 程式結束\n\nWe need to include each line with explanation.\n\nLet's produce more granular steps: Use decision blocks.\n\nWe should show indentation. Use arrow to represent flow.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 n 轉成字元陣列 digits // 方便逐位檢查  \n→ Step 2: 設 i = 1 // 從第二個位數開始檢查  \n→ Decision: 是否存在 i < len(digits) 且 digits[i] < digits[i-1]? // 找第一個下降位置  \n    Yes → Step 3: digits[i-1] ← digits[i-1] - 1 // 前一位減 1  \n    → Step 4: 對 j 從 i 到 len(digits)-1, digits[j] ← 9 // 後面所有位設為 9  \n    → Step 5: i ← i - 1 // 退回到前一位重新檢查  \n    → Decision: i > 0 且 digits[i] < digits[i-1]? // 是否還有不單調的地方  \n        Yes → 轉到 Step 3 重複減 1 與設定 9 的流程  \n        No  → 跳出循環  \n    No  → 直接跳過後續處理（已經單調）  \n→ Step 6: 將 digits 轉回整數 result // 重新組合為數字  \n→ End // 程式執行結束並回傳結果",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def monotoneIncreasingDigits(self, n: int) -> int:\n        \"\"\"\n        Return the largest number <= n that has monotone increasing digits.\n        \"\"\"\n        digits = list(str(n))          # 逐位操作\n        i = 1\n        # 找到第一個下降位置\n        while i < len(digits) and digits[i] >= digits[i - 1]:\n            i += 1\n        if i < len(digits):            # 仍存在下降\n            # 從該位置往前調整，確保不再下降\n            while i > 0 and digits[i] < digits[i - 1]:\n                digits[i - 1] = str(int(digits[i - 1]) - 1)\n                i -= 1\n            # 後面的位數全設為 9\n            for j in range(i + 1, len(digits)):\n                digits[j] = '9'\n        return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，並找出第一個數字作為 n\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        sys.exit(0)  # 沒有找到數字，直接退出\n    n = int(match.group())\n    result = Solution().monotoneIncreasingDigits(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "n = 1234",
          "expected_output": "1234",
          "success": true,
          "output": "1234"
        },
        {
          "example_index": 2,
          "input": "n = 332",
          "expected_output": "299",
          "success": true,
          "output": "299"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode729.json",
    "problem_index_in_file": 0,
    "title": "My Calendar I",
    "description_snippet": "You are implementing a program to use as your calendar. We can add a new event if adding the event w...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for MyCalendar class, describing steps. Provide line-by-line. We'll include a data structure: list of intervals. For book: iterate over existing intervals, check overlap. If none, add interval, return true else false.\n\nLet's craft virtual code. Use Start, End. We need to include arrow syntax. We'll present the class, constructor, book method. Each line is virtual code step. For loops etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCalendar 類別 // 宣告類別結構\n→ Step 2: 宣告 events 為空列表 // 用於儲存已預約的時間區間\n→ Step 3: MyCalendar() // 建構子\n    → Step 4: 初始化 events 為 [] // 空清單，無任何事件\n→ Step 5: book(start, end) // 企圖新增一個事件\n    → Step 6: Decision: 是否有與任何已存在事件重疊？ // 檢查可能的衝突\n        Yes → Step 7: 返回 False // 有衝突，不能預約\n        No  → Step 8: events.Add( (start, end) ) // 無衝突，加入新事件\n        → Step 9: 返回 True // 成功預約\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\n# ------------------------------\n# MyCalendar 類別，負責管理日曆預約\n# ------------------------------\nclass MyCalendar:\n    def __init__(self):\n        # 使用 list 來儲存已預約的時間區間 (start, end)\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        嘗試新增一個區間 [start, end)。\n        若與任何已存在的區間有重疊，回傳 False 並不新增。\n        若無重疊，將區間加入 bookings，回傳 True。\n        \"\"\"\n        for s, e in self.bookings:\n            # 若 max(s, start) < min(e, end) 則表示兩區間相交\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\n# ------------------------------\n# 主程式，處理標準輸入並輸出結果\n# ------------------------------\nif __name__ == \"__main__\":\n    # 讀取所有輸入（可能包含多行）\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將輸入包裝成合法的 JSON 陣列，方便解析\n    # 原始輸入形式：[\"MyCalendar\", \"book\", ...], [[], [10,20], ...]\n    wrapped_input = \"[\" + raw_input + \"]\"\n\n    # 解析為 Python 物件\n    try:\n        data = json.loads(wrapped_input)\n    except json.JSONDecodeError:\n        # 若解析失敗，直接結束\n        sys.exit()\n\n    # 第一個子清單是方法名，第二個是對應的參數\n    operations, arguments = data[0], data[1]\n\n    # 建立日曆實例\n    calendar = MyCalendar()\n    # 结果列表，第一個結果為 None（相當於 LeetCode 的 null）\n    results = [None]\n\n    # 依次執行每個操作\n    for op, args in zip(operations[1:], arguments[1:]):\n        if op == \"book\":\n            # args 為 [start, end]\n            res = calendar.book(args[0], args[1])\n            results.append(res)\n        else:\n            # 若有其他操作，暫時忽略（本題僅包含 book）\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以取得符合題目要求的格式\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "success": true,
          "output": "[null, true, false, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search approach. Use Start, Decision, etc. Provide explanation each line. Use arrow. Probably need to show initialization, loop, etc. Ensure no actual code. Use English? The requirement: output in Traditional Chinese. So explanations should be Chinese. Use \"Start\", \"End\". Let's craft.\n\nLines:\nStart\n→ Step 1: Initialize left=1, right=n // set search boundaries\n→ Decision: while left < right? // loop until boundaries meet\n    Yes → Step 2: mid = (left + right) // 2 // compute middle version\n    → Decision: isBadVersion(mid)? // check if mid is bad\n        Yes → Step 3: right = mid // bad means first bad is at or before mid\n        No  → Step 4: left = mid + 1 // good means first bad after mid\n    No  → Step 5: return left // left is first bad\nEnd\n\nBut we need to maintain while loop structure: The Decision for while left < right? The steps inside loop. Use arrows for indentation.\n\nMake sure each line contains `虛擬碼步驟` and comment. Use spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 1, right = n // 初始化搜尋範圍  \n→ Decision: 迴圈條件 left < right? // 當左邊界小於右邊界時持續搜尋  \n Yes → Step 2: 計算 mid = (left + right) // 2 // 取中間版本  \n → Decision: isBadVersion(mid)? // 判斷中間版本是否為壞版本  \n  Yes → Step 3: right = mid // 壞版本在 mid 或更早，縮小右邊界  \n  No  → Step 4: left = mid + 1 // 好版本，第一個壞版本必在右邊，移動左邊界  \n No → Step 5: 回傳 left // left 即為第一個壞版本  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Simulated API: returns True if the version is bad or later\ndef isBadVersion(version: int) -> bool:\n    return version >= _BAD_VERSION\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw = sys.stdin.read().strip()\n    # Extract all integers (handles formats like \"n = 5, bad = 4\" or \"5 4\")\n    nums = list(map(int, re.findall(r'\\d+', raw)))\n    if len(nums) < 2:\n        raise ValueError(\"Input must contain at least two integers: n and bad\")\n    n, bad = nums[0], nums[1]\n    # Store bad version for the simulated API\n    _BAD_VERSION = bad\n    # Compute the first bad version\n    result = Solution().firstBadVersion(n)\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find target in rotated sorted array with duplicates. The classic problem: Search in Rotated Sorted Array II. Use binary search with duplicates. Steps: Start, initialize low=0 high=nums.length-1, while low<=high: mid, if nums[mid]==target return true. Then if nums[low]==nums[mid]==nums[high], low++ high-- else if nums[low]<=nums[mid], left sorted else right sorted. If target in sorted half, adjust accordingly else the other half. Finally return false. Also need handle duplicates at boundaries.\n\nWe need produce step-by-step virtual code with explanations after each line. Format:\n\nStart // start\n\n→ Step: init low/high\n\n→ Decision: while low <= high?\n\n   Yes → ... and inside.\n\nWithin loop:\n\n   Step: compute mid\n\n   Decision: if nums[mid]==target? Yes → return true, No → continue\n\n   Decision: if nums[low]==nums[mid]==nums[high]? Yes → low++ high-- continue\n\n   Decision: if nums[low] <= nums[mid]? Yes → left sorted\n\n        Decision: if target >= nums[low] and target <= nums[mid]? Yes → high=mid-1 else low=mid+1\n\n        No → right sorted\n\n        Decision: if target >= nums[mid] and target <= nums[high]? Yes → low=mid+1 else high=mid-1\n\n   No → left sorted not true, so right sorted etc.\n\nAfter loop End return false.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\".\n\nWe must use \"Start\", \"End\", \"Decision:\", \"→\" arrows.\n\nMake sure to include indentation for decisions: indent two spaces maybe.\n\nLet's produce.\n\nAlso we need to mention \"Step\" maybe \"Step\" as prefix.\n\nLet's craft.\n\nExample:\n\nStart // 程式開始執行\n\n→ Step: low = 0, high = nums.length - 1 // 初始化搜尋區間\n\n→ Decision: low <= high? // 判斷是否仍有區間可搜尋\n\n    Yes → Step: mid = (low + high) / 2 // 取中間索引\n\n    Yes → Decision: nums[mid] == target? // 判斷中間是否為目標\n\n        Yes → Return true // 找到目標，結束\n\n        No  → Decision: nums[low] == nums[mid] && nums[mid] == nums[high]? // 兩端相同值，無法確定排序\n\n            Yes → Step: low = low + 1, high = high - 1 // 移除重複邊界，縮小搜尋範圍\n\n            No  → Decision: nums[low] <= nums[mid]? // 判斷左半段是否有序\n\n                Yes → Decision: target >= nums[low] && target <= nums[mid]? // 目標是否在左有序區間\n\n                    Yes → Step: high = mid - 1 // 搜尋左半段\n\n                    No  → Step: low = mid + 1 // 搜尋右半段\n\n                No  → Decision: target >= nums[mid] && target <= nums[high]? // 目標是否在右有序區間\n\n                    Yes → Step: low = mid + 1 // 搜尋右半段\n\n                    No  → Step: high = mid - 1 // 搜尋左半段\n\n    No → End // 搜尋結束未找到\n\nReturn false // 回傳未找到結果\n\nBut we must use \"End\" only at end, not earlier. We should structure with End after loop.\n\nLet's refine.\n\nAfter while loop, we output return false.\n\nWe need to ensure the format includes only virtual code lines, no actual code.\n\nAlso we must not output actual code like \"return true\". Use \"Return true\" as step.\n\nWe can use \"Return true\" as step.\n\nWe also must use \"Start\" and \"End\".\n\nWe should produce:\n\nStart // 程式開始執行\n\n→ Step: low = 0, high = nums.length - 1 // 初始化搜尋區間\n\n→ Decision: low <= high? // 是否仍有可搜尋區間\n\n    Yes → Step: mid = (low + high) / 2 // 計算中間索引\n\n    Yes → Decision: nums[mid] == target? // 判斷中間是否為目標\n\n        Yes → Return true // 找到目標，結束\n\n        No  → Decision: nums[low] == nums[mid] && nums[mid] == nums[high]? // 邊界重複，無法確定排序\n\n            Yes → Step: low = low + 1, high = high - 1 // 移除邊界，縮小搜尋範圍\n\n            No  → Decision: nums[low] <= nums[mid]? // 判斷左半段是否有序\n\n                Yes → Decision: target >= nums[low] && target <= nums[mid]? // 目標是否在左有序區間\n\n                    Yes → Step: high = mid - 1 // 搜尋左半段\n\n                    No  → Step: low = mid + 1 // 搜尋右半段\n\n                No  → Decision: target >= nums[mid] && target <= nums[high]? // 目標是否在右有序區間\n\n                    Yes → Step: low = mid + 1 // 搜尋右半段\n\n                    No  → Step: high = mid - 1 // 搜尋左半段\n\n    No → End // 迴圈結束\n\nReturn false // 未找到目標，回傳 false\n\nBut we need to indent decisions accordingly.\n\nWe need to ensure \"End\" occurs after loop, not before. So we should structure as:\n\n→ Decision: low <= high? // 判斷是否仍有可搜尋區間\n\n    Yes → (body)\n\n    No  → End // 迴圈結束\n\nBut we also need after End to output Return false.\n\nLet's produce final.\n\nAlso we should ensure \"Return false\" is after End. Use \"Return false\" as step.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: low = 0, high = nums.length - 1 // 初始化搜尋區間  \n\n→ Decision: low <= high? // 判斷是否仍有可搜尋區間  \n    Yes → Step: mid = (low + high) / 2 // 取中間索引  \n    Yes → Decision: nums[mid] == target? // 判斷中間是否為目標  \n        Yes → Return true // 找到目標，結束  \n        No  → Decision: nums[low] == nums[mid] && nums[mid] == nums[high]? // 邊界相同，無法確定排序  \n            Yes → Step: low = low + 1, high = high - 1 // 移除重複邊界，縮小搜尋範圍  \n            No  → Decision: nums[low] <= nums[mid]? // 判斷左半段是否有序  \n                Yes → Decision: target >= nums[low] && target <= nums[mid]? // 目標在左有序區間？  \n                    Yes → Step: high = mid - 1 // 搜尋左半段  \n                    No  → Step: low = mid + 1 // 搜尋右半段  \n                No  → Decision: target >= nums[mid] && target <= nums[high]? // 目標在右有序區間？  \n                    Yes → Step: low = mid + 1 // 搜尋右半段  \n                    No  → Step: high = mid - 1 // 搜尋左半段  \n    No  → End // 迴圈結束，未找到目標  \n\nReturn false // 未找到目標，回傳 false",
      "generated_code": "import sys\nimport re\nfrom ast import literal_eval\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\ndef parse_input(data):\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not target_match:\n        return [], None\n    nums_str = nums_match.group(1)\n    target_str = target_match.group(1)\n    nums = literal_eval(nums_str)\n    target = int(target_str)\n    return nums, target\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums, target = parse_input(data)\n    sol = Solution()\n    result = sol.search(nums, target)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode648.json",
    "problem_index_in_file": 0,
    "title": "Replace Words",
    "description_snippet": "In English, we have a concept called root, which can be followed by some other word to form another ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described algorithm: Given dictionary of roots, and sentence words, replace each word with the shortest root that is prefix. So algorithm: split sentence into words, for each word, find candidate roots that are prefix of word, choose shortest. Replace. Complexity O(n * m * L) etc. Use trie for efficiency maybe. Provide virtual steps with Start, End, Decision, etc.\n\nLet's produce steps:\n\nStart\n→ Load dictionary into trie // Build prefix tree\n→ Split sentence into words // tokenize by spaces\n→ Initialize result list\n→ For each word in words:\n    → Initialize replacement = word\n    → Search trie for shortest prefix that matches word\n    → If found:\n        → replacement = matched root\n    → Append replacement to result list\n→ Join result list with spaces into new sentence\n→ Output new sentence\nEnd\n\nNeed to use arrow lines and decision.\n\nLet's produce step-by-step:\n\nStart // 程式開始執行\n→ BuildTrie roots // 建立前綴樹以快速搜尋根字\n→ words = Split(sentence, ' ') // 將句子切分為單字\n→ result = [] // 儲存處理後的單字\n→ ForEach word in words: // 逐字處理\n    → prefix = FindShortestPrefix(word, trie) // 找出最短的前綴根\n    → If prefix != null:\n        → replacement = prefix // 若找到符合的根，替換\n        → Else replacement = word // 若無符合，保留原字\n    → Append replacement to result\n→ newSentence = Join(result, ' ') // 重新組合為句子\n→ Output newSentence // 回傳結果\nEnd // 程式執行結束\n\nBut need to fit arrow and decision style. Use Decision: if prefix exists?\n\nLet's craft:\n\nStart // 程式開始執行\n→ BuildTrie roots // 建立前綴樹\n→ words = Split(sentence, ' ') // 將句子拆成單字\n→ result = [] // 儲存結果\n→ ForEach word in words: // 逐字處理\n    → prefix = FindShortestPrefix(word, trie) // 搜尋最短前綴\n    → Decision: prefix ？ // 是否找到符合根\n        Yes → replacement = prefix // 用根替換\n        No  → replacement = word // 保留原字\n    → Append replacement to result\n→ newSentence = Join(result, ' ') // 重新組合\n→ Output newSentence // 結果輸出\nEnd // 程式結束\n\nWe might include decision inside loop. The arrow lines should be indented maybe.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildTrie roots // 建立前綴樹以快速搜尋根字  \n→ words = Split(sentence, ' ') // 將句子拆成單字  \n→ result = [] // 用於儲存處理後的單字  \n→ ForEach word in words: // 逐字處理  \n  → prefix = FindShortestPrefix(word, trie) // 搜尋最短的前綴根  \n  → Decision: prefix 存在？ // 是否找到符合的根  \n   Yes → replacement = prefix // 用根替換詞  \n   No  → replacement = word // 若無則保留原詞  \n  → Append replacement to result // 加入結果清單  \n→ newSentence = Join(result, ' ') // 重新組合為完整句子  \n→ Output newSentence // 回傳替換後的句子  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        trie = {}\n        END = True\n\n        # 建立 Trie\n        for root in dictionary:\n            node = trie\n            for char in root:\n                node = node.setdefault(char, {})\n            node[END] = root\n\n        def replace(word):\n            node = trie\n            for char in word:\n                if char not in node:\n                    break\n                node = node[char]\n                if END in node:\n                    return node[END]\n            return word\n\n        return ' '.join(map(replace, sentence.split()))\n\ndef parse_input(text: str):\n    \"\"\"\n    從形如\n    'dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"'\n    的字串中解析出 dictionary 與 sentence。\n    \"\"\"\n    dict_match = re.search(r'dictionary\\s*=\\s*(\\[[^\\]]*\\])', text)\n    sent_match = re.search(r'sentence\\s*=\\s*\"(.*?)\"', text)\n    if not dict_match or not sent_match:\n        return [], ''\n    dictionary = ast.literal_eval(dict_match.group(1))\n    sentence = sent_match.group(1)\n    return dictionary, sentence\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    dictionary, sentence = parse_input(data)\n\n    solution = Solution()\n    result = solution.replaceWords(dictionary, sentence)\n\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "success": true,
          "output": "the cat was rat by the bat"
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "success": true,
          "output": "a a b c"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Problem: Minimum intervals to remove to make rest non-overlapping. Classic: sort by end, greedily keep non-overlapping, count removals. Steps: sort intervals by end ascending. Initialize count=0, prevEnd = -inf. For each interval, if start>=prevEnd: keep, prevEnd=interval.end else count++ (remove). At end return count.\n\nWe need virtual code lines: Start, etc. Use arrow. Each line must include \"虛擬碼步驟\" + space + // 解釋. Provide step by step.\n\nLet's create steps:\n\nStart\n→ Step 1: Sort intervals by ascending end // 排序以利貪心\n→ Step 2: Set count = 0 // 記錄需要移除的區間數\n→ Step 3: Set prevEnd = -∞ // 前一個保留區間的結束點\n→ Step 4: For each interval in sorted intervals: // 遍歷所有區間\n   → Decision: 如果 interval.start >= prevEnd? // 判斷是否與前一個重疊\n        Yes → Step 5: prevEnd = interval.end // 更新最後保留的結束點\n        No  → Step 6: count++ // 需要移除此區間\n→ Step 7: Return count // 回傳最小移除數\n\nNeed to embed indentation. Use arrow for decisions: \"Decision: ...?\" lines with Yes/No. Indent inside.\n\nMake sure to use Chinese explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by ascending end // 將區間以結束點升序排列，方便貪心選擇  \n→ Step 2: Set count = 0 // 初始化需要移除的區間計數  \n→ Step 3: Set prevEnd = -∞ // 設定前一個保留區間的結束點為負無限，初始不限制  \n→ Step 4: For each interval in sorted intervals: // 遍歷已排序的所有區間  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: 如果 interval.start >= prevEnd? // 判斷當前區間是否與前一個保留區間不重疊  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: prevEnd = interval.end // 不重疊，將此區間保留並更新結束點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: count++ // 重疊，需將此區間移除，計數加一  \n→ Step 7: Return count // 回傳最小移除區間數量，使剩餘區間無重疊  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"Return the minimum number of intervals to remove so that the rest\n        do not overlap.  Intervals that only touch at a point are considered\n        non‑overlapping.\"\"\"\n        if not intervals:\n            return 0\n\n        # Sort intervals by their ending times (ascending).\n        intervals.sort(key=lambda x: x[1])\n\n        # Keep track of the end of the last interval that we decided to keep.\n        last_end = intervals[0][1]\n        non_overlap_count = 1  # We keep the first interval.\n\n        # Iterate through the remaining intervals.\n        for start, end in intervals[1:]:\n            if start >= last_end:          # No overlap with the last kept interval.\n                last_end = end             # Update the end marker.\n                non_overlap_count += 1     # We keep this interval.\n\n        # The number of intervals to remove equals total minus kept.\n        return len(intervals) - non_overlap_count\n\ndef parse_input(input_str: str):\n    \"\"\"Parse the input string to extract the list of intervals.\"\"\"\n    # Remove leading/trailing whitespace.\n    input_str = input_str.strip()\n    # Expect format like: intervals = [[1,2],[2,3]]\n    if '=' in input_str:\n        _, value = input_str.split('=', 1)\n    else:\n        value = input_str\n    # Use ast.literal_eval for safe evaluation.\n    return ast.literal_eval(value)\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin.\n    raw_input = sys.stdin.read()\n    # Parse the input to get the intervals list.\n    intervals = parse_input(raw_input)\n\n    # Compute the answer using the Solution class.\n    sol = Solution()\n    result = sol.eraseOverlapIntervals(intervals)\n\n    # Print the result to stdout.\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode710.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Blacklist",
    "description_snippet": "You are given an integer n and an array of unique integers blacklist. Design an algorithm to pick a ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code lines with comments. Must follow format: \"虛擬碼步驟 // 解釋\". Must use Start, End, Decision, Yes/No arrows.\n\nWe need design algorithm: mapping allowed numbers < n-b count mapping. Approach: Count m = n - len(blacklist). Store map of blacklisted numbers that are < m to corresponding allowed numbers >= m. Use random range [0, m-1]. If chosen in map, map to mapped value else return. That reduces random calls.\n\nImplement Solution constructor: store m, map dictionary. pick() randomInt(m). if in map -> return map[x] else return x.\n\nAlso provide algorithm for building mapping: iterate blacklist; for each b < m, find replacement from end of range (n-1 downwards) not in blacklist; map[b] = replacement; decrement candidate.\n\nWe need virtual code line by line. Let's produce.\n\nNeed to include Start and End. Use Decision for if statements. Use arrows.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 計算 m = n - blacklist.length // 可選數量\n→ Step 2: 初始化 map = 空字典 // 用於映射黑名單內的數\n→ Step 3: 初始化 candidate = n - 1 // 從最大值開始尋找替代\n\n→ Step 4: Decision: blacklist 是否為空? // 判斷是否有黑名單\n    Yes → End // 若無黑名單，直接結束初始化\n    No  → Decision: 迭代每個 b in blacklist? // 為每個黑名單元素進行處理\n        Yes → Decision: b < m? // 只處理小於可選範圍的黑名單\n            Yes → Decision: candidate 在 blacklist? // 確保替代不在黑名單\n                Yes → Step 5: candidate = candidate - 1 // 向下移動\n                No  → Step 6: map[b] = candidate // 建立映射\n                     → Step 7: candidate = candidate - 1 // 之後繼續尋找\n            No  → No action // 大於等於 m 的黑名單不影響映射\n        No  → No action // 完成所有黑名單元素的處理\n\n→ End // 初始化完成，準備呼叫 pick()\n\nStart // pick 方法執行\n\n→ Step 8: x = randomInt(m) // 產生 0 到 m-1 的隨機數\n→ Step 9: Decision: x in map? // 檢查是否需要映射\n    Yes → Step 10: return map[x] // 返回映射值\n    No  → Step 11: return x // 直接返回原值\n\nEnd // pick 方法結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    result = []\n    sol = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            n, bl = arg\n            sol = Solution(n, bl)\n            result.append(None)\n        elif op == \"pick\":\n            result.append(sol.pick())\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,6,0,4,0,0,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 6, 0, 4, 0, 0, 0, 4]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode677.json",
    "problem_index_in_file": 0,
    "title": "Map Sum Pairs",
    "description_snippet": "Design a map that allows you to do the following:\n\nMaps a string key to a given value.\nReturns the s...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, for a MapSum implementation: insertion, prefix sum. Use trie with storing sums. Virtual code lines: Start, steps, decisions, etc. Let's produce.\n\nOutline:\n\n- Class MapSum\n- Data structure: TrieNode with children map and sum (int).\n- Insert: traverse characters, add new nodes, update sums difference.\n- sum: traverse prefix, return node sum.\n\nWe need to output each line with virtual code + comment.\n\nWe'll write like:\n\nStart\n→ Step: Define class MapSum\n→ Step: Define TrieNode structure with children map and sum\n→ Step: Initialize root node\n→ Step: insert(key, val)\n   → Step: If key exists, get oldVal = current value, diff = val - oldVal else diff = val\n   → Step: Set key value in map\n   → Step: Traverse nodes updating sum with diff\n→ Step: sum(prefix)\n   → Step: Traverse nodes following prefix, if missing return 0\n   → Step: Return node.sum\nEnd\n\nUse Decision: if key exists? etc.\n\nWe need to use arrow syntax. Let's produce.\n\nWe'll number steps? Not required. Use labels like Step 1, etc.\n\nInclude \"Decision:\" lines.\n\nLet's craft.\n\nWe need to ensure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義 MapSum 類別 // 建立主類別  \n→ Step: 定義 TrieNode 結構  \n  → 子節點: Map\\<char, TrieNode\\> children // 儲存子節點  \n  → int sum // 此節點前綴對應的所有值總和  \n  → int val // 若為完整 key 則存值，否則 0  \n→ Step: 建立 root 節點 // 樹根，代表空前綴  \n→ Step: 建立 keyToVal Map\\<String, Integer\\> // 儲存 key 與其當前值  \n\n→ Step: insert(String key, int val) // 插入或覆寫 key  \n  → Decision: 如果 key 在 keyToVal 中? // 判斷 key 是否已存在  \n    Yes → Step: int oldVal = keyToVal.get(key) // 取得舊值  \n    No  → Step: int oldVal = 0 // 沒有舊值  \n  → Step: int diff = val - oldVal // 計算值差異  \n  → Step: keyToVal.put(key, val) // 更新 key 的值  \n  → Step: TrieNode node = root // 從根開始  \n  → Step: For each char c in key  \n    → Decision: 如果 node.children 沒有 c? // 檢查子節點是否存在  \n      Yes → Step: node.children.put(c, new TrieNode()) // 建立新節點  \n      No  → Step: // 子節點已存在，直接使用  \n    → Step: node = node.children.get(c) // 進入子節點  \n    → Step: node.sum += diff // 更新此前綴的總和  \n  → Step: node.val = val // 設定完整 key 的值  \n\n→ Step: sum(String prefix) // 取得以 prefix 為前綴的總和  \n  → Step: TrieNode node = root // 從根開始  \n  → Step: For each char c in prefix  \n    → Decision: 如果 node.children 沒有 c? // 前綴不存在  \n      Yes → Step: return 0 // 沒有符合前綴，總和為 0  \n      No  → Step: node = node.children.get(c) // 進入子節點  \n  → Step: return node.sum // 回傳前綴對應的總和  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    __slots__ = ('children', 'sum', 'val')\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n        self.val = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_to_val = {}\n\n    def insert(self, key: str, val: int) -> None:\n        old_val = self.key_to_val.get(key, 0)\n        diff = val - old_val\n        self.key_to_val[key] = val\n\n        node = self.root\n        node.sum += diff\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += diff\n        node.val = val\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    wrapped = '[' + data + ']'\n    try:\n        methods, args_list = json.loads(wrapped)\n    except json.JSONDecodeError:\n        sys.exit()\n    ms = MapSum()\n    outputs = []\n    for method, args in zip(methods, args_list):\n        if method == 'MapSum':\n            outputs.append(None)\n        elif method == 'insert':\n            ms.insert(*args)\n            outputs.append(None)\n        elif method == 'sum':\n            res = ms.sum(args[0])\n            outputs.append(res)\n    print(json.dumps(outputs))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "success": true,
          "output": "[null, null, 3, null, 5]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step, with each line including explanation. Use Start, End, Decision, etc. Must reflect solution to problem: find single number appearing once while others thrice. Use bit manipulation: count bits mod 3. Approach: use two variables bitmask1, bitmask2 to store bits seen once and twice. The standard algorithm: for each num, update ones, twos: ones = (ones ^ num) & ~twos; twos = (twos ^ num) & ~ones; At end, ones contains the unique number.\n\nWe need to present pseudocode line by line with explanation, using arrow style.\n\nLet's produce steps:\n\nStart\n→ Initialize ones = 0 // bits seen once\n→ Initialize twos = 0 // bits seen twice\n→ For each num in nums: // iterate array\n    → Update ones: temp = ones ^ num // toggle bits for ones\n    → Update twos: twos = twos ^ num // toggle bits for twos\n    → Update ones: ones = temp & ~twos // keep bits that are not in twos\n    → Update twos: twos = twos & ~ones // keep bits that are not in ones\nDecision? maybe not needed. After loop\n→ Return ones // the unique number\nEnd\n\nBut need to preserve algorithm correctness: Actually the algorithm uses simultaneous update: ones = (ones ^ num) & ~twos; twos = (twos ^ num) & ~ones; But we can break into steps. Provide explanation.\n\nAlso we can include Decision: maybe to check if ones & twos after update? Not necessary.\n\nBetter to show:\n\nStart\n→ ones = 0 // bits that have appeared 1 mod 3\n→ twos = 0 // bits that have appeared 2 mod 3\n→ For each num in nums\n    → ones = (ones XOR num) AND NOT twos // update ones\n    → twos = (twos XOR num) AND NOT ones // update twos\n→ Return ones // unique element\nEnd\n\nBut the algorithm uses updated ones inside twos calculation; but we need to compute twos after ones updated, which is fine.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ ones = 0 // 用來紀錄每個位元出現一次的累積結果\n→ twos = 0 // 用來紀錄每個位元出現兩次的累積結果\n→ For each num in nums // 逐一遍歷陣列\n    → ones = (ones XOR num) AND NOT twos // 更新一次出現的位元，同時排除已經出現兩次的位元\n    → twos = (twos XOR num) AND NOT ones // 更新兩次出現的位元，同時排除已經出現一次的位元\n→ Return ones // ones 中剩餘的位元即為唯一出現一次的數字\nEnd // 程式執行結束\n\nBut each line must follow format: \"虛擬碼步驟 // 解釋\". Also use arrow indicator: → Step etc. Might need \"→\" at start of each line after Start. Let's produce like:\n\nStart // 程式開始執行\n→ ones = 0 // 初始化一次出現的位元累積器\n→ twos = 0 // 初始化兩次出現的位元累積器\n→ For each num in nums // 遍歷輸入陣列\n    → ones = (ones XOR num) AND NOT twos // 先更新一次出現的位元，排除已經出現兩次的位元\n    → twos = (twos XOR num) AND NOT ones // 再更新兩次出現的位元，排除已經出現一次的位元\n→ Return ones // 唯一數字的位元位於 ones\nEnd // 程式結束\n\nBut the \"For each num in nums\" line might not be a step but a loop. Should maintain indent? Use arrow and indentation as in example: \"→ For each num in nums:\" then next lines under indentation. Example in requirement: They used indentation in the Decision block. We can replicate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ ones = 0 // 初始化一次出現的位元累積器\n→ twos = 0 // 初始化兩次出現的位元累積器\n→ For each num in nums // 遍歷輸入陣列\n    → ones = (ones XOR num) AND NOT twos // 更新一次出現的位元，排除已經出現兩次的位元\n    → twos = (twos XOR num) AND NOT ones // 更新兩次出現的位元，排除已經出現一次的位元\n→ Return ones // 唯一數字的位元位於 ones\nEnd // 程式結束\n\nWe need to add spaces properly: after arrow and before code.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ ones = 0 // 初始化一次出現的位元累積器  \n→ twos = 0 // 初始化兩次出現的位元累積器  \n→ For each num in nums // 遍歷輸入陣列  \n    → ones = (ones XOR num) AND NOT twos // 更新一次出現的位元，排除已經出現兩次的位元  \n    → twos = (twos XOR num) AND NOT ones // 更新兩次出現的位元，排除已經出現一次的位元  \n→ Return ones // 唯一數字的位元位於 ones  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def singleNumber(self, nums):\n        ones, twos = 0, 0\n        for num in nums:\n            ones = (ones ^ num) & ~twos\n            twos = (twos ^ num) & ~ones\n        return ones\n\ndef main():\n    # Read all input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list of numbers\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums = ast.literal_eval(match.group())\n    else:\n        nums = ast.literal_eval(data)\n\n    # Compute the single number\n    result = Solution().singleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for this algorithm: generate uniform random point inside circle. The standard method: choose random radius r = sqrt(random()) * radius, random angle theta = random()*2π. Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). Use random number generator between 0 and 1.\n\nWe need to produce a structure with Start, End, Decision, Steps, arrow syntax. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe have to define the class, constructor, method. Use virtual code lines.\n\nWe can include steps: initialization, random generation, compute. Use Decision? maybe not needed but could include.\n\nWe need to produce lines: Start, Step 1, Step 2, etc. Use arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義 Solution 類別並接收 radius, x_center, y_center // 初始化圓參數\n→ Step 2: 在建構子中將 radius, x_center, y_center 存入物件屬性 // 方便之後使用\n→ Step 3: 定義 randPoint() 方法 // 產生隨機點\n    → Step 4: 產生均勻隨機數 u 在 [0,1) // 用於計算半徑\n    → Step 5: 計算 r = radius * sqrt(u) // 調整半徑以保證均勻分佈\n    → Step 6: 產生均勻隨機數 v 在 [0,1) // 用於角度\n    → Step 7: 計算 theta = 2π * v // 隨機角度\n    → Step 8: 計算 x = x_center + r * cos(theta) // 轉換為座標\n    → Step 9: 計算 y = y_center + r * sin(theta) // 轉換為座標\n    → Step 10: 回傳 [x, y] // 結果輸出\nEnd // 程式執行結束\n\nWe could also include Decision steps? maybe not necessary. But maybe we can add a decision: if u < 0? No. But not needed.\n\nThe requirement: Use arrow \"→\", \"Yes →\", \"No →\" and structure Decision. Not mandatory to have decision but can include. But must maintain format.\n\nWe should maintain consistent indent. In sample, they indent decisions. For us we can indent steps under randPoint. Use indentation for substeps. The arrow appears before each step.\n\nThus produce output. Ensure each line has virtual code and comment. Use Traditional Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Solution 類別並接收 radius, x_center, y_center // 初始化圓參數  \n→ Step 2: 在建構子中將 radius, x_center, y_center 存入物件屬性 // 方便之後使用  \n→ Step 3: 定義 randPoint() 方法 // 產生隨機點  \n    → Step 4: 產生均勻隨機數 u ∈ [0,1) // 用於計算半徑  \n    → Step 5: 計算 r = radius * sqrt(u) // 調整半徑以保證均勻分佈  \n    → Step 6: 產生均勻隨機數 v ∈ [0,1) // 用於角度  \n    → Step 7: 計算 theta = 2π * v // 隨機角度  \n    → Step 8: 計算 x = x_center + r * cos(theta) // 轉換為座標  \n    → Step 9: 計算 y = y_center + r * sin(theta) // 轉換為座標  \n    → Step 10: 回傳 [x, y] // 結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻隨機半徑\n        r = self.radius * math.sqrt(random.random())\n        # 產生均勻隨機角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換回直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    methods = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # null in JSON\n        elif method == \"randPoint\":\n            point = obj.randPoint()\n            # 將座標保留 5 位小數，避免太多浮點位\n            point = [round(v, 5) for v in point]\n            results.append(point)\n\n    # 輸出為 JSON 格式，符合 LeetCode 的輸出要求\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.09312,-0.34637],[-0.43115,0.58941],[-0.07924,-0.84461]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.09312, -0.34637], [-0.43115, 0.58941], [-0.07924, -0.84461]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for generating combinations of k numbers from 1..n. Provide line-by-line with explanation. Use Start, End, Decision. Use arrow. Likely backtracking recursion. Provide steps: Start, Input n, k, init result list, call backtrack(start, path). Backtrack recursion: if path length == k add copy to result. For i from start to n: path add i; backtrack(i+1); path remove last.\n\nWill output each line with explanation. Use arrows for lines. For loops: Use \"For i from start to n:\" etc. Use decisions for path length. Use \"Add copy to result\" etc. Use \"Return result\". Also include input and output. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個整數 n 與 k // 取得使用者輸入的範圍上限與組合大小  \n→ Step 2: 初始化結果清單 result ← 空清單 // 用來存放所有合法的組合  \n→ Step 3: 呼叫 backtrack(1, 空清單) // 從 1 開始尋找組合  \n\n→ Function backtrack(start, path) // 定義遞迴函式  \n  Decision: path 長度是否等於 k? // 檢查目前已選取的數字是否足夠  \n   Yes → Step 4: 將 path 的拷貝加入 result // 找到一組合法組合，加入結果  \n    → End of this branch // 返回上一層遞迴  \n   No  → Step 5: For i 從 start 到 n  \n     Decision: i 是否小於等於 n? // 迴圈條件，確保索引合法  \n      Yes → Step 6: 在 path 加入 i // 加入當前數字  \n        → Step 7: 呼叫 backtrack(i+1, path) // 進一步尋找剩餘位置  \n         → Step 8: 從 path 刪除最後一個元素 // 回溯，移除已嘗試的數字  \n          → End of this branch  \n          No  → End of For  // 當 i 超過 n 時結束迴圈  \n        End of For  // 所有可能的 i 都已嘗試  \n    End of Function backtrack // 回到上層調用  \n\n→ Step 9: 輸出 result // 回傳所有組合給使用者  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combine(self, n: int, k: int):\n        res = []\n\n        def backtrack(start: int, path: list):\n            if len(path) == k:\n                res.append(path[:])\n                return\n            for i in range(start, n + 1):\n                path.append(i)\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(1, [])\n        return res\n\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入文字\n    data = sys.stdin.read()\n    # 從文字中擷取所有整數，支援 \"n = 4, k = 2\" 或 \"4 2\" 等格式\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) >= 2:\n        n, k = numbers[0], numbers[1]\n    else:\n        raise ValueError(\"輸入必須包含兩個整數 n 與 k\")\n\n    solution = Solution()\n    result = solution.combine(n, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: Given x, y, target, determine if reachable. Classic water jug problem. We can use GCD logic: reachable iff target <= x+y and target % gcd(x,y) == 0. But also need to consider zero jug capacity? Should handle. Provide steps: Start, compute gcd, check bounds, check divisible, return result. Use virtual code.\n\nMake sure each line includes virtual code and explanation.\n\nUse arrow \"→\" for steps. Use Decision: for if statements.\n\nLet's produce.\n\nAlso maybe need to handle case target == 0 trivial yes.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 x, y, target // 從使用者取得兩個壹容器容量及目標水量  \n→ Decision: 如果 target 為 0? // 任何容器都能空出 0 水  \n  Yes → Step 2: 回傳 True // 目標為 0，始終可達  \n  No  → Decision: 如果 target 大於 x + y? // 若目標超過兩容器總容量，無法滿足  \n    Yes → Step 3: 回傳 False // 超過總容量，無法達成  \n    No  → Step 4: 計算 g ← GCD(x, y) // 取得兩容器容量的最大公因數  \n→ Decision: 如果 target % g 為 0? // 檢查目標水量是否是公因數的倍數  \n  Yes → Step 5: 回傳 True // 可達到目標水量  \n  No  → Step 6: 回傳 False // 目標不是公因數的倍數，無法達成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        \"\"\"\n        使用水壺問題的 GCD 判斷法。若 target 超過兩個水壺總容量，或\n        target 不是兩個容量最大公因數的倍數，則無法達到目標。\n        \"\"\"\n        # 若目標為 0，永遠可以達成\n        if target == 0:\n            return True\n\n        # 若目標大於兩個水壺總容量，無法滿足\n        if target > x + y:\n            return False\n\n        # 計算兩個水壺容量的最大公因數\n        def gcd(a: int, b: int) -> int:\n            while b:\n                a, b = b, a % b\n            return a\n\n        g = gcd(x, y)\n        # 目標必須能被最大公因數整除\n        return target % g == 0\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，格式可能為：\n        x = 3, y = 5, target = 4\n    或任何含有三個整數的字串，提取後傳給 Solution.canMeasureWater\n    並將結果以小寫 'true' / 'false' 輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 以正則表達式抓取所有整數\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n\n    if len(numbers) < 3:\n        # 若輸入不足三個數字，視為無效輸入，直接退出\n        return\n\n    x, y, target = numbers[0], numbers[1], numbers[2]\n    sol = Solution()\n    result = sol.canMeasureWater(x, y, target)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode689.json",
    "problem_index_in_file": 0,
    "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
    "description_snippet": "Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the problem. We need to output each line with \"虛擬碼步驟\" then // explanation. Use arrows and structure. So produce steps:\n\nStart\n→ Compute prefix sums for array to get sum of any subarray length k quickly\n→ Compute array sums of subarrays of length k (call sums)\n→ Precompute best left indices for each position (maximum sum subarray starting before i)\n→ Precompute best right indices for each position (maximum sum subarray starting after i)\n→ Iterate middle subarray starting position i from k to n-2k\n    Decision: if left[i-1] and right[i+k] exist\n        → Compute total sum = sums[left] + sums[i] + sums[right]\n        → Decision: if total > bestSum? update best and indices\n        → Decision: if total == bestSum and lexicographically smaller? update\nEnd\n→ Output best indices\n\nWe need to use virtual arrows: e.g., \"Decision:\" and \"Yes →\" \"No →\".\n\nEnsure each line contains \"虛擬碼步驟\" and explanation. Let's craft each line.\n\nWe'll need variables: n = length of nums\nprefix[0]=0; for i 1..n: prefix[i]=prefix[i-1]+nums[i-1]\nsums[0..n-k] where sums[i] = prefix[i+k]-prefix[i]\n\nCompute left array: left[0] = 0\nfor i 1..n-k:\n    if sums[i] > sums[left[i-1]]: left[i] = i\n    else left[i] = left[i-1] // keep earlier for lexicographically smallest\n\nSimilarly right array: right[n-k] = n-k\nfor i from n-k-1 down to 0:\n    if sums[i] > sums[right[i+1]]: right[i] = i\n    else right[i] = right[i+1] // earlier smaller index when equal\n\nThen iterate middle start i from k to n-2k:\n    l = left[i-k]\n    r = right[i+k]\n    total = sums[l] + sums[i] + sums[r]\n    if total > bestSum: update\n    else if total == bestSum: compare indices lexicographically: if [l,i,r] < bestIndices -> update\n\nReturn bestIndices\n\nLet's format with virtual code steps.\n\nMake sure each line has explanation. Use arrow and decision.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算長度為 n 的前綴和 prefix，prefix[0] = 0，prefix[i] = prefix[i-1] + nums[i-1] // 快速取得任意子陣列和  \n→ Step 2: 建立 sums 陣列，sums[i] = prefix[i+k] - prefix[i]，i 從 0 到 n-k // 每個長度 k 的子陣列總和  \n→ Step 3: 建立左側最佳索引陣列 left，left[0] = 0  \n  Decision: 若 sums[i] > sums[left[i-1]]?  \n   Yes → left[i] = i // 更大和的起點  \n   No  → left[i] = left[i-1] // 保留較小索引以維持字典序  \n→ Step 4: 建立右側最佳索引陣列 right，right[n-k] = n-k  \n  Decision: 若 sums[i] > sums[right[i+1]]?  \n   Yes → right[i] = i // 更大和的起點  \n   No  → right[i] = right[i+1] // 保留較小索引以維持字典序  \n→ Step 5: 初始化 bestSum = -∞，bestIndices = [] // 儲存目前最佳結果  \n→ Step 6: 迴圈遍歷中間子陣列起點 i 從 k 到 n-2k  \n  Decision: 是否存在左子陣列 left[i-k] 與右子陣列 right[i+k]?  \n   Yes →  \n    l = left[i-k]  \n    r = right[i+k]  \n    total = sums[l] + sums[i] + sums[r] // 三個子陣列總和  \n    Decision: total > bestSum?  \n     Yes → bestSum = total，bestIndices = [l, i, r] // 更新更大總和  \n     No → Decision: total == bestSum?  \n      Yes → Decision: [l, i, r] lexicographically 小於 bestIndices?  \n       Yes → bestIndices = [l, i, r] // 選擇字典序較小  \n       No → // 不更新  \n     No → // 不更新  \n→ End // 程式執行結束  \n→ Step 7: 輸出 bestIndices // 回傳三個子陣列的起始索引列表  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self, nums, k):\n        n = len(nums)\n        if n < 3 * k:\n            return []\n\n        # Compute sums of all subarrays of length k\n        w = [0] * (n - k + 1)\n        window_sum = sum(nums[:k])\n        w[0] = window_sum\n        for i in range(1, n - k + 1):\n            window_sum += nums[i + k - 1] - nums[i - 1]\n            w[i] = window_sum\n\n        # best left index for each position\n        left = [0] * len(w)\n        best = 0\n        for i in range(len(w)):\n            if w[i] > w[best]:\n                best = i\n            left[i] = best\n\n        # best right index for each position\n        right = [0] * len(w)\n        best = len(w) - 1\n        for i in range(len(w) - 1, -1, -1):\n            if w[i] >= w[best]:\n                best = i\n            right[i] = best\n\n        # Find optimal middle position\n        best_total = -1\n        best_indices = None\n        for mid in range(k, len(w) - k):\n            i = left[mid - k]\n            j = mid\n            l = right[mid + k]\n            total = w[i] + w[j] + w[l]\n            if total > best_total:\n                best_total = total\n                best_indices = [i, j, l]\n            elif total == best_total:\n                candidate = [i, j, l]\n                if candidate < best_indices:\n                    best_indices = candidate\n\n        return best_indices\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form 'nums = [..], k = X'.\"\"\"\n    nums = None\n    k = None\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*([0-9]+)', data)\n    if nums_match:\n        nums = eval(nums_match.group(1))\n    if k_match:\n        k = int(k_match.group(1))\n    return nums, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums, k = parse_input(input_data)\n    if nums is None or k is None:\n        print(\"[]\")\n    else:\n        sol = Solution()\n        result = sol.maxSumOfThreeSubarrays(nums, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,2,6,7,5,1], k = 2",
          "expected_output": "[0,3,5]",
          "success": true,
          "output": "[0, 3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,2,1,2,1,2,1], k = 2",
          "expected_output": "[0,2,4]",
          "success": true,
          "output": "[0, 2, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode680.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome II",
    "description_snippet": "Given a string s, return true if the s can be palindrome after deleting at most one character from i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code that solves: Given string s, return true if the s can be palindrome after deleting at most one character from it. So we need to produce a virtual algorithm, step by step.\n\nWe must follow format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision: etc. Should be a step-by-step pseudo-code. Should avoid actual code, just virtual steps. Need to handle at most one deletion.\n\nWe can implement two-pointer approach. Outline:\n\nStart\n→ Initialize left = 0, right = len(s)-1 // pointers at ends\n→ Decision: while left < right? // loop\n    Yes → Decision: s[left] == s[right]? // compare\n        Yes → left++ ; right-- ; // move inward\n        No  → Decision: check if skipping left char leads to palindrome? // try deletion\n            Yes → Return true // can delete left char to make palindrome\n            No  → Decision: check if skipping right char leads to palindrome?\n                Yes → Return true // delete right char\n                No  → Return false // cannot\nEnd // return false if loop completes\n\nBut we need to incorporate at most one deletion. We need a helper function to check if substring is palindrome. So in virtual code, we can define sub-steps.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 設定 left = 0, right = s.length - 1 // 左右指標初始化\n→ Decision: while left < right? // 有未比較字符時進入迴圈\n    Yes → Decision: s[left] == s[right]? // 比較對應字符\n        Yes → Step 2: left++ ; right-- ; // 匹配則指標移動\n        No  → Decision: 子字符串 s[left+1…right] 是否為 palindrome? // 嘗試刪除左字符\n            Yes → Step 3: 返回 true // 可刪除左字符成回文\n            No  → Decision: 子字符串 s[left…right-1] 是否為 palindrome? // 嘗試刪除右字符\n                Yes → Step 4: 返回 true // 可刪除右字符成回文\n                No  → Step 5: 返回 false // 兩種刪除都不行\n    No → End // 循環結束，全部匹配成功\n→ Step 6: 返回 true // 原字符串已為回文\n\nBut need to incorporate \"End\" correctly. The loop ends when left >= right; at that point all matched.\n\nWe need to use arrow: \"→\". Also \"Decision:\" lines.\n\nWe also need to specify sub-check: \"Check palindrome of substring\".\n\nMaybe define a helper function: \"Function isPalindrome(subs)\".\n\nBut to keep simple, we can embed.\n\nLet's produce final answer with each line as per requirement.\n\nMake sure we use proper arrows and indentation.\n\nWe'll format each line exactly like example: \"Start // 程式開始執行\". We'll use \"→ Step ...\" etc. The \"Decision:\" lines must be formatted with indentation maybe? In example they indent after Decision. We'll follow same.\n\nWe must ensure no actual code. Just virtual steps.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = s.length - 1 // 初始化兩指標\n→ Decision: while left < right? // 只要還有未比對的字符就繼續\n    Yes → Decision: s[left] == s[right]? // 兩端字符是否相等\n        Yes → Step 2: left++ ; right-- ; // 匹配成功，指標向中間移動\n        No  → Decision: isPalindrome(s, left+1, right)? // 試圖刪除左側字符\n            Yes → Step 3: 返回 true // 刪除左字符後能成回文\n            No  → Decision: isPalindrome(s, left, right-1)? // 試圖刪除右側字符\n                Yes → Step 4: 返回 true // 刪除右字符後能成回文\n                No  → Step 5: 返回 false // 兩種刪除都失敗\n    No → End // while 循環結束，所有字符已匹配\n→ Step 6: 返回 true // 原字符串已是回文\n\nBut the indentation after Decision: may need to match example. Use spaces indent. Example uses 4 spaces for nested decisions? Actually in example they indent two spaces before Yes → Step etc. We'll replicate: use four spaces before Yes →.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = s.length - 1 // 初始化兩指標  \n→ Decision: while left < right? // 只要還有未比對的字符就繼續  \n    Yes → Decision: s[left] == s[right]? // 兩端字符是否相等  \n        Yes → Step 2: left++ ; right-- ; // 匹配成功，指標向中間移動  \n        No  → Decision: isPalindrome(s, left+1, right)? // 試圖刪除左側字符  \n            Yes → Step 3: 返回 true // 刪除左字符後能成回文  \n            No  → Decision: isPalindrome(s, left, right-1)? // 試圖刪除右側字符  \n                Yes → Step 4: 返回 true // 刪除右字符後能成回文  \n                No  → Step 5: 返回 false // 兩種刪除都失敗  \n    No → End // while 循環結束，所有字符已匹配  \n→ Step 6: 返回 true // 原字符串已是回文",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_palindrome_range(i: int, j: int) -> bool:\n            while i < j:\n                if s[i] != s[j]:\n                    return False\n                i += 1\n                j -= 1\n            return True\n\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] != s[j]:\n                return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1)\n            i += 1\n            j -= 1\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the string inside double quotes, e.g., s = \"aba\"\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else \"\"\n    solution = Solution()\n    result = solution.validPalindrome(s)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aba\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"abca\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"abc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode730.json",
    "problem_index_in_file": 0,
    "title": "Count Different Palindromic Subsequences",
    "description_snippet": "Given a string s, return the number of different non-empty palindromic subsequences in s. Since the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for solving the problem: count different non-empty palindromic subsequences in s modulo 1e9+7.\n\nWe must output line by line, each line: virtual code step + space + comment. Use arrow etc.\n\nWe need algorithm: dynamic programming over substrings, count[i][j] number of distinct palindromic subsequences in s[i..j]. Recurrence depends on first and last char.\n\nStandard approach: For i>j count=0. For i==j count=1. For i<j: if s[i]==s[j], then count[i][j] = count[i+1][j] + count[i][j-1] + 1; else count[i][j] = count[i+1][j] + count[i][j-1] - count[i+1][j-1]. But this counts not distinct? Actually that's for total palindromic subsequences with duplicates counted. For distinct we need more complex recurrence with next/prev occurrences: If s[i]==s[j], let low=next occurrence of s[i] after i, high=prev occurrence of s[j] before j. If low>high (no same char inside), then add 2. If low==high (one inside), add 1. Else add 2 + count[low+1][high-1]. Then add base count[i+1][j] + count[i][j-1] - count[i+1][j-1]. Use modulo. So we need to compute next and prev arrays.\n\nWe should produce pseudocode lines for: read s, n, modulo, compute nextPos and prevPos, init DP table n x n, iterate lengths, compute DP accordingly, output DP[0][n-1] modulo.\n\nLet's produce virtual code lines accordingly.\n\nBe careful to produce arrow lines and indentation. Use Decision lines.\n\nLet's start:\n\nStart // 程式開始\n\n→ Step 1: 讀取輸入字符串 s // 取得要處理的字串\n\n→ Step 2: 設定常量 MOD = 1000000007 // 取模數\n\n→ Step 3: 設定 n = s.length // 字串長度\n\n→ Step 4: 建立 nextPos[ n ][ 26 ] // 下一個相同字元的位置\n\n→ Step 5: 建立 prevPos[ n ][ 26 ] // 前一個相同字元的位置\n\n→ Step 6: 初始化 nextPos 全部為 n // 代表不存在\n\n→ Step 7: 從右到左遍歷 i = n-1 downto 0\n\n    → Step 7.1: For c in 0..25: nextPos[i][c] = nextPos[i+1][c] // 將右邊資訊複製\n\n    → Step 7.2: nextPos[i][ s[i] ] = i // 更新目前位置\n\n→ Step 8: 初始化 prevPos 全部為 -1 // 代表不存在\n\n→ Step 9: 從左到右遍歷 i = 0 to n-1\n\n    → Step 9.1: For c in 0..25: prevPos[i][c] = prevPos[i-1][c] // 將左邊資訊複製\n\n    → Step 9.2: prevPos[i][ s[i] ] = i // 更新目前位置\n\n→ Step 10: 建立 DP 二維表 dp[ n ][ n ] // dp[i][j] 代表 s[i..j] 的不同回文子序列數\n\n→ Step 11: 迭代長度 len = 1 to n\n\n    → Step 11.1: 迭代 i = 0 to n-len\n\n        → Step 11.1.1: 設定 j = i + len - 1 // 子串結尾位置\n\n        → Decision: 如果 len == 1? // 單一字元子串\n\n            → Yes → Step 11.1.2: dp[i][j] = 1 // 只有自己一個回文\n\n            → No → Decision: 如果 s[i] == s[j]? // 首尾相同\n\n                → Yes → Step 11.1.3: 計算 low = nextPos[i+1][ s[i] ] // 下個同字元\n\n                        → Step 11.1.4: 計算 high = prevPos[j-1][ s[j] ] // 前一個同字元\n\n                        → Decision: 如果 low > high? // 內部沒有相同字元\n\n                            → Yes → Step 11.1.5: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 ) mod MOD // 加 2\n\n                            → No → Decision: 如果 low == high? // 內部恰好一個相同字元\n\n                                → Yes → Step 11.1.6: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 1 ) mod MOD\n\n                                → No → Step 11.1.7: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 + dp[low+1][high-1] ) mod MOD\n\n                        → End\n\n                    → No → Step 11.1.8: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] ) mod MOD\n\n→ Step 12: Output dp[0][n-1] // 結果\n\nEnd // 程式結束\n\nMake sure each line has arrow and comment. Provide indent lines as needed. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字符串 s // 取得要處理的字串  \n→ Step 2: 設定常量 MOD = 1000000007 // 取模數  \n→ Step 3: 設定 n = s.length // 字串長度  \n→ Step 4: 建立 nextPos[ n ][ 26 ] // 下一個相同字元的位置表  \n→ Step 5: 建立 prevPos[ n ][ 26 ] // 前一個相同字元的位置表  \n→ Step 6: 初始化 nextPos 全部為 n // 代表不存在相同字元  \n→ Step 7: 從右到左遍歷 i = n-1 downto 0  \n  → Step 7.1: For c in 0..25: nextPos[i][c] = nextPos[i+1][c] // 複製右側資訊  \n  → Step 7.2: nextPos[i][ s[i] ] = i // 更新目前位置  \n→ Step 8: 初始化 prevPos 全部為 -1 // 代表不存在相同字元  \n→ Step 9: 從左到右遍歷 i = 0 to n-1  \n  → Step 9.1: For c in 0..25: prevPos[i][c] = prevPos[i-1][c] // 複製左側資訊  \n  → Step 9.2: prevPos[i][ s[i] ] = i // 更新目前位置  \n→ Step 10: 建立 DP 二維表 dp[ n ][ n ] // dp[i][j] 為 s[i..j] 的不同回文子序列數  \n→ Step 11: 迭代長度 len = 1 to n  \n  → Step 11.1: 迭代 i = 0 to n-len  \n    → Step 11.1.1: 設定 j = i + len - 1 // 子串結尾位置  \n    → Decision: 如果 len == 1? // 單一字元子串  \n      Yes → Step 11.1.2: dp[i][j] = 1 // 只有自己一個回文  \n      No → Decision: 如果 s[i] == s[j]? // 首尾相同  \n        Yes → Step 11.1.3: 計算 low = nextPos[i+1][ s[i] ] // 下個同字元  \n        → Step 11.1.4: 計算 high = prevPos[j-1][ s[j] ] // 前一個同字元  \n        → Decision: 如果 low > high? // 內部沒有相同字元  \n          Yes → Step 11.1.5: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 ) mod MOD // 加 2  \n          No → Decision: 如果 low == high? // 內部恰好一個相同字元  \n           Yes → Step 11.1.6: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 1 ) mod MOD  \n           No → Step 11.1.7: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] + 2 + dp[low+1][high-1] ) mod MOD  \n          End  \n        No → Step 11.1.8: dp[i][j] = ( dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] ) mod MOD  \n→ Step 12: 輸出 dp[0][n-1] // 結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # Map characters to indices 0..25\n    def idx(c): return ord(c) - 97\n\n    # next_pos[i][c] = next index >= i with character c, or n if none\n    next_pos = [[n] * 26 for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        next_pos[i] = next_pos[i + 1][:]          # copy from right side\n        next_pos[i][idx(s[i])] = i\n\n    # prev_pos[i][c] = previous index <= i with character c, or -1 if none\n    prev_pos = [[-1] * 26 for _ in range(n)]\n    for i in range(n):\n        if i > 0:\n            prev_pos[i] = prev_pos[i - 1][:]\n        prev_pos[i][idx(s[i])] = i\n\n    # dp[i][j] = number of distinct palindromic subsequences in s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n + 1):\n        for i in range(0, n - length + 1):\n            j = i + length - 1\n            if i == j:\n                dp[i][j] = 1\n                continue\n\n            if s[i] == s[j]:\n                low = next_pos[i + 1][idx(s[i])]\n                high = prev_pos[j - 1][idx(s[j])]\n\n                if low > high:\n                    # no same char inside\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 2) % MOD\n                elif low == high:\n                    # exactly one same char inside\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] + 1) % MOD\n                else:\n                    dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] +\n                                2 + dp[low + 1][high - 1]) % MOD\n            else:\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] -\n                            dp[i + 1][j - 1]) % MOD\n\n    return dp[0][n - 1] % MOD\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Try to extract string inside double quotes, if present\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = data[first_quote + 1:last_quote]\n    else:\n        s = data.replace(\"s =\", \"\").replace(\"'\", \"\").replace('\"', '').strip()\n    result = count_palindromic_subsequences(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '830315412'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '830315412'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find longest palindromic substring. Use center expansion or DP. Provide step-by-step with decisions. Let's design algorithm:\n\nStart\n→ Input string s\n→ Initialize variables: maxLen = 0, startIndex = 0\n→ For each index i in s:\n    → Expand around center i (odd length)\n        → while left>=0 && right<n && s[left]==s[right]:\n             → update maxLen & startIndex if length>maxLen\n        → Expand around center i,i+1 (even length)\n        → similar update\n→ Output substring from startIndex to startIndex+maxLen\nEnd\n\nWe need to produce each line with virtual code and comment. Use arrow formatting. For loops etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ n ← length(s) // 取得字串長度\n→ maxLen ← 0 // 記錄目前找到的最大回文長度\n→ startIdx ← 0 // 記錄最大回文子字串起始位置\n→ For i from 0 to n-1 // 逐個檢查每個字符作為中心\n    → // 奇數長度回文\n    → left ← i\n    → right ← i\n    → While left ≥ 0 and right < n and s[left] = s[right]\n        → currLen ← right - left + 1 // 當前回文長度\n        → If currLen > maxLen\n            → maxLen ← currLen\n            → startIdx ← left\n        → left ← left - 1\n        → right ← right + 1\n    → // 偶數長度回文\n    → left ← i\n    → right ← i + 1\n    → While left ≥ 0 and right < n and s[left] = s[right]\n        → currLen ← right - left + 1\n        → If currLen > maxLen\n            → maxLen ← currLen\n            → startIdx ← left\n        → left ← left - 1\n        → right ← right + 1\n→ result ← substring(s, startIdx, maxLen) // 取得最大回文子字串\n→ Output result // 返回結果\nEnd // 程式執行結束\n\nBut we must follow the formatting: each line: \"虛擬碼步驟\" space \"// 解釋\". Use arrows. Let's convert each step into lines. For loops, use \"For i from 0 to n-1\" as a line. Use indentation? The sample shows indentation with spaces and arrow for decisions. We'll keep each line as one statement. For nested loops, we need indentation? Could use spaces but it's fine.\n\nWe need to use \"→\" before each step. For decisions \"If\". Provide \"Decision:\" lines? The sample uses Decision: for if statements. Let's use \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 取得輸入字串  \n→ n ← length(s) // 取得字串長度  \n→ maxLen ← 0 // 記錄目前找到的最大回文長度  \n→ startIdx ← 0 // 記錄最大回文子字串起始位置  \n→ For i from 0 to n-1 // 逐個檢查每個字符作為中心  \n  Decision: 確認奇數長度回文中心? // 檢查以 i 為中心的回文  \n   → left ← i  \n   → right ← i  \n   → While left ≥ 0 and right < n and s[left] = s[right] // 逐步擴展  \n      currLen ← right - left + 1 // 當前回文長度  \n      Decision: currLen > maxLen? // 是否更新最大回文  \n        Yes → maxLen ← currLen  \n            startIdx ← left  \n        No →  \n            （不變）  \n            left ← left - 1  \n            right ← right + 1  \n  Decision: 確認偶數長度回文中心? // 檢查以 i 與 i+1 為中心的回文  \n   → left ← i  \n   → right ← i + 1  \n   → While left ≥ 0 and right < n and s[left] = s[right] // 逐步擴展  \n      currLen ← right - left + 1 // 當前回文長度  \n      Decision: currLen > maxLen? // 是否更新最大回文  \n        Yes → maxLen ← currLen  \n            startIdx ← left  \n        No →  \n            （不變）  \n            left ← left - 1  \n            right ← right + 1  \n→ result ← substring(s, startIdx, maxLen) // 取得最大回文子字串  \n→ Output result // 返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"Return the longest palindromic substring in s.\"\"\"\n        res = \"\"\n        n = len(s)\n        for i in range(n):\n            # Odd length palindrome centered at i\n            tmp = self._expand(s, i, i)\n            if len(tmp) > len(res):\n                res = tmp\n            # Even length palindrome centered at i and i+1\n            tmp = self._expand(s, i, i + 1)\n            if len(tmp) > len(res):\n                res = tmp\n        return res\n\n    def _expand(self, s: str, left: int, right: int) -> str:\n        \"\"\"Expand around center and return palindrome.\"\"\"\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return s[left + 1:right]\n\n\ndef _extract_string(line: str) -> str:\n    \"\"\"\n    Extract the first quoted string from the input line.\n    If no quotes are found, return the line trimmed.\n    \"\"\"\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", line)\n    if match:\n        return match.group(1)\n    return line.strip()\n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the string to process\n    s = _extract_string(raw_input)\n    # Compute and print the longest palindromic substring\n    solution = Solution()\n    result = solution.longestPalindrome(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "bab"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "bb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code. Approach: compute pair sums of A and B, count frequencies in map. Then iterate over pairs of C and D, sum to zero: need count of -(Ck+Dl) in map. Complexity O(n^2). Provide steps. Use decision and loops. Provide Start, End. Use arrow. Each line: \"虛擬碼步驟 // 解釋\". Use appropriate indentation maybe with spaces.\n\nWe need use Start and End markers. Use → for steps. Use Decision when checking n? But just loops. Should show loops with \"→ Step: For i in 0 to n-1\" etc. We can do.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 pairCount // 用來儲存 A[i]+B[j] 的出現次數\n→ Step 2: For i from 0 to n-1 // 遍歷 A 的索引\n    → Step 3: For j from 0 to n-1 // 遍歷 B 的索引\n        → Step 4: sumAB = A[i] + B[j] // 計算兩個元素的和\n        → Decision: sumAB 是否已存在於 pairCount? // 檢查是否已有該鍵\n            Yes → Step 5: pairCount[sumAB] = pairCount[sumAB] + 1 // 若存在，頻率加一\n            No  → Step 6: pairCount[sumAB] = 1 // 若不存在，初始化頻率為 1\n→ Step 7: 結果 = 0 // 初始化答案\n→ Step 8: For k from 0 to n-1 // 遍歷 C 的索引\n    → Step 9: For l from 0 to n-1 // 遍歷 D 的索引\n        → Step 10: sumCD = C[k] + D[l] // 計算兩個元素的和\n        → Step 11: target = -sumCD // 需要的 A+B 和\n        → Decision: target 是否存在於 pairCount? // 檢查字典\n            Yes → Step 12: 結果 = 結果 + pairCount[target] // 加上符合的組合數\n            No  → // 無需執行任何動作\n→ Step 13: 輸出 結果 // 回傳符合條件的四元組數\nEnd // 程式執行結束\n```\n\nNeed to keep format: each line \"虛擬碼步驟 // 解釋\". Use indent for nested steps? Use spaces and maybe arrow for each step.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 pairCount // 用來儲存 A[i]+B[j] 的出現次數  \n\n→ Step 2: For i from 0 to n-1 // 遍歷 A 的索引  \n  → Step 3: For j from 0 to n-1 // 遍歷 B 的索引  \n    → Step 4: sumAB = A[i] + B[j] // 計算兩個元素的和  \n    → Decision: sumAB 是否已存在於 pairCount? // 檢查是否已有該鍵  \n     Yes → Step 5: pairCount[sumAB] = pairCount[sumAB] + 1 // 若存在，頻率加一  \n     No  → Step 6: pairCount[sumAB] = 1 // 若不存在，初始化頻率為 1  \n\n→ Step 7: 結果 = 0 // 初始化答案  \n\n→ Step 8: For k from 0 to n-1 // 遍歷 C 的索引  \n  → Step 9: For l from 0 to n-1 // 遍歷 D 的索引  \n    → Step 10: sumCD = C[k] + D[l] // 計算兩個元素的和  \n    → Step 11: target = -sumCD // 需要的 A+B 和  \n    → Decision: target 是否存在於 pairCount? // 檢查字典  \n     Yes → Step 12: 結果 = 結果 + pairCount[target] // 加上符合的組合數  \n     No  → // 無需執行任何動作  \n\n→ Step 13: 輸出 結果 // 回傳符合條件的四元組數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef four_sum_count(A, B, C, D):\n    \"\"\"計算滿足 A[i] + B[j] + C[k] + D[l] == 0 的四元組數量。\"\"\"\n    # 先計算所有 A+B 的組合出現頻率\n    AB = Counter(a + b for a in A for b in B)\n    # 再依次遍歷 C+D，累加對應的 A+B 頻率\n    count = 0\n    for c in C:\n        for d in D:\n            count += AB.get(-(c + d), 0)\n    return count\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如\n    A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]\n    的輸入字串，返回四個列表 A, B, C, D。\n    \"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    values = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # 使用 ast.literal_eval 以安全方式解析列表字面量\n        values[key] = ast.literal_eval(val)\n    return values['A'], values['B'], values['C'], values['D']\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit()\n    A, B, C, D = parse_input(raw_input)\n    result = four_sum_count(A, B, C, D)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpzc_i48ud.py\", line 39, in <module>\n    A, B, C, D = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzc_i48ud.py\", line 31, in parse_input\n    values[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for pow(x,n). Steps: start, handle negative exponent, use exponentiation by squaring, loop while n>0. Probably include decision for n odd, multiply result by x, square x, halve n. Also handle zero exponent. Also maybe handle negative n by computing reciprocal.\n\nWe output line by line with virtual code syntax. Use arrow →. Provide explanation after //.\n\nWe should be careful: Use Start, End. Use Decision: etc. Provide steps.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 如果 n < 0? // 檢查指數是否為負\n    Yes → Step 2: 設置 x = 1 / x // 取倒數以處理負指數\n    No  → // 繼續\n→ Step 3: n = abs(n) // 取得指數的正整數值\n→ Step 4: 設置 result = 1 // 初始結果\n→ Decision: n == 0? // 如果指數為 0\n    Yes → Step 5: 輸出 result // result 為 1\n    No  → // 進行平方乘法\n→ Loop Start // 開始迴圈\n    Decision: n % 2 == 1? // n 為奇數\n        Yes → Step 6: result = result * x // 乘上 x\n        No  → // 跳過\n    Step 7: x = x * x // x 平方\n    Step 8: n = n // 2 // n 除以 2\n    Decision: n > 0? // 是否還有迴圈\n        Yes → Go to Loop Start\n        No  → // 迴圈結束\n→ Step 9: 輸出 result // 輸出計算結果\nEnd // 程式執行結束\n\nBut we need the syntax exactly: Use \"Decision:\" for if statements, \"Yes →\", \"No →\" etc. For loop, we might express with \"→ Loop:\" but not specified. We can use \"→ Loop Start\" as step and then decisions inside. They said use virtual code's arrow (→) and structure (Start, End, Decision:). So we can create:\n\nStart // 程式開始執行\n→ Step 1: Decision: if n < 0? // 檢查指數是否為負\n    Yes → Step 2: x = 1 / x // 取倒數\n    No  → // 直接繼續\n→ Step 3: n = abs(n) // 取得指數的正整數值\n→ Step 4: result = 1 // 初始化結果\n→ Decision: n == 0? // 指數為零?\n    Yes → Step 5: output result // result 為 1\n    No  → // 進行平方乘法\n→ Step 6: // 進入迴圈\n→ Decision: n > 0? // 迴圈條件\n    Yes → Step 7: Decision: n % 2 == 1? // n 為奇數?\n        Yes → Step 8: result = result * x // 乘上 x\n        No  → // 跳過\n    → Step 9: x = x * x // x 平方\n    → Step 10: n = n // 2 // n 除以 2\n    → // 迴圈結束後重新判斷\n    Go back to Decision: n > 0? // 迴圈重複\n    No  → // 迴圈結束\n→ Step 11: output result // 輸出結果\nEnd // 程式結束\n\nBut they asked \"逐行地產生虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋\". So each line separate.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Decision: 如果 n < 0? // 檢查指數是否為負\n    Yes → Step 2: x = 1 / x // 取倒數以處理負指數\n    No  → // 繼續\n→ Step 3: n = abs(n) // 取得指數的正整數值\n→ Step 4: result = 1 // 初始結果\n→ Decision: 如果 n == 0? // 指數為 0?\n    Yes → Step 5: output result // result 為 1\n    No  → // 進行平方乘法\n→ Loop Start // 進入主迴圈\n    Decision: 如果 n > 0? // 仍有位需要處理?\n        Yes → Step 6: Decision: 如果 n % 2 == 1? // n 為奇數?\n            Yes → Step 7: result = result * x // 乘上 x\n            No  → // 跳過\n        → Step 8: x = x * x // x 平方\n        → Step 9: n = n // 2 // n 除以 2\n        → // 迴圈結束後重新判斷\n        Go to Loop Start\n        No  → // 迴圈結束\n→ Step 10: output result // 輸出最終結果\nEnd // 程式結束\n\nBut maybe we should avoid \"Loop Start\" as unknown keyword; we can use \"→ Step 6: Decision: n > 0?\" etc. Let's just use steps sequentially and decisions nested.\n\nWe need to produce each line separate, using arrow \"→\" or \"Start\" etc. Use indentation? In the example, they show nested decisions as indented lines.\n\nWe should mimic that. Use:\n\nStart // 程式開始執行\n→ Step 1: Decision: 如果 n < 0? // 檢查指數是否為負\n    Yes → Step 2: x = 1 / x // 取倒數以處理負指數\n    No  → // 繼續\n→ Step 3: n = abs(n) // 取得指數的正整數值\n→ Step 4: result = 1 // 初始結果\n→ Decision: 如果 n == 0? // 指數為 0?\n    Yes → Step 5: output result // result 為 1\n    No  → // 進行平方乘法\n→ Step 6: // 進入迴圈\n→ Decision: n > 0? // 仍有位需要處理?\n    Yes → Step 7: Decision: n % 2 == 1? // n 為奇數?\n        Yes → Step 8: result = result * x // 乘上 x\n        No  → // 跳過\n    → Step 9: x = x * x // x 平方\n    → Step 10: n = n // 2 // n 除以 2\n    → // 迴圈結束後重新判斷\n    Go to Decision: n > 0?\n    No  → // 迴圈結束\n→ Step 11: output result // 輸出最終結果\nEnd // 程式結束\n\nBut \"Go to Decision: n > 0?\" is not typical; we might instead show that after step 10 we loop back. We can simply show the recursion by indenting same decision block again.\n\nBut maybe simpler: Use a while loop pseudo step: \"→ Loop: while n > 0?\" with body steps. Let's adopt:\n\nStart // 程式開始執行\n→ Step 1: Decision: 如果 n < 0? // 檢查指數是否為負\n    Yes → Step 2: x = 1 / x // 取倒數以處理負指數\n    No  → // 繼續\n→ Step 3: n = abs(n) // 取得指數的正整數值\n→ Step 4: result = 1 // 初始結果\n→ Decision: 如果 n == 0? // 指數為 0?\n    Yes → Step 5: output result // result 為 1\n    No  → // 進行平方乘法\n→ Loop Start // 進入迴圈\n    Decision: 如果 n > 0? // 仍有位需要處理?\n        Yes → Step 6: Decision: 如果 n % 2 == 1? // n 為奇數?\n            Yes → Step 7: result = result * x // 乘上 x\n            No  → // 跳過\n        → Step 8: x = x * x // x 平方\n        → Step 9: n = n // 2 // n 除以 2\n        → // 回到 Loop Start\n        No  → // 迴圈結束\n→ Step 10: output result // 輸出最終結果\nEnd // 程式結束\n\nBut we might need to maintain proper formatting: each line with \"→\". Indentation indicates nested. Should we use \"Decision:\" for if? Use \"Yes →\" \"No →\".\n\nLet's produce final answer accordingly.\n\nWe must ensure no actual code. Only virtual code.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Decision: 如果 n < 0? // 檢查指數是否為負  \n  Yes → Step 2: x = 1 / x // 取倒數以處理負指數  \n  No  → // 繼續  \n→ Step 3: n = abs(n) // 取得指數的正整數值  \n→ Step 4: result = 1 // 初始結果  \n→ Decision: 如果 n == 0? // 指數為 0?  \n  Yes → Step 5: output result // result 為 1  \n  No  → // 進行平方乘法  \n→ Loop Start // 進入主迴圈  \n  Decision: 如果 n > 0? // 仍有位需要處理?  \n   Yes → Step 6: Decision: 如果 n % 2 == 1? // n 為奇數?  \n    Yes → Step 7: result = result * x // 乘上 x  \n    No  → // 跳過  \n   → Step 8: x = x * x // x 平方  \n   → Step 9: n = n // 2 // n 除以 2  \n   → // 回到 Loop Start  \n   No  → // 迴圈結束  \n→ Step 10: output result // 輸出最終結果  \nEnd // 程式結束",
      "generated_code": "import sys\n\ndef my_pow(x: float, n: int) -> float:\n    \"\"\"Fast exponentiation (iterative) to compute x^n.\"\"\"\n    if n == 0:\n        return 1.0\n    if n < 0:\n        x = 1.0 / x\n        n = -n\n\n    result = 1.0\n    while n > 0:\n        if n & 1:           # if n is odd\n            result *= x\n        x *= x              # square the base\n        n >>= 1             # integer division by 2\n    return result\n\ndef main():\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n\n    # Expected format: \"x = 2.00000, n = 10\"\n    parts = [p.strip() for p in line.split(',')]\n    values = {}\n    for part in parts:\n        key, val = part.split('=')\n        values[key.strip()] = val.strip()\n\n    x = float(values.get('x', 0))\n    n = int(values.get('n', 0))\n\n    result = my_pow(x, n)\n    print(f\"{result:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow, decision, etc. Provide explanation after space. Use Chinese. Must not output actual code. Just steps. Use Start, End. The algorithm:\n\nStart\n→ Step: 讀取輸入字符串 s // Get the input string\n→ Step: 初始化 index = 0 // index pointer\n→ Decision: 是否有前導空白? // check whitespace\n  Yes → Step: 當 s[index] 為空白時 index++ // skip whitespace\n  No  → (proceed)\n→ Step: 判斷符號 // determine sign\n  Decision: s[index] 是否為 '-' 或 '+'?\n    Yes → if '-' set sign = -1 else sign = 1\n          index++ // skip sign\n    No  → sign = 1\n→ Step: 跳過前導零 // skip leading zeros\n  Decision: s[index] 為 '0'?\n    Yes → index++ continue\n    No  → (proceed)\n→ Step: 讀取數字並累加 // parse digits\n  初始化 result = 0\n  Decision: s[index] 是否為數字\n    Yes → 進入 loop: \n           while index < len(s) and s[index] 為數字\n             digit = int(s[index])\n             // Check overflow before adding: if result > (INT_MAX - digit)/10 etc\n             result = result * 10 + digit\n             index++\n           (end loop)\n    No  → (no digits, result remains 0)\n→ Step: 應用符號 // apply sign\n  result = sign * result\n→ Step: 限制範圍 // clamp to 32-bit signed range\n  Decision: result < INT_MIN?\n    Yes → result = INT_MIN\n    No → Decision: result > INT_MAX?\n        Yes → result = INT_MAX\n        No  → (keep)\n→ End // return result\n\nWe need each line with \"虛擬碼步驟 [space] // 解釋\". Use arrow. Use \"→\" for steps. For decisions, use \"Decision:\" then indent with Yes →, No →. Provide explanation.\n\nWe must ensure each step line has the explanation. For nested decisions, indentation is represented by new lines starting with \"Yes →\" or \"No →\" preceded by spaces? Use as per example. In example, they indent Yes and No lines with spaces. We'll follow that.\n\nWe need to mention INT_MIN = -2147483648, INT_MAX = 2147483647. Or maybe specify variables.\n\nLet's write steps.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字符串 s // 從使用者或函式參數取得字串\n→ Step 2: 初始化 index = 0 // 設定指標位置為字串起點\n→ Decision: 是否有前導空白? // 判斷是否需要跳過空白字元\n    Yes → Step 3: 當 s[index] 為空白時 index++ // 逐個移除前導空白\n    No  → (不進行移除)\n→ Step 4: 判斷符號 // 檢查下一個字元是否為 '+' 或 '-'\n    Decision: s[index] 是否為 '-' 或 '+'?\n        Yes → Decision: 是 '-'?\n                Yes → Step 5: 設定 sign = -1 並 index++ // 符號為負且移除符號字元\n                No  → Step 6: 設定 sign = 1 並 index++ // 符號為正且移除符號字元\n        No  → Step 7: 設定 sign = 1 // 無符號，預設為正\n→ Step 8: 跳過前導零 // 去除多餘的零以避免不必要的計算\n    Decision: s[index] 為 '0'?\n        Yes → Step 9: index++ 並回到此決策 // 仍是零則繼續跳過\n        No  → (進入下一步)\n→ Step 10: 讀取數字並累加 // 依序處理每個數字字元\n    → Step 10.1: 初始化 result = 0 // 記錄累積的數值\n    → Decision: s[index] 是否為數字?\n        Yes → Step 10.2: 當 index < len(s) 且 s[index] 為數字時執行\n                    → Step 10.2.1: digit = int(s[index]) // 取得數字值\n                    → Step 10.2.2: 檢查是否會溢出\n                        Decision: result > (INT_MAX - digit) / 10 ?\n                            Yes → Step 10.2.3: result = INT_MAX // 防止溢出，直接設為上限\n                            No  → Step 10.2.4: result = result * 10 + digit // 正常累加\n                    → Step 10.2.5: index++ // 移動到下一個字元\n                    → Loop back到 Decision: s[index] 是否為數字?\n        No  → Step 10.3: 無數字可讀，result 仍為 0\n→ Step 11: 應用符號 // 根據先前判定的符號更新結果\n    → Step 11.1: result = sign * result // 乘以符號\n→ Step 12: 限制範圍 // 保證結果在 32-bit signed int 範圍內\n    → Decision: result < INT_MIN ?\n        Yes → Step 12.1: result = INT_MIN // 下限\n        No  → Decision: result > INT_MAX ?\n                Yes → Step 12.2: result = INT_MAX // 上限\n                No  → (保持不變)\n→ End // 程式結束，返回 result\n\nMake sure each line includes virtual code step and comment. Also maintain format. Provide step numbers optionally. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字符串 s // 從使用者或函式參數取得字串\n→ Step 2: 初始化 index = 0 // 設定指標位置為字串起點\n→ Decision: 是否有前導空白? // 判斷是否需要跳過空白字元\n    Yes → Step 3: 當 s[index] 為空白時 index++ // 逐個移除前導空白\n    No  → (不進行移除)\n→ Step 4: 判斷符號 // 檢查下一個字元是否為 '+' 或 '-'\n    Decision: s[index] 是否為 '-' 或 '+'?\n        Yes → Decision: 是 '-'?\n                Yes → Step 5: 設定 sign = -1 並 index++ // 符號為負且移除符號字元\n                No  → Step 6: 設定 sign = 1 並 index++ // 符號為正且移除符號字元\n        No  → Step 7: 設定 sign = 1 // 無符號，預設為正\n→ Step 8: 跳過前導零 // 去除多餘的零以避免不必要的計算\n    Decision: s[index] 為 '0'?\n        Yes → Step 9: index++ 並回到此決策 // 仍是零則繼續跳過\n        No  → (進入下一步)\n→ Step 10: 讀取數字並累加 // 依序處理每個數字字元\n    → Step 10.1: 初始化 result = 0 // 記錄累積的數值\n    → Decision: s[index] 是否為數字?\n        Yes → Step 10.2: 當 index < len(s) 且 s[index] 為數字時執行\n                    → Step 10.2.1: digit = int(s[index]) // 取得數字值\n                    → Step 10.2.2: 檢查是否會溢出\n                        Decision: result > (INT_MAX - digit) / 10 ?\n                            Yes → Step 10.2.3: result = INT_MAX // 防止溢出，直接設為上限\n                            No  → Step 10.2.4: result = result * 10 + digit // 正常累加\n                    → Step 10.2.5: index++ // 移動到下一個字元\n                    → Loop back到 Decision: s[index] 是否為數字?\n        No  → Step 10.3: 無數字可讀，result 仍為 0\n→ Step 11: 應用符號 // 根據先前判定的符號更新結果\n    → Step 11.1: result = sign * result // 乘以符號\n→ Step 12: 限制範圍 // 保證結果在 32-bit signed int 範圍內\n    → Decision: result < INT_MIN ?\n        Yes → Step 12.1: result = INT_MIN // 下限\n        No  → Decision: result > INT_MAX ?\n                Yes → Step 12.2: result = INT_MAX // 上限\n                No  → (保持不變)\nEnd // 程式結束，返回 result",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        # 1. 去除前導空白\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        sign = 1\n        idx = 0\n\n        # 2. 判斷符號\n        if s[0] == '+':\n            idx += 1\n        elif s[0] == '-':\n            sign = -1\n            idx += 1\n\n        # 3. 跳過前導零\n        while idx < len(s) and s[idx] == '0':\n            idx += 1\n\n        # 4. 讀取數字並累加，同時做溢出檢查\n        result = 0\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        while idx < len(s) and s[idx].isdigit():\n            digit = int(s[idx])\n            # 檢查是否會溢出\n            if result > (INT_MAX - digit) // 10:\n                result = INT_MAX\n                break\n            result = result * 10 + digit\n            idx += 1\n\n        result *= sign\n\n        # 5. 限制範圍\n        if result < INT_MIN:\n            return INT_MIN\n        if result > INT_MAX:\n            return INT_MAX\n        return result\n\ndef extract_string(line: str) -> str:\n    \"\"\"\n    從類似 's = \"42\"' 的輸入行中提取字串 '42'。\n    若無引號，則直接返回經過 strip 的內容。\n    \"\"\"\n    # 先搜尋雙引號\n    match = re.search(r'\"(.*)\"', line)\n    if match:\n        return match.group(1)\n    # 若沒有引號，嘗試去除可能的 's = ' 前綴\n    if '=' in line:\n        return line.split('=', 1)[1].strip()\n    return line.strip()\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read()\n    # 分行處理，取第一個非空行作為輸入\n    lines = [ln for ln in raw_input.splitlines() if ln.strip()]\n    if not lines:\n        sys.exit(0)\n    s = extract_string(lines[0])\n    sol = Solution()\n    print(sol.myAtoi(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for reversing words. Should handle leading/trailing spaces, multiple spaces. Steps: trim, split by space, filter empties, reverse, join. In virtual code using arrows. We'll produce lines with \"→\" etc. Each line followed by comment. Start, End. Use decision? maybe for checking. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義輸入字串 s // 接收要處理的原始字串  \n→ Step 2: Trim s 的前後空白 // 去除首尾多餘空格  \n→ Step 3: 用空白拆分 s 為單詞列表 words // 以空格作為分隔符  \n→ Step 4: 建立空列表 filteredWords // 用來存放有效單詞  \n→ Decision: words 中是否存在空字串? // 檢查拆分後是否有空項  \n    Yes → Step 5: 移除空字串並加入 filteredWords // 過濾多餘空格產生的空單詞  \n    No  → Step 5: 直接將 words 加入 filteredWords // 直接使用已拆分的單詞  \n→ Step 6: 反轉 filteredWords 的順序 // 取得逆序單詞列表  \n→ Step 7: 用單一空格將 filteredWords 連接成結果字串 result // 拼接逆序單詞  \n→ Step 8: 輸出 result // 回傳逆序後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        1. 去除前後空白\n        2. 以空白拆分為單詞\n        3. 反轉順序\n        4. 用單一空格連接\n        \"\"\"\n        # strip 去除首尾空格，split() 會自動忽略連續空格\n        words = s.strip().split()\n        # 反轉並用空格連接\n        return ' '.join(words[::-1])\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 移除多餘的換行與空白\n    data = data.strip()\n\n    # 嘗試從輸入中提取字符串，假設格式為 s = \"...\"\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        s = data[start + 1:end]\n    else:\n        # 若沒有引號，直接使用整個輸入\n        s = data\n\n    solution = Solution()\n    reversed_str = solution.reverseWords(s)\n\n    # 根據範例輸出，加上雙引號\n    print(f'\"{reversed_str}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "\"blue is sky the\""
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "\"world hello\""
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "\"example good a\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for removing elements equal to val in-place. Use Start, End, Decision, arrow. Provide simple logic: iterate over array with write pointer. For each element if not val, write to write pointer then increment. At end return write pointer as k. Provide step by step. Use comments. Let's produce lines.\n\nUse structure:\n\nStart\n→ Step 1: 初始化 writeIndex 為 0 // 記錄寫入位置\n→ For each index i from 0 to length-1\n    → Decision: nums[i] 是否等於 val\n        Yes → Next // 跳過，保持 writeIndex 不變\n        No  → Step 2: nums[writeIndex] = nums[i] // 把非 val 的元素覆蓋到寫入位置\n              → Step 3: writeIndex += 1 // 移動寫入指標\n→ End // 返回 writeIndex 作為新長度\n\nBut need each line as \"虛擬碼步驟 // 解釋\". Use arrow. Provide for loop. Might need to represent loop. Let's do:\n\nStart\n→ Step 1: writeIndex = 0 // 初始化寫入指標\n→ Step 2: For i = 0 to nums.length - 1 // 遍歷每個元素\n    → Decision: nums[i] == val? // 檢查當前元素是否為要移除的值\n        Yes → Next // 如果是，跳過\n        No  → Step 3: nums[writeIndex] = nums[i] // 將非 val 元素寫入\n              → Step 4: writeIndex += 1 // 移動寫入指標\n→ Step 5: Return writeIndex // writeIndex 即為新長度 k\nEnd\n\nBut need each line with arrow. The loop can be separate lines? We can write as:\n\n→ Step 2: Start for-loop // 開始迴圈\n    → Step 3: i = 0 // 設定起始索引\n    → Decision: i < nums.length? // 判斷是否結束\n        Yes → Step 4: ...\n        No  → End loop\n\nBut simpler: combine.\n\nWe need each line as a virtual step. Use arrow \"→\" before each step. Indentation maybe. But just produce lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: writeIndex = 0 // 初始化寫入指標\n→ Step 2: for i = 0; i < nums.length; i++ // 逐個檢查每個元素\n    → Decision: nums[i] == val? // 判斷是否需要移除\n        Yes → Next // 若為 val，直接跳過\n        No  → Step 3: nums[writeIndex] = nums[i] // 將非 val 元素覆蓋到寫入位置\n              → Step 4: writeIndex += 1 // 更新寫入指標\n→ Step 5: return writeIndex // 返回新的長度 k\nEnd // 程式執行結束\n\nBut we need every line separated. Indentation indicates sub-steps. Provide accordingly. Ensure each line ends with comment. Use // for comment. Provide arrow. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIndex = 0 // 初始化寫入指標，表示將要覆蓋的位置  \n→ Step 2: for i = 0; i < nums.length; i++ // 逐個檢查陣列中的每個元素  \n  → Decision: nums[i] == val? // 判斷當前元素是否為要移除的值  \n   Yes → Next // 若為 val，跳過此元素，寫入指標保持不變  \n   No  → Step 3: nums[writeIndex] = nums[i] // 將非 val 的元素寫入到寫入指標位置  \n    → Step 4: writeIndex += 1 // 更新寫入指標，準備寫入下一個非 val 元素  \n→ Step 5: return writeIndex // writeIndex 即為新長度 k，表示前 k 個元素已經是保留值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef remove_element(nums, val):\n    \"\"\"\n    移除 nums 中所有等於 val 的元素，並返回新長度 k。\n    操作在原地完成，前 k 個位置將是保留的元素。\n    \"\"\"\n    write_idx = 0  # 用於寫入非 val 的元素的位置\n    for num in nums:  # 逐個遍歷元素\n        if num != val:\n            nums[write_idx] = num  # 覆蓋寫入位置\n            write_idx += 1\n    return write_idx\n\ndef parse_input(data):\n    \"\"\"\n    從輸入字串解析得到 nums 列表和 val 整數。\n    輸入格式預期為： 'nums = [1,2,3], val = 2'\n    \"\"\"\n    # 將整行拆成兩部分\n    parts = data.split(', val =')\n    nums_part = parts[0].replace('nums =', '').strip()\n    val_part = parts[1].strip() if len(parts) > 1 else ''\n    nums = ast.literal_eval(nums_part)          # 轉成列表\n    val = int(val_part) if val_part else 0      # 轉成整數\n    return nums, val\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    nums, val = parse_input(raw_input)\n\n    # 執行移除操作\n    k = remove_element(nums, val)\n\n    # 準備輸出格式：第一個 k 為新長度，後面跟著帶 '_' 的完整數組\n    formatted_elements = []\n    for i in range(len(nums)):\n        if i < k:\n            formatted_elements.append(str(nums[i]))\n        else:\n            formatted_elements.append('_')\n    output = f\"{k}, nums = [{', '.join(formatted_elements)}]\"\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2, 2, _, _]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "success": true,
          "output": "5, nums = [0, 1, 3, 0, 4, _, _, _]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to count numbers with unique digits for numbers less than 10^n. That is count numbers 0 to 10^n -1 inclusive with all digits distinct. This known problem from LeetCode \"Unique Number\". Approach: for n=0 answer=1 (just 0). For n>=1 count numbers: 1 (zero) + sum_{k=1}^{n} 9 * P(9, k-1). Because first digit cannot be zero. For k digits number: first digit 1-9 (9 choices), remaining k-1 digits choose from remaining 9 digits (including zero) without repetition. So we can compute using factorial-like multiplication.\n\nWe'll produce virtual code with loops. Steps: Start; Input n; if n==0 return 1; result=1; digitsUsed=9; For i=1 to n: result += 9 * digitsUsed; digitsUsed*= (9 - i +1?) Wait: For k from 1 to n: at step k, multiplier = 9 * P(9, k-1). Implementation: we maintain product =9; for k from1 to n: if k==1 product=9 else product*= (10 - k); Actually P(9, k-1) = 9*8*...*(10-k). So we can maintain product =9; For k=1 result+=9; For k=2 product*=8; result+=product; For k=3 product*=7; etc. So loop: product=9; for k=1 to n: result+=product; if k < n: product*= (10 - k -1?) Wait check: When k=1 product=9; next multiplier for k=2 should be product=9*8=72. So multiply by 8 when k=1 to get k=2. That is multiply by (10 - k - 1)? For k=1, (10 -1 -1)=8 correct. For k=2, multiply by (10 -2 -1)=7 for k=3 product=72*7=504 correct. So formula product*= (10 - k -1). We'll loop while k < n. Alternatively use variable remaining=8 and decrement each loop.\n\nLet's produce virtual code: Step 1: Input n. Step 2: Decision n==0? Yes -> return 1. No -> continue. Step 3: Initialize result=1. Step 4: Initialize product=9. Step 5: Initialize i=1. Step 6: Decision i <= n? Yes -> add product to result. Step 7: Decision i==n? Yes -> End loop. No -> multiply product by (10 - i -1). Step 8: Increment i. Step 9: Go to decision. End. Return result.\n\nAlso consider if n>10, unique digits limited to 10 digits, but for n>10, count of unique-digit numbers with digits length up to n but digits distinct limited to 10 digits; for n>=10 the count for k>10 is zero because cannot have more than 10 unique digits. So we should stop at min(n,10). So loop while i <= min(n,10). So we need Decision: i <= 10? etc.\n\nWe'll incorporate.\n\nNow produce lines with virtual code syntax: \"Start\", \"→\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得要計算的數字長度  \n→ Decision: 如果 n = 0? // 直接處理 n = 0 的特殊情況  \n  Yes → Step 2: 回傳 1 // 只有 0 一個符合條件的數字  \n  No → Step 3: 初始化 result = 1 // result 包含 0  \n→ Step 4: 初始化 product = 9 // 第一位數可以選 1-9 的 9 種  \n→ Step 5: 初始化 i = 1 // 目前處理的位數  \n→ Decision: 如果 i ≤ 10 且 i ≤ n? // 只考慮最多 10 位，且不超過 n  \n  Yes → Step 6: result = result + product // 加入 i 位數所有獨特數字的個數  \n  No → Step 7: 跳出迴圈 // 已經處理完所有可能的位數  \n→ Decision: 是否已處理完所有位數?  \n  Yes → End // 完成計算，程式結束  \n  No → Step 8: product = product * (10 - i - 1) // 為下一位數準備剩餘可選數量  \n  No → Step 9: i = i + 1 // 進入下一位數  \n  No → Step 10: 回到 Decision: 如果 i ≤ 10 且 i ≤ n? // 重複迴圈  \nEnd // 程式執行結束，result 為符合條件的數字總數",
      "generated_code": "import sys\nimport re\n\ndef count_unique_digits(n: int) -> int:\n    \"\"\"\n    Return the count of all non‑negative integers less than 10**n\n    that have all digits distinct.\n    \"\"\"\n    if n == 0:\n        return 1                     # only number 0\n\n    n = min(n, 10)                   # cannot have more than 10 unique digits\n    result = 1                       # include number 0\n    product = 9                      # numbers with 1 digit (1–9)\n\n    for i in range(1, n + 1):\n        result += product            # add numbers with i digits\n        if i < n:\n            product *= (10 - i)      # prepare product for i+1 digits\n\n    return result\n\ndef main() -> None:\n    # Read entire input; extract the first integer found\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    print(count_unique_digits(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": true,
          "output": "91"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for checking if s is a subsequence of t. Use Start, End, Decision, steps. Each line has virtual code step + // explanation. Use arrow syntax. Provide lines: Start, Step 1: set pointers i,j to 0. Step 2: while i< len(s) and j< len(t). Step 3: if s[i]==t[j] then i++ else j++. After loop, Decision: if i==len(s) → return true else false. End. Let's produce. Use arrow for each step. Also incorporate Decision block properly. Format exactly as required. Ensure each line ends with comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化指標 i = 0, j = 0 // i 指向 s 的首字元，j 指向 t 的首字元  \n→ Step 2: 迴圈: while i < len(s) 且 j < len(t) // 只要 s 尚未完全比對且 t 尚未走完就繼續  \n  Decision: 若 s[i] == t[j]？ // 檢查兩個指標所在字元是否相同  \n   Yes → Step 3: i = i + 1, j = j + 1 // 若相同，兩個指標同時往後移  \n   No  → Step 4: j = j + 1 // 若不同，只移動 t 的指標  \n→ Decision: s 的所有字元是否已被比對完？即 i == len(s)？ // 判斷是否為子序列  \n  Yes → Step 5: 回傳 true // s 為 t 的子序列  \n  No  → Step 6: 回傳 false // s 不是 t 的子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        \"\"\"Return True if s is a subsequence of t.\"\"\"\n        if not s:\n            return True\n        index_s = 0\n        for char in t:\n            if char == s[index_s]:\n                index_s += 1\n                if index_s == len(s):\n                    return True\n        return False\n\ndef parse_input(raw: str):\n    \"\"\"\n    Parse the raw input string to extract s and t.\n    Supports two formats:\n    1. Two separate lines: first line is s, second is t.\n    2. Single line with comma-separated assignments, e.g.:\n       s = \"abc\", t = \"ahbgdc\"\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return \"\", \"\"\n\n    # If there are newline characters, treat first two lines as s and t\n    if \"\\n\" in raw:\n        lines = raw.splitlines()\n        s = lines[0].strip()\n        t = lines[1].strip() if len(lines) > 1 else \"\"\n        return s, t\n\n    # Otherwise, attempt to extract quoted strings from the single line\n    # Example: s = \"abc\", t = \"ahbgdc\"\n    matches = re.findall(r'\"([^\"]*)\"', raw)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n    # Fallback: split by comma and strip quotes if present\n    parts = raw.split(\",\")\n    if len(parts) >= 2:\n        s_part = parts[0].strip()\n        t_part = parts[1].strip()\n        s = s_part.strip('\"').strip()\n        t = t_part.strip('\"').strip()\n        return s, t\n    # If parsing fails, return empty strings\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, t = parse_input(raw_input)\n    sol = Solution()\n    result = sol.isSubsequence(s, t)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm for decoding ways. Essentially classic decode ways problem (Leetcode 91). Use DP.\n\nWe need step-by-step with arrows.\n\nStart -> read string s length n. If s empty return 0? Actually if empty maybe 0 or 1? Problem says only digits, might not be empty. We'll just handle.\n\ndp[0] = 1 sentinel. iterate i from 1 to n:\n    ways=0\n    if s[i-1] != '0': ways += dp[i-1]\n    if i>=2 and s[i-2]!='0' and integer(s[i-2:i]) <= 26: ways += dp[i-2]\n    dp[i] = ways\nReturn dp[n].\n\nAlso need to handle invalid zero patterns.\n\nWe'll produce virtual code lines.\n\nLet's produce each line with explanation comment.\n\nWe'll include Decision steps.\n\nLet's output:\n\nStart // 程式開始\n→ Step 1: 取得輸入字串 s, 計算長度 n // 取得輸入\n→ Step 2: 建立 dp 陣列長度 n+1，並將 dp[0] 設為 1 // 初始化\n→ Decision: n 為 0? // 判斷是否為空字串\n    Yes → Step 3: 回傳 0 // 空字串無解\n    No  → Continue\n→ Step 4: for i 1 到 n 進行迴圈 // 主迴圈\n    → Step 5: 設定 ways = 0 // 本位置可能的編碼數\n    → Decision: s[i-1] != '0'? // 單數字有效\n        Yes → Step 6: ways += dp[i-1] // 加上前一位的方案\n        No  → Step 7: 不變\n    → Decision: i >= 2 AND s[i-2] != '0' AND int(s[i-2:i]) <= 26? // 兩位數字有效\n        Yes → Step 8: ways += dp[i-2] // 加上前兩位的方案\n        No  → Step 9: 不變\n    → Step 10: dp[i] = ways // 設置本位置的編碼方式數\n→ Step 11: 回傳 dp[n] // 最後答案\nEnd // 程式結束\n\nNeed to include arrows for decision.\n\nLet's format exactly: each line: \"虛擬碼步驟 // 解釋\"\n\nUse arrow \"→\" for steps, \"Decision:\" for decision. For nested, indent.\n\nWe must ensure each line has the code part then space then comment. For decision, the line itself: \"Decision: condition?\".\n\nBut we need to match format: each line must contain: virtual code step + space + comment. So \"Decision: if s[i-1] != '0'? // 判斷\" is ok.\n\nBut indentation: we can include leading spaces but still a line. Example:\n\n→ Decision: s[i-1] != '0'? // 判斷\n\n    Yes → Step 6: ways += dp[i-1] // ...\n\nWe'll keep indentation with four spaces for nested lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 取得輸入字串 s，計算長度 n // 取得輸入\n→ Step 2: 建立 dp 陣列長度 n+1，並將 dp[0] 設為 1 // 初始化\n→ Decision: n 為 0? // 判斷是否為空字串\n    Yes → Step 3: 回傳 0 // 空字串無解\n    No  → (繼續執行)\n→ Step 4: for i from 1 到 n 進行迴圈 // 主迴圈\n    → Step 5: 設定 ways = 0 // 本位置可能的編碼數\n    → Decision: s[i-1] != '0'? // 單數字有效\n        Yes → Step 6: ways += dp[i-1] // 加上前一位的方案\n        No  → (不變)\n    → Decision: i >= 2 AND s[i-2] != '0' AND int(s[i-2:i]) <= 26? // 兩位數字有效\n        Yes → Step 7: ways += dp[i-2] // 加上前兩位的方案\n        No  → (不變)\n    → Step 8: dp[i] = ways // 設置本位置的編碼方式數\n→ Step 9: 回傳 dp[n] // 最後答案\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef num_decodings(s: str) -> int:\n    \"\"\"Return the number of ways to decode the digit string s.\"\"\"\n    if not s or s[0] == '0':\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1          # Empty string has one decoding (do nothing)\n    dp[1] = 1          # Single non-zero digit has one decoding\n\n    for i in range(2, n + 1):\n        # Check the last single digit\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n\n        # Check the last two digits\n        two_digit = int(s[i - 2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract digits even if input includes quotes or other characters\n    digits = re.findall(r'\\d+', data)\n    s = ''.join(digits)\n    result = num_decodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode649.json",
    "problem_index_in_file": 0,
    "title": "Dota2 Senate",
    "description_snippet": "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code describing solution to Dota2 senate problem (like Senate Evacuation? Actually similar to Leetcode 649. Dota2 Senate). Need to produce step-by-step virtual code with explanation, per line, no actual code, just steps. Must output \"Radiant\" or \"Dire\". So algorithm: use queue for indices of Radiant and Dire. While both non-empty, pop front of each, compare indices, higher index senator gets banned, lower index goes to back with index+len. Return party name.\n\nWe must provide virtual code lines: Start, Step1: initialize queues, etc. Use Decision etc.\n\nLet's craft.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n\n→ Step 1: 取得輸入字串 senate // 讀取參賽者陣列\n\n→ Step 2: 初始化 RadiantQueue, DireQueue // 建立兩隊列存放對應索引\n\n→ Decision: 為每個索引 i, 若 senate[i] == 'R' → enqueue i to RadiantQueue else enqueue i to DireQueue // 將所有索引加入各自隊列\n\n→ Step 3: 循環判斷 RadiantQueue 和 DireQueue 是否同時非空 // 若同時有剩餘成員則進行比賽\n\n    → Decision: 若 RadiantQueue 前端索引 < DireQueue 前端索引? // 比較兩隊列最前面索引\n\n        Yes → Radiant勝利者 ban Dire // Radiant的左邊成員先行，將 Dire 的成員禁用\n              → 將 Radiant 的索引重新入隊，索引加上總長 senate_len // Radiant 重新排入下一輪\n              → 解除 Dire 的索引 // Dire 成員被禁用，不進入隊列\n\n        No  → Dire勝利者 ban Radiant // 反之 Dire 先行\n              → 將 Dire 的索引重新入隊，索引加上總長 senate_len\n              → 解除 Radiant 的索引\n\n→ Decision: 若 RadiantQueue 為空? // 只有 Dire 存在\n\n    Yes → Output \"Dire\" // Dire 宣佈勝利\n\n    No → Output \"Radiant\" // Radiant 宣佈勝利\n\nEnd // 程式結束\n\nBut need to incorporate virtual code lines with arrow and comments.\n\nAlso we may need to mention the loop. Use Start, → Step, → Decision, Yes →, No →.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 senate // 取得所有議員的陣列  \n→ Step 2: 建立兩個隊列 RadiantQueue 與 DireQueue // 用於存放各黨派議員的索引  \n→ Decision: 遍歷 senate 中每個索引 i  \n  Yes → 若 senate[i] == 'R' → Enqueue i 到 RadiantQueue // Radiant 的議員加入隊列  \n  No  → Enqueue i 到 DireQueue // Dire 的議員加入隊列  \n→ Step 3: 計算總長 senate_len = senate.length // 用於索引輪轉  \n→ Step 4: 當 RadiantQueue 與 DireQueue 同時非空時  \n  → Decision: 比較兩隊列前端索引  \n   Yes → Radiant 的索引小於 Dire 的索引 // Radiant 先行  \n    → Radiant bans Dire 的議員 // Dire 的索引不進入隊列  \n    → Radiant 的索引重新入隊，索引加上 senate_len // 讓 Radiant 參與下一輪  \n   No  → Dire 的索引小於 Radiant 的索引 // Dire 先行  \n    → Dire bans Radiant 的議員  \n    → Dire 的索引重新入隊，索引加上 senate_len  \n→ Decision: 若 RadiantQueue 為空? // 只剩 Dire  \n  Yes → Output \"Dire\" // Dire 宣佈勝利  \n  No  → Output \"Radiant\" // Radiant 宣佈勝利  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def predictPartyVictory(self, senate: str) -> str:\n        n = len(senate)\n        radiant = deque()\n        dire = deque()\n\n        for i, s in enumerate(senate):\n            if s == 'R':\n                radiant.append(i)\n            else:\n                dire.append(i)\n\n        while radiant and dire:\n            r_index = radiant.popleft()\n            d_index = dire.popleft()\n            if r_index < d_index:\n                radiant.append(r_index + n)\n            else:\n                dire.append(d_index + n)\n\n        return \"Radiant\" if radiant else \"Dire\"\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse input which might be like: senate = \"RD\"\n    if '=' in data:\n        _, value = data.split('=', 1)\n        senate = value.strip()\n    else:\n        senate = data\n\n    # Remove surrounding quotes if present\n    if (senate.startswith('\"') and senate.endswith('\"')) or (senate.startswith(\"'\") and senate.endswith(\"'\")):\n        senate = senate[1:-1]\n\n    solution = Solution()\n    result = solution.predictPartyVictory(senate)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "senate = \"RD\"",
          "expected_output": "\"Radiant\"",
          "success": true,
          "output": "Radiant"
        },
        {
          "example_index": 1,
          "input": "senate = \"RDD\"",
          "expected_output": "\"Dire\"",
          "success": true,
          "output": "Dire"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation in Chinese. The problem: check if array has subarray length>=2 with sum multiple of k. Classic solution: prefix sum mod k, store earliest index for each remainder. If same remainder seen again with distance>=2, return true. Edge case k=0: need subarray sum 0 with length>=2; track cumulative sum, and if any two same sums with distance>=2.\n\nWe'll produce steps: Start, initialize map remainder->first index, maybe map with -1 initial for remainder 0. Iterate over array, compute prefix sum, compute remainder (if k!=0 else sum). Check if remainder seen before with index difference>=2 => return true. At end return false. Also handle k==0 case: store first occurrence of each sum; if same sum seen again with distance>=2, return true. Provide explanation each line.\n\nUse virtual code with arrows. Use Decision, Step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 `prefixSum ← 0` // 計算前綴和  \n→ Step 2: 初始化字典 `remainderIndex`，存放「餘數 → 最早索引」 // 用於檢查相同餘數  \n→ Step 3: 如果 `k ≠ 0`，則 `remainderIndex[0] ← -1` // 讓餘數 0 從索引 -1 開始，方便長度≥2檢查  \n→ Decision: `k = 0`? // 需要特殊處理  \n  Yes → Step 4: 初始化字典 `sumIndex`，存放「前綴和 → 最早索引」  \n  No  → Continue  \n\n→ Step 5: 遍歷陣列 `nums`，索引為 `i`（從 0 開始）  \n  → Update `prefixSum ← prefixSum + nums[i]` // 更新前綴和  \n  → Decision: `k = 0`?  \n    Yes → Step 6: 計算 `currentSum ← prefixSum` // 直接使用總和作為鍵  \n     → Decision: `currentSum` 是否已在 `sumIndex`?  \n      Yes → Step 7: 計算距離 `dist ← i - sumIndex[currentSum]`  \n       → Decision: `dist ≥ 2`?  \n         Yes → Step 8: 返回 `true` // 找到長度≥2且和為 0 的子陣列  \n         No → Step 9: 更新 `sumIndex[currentSum] ← i` // 更新最近索引  \n      No → Step 9: 更新 `sumIndex[currentSum] ← i` // 新的前綴和記錄  \n    No → Step 10: 計算 `remainder ← prefixSum mod k`（k>0）  \n     → Decision: `remainder` 是否已在 `remainderIndex`?  \n      Yes → Step 11: 計算距離 `dist ← i - remainderIndex[remainder]`  \n       → Decision: `dist ≥ 2`?  \n         Yes → Step 12: 返回 `true` // 找到長度≥2且和為 k 的倍數  \n         No → Step 13: 更新 `remainderIndex[remainder] ← i` // 更新最近索引  \n      No → Step 13: 更新 `remainderIndex[remainder] ← i` // 新的餘數記錄  \n\n→ Step 14: 循環結束後，若未返回 `true`  \n→ Step 15: 返回 `false` // 未找到符合條件的子陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        \"\"\"\n        檢查 nums 是否存在長度至少 2 的子陣列，且子陣列和是 k 的倍數。\n        \"\"\"\n        # 字典存儲餘數 -> 最早出現的索引\n        remainder_index = {0: -1}\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            if k != 0:\n                total %= k\n            # 若此餘數已出現過且距離 >= 2，即找到符合條件的子陣列\n            if total in remainder_index:\n                if i - remainder_index[total] > 1:\n                    return True\n            else:\n                remainder_index[total] = i\n        return False\n\ndef main():\n    # 從 stdin 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到第一個 ']'，將列表與 k 分離\n    close_bracket = data.find(']')\n    if close_bracket == -1:\n        raise ValueError(\"輸入格式錯誤，缺少 ']'\")\n\n    list_str = data[:close_bracket + 1]\n    rest_str = data[close_bracket + 1:].strip()\n\n    # 移除可能的前置逗號和空白，得到 k 的字串\n    if rest_str.startswith(','):\n        rest_str = rest_str[1:].strip()\n    k = int(rest_str) if rest_str else 0\n\n    # 使用 ast.literal_eval 解析列表，安全處理\n    nums = ast.literal_eval(list_str)\n\n    # 執行邏輯\n    solution = Solution()\n    result = solution.checkSubarraySum(nums, k)\n\n    # 輸出結果，要求為小寫字串\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines. It's a known problem: find smallest missing positive. O(n) time, O(1) space. Approach: place each number in its correct index (1 to n). Then first index not matching. Provide pseudocode lines.\n\nWe need to produce step by step lines: Start, etc. Use arrow, decision, etc. Provide comment after space. Each line: `虛擬碼步驟 // 解釋`. Use arrow `→` to indicate next step. For loops, we can have `For i = 0 to n-1:` maybe. Use decision: if condition, Yes→, No→. Use End.\n\nLet's craft:\n\nStart // start\n→ Step 1: Let n = length(nums) // store length\n→ For i = 0 to n-1: // iterate all indices\n    → Decision: if nums[i] <= 0 or nums[i] > n? // skip non-positive or out of range\n        Yes → Continue // skip\n        No  → // valid candidate\n            → Decision: while nums[i] != i+1 and nums[nums[i]-1] != nums[i] // while not in correct position and target spot not same\n                Yes → Step 2: swap nums[i] and nums[nums[i]-1] // place number to correct index\n                No  → // no need to swap\n→ For i = 0 to n-1: // find first missing\n    → Decision: if nums[i] != i+1\n        Yes → Step 3: Return i+1 // smallest missing positive\n        No  → Continue\n→ Step 4: Return n+1 // all positions filled\nEnd\n\nBut need to output line by line with arrow. For loops need arrow before each line maybe. The sample shows arrow for each step line, not for loops. We can represent loop lines as:\n\n→ Step 1: Let n = length(nums) // store length\n→ Step 2: For i = 0 to n-1 do // iterate indices\n    → Decision: if nums[i] <= 0 or nums[i] > n\n        Yes → Continue // skip\n        No  → Step 3: // continue to placement\n            → Decision: while nums[i] != i+1 and nums[nums[i]-1] != nums[i]\n                Yes → Step 4: swap nums[i] and nums[nums[i]-1]\n                No  → // exit while\n\nBut formatting may be messy. We could write each line separately and use indentation for decisions.\n\nMaybe better:\n\nStart // start\n→ Step 1: Let n = length(nums) // get array size\n→ Step 2: For i = 0 to n-1 do // iterate over all elements\n    → Decision: if nums[i] <= 0 or nums[i] > n\n        Yes → Continue // ignore non-positive or too large\n        No  → // valid number, attempt to place\n            → Decision: while nums[i] != i+1 and nums[nums[i]-1] != nums[i]\n                Yes → Step 3: swap nums[i] and nums[nums[i]-1] // put number in correct slot\n                No  → // correct slot reached\n→ Step 4: For i = 0 to n-1 do // find first index not matching\n    → Decision: if nums[i] != i+1\n        Yes → Return i+1 // missing positive found\n        No  → Continue\n→ Step 5: Return n+1 // all positions filled, next positive missing\nEnd // finish\n\nNeed each line in output. But each line must contain \"虛擬碼步驟\" then space then comment. Use arrows. Should we put indentation? We can keep arrow for each new line. For decision branches, we indent? The sample uses indentation after Decision: maybe use spaces. Eg:\n\n→ Decision: ...\n    Yes → ...\n    No  → ...\n\nSo we need to produce lines exactly like that.\n\nAlso we must not output actual code. So we keep generic names. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n = length(nums) // 取得陣列長度  \n→ Step 2: For i = 0 to n-1 do // 逐一遍歷每個索引  \n  → Decision: if nums[i] <= 0 or nums[i] > n // 非正數或超出範圍的值不做處理  \n   Yes → Continue // 跳過此元素  \n   No  → // 進行位置交換  \n    → Decision: while nums[i] != i+1 and nums[nums[i]-1] != nums[i] // 該數字尚未在正確位置且目標位置不相同  \n     Yes → Step 3: swap nums[i] and nums[nums[i]-1] // 將數字放到正確索引  \n     No  → // 位置已正確，離開迴圈  \n→ Step 4: For i = 0 to n-1 do // 再次掃描陣列尋找缺失正整數  \n  → Decision: if nums[i] != i+1 // 位置上的數字不符合應有值  \n   Yes → Return i+1 // 找到最小缺失正整數  \n   No  → Continue // 位置正確，繼續檢查下一個  \n→ Step 5: Return n+1 // 所有位置皆符合，缺失數為 n+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef firstMissingPositive(nums):\n    \"\"\"\n    Find the smallest missing positive integer in an unsorted list.\n    Uses O(n) time and O(1) additional space.\n    \"\"\"\n    n = len(nums)\n    for i in range(n):\n        # Place each number in its correct position if possible\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    # Find the first index where the number is not correct\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n\n    return n + 1\n\ndef main():\n    \"\"\"\n    Read input from stdin, extract the list of integers,\n    compute the answer, and print it to stdout.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part from possible \"nums = [ ... ]\" format\n    idx = data.find('[')\n    if idx == -1:\n        # Assume the entire input is the list\n        nums = ast.literal_eval(data)\n    else:\n        nums = ast.literal_eval(data[idx:])\n\n    result = firstMissingPositive(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Each line: virtual step + // explanation. Use Start, Decision, arrows, etc. We should design algorithm: iterate string, count As, track consecutive L's. If A>=2 or consecutive L>=3 => false else true.\n\nWe must produce line-by-line steps with virtual code. Let's outline:\n\nStart // program start\n→ Step 1: 初始化缺席計數 countA = 0 // count absent days\n→ Step 2: 初始化連續遲到計數 consecL = 0 // consecutive late days\n→ Step 3: 迭代遍歷每個字符 ch in s // process each day\n    → Decision: 是否 ch == 'A'? // check absent\n        Yes → countA = countA + 1 // increment absent count\n        No  → Decision: 是否 ch == 'L'? // check late\n            Yes → consecL = consecL + 1 // increment consecutive late\n            No  → consecL = 0 // reset consecutive late when present\n    → Decision: countA >= 2? // too many absences\n        Yes → Return False // not eligible\n        No  → Decision: consecL >= 3? // too many consecutive late\n            Yes → Return False // not eligible\n            No → continue loop\n→ Step 4: After loop, return True // eligible\n\nEnd.\n\nWe must ensure we output virtual code lines with arrows. We should use \"→\" for sequential steps. Indentation for decisions and substeps.\n\nUse \"Start\" and \"End\". Provide explanation for each line.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 初始化缺席計數 countA = 0 // 記錄整體缺席天數\n→ Step 2: 初始化連續遲到計數 consecL = 0 // 記錄連續遲到天數\n→ Step 3: 迭代遍歷字串 s 的每個字元 ch // 逐天檢查\n    → Decision: ch == 'A' ? // 判斷是否為缺席\n        Yes → countA = countA + 1 // 增加缺席計數\n        No  → Decision: ch == 'L' ? // 判斷是否為遲到\n            Yes → consecL = consecL + 1 // 增加連續遲到計數\n            No  → consecL = 0 // 遲到結束，重設計數\n    → Decision: countA >= 2 ? // 過多缺席\n        Yes → Return False // 不符合獎勵條件\n        No  → Decision: consecL >= 3 ? // 過多連續遲到\n            Yes → Return False // 不符合獎勵條件\n            No  → // 繼續處理下一天\n→ Step 4: 迴圈結束後，Return True // 仍符合所有條件\nEnd // 程式結束執行\n\nBut we must keep each line separate. We need to ensure each line ends with explanation. For lines with multiple steps like \"→ Decision: ch == 'A' ?\" should be one line. The Yes and No branches are sublines with indentation. They should also have explanations.\n\nLet's craft final answer accordingly. Ensure consistent spacing.\n\nWe need to include Start and End lines. Provide virtual code arrow and explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化缺席計數 countA = 0 // 記錄整體缺席天數  \n→ Step 2: 初始化連續遲到計數 consecL = 0 // 記錄連續遲到天數  \n→ Step 3: 迭代遍歷字串 s 的每個字元 ch // 逐天檢查  \n  → Decision: ch == 'A' ? // 判斷是否為缺席  \n   Yes → countA = countA + 1 // 增加缺席計數  \n   No  → Decision: ch == 'L' ? // 判斷是否為遲到  \n     Yes → consecL = consecL + 1 // 增加連續遲到計數  \n     No  → consecL = 0 // 遲到結束，重設計數  \n  → Decision: countA >= 2 ? // 過多缺席  \n   Yes → Return False // 不符合獎勵條件  \n   No  → Decision: consecL >= 3 ? // 過多連續遲到  \n     Yes → Return False // 不符合獎勵條件  \n     No  → // 繼續處理下一天  \n→ Step 4: 迴圈結束後，Return True // 仍符合所有條件  \nEnd // 程式結束執行",
      "generated_code": "import sys\n\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        # 計算缺席天數\n        if s.count('A') >= 2:\n            return False\n        # 檢查是否有 3 天連續遲到\n        if 'LLL' in s:\n            return False\n        return True\n\ndef main():\n    # 從標準輸入讀取原始字串，去除可能存在的雙引號\n    raw_input = sys.stdin.read().strip()\n    s = raw_input.strip('\"')\n    solution = Solution()\n    result = solution.checkRecord(s)\n    # 依據題目要求輸出小寫的 true/false\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line explanation in Traditional Chinese. Must follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows, decision, Start, End.\n\nWe need to implement typical remove duplicates in sorted array. Approach: use two pointers, write unique elements at position i. Return i.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize writeIndex = 1 // index for writing next unique\n→ Step 2: If nums length <= 1, return nums length // trivial\n→ Decision: 是否有至少兩個元素? // start loop\n    Yes → Step 3: For readIndex from 1 to nums.length-1 // iterate\n        → Decision: nums[readIndex] != nums[readIndex-1]? // new unique\n            Yes → Step 4: nums[writeIndex] = nums[readIndex] // write\n            → Step 5: writeIndex = writeIndex + 1 // increment\n            No → // duplicate, skip\n        → End Decision\n    → End For\n    → Step 6: return writeIndex // number of unique\n    No → Step 7: return 0 // empty array\nEnd\n\nBut need to keep consistent with arrow and decision syntax.\n\nLet's produce lines with indentation to indicate nesting. Use \"Decision:\" lines.\n\nWe need \"Start // 程式開始執行\" etc.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: writeIndex ← 1 // 用於寫入下一個唯一元素的位置\n\nLine3: → Decision: nums.length <= 1? // 判斷陣列是否為空或只有一個元素\n\nLine4:     Yes → Step 2: return nums.length // 若只有0或1個元素，直接返回長度\n\nLine5:     No  → // 進入後續處理\n\nLine6: → Step 3: for readIndex ← 1 to nums.length-1 // 從第二個元素開始遍歷\n\nLine7: →     Decision: nums[readIndex] ≠ nums[readIndex-1]? // 檢查是否為新唯一值\n\nLine8: →         Yes → Step 4: nums[writeIndex] ← nums[readIndex] // 把唯一值寫入結果位置\n\nLine9: →         → Step 5: writeIndex ← writeIndex + 1 // 更新寫入指標\n\nLine10: →         No  → // 重複值，直接跳過\n\nLine11: →     End Decision\n\nLine12: → End For\n\nLine13: → Step 6: return writeIndex // 返回唯一元素個數\n\nLine14: End // 程式執行結束\n\nBut we need \"End Decision\" lines. Use \"End Decision\". Provide comments.\n\nAlso need to close loops: \"End For\". Use \"End For\" comment.\n\nLet's adjust formatting: Each line separated. Use arrow only at start of step lines? They used \"→\" for step lines. For decisions we use \"Decision:\" lines with indent. They used indent as spaces. Provide consistent.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIndex ← 1 // 用於寫入下一個唯一元素的位置  \n→ Decision: nums.length <= 1? // 判斷陣列是否為空或只有一個元素  \n Yes → Step 2: return nums.length // 若只有0或1個元素，直接返回長度  \n No  → // 進入後續處理  \n→ Step 3: for readIndex ← 1 to nums.length-1 // 從第二個元素開始遍歷  \n → Decision: nums[readIndex] ≠ nums[readIndex-1]? // 檢查是否為新唯一值  \n  Yes → Step 4: nums[writeIndex] ← nums[readIndex] // 把唯一值寫入結果位置  \n   → Step 5: writeIndex ← writeIndex + 1 // 更新寫入指標  \n  No  → // 重複值，直接跳過  \n → End Decision  \n→ End For  \n→ Step 6: return writeIndex // 返回唯一元素個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef remove_duplicates(nums):\n    \"\"\"\n    移除已排序陣列中的重複元素，並回傳唯一元素的個數。\n    \"\"\"\n    if not nums:          # 空陣列直接回傳 0\n        return 0\n    write_idx = 1         # 用於寫入下一個唯一元素的位置\n    for read_idx in range(1, len(nums)):\n        if nums[read_idx] != nums[read_idx - 1]:  # 新唯一值\n            nums[write_idx] = nums[read_idx]      # 寫入結果\n            write_idx += 1\n    return write_idx      # 唯一元素個數\n\ndef main():\n    # 讀取標準輸入，預期格式為 'nums = [1,1,2]' 或直接 '[1,1,2]'\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 拆解 'nums = [ ... ]' 之類的輸入\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 如果字串不是合法 Python 列表，嘗試自行解析數字\n        nums = list(map(int, re.findall(r'-?\\d+', list_str)))\n\n    k = remove_duplicates(nums)\n\n    # 構造輸出字串，將剩餘位置用 '_' 表示\n    output_elements = [str(nums[i]) for i in range(k)] + ['_'] * (len(nums) - k)\n    output = f\"{k}, nums = [{','.join(output_elements)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": true,
          "output": "2, nums = [1,2,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step, with arrows, Start, End, Decision, etc. The requirement: use virtual code arrow, each line includes // explanation. Must not output actual code, only pseudo-code structure. Should be line-by-line. For the algorithm: find third distinct maximum or return max if less than 3 distinct.\n\nWe'll produce a flow. Outline:\n\nStart\n→ Initialize first, second, third maximum variables to negative infinity or null\n→ Iterate over nums:\n    → For each number, if equals any of first/second/third skip\n    → If number > first:\n          third = second; second = first; first = number\n       Else if number > second:\n          third = second; second = number\n       Else if number > third:\n          third = number\n→ After loop, if third is still null or negative infinity, return first else return third\nEnd\n\nBut need to adhere to \"虛擬碼步驟\" lines. Use \"Decision:\" for if checks.\n\nLet's produce step-by-step:\n\nStart // 程式開始\n→ 初始化 first, second, third 為 null // 用於存儲前三個最大不同數\n→ Decision: nums 是否為空? // 判斷輸入是否有效\n    Yes → Step: 返回 null 或 0? // 若空，根據需求可返回 null（或 0）\n    No  → For each number in nums:\n        → Decision: number 是否等於 first 或 second 或 third? // 跳過重複值\n            Yes → // 跳過\n            No  → Decision: number > first? // 更新最大值\n                Yes → Step: third = second, second = first, first = number // 更新三個最大值\n                No  → Decision: number > second? // 更新第二大\n                    Yes → Step: third = second, second = number\n                    No  → Decision: number > third? // 更新第三大\n                        Yes → Step: third = number\n                        No  → // 無操作\n        // 迭代結束\n    → Decision: third 是否為 null? // 判斷是否存在第三大\n        Yes → Step: 返回 first // 沒有第三大，返回最大值\n        No  → Step: 返回 third // 返回第三大\nEnd // 程式結束\n\nWe need to ensure each line has format: \"虛擬碼步驟 [空格] // 解釋/說明\". Also using arrows. For loops, we can use \"For each number in nums:\" line. But they want arrow lines: \"→ For each number in nums:\" could be considered step. For decision lines: \"Decision: ...\" with arrows for Yes/No. Ensure indentation using spaces.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize first, second, third 為 null // 用於存儲前三個最大不同數值  \n→ Decision: nums 是否為空? // 檢查輸入是否為空陣列  \n    Yes → Return null // 若空陣列，直接回傳 null（或可依需求回傳 0）  \n    No  → For each number in nums: // 開始遍歷每個數字  \n        → Decision: number 等於 first 或 second 或 third? // 跳過重複值  \n            Yes → // 跳過此數字，繼續下一個  \n            No  → Decision: number > first? // 檢查是否為新的最大值  \n                Yes → Step: third = second, second = first, first = number // 更新三個最大值  \n                No  → Decision: number > second? // 檢查是否為第二大值  \n                    Yes → Step: third = second, second = number // 更新第二大與第三大  \n                    No  → Decision: number > third? // 檢查是否為第三大值  \n                        Yes → Step: third = number // 更新第三大值  \n                        No  → // 目前數字不屬於前三大，無需操作  \n        // 迭代結束  \n    → Decision: third 是否為 null? // 判斷是否存在第三大不同數  \n        Yes → Step: Return first // 沒有第三大，返回最大值  \n        No  → Step: Return third // 返回第三大不同數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def thirdMax(self, nums):\n        \"\"\"\n        找出陣列中第三個不同的最大值。\n        若不存在第三個不同的最大值，則回傳最大值。\n        \"\"\"\n        # 使用負無限大作為初始值，方便比較\n        first = second = third = float('-inf')\n        # 去重後的集合，確保不會因重複值影響排名\n        nums_set = set(nums)\n\n        for num in nums_set:\n            if num > first:\n                third = second\n                second = first\n                first = num\n            elif num > second:\n                third = second\n                second = num\n            elif num > third:\n                third = num\n\n        # 若不同數量不足三個，回傳最大值\n        return third if len(nums_set) >= 3 else first\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，返回一個整數列表。\n    允許輸入形如 'nums = [1, 2, 3]' 或直接 '[1, 2, 3]'。\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        data = rhs.strip()\n    try:\n        # 使用 ast.literal_eval 以安全方式解析列表\n        return ast.literal_eval(data)\n    except Exception:\n        # 如果解析失敗，回傳空列表\n        return []\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n\n    solution = Solution()\n    result = solution.thirdMax(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode639.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways II",
    "description_snippet": "A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step to compute number of decodings for string with digits and '*'. Classic problem: Count decodings with '*' using DP and modulo. Provide step-by-step algorithm pseudocode with decisions.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision. Provide Start, End.\n\nWe need to consider the logic: DP[i] = number of ways to decode first i characters. DP[0]=1. For each i from 1..n, compute dp[i] based on s[i-1] char and previous two chars. Cases: single char: if '*' -> 9 ways; if '1'..'9' -> 1 way; else 0. For two char pair: if i>=2: consider s[i-2] and s[i-1]. Cases: if first is '1': if second '*': 9 ways; else 1. If first is '2': if second '*': 6 ways; else if second in '0'..'6': 1 else 0. If first is '*': then if second is '*': 15 ways (since '**' can be 11-19 and 21-26). Actually mapping: '**' possibilities: '11' to '19' (9) + '21' to '26' (6) = 15. If second is digit '0'-'6': '*' can be '1' or '2' -> 2 ways; if second '7'-'9': only '*' can be '1' -> 1 way.\n\nAlso need modulo.\n\nWe will produce steps for initialization, loop, compute single and double contributions, accumulate.\n\nAlso need to handle big numbers mod.\n\nWe need to output each line with explanation.\n\nLet's craft pseudo-code:\n\nStart\n→ Decision: If input string empty? No // handle case\n    Yes → End // empty input has 0 decodings? Actually empty string maybe 0? Usually return 0; but we can treat dp[0]=1 and if n==0 return 0. But we can just proceed.\n    No  → Step 1: Initialize dp array of length n+1 with 0 // DP table\n    → Step 2: dp[0] ← 1 // Base case\n    → Step 3: For i from 1 to n // iterate through string\n        → Step 3.1: single = 0 // ways from single character\n        → Decision: If s[i-1] == '*'? Yes\n            → Step 3.1a: single ← 9 // '*' can be 1-9\n        → No  → Decision: If s[i-1] between '1' and '9'? Yes\n            → Step 3.1b: single ← 1\n        → No → Step 3.1c: single ← 0 // '0' cannot be decoded alone\n        → Step 3.2: double = 0 // ways from two-character pair\n        → Decision: If i >= 2? Yes\n            → Step 3.2a: c1 ← s[i-2] ; c2 ← s[i-1]\n            → Decision: If c1 == '1'? Yes\n                → Decision: If c2 == '*'? Yes\n                    → Step 3.2a1: double ← 9 // '1*' forms 11-19\n                → No → Step 3.2a2: double ← 1 // '1d' where d 0-9 -> only if d!=0? Wait '10' valid, '11'-'19' valid. If c2=='0' -> 10 valid. So 1 way.\n            → No → Decision: If c1 == '2'? Yes\n                → Decision: If c2 == '*'? Yes\n                    → Step 3.2b1: double ← 6 // '2*' forms 21-26\n                → No → Decision: If c2 between '0' and '6'? Yes\n                    → Step 3.2b2: double ← 1 // '20'-'26'\n                → No → Step 3.2b3: double ← 0 // '27'-'29' invalid\n            → No → Decision: If c1 == '*'? Yes\n                → Decision: If c2 == '*'? Yes\n                    → Step 3.2c1: double ← 15 // '**' forms 11-19 and 21-26\n                → No → Decision: If c2 between '0' and '6'? Yes\n                    → Step 3.2c2: double ← 2 // '*' can be '1' or '2' to form 10-26\n                → No → Decision: If c2 between '7' and '9'? Yes\n                    → Step 3.2c3: double ← 1 // '*' must be '1' to form 17-19\n                → No → Step 3.2c4: double ← 0 // c2 is '0' but we already handled in '0'-'6'\n            → No → Step 3.2d: double ← 0 // other cases\n        → No → Step 3.2: double ← 0 // if i<2\n        → Step 3.3: dp[i] ← (single + double) mod MOD\n    → Step 4: Return dp[n] // number of ways\nEnd\n\nAlso we need to define MOD constant. We'll produce lines.\n\nNeed to output each line with explanation comment.\n\nWe should also add lines for modulo constant and maybe variable definitions.\n\nLet's craft final answer.\n\nWe'll produce Start line, then maybe \"MOD ← 1000000007 // modulus\".\n\nWe need to use \"Decision:\" lines and arrows. Each line includes the arrow arrow '→' after 'Start', etc.\n\nLet's produce each line accordingly.\n\nWe'll keep the pseudocode concise but cover all steps. Include arrow lines for decisions.\n\nLet's write the answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果輸入字串 s 為空? // 檢查是否有字元可解碼  \n  Yes → End // 空字串無解碼方式，程式結束  \n  No  → Step 1: MOD ← 1000000007 // 定義模數  \n→ Step 2: n ← s 的長度 // 取得字串長度  \n→ Step 3: 初始化 dp 陣列長度 n+1，全為 0 // DP 表，用來儲存到各位置的解碼數  \n→ Step 4: dp[0] ← 1 // 空前綴視為一種合法解碼  \n→ For i 從 1 到 n // 逐字元處理  \n  → Step 5: single ← 0 // 從單一字元解碼的方式數  \n  → Decision: s[i-1] == '*'? // 判斷當前字元  \n    Yes → Step 5a: single ← 9 // '*' 代表 1~9，共 9 種  \n    No  → Decision: s[i-1] 在 '1'~'9' 之間? // 是有效數字  \n      Yes → Step 5b: single ← 1 // 只有一種對應  \n      No  → Step 5c: single ← 0 // '0' 不能單獨解碼  \n  → Step 6: double ← 0 // 從兩字元組合解碼的方式數  \n  → Decision: i >= 2? // 是否足夠兩個字元  \n    Yes → Step 6a: c1 ← s[i-2] ; c2 ← s[i-1] // 取前兩字元  \n      → Decision: c1 == '1'? // 第一個是 1  \n       Yes → Decision: c2 == '*'? // 第二個是 '*'\n         Yes → Step 6a1: double ← 9 // '1*' 可以是 11~19\n         No  → Step 6a2: double ← 1 // '1d'（d 0~9）都是有效，僅一種\n       No → Decision: c1 == '2'? // 第一個是 2  \n        Yes → Decision: c2 == '*'?  \n          Yes → Step 6b1: double ← 6 // '2*' 可以是 21~26\n          No  → Decision: c2 在 '0'~'6'?  \n           Yes → Step 6b2: double ← 1 // 20~26\n           No  → Step 6b3: double ← 0 // 27~29 無效  \n       No → Decision: c1 == '*'? // 第一個是 '*'\n        Yes → Decision: c2 == '*'?  \n          Yes → Step 6c1: double ← 15 // '**' 可以是 11~19 (9) + 21~26 (6)\n          No → Decision: c2 在 '0'~'6'?  \n           Yes → Step 6c2: double ← 2 // '*' 可能是 1 或 2  \n           No → Decision: c2 在 '7'~'9'?  \n            Yes → Step 6c3: double ← 1 // '*' 必須是 1  \n            No  → Step 6c4: double ← 0 // 其他情況無效  \n       No → Step 6d: double ← 0 // 其他不符合條件的組合  \n    No  → Step 6e: double ← 0 // i < 2 時不考慮兩字元組合  \n  → Step 7: dp[i] ← (single + double) mod MOD // 累加單字元與雙字元解碼方式，取模  \n→ Step 8: 返回 dp[n] // 最後一個位置的解碼方式總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            # Single character contribution\n            if s[i-1] == '*':\n                dp[i] = 9 * dp[i-1]\n            elif s[i-1] != '0':\n                dp[i] = dp[i-1]\n            else:\n                dp[i] = 0\n\n            # Two character contribution\n            if i > 1:\n                if s[i-2] == '*' and s[i-1] == '*':\n                    dp[i] += 15 * dp[i-2]\n                elif s[i-2] == '*':\n                    if s[i-1] <= '6':\n                        dp[i] += 2 * dp[i-2]\n                    else:\n                        dp[i] += 1 * dp[i-2]\n                elif s[i-1] == '*':\n                    if s[i-2] == '1':\n                        dp[i] += 9 * dp[i-2]\n                    elif s[i-2] == '2':\n                        dp[i] += 6 * dp[i-2]\n                else:\n                    if 10 <= int(s[i-2:i]) <= 26:\n                        dp[i] += dp[i-2]\n            dp[i] %= MOD\n        return dp[n]\n\ndef extract_string(data: str) -> str:\n    \"\"\"\n    Extracts the first quoted string from the input data.\n    If no quotes are found, returns the trimmed input.\n    \"\"\"\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    if match:\n        return match.group(1)\n    # If input is something like s = *, return the part after '='\n    if '=' in data:\n        return data.split('=')[1].strip().strip('\"\\'')\n    return data.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = extract_string(raw_input)\n    result = Solution().numDecodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"*\"",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "s = \"1*\"",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 2,
          "input": "s = \"2*\"",
          "expected_output": "15",
          "success": true,
          "output": "15"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line for a function that checks if a positive integer num is a perfect square, without using sqrt, no built-in library. Likely use binary search, or integer square root method. Provide explanation per line. Use Start, End, Decision, etc.\n\nLet's produce a flow:\n\nStart\n→ Step 1: If num < 1, return false // but input is positive integer, still check? maybe not necessary but safe.\n→ Step 2: Initialize low = 1, high = num // binary search boundaries\n→ Step 3: While low <= high: // loop\n    → Step 4: mid = (low + high) // 2 // integer division\n    → Step 5: square = mid * mid // compute square\n    → Decision: If square == num? // check\n        Yes → Step 6: return true // found perfect square\n        No  → Decision: If square < num? // adjust boundaries\n            Yes → Step 7: low = mid + 1 // search higher\n            No  → Step 8: high = mid - 1 // search lower\n→ End // return false after loop ends\n\nAlso maybe we need to return false at the end.\n\nThus we produce lines.\n\nBut need to output each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to keep each step as a line. Use \"Start\", \"End\". For decisions we indent or not? The format example uses indentation inside decisions. We can follow same style.\n\nWe need to produce exactly following format: each line \"虛擬碼步驟 [space] // 解釋/說明\". The arrow etc. For decisions we should indent accordingly. In the example, they used spaces and indent like:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n\nThus we should use similar indentation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: If num < 1, return false // 若輸入非正整數，直接返回假\n→ Step 2: low = 1 // 設定二分搜尋左邊界\n→ Step 3: high = num // 設定二分搜尋右邊界\n→ Decision: 低於 high? // 循環條件\n    Yes → Step 4: mid = (low + high) // 2 // 取中間值\n    Yes → Step 5: square = mid * mid // 計算平方\n    Yes → Decision: square == num? // 判斷是否為完美平方\n        Yes → Step 6: return true // 找到平方，返回真\n        No  → Decision: square < num? // 確定搜尋方向\n            Yes → Step 7: low = mid + 1 // 低邊界上移\n            No  → Step 8: high = mid - 1 // 右邊界下移\n→ End // 所有可能性檢查完畢，返回假\n\nBut we need to ensure the indentation and arrow formatting matches.\n\nBetter to keep structure like:\n\nStart // 程式開始執行\n→ Step 1: If num < 1, return false // 若輸入非正整數，直接返回假\n→ Step 2: low = 1 // 設定二分搜尋左邊界\n→ Step 3: high = num // 設定二分搜尋右邊界\n→ Decision: low <= high? // 循環條件\n    Yes → Step 4: mid = (low + high) // 2 // 取中間值\n    Yes → Step 5: square = mid * mid // 計算平方\n    Yes → Decision: square == num? // 判斷是否為完美平方\n        Yes → Step 6: return true // 找到平方，返回真\n        No  → Decision: square < num? // 確定搜尋方向\n            Yes → Step 7: low = mid + 1 // 低邊界上移\n            No  → Step 8: high = mid - 1 // 右邊界下移\n→ End // 若迴圈結束未找到，返回假\n\nBut we also need to have a return false at end. The End line might be \"End // 程式執行結束\" and we can say return false inside? Maybe add Step 9: return false at end.\n\nLet's add:\n\n→ Step 9: return false // 若未在循環中返回，則不是完美平方\n\nBut we need to integrate End.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: If num < 1, return false // 若輸入非正整數，直接返回假\n→ Step 2: low = 1 // 設定二分搜尋左邊界\n→ Step 3: high = num // 設定二分搜尋右邊界\n→ Decision: low <= high? // 循環條件\n    Yes → Step 4: mid = (low + high) // 2 // 取中間值\n    Yes → Step 5: square = mid * mid // 計算平方\n    Yes → Decision: square == num? // 判斷是否為完美平方\n        Yes → Step 6: return true // 找到平方，返回真\n        No  → Decision: square < num? // 確定搜尋方向\n            Yes → Step 7: low = mid + 1 // 低邊界上移\n            No  → Step 8: high = mid - 1 // 右邊界下移\n→ Step 9: return false // 迴圈結束未找到，返回假\nEnd // 程式執行結束\n\nBut we need to place Step 9 inside the Decision? Actually after loop ends, we need to return false. We can put Step 9 as part of the loop's else? No, after loop ends, we just return false.\n\nBut the arrow style: after Decision: low <= high? The Yes branch contains steps until maybe high updated. The loop repeats. Once low > high, we exit loop. So Step 9 should be after the loop. So we need to close the decision. In example, they used indentation but still all lines after decision may not be inside? Actually the \"Decision: low <= high?\" lines will produce yes branch with steps. The \"Yes\" arrow shows steps. After that branch, when low > high, we exit loop. So we then have Step 9.\n\nSo we can do:\n\nDecision: low <= high? // 循環條件\n    Yes → ... (steps)\n→ Step 9: return false // 迴圈結束未找到，返回假\n\nBut we need to ensure arrow placement: \"→ Step 9: return false\" maybe not preceded by arrow? In the example, they had \"End // 程式執行結束\" at same indentation as Start, no arrow. So we can just write \"Step 9: return false // ...\" preceded by nothing? But they want each line to have the arrow arrow? They used \"→\" before each step within flow. For top-level step after decision, maybe use \"→\" as well.\n\nBut the example's format: Each line begins with \"Start\" or \"→\" for steps. For example:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // ...\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nThus at top-level we use \"→\" for steps. So Step 9 should be \"→ Step 9: return false // ...\". And End line is \"End // ...\". Yes.\n\nAlso note the \"Decision\" line indentation: they used \"Decision: ...\" not \"→ Decision\". In example, they had \"→ Decision: 如果數字大於 0? // 檢查數值是否為正\". So decision lines preceded by \"→\". Then indent Yes/No arrow lines. Good.\n\nSo we should use \"→ Decision:\" for the loop condition. Then inside we need \"Yes → Step\" etc.\n\nAlso we need to close the loop? There's no explicit closing, but the structure ends with Step 9. So we just provide Step 9 after the decision block.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: If num < 1, return false // 若輸入非正整數，直接返回假  \n→ Step 2: low = 1 // 設定二分搜尋左邊界  \n→ Step 3: high = num // 設定二分搜尋右邊界  \n→ Decision: low <= high? // 進行二分搜尋，條件為左邊界不超過右邊界  \n Yes → Step 4: mid = (low + high) // 2 // 取中間值  \n Yes → Step 5: square = mid * mid // 計算平方  \n Yes → Decision: square == num? // 判斷是否為完美平方  \n  Yes → Step 6: return true // 找到平方，返回真  \n  No → Decision: square < num? // 確定搜尋方向  \n   Yes → Step 7: low = mid + 1 // 低邊界上移，搜尋較大數字  \n   No → Step 8: high = mid - 1 // 右邊界下移，搜尋較小數字  \n→ Step 9: return false // 迴圈結束未找到，返回假  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num < 2:\n            return True\n        left, right = 2, num // 2\n        while left <= right:\n            mid = (left + right) // 2\n            guess = mid * mid\n            if guess == num:\n                return True\n            elif guess > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將可能的「num = 16」格式轉成整數\n    if '=' in data:\n        try:\n            num = int(data.split('=')[1].strip())\n        except ValueError:\n            num = int(data.strip())\n    else:\n        num = int(data.strip())\n\n    sol = Solution()\n    result = sol.isPerfectSquare(num)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line, with each line having \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow \"→\" and structure \"Start\", \"End\", \"Decision:\".\n\nWe need to produce algorithm for Kadane's algorithm: find maximum subarray sum. Steps: initialize max_so_far, max_ending_here. Iterate array. Update max_ending_here = max(nums[i], max_ending_here + nums[i]). Update max_so_far = max(max_so_far, max_ending_here). Return max_so_far.\n\nWe need to produce pseudo-code lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 max_so_far = nums[0] // 設定初始最大值\n→ Step 2: 初始化 max_ending_here = nums[0] // 設定初始子序列和\n→ Step 3: 從 i = 1 到 nums.length - 1 循環 // 遍歷陣列\n    → Decision: 如果 max_ending_here + nums[i] > nums[i]? // 判斷是否將 nums[i] 加入現有子序列\n        Yes → Step 4: max_ending_here = max_ending_here + nums[i] // 加入\n        No  → Step 5: max_ending_here = nums[i] // 重新開始子序列\n    → Step 6: max_so_far = max(max_so_far, max_ending_here) // 更新最大值\n→ Step 7: 返回 max_so_far // 結果\n\nBut we need to maintain formatting with arrows for decisions and else. Use nested indentation maybe. Use spaces for indent.\n\nThe example used indentation with 4 spaces? Actually the example used:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\nEnd // 程式執行結束\n\nSo indentation is 4 spaces for nested decisions. For our algorithm, we have two nested levels: loop and decision. Use similar.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 將 max_so_far 設為 nums[0] // 初始最大子序列和\n→ Step 2: 將 max_ending_here 設為 nums[0] // 初始子序列和\n→ Step 3: 從 i = 1 到 nums.length - 1 迴圈 // 遍歷陣列\n    → Decision: 如果 max_ending_here + nums[i] > nums[i]? // 判斷是否繼續目前子序列\n        Yes → Step 4: max_ending_here = max_ending_here + nums[i] // 加入當前元素\n        No  → Step 5: max_ending_here = nums[i] // 以當前元素開始新子序列\n    → Step 6: max_so_far = max(max_so_far, max_ending_here) // 更新全局最大值\n→ Step 7: 返回 max_so_far // 回傳最大的子陣列和\nEnd // 程式執行結束\n\nCheck formatting: \"→ Decision:\" lines. Indentation: 4 spaces before nested lines. After each line we need explanation. We need to keep Chinese.\n\nWe need to be careful: \"→ Decision:\" line after \"Step 3\" should start with arrow? The example uses \"→ Decision:\" exactly. So use \"→ Decision:\".\n\nIn nested block, indent 4 spaces then lines \"Yes → ...\" etc.\n\nMake sure each line ends with \"// 解釋/說明\". For decision line we also need explanation after the colon? In example they wrote:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n\nSo we follow same. For decision: we need explanation after the colon. So \"→ Decision: 如果 max_ending_here + nums[i] > nums[i]? // 判斷是否繼續目前子序列\".\n\nNow each step line also includes explanation after comment. For step lines we should include explanation after //.\n\nThus final output:\n\nStart // 程式開始執行\n→ Step 1: 將 max_so_far 設為 nums[0] // 初始最大子序列和\n→ Step 2: 將 max_ending_here 設為 nums[0] // 初始子序列和\n→ Step 3: 從 i = 1 到 nums.length - 1 迴圈 // 遍歷陣列\n    → Decision: 如果 max_ending_here + nums[i] > nums[i]? // 判斷是否繼續目前子序列\n        Yes → Step 4: max_ending_here = max_ending_here + nums[i] // 加入當前元素\n        No  → Step 5: max_ending_here = nums[i] // 以當前元素開始新子序列\n    → Step 6: max_so_far = max(max_so_far, max_ending_here) // 更新全局最大值\n→ Step 7: 返回 max_so_far // 回傳最大的子陣列和\nEnd // 程式執行結束\n\nEnsure proper indentation: 4 spaces for nested lines. In the example, indentation before \"Yes →\" and \"No →\" is 8 spaces? They used 4 spaces before \"Yes →\". In example:\n\n        Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n        No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nThey had 8 spaces before \"Yes →\" maybe? Let's count: In example they had:\n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n```\n\nWe see 4 spaces before \"Yes →\". So nested inside decision. Similarly \"Yes → Step 4\". So we need 4 spaces.\n\nAlso after \"Decision:\" line, the \"Yes →\" and \"No  →\" lines should each have indentation 4 spaces.\n\nWe also need to ensure that we include a line \"→ Step 6:\" after the decision block but still within the loop. In example, \"→ Step 6: ...\" appears at same indentation as \"Decision:\" line? Actually \"Step 6\" is at the same indentation as \"Decision:\"? Wait example:\n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n```\n\nHere Step 6 does not exist. So we need to align Step 6 at same indentation as Decision. But Step 6 is outside Decision block but inside loop. So we indent it 4 spaces relative to \"Step 3\" line? Wait \"Step 3\" line has no indentation. After \"Step 3: 從 i=1 到 ... 迴圈 //...\" we indent the block inside loop. The \"Decision:\" line is inside loop. So Step 6 should be indented same as Decision line (4 spaces). Good.\n\nThus final pseudo-code:\n\n```\nStart // 程式開始執行\n→ Step 1: 將 max_so_far 設為 nums[0] // 初始最大子序列和\n→ Step 2: 將 max_ending_here 設為 nums[0] // 初始子序列和\n→ Step 3: 從 i = 1 到 nums.length - 1 迴圈 // 遍歷陣列\n    → Decision: 如果 max_ending_here + nums[i] > nums[i]? // 判斷是否繼續目前子序列\n        Yes → Step 4: max_ending_here = max_ending_here + nums[i] // 加入當前元素\n        No  → Step 5: max_ending_here = nums[i] // 以當前元素開始新子序列\n    → Step 6: max_so_far = max(max_so_far, max_ending_here) // 更新全局最大值\n→ Step 7: 返回 max_so_far // 回傳最大的子陣列和\nEnd // 程式執行結束\n```\n\nCheck if each line ends with comment. Yes. We also need to keep the lines as separate lines, no code formatting. Use plain text. So output these lines.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 max_so_far 設為 nums[0] // 初始最大子序列和\n→ Step 2: 將 max_ending_here 設為 nums[0] // 初始子序列和\n→ Step 3: 從 i = 1 到 nums.length - 1 迴圈 // 遍歷陣列\n    → Decision: 如果 max_ending_here + nums[i] > nums[i]? // 判斷是否繼續目前子序列\n        Yes → Step 4: max_ending_here = max_ending_here + nums[i] // 加入當前元素\n        No  → Step 5: max_ending_here = nums[i] // 以當前元素開始新子序列\n    → Step 6: max_so_far = max(max_so_far, max_ending_here) // 更新全局最大值\n→ Step 7: 返回 max_so_far // 回傳最大的子陣列和\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef max_subarray_sum(nums):\n    \"\"\"Kadane's algorithm to find maximum subarray sum.\"\"\"\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        max_current = num if num > max_current + num else max_current + num\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\ndef parse_input(input_str):\n    \"\"\"Parse a list of integers from a string like 'nums = [-2,1,-3,4]'.\"\"\"\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or end <= start:\n        return []\n    nums_str = input_str[start+1:end]\n    # Split by comma, strip spaces, and convert to int\n    return [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = parse_input(data)\n    if not nums:\n        print(0)\n        return\n    result = max_subarray_sum(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with each line \"虛擬碼步驟 // 解釋\". Use arrows. The requirement: Start, End, Decision etc. The function to find longest common prefix among array of strings. Provide virtual steps.\n\nWe need to show algorithm. Approach: Check if array empty return \"\". Find min length string among array to set limit. Compare characters column-wise. Use loops. Use decisions for mismatch.\n\nWe need to produce each line separately. Use \"Start\", \"→ Step 1: ...\", \"→ Decision: ...\", \"Yes →\", \"No →\" etc.\n\nWe need to output in Traditional Chinese. Provide steps and explanations in Chinese.\n\nLet's design:\n\nStart\n→ Step 1: 初始化變數 commonPrefix 為空字串 // 起始\n→ Step 2: 如果 strings 為空集合，返回空字串 // 結果\n→ Step 3: 找到最短字串的長度 minLen // 用於迭代上限\n→ Step 4: 從 0 到 minLen-1 迴圈 idx // 每個字符位置\n    → Step 4a: 將第一個字串的 idx 字符作為參考 charRef // 參考字符\n    → Decision: 所有字串在位置 idx 的字符是否等於 charRef? // 檢查\n        Yes → Step 4b: 將 charRef 加到 commonPrefix // 建立前綴\n        No  → Step 4c: 立即返回 commonPrefix // 前綴完成\n→ Step 5: 返回 commonPrefix // 完成\n\nWe also need End.\n\nLet's format each line exactly.\n\nMake sure to use \"→\" and \"Decision:\" lines.\n\nAlso need to include indentation? Not strictly but we can indent substeps. Example:\n\nStart // 程式開始執行\n→ Step 1: ... // explanation\n→ Decision: ... // explanation\n   Yes → ...\n   No  → ...\n\nYes.\n\nLet's produce. Ensure each line ends with comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義變數 commonPrefix 為空字串 // 用於存放長度最長的公共前綴\n→ Step 2: 檢查 strings 是否為空集合 // 如果沒有字串，直接返回空字串\n    Yes → Step 3: 返回 commonPrefix // commonPrefix 仍為空，結束執行\n    No  → Decision: 繼續執行\n→ Step 4: 找出 strings 中最短字串的長度 minLen // 以此作為最大可能前綴長度\n→ Step 5: 從 i = 0 到 i < minLen 進行迴圈 // 逐個位置比較字符\n    → Step 5a: 設定 charRef 為 strings[0][i] // 第一個字串的參考字符\n    → Decision: 所有 strings[j][i] 是否等於 charRef? // 判斷此位置是否所有字串相同\n        Yes → Step 5b: 將 charRef 加到 commonPrefix // 加入公共前綴\n        No  → Step 5c: 返回 commonPrefix // 出現不匹配，結束尋找\n→ Step 6: 迴圈結束後返回 commonPrefix // 所有位置皆相同，返回完整前綴\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_common_prefix(strs):\n    \"\"\"\n    找出字串陣列中最長的公共前綴。\n    若陣列為空或無公共前綴，回傳空字串。\n    \"\"\"\n    if not strs:\n        return \"\"\n\n    # 先以第一個字串作為初始前綴\n    prefix = strs[0]\n    # 遍歷其餘字串，逐一縮短前綴直到符合\n    for s in strs[1:]:\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]          # 去掉最後一個字元\n            if not prefix:                # 若前綴已空，直接回傳\n                return \"\"\n    return prefix\n\ndef parse_input(raw):\n    \"\"\"\n    從原始輸入字串解析出字串列表。\n    支援格式例如 'strs = [\"flower\",\"flow\",\"flight\"]' 或僅 '[...]'。\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return []\n\n    # 取出 '[' 後的部分，使用 ast.literal_eval 進行安全評估\n    idx = raw.find('[')\n    if idx != -1:\n        list_part = raw[idx:]\n    else:\n        list_part = raw\n    try:\n        return ast.literal_eval(list_part)\n    except Exception:\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    strs = parse_input(raw_input)\n\n    result = longest_common_prefix(strs)\n\n    # 按題目要求，輸出結果須包含雙引號\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "\"fl\""
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudo-code for edit distance. We must output line by line with explanation. Use Start, Decision, etc. Probably dynamic programming. Each line with \"虛擬碼步驟\" then space then comment. Use arrow.\n\nWe should include Start, Step1: Initialize DP matrix, etc.\n\nLet's produce. Use typical DP: dp[i][j] minimal operations to convert word1[0..i-1] to word2[0..j-1]. Initialize first row/col. Then nested loops. Then answer dp[m][n]. End.\n\nWe must keep each line minimal. Use arrow \"→\" to show next step. Use Decision for if conditions.\n\nWe'll include lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 m = word1 長度, n = word2 長度 // 取得兩字串長度\n→ Step 2: 建立 m+1 行 n+1 列 的 DP 表格 dp // 初始化動態規劃表\n→ Step 3: for i = 0 to m: dp[i][0] = i // 將 word1 轉成空字串需刪除 i 個字元\n→ Step 4: for j = 0 to n: dp[0][j] = j // 將空字串轉成 word2 需插入 j 個字元\n→ Decision: 是否開始雙層迴圈? // 檢查是否有需要填表格\n    Yes → Step 5: for i = 1 to m:\n        → Step 6: for j = 1 to n:\n            → Decision: word1[i-1] 與 word2[j-1] 是否相同? // 檢查字元是否一致\n                Yes → Step 7: dp[i][j] = dp[i-1][j-1] // 無需操作\n                No  → Step 8: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 // 取替換、刪除、插入中最小值加 1\n→ Step 9: 計算結果 = dp[m][n] // 取得最小操作數\n→ Step 10: 回傳結果 // 將結果輸出\nEnd // 程式執行結束\n\nMake sure each line is a line. Also use arrow only for step lines, decisions use indentation with Yes/No. Might need to indent steps under Decision. Provide comments. Ensure the output format matches: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 m = word1 的長度, n = word2 的長度 // 取得兩字串長度\n→ Step 2: 建立 m+1 行 n+1 列的 DP 表格 dp // 初始化動態規劃表\n→ Step 3: for i = 0 to m: dp[i][0] = i // 把 word1 轉成空字串需刪除 i 個字元\n→ Step 4: for j = 0 to n: dp[0][j] = j // 把空字串轉成 word2 需插入 j 個字元\n→ Decision: 是否開始填表格? // 檢查是否有需要進行雙層迴圈\n    Yes → Step 5: for i = 1 to m:\n        → Step 6: for j = 1 to n:\n            → Decision: word1[i-1] 與 word2[j-1] 是否相同? // 檢查當前字元是否一致\n                Yes → Step 7: dp[i][j] = dp[i-1][j-1] // 無需操作，直接遺傳前一步結果\n                No  → Step 8: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 // 取替換、刪除、插入三種操作中最小值加 1\n→ Step 9: 計算結果 = dp[m][n] // 取得將 word1 轉成 word2 所需的最小操作數\n→ Step 10: 回傳結果 // 將最小操作數輸出\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef minDistance(word1: str, word2: str) -> int:\n    \"\"\"\n    計算將 word1 轉換為 word2 所需的最小編輯距離。\n    使用動態規劃，時間複雜度 O(m*n)，空間複雜度 O(m*n)。\n    \"\"\"\n    m, n = len(word1), len(word2)\n    # 建立 DP 表格\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # 初始化第一行和第一列\n    for i in range(m + 1):\n        dp[i][0] = i          # 將前 i 個字元刪除\n    for j in range(n + 1):\n        dp[0][j] = j          # 將空字串插入前 j 個字元\n\n    # 填表格\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]   # 字元相同，不需操作\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i - 1][j],     # 刪除\n                    dp[i][j - 1],     # 插入\n                    dp[i - 1][j - 1]  # 替換\n                )\n    return dp[m][n]\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串，計算編輯距離，輸出結果。\n    支援兩種輸入格式：\n      1. 例如：word1 = \"horse\", word2 = \"ros\"\n      2. 例如：horse ros\n    \"\"\"\n    data = sys.stdin.read()\n    # 先嘗試抓取引號中的字串\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        word1, word2 = quoted[0], quoted[1]\n    else:\n        # 若無引號，直接以空白分隔\n        tokens = data.strip().split()\n        if len(tokens) >= 2:\n            word1, word2 = tokens[0], tokens[1]\n        else:\n            # 輸入不足，直接結束\n            return\n\n    result = minDistance(word1, word2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode765.json",
    "problem_index_in_file": 0,
    "title": "Couples Holding Hands",
    "description_snippet": "There are n couples sitting in 2n seats arranged in a row and want to hold hands.\n\nThe people and se...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: Minimum swaps to seat couples together. Classic solution: Build mapping person->index, then iterate over seats in pairs, if pair already correct continue; else swap current partner with the seat partner of the partner to fix. Count swaps. Or use DSU/graph: each couple as node, each seat pair as connection, find cycles. Minimum swaps = sum(cycleSize-1). Provide virtual code line-by-line with explanation.\n\nWe need to produce steps with arrow syntax. Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". For each decision block, indent? Example shows indentation via spaces.\n\nWe need to output in traditional Chinese. Provide algorithm steps.\n\nWe'll create:\n\nStart\n→ Step 1: 建立 personToIndex 映射 // 將每個人 ID 與座位索引對應\n→ Step 2: 初始化 swaps = 0 // 交換次數計數\n→ Step 3: 迭代座位 i 從 0 到 2n-1 步進 2 // 每兩個座位為一對\n    → Decision: 如果 row[i] 和 row[i+1] 是同一對夫妻? // 檢查是否已配對\n        Yes → Continue // 已配對，移至下一對\n        No  → \n            → Step 4: 找到 row[i] 的配偶 partner = row[i] XOR 1 // 夫妻編號可用 XOR 1\n            → Step 5: 找到 partner 的座位 indexPartner = personToIndex[partner] // 查找座位\n            → Step 6: 交換 row[i+1] 與 row[indexPartner] 的位置 // 使 partner 與 row[i] 同側\n            → Step 7: 更新 personToIndex for the swapped persons // 更新映射\n            → Step 8: swaps++ // 交換次數加一\nEnd // 回傳 swaps\n\nBut we need to reflect mapping update: after swap, indices of two persons change. Provide step to update.\n\nAlso need to consider that personToIndex mapping will be updated after each swap.\n\nAlternatively, DSU approach: Build graph edges between couple indices: For each seat pair, union their couple numbers. After processing all pairs, cycles count = number of components? Actually each cycle of size k requires k-1 swaps. So sum(k-1) = totalPairs - number_of_components. But easier to do pairwise swapping.\n\nWe'll output virtual code lines accordingly.\n\nEnsure each line starts with arrow or Step label.\n\nWe need to use arrow notation: \"→ Step X:\" etc. And decisions with \"Decision:\" and indented Yes / No.\n\nAlso \"Continue\" maybe as \"→ Step X: 下一個座位對 // 繼續處理\" but better use \"→ Step X: next pair\".\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 personToIndex 映射，將每個人 ID 與座位索引對應 // 用於快速查找任何人的座位位置  \n→ Step 2: 初始化 swaps = 0 // 計算最少交換次數  \n→ Step 3: 迭代座位 i 從 0 到 2n-1，步進 2 // 每兩個座位為一對需要檢查的座位  \n  Decision: 如果 row[i] 與 row[i+1] 已是同一對夫妻? // 檢查目前座位對是否正確  \n   Yes → Step 4: 跳至下一個座位對 // 已配對，直接往後處理  \n   No →  \n    → Step 5: 找到 row[i] 的配偶 partner = row[i] XOR 1 // 夫妻編號可用 XOR 1 取得對方 ID  \n    → Step 6: 查找 partner 的座位 indexPartner = personToIndex[partner] // 取得配偶目前座位  \n    → Step 7: 交換 row[i+1] 與 row[indexPartner] 的位置 // 讓 partner 與 row[i] 同側  \n    → Step 8: 更新 personToIndex[row[i+1]] = indexPartner // 交換後 row[i+1] 的新座位  \n      → Step 9: 更新 personToIndex[row[indexPartner]] = i+1 // 交換後 partner 的新座位  \n    → Step 10: swaps++ // 交換次數累加  \n    → Step 11: 跳至下一個座位對 // 完成本對處理  \nEnd // 程式執行結束，返回 swaps 作為最小交換次數",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minSwapsCouples(self, row):\n        n = len(row)\n        pos = [0] * n\n        for i, x in enumerate(row):\n            pos[x] = i\n\n        swaps = 0\n        for i in range(0, n, 2):\n            x = row[i]\n            partner = x ^ 1  # partner's ID\n            if row[i + 1] != partner:\n                partner_idx = pos[partner]\n                # swap the partner into the current pair\n                row[i + 1], row[partner_idx] = row[partner_idx], row[i + 1]\n                # update positions after swap\n                pos[row[partner_idx]] = partner_idx\n                pos[row[i + 1]] = i + 1\n                swaps += 1\n        return swaps\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract the list expression from the input\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data.strip()\n    # Safely parse the list\n    row = ast.literal_eval(expr)\n    result = Solution().minSwapsCouples(row)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "row = [0,2,1,3]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "row = [3,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with step by step for solving the guess game. We need to output each line with virtual code and explanation. Must not output real code. Use arrow notation and decisions.\n\nThe algorithm: binary search from 1 to n. Use guess function.\n\nWe produce something like:\n\nStart\n→ Initialize low = 1, high = n\n→ Decision: low <= high?\n    Yes → Compute mid = (low + high)/2\n    → Call guess(mid) -> result\n    → Decision: result == 0? \n        Yes → Return mid // found\n        No → Decision: result < 0? // guess too high\n            Yes → high = mid - 1\n            No  → low = mid + 1\n    No → End (shouldn't happen) or return -1\nEnd\n\nAdd explanation after each line.\n\nWe need to format each line: \"虛擬碼步驟 // 解釋\".\n\nWe must not output actual code but just pseudo steps. Use arrow arrows for steps.\n\nLet's craft.\n\nNeed to use Chinese explanations. Use \"Start\" and \"End\".\n\nAlso need decision lines: \"Decision: ...\".\n\nUse \"Yes →\", \"No →\".\n\nLet's produce.\n\nWe should include \"Return mid\" step. But in virtual code, we might say \"Return mid\" and \"End\". But maybe we can put \"→ Return mid\" then \"End\".\n\nAlso note that we need to show steps within decision branches.\n\nLet's produce a clear, structured flow.\n\nBe careful: each line should have only one step. Use indentation? The example uses indentation to indicate nested decisions. Use same style.\n\nOk.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 1, high ← n // 初始化搜尋區間  \n→ Decision: low ≤ high? // 檢查區間是否仍有可能  \n    Yes → Step 2: mid ← (low + high) / 2 // 計算中點作為猜測值  \n    → Step 3: result ← guess(mid) // 呼叫 API 取得判斷結果  \n    → Decision: result == 0? // 判斷是否猜對  \n        Yes → Step 4: return mid // 找到目標數字，結束搜尋  \n        No → Decision: result < 0? // 判斷猜測是否過大  \n            Yes → Step 5: high ← mid - 1 // 目標在 lower half  \n            No  → Step 6: low ← mid + 1 // 目標在 upper half  \n    No → End // 理論上不會到此，表示無法找到數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Global variable to store the number to be guessed\npick = None\n\ndef guess(num: int) -> int:\n    \"\"\"\n    模擬猜數字的 API。\n    -1: num > pick\n     1: num < pick\n     0: num == pick\n    \"\"\"\n    global pick\n    if num > pick:\n        return -1\n    elif num < pick:\n        return 1\n    else:\n        return 0\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        \"\"\"\n        使用二分搜尋在 1 ~ n 的區間內找出 pick。\n        \"\"\"\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:        # mid > pick\n                right = mid - 1\n            else:                # mid < pick\n                left = mid + 1\n        return -1  # 理論上不會到此\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，提取所有整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        raise ValueError(\"輸入不足兩個整數（n 與 pick）。\")\n    n, pick = nums[0], nums[1]\n\n    sol = Solution()\n    result = sol.guessNumber(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the 4Sum problem. Provide step-by-step algorithm: sort, nested loops, two pointers, skip duplicates. Provide explanations. Must use Start, End, Decision, arrows. Each line must have \"虛擬碼步驟 [space] // 解釋/說明\". Use Chinese explanation.\n\nLet's craft:\n\nStart\n→ Sort nums ascending // 排序方便後續雙指針與去重\n→ Step 1: 取 i from 0 to n-4 // 第1個指標\n    Decision: i > 0 AND nums[i] == nums[i-1]? // 跳過重複\n        Yes → Skip i // 略過相同的首元素\n        No  → Step 2: 取 j from i+1 to n-3 // 第2個指標\n            Decision: j > i+1 AND nums[j] == nums[j-1]? // 跳過重複\n                Yes → Skip j\n                No  → Step 3: left = j+1, right = n-1 // 兩指針\n                    Decision: left < right? // 有可能組合\n                        Yes → Step 4: sum = nums[i]+nums[j]+nums[left]+nums[right] // 計算和\n                            Decision: sum == target? // 是否符合\n                                Yes → Add quadruplet to result // 收集答案\n                                → left++ // 移動左指標\n                                → right-- // 移動右指標\n                                → Skip duplicates for left: while left < right AND nums[left]==nums[left-1] left++\n                                → Skip duplicates for right: while left < right AND nums[right]==nums[right+1] right--\n                                → Continue loop\n                                No  → Decision: sum < target? // 需要更大\n                                    Yes → left++ // 移動左指標\n                                    No  → right-- // 移動右指標\n                        No → End of while loop\n            End Decision j duplicate\n        End Decision i duplicate\nEnd Decision i loop\nEnd // 程式結束\n\nNeed to ensure each line exactly one step, and nested indentation is shown via indentation (spaces) but not necessary. Use arrow format. Let's produce each line exactly one. Use Start and End. Provide \"Decision:\" lines with Yes and No arrows. For loops maybe Step lines.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 排序以便後續兩指針處理與去重\n→ Step 2: For i = 0 to n-4 // 選取第一個數\n    Decision: i > 0 AND nums[i] == nums[i-1]? // 檢查重複\n        Yes → Skip i // 跳過相同的首元素\n        No  → Step 3: For j = i+1 to n-3 // 選取第二個數\n            Decision: j > i+1 AND nums[j] == nums[j-1]? // 檢查重複\n                Yes → Skip j // 跳過相同的第二元素\n                No  → Step 4: left = j+1, right = n-1 // 設定兩指針\n                    Decision: left < right? // 是否還能形成四元組\n                        Yes → Step 5: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算目前四元組和\n                            Decision: sum == target? // 是否符合目標\n                                Yes → Add [nums[i], nums[j], nums[left], nums[right]] to result // 收集結果\n                                → left++ // 移動左指針向右\n                                → right-- // 移動右指針向左\n                                → Decision: left < right AND nums[left] == nums[left-1]? // 跳過左重複\n                                    Yes → left++ // 跳過重複\n                                    No  → // 繼續\n                                → Decision: left < right AND nums[right] == nums[right+1]? // 跳過右重複\n                                    Yes → right-- // 跳過重複\n                                    No  → // 繼續\n                                → Continue while loop\n                                No  → Decision: sum < target? // 和太小\n                                    Yes → left++ // 向右移動左指針\n                                    No  → right-- // 向左移動右指針\n                        No → // 左右指針移動結束\n                    No → // 左右指針已無法再縮小\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟 [space] // 解釋\". We already included arrow \"→\" for steps. For decisions, we need \"Decision:\" lines and Yes/No lines with arrows.\n\nLet's reformat:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 排序以便後續兩指針處理與去重\n→ Step 2: For i = 0 to n-4 // 選取第一個數\n    Decision: i > 0 AND nums[i] == nums[i-1]? // 檢查重複\n        Yes → Skip i // 跳過相同的首元素\n        No  → Step 3: For j = i+1 to n-3 // 選取第二個數\n            Decision: j > i+1 AND nums[j] == nums[j-1]? // 檢查重複\n                Yes → Skip j // 跳過相同的第二元素\n                No  → Step 4: left = j+1, right = n-1 // 設定兩指針\n                    Decision: left < right? // 是否還能形成四元組\n                        Yes → Step 5: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算目前四元組和\n                            Decision: sum == target? // 是否符合目標\n                                Yes → Add [nums[i], nums[j], nums[left], nums[right]] to result // 收集結果\n                                → left++ // 移動左指針向右\n                                → right-- // 移動右指針向左\n                                → Decision: left < right AND nums[left] == nums[left-1]? // 跳過左重複\n                                    Yes → left++ // 跳過重複\n                                    No  → // 繼續\n                                → Decision: left < right AND nums[right] == nums[right+1]? // 跳過右重複\n                                    Yes → right-- // 跳過重複\n                                    No  → // 繼續\n                                → // 重新進入 while\n                                → // 繼續循環\n                                No  → Decision: sum < target? // 和太小\n                                    Yes → left++ // 向右移動左指針\n                                    No  → right-- // 向左移動右指針\n                        No → // 左右指針移動結束\n                    No → // 左右指針已無法再縮小\nEnd // 程式結束\n\nWe might need to indent properly. Provide each line with indentation as shown. That should satisfy.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 排序以便後續兩指針處理與去重  \n→ Step 2: For i = 0 to n-4 // 選取第一個數  \n Decision: i > 0 AND nums[i] == nums[i-1]? // 檢查重複  \n  Yes → Skip i // 跳過相同的首元素  \n  No  → Step 3: For j = i+1 to n-3 // 選取第二個數  \n   Decision: j > i+1 AND nums[j] == nums[j-1]? // 檢查重複  \n    Yes → Skip j // 跳過相同的第二元素  \n    No  → Step 4: left = j+1, right = n-1 // 設定兩指針  \n     Decision: left < right? // 是否還能形成四元組  \n      Yes → Step 5: sum = nums[i] + nums[j] + nums[left] + nums[right] // 計算目前四元組和  \n       Decision: sum == target? // 是否符合目標  \n        Yes → Add [nums[i], nums[j], nums[left], nums[right]] to result // 收集結果  \n         → left++ // 移動左指針向右  \n         → right-- // 移動右指針向左  \n         → Decision: left < right AND nums[left] == nums[left-1]? // 跳過左重複  \n          Yes → left++ // 跳過重複  \n          No  → // 繼續  \n         → Decision: left < right AND nums[right] == nums[right+1]? // 跳過右重複  \n          Yes → right-- // 跳過重複  \n          No  → // 繼續  \n         → // 重新進入 while  \n         → // 繼續循環  \n        No  → Decision: sum < target? // 和太小  \n         Yes → left++ // 向右移動左指針  \n         No  → right-- // 向左移動右指針  \n      No → // 左右指針移動結束  \n     No → // 左右指針已無法再縮小  \nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return [], 0\n    # Expect format like: nums = [...], target = ...\n    parts = data.split('target =', 1)\n    nums_part = parts[0].split('=', 1)[1].strip()\n    target_part = parts[1].strip() if len(parts) > 1 else '0'\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.fourSum(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpxj6h8d_6.py\", line 50, in <module>\n    result = solution.fourSum(nums, target)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxj6h8d_6.py\", line 7, in fourSum\n    nums.sort()\n    ^^^^^^^^^\nAttributeError: 'tuple' object has no attribute 'sort'"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp6vk1y2kh.py\", line 50, in <module>\n    result = solution.fourSum(nums, target)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6vk1y2kh.py\", line 7, in fourSum\n    nums.sort()\n    ^^^^^^^^^\nAttributeError: 'tuple' object has no attribute 'sort'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for Fibonacci sequence calculation with input n, compute F(n). They want step-by-step virtual code, each line with arrow and explanation. No actual code. Let's produce a virtual algorithm: Use iterative approach. Steps: Start, Input n, Decision n==0, output 0, Decision n==1, output 1, else initialize a=0,b=1, counter=2, loop while counter<=n, next=b+a, a=b, b=next, counter++, after loop output b. End.\n\nMake sure to follow formatting. Use \"→\" arrows. Use \"Decision:\" etc. Each line includes a comment after //. The format requires each line: 虛擬碼步驟 + space + // explanation. Let's produce.\n\nCheck formatting: The sample shows: Start // 程式開始執行. Then \"→ Step 1: ...\" etc. So we need to indent decisions and arrows appropriately. Use indentation spaces to show sub-steps.\n\nWe'll produce as plain text. Use Traditional Chinese for explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 從使用者處取得要計算的 Fibonacci 索引  \n→ Decision: 若 n = 0? // 檢查是否為最小值  \n  Yes → Step 2: 輸出 0 // Fibonacci(0) 為 0  \n  No  → Decision: 若 n = 1? // 檢查是否為第二個最小值  \n    Yes → Step 3: 輸出 1 // Fibonacci(1) 為 1  \n    No  → Step 4: 初始化 a ← 0, b ← 1, counter ← 2 // a 為 F(0)，b 為 F(1)  \n    → Loop: 當 counter ≤ n? // 逐步計算直到達到 n  \n     Yes → Step 5: next ← a + b // 計算下一個 Fibonacci 數  \n      a ← b // 移動到前一個位置  \n      b ← next // 更新為新的 Fibonacci 數  \n      counter ← counter + 1 // 進行迭代  \n     No  → Step 6: 輸出 b // b 現為 F(n)  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fib(n: int) -> int:\n    \"\"\"計算第 n 個 Fibonacci 數字（F(0)=0，F(1)=1）。\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取 n，計算並輸出 F(n)。\"\"\"\n    data = sys.stdin.read()\n    # 找出第一個出現的整數（可以處理像 \"n = 2\" 或直接 \"2\" 的輸入）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return  # 沒有有效輸入時直接結束\n    n = int(match.group())\n    print(fib(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for finding all unique triplets that sum to zero. Use sorting, two pointers, skip duplicates. Steps: sort array, iterate i, skip duplicates, set left and right, while left<right, compute sum, adjust, skip duplicates. Output. Each line with comment. We'll output the virtual code line by line. No actual code. Use \"Start\" etc. Let's produce.\n\nRemember format: \"虛擬碼步驟 [space] // 解釋\" Each line must have arrow maybe? Use → for step progression. Decision uses Decision:.\n\nWe'll structure as:\n\nStart\n→ Step 1: Sort nums ascending\n→ Step 2: Initialize result list\n→ Step 3: For i from 0 to len(nums)-3\n    Decision: If i>0 and nums[i]==nums[i-1]? // skip duplicates\n        No → Step 4: left=i+1, right=len(nums)-1\n        → Decision: while left<right?\n            Yes → Step 5: sum=nums[i]+nums[left]+nums[right]\n            → Decision: sum==0?\n                Yes → Step 6: Append triplet to result\n                    → Step 7: Move left while left<right and nums[left]==nums[left+1] (skip duplicates)\n                    → Step 8: Move right while left<right and nums[right]==nums[right-1] (skip duplicates)\n                    → Step 9: left++, right--\n                No → Decision: sum<0?\n                    Yes → Step 10: left++\n                    No → Step 11: right--\n    (loop ends)\nEnd\n\nWe need to maintain correct indentation but just lines. Use arrow for steps inside decisions maybe.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續跳過重複並使用雙指標  \n→ Step 2: Initialize result list // 用來存儲所有符合條件的三元組  \n→ Step 3: For i from 0 to len(nums)-3 // 遍歷所有可能作為第一個數的索引  \n    Decision: i>0 and nums[i]==nums[i-1]? // 若此值與前一個相同，跳過以避免重複  \n        Yes → Continue // 直接進入下一個 i  \n        No  →  \n            → Step 4: left = i + 1, right = len(nums) - 1 // 設定左、右指標  \n            → Decision: left < right? // 確保指標不重疊  \n                Yes →  \n                    → Step 5: sum = nums[i] + nums[left] + nums[right] // 計算三數之和  \n                    → Decision: sum == 0? // 是否恰好為零  \n                        Yes →  \n                            → Step 6: Append [nums[i], nums[left], nums[right]] to result // 加入合法三元組  \n                            → Step 7: While left < right and nums[left] == nums[left + 1] // 跳過左側重複  \n                                left++  \n                            → Step 8: While left < right and nums[right] == nums[right - 1] // 跳過右側重複  \n                                right--  \n                            → Step 9: left++, right-- // 移動兩指標繼續搜尋  \n                        No → Decision: sum < 0? // 需要更大的和  \n                            Yes → Step 10: left++ // 左指標右移  \n                            No  → Step 11: right-- // 右指標左移  \n                No → // left >= right 時結束此 i 的搜尋  \n→ End // 程式執行結束，result 為所有不重複且相加為 0 的三元組集合",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def threeSum(self, nums):\n        nums.sort()\n        res = []\n        n = len(nums)\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:\n                    res.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 尋找形如 nums = [...] 的字串\n    match = re.search(r'nums\\s*=\\s*(\\[.*\\])', data, re.S)\n    if not match:\n        # 若沒有找到，則直接輸出空列表\n        print([])\n        return\n    nums_str = match.group(1)\n    try:\n        nums = eval(nums_str, {}, {})\n    except Exception:\n        print([])\n        return\n    result = Solution().threeSum(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step for solving: given array of binary strings and m, n, find largest subset size with at most m zeros and n ones. Classic 0-1 knap DP 2D. So steps: start, count zeros and ones for each string, DP array of size (m+1)x(n+1) initialized 0. For each string, iterate i from m down to zeros, j from n down to ones, dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1). Finally result dp[m][n]. Need to output virtual code line by line with comments. Use arrows etc. Use structure Start, Decision etc. Provide each line: \"→ Step X: ...\" with comment. Must include arrow for loops and decisions. Also include decisions for boundary checks. Let's craft.\n\nWe'll produce lines:\n\nStart // begin\n→ Step 1: Initialize DP array dp[0..m][0..n] = 0 // create DP table\n→ Step 2: For each string s in strs // iterate over strings\n    → Step 3: Count zeros z and ones o in s // compute counts\n    → Decision: If z > m or o > n? // skip strings exceeding limits\n        Yes → Continue to next string // skip\n        No  → Step 4: For i from m down to z // iterate weights backwards\n            → Step 5: For j from n down to o // iterate ones backwards\n                → Step 6: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // update DP\n→ Step 7: Result = dp[m][n] // maximum subset size\nEnd // finish\n\nNeed to use arrow \"→\" etc. Also use Decision: \"Decision: If ...\". Provide indentation maybe.\n\nAlso maybe include a \"Decision: 是否超出限制?\".\n\nLet's produce accordingly. Use each line with comment. Use indentation to show nested structure.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 2D DP 陣列 dp[0..m][0..n] = 0 // 建立動態規劃表，預設所有格為 0\n→ Step 2: 對 strs 中每一個字串 s 進行迭代 // 逐一考慮每個可能加入子集的字串\n    → Step 3: 計算 s 中 0 的個數 z 與 1 的個數 o // 需要知道此字串對 0 與 1 的貢獻\n    → Decision: z > m 或 o > n? // 如果字串的 0/1 數量已超過總限制，無法加入任何子集\n        Yes → 直接跳過此字串 // 無法加入，轉到下一個字串\n        No  → Step 4: 從 i = m 逐步遞減到 z // 以遞減方式更新 DP，避免重複計算\n            → Step 5: 從 j = n 逐步遞減到 o // 同樣針對 1 的限制遞減\n                → Step 6: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // 若加入此字串能得到更大的子集，更新\n→ Step 7: 結果 = dp[m][n] // dp 表中 m,n 位置即為最大的子集大小\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef findMaxForm(strs, m, n):\n    \"\"\"動態規劃求最多可放入的字串數量\n    dp[i][j] 表示在 0 的數量不超過 i、1 的數量不超過 j 時，能得到的最大字串數\n    \"\"\"\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for s in strs:\n        zeros = s.count('0')\n        ones = s.count('1')\n        # 如果一個字串本身已超過限制，直接跳過\n        if zeros > m or ones > n:\n            continue\n        # 逆向遍歷，避免同一個字串被重複計算\n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    return dp[m][n]\n\ndef parse_input(text):\n    \"\"\"將輸入文字轉成 (strs, m, n) 三元組\n    支援類似 \"strs = [...], m = 5, n = 3\" 的格式\n    \"\"\"\n    strs_match = re.search(r'strs\\s*=\\s*(\\[[^\\]]*\\])', text)\n    m_match = re.search(r'm\\s*=\\s*(\\d+)', text)\n    n_match = re.search(r'n\\s*=\\s*(\\d+)', text)\n    if not (strs_match and m_match and n_match):\n        raise ValueError(\"Invalid input format\")\n    strs = ast.literal_eval(strs_match.group(1))\n    m = int(m_match.group(1))\n    n = int(n_match.group(1))\n    return strs, m, n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    try:\n        strs, m, n = parse_input(raw_input)\n    except ValueError:\n        print(\"0\")\n        sys.exit()\n    result = findMaxForm(strs, m, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating an arithmetic expression string with +,-,*,/ and spaces, integer division truncate toward zero. No eval. We'll need a stack or two stacks: operand stack and operator stack. Use precedence. We'll parse char by char.\n\nSteps: Start, initialize stack, index i=0, n=len(s). While i<n: if s[i] is space skip. If digit: parse number accumulate. Then push number to stack? We can use operand stack. After parsing number, we need to apply any pending high precedence operators? Approach: We can use a single stack for numbers, and a variable lastOperator. Actually simpler: We can handle *,/ immediately: keep a lastNumber variable, lastOperator initially '+'. When we see a number, we combine with lastOperator: if '+', push number; if '-', push -number; if '*', pop stack top and multiply with number push; if '/', pop stack top divide by number truncate. At end sum stack.\n\nSo pseudo:\n\nStart\n→ Init stack [], lastOperator='+', i=0\n→ While i < len(s)\n    → If s[i] == ' ' → i++ // skip\n    → Decision: Is digit? // parse number\n        Yes → Step: parse num = 0 while i<n and digit: num = num*10 + int(s[i]); i++\n        No → Decision: is s[i] in '+-*/'? // operator\n            Yes → Step: lastOperator = s[i]; i++\n            No → i++ // maybe end\n\n    After parsing number, Step: Apply lastOperator to num and stack\n        Decision: if lastOperator == '+'\n            Yes → push num to stack\n            No → Decision: lastOperator == '-'\n                Yes → push -num\n                No → Decision: '*'\n                    Yes → temp = pop stack; push temp * num\n                    No → Division\n                        Yes → temp = pop stack; push truncate(temp/num)\n                        No → // nothing\nContinue loop.\n\nAfter loop: sum stack -> result.\n\nEnd.\n\nWe need to output line by line with explanation.\n\nMake sure to handle integer division truncation toward zero. In Python floor division // truncates toward negative infinity, so use int(temp/num) or // but adjust? For positive temp, // is fine. For negative, need int(temp/num) or use trunc. We'll note truncation.\n\nLet's produce steps accordingly.\n\nWe need to include arrow lines: Start, → Step 1, etc. Use indentation? Provided example uses indentation for decisions. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 stack = [] 與 lastOperator = '+' // 準備儲存中間結果  \n→ Step 2: 設定 i = 0, n = len(s) // 定位到字串起始  \n\n→ While i < n  \n    → Decision: s[i] 為空格? // 跳過空白字符  \n        Yes → i = i + 1  \n        No → Decision: s[i] 為數字? // 需要解析完整數字  \n            Yes → Step 3: parse num = 0  \n                → While i < n 且 s[i] 為數字  \n                    → num = num * 10 + int(s[i]) // 逐位構造整數  \n                    → i = i + 1  \n                → Step 4: 解析完成，根據 lastOperator 將 num 與 stack 互動  \n                    Decision: lastOperator == '+'  \n                        Yes → stack.append(num) // 正號直接加入堆疊  \n                        No → Decision: lastOperator == '-'  \n                            Yes → stack.append(-num) // 負號加入堆疊  \n                            No → Decision: lastOperator == '*'  \n                                Yes → temp = stack.pop() → stack.append(temp * num) // 乘法先執行  \n                                No → // 必然為除法  \n                                    temp = stack.pop()  \n                                    stack.append(int(temp / num)) // 整數除法向零截斷  \n            No → Decision: s[i] 為運算符 '+', '-', '*', '/'?  \n                Yes → lastOperator = s[i] → i = i + 1 // 更新運算符並移動指標  \n                No → i = i + 1 // 其它字符（理論上不會出現）  \n\n→ Step 5: result = sum(stack) // 將堆疊中所有項相加得到最終答案  \n→ Step 6: 輸出 result // 將計算結果返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        \"\"\"\n        Evaluate the arithmetic expression contained in s.\n        Supports +, -, *, / operators and integer division truncated toward zero.\n        Spaces are ignored.\n        \"\"\"\n        stack = []\n        num = 0\n        sign = '+'\n        # Append a dummy operator to process the last number\n        s += '+'\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-*/':\n                # Perform the pending operation with the previous sign\n                if sign == '+':\n                    stack.append(num)\n                elif sign == '-':\n                    stack.append(-num)\n                elif sign == '*':\n                    stack.append(stack.pop() * num)\n                elif sign == '/':\n                    top = stack.pop()\n                    # Truncate toward zero\n                    if top < 0:\n                        stack.append(-(-top // num))\n                    else:\n                        stack.append(top // num)\n                # Update sign and reset num\n                sign = c\n                num = 0\n            else:\n                # Skip any other character (e.g., spaces)\n                continue\n        return sum(stack)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Try to extract the string inside quotes, e.g., s = \"3+2*2\"\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # If no quotes, assume the whole input is the expression\n        s = data.replace('s', '').replace('=', '').strip()\n    solution = Solution()\n    result = solution.calculate(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode673.json",
    "problem_index_in_file": 0,
    "title": "Number of Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step using Start, End, Decision, and arrows. Provide explanation after each line. Should be not actual code, just steps. We need to implement algorithm: given integer array nums, find number of longest increasing subsequences. Classic DP: for each index, maintain length[i] and count[i]. Then compute maxLen and total counts. Let's outline steps:\n\nStart\n→ Step 1: 初始化 n = length of nums // get array length\n→ Step 2: If n == 0, return 0 // empty array edge\n→ Step 3: 建立兩個長度為 n 的陣列 length[0..n-1] 與 count[0..n-1]，初值皆為 1 // every element is subsequence of length 1\n→ Step 4: For i from 0 to n-1:\n        → Step 4.1: For j from 0 to i-1:\n            → Decision: if nums[j] < nums[i]? // check increasing\n                Yes → Decision: if length[j] + 1 > length[i]? // longer subsequence found\n                    Yes → Step 4.1.1: length[i] = length[j] + 1 // update length\n                            count[i] = count[j] // new count from j\n                    No → Decision: if length[j] + 1 == length[i]? // same length\n                        Yes → Step 4.1.2: count[i] += count[j] // add counts\n                        No → skip\n                No → skip\n→ Step 5: 找出最大長度 maxLen = max(length[0..n-1]) // longest subsequence length\n→ Step 6: total = 0\n→ Step 7: For i from 0 to n-1:\n        → Decision: if length[i] == maxLen? // contribute to answer\n            Yes → Step 7.1: total += count[i] // accumulate\n→ End // 回傳 total\n\nBut we need pseudocode lines with \"→\" and \"Decision:\".\n\nEnsure each line ends with // explanation. Provide step names.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length of nums // 取得陣列長度  \n→ Step 2: Decision: 若 n = 0? // 判斷陣列是否為空  \n    Yes → Step 3: 回傳 0 // 空陣列沒有子序列  \n    No  →  // 繼續執行  \n→ Step 4: 建立 length[0..n-1] ← 1, count[0..n-1] ← 1 // 初始每個元素為長度 1 的子序列，計數為 1  \n→ Step 5: For i from 0 to n-1: // 逐個元素做 DP  \n    → Step 5.1: For j from 0 to i-1: // 與前面元素比較  \n        → Decision: 若 nums[j] < nums[i]? // 必須嚴格遞增  \n            Yes → Decision: 若 length[j] + 1 > length[i]? // 找到更長子序列  \n                Yes → Step 5.1.1: length[i] ← length[j] + 1 // 更新長度  \n                         count[i] ← count[j] // 取 j 的計數  \n                No → Decision: 若 length[j] + 1 = length[i]? // 同長度可累加計數  \n                    Yes → Step 5.1.2: count[i] ← count[i] + count[j] // 累加  \n                    No  →  // 無須更改  \n            No →  // nums[j] 不小於 nums[i]，跳過  \n→ Step 6: maxLen ← maximum value in length[0..n-1] // 找到最長子序列長度  \n→ Step 7: total ← 0 // 初始化答案  \n→ Step 8: For i from 0 to n-1: // 累計所有等於最大長度的子序列數量  \n    → Decision: 若 length[i] = maxLen?  \n        Yes → Step 8.1: total ← total + count[i] // 加總計數  \n→ End // 程式執行結束，total 為答案。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findNumberOfLIS(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        lengths = [1] * n          # lengths[i] = length of LIS ending at i\n        counts  = [1] * n          # counts[i]  = number of LIS ending at i\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    if lengths[j] + 1 > lengths[i]:\n                        lengths[i] = lengths[j] + 1\n                        counts[i] = counts[j]\n                    elif lengths[j] + 1 == lengths[i]:\n                        counts[i] += counts[j]\n\n        longest = max(lengths)\n        return sum(c for l, c in zip(lengths, counts) if l == longest)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，支援如下兩種格式：\n    1. nums = [1,3,5,4,7]\n    2. [1,3,5,4,7]\n    \"\"\"\n    data = data.strip()\n    # 若包含 '='，取等號右側\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    # 只保留方括號內部內容，再包裝成列表字串\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        raise ValueError(\"無法找到有效的列表\")\n    list_str = match.group()\n    # 直接使用 eval（假設輸入安全）\n    return eval(list_str)\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    solution = Solution()\n    result = solution.findNumberOfLIS(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,4,7]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode686.json",
    "problem_index_in_file": 0,
    "title": "Repeated String Match",
    "description_snippet": "Given two strings a and b, return the minimum number of times you should repeat string a so that str...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step. We must produce lines like:\n\nStart // 程式開始執行\n→ Step 1: ...\nWe must consider the algorithm: given a and b, find minimal repeats of a such that b is substring. Approach: compute min repeats needed: repeatCount = ceil(len(b)/len(a)). Then check if b is substring of a repeated repeatCount times. If not, check with repeatCount+1. If still not, return -1. So algorithm:\n\n1. compute lenA, lenB.\n2. minRepeats = (lenB + lenA - 1) / lenA (ceil).\n3. Build repeated string: repeated = a repeated minRepeats times.\n4. If b in repeated → return minRepeats.\n5. Else if b in repeated + a → return minRepeats + 1.\n6. Else return -1.\n\nEdge cases: b empty? Then zero repeats? But typical solutions return 0 or 1? Usually return 0. But not needed.\n\nWe'll produce virtual code lines accordingly.\n\nMake sure to use arrow lines properly.\n\nLet's produce:\n\nStart\n→ Step 1: 計算 a 長度 lenA, b 長度 lenB // 取得兩個字串長度\n→ Step 2: 計算最小重複次數 minRepeat = (lenB + lenA - 1) / lenA // 向上取整\n→ Step 3: 建立重複字串 repeatStr = a 重複 minRepeat 次 // 產生候選字串\n→ Decision: 如果 b 為 repeatStr 的子字串? // 檢查是否滿足\n    Yes → Step 4: 回傳 minRepeat // 最小重複次數\n    No  → Step 5: 建立 extendedStr = repeatStr + a // 加一次 a 以處理重疊情況\n    No → Decision: 如果 b 為 extendedStr 的子字串? // 再次檢查\n        Yes → Step 6: 回傳 minRepeat + 1 // 需要多一次\n        No  → Step 7: 回傳 -1 // 仍不可能\nEnd\n\nBut we must also consider the possibility of b empty: we might handle that. But not required.\n\nAlso note we might need to handle string empty: if b empty, return 0. But we can skip.\n\nLet's produce with arrow indentation.\n\nWe need to use \"Yes →\" and \"No →\" after decision lines. Use nested indent.\n\nAlso \"→ Decision: ... ?\" line with question.\n\nLet's craft the final output exactly as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 a 的長度 lenA 與 b 的長度 lenB // 取得兩個字串的長度  \n→ Step 2: 計算最小重複次數 minRepeat = (lenB + lenA - 1) / lenA // 向上取整以保證重複後長度至少等於 b  \n→ Step 3: 建立重複字串 repeatStr = a 重複 minRepeat 次 // 產生候選的重複字串  \n→ Decision: b 是否為 repeatStr 的子字串? // 檢查是否已滿足條件  \n    Yes → Step 4: 回傳 minRepeat // 找到最小重複次數  \n    No  → Step 5: 建立 extendedStr = repeatStr + a // 加一次 a 以處理跨界的子字串  \n    No → Decision: b 是否為 extendedStr 的子字串? // 再次檢查  \n        Yes → Step 6: 回傳 minRepeat + 1 // 需要多一次重複  \n        No  → Step 7: 回傳 -1 // 無法成為子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef repeatedStringMatch(a: str, b: str) -> int:\n    \"\"\"\n    Return the minimum number of times string `a` must be repeated\n    so that string `b` becomes a substring.  If impossible, return -1.\n    \"\"\"\n    # Minimum repeats needed to cover the length of b\n    repeat = (len(b) + len(a) - 1) // len(a)\n    s = a * repeat\n    if b in s:\n        return repeat\n    s += a  # one more repeat to cover overlap cases\n    if b in s:\n        return repeat + 1\n    return -1\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse two quoted strings a and b,\n    compute the result, and print it.\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract all quoted substrings; first is a, second is b\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        a, b = quoted[0], quoted[1]\n    else:\n        # Fallback: split by whitespace if no quotes are found\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            a, b = parts[0], parts[1]\n        else:\n            # Insufficient input; nothing to output\n            return\n    result = repeatedStringMatch(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm to find maximum product subarray. Use typical DP with tracking max and min product. We'll produce step-by-step. Each line with virtual code step and explanation. Use Start, Decision. Probably include loops. Let's craft.\n\nStart\n→ Step 1: Initialize maxProd, minProd, result with first element // set initial values\n→ For each element nums[i] from index 1 to end:\n    → Decision: If nums[i] is negative? // need to swap max/min when negative\n        Yes → Swap maxProd, minProd // swap because negative flips sign\n        No  → No action\n    → Update maxProd = max(nums[i], maxProd * nums[i]) // current max product ending here\n    → Update minProd = min(nums[i], minProd * nums[i]) // current min product ending here\n    → Update result = max(result, maxProd) // track global maximum\nEnd // return result\n\nBut need line by line. We'll output each step as separate line. Use arrows appropriately.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: Set maxProd = nums[0], minProd = nums[0], result = nums[0] // 初始化\n→ For i from 1 to length(nums)-1: // 迭代每個數\n    → Decision: nums[i] < 0? // 判斷是否為負數\n        Yes → Swap(maxProd, minProd) // 負數時最大最小交換\n        No  → // 無操作\n    → maxProd = max(nums[i], maxProd * nums[i]) // 更新以當前為結尾的最大積\n    → minProd = min(nums[i], minProd * nums[i]) // 更新以當前為結尾的最小積\n    → result = max(result, maxProd) // 更新全局最大積\nEnd // 回傳結果\n\nBut we need \"虛擬碼步驟\" e.g., \"Step 2: ...\" Provide arrow with '→'. Use \"Decision:\" lines with indentation. Provide explanation comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set maxProd = nums[0], minProd = nums[0], result = nums[0] // 初始化最大、最小積與答案為第一個元素  \n→ For i from 1 to length(nums)-1: // 逐一處理後續元素  \n    → Decision: nums[i] < 0? // 判斷當前數是否為負數  \n        Yes → Swap(maxProd, minProd) // 負數會把最大積變成最小，反之亦然，先交換  \n        No  → // 正數不需要交換  \n    → maxProd = max(nums[i], maxProd * nums[i]) // 以 nums[i] 為結尾的子陣列中最大積  \n    → minProd = min(nums[i], minProd * nums[i]) // 以 nums[i] 為結尾的子陣列中最小積  \n    → result = max(result, maxProd) // 取全局最大積  \nEnd // 回傳答案（result）",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProduct(self, nums):\n        if not nums:\n            return 0\n        max_prod = min_prod = result = nums[0]\n        for num in nums[1:]:\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n            result = max(result, max_prod)\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    解析類似 'nums = [2,3,-2,4]' 的輸入字串，返回列表。\n    \"\"\"\n    # 去掉前後空白\n    data = data.strip()\n    # 找到等號後面的方括號內容\n    match = re.search(r'\\[(.*)\\]', data)\n    if not match:\n        return []\n    # 用 eval 解析列表，因為輸入格式已知且安全\n    return eval('[' + match.group(1) + ']')\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.maxProduct(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines. The task is to count number of expressions with + or - before each integer that sum to target. This is typical target sum problem. Need to produce virtual code steps, not actual code. We'll produce algorithm steps: Start, decide to use DFS or DP. We'll produce pseudo steps.\n\nWe need each line with \"虛擬碼步驟\" and comment after //.\n\nWe need to use arrows, Decision: etc.\n\nLet's write steps:\n\nStart\n→ Step 1: Define function countExpressions(nums, target) // entry function\n→ Step 2: Determine n = length(nums) // number of elements\n→ Decision: If n == 0? // check empty\n    Yes → Step 3: Return 0 if target != 0 else 1 // no numbers\n    No → Step 4: Initialize memo map // for DP\n\nWe can use DFS with memoization on index and current sum.\n\n→ Step 5: Define recursive helper(index, currentSum) // process numbers\n→ Decision: If index == n? // all numbers processed\n    Yes → Decision: If currentSum == target? // sum matches\n                Yes → Step 6: Return 1 // valid expression\n                No  → Step 7: Return 0 // not valid\n    No  → Step 8: left = helper(index+1, currentSum + nums[index]) // add positive\n    → Step 9: right = helper(index+1, currentSum - nums[index]) // add negative\n    → Step 10: Return left + right // total ways\n\nMemoization: use key (index, currentSum) to cache result.\n\nReturn helper(0, 0) // start from first index with sum 0.\n\nEnd\n\nAdd explanation comments each line.\n\nLet's write in lines accordingly.\n\nWe also might add decision for memo existence.\n\nAt Step 5: we can add Decision: If memo contains (index,currentSum) -> return memo value. That's inside helper.\n\nLet's incorporate:\n\n→ Step 5: Define helper(index, currentSum)\n    → Decision: If memo contains (index,currentSum)? // check cache\n        Yes → Step 6: Return memo[(index,currentSum)] // cached result\n        No  → Proceed to process\n\nBut we need to keep numbering consistent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define function countExpressions(nums, target) // 進入點，接收數字陣列與目標值\n→ Step 2: Set n = length(nums) // 取得陣列長度\n→ Decision: If n == 0? // 檢查是否有數字可處理\n    Yes → Step 3: Return (target == 0) ? 1 : 0 // 無數字時只有 target 為 0 才能算一種表達式\n    No  → Step 4: Initialize memo as empty map // 建立快取以避免重複計算\n→ Step 5: Define recursive helper(index, currentSum) // 以索引與目前累積和為參數遞迴\n    → Decision: If memo contains (index, currentSum)? // 檢查是否已計算過\n        Yes → Step 6: Return memo[(index, currentSum)] // 直接回傳快取結果\n        No  → Proceed to next steps\n    → Decision: If index == n? // 所有數字已處理完\n        Yes → Decision: If currentSum == target? // 檢查累積和是否符合目標\n                Yes → Step 7: Return 1 // 成功的一種表達式\n                No  → Step 8: Return 0 // 失敗，無合法表達式\n        No  → Step 9: left = helper(index + 1, currentSum + nums[index]) // 加上正號\n        → Step 10: right = helper(index + 1, currentSum - nums[index]) // 加上負號\n        → Step 11: result = left + right // 合併兩種可能\n        → Step 12: memo[(index, currentSum)] = result // 存入快取\n        → Step 13: Return result // 回傳本層結果\n→ Step 14: Return helper(0, 0) // 從第一個數字開始，初始和為 0\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        \"\"\"\n        Count the number of ways to assign + or - to each element in nums\n        so that the resulting expression evaluates to target.\n        \"\"\"\n        dp = defaultdict(int)\n        dp[0] = 1  # one way to reach sum 0 with no numbers\n\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s, cnt in dp.items():\n                next_dp[s + num] += cnt  # add positive sign\n                next_dp[s - num] += cnt  # add negative sign\n            dp = next_dp\n\n        return dp[target]\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list of numbers and the target value using regex\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not target_match:\n        print(\"0\")\n        return\n\n    # Safely evaluate the list of numbers\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n\n    # Compute and output the result\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line for counting boomerangs. Should be conceptual algorithm. Use virtual code with Start, Decision, etc. We need to output each step with explanation. Probably steps: Start, compute answer=0, iterate over each point i, create map distances, iterate over other points j to compute distance squared, increment count of distance in map, then for each distance value d, add cnt*(cnt-1) to answer (since order matters). End.\n\nWe need to use arrow notation. Each line: Virtual code step + \" // explanation\".\n\nBe careful to keep each line in one line. Use arrow \"→\". The decision steps may not be necessary but we can include if needed.\n\nLet's produce.\n\nAlso we need to use n points variable. Provide loops.\n\nWe'll produce pseudo code:\n\nStart // 開始\n→ Initialize answer = 0 // 存儲最終結果\n→ For each i in 0..n-1 // 遍歷每個作為中心點\n    → Create empty map distanceCount // 記錄以 i 為中心時各距離出現次數\n    → For each j in 0..n-1, j != i // 遍歷所有其他點\n        → Compute dist = (x_i - x_j)^2 + (y_i - y_j)^2 // 距離平方\n        → Increment distanceCount[dist] by 1 // 更新距離出現次數\n    → For each count in distanceCount.values() // 對每個距離\n        → If count > 1\n            → Add count*(count-1) to answer // 計算有序排列數量\n→ End // 結束\n\nWe must format each line as \"虛擬碼步驟 // 解釋\". Use arrow and indent appropriately.\n\nAlso we need to show decisions: \"If count > 1\". Use Decision: Yes → Step, No → Next.\n\nLet's produce lines.\n\nWe need Start and End lines.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ 初始化 answer = 0 // 用於累計所有 boomerangs\n→ Decision: 是否還有未處理的中心點 i? // 判斷是否有更多點作為中心\n    Yes → Step: 取下一個 i // 選取下一個作為中心點\n    No  → End // 所有中心點已處理，結束\n\nWithin i loop we need create map, etc. But we can embed within the Yes block.\n\nLet's design:\n\nStart\n→ 設定 answer = 0\n→ For each i in 0..n-1\n    → 建立空 map distanceCount\n    → For each j in 0..n-1, j ≠ i\n        → 計算 dist = (x_i - x_j)^2 + (y_i - y_j)^2\n        → distanceCount[dist] = distanceCount.get(dist,0)+1\n    → For each cnt in distanceCount.values()\n        → Decision: cnt > 1 ?\n            Yes → answer += cnt * (cnt - 1)\n            No  →  // 無需操作\n\nEnd\n\nBut we need to use arrow syntax and \"Decision:\" lines. So maybe:\n\nStart\n→ 初始化 answer = 0\n→ For i from 0 to n-1\n    → 初始化空距離計數表 distanceCount\n    → For j from 0 to n-1, j ≠ i\n        → 計算距離平方 dist\n        → distanceCount[dist] = distanceCount.get(dist,0)+1\n    → For 每個 cnt in distanceCount.values()\n        → Decision: cnt > 1? \n            Yes → answer += cnt*(cnt-1)\n            No  → // 不需要加\nEnd\n\nBut we need each line with arrow \"→\" and \"Decision:\" etc. Indentation can be with spaces.\n\nWe need to ensure each line is a separate line. Let's produce final.\n\nAlso maybe we can add comment for distance calculation: \"dist = (xi - xj)^2 + (yi - yj)^2\".\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化 answer = 0 // 用於累計所有 boomerangs  \n→ For i 從 0 到 n-1 // 遍歷每個點作為中心點  \n    → 初始化空距離計數表 distanceCount // 記錄以 i 為中心時各距離的出現次數  \n    → For j 從 0 到 n-1, j ≠ i // 遍歷所有其他點  \n        → 計算距離平方 dist = (x_i - x_j)^2 + (y_i - y_j)^2 // 不需要實際平方根，只需距離平方  \n        → distanceCount[dist] = distanceCount.get(dist, 0) + 1 // 更新此距離的計數  \n    → For 每個 cnt 在 distanceCount.values() // 逐一檢查每個距離的點數  \n        → Decision: cnt > 1? // 只有同距離點數大於 1 才能組成 boomerang  \n            Yes → answer += cnt * (cnt - 1) // 有序排列數量 = cnt * (cnt - 1)  \n            No  → // 低於 2 的點數不產生任何 boomerang  \nEnd // 程式執行結束，返回 answer",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        total = 0\n        for x1, y1 in points:\n            dist_count = defaultdict(int)\n            for x2, y2 in points:\n                if x1 == x2 and y1 == y2:\n                    continue\n                d = (x1 - x2) ** 2 + (y1 - y2) ** 2\n                dist_count[d] += 1\n            for cnt in dist_count.values():\n                total += cnt * (cnt - 1)\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 若輸入形如 'points = [[0,0],[1,0],[2,0]]'，去掉前綴\n    if data.lower().startswith(\"points\"):\n        _, _, data = data.partition(\"=\")\n        data = data.strip()\n    # 解析成 Python 物件\n    try:\n        points = ast.literal_eval(data)\n    except Exception:\n        points = eval(data, {\"__builtins__\": None}, {})\n    solution = Solution()\n    print(solution.numberOfBoomerangs(points))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Each line has \"虛擬碼步驟\" and comment. We must adhere to format with Start, End, Decision. We need to produce algorithm steps for class Solution with constructor, reset, shuffle. Use pseudo-code with arrows. Let's craft step-by-step:\n\nStart\n→ Step 1: Store original array copy // copy input\n→ Step 2: Initialize internal array // set arr = original\n→ End\n\nThen reset method: Start, Step 1: set arr to original copy, Step 2: return arr.\n\nShuffle method: Start, Step 1: create copy of arr, Step 2: for i from 0 to n-1: generate random index j between i and n-1 inclusive, swap elements at i and j, Step 3: return arr.\n\nNeed to format each line. Use \"→ Step 1: ...\" Each step line maybe nested within methods. Could denote method names as \"Method: reset()\", then steps. Use indentation? Not necessary. Just linear sequence. Use Decision if any but not needed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收整數陣列 nums 作為建構參數 // 獲取輸入資料\n→ Step 2: 建立 original = nums 的完整拷貝 // 儲存原始順序\n→ Step 3: 初始化 current = original 的拷貝 // 內部可變陣列\n→ End // 建構完成\n\n// -------------------------------------------------\n\nStart // reset 方法開始執行\n→ Step 1: 設定 current 為 original 的拷貝 // 回復原始順序\n→ Step 2: 回傳 current // 返回重置後的陣列\n→ End // reset 方法結束\n\n// -------------------------------------------------\n\nStart // shuffle 方法開始執行\n→ Step 1: 將 current 的拷貝命名為 result // 用於隨機化\n→ Step 2: 取得陣列長度 n\n→ Decision: 是否 n > 1? // 若陣列只有一個元素，直接返回\n    Yes → \n        → Step 3: 從 i = 0 到 n-1 做以下操作\n            → Step 3.1: 隨機產生 j，範圍為 i 到 n-1 // 隨機索引\n            → Step 3.2: 交換 result[i] 與 result[j] // 執行洗牌\n    No → \n        → Step 3: 直接進入下一步\n→ Step 4: 回傳 result // 返回隨機排列\n→ End // shuffle 方法結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport re\n\nclass Solution:\n    \"\"\"隨機洗牌的解決方案。\"\"\"\n\n    def __init__(self, nums):\n        # 儲存原始陣列的複本\n        self._original = list(nums)\n        # 內部可變陣列，初始時與原始相同\n        self._nums = list(self._original)\n\n    def reset(self):\n        \"\"\"重置陣列為原始順序並回傳。\"\"\"\n        self._nums = list(self._original)\n        return self._nums\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法，隨機打亂陣列並回傳。\"\"\"\n        shuffled = list(self._nums)\n        n = len(shuffled)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n\n    if not raw_input:\n        sys.exit(0)\n\n    # 把輸入分成兩個 JSON 陣列：commands 與 params\n    # 例：[\"Solution\",\"shuffle\"], [[[1,2,3]],[]]\n    parts = re.split(r'\\],\\s*', raw_input, maxsplit=1)\n    commands_str = parts[0] + ']'          # 加回閉合的 ]\n    params_str = parts[1] if len(parts) > 1 else '[]'\n\n    commands = json.loads(commands_str)\n    params = json.loads(params_str)\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, params):\n        if cmd == \"Solution\":\n            # 建構子，arg 是一個陣列，例如 [1,2,3]\n            obj = Solution(arg[0] if arg else [])\n            results.append(None)  # 代表 null\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有未知指令，直接跳過或 raise\n            raise ValueError(f\"未知指令 {cmd}\")\n\n    # 輸出結果，使用 json.dumps 以符合期望格式\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. Task: convert 32-bit integer to hex string. Use two's complement for negatives. No built-in methods. Must handle leading zeros. Use lowercase letters. Provide step-by-step algorithm in virtual code. We need to adhere to format: Start, → Step lines, Decision lines, End. Provide brief explanation after //.\n\nLet's design algorithm:\n\n1. Start.\n2. Input num.\n3. If num == 0: return \"0\".\n4. Initialize empty string result.\n5. Set mask = 0xF (binary 1111).\n6. While num != 0:\n   a. Extract digit = num & mask.\n   b. Convert digit to hex char: if digit < 10: '0'+digit else 'a'+(digit-10).\n   c. Prepend to result? Since we process from LSB, we can push to result string and later reverse, or we can prepend each char to result to avoid reversing.\n   d. Shift num right by 4 bits. For negative numbers in two's complement: we need arithmetic right shift. In many languages, >> is arithmetic shift. So just shift.\n7. Return result.\n\nEdge: For negative numbers, the shift will continue until num becomes 0? For negative numbers, after shifting right, it will stay negative until bits become all 1? Actually arithmetic shift of negative numbers: sign bit is replicated, so eventually you'll get -1 after enough shifts? Wait, if we do while num != 0, for negative numbers the loop may never end because num stays negative. But we only need 32 bits. So we should limit to 8 hex digits. Approach: Use mask and shift and stop after 8 iterations or when num becomes 0? For negative numbers, after shifting 4 bits, we keep shifting until num becomes 0? For negative numbers, after enough shifts, num will become -1 because all bits are 1? Actually starting from a negative 32-bit integer, shifting arithmetic right by 4 repeatedly will eventually produce -1? Let's test: Suppose -1 is all ones; shift >> 4 gives -1 again. So loop will not terminate. So we need to limit iterations to 8 hex digits for 32 bits. So we can use a loop counter i from 0 to 7: while i<8 and num !=0? But for negative, we want to process all bits even if num remains negative? Since we mask each 4 bits, we need to process all 8 hex digits anyway. So best to loop exactly 8 times. Use counter.\n\nSimplify: Set count=0; result=\"\"; while count<8:\n   digit = num & 0xF\n   char conversion\n   prepend\n   num = num >> 4\n   count++\n\nAfter loop, remove leading zeros: while result starts with '0' and length>1: remove first char.\n\nReturn result.\n\nNow produce virtual code.\n\nLine by line: Start, → Step: Input num, etc.\n\nWe need to include explanation after //.\n\nLet's write.\n\nAlso we must not use built-in library method to directly solve, but we can use operations like & >> etc.\n\nMake sure to mention that we handle negative by two's complement using 32-bit.\n\nOk.\n\nLet's craft virtual code lines.\n\nStart\n→ Step 1: Input num // 取得使用者輸入的 32 位整數\n→ Decision: 如果 num 等於 0? // 檢查是否為 0\n    Yes → Step 2: 返回 \"0\" // 直接回傳字串 \"0\"\n    No  → Step 3: 初始化 result 為空字串 // 用於儲存十六進位結果\n    No  → Step 4: 初始化 count 為 0 // 用於控制處理 8 個 4 位元\n→ Step 5: Decision: 是否 count < 8? // 只處理 32 位元\n    Yes → Step 6: 計算 digit = num & 0xF // 取得最低 4 位元\n    Yes → Step 7: Decision: 是否 digit < 10? // 判斷數值對應的十六進位字元\n        Yes → Step 8: 設定 char = '0' + digit // 轉成 '0'~'9'\n        No  → Step 9: 設定 char = 'a' + (digit - 10) // 轉成 'a'~'f'\n    Yes → Step 10: Prepend char 至 result // 由低位到高位建立字串\n    Yes → Step 11: num = num >> 4 // 算術右移 4 位元，保留符號位\n    Yes → Step 12: count = count + 1 // 進位計數\n    Yes → 回到 Step 5 // 重新檢查 count 是否小於 8\n→ Step 13: Decision: 是否 result 以 '0' 為首且長度 > 1? // 去除前導零\n    Yes → Step 14: 去除 result 的第一個字元 // 刪除多餘的零\n    Yes → 回到 Step 13 // 繼續檢查直到不符合條件\n    No  → Step 15: 返回 result // 完成十六進位轉換\nEnd // 程式執行結束\n\nNeed to make sure each line has virtual code step and explanation. Format: \"虛擬碼步驟 // 解釋\". Use \"Start\" \"End\" lines. Use arrows.\n\nLet's write with proper arrow formatting: \"Start\", \"→ Step ...\" etc.\n\nWe should ensure each decision uses Decision: and Yes →, No →.\n\nMake sure each line contains the arrow before step except Start and End.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 num // 從使用者處取得一個 32 位元整數\n→ Decision: 如果 num 等於 0? // 檢查是否為零\n    Yes → Step 2: 返回 \"0\" // 直接回傳字串 \"0\" 並結束\n    No  → Step 3: 初始化 result 為空字串 // 用於儲存十六進位結果\n    No  → Step 4: 初始化 count 為 0 // 用於控制處理 8 個 4 位元\n→ Decision: 是否 count < 8? // 只處理 32 位元（8 個十六進位位）\n    Yes → Step 5: 計算 digit = num & 0xF // 取得最低 4 位元\n    Yes → Step 6: Decision: 如果 digit < 10? // 判斷數值對應的十六進位字元\n        Yes → Step 7: 設定 char = '0' + digit // 轉成 '0'~'9'\n        No  → Step 8: 設定 char = 'a' + (digit - 10) // 轉成 'a'~'f'\n    Yes → Step 9: Prepend char 至 result // 由低位到高位建立字串\n    Yes → Step 10: num = num >> 4 // 算術右移 4 位元，保留符號位\n    Yes → Step 11: count = count + 1 // 進位計數\n    Yes → 回到 Decision: 是否 count < 8? // 重新檢查是否還有位元要處理\n→ Step 12: Decision: 是否 result 以 '0' 為首且長度 > 1? // 去除前導零\n    Yes → Step 13: 去除 result 的第一個字元 // 刪除多餘的零\n    Yes → 回到 Step 12 // 依序檢查直到不符合條件\n    No  → Step 14: 返回 result // 完成十六進位轉換\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef to_hex(num: int) -> str:\n    if num == 0:\n        return \"0\"\n    hex_chars = \"0123456789abcdef\"\n    result = \"\"\n    for _ in range(8):  # 32 bits -> 8 hex digits\n        digit = num & 0xF\n        result = hex_chars[digit] + result\n        num >>= 4\n    # remove leading zeros but keep at least one digit\n    i = 0\n    while i < len(result) - 1 and result[i] == '0':\n        i += 1\n    return result[i:]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        num = int(match.group(0))\n        print(to_hex(num))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode722.json",
    "problem_index_in_file": 0,
    "title": "Remove Comments",
    "description_snippet": "Given a C++ program, remove comments from it. The program source is an array of strings source where...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanations for removing comments from array of strings. Provide algorithm steps. Not code, just steps. Let's produce.\n\nWe need to consider state: inBlockComment flag. For each line, iterate through characters. Build output string. When not in block comment, check for comment start patterns: // or /*. When encountering //, skip rest of line. When encountering /*, set inBlockComment true, skip pattern. When encountering */, set inBlockComment false, skip pattern. Also handle that when we exit block comment maybe we skip until after */. At end of line, if we are not in block comment and the built string non-empty, output line. If built string empty and no characters left, skip output.\n\nAlso handle case that line ends with // after code. Implementation pseudo.\n\nWe'll produce step list.\n\nLet's produce structure: Start, iterate lines, inside loop iterate index. Build variable inBlockComment false. For each line create buffer outputLine empty.\n\nPseudo steps: \nStart\n→ Initialize inBlockComment = false\n→ Initialize result = []\n→ For each line index i from 0 to len(source)-1\n    → currentLine = source[i]\n    → Initialize j = 0\n    → Initialize newLine = \"\"\n    → While j < len(currentLine)\n        → If inBlockComment:\n            → If currentLine[j:j+2] == '*/':\n                → inBlockComment = false\n                → j += 2\n            → Else:\n                → j += 1\n        → Else:\n            → If currentLine[j:j+2] == '//':\n                → Break // rest ignored\n            → Else if currentLine[j:j+2] == '/*':\n                → inBlockComment = true\n                → j += 2\n            → Else:\n                → Append currentLine[j] to newLine\n                → j += 1\n    → End While\n    → If newLine trimmed not empty and not inBlockComment? Actually if newLine non-empty, add to result\n        → Decision: newLine trimmed not empty?\n            → Yes → Add newLine to result\n            → No → Skip\n→ End For\n→ Return result\nEnd\n\nBut we need to output as virtual steps.\n\nUse decision nodes.\n\nLet's craft step by step with arrow structure.\n\nWe'll produce steps with indentation for decision branches. Use format: \"→ Decision:\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 inBlockComment ← False // 初始不在區塊註解內\n→ Step 2: 設定 result ← 空陣列 // 用於儲存移除註解後的每行程式碼\n→ Step 3: 取 source 的長度 n\n→ Decision: 是否已處理完所有行? // 判斷是否完成整個 source 的迭代\n    No  → Step 4: 設定 i ← 0 // 行索引初值\n    Yes → End // 程式執行結束\n→ While i < n\n    → Step 5: currentLine ← source[i] // 取得目前處理的程式碼行\n    → Step 6: j ← 0 // 字元索引初值\n    → Step 7: newLine ← 空字串 // 用於累積此行移除註解後的內容\n    → While j < len(currentLine)\n        → Decision: inBlockComment 為 True? // 判斷目前是否處於區塊註解中\n            Yes →\n                → Decision: currentLine[j:j+2] == '*/'? // 判斷是否遇到區塊註解結束符\n                    Yes →\n                        → inBlockComment ← False // 退出區塊註解\n                        → j ← j + 2 // 跳過結束符\n                    No  →\n                        → j ← j + 1 // 在區塊註解內，忽略目前字元\n            No  →\n                → Decision: currentLine[j:j+2] == '//'? // 判斷是否遇到行註解開頭\n                    Yes →\n                        → Break // 跳出內部 while，忽略此行剩餘字元\n                    No  →\n                        → Decision: currentLine[j:j+2] == '/*'? // 判斷是否遇到區塊註解開頭\n                            Yes →\n                                → inBlockComment ← True // 進入區塊註解\n                                → j ← j + 2 // 跳過開頭符\n                            No  →\n                                → newLine ← newLine + currentLine[j] // 將字元加入新行\n                                → j ← j + 1 // 移動到下一字元\n    → End While // 內部 while 結束\n    → Decision: newLine 不是空字串? // 判斷此行是否還有有效程式碼\n        Yes →\n            → result.append(newLine) // 將新行加入結果陣列\n        No  → // 不輸出空行\n    → i ← i + 1 // 進到下一行\n→ End While // 所有行都已處理\n→ Step 8: 回傳 result // 輸出移除註解後的程式碼陣列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def removeComments(self, source):\n        res = []\n        in_block = False\n        new_line = []\n\n        for line in source:\n            i = 0\n            if not in_block:\n                new_line = []\n            while i < len(line):\n                # Inside a block comment: look for the end marker\n                if in_block and i + 1 < len(line) and line[i] == '*' and line[i + 1] == '/':\n                    in_block = False\n                    i += 2\n                    continue\n                # Outside a block comment: look for comment starts\n                if not in_block:\n                    if i + 1 < len(line) and line[i] == '/' and line[i + 1] == '*':\n                        in_block = True\n                        i += 2\n                        continue\n                    if i + 1 < len(line) and line[i] == '/' and line[i + 1] == '/':\n                        break  # rest of the line is a line comment\n                # Add non‑comment characters to the current line\n                if not in_block:\n                    new_line.append(line[i])\n                i += 1\n            if new_line and not in_block:\n                res.append(\"\".join(new_line))\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # Extract the list expression after the '=' sign, if present\n    idx = data.find('=')\n    if idx != -1:\n        expr = data[idx + 1:].strip()\n    else:\n        expr = data.strip()\n    try:\n        source = ast.literal_eval(expr)\n    except Exception:\n        # Fallback: try eval if literal_eval fails\n        source = eval(expr)\n    result = Solution().removeComments(source)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "source = [\"/*Test program */\", \"int main()\", \"{ \", \"  // variable declaration \", \"int a, b, c;\", \"/* This is a test\", \"   multiline  \", \"   comment for \", \"   testing */\", \"a = b + c;\", \"}\"]",
          "expected_output": "[\"int main()\",\"{ \",\"  \",\"int a, b, c;\",\"a = b + c;\",\"}\"]",
          "success": true,
          "output": "[\"int main()\", \"{ \", \"  \", \"int a, b, c;\", \"a = b + c;\", \"}\"]"
        },
        {
          "example_index": 1,
          "input": "source = [\"a/*comment\", \"line\", \"more_comment*/b\"]",
          "expected_output": "[\"ab\"]",
          "success": true,
          "output": "[\"ab\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solution: Nim game where you can win if n % 4 != 0. Provide virtual code lines with explanations. Use structure: Start, Decision, etc. No actual code. Provide step by step. Should be straightforward: Input n, if n % 4 != 0 return true else false. Also handle n>0.\n\nLet's create steps: Start, Step 1: Input n. Step 2: Check if n <=0? But maybe not needed. Step 3: Compute remainder. Decision: remainder != 0? Yes => return true else false. End.\n\nWe need to use arrows: → Step ...; Decision lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 從使用者取得石子總數  \n→ Decision: 若 n <= 0? // 檢查石子數是否為非正值  \n  Yes → Step 2: 輸出錯誤訊息 // 若石子數無效，提示並終止  \n  No  → Step 3: 計算 remainder = n mod 4 // 取得石子數除以 4 的餘數  \n→ Decision: remainder != 0? // 判斷餘數是否非零  \n  Yes → Step 4: 輸出 true // 你能勝出的情況  \n  No  → Step 5: 輸出 false // 你無法勝出的情況  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        \"\"\"先手能否必勝：若石子數不是 4 的倍數則可勝\"\"\"\n        return n % 4 != 0\n\ndef main() -> None:\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 從輸入中擷取第一個整數\n    match = re.search(r'\\d+', raw_input)\n    if not match:\n        # 若沒有數字則視為無效輸入\n        return\n    n = int(match.group())\n\n    solution = Solution()\n    result = solution.canWinNim(n)\n\n    # 按題目要求輸出 true / false\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: check if n>0, then while n%2==0 n/=2; while n%3==0 n/=3; while n%5==0 n/=5; return n==1. Also check negative or zero => false.\n\nWe'll produce virtual code lines with Start, End, Decision.\n\nWe need to follow the format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows: \"→\".\n\nAlso decisions: \"Decision:\".\n\nWe should write step by step. Ensure no actual code. Use simple steps.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 取得輸入值\n→ Decision: 如果 n <= 0? // 檢查是否為正整數\n    Yes → Step 2: 回傳 false // 非正數不是丑數\n    No  → Decision: 是否能被 2 整除? // 開始除以 2\n        Yes → Step 3: n = n / 2 // 消除所有 2 的因子\n        No  → Decision: 是否能被 3 整除? // 進一步檢查 3\n            Yes → Step 4: n = n / 3 // 消除所有 3 的因子\n            No  → Decision: 是否能被 5 整除? // 進一步檢查 5\n                Yes → Step 5: n = n / 5 // 消除所有 5 的因子\n                No  → Step 6: 跳出循環 // 所有因子已消除\n...\nBut the above not accurate because we need loops.\n\nMaybe simpler: Step 3: while n % 2 == 0: n = n / 2\nStep 4: while n % 3 == 0: n = n / 3\nStep 5: while n % 5 == 0: n = n / 5\nStep 6: Decision: n == 1? // 判斷是否只剩 1\n    Yes → Step 7: 回傳 true\n    No  → Step 8: 回傳 false\nEnd\n\nBut we need to incorporate decisions within loops maybe.\n\nSimpler: Use Decision loops.\n\nWe can represent loop as \"While\" step. In virtual code we can just say \"While n % 2 == 0: n = n / 2 // 消除因子 2\" but maybe not exactly but acceptable.\n\nWe'll produce lines accordingly.\n\nNeed to maintain each line with arrow, explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 取得輸入值\n→ Decision: n <= 0? // 判斷是否為正整數\n    Yes → Step 2: 回傳 false // 非正數非丑數\n    No  → → Step 3: While n % 2 == 0: n = n / 2 // 連續除以 2，去除所有 2 的因子\n    → Step 4: While n % 3 == 0: n = n / 3 // 連續除以 3，去除所有 3 的因子\n    → Step 5: While n % 5 == 0: n = n / 5 // 連續除以 5，去除所有 5 的因子\n    → Decision: n == 1? // 檢查是否已完全除完\n        Yes → Step 6: 回傳 true // 只剩 1，為丑數\n        No  → Step 7: 回傳 false // 有其他質因子，非丑數\nEnd // 程式結束\n\nBut need each line separated. For decisions with Yes/No we need separate lines for each.\n\nNeed to maintain arrow indentation.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 取得輸入值\n→ Decision: n <= 0? // 判斷是否為正整數\n    Yes → Step 2: 回傳 false // 非正數非丑數\n    No  → Step 3: While n % 2 == 0: n = n / 2 // 去除所有 2 的因子\n→ Step 4: While n % 3 == 0: n = n / 3 // 去除所有 3 的因子\n→ Step 5: While n % 5 == 0: n = n / 5 // 去除所有 5 的因子\n→ Decision: n == 1? // 判斷是否剩 1\n    Yes → Step 6: 回傳 true // 是丑數\n    No  → Step 7: 回傳 false // 含有其他質因子\nEnd // 程式結束\n\nWe should maintain arrow before each step. For decisions we use \"Decision:\".\n\nCheck formatting: Each line: \"虛擬碼步驟 // 解釋\". For decision lines, the code may be like \"Decision: n <= 0?\" plus comments. For Yes branch we need indentation.\n\nExample formatting as earlier: \n\nDecision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n\nThus we will do:\n\nDecision: n <= 0? // 判斷是否為正整數\n    Yes → Step 2: 回傳 false // 非正數非丑數\n    No  → Step 3: While n % 2 == 0: n = n / 2 // 去除所有 2 的因子\n\nBut arrow indentation: \"→\" maybe not needed before the decision line. The earlier example: \"Decision: 如果數字大於 0?\" had no arrow. So we follow.\n\nThus produce.\n\nAlso after No branch, we continue with next steps.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 取得輸入值\nDecision: n <= 0? // 判斷是否為正整數\n    Yes → Step 2: 回傳 false // 非正數非丑數\n    No  → Step 3: While n % 2 == 0: n = n / 2 // 連續除以 2，去除所有 2 的因子\n→ Step 4: While n % 3 == 0: n = n / 3 // 連續除以 3，去除所有 3 的因子\n→ Step 5: While n % 5 == 0: n = n / 5 // 連續除以 5，去除所有 5 的因子\nDecision: n == 1? // 判斷是否只剩 1\n    Yes → Step 6: 回傳 true // 只剩 1，為丑數\n    No  → Step 7: 回傳 false // 含有其他質因子\nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isUgly(self, n: int) -> bool:\n        \"\"\"判斷 n 是否為丑數。\"\"\"\n        if n <= 0:\n            return False\n        for p in (2, 3, 5):\n            while n % p == 0:\n                n //= p\n        return n == 1\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取數字，輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 允許輸入形式為 \"n = 6\" 或僅為 \"6\"\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n    else:\n        value = data\n\n    # 若仍無法轉成整數，嘗試從字串中抽取第一個數字\n    try:\n        n = int(value)\n    except ValueError:\n        import re\n        match = re.search(r'-?\\d+', data)\n        n = int(match.group()) if match else 0\n\n    sol = Solution()\n    result = sol.isUgly(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for generating power set for unique integer array. Use recursion or backtracking. Each step with explanation. Must be line by line.\n\nUse \"Start\", \"Decision:\", \"Step:\", \"End\". Provide arrow \"→\". Example: \nStart // 程式開始執行\n→ Step 1: 定義結果列表 subsets = [] // 初始化儲存子集\n→ Step 2: 呼叫回溯函式 backtrack(index=0, current=[]) // 開始回溯\n→ Decision: index == len(nums)? // 判斷是否到達尾部\n   Yes → Step 3: 加入 current 到 subsets // 收集子集\n   No  → Step 4: // 兩種選擇：不包含 nums[index]\n       → Step 4a: backtrack(index+1, current) // 跳過\n   No  → Step 5: // 包含 nums[index]\n       → Step 5a: current.append(nums[index]) // 加入元素\n       → Step 5b: backtrack(index+1, current) // 遞歸\n       → Step 5c: current.pop() // 回溯\nEnd // 程式結束\n\nBut we need to match format: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". For arrows \"→\" etc. For decision we show indentation maybe. Use spaces before lines? In example they used indentation with 4 spaces for nested lines? The example: \n```\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\nEnd // 程式執行結束\n```\nSo indentation uses 4 spaces.\n\nThus we need to produce similar.\n\nWe need to include Start and End. Provide each step.\n\nWe must not output actual code. Just virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 subsets 為空列表 // 用來儲存所有子集  \n→ Step 2: 定義遞迴函式 backtrack(index, current) // index 為目前考慮的位置，current 為目前已選的元素集合  \n→     → Decision: index == len(nums)? // 判斷是否已遍歷完整數組  \n>     Yes → Step 3: 將 current 複製並加入 subsets // 收集一個完整的子集  \n>     No  → Step 4: // 不包含 nums[index] 的選擇  \n>         → Step 4a: 呼叫 backtrack(index + 1, current) // 直接跳過目前元素  \n>     No  → Step 5: // 包含 nums[index] 的選擇  \n>         → Step 5a: 把 nums[index] 加入 current // 加入元素  \n>         → Step 5b: 呼叫 backtrack(index + 1, current) // 繼續遞迴  \n>         → Step 5c: 從 current 中移除最後加入的元素 // 回溯到上一層  \n→ Step 6: 呼叫 backtrack(0, []) // 從索引 0 開始回溯，初始子集為空  \n→ Step 7: 返回 subsets // 完成後將所有子集作為結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    res = []\n\n    def backtrack(start, path):\n        res.append(path[:])              # 收集目前子集\n        for i in range(start, len(nums)):\n            path.append(nums[i])         # 包含 nums[i]\n            backtrack(i + 1, path)       # 進一步遞迴\n            path.pop()                   # 回溯，移除最後加入的元素\n\n    backtrack(0, [])\n    return res\n\ndef format_subsets(subsets_list):\n    \"\"\"將子集列表轉換為符合題目輸出的字串格式\"\"\"\n    return '[' + ','.join(\n        '[' + ','.join(map(str, sub)) + ']' for sub in subsets_list\n    ) + ']'\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取一行，例如: 'nums = [1,2,3]'\n    line = sys.stdin.readline().strip()\n    if not line:\n        print('[]')\n        sys.exit(0)\n\n    # 取出方括號內的部分並解析為列表\n    start = line.find('[')\n    end = line.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(line[start:end+1])\n\n    result = subsets(nums)\n    print(format_subsets(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[],[0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for solving the problem: given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order. This is Leetcode problem 423: Number of Distinct Islands? Wait no. Actually it's \"Digits from English\" problem 424? Actually it's \"Number of Distinct Islands\"? Not. The problem: \"Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\" It's Leetcode 423? No. The problem is \"Number of Distinct Islands\"? Actually it's Leetcode 423. Wait.\n\nLet's think: The string contains letters that form the English words for digits 0-9 (like \"zero\", \"one\", \"two\", etc.). The string is out-of-order: the letters are shuffled. We need to reconstruct the digits and output them sorted ascending as a string.\n\nThe classic solution uses letter counts and unique letters for each digit. Steps:\n\n1. Count frequency of each letter in s.\n2. Determine digits based on unique letters:\n   - 'z' unique to \"zero\" (0)\n   - 'w' unique to \"two\" (2)\n   - 'u' unique to \"four\" (4)\n   - 'x' unique to \"six\" (6)\n   - 'g' unique to \"eight\" (8)\n   - After those, use 'o' for \"one\" (1) after removing zero, two, four.\n   - 'h' for \"three\" (3) after removing eight.\n   - 'f' for \"five\" (5) after removing four.\n   - 's' for \"seven\" (7) after removing six.\n   - 'i' for \"nine\" (9) after removing 0,2,4,6,8.\n\nWe can produce pseudo-code accordingly.\n\nWe should output line by line. Use \"Start\", \"End\", \"Decision:\" etc. Each line with explanation. Provide arrow lines.\n\nWe need to adhere to output format: each line: virtual code step, space, comment with explanation.\n\nLet's produce.\n\nWe can include loops for constructing output string.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化字母頻率表 count[26] = 0 // 用於統計每個字母出現次數\n→ Step 2: 對於 s 中的每個字符 ch: count[ch - 'a']++ // 建立字母出現頻率\n→ Step 3: 初始化 digits[10] = 0 // 用於統計每個數字的個數\n\nThen determine each digit:\n\n→ Decision: 是否存在 'z'? // 'z'只出現在\"zero\"（0）\n    Yes → Step 4: digits[0] = count['z' - 'a'] // 確定 0 的個數\n        → Step 5: for 每個字母 c in \"zero\": count[c - 'a'] -= digits[0] // 減去已用字母\n    No  → Step 4: digits[0] = 0 // 0 為 0\n\nSimilarly for 'w', 'u', 'x', 'g', 'o', 'h', 'f', 's', 'i'.\n\nWe need to produce all these lines.\n\nWe can group repeated patterns with comments.\n\nBut each step must be explicit.\n\nLet's produce pseudo-code for each digit:\n\n- For 'z' -> 0\n- For 'w' -> 2\n- For 'u' -> 4\n- For 'x' -> 6\n- For 'g' -> 8\n- For 'o' -> 1\n- For 'h' -> 3\n- For 'f' -> 5\n- For 's' -> 7\n- For 'i' -> 9\n\nAfter counting digits, build result string sorted:\n\n→ Step X: result = \"\" // 初始化結果字符串\n→ Step Y: for d from 0 to 9:\n    → Step Z: result += string(digit value repeated digits[d] times) // 將每個數字按升序加入結果\n→ End // 程式結束，返回結果\n\nWe need to include \"Return result\" maybe.\n\nNow, each line needs arrow \"→\" at beginning.\n\nLet's produce in order. Use \"Decision:\" with \"Yes →\" and \"No →\".\n\nBut we can simply assign without decision, since we know mapping from count.\n\nActually we don't need a decision, we can just set digits based on count of unique letter. We can just compute digits[0] = count['z'-'a'] etc. Then subtract.\n\nSimplify: no Decision. But problem states to use Decision structure. Could still use decisions.\n\nBut we can still use Decision: If count['z'] > 0 then assign digits[0], else digits[0] = 0. But if count is zero, assign zero anyway. But we can just assign directly.\n\nBut to satisfy requirement, we can use Decision for each digit.\n\nLet's produce as:\n\nDecision: 如果 count['z']>0? // 判斷是否存在 'z'\n    Yes → Step: digits[0] = count['z'] // 計算 0 的個數\n        → Step: for c in \"zero\": count[c] -= digits[0] // 減去對應字母\n    No  → Step: digits[0] = 0 // 沒有 0\n\nBut we can shorten explanation.\n\nWe need to produce for each digit.\n\nThen after all digits, we need to build result.\n\nWe also need to use \"Start\" and \"End\".\n\nLet's produce final answer accordingly.\n\nLet's ensure every line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe need to use '→' arrow before each line after Start and End? The example uses:\n\nStart // 程式開始執行\n→ Step 1: ... // ...\n→ Decision: ...\n    Yes → Step ...\n    No  → Step ...\n\nSo we need to mimic that.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化字母頻率表 count[26] = 0 // 用於統計每個字母出現次數\n→ Step 2: 對於每個字符 ch in s: count[ch - 'a']++ // 建立字母出現頻率\n→ Step 3: 初始化 digits[10] = 0 // 用於統計每個數字的個數\n\nDecision: 是否存在 'z' (0 的唯一字母)? // 'z' 只出現在 \"zero\"\n    Yes → Step 4: digits[0] = count['z' - 'a'] // 計算 0 的個數\n        → Step 5: for 每個字母 c in \"zero\": count[c - 'a'] -= digits[0] // 減去已用字母\n    No  → Step 4: digits[0] = 0 // 沒有 0\n\nDecision: 是否存在 'w' (2 的唯一字母)? // 'w' 只出現在 \"two\"\n    Yes → Step 6: digits[2] = count['w' - 'a'] // 計算 2 的個數\n        → Step 7: for 每個字母 c in \"two\": count[c - 'a'] -= digits[2] // 減去已用字母\n    No  → Step 6: digits[2] = 0 // 沒有 2\n\nDecision: 是否存在 'u' (4 的唯一字母)? // 'u' 只出現在 \"four\"\n    Yes → Step 8: digits[4] = count['u' - 'a'] // 計算 4 的個數\n        → Step 9: for 每個字母 c in \"four\": count[c - 'a'] -= digits[4] // 減去已用字母\n    No  → Step 8: digits[4] = 0 // 沒有 4\n\nDecision: 是否存在 'x' (6 的唯一字母)? // 'x' 只出現在 \"six\"\n    Yes → Step 10: digits[6] = count['x' - 'a'] // 計算 6 的個數\n        → Step 11: for 每個字母 c in \"six\": count[c - 'a'] -= digits[6] // 減去已用字母\n    No  → Step 10: digits[6] = 0 // 沒有 6\n\nDecision: 是否存在 'g' (8 的唯一字母)? // 'g' 只出現在 \"eight\"\n    Yes → Step 12: digits[8] = count['g' - 'a'] // 計算 8 的個數\n        → Step 13: for 每個字母 c in \"eight\": count[c - 'a'] -= digits[8] // 減去已用字母\n    No  → Step 12: digits[8] = 0 // 沒有 8\n\nDecision: 是否存在 'o' (1 的唯一字母, 但已去掉 0,2,4 的 'o')? // 'o' 出現在 \"one\" 以及已消除的 0,2,4\n    Yes → Step 14: digits[1] = count['o' - 'a'] // 計算 1 的個數\n        → Step 15: for 每個字母 c in \"one\": count[c - 'a'] -= digits[1] // 減去已用字母\n    No  → Step 14: digits[1] = 0 // 沒有 1\n\nDecision: 是否存在 'h' (3 的唯一字母, 但已去掉 8 的 'h')? // 'h' 出現在 \"three\" 以及已消除的 8\n    Yes → Step 16: digits[3] = count['h' - 'a'] // 計算 3 的個數\n        → Step 17: for 每個字母 c in \"three\": count[c - 'a'] -= digits[3] // 減去已用字母\n    No  → Step 16: digits[3] = 0 // 沒有 3\n\nDecision: 是否存在 'f' (5 的唯一字母, 但已去掉 4 的 'f')? // 'f' 出現在 \"five\" 以及已消除的 4\n    Yes → Step 18: digits[5] = count['f' - 'a'] // 計算 5 的個數\n        → Step 19: for 每個字母 c in \"five\": count[c - 'a'] -= digits[5] // 減去已用字母\n    No  → Step 18: digits[5] = 0 // 沒有 5\n\nDecision: 是否存在 's' (7 的唯一字母, 但已去掉 6 的 's')? // 's' 出現在 \"seven\" 以及已消除的 6\n    Yes → Step 20: digits[7] = count['s' - 'a'] // 計算 7 的個數\n        → Step 21: for 每個字母 c in \"seven\": count[c - 'a'] -= digits[7] // 減去已用字母\n    No  → Step 20: digits[7] = 0 // 沒有 7\n\nDecision: 是否存在 'i' (9 的唯一字母, 但已去掉 0,2,4,6,8 的 'i')? // 'i' 出現在 \"nine\" 以及已消除的 0,2,4,6,8\n    Yes → Step 22: digits[9] = count['i' - 'a'] // 計算 9 的個數\n        → Step 23: for 每個字母 c in \"nine\": count[c - 'a'] -= digits[9] // 減去已用字母\n    No  → Step 22: digits[9] = 0 // 沒有 9\n\n→ Step 24: result = \"\" // 初始化結果字符串\n→ Step 25: for d in 0 to 9:\n    → Step 26: result += string(repeat character '0'+d, digits[d]) // 將每個數字按升序加入結果\n→ End // 程式執行結束，返回結果\n\nBut we need to keep each line minimal and include arrow. Each decision branch lines must be preceded by \"Yes →\" or \"No  →\". And the lines inside each branch have \"→\" as well. Indentation not necessary but can use.\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must be a line: arrow, step, comment. Even inside branches we need to include \"Yes →\" and \"No →\" lines.\n\nBetter to structure:\n\nDecision: 是否存在 'z'? // ...\n    Yes → Step 4: digits[0] = count['z' - 'a'] // ...\n        → Step 5: for each c in \"zero\": count[c - 'a'] -= digits[0] // ...\n    No  → Step 4: digits[0] = 0 // ...\n\nThis matches the example: Decision line, then indented Yes → Step ... lines, No  → Step ... lines.\n\nMake sure each branch line also has arrow and comment.\n\nFor repeated similar steps, we can use same pattern.\n\nAfter all digits, build result.\n\nThe final line \"End // 程式執行結束，返回結果\" but we need to return result. Perhaps we need to add Step 27: return result. But End marks program end.\n\nWe can produce \"End // 程式執行結束，返回結果\".\n\nWe might add Step 27: return result.\n\nBut as End is end, we can assume returning result.\n\nNow produce final answer. Ensure no actual code. Provide in traditional Chinese. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字母頻率表 count[26] = 0 // 用於統計每個字母出現次數  \n→ Step 2: 對於 s 中的每個字符 ch: count[ch - 'a']++ // 建立字母出現頻率  \n→ Step 3: 初始化 digits[10] = 0 // 用於統計每個數字的個數  \n\nDecision: 是否存在 'z' (0 的唯一字母)? // 'z' 只出現在 \"zero\"  \n    Yes → Step 4: digits[0] = count['z' - 'a'] // 計算 0 的個數  \n        → Step 5: for 每個字母 c in \"zero\": count[c - 'a'] -= digits[0] // 減去已用字母  \n    No  → Step 4: digits[0] = 0 // 沒有 0  \n\nDecision: 是否存在 'w' (2 的唯一字母)? // 'w' 只出現在 \"two\"  \n    Yes → Step 6: digits[2] = count['w' - 'a'] // 計算 2 的個數  \n        → Step 7: for 每個字母 c in \"two\": count[c - 'a'] -= digits[2] // 減去已用字母  \n    No  → Step 6: digits[2] = 0 // 沒有 2  \n\nDecision: 是否存在 'u' (4 的唯一字母)? // 'u' 只出現在 \"four\"  \n    Yes → Step 8: digits[4] = count['u' - 'a'] // 計算 4 的個數  \n        → Step 9: for 每個字母 c in \"four\": count[c - 'a'] -= digits[4] // 減去已用字母  \n    No  → Step 8: digits[4] = 0 // 沒有 4  \n\nDecision: 是否存在 'x' (6 的唯一字母)? // 'x' 只出現在 \"six\"  \n    Yes → Step 10: digits[6] = count['x' - 'a'] // 計算 6 的個數  \n        → Step 11: for 每個字母 c in \"six\": count[c - 'a'] -= digits[6] // 減去已用字母  \n    No  → Step 10: digits[6] = 0 // 沒有 6  \n\nDecision: 是否存在 'g' (8 的唯一字母)? // 'g' 只出現在 \"eight\"  \n    Yes → Step 12: digits[8] = count['g' - 'a'] // 計算 8 的個數  \n        → Step 13: for 每個字母 c in \"eight\": count[c - 'a'] -= digits[8] // 減去已用字母  \n    No  → Step 12: digits[8] = 0 // 沒有 8  \n\nDecision: 是否存在 'o' (1 的唯一字母, 但已去掉 0,2,4 的 'o')? // 'o' 出現在 \"one\"  \n    Yes → Step 14: digits[1] = count['o' - 'a'] // 計算 1 的個數  \n        → Step 15: for 每個字母 c in \"one\": count[c - 'a'] -= digits[1] // 減去已用字母  \n    No  → Step 14: digits[1] = 0 // 沒有 1  \n\nDecision: 是否存在 'h' (3 的唯一字母, 但已去掉 8 的 'h')? // 'h' 出現在 \"three\"  \n    Yes → Step 16: digits[3] = count['h' - 'a'] // 計算 3 的個數  \n        → Step 17: for 每個字母 c in \"three\": count[c - 'a'] -= digits[3] // 減去已用字母  \n    No  → Step 16: digits[3] = 0 // 沒有 3  \n\nDecision: 是否存在 'f' (5 的唯一字母, 但已去掉 4 的 'f')? // 'f' 出現在 \"five\"  \n    Yes → Step 18: digits[5] = count['f' - 'a'] // 計算 5 的個數  \n        → Step 19: for 每個字母 c in \"five\": count[c - 'a'] -= digits[5] // 減去已用字母  \n    No  → Step 18: digits[5] = 0 // 沒有 5  \n\nDecision: 是否存在 's' (7 的唯一字母, 但已去掉 6 的 's')? // 's' 出現在 \"seven\"  \n    Yes → Step 20: digits[7] = count['s' - 'a'] // 計算 7 的個數  \n        → Step 21: for 每個字母 c in \"seven\": count[c - 'a'] -= digits[7] // 減去已用字母  \n    No  → Step 20: digits[7] = 0 // 沒有 7  \n\nDecision: 是否存在 'i' (9 的唯一字母, 但已去掉 0,2,4,6,8 的 'i')? // 'i' 出現在 \"nine\"  \n    Yes → Step 22: digits[9] = count['i' - 'a'] // 計算 9 的個數  \n        → Step 23: for 每個字母 c in \"nine\": count[c - 'a'] -= digits[9] // 減去已用字母  \n    No  → Step 22: digits[9] = 0 // 沒有 9  \n\n→ Step 24: result = \"\" // 初始化結果字符串  \n→ Step 25: for d in 0 to 9:  \n    → Step 26: result += string(repeat character '0'+d, digits[d]) // 將每個數字按升序加入結果  \n→ End // 程式執行結束，返回結果",
      "generated_code": "class Solution:\n    def originalDigits(self, s: str) -> str:\n        from collections import Counter\n        count = Counter(s)\n\n        out = {}\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n\n        res = [k * out[k] for k in sorted(out.keys())]\n        return ''.join(res)\n\n\ndef main() -> None:\n    import sys\n    import re\n\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 取得第一個雙引號內的字串，若找不到則直接使用整行文字\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else data\n\n    sol = Solution()\n    result = sol.originalDigits(s)\n\n    # 按範例輸出時帶上雙引號\n    print(f'\"{result}\"')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "\"012\""
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "\"45\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Problem: Largest palindrome product of two n-digit numbers, modulo 1337. Need algorithm: iterate from largest n-digit down to smallest, compute product, check palindrome, track max. Use modulo only at final return. Complexity fine.\n\nWe should produce pseudocode lines with explanation. Use Start, Decision, loops, etc.\n\nWe need to include steps: compute lower and upper bounds, loop for i from upper to lower, for j from i down to lower (to avoid duplicate). Check palindrome: convert to string, compare with reverse. Keep max. After loops, return max % 1337.\n\nWe need to ensure each line has `虛擬碼步驟` + ` // 解釋`. Provide arrow and decision.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 lower = 10^(n-1) // 最小 n 位數  \n→ Step 2: 設定 upper = 10^n - 1 // 最大 n 位數  \n→ Step 3: 設定 max_palindrome = 0 // 儲存目前最大的回文數  \n→ Decision: 迴圈 i 從 upper 下降到 lower? // 從最大數開始尋找  \n    Yes → Step 4: 迴圈 j 從 i 下降到 lower? // 只考慮 j ≤ i 以避免重複計算  \n        Yes → Step 5: 計算 product = i * j // 兩數相乘  \n        → Step 6: 判斷 product 是否為回文？ // 轉成字串比較正反  \n            → Decision: product 轉成字串等於其逆序?  \n                Yes → Step 7: 如果 product > max_palindrome  \n                    → Decision: product > max_palindrome?  \n                        Yes → Step 8: 更新 max_palindrome = product // 找到更大的回文  \n                        No → No Action // 仍保持較大的值  \n                No → No Action // 不是回文，忽略  \n        → Step 9: j 結束迴圈  \n    → Step 10: i 結束迴圈  \n→ Step 11: 計算 result = max_palindrome % 1337 // 取模後得到答案  \n→ Step 12: 輸出 result // 將結果回傳給呼叫方  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        \"\"\"Return the largest palindromic product of two n‑digit numbers, modulo 1337.\"\"\"\n        # Handle single digit case directly\n        if n == 1:\n            return 9\n\n        lower = 10 ** (n - 1)          # Smallest n‑digit number\n        upper = 10 ** n - 1            # Largest n‑digit number\n        max_palindrome = 0\n\n        # Iterate over the first factor from largest to smallest\n        for i in range(upper, lower - 1, -1):\n            # If the product of i and the largest possible j is already <= max_palindrome,\n            # we can skip the rest of this outer loop\n            if i * upper <= max_palindrome:\n                break\n\n            # Iterate over the second factor from i downwards to avoid duplicate pairs\n            for j in range(i, lower - 1, -1):\n                product = i * j\n\n                # Since j is decreasing, once product <= max_palindrome we can break inner loop\n                if product <= max_palindrome:\n                    break\n\n                if str(product) == str(product)[::-1]:\n                    max_palindrome = product\n\n        return max_palindrome % 1337\n\n\nif __name__ == \"__main__\":\n    # Read entire input, extract the first integer encountered\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        sys.exit(0)\n    n = int(numbers[0])\n\n    sol = Solution()\n    result = sol.largestPalindrome(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with explanations. The algorithm: Given arrays players and trainers, want maximum matches where ability <= capacity, one-to-one. This is classic bipartite matching sorted greedy: sort both arrays, use two pointers to match smallest ability to smallest capacity that can fit. That gives maximum cardinality. So pseudocode:\n\nStart\n→ Step 1: Sort players ascending // to process low ability first\n→ Step 2: Sort trainers ascending // to process low capacity first\n→ Step 3: Initialize i=0, j=0, matches=0 // pointers and counter\n→ Decision: i < players.length AND j < trainers.length? // while both arrays have elements\n   Yes →\n     Decision: players[i] <= trainers[j]? // can match\n        Yes →\n          → Step 4: matches++ // increment matches\n          → Step 5: i++ // move to next player\n          → Step 6: j++ // move to next trainer\n        No →\n          → Step 7: j++ // trainer too weak, try next trainer\n   No → End loop\n→ Step 8: Return matches // maximum matches\n\nNeed to output each line with explanation, with arrow. Also start and end. Let's format.\n\nNeed to include 'Start // 程式開始執行' and 'End // 程式執行結束'. Also we should use virtual code arrows: → Step, Decision:, Yes →, No →.\n\nMake sure each line ends with explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort players ascending // 先將玩家能力從小到大排列\n→ Step 2: Sort trainers ascending // 先將訓練師容量從小到大排列\n→ Step 3: Initialize i = 0, j = 0, matches = 0 // i 指向玩家，j 指向訓練師，matches 計算匹配數\n→ Decision: i < players.length AND j < trainers.length? // 兩陣列還有未處理元素\n    Yes →\n        Decision: players[i] <= trainers[j]? // 能否用當前訓練師匹配當前玩家\n            Yes →\n                → Step 4: matches++ // 匹配成功，計數加一\n                → Step 5: i++ // 移到下一個玩家\n                → Step 6: j++ // 移到下一個訓練師\n            No →\n                → Step 7: j++ // 當前訓練師容量不足，嘗試更高容量的訓練師\n    No → // 迴圈結束\n→ Step 8: Return matches // 回傳最大可匹配數量\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def matchPlayersAndTrainers(self, players, trainers):\n        \"\"\"\n        先把玩家和訓練師各自按能力/容量升序排序。\n        用兩個指標 i（玩家）和 j（訓練師）從最小開始掃描。\n        當 players[i] <= trainers[j] 時能配對，兩指標同時往後移並計數；\n        否則 j 前進，尋找更適合的訓練師。\n        直到任一陣列結束，返回計數即為最大配對數。\n        \"\"\"\n        players.sort()\n        trainers.sort()\n        i = j = matches = 0\n        while i < len(players) and j < len(trainers):\n            if players[i] <= trainers[j]:\n                matches += 1\n                i += 1\n            j += 1\n        return matches\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中找出兩個列表。\n    允許輸入類似 \"players = [4,7,9], trainers = [8,2,5,8]\"\n    或者單獨兩行列表。\n    \"\"\"\n    players = trainers = None\n\n    # 先嘗試尋找名為 players 與 trainers 的列表\n    players_match = re.search(r'players\\s*=\\s*(\\[[^\\]]*\\])', text)\n    trainers_match = re.search(r'trainers\\s*=\\s*(\\[[^\\]]*\\])', text)\n\n    if players_match:\n        players = ast.literal_eval(players_match.group(1))\n    if trainers_match:\n        trainers = ast.literal_eval(trainers_match.group(1))\n\n    # 若沒找到，嘗試直接從所有方括號中取得兩個列表\n    if players is None or trainers is None:\n        lists = re.findall(r'\\[[^\\]]*\\]', text)\n        if len(lists) >= 2:\n            players = ast.literal_eval(lists[0])\n            trainers = ast.literal_eval(lists[1])\n\n    # 最後若還是 None，給空列表防止錯誤\n    players = players or []\n    trainers = trainers or []\n    return players, trainers\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    players, trainers = parse_input(raw_input)\n    sol = Solution()\n    result = sol.matchPlayersAndTrainers(players, trainers)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode704.json",
    "problem_index_in_file": 0,
    "title": "Binary Search",
    "description_snippet": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search algorithm. Use Start, Decision etc. Provide lines with virtual code step and explanation. Must follow output format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow characters. We should produce steps: Start, set left=0, right=n-1, loop while left<=right, compute mid, compare nums[mid] with target, adjust left/right, if found return mid, else return -1. Use End.\n\nNeed to use \"Decision:\" for loops and if statements. Use \"→\" arrow.\n\nMake sure to include comments. Format each line with one step. Should we combine multiple lines? Probably separate each action.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 left = 0 // 左邊界設為陣列起點\n→ Step 2: 定義 right = len(nums) - 1 // 右邊界設為陣列終點\n→ Decision: while left ≤ right? // 只要左邊界不超過右邊界，繼續搜尋\n    Yes → Step 3: mid = (left + right) // 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 判斷中間元素是否為目標\n        Yes → Step 4: return mid // 找到目標，回傳索引\n        No  → Decision: nums[mid] < target? // 若中間小於目標，目標在右半段\n            Yes → Step 5: left = mid + 1 // 左邊界移至 mid + 1\n            No  → Step 6: right = mid - 1 // 否則右邊界移至 mid - 1\n    No  → (loop back) // 若未滿足條件，重新評估 while\n→ Step 7: return -1 // 搜尋完畢仍未找到，回傳 -1\nEnd // 程式執行結束\n\nBut need to align \"Decision:\" lines with arrows. The standard format uses indenting with tab? We can mimic indent as example shows using spaces. Use 4 spaces indentation for nested steps.\n\nAlso need \"→\" before each step. For decisions we show \"Decision: ...\" with arrow? In example: \"Decision: 如果數字大於 0?\" without arrow preceding? Actually example shows:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: ...\n\nSo \"Decision:\" is preceded by arrow. Use same.\n\nAlso loops: \"Decision: while left ≤ right?\" with arrow.\n\nWe need \"Yes →\" and \"No →\".\n\nFor loop: \"Yes → Step 3: ...\" inside while.\n\nAlso after while loop finishes, we go to Step 7: return -1.\n\nWe need to show the loop as repeated until condition fails.\n\nThe \"while\" is a decision; we need a Yes branch that continues loop and No branch that exits loop. But we may not need to explicitly show No branch; can just show loop continues until condition false then exit to Step 7. In example, they didn't show No branch for while, but we can show \"No →\" line maybe. But not necessary.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: left = 0 // 左邊界設為陣列起點\n→ Step 2: right = len(nums) - 1 // 右邊界設為陣列終點\n→ Decision: while left ≤ right? // 只要左邊界不超過右邊界，繼續搜尋\n    Yes → Step 3: mid = (left + right) // 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 判斷中間元素是否為目標\n        Yes → Step 4: return mid // 找到目標，回傳索引\n        No  → Decision: nums[mid] < target? // 若中間小於目標，目標在右半段\n            Yes → Step 5: left = mid + 1 // 左邊界移至 mid + 1\n            No  → Step 6: right = mid - 1 // 右邊界移至 mid - 1\n    No → (loop back) // 未滿足 while，結束循環\n→ Step 7: return -1 // 搜尋完畢仍未找到，回傳 -1\nEnd // 程式執行結束\n\nBut the \"No → (loop back)\" is ambiguous. We can avoid it. Instead, after No branch of inner decision, we loop back automatically.\n\nMaybe simpler:\n\nStart // 程式開始執行\n→ Step 1: left = 0 // 左邊界設為陣列起點\n→ Step 2: right = len(nums) - 1 // 右邊界設為陣列終點\n→ Decision: while left ≤ right? // 只要左邊界不超過右邊界，繼續搜尋\n    Yes → Step 3: mid = (left + right) // 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 判斷中間元素是否為目標\n        Yes → Step 4: return mid // 找到目標，回傳索引\n        No  → Decision: nums[mid] < target? // 若中間小於目標，目標在右半段\n            Yes → Step 5: left = mid + 1 // 左邊界移至 mid + 1\n            No  → Step 6: right = mid - 1 // 右邊界移至 mid - 1\n→ Step 7: return -1 // 搜尋完畢仍未找到，回傳 -1\nEnd // 程式執行結束\n\nThis format may satisfy.\n\nNeed to ensure each line has arrow and comment. Let's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0 // 設定左邊界為陣列起點  \n→ Step 2: right = len(nums) - 1 // 設定右邊界為陣列終點  \n→ Decision: while left ≤ right? // 只要左邊界不超過右邊界，繼續搜尋  \n&nbsp;&nbsp;Yes → Step 3: mid = (left + right) // 2 // 計算中間索引  \n&nbsp;&nbsp;→ Decision: nums[mid] == target? // 判斷中間元素是否為目標  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: return mid // 找到目標，回傳索引  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: nums[mid] < target? // 若中間小於目標，目標在右半段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: left = mid + 1 // 將左邊界移至 mid + 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 6: right = mid - 1 // 將右邊界移至 mid - 1  \n→ Step 7: return -1 // 搜尋完畢仍未找到，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 取得所有整數（含負號）\n    numbers = re.findall(r'-?\\d+', raw_input)\n    nums = list(map(int, numbers))\n\n    # target 為最後一個整數，nums 為前面的整數\n    target = nums[-1]\n    nums_list = nums[:-1]\n\n    solution = Solution()\n    result = solution.search(nums_list, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode724.json",
    "problem_index_in_file": 0,
    "title": "Find Pivot Index",
    "description_snippet": "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the in...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing pivot index, step by step. Each line: \"虛擬碼步驟\" then space then // explanation. Use arrows. Start, End, Decision. Let's produce typical algorithm: compute total sum, iterate with left sum, if left sum equals total - left sum - nums[i] then pivot. Return index else -1. Provide steps.\n\nWe must not output actual code. Only virtual steps. So lines like:\n\nStart // 開始執行\n→ Step 1: 計算 nums 整體總和 total // 先求所有元素之和\n→ Step 2: 初始化 leftSum 為 0 // 左側已經累加的總和\n→ Step 3: 循環遍歷每個索引 i 從 0 到 n-1 // 對每個位置做檢查\n    → Decision: leftSum 等於 total - leftSum - nums[i]? // 判斷當前為 pivot\n        Yes → Step 4: 回傳 i // 找到左邊最小的 pivot，返回索引\n        No  → Step 5: 更新 leftSum += nums[i] // 加入當前元素進左邊和\n→ Step 6: 循環結束後沒有找到 pivot → Step 7: 回傳 -1 // 沒有符合條件的索引\nEnd // 程式結束\n\nMake sure each line uses arrow where appropriate. For Decision block, indent with spaces. Use \"Decision:\" line. Provide explanation. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 nums 的總和 total // 先求出所有元素之和  \n→ Step 2: 初始化 leftSum 為 0 // 左邊已累加的總和，起始為 0  \n→ Step 3: 循環遍歷每個索引 i 從 0 到 n-1 // 逐一檢查每個位置是否為 pivot  \n  Decision: leftSum 等於 total - leftSum - nums[i]? // 判斷左邊和是否等於右邊和  \n   Yes → Step 4: 回傳 i // 找到左邊最小的 pivot，直接返回索引  \n   No  → Step 5: 更新 leftSum += nums[i] // 把當前元素加入左邊和，繼續下一個索引  \n→ Step 6: 循環結束後仍未找到 pivot → Step 7: 回傳 -1 // 沒有符合條件的索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def pivotIndex(self, nums):\n        \"\"\"返回左側和等於右側和的最左邊索引，若不存在則回傳 -1\"\"\"\n        total = sum(nums)          # 整個陣列的總和\n        left_sum = 0               # 目前為止左側已累加的總和\n        for i, num in enumerate(nums):\n            # 左側和 == 右側和 的判斷式\n            if left_sum == total - left_sum - num:\n                return i          # 找到符合條件的最左邊索引\n            left_sum += num        # 把目前元素加入左側和\n        return -1                 # 沒有符合條件的索引\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 只抓取第一個 '[' 到最後一個 ']' 的子字串，然後做 literal_eval\n    if '[' in data:\n        start = data.find('[')\n        end = data.rfind(']')\n        list_str = data[start:end + 1]\n        nums = ast.literal_eval(list_str)\n    else:\n        # 若輸入本身就是 list 字串，直接 eval\n        nums = ast.literal_eval(data)\n\n    solution = Solution()\n    result = solution.pivotIndex(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,3,6,5,6]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode761.json",
    "problem_index_in_file": 0,
    "title": "Special Binary String",
    "description_snippet": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solution algorithm. We need to output step-by-step pseudocode with explanation comments. Should be in Chinese (繁體). Should be virtual code, not actual code. Use arrow etc. Provide a high-level algorithm. We need to produce pseudocode for the problem: given special binary string s, can perform swaps of two consecutive special substrings. Want lexicographically largest result.\n\nWe need algorithm: The best approach: Since special string property: balanced and prefixes 1>=0. Swapping consecutive special substrings preserves that property? Need to find lexicographically largest string by rearranging special substrings.\n\nObservation: This is similar to problem LeetCode 1021 \"Remove Outermost Parentheses\" but with binary. The maximal lexicographic string can be obtained by sorting the special substrings lexicographically descending. But we need to consider nested structure.\n\nApproach: Recursively decompose the string into top-level special substrings. For each substring, recursively transform to lexicographically largest by sorting its internal substrings. Then sort the top-level substrings in descending order, concatenate.\n\nThus algorithm:\n\n- Define function solve(substring):\n    - If length <=2: return substring.\n    - Initialize list parts.\n    - Use counter for depth; iterate over substring; when counter returns to 0, we have a special substring; add to parts; continue.\n    - For each part: recursively solve(part).\n    - Sort parts in descending lex order.\n    - Concatenate and return.\n\nEdge: Need to treat the string as 'special', so it's balanced.\n\nComplexities: O(n log n) due to sorting.\n\nSo produce virtual code.\n\nWe need to output each line of pseudocode with arrow or start etc. The format: Start, → Step, etc.\n\nWill produce:\n\nStart // 程式開始\n\n→ Step 1: 定義 function solve(s) // 定義遞迴轉換\n\n→   Step 1.1: 如果 s 長度 <= 2 → Return s // 基本情況\n\n→   Step 1.2: parts ← empty list // 存放 top-level 特殊子字串\n\n→   Step 1.3: depth ← 0\n\n→   Step 1.4: i ← 0\n\n→   Step 1.5: While i < length(s) :\n\n→     → Decision: depth == 0? // 判斷是否回到平衡\n\n→        Yes → part_start ← i // 開始位置\n\n→        → While depth != 0 : // 找到對應結束\n\n→              → Increment/Decrement depth accordingly\n\n→              → i++\n\n→        → part ← substring(s, part_start, i) // 取子字串\n\n→        → Append solve(part) to parts // 內部遞迴\n\n→     No → Update depth based on s[i] // '1' +1, '0' -1\n\n→     → i++\n\n→   End While\n\n→   Step 1.6: Sort parts descending lexicographically // 讓子字串按大到小排列\n\n→   Step 1.7: result ← concatenate all parts\n\n→   Step 1.8: Return result\n\nThen main:\n\nStart // 程式開始\n\n→ Input s\n\n→ Step 2: output solve(s)\n\n→ End\n\nBut need to use virtual arrows. Provide proper indentation maybe.\n\nLet's write each step as a line.\n\nWe need to maintain readability: Use indentation with arrow and decisions.\n\nWe need to produce a final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義遞迴函式 Solve(s) // 轉換特殊子字串為字典序最大  \n  → Decision: s 的長度 <= 2? // 基本情況：只有 10 或空字串  \n    Yes → Return s // 直接回傳  \n    No → // 需要拆解  \n     → Step 1.1: parts ← 空清單 // 存放最外層特殊子字串  \n     → Step 1.2: depth ← 0 // 追蹤 1 與 0 的平衡  \n     → Step 1.3: i ← 0 // 索引指標  \n     → While i < s.length:  \n       → Decision: depth == 0? // 已回到平衡點，結束一個子字串  \n         Yes → start ← i // 記錄子字串開始位置  \n          → While depth != 0:  \n            → If s[i] == '1' → depth++  \n            → Else → depth--  \n            → i++  \n          → part ← s.substring(start, i) // 取得子字串  \n          → parts.append( Solve(part) ) // 內部遞迴轉換  \n         No  → // 仍在子字串內  \n          → If s[i] == '1' → depth++  \n           Else → depth--  \n          → i++  \n        End While  \n     → End While  \n     → Step 1.4: parts.sort(descending) // 讓子字串按字典序大到小排列  \n     → Step 1.5: result ← Concatenate(parts) // 合併所有子字串  \n     → Return result  \nEnd // 函式定義結束  \n\nStart // 主程式開始  \n→ Step 2: 讀入字串 s  \n→ Step 3: output Solve(s) // 印出字典序最大的結果  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def makeLargestSpecial(self, s: str) -> str:\n        count = 0\n        i = 0\n        res = []\n        for j, c in enumerate(s):\n            if c == '1':\n                count += 1\n            else:\n                count -= 1\n            if count == 0:\n                inner = self.makeLargestSpecial(s[i+1:j])\n                res.append('1' + inner + '0')\n                i = j + 1\n        res.sort(reverse=True)\n        return ''.join(res)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract only '0' and '1' characters to form the binary string\n    s = ''.join(c for c in data if c in '01')\n    if not s:\n        return\n    solution = Solution()\n    result = solution.makeLargestSpecial(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"11011000\"",
          "expected_output": "\"11100100\"",
          "success": true,
          "output": "11100100"
        },
        {
          "example_index": 1,
          "input": "s = \"10\"",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code line-by-line with explanations. Should not output real code. Use virtual code steps, arrows. Provide steps to compute Hamming distance between two integers x and y. Steps: start, XOR, count bits, output. Use Decision? Possibly loop over bits. Use bitwise operations.\n\nLet's design:\n\nStart\n→ Step 1: Compute xor = x XOR y // bitwise difference\n→ Step 2: Initialize count = 0 // result counter\n→ Step 3: While xor > 0 // iterate bits\n    → Decision: If xor LSB == 1? // check lowest bit\n        Yes → count = count + 1 // increment\n    → xor = xor >> 1 // shift right to process next bit\n→ Step 4: Return count // final Hamming distance\nEnd\n\nAdd explanations. Provide each line with //.\n\nMake sure to use \"→\" arrow. Indentation? Use indentation in virtual code? Use tab or spaces. The format example uses indentation for decisions. So we can indent for decision branches. Provide each line as separate line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: xor ← x XOR y // 計算兩個整數的 XOR，得到不同位元的 1\n→ Step 2: count ← 0 // 初始化不同位元數量\n→ Step 3: While xor > 0 // 當仍有位元未處理時\n    → Decision: xor AND 1 == 1? // 檢查最低位元是否為 1\n        Yes → count ← count + 1 // 若為 1，說明此位不同，計數器加 1\n        No  → // 無需做事\n    → xor ← xor >> 1 // 右移一位，移除已處理的最低位元\n→ Step 4: Return count // 回傳最終 Hamming 距離\nEnd // 程式執行結束\n\nBut we need each line to have arrow for steps. The decision block lines: use \"Decision:\" with indentation. The 'Yes →' and 'No →' lines should have arrows. Indentation: four spaces maybe.\n\nAlso, the \"No →\" line: we may leave blank after arrow? The example used \"No  → Decision:\" and there was a space after arrow. For No, we could use \"No  →\" with a comment. But it's fine to include comment that nothing to do.\n\nMake sure each line ends with \" // 說明\".\n\nWe need to not output real code. Should not use actual language syntax like \"<-\" or \"←\"? In virtual code, we can use arrow for assignment like \"=\" or \"←\". But it's virtual code; we can keep assignment with \"=\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: xor ← x XOR y // 計算兩個整數的 XOR，得到不同位元為 1 的位元組  \n→ Step 2: count ← 0 // 初始化不同位元的計數器  \n→ Step 3: While xor > 0 // 若仍有位元尚未處理  \n  → Decision: (xor AND 1) == 1? // 檢查最低位元是否為 1  \n   Yes → count ← count + 1 // 若是 1，表示此位不同，計數器加 1  \n   No  → // 無需做事  \n  → xor ← xor >> 1 // 右移一位，將已處理的最低位元丟棄  \n→ Step 4: Return count // 回傳最終 Hamming 距離  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_distance(x: int, y: int) -> int:\n    \"\"\"計算兩個整數之間的 Hamming 距離。\"\"\"\n    xor = x ^ y                     # XOR 取得不同位元\n    count = 0\n    while xor:\n        count += xor & 1            # 若最低位元為 1，計數器加 1\n        xor >>= 1                   # 右移 1 位，處理下一位\n    return count\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取資料，計算並輸出 Hamming 距離。\"\"\"\n    data = sys.stdin.read()                     # 讀取所有輸入\n    nums = re.findall(r'-?\\d+', data)           # 擷取所有整數\n    if len(nums) >= 2:\n        x, y = int(nums[0]), int(nums[1])       # 取得 x、y\n        result = hamming_distance(x, y)          # 計算距離\n        print(result)                           # 輸出結果\n    else:\n        # 如果無法解析，則直接輸出空行或錯誤訊息（可自行調整）\n        pass\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode754.json",
    "problem_index_in_file": 0,
    "title": "Reach a Number",
    "description_snippet": "You are standing at position 0 on an infinite number line. There is a destination at position target...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm to find minimal number of moves to reach target on infinite line where move i moves i steps left or right. Classic problem: minimal n such that sum 1..n >= |target| and parity matches (sum - target) even. Steps: compute target abs. iterate n sum accumulating until sum >= target and (sum-target)%2==0.\n\nWe'll produce virtual code lines with comments. Provide steps: Start, input target, compute abs, set n=0, sum=0, loop, n++, sum+=n, check conditions, if satisfied break, output n. End.\n\nAlso maybe decision step. Let's craft.\n\nUse arrow for each step: Start // etc.\n\nAlso incorporate decision blocks.\n\nLet's produce.\n\nNeed each line \"虛擬碼步驟 [space] // 解釋/說明\".\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取目標位置 target // 取得使用者輸入的目標座標  \n→ Step 2: 計算 absTarget ← |target| // 只考慮距離，方向可後續調整  \n→ Step 3: 初始化 n ← 0, sum ← 0 // n 為已使用的步數，sum 為已走總距離  \n→ Decision: sum 是否小於 absTarget? // 判斷是否已足夠覆蓋距離  \n    Yes → Step 4: n ← n + 1 // 執行下一次移動  \n    No  → End // 已達到或超過距離，跳出循環  \n→ Step 5: sum ← sum + n // 累加第 n 步的距離  \n→ Decision: (sum - absTarget) 是否為偶數? // 確認可否透過方向調整抵達 exact 目標  \n    Yes → End // 條件滿足，找到最小步數  \n    No  → 回到 Decision: sum 是否小於 absTarget? // 若不滿足則繼續加大步數  \nEnd // 輸出結果並結束程式（n 為最小移動次數）",
      "generated_code": "import sys\nimport re\n\ndef minimum_moves(target: int) -> int:\n    \"\"\"\n    計算最小移動次數，使在第 i 步可向左或右走 i 步，最後到達 target。\n    \"\"\"\n    target = abs(target)          # 只考慮距離\n    step = 0                      # 已使用的步數\n    total = 0                     # 已走總距離\n    # 當總距離小於目標或差值奇數時，繼續增加步數\n    while total < target or (total - target) % 2 != 0:\n        step += 1\n        total += step\n    return step\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 從輸入中提取第一個整數（允許負號）\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        raise ValueError(\"輸入中沒有找到有效的整數\")\n    target_value = int(match.group())\n    result = minimum_moves(target_value)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "target = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce virtual code for scheduling tasks with cooling period. Classic LeetCode 621. Approach: Count frequencies, find max freq, count how many tasks have that max, calculate idle slots. Formula: (maxFreq-1)*(n+1)+countMax. If total tasks > that, answer = total tasks. Steps: count frequencies, find max, count max tasks, compute part1, part2, result. Let's produce step-by-step pseudo.\n\nWe need Start, Steps with arrows, decisions, end. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols like →.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率表 frequency // 統計每個任務字母出現次數\n→ Step 2: maxFreq = 0, countMax = 0 // 初始化最大頻率與其出現數\n→ Decision: 對於每個 freq in frequency? // 遍歷頻率表\n    Yes → Decision: freq > maxFreq? // 判斷是否更高\n        Yes → maxFreq = freq; countMax = 1 // 更新最大頻率及計數\n        No  → Decision: freq == maxFreq? // 是否相同\n            Yes → countMax += 1 // 同一最大頻率任務數量累加\n            No  → Skip // 不變\n→ Step 3: part1 = (maxFreq - 1) * (n + 1) // 計算必備的間隔段\n→ Step 4: part2 = countMax // 這些最大頻率任務填充最後一段\n→ Step 5: idleSlots = part1 - countMax // 需要空閒的時間點\n→ Decision: idleSlots < 0? // 若無需空閒\n    Yes → idleSlots = 0 // 設為0\n→ Step 6: totalTasks = 任務總數 // 任務數量\n→ Step 7: result = idleSlots + totalTasks // 最小 CPU 間隔數\n→ Decision: result < totalTasks? // 若計算結果小於任務數\n    Yes → result = totalTasks // 用任務數作為最小值\n→ End // 程式結束\n\nBut we need more explicit: maybe use loops and decisions.\n\nLet's produce more structured: Step for counting, then decision loops. Use 'For each task in tasks'. Use Decision for max frequency update. Use Step for calculating idleSlots etc.\n\nAlso we need to mention part1, part2 names accordingly.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 frequency // 用來存每個任務字母的出現頻率\n→ For each task in tasks:\n    → Step 2: frequency[task] += 1 // 統計每個任務的頻率\n→ Step 3: maxFreq = 0; countMax = 0 // 初始化最大頻率與該頻率任務數量\n→ For each freq in frequency.values():\n    → Decision: freq > maxFreq? // 檢查是否為新的最大頻率\n        Yes → maxFreq = freq; countMax = 1 // 更新最大頻率並重設計數\n        No  → Decision: freq == maxFreq? // 檢查是否與現有最大頻率相同\n            Yes → countMax += 1 // 同一最大頻率的任務數量累加\n            No  → // 其它情況不變\n→ Step 4: part1 = (maxFreq - 1) * (n + 1) // 計算必備的間隔段數（含空閒）\n→ Step 5: idleSlots = part1 - countMax // 需要的空閒時間點\n→ Decision: idleSlots < 0? // 若計算結果為負數，表示不需要空閒\n    Yes → idleSlots = 0\n→ Step 6: totalTasks = len(tasks) // 任務總數\n→ Step 7: result = idleSlots + totalTasks // 最小 CPU 間隔數\n→ Decision: result < totalTasks? // 若計算結果小於實際任務數\n    Yes → result = totalTasks // 用任務數作為下限\n→ End // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"計算完成所有任務所需的最小 CPU 間隔數。\"\"\"\n    # 統計每個任務的出現頻率\n    freq = Counter(tasks)\n    # 找到最高頻率以及有多少個任務達到這個頻率\n    max_freq = max(freq.values())\n    max_count = sum(1 for cnt in freq.values() if cnt == max_freq)\n    # 先計算假設每個最頻任務之間都需要間隔的總間隔數\n    part1 = (max_freq - 1) * (n + 1)\n    # 空閒時間需要填充的空位\n    idle_slots = part1 - max_count\n    if idle_slots < 0:\n        idle_slots = 0\n    # 最終結果為空閒時間加上所有任務數\n    return idle_slots + len(tasks)\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析 tasks 與 n。\"\"\"\n    # 先嘗試使用正則式直接抓取 'tasks = [...] , n = ...'\n    pattern = r'tasks\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*n\\s*=\\s*(\\d+)'\n    m = re.search(pattern, data)\n    if m:\n        tasks_str, n_str = m.group(1), m.group(2)\n        tasks = eval(tasks_str)          # 解析為列表\n        n = int(n_str)\n        return tasks, n\n\n    # 若上述失敗，嘗試每行一項\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        tasks = eval(lines[0])           # 第一行為 tasks 列表\n        n = int(lines[1])                # 第二行為 n\n        return tasks, n\n\n    raise ValueError(\"輸入格式不符合預期\")\n\ndef main():\n    data = sys.stdin.read()\n    tasks, n = parse_input(data)\n    result = least_interval(tasks, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '10'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '10'"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '12'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation for simplified Twitter. Provide steps: initialize data structures: map of user to set of followees, map user to list of tweets (tweetId with timestamp). maintain global timestamp increment. Methods accordingly.\n\nWe need each line as \"虛擬碼步驟 // 解釋\". Use arrows. Provide stepwise. For each method, we should list steps. Use Start End blocks for class initialization? The example shows Start/End for program but here we can use Start for class construction, and End for class? Probably use Start for Twitter() initialization. For methods, we can include a header and then steps.\n\nWe need to produce line by line pseudocode. Let's format:\n\nStart // 程式開始執行 (or for class)\n\nBut likely they want pseudocode for the class definition, then methods.\n\nLet's produce:\n\nStart // Twitter 類別初始化\n\n→ Step 1: 建立 userFollowMap: Map<int, Set<int>> // 用於儲存每個使用者的追蹤關係\n\n→ Step 2: 建立 userTweetMap: Map<int, List<Tweet>> // 每個使用者的 tweet 列表\n\n→ Step 3: 建立全域時間戳 timestamp = 0 // 用於排序 tweet\n\nEnd // Twitter 物件建立完成\n\nThen for postTweet:\n\n→ Step 1: 增加 timestamp++ // 取得新的時間戳\n\n→ Step 2: 建立 Tweet 物件 (id: tweetId, time: timestamp)\n\n→ Step 3: 若 userTweetMap 中沒有 userId，則新增空 list\n\n→ Step 4: 將 Tweet 加入 userTweetMap[userId] // 追加到尾端\n\nSimilarly for follow/unfollow.\n\nFor getNewsFeed:\n\nNeed to collect tweets from user and followees, then get top 10 by timestamp.\n\nSimplify: maintain min-heap of size 10.\n\nWe'll produce steps accordingly.\n\nLet's produce pseudocode lines.\n\nMake sure each line uses \"→\" arrow or \"Yes →\" etc.\n\nUse \"Decision:\" for conditional.\n\nLet's start.\n\nWe should avoid actual code. Just pseudocode steps.\n\nWe'll produce:\n\nStart // Twitter 初始化\n→ Step 1: userFollowMap ← new Map // key: userId, value: Set of followeeIds\n→ Step 2: userTweetMap ← new Map // key: userId, value: List of tweets\n→ Step 3: timestamp ← 0 // 全域時間戳\nEnd // Twitter 物件建立完成\n\nThen methods.\n\nMethod: postTweet(userId, tweetId)\n\n→ Step 1: timestamp ← timestamp + 1 // 產生遞增時間戳\n→ Step 2: tweet ← (tweetId, timestamp) // 建立 tweet 物件\n→ Step 3: 若 userTweetMap 不包含 userId，則 userTweetMap[userId] ← new List // 初始化\n→ Step 4: userTweetMap[userId].append(tweet) // 加入使用者的 tweet 列表\n→ Step 5: 完成 // tweet 已發布\n\nMethod: follow(followerId, followeeId)\n\n→ Step 1: 若 userFollowMap 不包含 followerId，則 userFollowMap[followerId] ← new Set // 初始化\n→ Step 2: userFollowMap[followerId].add(followeeId) // 加入追蹤者\n→ Step 3: 完成 // 追蹤關係建立\n\nMethod: unfollow(followerId, followeeId)\n\n→ Step 1: 若 userFollowMap 包含 followerId，且 userFollowMap[followerId] 包含 followeeId，則\n    Yes → userFollowMap[followerId].remove(followeeId) // 移除追蹤者\n    No  → // 不做任何事 // 若不存在，忽略\n→ Step 2: 完成 // 追蹤關係解除\n\nMethod: getNewsFeed(userId)\n\n→ Step 1: feedCandidates ← new MinHeap(size=10, key=timestamp) // 儲存前 10 最新 tweet\n→ Step 2: 取得 followees ← userFollowMap.get(userId) or empty set\n→ Step 3: 來源集合 ← followees ∪ {userId} // 包括自己\n→ Step 4: 對於 每個 uid in 來源集合:\n            → 若 userTweetMap 包含 uid，則\n                → 對於 每個 tweet in userTweetMap[uid]:\n                    → 若 feedCandidates.size < 10，則 feedCandidates.insert(tweet)\n                    → 否則若 tweet.timestamp > feedCandidates.min().timestamp，則\n                        Yes → feedCandidates.removeMin()\n                        Yes → feedCandidates.insert(tweet)\n→ Step 5: result ← empty List\n→ Step 6: 當 feedCandidates 非空時，取出最大元素並插入 result 前面 // 使結果由新到舊\n→ Step 7: 返回 result // 10 近期 tweetId\n\nBut need to convert to simple pseudocode steps.\n\nMaybe we can combine steps.\n\nLet's produce final output with each line accordingly.\n\nMake sure to include arrows and explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // Twitter 物件初始化\n→ Step 1: 建立 userFollowMap ← Map<int, Set<int>> // 用來儲存每個使用者追蹤的使用者集合\n→ Step 2: 建立 userTweetMap ← Map<int, List<Tweet>> // 用來儲存每個使用者的推文列表\n→ Step 3: 設定 timestamp ← 0 // 全域時間戳，用於排序推文\nEnd // Twitter 物件建立完成\n\n//-------------------------------------\n// 方法: postTweet(userId, tweetId)\nStart // postTweet 開始\n→ Step 1: timestamp ← timestamp + 1 // 產生新的遞增時間戳\n→ Step 2: tweet ← (tweetId, timestamp) // 建立推文物件\n→ Step 3: 若 userTweetMap 不包含 userId，則 userTweetMap[userId] ← new List<Tweet> // 初始化使用者推文列表\n→ Step 4: userTweetMap[userId].append(tweet) // 將推文加入列表\nEnd // 推文發布完成\n\n//-------------------------------------\n// 方法: follow(followerId, followeeId)\nStart // follow 開始\n→ Step 1: 若 userFollowMap 不包含 followerId，則 userFollowMap[followerId] ← new Set<int> // 初始化追蹤集合\n→ Step 2: userFollowMap[followerId].add(followeeId) // 加入追蹤對象\nEnd // 追蹤關係建立完成\n\n//-------------------------------------\n// 方法: unfollow(followerId, followeeId)\nStart // unfollow 開始\n→ Decision: 是否 userFollowMap 包含 followerId? // 檢查是否已存在追蹤集合\n    Yes → Decision: followerId 的集合中是否包含 followeeId? // 確認要解除的對象是否在集合內\n        Yes → userFollowMap[followerId].remove(followeeId) // 移除追蹤對象\n        No  → // 不做任何事 // 若不存在，忽略\n    No  → // 不做任何事 // 若整個追蹤集合不存在，忽略\nEnd // 追蹤關係解除完成\n\n//-------------------------------------\n// 方法: getNewsFeed(userId)\nStart // getNewsFeed 開始\n→ Step 1: feedCandidates ← MinHeap< (timestamp, tweetId) > (maxSize=10) // 儲存 10 個最新推文\n→ Step 2: followees ← userFollowMap.get(userId) 或 {} // 取得追蹤集合\n→ Step 3: 來源集合 ← followees ∪ {userId} // 包含自己與所有追蹤對象\n→ Decision: 是否 來源集合 非空? // 檢查是否有可讀取的推文來源\n    Yes →\n        → For 每個 uid in 來源集合:\n            → Decision: userTweetMap 包含 uid? // 確認該使用者是否有推文\n                Yes →\n                    → For 每個 tweet in userTweetMap[uid]:\n                        → Decision: feedCandidates.size < 10? // 是否尚未滿 10 個\n                            Yes → feedCandidates.insert(tweet) // 直接加入\n                            No  → Decision: tweet.timestamp > feedCandidates.peekMin().timestamp? // 與目前最小時間戳比較\n                                Yes → feedCandidates.removeMin(); feedCandidates.insert(tweet) // 交換\n                                No  → // 留下較舊的推文\n                No → // 無推文，跳過\n    No  → // 若沒有任何來源，直接返回空列表\n→ Step 4: result ← empty List<int> // 用於儲存最終新聞推文 ID\n→ Step 5: While feedCandidates 非空:\n            → tmp ← feedCandidates.removeMax() // 取出最新時間戳的推文\n            → result.prepend(tmp.tweetId) // 依時間倒序加入結果\n→ Step 6: return result // 返回最多 10 個推文 ID\nEnd // getNewsFeed 完成",
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)          # userId -> list of (timestamp, tweetId)\n        self.following = defaultdict(set)        # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n\n    def getNewsFeed(self, userId: int):\n        if userId not in self.tweets and userId not in self.following:\n            return []\n\n        # Include the user themselves in the feed sources\n        sources = set(self.following[userId]) if userId in self.following else set()\n        sources.add(userId)\n\n        heap = []  # max-heap using negative timestamp\n        for uid in sources:\n            tws = self.tweets.get(uid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, uid, idx))\n\n        res = []\n        while heap and len(res) < 10:\n            negtime, tid, uid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                prev_time, prev_id = self.tweets[uid][idx - 1]\n                heapq.heappush(heap, (-prev_time, prev_id, uid, idx - 1))\n\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:\n            self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:\n            self.following[followerId].discard(followeeId)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Convert input string to two lists (methods, arguments)\n    methods, args = ast.literal_eval(f'({data})')\n\n    twitter = None\n    results = []\n\n    for m, a in zip(methods, args):\n        if m == \"Twitter\":\n            twitter = Twitter()\n            results.append(None)\n        elif m == \"postTweet\":\n            twitter.postTweet(a[0], a[1])\n            results.append(None)\n        elif m == \"getNewsFeed\":\n            res = twitter.getNewsFeed(a[0])\n            results.append(res)\n        elif m == \"follow\":\n            twitter.follow(a[0], a[1])\n            results.append(None)\n        elif m == \"unfollow\":\n            twitter.unfollow(a[0], a[1])\n            results.append(None)\n        else:\n            # Unknown method; skip or raise error\n            results.append(None)\n\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": true,
          "output": "[null, null, [5], null, null, [6, 5], null, [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode670.json",
    "problem_index_in_file": 0,
    "title": "Maximum Swap",
    "description_snippet": "You are given an integer num. You can swap two digits at most once to get the maximum valued number....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: Given integer num, can swap two digits at most once to maximize value. Return max number. Should provide steps line by line with arrow, explanation. Should not produce actual code. Should produce logic steps. Use Start, End, Decision, etc. Need to include the steps for converting num to string, scanning digits to find best swap. Implementation: find max digit to the right of each position? Actually common approach: find leftmost digit that can be swapped with a larger digit to the right, choose rightmost largest digit. Steps: convert num to list of digits, find best positions. Implementation: For i from 0 to n-2: find j from n-1 down to i+1: if digits[j] > digits[i] then choose max digit? Standard algorithm: find the rightmost maximum digit greater than current digit. Keep track of best i and j. After loop, if best swap found, swap. Return number. Also consider if no swap. Also handle negative? Not needed. We'll produce steps accordingly.\n\nNeed to output each line with arrow arrow? Format uses \"→ Step ...\" for steps. For decisions we use \"Decision: ...\". Indentation for nested decisions. Use Start, End. We'll produce pseudo-code. Should be in Chinese. Use explanation comment after //.\n\nLet's produce steps:\n\nStart\n→ Step 1: 將 num 轉成字元陣列 digits // 方便逐位處理\n→ Step 2: 初始化 best_i, best_j 為 -1 // 以標示尚未找到交換位置\n→ Decision: 整數長度 > 1? // 若只有一位，無法交換\n    Yes →\n        → Step 3: 從左至右遍歷每個位 i\n            → Step 4: 在 i 右側尋找最大數字 max_digit 與其最右端位置 pos // 避免選取左側同值\n            → Decision: max_digit > digits[i]? // 是否有更大數字可交換\n                Yes →\n                    → Step 5: 設定 best_i = i, best_j = pos // 記錄最佳交換\n                No →\n                    → Step 6: 進入下一個 i\n        → Decision: best_i == -1? // 是否找到可交換\n            Yes →\n                → Step 7: 直接返回原 num // 無法提升\n            No →\n                → Step 8: 交換 digits[best_i] 與 digits[best_j] // 執行一次交換\n                → Step 9: 重新組合 digits 為字串後轉回整數 // 取得最大值\n→ Decision: 整數長度 <= 1? // 只一位\n    Yes →\n        → Step 10: 直接返回原 num\nEnd\n\nWe need to ensure proper indentation. Use arrow for steps. For decisions, indent Yes/No branches with 4 spaces? They use 4 spaces indentation in example. So after Decision, indent Yes → etc.\n\nAlso include explanation comments for each line.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 num 轉成字元陣列 digits // 方便逐位處理\n→ Step 2: 初始化 best_i, best_j 為 -1 // 以標示尚未找到交換位置\n→ Decision: 整數長度 > 1? // 若只有一位，無法交換\n    Yes →\n        → Step 3: 從左至右遍歷每個位 i // 逐個檢查是否能交換\n            → Step 4: 在 i 右側尋找最大數字 max_digit 與其最右端位置 pos // 取得右側最大的數字\n            → Decision: max_digit > digits[i]? // 是否有更大數字可交換\n                Yes →\n                    → Step 5: 設定 best_i = i, best_j = pos // 記錄最佳交換位置\n                No →\n                    → Step 6: 進入下一個 i // 沒有更大數字，繼續往右\n        → Decision: best_i == -1? // 是否找到可交換\n            Yes →\n                → Step 7: 直接返回原 num // 無法提升\n            No →\n                → Step 8: 交換 digits[best_i] 與 digits[best_j] // 執行一次交換\n                → Step 9: 重新組合 digits 為字串後轉回整數 // 取得最大值\n    No →\n        → Step 10: 直接返回原 num // 只一位，無需交換\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maximumSwap(self, num: int) -> int:\n        \"\"\"Return the maximum number obtainable by swapping two digits at most once.\"\"\"\n        digits = list(str(num))\n        # Record the last index of each digit (0-9)\n        last_pos = {int(d): i for i, d in enumerate(digits)}\n        for i, d in enumerate(digits):\n            current = int(d)\n            # Search for a larger digit to swap with, starting from 9 down to current+1\n            for larger in range(9, current, -1):\n                if larger in last_pos and last_pos[larger] > i:\n                    # Perform the swap\n                    j = last_pos[larger]\n                    digits[i], digits[j] = digits[j], digits[i]\n                    return int(''.join(digits))\n        # No swap improves the number\n        return int(''.join(digits))\n\ndef main() -> None:\n    \"\"\"Read input, compute maximum swap, and print the result.\"\"\"\n    data = sys.stdin.read().strip()\n    # Extract the first integer found in the input (handles formats like 'num = 2736')\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        return\n    num = int(numbers[0])\n    solution = Solution()\n    print(solution.maximumSwap(num))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 2736",
          "expected_output": "7236",
          "success": true,
          "output": "7236"
        },
        {
          "example_index": 1,
          "input": "num = 9973",
          "expected_output": "9973",
          "success": true,
          "output": "9973"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the class definition and methods. We have to use virtual code style. Each line must have \"虛擬碼步驟\" + space + \"// 解釋\". Use Start, End, Decision, Yes →, No →. For class definition, we can do Start, then Step: Define class NumArray, Step: Constructor, Step: sumRange method. Also need to handle prefix sum array. We can outline steps: store nums, build prefixSum array; sumRange uses prefixSum[right+1] - prefixSum[left].\n\nWe'll produce virtual code lines.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 建立 NumArray 類別\n→ Step 2: 內部變數 prefixSum ← 空陣列 // 用於存儲前綴和\n→ Step 3: Constructor(nums) // 初始化，接收原始陣列\n    → Step 3a: prefixSum[0] ← 0 // 前綴和初始值\n    → Step 3b: For i from 0 to nums.length-1\n        → Step 3b1: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n→ Step 4: sumRange(left, right) // 計算區間和\n    → Step 4a: result ← prefixSum[right+1] - prefixSum[left] // 区间和公式\n    → Step 4b: Return result // 回傳結果\nEnd // 程式執行結束\n\nBut we must follow exact format: each line \"虛擬碼步驟 // 解釋\". Also we need arrow formatting: \"→\" preceding each step. For nested steps we can indent? But we just produce separate lines, using indentation maybe but not required. Use \"→ Step X:\" for each step.\n\nAlso for Decision we don't need Decision. But we can show loop as a Decision? Not necessary. The requirement says use arrow and structure (Start, End, Decision). So we can use loops as steps, no decision needed.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 建立 NumArray 類別\n→ Step 2: 定義私有變數 prefixSum: 整數陣列 // 存前綴和\n→ Step 3: Constructor(nums) // 接收原始數組並初始化\n    → Step 3a: prefixSum[0] ← 0 // 前綴和起始值\n    → Step 3b: For i = 0 to nums.length - 1\n        → Step 3b1: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n→ Step 4: sumRange(left, right) // 回傳區間和\n    → Step 4a: sum ← prefixSum[right+1] - prefixSum[left] // 区间和公式\n    → Step 4b: Return sum // 返回結果\nEnd // 程式執行結束\n\nWe must keep each line separate. We can indent nested steps but still each line separate. Provide \"Step 3b\" maybe not needed; we can just show steps sequentially.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NumArray // 建立 NumArray 類別\n→ Step 2: 定義私有變數 prefixSum: 整數陣列 // 存前綴和\n→ Step 3: Constructor(nums) // 接收原始數組並初始化\n    → Step 3a: prefixSum[0] ← 0 // 前綴和起始值\n    → Step 3b: For i = 0 to nums.length - 1\n        → Step 3b1: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n→ Step 4: sumRange(left, right) // 回傳區間和\n    → Step 4a: sum ← prefixSum[right+1] - prefixSum[left] // 区间和公式\n    → Step 4b: Return sum // 返回結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    commands, arguments = json.loads(input_data)\n    instance = None\n    results = []\n\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"NumArray\":\n            instance = NumArray(args[0])\n            results.append(None)\n        elif cmd == \"sumRange\":\n            results.append(instance.sumRange(*args))\n        else:\n            # 任何未定義的命令直接忽略\n            results.append(None)\n\n    # 使用 json.dumps 以確保 None 轉成 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp6_8nnbi1.py\", line 20, in <module>\n    commands, arguments = json.loads(input_data)\n                          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code (like flowchart) for removing duplicates in sorted array so each element appears at most twice. Must be in-place, O(1) memory, return k. Need to output in required format: each line: \"虛擬碼步驟 // 解釋\". Use arrows and decision etc. Provide step-by-step algorithm. Let's produce:\n\nStart\n→ Initialize writeIndex = 0 // index to write new element\n→ For readIndex from 0 to len(nums)-1: // iterate through array\n    → Decision: If writeIndex < 2? // For first two elements always write\n        Yes → nums[writeIndex] = nums[readIndex]\n        No  → Decision: nums[readIndex] == nums[writeIndex-1] AND nums[readIndex] == nums[writeIndex-2]?\n                Yes → Skip this element (do nothing)\n                No  → nums[writeIndex] = nums[readIndex]\n        After write, increment writeIndex if wrote\nEnd\n→ Return writeIndex // number of elements kept\n\nBut need to put virtual code lines sequentially. We must use arrow and decisions. Each line: \"Start\" etc. Use \"→\" for steps. Use Decision lines.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: writeIndex ← 0 // 初始化寫入指標\n→ Step 2: readIndex ← 0 // 初始化讀取指標\n→ Decision: readIndex < len(nums)？ // 是否還有元素要處理\n    Yes →\n        → Decision: writeIndex < 2？ // 前兩個元素直接寫入\n            Yes →\n                → nums[writeIndex] ← nums[readIndex] // 把當前元素寫入\n                → writeIndex ← writeIndex + 1 // 更新寫入位置\n            No →\n                → Decision: nums[readIndex] == nums[writeIndex-1] AND nums[readIndex] == nums[writeIndex-2]？ // 是否已出現兩次\n                    Yes →\n                        // 跳過此重複元素\n                    No →\n                        → nums[writeIndex] ← nums[readIndex] // 寫入元素\n                        → writeIndex ← writeIndex + 1\n        → readIndex ← readIndex + 1 // 移動到下一個元素\n    No →\n        // 迴圈結束\nEnd // 程式執行結束\n→ Step 3: Return writeIndex // 返回保留元素個數\n\nNeed to ensure each line includes the code step and comment. But we must maintain the structure: Use \"Decision:\" and \"Yes →\" \"No →\" etc. Each line should be separate. Use \"→\" for steps. Use nested decisions. For nested decisions, we indent? In example, they used indentation. Let's follow.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Step 1: writeIndex ← 0 // 初始化寫入指標\n→ Step 2: readIndex ← 0 // 初始化讀取指標\n→ Decision: readIndex < len(nums)？ // 是否還有元素可處理\n    Yes →\n        → Decision: writeIndex < 2？ // 前兩個元素直接寫入\n            Yes →\n                → nums[writeIndex] ← nums[readIndex] // 將元素寫入\n                → writeIndex ← writeIndex + 1 // 更新寫入位置\n            No →\n                → Decision: nums[readIndex] == nums[writeIndex-1] AND nums[readIndex] == nums[writeIndex-2]？ // 是否已出現兩次\n                    Yes →\n                        // 跳過重複\n                    No →\n                        → nums[writeIndex] ← nums[readIndex] // 寫入元素\n                        → writeIndex ← writeIndex + 1\n        → readIndex ← readIndex + 1 // 前進讀取指標\n    No →\n        // 完成迴圈\nEnd // 程式執行結束\n→ Step 3: Return writeIndex // 返回結果長度\n\nEnsure each line ends with comment after //.\n\nNeed to make sure each line has \"虛擬碼步驟\" and comment. Provide arrow for steps.\n\nWe'll output exactly as above.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIndex ← 0 // 初始化寫入指標  \n→ Step 2: readIndex ← 0 // 初始化讀取指標  \n→ Decision: readIndex < len(nums)？ // 是否還有元素可處理  \n  Yes →  \n   → Decision: writeIndex < 2？ // 前兩個元素直接寫入  \n    Yes →  \n     → nums[writeIndex] ← nums[readIndex] // 將元素寫入  \n     → writeIndex ← writeIndex + 1 // 更新寫入位置  \n    No →  \n     → Decision: nums[readIndex] == nums[writeIndex-1] AND nums[readIndex] == nums[writeIndex-2]？ // 是否已出現兩次  \n      Yes →  \n       // 跳過此重複元素  \n      No →  \n       → nums[writeIndex] ← nums[readIndex] // 寫入元素  \n       → writeIndex ← writeIndex + 1  \n       // 完成寫入",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        k = 1          # index to write next valid element\n        count = 1      # count of current number occurrences\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                count = 1\n            if count <= 2:\n                nums[k] = nums[i]\n                k += 1\n        return k\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the list representation from input like \"nums = [1,1,1,2,2,3]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        try:\n            nums = ast.literal_eval(data)\n        except Exception:\n            nums = []\n    else:\n        nums_str = data[start:end + 1]\n        nums = ast.literal_eval(nums_str)\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # Build output string with underscores for unused positions\n    out = f\"{k}, nums = [\"\n    for i in range(len(nums)):\n        if i < k:\n            out += str(nums[i])\n        else:\n            out += \"_\"\n        if i != len(nums) - 1:\n            out += \",\"\n    out += \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": true,
          "output": "5, nums = [1,1,2,2,3,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": true,
          "output": "7, nums = [0,0,1,1,2,3,3,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\", decisions with Yes → No →. Start End. Must not output real code. Use Vietnamese? No, Chinese.\n\nWe need to produce algorithm for integer division without *, /, %. Classic bit shifting algorithm. Steps: handle sign, convert to absolute, use bit shifting to subtract. Clip to 32-bit. Use while loop etc. Virtual code.\n\nMake sure each line has explanation. Use arrow. Let's produce.\n\nStructure:\n\nStart\n→ Step 1: 判斷兩數符號並記錄結果 // 取得正負符號\n→ Step 2: 轉為正整數（取絕對值） // 方便位移運算\n→ Step 3: 初始化 quotient = 0\n→ Step 4: Decision: dividend >= divisor? // 若餘數足夠，進行除法\n   Yes → Step 5: 找到最高位移值\n       → Step 6: Decision: (divisor << shift) <= dividend? // 判斷能否減\n           Yes → Step 7: dividend -= divisor << shift // 減去\n                  → Step 8: quotient += 1 << shift // 加回商\n                  → Step 9: 再次回到 Step 4 // 重新檢查餘數\n           No → Step 10: shift -= 1 // 位移縮小\n           // After loop break when shift < 0\n   No → // 結束迴圈\n→ Step 11: Decision: 符號為負? // 取負\n   Yes → Step 12: quotient = -quotient\n→ Step 13: Decision: quotient > INT_MAX? // 上限檢查\n   Yes → Step 14: return INT_MAX\n   No → Step 15: Decision: quotient < INT_MIN? // 下限檢查\n      Yes → Step 16: return INT_MIN\n      No → Step 17: return quotient\nEnd\n\nNeed to use virtual arrow style. Also include \"Start\" and \"End\". Each line should have // explanation. Provide arrows and decisions.\n\nLet's format with each line starting with \"Start\" etc. Use \"→\". For Decision use indentation? In example they indent Yes → ... No → ... We can produce as such. Ensure each line has explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 確定結果符號 (isNegative = (dividend < 0) XOR (divisor < 0)) // 取得最終商的正負  \n→ Step 2: 取絕對值 dividendAbs = abs(dividend) , divisorAbs = abs(divisor) // 方便後續位移操作  \n→ Step 3: 初始化 quotient = 0 // 商的暫存值  \n→ Step 4: Decision: dividendAbs >= divisorAbs? // 判斷是否還有足夠餘數可除  \n  Yes → Step 5: 計算最高位移 shift = 0  \n   → Step 6: Decision: (divisorAbs << shift) <= dividendAbs? // 判斷能否一次減去  \n    Yes → Step 7: dividendAbs -= divisorAbs << shift // 減去對應位移的除數  \n     → Step 8: quotient += 1 << shift // 把相應位移加到商  \n     → Step 9: 回到 Step 4 // 重新檢查餘數是否仍可除  \n    No → Step 10: shift -= 1 // 將位移縮小再試一次",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def divide(self, dividend, divisor):\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        # 特殊情況：-2^31 除以 -1 會溢位\n        if dividend == -2**31 and divisor == -1:\n            return INT_MAX\n\n        # 判斷最終結果是否為負數\n        negative = (dividend < 0) != (divisor < 0)\n\n        # 轉成正整數進行計算\n        dividend_abs = abs(dividend)\n        divisor_abs = abs(divisor)\n\n        quotient = 0\n\n        # 逐位移減法，類似位移法除法\n        while dividend_abs >= divisor_abs:\n            temp = divisor_abs\n            multiple = 1\n            # 找到最大的 2^k 倍\n            while dividend_abs >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            dividend_abs -= temp\n            quotient += multiple\n\n        # 若結果為負則取相反數\n        if negative:\n            quotient = -quotient\n\n        # 限制在 32 位整數範圍內\n        if quotient > INT_MAX:\n            return INT_MAX\n        if quotient < INT_MIN:\n            return INT_MIN\n        return quotient\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) >= 2:\n        dividend = int(nums[0])\n        divisor = int(nums[1])\n        sol = Solution()\n        result = sol.divide(dividend, divisor)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving word pattern problem. Each line: \"虛擬碼步驟\" + space + \"// 解釋\". Use Start, End, Decision: etc. Need to produce line by line pseudocode, not actual code. Provide explanation for each line. We'll include variable names like pattern, s, words, mapping, set. Steps: split s into words list, check length mismatch, mapping dict, used set. Iterate over pattern and words. Decision if mapping contains char: check same word else mapping new, check if word already used. If conflict then return false. After loop return true. End. Use arrow \"→\". Provide explanation comments.\n\nLet's construct.\n\nStart\n→ Step 1: words ← split s by spaces // 把字串分割成單詞陣列\n→ Decision: if length(words) ≠ length(pattern) → End with false // 長度不同則不符合模式\n→ Step 2: map ← empty dictionary // 建立字母到單詞的對應表\n→ Step 3: used ← empty set // 追蹤已被映射的單詞\n→ Decision: for i in 0..length(pattern)-1 → // 逐一檢查每個字母與單詞\n    letter ← pattern[i] // 取 pattern 的第 i 個字母\n    word ← words[i] // 取 words 的第 i 個單詞\n    → Decision: if letter in map → // 已經有映射\n        Yes → Decision: if map[letter] ≠ word → // 映射不一致\n            Yes → End with false // 同一字母映射到不同單詞\n            No → // 繼續\n        No → Decision: if word in used → // 該單詞已被其他字母映射\n            Yes → End with false // 兩個字母映射到同一單詞\n            No → map[letter] ← word ; used ← used ∪ {word} // 新增映射\n→ Step 4: End with true // 所有檢查通過，符合模式\nEnd\n\nWe need to format each line as \"虛擬碼步驟 // 解釋\". Also use arrows. Use \"→\" to indent.\n\nMake sure each line includes arrow and comment. Eg:\n\nStart // 程式開始執行\n\n→ Step 1: words ← split s by spaces // 把字串分割成單詞陣列\n\n...\n\nNeed to include Decision: lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: words ← split s by spaces // 把字串分割成單詞陣列  \n→ Decision: 如果 length(words) ≠ length(pattern) → // 長度不同則不符合模式  \n Yes → End with false // 直接結束並返回 false  \n→ Step 2: map ← empty dictionary // 建立字母到單詞的對應表  \n→ Step 3: used ← empty set // 追蹤已被映射的單詞  \n→ Decision: for i in 0..length(pattern)-1 → // 逐一檢查每個字母與單詞  \n  letter ← pattern[i] // 取 pattern 的第 i 個字母  \n  word ← words[i] // 取 words 的第 i 個單詞  \n  Decision: 如果 letter 在 map 中? → // 已經有映射  \n   Yes → Decision: 如果 map[letter] ≠ word? → // 映射不一致  \n    Yes → End with false // 同一字母映射到不同單詞  \n    No → // 繼續下一個  \n   No → Decision: 如果 word 在 used 中? → // 該單詞已被其他字母映射  \n    Yes → End with false // 兩個字母映射到同一單詞  \n    No → map[letter] ← word ; used ← used ∪ {word} // 新增映射  \n→ Step 4: End with true // 所有檢查通過，符合模式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef word_pattern(pattern: str, s: str) -> bool:\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_to_word = {}\n    word_to_char = {}\n\n    for c, w in zip(pattern, words):\n        if c in char_to_word:\n            if char_to_word[c] != w:\n                return False\n        else:\n            char_to_word[c] = w\n\n        if w in word_to_char:\n            if word_to_char[w] != c:\n                return False\n        else:\n            word_to_char[w] = c\n\n    return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Expected format: pattern = \"abba\", s = \"dog cat cat dog\"\n    match = re.search(r'pattern\\s*=\\s*\"([^\"]*)\",\\s*s\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        pattern_str = match.group(1)\n        s_str = match.group(2)\n    else:\n        # Fallback: split by spaces if format differs\n        parts = data.split()\n        pattern_str = parts[1] if len(parts) > 1 else \"\"\n        s_str = \" \".join(parts[2:]) if len(parts) > 2 else \"\"\n\n    result = word_pattern(pattern_str, s_str)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode581.json",
    "problem_index_in_file": 0,
    "title": "Shortest Unsorted Continuous Subarray",
    "description_snippet": "Given an integer array nums, you need to find one continuous subarray such that if you only sort thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps to solve: find shortest continuous subarray that if sorted will make entire array sorted. This is a known problem: find left and right boundaries where array deviates. Approach: find first element from left where arr[i] > minRight, find last from right where arr[i] < maxLeft. Use monotonic stack? But typical solution: compute min of suffix, max of prefix. Or using stack. We'll produce steps.\n\nWe need to output line by line: virtual code step + explanation. Use arrow notation.\n\nLet's craft steps:\n\nStart\n→ Step 1: Read array nums // get input\n→ Step 2: Initialize n = length(nums) // length\n→ Step 3: Find max prefix array // compute max up to i\n→ Step 4: Find min suffix array // compute min from i to end\n→ Step 5: Initialize left = n, right = -1 // bounds\n→ Step 6: For i in 0..n-1:\n    If nums[i] > min_suffix[i+1] then right = i // subarray end\n→ Step 7: For i in n-1..0:\n    If nums[i] < max_prefix[i-1] then left = i // subarray start\n→ Step 8: If left > right then return 0 // already sorted\n→ Step 9: Return right - left + 1 // length\n\nNeed to handle edges: min_suffix[n] set INF, max_prefix[-1] set -INF. We'll use sentinel.\n\nWe'll produce pseudocode lines with arrows. Also include Decision lines for left > right.\n\nLet's produce step by step.\n\nWe need \"虛擬碼步驟\" line with arrow. Use `Start` and `End`.\n\nWe'll use indentation for sub-steps. Use arrow `→`.\n\nMake sure each line ends with `// 解釋`.\n\nLet's produce:\n\nStart\n→ Step 1: nums = inputArray // 取得輸入陣列\n→ Step 2: n = length(nums) // 取得陣列長度\n→ Step 3: maxPrefix = array of size n // 儲存前綴最大值\n→ Decision: if n == 0? // 判斷陣列是否為空\n    Yes → End // 空陣列不需要處理，結束\n    No  →\n        → Step 4: maxPrefix[0] = nums[0] // 前綴第一個最大值為自身\n        → Step 5: For i = 1 to n-1:\n            → Step 5.1: maxPrefix[i] = max(maxPrefix[i-1], nums[i]) // 更新前綴最大值\n→ Step 6: minSuffix = array of size n+1 // 儲存後綴最小值，額外一個位置\n→ Step 7: minSuffix[n] = +∞ // 後綴最小值的終端為無限大\n→ Step 8: For i = n-1 downto 0:\n    → Step 8.1: minSuffix[i] = min(minSuffix[i+1], nums[i]) // 更新後綴最小值\n→ Step 9: left = n // 初始化左界\n→ Step 10: right = -1 // 初始化右界\n→ Step 11: For i = 0 to n-1:\n    → Decision: if nums[i] > minSuffix[i+1]? // 此位置大於後綴最小值\n        Yes → right = i // 設定右界為最右側\n        No  → // 不中斷\n→ Step 12: For i = n-1 downto 0:\n    → Decision: if nums[i] < maxPrefix[i-1]? // 此位置小於前綴最大值\n        Yes → left = i // 設定左界為最左側\n        No  → //\n→ Decision: if left > right? // 右界未更新，陣列已經排序\n    Yes → Result = 0\n    No  → Result = right - left + 1\n→ End // 輸出結果\n\nBut each line should be separate. Need to avoid too many sub-steps? Might keep all sub-steps as separate lines too.\n\nBut each step is a line. For loops, we can express as step with nested lines.\n\nBetter to keep simple lines. Provide sub-steps using indentation but still each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums = inputArray // 取得輸入陣列  \n→ Step 2: n = length(nums) // 取得陣列長度  \n\n→ Step 3: maxPrefix = array of size n // 儲存前綴最大值  \n→ Step 4: maxPrefix[0] = nums[0] // 前綴第一個最大值為自身  \n→ Step 5: For i = 1 to n-1: // 迭代計算前綴最大值  \n  → Step 5.1: maxPrefix[i] = max(maxPrefix[i-1], nums[i]) // 更新前綴最大值  \n\n→ Step 6: minSuffix = array of size n+1 // 儲存後綴最小值，額外一個位置  \n→ Step 7: minSuffix[n] = +∞ // 後綴最小值的終端為無限大  \n→ Step 8: For i = n-1 downto 0: // 迭代計算後綴最小值  \n  → Step 8.1: minSuffix[i] = min(minSuffix[i+1], nums[i]) // 更新後綴最小值  \n\n→ Step 9: left = n // 初始化左界為陣列外  \n→ Step 10: right = -1 // 初始化右界為陣列外  \n\n→ Step 11: For i = 0 to n-1: // 找右界  \n  → Decision: if nums[i] > minSuffix[i+1]? // 若此位置大於後綴最小值  \n    Yes → right = i // 右界設為最右側  \n    No  → // 仍繼續迭代  \n\n→ Step 12: For i = n-1 downto 0: // 找左界  \n  → Decision: if nums[i] < maxPrefix[i-1]? // 若此位置小於前綴最大值  \n    Yes → left = i // 左界設為最左側  \n    No  → // 仍繼續迭代  \n\n→ Decision: if left > right? // 右界未更新，陣列已經排序  \n  Yes → Result = 0 // 不需要任何子陣列  \n  No  → Result = right - left + 1 // 子陣列長度  \n\nEnd // 程式執行結束（輸出 Result）",
      "generated_code": "import sys\n\ndef find_unsorted_subarray(nums):\n    \"\"\"\n    找到最短的連續子陣列，若只對其排序後整個陣列會變成遞增。\n    回傳該子陣列長度；若陣列已經排序，回傳 0。\n    \"\"\"\n    n = len(nums)\n    if n <= 1:\n        return 0\n\n    # 前綴最大值與後綴最小值\n    max_pref = nums[0]\n    min_suf = nums[-1]\n\n    left = n          # 左界初值設為陣列外\n    right = -1        # 右界初值設為陣列外\n\n    for i in range(1, n):\n        # 更新前綴最大值\n        max_pref = max(max_pref, nums[i])\n        # 更新後綴最小值\n        min_suf = min(min_suf, nums[n - 1 - i])\n\n        # 若此位置的數字小於前綴最大值，表示它必須被移動到左側\n        if nums[i] < max_pref:\n            right = i\n        # 若此位置的數字大於後綴最小值，表示它必須被移動到右側\n        if nums[n - 1 - i] > min_suf:\n            left = n - 1 - i\n\n    # 若 left > right，表示陣列已經排序\n    if left > right:\n        return 0\n    return right - left + 1\n\ndef parse_input(raw):\n    \"\"\"\n    解析輸入字串，預期格式為 'nums = [1, 2, 3]' 或僅為 '[1, 2, 3]'。\n    \"\"\"\n    raw = raw.strip()\n    if raw.startswith('nums'):\n        # 去除 'nums = ' 這一段\n        raw = raw.split('=', 1)[1].strip()\n    # 用 eval 解析為 Python 物件（在受信任環境下安全）\n    return eval(raw)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    if not data:\n        nums = []\n    else:\n        nums = parse_input(data)\n    result = find_unsorted_subarray(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps: Start, etc. We need to solve problem: given integer n, find nth digit in infinite integer sequence 123456789101112... That means we treat the sequence as concatenated decimal representations of positive integers. Need to find nth digit.\n\nWe produce pseudocode steps: determine digit length blocks. For length L numbers (1-digit: 1-9 count=9, 2-digit: 10-99 count=90, etc). For each block, compute total digits. Iterate subtract until find block containing nth digit.\n\nFinally find specific number and digit.\n\nSo we produce steps line by line with explanation. Use arrow and decision.\n\nWe need to output only the virtual code lines, no real code.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize remaining_n = n // copy\n→ Step 2: Initialize digit_length = 1\n→ Step 3: Initialize numbers_in_this_length = 9 * 10^(digit_length-1)\n→ Decision: If remaining_n <= digit_length * numbers_in_this_length? etc.\n\nBut must use the arrow syntax: → Step: description // explanation\n\nWe need to show decisions.\n\nOk produce pseudocode lines.\n\nAlso need to handle when n very large maybe > int? but ignore.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Set remaining = n // 則用於追蹤剩餘需要定位的位數\n→ Step 2: Set len = 1 // 每個區塊的數字位數\n→ Step 3: Set count = 9 * 10^(len-1) // 目前位數的數字總個數\n→ Decision: remaining <= len * count? // 判斷目標位數是否在此區塊\n    Yes → Go to FindNumber // 進入找尋具體數字的流程\n    No  → Step 4: remaining -= len * count // 把整個區塊的位數扣除\n          Step 5: len += 1 // 下一個位數區塊\n          Step 6: count = 9 * 10^(len-1) // 更新該位數區塊的數字個數\n          Step 7: Go to Decision // 重複判斷\n// After loop, remaining falls within current block\n\n→ Step 8: Set number = 10^(len-1) + (remaining-1) / len // 找到具體數字\n→ Step 9: Set digit_index = (remaining-1) % len // 找到數字中的哪個位\n→ Step 10: Set digit_char = digit at position digit_index of number // 取得該位數字\n→ Step 11: Output digit_char // 顯示結果\nEnd // 程式結束\n\nBut we need arrow notation. Use \"→\" for flow.\n\nAlso \"Decision:\" prefix: \"Decision: condition?\" We should indent substeps. Use \"Yes →\" and \"No →\". Let's craft accordingly.\n\nWe'll use \"→ Decision:\" and indentation for sub-steps. Use indentation by spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 remaining ← n // 追蹤尚未定位的位數  \n→ Step 2: 設定 len ← 1 // 目前處理的數字位數  \n→ Step 3: 設定 count ← 9 × 10^(len-1) // 這個位數區塊的數字個數  \n→ Decision: remaining ≤ len × count? // 判斷目標位數是否在此區塊  \n  Yes → Step 4: 跳至 FindNumber // 進入尋找具體數字的流程  \n  No  → Step 5: remaining ← remaining - len × count // 扣除整個區塊的位數  \n    Step 6: len ← len + 1 // 移到下一個位數區塊  \n    Step 7: count ← 9 × 10^(len-1) // 更新新區塊的數字個數  \n    Go to Decision // 重新判斷  \n// 迴圈結束後，remaining 位於目前 len 位數的區塊  \n\n→ Step 8: 計算 number ← 10^(len-1) + (remaining-1) ÷ len // 找到具體的數字  \n→ Step 9: 計算 digit_index ← (remaining-1) mod len // 找到數字中的第幾個位  \n→ Step 10: 取得 digit ← digit of number at position digit_index // 取出該位數字  \n→ Step 11: 輸出 digit // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findNthDigit(self, n: int) -> int:\n        \"\"\"Return the nth digit in the infinite sequence 123456789101112….\"\"\"\n        length = 1          # Current digit length of numbers\n        count = 9           # Count of numbers with this digit length\n        start = 1           # First number with this digit length\n\n        # Find the block that contains the nth digit\n        while n > length * count:\n            n -= length * count\n            length += 1\n            count *= 10\n            start *= 10\n\n        # Locate the exact number and digit\n        start += (n - 1) // length\n        s = str(start)\n        return int(s[(n - 1) % length])\n\ndef main():\n    # Read all input, find the first integer\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input\")\n    n = int(match.group())\n\n    sol = Solution()\n    result = sol.findNthDigit(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode769.json",
    "problem_index_in_file": 0,
    "title": "Max Chunks To Make Sorted",
    "description_snippet": "You are given an integer array arr of length n that represents a permutation of the integers in the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for problem: split permutation into max chunks sorted individually to produce sorted array. Known solution: iterate, keep max index seen so far; when max index equals current index, increment count.\n\nWe need produce step-by-step pseudo-code with arrows and comments. Should not output actual code, just virtual steps.\n\nLet's produce lines:\n\nStart\n→ Initialize count = 0\n→ Initialize maxSeen = -1\n→ For each index i from 0 to n-1:\n    → Update maxSeen = max(maxSeen, arr[i])\n    → If maxSeen == i:\n        Yes → Increment count\nEnd\n→ Return count\n\nBut need to format with Start, End, Decision, etc. Provide comments each line.\n\nAlso include initialization of arr? The problem input arr length n. We can assume arr variable. We'll include Step 1: Receive arr. Then loops.\n\nAlso maybe include Step 0: Define n = length of arr.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 0: 接收陣列 arr // 取得長度為 n 的排列\n→ Step 1: 設定 n = length of arr // 取得陣列長度\n→ Step 2: 初始化 count = 0 // 用於計算可拆分區塊數\n→ Step 3: 初始化 maxSeen = -1 // 用於追蹤目前為止看到的最大值\n→ Decision: 是否有未處理的索引? // 進行遍歷\n    Yes → Step 4: 取得 i = 0 // 從第一個索引開始\n    → Step 5: maxSeen = max(maxSeen, arr[i]) // 更新已見最大值\n    → Decision: maxSeen 是否等於 i? // 檢查是否可切割\n        Yes → Step 6: count = count + 1 // 找到一個可切割的區塊\n        No → // 不切割，繼續往下\n    → Step 7: i = i + 1 // 移至下一個索引\n    → Go back to Decision: 是否有未處理的索引?\n    No  → Step 8: 輸出 count // 結束計算\nEnd // 程式執行結束\n\nBut the decision structure in virtual code may not be nested exactly. Provide proper indentation maybe using tab. But keep simple.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 0: 接收陣列 arr // 取得長度為 n 的排列\n→ Step 1: n = length(arr) // 取得陣列長度\n→ Step 2: count = 0 // 先假設沒有切割\n→ Step 3: maxSeen = -1 // 追蹤目前已見最大值\n→ Step 4: i = 0 // 初始化索引\n→ Decision: i < n? // 是否還有元素未處理\n    Yes → Step 5: maxSeen = max(maxSeen, arr[i]) // 更新最大值\n    → Decision: maxSeen == i? // 是否可以切割\n        Yes → Step 6: count = count + 1 // 切割並計數\n        No  → // 什麼都不做\n    → Step 7: i = i + 1 // 移動到下一個元素\n    → Go back to Decision: i < n?\n    No  → Step 8: return count // 回傳最大切割數\nEnd // 程式結束\n\nWe can also include comment about final result.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 接收陣列 arr // 取得長度為 n 的排列  \n→ Step 1: n = length(arr) // 取得陣列長度  \n→ Step 2: count = 0 // 初始區塊數為 0  \n→ Step 3: maxSeen = -1 // 追蹤目前已見的最大值  \n→ Step 4: i = 0 // 初始化索引  \n→ Decision: i < n? // 是否還有元素未處理  \n Yes → Step 5: maxSeen = max(maxSeen, arr[i]) // 更新已見最大值  \n  → Decision: maxSeen == i? // 這個位置是否能成為一個完整區塊  \n   Yes → Step 6: count = count + 1 // 找到一個可切割區塊，計數加一  \n   No → // 什麼也不做，繼續向後  \n  → Step 7: i = i + 1 // 移到下一個索引  \n  → Go back to Decision: i < n?  \n No → Step 8: return count // 所有元素已遍歷，回傳最大區塊數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        計算在對每個區塊獨立排序後，能得到完全排序陣列的最大區塊數。\n        主要思路：在遍歷陣列時，持續追蹤到目前為止看到的最大值。\n        當該最大值等於當前索引時，表示從上一次切割點到此位置的所有元素\n        均小於等於該位置的值，故可以切割。\n        \"\"\"\n        chunks = 0\n        left_max = -1\n        for i, val in enumerate(arr):\n            left_max = max(left_max, val)\n            if left_max == i:\n                chunks += 1\n        return chunks\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入字串中抽取方括號內的陣列表達式\n    match = re.search(r'\\[.*\\]', data)\n    arr_str = match.group() if match else '[]'\n\n    # 安全解析為 Python list\n    try:\n        arr = ast.literal_eval(arr_str)\n    except Exception:\n        # 若解析失敗，回傳空列表\n        arr = []\n\n    # 計算並輸出答案\n    solution = Solution()\n    result = solution.maxChunksToSorted(arr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "arr = [4,3,2,1,0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "arr = [1,0,2,3,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines. Input: integer num. Output: string base-7 representation. Should handle negative numbers? Probably include negative. Steps: Start, read num, handle zero, handle sign, convert positive number to base 7 by dividing repeatedly, build string (reverse), prepend sign if needed, End. Provide arrow arrows and decisions. Use \"→\" arrow before steps. Provide comment. Use Decision lines for if zero, sign. Use loops? Represent loop: maybe \"Loop\" step. We'll write like:\n\nStart\n→ Step 1: Read integer num\n→ Decision: If num == 0?\n    Yes → Step 2: Return '0'\n    No → Step 3: Handle sign\n        → Step 4: Set negative flag = num < 0\n        → Step 5: num = absolute value of num\n→ Step 6: Initialize empty string result\n→ Loop: While num > 0\n    → Step 7: digit = num mod 7\n    → Step 8: Prepend digit to result\n    → Step 9: num = num // 7\n→ Decision: If negative flag?\n    Yes → Step 10: Prepend '-' to result\n    No → No action\n→ Step 11: Return result\nEnd\n\nNeed each line with virtual code and comment. Use \"Start\" and \"End\". Use \"Decision:\" lines. Use \"Loop:\" maybe not needed but can denote while loop. We need to use arrow before each step: \"→\". Use \"Yes →\", \"No →\" as arrow. Provide comment after //.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 num // 從使用者或函式參數取得整數  \n→ Decision: 如果 num 等於 0? // 檢查是否為零  \n  Yes → Step 2: 回傳字串 '0' // 零的七進位是 '0'  \n  No → Step 3: 進入正負號處理  \n    → Step 4: 設定負號旗標 isNegative = num < 0 // 判斷是否為負數  \n    → Step 5: num = 絕對值(num) // 取得正值進行轉換  \n→ Step 6: 初始化空字串 result = '' // 儲存七進位結果  \n→ Loop: 當 num > 0 時  \n  → Step 7: digit = num mod 7 // 取得最低位數字  \n  → Step 8: result = digit 轉成字元 + result // 將位數前置到字串前面  \n  → Step 9: num = num // 7 // 刪除已處理的位數  \n→ Decision: 如果 isNegative? // 判斷是否需要在前面加負號  \n  Yes → Step 10: result = '-' + result // 加上負號  \n  No → No operation // 正數保持不變  \n→ Step 11: 回傳 result // 回傳最終的七進位字串  \nEnd // 程式執行結束",
      "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\n將十進制整數轉換為七進制字串的程式。\n\"\"\"\n\nimport sys\n\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        \"\"\"\n        把整數轉成七進位的字串。\n        \"\"\"\n        # 若數字為 0，直接回傳 \"0\"\n        if num == 0:\n            return \"0\"\n\n        # 判斷負號，並取絕對值後處理\n        negative = num < 0\n        num = abs(num)\n\n        digits = []\n        # 逐位除 7，取得餘數\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n\n        # 如果原來是負數，在最前面加上 '-'\n        if negative:\n            digits.append('-')\n\n        # 反轉列表並連接成字串\n        return ''.join(digits[::-1])\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取整數，輸出其七進制表示。\n    \"\"\"\n    # 讀取整數，支持多行或空白分隔\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    try:\n        num = int(data)\n    except ValueError:\n        # 若輸入不是合法整數，直接返回\n        print(\"Invalid input\")\n        return\n\n    solution = Solution()\n    result = solution.convertToBase7(num)\n    # 將結果輸出到標準輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "202"
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for LFU Cache. Each line with comment. Use structure Start, Decision, etc. Probably we need to outline design: data structures: hash map key->node, freq->OrderedDict of nodes. We need operations: get, put. Provide pseudocode. Each line with explanation. Ensure O(1). Provide pseudo logic. Provide initializations. Use arrow. Let's craft stepwise.\n\nWe might need to include steps like: Start; Initialize capacity; create minFreq; create keyMap; create freqMap; etc. Then get operation: check keyMap; if not exist return -1; else update frequency: remove from old freq list; increment freq; add to new freq list; if old freq list empty and freq==minFreq then minFreq++ ; return value. Put operation: if capacity==0 return; if key exists: update value; call get(key) to update freq; else if size==capacity: evict key with minFreq's LRU: remove last from freqMap[minFreq] ; remove from keyMap; then insert new key with freq=1; add to freqMap[1]; update minFreq=1. Provide explanation each line.\n\nMake sure to include Start/End lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 LFUCache(capacity) // 建立容量、最小頻率及兩個哈希表  \n  KeyMap ← 空哈希表  // key → Node（value, freq, 位置）  \n  FreqMap ← 空哈希表  // freq → 有序集合（保留最近使用順序）  \n  MinFreq ← 0  // 目前最小使用頻率  \nEnd // 初始化結束  \n\nStart // get 操作開始  \n→ Step 2: get(key)  \n  Decision: key 是否在 KeyMap? // 檢查 key 是否存在  \n   Yes → Step 3: 取出 Node = KeyMap[key] // 取得節點資訊  \n    → Step 4: 更新頻率  \n      Decision: Node.freq 是否存在於 FreqMap? // 應當存在  \n       Yes → Step 5: 從 FreqMap[Node.freq] 移除 Node  \n        If FreqMap[Node.freq] 為空 AND Node.freq == MinFreq  \n         → MinFreq ← MinFreq + 1 // 更新最小頻率  \n        End  \n       No → // 若不存在，表示資料已被清除，直接回傳 -1  \n        End  \n      → Node.freq ← Node.freq + 1 // 使頻率加一  \n      → If FreqMap[Node.freq] 不存在 → 建立空集合  \n      → 將 Node 加入 FreqMap[Node.freq] 的尾部 // 代表最近使用  \n      → KeyMap[key] ← Node // 更新映射（實際已是同一物件，可略過）  \n      → Return Node.value // 回傳值  \n      End  \n    No → Return -1 // key 不存在  \n  End  \nEnd // get 操作結束  \n\nStart // put 操作開始  \n→ Step 6: put(key, value)  \n  Decision: capacity <= 0? // 無效容量直接結束  \n   Yes → End // 直接退出  \n   No → // 進一步處理  \n    Decision: key 是否在 KeyMap? // 先檢查是否已存在  \n     Yes → Step 7: KeyMap[key].value ← value // 更新值  \n      → 執行 get(key) // 讓頻率跟更新順序同步  \n      → End  \n     No → // 新增鍵值  \n      Decision: KeyMap.size == capacity? // 是否需要淘汰  \n       Yes → Step 8: 淘汰最少頻率且最舊的鍵  \n         → EvictKey ← FreqMap[MinFreq].最前面鍵（最近最少使用）  \n         → 從 FreqMap[MinFreq] 移除 EvictKey  \n         → 從 KeyMap 刪除 EvictKey  \n         → If FreqMap[MinFreq] 變為空 → 建立新的空集合（可略）  \n        End  \n       No → // 只要空間足夠即可  \n      End  \n      // 插入新鍵  \n      Node ← {value: value, freq: 1}  \n      KeyMap[key] ← Node  \n      If FreqMap[1] 不存在 → 建立空集合  \n      將 Node 加入 FreqMap[1] 的尾部  \n      MinFreq ← 1 // 新鍵頻率最低  \n      End  \n    End  \nEnd // put 操作結束\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys (in order of usage)\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (and least recently used among them)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef _split_two_lists(s: str):\n    depth = 0\n    for i, ch in enumerate(s):\n        if ch in '([':\n            depth += 1\n        elif ch in ')]':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            return s[:i], s[i+1:]\n    return s, ''\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops_str, args_str = _split_two_lists(data)\n    ops = ast.literal_eval(ops_str.strip())\n    args = ast.literal_eval(args_str.strip())\n\n    result = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            result.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)\n        elif op == \"get\":\n            res = cache.get(arg[0])\n            result.append(res)\n\n    # Convert Python None to JSON null for output\n    output = '[' + ', '.join('null' if v is None else str(v) for v in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": true,
          "output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanation, per format. Problem: evaluate all possible results from expression with operators. Likely use divide and conquer recursion with memoization. Use dynamic programming: parse expression into numbers and operators. Use recursion to compute all results for substring. Use memo key as substring indices. Return list of integers. Steps: Start, parse expression into tokens, define recursive function compute(start, end), if memo contains return; if no operator then convert to number; else for each operator at index, compute left results, right results, combine with operator to produce new results. Append to results. Memoize. At end call compute(0, n-1). Return results.\n\nWe need pseudocode lines with arrows etc. Provide explanatory comments. Use Start, End.\n\nLet's craft.\n\nWe need to output only pseudocode, each line: \"虛擬碼步驟 // 解釋\". Use arrow notation.\n\nExample:\n\nStart // 程式開始\n→ Step 1: Parse expression into tokens list numbers and operators // ...\n\nWe'll need to keep consistent indentation: after Decision, Yes → etc.\n\nNeed to handle recursion: Use function definition as steps.\n\nWe'll produce as sequential steps.\n\nWill include memoization.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: tokens ← 解析 expression 成為數字與運算符的順序列表 // 將字串拆成「數字」「+」「-」「*」等\n→ Step 2: memo ← 空字典 // 用來儲存已計算子表達式的結果\n→ Step 3: results ← 計算(0, len(tokens)-1) // 以遞迴方式求得整個表達式所有可能結果\n→ Step 4: 輸出 results // 結果列表即為所有不同的計算結果\nEnd // 程式執行結束\n\n// 遞迴函式計算子表達式的所有結果\n→ Function 計算(start, end) // start 與 end 為 tokens 列表中的索引\n    → Decision: 若 (start == end) ? // 子表達式是否只有一個元素\n        Yes → Return [轉換為整數(tokens[start])] // 直接回傳數字本身\n        No  →\n            → Decision: 若 memo 已存在 key (start, end) ? // 檢查是否已計算\n                Yes → Return memo[(start, end)] // 取出已儲存的結果\n                No  →\n                    → results ← 空列表 // 用於收集本子表達式所有結果\n                    → i ← start + 1\n                    → Decision: i ≤ end? // 遍歷所有運算符位置\n                        Yes →\n                            → Decision: tokens[i] 是運算符？ // 運算符位置為奇數索引\n                                Yes →\n                                    → left ← 計算(start, i-1) // 計算左子表達式\n                                    → right ← 計算(i+1, end) // 計算右子表達式\n                                    → 遍歷每個 l in left\n                                        → 遍歷每個 r in right\n                                            → Decision: tokens[i] 為 '+'? // 根據運算符進行運算\n                                                Yes → results ← results + [l + r]\n                                                No →\n                                                    Decision: tokens[i] 為 '-'? // 減法\n                                                        Yes → results ← results + [l - r]\n                                                        No →\n                                                            Decision: tokens[i] 為 '*'? // 乘法\n                                                                Yes → results ← results + [l * r]\n                                                                No → // 不可能發生\n                    → i ← i + 2 // 移到下一個運算符位置\n                    → 迴圈結束\n                    → memo[(start, end)] ← results // 缓存結果\n                    → Return results\nEnd // 結束遞迴函式定義",
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n            if not res:  # no operator, just a number\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\ndef parse_input(data: str) -> str:\n    data = data.strip()\n    if '=' in data:\n        _, expr_part = data.split('=', 1)\n        expr_part = expr_part.strip()\n        # Remove surrounding quotes if present\n        if expr_part and expr_part[0] in ('\"', \"'\") and expr_part[-1] == expr_part[0]:\n            expr_part = expr_part[1:-1]\n        return expr_part\n    return data\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    expression = parse_input(raw_input)\n    result = Solution().diffWaysToCompute(expression)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[2,0]",
          "success": true,
          "output": "[2, 0]"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-10,-14,-10,10]",
          "success": true,
          "output": "[-34, -10, -14, -10, 10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Problem: find two unique numbers in array where others appear twice. Approach: XOR all gives xor of two unique numbers, then find rightmost set bit, split array into two groups, XOR each to get the two numbers.\n\nWe need linear time O(n) and constant space O(1). Provide pseudocode step by step with explanation.\n\nWe need to use the specified format: Each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Should start with Start and End.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize xor_all = 0 // 用於存儲所有元素的 XOR\n→ Step 2: For each num in nums: xor_all = xor_all XOR num // 先 XOR 整個陣列，得到兩個唯一數字的 XOR\n→ Decision: 找到 xor_all 中最低位的 1 // 找右邊最低位 1\n    Yes → Step 3: mask = xor_all AND (-xor_all) // 取最低位 1 的掩碼\n    No  → (unlikely, but handle)\n→ Step 4: Initialize num1 = 0, num2 = 0 // 分別存儲兩個唯一數字\n→ Step 5: For each num in nums:\n    Decision: if num AND mask != 0? // 判斷該位是否為 1\n        Yes → num1 = num1 XOR num // 把該組的元素 XOR 到 num1\n        No  → num2 = num2 XOR num // 把另一組的元素 XOR 到 num2\n→ Step 6: Output [num1, num2] // 兩個唯一元素\n\nEnd\n\nBut need arrow style: Use \"→\" for step, \"Decision:\" for if. For inside Decision, need indent with Yes → or No →.\n\nLet's craft lines accordingly.\n\nRemember to include // after each line with explanation.\n\nAlso ensure that we use \"Step\" naming etc. Possibly need \"Start\" and \"End\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 xor_all = 0 // 用來累積所有元素的 XOR  \n→ Step 2: 對 nums 中每個 num 執行：xor_all ← xor_all XOR num // 先將所有數字 XOR 起來，結果是兩個唯一數字的 XOR  \n→ Decision: 找到 xor_all 中最低位的 1 // 這個位可以將兩個唯一數字分開  \n  Yes → Step 3: 設置 mask = xor_all AND (-xor_all) // 取得最低位 1 的掩碼  \n  No  → （理論上不會發生，因為兩個唯一數字一定不相同）  \n→ Step 4: 初始化 num1 = 0, num2 = 0 // 這兩個變數將存儲最終的兩個唯一數字  \n→ Step 5: 對 nums 中每個 num 執行：  \n  Decision: 若 (num AND mask) ≠ 0? // 判斷 num 在 mask 位上的值  \n   Yes → num1 ← num1 XOR num // 把此類型的數字累積到 num1  \n   No  → num2 ← num2 XOR num // 把另一類型的數字累積到 num2  \n→ Step 6: 輸出 [num1, num2] // 回傳兩個只出現一次的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def singleNumber(self, nums):\n        xor = 0\n        for num in nums:\n            xor ^= num\n        # 找到 xor 的最低位 1，作為分組的鑰匙\n        diff_bit = xor & -xor\n        a = b = 0\n        for num in nums:\n            if num & diff_bit:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]\n\ndef parse_input(data: str):\n    \"\"\"從 stdin 讀取的字串中解析出 nums 列表\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 支援「nums = [...]}」與「[...]}」兩種輸入格式\n    if '=' in data:\n        _, rest = data.split('=', 1)\n        data = rest.strip()\n    # 用 eval 解析列表字面量\n    try:\n        nums = eval(data, {\"__builtins__\": None}, {})\n    except Exception:\n        # 如果 eval 失敗，使用正則抽取整數\n        import re\n        nums = [int(x) for x in re.findall(r'-?\\d+', data)]\n    return nums\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    answer = solution.singleNumber(nums)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for a basic calculator to evaluate a string expression without eval. Likely algorithm: use two stacks: numbers and operators. Or we can do recursion for parentheses, handle +,-,*,/. Simplify: process left-to-right with precedence using stack. Steps: iterate through characters, parse numbers, push to stack; handle operators with precedence. Implementation in pseudocode. Provide line-by-line with arrow and comments. Use \"Start\", \"End\". Use Decision. Provide explanation for each line.\n\nWe'll output in Chinese. Must follow format: line: \"虛擬碼步驟 // 解釋\". Use arrow lines. For decision, indentation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空堆疊 Numbers 和 Operators // 用於存放數字和運算符  \n→ Step 2: 將字符串 s 右側多加一個運算符 “+” 作為終結標記 // 方便最後一次處理剩餘數字  \n→ Step 3: 建立指標 i = 0 // 用於遍歷字符串  \n→ Decision: 是否到達字符串結尾? // 判斷是否還有字符需要處理  \n  Yes → Step 4: 讀取當前字符 ch = s[i] // 取得當前字符  \n    Decision: ch 是數字? // 判斷是否為數字  \n     Yes → Step 5: 建立變量 num = 0  \n      While ch 是數字:  \n        num = num * 10 + (ch - '0') // 解析多位數  \n        i = i + 1  \n        ch = s[i]  \n      End While  \n      Push num 到 Numbers 堆疊 // 把完整數字存入  \n      Continue // 跳回判斷下一字符  \n      No → Decision: ch 是左括號 '('?  \n       Yes → Step 6: Push '(' 到 Operators 堆疊 // 標記左括號  \n       No → Decision: ch 是右括號 ')'？  \n        Yes → Step 7: While Operators.top() ≠ '(':  \n          Pop op = Operators.pop()  \n          Pop b = Numbers.pop()  \n          Pop a = Numbers.pop()  \n          Push compute(a, b, op) 到 Numbers // 計算並存回  \n         End While  \n         Pop '(' from Operators // 消除左括號  \n        No → Decision: ch 是運算符 '+', '-', '*', '/'？  \n         Yes → Step 8: 目前運算符 op = ch  \n          Decision: Operators 為空或 Operators.top() 的優先級 < op?  \n           Yes → Step 9: Push op 到 Operators 堆疊 // 無需先處理  \n           No → Step 10: While Operators 非空且 Operators.top() 的優先級 ≥ op:  \n             Pop cur = Operators.pop()  \n             Pop y = Numbers.pop()  \n             Pop x = Numbers.pop()  \n             Push compute(x, y, cur) 到 Numbers // 先計算前面的運算符  \n            End While  \n           Push op 到 Operators 堆疊 // 將當前運算符入堆疊  \n        No → Step 11: i = i + 1 // 處理非關鍵字符（如空格）  \n        End Decision  \n       End Decision  \n       End Decision  \n       End Decision  \n       End Decision  \n      End Decision  \n      Continue // 重複處理下一字符  \n  End Decision  \n→ Decision: Operators 堆疊不為空? // 檢查是否還有未處理運算符  \n  Yes → Step 12: While Operators 非空:  \n     Pop op = Operators.pop()  \n     Pop b = Numbers.pop()  \n     Pop a = Numbers.pop()  \n     Push compute(a, b, op) 到 Numbers  \n    End While  \n    End Decision  \n→ Step 13: Result = Numbers.pop() // 最終結果在 Numbers 堆疊頂部  \n→ Step 14: Return Result // 回傳計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        res = 0\n        num = 0\n        sign = 1\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-':\n                res += sign * num\n                num = 0\n                sign = 1 if c == '+' else -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()          # sign before the parenthesis\n                res += stack.pop()          # value before the parenthesis\n        res += sign * num\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n    # Extract expression inside the first pair of double quotes if present\n    start = data.find('\"')\n    if start != -1:\n        end = data.find('\"', start + 1)\n        expr = data[start + 1:end]\n    else:\n        expr = data.strip()\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode561.json",
    "problem_index_in_file": 0,
    "title": "Array Partition",
    "description_snippet": "Given an integer array nums of 2n integers, group these integers into n pairs (a_1, b_1), (a_2, b_2)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code algorithm for this problem. We need to produce step by step virtual code lines, each with comment. Problem: Given array nums of size 2n, pair into n pairs to maximize sum of min(ai, bi). Classic: sort array, pair adjacent elements, sum every second element starting from index 1 (since sorted ascending, pairing (0,1),(2,3),... gives min as index 0 of each pair, but we want max sum of mins, so we should pair sorted array as (0,1),(2,3)... Actually to maximize sum of min, we should pair adjacent sorted elements: because min of adjacent sorted pair is the first element of pair; sum of all first elements of pairs: sum of nums[0], nums[2], nums[4]... Wait let's recall Leetcode 5617 \"Maximum Sum of Min Pair\". The answer is sum of nums sorted ascending, take every other starting from index 1? Let's check: For array [1,4,3,2], sorted [1,2,3,4], pair (1,2),(3,4) -> min=1+3=4. That's sum of elements at indices 0 and 2. Actually min of each pair is the smaller number; in sorted ascending, if we pair adjacent elements, the smaller of each pair is the first element. So we need to sum elements at indices 0,2,4,... So we sum all even indices after sorting. Equivalent to sum of elements at odd indices if sorted descending? But typical solution: sort ascending, then sum nums[0], nums[2], ... or sum of every second element starting from index 1? Wait: Example [3,5,2,4] sorted [2,3,4,5], pairs (2,3),(4,5) sum mins=2+4=6; that's indices 0 and 2. So sum even indices. Implementation: sort, then for i in range(0, len(nums), 2): sum+=nums[i].\n\nWe should produce virtual code accordingly. Step: Start, Step 1: Input nums, Step 2: sort ascending, Step 3: initialize sum =0, Step 4: iterate i from 0 to len(nums)-1 step 2, add nums[i] to sum, Step 5: return sum, End.\n\nAlso maybe decision: if array empty? But constraints 2n size. So ignore.\n\nLet's produce virtual code lines: \"Start // 程式開始執行\", \"→ Step 1: 取得陣列 nums // 從使用者輸入取得整數陣列\", etc.\n\nWe should use arrow, Start, End, Decision. For loops we can express as \"→ Loop: i從0到len(nums)-1 步長2 // 迭代每兩個元素\". We'll include comment. Also \"→ Step 2: 對 nums 進行升序排序 // 以便相鄰元素成對\". Good.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得陣列 nums // 從使用者輸入取得整數陣列\n→ Step 2: 對 nums 進行升序排序 // 以便相鄰元素成對，便於取得每對中的最小值\n→ Decision: 若 nums 為空? // 只為處理邊界情況\n    Yes → Step 3: 回傳 0 // 空陣列無對，最大和為 0\n    No  → Step 4: 初始化 sum ← 0 // 用於累加每對的最小值\n→ Loop: i ← 0, i < len(nums), i ← i + 2 // 每次迭代走兩個位置，對應一對 (nums[i], nums[i+1])\n    → Step 5: sum ← sum + nums[i] // nums[i] 為這對中的最小值，加入總和\n→ Step 6: 回傳 sum // 回傳所有對的最小值之和，為最大化結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef array_pair_sum(nums):\n    \"\"\"將整數陣列分組，最大化 min(ai, bi) 的總和。\"\"\"\n    nums.sort()                # 先升序排序，方便相鄰成對\n    return sum(nums[::2])      # 取偶數位（0,2,4…）作為每對的最小值\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 若無輸入則直接結束\n        sys.exit(0)\n\n    # 解析輸入字串為 Python list（安全方式）\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，印出錯誤訊息並結束\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    # 確保輸入是整數列表\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        print(\"Input must be a list of integers\")\n        sys.exit(1)\n\n    # 計算並輸出結果\n    result = array_pair_sum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,4,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "[6,2,6,5,1,2]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step with explanations. Use Start, End, Decision. Should produce algorithm for Jump Game I. Use greedy: maintain maxReach. For each index, if i > maxReach return false. Update maxReach = max(maxReach, i+nums[i]). After loop return true.\n\nWe must output each step line with // explanation.\n\nWe need arrow formatting.\n\nProbably:\n\nStart // 程式開始執行\n→ Step 1: 設定 maxReach = 0 // 初始化能達到的最遠索引\n→ Step 2: 從索引 0 迭代到陣列長度 - 1 // 遍歷每個位置\n    → Decision: 如果 i > maxReach? // 檢查目前位置是否可達\n        Yes → Step 3: 回傳 false // 無法到達此位置，終止\n        No  → Step 4: 更新 maxReach = max(maxReach, i + nums[i]) // 更新可達範圍\n→ Step 5: 回傳 true // 完成遍歷，最後一個索引可達\nEnd // 程式執行結束\n\nNeed to match format: each line with arrow? For decisions, indent with arrow? The example uses indentation for decisions and arrow inside.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: maxReach ← 0 // 初始化最遠可達索引\n→ Step 2: for i from 0 to length(nums)-1 do // 遍歷陣列\n    → Decision: i > maxReach? // 是否已經超過目前能達的範圍\n        Yes → Step 3: return false // 無法到達此索引，結束\n        No  → Step 4: maxReach ← max(maxReach, i + nums[i]) // 更新最遠可達索引\n→ Step 5: return true // 走完所有索引，能到達最後一個\nEnd // 程式執行結束\n\nWe need to ensure each line contains `虛擬碼步驟` plus space then comment. For Decision block lines inside, they still need `Decision: ...` lines with comment, but we may indent them. In example, they indent lines after Decision with spaces.\n\nLet's craft.\n\nWe should include \"→\" at beginning of each line.\n\nMake sure the \"Yes →\" lines start with \"Yes →\" after Decision.\n\nYes.\n\nThus produce output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: maxReach ← 0 // 初始化最遠可達索引  \n→ Step 2: for i from 0 to length(nums)-1 do // 遍歷陣列  \n  → Decision: i > maxReach? // 檢查是否已超過目前能達的範圍  \n   Yes → Step 3: return false // 無法到達此索引，結束程式  \n   No  → Step 4: maxReach ← max(maxReach, i + nums[i]) // 更新最遠可達索引  \n→ Step 5: return true // 完整遍歷後，能到達最後一個索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canJump(self, nums):\n        max_reach = 0\n        for i, jump in enumerate(nums):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + jump)\n        return True\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Extract the list inside brackets, e.g., 'nums = [2,3,1,1,4]'\n    start = raw_input.find('[')\n    end = raw_input.rfind(']')\n    if start != -1 and end != -1:\n        nums_str = raw_input[start:end+1]\n        try:\n            nums = ast.literal_eval(nums_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.canJump(nums)\n    # Output in lowercase as required by the examples\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code step by step, following the required format. Use Start, End, Decision, etc. Provide each line as \"虛擬碼步驟 // 解釋\". We must produce virtual code for algorithm that checks if such pair exists. We can use sliding window with hash map to maintain indices within indexDiff. Approach: iterate over nums with index j, maintain a set or map of values of previous indexDiff elements. For each nums[j], check if any value in map within valueDiff: use balanced BST like TreeSet to query floor/ceil. But since we just produce pseudocode, we can abstract: maintain sorted list. Use binary search.\n\nSimpler: nested loops but too slow. We'll produce efficient approach: For each j from 0 to n-1: Check if any i in [max(0, j-indexDiff), j-1] such that abs(nums[i]-nums[j]) <= valueDiff. We can maintain multiset of values in window. For each new j, query if any value in multiset within range [nums[j]-valueDiff, nums[j]+valueDiff]. If found, return true. Then add nums[j] to multiset. If window size > indexDiff, remove nums[j-indexDiff] from multiset.\n\nThus pseudocode: Start, for j from 0 to n-1, Decision: window not empty? If yes, check range via search. If found, return true. Add current value to multiset. If j>=indexDiff: remove nums[j-indexDiff]. End loop. Return false.\n\nWe'll produce step by step with arrows. Use Decision to check if any within range. Use sub-decision to check range. Use data structure \"SortedMultiset\" with methods add, remove, rangeExists. We'll show \"Find any value in multiset within [low, high]\".\n\nMake sure to output each line: \"虛擬碼步驟 // 解釋\". We must not output actual code but pseudo with arrows.\n\nWe must produce lines as:\n\nStart // 程式開始執行\n→ Step 1: 建立空的有序多重集 window // 用於存放滑動窗口內的數值\n→ Step 2: 對索引 j 從 0 到 nums.length-1 迭代 // 遍歷陣列\n    → Decision: window 中是否存在值在 [nums[j]-valueDiff, nums[j]+valueDiff] 內? // 檢查是否已有符合條件的配對\n        Yes → Step 3: 回傳 true // 找到符合條件的 (i,j) 配對\n        No  → Step 4: 將 nums[j] 加入 window // 將目前元素加入滑動窗口\n    → Decision: j >= indexDiff? // 判斷是否需要移除最舊的元素以維持窗口大小\n        Yes → Step 5: 移除 nums[j-indexDiff] 從 window // 移除過舊元素\n        No  → No operation\n→ Step 6: 回傳 false // 所有組合檢查完畢仍無符合條件\nEnd // 程式結束\n\nBut we need to show arrow at each step. Also \"Decision:\" lines may have indentation.\n\nThe format: each line has virtual code step and comment. We must include \"→\" arrows. For indentation, we might use multiple arrows? The example shows \"Decision:\" lines preceded by spaces and arrows. So we can use same style.\n\nWe'll produce lines accordingly.\n\nAlso maybe need to handle the case where indexDiff or valueDiff negative? Not necessary.\n\nWe just produce the pseudocode. Ensure each line contains \"虛擬碼步驟 // 解釋\" with no extra. Use \"→\" arrow at start of each step except Start and End. For decisions, we indent with a space and then \"Decision:\".\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的有序多重集 window // 用於存放滑動窗口內的數值  \n→ Step 2: 對索引 j 從 0 到 nums.length-1 迭代 // 遍歷整個陣列  \n    → Decision: window 中是否存在值在 [nums[j]-valueDiff, nums[j]+valueDiff] 內? // 檢查是否已有符合條件的配對  \n        Yes → Step 3: 回傳 true // 找到符合條件的 (i,j) 配對，立即結束  \n        No  → Step 4: 將 nums[j] 加入 window // 將目前元素加入滑動窗口  \n    → Decision: j >= indexDiff? // 判斷是否需要移除最舊的元素以維持窗口大小  \n        Yes → Step 5: 移除 nums[j-indexDiff] 從 window // 移除已超出窗口範圍的舊元素  \n        No  → No operation // 仍在窗口內，無需移除  \n→ Step 6: 回傳 false // 所有索引都檢查完畢仍未找到符合條件的配對  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport bisect\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        if k <= 0 or t < 0:\n            return False\n        window = []  # 有序列表，保存滑動窗口內的值\n        for i, num in enumerate(nums):\n            # 找到第一個 >= num - t 的位置\n            pos = bisect.bisect_left(window, num - t)\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n            bisect.insort(window, num)  # 插入保持排序\n            if len(window) > k:\n                # 刪除最舊的元素 nums[i - k]\n                idx = bisect.bisect_left(window, nums[i - k])\n                del window[idx]\n        return False\n\ndef parse_input(data: str):\n    # 解析輸入字串取得 nums, indexDiff, valueDiff\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', data)\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not index_match or not value_match:\n        raise ValueError(\"Input format not recognized\")\n\n    nums_str = nums_match.group(1).strip()\n    if nums_str:\n        nums = [int(x.strip()) for x in nums_str.split(',')]\n    else:\n        nums = []\n\n    k = int(index_match.group(1))\n    t = int(value_match.group(1))\n    return nums, k, t\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums, k, t = parse_input(input_data)\n    sol = Solution()\n    result = sol.containsNearbyAlmostDuplicate(nums, k, t)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants virtual code for problem: given array size n, find all elements appearing more than floor(n/3) times. This is classic majority element (more than n/3) problem solved by Boyer-Moore generalized to k=3. So we output step-by-step pseudo-code: Start, Step: input array, compute n, initialize candidates and counts, first pass to find potential candidates, second pass to verify counts, collect results, End. Provide comments. Use arrow \"→\", \"Yes →\", \"No →\". Use Start/End. Each line must be \"虛擬碼步驟 // 解釋\". Provide Chinese explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums, 計算 n = nums.length // 取得陣列及長度  \n→ Step 2: 初始化候選人 cand1 = null, cand2 = null; 計數 cnt1 = 0, cnt2 = 0 // 兩個可能的 majority 元素及其計數  \n→ Decision: 遍歷 nums 中每個值 num // 第一輪：確定候選人  \n  Yes → Decision: 如果 num 等於 cand1? // 檢查 num 是否為第一個候選人  \n    Yes → cnt1 = cnt1 + 1 // 若相同，計數加 1  \n    No → Decision: 如果 num 等於 cand2? // 檢查 num 是否為第二個候選人  \n      Yes → cnt2 = cnt2 + 1 // 若相同，計數加 1  \n      No → Decision: 如果 cnt1 == 0? // 若第一個候選人不存在  \n        Yes → cand1 = num; cnt1 = 1 // 以 num 為新候選人  \n        No → Decision: 如果 cnt2 == 0? // 若第二個候選人不存在  \n          Yes → cand2 = num; cnt2 = 1 // 以 num 為新候選人  \n          No → cnt1 = cnt1 - 1; cnt2 = cnt2 - 1 // 同時減 1，丟棄不符合候選人  \n→ Step 3: 重新將 cnt1, cnt2 設為 0 // 第二輪：驗證實際計數  \n→ Decision: 遍歷 nums 中每個值 num // 重新統計候選人的實際出現次數  \n  Yes → Decision: 如果 num 等於 cand1? // 若是第一個候選人  \n    Yes → cnt1 = cnt1 + 1 // 計數加 1  \n    No → Decision: 如果 num 等於 cand2? // 若是第二個候選人  \n      Yes → cnt2 = cnt2 + 1 // 計數加 1  \n→ Step 4: 建立空陣列 result // 用於儲存符合條件的元素  \n→ Decision: 如果 cnt1 > n / 3? // 檢查第一個候選人是否滿足 > n/3 的條件  \n  Yes → result.append(cand1) // 加入結果  \n→ Decision: 如果 cnt2 > n / 3? // 檢查第二個候選人是否滿足 > n/3 的條件  \n  Yes → result.append(cand2) // 加入結果  \n→ Step 5: 輸出 result // 顯示所有符合出現次數的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom typing import List, Optional\n\ndef majority_element(nums: List[int]) -> List[int]:\n    \"\"\"\n    找出所有出現次數大於 ⌊n/3⌋ 的元素。\n    使用 Boyer-Moore 推廣版（k=3）演算法。\n    \"\"\"\n    if not nums:\n        return []\n\n    # 兩個候選人及其計數\n    cand1: Optional[int] = None\n    cand2: Optional[int] = None\n    count1, count2 = 0, 0\n\n    # 第一輪：確定可能的候選人\n    for num in nums:\n        if cand1 == num:\n            count1 += 1\n        elif cand2 == num:\n            count2 += 1\n        elif count1 == 0:\n            cand1, count1 = num, 1\n        elif count2 == 0:\n            cand2, count2 = num, 1\n        else:\n            count1 -= 1\n            count2 -= 1\n\n    # 第二輪：重新計算實際出現次數\n    count1, count2 = 0, 0\n    for num in nums:\n        if num == cand1:\n            count1 += 1\n        elif num == cand2:\n            count2 += 1\n\n    # 檢查是否真的超過 ⌊n/3⌋\n    n = len(nums)\n    result: List[int] = []\n    if count1 > n // 3:\n        result.append(cand1)\n    if count2 > n // 3:\n        result.append(cand2)\n\n    return result\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，處理輸入資料並輸出結果。\n    支援形如「nums = [3,2,3]」或直接「[3,2,3]」的輸入。\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 若包含「nums =」前綴，先移除\n    if '=' in raw:\n        _, part = raw.split('=', 1)\n        part = part.strip()\n    else:\n        part = raw\n\n    # 轉成 Python 列表\n    try:\n        nums = ast.literal_eval(part)\n    except Exception:\n        # 若解析失敗，直接印空列表\n        print([])\n        return\n\n    if not isinstance(nums, list):\n        print([])\n        return\n\n    result = majority_element(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode748.json",
    "problem_index_in_file": 0,
    "title": "Shortest Completing Word",
    "description_snippet": "Given a string licensePlate and an array of strings words, find the shortest completing word in word...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode step by step, with arrow syntax, Start, End, Decision, etc. Provide brief explanation after each line. Must not output real code. Let's produce algorithm: Preprocess licensePlate to count letters ignoring case, build frequency map. Then iterate words in order, for each word check if word contains at least required counts. Keep track of shortest length. If length smaller than current best, update. After loop return best word.\n\nAlso need to consider early termination if length==min? But we need shortest. Could keep minLen and bestWord. Steps: preprocess, build map. Iterate words: for each word count letters? We could check by building word map each time. Or check by scanning word and decreasing copy of requirement. We'll do simpler: for each word create freq map. Then compare with requirement.\n\nLet's produce pseudocode. We'll use virtual code lines like:\n\nStart // Program start\n→ Step 1: Preprocess licensePlate // Build letter frequency map\n\nWe need arrow format. For loops use \"For each ...\".\n\nMake decisions: Decision: word length < current best? etc.\n\nLet's produce step by step:\n\n1. Start\n2. Step 1: Initialize requirement map R as empty // to store counts of letters in licensePlate\n3. Step 2: For each char c in licensePlate\n4. Decision: Is c a letter? // ignore digits/spaces\n    Yes → Step 3: Convert c to lowercase // standardize case\n    → Step 4: Increment R[c] // count letter\n    No → Step 5: Continue // skip non-letter\n5. Step 6: Initialize bestWord = empty, minLen = infinity // track best result\n6. Step 7: For each word w in words\n7. Decision: length of w >= minLen? // if w shorter than current best, still possible\n    Yes → Step 8: Build freq map F for w // counts of letters\n    → Decision: Does F satisfy R? // all required letters present enough times\n        Yes → Step 9: If length of w < minLen then\n                → Step 10: bestWord = w // new best\n                → Step 11: minLen = length of w\n        No → Step 12: Continue // not completing\n    No → Step 13: Continue // skip longer words maybe? but need to still check? Actually we can skip because they can't be shorter than current minLen, but if equal we might need first occurrence. Since we keep first, skip.\n8. End // return bestWord\n\nNeed to output line by line. Use arrow arrow. For loops: \"→ For each w in words:\" etc.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化要求字母頻率表 R 為空 // 用於儲存 licensePlate 中各字母的需求數量  \n→ Step 2: For each 字元 c in licensePlate // 遍歷 licensePlate 中的每個字元  \n  Decision: c 是字母? // 只處理字母，忽略數字與空格  \n   Yes → Step 3: 將 c 轉成小寫 // 對大小寫不敏感  \n    → Step 4: R[c] += 1 // 更新該字母的需求數量  \n   No → Step 5: Continue // 非字母直接跳過  \n→ Step 6: 初始化 bestWord 為空字串，minLen 為正無窮 // 用於儲存目前最短符合條件的單字  \n→ Step 7: For each 單字 w in words // 遍歷所有候選單字  \n  Decision: length(w) < minLen? // 只在潛在更短或等長時檢查  \n   Yes → Step 8: 建立 w 的字母頻率表 F // 計算該單字中每個字母的出現次數  \n    → Decision: F 是否滿足 R? // 所有需求字母至少出現相同或更多次  \n     Yes → Step 9: If length(w) < minLen then  \n       → Step 10: bestWord = w // 更新最短單字  \n       → Step 11: minLen = length(w)  \n     No → Step 12: Continue // 不是完成單字，跳到下一個  \n  No → Step 13: Continue // 當前單字已長於已知最短，直接跳過  \nEnd // 程式執行結束，回傳 bestWord",
      "generated_code": "import sys\nimport re\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n        # Build requirement counter from licensePlate (ignore non-letters, case-insensitive)\n        plate_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n\n        best_word = None\n        best_len = float('inf')\n\n        # Iterate over each word in order\n        for word in words:\n            # Quick length check: only consider if could beat current best\n            if len(word) > best_len:\n                continue\n\n            word_count = Counter(word)\n            # Check if word satisfies all requirements\n            if all(word_count[c] >= plate_count[c] for c in plate_count):\n                if len(word) < best_len:\n                    best_word = word\n                    best_len = len(word)\n                # If same length, keep first occurrence (already satisfied by not updating)\n\n        return best_word\n\ndef parse_input(data: str):\n    \"\"\"Parse the input string into licensePlate and words list.\"\"\"\n    license_plate = ''\n    words = []\n\n    # Extract licensePlate\n    m = re.search(r'licensePlate\\s*=\\s*\"([^\"]*)\"', data)\n    if m:\n        license_plate = m.group(1)\n\n    # Extract words list\n    m = re.search(r'words\\s*=\\s*(\\[.*\\])', data, re.DOTALL)\n    if m:\n        words_json = m.group(1)\n        try:\n            words = json.loads(words_json)\n        except json.JSONDecodeError:\n            words = eval(words_json)  # fallback if JSON parsing fails\n\n    return license_plate, words\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Parse the input format\n    license_plate, words = parse_input(raw_input)\n\n    # Compute the result\n    sol = Solution()\n    result = sol.shortestCompletingWord(license_plate, words)\n\n    # Print with double quotes as required\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "success": true,
          "output": "\"steps\""
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "success": true,
          "output": "\"pest\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, explaining. The algorithm: use XOR to find single. Steps: start, initialize result to 0, loop over array, XOR each element with result, end. Complexity O(n), space O(1). We need to output each line as \"虛擬碼步驟 // 解釋\".\n\nUse arrow: → Step 1 etc. Use Decision? Not necessary. It's linear.\n\nWe must ensure format: Start // 程式開始執行\n\nThen arrows. Use \"→\" before each step.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: For each num in nums // 遍歷陣列中的每個數字\n    → Step 3: result ← result XOR num // 將結果與目前數字做 XOR，重複的數字相消\n→ Step 4: Return result // 返回剩下的唯一數字\nEnd // 程式執行結束\n\nWe might also include explanation for XOR property.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化結果為 0，準備累積 XOR 結果  \n→ Step 2: For each num in nums // 遍歷陣列中的每個數字  \n    → Step 3: result ← result XOR num // 將結果與目前數字做 XOR，重複出現的數字會相互抵消  \n→ Step 4: Return result // 回傳剩餘的唯一數字，為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        Find the element that appears only once in the array using XOR.\n        XOR properties:\n        - a ^ a = 0\n        - a ^ 0 = a\n        Thus XORing all numbers leaves the unique one.\n        \"\"\"\n        result = 0\n        for num in nums:\n            result ^= num\n        return result\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the list part. Input examples are like: \"nums = [2,2,1]\"\n    if \"=\" in raw_input:\n        nums_part = raw_input.split(\"=\", 1)[1].strip()\n    else:\n        nums_part = raw_input\n\n    # Safely evaluate the list\n    try:\n        nums = ast.literal_eval(nums_part)\n    except Exception:\n        # If evaluation fails, try to parse as a comma-separated list without brackets\n        nums = [int(x.strip()) for x in nums_part.split(\",\") if x.strip()]\n\n    # Compute and print the single number\n    solution = Solution()\n    print(solution.singleNumber(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1991.json",
    "problem_index_in_file": 0,
    "title": "Find the Middle Index in Array",
    "description_snippet": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for solving problem: find leftmost equilibrium index. Provide step-by-step virtual pseudocode with arrows, decisions, etc. Must include explanation per line. Provide in Traditional Chinese. Avoid actual code. Provide structure. Let's craft.\n\nWe need algorithm: compute total sum, iterate i from 0 to n-1, maintain left sum. For each i, right sum = total - leftSum - nums[i]. If leftSum == rightSum, return i. After loop, return -1. Also need handle leftmost.\n\nProvide virtual code lines:\n\nStart\n→ Step 1: 取得陣列長度 n // Determine length\n→ Step 2: 計算總和 total = sum(nums) // Sum of all elements\n→ Step 3: 初始化 leftSum = 0 // Sum of elements left of current index\n→ Decision: 如果 n == 0? // Edge case empty array\n    Yes → Step 4: 輸出 -1 // No middle index\n    No  → Step 5: 開始迴圈 i 0 到 n-1 // Iterate through indices\n        → Step 5a: 計算 rightSum = total - leftSum - nums[i] // Sum right of current\n        → Decision: 如果 leftSum == rightSum? // Check equilibrium\n            Yes → Step 5b: 輸出 i // Found leftmost index\n            No  → Step 5c: 更新 leftSum = leftSum + nums[i] // Move leftSum forward\n        → End of loop\n→ Step 6: 輸出 -1 // No index found\nEnd\n\nWe need arrows and decisions lines exactly as format: \"Decision:\" lines with Yes→, No→.\n\nWe need to use \"Start\", \"End\". Provide explanation after each line.\n\nMake sure each line is separate, no code. Use Chinese comments.\n\nLet's write lines accordingly. Ensure each line has \"→\" or indentation. For decisions we need to indent Yes→ and No→ lines under Decision. Use proper indentation with spaces.\n\nAlso need to include step for empty array. We could combine with n==0 decision inside loop start? But fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n // 取得 nums 的長度  \n→ Step 2: 計算總和 total = sum(nums) // 先求出所有元素之和  \n→ Step 3: 初始化 leftSum = 0 // 左側已經遍歷過的元素總和  \n→ Decision: n == 0? // 空陣列無法有平衡點  \n  Yes → Step 4: 輸出 -1 // 回傳 -1 表示不存在中點  \n  No  → Step 5: 開始迴圈 i 0 到 n-1 // 循環檢查每個索引  \n   → Step 5a: 計算 rightSum = total - leftSum - nums[i] // 右側元素總和  \n   → Decision: leftSum == rightSum? // 判斷是否為平衡點  \n     Yes → Step 5b: 輸出 i // 找到左側最小的平衡點，立即返回  \n     No  → Step 5c: 更新 leftSum = leftSum + nums[i] // 進入下一個索引前更新左側和  \n   → End of loop // 完成所有索引的檢查  \n→ Step 6: 輸出 -1 // 若迴圈結束仍未找到，回傳 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef find_middle_index(nums):\n    total = sum(nums)\n    left_sum = 0\n    for i, val in enumerate(nums):\n        if left_sum == total - left_sum - val:\n            return i\n        left_sum += val\n    return -1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得陣列表達式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    try:\n        nums = ast.literal_eval(expr.strip())\n    except Exception:\n        nums = []\n    result = find_middle_index(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-1,8,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,-1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,5]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with comments. The logic: check if word is all uppercase, or all lowercase, or first uppercase rest lowercase. Return true if matches. So steps: Start, Step 1: input word. Step 2: check if word is all uppercase. Step 3: check if all lowercase. Step 4: check if first uppercase and rest lowercase. Use Decision nodes.\n\nImplement as pseudocode: Start, Step1: read word. Step2: if word == word.upper() → true. Step3: else if word == word.lower() → true. Step4: else if word[0].isupper() and word[1:]==word[1:].lower() → true. Step5: else → false. End.\n\nWe need to use \"Decision:\" lines and arrow. Example format: Start, then arrow. Use \"Yes →\" and \"No →\". For each check: Decision: if word is all uppercase? Yes → return true; No → next decision. And so on.\n\nReturn true or false. We'll do a Step: Output 'true' or 'false'. Or we can have Decision at end: if any condition satisfied → return true else false.\n\nBut requirement: produce virtual code lines with comments. Ensure each line includes // explanation. Use Start, End. Provide proper indentation via spaces maybe.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 word // 取得要檢查的單詞\n→ Decision: word 是否全為大寫? // 判斷是否為全大寫情況\n    Yes → Step 2: 返回 true // 全大寫符合規則\n    No  → Decision: word 是否全為小寫? // 若非全大寫，檢查是否為全小寫\n        Yes → Step 3: 返回 true // 全小寫符合規則\n        No  → Decision: 第一個字母大寫且其餘小寫? // 檢查首字母大寫其餘小寫情況\n            Yes → Step 4: 返回 true // 首字母大寫其餘小寫符合規則\n            No  → Step 5: 返回 false // 以上皆不符，則不正確\nEnd // 程式執行結束\n\nBut we need to include 'Step' labels. Provide comments after each line. Use arrow after 'Start', '→', etc. Ensure each line ends with comment.\n\nWe might need to add indentation for nested decisions. Example:\n\n→ Decision: word 是否全為大寫? // ...\n    Yes → Step 2: 返回 true // ...\n    No  → Decision: ...\n\nWe must maintain correct indentation with spaces. The \"Yes →\" lines indent under decision. Good.\n\nReturn value as true/false. So Step lines: Step 2: return true. Step 5: return false.\n\nLet's craft final. Ensure no actual code. Provide in required format.\n\nAlso mention that we treat string functions like upper/lower. Provide comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 word // 取得要檢查的單詞  \n→ Decision: word 是否全為大寫? // 判斷是否為全大寫情況  \n  Yes → Step 2: 返回 true // 全大寫符合規則  \n  No  → Decision: word 是否全為小寫? // 若非全大寫，檢查是否為全小寫  \n    Yes → Step 3: 返回 true // 全小寫符合規則  \n    No  → Decision: 第一個字母大寫且其餘小寫? // 檢查首字母大寫其餘小寫情況  \n      Yes → Step 4: 返回 true // 首字母大寫其餘小寫符合規則  \n      No  → Step 5: 返回 false // 以上皆不符，則不正確  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        \"\"\"\n        Return True if the word follows the correct capital usage:\n        1. All letters are capitals.\n        2. All letters are not capitals.\n        3. Only the first letter is capital.\n        \"\"\"\n        return word.isupper() or word.islower() or word.istitle()\n\ndef main() -> None:\n    # Read the whole input, remove surrounding whitespace and optional quotes\n    data = sys.stdin.read()\n    if not data:\n        return\n    word = data.strip().strip('\"').strip(\"'\")\n    \n    solution = Solution()\n    result = solution.detectCapitalUse(word)\n    # Output 'true' or 'false' in lowercase as required\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting Excel column title to number. Provide step-by-step. Use Start, End, Decision, arrow. Each line: code + // explanation. Use arrow. Should be line by line. Ensure no actual code, just pseudocode.\n\nLet's design:\n\nStart\n→ Step 1: 初始化 result = 0 // 用於累計列號\n→ Step 2: 循環遍歷 columnTitle 的每個字符 // 逐字符處理\n    → Step 2.1: 取得字符 c\n    → Step 2.2: 將 c 的字母序轉為數值 val = ord(c) - ord('A') + 1 // A->1 ...\n    → Step 2.3: result = result * 26 + val // 進位\n→ Step 3: 返回 result // 完成\n\nBut also need decision for end? Not necessary. Might add Decision for empty string? We can include.\n\nMake lines:\n\nStart // 程式開始\n→ Step 1: result ← 0 // 初始化累計結果為 0\n→ Decision: 如果 columnTitle 為空? // 檢查是否為空字串\n    Yes → Step 2: return 0 // 空字串回傳 0\n    No  →\n        → Step 3: 對於每個字符 c 在 columnTitle 之中 // 逐字處理\n            → Step 3.1: val ← ord(c) - ord('A') + 1 // 將字母轉為 1-26 的數值\n            → Step 3.2: result ← result * 26 + val // 進位累加\n→ Step 4: return result // 回傳最終列號\nEnd // 程式結束\n\nWe must format each line with `虛擬碼步驟` then space then `// 解釋`. Use arrow as shown. So produce:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化累計結果為 0\n→ Decision: 如果 columnTitle 為空? // 檢查是否為空字串\n    Yes → Step 2: return 0 // 空字串回傳 0\n    No  → // 進入主邏輯\n        → Step 3: 對於每個字符 c 在 columnTitle 之中 // 逐字處理\n            → Step 3.1: val ← ord(c) - ord('A') + 1 // 轉為 1-26 數值\n            → Step 3.2: result ← result * 26 + val // 進位累加\n→ Step 4: return result // 回傳最終列號\nEnd // 程式結束\n\nBut we need each line as separate line. Use indentation for nested steps? We can indent lines with spaces.\n\nEnsure no actual code. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化累計結果為 0  \n→ Decision: 如果 columnTitle 為空? // 檢查字串是否為空  \n    Yes → Step 2: return 0 // 空字串回傳 0  \n    No → // 進入主邏輯  \n        → Step 3: 對於每個字符 c 在 columnTitle 之中 // 逐字處理  \n            → Step 3.1: val ← ord(c) - ord('A') + 1 // 將字母轉為 1-26 的數值  \n            → Step 3.2: result ← result * 26 + val // 進位累加  \n→ Step 4: return result // 回傳最終列號  \nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"將 Excel 欄位標題轉換成數字。\"\"\"\n        result = 0\n        for ch in columnTitle:\n            # 取得字母的 1~26 數值\n            val = ord(ch) - ord('A') + 1\n            result = result * 26 + val\n        return result\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取資料並輸出欄位數字。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中提取欄位名稱\n    if \"'\" in data:                      # 例子: columnTitle = 'AB'\n        start = data.find(\"'\")\n        end = data.rfind(\"'\")\n        title = data[start + 1:end]\n    else:\n        # 直接輸入字串或 format: columnTitle = AB\n        if '=' in data:\n            title = data.split('=', 1)[1].strip()\n        else:\n            title = data\n\n    solution = Solution()\n    print(solution.titleToNumber(title))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the algorithm of combination sum: backtracking, candidates sorted. Each line with explanation. We need to follow the output format: \"虛擬碼步驟 [space] // 解釋\". Use arrows etc. Start, End, Decision etc. Each line is a step. So need to represent algorithm steps like Start, define function, iterate, recursion, etc.\n\nWe should produce line by line steps that represent algorithm: e.g.:\n\nStart\n→ Define function combine(candidates, target) // main entry\n→ Sort candidates ascending // ensure order to avoid duplicates\n→ Define backtrack(start, current, remaining)\n→ Decision: remaining == 0? // base case success\n  Yes → Append current to result // store combination\n  No → Decision: remaining < 0? // invalid\n    Yes → Return // prune\n    No → Loop i from start to len(candidates)-1\n        → Add candidates[i] to current // choose\n        → Recursively call backtrack(i, current, remaining - candidates[i]) // allow unlimited\n        → Remove last from current // backtrack\n→ End // algorithm finished\nReturn result\n\nWe need each line with explanation. Use arrows. For decision we indent. Also each step is separate line. We need to include arrow before each step, except Start and End maybe no arrow. The example shows \"Start // 程式開始執行\". So we should follow that.\n\nLet's produce steps.\n\nBut careful: Each step line must be like:\n\nStart // 程式開始執行\n→ Define function combinationSum(candidates, target) // 主入口，傳入參數\n→ Sort candidates ascending // 方便遞迴避免重複組合\n→ Initialize result list // 用於存放所有有效組合\n→ Define backtrack(startIndex, currentCombo, remainingSum) // 回溯函式\n→ Decision: remainingSum == 0? // 是否已達目標\n    Yes → Append copy of currentCombo to result // 成功加入結果\n    No → Decision: remainingSum < 0? // 是否超過目標\n        Yes → Return // 超過則停止\n        No → For i from startIndex to len(candidates)-1 // 遍歷候選數\n            → Append candidates[i] to currentCombo // 選擇數字\n            → backtrack(i, currentCombo, remainingSum - candidates[i]) // 允許重複選擇\n            → Remove last element from currentCombo // 回溯\n→ backtrack(0, [], target) // 啟動回溯\n→ Return result // 返回所有組合\nEnd // 程式結束\n\nNeed each line with // explanation.\n\nNow produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define function combinationSum(candidates, target) // 主入口，傳入候選數與目標和  \n→ Sort candidates ascending // 讓遞迴時能以遞增順序遍歷，避免重複組合  \n→ Initialize result list // 用來存放所有符合條件的組合  \n→ Define backtrack(startIndex, currentCombo, remainingSum) // 回溯子函式  \n→ Decision: remainingSum == 0? // 檢查是否已正好達到目標和  \n  Yes → Append copy of currentCombo to result // 成功組合加入結果  \n  No → Decision: remainingSum < 0? // 檢查是否已超過目標和  \n    Yes → Return // 超過就直接回傳，停止此分支  \n    No → For i from startIndex to len(candidates)-1 // 從當前索引開始遍歷所有候選數  \n     → Append candidates[i] to currentCombo // 選擇當前數字  \n     → backtrack(i, currentCombo, remainingSum - candidates[i]) // 允許重複使用相同數字  \n     → Remove last element from currentCombo // 回溯，移除剛選的數字  \n→ backtrack(0, [], target) // 從索引0開始，空組合，目標和為 target  \n→ Return result // 傳回所有找到的唯一組合  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    parts = [p.strip() for p in data.split(',')]\n    cand_part = parts[0]\n    target_part = parts[1] if len(parts) > 1 else ''\n    cand_list_str = cand_part.split('=')[1].strip()\n    target_str = target_part.split('=')[1].strip()\n    candidates = ast.literal_eval(cand_list_str)\n    target = int(target_str)\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpv5ptgwo8.py\", line 30, in <module>\n    target_str = target_part.split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpw8xxxee4.py\", line 30, in <module>\n    target_str = target_part.split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations for the problem: given binary array, find max length contiguous subarray with equal number of 0 and 1. We need to produce algorithm: prefix sum, map from cumulative sum to first index. Use -1 for zero sum at start. Iterate over array, treat 0 as -1, 1 as +1, maintain sum. For each sum, if first seen, record index, else compute length. Keep max.\n\nWe produce steps in virtual code with arrows.\n\nWe must output each line as \"虛擬碼步驟 // 解釋/說明\".\n\nWe must include start, end, decision, loops, etc.\n\nLet's structure:\n\nStart\n→ Step 1: 初始化 maxLen = 0, sum = 0, map = {0: -1} // 設定初始參數\n→ Step 2: 對於索引 i 從 0 到 n-1 循環 // 遍歷陣列\n   → Decision: nums[i] == 0? // 判斷目前元素\n       Yes → sum = sum - 1 // 0 轉為 -1\n       No  → sum = sum + 1 // 1 轉為 +1\n   → Decision: sum 是否已在 map 中? // 檢查累積和是否已出現\n       Yes → length = i - map[sum] // 计算子数组长度\n             → Decision: length > maxLen? // 是否更新最大長度\n                 Yes → maxLen = length // 更新最大長度\n                 No  → // 不做任何事\n       No  → map[sum] = i // 記錄首次出現的位置\n→ Step 3: 返回 maxLen // 回傳結果\nEnd\n\nWe should include each line with // explanation.\n\nAlso use arrow syntax for decisions: Decision: <condition>?\n\nYes → ... No → ...\n\nWe'll keep indentation via spaces.\n\nWe should produce each line individually. Let's output exactly as required.\n\nUse \"Start\" \"End\". Use \"Decision:\" lines.\n\nEnsure each line has one virtual code step and explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxLen = 0, sum = 0, map = {0: -1} // 設定初始參數，記錄 0 累計和在索引 -1\n→ Step 2: for i from 0 to nums.length-1 循環 // 遍歷整個陣列\n   → Decision: nums[i] == 0? // 判斷目前元素是 0 還是 1\n       Yes → sum = sum - 1 // 0 轉成 -1，累積和更新\n       No  → sum = sum + 1 // 1 轉成 +1，累積和更新\n   → Decision: sum 是否已在 map 中? // 檢查此累計和是否已出現過\n       Yes → length = i - map[sum] // 若已出現，計算相等 0 與 1 的子陣列長度\n             → Decision: length > maxLen? // 比較是否為目前最大長度\n                 Yes → maxLen = length // 更新最大長度\n                 No  → // 目前長度不大於最大長度，保持不變\n       No  → map[sum] = i // 若未出現，記錄此累計和第一次出現的索引\n→ Step 3: return maxLen // 返回最長子陣列長度\nEnd // 程式執行結束\n\nLet's check each line has arrow or step. Need to indent decision lines properly.\n\nWe must ensure each line is separate and not nested.\n\nBut we need to output each line as separate lines; the \"Decision\" lines have nested arrows inside; we can output each nested line on its own line.\n\nThus we need separate lines for each arrow and decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxLen = 0, sum = 0, map = {0: -1} // 設定初始參數，記錄 0 累計和在索引 -1\n→ Step 2: for i from 0 to nums.length-1 循環 // 遍歷整個陣列\n   → Decision: nums[i] == 0? // 判斷目前元素是 0 還是 1\n       Yes → sum = sum - 1 // 0 轉成 -1，累積和更新\n       No  → sum = sum + 1 // 1 轉成 +1，累積和更新\n   → Decision: sum 是否已在 map 中? // 檢查此累計和是否已出現過\n       Yes → length = i - map[sum] // 若已出現，計算相等 0 與 1 的子陣列長度\n             → Decision: length > maxLen? // 比較是否為目前最大長度\n                 Yes → maxLen = length // 更新最大長度\n                 No  → // 目前長度不大於最大長度，保持不變\n       No  → map[sum] = i // 若未出現，記錄此累計和第一次出現的索引\n→ Step 3: return maxLen // 返回最長子陣列長度\nEnd // 程式執行結束\n\nMake sure each line has one code step. But the nested lines like \"Decision: length > maxLen?\" have arrow and indent. This seems fine.\n\nDouble-check formatting: \"→ Decision: nums[i] == 0? // ...\" This line is considered a virtual code step.\n\nYes.\n\nWe should maintain proper indentation spaces for clarity but not necessary.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxLen = 0, sum = 0, map = {0: -1} // 設定初始參數，記錄 0 累計和在索引 -1  \n→ Step 2: for i from 0 to nums.length-1 循環 // 遍歷整個陣列  \n → Decision: nums[i] == 0? // 判斷目前元素是 0 還是 1  \n  Yes → sum = sum - 1 // 0 轉成 -1，累積和更新  \n  No  → sum = sum + 1 // 1 轉成 +1，累積和更新  \n → Decision: sum 是否已在 map 中? // 檢查此累計和是否已出現過  \n  Yes → length = i - map[sum] // 若已出現，計算相等 0 與 1 的子陣列長度  \n   → Decision: length > maxLen? // 比較是否為目前最大長度  \n    Yes → maxLen = length // 更新最大長度  \n    No  → // 目前長度不大於最大長度，保持不變  \n  No  → map[sum] = i // 若未出現，記錄此累計和第一次出現的索引  \n→ Step 3: return maxLen // 返回最長子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef findMaxLength(nums):\n    \"\"\"Return the length of the longest contiguous subarray with equal number of 0 and 1.\"\"\"\n    count_map = {0: -1}   # cumulative count -> first index where it occurs\n    max_len = 0\n    count = 0\n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in count_map:\n            curr_len = i - count_map[count]\n            if curr_len > max_len:\n                max_len = curr_len\n        else:\n            count_map[count] = i\n    return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        nums = ast.literal_eval(data)   # parse input like \"[0,1,0]\"\n    except Exception:\n        import json\n        nums = json.loads(data)\n    result = findMaxLength(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for topological sorting to detect cycle. Use DFS or Kahn's algorithm. Provide step-by-step pseudocode.\n\nWe'll use DFS with visited status: 0 unvisited, 1 visiting, 2 visited. Detect back edge.\n\nWe'll produce:\n\nStart\n\n→ Build adjacency list\n\n→ Initialize visited array to 0\n\n→ For each course i from 0 to numCourses-1\n\n    → Decision: If visited[i]==0? // Not visited yet\n\n        Yes → Step: DFS(i) // explore\n\n            → Decision: If DFS returns false? // cycle found\n\n                Yes → Return false // cannot finish\n\n→ After loop, Return true\n\nDFS function:\n\n→ Function DFS(course)\n\n    → Mark visited[course]=1 // in process\n\n    → For each neighbor in adjacency[course]\n\n        → Decision: visited[neighbor]==1? // cycle\n\n            Yes → Return false\n\n        → Decision: visited[neighbor]==0? // not visited\n\n            Yes → If DFS(neighbor) == false then return false\n\n    → Mark visited[course]=2 // processed\n\n    → Return true\n\nWe'll structure as virtual steps. Use arrows and decisions.\n\nLet's produce each line as:\n\nStart // 程式開始執行\n\n→ Step 1: 建立課程圖 (adjacency list) from prerequisites // 轉換輸入為鄰接表\n\n→ Step 2: 建立 visited 陣列長度 numCourses，初值 0 // 0=未訪問\n\n→ Step 3: 定義遞迴函式 DFS(course) // 用於 DFS 探索\n\n→ Step 4: 遍歷所有課程 i from 0 to numCourses-1 // 嘗試訪問每個節點\n\n    → Decision: visited[i] == 0? // 尚未訪問\n\n        Yes → Step 5: 如果 DFS(i) 為 false 則 // 產生迴圈\n\n            Yes → Return false // 不能完成課程\n\n→ Step 6: 所有課程均可訪問，返回 true // 能完成所有課程\n\nThen details of DFS:\n\nStep 7: DFS(course)\n\n    → Mark visited[course] = 1 // 正在探索\n\n    → For each neighbor in adjacency[course]\n\n        → Decision: visited[neighbor] == 1? // 循環檢測\n\n            Yes → Return false\n\n        → Decision: visited[neighbor] == 0? // 未訪問\n\n            Yes → Decision: DFS(neighbor) == false? // 子遞迴失敗\n\n                Yes → Return false\n\n    → Mark visited[course] = 2 // 探索完成\n\n    → Return true\n\nEnd.\n\nWe need to output each line with arrow etc. Provide lines. Use indentation for decision branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立課程圖 (adjacency list) from prerequisites // 將 prerequisites 轉換成鄰接表，方便快速查詢哪些課程依賴於此課程  \n→ Step 2: 建立 visited 陣列長度 numCourses，初值 0 // 0 = 未訪問，1 = 正在訪問（gray），2 = 已完成（black）  \n→ Step 3: 定義遞迴函式 DFS(course) // 用於深度優先搜尋並偵測循環  \n→ Step 4: 遍歷所有課程 i from 0 to numCourses-1 // 嘗試從每個節點開始 DFS  \n    → Decision: visited[i] == 0? // 尚未被訪問  \n        Yes → Step 5: 如果 DFS(i) 為 false 則 // 發現循環時回傳 false  \n            Yes → Return false // 無法完成所有課程  \n→ Step 6: 所有課程均可訪問，返回 true // 能完成所有課程  \nEnd // 程式執行結束  \n\n// 下面列出 DFS 的具體虛擬碼  \n\nDFS(course) // 開始搜尋課程 course  \n    → Step 7: Mark visited[course] = 1 // 標記為「正在訪問」  \n    → Step 8: For each neighbor in adjacency[course] // 遍歷所有必修前置課程  \n        → Decision: visited[neighbor] == 1? // 同一棵 DFS 树中再次遇到「正在訪問」節點  \n            Yes → Return false // 發現回環，無法完成課程  \n        → Decision: visited[neighbor] == 0? // 還未被訪問  \n            Yes → Decision: DFS(neighbor) == false? // 子 DFS 發現循環  \n                Yes → Return false  \n    → Step 9: Mark visited[course] = 2 // 標記為「已完成」  \n    → Return true // 本節點及其所有子節點無循環，正常結束 DFS",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # 建立鄰接表\n        graph = [[] for _ in range(numCourses)]\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n\n        visited = [0] * numCourses  # 0=未訪問, 1=正在訪問, 2=已完成\n\n        def dfs(course):\n            visited[course] = 1  # 標記為正在訪問\n            for nxt in graph[course]:\n                if visited[nxt] == 1:  # 看到正在訪問的節點 → 循環\n                    return False\n                if visited[nxt] == 0:  # 未訪問\n                    if not dfs(nxt):\n                        return False\n            visited[course] = 2  # 標記為已完成\n            return True\n\n        for c in range(numCourses):\n            if visited[c] == 0:\n                if not dfs(c):\n                    return False\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    # 移除關鍵字，取得 numCourses 與 prerequisites\n    data = data.replace(\"numCourses =\", \"\").replace(\"prerequisites =\", \"\")\n    parts = data.split(\",\", 1)\n    numCourses = int(parts[0].strip())\n    prerequisites = ast.literal_eval(parts[1].strip())\n    sol = Solution()\n    result = sol.canFinish(numCourses, prerequisites)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step for algorithm to check if string can be constructed by repeating a substring. Typical solution: check if s is substring of s + s starting from 1 to len-1. Or iterate length from 1 to n/2 check divisible, substring, repeat.\n\nWe should produce virtual code lines with arrow and explanation. Each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc.\n\nWe produce steps: Start, Input s, n = length, Decision: if n==0? -> True? maybe consider empty string considered? We'll say yes. Then iterate i from 1 to n/2: Decision if n mod i == 0? If yes, candidate = s[0:i]; repeated = candidate repeated n/i times; Decision if repeated == s? If yes return True; else continue. After loop, return False. End.\n\nAdd line for returning True/False. Use Return.\n\nLet's produce code. Use arrow lines with →. Format: \"Start // 程式開始執行\". Next \"→ Step 1: 輸入字串 s // 從使用者取得輸入字串\". Then \"→ Step 2: 計算 n = length of s // 取得字串長度\". Then \"→ Decision: n 等於 0? // 檢查是否為空字串\". Then \"Yes → Step 3: 回傳 True // 空字串可視為重複子字串\". \"No → Step 4: 初始化 i = 1 // 設定子字串長度起點\". \"→ Decision: i <= n/2? // 只需檢查到半長度\". \"Yes → Decision: n mod i 等於 0? // 子字串長度必須能整除總長度\". \"Yes → Step 5: 取得 candidate = s[0:i] // 取前 i 個字符作為候選子字串\". \"→ Step 6: 產生 repeated = candidate 重複 n/i 次 // 建立重複字串\". \"→ Decision: repeated 等於 s? // 判斷是否完全匹配\". \"Yes → Step 7: 回傳 True // 找到符合條件的子字串\". \"No  → Step 8: i = i + 1 // 進一步檢查下個長度\". \"No  → Step 8: i = i + 1 // 不是整除，跳過\". \"No  → Step 9: i = i + 1 // 長度超過 n/2 時結束迴圈\". \"→ Decision: i <= n/2? // 迴圈結束判斷\". \"No  → Step 10: 回傳 False // 沒有找到符合條件\". \"End // 程式結束\". That seems enough.\n\nWe need to ensure each line ends with // 解釋.\n\nAlso, we need to use arrows: Start line maybe no arrow. But can use \"Start //\". Next \"→ Step 1:\" etc.\n\nWe must avoid actual code. Use pseudocode like \"n = length(s)\" but not actual code. It's okay. Provide explanation each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者取得輸入字串  \n→ Step 2: 計算 n = s 的長度 // 取得字串長度  \n→ Decision: n 等於 0? // 檢查是否為空字串  \n  Yes → Step 3: 回傳 True // 空字串視為可重複子字串  \n  No  → Step 4: 初始化 i = 1 // 設定子字串長度起點  \n→ Decision: i <= n/2? // 只需檢查到半長度  \n  Yes → Decision: n mod i 等於 0? // 子字串長度必須能整除總長度  \n    Yes → Step 5: 取得 candidate = s 的前 i 個字符 // 取候選子字串  \n    → Step 6: 產生 repeated = candidate 重複 (n ÷ i) 次 // 建立重複字串  \n    → Decision: repeated 等於 s? // 判斷是否完全匹配  \n      Yes → Step 7: 回傳 True // 找到符合條件的子字串  \n      No  → Step 8: i = i + 1 // 進一步檢查下個長度  \n    No  → Step 8: i = i + 1 // 不是整除，跳過此長度  \n  No  → Step 8: i = i + 1 // 長度超過 n/2 時結束迴圈  \n→ Decision: i <= n/2? // 迴圈結束判斷  \n  No  → Step 9: 回傳 False // 沒有找到符合條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                if s[:i] * (n // i) == s:\n                    return True\n        return False\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        print('false')\n        return\n\n    # 支援兩種輸入格式：\n    # 1. 直接給字串，例如: abab\n    # 2. 帶變數定義，例如: s = \"abab\"\n    s = data\n    if s.lower().startswith('s ='):\n        # 去掉前綴\n        s = s[s.index('=') + 1:].strip()\n        # 移除可能存在的雙引號\n        if s.startswith('\"') and s.endswith('\"'):\n            s = s[1:-1]\n        elif s.startswith(\"'\") and s.endswith(\"'\"):\n            s = s[1:-1]\n    else:\n        # 直接使用整行作為字串\n        s = s.strip()\n\n    sol = Solution()\n    result = sol.repeatedSubstringPattern(s)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for implementing pickIndex function with weighted random selection. Provide step-by-step lines with explanation comments. Must use virtual code syntax with arrows, Start, End, Decision: etc. Must produce in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows like \"→\". Provide step by step for initialization and pickIndex method. Provide algorithm: build prefix sum array in constructor, random number in [0,total), binary search for index. Use pseudocode lines.\n\nEnsure each line is a separate step with arrow. Use Start for initialization? We can start with \"Start\" then Steps. Also include Decision. The pseudocode should reflect steps in building prefix sums, then pickIndex steps.\n\nWe should not output actual code. Provide virtual code with comments.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 w // 初始化\n→ Step 2: 建立 prefixSum 陣列 // 用於累計權重\n→ Step 3: 計算 totalWeight ← prefixSum[-1] // 總權重\n→ Step 4: 定義函式 pickIndex() // 開始定義隨機挑選\n    → Step 5: 產生亂數 r 在 [0, totalWeight) // 隨機數\n    → Step 6: binarySearch 於 prefixSum 找出第一個值 ≥ r // 以累積權重定位索引\n    → Decision: r 在 prefixSum 的哪個區間? // 透過二分查找確定\n        Yes → Step 7: 回傳對應索引 i // 找到的索引\n    End // 函式結束\nEnd // 程式結束\n\nBut we need to include Decision: maybe better to show binary search decision steps. Use \"Decision: 如果 r < prefixSum[mid]?\". Provide branch.\n\nLet's produce more detailed steps:\n\nStart // 程式開始執行\n→ Step 1: 輸入權重陣列 w // w 為正整數\n→ Step 2: 初始化 prefixSum[0] ← w[0]\n→ Decision: 是否有更多元素? // 檢查陣列長度\n    Yes → Step 3: 對 i = 1 到 len(w)-1 進行\n        → Step 3a: prefixSum[i] ← prefixSum[i-1] + w[i] // 計算累積\n    No → ...\n→ Step 4: 設定 totalWeight ← prefixSum[len(w)-1] // 總權重\n→ Step 5: 定義函式 pickIndex() // 隨機挑選索引\n    → Step 6: 產生亂數 r 介於 [0, totalWeight) // 隨機數\n    → Decision: 是否 r < prefixSum[0]? // 判斷最小索引\n        Yes → Step 7: 回傳 0 // 選擇第一個\n        No → Step 8: 初始化 low ← 0, high ← len(w)-1\n            → Decision: low < high? // 二分查找\n                Yes → Step 9: mid ← (low+high)/2\n                    → Decision: r < prefixSum[mid]? // 判斷左半區\n                        Yes → Step 10: high ← mid\n                        No → Step 11: low ← mid + 1\n                No → Step 12: 回傳 low // 找到對應索引\n    End // 函式結束\nEnd // 程式結束\n\nThis is more detailed. Ensure each line separate. Use arrows for flow. Provide comments in Chinese. Use \"→\" each line. Use Decision. Ensure format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入權重陣列 w // w 為正整數的 0‑index 陣列  \n→ Step 2: 初始化 prefixSum[0] ← w[0] // 建立累積權重陣列的第一個元素  \n→ Decision: w 的長度是否大於 1? // 檢查是否還有後續元素  \n  Yes → Step 3: 對 i = 1 到 len(w)-1 進行  \n  → Step 3a: prefixSum[i] ← prefixSum[i-1] + w[i] // 將前一個累積值加上當前權重  \n  No  → // 已完成累積權重計算  \n→ Step 4: 設定 totalWeight ← prefixSum[len(w)-1] // 總權重為累積陣列最後一個值  \n→ Step 5: 定義函式 pickIndex() // 開始定義隨機挑選索引的功能  \n  → Step 6: 產生亂數 r 介於 [0, totalWeight) // 取得一個隨機數作為篩選標準  \n  → Decision: r < prefixSum[0]? // 判斷是否落在第一個索引區間  \n    Yes → Step 7: 回傳 0 // 若在第一個區間，直接返回索引 0  \n    No  → Step 8: 初始化 low ← 0, high ← len(w)-1 // 準備二分搜尋  \n      → Decision: low < high? // 開始二分搜尋流程  \n        Yes → Step 9: mid ← (low + high) / 2 // 計算中點索引  \n        → Decision: r < prefixSum[mid]? // 判斷隨機數落在左半邊還是右半邊  \n          Yes → Step 10: high ← mid // 若在左半邊，將 high 收縮至 mid  \n          No  → Step 11: low ← mid + 1 // 若在右半邊，將 low 移至 mid+1  \n        No  → Step 12: 回傳 low // low 即為符合條件的索引  \n  End // pickIndex 函式結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機產生 1 ~ total 的整數\n        target = random.randint(1, self.total)\n        # bisect_left 找出第一個 >= target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將兩個頂層列表包起來，使其成為合法的 Python 表達式\n    wrapped = '[' + raw_input + ']'\n    try:\n        ops, args = ast.literal_eval(wrapped)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {e}\")\n\n    instance = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 參數是 w 的列表\n            instance = Solution(arg[0])\n            results.append(None)  # Constructor 沒有回傳值\n        elif op == \"pickIndex\":\n            if instance is None:\n                raise ValueError(\"未先呼叫 Constructor\")\n            results.append(instance.pickIndex())\n        else:\n            raise ValueError(f\"未知的方法名稱: {op}\")\n\n    # 輸出為 JSON 格式，None 會被轉為 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": true,
          "output": "[null, 0]"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 1, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for decoding an encoded string of form k[encoded_string] with nested. We must not output actual code. Just pseudo steps with arrow and explanation. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to consider typical algorithm: use stack of string builder and number stack. Iterate chars: if digit accumulate number, if '[' push current string onto stack, reset current string, push number onto stack, if ']' pop number, pop previous string, repeat current string that many times and append to previous string, set as current string. At end, result is current string. We must produce step by step.\n\nAlso need to handle start and end, decisions. Provide virtual steps. Use arrows \"→\" and \"Decision:\".\n\nLet's craft.\n\nStart\n\n→ Initialize empty string builder current // 用於累積當前層編碼結果\n→ Initialize empty stack<string> stringStack // 儲存上一層字符串\n→ Initialize empty stack<int> numberStack // 儲存對應的重複次數\n→ Initialize variable num = 0 // 用於收集多位數的重複數\n\nNow iterate each character ch in input string:\n\n→ Decision: ch 是數字? // 判斷是否為數字\n    Yes → num = num * 10 + int(ch - '0') // 累積數字\n    No → Decision: ch 是 '['? // 判斷是否進入新層\n        Yes → \n            stringStack.push(current) // 保存目前字符串\n            numberStack.push(num) // 保存重複次數\n            current = \"\" // 重置為新層\n            num = 0 // 重置數字\n        No → Decision: ch 是 ']'? // 判斷是否結束當前層\n            Yes →\n                repeatTimes = numberStack.pop() // 取出重複次數\n                prevString = stringStack.pop() // 取出上一層字符串\n                // 將 current 重複 repeatTimes 次\n                temp = \"\"\n                for i in 1..repeatTimes:\n                    temp += current\n                current = prevString + temp // 合併到上一層\n            No → \n                current += ch // 添加字母到當前字符串\n\nEnd of loop\n\n→ Result = current // 當前字符串即為解碼結果\nEnd\n\nAdd comments. Ensure each line has // explanation. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize current = \"\" // 用於累積目前層的解碼結果\n→ Initialize stringStack = [] // 用於儲存上一層字符串\n→ Initialize numberStack = [] // 用於儲存對應的重複次數\n→ Initialize num = 0 // 用於收集多位數的重複數字\n\n→ Iterate over each character ch in input string // 逐個處理輸入字元\n    → Decision: ch 是數字? // 判斷是否為數字字符\n        Yes → num = num * 10 + int(ch - '0') // 累積多位數字\n        No → Decision: ch 是 '['? // 判斷是否進入新層\n            Yes → \n                stringStack.push(current) // 保存目前層字符串\n                numberStack.push(num) // 保存目前數字\n                current = \"\" // 重置為新層\n                num = 0 // 重置數字收集\n            No → Decision: ch 是 ']'? // 判斷是否結束當前層\n                Yes →\n                    repeatTimes = numberStack.pop() // 取出重複次數\n                    prevString = stringStack.pop() // 取出上一層字符串\n                    temp = \"\" // 用於儲存重複後的字符串\n                    for i in 1..repeatTimes: // 重複 current\n                        temp += current\n                    current = prevString + temp // 合併回上一層\n                No →\n                    current += ch // 把字母添加到目前層字符串\n\nResult = current // 最終解碼字符串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef decodeString(s: str) -> str:\n    \"\"\"Decode an encoded string of the form k[encoded_string].\"\"\"\n    stack = []            # 用來儲存上一層的字串和重複次數\n    current_num = 0       # 用於收集多位數的重複次數\n    current_str = ''      # 當前層的解碼結果\n\n    for char in s:\n        if char.isdigit():\n            # 若為數字，累積成多位數\n            current_num = current_num * 10 + int(char)\n        elif char == '[':\n            # 進入新層：把目前字串與重複次數入棧，並重置\n            stack.append((current_str, current_num))\n            current_str = ''\n            current_num = 0\n        elif char == ']':\n            # 結束當前層：出棧並重複拼接\n            prev_str, num = stack.pop()\n            current_str = prev_str + current_str * num\n        else:\n            # 普通字母直接累加\n            current_str += char\n\n    return current_str\n\ndef extract_encoded_string(raw_input: str) -> str:\n    \"\"\"\n    從原始輸入中抽取真正的編碼字串。\n    支援兩種常見輸入格式：\n    1. s = \"3[a]2[bc]\"\n    2. 直接輸入編碼字串本身\n    \"\"\"\n    raw_input = raw_input.strip()\n    # 若有雙引號，取引號內部內容\n    match = re.search(r'\\\"([^\\\"]*)\\\"', raw_input)\n    if match:\n        return match.group(1)\n\n    # 若是形如 s = ... 的寫法，取等號後面的字串\n    if raw_input.startswith('s'):\n        parts = raw_input.split('=', 1)\n        if len(parts) == 2:\n            return parts[1].strip()\n    # 其餘情況直接回傳原始字串\n    return raw_input\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_data = sys.stdin.read()\n    if not raw_data:\n        sys.exit()\n\n    encoded = extract_encoded_string(raw_data)\n    result = decodeString(encoded)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "aaabcbc"
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "accaccacc"
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "abcabccdcdcdef"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for function that returns number of set bits. Use arrow notation. Each line: step description with comment. Should include Start, End, Decision. Provide steps: input n, initialize count=0, while n>0, if n & 1 then count++, then n = n >> 1 (or n // 2). Finally return count. Use virtual steps. Use Start. Use Decision: if n > 0? Yes-> etc. Provide comments. Let's produce.\n\nWe must not output actual code, just pseudo steps. Provide line by line. Use arrows. Example format.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 接收正整數 n // 取得輸入\n→ Step 2: 初始化 count 為 0 // 記錄設置位數\n→ Decision: n 是否大於 0? // 判斷是否還有位可處理\n    Yes → Step 3: 如果 (n & 1) 為 1，則 count 加 1 // 若最低位為 1，累計\n    Yes → Step 4: n 右移 1 位 // 移除已處理的最低位\n    Yes → 跳回 Decision: n 是否大於 0? // 重新檢查\n    No  → Step 5: 回傳 count // 所有位處理完畢，回傳結果\nEnd // 程式執行結束\n\nNeed to ensure correct arrow usage: Yes → for each. Provide indent for nested.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收正整數 n // 取得輸入  \n→ Step 2: 初始化 count 為 0 // 用來記錄 1 的個數  \n→ Decision: n 是否大於 0? // 判斷是否還有位可處理  \n  Yes → Step 3: 如果 (n & 1) 為 1，則 count 加 1 // 檢查最低位是否為 1  \n  Yes → Step 4: n 右移 1 位 // 移除已處理的最低位  \n  Yes → 跳回 Decision: n 是否大於 0? // 重新檢查下一個位  \n  No  → Step 5: 回傳 count // 所有位都已處理完畢，輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        \"\"\"Return the number of set bits (1's) in the binary representation of n.\"\"\"\n        count = 0\n        while n:\n            count += n & 1   # add 1 if the least significant bit is set\n            n >>= 1          # shift right to process the next bit\n        return count\n\ndef main() -> None:\n    \"\"\"Read an integer from stdin, compute its Hamming weight, and print the result.\"\"\"\n    # Read entire input (could be something like \"n = 11\" or just \"11\")\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first integer found in the input\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = Solution().hammingWeight(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce pseudocode for algorithm. Steps: Count soldiers per row using binary search because rows sorted. Then sort rows by (count, index). Then pick first k indices.\n\nWe must output each line as described. Use virtual code arrow. We'll write:\n\nStart\n→ Step 1: Initialize empty list rows\n→ Decision: iterate rows\n    → Step 2: For each row i, count soldiers via binary search\n        → Step 3: Append (count, i) to rows\n→ Step 4: Sort rows by count ascending, index ascending\n→ Step 5: Initialize result list\n→ Step 6: For t from 0 to k-1:\n    → Step 7: Append rows[t].index to result\n→ End // return result\n\nNeed to use arrow for loops? Use Decision maybe. We can show loops with \"For each\" etc. We'll adhere to format. Use \"→\" preceding each step.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: Create empty list rows // 用於存儲每行的(兵力數, 行號)\n→ Decision: For i from 0 to m-1? Actually we can use For loop as a step: \n    → Step 2: For each row index i in mat // 遍歷每一行\n        → Step 3: count ← BinarySearch(mat[i]) // 用二分搜尋得到 1 的個數\n        → Step 4: Append (count, i) to rows // 儲存 (兵力, 行號)\n→ Step 5: Sort rows by first element ascending, then by second ascending // 先根據兵力，兵力相同則根據行號\n→ Step 6: Create empty list result // 儲存最弱 k 行的行號\n→ Step 7: For t from 0 to k-1:\n    → Step 8: Append rows[t].second to result // 加入對應行號\n→ End // 返回 result\n\nWe need to include comments after each line.\n\nMake sure each line ends with // explanation. Also include indent lines as shown.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: rows ← [] // 建立空列表，存放 (兵力數, 行號)\n→ Decision: For each row index i in mat // 遍歷每一行\n    → Step 2: count ← BinarySearch(mat[i]) // 用二分搜尋找出 1 的個數\n    → Step 3: rows.append((count, i)) // 將 (兵力, 行號) 加入 rows\n→ Step 4: rows.sort(key = (count, i)) // 依兵力升序，兵力相同則依行號升序排序\n→ Step 5: result ← [] // 建立空列表，存放最弱 k 行的行號\n→ Decision: For t from 0 to k-1\n    → Step 6: result.append(rows[t].index) // 加入對應行號\n→ End // 返回 result，包含最弱 k 行的索引\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # Count number of soldiers (1's) in a row using binary search.\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # Build a list of tuples (soldier_count, row_index).\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        # Sort by soldier count ascending, then by row index ascending.\n        soldiers.sort()\n        # Return the indices of the first k weakest rows.\n        return [idx for _, idx in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    import ast\n\n    # Read the entire input from stdin.\n    raw_input = sys.stdin.read().strip()\n\n    # Execute the input string in a clean namespace to extract mat and k.\n    # The input is expected to contain two assignments, e.g.:\n    #   mat = [[1,0,0],[1,1,0]]\n    #   k = 2\n    namespace = {}\n    exec(raw_input, {}, namespace)\n\n    mat = namespace['mat']\n    k = namespace['k']\n\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n\n    # Print the result as a Python list literal.\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjruwhrxg.py\", line 34, in <module>\n    exec(raw_input, {}, namespace)\n  File \"<string>\", line 1\n    mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmphuizairb.py\", line 34, in <module>\n    exec(raw_input, {}, namespace)\n  File \"<string>\", line 1\n    mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve problem: find minimal string of digits length to guarantee that any password of length n over alphabet [0,k-1] appears as substring of entered string. It's De Bruijn sequence of order n over alphabet size k. Minimum length is k^n + n - 1. Steps: construct De Bruijn sequence via algorithm like Hierholzer's algorithm on de Bruijn graph. Provide pseudocode line by line with explanations. Use virtual code arrows.\n\nWe'll present steps: Build graph with k^n nodes? Actually nodes are sequences of length n-1. Edges represent adding digit. Use DFS to produce Eulerian cycle. Output sequence start n-1 zeros + edges. Provide explanation per line.\n\nLet's craft steps:\n\nStart\n→ Step 1: Input n, k // receive password length and digit range\n→ Decision: if n==0? // handle trivial case\n    Yes → Step 2: Output empty string // no digits needed\n    No → Step 3: Build de Bruijn graph // proceed\n→ Step 4: Create adjacency list for all (k^(n-1)) nodes // each node corresponds to sequence of n-1 digits\n→ Step 5: For each node, push edges labeled 0..k-1 // directed edge to node formed by shift left and add digit\n→ Step 6: Initialize empty stack and path // for Hierholzer\n→ Step 7: Push start node (all zeros) onto stack // start traversal\n→ Step 8: While stack not empty // Hierholzer main loop\n    → Decision: if current node has unused edges? // check adjacency\n        Yes → Step 9: Remove an edge, push destination node onto stack // traverse\n        No  → Step 10: Pop node from stack, append to path // backtrack\n→ Step 11: After loop, path contains Eulerian cycle in reverse order // reverse later\n→ Step 12: Reverse path // get correct order\n→ Step 13: Construct output string: start with (n-1) zeros then for each edge in path after first node, append edge label // builds de Bruijn sequence\n→ Step 14: Return output string // minimal unlocking string\nEnd\n\nNeed to add explanations. Ensure format: each line: \"虛擬碼步驟 // 解釋\".\n\nAlso include arrows. For steps with branches we use Decision. Provide indentations.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 n, k // 取得密碼長度與數字範圍\n→ Decision: 如果 n == 0? // 處理特殊情況，長度為 0\n    Yes → Step 2: 輸出 \"\" // 直接回傳空字串，無需輸入任何數字\n    No  → Step 3: 建立 De Bruijn 圖 // 從 n 與 k 開始建立圖結構\n→ Step 4: 建立鄰接表 adj[0 … k^(n-1)-1] // 每個節點代表長度為 n-1 的序列\n→ Step 5: 對每個節點 i\n    → For d = 0 to k-1\n        → Edge (i → ((i * k + d) mod k^(n-1))) 帶標籤 d // 加一個數字後的移位節點\n→ Step 6: 初始化 stack S ← [0] // 從全 0 節點開始\n→ Step 7: 初始化 path 為空 // 儲存 Euler 循環\n→ Step 8: While S 非空\n    → Decision: 若 S.top() 的節點還有未使用邊? // 檢查是否可以再往前走\n        Yes → Step 9: 取出一條未使用的邊 (v → w) 並標籤 d\n            → 推進 S ← S ∪ [w] // 把目的節點推進棧\n            → 標記此邊已使用\n        No  → Step 10: pop ← S.pop() // 回到上一節點\n            → Append pop 到 path // 記錄路徑\n→ Step 11: 反轉 path // 目前的順序是反向的 Euler 循環\n→ Step 12: 建立答案字串 ans ← \"0\" * (n-1) // 先加上前 n-1 個 0\n→ Step 13: 對於 path 中的每個相鄰節點對 (prev, curr)\n    → 取出對應邊的標籤 d\n    → ans ← ans + d // 把標籤追加到答案\n→ Step 14: 輸出 ans // 這個字串長度為 k^n + n - 1，能包含所有長度為 n 的序列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        if n == 0:\n            return \"\"\n        seen = set()\n        res = []\n\n        def dfs(node: str):\n            for x in map(str, range(k)):\n                nei = node + x\n                if nei not in seen:\n                    seen.add(nei)\n                    dfs(nei[1:])\n                    res.append(x)\n\n        start = \"0\" * (n - 1)\n        dfs(start)\n        return \"\".join(res) + start\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    sol = Solution()\n    result = sol.crackSafe(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(1 << 25)\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with arrow notation, start, decision, etc. We need to compute trailing zeros of factorial n. Standard method: count number of factors 5 in n! (since 2s are abundant). So pseudocode: input n, set count=0, set divisor=5, while n/divisor >=1: count += n/divisor; divisor *=5; output count. That's it. We'll produce steps with \"Start\", \"→ Step 1: Input n\", \"→ Step 2: Initialize count=0, divisor=5\", \"→ Step 3: While n / divisor >= 1\", \"→ Step 4: count += n/divisor\", \"→ Step 5: divisor *= 5\", \"→ End\" etc. Use Decision: \"Decision: n/divisor >=1?\" with Yes branch. Ensure to include arrow. Provide comment after //.\n\nLet's craft. Use Chinese commentary. Use the arrow arrow. Use \"Start\", \"End\". Provide each step line. Provide decision. For while loop, use Decision. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n // 取得使用者輸入的正整數  \n→ Step 2: 初始化 count ← 0, divisor ← 5 // count 用來累加 5 的因子個數，divisor 用於計算 5 的各次方  \n→ Decision: n ÷ divisor ≥ 1? // 判斷是否還有更高次方的 5 可以出現在 n!  \n  Yes → Step 3: count ← count + ⌊n ÷ divisor⌋ // 將此次方 5 的個數加入計數  \n  Yes → Step 4: divisor ← divisor × 5 // 移到下一個 5 的次方  \n  Yes → 回到 Decision: n ÷ divisor ≥ 1? // 重複判斷  \n  No  → End // 所有 5 的因子已被計算完畢，結束循環  \nEnd // 程式執行結束，count 即為 n! 的尾零個數。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        \"\"\"\n        計算 n! 的尾零個數。\n        只需要統計因子 5 的個數即可，因為因子 2 的個數永遠多於 5。\n        \"\"\"\n        count = 0\n        divisor = 5\n        while n // divisor:\n            count += n // divisor\n            divisor *= 5\n        return count\n\ndef main() -> None:\n    \"\"\"\n    主函式：\n    1. 從標準輸入讀取資料，並解析出整數 n。\n    2. 使用 Solution.trailingZeroes 計算結果。\n    3. 將結果輸出到標準輸出。\n    \"\"\"\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 利用正則表達式抽取第一個整數\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    result = sol.trailingZeroes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode720.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary",
    "description_snippet": "Given an array of strings words representing an English Dictionary, return the longest word in words...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Should not output actual code, only pseudo steps with explanation comments. Use Start, Decision, etc. We need to cover sorting, building words, dictionary, etc.\n\nLet's outline algorithm: sort words by length ascending, then lexicographic to handle tie. Or sort by length asc, lex asc. Then iterate, maintain set of built words. For each word, if word length==1 or all prefixes in set, add to set and record candidate. Finally return candidate (longest built). If none, return \"\". We'll produce virtual code step by step.\n\nNeed to show steps: Start, Step 1: Sort words ascending length and lexicographically. Step 2: Initialize set builtWords, bestWord empty. Step 3: For each word in sorted list: Check if word length 1 or all prefixes in builtWords. If yes, add to builtWords and update bestWord if longer or same length but lexicographically smaller. End loop. End: return bestWord.\n\nBut must adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrow for flow.\n\nWe need to use decision blocks: Decision: if word length==1? Actually we can combine: Decision: if word length==1? Yes: add; No: then check prefixes. So use nested decisions.\n\nAlso maintain bestWord logic: Decision: if word longer than bestWord? Yes: update; No: if same length but lexicographically smaller: update.\n\nLet's craft lines.\n\nWe'll start with Start // 程式開始執行\n\n→ Step 1: Sort words by ascending length, then lexicographic // 對單詞進行排序，確保較短或相同長度較小的字典序先處理\n\n→ Step 2: Initialize empty set builtWords // 用於儲存已能構建的單詞\n\n→ Step 3: Initialize bestWord as empty string // 儲存目前最長可構建單詞\n\n→ Step 4: For each word in sorted words // 逐個處理單詞\n\n→ Decision: 如果 word length == 1? // 判斷是否為單字符單詞\n\n    Yes → Step 5a: Add word to builtWords // 直接能構建，加入集合\n\n    No  → Step 5b: 初始化 flag可構建 = true // 檢查前綴是否都已存在\n\n        → Step 5c: For i from 1 to length-1 // 檢查每個前綴\n\n            → Step 5d: If word[0:i] not in builtWords then flag可構建 = false, break // 前綴缺失，無法構建\n\n        → Decision: 如果 flag可構建? // 前綴都存在，則可構建\n\n            Yes → Step 5e: Add word to builtWords // 加入集合\n\n            No  → Step 5f: Continue to next word // 無法構建，跳過\n\n→ Step 6: Decision: 如果 word 可構建? // 確保只有可構建的單詞進行更新\n\n    Yes → Step 7: Decision: 如果 word.length > bestWord.length? // 判斷是否比目前最佳長度更長\n\n        Yes → Step 8: bestWord = word // 更新最佳答案\n\n        No  → Decision: 如果 word.length == bestWord.length? // 若長度相同\n\n            Yes → Decision: 如果 word lexicographically < bestWord? // 較小字典序\n\n                Yes → Step 9: bestWord = word // 更新為字典序較小\n\n                No  → Step 10: Do nothing // 保持現有答案\n\n            No  → Step 10: Do nothing // 不更新\n\n→ Step 11: End loop // 結束遍歷\n\n→ End // 返回 bestWord（若為空則返回空字符串） // 程式結束\n\nBut we need each line with arrow? Actually the format shows arrow in the lines after Start. So we use \"→\". For decisions, we indent children with spaces or tab? The example shows indent inside Decision block with spaces then Yes → ... etc. We'll follow.\n\nWe should add comments for each line.\n\nMake sure to not output actual code. Use Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Sort words by ascending length, then lexicographic order // 對單詞進行排序，確保較短或相同長度較小的字典序先處理\n→ Step 2: Initialize empty set builtWords // 用於儲存已能構建的單詞\n→ Step 3: Initialize bestWord as empty string // 儲存目前最長可構建單詞\n→ Step 4: For each word in sorted words // 逐個處理單詞\n    → Decision: 如果 word.length == 1? // 判斷是否為單字符單詞\n        Yes → Step 5a: Add word to builtWords // 直接能構建，加入集合\n        No  → Step 5b: Set flagCanBuild = true // 檢查前綴是否都已存在\n            → Step 5c: For i from 1 to word.length-1 // 檢查每個前綴\n                → Step 5d: If word[0:i] not in builtWords then flagCanBuild = false, break // 前綴缺失，無法構建\n            → Decision: 如果 flagCanBuild? // 前綴都存在，則可構建\n                Yes → Step 5e: Add word to builtWords // 加入集合\n                No  → Step 5f: Continue to next word // 無法構建，跳過\n    → Decision: 如果 word 可構建? // 確保只有可構建的單詞進行更新\n        Yes → Step 7: Decision: 如果 word.length > bestWord.length? // 判斷是否比目前最佳長度更長\n                Yes → Step 8: bestWord = word // 更新最佳答案\n                No  → Decision: 如果 word.length == bestWord.length? // 若長度相同\n                        Yes → Decision: 如果 word lexicographically < bestWord? // 較小字典序\n                                Yes → Step 9: bestWord = word // 更新為字典序較小\n                                No  → Step 10: Do nothing // 保持現有答案\n                        No  → Step 10: Do nothing // 不更新\n→ Step 11: End loop // 結束遍歷\nEnd // 返回 bestWord（若為空則返回空字符串） // 程式結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestWord(self, words):\n        \"\"\"\n        在已排序的單詞列表中逐個檢查，若能以已有單詞構成，則加入集合並更新答案。\n        \"\"\"\n        # 先按長度升序，長度相同則按字典序升序排序\n        words_sorted = sorted(words, key=lambda x: (len(x), x))\n        built = set()      # 已能構成的單詞集合\n        best = \"\"          # 最長可構成的單詞\n\n        for w in words_sorted:\n            # 若單字長度為 1 或所有前綴都已在 built 中，即可構成\n            if len(w) == 1 or all(w[:i] in built for i in range(1, len(w))):\n                built.add(w)\n                # 更新答案：更長或相同長度但字典序更小\n                if len(w) > len(best) or (len(w) == len(best) and w < best):\n                    best = w\n        return best\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，期望形如 words = [\"a\",\"b\",\"c\"]\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        list_str = data[start:end + 1]\n        words = ast.literal_eval(list_str)\n    except Exception:\n        # 若直接給列表字串，直接解析\n        words = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.longestWord(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"w\",\"wo\",\"wor\",\"worl\",\"world\"]",
          "expected_output": "world",
          "success": true,
          "output": "world"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"banana\",\"app\",\"appl\",\"ap\",\"apply\",\"apple\"]",
          "expected_output": "apple",
          "success": true,
          "output": "apple"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines: Start, steps, decisions, recursion, backtracking. Each line with explanation. We need to handle partition string s into all palindrome partitions. Provide pseudocode. Use recursion/backtracking.\n\nWe need to output in Chinese (繁體). Provide lines. Use arrows. We'll include variables: function Partition(s): result = []; Backtrack(start, path). Inside: if start == len(s): result.append(path.copy()); return. For end from start to len(s)-1: if substring s[start:end+1] is palindrome: path.append(substring); Backtrack(end+1, path); path.pop().\n\nAlso we need a function isPalindrome(sub): two pointers.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義 function Partition(s) // 主入口\n→ Step 2: 初始化結果列表 result ← []\n→ Step 3: 定義遞迴函式 Backtrack(start, path) // backtracking\n→ Decision: 如果 start == length of s? // 判斷是否已分割完\n    Yes → Step 4: 將 path 複製並加入 result // 收集完整解\n    No  → Step 5: 循環 end 取子字串 s[start:end+1]\n        → Decision: 子字串是否為回文? // 檢查 palindrome\n            Yes → Step 6: path 加入子字串\n                → Step 7: Backtrack(end+1, path) // 進一步分割\n                → Step 8: path 從尾部移除子字串 // 回溯\n            No  → No action // 跳過非回文子字串\n→ Step 9: 呼叫 Backtrack(0, []) // 開始\n→ Step 10: 回傳 result // 返回所有分割結果\nEnd\n\nAlso need helper function isPalindrome(s, left, right) with two pointers.\n\nAdd that as separate steps before Partition.\n\nLet's produce full virtual code with explanation lines. Ensure each line has comment after //.\n\nWe need to include helper function definitions. Use arrow and indentation? The example used indentation but not necessary. We'll maintain same style.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 IsPalindrome(str, left, right) // 檢查子字串是否回文\n    → Step 1.1: while left < right\n        → Decision: str[left] == str[right] ?\n            Yes → left ← left + 1 // 移到下一對\n            No  → Return False // 不是回文\n    → Step 1.2: Return True // 所有對比均相同\n\nThen Partition.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 IsPalindrome(str, left, right) // 檢查子字串是否為回文  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 1.1: while left < right // 循環比較對稱字符  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: str[left] == str[right] ? // 是否相同  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → left ← left + 1 // 右移左指針  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Return False // 不相同即非回文  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 1.2: Return True // 所有對比均相同，為回文  \nEnd // IsPalindrome 定義完成  \n\nStart // 進入主程式  \n→ Step 2: 定義函式 Partition(s) // 主入口，輸入為欲分割字串  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.1: result ← [] // 用於儲存所有合法分割  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.2: 定義遞迴函式 Backtrack(start, path) // backtracking  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: start == length(s) ? // 已分割完所有字符？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.2.1: result.append(path.copy()) // 收集完整解  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 2.2.2: for end from start to length(s)-1 // 產生子字串  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: IsPalindrome(s, start, end) ? // 子字串是否回文？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.2.2.1: path.append(s[start:end+1]) // 加入分割  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.2.2.2: Backtrack(end+1, path) // 進一步分割  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.2.2.3: path.pop() // 回溯，移除最後一段  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → No action // 跳過非回文子字串  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.3: Backtrack(0, []) // 從頭開始分割  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2.4: Return result // 返回所有合法分割  \nEnd // 主程式結束\n\nStart // 執行入口  \n→ Step 3: print(Partition(\"aab\")) // 範例執行，輸出 [\"a\",\"a\",\"b\"], [\"aa\",\"b\"]  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def partition(self, s: str):\n        res = []\n\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        def dfs(start: int, path: list):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    dfs(end, path + [s[start:end]])\n\n        dfs(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n\n    # 嘗試從輸入中抓取被雙引號包起來的字串\n    match = re.search(r'\\\"(.*?)\\\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有雙引號，直接去除首尾空白與可能的引號\n        s = data.strip().strip('\"').strip(\"'\")\n\n    solution = Solution()\n    result = solution.partition(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[['a', 'a', 'b'], ['aa', 'b']]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[['a']]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanations. The task: multiply two non-negative integer strings without BigInteger, produce product string. Use standard long multiplication algorithm. Provide steps: reverse strings, array for results length len1+len2, iterate digits multiply, add carry, convert to string skipping leading zeros.\n\nWe'll produce Start, Steps, Decision, End. Use \"Step\" lines. Ensure each line has // explanation after a space.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得字串 num1 與 num2 // 取得兩個輸入字串  \n→ Step 2: 取得 len1 ← 長度(num1) // 取得第一個字串長度  \n→ Step 3: 取得 len2 ← 長度(num2) // 取得第二個字串長度  \n→ Decision: 如果 num1 為 \"0\" 或 num2 為 \"0\"? // 檢查是否有零  \n Yes → Step 4: 輸出 \"0\" // 任一輸入為零，結果為零  \n No  → Step 5: 建立 result ← 數組長度 len1+len2 且所有元素為 0 // 用於儲存乘積各位  \n→ Step 6: 反轉 num1 為 rev1 // 反轉為易於從低位開始計算  \n→ Step 7: 反轉 num2 為 rev2 // 反轉為易於從低位開始計算  \n→ Step 8: 迴圈 i 從 0 到 len1-1  \n  → Step 9: 取得 digit1 ← 數字(rev1[i]) // 取第一個字串低位數字  \n  → Step 10: 迴圈 j 從 0 到 len2-1  \n    → Step 11: 取得 digit2 ← 數字(rev2[j]) // 取第二個字串低位數字  \n    → Step 12: 乘積 ← digit1 * digit2 + result[i+j] // 乘法加上已有的位值  \n    → Step 13: result[i+j] ← 乘積 mod 10 // 更新低位  \n    → Step 14: result[i+j+1] ← result[i+j+1] + 乘積 div 10 // 將進位加到下一位  \n→ Step 15: 迴圈 k 從 result.length-1 到 0  \n  → Decision: 如果 result[k] 為 0? // 跳過前導零  \n    Yes → Step 16: 連接空字串 // 不加入任何字符  \n    No  → Step 17: 連接 result[k] 為字元 // 加入當前位  \n→ Step 18: 輸出連接後的字串 // 返回乘積字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 直接處理乘以 0 的情況\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 結果位數不超過 m + n\n        pos = [0] * (m + n)\n\n        # 從高位到低位做長乘法\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        # 轉成字串並去除前導 0\n        result = \"\".join(map(str, pos)).lstrip(\"0\")\n        return result if result else \"0\"\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中抽取兩個被單引號包起來的數字字串\n    nums = re.findall(r\"'(\\d+)'\", data)\n    if len(nums) < 2:\n        # 若輸入格式不符，直接結束\n        sys.exit(0)\n\n    num1, num2 = nums[0], nums[1]\n    solver = Solution()\n    print(solver.multiply(num1, num2))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": true,
          "output": "56088"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: given list of times, find minimum difference between any two times in minutes, times are 24-hour clock \"HH:MM\". Approach: convert each to minutes since midnight, sort, then compute differences between adjacent and wrap around between last and first + 1440. Output min. Steps:\n\nStart\n→ Step: Read list times // input list\n→ Step: Convert each time string to minutes since midnight // parse HH,MM to minutes\n→ Step: Store in array MinutesList\n→ Step: Sort MinutesList ascending // sorting\n→ Step: Initialize minDiff = large // set high\n→ Decision: iterate i from 0 to len-2 // compute difference with next\n    Yes → Step: diff = MinutesList[i+1] - MinutesList[i]\n    Yes → Step: if diff < minDiff then minDiff = diff\n→ Step: compute wrapDiff = (MinutesList[0] + 1440) - MinutesList[last] // difference between first after midnight and last\n→ Step: if wrapDiff < minDiff then minDiff = wrapDiff\n→ Step: Return minDiff\nEnd\n\nNeed virtual code lines with arrows and comments. Ensure \"Step\" prefix. Provide explanation after space.\n\nWe'll format each line as \"虛擬碼步驟 // 解釋\". Use arrows. Eg: \"Start // 程式開始執行\".\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 讀取時間點清單 TimesList // 從使用者或資料來源取得「HH:MM」格式的時間清單  \n→ Step: 建立空陣列 MinutesList // 用於存放轉換成分鐘數的時間值  \n→ Step: 對 TimesList 中每個時間字串 Time 做  \n  → Step: 解析 HH 與 MM // 把 \"HH:MM\" 分割為兩個整數  \n  → Step: 計算 minutes = HH × 60 + MM // 把時間轉換成自午夜以來的分鐘數  \n  → Step: 把 minutes 加入 MinutesList // 進一步建立分鐘列表  \n→ Step: 將 MinutesList 依升序排序 // 方便計算相鄰時間差  \n→ Step: 設定 minDiff = 9999 // 初始化為一個較大值  \n→ Step: 依序遍歷 i 從 0 到 MinutesList.Length-2  \n  → Step: diff = MinutesList[i+1] - MinutesList[i] // 計算相鄰兩個時間差  \n  → Decision: 如果 diff < minDiff? // 檢查是否為目前最小差值  \n   Yes → Step: minDiff = diff // 更新最小差值  \n   No  → // 保持原值  \n→ Step: wrapDiff = (MinutesList[0] + 1440) - MinutesList[MinutesList.Length-1] // 兩極端時間之差，考慮跨午夜  \n→ Decision: 如果 wrapDiff < minDiff? // 判斷跨午夜差值是否更小  \n  Yes → Step: minDiff = wrapDiff // 更新最小差值  \n  No  → // 保持原值  \n→ Step: 回傳 minDiff // 回傳最小分鐘差值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\ndef find_min_difference(time_points):\n    \"\"\"計算時間點列表中任兩個時間點的最小分鐘差值。\"\"\"\n    # 1. 先把每個 HH:MM 轉成自午夜以來的分鐘數\n    minutes = []\n    for t in time_points:\n        h, m = map(int, t.split(':'))\n        minutes.append(h * 60 + m)\n\n    # 2. 排序，方便計算相鄰差值\n    minutes.sort()\n\n    # 3. 依序檢查相鄰兩點的差值\n    min_diff = 1440  # 最多差值為 24 小時\n    for i in range(1, len(minutes)):\n        diff = minutes[i] - minutes[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n\n    # 4. 考慮跨午夜的差值\n    wrap_diff = 1440 - (minutes[-1] - minutes[0])\n    if wrap_diff < min_diff:\n        min_diff = wrap_diff\n\n    return min_diff\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 資料為 JSON 格式，例如 '[\"23:59\",\"00:00\"]'\n    time_points = json.loads(data)\n\n    result = find_min_difference(time_points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode665.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Array",
    "description_snippet": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines describing algorithm. We need step by step. The requirement: gradually produce virtual code lines with explanation. Should be in Traditional Chinese. Each line: virtual code step + space + // explanation. Use arrows, Decision:, Start, End. Should be step by step.\n\nAlgorithm: iterate over array, find violations where nums[i] > nums[i+1]. Count violations. If count > 1 return false. If count <=1, check whether modifying element can fix: check at violation index i, we can adjust nums[i] to <= nums[i+1] or nums[i+1] to >= nums[i-1]. Condition: if i==0 or nums[i-1] <= nums[i+1] then ok. Else if i+2>=n or nums[i] <= nums[i+2] then ok else false.\n\nWe produce pseudocode lines.\n\nNeed to start with Start, End, Step 1 etc.\n\nLet's craft lines:\n\nStart\n→ Step 1: Initialize count = 0, n = length(nums)\n→ Decision: If n <= 2? // array of size 0-2 always non-decreasing\n    Yes → Step 2: Return true // trivial case\n    No → Step 3: for i from 0 to n-2: // iterate pairs\n        → Step 4: If nums[i] > nums[i+1] then\n            → Step 5: Increment count\n            → Decision: If count > 1 then\n                → Step 6: Return false // more than one violation\n                → End\n            → Decision: Check if i==0 or nums[i-1] <= nums[i+1] then\n                → Step 7: // modification possible by lowering nums[i]\n                → No  → Decision: If i+2>=n or nums[i] <= nums[i+2] then\n                    → Step 8: // modification possible by raising nums[i+1]\n                    → No → Step 9: Return false // cannot fix\n        → End loop\n→ Step 10: Return true // no issues found\nEnd\n\nNeed to add arrow formatting: For nested decisions we might indent. Use arrow for lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0, n = nums.length // 以備後續統計違規次數  \n→ Decision: 如果 n <= 2? // 數列長度 ≤ 2 永遠可調整為非遞減  \n  Yes → Step 2: 回傳 true // 簡易情況直接結束  \n  No  → Step 3: 從 i = 0 到 n-2 迭代 // 檢查相鄰元素的關係  \n    → Step 4: 如果 nums[i] > nums[i+1] 那麼 // 發現一次遞減違規  \n      → Step 5: count++ // 記錄違規次數  \n      → Decision: 如果 count > 1? // 超過一次違規就不可能只改一個元素  \n        Yes → Step 6: 回傳 false // 結束程式  \n        No  → Decision: 如果 i == 0 或 nums[i-1] <= nums[i+1]? // 可否把 nums[i] 降低以符合規則  \n          Yes → Step 7: // 這個位置的元素可被調整，繼續檢查剩餘數列  \n          No  → Decision: 如果 i+2 >= n 或 nums[i] <= nums[i+2]? // 或者把 nums[i+1] 升高以符合規則  \n           Yes → Step 8: // 這個位置的元素可被調整，繼續檢查剩餘數列  \n           No  → Step 9: 回傳 false // 無法僅改一個元素即可修正  \n    → End for  \n→ Step 10: 回傳 true // 迴圈結束後未超過一次違規，或所有違規都可被修正  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def checkPossibility(self, nums):\n        \"\"\"\n        檢查是否只改動最多一個元素即可使數列非遞減。\n        \"\"\"\n        count = 0  # 違規次數\n        n = len(nums)\n        for i in range(1, n):\n            if nums[i] < nums[i - 1]:\n                count += 1\n                if count > 1:          # 超過一次違規，無法僅改一個元素\n                    return False\n                # 判斷哪個元素更適合調整\n                if i == 1 or nums[i] >= nums[i - 2]:\n                    nums[i - 1] = nums[i]  # 把前一個元素調整為 nums[i]\n                else:\n                    nums[i] = nums[i - 1]  # 把目前元素調整為 nums[i-1]\n        return True\n\ndef main():\n    \"\"\"\n    從標準輸入讀取數列，執行判斷，並輸出 'true' 或 'false'。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中提取列表字面量，例如 \"[4,2,3]\"\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group()\n        nums = eval(nums_str)  # 直接解析成 list，假設輸入安全\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.checkPossibility(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,2,3]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [4,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: count number of arithmetic subsequences of length >=3. Classic DP with maps per index: dp[i][diff] number of subsequences ending at i with diff. For each pair (i,j), diff = nums[i]-nums[j]. Let count = dp[j][diff]; then we add to answer count (for sequences of length >=3) and update dp[i][diff] += count + 1 (for new pair). The answer fits 32-bit.\n\nWe need to produce step-by-step pseudocode with explanations. Use Start, End, Decision.\n\nWe need to output per line: virtual code step + // explanation.\n\nLet's outline algorithm:\n\nStart\n→ Input array nums\n→ Initialize result = 0\n→ For each index i from 0 to n-1:\n   → Create empty map diffCount for this index (dp[i])\n   → For each j from 0 to i-1:\n      → diff = nums[i] - nums[j]\n      → prev = dp[j].get(diff, 0)\n      → result += prev   // add sequences of length >=3\n      → dp[i][diff] = dp[i].get(diff, 0) + prev + 1  // extend prev sequences and add pair\n→ End // output result\n\nWe need to use Start, End, Decision: but no decision needed except loops.\n\nWe can incorporate Decision: maybe if prev >0? But we can skip.\n\nHowever instructions: use Decision and arrows for loops too. They expect arrow syntax for steps and decisions. We'll produce loops as arrows.\n\nExample:\n\nStart // 程式開始執行\n→ Input nums // 讀入整數陣列\n→ result = 0 // 初始化答案\n→ For i from 0 to len(nums)-1 // 逐位遍歷每個元素\n    → diffMap_i = empty map // 每個位置的差值計數表\n    → For j from 0 to i-1 // 以前元素作為前置\n        → diff = nums[i] - nums[j] // 兩個元素之差\n        → prev = dp[j].get(diff, 0) // 以前已完成的相同差值序列數\n        → result += prev // 這些序列延長後長度 >=3，計入答案\n        → dp[i][diff] = dp[i].get(diff, 0) + prev + 1 // 加入新序列\n→ End // 輸出答案\n\nBut we also need the dp structure defined: dp = list of maps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ n = length(nums) // 獲取陣列長度\n→ dp = array of n empty maps // dp[i] 儲存以 nums[i] 結束的差值計數\n→ result = 0 // 結果累計\n→ For i from 0 to n-1\n    → For j from 0 to i-1\n        → diff = nums[i] - nums[j]\n        → prev = dp[j].get(diff, 0)\n        → result += prev\n        → dp[i][diff] = dp[i].get(diff, 0) + prev + 1\n→ End // 回傳 result\n\nAlso may add Decision: If prev > 0? But not necessary.\n\nWe should adhere to format: each line is \"虛擬碼步驟 // 解釋\". Use arrow for step. Provide indentation? In example, they use arrow before each step. We can include indentation with tabs.\n\nAlso need Decision for loops? Not needed. But we can keep loops as \"→ For ...\" as step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ n = length(nums) // 取得陣列長度  \n→ dp = array of n empty maps // dp[i] 儲存以 nums[i] 結束的差值計數表  \n→ result = 0 // 初始化答案  \n\n→ For i from 0 to n-1 // 遍歷每個元素作為序列最後一個  \n    → For j from 0 to i-1 // 遍歷前面的元素作為序列前一個  \n        → diff = nums[i] - nums[j] // 兩個元素之差  \n        → prev = dp[j].get(diff, 0) // 以前已完成的相同差值序列數  \n        → result += prev // 這些序列延長後長度 ≥3，加入答案  \n        → dp[i][diff] = dp[i].get(diff, 0) + prev + 1 // 更新 dp[i]，加入新序列  \n\nEnd // 輸出結果，返回 result (符合 32 位整數限制)",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]\n                dp[i][diff] += count + 1\n                total += count\n\n        return total\n\ndef parse_input(text):\n    \"\"\"Parse input that may look like 'nums = [1,2,3]' or just a list.\"\"\"\n    text = text.strip()\n    if not text:\n        return []\n    # Remove any leading 'nums ='\n    if text.lower().startswith('nums'):\n        idx = text.find('[')\n        if idx != -1:\n            text = text[idx:]\n    # Use literal_eval for safety\n    return ast.literal_eval(text)\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = Solution().numberOfArithmeticSlices(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Best Time to Buy and Sell Stock with Cooldown (Leetcode 309). We need to produce step-by-step algorithm, not actual code, but pseudocode with arrows and decision. The user wants virtual code lines with // explanations after each line. We'll provide algorithm: dynamic programming with states: hold, sold, rest. Iterate days. Use DP arrays or variables.\n\nLet's craft virtual code lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 n = length(prices) // 獲取天數\n→ Decision: 如果 n == 0? // 無股票價格時\n    Yes → Step 2: Return 0 // 沒有任何交易可做\n    No  → Step 3: 初始化三個變數\n        → sell = 0 // 前一天賣出後處於冷卻\n        → hold = -prices[0] // 立即買入第一天\n        → rest = 0 // 前一天沒有持股也沒賣出\n\nThen loop i from 1 to n-1:\n→ Step 4: Set newHold = max(hold, rest - prices[i]) // 保持持股或從休息狀態買入\n→ Step 5: Set newSell = hold + prices[i] // 前一天持股並賣出\n→ Step 6: Set newRest = max(rest, sell) // 前一天冷卻或休息持續\n\n→ Step 7: Update hold = newHold; sell = newSell; rest = newRest // 更新狀態\n\nAfter loop:\n→ Step 8: Return max(sell, rest) // 最終最大利潤為賣出或休息\n\nEnd\n\nWe need to include arrows: Start, End, Decision: etc.\n\nEach line: \"Start // 程式開始執行\". Next lines with \"→\". Use indent for decisions.\n\nMake sure to keep lines as per requirement.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(prices) // 取得股票價格陣列長度  \n→ Decision: 如果 n == 0? // 若沒有任何價格  \n    Yes → Step 2: Return 0 // 無交易，利潤為 0  \n    No  → Step 3: 初始化三個狀態變數  \n        → sell = 0 // 前一日已賣出，處於冷卻  \n        → hold = -prices[0] // 直接在第一天買入股票  \n        → rest = 0 // 前一日無持股且未賣出  \n\n→ Step 4: 循環 i = 1 to n-1 // 遍歷每一天  \n    → newHold = max(hold, rest - prices[i]) // 保持持股或從休息狀態購買  \n    → newSell = hold + prices[i] // 前一日持股並賣出  \n    → newRest = max(rest, sell) // 前一日休息或冷卻持續  \n\n→ Step 5: 更新狀態  \n    → hold = newHold  \n    → sell = newSell  \n    → rest = newRest  \n\n→ Step 6: 結束循環  \n\n→ Step 7: Return max(sell, rest) // 最終利潤為賣出或休息的較大值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        n = len(prices)\n        hold = -prices[0]  # 持有股票時的最大收益\n        sold = 0           # 剛賣出的最大收益\n        rest = 0           # 既不持股也沒剛賣出的最大收益\n        for price in prices[1:]:\n            prev_sold = sold\n            sold = hold + price            # 今天賣出\n            hold = max(hold, rest - price) # 今天持有或買入\n            rest = max(rest, prev_sold)    # 今天休息\n        return max(sold, rest)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，返回價格列表。\n    支援兩種格式：\n    1. 直接列表，例如 \"[1,2,3,0,2]\"\n    2. \"prices = [1,2,3,0,2]\"\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # 先嘗試直接 eval\n    try:\n        # 若包含 'prices' 關鍵字，先去除\n        if '=' in data:\n            _, list_part = data.split('=', 1)\n            list_part = list_part.strip()\n        else:\n            list_part = data\n        # 使用 eval 轉成列表，安全性此題可接受\n        prices = eval(list_part, {\"__builtins__\": None}, {})\n        if isinstance(prices, list):\n            return prices\n        else:\n            return []\n    except Exception:\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    prices = parse_input(raw_input)\n    result = Solution().maxProfit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese. Problem: find h-index for sorted citations ascending. Need log time. Approach: binary search for h: find largest index i such that citations[i] >= n-i, where n = length. h = n - i. Steps: Start, define n, low=0, high=n-1, while low <= high: mid, compute needed = n - mid. If citations[mid] >= needed: low = mid +1, else high = mid -1. After loop, h = n - (high+1). End. Provide explanation per line. Use arrows. Provide each line with explanation. Use Start and End. Use Decision: lines. We'll include binary search logic. Let's produce.\n\nRemember: \"虛擬碼步驟\" and comment after space. Use \"→\". Use \"Decision:\" when evaluating. Provide explanation.\n\nLet's produce step lines:\n\nStart\n→ Step 1: 取得 n = 議題長度 // array length\n→ Step 2: 設 low = 0, high = n - 1 // 初始化二分搜尋區間\n→ Decision: low ≤ high? // 判斷搜尋是否還可進行\n    Yes →\n        → Step 3: mid = (low + high) / 2 // 取中間索引\n        → Step 4: required = n - mid // 需要至少 cited times 的數量\n        → Decision: citations[mid] ≥ required? // 判斷該索引是否符合 h 指標條件\n            Yes →\n                → Step 5: low = mid + 1 // 將搜尋區間右移，尋找更大的 h\n            No  →\n                → Step 6: high = mid - 1 // 將搜尋區間左移，縮小 h\n    No  →\n→ Step 7: h = n - (high + 1) // 根據最後 high 計算 h-index\n→ Step 8: 回傳 h // 結果輸出\nEnd\n\nEnsure each line has \"// 解釋\". Use proper Chinese.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← 議題長度 // 取得 array 的長度  \n→ Step 2: low ← 0, high ← n - 1 // 初始化二分搜尋區間  \n→ Decision: low ≤ high? // 判斷是否還有區間可搜尋  \n    Yes →  \n        → Step 3: mid ← (low + high) / 2 // 取得中間索引  \n        → Step 4: required ← n - mid // 至少需要被引用的次數  \n        → Decision: citations[mid] ≥ required? // 檢查該索引是否符合 h 指標條件  \n            Yes →  \n                → Step 5: low ← mid + 1 // 將搜尋區間右移，尋找更大的 h  \n            No →  \n                → Step 6: high ← mid - 1 // 將搜尋區間左移，縮小 h  \n    No →  \n→ Step 7: h ← n - (high + 1) // 根據最後 high 計算 h-index  \n→ Step 8: 回傳 h // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        將已排序的 citations 進行二分搜尋，找到最大的 h 使\n        至少 h 篇文章被引用至少 h 次。\n        \"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            needed = n - mid  # 需要至少 cited times 的數量\n            if citations[mid] >= needed:\n                # 符合條件，嘗試找更大的 h\n                left = mid + 1\n            else:\n                # 不符合條件，縮小搜尋範圍\n                right = mid - 1\n        # left 指向第 one 證書數小於所需的第一個位置\n        return n - left\n\ndef parse_citations(input_str: str):\n    \"\"\"\n    從輸入字串中抽取列表。\n    假設輸入類似 'citations = [0,1,3,5,6]' 或只是一個列表字串。\n    \"\"\"\n    input_str = input_str.strip()\n    # 找到第一個 '[' 和最後一個 ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    list_str = input_str[start:end + 1]\n    try:\n        # 使用 eval 解析列表字串，因為輸入由題目給定，安全可接受\n        return eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data:\n        sys.exit(0)\n    citations = parse_citations(data)\n    result = Solution().hIndex(citations)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the frog crossing problem. It's like LeetCode 403. We'll output pseudo code lines. Should cover algorithm: use set for stones, DFS with memoization or BFS. We'll produce step-by-step. Let's design.\n\nStart\n→ Step: create set of stone positions\n→ Step: initialize memoization map\n→ Decision: if first stone not 0 or stones[1] != 1? But typical.\n\nWe need to illustrate algorithm: DFS from index 0 with last jump k. If reach last stone, return true.\n\nPseudo: function canCross(stones): set = set(stones); memo = dict(); return dfs(0,0). But first jump must be 1.\n\nSimplify: use recursive with memoization: key (index,lastJump). We'll produce pseudo lines accordingly.\n\nWe need to produce per line with explanation. Let's craft.\n\nWe'll use indentation with arrows. Use \"Decision:\" with Yes/No.\n\nLet's create.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立石頭位置集合 stonesSet ← Set(石頭列表) // 方便 O(1) 查找\n→ Step 2: 建立記憶表 memo ← 空映射 // 針對 (index, lastJump) 進行快取\n→ Step 3: 呼叫遞迴判斷函式 CanCross(index=0, lastJump=0) // 初始於第一顆石頭，未跳任何距離\n→ Decision: CanCross 是否回傳 True? // 判斷整體能否過河\n    Yes → Step 4: 輸出 \"可以過河\" // 成功跨越最後一塊石頭\n    No  → Step 5: 輸出 \"無法過河\" // 無法達到最後一塊石頭\nEnd // 程式執行結束\n\n// ----------------------------------------------------\n// 下面為遞迴函式 CanCross 的虛擬碼\n// ----------------------------------------------------\nStart // CanCross 函式開始\n→ Decision: (index == stonesList.length - 1)？ // 是否已站在最後一塊石頭？\n    Yes → Return True // 成功過河\n    No  → Step 6: 檢查 memo[(index, lastJump)] 是否已記錄 // 快取檢查\n        Yes → Return memo[(index, lastJump)] // 直接回傳快取結果\n        No  → // 進行跳躍嘗試\n→ Step 7: 設定 result ← False // 預設無法通過\n→ Step 8: 對於 delta in {lastJump-1, lastJump, lastJump+1} 循環 // 三種可能的跳躍距離\n        Decision: delta <= 0？ // 跳躍距離必須為正\n            Yes → Continue // 跳過此 delta\n            No  → // 计算下一位置\n→ Step 9: nextPos ← stonesList[index] + delta // 下一石頭位置\n→ Decision: stonesSet.contains(nextPos)？ // 下一位置是否有石頭？\n    Yes → Step 10: result ← result OR CanCross(nextIndex, delta) // 递归探查\n    No  → Continue // 沒石頭，跳過\n→ Step 11: 结束循环\n→ Step 12: memo[(index, lastJump)] ← result // 存入快取\n→ Step 13: Return result // 返回此路徑是否成功\nEnd // CanCross 函式結束\n\n// ----------------------------------------------------\n// 先前假設：第一跳必須為 1 單位\n// ----------------------------------------------------\nStart // 檢查第一跳合法性\n→ Decision: stonesList[1] != 1？ // 第二塊石頭是否在 1 單位處\n    Yes → Return False // 無法完成第一跳，直接失敗\n    No  → // 可以進行正常遞迴\n→ Step 14: Return CanCross(0, 1) // 以 1 單位作為第一跳距離呼叫遞迴\nEnd // 檢查結束\n\n// ----------------------------------------------------\n// 整體流程結合\n// ----------------------------------------------------\nStart // 主程序開始\n→ Step 15: stonesList ← 輸入石頭位置 (已排序)\n→ Step 16: 若 stonesList 為空或 stonesList[0] != 0，Return False // 必須從 0 單位起跳\n→ Step 17: 呼叫上面定義的檢查與遞迴流程\nEnd // 主程序結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\ndef can_cross(stones):\n    \"\"\"判斷蛙是否能從第一塊石頭跳到最後一塊石頭。\"\"\"\n    if not stones:\n        return False\n    if stones[0] != 0:\n        return False\n    # 第一跳必須是 1 單位\n    if len(stones) > 1 and stones[1] != 1:\n        return False\n\n    stone_set = set(stones)\n    last_stone = stones[-1]\n    # 每塊石頭能到達時可能的跳距離集合\n    jumps = defaultdict(set)\n    jumps[0].add(0)\n\n    for stone in stones:\n        for k in jumps[stone]:\n            for step in (k - 1, k, k + 1):\n                if step <= 0:\n                    continue\n                nxt = stone + step\n                if nxt in stone_set:\n                    jumps[nxt].add(step)\n\n    return bool(jumps[last_stone])\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串轉成整數列表。\"\"\"\n    # 找出第一對中括號內的內容\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if not match:\n        return []\n    nums = match.group(1)\n    # 取出所有整數\n    return [int(x) for x in re.findall(r'-?\\d+', nums)]\n\ndef main():\n    raw = sys.stdin.read()\n    stones = parse_input(raw)\n    result = can_cross(stones)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]