{
  "run_index": 22,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 393,
  "generation_or_validation_failure_count": 46,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,3,2,5,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 3, 2, 5, 3]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳所有結果的串列\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Each line includes \"虛擬碼步驟\" and comment. Use arrow syntax. For function definition, we can use \"Start\" inside function? Probably:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 roll_dice(n) // 函式接受擲骰次數\n→ Step 2: 初始化 empty list results // 用來存結果\n→ Step 3: 迴圈 i 0 to n-1 // 重複擲骰\n    → Step 3a: 產生隨機數 1-6 // 模擬骰子\n    → Step 3b: 把隨機數加入 results // 收集結果\n→ Step 4: 回傳 results // 結果列表\nEnd // 程式結束\n\nBut we need arrow structure. For loops, we can show nested.\n\nAlso use \"Decision:\" only if needed.\n\nLet's produce step-by-step.\n\nUse \"→\" arrow at start of line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 roll_dice(n) // 宣告函式，接受擲骰次數 n\n→ Step 2: 初始化空列表 results // 用於存儲每次擲骰的結果\n→ Step 3: 迴圈 for i 1 到 n // 重複擲骰 n 次\n    → Step 3a: 生成隨機整數 dice_value 介於 1 與 6 // 模擬擲六面骰\n    → Step 3b: 將 dice_value 加入 results // 收集結果\n→ Step 4: 回傳 results // 返回所有擲骰結果\nEnd // 程式執行結束\n\nMake sure each line ends with comment after space. Use arrow for each. Use \"→\" at start. Use indentation with 4 spaces? Not specified. But show indentation.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 roll_dice(n) // 宣告函式，接受擲骰次數 n  \n→ Step 2: 初始化空列表 results // 用於存儲每次擲骰的結果  \n→ Step 3: 迴圈 for i 1 到 n // 重複擲骰 n 次  \n  → Step 3a: 生成隨機整數 dice_value 介於 1 與 6 // 模擬擲六面骰  \n  → Step 3b: 將 dice_value 加入 results // 收集結果  \n→ Step 4: 回傳 results // 返回所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需秒數，並回傳四捨五入到小數點 3 位的值。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    # 讀取整個標準輸入內容\n    code = sys.stdin.read()\n    # 執行讀入的程式碼，確保 measure_time 可被使用\n    exec_globals = {'measure_time': measure_time, '__builtins__': __builtins__}\n    exec(code, exec_globals)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code with explanations. Use Start, End, Decision, etc. Use arrow lines. The function measure_time takes func, *args, measures time, returns rounded result to 3 decimal places. Also might want to return time duration or function result? The requirement says \"測量函數 func 執行所需的秒數，並回傳結果\" which likely means return elapsed time. Could also include returning the function result? But instruction: \"回傳結果\" ambiguous. We'll assume returning elapsed time. Provide virtual code for function definition, import time, etc.\n\nNeed to produce virtual code line by line. Use arrow and decisions? Might not need decision. But we can include error check: maybe if no args. But simple.\n\nWe'll produce:\n\nStart // 程式開始\n→ Import time module // 引入 time\n→ Define function measure_time(func, *args) // 定義函式\n→ Decision: 是否有 func? // 確認 func 不是空\n    Yes → Step: record start time // 開始計時\n    No  → Step: 返回錯誤訊息 // 這邊可返回 None\n→ Execute func(*args) // 執行傳入函式\n→ Record end time // 記錄結束時間\n→ 計算 elapsed = end - start // 計算耗時\n→ Round elapsed to 3 decimal places // 四捨五入\n→ Return rounded elapsed // 回傳結果\nEnd // 程式結束\n\nBut we need to maintain virtual code style: \"→ Step 1: ...\" and arrow indent. For Decision we need indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time module // 引入 time 模組以取得計時功能  \n→ Define function measure_time(func, *args) // 定義 measure_time，接收目標函式及其參數  \n→ Decision: 是否傳入 func? // 確認 func 不是 None  \n Yes → Step 1: start = time.time() // 記錄開始時間  \n No  → Step 1: Return None // 若無函式，直接回傳 None  \n→ Step 2: result = func(*args) // 執行傳入函式，傳遞所有參數  \n→ Step 3: end = time.time() // 記錄結束時間  \n→ Step 4: elapsed = end - start // 計算執行所需秒數  \n→ Step 5: rounded = round(elapsed, 3) // 將秒數四捨五入到小數點 3 位  \n→ Step 6: Return rounded // 回傳計算得到的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"grape\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'grape', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（如果有的話），但不做任何處理\n    sys.stdin.read()\n    \n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n    \n    # 1. 使用 add() 新增 'orange'\n    fruits.add('orange')\n    \n    # 2. 使用 update() 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n    \n    # 3. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n    \n    # 4. 使用 discard() 嘗試移除 'pineapple'（不存在時不拋錯）\n    fruits.discard('pineapple')\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode with explanation comments after space. Each line with arrow, etc. No actual code. We'll produce Start, then steps.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合\n\n→ Step 2: 使用 add() 新增 'orange' 到 fruits // 新增單一元素\n\n→ Step 3: 使用 update() 新增 'grape' 與 'melon' 到 fruits // 批次新增多元素\n\n→ Step 4: 使用 remove() 移除 'banana' 從 fruits // 刪除指定元素\n\n→ Step 5: 使用 discard() 嘗試移除 'pineapple' // 若不存在不拋錯誤\n\n→ Step 6: 輸出 fruits // 顯示集合內容\n\nEnd // 程式結束\n\nBut need each line with format: `虛擬碼步驟 // 解釋`. Also use arrow `→` before each step. For decision we don't need. Use `Start` and `End`. Ensure each line has arrow and comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建集合 fruits = {'apple', 'banana'} // 初始化集合，包含兩個水果  \n→ Step 2: 使用 add() 新增 'orange' 到 fruits // 在集合中加入單一元素 'orange'  \n→ Step 3: 使用 update() 新增 'grape' 與 'melon' 到 fruits // 批次加入多個元素到集合  \n→ Step 4: 使用 remove() 移除 'banana' 從 fruits // 刪除集合中的 'banana' 元素，若不存在會錯誤  \n→ Step 5: 使用 discard() 嘗試移除 'pineapple' // 若元素不存在則不拋出錯誤，安全刪除  \n→ Step 6: 輸出 fruits // 顯示集合最終內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.76TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.76 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate():\n    \"\"\"\n    向 exchangerate-api 取得美元對台幣的匯率。\n    回傳浮點數，如果失敗回傳 None。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        resp = requests.get(url, timeout=5)\n        resp.raise_for_status()\n        data = resp.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef update_label(label):\n    \"\"\"\n    取得最新匯率並更新標籤文字。\n    \"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n    else:\n        label.config(text=\"更新失敗，請檢查網路連線\")\n\ndef launch_gui():\n    \"\"\"\n    建立 tkinter GUI，包含一個顯示匯率的標籤和一個更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    btn = tk.Button(win, text='更新匯率',\n                    command=lambda: update_label(label))\n    btn.pack(pady=5)\n\n    # 初始載入一次匯率\n    update_label(label)\n\n    win.mainloop()\n\ndef main():\n    \"\"\"\n    主入口函式。\n    1. 先從標準輸入讀取文字。\n    2. 若輸入中包含「更新匯率」或「按下」，則直接取得匯率並輸出到標準輸出。\n    3. 否則啟動 GUI 介面。\n    \"\"\"\n    # 讀取整個 stdin，並移除首尾空白\n    user_input = sys.stdin.read().strip()\n\n    # 判斷是否需要即時輸出匯率\n    if user_input and ('更新匯率' in user_input or '按下' in user_input):\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        launch_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with explanation, following format. Use Start, End, Decision, etc. Use arrow symbols. Must not output actual code. Provide steps: import modules, define function to fetch API, parse JSON, update label. Create Tkinter window, button, label, set command. Main loop.\n\nWe must produce each line like \"Start // 程式開始執行\". Use arrow like \"→ Step 1: Import modules requests and tkinter // import needed libraries\". Use decision points? Maybe decision for error handling? But can skip? Provide some decision for HTTP status. Use Decision: If response status 200? Yes / No. Good.\n\nLet's craft. Ensure each line is separate. Use indentation with arrow to show flow. Probably need to use tab or spaces. Example from prompt shows indent inside Decision. We'll replicate.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Import requests and tkinter as tk // 導入 HTTP 與 GUI 套件\n→ Step 2: 定義函式 fetch_rate() // 用於請求匯率資料\n→     Step 2.1: 發送 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得最新美元匯率\n→     Decision: 如果回傳 200? // 檢查請求是否成功\n→         Yes → Step 2.2: 解析 JSON，取得 'rates' -> 'TWD' // 取出台幣匯率\n→             Step 2.3: 返回匯率值 // 函式完成\n→         No  → Step 2.4: 顯示錯誤訊息 \"API request failed\" // 失敗時提示\n→ Step 3: 建立主視窗 root = tk.Tk() // 初始化 Tkinter 視窗\n→ Step 4: 建立標籤 rate_label = tk.Label(root, text=\"匯率未載入\") // 顯示匯率的文字\n→ Step 5: 放置標籤 rate_label 在視窗中 // 佈局\n→ Step 6: 建立更新按鈕 update_btn = tk.Button(root, text=\"更新匯率\") // 按鈕\n→ Step 7: 設定按鈕動作 update_btn.config(command=update_rate) // 按下時呼叫 update_rate\n→ Step 8: 放置按鈕 update_btn 在視窗中 // 佈局\n→ Step 9: 定義函式 update_rate() // 更新匯率的邏輯\n→     Step 9.1: 呼叫 fetch_rate() 並存儲回傳值為 rate // 取得最新匯率\n→     Step 9.2: 若 rate 不是 None? // 判斷是否成功取得\n→         Yes → Step 9.3: rate_label.config(text=f\"USD to TWD: {rate}\") // 更新標籤文字\n→         No  → Step 9.4: rate_label.config(text=\"取得匯率失敗\") // 更新為失敗訊息\n→ Step 10: 呼叫 update_rate() // 初始化時載入一次匯率\n→ Step 11: 執行主循環 root.mainloop() // 開始 GUI 事件迴圈\nEnd // 程式執行結束\n\nMake sure arrow usage consistent. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import requests and tkinter as tk // 導入 HTTP 與 GUI 套件\n→ Step 2: 定義函式 fetch_rate() // 用於請求匯率資料\n→     Step 2.1: 發送 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得最新美元匯率\n→     Decision: 如果回傳 200? // 檢查請求是否成功\n→         Yes → Step 2.2: 解析 JSON，取得 'rates' -> 'TWD' // 取出台幣匯率\n→             Step 2.3: 返回匯率值 // 函式完成\n→         No  → Step 2.4: 顯示錯誤訊息 \"API request failed\" // 失敗時提示\n→ Step 3: 建立主視窗 root = tk.Tk() // 初始化 Tkinter 視窗\n→ Step 4: 建立標籤 rate_label = tk.Label(root, text=\"匯率未載入\") // 顯示匯率的文字\n→ Step 5: 放置標籤 rate_label 在視窗中 // 佈局\n→ Step 6: 建立更新按鈕 update_btn = tk.Button(root, text=\"更新匯率\") // 按鈕\n→ Step 7: 設定按鈕動作 update_btn.config(command=update_rate) // 按下時呼叫 update_rate\n→ Step 8: 放置按鈕 update_btn 在視窗中 // 佈局\n→ Step 9: 定義函式 update_rate() // 更新匯率的邏輯\n→     Step 9.1: 呼叫 fetch_rate() 並存儲回傳值為 rate // 取得最新匯率\n→     Step 9.2: 若 rate 不是 None? // 判斷是否成功取得\n→         Yes → Step 9.3: rate_label.config(text=f\"USD to TWD: {rate}\") // 更新標籤文字\n→         No  → Step 9.4: rate_label.config(text=\"取得匯率失敗\") // 更新為失敗訊息\n→ Step 10: 呼叫 update_rate() // 初始化時載入一次匯率\n→ Step 11: 執行主循環 root.mainloop() // 開始 GUI 事件迴圈\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[None,[0,0],[2,0],[1,0],None,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[None, [0, 0], [2, 0], [1, 0], None, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.mapping = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        idx = self.mapping.get(r, r)\n        last = self.total - 1\n        self.mapping[r] = self.mapping.get(last, last)\n        self.total -= 1\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Ensure data can be parsed as a tuple of two lists\n    data = data.strip()\n    if not (data.startswith(\"(\") and data.endswith(\")\")):\n        data = \"(\" + data + \")\"\n\n    try:\n        commands, args = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(f\"Input format error: {e}\")\n\n    results = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif cmd == \"flip\":\n            results.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            results.append(None)\n        else:\n            raise ValueError(f\"Unknown command: {cmd}\")\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations. For the problem: design algorithm. We need to produce virtual code pseudocode steps. Let's outline algorithm: use reservoir sampling concept: treat matrix positions as a list 0..m*n-1. Maintain mapping dictionary from index to swapped index. Initially mapping empty. For flip: choose random integer r in [0, remaining-1]. Map to actual index: idx = mapping.get(r, r). Then decrement remaining. Also mapping[r] = mapping.get(remaining-1, remaining-1). Return row = idx // n, col = idx % n. For reset: clear mapping, set remaining = m*n.\n\nNow produce virtual code line by line with explanation. Ensure format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. We'll produce initialization lines, flip algorithm steps, reset. We'll include comment lines for explanation. Use arrow notation. Let's write.\n\nNeed to produce for entire solution class. We'll include class definition.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Initialize m, n, total = m * n // 計算矩陣總元素\n→ Step 2: remaining = total // 剩餘可選取的 0 位置數\n→ Step 3: mapping = empty map // 位置映射表，用於交換索引\n→ Step 4: End // 建構子完成\n\nflip function:\nStart // flip 開始\n→ Decision: If remaining == 0? // 檢查是否還有 0 位置\n    Yes → Raise error // 沒有可用位置\n    No  → Step 5: r = random_int(0, remaining-1) // 隨機選取剩餘範圍\n→ Step 6: idx = mapping.get(r, r) // 取得實際位置\n→ Step 7: last = remaining - 1 // 最後一個可用位置\n→ Step 8: mapping[r] = mapping.get(last, last) // 將 r 映射到最後位置\n→ Step 9: remaining = remaining - 1 // 減少剩餘數\n→ Step 10: row = idx // n // 轉換為行\n→ Step 11: col = idx % n // 轉換為列\n→ Step 12: Return [row, col] // 回傳選中的索引\nEnd // flip 完成\n\nreset function:\nStart // reset 開始\n→ Step 13: remaining = total // 重設剩餘數\n→ Step 14: mapping.clear() // 清空映射表\n→ Step 15: End // reset 完成\n\nBut need to incorporate class structure: Solution class with methods. Maybe separate lines for class start and method definitions.\n\nLet's produce a linear list of lines.\n\nEnsure each line uses \"→\" for steps. For decisions use \"Decision:\" and Yes/No branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Class Solution // 宣告 Solution 類別\n→ Step 2: Function __init__(self, m, n) // 建構子，接收矩陣尺寸\n→     Step 3: self.m = m // 儲存行數\n→     Step 4: self.n = n // 儲存列數\n→     Step 5: self.total = m * n // 計算總元素數\n→     Step 6: self.remaining = self.total // 剩餘可被選為 0 的位置\n→     Step 7: self.mapping = {} // 建立映射表，用於交換索引\n→ End // 建構子結束\n\n→ Function flip(self) // 隨機挑選一個 0 位置並置為 1\n→     Decision: If self.remaining == 0? // 檢查是否還有可選位置\n→         Yes → Raise Exception('No zeros left') // 若無可選，拋出錯誤\n→         No  → Step 8: r = random_int(0, self.remaining - 1) // 隨機取得一個剩餘索引\n→     Step 9: idx = self.mapping.get(r, r) // 取得實際矩陣索引\n→     Step 10: last = self.remaining - 1 // 最後一個剩餘位置\n→     Step 11: self.mapping[r] = self.mapping.get(last, last) // 將 r 映射到最後位置\n→     Step 12: self.remaining -= 1 // 減少剩餘數\n→     Step 13: row = idx // self.n // 轉換為行號\n→     Step 14: col = idx % self.n // 轉換為列號\n→     Step 15: Return [row, col] // 回傳選中的索引\n→ End // flip 結束\n\n→ Function reset(self) // 重置矩陣，將所有值改回 0\n→     Step 16: self.remaining = self.total // 重設剩餘數為總元素數\n→     Step 17: self.mapping.clear() // 清空映射表\n→ End // reset 結束\n\nEnd // 程式結束執行"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpru8dl0wq.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpru8dl0wq.py\", line 17, in main\n    data = sys.stdin.read().strip()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp66we64ml.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmp66we64ml.py\", line 17, in main\n    data = sys.stdin.read().strip()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import re\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        \"\"\"計算總被中毒秒數\"\"\"\n        if not timeSeries:                     # 沒有攻擊時間\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            # 本次攻擊對被中毒時間的實際貢獻\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration                      # 最後一次攻擊的完整持續時間\n        return total\n\ndef main():\n    \"\"\"從 stdin 讀取輸入，輸出結果到 stdout\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析時間序列列表\n    list_match = re.search(r'timeSeries\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if list_match:\n        list_str = list_match.group(1)\n        # 安全評估列表字串\n        try:\n            timeSeries = eval(list_str, {\"__builtins__\": None}, {})\n        except Exception:\n            timeSeries = []\n    else:\n        timeSeries = []\n\n    # 解析持續時間\n    dur_match = re.search(r'duration\\s*=\\s*(-?\\d+)', data)\n    duration = int(dur_match.group(1)) if dur_match else 0\n\n    solution = Solution()\n    result = solution.findPoisonedDuration(timeSeries, duration)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: compute total poisoned time given sorted attack times and duration. Steps: start, iterate over array, for each time, compute added time as max(0, min(duration, next_time - current_time)), accumulate. At end add full duration for last attack. Provide explanation after each line.\n\nLet's generate lines:\n\nStart\n→ Step 1: Initialize total = 0 // accumulate poison seconds\n→ Step 2: For i from 0 to len(timeSeries)-1 // iterate attacks\n    → Decision: If i < len-1? // not last attack\n        Yes → Step 3: diff = timeSeries[i+1] - timeSeries[i] // time until next attack\n             → Step 4: add = min(duration, diff) // effective poison seconds from this attack\n             → Step 5: total += add // accumulate\n        No  → Step 6: total += duration // last attack adds full duration\nEnd\n\nBut we should add also maybe handle empty array? Not needed but fine.\n\nLet's produce lines as per format, with arrow syntax: Use \"→\" and \"Yes →\", \"No →\".\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← 0 // 初始化累計被中毒的秒數  \n→ Step 2: For i ← 0 To len(timeSeries) - 1 // 遍歷每一次攻擊  \n  → Decision: i < len(timeSeries) - 1? // 是否還有下一次攻擊？  \n   Yes → Step 3: diff ← timeSeries[i + 1] - timeSeries[i] // 下一次攻擊前的時間間隔  \n    → Step 4: add ← min(duration, diff) // 本次攻擊對被中毒時間的實際貢獻  \n    → Step 5: total ← total + add // 累加到總中毒時間  \n   No  → Step 6: total ← total + duration // 最後一次攻擊直接增加完整持續時間  \nEnd // 程式執行結束，返回 total 即為 Ashe 被中毒的總秒數"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplo5s89fu.py\", line 86, in <module>\n    main()\n  File \"/tmp/tmplo5s89fu.py\", line 62, in main\n    obj.buildDict(arg)\n  File \"/tmp/tmplo5s89fu.py\", line 12, in buildDict\n    key = word[:i] + '*' + word[i+1:]\n          ~~~~~~~~~^~~~~\nTypeError: can only concatenate list (not \"str\") to list"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.patterns = {}\n\n    def buildDict(self, dictionary):\n        self.patterns.clear()\n        for word in dictionary:\n            for i in range(len(word)):\n                key = word[:i] + '*' + word[i+1:]\n                if key not in self.patterns:\n                    self.patterns[key] = set()\n                self.patterns[key].add(word)\n\n    def search(self, searchWord):\n        for i in range(len(searchWord)):\n            key = searchWord[:i] + '*' + searchWord[i+1:]\n            if key in self.patterns:\n                words = self.patterns[key]\n                if len(words) > 1 or searchWord not in words:\n                    return True\n        return False\n\n\ndef parse_input(data: str):\n    data = data.strip()\n    depth = 0\n    split_index = None\n    for idx, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n            if depth == 0:\n                split_index = idx\n                break\n    if split_index is None:\n        raise ValueError(\"Invalid input format\")\n    list1_str = data[:split_index + 1]\n    list2_str = data[split_index + 2:].strip()\n    list1 = json.loads(list1_str)\n    list2 = json.loads(list2_str)\n    return list1, list2\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    commands, arguments = parse_input(raw_input)\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif cmd == \"buildDict\":\n            obj.buildDict(arg)\n            results.append(None)\n        elif cmd == \"search\":\n            res = obj.search(arg[0] if isinstance(arg, list) else arg)\n            results.append(res)\n        else:\n            # Unknown command; skip or raise error\n            results.append(None)\n\n    # Convert Python None/True/False to LeetCode-like output\n    output = []\n    for r in results:\n        if r is None:\n            output.append('null')\n        elif r is True:\n            output.append('true')\n        elif r is False:\n            output.append('false')\n        else:\n            output.append(str(r))\n    print('[' + ', '.join(output) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. It's like design of MagicDictionary. We need to design data structure to check if changing exactly one character yields a word in dictionary. A typical solution: For each word, for each position replace with wildcard * or something, store mapping. Or use Trie and DFS with edit count. But virtual code should be stepwise. We'll produce algorithm: Build dictionary: For each word, for each index, create key with '*' placeholder. Use hash map from key to set of words. Then search: For searchWord, for each index, replace with '*' to form key, look up in map: if key exists and either the word is not same (needs exactly one change) or there are multiple words. Return true if any. Also consider exact match not allowed because need exactly one change.\n\nWe'll produce steps. We'll include decision points. Let's produce:\n\nStart\n→ Build: initialize empty map\n→ Build: for each word in dictionary: for each index i: key = word[0:i] + \"*\" + word[i+1:]\n→ Build: add word to set at map[key]\nEnd building\n\nSearch:\n→ Search: for each index i in searchWord: key = searchWord[0:i] + \"*\" + searchWord[i+1:]\n→ Decision: if key in map? // found words with same pattern\n    → Decision: if set size > 1 or word not equal to searchWord? // if different word exists\n        Yes → Return true\n        No  → Continue\n→ After loop: Return false\n\nLet's produce virtual code. Each line with comment. Use arrow for start of block? The example uses indentation for decisions. We'll follow similar.\n\nLet's write lines:\n\nStart // 開始流程\n→ BuildDictionary // 初始化並建立資料結構\n    → 初始化 emptyMap // 建立空的映射 key→word set\n    → For each word in dictionary: // 遍歷字典\n        → For i = 0 to len(word)-1:\n            → key = word[0:i] + \"*\" + word[i+1:] // 取代第 i 個字元為 *\n            → If key not in emptyMap: add empty set\n            → Add word to emptyMap[key] // 將單字加入對應模式\nEnd // 建構完成\n\nSearch(searchWord)\n→ For i = 0 to len(searchWord)-1:\n    → key = searchWord[0:i] + \"*\" + searchWord[i+1:]\n    → Decision: key in emptyMap? // 是否有匹配模式\n        Yes → Decision: emptyMap[key] contains word not equal to searchWord OR size>1? // 是否能改一個字得到不同單字\n            Yes → Return true\n            No  → // continue\n        No  → // continue\n→ Return false // 無法改一個字匹配任何單字\nEnd // 搜尋結束\n\nBut must follow format: each line: \"虛擬碼步驟 // 解釋\". We'll produce each line individually. Indentation to show decisions but each line still separate. Use arrows: \"→\" for steps. For decisions: \"Decision: ...\". Use \"Yes →\" etc.\n\nWe need each line has arrow and explanation.\n\nLet's produce code:\n\nStart // 程式開始執行\n→ BuildDictionary // 初始化資料結構\n    → Initialize emptyMap // 建立空的映射\n    → Decision: dictionary 非空? // 檢查是否有字典輸入\n        Yes → For each word in dictionary: // 遍歷每個單字\n            → Decision: word 不是空? // 檢查單字合法\n                Yes → For i = 0 to len(word)-1:\n                    → key = word[0:i] + \"*\" + word[i+1:] // 替換第 i 個字元為 *\n                    → Decision: key not in emptyMap? // 是否已存在此模式\n                        Yes → emptyMap[key] = empty set // 建立新集合\n                    → Add word to emptyMap[key] // 將單字加入集合\n                No → // 跳過空單字\n            No → // 跳過\n        No → // 沒有字典資料\nEnd // 建構完成\n\nSearch(searchWord)\n→ For i = 0 to len(searchWord)-1:\n    → key = searchWord[0:i] + \"*\" + searchWord[i+1:] // 產生匹配模式\n    → Decision: key in emptyMap? // 是否有此模式\n        Yes → Decision: emptyMap[key] contains word not equal to searchWord OR |emptyMap[key]| > 1? // 確認是否能改一個字得到不同單字\n            Yes → Return true // 找到符合條件\n            No  → // 繼續檢查其他位置\n        No  → // 繼續檢查其他位置\n→ Return false // 未找到符合條件\nEnd // 搜尋結束\n\nBut each line must have the virtual code and comment. For loops, decisions, etc each line separate.\n\nHowever, the formatting example shows arrows only for steps. For decision block, they indent further. So we can do similar.\n\nWe'll produce each line individually. Let's produce:\n\n```\nStart // 程式開始執行\n→ BuildDictionary // 初始化資料結構\n    → Initialize emptyMap // 建立空的映射 key → set\n    → Decision: dictionary 非空? // 是否有字典輸入\n        Yes → For each word in dictionary: // 遍歷每個單字\n            → Decision: word 非空? // 檢查單字合法\n                Yes → For i = 0 to len(word)-1: // 遍歷字元位置\n                    → key = word[0:i] + \"*\" + word[i+1:] // 替換第 i 個字元為 *\n                    → Decision: key not in emptyMap? // 是否已有此模式\n                        Yes → emptyMap[key] = empty set // 建立新集合\n                    → Add word to emptyMap[key] // 將單字加入集合\n                No → // 空單字跳過\n            No → // 無效單字跳過\n        No → // 無字典資料\nEnd // 建構完成\n\nSearch(searchWord)\n→ For i = 0 to len(searchWord)-1: // 遍歷搜尋字串位置\n    → key = searchWord[0:i] + \"*\" + searchWord[i+1:] // 產生匹配模式\n    → Decision: key in emptyMap? // 是否存在此模式\n        Yes → Decision: emptyMap[key] 只包含 searchWord 或集合大小為 1? // 檢查是否只有自己\n            No → // 有其他單字可改一字匹配\n                → Return true // 找到符合條件\n            Yes → // 只有自己，需繼續檢查\n        No → // 模式不存在，繼續\n→ Return false // 沒有符合條件的改法\nEnd // 搜尋結束\n```\n\nBut the format expects each line with \"虛擬碼步驟\" and comment separated by space. The indentation inside code can be shown but each line still separate. Also arrow for decisions. Let's ensure each line ends with comment. Also the indentation inside arrow for decision lines uses arrow \"→\". For \"Decision:\" lines, we don't put arrow? The example uses \"Decision:\" with no arrow. Then inside indent, we put \"Yes →\" etc. We'll replicate.\n\nWe must ensure each line has arrow \"→\" before step lines, but decision lines start with \"Decision:\" no arrow. Then inside indented lines with \"Yes →\" etc. We'll replicate accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildDictionary // 初始化資料結構  \n    → Initialize emptyMap // 建立空的映射 key → set  \n    → Decision: dictionary 非空? // 是否有字典輸入  \n        Yes → For each word in dictionary: // 遍歷每個單字  \n            → Decision: word 非空? // 檢查單字合法  \n                Yes → For i = 0 to len(word)-1: // 遍歷字元位置  \n                    → key = word[0:i] + \"*\" + word[i+1:] // 替換第 i 個字元為 *  \n                    → Decision: key not in emptyMap? // 是否已有此模式  \n                        Yes → emptyMap[key] = empty set // 建立新集合  \n                    → Add word to emptyMap[key] // 將單字加入集合  \n                No → // 空單字跳過  \n            No → // 無效單字跳過  \n        No → // 無字典資料  \nEnd // 建構完成  \n\nSearch(searchWord)  \n→ For i = 0 to len(searchWord)-1: // 遍歷搜尋字串位置  \n    → key = searchWord[0:i] + \"*\" + searchWord[i+1:] // 產生匹配模式  \n    → Decision: key in emptyMap? // 是否存在此模式  \n        Yes → Decision: emptyMap[key] 只包含 searchWord 或集合大小為 1? // 檢查是否只有自己  \n            No → // 有其他單字可改一字匹配  \n                → Return true // 找到符合條件  \n            Yes → // 只有自己，需繼續檢查  \n        No → // 模式不存在，繼續  \n→ Return false // 沒有符合條件的改法  \nEnd // 搜尋結束"
    },
    {
      "title": "Bulb Switcher II",
      "source_file": "Leetcode/leetcode672.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, presses = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_hghqa5o.py\", line 22, in <module>\n    n = int(data[0])\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7pwn6hub.py\", line 22, in <module>\n    n = int(data[0])\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn9min10u.py\", line 22, in <module>\n    n = int(data[0])\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def flipLights(self, n: int, presses: int) -> int:\n        if presses == 0:\n            return 1\n        if n == 1:\n            return 2\n        if n == 2:\n            return 4 if presses > 1 else 3\n        if presses == 1:\n            return 4\n        if presses == 2:\n            return 7\n        return 8\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit(0)\n    # 只取前兩個整數作為 n 與 presses\n    n = int(data[0])\n    presses = int(data[1]) if len(data) > 1 else 0\n    result = Solution().flipLights(n, presses)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode to compute number of distinct bulb states after exactly presses button presses on n bulbs with initial all on. Buttons: flip all; flip even; flip odd; flip indices j=3k+1 (i.e., 1 mod 3). We need to output number of different possible statuses after exactly presses presses.\n\nWe need to write virtual code line by line with explanation. We don't produce actual code, just structured pseudocode.\n\nWe need to think of algorithm: We can model each button as a vector of bits (bulb statuses). But we want number of distinct resulting states after exactly presses. Equivalent to counting distinct vectors reachable by linear combinations modulo 2? Each button flip is XOR of pattern. After presses, each button pressed certain number times. Since flip is XOR, pressing same button twice cancels. But we must press exactly presses times, so parity matters.\n\nWe need to consider sequences of length presses where order doesn't matter? But number of resulting states depends on which buttons pressed (multiset). Since pressing order doesn't change final state (XOR commutes). So we only need counts of each button pressed modulo 2, but the number of presses constraints.\n\nLet a,b,c,d be number of times pressing button1..4. We need a+b+c+d = presses. Final state = XOR of patterns: a*P1 + b*P2 + c*P3 + d*P4 (mod 2). So the state depends on parity of each count: a mod 2 etc. Because pressing twice cancels. So we only care about parity of each a,b,c,d. So we need to count distinct XOR combinations reachable where parities satisfy that sum of counts equals presses. Since counts mod 2 only matter, but number of solutions for a,b,c,d with given parities and sum presses may exist.\n\nGiven n up to maybe large, but we can compute number of distinct states as number of distinct XOR patterns reachable.\n\nWe can observe that the patterns are vectors over GF(2)^n. There are at most 16 possible combinations of parities (2^4). But not all may be reachable due to presses count parity. Condition: a+b+c+d = presses. Taking mod 2, sum of parities equals presses mod 2. Because each a,b,c,d mod 2 sum equals presses mod 2. So only parity patterns where parity sum = presses mod 2 are possible.\n\nAdditionally, we need to check that there exists a nonnegative integer solution for counts with given parities and total presses. For a given parity pattern, can we find nonnegative integers a,b,c,d with those parities and sum presses? Yes if presses >= minimal sum needed? For each parity, the minimal count with that parity is 0 or 1. So minimal sum = number of parities that are 1. So if presses >= that minimal sum and (presses - minimal sum) is even (since we can add 2 to any count to keep parity same), then solution exists. So all parity patterns with sum parity = presses mod 2 and minimal sum <= presses are reachable.\n\nThus reachable XOR patterns = set of XOR of button patterns with parities satisfying conditions. So we just need to compute distinct XOR results.\n\nWe can compute the four button patterns vectors:\n\nP1: all ones.\nP2: 1 at even indices.\nP3: 1 at odd indices.\nP4: 1 at indices 1 mod 3.\n\nWe need to compute set of XOR combinations. Since n may be large, but we can derive analytic count. The space spanned by these four vectors is at most rank 3? Let's check linear independence. Let's analyze.\n\nLet vector representation over GF(2)^n. Let E = pattern of even indices; O = odd indices; A = all ones; B = indices 1 mod 3. We have A = E XOR O (since all ones = even + odd). So A is linear combination of E and O. So rank <=3 (since A redundant). Also B may be combination of E and O? Let's check. Pattern 1 mod 3: positions 1,4,7,... Suppose n arbitrary. We need to see if B is linear independent from E and O. Let's compute B = pattern of 1 mod 3. We can express B in terms of E and O? Not necessarily. For example, positions 1,4,7: 1 is odd, 4 even, 7 odd. So B includes both parities. So it might not be combination of E and O. So rank might be 3. Let's analyze further. In GF(2), linear combination of E and O yields either all zeros, all ones (E+O), E, O. So cannot produce B if B is not one of these. So B is independent. Thus rank = 3. So the space spanned has size 2^3=8 distinct patterns.\n\nHowever, we must consider that we only allow XOR combinations where a,b,c,d parities satisfy sum parity = presses mod 2 and minimal sum <= presses. But that only restricts parity patterns; the XOR result might be same for different parity patterns. But maximum distinct patterns is at most 8.\n\nThus answer is min(8, number of reachable parity patterns). But we need to compute distinct XOR outputs, not just parity patterns.\n\nWe need to compute all possible XOR results from the set of allowed parity patterns. For each parity pattern (p1,p2,p3,p4) where p1+...+p4 ≡ presses mod 2, and minimal sum m = p1+p2+p3+p4 ≤ presses, and (presses - m) even, then XOR = p1*P1 + p2*P2 + p3*P3 + p4*P4.\n\nWe can precompute all possible XOR outputs for all parity patterns (2^4=16) and then filter those that are reachable given presses constraints. Then count unique XOR outputs.\n\nThus algorithm:\n\n- Compute patterns P1..P4 as bit strings maybe represented by counts? But we can just compute resulting status count? We can compute pattern equivalence: we only need to count distinct patterns, not actual vector. For counting distinct patterns, we can represent each pattern as tuple of counts? But n up to large; but we can compute the actual pattern using bitset of length n? Could be heavy. Instead we can compute whether two patterns are equal. Since patterns derived from linear combination of base vectors. The resulting pattern can be expressed in terms of E,O,B. Since rank 3, we can represent pattern as combination of basis {E,O,B}. But E,O,B not independent? E and O independent; B independent. So we can represent as (alpha, beta, gamma) in GF(2)^3 where pattern = alpha*E + beta*O + gamma*B.\n\nLet's compute mapping from parity pattern to coefficients. Let p1,p2,p3,p4.\n\nCompute XOR = p1*A + p2*E + p3*O + p4*B. Since A = E XOR O. So XOR = p1*(E+O) + p2*E + p3*O + p4*B = (p1+p2)*E + (p1+p3)*O + p4*B (mod 2). So coefficients:\n\nalpha = p1 XOR p2\nbeta = p1 XOR p3\ngamma = p4\n\nThus each parity pattern maps to (alpha, beta, gamma). So distinct patterns correspond to distinct tuples (alpha, beta, gamma). There are at most 8 combos.\n\nThus we just need to count number of distinct tuples reachable given presses constraints.\n\nThus answer = count of distinct tuples (alpha, beta, gamma) reachable.\n\nNow we need to count reachable tuples.\n\nGiven presses and n, but n not used in calculation? Wait patterns E,O,B depend on n for actual bit patterns but equality among them independent of n? Let's check if for some n, patterns E,O,B may not be distinct? For small n maybe E or O or B could be zero vector? Eg if n=1, E empty? Actually E: bulbs with even labels: if n=1, no even, so E is zero vector. O: odd labels: 1 -> vector 1. B: indices 1 mod 3: 1 -> vector 1. So O and B same; thus rank less than 3. So for small n, some patterns coincide. So distinctness depends on n. We need to analyze n general.\n\nSo we need to determine for given n, the number of distinct patterns of P1..P4.\n\nWe can analyze for n >= 3 maybe full rank 3. But we need to consider small n cases. Let's analyze:\n\nn=1: bulbs: only index1. Patterns:\n\nA: [1]\nE: [0]\nO: [1]\nB: [1] (since 1 mod 3)\n\nSo E=0, O=A=B=1. So distinct patterns: {0,1}. So only 2 states reachable.\n\nn=2: indices 1,2. Patterns:\n\nA: [1,1]\nE: [0,1]\nO: [1,0]\nB: indices 1 mod3 => 1 -> [1,0]\n\nSo B=O. Distinct patterns: A, E, O. Let's see if A and E+O? A=E+O? [0,1]+[1,0]=[1,1]=A. So rank 2. Distinct patterns maybe 4? Let's list: 0, A, E, O. Are there more? XOR combinations: 0, A, E, O, A+E = O, A+O=E, E+O=A. So only 4? Actually we have 0, A, E, O. So 4 states.\n\nn=3: indices 1,2,3. Patterns:\n\nA: [1,1,1]\nE: [0,1,0]\nO: [1,0,1]\nB: indices 1 mod3: 1,4>3 so only 1: [1,0,0]\n\nCompute linear independence: Let's compute basis: E, O, B.\n\nCheck if B can be expressed as combination of E,O? E+O = [1,1,1] = A. B != E, O, A. So independent? Suppose aE+bO = B? Solve [0,1,0]*a + [1,0,1]*b = [1,0,0] => coordinates: index1: a0 + b1 =1 => b=1. index2: a1 + b0=0 => a=0. index3: a0 + b1=0 => b=0 => conflict. So not possible. So rank 3.\n\nThus for n>=3, rank 3. But also need to consider pattern B might coincide with E or O or A for some n? Let's check n=4: indices 1,2,3,4. B indices 1,4 => [1,0,0,1]. E: [0,1,0,1]. O: [1,0,1,0]. B differs from both. So rank 3.\n\nThus for n>=3, rank 3. For n=2, rank 2. For n=1, rank 1? Actually rank 1? Because only one nonzero pattern? But A,O,B same so rank 1. But 0 also.\n\nThus distinct patterns maximum 8,4,2 accordingly.\n\nBut still we need to compute number of reachable distinct statuses after presses.\n\nSo algorithm:\n\nCompute basis patterns E,O,B and rank. Then compute set of reachable tuples (alpha,beta,gamma) given presses constraints and parity patterns.\n\nBut since rank=1 or 2 or 3, the mapping from parity patterns to patterns may produce fewer unique results.\n\nWe can compute all parity patterns (p1,p2,p3,p4) that satisfy sum parity = presses%2 and minimal sum <= presses, (presses-minSum) even. For each, compute tuple (alpha,beta,gamma) where alpha = p1 xor p2, beta = p1 xor p3, gamma = p4. Then unique patterns count is number of unique tuples that correspond to distinct patterns in GF(2)^n? But if rank less than 3, some tuples produce same vector. But we can rely on linear mapping: given alpha,beta,gamma, we can compute vector value via combination of E,O,B. If rank less than 3, some different tuples produce same vector. But easier: we can directly compute vector representation as a string or bitset? Not efficient but for small n it's fine. But we don't have to produce actual code, just pseudocode. We can mention that we can store pattern as tuple of alpha,beta,gamma and also check if rank less than 3, but mapping still unique? Actually if rank<3, then some patterns coincide, but mapping still unique? For rank=2, gamma variable may not affect vector if B is combination of E and O. Let's examine n=2: B=O. So gamma=1 just adds O. So alpha,beta,gamma produce same vector as some other combination. But we can handle by computing actual vector: pattern = alpha*E xor beta*O xor gamma*B. But since E,O,B are known, we can compute bitset of length n. For n up to maybe 10^9? But we can compute vector by using indices? Might be heavy. But as virtual code, we can assume we can compute patterns as bitset of n bits. So fine.\n\nSimplify: We'll compute all reachable parity patterns, compute resulting vector using XOR of button patterns, store unique vectors (bitset) in set, count size.\n\nThus pseudocode: we need to produce step-by-step.\n\nLet's produce generic pseudocode:\n\n- Input n, presses\n- Build vector for each button as bitset length n: P1, P2, P3, P4.\n- Initialize empty set S\n- For each a parity in {0,1}\n  For each b parity\n    For each c parity\n      For each d parity\n        If (a+b+c+d) % 2 == presses % 2 and (a+b+c+d) <= presses and (presses - (a+b+c+d)) % 2 == 0\n           Compute vector V = a*P1 XOR b*P2 XOR c*P3 XOR d*P4\n           Insert V into S\n- Return |S|\n\nBut we need to handle large n? Not specified. We'll keep pseudocode abstract.\n\nBut we might need to optimize: We can observe there are only 16 parity combos; we can iterate them.\n\nWe also can reduce to using coefficients as described.\n\nLet's produce final pseudocode.\n\nWe'll write lines with Start, Decision, etc.\n\nNow output in required format. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n 與 presses // 取得房間燈號與按鈕總次數  \n\n// ---------- 準備四種按鈕的狀態向量 ----------  \n→ Step 2: 建立長度為 n 的位元串 P1, P2, P3, P4  \n    → Decision: 初始化所有位元為 0 // P1,P2,P3,P4 為全 0 向量  \n    → Step 3: 對 i 從 1 到 n  \n        → Decision: i 為奇數?  \n            Yes → Step 4: 把 P1[i], P3[i] 設為 1 // 全部、奇數位置開啟  \n            No  → Step 5: 把 P1[i] 設為 1 // 全部位置開啟  \n        → Decision: i 為偶數?  \n            Yes → Step 6: 把 P2[i] 設為 1 // 偶數位置開啟  \n        → Decision: (i-1) mod 3 == 0?  \n            Yes → Step 7: 把 P4[i] 設為 1 // 3k+1 位置開啟  \n\n// ---------- 產生所有可行的按鈕奇偶組合 ----------  \n→ Step 8: 建立空集合 ResultSet // 用於儲存不同的最終燈號向量  \n→ Step 9: 針對 a ∈ {0,1}  \n    → Step 10: 針對 b ∈ {0,1}  \n        → Step 11: 針對 c ∈ {0,1}  \n            → Step 12: 針對 d ∈ {0,1}  \n                → Decision: (a+b+c+d) % 2 == presses % 2? // 符合按鈕總次數奇偶性  \n                    Yes →  \n                        → Decision: (a+b+c+d) <= presses? // 最小總次數不超過 presses  \n                            Yes →  \n                                → Decision: (presses - (a+b+c+d)) % 2 == 0? // 可用加 2 的方式補足  \n                                    Yes →  \n                                        → Step 13: 計算 V = (a?P1:0) XOR (b?P2:0) XOR (c?P3:0) XOR (d?P4:0)  \n                                        → Step 14: 把 V 加入 ResultSet // 若已存在則不重複  \n                                    No → Step 15: 這個組合不可行，繼續下一個  \n                            No → Step 16: 這個組合不可行，繼續下一個  \n                    No → Step 17: 這個組合不可行，繼續下一個  \n\n// ---------- 結果輸出 ----------  \n→ Step 18: Return |ResultSet| // ResultSet 的大小即為不同的燈號狀態數  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2n2f9r6o.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp2n2f9r6o.py\", line 35, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2n2f9r6o.py\", line 17, in __init__\n    self.lookup[(pref, suff)] = idx\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立一個字典，鍵是 (prefix, suffix) 這對，值是最大索引\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 所有可能的前綴\n            for i in range(L + 1):\n                pref = word[:i]\n                # 所有可能的後綴\n                for j in range(L + 1):\n                    suff = word[j:]\n                    # 由於遍歷順序是從較小索引到較大索引，直接覆蓋即可得到最大索引\n                    self.lookup[(pref, suff)] = idx\n\n    def f(self, prefix, suffix):\n        # 回傳最大索引，若不存在則回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將兩個列表包成一個元組，方便直接 eval\n    try:\n        words, query = ast.literal_eval('(' + data + ')')\n    except Exception:\n        # 若解析失敗，直接結束\n        return\n    # words: list of strings, query: list of two strings\n    wf = WordFilter(words)\n    result = wf.f(query[0], query[1])\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to design virtual code for WordFilter. Provide algorithm: build combined trie for prefix and suffix? Known solution: use prefix and suffix trie with combined key \"pref#suff\" to map index. Or use dictionary mapping pair of prefix-suffix to index. For simplicity, we can store all words, and for each word index, for all prefixes and suffixes we store mapping to largest index. That's heavy but okay. Provide virtual code accordingly.\n\nWe need step-by-step pseudocode. Provide virtual code steps with arrows, decisions, etc. We need to design class WordFilter with constructor and method f. Provide high-level pseudocode. Also mention data structures: hash map mapping pair to index.\n\nLet's produce steps:\n\nStart\n→ Initialize WordFilter: input words array\n    → Create empty map prefixSuffixMap // key: pref#suff, value: max index\n    → For each word with index i:\n        → For each prefix of word:\n            → For each suffix of word:\n                → key = prefix + \"#\" + suffix\n                → if key not in map or map[key] < i: map[key] = i\n→ End constructor\n\nMethod f(pref, suff):\n    → key = pref + \"#\" + suff\n    → if key in map: return map[key]\n    → else return -1\n\nAlso we may add decision: If key not found. Provide pseudocode.\n\nLet's produce line-by-line with explanations. Use arrows. Provide \"Start\" and \"End\". Provide decisions.\n\nLet's write in Chinese.\n\nWe'll need to handle loops: For each word, for prefix i 0..len, for suffix j 0..len.\n\nMake sure to format each line as \"虛擬碼步驟 // 解釋\". Use arrow for each step.\n\nLet's produce.\n\nRemember to include \"Start\" and \"End\" at top-level and inside method maybe. Provide decisions inside f for existence.\n\nLet's generate.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ WordFilter(words) // 建構子，接收字典中的所有單字  \n→ Create Empty Map prefixSuffixMap // 用於儲存「前綴+#+後綴」對應的最大索引  \n→ Decision: words is empty? // 檢查字典是否為空  \n    Yes → End // 若空則直接結束建構  \n    No →  \n        → For each (word, index) in words // 遍歷每個單字及其索引  \n            → For i from 0 to len(word) // 產生所有可能的前綴  \n                → prefix = substring(word, 0, i)  \n                → For j from 0 to len(word) // 產生所有可能的後綴  \n                    → suffix = substring(word, len(word)-j)  \n                    → key = prefix + \"#\" + suffix // 組合關鍵字  \n                    → Decision: key exists in prefixSuffixMap? // 檢查是否已存在相同關鍵字  \n                        Yes → \n                            → Decision: prefixSuffixMap[key] < index? // 若已存在但索引較小  \n                                Yes → prefixSuffixMap[key] = index // 更新為更大的索引  \n                                No → // 已有較大索引，保持不變  \n                        No → prefixSuffixMap[key] = index // 新增鍵值對  \n→ End // 建構子結束  \n---  \nf(pref, suff) // 查詢方法，回傳符合前綴pref且後綴suff的最大索引  \n→ key = pref + \"#\" + suff // 組合查詢鍵  \n→ Decision: key exists in prefixSuffixMap? // 檢查鍵值是否存在  \n    Yes → Return prefixSuffixMap[key] // 回傳最大索引  \n    No → Return -1 // 若不存在，回傳 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all possible results after removing the minimum number of invalid parentheses.\n        \"\"\"\n        if not s:\n            return [\"\"]\n        # Helper to check validity of a string\n        def is_valid(st):\n            count = 0\n            for ch in st:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS: start from the original string\n        level = {s}\n        while level:\n            # Find all valid strings at the current level\n            valid = [x for x in level if is_valid(x)]\n            if valid:\n                return valid\n            # Generate next level by removing one parenthesis\n            next_level = set()\n            for expr in level:\n                for i in range(len(expr)):\n                    if expr[i] in ('(', ')'):\n                        next_level.add(expr[:i] + expr[i+1:])\n            level = next_level\n        return []\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Parse the input string. Handles formats like:\n    s = \"()())()\"\n    or just \"()())()\"\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return \"\"\n    # If the input contains 's =', extract the quoted string\n    if data.lower().startswith('s'):\n        quote_start = data.find('\"')\n        quote_end = data.rfind('\"')\n        if 0 <= quote_start < quote_end:\n            return data[quote_start+1:quote_end]\n    # Otherwise assume the whole line is the string (possibly quoted)\n    if data.startswith('\"') and data.endswith('\"'):\n        return data[1:-1]\n    return data\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    sol = Solution()\n    result = sol.removeInvalidParentheses(s)\n    # Ensure the output format matches the examples (Python list representation)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that removes minimal invalid parentheses to produce all valid strings. Classic problem: Remove Invalid Parentheses (LeetCode 301). We can do BFS level search or DFS with pruning. We'll produce a virtual algorithm: start with input string, calculate minimal removals needed by scanning to count unmatched '(' and ')'. Then perform DFS/backtracking to generate all possible strings by removing parentheses positions, avoiding duplicates. We'll produce pseudo-code lines with decisions and steps. Should use arrow arrows.\n\nNeed to output each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to produce structured steps: Start, etc.\n\nWe can include functions: compute min removals, DFS, helper. We must keep it line by line with arrow arrows and decisions.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize countLeft=0, countRight=0 // 計算需要移除的左右括號數\n→ Decision: For each char c in s // 遍歷字串\n    → If c == '(' // 左括號\n        → countLeft++ // 增加左括號計數\n    → Else if c == ')' // 右括號\n        → If countLeft > 0\n            → countLeft-- // 匹配左括號\n        → Else\n            → countRight++ // 無法匹配的右括號\nEnd // 兩個變數已得最小移除數\n\nStart DFS\n→ Step 2: Define recursive function dfs(index, path, removed, lCount, rCount, res) // 回溯\n→ Step 3: If index == length(s)\n    → Decision: If removed == minRemovals // 所有移除數達到最小值\n        → Yes → Add path to res if not duplicate\n        → No  → Return\n    → End\n→ Step 4: Let c = s[index] // 取得目前字元\n→ Decision: If c is '(' or ')'\n    → Yes → Option 1: Skip this parenthesis // remove\n        → dfs(index+1, path, removed+1, lCount, rCount, res) // 移除後繼續\n    → No → Option 2: Keep the parenthesis\n        → Decision: If c == '(' // 保留左括號\n            → dfs(index+1, path+'(', removed, lCount+1, rCount, res)\n        → Else // c == ')'\n            → Decision: If lCount > rCount // 有多餘左括號可配對\n                → dfs(index+1, path+')', removed, lCount, rCount+1, res)\n            → Else // 無法配對，不能保留\n                → // skip this branch\n→ Else // c is letter\n    → dfs(index+1, path+c, removed, lCount, rCount, res) // 直接保留字母\n→ End of dfs\n\nStart main\n→ Step 5: Compute minRemovals // 前面計算的 countLeft + countRight\n→ Step 6: Initialize empty set res // 儲存結果\n→ Step 7: Call dfs(0, \"\", 0, 0, 0, res) // 開始回溯\n→ Step 8: Return list(res) // 轉為列表返回\nEnd\n\nBut we must format each line with arrow and explanation. Must use \"→\" arrows. Indentation? Not required but can use spaces. For decisions, indent deeper. Use \"Decision:\" lines.\n\nLet's produce each line. Ensure each line is separate.\n\nAlso we should mention that we maintain set to avoid duplicates.\n\nLet's craft.\n\nWe need to include BFS? We'll do DFS. Fine.\n\nLet's write pseudo-code lines.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: Initialize leftCount = 0, rightCount = 0 // 用於計算最小需要移除的括號數\n\nLine 3: → Decision: For each character ch in s // 遍歷輸入字串\n\nLine 4:     → If ch == '(' // 左括號\nLine 5:         → leftCount++ // 增加左括號計數\nLine 6:     → Else if ch == ')' // 右括號\nLine 7:         → Decision: If leftCount > 0 // 有可配對左括號\nLine 8:             → Yes → leftCount-- // 匹配並減少左括號計數\nLine 9:             → No  → rightCount++ // 無法匹配的右括號，增加右括號計數\nLine 10: End // 兩個計數已得到最小移除數\n\nLine 11: → Step 2: Define recursive function dfs(idx, path, removed, l, r, resultSet) // 回溯生成合法字串\n\nLine 12: → Step 3: If idx == len(s) // 已到字串末尾\nLine 13:     → Decision: If removed == leftCount + rightCount // 移除數達到最小值\nLine 14:         → Yes → Add path to resultSet // 將合法字串加入結果\nLine 15:         → No  → Return // 過多移除，放棄\nLine 16:     → End\n\nLine 17: → Step 4: Let ch = s[idx] // 取得當前字元\n\nLine 18: → Decision: If ch == '(' or ch == ')' // 是括號\nLine 19:     → Yes → // 先考慮移除該括號\nLine 20:         → dfs(idx+1, path, removed+1, l, r, resultSet) // 移除後繼續\nLine 21:     → No  → // 保留括號\nLine 22:         → Decision: If ch == '(' // 保留左括號\nLine 23:             → Yes → dfs(idx+1, path + '(', removed, l+1, r, resultSet) // 加左括號並遞迴\nLine 24:             → No  → // 不是左括號，跳過\nLine 25:         → Decision: If ch == ')' // 保留右括號\nLine 26:             → Yes → Decision: If l > r // 有多餘左括號可配對\nLine 27:                 → Yes → dfs(idx+1, path + ')', removed, l, r+1, resultSet) // 加右括號\nLine 28:                 → No  → // 無法配對，放棄此分支\nLine 29:             → No  → // 不是右括號，跳過\n\nLine 30: → Else // ch 是字母\nLine 31:     → dfs(idx+1, path + ch, removed, l, r, resultSet) // 直接保留字母\n\nLine 32: End // dfs 函式結束\n\nLine 33: → Step 5: Initialize empty set resultSet // 用於儲存唯一合法字串\n\nLine 34: → Step 6: Call dfs(0, \"\", 0, 0, 0, resultSet) // 開始回溯\n\nLine 35: → Step 7: Return list(resultSet) // 把集合轉為列表返回\n\nLine 36: End // 程式執行結束\n\nMake sure to align decision lines indent; not required but fine.\n\nLet's output exactly as lines with \"→\" and \"Decision:\" etc. Ensure each line ends with comment.\n\nWe'll output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize leftCount = 0, rightCount = 0 // 用於計算最小需要移除的括號數  \n→ Decision: For each character ch in s // 遍歷輸入字串  \n  → If ch == '(' // 左括號  \n   → leftCount++ // 增加左括號計數  \n  → Else if ch == ')' // 右括號  \n   → Decision: If leftCount > 0 // 有可配對左括號  \n     Yes → leftCount-- // 匹配並減少左括號計數  \n     No  → rightCount++ // 無法匹配的右括號，增加右括號計數  \n→ End // 兩個計數已得到最小移除數  \n→ Step 2: Define recursive function dfs(idx, path, removed, l, r, resultSet) // 回溯生成合法字串  \n→ Step 3: If idx == len(s) // 已到字串末尾  \n  → Decision: If removed == leftCount + rightCount // 移除數達到最小值  \n    Yes → Add path to resultSet // 將合法字串加入結果  \n    No  → Return // 過多移除，放棄  \n  → End  \n→ Step 4: Let ch = s[idx] // 取得當前字元  \n→ Decision: If ch == '(' or ch == ')' // 是括號  \n  Yes → // 先考慮移除該括號  \n   → dfs(idx+1, path, removed+1, l, r, resultSet) // 移除後繼續  \n  No  → // 保留括號  \n   → Decision: If ch == '(' // 保留左括號  \n    Yes → dfs(idx+1, path + '(', removed, l+1, r, resultSet) // 加左括號並遞迴  \n    No  → // 不是左括號，跳過  \n   → Decision: If ch == ')' // 保留右括號  \n    Yes → Decision: If l > r // 有多餘左括號可配對  \n     Yes → dfs(idx+1, path + ')', removed, l, r+1, resultSet) // 加右括號  \n     No  → // 無法配對，放棄此分支  \n    No  → // 不是右括號，跳過  \n→ Else // ch 是字母  \n  → dfs(idx+1, path + ch, removed, l, r, resultSet) // 直接保留字母  \n→ End // dfs 函式結束  \n→ Step 5: Initialize empty set resultSet // 用於儲存唯一合法字串  \n→ Step 6: Call dfs(0, \"\", 0, 0, 0, resultSet) // 開始回溯  \n→ Step 7: Return list(resultSet) // 把集合轉為列表返回  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkoa5wksk.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpkoa5wksk.py\", line 43, in main\n    start, end = args[arg_idx]\n    ^^^^^^^^^^\nValueError: not enough values to unpack (expected 2, got 0)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\n\nclass MyCalendarThree:\n    def __init__(self):\n        # 用一個列表保存時間點與變化量，並保持排序\n        self.timeline = []\n\n    def book(self, start, end):\n        # 插入開始與結束的時間點\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n\n        # 行走時間點，計算最大重疊數量\n        active = 0\n        max_active = 0\n        for _, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\ndef main():\n    # 讀取整個標準輸入\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n\n    # 將兩個列表包裝成一個合法的 JSON，方便解析\n    full = '[' + data_str + ']'\n    ops, args = json.loads(full)\n\n    results = []\n    calendar = None\n    arg_idx = 0\n\n    for op in ops:\n        if op == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)          # 代表 null\n        elif op == \"book\":\n            start, end = args[arg_idx]\n            arg_idx += 1\n            results.append(calendar.book(start, end))\n        else:\n            # 若遇到未知操作，仍進行參數索引遞增，避免錯誤\n            arg_idx += 1\n\n    # 輸出結果列表，None 會自動轉為 JSON 的 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudocode with steps for MyCalendarThree: we need to maintain events intervals and after each book call return maximum overlapping count. Usually solution uses line sweep with difference map or segment tree. We produce virtual code steps with explanation each line. Use structure: Start, Decision, etc.\n\nWe need to produce code steps for the entire class initialization and book method. We'll describe using a balanced BST map of changes. Steps: start, init map. book method: add +1 at start, -1 at end; then sweep through sorted keys to compute max. Return max. Use pseudocode. Each line with explanation.\n\nLet's output line by line. Probably start with class definition.\n\nWe will produce steps like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCalendarThree 類別 // 初始化類別\n→ Step 2: 在建構子中建立差分地圖 diff // 用來記錄每個時間點的變化量\n→ Step 3: 定義 book(start, end) 方法 // 處理每個新事件\n→ Step 4: 在 diff 中將 start 位置加 1 // 代表一個事件開始\n→ Step 5: 在 diff 中將 end 位置減 1 // 代表一個事件結束\n→ Step 6: 初始化 currentOverlap = 0, maxOverlap = 0 // 用於計算最大重疊\n→ Step 7: 依序遍歷 diff 中的時間點 // 依時間排序\n    → Decision: 若 time 位置遞增? // 遍歷順序保證時間遞增\n        Yes → currentOverlap += diff[time] // 更新當前重疊數\n        Yes → maxOverlap = max(maxOverlap, currentOverlap) // 更新最大值\n→ Step 8: 回傳 maxOverlap // 返回目前最大 k-booking\nEnd // 程式結束\n\nBut need to adhere to arrow formatting: \"→ Step X:\" lines. Decision lines: \"Decision:\" etc. Provide explanation after //.\n\nLet's craft fully. Use \"Decision:\" for if needed, but our loop is simple. Might not need decision. But we can show \"Decision: 遍歷 diff 中時間點?\" but no branch. But we can still use \"Decision:\" with Yes to show processing.\n\nWe should produce each line with \"虛擬碼步驟\" plus comment. Provide step numbers maybe but not necessary. The format example uses \"Step 1:\" etc. We can include step numbers.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCalendarThree 類別 // 建立類別以支援多重預約查詢  \n→ Step 2: 在建構子中建立 diff 地圖 // 用 map 來記錄時間點的變化量（+1 開始，-1 結束）  \n→ Step 3: 定義 book(start, end) 方法 // 處理每一次新增事件的請求  \n→ Step 4: diff[start] += 1 // 事件在 start 時開始，重疊數量增加 1  \n→ Step 5: diff[end] -= 1 // 事件在 end 時結束，重疊數量減少 1  \n→ Step 6: currentOverlap = 0 // 當前時間點的重疊數量初始化  \n→ Step 7: maxOverlap = 0 // 迄今為止看到的最大重疊數量  \n→ Step 8: 依時間順序遍歷 diff 的所有關鍵點  \n  → Decision: 迭代到下一個時間點? // 確保按照時間遞增順序處理  \n   Yes → currentOverlap += diff[time] // 更新當前重疊數量  \n   Yes → maxOverlap = max(maxOverlap, currentOverlap) // 如有需要更新最大值  \n→ Step 9: 回傳 maxOverlap // 回傳目前所有事件中最大的 k-booking 數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,-3,null,0,-2]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,-3,null,0,-2]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if self.stack:\n            val = self.stack.pop()\n            if val == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self):\n        if self.stack:\n            return self.stack[-1]\n\n    def getMin(self):\n        if self.min_stack:\n            return self.min_stack[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將輸入轉成符合 json.loads 的格式\n    # 若輸入形如 '[\"MinStack\", ...], [[], ...]'，則包裝成外層列表\n    if not data.startswith('['):\n        data = f'[{data}]'\n    try:\n        ops, args = json.loads(data)\n    except json.JSONDecodeError:\n        # 若解析失敗，直接退出\n        sys.exit()\n\n    res = []\n    stack_obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack_obj = MinStack()\n            res.append(None)\n        elif op == \"push\":\n            stack_obj.push(arg[0])\n            res.append(None)\n        elif op == \"pop\":\n            stack_obj.pop()\n            res.append(None)\n        elif op == \"top\":\n            res.append(stack_obj.top())\n        elif op == \"getMin\":\n            res.append(stack_obj.getMin())\n        else:\n            # 不支持的操作，忽略\n            res.append(None)\n\n    # 輸出結果，將 None 轉成 JSON 的 null\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code, line by line, with explanation, no actual code. Provide steps for MinStack design.\n\nWe must follow format: Each line \"虛擬碼步驟 // 解釋\".\n\nUse arrows: \"Start\", \"→\", \"Decision:\". We need to describe the algorithm.\n\nProbably maintain two stacks: main stack, min stack. push: push val to main; if min stack empty or val <= minTop, push val to min stack. pop: pop main; if popped equals minTop, pop min stack. top: return main top. getMin: return minTop.\n\nWe'll produce steps for initialization, push, pop, top, getMin.\n\nAlso handle empty checks.\n\nLet's output lines. Use \"Start\" and \"End\" around overall structure? But we can design each method.\n\nBut the requirement: produce virtual code for entire design.\n\nWe can have top-level Start, then operations as steps. Let's include Start for initialization of class, then methods.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Step 1: 定義主棧 mainStack // 用於存儲所有元素\n→ Step 2: 定義最小棧 minStack // 用於追蹤當前最小值\n→ Step 3: End 初始化 // 初始化完成\n\nThen separate methods:\n\n→ Step 4: 方法 push(val)\n    → Decision: minStack 為空 OR val <= minStack.top()?\n        Yes → minStack.push(val) // 若新值是最小值，推入最小棧\n        No → // 不推入\n    → mainStack.push(val) // 將值推入主棧\n\n→ Step 5: 方法 pop()\n    → Decision: mainStack 為空? // 防止空棧彈出\n        Yes → // 執行錯誤處理\n        No →\n            → popped = mainStack.pop() // 移除主棧頂\n            → Decision: popped == minStack.top()?\n                Yes → minStack.pop() // 若頂元素為最小值，同步彈出最小棧\n                No → // 無需同步\n\n→ Step 6: 方法 top()\n    → Decision: mainStack 為空? // 防止空棧取頂\n        Yes → // 返回錯誤值\n        No → return mainStack.top() // 返回主棧頂\n\n→ Step 7: 方法 getMin()\n    → Decision: minStack 為空? // 防止空棧取最小值\n        Yes → // 返回錯誤值\n        No → return minStack.top() // 返回最小棧頂\n\nEnd // 程式執行結束\n\nBut must keep each line with arrow and comment.\n\nUse \"→\" for step, \"Decision:\" for decisions. Use indentation for nested decisions? They didn't specify indentation but in example they indent using spaces. We'll follow.\n\nEnsure each line ends with comment.\n\nLet's craft.\n\nWe must avoid actual code. Use pseudo.\n\nWe need to start with \"Start\".\n\nEach line:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 mainStack, minStack // 建立兩個棧以支援 O(1) 操作\n\n... etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 mainStack, minStack // 建立兩個棧：主棧儲存所有元素，最小棧追蹤目前最小值  \n→ Step 2: End 初始化 // 初始化完成  \n\n// push(val) 方法  \n→ Step 3: 方法 push(val) // 新增元素至堆疊  \n    → Decision: minStack 為空 OR val ≤ minStack.top()? // 判斷是否是新的最小值  \n        Yes → minStack.push(val) // 若是最小值，亦推入最小棧  \n        No  → // 不做任何操作於最小棧  \n    → mainStack.push(val) // 將值推入主棧  \n\n// pop() 方法  \n→ Step 4: 方法 pop() // 移除堆疊頂端元素  \n    → Decision: mainStack 為空? // 防止對空棧執行彈出  \n        Yes → // 執行錯誤處理或忽略  \n        No →  \n            → popped = mainStack.pop() // 從主棧彈出頂端  \n            → Decision: popped == minStack.top()? // 判斷彈出元素是否為最小值  \n                Yes → minStack.pop() // 同步彈出最小棧  \n                No  → // 無需同步  \n\n// top() 方法  \n→ Step 5: 方法 top() // 取得堆疊頂端元素  \n    → Decision: mainStack 為空?  \n        Yes → // 返回錯誤值或 null  \n        No → return mainStack.top() // 回傳主棧頂  \n\n// getMin() 方法  \n→ Step 6: 方法 getMin() // 取得目前最小值  \n    → Decision: minStack 為空?  \n        Yes → // 返回錯誤值或 null  \n        No → return minStack.top() // 回傳最小棧頂  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\nfrom collections import defaultdict\nimport json\n\nclass Solution:\n    \"\"\"\n    先把每個數字對應到它在陣列中的所有索引，存成字典。\n    在 pick 時直接隨機挑選其中一個索引即可。\n    \"\"\"\n    def __init__(self, nums):\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        return random.choice(self.indices[target])\n\ndef parse_input(data: str):\n    \"\"\"\n    把輸入字串分成兩個部分：指令列和參數列。\n    由於可能有多層括號，必須逐字讀取，維持括號深度來決定分割點。\n    \"\"\"\n    depth = 0\n    split_index = None\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_index = i\n            break\n    if split_index is None:\n        raise ValueError(\"Invalid input format\")\n    cmds_str = data[:split_index]\n    args_str = data[split_index+1:]\n    # 使用 literal_eval 解析成 Python 物件\n    import ast\n    commands = ast.literal_eval(cmds_str)\n    arguments = ast.literal_eval(args_str)\n    return commands, arguments\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    commands, arguments = parse_input(raw)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            obj = Solution(arg[0])  # arg is a list containing nums\n            results.append(None)\n        elif cmd == \"pick\":\n            results.append(obj.pick(arg[0]))\n        else:\n            # 若有其他方法，按需處理\n            results.append(None)\n\n    # 用 json.dumps 產生類似 LeetCode 的輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm described. This is typical \"Random Pick with Weight\" but simpler: we want random index of target in array. Approach: preprocess indices of each number. In constructor, build map from number to list of indices. In pick, fetch list, pick random index using random selection from list.\n\nWe need to output line by line with comments. Use virtual code syntax: Start, →, Decision, etc.\n\nLet's produce:\n\nStart // Start\n→ Step 1: Initialize empty map M // store number->list of indices\n→ For i from 0 to nums.length-1:\n    → Step 2: num = nums[i] // current number\n    → Decision: If M contains num? // check map\n        Yes → Step 3: Append i to M[num] // add index to existing list\n        No  → Step 4: Create new list L; add i; set M[num] = L // new entry\n→ End // constructor finished\n\nFor pick method:\nStart // pick method start\n→ Step 5: list = M[target] // get list of indices for target\n→ Step 6: n = length of list // number of occurrences\n→ Step 7: r = RandomInt(0, n-1) // random integer in range\n→ Step 8: return list[r] // return chosen index\nEnd // pick method end\n\nWe need to reflect the class structure. Use virtual steps like \"Start\", \"End\". Maybe we need separate start for constructor and method. Provide explanation after each line.\n\nLet's craft. Ensure each line ends with // explanation.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: M ← {} // 初始化一個空映射，鍵為數字，值為該數字所有索引的列表  \n\n→ For i ← 0 to nums.length - 1: // 遍歷整個陣列  \n  → Step 2: num ← nums[i] // 取得當前元素的值  \n  → Decision: M 是否已包含 key num? // 判斷映射中是否已有此數字  \n    Yes → Step 3: Append i to M[num] // 若已存在，將索引加入其列表  \n    No  → Step 4: L ← [i] ; M[num] ← L // 若不存在，建立新列表並存入映射  \n\nEnd // 建構子結束，映射已建立  \n\nStart // pick 方法開始執行  \n→ Step 5: list ← M[target] // 取得目標值的所有索引列表  \n→ Step 6: n ← Length(list) // 該列表中索引數量  \n→ Step 7: r ← RandomInt(0, n-1) // 隨機產生合法索引位置  \n→ Step 8: return list[r] // 回傳隨機選出的索引  \n\nEnd // pick 方法結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[None,3],[3,None],[1,0],[0,1],[0,1],[1,0],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[None, 3], [3, None], [1, 0], [0, 1], [0, 1], [1, 0], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1], [1, 0]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Return True if s is a palindrome.\"\"\"\n    return s == s[::-1]\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典: word -> index\n        index_of = {word: i for i, word in enumerate(words)}\n        res = []\n\n        # 若存在空字串，先處理空字串與所有回文單字的配對\n        empty_index = index_of.get(\"\")\n        if empty_index != -1:\n            for j, w in enumerate(words):\n                if j == empty_index:\n                    continue\n                if is_palindrome(w):\n                    res.append([empty_index, j])  # 空 + 回文\n                    res.append([j, empty_index])  # 回文 + 空\n\n        # 針對每個單字做分割檢查\n        for i, word in enumerate(words):\n            # 空字串已在上面處理，這裡可跳過\n            if word == \"\":\n                continue\n            L = len(word)\n            for pos in range(L + 1):\n                prefix = word[:pos]\n                suffix = word[pos:]\n\n                # 如果前綴是回文，則後綴反轉後要存在\n                if is_palindrome(prefix):\n                    rev_suffix = suffix[::-1]\n                    j = index_of.get(rev_suffix)\n                    if j is not None and j != i:\n                        res.append([j, i])  # rev_suffix + word\n\n                # 如果後綴是回文，且 pos > 0 防止重複\n                if pos != 0 and is_palindrome(suffix):\n                    rev_prefix = prefix[::-1]\n                    j = index_of.get(rev_prefix)\n                    if j is not None and j != i:\n                        res.append([i, j])  # word + rev_prefix\n\n        return res\n\ndef main():\n    # 讀取整行輸入，範例如 'words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]'\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 去掉可能的變數名與等號\n    if '=' in raw:\n        raw = raw.split('=', 1)[1].strip()\n    # 解析成 Python 物件\n    try:\n        words = ast.literal_eval(raw)\n    except Exception:\n        words = []\n    # 取得答案\n    ans = Solution().palindromePairs(words)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Provide algorithm O(total length). Approach: for each word, iterate over splits, check prefixes/suffixes palindrome and use hash map from word to index. Steps: build map word->index. Then for each word, for each split position, check prefix palindrome -> reversed suffix exists. Also suffix palindrome -> reversed prefix exists. Exclude same index. Collect pairs.\n\nWe need to output virtual steps line by line, with comments. Use Start, End, Decision, Yes/No arrows.\n\nMake sure each line includes \"虛擬碼步驟 // 解釋\". Provide arrow lines. Also indentation: Use tabs or spaces? The example uses two spaces indentation for nested decisions. We'll follow similar.\n\nWe'll list steps:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 hash_map // 以字串為鍵，索引為值\n→ Decision: 迭代 words 生成 hash_map? // 建立字典\n    Yes → Step 2: 把 words[i] 放入 hash_map\n    No  → (continue) // 迴圈結束\n\nBut better: Step 1: For i in 0..words.length-1: hash_map[words[i]] = i.\n\nThen Step 2: 初始化空列表 results.\n\nThen iterate each word with index i.\n\nFor each word, length L, for split pos 0..L inclusive:\n    prefix = word[0:pos]\n    suffix = word[pos:]\n    if isPalindrome(prefix):\n        reversed_suffix = reverse(suffix)\n        if reversed_suffix in hash_map and hash_map[reversed_suffix] != i:\n            add (hash_map[reversed_suffix], i)\n    if isPalindrome(suffix):\n        reversed_prefix = reverse(prefix)\n        if reversed_prefix in hash_map and hash_map[reversed_prefix] != i:\n            add (i, hash_map[reversed_prefix])\n\nReturn results.\n\nWe must explain each line. Use \"Decision:\" lines for palindrome checks.\n\nAlso we need to incorporate O(total length) complexity: we need to precompute reverse or use slicing. But it's fine.\n\nLet's output virtual code. Ensure no actual code, just steps.\n\nWe need to avoid duplicate pairs. Our algorithm handles duplicates by only adding when reversed word not same index. It may add same pair twice if both palindrome checks succeed? For example, word is palindrome, we might add pair (i,j) and (j,i). That's fine, required.\n\nAlso we need to handle empty string: For empty string, splits at pos 0: prefix=\"\" suffix=\"\" both palindrome. reversed suffix=\"\". But reversed suffix same as word. But since same index check ensures not adding. For prefix palindrome, reversed suffix may be a word that's palindrome? Actually we need to add pairs for empty string with other palindrome words. We'll handle separately? Our algorithm will catch: For word \"\", prefix=\"\" palindrome; reversed_suffix=\"\" which is same index; skip. For other word w that is palindrome, when iterating w, split pos= len(w), suffix=\"\" palindrome; reversed_prefix=reverse(w)=w, but index same; skip. To get pairs with empty string we need to check when word is empty: we need to find all palindrome words and add (empty_index, palindrome_index) and (palindrome_index, empty_index). Our algorithm above may not add because reversed suffix/prefix would be itself, same index. We need special handling: if word is empty, add pairs with all palindrome words. So include step: If word is empty, iterate over all words, if other is palindrome, add pairs accordingly. We'll include that.\n\nLet's produce virtual steps accordingly.\n\nAlso we need to ensure we maintain O(total length). For empty string handling, iterating over all words is O(n) but n could be large relative to total length? But each word length is at least 1, so total length >= n. So still O(total length). Good.\n\nLet's output.\n\nWe'll use \"→\" for steps. Indentation: for nested decisions indent with spaces.\n\nLet's produce.\n\nAlso include \"End\" at end.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 hash_map // 以字串為鍵，索引為值  \n→ Step 2: 建立空列表 results // 儲存所有符合條件的 (i, j)  \n→ Step 3: 迭代 words 以建立 hash_map  \n    → For i from 0 到 words.length-1  \n        Yes → hash_map[words[i]] = i // 把每個單字及其索引存入字典  \n→ Step 4: 找出空字串索引（若存在）  \n    → Decision: words 內是否有 \"\"? // 需要單獨處理空字串  \n        Yes → Step 5: empty_index = hash_map[\"\"] // 取得空字串所在位置  \n        No → Step 5: empty_index = -1 // 無空字串，設為 -1  \n→ Step 6: 若 empty_index != -1，對每個非空單字檢查是否為回文  \n    → Decision: empty_index != -1?  \n        Yes → For j from 0 到 words.length-1  \n              Decision: j == empty_index? // 避免自己  \n                  No → Decision: words[j] 是否回文?  \n                      Yes → results.add((empty_index, j)) // 空字串 + 回文  \n                      Yes → results.add((j, empty_index)) // 回文 + 空字串  \n                      No  → (跳過)  \n        No → (跳過)  \n→ Step 7: 迭代每個單字進行分割檢查  \n    → For i from 0 到 words.length-1  \n        Let word = words[i]  \n        Let L = word.length  \n        → For pos from 0 到 L  \n              Let prefix = word[0:pos] // 前綴  \n              Let suffix = word[pos:L] // 後綴  \n              → Decision: prefix 是否回文?  \n                  Yes → Let rev_suffix = reverse(suffix)  \n                      Decision: rev_suffix 在 hash_map 且 hash_map[rev_suffix] != i?  \n                          Yes → results.add((hash_map[rev_suffix], i)) // rev_suffix + word  \n                          No  → (跳過)  \n                  No  → (跳過)  \n              → Decision: suffix 是否回文?  \n                  Yes → Let rev_prefix = reverse(prefix)  \n                      Decision: rev_prefix 在 hash_map 且 hash_map[rev_prefix] != i?  \n                          Yes → results.add((i, hash_map[rev_prefix])) // word + rev_prefix  \n                          No  → (跳過)  \n                  No  → (跳過)  \n→ End // 程式執行結束，結果即為所有符合條件的 (i, j) 列表"
    },
    {
      "title": "Best Time to Buy and Sell Stock IV",
      "source_file": "Leetcode/leetcode188.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnok116ar.py\", line 40, in <module>\n    k, prices = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnok116ar.py\", line 33, in parse_input\n    prices = eval(prices_part.split('=')[1].strip())\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx16k6iew.py\", line 40, in <module>\n    k, prices = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx16k6iew.py\", line 33, in parse_input\n    prices = eval(prices_part.split('=')[1].strip())\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def maxProfit(self, k: int, prices: list[int]) -> int:\n        n = len(prices)\n        if n == 0:\n            return 0\n        # If k is large enough, treat as unlimited transactions\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        # DP table: dp[t][d] = max profit using at most t transactions up to day d\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]\n            for d in range(1, n):\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\ndef parse_input(content: str):\n    \"\"\"\n    Parses input in the form:\n    k = <int>, prices = [<int>, ...]\n    \"\"\"\n    parts = [p.strip() for p in content.replace('\\n', ' ').split(',')]\n    k_part = parts[0]\n    prices_part = parts[1]\n    k = int(k_part.split('=')[1].strip())\n    prices = eval(prices_part.split('=')[1].strip())\n    return k, prices\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    if not raw.strip():\n        sys.exit(0)\n    k, prices = parse_input(raw)\n    result = Solution().maxProfit(k, prices)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudo code step by step for the problem: stock max profit with at most k transactions. It's a classic DP. Steps: check k > n/2 shortcut; else DP[transactions][days], transition. Provide pseudo code lines with explanation. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Must use arrow →. Also nested Decision.\n\nLet's outline:\n\nStart\n→ Read array prices, int k\n→ Set n = len(prices)\n→ Decision: 如果 k >= n/2? // If unlimited transactions\n    Yes → Return sum of all positive differences\n    No → \n        → Initialize DP array dp[2][k+1][n] maybe simpler: Use dp[t][i] for max profit up to day i with t transactions\n        → Initialize dp[t][0] = 0 for all t\n        → For day i from 1 to n-1:\n            → For t from 1 to k:\n                → Decision: 如果需要使用前一天的 dp[t][i-1] vs dp[t-1][i-1] + (prices[i]-max_diff) \nBut to avoid nested loops with max diff each time we maintain maxDiff. Classic algorithm: For each t, keep maxDiff = max(maxDiff, dp[t-1][i-1] - prices[i-1]); then dp[t][i] = max(dp[t][i-1], prices[i] + maxDiff). Provide pseudocode.\n\nSimplify: Use 2D dp[t][i]. Provide loops.\n\nLet's produce lines.\n\nRemember no real code. Just virtual steps.\n\nOk. Let's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Read array prices, integer k // 取得股價序列與最大交易次數  \n→ Set n = length(prices) // 取得股價天數  \n→ Decision: 如果 k >= n / 2? // 檢查是否可視為無限交易  \n    Yes → Return sum of all positive differences between consecutive days // 無限交易時，累加所有利潤  \n    No →  \n        → Initialize 2D array dp[k+1][n] with zeros // dp[t][i] 表示前 i 天內完成 t 次交易的最大利潤  \n        → For i from 1 to n-1: // 循環每一天  \n            → For t from 1 to k: // 循環每一筆交易數  \n                → Decision: 是否使用前一天的結果? // 判斷是否在第 i 天進行賣出  \n                    Yes → Set maxDiff = max(maxDiff, dp[t-1][i-1] - prices[i-1]) // 更新最大差值，代表最優買入時機  \n                    No → // maxDiff 仍保留上一筆更新的值  \n                → Set dp[t][i] = max(dp[t][i-1], prices[i] + maxDiff) // 選擇不賣或賣出取得最大利潤  \n        → End For  \n        → End For  \n        → Return dp[k][n-1] // 取得完成 k 次交易後的最大利潤  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\n# 求給定字串陣列中，最長的不常見子序列長度\ndef findLUSlength(strs):\n    \"\"\"\n    1. 計算每個字串出現次數\n    2. 尋找出現次數為 1（唯一）的字串\n    3. 取這些唯一字串中的最大長度\n    4. 若無唯一字串，回傳 -1\n    \"\"\"\n    freq = Counter(strs)            # 步驟 1：計數\n    max_len = -1                    # 步驟 2：初始化答案\n    for s in strs:                  # 步驟 3：遍歷每個字串\n        if freq[s] == 1:            # 只要是唯一字串\n            if len(s) > max_len:    # 更新最大長度\n                max_len = len(s)\n    return max_len                  # 步驟 4：返回結果\n\n\ndef main():\n    \"\"\"\n    主程式\n    1. 從標準輸入讀取整個內容\n    2. 解析成字串列表\n    3. 計算最長不常見子序列長度\n    4. 輸出結果\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:                    # 若無輸入直接結束\n        return\n    try:\n        strs = ast.literal_eval(data)   # 解析 ['a','b'] 形式的輸入\n    except Exception:\n        # 若解析失敗，假設輸入本身就是單一字串\n        strs = [data]\n    result = findLUSlength(strs)\n    print(result)                   # 將答案輸出到標準輸出\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines with comments, following the format. For the problem: longest uncommon subsequence between strings.\n\nWe need algorithm: If there is a string that is not equal to any other string, then the longest uncommon subsequence is that string's length, because the string itself is a subsequence of itself but not of others (since others different). So answer is max length among unique strings. If all strings identical, answer -1.\n\nThus steps: Count frequencies, find if any string unique. If yes, find max length among unique. Return that. Else -1.\n\nLet's produce virtual code lines.\n\nWe need start, step etc.\n\nLet's propose:\n\nStart\n→ Step 1: Build a map of string to frequency // count occurrences\n→ Step 2: Initialize maxLen = -1 // default answer\n→ Decision: For each string str in array // iterate\n    → Step 3: If frequency of str == 1 // unique\n        → Step 4: Update maxLen = max(maxLen, length of str) // track longest\n→ Step 5: Return maxLen // if -1 means none unique\nEnd\n\nWe need comments in Chinese.\n\nLet's produce lines with arrow and comments. Use proper indentation? In example, indentation with spaces and lines inside decision. We'll produce like:\n\nStart // 程式開始執行\n→ Step 1: Initialize freqMap // 建立字串頻率映射\n→ Step 2: For each str in strs // 遍歷所有字串\n    → Step 3: Increment freqMap[str] // 計算每個字串的出現次數\n→ Step 4: Set maxLen = -1 // 初始答案為 -1\n→ Step 5: For each str in strs // 再次遍歷以判斷唯一字串\n    → Decision: freqMap[str] == 1? // 是否唯一\n        Yes → Step 6: Update maxLen = max(maxLen, length of str) // 更新最大長度\n        No  → // 不是唯一，跳過\n→ Step 7: Return maxLen // 回傳結果\nEnd // 程式執行結束\n\nBut we need to maintain format: each line ends with comment after space.\n\nAlso use arrow in decision: `Yes →`, `No →`.\n\nWe need to show Decision block properly indented.\n\nWe'll do:\n\nStart // 程式開始執行\n→ Step 1: Initialize freqMap // 建立字串頻率映射\n→ Step 2: For each str in strs // 遍歷所有字串\n    → Step 3: Increment freqMap[str] // 計算每個字串的出現次數\n→ Step 4: Set maxLen = -1 // 初始答案為 -1\n→ Step 5: For each str in strs // 再次遍歷以判斷唯一字串\n    → Decision: freqMap[str] == 1? // 是否唯一\n        Yes → Step 6: Update maxLen = max(maxLen, length of str) // 更新最大長度\n        No  → // 不是唯一，跳過\n→ Step 7: Return maxLen // 回傳結果\nEnd // 程式執行結束\n\nMake sure indentation spaces? In example, they used two spaces indentation for lines inside decision. Let's use four spaces? In example they used 4 spaces before `Yes →`. Actually example shows:\n\n    Yes → Step 2: ...\n\nSo 4 spaces before Yes. Let's replicate.\n\nThus produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize freqMap // 建立字串頻率映射  \n→ Step 2: For each str in strs // 遍歷所有字串  \n    → Step 3: Increment freqMap[str] // 計算每個字串的出現次數  \n→ Step 4: Set maxLen = -1 // 初始答案為 -1  \n→ Step 5: For each str in strs // 再次遍歷以判斷唯一字串  \n    → Decision: freqMap[str] == 1? // 是否唯一  \n        Yes → Step 6: Update maxLen = max(maxLen, length of str) // 更新最大長度  \n        No  → // 不是唯一，跳過  \n→ Step 7: Return maxLen // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Return all permutations of the list nums using backtracking.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # When all positions are fixed, record the current permutation\n            if start == len(nums):\n                res.append(nums[:])  # make a copy\n                return\n            # Try every remaining element in the current position\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack swap\n\n        backtrack(0)\n        return res\n\ndef read_nums_from_stdin():\n    \"\"\"\n    Read the input from stdin. The input format is expected to be:\n    \"nums = [1, 2, 3]\"\n    or simply \"[1, 2, 3]\". The function extracts the list of integers.\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return []\n\n    # If the input contains an assignment, split on '='\n    if '=' in raw:\n        _, expr = raw.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw\n\n    # Use literal_eval to safely parse the list literal\n    return ast.literal_eval(expr)\n\nif __name__ == \"__main__\":\n    nums = read_nums_from_stdin()\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The task: generate all permutations of distinct integers array. Use backtracking.\n\nWe must adhere to format: each line: virtual code step + space + comment.\n\nUse arrows → for flow. Use Decision: for if. Use Start, End.\n\nWe need step by step. Eg:\n\nStart\n→ Step 1: Initialize result list\n→ Step 2: Define recursive function backtrack(current, remaining)\n→ Decision: 如果 remaining 為空?\n    Yes → Step 3: 將 current 加入 result\n    No  → Step 4: For each number in remaining:\n        → Step 5: 呼叫 backtrack(current + [num], remaining - {num})\n\nAt the end, return result.\n\nLet's format.\n\nMake sure each line is virtual code and explanation. Use arrow for each line after Start. For Decision nested, indent lines maybe. Use the same style as example. So we will indent the nested steps.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 建立空的結果列表  \n→ Step 2: 定義函式 backtrack(current, remaining) // 從剩餘元素產生排列  \n→ Decision: 如果 remaining 為空? // 檢查是否已排列完成  \n    Yes → Step 3: result ← result + [current] // 將完成的排列加入結果  \n    No → Step 4: 為 each num in remaining: // 遍歷每個剩餘元素  \n        → Step 5: backtrack(current + [num], remaining \\ {num}) // 遞迴加入元素並移除  \n→ Step 6: backtrack([], nums) // 從空排列開始遞迴  \nEnd // 程式執行結束  \n→ Step 7: return result // 回傳所有排列結果"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsw6q3i13.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmpsw6q3i13.py\", line 58, in main\n    args = ast.literal_eval(args_text)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[], [1], [1], [2], [], [1], []]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用列表儲存所有元素，支持 O(1) 隨機存取\n        self.data = []\n        # 字典：key 為數值，value 為該數值在 data 中所有索引的集合\n        self.idx_map = {}\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，若為首次出現返回 True，否則 False。\"\"\"\n        if val not in self.idx_map:\n            self.idx_map[val] = set()\n        # 把新值放在列表尾部\n        self.data.append(val)\n        # 記錄其索引\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若集合剛好只有一個索引，表示之前未出現過\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在返回 True，否則 False。\"\"\"\n        if val not in self.idx_map or not self.idx_map[val]:\n            return False\n        # 任取一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 把最後一個元素放到被刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n        # 移除列表尾部元素\n        self.data.pop()\n        # 若該值已無索引，從字典中刪除\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素。\"\"\"\n        return random.choice(self.data)\n\n\ndef main():\n    input_text = sys.stdin.read().strip()\n    if not input_text:\n        return\n    # 找到第一個結束第一個列表的位置\n    split_pos = input_text.find(']') + 1\n    ops_text = input_text[:split_pos]\n    args_text = input_text[split_pos:].strip()\n    ops = ast.literal_eval(ops_text)\n    args = ast.literal_eval(args_text)\n\n    rc = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            rc = RandomizedCollection()\n            output.append(None)\n        elif op == \"insert\":\n            output.append(rc.insert(arg[0]))\n        elif op == \"remove\":\n            output.append(rc.remove(arg[0]))\n        elif op == \"getRandom\":\n            output.append(rc.getRandom())\n\n    print(json.dumps(output))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedCollection with operations insert, remove, getRandom, each O(1) average. Use array list and hashmap of val to set of indices. Provide pseudocode line by line with explanations. Let's design steps. Outline:\n\nStart\nInitialize list and map\nInsert: if val not in map, add new set. Add val to list, record index, update map. Return whether was new.\nRemove: if val not in map or set empty return false. Else pick an arbitrary index from set. Get last element and last index. Replace removed index with last element in list. Update map entries for last element's index. Remove last from list. Remove index from val's set; if set empty remove key. Return true.\nGetRandom: return random element from list.\n\nWill produce each line of pseudocode with explanation. Let's follow the output format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows and decisions. Should include Start and End. Provide steps. We'll write in Chinese. Ensure arrow syntax like \"→\". Provide decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 list = [] // 用於存放所有元素，支持 O(1) 隨機存取  \n→ Step 2: 初始化 map = {} // key 為值，value 為該值在 list 中所有索引的集合  \n\n// ---------- Insert ----------\n→ Step 3: 函式 insert(val) // 開始插入操作  \n→ Step 4: 如果 val 不在 map 中 → map[val] = 空集合 // 如果是第一次插入，建立集合  \n→ Step 5: 將 val 加到 list 的尾部 → idx = list.size() - 1 // 新元素索引  \n→ Step 6: map[val].add(idx) // 將索引加入對應集合  \n→ Step 7: 返回 map[val].size() == 1 // 若之前不存在則為 true，否則為 false  \n\n// ---------- Remove ----------\n→ Step 8: 函式 remove(val) // 開始刪除操作  \n→ Step 9: Decision: 如果 val 不在 map 或 map[val] 為空? // 判斷 val 是否存在  \n    → No → return false // 無此元素，直接返回 false  \n    → Yes →  \n        → Step 10: 選取 map[val] 中任一索引 → idxToRemove = 任意元素  \n        → Step 11: 取得 list 的最後一個元素及其索引 → lastVal = list[-1], lastIdx = list.size() - 1  \n        → Step 12: 將 list[idxToRemove] = lastVal // 用最後元素覆蓋被刪除位置  \n        → Step 13: 更新 map[lastVal]：先移除 lastIdx，再加入 idxToRemove  \n        → Step 14: 刪除 list 的最後一個元素 → list.pop() // 真正減少長度  \n        → Step 15: map[val].remove(idxToRemove) // 移除被刪除元素的索引  \n        → Step 16: Decision: 如果 map[val] 現已空? // 清理空集合  \n            → Yes → delete map[val]  \n        → Step 17: return true // 成功刪除一個元素  \n\n// ---------- getRandom ----------\n→ Step 18: 函式 getRandom() // 隨機取值  \n→ Step 19: 生成隨機索引 r ∈ [0, list.size()-1]  \n→ Step 20: return list[r] // 隨機返回元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # 大根堆 (小數部分) 用負數儲存\n        self.small = []\n        # 小根堆 (大數部分)\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 先放到小數部分\n        heapq.heappush(self.small, -num)\n        # 保持「小數部分」最大值 <= 「大數部分」最小值\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 平衡兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析成兩個列表\n    commands, args = eval(data)\n\n    result = []\n    mf = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            mf.addNum(arg[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            median = mf.findMedian()\n            result.append(median)\n\n    # 轉換結果為 JSON 風格輸出\n    out = []\n    for r in result:\n        if r is None:\n            out.append(\"null\")\n        else:\n            out.append(str(r))\n    print(\"[\" + \", \".join(out) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo code line by line for MedianFinder class with addNum and findMedian. Use a heap approach: two heaps: max heap for lower half, min heap for upper half. Maintain size difference <=1. When addNum, push into appropriate heap, then balance. findMedian: if same size, return (top1 + top2)/2 else return top of larger heap. Provide line-by-line pseudo-code. Use structure Start, End, Decision. Use arrow. Provide short explanation after // each line.\n\nLet's produce: Start, constructor, initialize heaps, addNum function with steps, findMedian function. Each line separate.\n\nBe careful to keep format exactly: `虛擬碼步驟 // 解釋/說明`\n\nWe must produce in Traditional Chinese.\n\nWe'll need to write pseudocode lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 建立類別\n→ Step 2: 初始化 maxHeap, minHeap // 兩個堆積\n\nWe need to be precise: The code is pseudo, we don't write actual code. Just steps.\n\nLet's produce:\n\nStart\n→ Step: 定義 MedianFinder 類別 // 建立類別\n→ Step: 宣告 maxHeap 為大根堆 // 用於儲存較小的一半數字\n→ Step: 宣告 minHeap 為小根堆 // 用於儲存較大的一半數字\n→ Step: 定義 addNum(num) 方法 // 增加新數字\n    → Decision: 如果 maxHeap 空 或 num <= maxHeap.top? // 判斷數字應放於哪個堆\n        Yes → Step: maxHeap.push(num) // 把 num 放進大根堆\n        No  → Step: minHeap.push(num) // 把 num 放進小根堆\n    → Decision: 如果 maxHeap.size() > minHeap.size() + 1? // 檢查大小差距是否大於 1\n        Yes → Step: minHeap.push(maxHeap.pop()) // 將大根堆頂移到小根堆\n    → Decision: 如果 minHeap.size() > maxHeap.size() + 1? // 檢查另一方大小差距\n        Yes → Step: maxHeap.push(minHeap.pop()) // 將小根堆頂移到大根堆\n→ Step: 定義 findMedian() 方法 // 回傳目前的中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 檢查兩堆大小是否相等\n        Yes → Step: 返回 (maxHeap.top() + minHeap.top()) / 2.0 // 兩堆平均\n        No  → Decision: maxHeap.size() > minHeap.size()? // 判斷哪堆較大\n            Yes → Step: 返回 maxHeap.top() // 大根堆頂即為中位數\n            No  → Step: 返回 minHeap.top() // 小根堆頂即為中位數\nEnd // 程式結束\n\nMake sure each line ends with // 解釋/說明. Use spaces after pseudo code.\n\nWe also need to use arrows in decisions: Use `→ Decision:`.\n\nOk. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類別 // 建立類別  \n→ Step 2: 宣告 maxHeap 為大根堆 // 儲存較小的一半數字  \n→ Step 3: 宣告 minHeap 為小根堆 // 儲存較大的一半數字  \n\n→ Step 4: 定義 addNum(num) 方法 // 增加新數字  \n  → Decision: 如果 maxHeap 空 或 num <= maxHeap.top()? // 判斷數字應放於哪個堆  \n    Yes → Step 5: maxHeap.push(num) // 把 num 放進大根堆  \n    No  → Step 6: minHeap.push(num) // 把 num 放進小根堆  \n  → Decision: 如果 maxHeap.size() > minHeap.size() + 1? // 檢查大小差距是否大於 1  \n    Yes → Step 7: minHeap.push(maxHeap.pop()) // 將大根堆頂移到小根堆  \n  → Decision: 如果 minHeap.size() > maxHeap.size() + 1? // 檢查另一方大小差距  \n    Yes → Step 8: maxHeap.push(minHeap.pop()) // 將小根堆頂移到大根堆  \n\n→ Step 9: 定義 findMedian() 方法 // 回傳目前的中位數  \n  → Decision: maxHeap.size() == minHeap.size()? // 檢查兩堆大小是否相等  \n    Yes → Step 10: 返回 (maxHeap.top() + minHeap.top()) / 2.0 // 兩堆平均  \n    No  → Decision: maxHeap.size() > minHeap.size()? // 判斷哪堆較大  \n     Yes → Step 11: 返回 maxHeap.top() // 大根堆頂即為中位數  \n     No  → Step 12: 返回 minHeap.top() // 小根堆頂即為中位數  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5n5h05u5.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp5n5h05u5.py\", line 50, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5n5h05u5.py\", line 41, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnlzalm7j.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpnlzalm7j.py\", line 50, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnlzalm7j.py\", line 41, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted, non-overlapping list of intervals,\n        merging if necessary.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n\n        # Add the remaining intervals that start after the new interval ends\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(raw: str):\n    \"\"\"\n    Parse the input format:\n    'intervals = [[1,3],[6,9]], newInterval = [2,5]'\n    \"\"\"\n    # Find the two list literals in the string\n    lists = re.findall(r'\\[.*?\\]', raw)\n    if len(lists) != 2:\n        raise ValueError(\"Input format is incorrect.\")\n    intervals = eval(lists[0])\n    new_interval = eval(lists[1])\n    return intervals, new_interval\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    intervals, new_interval = parse_input(raw_input)\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudocode with arrow format. Each line: virtual step + // explanation. Use arrows. We need to cover algorithm: iterate, insert before/after, merge.\n\nWe need to generate step lines.\n\nLet's produce:\n\nStart\n→ Initialize result list // new array to store final intervals\n→ Initialize i=0 // index for original intervals\n→ While i < intervals.length and intervals[i].end < newInterval.start // intervals completely before new interval\n    → Append intervals[i] to result // add non-overlapping before\n    → i++ // move next\n→ // Now we may have overlap or next after new interval\n→ Decision: Are there remaining intervals and intervals[i].start <= newInterval.end? // check for overlap\n    Yes → Merge newInterval with overlapping intervals\n        → While i < intervals.length and intervals[i].start <= newInterval.end\n            → newInterval.start = min(newInterval.start, intervals[i].start) // update start\n            → newInterval.end = max(newInterval.end, intervals[i].end) // update end\n            → i++ // skip merged\n        → Append newInterval to result // add merged interval\n    No  → // No overlap, just append new interval\n        → Append newInterval to result\n→ // Append the rest intervals after new interval\n→ While i < intervals.length\n    → Append intervals[i] to result\n    → i++\n→ End // return result\n\nMake sure each line is a separate line. Use arrows and indent for decisions.\n\nLet's produce with correct format. Use Start, End, Decision, Yes→, No→ etc. Ensure we include \"Decision:\" line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ result ← [] // 初始化結果陣列，用於存放合併後的區間\n→ i ← 0 // 初始化索引，用於遍歷原始區間\n→ While i < intervals.length 且 intervals[i].end < newInterval.start // 找到所有完全位於新區間之前的區間\n    → result.append(intervals[i]) // 把前置區間加入結果\n    → i ← i + 1 // 移動到下一個區間\n→ Decision: 是否還有剩餘區間且 intervals[i].start ≤ newInterval.end? // 判斷是否存在重疊區間\n    Yes → // 需要合併重疊區間\n        → While i < intervals.length 且 intervals[i].start ≤ newInterval.end\n            → newInterval.start ← min(newInterval.start, intervals[i].start) // 更新合併區間的開始點\n            → newInterval.end ← max(newInterval.end, intervals[i].end) // 更新合併區間的結束點\n            → i ← i + 1 // 跳過已合併的區間\n        → result.append(newInterval) // 把合併後的區間加入結果\n    No  → // 無重疊，直接加入新區間\n        → result.append(newInterval) // 把新區間加入結果\n→ // 把剩餘不重疊且位於新區間之後的區間追加\n→ While i < intervals.length\n    → result.append(intervals[i]) // 加入剩餘區間\n    → i ← i + 1 // 移動到下一個區間\nEnd // 程式執行結束，返回 result（插入並合併後的區間列表）"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nINF = 10**9\n\ndef collapse(board: str) -> str:\n    \"\"\"Remove all groups of 3 or more consecutive same-colored balls repeatedly.\"\"\"\n    while True:\n        new_board = []\n        i = 0\n        changed = False\n        while i < len(board):\n            j = i + 1\n            while j < len(board) and board[j] == board[i]:\n                j += 1\n            count = j - i\n            if count >= 3:\n                changed = True  # group removed\n            else:\n                new_board.append(board[i] * count)\n            i = j\n        if not changed:\n            return board\n        board = ''.join(new_board)\n\ndef dfs(board: str, hand_counts: dict, memo: dict) -> int:\n    \"\"\"Recursively find minimal insertions to clear board.\"\"\"\n    if not board:\n        return 0\n    if all(v == 0 for v in hand_counts.values()):\n        return INF\n    key = (board, tuple(hand_counts[c] for c in 'RYBGW'))\n    if key in memo:\n        return memo[key]\n    min_steps = INF\n    n = len(board)\n    for i in range(n + 1):\n        for color in 'RYBGW':\n            if hand_counts[color] == 0:\n                continue\n            # Count same-colored balls adjacent to insertion point\n            left = i - 1\n            left_count = 0\n            while left >= 0 and board[left] == color:\n                left_count += 1\n                left -= 1\n            right = i\n            right_count = 0\n            while right < n and board[right] == color:\n                right_count += 1\n                right += 1\n            if left_count + right_count + 1 < 3:\n                continue  # insertion wouldn't trigger removal\n            # Perform insertion and collapse\n            new_board = board[:i] + color + board[i:]\n            collapsed = collapse(new_board)\n            hand_counts[color] -= 1\n            sub_steps = dfs(collapsed, hand_counts, memo)\n            hand_counts[color] += 1\n            if sub_steps != INF:\n                min_steps = min(min_steps, 1 + sub_steps)\n    memo[key] = min_steps\n    return min_steps\n\ndef find_min_steps(board: str, hand: str) -> int:\n    hand_counts = defaultdict(int)\n    for c in hand:\n        hand_counts[c] += 1\n    memo = {}\n    res = dfs(board, hand_counts, memo)\n    return -1 if res >= INF else res\n\ndef main():\n    data = sys.stdin.read()\n    # Extract quoted substrings; expected two: board and hand\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        board, hand = parts[0], parts[1]\n    else:\n        # fallback: split by comma\n        parts = [p.strip() for p in data.split(',')]\n        board = parts[0].split('=')[1].strip().strip('\"').strip(\"'\")\n        hand = parts[1].split('=')[1].strip().strip('\"').strip(\"'\")\n    result = find_min_steps(board, hand)\n    print(result)\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(10000)\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving this Zuma variation: minimal insertions to clear board using given hand. This is a classic problem \"Zuma Game\" from Leetcode. The solution involves DFS/backtracking with pruning, using state representation: board string, hand counts. Recursively try insertions that can create a removal. Use caching. Minimal steps. If not possible, return -1.\n\nWe need to output in specified format: each line has \"虛擬碼步驟\" and comment. Use arrows, decisions. Provide structure. Not actual code. Provide step-by-step pseudo-algorithm.\n\nWe need to produce a series of steps. We must incorporate recursion, backtracking, board collapse logic, counting of hand balls.\n\nLet's outline:\n\nStart\n→ Initialize hand count map from hand string\n→ Define function DFS(board, handCount) returning minimal steps or INF\n    Decision: If board empty → return 0\n    Decision: If hand empty → return INF\n    -> For each index in board positions (0..len)\n        -> Determine color to insert: for each color c where handCount[c]>0\n            -> If inserting at index can create a group of >=3 of color c:\n                -> Simulate insertion and collapse\n                -> Reduce handCount[c] by 1\n                -> Recursively call DFS on new board\n                -> Record min steps = min(min, 1 + result)\n    -> Return min or INF\n→ Call DFS(initialBoard, handCount)\n→ Decision: If result >= INF → return -1 else return result\n\nWe also need collapse function: while any group >=3, remove them, then repeat. We can implement as loop scanning.\n\nAdd caching: Use map from (board, handKey) to result. Use memoization to avoid recomputation.\n\nNow produce lines.\n\nWe must use arrows and decisions. Provide explanation after //.\n\nLet's write.\n\nWe should mention start of program, initialize, function definitions, recursion, loops.\n\nMake sure each line is single step with explanation.\n\nLet's craft.\n\nWe might need to break loops into steps.\n\nLet's produce the pseudo code.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Build handCount // 將手牌字串轉成顏色計數表  \n    ← For each character c in hand  \n        → handCount[c] += 1 // 記錄每種顏色的可用數量  \n\n→ Define DFS(board, handCount) // 定義遞迴求最小插入數的函式  \n    ← 若 board 為空串 → Return 0 // 已清空，無需再插入  \n    ← 若 handCount 所有顏色數量為 0 → Return INF // 手牌已用盡，無法完成  \n\n    ← Set minStep = INF // 初始最小步數為無限大  \n    → For i from 0 to board.length() // 遍歷每個插入位置  \n        → For each color c where handCount[c] > 0 // 嘗試每種可插入顏色  \n            → Decision: 若在位置 i 插入 c 能形成 >=3 同色連續球?  \n                Yes →  \n                    → newBoard = InsertAndCollapse(board, i, c) // 插入並消除  \n                    → handCount[c] -= 1 // 使用一顆手牌  \n                    → steps = DFS(newBoard, handCount) // 递归求解剩余部分  \n                    → 若 steps < INF → minStep = min(minStep, 1 + steps) // 更新最小步數  \n                    → handCount[c] += 1 // 回溯，恢復手牌數量  \n                No  → // 插入不產生任何消除，跳過此組合  \n                    Continue  \n\n    ← Return minStep // 返回找到的最小步數或 INF  \n\n→ Define InsertAndCollapse(board, index, color) // 插入後連續消除的輔助函式  \n    ← newBoard = board[:index] + color + board[index:] // 在指定位置插入球  \n    ← While True // 重複消除過程直到無法再消除  \n        → 找到 board 中所有長度 >=3 的同色區段  \n        → 若無此區段 → Break // 沒有可消除區域，結束循環  \n        → 否則 →  \n            → newBoard = RemoveAllOccurrences(newBoard, 每個長度>=3 的區段) // 同時移除所有區段  \n            → // 循環繼續檢查新 board  \n    ← Return newBoard  \n\n→ Define memoization cache // 用於存儲已計算的子問題結果  \n    ← cache = {} // key: (board, handCountKey)  \n\n→ Define MemoizedDFS(board, handCount) // 包裝 DFS 幫助使用快取  \n    ← key = (board, handCountKey) // handCountKey 為手牌計數的字串表示  \n    → Decision: 若 key 存在於 cache  \n        Yes → Return cache[key] // 直接回傳已計算結果  \n        No  →  \n            → result = DFS(board, handCount) // 執行實際遞迴  \n            → cache[key] = result // 存入快取  \n            → Return result  \n\n→ result = MemoizedDFS(initialBoard, handCount) // 啟動主遞迴  \n→ Decision: 若 result >= INF  \n    Yes → Return -1 // 無法清空全部球  \n    No  → Return result // 返回最小插入數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Delete Operation for Two Strings",
      "source_file": "Leetcode/leetcode583.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "word1 = \"sea\", word2 = \"eat\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "word1 = \"leetcode\", word2 = \"etco\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef extract_word(line: str) -> str:\n    \"\"\"\n    從一行文字中擷取字串，若有雙引號則取其中內容。\n    \"\"\"\n    match = re.search(r'\"([^\"]*)\"', line)\n    if match:\n        return match.group(1)\n    return line.strip().strip('\"').strip(\"'\")\n\ndef min_deletions_to_equal(word1: str, word2: str) -> int:\n    \"\"\"\n    使用 LCS (Longest Common Subsequence) 計算最小刪除步驟。\n    步驟 = len(word1) + len(word2) - 2 * LCS_len\n    \"\"\"\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    lcs_len = dp[m][n]\n    return m + n - 2 * lcs_len\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    if len(data) >= 2:\n        w1 = extract_word(data[0])\n        w2 = extract_word(data[1])\n    else:\n        parts = data[0].split()\n        w1 = extract_word(parts[0])\n        w2 = extract_word(parts[1]) if len(parts) > 1 else \"\"\n\n    result = min_deletions_to_equal(w1, w2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode that solves the problem: given two strings word1 and word2, minimum number of deletions to make them equal. That's essentially find longest common subsequence length L, then steps = (len(word1)-L)+(len(word2)-L). But we can also do dynamic programming.\n\nWe need to produce step-by-step pseudocode lines with explanation after each line.\n\nThe output must be plain lines with \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe must use arrow symbols (→, Yes →, No →). Use Start, End, Decision:.\n\nThus, we design algorithm:\n\nStart\n→ Input word1, word2\n→ Let m = length(word1), n = length(word2)\n→ Initialize DP table of size (m+1)x(n+1) with zeros // DP[i][j] LCS length of first i chars of word1 and first j of word2\n→ For i from 1 to m:\n    → For j from 1 to n:\n        → Decision: if word1[i-1] == word2[j-1]?\n            Yes → DP[i][j] = DP[i-1][j-1] + 1\n            No  → DP[i][j] = max(DP[i-1][j], DP[i][j-1])\n→ LCS = DP[m][n]\n→ steps = (m - LCS) + (n - LCS)\n→ Output steps\nEnd\n\nBut we need to output each line with explanation. Also use arrow for loops maybe. For loops we can use \"For i from 1 to m:\" as a step.\n\nWe must use virtual code step arrow syntax: Use \"→\" before each step.\n\nAlso for decision, we need to indent the Yes/No branches.\n\nWe need to ensure each line has arrow.\n\nLet's draft.\n\nLine 1: Start // 程式開始\n\nLine 2: → Input word1, word2 // 取得兩個字串\n\nLine 3: → m = length(word1), n = length(word2) // 取得長度\n\nLine 4: → Initialize DP[0..m][0..n] with 0 // LCS 表格\n\nLine 5: → For i from 1 to m: // 逐行遍歷 word1\n\nLine 6:     → For j from 1 to n: // 逐列遍歷 word2\n\nLine 7:         → Decision: word1[i-1] == word2[j-1]? // 比較字元\n\nLine 8:             Yes → DP[i][j] = DP[i-1][j-1] + 1 // 兩字元相同，遞增\n\nLine 9:             No  → DP[i][j] = max(DP[i-1][j], DP[i][j-1]) // 取最大\n\nLine 10: → LCS = DP[m][n] // 最長公共子序列長度\n\nLine 11: → steps = (m - LCS) + (n - LCS) // 需要刪除的總數\n\nLine 12: → Output steps // 顯示答案\n\nLine 13: End // 程式結束\n\nWe need to ensure we follow requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". Yes.\n\nAlso need to use virtual code arrow (→) before each step, including Start and End.\n\nBut indentation for inner loops maybe we add arrow at start of each line as \"→\" but we also need to indent lines maybe with spaces? In the example, inner lines have indentation and arrow after indentation: e.g., \"Yes → Step ...\". For loops, example didn't show indentation. But we can still indent lines after For with a tab or spaces and arrow. The arrow must be after indentation? In example, they show \"Yes →\" at start of line with no indentation. For loops, they don't show arrow, but we can follow style: Use \"→\" for each step. For nested, maybe indent with 4 spaces then arrow. Let's match style: \"→ For i from 1 to m:\" maybe. Then inner lines indent 4 spaces then \"→\" again? In example, the lines under Decision: Yes/No also have indent but arrow remains. For simplicity, use \"→\" at beginning of each line regardless of indentation. But we can indent with spaces for readability. Provide each line starting with \"→\".\n\nLet's produce.\n\nMake sure no extra code. Provide lines as plain text lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始  \n→ Input word1, word2 // 取得兩個字串  \n→ m = length(word1), n = length(word2) // 取得字串長度  \n→ Initialize DP[0..m][0..n] with 0 // 建立 LCS 表格，初始值為 0  \n→ For i from 1 to m: // 逐行遍歷 word1  \n → For j from 1 to n: // 逐列遍歷 word2  \n  → Decision: word1[i-1] == word2[j-1]? // 比較當前字元是否相同  \n   Yes → DP[i][j] = DP[i-1][j-1] + 1 // 相同時遞增 LCS 長度  \n   No  → DP[i][j] = max(DP[i-1][j], DP[i][j-1]) // 不同時取上一步或左一步最大值  \n→ LCS = DP[m][n] // 取得整體最長公共子序列長度  \n→ steps = (m - LCS) + (n - LCS) // 計算需要刪除的總字元數  \n→ Output steps // 顯示最小步驟數  \nEnd // 程式結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []  # list of [l, r), sorted by l, non-overlapping\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:  # overlap\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        # binary search for interval that could cover left\n        lo, hi = 0, len(self.ranges) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            l, r = self.ranges[mid]\n            if l <= left < r:\n                return right <= r\n            if left < l:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return False\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef parse_command(cmd: str):\n    \"\"\"Return (method, left, right) or (method, None, None)\"\"\"\n    if cmd.startswith(\"rangeModule.addRange\"):\n        m = re.search(r'\\(([^,]+),\\s*([^)]+)\\)', cmd)\n        left, right = int(m.group(1)), int(m.group(2))\n        return (\"addRange\", left, right)\n    if cmd.startswith(\"rangeModule.removeRange\"):\n        m = re.search(r'\\(([^,]+),\\s*([^)]+)\\)', cmd)\n        left, right = int(m.group(1)), int(m.group(2))\n        return (\"removeRange\", left, right)\n    if cmd.startswith(\"rangeModule.queryRange\"):\n        m = re.search(r'\\(([^,]+),\\s*([^)]+)\\)', cmd)\n        left, right = int(m.group(1)), int(m.group(2))\n        return (\"queryRange\", left, right)\n    return (None, None, None)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # split by ';' and newline, ignore empty strings\n    tokens = [t.strip() for t in re.split(r'[;\\n]+', data) if t.strip()]\n    rm = RangeModule()\n    outputs = []\n    for token in tokens:\n        if token.startswith(\"RangeModule\"):\n            # constructor, ignore\n            continue\n        method, left, right = parse_command(token)\n        if method == \"addRange\":\n            rm.addRange(left, right)\n            outputs.append(\"null\")\n        elif method == \"removeRange\":\n            rm.removeRange(left, right)\n            outputs.append(\"null\")\n        elif method == \"queryRange\":\n            res = rm.queryRange(left, right)\n            outputs.append(\"true\" if res else \"false\")\n        else:\n            # unknown token, ignore\n            continue\n    print(\"[\" + \", \".join(outputs) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for a RangeModule data structure. Use a virtual code with steps like Start, Decision, etc. Need to output line by line: \"虛擬碼步驟 // 解釋\". Provide a step-by-step algorithm design: e.g., using an ordered map or list of intervals, merge, query, remove. Use a sorted list or TreeSet. We'll design using TreeSet of intervals represented as pairs. Steps: initialize set. AddRange: find overlapping intervals, merge. QueryRange: check coverage. RemoveRange: split or adjust intervals.\n\nWe need to produce virtual code, not actual code, but pseudocode. Use arrows \"→\". Use Decision statements. Provide explanation.\n\nLet's produce:\n\nStart // begin\n\n→ Step 1: Initialize TreeSet of intervals // store non-overlapping intervals sorted by start\n\nAddRange:\n\n→ Step 2: AddRange(left,right) // main function\n→ Decision: Find first interval with start <= right and end >= left? // find overlapping intervals\n    Yes → ...\nBut we should outline the algorithm: Use lowerBound to find potential overlapping intervals. Merge them.\n\nSimplify: We'll produce high-level steps:\n\nAddRange:\n\n- Find iterator to first interval where end >= left (i.e., potential overlap)\n- While interval.start <= right:\n    - Update left = min(left, interval.start)\n    - Update right = max(right, interval.end)\n    - Remove interval from set\n- Insert merged [left,right] into set\n\nSimilarly queryRange:\n\n- Find interval that starts after left? Actually find interval where start <= left and end >= right? Wait.\n\n- Find interval that starts at or before left. If none, return false\n- If that interval.end >= right, return true else false\n\nRemoveRange:\n\n- Find interval that starts before right and ends after left\n- For each overlapping interval, may need to split into up to two intervals: left part before left, right part after right\n- Remove all overlapping intervals\n- Insert remaining parts if any.\n\nWe need to output step by step pseudocode with explanation.\n\nLet's produce.\n\nWe should produce each line like:\n\nStart // start\n\n→ Step 1: Define RangeModule // define the data structure\n\n→ Step 2: TreeSet<Interval> intervals // store intervals sorted\n\n→ Step 3: Constructor: intervals = new TreeSet(compare by start) // init\n\nThen methods: AddRange, QueryRange, RemoveRange.\n\nWe need to show arrow transitions.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RangeModule 類別 // 建立範圍模組的資料結構  \n→ Step 2: TreeSet<Interval> intervals // 用有序集合存儲非重疊的半開區間  \n→ Step 3: Constructor  \n    → intervals = new TreeSet(按 start 排序) // 初始化集合  \n\n→ Step 4: Method addRange(left, right) // 加入區間  \n    → Decision: 找到第一個可能重疊的區間  \n        Yes → it = intervals.lowerBound([left, ∞)) // 第一个 start ≥ left 的區間  \n        No  → it = intervals.begin() // 沒有直接超過 left 的區間，從頭開始  \n    → left = left, right = right // 重新設定合併範圍  \n    → While it != intervals.end() 且 it.start <= right // 只考慮可能重疊的區間  \n        → left = min(left, it.start) // 合併左邊界  \n        → right = max(right, it.end) // 合併右邊界  \n        → next = next(it)  \n        → intervals.erase(it) // 移除已合併的區間  \n        → it = next  \n    → intervals.insert([left, right]) // 插入合併後的新區間  \n\n→ Step 5: Method queryRange(left, right) // 查詢區間是否完全覆蓋  \n    → Decision: 在 intervals 中尋找最後一個 start <= left 的區間  \n        Yes → it = intervals.floor([left, ∞))  \n        No  → return false // 沒有起始於左側或之前的區間  \n    → Decision: it.end >= right? // 該區間是否覆蓋右側  \n        Yes → return true  \n        No  → return false  \n\n→ Step 6: Method removeRange(left, right) // 移除區間  \n    → Decision: 找到第一個可能重疊的區間  \n        Yes → it = intervals.lowerBound([left, ∞))  \n        No  → it = intervals.begin()  \n    → While it != intervals.end() 且 it.start < right // 只處理可能重疊的區間  \n        → Decision: it.start < left? // 需要保留左邊部分  \n            Yes → intervals.insert([it.start, left]) // 插入左側剩餘區間  \n        → Decision: it.end > right? // 需要保留右邊部分  \n            Yes → intervals.insert([right, it.end]) // 插入右側剩餘區間  \n        → next = next(it)  \n        → intervals.erase(it) // 移除已被切割的原區間  \n        → it = next  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0kcvt17f.py\", line 90, in <module>\n    main()\n  File \"/tmp/tmp0kcvt17f.py\", line 61, in main\n    commands = json.loads(lines[0])\n               ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k       # 儲存元素的循環緩衝區\n        self.head = 0            # 指向目前前端元素的位置\n        self.count = 0           # 當前元素個數\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1 + self.k) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n    commands = json.loads(lines[0])\n    args_list = json.loads(lines[1]) if len(lines) > 1 else []\n    results = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            results.append(None)\n        elif cmd == \"insertFront\":\n            results.append(obj.insertFront(*args))\n        elif cmd == \"insertLast\":\n            results.append(obj.insertLast(*args))\n        elif cmd == \"deleteFront\":\n            results.append(obj.deleteFront(*args))\n        elif cmd == \"deleteLast\":\n            results.append(obj.deleteLast(*args))\n        elif cmd == \"getFront\":\n            results.append(obj.getFront(*args))\n        elif cmd == \"getRear\":\n            results.append(obj.getRear(*args))\n        elif cmd == \"isEmpty\":\n            results.append(obj.isEmpty(*args))\n        elif cmd == \"isFull\":\n            results.append(obj.isFull(*args))\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code lines with explanations. Virtual code uses arrows →, decisions etc. We need to design implementation of circular deque.\n\nWe need to produce pseudo-code structure that covers initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Provide step-by-step logic for each method. Use decision blocks.\n\nWe'll produce like:\n\nStart\n→ Step: 定義 MyCircularDeque class with capacity, array, front, rear, size\n→ Method: Init(k)\n→ etc.\n\nWe should produce each line as separate line. Use \"→\" for step. For decisions, use \"Decision: ...?\" and then Yes → and No →.\n\nWe need to show internal logic. For insertFront: check if full, if not, adjust front pointer (decrement circular), assign value, increment size.\n\nWe should mention array indexing modulo capacity.\n\nSimilarly for insertLast.\n\nFor deleteFront: check empty, adjust front pointer (increment circular), decrement size.\n\nDeleteLast: check empty, adjust rear pointer (decrement circular), decrement size.\n\nGetFront: if empty return -1 else return array[front]\n\nGetRear: if empty return -1 else return array[(rear-1+capacity)%capacity] maybe if rear points to next insertion.\n\nBut we can decide design: using front and rear indices as pointers to front and rear positions? Typical design: front index points to front element; rear index points to next insertion position? We can choose design: front index of front element, rear index of last element. Use size to check empty/full. We'll design accordingly.\n\nWe need to produce pseudo-code. Each line with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: 定義類別 MyCircularDeque // 開始定義類別\n→ Step 2: 變數 capacity, data array, front index, rear index, size\n→ Step 3: Method MyCircularDeque(k) // 初始化\n   → Assignment: capacity ← k\n   → Allocation: data ← array of size k\n   → front ← 0\n   → rear ← 0\n   → size ← 0\n→ Method insertFront(value)\n   → Decision: 如果 isFull()? // 檢查是否已滿\n      Yes → return False // 不能插入\n      No  → \n         → front ← (front - 1 + capacity) mod capacity // 往前移動指標\n         → data[front] ← value // 放入數值\n         → size ← size + 1\n         → return True\nSimilarly for insertLast:\n\n→ Method insertLast(value)\n   → Decision: if isFull()?\n      Yes → return False\n      No →\n         → data[rear] ← value\n         → rear ← (rear + 1) mod capacity // 移動指標\n         → size ← size + 1\n         → return True\n\nDeleteFront:\n\n→ Method deleteFront()\n   → Decision: if isEmpty()?\n      Yes → return False\n      No →\n         → front ← (front + 1) mod capacity\n         → size ← size - 1\n         → return True\n\nDeleteLast:\n\n→ Method deleteLast()\n   → Decision: if isEmpty()?\n      Yes → return False\n      No →\n         → rear ← (rear - 1 + capacity) mod capacity\n         → size ← size - 1\n         → return True\n\nGetFront:\n\n→ Method getFront()\n   → Decision: if isEmpty()?\n      Yes → return -1\n      No →\n         → return data[front]\n\nGetRear:\n\n→ Method getRear()\n   → Decision: if isEmpty()?\n      Yes → return -1\n      No →\n         → index ← (rear - 1 + capacity) mod capacity\n         → return data[index]\n\nisEmpty:\n\n→ Method isEmpty()\n   → return size == 0\n\nisFull:\n\n→ Method isFull()\n   → return size == capacity\n\nEnd\n\nWe need to produce each line as separate, including internal steps. But careful: lines like \"Assignment: capacity ← k\" and explanation. Also we may need to separate inside methods.\n\nLet's output each step line by line.\n\nMake sure to include \"→\" before step lines. For decisions, we need \"Decision:\" line then indent lines for Yes and No. But formatting: each line is a separate line, with \"Decision: ...?\" line and then following Yes → and No → lines. We need to maintain the format. Indent not necessary but we can separate with newline.\n\nWe should maintain the example formatting: For decisions we include lines like:\n\nDecision: 如果 isFull()? // 檢查是否已滿\n    Yes → return False // 不能插入\n    No  → // further steps\n\nWe need to keep each line as separate.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MyCircularDeque // 開始定義類別  \n→ Step 2: 宣告變數 capacity, data array, front, rear, size // 設定資料結構  \n\n→ Method MyCircularDeque(k) // 初始化函式  \n    → Assignment: capacity ← k // 儲存最大容量  \n    → Allocation: data ← array of size k // 建立固定長度陣列  \n    → front ← 0 // 前端指標初始化  \n    → rear ← 0 // 後端指標初始化  \n    → size ← 0 // 現有元素數量為 0  \n\n→ Method insertFront(value) // 在前端插入元素  \n    → Decision: 如果 isFull()? // 檢查是否已滿  \n        Yes → return False // 插入失敗，回傳 False  \n        No  → // 可插入  \n            → front ← (front - 1 + capacity) mod capacity // 前移指標  \n            → data[front] ← value // 放入數值  \n            → size ← size + 1 // 元素數量加 1  \n            → return True // 插入成功  \n\n→ Method insertLast(value) // 在後端插入元素  \n    → Decision: 如果 isFull()? // 檢查是否已滿  \n        Yes → return False // 插入失敗，回傳 False  \n        No  → // 可插入  \n            → data[rear] ← value // 放入數值  \n            → rear ← (rear + 1) mod capacity // 後移指標  \n            → size ← size + 1 // 元素數量加 1  \n            → return True // 插入成功  \n\n→ Method deleteFront() // 刪除前端元素  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → return False // 刪除失敗，回傳 False  \n        No  → // 可刪除  \n            → front ← (front + 1) mod capacity // 前移指標  \n            → size ← size - 1 // 元素數量減 1  \n            → return True // 刪除成功  \n\n→ Method deleteLast() // 刪除後端元素  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → return False // 刪除失敗，回傳 False  \n        No  → // 可刪除  \n            → rear ← (rear - 1 + capacity) mod capacity // 後移指標  \n            → size ← size - 1 // 元素數量減 1  \n            → return True // 刪除成功  \n\n→ Method getFront() // 取得前端元素  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → return -1 // 空，回傳 -1  \n        No  → return data[front] // 回傳前端值  \n\n→ Method getRear() // 取得後端元素  \n    → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → return -1 // 空，回傳 -1  \n        No  → \n            → index ← (rear - 1 + capacity) mod capacity // 計算最後一個元素索引  \n            → return data[index] // 回傳後端值  \n\n→ Method isEmpty() // 判斷是否為空  \n    → return size == 0 // 若 size 為 0，回傳 true  \n\n→ Method isFull() // 判斷是否已滿  \n    → return size == capacity // 若 size 等於容量，回傳 true  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        找到所有內容相同的檔案組\n        :param paths: List[str] - 每個字串包含目錄路徑與檔案(內容)\n        :return: List[List[str]] - 每個子清單為重複檔案的完整路徑\n        \"\"\"\n        content_map = defaultdict(list)   # content -> list of full paths\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]               # 目錄路徑\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]    # 去掉最後的 ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只取重複（長度>1）的組\n        return [files for files in content_map.values() if len(files) > 1]\n\ndef main():\n    # 讀取整個 stdin，並把字串轉成 Python 列表\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 找到列表的起始位置，避免 'paths = ' 的前置文字\n    start = raw_input.find('[')\n    if start == -1:\n        # 如果直接給列表字面值\n        paths_list = ast.literal_eval(raw_input)\n    else:\n        # 取從 '[' 到最後的子字串\n        list_str = raw_input[start:]\n        paths_list = ast.literal_eval(list_str)\n\n    solver = Solution()\n    duplicates = solver.findDuplicate(paths_list)\n    print(duplicates)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code lines step-by-step to solve the problem described. Should output each line as \"虛擬碼步驟 // 解釋\". Use arrows, decisions. Provide structure.\n\nWe need to parse input list of strings, map content to list of file paths, collect duplicates. Steps: Start, iterate over list, split by space, first part is path, rest are file descriptors, parse each: file name and content inside parentheses. Build full path, store in map content->list. After loop, iterate map to pick lists with size>1, collect into result list. End.\n\nAdd decision if content already exists? Might not need. Use map operations.\n\nWe will produce lines like:\n\nStart // 程式開始\n→ Step 1: 初始化空字典 contentMap // 用於存放內容到文件路徑的映射\n→ For each info in paths: // 逐個處理每個目錄資訊字串\n    → Split info by space into parts // 第一個為目錄路徑，其餘為文件描述\n    → Set dirPath = parts[0] // 取得目錄路徑\n    → For i from 1 to parts.length-1: // 處理每個文件\n        → Extract fileName 和 content from parts[i] // 解析文件名與內容\n        → fullPath = dirPath + \"/\" + fileName // 組合完整路徑\n        → If content not in contentMap: // 判斷是否已存在此內容\n            Yes → contentMap[content] = [] // 初始化列表\n        → Append fullPath to contentMap[content] // 添加文件路徑\n→ Step 2: 初始化空列表 result // 存放重複文件組\n→ For each entry (content, paths) in contentMap: // 遍歷內容映射\n    → If paths.size > 1: // 只取重複文件\n        Yes → Append paths to result // 加入結果\nEnd // 程式結束\n\nAdd explanation after each line.\n\nWe need to use \"Decision:\" lines maybe. We can incorporate Decision with Yes/No arrows.\n\nMake sure to use \"Start\", \"End\". Provide comments.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 contentMap // 用於將檔案內容映射到檔案完整路徑列表  \n→ For each directoryInfo in paths: // 逐一處理輸入的每一行資訊  \n    → Split directoryInfo by 空格 → parts // 第一項為目錄路徑，其餘為檔案描述  \n    → Set dirPath = parts[0] // 取得目錄路徑  \n    → For i = 1 to parts.length - 1: // 處理每個檔案描述  \n        → Extract fileName 和 content 從 parts[i] // 解析檔名與其內容  \n        → fullPath = dirPath + \"/\" + fileName // 組成完整檔案路徑  \n        → Decision: contentMap 是否已有此 content? // 判斷內容是否已在字典中  \n            Yes → Skip // 若已存在，直接進行下一步  \n            No  → contentMap[content] = [] // 若不存在，初始化新列表  \n        → Append fullPath 到 contentMap[content] // 將檔案路徑加入對應內容的列表  \n→ Step 2: 建立空列表 result // 用於存放所有重複檔案組  \n→ For each (content, fileList) in contentMap: // 遍歷內容與其檔案路徑列表  \n    → Decision: fileList 長度 > 1? // 只對重複檔案進行收集  \n        Yes → Append fileList 到 result // 將重複檔案路徑列表加入結果  \n        No  → Skip // 若只有一個檔案，忽略  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphjhy3r2w.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmphjhy3r2w.py\", line 38, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmphjhy3r2w.py\", line 16, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr82p9p75.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpr82p9p75.py\", line 38, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpr82p9p75.py\", line 16, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvdya017p.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpvdya017p.py\", line 38, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpvdya017p.py\", line 16, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\n\n# ------------------------------------------------------------\n# The API rand7() is assumed to be provided externally.  \n# It returns a uniform random integer in the range [1, 7].\n# ------------------------------------------------------------\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        Generate a uniform random integer in the range [1, 10]\n        using only the rand7() API.\n        \"\"\"\n        while True:\n            # 兩次呼叫 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            # 只接受 1~40 的數字，否則重試\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\n\ndef main() -> None:\n    \"\"\"\n    Read input, call rand10() n times, and print the results as a list.\n    Input format example: 'n = 1'\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中提取整數 n\n    try:\n        n = int(''.join(filter(str.isdigit, data)))\n    except ValueError:\n        n = 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for rand10() using rand7(). We need to write line by line with comments. We cannot use built-in random. Classic solution: use rejection sampling with two calls to get 1-49, then reject >40 to get 1-40 uniform then map to 1-10. Or use 1-49 and 1-35 etc.\n\nLet's produce steps:\n\nStart\n→ Generate two rand7() calls: a = rand7(), b = rand7()\n→ Compute value = (a-1)*7 + b // maps 1-49 uniformly\n→ Decision: if value > 40? // 40 leaves 1-40 uniform\n    Yes → go back to start (rejection)\n    No → Step: return ((value-1) mod 10) + 1 // map 1-40 to 1-10\n\nBut they want step by step pseudocode. We can include loops. Let's produce:\n\nStart\n→ Loop\n    → a ← rand7() // first random number 1-7\n    → b ← rand7() // second random number 1-7\n    → value ← (a - 1) * 7 + b // combine to get 1-49\n    → Decision: if value > 40? // reject 41-49\n        Yes → Loop continue\n        No  → Step: return ((value - 1) mod 10) + 1 // produce 1-10\nEnd\n\nBut we need to include step numbers? Not necessary. They ask each line must have virtual code and explanation. Let's produce each line accordingly.\n\nUse indentation to show decision branches. They use arrow for flow. We'll replicate pattern.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Loop // 重複直到成功生成 1-10  \n  → a ← rand7() // 取得第一個 1~7 的隨機數  \n  → b ← rand7() // 取得第二個 1~7 的隨機數  \n  → value ← (a - 1) * 7 + b // 組合成 1~49 的均勻分布  \n  → Decision: 如果 value > 40? // 檢查是否落在 41~49 的拒絕區域  \n    Yes → Loop // 若大於 40，重新開始循環（重試）  \n    No  → Step: return ((value - 1) mod 10) + 1 // 將 1~40 映射為 1~10，並返回結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjggxtz2o.py\", line 42, in <module>\n    points = parse_points(input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjggxtz2o.py\", line 36, in parse_points\n    raise ValueError(\"Input must contain exactly four points with two coordinates each.\")\nValueError: Input must contain exactly four points with two coordinates each."
        },
        {
          "example_index": 1,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp110y7y6v.py\", line 42, in <module>\n    points = parse_points(input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp110y7y6v.py\", line 36, in parse_points\n    raise ValueError(\"Input must contain exactly four points with two coordinates each.\")\nValueError: Input must contain exactly four points with two coordinates each."
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplqa59crh.py\", line 42, in <module>\n    points = parse_points(input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmplqa59crh.py\", line 36, in parse_points\n    raise ValueError(\"Input must contain exactly four points with two coordinates each.\")\nValueError: Input must contain exactly four points with two coordinates each."
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validSquare(self, p1, p2, p3, p4):\n        # Helper to compute squared Euclidean distance\n        def dist_sq(a, b):\n            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n        points = [p1, p2, p3, p4]\n        dists = []\n\n        # Compute all 6 pairwise squared distances\n        for i in range(4):\n            for j in range(i + 1, 4):\n                dists.append(dist_sq(points[i], points[j]))\n\n        dists.sort()\n\n        # For a valid square:\n        # 1. The smallest distance (side) must be positive.\n        # 2. The first four distances must be equal (four equal sides).\n        # 3. The last two distances must be equal (two equal diagonals).\n        # 4. The diagonal must be larger than the side.\n        return (\n            dists[0] > 0 and\n            dists[0] == dists[1] == dists[2] == dists[3] and\n            dists[4] == dists[5] and\n            dists[4] > dists[0]\n        )\n\ndef parse_points(data: str):\n    # Find all integers in the input string\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) != 8:\n        raise ValueError(\"Input must contain exactly four points with two coordinates each.\")\n    # Group into four points\n    return [nums[i:i+2] for i in range(0, 8, 2)]\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    points = parse_points(input_data)\n    sol = Solution()\n    result = sol.validSquare(*points)\n    print(str(result).lower())",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: determine if 4 points form a square. Output virtual code lines with explanations. Use Start, End, Decision, arrow, etc. Need to include distance calculations, checking pairwise distances: 4 equal sides, 2 equal diagonals. Approach: compute all 6 squared distances between points. Count occurrences: 4 equal small distances (sides) and 2 equal larger distances (diagonals). Also ensure side > 0. Additionally ensure diagonals > side. That ensures a square. Steps: input list of 4 points. Compute all pairwise squared distances. Sort or use map. Count frequencies. Decision: if two distinct distances exist, count of smaller distance == 4, count of larger == 2, and larger > smaller > 0. Return true else false. Implementation in virtual code. Provide each line with explanation. Use arrow and indentation.\n\nLet's produce:\n\nStart\n→ Step 1: 接收四點座標列表 // 獲取輸入\n→ Step 2: 初始化空列表 distances // 用於存放六條距離\n→ Step 3: 對於 i from 0 到 3\n    → Step 4: 對於 j from i+1 到 3\n        → Step 5: 計算 squared_distance = (x_i - x_j)^2 + (y_i - y_j)^2 // 兩點間距離的平方\n        → Step 6: distances.append(squared_distance) // 存入列表\n→ Step 7: 建立字典 freq = count of each distance in distances // 统计出现次数\n→ Decision: 如果 freq 中有 2 個不同的距離? // 检查是否只有两种长度\n    Yes → Decision: 小距離出現次數為 4? // 确保四条相等边\n        Yes → Decision: 大距離出現次數為 2? // 确保两条相等对角线\n            Yes → Decision: 大距離 > 小距離 且 小距離 > 0? // 确保正长且对角线更长\n                Yes → Step 8: Return True // 四点构成正方形\n                No  → Step 9: Return False // 对角线不满足条件\n            No  → Step 10: Return False // 对角线次数不对\n        No  → Step 11: Return False // 边次数不对\n    No  → Step 12: Return False // 距离种类不只两种\nEnd // 结束流程\n\nAdd comments. Ensure each line includes virtual code and comment. Use arrow for decisions, indent lines. We'll produce accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 接收四點座標列表 // 從使用者取得 4 個點的座標\n→ Step 2: 初始化空列表 distances // 用於存放六條兩兩點之間的平方距離\n→ Step 3: 對於 i 從 0 到 3\n    → Step 4: 對於 j 從 i+1 到 3\n        → Step 5: 計算 squared_distance = (x_i - x_j)^2 + (y_i - y_j)^2 // 計算兩點之間距離的平方\n        → Step 6: distances.append(squared_distance) // 將平方距離加入列表\n→ Step 7: 建立字典 freq = count of each distance in distances // 統計每個距離出現的次數\n→ Decision: 如果 freq 中有 2 個不同的距離? // 檢查是否只有兩種長度（邊和對角線）\n    Yes → Decision: 小距離出現次數為 4? // 確保四條相等的邊\n        Yes → Decision: 大距離出現次數為 2? // 確保兩條相等的對角線\n            Yes → Decision: 大距離 > 小距離 且 小距離 > 0? // 確保正長且對角線更長\n                Yes → Step 8: Return True // 四點構成正方形\n                No  → Step 9: Return False // 對角線長度不符合條件\n            No  → Step 10: Return False // 對角線出現次數不對\n        No  → Step 11: Return False // 边出現次數不對\n    No  → Step 12: Return False // 距離種類不只兩種\nEnd // 程式執行結束\n```"
    },
    {
      "title": "ZigZag Conversion",
      "source_file": "Leetcode/leetcode6.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprym2lkec.py\", line 23, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    s = 'PAYPALISHIRING', numRows = 3\n    ^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"將字串轉成 zigzag 並按行讀取\"\"\"\n        if numRows == 1 or numRows >= len(s):\n            return s\n        res = [''] * numRows\n        index, step = 0, 1\n        for c in s:\n            res[index] += c\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n        return ''.join(res)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容，並執行 python 變量賦值\n    data = sys.stdin.read().strip()\n    # 允許像 \"s = 'PAYPALISHIRING', numRows = 3\" 這樣的輸入\n    exec(data, globals())\n    # 假設執行後已經定義了 s 和 numRows\n    solution = Solution()\n    result = solution.convert(s, numRows)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, for converting a string to zigzag pattern and reading line by line. Likely we need to transform string into zigzag given numRows, then read row by row. The output example: \"PAYPALISHIRING\" with 3 rows -> \"PAHNAPLSIIGYIR\". Virtual code: Start → input string and numRows → decision if numRows <=1 → return string. Else initialize array of strings length numRows. Set currentRow=0, direction=-1. Iterate over characters: add char to currentRow string. If at first or last row, reverse direction. Update currentRow += direction. After loop, concatenate all rows. Return result. End. Provide virtual code with arrow and explanation. Use required format: each line \"虛擬碼步驟 // 解釋\". Use indentation for decisions.\n\nLet's craft. Use Start and End. Provide step numbers. Ensure each line includes explanation. Use arrow ->. Use indentation for decisions. Use \"Decision:\" with Yes→ etc.\n\nWe need to output just virtual code lines, no actual code. Ok. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: 取得字串 str 與行數 numRows // 從使用者處取得資料  \n→ Decision: 若 numRows <= 1? // 無需轉換，直接返回  \n    Yes → Output: 直接回傳 str // 字串不變  \n    No  → Initialize: 建立 length 為 numRows 的空字串陣列 rows // 用於儲存每一行  \n→ Step: 變數 currentRow ← 0 // 現在所在的行  \n→ Step: 變數 direction ← -1 // 初始方向，-1 表示向下  \n→ For each character ch in str // 逐字處理  \n    → Append: 把 ch 加到 rows[currentRow] // 將字元放入對應行  \n    → Decision: 若 currentRow == 0 或 currentRow == numRows-1? // 到達頂或底行時需改變方向  \n        Yes → direction ← -direction // 反轉方向  \n        No  → （不做任何事）  \n    → Step: currentRow ← currentRow + direction // 移動到下一行  \n→ Step: 結果 ← 空字串 // 用於拼接所有行  \n→ For each row in rows // 逐行讀取  \n    → Append: 把 row 加到 結果 // 將行內容連接起來  \n→ Output: 回傳 結果 // 完成 zigzag 轉換  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar II",
      "source_file": "Leetcode/leetcode731.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,true,true]'\nGot (Norm):      '[None,True,True,True,False,True,True]'\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, true, true]'\nRaw Got:      '[None, True, True, True, False, True, True]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyCalendarTwo:\n    \"\"\"實作可避免三重預約的日曆。\"\"\"\n\n    def __init__(self):\n        # 只儲存單重預約的區間\n        self.booked = []          # List[Tuple[int, int]]\n        # 儲存已經被兩個預約重疊的區間\n        self.overlaps = []        # List[Tuple[int, int]]\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"嘗試將區間 [start, end) 加入日曆。\n        若加入後會產生三重重疊，返回 False 並不加入；否則加入並返回 True。\"\"\"\n        # 先檢查是否會造成三重重疊\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n\n        # 取出與已存在單重預約的重疊區間，加入 overlaps\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n\n        # 最後把這個區間本身加入 booked\n        self.booked.append((start, end))\n        return True\n\ndef parse_input(data: str):\n    \"\"\"將 stdin 的內容轉成 commands 與 arguments。\"\"\"\n    data = data.strip()\n    if '\\n' in data:\n        # 兩行分開\n        lines = data.splitlines()\n        cmd_line = lines[0]\n        arg_line = lines[1]\n    else:\n        # 單行，形如 '[\"MyCalendarTwo\", \"book\"], [[], [10, 20]]'\n        # 找到第一個 '],' 分開兩個列表\n        idx = data.find('],')\n        if idx == -1:\n            raise ValueError(\"Invalid input format\")\n        cmd_line = data[:idx + 1]\n        arg_line = data[idx + 2:]\n    commands = ast.literal_eval(cmd_line)\n    arguments = ast.literal_eval(arg_line)\n    return commands, arguments\n\ndef main():\n    raw_input = sys.stdin.read()\n    commands, arguments = parse_input(raw_input)\n\n    results = []\n    obj = None\n    for i, cmd in enumerate(commands):\n        if cmd == \"MyCalendarTwo\":\n            obj = MyCalendarTwo()\n            results.append(None)\n        else:\n            # book 的參數為 [start, end]\n            args = arguments[i]\n            if not isinstance(args, (list, tuple)):\n                args = [args]\n            method = getattr(obj, cmd)\n            res = method(*args)\n            results.append(res)\n    # 輸出結果\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the problem of designing MyCalendarTwo with no triple booking. Need to produce step-by-step pseudocode using the format. So we need to create structure: Start, steps, decisions. We'll show algorithm: keep list of intervals (bookings), and double overlaps. The approach: store single intervals and double intervals. On booking, check against double intervals; if overlap with any double interval, return false. Then compute overlaps between new interval and existing single intervals, add those overlaps to double intervals list. Finally add the new interval to single intervals list. Return true.\n\nWe'll write pseudocode lines with arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 MyCalendarTwo 類別 // 初始化資料結構\n    → Step 1.1: 宣告 singleEvents 為空清單 // 儲存所有已成功加入的單重區間\n    → Step 1.2: 宣告 doubleEvents 為空清單 // 儲存所有重疊兩次的區間\n→ End // MyCalendarTwo 準備完成\n\nStart // book 方法開始執行\n→ Step 2: 接收輸入 startTime, endTime // 取得欲加入的事件區間\n→ Decision: 是否有任何 doubleEvents 與 [startTime, endTime) 重疊? // 檢查是否會產生三重重疊\n    Yes → Step 3: 回傳 false // 不能加入，三重重疊發生\n    No  → Step 4: 建立 newOverlaps 為空清單 // 儲存與單重區間重疊的區間\n→ Step 5: 對每個 singleEvents 中的 interval (s, e) 進行\n    → Decision: 是否與 [startTime, endTime) 重疊? // 判斷兩區間是否有交集\n        Yes → Step 6: 計算 overlapStart = max(startTime, s) // 交集起始\n              → Step 7: 計算 overlapEnd   = min(endTime, e) // 交集結束\n              → Step 8: 將 [overlapStart, overlapEnd) 加入 newOverlaps // 收集重疊區間\n        No  → Step 9: 繼續檢查下一個 singleEvents // 無重疊則略過\n→ Step 10: 將 newOverlaps 所有區間加入 doubleEvents // 更新雙重重疊記錄\n→ Step 11: 將 [startTime, endTime) 加入 singleEvents // 成功加入單重區間\n→ Step 12: 回傳 true // 事件已成功加入\nEnd // book 方法執行結束"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3khwstjk.py\", line 61, in <module>\n    s1, n1, s2, n2 = parse_input(data)\n                     ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3khwstjk.py\", line 56, in parse_input\n    raise ValueError(\"Input format not recognized.\")\nValueError: Input format not recognized."
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpywxotnwc.py\", line 61, in <module>\n    s1, n1, s2, n2 = parse_input(data)\n                     ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpywxotnwc.py\", line 56, in parse_input\n    raise ValueError(\"Input format not recognized.\")\nValueError: Input format not recognized."
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0 or not s1 or not s2:\n            return 0\n\n        len1, len2 = len(s1), len(s2)\n\n        # Precompute for each start position in s1:\n        #   count[i]  - number of s2 completed after one full s1 cycle\n        #   next[i]   - next position in s2 after that cycle\n        count = [0] * len1\n        next_pos = [0] * len1\n        for i in range(len1):\n            cur = 0          # current position in s2\n            cnt = 0          # completed s2 count\n            # iterate through one full s1 cycle starting at i\n            for k in range(len1):\n                ch = s1[(i + k) % len1]\n                if ch == s2[cur]:\n                    cur += 1\n                    if cur == len2:\n                        cnt += 1\n                        cur = 0\n            count[i] = cnt\n            next_pos[i] = cur\n\n        # Simulate n1 repetitions of s1 using the precomputed table\n        total_cnt = 0\n        cur_pos = 0\n        for _ in range(n1):\n            total_cnt += count[cur_pos]\n            cur_pos = next_pos[cur_pos]\n\n        # How many times s2 can be formed in total\n        return total_cnt // n2\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse input of the form:\n        s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n    Returns (s1, n1, s2, n2).\n    \"\"\"\n    # Find all quoted strings and integers\n    tokens = re.findall(r'[\"\\']([^\"\\']+)[\"\\']|(\\d+)', text)\n    # tokens is a list of tuples; first element of tuple is string if matched, else second element is number\n    values = []\n    for string_part, number_part in tokens:\n        if string_part:\n            values.append(string_part)\n        else:\n            values.append(int(number_part))\n    if len(values) != 4:\n        raise ValueError(\"Input format not recognized.\")\n    return values[0], values[1], values[2], values[3]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, n1, s2, n2 = parse_input(data)\n    sol = Solution()\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the problem. The problem: find max m such that str2 repeated m times can be obtained as subsequence from str1 repeated n1 times. Equivalent to known LeetCode problem 4665: Maximum number of times that string t can be formed from string s. Actually \"Maximum number of times that string t can be formed from string s\" (max repeat). But here s1 and s2 are base strings. So we need to compute how many times s2 can be formed from s1 repeated n1 times.\n\nPseudo-code algorithm: Precompute for each position in s1, how many s2's can be completed when we start at that position. Use mapping of index in s1 to (count, next index). Then iterate n1 times, accumulate count, find how many full s2 we can get, then compute m = count / n2? Wait careful: We want max m such that [str2, m] can be obtained from str1. str2 = [s2, n2]. So we need number of times s2 can be formed from str1, call it totalS2Count. Then m = floor(totalS2Count / n2). That's the answer.\n\nWe need to output pseudocode lines with arrow. We'll include Start, Decision, End.\n\nWe'll produce algorithm steps: Input s1, n1, s2, n2. Initialize variables. Precompute mapping: For i in 0..len(s1)-1: count=0, index=0; For each repetition of s1: simulate scanning s1, when char matches s2[index], increment index, if index==len(s2) then count++, index=0. Record mapping[i] = (count, index). Actually we need to compute for each start index in s1, after scanning one s1, how many s2 formed and what index into s2 at the end.\n\nSimpler: for startIdx from 0 to len(s1)-1: set curIndex=0, curCount=0; loop over j from 0 to len(s1)-1: char = s1[(startIdx + j) % len(s1)]? Wait we only simulate one full traversal of s1 starting at startIdx. But we can simulate by iterating s1 starting from startIdx to end, then from 0 to startIdx-1.\n\nBut typical solution: For i in 0..len(s1)-1: initialize cnt=0, j=0; for k in 0..len(s1)-1: if s1[k]==s2[j] then j++; if j==len(s2): cnt++; j=0. But this is independent of start. Actually we need for each i: we consider that we start from i in s1 as the current position in s1's cycle, and we want to know after consuming one whole s1 cycle (len(s1) characters), how many s2 substrings are formed and what is the position in s2 where we ended.\n\nWe can precompute an array next[i] that gives next position in s2 after processing s1 starting at i, and count[i] number of s2 formed. Implementation: For each i in 0..len(s1)-1: curPosS2=0, curCnt=0; for k in 0..len(s1)-1: c = s1[(i + k) % len(s1)]; if c == s2[curPosS2] then curPosS2++; if curPosS2==len(s2) then curCnt++; curPosS2=0; end; store count[i]=curCnt, nextPos[i]=curPosS2.\n\nBut for pseudo-code we don't need actual code; we can describe loops.\n\nThen main loop: curPos=0; totalCnt=0; for i from 0 to n1-1: totalCnt += count[curPos]; curPos = nextPos[curPos];\n\nAfter loop, answer = totalCnt / n2 (integer division).\n\nWe'll produce pseudocode with Start, Decision, End. Use arrows.\n\nLet's produce line by line:\n\nStart // 程式開始\n\n→ Step 1: 輸入 s1, n1, s2, n2 // 取得輸入\n\n→ Step 2: 定義 len1 = s1 的長度, len2 = s2 的長度 // 取得字串長度\n\n→ Step 3: 建立陣列 count[0..len1-1] 與 next[0..len1-1] // 用來儲存一次掃描 s1 後完成的 s2 數量與剩餘位置\n\n→ Decision: 如果 len1 為 0? // 防止除零\n\n    Yes → Step 4: 回傳 0 // 無法形成任何 s2\n\n    No →  // 繼續\n\n→ Step 5: 對於每個起始位置 i 從 0 到 len1-1 進行預計算\n\n    → Step 5.1: 設 curS2Pos = 0, curCnt = 0 // 重新初始化\n\n    → Step 5.2: 對於 j 從 0 到 len1-1 進行一次完整的 s1 迭代\n\n        → Decision: 若 s1[(i + j) mod len1] == s2[curS2Pos]? // 比較字元\n\n            Yes → Step 5.2.a: curS2Pos++ // 位置進位\n\n            No  → Step 5.2.b: // 不變\n\n        → Decision: 若 curS2Pos == len2? // 完成一個 s2\n\n            Yes → Step 5.2.c: curCnt++ // 计数加一\n\n                   Step 5.2.d: curS2Pos = 0 // 重置到 s2 起始\n\n            No  → Step 5.2.e: // 不變\n\n    → Step 5.3: 設 count[i] = curCnt, next[i] = curS2Pos // 存储结果\n\n→ Step 6: 初始化 curPos = 0, totalCnt = 0 // 当前 s2 位置与总计数\n\n→ Step 7: 對於 k 從 0 到 n1-1 執行\n\n    → Step 7.1: totalCnt += count[curPos] // 加上這次掃描完成的 s2 數量\n\n    → Step 7.2: curPos = next[curPos] // 更新到下一個起始位置\n\n→ Step 8: 計算答案 m = totalCnt / n2 // 整數除法得到最大可重複數\n\n→ Step 9: 回傳 m // 結果\n\nEnd // 程式結束\n\nWe need to format each line: \"虛擬碼步驟 // 解釋\". Use arrow characters. For Decision lines: we need indent lines. In example, they used indentation for nested steps: \"Decision:\" line then \"Yes →\", \"No →\". We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 輸入 s1, n1, s2, n2 // 取得輸入參數  \n→ Step 2: 定義 len1 = s1 的長度, len2 = s2 的長度 // 取得字串長度  \n→ Step 3: 建立陣列 count[0..len1-1] 與 next[0..len1-1] // 用來儲存一次掃描 s1 後完成的 s2 數量與剩餘位置  \n\n→ Decision: 若 len1 為 0? // 防止除零  \n  Yes → Step 4: 回傳 0 // 無法形成任何 s2，直接結束  \n  No → // 繼續執行  \n\n→ Step 5: 對於每個起始位置 i 從 0 到 len1-1 進行預計算  \n  → Step 5.1: 設 curS2Pos = 0, curCnt = 0 // 重新初始化  \n  → Step 5.2: 對於 j 從 0 到 len1-1 進行一次完整的 s1 迭代  \n    → Decision: 若 s1[(i + j) mod len1] == s2[curS2Pos]? // 比較字元  \n      Yes → Step 5.2.a: curS2Pos++ // 位置進位  \n      No  → Step 5.2.b: // 不變  \n    → Decision: 若 curS2Pos == len2? // 完成一個 s2  \n      Yes → Step 5.2.c: curCnt++ // 计数加一  \n        Step 5.2.d: curS2Pos = 0 // 重置到 s2 起始  \n      No  → Step 5.2.e: // 不變  \n  → Step 5.3: 設 count[i] = curCnt, next[i] = curS2Pos // 存储结果  \n\n→ Step 6: 初始化 curPos = 0, totalCnt = 0 // 当前 s2 位置与总计数  \n\n→ Step 7: 對於 k 從 0 到 n1-1 執行  \n  → Step 7.1: totalCnt += count[curPos] // 加上這次掃描完成的 s2 數量  \n  → Step 7.2: curPos = next[curPos] // 更新到下一個起始位置  \n\n→ Step 8: 計算答案 m = totalCnt / n2 // 整數除法得到最大可重複數  \n\n→ Step 9: 回傳 m // 結果  \n\nEnd // 程式結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4o1sv4xz.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmp4o1sv4xz.py\", line 51, in main\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4o1sv4xz.py\", line 44, in parse_input\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp07vnmoh0.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmp07vnmoh0.py\", line 51, in main\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp07vnmoh0.py\", line 44, in parse_input\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpximanfsk.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpximanfsk.py\", line 51, in main\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpximanfsk.py\", line 44, in parse_input\n    equations = ast.literal_eval(eq_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        result = []\n        for u, v in queries:\n            result.append(dfs(u, v, set()))\n        return result\n\ndef parse_input(text: str):\n    # Extract lists assigned to equations, values, and queries\n    eq_pat = re.compile(r'equations\\s*=\\s*(\\[.*?\\])', re.S)\n    val_pat = re.compile(r'values\\s*=\\s*(\\[.*?\\])', re.S)\n    qry_pat = re.compile(r'queries\\s*=\\s*(\\[.*?\\])', re.S)\n\n    eq_match = eq_pat.search(text)\n    val_match = val_pat.search(text)\n    qry_match = qry_pat.search(text)\n\n    if not (eq_match and val_match and qry_match):\n        raise ValueError(\"Input format is incorrect.\")\n\n    equations = ast.literal_eval(eq_match.group(1))\n    values    = ast.literal_eval(val_match.group(1))\n    queries   = ast.literal_eval(qry_match.group(1))\n    return equations, values, queries\n\ndef main():\n    data = sys.stdin.read()\n    equations, values, queries = parse_input(data)\n\n    solution = Solution()\n    ans = solution.calcEquation(equations, values, queries)\n\n    # Format output with 5 decimal places\n    out = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving equations / queries. It's classic problem: evaluate division with union-find or graph traversal.\n\nWe'll produce pseudocode: Build graph adjacency mapping variable to neighbors with weight ratios. For each query, BFS/DFS to find path product. If no path, return -1.0.\n\nSteps: Start, Build graph, For each query, compute answer via DFS, else -1.0. End.\n\nWe'll produce lines with arrows. Use Decision, etc.\n\nLet's craft virtual code. Use Step 1: Build adjacency list. Step 2: For each query: If either variable not in graph, answer -1.0. Else DFS. We'll include DFS function. Provide explanation each line.\n\nMake sure to follow format: each line: virtual code step + space + // explanation.\n\nUse arrows: → Step. Use Decision: etc.\n\nLet's produce.\n\nWe might need to define DFS recursively: function DFS(current, target, visited, acc). We'll produce Step for function. For each query, call DFS.\n\nWe'll structure:\n\nStart\n→ Step 1: 初始化圖 adjacency // 建立鄰接表\n→ Step 2: 對每個方程式 equations[i]\n    → Step 2.1: Ai = equations[i][0], Bi = equations[i][1], val = values[i]\n    → Step 2.2: adjacency[Ai].append((Bi, val))\n    → Step 2.3: adjacency[Bi].append((Ai, 1/val))\n→ Step 3: 定義函式 DFS(src, dst, visited, acc)\n    → Decision: 如果 src == dst?\n        Yes → Step 3.1: 回傳 acc // 已找到路徑\n        No  → Step 3.2: visited.add(src)\n               → Step 3.3: 對每個 (nei, w) in adjacency[src]\n                            → Decision: 如果 nei not in visited?\n                                Yes → Step 3.4: res = DFS(nei, dst, visited, acc * w)\n                                            → Decision: 如果 res != -1?\n                                                Yes → Step 3.5: 回傳 res\n                                                No  → Step 3.6: 繼續下一個鄰居\n                                No  → Step 3.7: 繼續下一個鄰居\n               → Step 3.8: 回傳 -1 // 無法到達\n→ Step 4: 建立答案陣列 result\n→ Step 5: 對每個查詢 queries[j]\n    → Step 5.1: C = queries[j][0], D = queries[j][1]\n    → Decision: 如果 C not in adjacency 或 D not in adjacency?\n        Yes → Step 5.2: result.append(-1.0) // 變量未定義\n        No  → Step 5.3: ans = DFS(C, D, set(), 1.0)\n                → Step 5.4: result.append(ans)\n→ End // 輸出答案\n\nEnsure each line has code and comment.\n\nMake sure to include arrow and indentation? They want arrow symbol at start of each line maybe. Use '→' before each step line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化圖 adjacency // 建立鄰接表  \n→ Step 2: 對每個方程式 equations[i]  \n → Step 2.1: Ai ← equations[i][0], Bi ← equations[i][1], val ← values[i] // 取得變量與比值  \n → Step 2.2: adjacency[Ai].append((Bi, val)) // Ai → Bi 的比值  \n → Step 2.3: adjacency[Bi].append((Ai, 1/val)) // Bi → Ai 的逆比值  \n→ Step 3: 定義函式 DFS(src, dst, visited, acc) // 以 DFS 取得兩變量之比  \n → Decision: 如果 src == dst?  \n  Yes → Step 3.1: 回傳 acc // 已找到路徑  \n  No → Step 3.2: visited.add(src) // 標記已訪問  \n   → Step 3.3: 對每個 (nei, w) in adjacency[src]  \n    → Decision: 如果 nei not in visited?  \n     Yes → Step 3.4: res ← DFS(nei, dst, visited, acc * w) // 遞迴計算  \n      Decision: 如果 res != -1?  \n       Yes → Step 3.5: 回傳 res // 成功找到  \n       No → Step 3.6: 繼續下一個鄰居  \n     No → Step 3.7: 繼續下一個鄰居  \n    → Step 3.8: 回傳 -1 // 無法到達  \n→ Step 4: 建立答案陣列 result // 用於儲存所有查詢結果  \n→ Step 5: 對每個查詢 queries[j]  \n → Step 5.1: C ← queries[j][0], D ← queries[j][1] // 取得查詢變量  \n → Decision: 如果 C not in adjacency 或 D not in adjacency?  \n  Yes → Step 5.2: result.append(-1.0) // 變量未定義，無法計算  \n  No → Step 5.3: ans ← DFS(C, D, set(), 1.0) // 以 DFS 取得比值  \n   → Step 5.4: result.append(ans) // 加入結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[\"dogcatsdog\", \"catsdogcats\", \"ratcatdogcat\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\ndef can_segment(word, word_set):\n    \"\"\"Return True if `word` can be formed by at least two words from `word_set`.\"\"\"\n    n = len(word)\n    dp = [False] * (n + 1)          # dp[i] == True if word[:i] can be segmented\n    cnt = [0] * (n + 1)             # cnt[i] == max number of words used to segment word[:i]\n    dp[0] = True\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_set:\n                dp[i] = True\n                cnt[i] = max(cnt[i], cnt[j] + 1)\n    return dp[n] and cnt[n] >= 2\n\ndef find_concatenated_words(words):\n    \"\"\"Find all concatenated words in the list `words`.\"\"\"\n    words.sort(key=len)               # process shorter words first\n    word_set = set()\n    result = []\n    for w in words:\n        if not w:                     # skip empty strings\n            continue\n        if can_segment(w, word_set):\n            result.append(w)\n        word_set.add(w)               # add current word for later words\n    return result\n\ndef main():\n    # Read entire input\n    raw = sys.stdin.read().strip()\n    if not raw:\n        print(\"[]\")\n        return\n\n    # Extract the list expression\n    if raw.lower().startswith(\"words\"):\n        # Assume format: words = [ ... ]\n        raw = raw.split(\"=\", 1)[1].strip()\n    try:\n        words = ast.literal_eval(raw)\n    except Exception:\n        # Fallback: treat raw as a comma-separated list inside brackets\n        words = ast.literal_eval(f'[{raw}]')\n\n    if not isinstance(words, list):\n        words = []\n\n    concatenated = find_concatenated_words(words)\n    # Output with double quotes as in the examples\n    print(json.dumps(concatenated))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. We need to produce a step-by-step pseudo code for algorithm to find concatenated words. We should include Start, End, Decision, etc. Use virtual code lines. We must not output actual code. Just lines of virtual code with comments.\n\nAlgorithm: Use Trie or hash set. For each word sorted by length ascending. For each word, check if it can be segmented into at least two words from set. Use DP: can[i] true if prefix can be segmented. If can[len] true and at least two words, then it's concatenated. Add to result. Add word to set after checking. Use dictionary. Complexity.\n\nWe need to produce virtual code: Start, steps: Build set, sort array by length, iterate, for each word do DP, store result. Use Decision and loops.\n\nWe'll write virtual code line by line:\n\nStart\n→ Step 1: Initialize Set wordSet ← empty set // 用來存放已處理的單字\n→ Step 2: Sort words by length ascending // 先處理短字，方便斷詞\n→ Step 3: Initialize Result list ← empty list // 存放所有連字詞\n\n→ Decision: For each word in sorted words? // 逐一檢查每個單字\n    → Step 4: If word is empty? // 空字跳過\n        → Decision: Yes → Continue to next word // 跳過空字\n        → Decision: No\n\n    → Step 5: If canSegment(word, wordSet) AND wordSet is not empty? // 判斷是否能斷成至少兩個詞\n        → Decision: Yes → Step 6: Add word to Result // 加入結果\n        → Decision: No\n\n    → Step 7: Add word to wordSet // 無論是否連字詞，都加入集合\n\n→ Step 8: Return Result // 完成\n\nWe need to define canSegment function:\n\n→ Step 9: Define canSegment(word, wordSet): // 判斷單字是否可由集合單字斷開\n    → Step 10: Initialize DP array can[0..len] ← false\n    → Step 11: can[0] ← true // 空前綴可斷\n    → Decision: For i from 1 to len? // 遍歷每個位置\n        → Step 12: For j from 0 to i-1? // 遍歷前綴\n            → Decision: If can[j] AND substring(word, j, i) in wordSet? // 前綴已可斷且中間字在集合\n                → Decision: Yes → Step 13: can[i] ← true // 記錄此位置可斷\n                → Decision: No\n    → Step 14: Return can[len] AND countWords(word, wordSet) >= 2 // 需至少兩個單字\n\nBut counting words is not trivial; easier: while building DP, track count of words used. Use DP of pair or use additional array count[i] storing number of words used to reach i. We'll keep simpler: While DP, if we found can[i] true, record count[i] = max(count[j] + 1). At the end check count[len] >= 2.\n\nLet's incorporate:\n\n→ Step 15: Initialize Count array count[0..len] ← 0 // 记录用多少个词到达i\n→ Step 16: count[0] ← 0\n\nThen inside loop when can[j] and substring in set:\n    → Step 17: If count[j] + 1 > count[i] → count[i] ← count[j] + 1\n\nAfter loops, return can[len] AND count[len] >= 2\n\nSimplify: In canSegment function we output bool.\n\nLet's produce virtual code lines accordingly. We need to use arrow arrow. Let's write.\n\nMake sure each line ends with // 解釋.\n\nAlso need to include End line. Also need to close functions maybe.\n\nLet's produce.\n\nNote: The virtual code can be hierarchical but we need to maintain arrow indent.\n\nWill produce lines:\n\nStart // 程式開始\n→ Step 1: Initialize wordSet ← empty set // 用來儲存已確認的單字\n→ Step 2: Sort words by length ascending // 先處理短字，便於斷詞\n→ Step 3: Initialize result ← empty list // 存放所有連字詞\n→ Decision: For each word in words? // 逐一檢查\n    → Step 4: If word is empty? // 空字跳過\n        → Decision: Yes → Continue // 進入下一個單字\n        → Decision: No\n    → Step 5: If canSegment(word, wordSet)? // 判斷是否可斷為至少兩個字\n        → Decision: Yes → Step 6: Add word to result // 加入連字詞列表\n        → Decision: No\n    → Step 7: Add word to wordSet // 無論結果，將此單字加入集合\n→ Step 8: Return result // 結束並返回所有連字詞\nEnd // 程式結束\n\nDefine canSegment:\n\n→ Function canSegment(word, wordSet): // 判斷單字是否能由集合斷開\n    → Step 9: len ← length of word // 字長\n    → Step 10: Initialize can[0..len] ← false // DP 標誌\n    → Step 11: Initialize count[0..len] ← 0 // 斷詞數量\n    → Step 12: can[0] ← true // 空前綴可斷\n    → Decision: For i from 1 to len? // 檢查每個位置\n        → Step 13: For j from 0 to i-1? // 檢查前綴\n            → Decision: If can[j] AND substring(word, j, i) in wordSet? // 前綴可斷且中間字在集合\n                → Decision: Yes → Step 14: can[i] ← true // 記錄位置可斷\n                → Decision: Yes → Step 15: count[i] ← max(count[i], count[j] + 1) // 更新斷詞數量\n                → Decision: No\n    → Step 16: Return can[len] AND count[len] >= 2 // 至少兩個字才能算連字詞\nEnd // 函式結束\n\nBut we need to show end of function maybe End Function.\n\nLet's produce more tidy:\n\n→ End // canSegment 函式結束\n\nHowever our arrow lines may be nested. We might need to use indentation like \"    →\" for nested steps. We'll produce accordingly.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: Initialize wordSet ← empty set // 用來儲存已確認的單字  \n→ Step 2: Sort words by length ascending // 先處理短字，便於斷詞  \n→ Step 3: Initialize result ← empty list // 存放所有連字詞  \n→ Decision: For each word in words? // 逐一檢查  \n  → Step 4: If word is empty? // 空字跳過  \n    Yes → Continue // 進入下一個單字  \n    No  \n  → Step 5: If canSegment(word, wordSet)? // 判斷是否可斷為至少兩個字  \n    Yes → Step 6: Add word to result // 加入連字詞列表  \n    No  \n  → Step 7: Add word to wordSet // 無論結果，將此單字加入集合  \n→ Step 8: Return result // 結束並返回所有連字詞  \nEnd // 程式結束  \n\nFunction canSegment(word, wordSet): // 判斷單字是否能由集合斷開  \n  → Step 9: len ← length of word // 字長  \n  → Step 10: Initialize can[0..len] ← false // DP 標誌  \n  → Step 11: Initialize count[0..len] ← 0 // 斷詞數量  \n  → Step 12: can[0] ← true // 空前綴可斷  \n  → Decision: For i from 1 to len? // 檢查每個位置  \n    → Step 13: For j from 0 to i-1? // 檢查前綴  \n      → Decision: If can[j] AND substring(word, j, i) in wordSet? // 前綴可斷且中間字在集合  \n        Yes → Step 14: can[i] ← true // 記錄位置可斷  \n        Yes → Step 15: count[i] ← max(count[i], count[j] + 1) // 更新斷詞數量  \n        No  \n  → Step 16: Return can[len] AND count[len] ≥ 2 // 至少兩個字才能算連字詞  \nEnd // canSegment 函式結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8srxh937.py\", line 43, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8srxh937.py\", line 35, in parse_input\n    prerequisites = eval(prereq_str)  # 假設輸入合法且安全\n                    ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9vtd1usp.py\", line 43, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9vtd1usp.py\", line 35, in parse_input\n    prerequisites = eval(prereq_str)  # 假設輸入合法且安全\n                    ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立圖與入度計數\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 先入度為 0 的節點加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 的拓樸排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若能安排所有課程則回傳順序，否則回傳空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input(s: str):\n    \"\"\"將 'numCourses = 2, prerequisites = [[1,0]]' 解析為 (2, [[1,0]])\"\"\"\n    parts = s.split(',')\n    num_courses = int(parts[0].split('=')[1].strip())\n    prereq_str = parts[1].split('=')[1].strip()\n    prerequisites = eval(prereq_str)  # 假設輸入合法且安全\n    return num_courses, prerequisites\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n    else:\n        numCourses, prerequisites = parse_input(raw_input)\n        sol = Solution()\n        result = sol.findOrder(numCourses, prerequisites)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the course schedule problem. Likely Kahn's algorithm topological sort or DFS. Provide steps. Output line by line: Start, then steps, Decision etc. Must include explanation comment after space.\n\nLet's craft steps:\n\nStart\n→ Step 1: 建立圖 adjacency list from prerequisites // 轉換關係為圖\n→ Step 2: 計算每門課的入度 indegree // 需要先修課程數量\n→ Step 3: 將所有入度為 0 的課程放入佇列 queue // 可直接開始\n→ Step 4: 初始化空的順序 list order // 存放結果\n→ Decision: queue 是否為空? // 檢查是否還有可學的課\n    Yes → Step 5: 從 queue 取出一門課 cur // 取出\n        → Step 6: 將 cur 加入 order // 記錄順序\n        → Step 7: 遍歷 cur 的鄰接課程 next\n            → Step 8: indegree[next] -= 1 // 減少依賴數\n            → Decision: indegree[next] 是否為 0? // 是否可開始\n                Yes → Step 9: 將 next 加入 queue // 可學\n                No  → [skip]\n        → Decision: queue 是否為空? // 迴圈\n            Yes → [repeat] // 循環\n            No  → [break]\n→ Step 10: Decision: order 長度是否等於 numCourses? // 檢查是否所有課都已安排\n    Yes → Step 11: Return order // 成功\n    No  → Step 12: Return 空陣列 // 失敗\nEnd\n\nWe need arrow formatting with Yes→ and No→. Provide each line with explanation. Use \"→\" for steps. For decisions we use \"Decision:\" line with indent.\n\nNeed to use correct indentation: For nested decisions and steps, we indent lines. We'll show indentation using spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立圖 adjacency list from prerequisites // 轉換課程前置關係為圖  \n→ Step 2: 計算每門課的入度 indegree // 需要先修課程數量  \n→ Step 3: 將所有入度為 0 的課程放入佇列 queue // 可直接開始的課  \n→ Step 4: 初始化空的順序 list order // 存放最終課程排序  \n→ Decision: queue 是否為空? // 檢查是否還有可學的課  \n&nbsp;&nbsp;Yes → Step 5: 從 queue 取出一門課 cur // 取出目前可學課程  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 6: 將 cur 加入 order // 記錄順序  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 7: 遍歷 cur 的鄰接課程 next // 檢查後續課程  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 8: indegree[next] -= 1 // 減少依賴數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: indegree[next] 是否為 0? // 是否可開始  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 9: 將 next 加入 queue // 可學課加入佇列  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 不可學，略過  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: queue 是否為空? // 是否繼續處理  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → // 回到 Decision，循環  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 進入下一輪迴圈  \n→ Step 10: Decision: order 長度是否等於 numCourses? // 檢查是否所有課已安排  \n&nbsp;&nbsp;Yes → Step 11: Return order // 成功完成所有課程  \n&nbsp;&nbsp;No  → Step 12: Return 空陣列 // 週期或無法完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Palindromic Subsequence",
      "source_file": "Leetcode/leetcode516.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindromeSubseq(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [[0] * n for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n                else:\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n        return dp[0][n - 1]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    s = data[0].strip()\n    sol = Solution()\n    result = sol.longestPalindromeSubseq(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: longest palindromic subsequence length. We'll use DP. Outline: read string s length n. Initialize dp[n][n] with 0. For i from n-1 to 0: dp[i][i] = 1. For j from i+1 to n-1: if s[i]==s[j] dp[i][j] = dp[i+1][j-1] + 2 else dp[i][j] = max(dp[i+1][j], dp[i][j-1]). Return dp[0][n-1]. Need to produce line by line pseudocode with explanations. Use arrow notation. We'll need Start, End. Provide each step. Probably break into sub-steps: input, initialization, loops, decisions, updates. Each line must have \"虛擬碼步驟 // 解釋\". Use spaces. Example: Start // 程式開始執行. Then arrow lines. Use \"→\". For decisions use \"Decision:\". We need to decide to use \"Decision:\" with Yes/No arrows. The DP loops can be represented as loops with \"→ Step: ...\" but not necessary decisions. Use \"→ For i = n-1 downto 0\" but pseudocode uses loop arrow. Provide \"→ Step 1: 讀取字串 s // 從輸入取得字串\". Provide variable n. Provide dp table. Then loops. For each i, set dp[i][i] = 1. Then inner loop j. Inside decision if s[i]==s[j] else. Provide accordingly. At end print dp[0][n-1]. Then End.\n\nLet's craft each line with explanation in Chinese. Ensure each line has a single // comment. Use \"→\" arrow. Provide indentation for nested steps? The example shows indentation for nested decisions. We can use indentation using spaces before \"Yes →\" etc. We'll follow similar style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 s // 從輸入取得待分析字串  \n→ Step 2: n ← length(s) // 計算字串長度  \n→ Step 3: 建立 dp[n][n] 並初始化為 0 // 兩維表存儲子問題答案  \n→ Step 4: 對 i 從 n-1 下降到 0 執行 // 外層迴圈遍歷左指標  \n  → Step 4.1: dp[i][i] ← 1 // 單字符本身即為長度 1 的回文子序列  \n  → Step 4.2: 對 j 從 i+1 到 n-1 執行 // 內層迴圈遍歷右指標  \n    → Decision: s[i] == s[j]？ // 判斷兩端字符是否相同  \n      Yes → Step 4.2.1: dp[i][j] ← dp[i+1][j-1] + 2 // 相同則包含兩端，長度加 2  \n      No  → Step 4.2.2: dp[i][j] ← max(dp[i+1][j], dp[i][j-1]) // 不同則取排除左或右的最大值  \n→ Step 5: 輸出 dp[0][n-1] // 整體字串的長度即為答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 移除可能的前綴 'accounts ='\n    if raw_input.lower().startswith(\"accounts\"):\n        raw_input = raw_input.split(\"=\", 1)[1].strip()\n    # 解析為 Python 物件\n    try:\n        accounts = ast.literal_eval(raw_input)\n    except Exception as e:\n        print(\"Invalid input format\", file=sys.stderr)\n        sys.exit(1)\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need produce pseudo code for merging accounts with common emails. We'll outline steps: Build graph email adjacency via name mapping, union-find or DFS. Use dictionary email->name, adjacency list for graph. Then DFS to get connected components. Sort emails, prepend name. Output list.\n\nLet's write line by line with arrows, decisions.\n\nWe can start with Start, then Build mapping, adjacency, etc. Use Decision for if email seen etc.\n\nWe must use virtual code steps. No actual code. Provide explanation per line.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize dict email_to_name, dict adjacency (email→set) // 存儲每個 email 與其名稱，以及相鄰關係\n→ Step 2: For each account in accounts // 遍歷所有帳戶\n    → Step 2a: name ← account[0] // 取帳戶名\n    → Step 2b: emails ← account[1:] // 取所有 email\n    → Decision: 如果 emails 內有重複 email? // 需要連結相同 email\n        Yes → For each email e in emails\n                → Step 2c: email_to_name[e] ← name // 將 email 與名稱關聯\n                → Step 2d: For each other_email in emails\n                        → Decision: if e != other_email? // 連結不同 email\n                            Yes → adjacency[e].add(other_email)\n                            No  → skip\n        No  → 這個帳戶不重複, 直接關聯\n    End Decision\nEnd For\n→ Step 3: Initialize visited set // 記錄已處理 email\n→ Step 4: Initialize result list // 儲存合併後帳戶\n→ Step 5: For each email e in email_to_name // 遍歷所有 email\n    → Decision: 如果 e 已在 visited? // 避免重複\n        Yes → skip\n        No  → \n            → Step 5a: Initialize stack with e // DFS stack\n            → Step 5b: Initialize component set with e\n            → Step 5c: While stack not empty\n                → Step 5c1: cur ← stack.pop()\n                → Step 5c2: For each neighbor in adjacency[cur]\n                    → Decision: 如果 neighbor 未在 component? \n                        Yes → component.add(neighbor)\n                        → stack.push(neighbor)\n            → Step 5d: Mark all emails in component as visited\n            → Step 5e: Sort component list ascending\n            → Step 5f: name ← email_to_name[any email in component] // 取名稱\n            → Step 5g: Append [name] + component to result\nEnd Decision\nEnd For\nEnd // 結束\n\nNeed to ensure each line with // explanation. Use arrow for steps.\n\nWe must avoid nested indent with arrow? In example they had arrow after Decision. We'll mimic.\n\nAlso need decisions indentation. Provide lines as separate with arrow lines. Use \"→\" at start of each step. For Decision block, use indentation with spaces? In example, they used indentation for lines inside Decision block.\n\nWe'll produce accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典 email_to_name 與 adjacency // 用於存放 email 與名稱關聯及 email 之間的連結  \n→ Step 2: 對於每個帳戶 accounts[i]  \n    → Step 2a: name ← accounts[i][0] // 取得帳戶名稱  \n    → Step 2b: emails ← accounts[i][1:] // 取得帳戶所有 email  \n    → Decision: 若 emails 中存在重複 email? // 判斷是否需要建立連結  \n        Yes → For each email e in emails  \n            → Step 2c: email_to_name[e] ← name // 將 email 與名稱關聯  \n            → For each other_email in emails  \n                → Decision: 如果 e ≠ other_email? // 只連結不同 email  \n                    Yes → adjacency[e].add(other_email) // 建立雙向連結  \n                    No → // 無需連結  \n            End Decision  \n        No → // email 都唯一，僅關聯名稱  \n            → For each email e in emails  \n                → Step 2c: email_to_name[e] ← name  \n        End Decision  \n    End For  \n→ Step 3: 初始化 visited 集合 // 記錄已處理的 email  \n→ Step 4: 初始化 result 列表 // 儲存合併後的帳戶  \n→ Step 5: 對於每個 email e in email_to_name  \n    → Decision: 若 e 已在 visited?  \n        Yes → // 已處理，跳過  \n        No →  \n            → Step 5a: 初始化 stack ← [e] // DFS 堆疊  \n            → Step 5b: component ← {e} // 當前連通分量  \n            → Step 5c: 當 stack 非空時  \n                → Step 5c1: cur ← stack.pop()  \n                → For each neighbor in adjacency[cur]  \n                    → Decision: 若 neighbor 不在 component?  \n                        Yes → component.add(neighbor)  \n                        → stack.push(neighbor)  \n                        No → // 已在分量中  \n                    End Decision  \n            → End While  \n            → Step 5d: visited ← visited ∪ component // 標記已處理  \n            → Step 5e: emails_sorted ← 排序(component) // 將 email 排序  \n            → Step 5f: name ← email_to_name[next(iter(component))] // 取得此分量的名稱  \n            → Step 5g: result.append([name] + emails_sorted) // 加入最終結果  \n        End Decision  \n    End For  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsgcn96yo.py\", line 32, in <module>\n    obj = Solution(*args[0])  # args[0] contains [n, blacklist]\n          ^^^^^^^^^^^^^^^^^^\nTypeError: __main__.Solution() argument after * must be an iterable, not int"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n    obj = None\n    results = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args[0])  # args[0] contains [n, blacklist]\n            results.append(None)\n        elif cmd == \"pick\":\n            results.append(obj.pick())\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line with explanation, no real code. The problem is the random pick algorithm with blacklist. We should outline algorithm: map blacklisted numbers in [0, n-1] to numbers in [0, m-1] where m = n - len(blacklist). Preprocess: create a set of blacklist values. Create a mapping dictionary for blacklisted numbers that are less than m to a white number that is > m-1 and not in blacklist. Then pick a random integer in [0, m-1], if in mapping then return mapped value else return itself. Provide steps: initialization, pick. Need to produce virtual code with arrow etc. Provide explanation for each line.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize n, blacklist, m = n - blacklist.size // compute range size\n→ Step 2: Create set B of blacklist for O(1) lookup // for quick membership\n→ Step 3: Initialize empty map remap // to store blacklisted < m\n→ Decision: If m <= 0? // safety\n    Yes → Step 4: Handle error // not needed\n    No  →\n        → Step 5: Build list of valid numbers >= m that are not in B // call them candidates\n        → Step 6: For each blacklisted number b in B where b < m\n            → Step 6a: Pick next candidate c from list // the smallest valid > m-1\n            → Step 6b: remap[b] = c // map b to c\n            → Step 6c: Remove c from candidates // to avoid reuse\n→ Step 7: pick() // method\n    → Step 7a: Generate random r in [0, m-1] // one call to random\n    → Decision: If r in remap?\n        Yes → Step 7b: Return remap[r] // mapped to valid number\n        No  → Step 7c: Return r // r itself is valid\nEnd\n\nBut need to adhere to output format: each line `虛擬碼步驟 // 解釋`. Use arrow for indentation, etc. Provide for decisions. Must show indentation with spaces? Example shows indentation with tabs or spaces. We'll produce as per example.\n\nWe'll produce lines starting with `Start // ...`. Then `→ Step ...`. For Decision we produce `Decision: ...` with indentation lines following.\n\nLet's produce.\n\nWe must include explanation in Chinese.\n\nMake sure to use `→` arrow for steps. For decisions, use `Decision: ...` and indent following lines with spaces.\n\nAlso we need to minimize random calls: we use one per pick.\n\nNow produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n 與 blacklist // 取得輸入參數  \n→ Step 2: 計算 m = n - blacklist.size // 有效數字的總數  \n→ Step 3: 建立集合 B 為 blacklist 以 O(1) 檢查 // 快速判斷黑名單  \n→ Step 4: 初始化空映射 remap // 存放需映射的黑名單  \n→ Decision: m <= 0? // 檢查有效範圍是否為空  \n    Yes → Step 5: Throw exception or handle error // 不應發生  \n    No → // 進行映射建構  \n        → Step 6: 準備候選集合 candidates，包含所有 [m, n-1] 且不在 B 的數字 // 待映射目標  \n        → Step 7: For each b in B where b < m  \n            → Step 7a: 取得並移除 candidates 的最小元素 c // 取一個合法值  \n            → Step 7b: remap[b] = c // 將低於 m 的黑名單映射到合法值  \n            → Step 7c: 釋放 c 從 candidates，避免重複使用  \n→ Step 8: 實作 pick() 方法  \n    → Step 8a: 產生隨機整數 r ∈ [0, m-1] // 只呼叫一次 random  \n    → Decision: r 在 remap 裡? // r 可能被映射  \n        Yes → Step 8b: Return remap[r] // 取得映射後的合法數  \n        No  → Step 8c: Return r // r 本身即合法  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.5682496784136294,0.09173387746843395],[-0.3119998088547109,0.4505645539661322],[-0.05275525572028736,0.6787304349023746]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.5682496784136294, 0.09173387746843395], [-0.3119998088547109, 0.4505645539661322], [-0.05275525572028736, 0.6787304349023746]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機生成極坐標中的半徑與角度，並轉換為笛卡兒座標\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    # 讀取指令和對應的參數，格式類似 LeetCode 風格的輸入\n    commands_line = sys.stdin.readline()\n    args_line = sys.stdin.readline()\n\n    if not commands_line or not args_line:\n        return\n\n    commands = json.loads(commands_line.strip())\n    args_list = json.loads(args_line.strip())\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # 第一個呼叫對應 null\n        else:\n            method = getattr(obj, cmd)\n            result = method(*args)\n            results.append(result)\n\n    # 輸出結果，None 會被轉成 null\n    sys.stdout.write(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. Provide a sequence: Start, step: initialize, random point generation. The algorithm: sample r = radius * sqrt(rand()), theta = random * 2π, x = x_center + r cos theta, y = y_center + r sin theta. Provide decision? Not needed. Provide class definition. Use pseudocode with arrows.\n\nWe need to output each line like:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→ Step 1: Constructor(radius, x_center, y_center) // 初始化圓半徑與中心\n...\n\nNeed to follow the arrow style. Use '→' before each step line. Also include 'Decision:' only if needed. We'll likely not need decision.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→ Step 1: Constructor(radius, x_center, y_center) // 設定半徑與中心座標\n    → Set self.radius = radius // 保存半徑\n    → Set self.x_center = x_center // 保存中心 x 坐標\n    → Set self.y_center = y_center // 保存中心 y 坐標\n→ Step 2: Function randPoint() // 產生隨機點\n    → Generate u = random_uniform(0,1) // 隨機數 0~1\n    → Compute r = self.radius * sqrt(u) // 應用圓面均勻分布公式\n    → Generate theta = random_uniform(0, 2π) // 隨機角度\n    → Compute x = self.x_center + r * cos(theta) // 轉換到平面坐標\n    → Compute y = self.y_center + r * sin(theta) // 轉換到平面坐標\n    → Return [x, y] // 回傳點座標\nEnd // 程式執行結束\n\nBut we need to ensure each line is a single line with '→'. Also we need to maintain indentation for nested lines? In example they use indentation for nested decisions. For our lines, we can indent for steps inside function. Use tabs or spaces? Use indentation. We'll provide spaces.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義 Solution 類別  \n→ Step 1: Constructor(radius, x_center, y_center) // 初始化半徑與中心座標  \n → Set self.radius = radius // 儲存半徑  \n → Set self.x_center = x_center // 儲存中心 X 座標  \n → Set self.y_center = y_center // 儲存中心 Y 座標  \n→ Step 2: Function randPoint() // 產生隨機點  \n → Generate u = random_uniform(0, 1) // 產生 0~1 的均勻隨機數  \n → Compute r = self.radius * sqrt(u) // 根據圓面均勻分布公式計算半徑  \n → Generate theta = random_uniform(0, 2π) // 產生 0~2π 的隨機角度  \n → Compute x = self.x_center + r * cos(theta) // 將極坐標轉換為 Cartesian X  \n → Compute y = self.y_center + r * sin(theta) // 將極坐標轉換為 Cartesian Y  \n → Return [x, y] // 回傳隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Pow(x, n)",
      "source_file": "Leetcode/leetcode50.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0.25000'\nGot (Norm):      '4.00000'\n--- (Raw) ---\nRaw Expected: '0.25000'\nRaw Got:      '4.00000'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef my_pow(x: float, n: int) -> float:\n    \"\"\"\n    Calculate x raised to the power n using binary exponentiation.\n    Handles negative exponents by inverting the base.\n    \"\"\"\n    if n == 0:\n        return 1.0\n    if n < 0:\n        x = 1.0 / x\n        n = -n\n\n    result = 1.0\n    while n > 0:\n        if n & 1:          # 如果 n 的最低位是 1\n            result *= x\n        x *= x              # 平方基數\n        n >>= 1             # 右移一位\n    return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，可能包含空格、逗號等\n    data = sys.stdin.read()\n    # 找出所有數字（整數或浮點數）\n    numbers = re.findall(r'[-+]?\\d*\\.\\d+|\\d+', data)\n    if len(numbers) < 2:\n        sys.exit(0)  # 沒有足夠的數字，直接退出\n\n    x = float(numbers[0])\n    n = int(float(numbers[1]))  # 先轉成 float 再轉 int，處理「-2」這類輸入\n\n    result = my_pow(x, n)\n    # 按照範例輸出保留五位小數\n    print(f\"{result:.5f}\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code for pow(x, n). Likely iterative exponentiation or binary exponentiation. Use decision structure.\n\nWe need each line: \"虛擬碼步驟 // 解釋\" with arrows. We need to start with Start, End. Use Decision. Use arrows →, Yes →, No →. Provide explanation for each.\n\nLet's design algorithm:\n\nStart\n→ Step 1: 定義 result = 1 // 初始化結果為 1\n→ Step 2: 取得 base = x // 把 x 存入 base\n→ Step 3: 取得 exponent = n // 把 n 存入 exponent\n→ Decision: exponent 是否小於 0? // 若為負數，處理\n    Yes → Step 4: base = 1 / base // 取倒數\n    Yes → Step 5: exponent = -exponent // 取絕對值\n    No → // 不做處理\n→ Step 6: 迴圈 While exponent > 0 // 逐位計算\n    → Decision: exponent 是否為奇數? // 判斷最低位\n        Yes → Step 7: result = result * base // 若奇數，累乘\n        No → // 不累乘\n    → Step 8: base = base * base // 平方 base\n    → Step 9: exponent = exponent / 2 // 右移一位\n→ Step 10: Return result // 返回結果\nEnd\n\nBut need to reflect arrow structure. We can use indentation or arrow lines. Use \"→\" before each step. Use Decision lines with Yes → etc. Each line include // 解釋.\n\nMake sure every line has exactly: [虛擬碼步驟] [空格] // [解釋].\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: result = 1 // 初始化結果為 1\n→ Step 2: base = x // 把輸入的底數存入 base\n→ Step 3: exponent = n // 把輸入的指數存入 exponent\n→ Decision: exponent < 0? // 檢查指數是否為負數\n    Yes → Step 4: base = 1 / base // 若負數，將底數取倒數\n    Yes → Step 5: exponent = -exponent // 把指數轉為正數\n    No  → // 指數為正，直接執行\n→ Step 6: While exponent > 0 // 進行快速冪計算的迴圈\n    → Decision: exponent mod 2 == 1? // 判斷指數最低位是否為 1\n        Yes → Step 7: result = result * base // 若最低位為 1，累乘到結果\n        No  → // 不做累乘\n    → Step 8: base = base * base // 將底數平方\n    → Step 9: exponent = exponent / 2 // 將指數右移一位\n→ Step 10: Return result // 回傳最終計算結果\nEnd // 程式執行結束\n\nEnsure each line includes // after a space. Provide consistent arrow usage. Maybe use \"→ Decision:\" as per example. Need to show indentation? The example shows indentation with spaces. We'll replicate.\n\nAlso, after Decision lines, we need to indent Yes and No lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = 1 // 初始化結果為 1  \n→ Step 2: base = x // 把輸入的底數存入 base  \n→ Step 3: exponent = n // 把輸入的指數存入 exponent  \n→ Decision: exponent < 0? // 檢查指數是否為負數  \n  Yes → Step 4: base = 1 / base // 若負數，將底數取倒數  \n  Yes → Step 5: exponent = -exponent // 把指數轉為正數  \n  No → // 指數為正，直接執行  \n→ Step 6: While exponent > 0 // 進行快速冪計算的迴圈  \n  → Decision: exponent mod 2 == 1? // 判斷指數最低位是否為 1  \n    Yes → Step 7: result = result * base // 若最低位為 1，累乘到結果  \n    No → // 不做累乘  \n  → Step 8: base = base * base // 將底數平方  \n  → Step 9: exponent = exponent / 2 // 將指數右移一位  \n→ Step 10: Return result // 回傳最終計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Edit Distance",
      "source_file": "Leetcode/leetcode72.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "actual_output_or_error": "File \"/tmp/tmpjgexl144.py\", line 22\n    word1 = \"horse\", word2 = \"ros\"\"\"\"\n                                    ^\nSyntaxError: unterminated string literal (detected at line 22)"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "actual_output_or_error": "File \"/tmp/tmp2y7lgk66.py\", line 22\n    word1 = \"horse\", word2 = \"ros\"\"\"\"\n                                    ^\nSyntaxError: unterminated string literal (detected at line 22)"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        return dp[m][n]\n\ndef parse_input(text: str):\n    \"\"\"Extract word1 and word2 from a string like:\n       word1 = \"horse\", word2 = \"ros\"\"\"\"\n    # Try regex extraction\n    w1_match = re.search(r'word1\\s*=\\s*\"([^\"]*)\"', text)\n    w2_match = re.search(r'word2\\s*=\\s*\"([^\"]*)\"', text)\n    if w1_match and w2_match:\n        return w1_match.group(1), w2_match.group(1)\n\n    # Fallback: assume first non-empty line is word1, second is word2\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n    # If still not found, return empty strings\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    word1, word2 = parse_input(raw_input)\n    result = Solution().minDistance(word1, word2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for edit distance DP. Provide explanation. Let's produce steps:\n\nStart\n→ Initialize DP table of size (len(word1)+1) x (len(word2)+1)\n→ For i from 0 to len(word1): set DP[i][0] = i // delete all from word1\n→ For j from 0 to len(word2): set DP[0][j] = j // insert all into word1\n→ For i from 1 to len(word1):\n    → For j from 1 to len(word2):\n        → Decision: if word1[i-1]==word2[j-1]? // compare chars\n            Yes → DP[i][j] = DP[i-1][j-1] // no operation needed\n            No  → DP[i][j] = 1 + min(DP[i-1][j-1], DP[i-1][j], DP[i][j-1]) // replace, delete, insert\n→ Result = DP[len(word1)][len(word2)]\nEnd\n\nBut they want each line as: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for steps. Provide indentation maybe. Use \"Decision:\" with Yes→ and No→. Let's format each line with that.\n\nWe need no real code, just virtual. Use simple labels: Start, End, Step X. We'll number steps maybe. Let's create step lines.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 設定 n = word1.length, m = word2.length // 取得兩個字串長度\nLine 3: → Step 2: 建立 DP 表 (n+1)×(m+1) // 用來存儲子問題答案\nLine 4: → Step 3: 依序為 i = 0..n 設定 DP[i][0] = i // 只刪除 word1\nLine 5: → Step 4: 依序為 j = 0..m 設定 DP[0][j] = j // 只插入字元\nLine 6: → Step 5: 對於 i = 1..n\nLine 7:     → Step 6: 對於 j = 1..m\nLine 8:         → Decision: word1[i-1] == word2[j-1]? // 比對目前字元\nLine 9:             Yes → Step 7: DP[i][j] = DP[i-1][j-1] // 字元相同，不需操作\nLine 10:            No  → Step 8: DP[i][j] = 1 + min(DP[i-1][j-1], DP[i-1][j], DP[i][j-1]) // 取三種操作中最小\nLine 11: → Step 9: 回傳 DP[n][m] // 最小操作數\nLine 12: End // 程式執行結束\n\nWe need to adhere to format: Each line \"虛擬碼步驟 // 解釋\". Use \"→\" for steps. For decision lines we use \"Decision:\". The indentation can be shown by spaces. Use correct Chinese explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 設定 n = word1.length, m = word2.length // 取得兩個字串長度\n→ Step 2: 建立 DP 表 (n+1)×(m+1) // 用來存儲子問題答案\n→ Step 3: 依序為 i = 0..n 設定 DP[i][0] = i // 只刪除 word1\n→ Step 4: 依序為 j = 0..m 設定 DP[0][j] = j // 只插入字元\n→ Step 5: 對於 i = 1..n\n    → Step 6: 對於 j = 1..m\n        → Decision: word1[i-1] == word2[j-1]? // 比對目前字元\n            Yes → Step 7: DP[i][j] = DP[i-1][j-1] // 字元相同，不需操作\n            No  → Step 8: DP[i][j] = 1 + min(DP[i-1][j-1], DP[i-1][j], DP[i][j-1]) // 取三種操作中最小\n→ Step 9: 回傳 DP[n][m] // 最小操作數\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkgwl9sr6.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpkgwl9sr6.py\", line 42, in main\n    obj = Solution(*arg[0])\n          ^^^^^^^^^^^^^^^^^\nTypeError: Solution.__init__() takes 2 positional arguments but 4 were given"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的拷貝\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return self.original\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌演算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入分成兩部分：操作序列和參數序列\n    split_idx = data.find('],')\n    ops_part = data[:split_idx + 1]\n    args_part = data[split_idx + 2:].strip()\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            # 建構物件，arg 是一個列表，例如 [[1,2,3]]\n            obj = Solution(*arg[0])\n            results.append(None)  # LeetCode 風格輸出為 null\n        elif op == 'reset':\n            results.append(obj.reset())\n        elif op == 'shuffle':\n            results.append(obj.shuffle())\n        else:\n            # 其他未知操作，保持 None\n            results.append(None)\n\n    # 將結果轉成 JSON，讓 None 變成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation. Virtual code uses arrows and decisions. We need to describe algorithm: Fisher-Yates shuffle. Steps: store original copy, reset returns copy, shuffle copies array then for i from n-1 down to 1 swap with random index 0..i.\n\nWe need line by line. Use Start, End. Use arrow and indentation for decisions. But no actual code, just pseudocode steps.\n\nWe should produce a step-by-step pseudocode for class Solution.\n\nWe need to incorporate constructor, reset, shuffle. We'll represent methods.\n\nWe can do:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 定義 Solution 類別\n→ Decision: ...\nBetter to just break into methods.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 創建 Solution 類別\n→ Step 2: 內部變數 original: int[] // 儲存原始陣列\n→ Step 3: 內部變數 current: int[] // 儲存當前陣列\n→ Step 4: 內部變數 n: int // 陣列長度\n\n→ Step 5: Constructor: Solution(nums) // 初始化\n    → Step 6: original ← copy(nums) // 複製原始陣列\n    → Step 7: current ← copy(original) // 初始化為原始\n\n→ Step 8: 方法 reset() // 重置\n    → Step 9: current ← copy(original) // 重新複製\n    → Step 10: 返回 current // 回傳\n\n→ Step 11: 方法 shuffle() // 隨機打亂\n    → Step 12: current ← copy(original) // 先複製\n    → Step 13: For i from n-1 down to 1\n        → Step 14: j ← random(0, i) // 隨機索引\n        → Step 15: swap current[i] 和 current[j] // 交換\n    → Step 16: 返回 current // 回傳打亂後陣列\nEnd // 程式執行結束\n\nNeed to format exactly: each line \"虛擬碼步驟 // 解釋\" with arrow. Use arrow after the step. Indentation for decisions? No decisions, just linear steps.\n\nWe must ensure each line has \"→\" except start and end. But some steps include indentation for steps inside methods. We can use indentation by spaces or tab.\n\nWe need to follow example: \"→ Step 1: ...\" etc.\n\nMake sure \"Start\" line has no arrow.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 內部變數 original: int[] // 儲存原始陣列  \n→ Step 3: 內部變數 current: int[] // 儲存目前陣列  \n→ Step 4: 內部變數 n: int // 陣列長度  \n\n→ Step 5: Constructor: Solution(nums) // 初始化物件  \n → Step 6: original ← copy(nums) // 複製輸入陣列成原始副本  \n → Step 7: current ← copy(original) // 初始化為原始陣列  \n → Step 8: n ← length(original) // 記錄陣列長度  \n\n→ Step 9: 方法 reset() // 重置陣列  \n → Step 10: current ← copy(original) // 重新複製原始陣列  \n → Step 11: 返回 current // 回傳重置後陣列  \n\n→ Step 12: 方法 shuffle() // 隨機打亂陣列  \n → Step 13: current ← copy(original) // 先複製原始陣列  \n → Step 14: For i from n-1 down to 1 // 從尾到頭遍歷  \n    → Step 15: j ← random(0, i) // 產生 0~i 的隨機索引  \n    → Step 16: swap current[i] 與 current[j] // 交換兩元素  \n → Step 17: 返回 current // 回傳已打亂的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"\n    回傳所有子集 (冪集)\n    \"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # 把目前的子集加入結果\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            # 選取 nums[i]\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            # 回溯，移除最後一個元素\n            path.pop()\n\n    backtrack(0, [])\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入，例如 \"nums = [1,2,3]\"\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # 使用安全的 literal_eval 取得 list\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = []\n\n    # 計算子集並輸出\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudocode in Traditional Chinese, step-by-step, with arrow syntax, comments. Need to generate all subsets of unique elements array. Use backtracking or iterative. Provide explanation each line.\n\nLet's produce:\n\nStart\n\n→ Step 1: Sort or not needed because unique. We just need to start.\n\nUse recursive backtracking: function backtrack(start, current).\n\nInitialize result list.\n\nImplement recursion.\n\nPseudo steps:\n\nStart\n\n→ Step 1: Initialize empty list result\n\n→ Step 2: Define recursive function backtrack(index, path)\n\n→ Step 3: Add current path to result\n\n→ Step 4: For i from index to n-1\n\n→ Decision: 若 i< n\n\n    Yes → Step 5: Append nums[i] to path\n\n    → Step 6: backtrack(i+1, path)\n\n    → Step 7: Remove last element from path (backtrack)\n\n→ End recursion\n\n→ Call backtrack(0, [])\n\n→ Return result\n\nWrap.\n\nBut must output each line with arrow.\n\nNeed to format:\n\nStart // 程式開始執行\n\n→ Step 1: nums ← input array // 取得輸入陣列\n\n→ Step 2: result ← empty list // 用來存所有子集\n\n→ Step 3: Define function backtrack(start, path) // 递归函数\n\n→ Step 4: result ← result ∪ [path] // 将当前子集加入结果\n\n→ Step 5: For i ← start to length(nums)-1 // 遍历剩余元素\n\n    → Decision: i <= length(nums)-1? // 检查循环边界\n\n        Yes → Step 6: path ← path ∪ [nums[i]] // 选中当前元素\n\n        → Step 7: backtrack(i+1, path) // 递归生成子集\n\n        → Step 8: path ← path - last element // 回溯，移除元素\n\n        No  → // 结束循环\n\n→ End // 递归结束\n\n→ Call backtrack(0, empty list) // 启动回溯\n\n→ Return result // 输出全部子集\n\nEnd // 程式结束\n\nWe must ensure no code, only virtual code steps.\n\nNeed to use arrow syntax and decision indentation.\n\nAlso keep each line separate.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← input array // 取得輸入陣列  \n→ Step 2: result ← empty list // 用來存所有子集  \n→ Step 3: Define function backtrack(start, path) // 建立遞迴子程序  \n→ Step 4: result ← result ∪ [path] // 把目前的子集加入結果  \n→ Step 5: For i ← start to length(nums)-1 // 遍歷剩餘元素  \n  Decision: i ≤ length(nums)-1? // 檢查循環條件  \n   Yes → Step 6: path ← path ∪ [nums[i]] // 選中當前元素  \n    → Step 7: backtrack(i+1, path) // 進一步遞迴  \n    → Step 8: path ← path - last element // 回溯，移除最後一個元素  \n   No → // 循環結束  \n→ End // 递归子程序結束  \n→ Call backtrack(0, empty list) // 啟動回溯  \n→ Return result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '6,nums=[1,1,1,2,2,3]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      '6, nums = [1,1,1,2,2,3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        write_index = 2  # 第三個位置開始寫入\n        count = 1        # 目前已處理元素的重複計數\n        for i in range(2, len(nums)):\n            if nums[i] == nums[i - 1]:\n                if count < 2:\n                    nums[write_index] = nums[i]\n                    write_index += 1\n                count += 1\n            else:\n                nums[write_index] = nums[i]\n                write_index += 1\n                count = 1\n        return write_index\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串轉成 Python list。\"\"\"\n    data = data.strip()\n    if '=' in data:\n        # 取等號後面的部分\n        _, part = data.split('=', 1)\n        data = part.strip()\n    # 直接使用 literal_eval 解析列表\n    return ast.literal_eval(data)\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    nums = parse_input(raw)\n    solution = Solution()\n    k = solution.removeDuplicates(nums)\n    # 建立輸出字串，後面用 '_' 代表未使用的位置\n    result_parts = [str(x) for x in nums[:k]] + ['_'] * (len(nums) - k)\n    output = f\"{k}, nums = [{','.join(result_parts)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with arrow syntax. Provide for the problem: remove duplicates allowing at most twice. Typical algorithm: two pointers. We'll generate steps accordingly. Ensure we use \"Start\", \"End\", \"Decision:\" and arrows. Each line has \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe need to produce steps for algorithm: If array length <=2 return length. else use i pointer from 0 to len-1, count duplicates for each element. Use j pointer for placement. Actually typical: iterate i from 0 to n-1, keep count. Or two-pointer: j tracks position to write. Use count variable.\n\nWe'll produce pseudocode.\n\nLet's outline:\n\nStart // 程式開始執行\n→ Decision: nums 为空? // 判斷陣列是否為空\n    Yes → Return 0 // 空陣列直接返回 0\n    No  → Decision: nums 长度 <=2? // 只有一或兩個元素時不需要移除\n        Yes → Return nums.length // 直接返回長度\n        No  → Step 1: 初始化 writeIndex = 2 // 第三個位置開始寫入\n        → Step 2: 初始化 count = 1 // 目前處理的元素已出現 1 次\n        → Step 3: 循环 i 从 2 到 nums.length-1 // 遍历数组\n            → Decision: nums[i] == nums[i-1]? // 是否和前一個相同\n                Yes → Decision: count < 2? // 是否已經出現兩次\n                    Yes → Step 4: nums[writeIndex] = nums[i] // 放入\n                        → Step 5: writeIndex += 1 // 移動寫入指標\n                        → Step 6: count += 1 // 次數加一\n                    No  → Step 7: // 跳過，已經兩次\n                No  → Step 8: nums[writeIndex] = nums[i] // 放入\n                    → Step 9: writeIndex += 1 // 移動寫入指標\n                    → Step 10: count = 1 // 重置次數\n        → Step 11: Return writeIndex // writeIndex 即為新的長度\nEnd // 程式執行結束\n\nWe should ensure proper indentation. Use arrows for decisions and actions. Provide explanation.\n\nAlso we must follow formatting: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\" before steps. Also \"Yes →\" \"No →\" in decisions. Also \"Start\" \"End\".\n\nWe must produce lines accordingly. Use proper Chinese explanation.\n\nLet's craft.\n\nAlso we should include the decision for empty array and length <=2. Use \"Decision: nums 為空?\" and \"Decision: nums 長度 <= 2?\" etc.\n\nAlso ensure step numbers? We can keep simple like Step 1, Step 2, etc. Or use labels.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums 為空? // 判斷陣列是否為空  \n  Yes → Return 0 // 空陣列直接返回長度 0  \n  No  → Decision: nums 長度 <= 2? // 只有 1 或 2 個元素時不需要移除  \n    Yes → Return nums.length // 直接返回長度  \n    No  → Step 1: writeIndex ← 2 // 從第三個位置開始寫入  \n    → Step 2: count ← 1 // 目前已處理元素的重複計數  \n    → Step 3: 循環 i 從 2 到 nums.length-1 // 遍歷剩餘元素  \n      → Decision: nums[i] == nums[i-1]? // 是否與前一個元素相同  \n       Yes → Decision: count < 2? // 是否已經出現兩次  \n        Yes → Step 4: nums[writeIndex] ← nums[i] // 放入元素  \n         → Step 5: writeIndex ← writeIndex + 1 // 移動寫入指標  \n         → Step 6: count ← count + 1 // 次數加一  \n        No → // 已經出現兩次，跳過此元素  \n       No  → Step 7: nums[writeIndex] ← nums[i] // 放入不同元素  \n        → Step 8: writeIndex ← writeIndex + 1 // 移動寫入指標  \n        → Step 9: count ← 1 // 重置次數  \n    → Step 10: Return writeIndex // writeIndex 為去重後的新長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphtx931sg.py\", line 42, in <module>\n    index_diff_part = parts[1].split('=')[1].strip()\n                      ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphljaqht2.py\", line 42, in <module>\n    index_diff_part = parts[1].split('=')[1].strip()\n                      ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        if indexDiff <= 0 or valueDiff < 0:\n            return False\n\n        window = []  # sorted list of numbers in the current sliding window\n\n        for i, num in enumerate(nums):\n            # Find the first element in window that is >= num - valueDiff\n            pos = bisect.bisect_left(window, num - valueDiff)\n\n            # Check if this element is within the allowed value difference\n            if pos < len(window) and abs(window[pos] - num) <= valueDiff:\n                return True\n\n            # Insert the current number into the sorted window\n            bisect.insort(window, num)\n\n            # Maintain the window size to at most indexDiff elements\n            if len(window) > indexDiff:\n                # Remove the number that is now out of the sliding window\n                out_num = nums[i - indexDiff]\n                idx = bisect.bisect_left(window, out_num)\n                window.pop(idx)\n\n        return False\n\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Example input: 'nums = [1,2,3,1], indexDiff = 3, valueDiff = 0'\n    parts = [p.strip() for p in data.split(',')]\n    nums_part = parts[0].split('=')[1].strip()\n    index_diff_part = parts[1].split('=')[1].strip()\n    value_diff_part = parts[2].split('=')[1].strip()\n\n    nums = ast.literal_eval(nums_part)\n    indexDiff = int(index_diff_part)\n    valueDiff = int(value_diff_part)\n\n    sol = Solution()\n    result = sol.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with comments. We need to solve problem: detect pair with constraints. It's similar to Leetcode 487. Use sliding window with TreeSet or Balanced BST for values. We'll produce algorithm steps. For simplicity: start, iterate indices, maintain sorted set of values in window of last indexDiff. For each nums[i], find floor/ceiling to check diff. Use Decision etc.\n\nWe'll generate pseudocode steps. Need to include arrows. Use Start, End. Use Decision for checks.\n\nLet's write.\n\nStart\n→ Step 1: 建立空集合 window 用於存放最近 indexDiff 個元素 // 用於快速查詢值差\n→ Step 2: 迴圈 i 從 0 到 nums.length-1 // 遍歷陣列\n    → Decision: 若 i > indexDiff? // 判斷是否已超過窗口大小\n        Yes → Step 3: 移除 window 中 nums[i-indexDiff-1] // 移除最舊元素以維持窗口\n        No  → // 無需移除\n    → Step 4: 在 window 中查找最接近 nums[i] 的值\n        → Decision: 是否存在值 v 使得 abs(v - nums[i]) <= valueDiff?\n            Yes → Step 5: 返回 true // 找到符合條件的對\n            No  → Step 6: 將 nums[i] 插入 window // 將當前元素加入窗口\n→ End // 若循環結束仍未返回，則不存在符合條件，返回 false\n\nNeed to add comments after each line. Use correct format.\n\nMake sure each line ends with // 解釋.\n\nAlso use decision indentation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 window 用於存放最近 indexDiff 個元素 // 用於快速查詢值差\n→ Step 2: 迴圈 i 從 0 到 nums.length-1 // 遍歷陣列\n    → Decision: i > indexDiff? // 判斷是否已超過窗口大小\n        Yes → Step 3: 移除 window 中 nums[i-indexDiff-1] // 移除最舊元素以維持窗口\n        No  → // 無需移除\n    → Step 4: 在 window 中查找最接近 nums[i] 的值 // 找出與當前值距離最小的元素\n        → Decision: 是否存在值 v 使得 abs(v - nums[i]) <= valueDiff?\n            Yes → Step 5: 返回 true // 找到符合條件的對，結束程式\n            No  → Step 6: 將 nums[i] 插入 window // 將當前元素加入窗口，繼續下一個索引\n→ End // 若循環結束仍未返回，則不存在符合條件，返回 false"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpru7pmx5w.py\", line 38, in <module>\n    candidates = eval(candidates_str)\n                 ^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptht4dz0n.py\", line 38, in <module>\n    candidates = eval(candidates_str)\n                 ^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Remove any newline or extra spaces\n    data = data.replace('\\n', ' ').replace('\\r', ' ')\n    parts = data.split(',')\n    if len(parts) < 2:\n        # Handle case where input might be on separate lines\n        parts = [line for line in data.split() if '=' in line]\n    # Extract candidates\n    cand_part = [p for p in parts if 'candidates' in p][0]\n    target_part = [p for p in parts if 'target' in p][0]\n    candidates_str = cand_part.split('=')[1].strip()\n    target_str = target_part.split('=')[1].strip()\n    # Evaluate list of candidates\n    candidates = eval(candidates_str)\n    target = int(target_str)\n\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step for this algorithm: combination sum, using backtracking. Provide each line with explanation. Must use arrow notation Start, End, Decision, etc. Provide each step: input, sort candidates, define backtrack function, recursion, prune, add combination when target==0, etc. Use \"→\" for each step. Use indentation for nested decisions? Provide consistent structure. Use Chinese. Let's craft.\n\nStructure:\n\nStart\n→ Step 1: 讀入 candidates 和 target // 取得輸入\n→ Step 2: 先排序 candidates // 方便後續剪枝\n→ Step 3: 建立結果清單 result = [] // 存儲所有合法組合\n→ Decision: 開始回溯調用 Backtrack([], 0, target) // 初始空組合、索引0、目標\n    → Function: Backtrack(current, start, remain)\n        → Decision: 如果 remain == 0? // 檢查是否達成目標\n            Yes → Step: 把 current 的複製加入 result // 收集解\n            No → Decision: 如果 start >= len(candidates)? // 超出候選範圍\n                Yes → Step: 返回 // 無法進一步選擇\n                No → Step: for i in range(start, len(candidates))\n                    → Decision: 如果 candidates[i] > remain? // 剪枝\n                        Yes → Step: break // 後續皆大於 remain\n                        No → Step: Append candidates[i] 到 current // 選擇此數\n                        → Step: Backtrack(current, i, remain - candidates[i]) // 允許重複\n                        → Step: Remove last from current // 回溯\nEnd\n\nNeed to use arrow formatting properly. For nested steps, we may indent but still use \"→\" per line. Use \"Decision:\" lines with indentation. For loops we can just step.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入候選數組 candidates 與目標值 target // 取得輸入\n→ Step 2: 將 candidates 進行升序排序 // 方便之後的剪枝\n→ Step 3: 建立結果清單 result = [] // 用來存放所有合法組合\n→ Decision: 進行回溯調用 Backtrack([], 0, target) // 初始空組合、起始索引0、剩餘目標\n    → Function: Backtrack(current, start, remain) // 回溯函式，current為當前組合\n        → Decision: 若 remain == 0? // 判斷是否已達到目標和\n            Yes → Step: 把 current 的複製加入 result // 收集合法解\n            No → Decision: 若 start >= len(candidates)? // 判斷是否已走到最後一個候選數\n                Yes → Step: 返回 // 無法再選擇，結束此路徑\n                No → Step: for i from start to len(candidates)-1 // 逐一嘗試剩餘候選數\n                    → Decision: 若 candidates[i] > remain? // 若當前數大於剩餘和，可剪枝\n                        Yes → Step: break // 後續皆大於 remain，直接跳出迴圈\n                        No → Step: Append candidates[i] 到 current // 選擇此數\n                        → Step: Backtrack(current, i, remain - candidates[i]) // 允許重複選擇同一數\n                        → Step: Remove last element from current // 回溯，移除剛加入的數\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和陣列\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機產生 1 ~ total 的整數\n        target = random.randint(1, self.total)\n        # 使用 bisect 找出最小索引使 prefix_sum[idx] >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包成 tuple，方便使用 literal_eval 解析\n    content = '(' + data + ')'\n    ops, args_list = ast.literal_eval(content)\n\n    results = []\n    sol = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            sol = Solution(args[0] if args else [])\n            results.append(None)  # constructor 回傳 null\n        elif op == \"pickIndex\":\n            if sol is None:\n                raise ValueError(\"Solution instance not created before pickIndex call\")\n            results.append(sol.pickIndex())\n        else:\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # 輸出 JSON 格式，將 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for implementing pickIndex with weighted random selection. Steps: compute prefix sums, total sum, random number in [0,total), binary search to find first prefix > rand. Provide virtual code lines with comments. Must follow format: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Start, End, Decision, etc. Provide code for initialization and pickIndex function. Should produce lines. Ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\". Use arrows and decisions.\n\nLet's design:\n\nStart\n→ Step 1: 初始化前綴和陣列 prefix[0] = w[0] // 建立累積和\n→ Loop i from 1 to n-1:\n    → prefix[i] = prefix[i-1] + w[i] // 計算累積和\n→ total = prefix[n-1] // 總重\n→ Function pickIndex:\n    → Step 2: rand = random integer from 1 to total // 產生隨機數\n    → Step 3: binary search on prefix to find smallest index with prefix[idx] >= rand // 選取權重\n    → Return idx\n\nWe need to use Decision arrows for binary search loops. Let's write each line as a separate step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 prefix 陣列長度 n // 用於累積權重\n→ Step 2: prefix[0] = w[0] // 初始化第一個累積值\n→ Loop i = 1 到 n-1:\n    → prefix[i] = prefix[i-1] + w[i] // 依序累加權重\n→ Step 3: total = prefix[n-1] // 總權重\n→ Function pickIndex():\n    → Step 4: rand = 1 + randomInt(total-1) // 隨機數 1~total\n    → Step 5: low = 0; high = n-1 // 二分搜尋範圍\n    → Decision: low <= high? // 判斷搜尋是否結束\n        Yes → Step 6: mid = (low+high)/2 // 計算中點\n            Decision: rand <= prefix[mid]? // rand 在左半區?\n                Yes → high = mid - 1 // 搜尋左半\n                No  → low = mid + 1 // 搜尋右半\n    → Step 7: return low // low 為最小索引符合條件\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" and comment. The step 1-7 etc. We need to format each line with a code-like representation. Use \"→\" for arrows.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 prefix 陣列長度 n // 用於累積權重  \n→ Step 2: prefix[0] = w[0] // 初始化第一個累積值  \n→ Loop i = 1 到 n-1:  \n → prefix[i] = prefix[i-1] + w[i] // 依序累加權重  \n→ Step 3: total = prefix[n-1] // 總權重  \n→ Function pickIndex():  \n → Step 4: rand = 1 + randomInt(total-1) // 隨機數 1~total  \n → Step 5: low = 0; high = n-1 // 二分搜尋範圍  \n → Decision: low <= high? // 判斷搜尋是否結束  \n  Yes → Step 6: mid = (low+high)/2 // 計算中點  \n   Decision: rand <= prefix[mid]? // rand 在左半區?  \n    Yes → high = mid - 1 // 搜尋左半  \n    No → low = mid + 1 // 搜尋右半  \n → Step 7: return low // low 為最小索引符合條件  \nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        pos = [0] * (m + n)\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result or \"0\"\n\ndef main():\n    data = sys.stdin.read()\n    # Extract all digit sequences; works for inputs like \"num1 = '123', num2 = '456'\"\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        # Fallback: maybe input is two lines each containing a number\n        lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            nums = [lines[0], lines[1]]\n    if len(nums) < 2:\n        # If still insufficient, exit gracefully\n        return\n    num1, num2 = nums[0], nums[1]\n    result = Solution().multiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for multiplication of two non-negative integer strings, returning string product, without big integer library or converting to int directly. Provide step-by-step virtual code lines with explanation.\n\nEssentially implement classic multiplication using arrays of digits.\n\nNeed to produce \"虛擬碼\" and each line with explanation. Use arrows →, Start, End, Decision, etc.\n\nWe need to produce line by line algorithmic steps.\n\nLet's craft pseudocode.\n\n1. Start\n2. Initialize arrays of digits: digits1 = reverse(num1) convert each char to int\n3. digits2 similarly\n4. result array length = len(num1)+len(num2), filled 0\n5. Nested loops: for i in range(len(digits1)):\n   for j in range(len(digits2)):\n   product = digits1[i]*digits2[j] + result[i+j]\n   result[i+j] = product % 10\n   result[i+j+1] += product // 10\n6. After loops, remove leading zeros from result (highest indices)\n7. Convert result array back to string by reversing and concatenating digits\n8. If string empty, return \"0\"\n9. End\n\nAdd Decision: if either input is \"0\" return \"0\" early.\n\nAlso Decision for trimming zeros.\n\nLet's produce each line. Use arrow. Provide explanation.\n\nOk. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 num1 為 \"0\" 或 num2 為 \"0\"? // 快速判斷是否有零，避免冗長運算  \n  Yes → Step 1: 輸出 \"0\" // 任何一方為零，乘積直接為零  \n  No → Step 2: 將 num1 反轉後轉為數字陣列 digits1 // 方便從最低位開始相乘  \n→ Step 3: 將 num2 反轉後轉為數字陣列 digits2 // 同樣為最低位對齊  \n→ Step 4: 建立長度為 len(num1)+len(num2) 的 result 陣列，初始值皆為 0 // 存放每位乘積與進位  \n→ Step 5: 進行雙層迴圈相乘  \n  → Loop i from 0 到 len(digits1)-1  \n   → Loop j from 0 到 len(digits2)-1  \n     → product ← digits1[i] * digits2[j] + result[i+j] // 原始乘積加上已累積的值  \n     → result[i+j] ← product % 10 // 取單位位存回 result  \n     → result[i+j+1] ← result[i+j+1] + product // 10 // 進位累加到下一位  \n→ Step 6: 移除 result 陣列中多餘的最高位 0 // 清除前導零，確保正確結果長度  \n  → Decision: result[最後一位] 是否為 0?  \n    Yes → Remove it // 繼續往前移除直到非 0 或僅剩一位  \n    No → Continue  \n→ Step 7: 反轉 result 陣列並轉成字串 strResult // 恢復正確位序並組成最終字串  \n→ Step 8: Decision: strResult 是否為空? // 這種情況僅在兩個輸入皆為 \"0\" 時發生  \n  Yes → Step 9: 輸出 \"0\" // 直接回傳零  \n  No  → Step 9: 輸出 strResult // 正常乘積字串  \nEnd // 程式執行結束"
    }
  ]
}