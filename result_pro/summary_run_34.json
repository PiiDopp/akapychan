{
  "run_index": 34,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 389,
  "generation_or_validation_failure_count": 50,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[1,4,3,4,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[1, 4, 3, 4, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    input_code = sys.stdin.read()\n    # 以本模組的全域命名空間執行輸入的程式碼\n    # 這樣可以直接呼叫 roll_dice，並把輸出的結果印到 stdout\n    exec(input_code, globals())",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode lines with comments. Use random module, function roll_dice(n). Should create list of results. Provide explanation each line. Use arrow and structure.\n\nWe'll produce Start, maybe Decision? It's simple.\n\nWe'll use pseudo:\n\nStart\n→ Step 1: Import random module\n→ Step 2: Define function roll_dice(n)\n   → Step 3: Initialize empty list results\n   → Decision: If n <= 0? // check invalid input\n      Yes → Step 4: Return empty list\n      No → Step 5: Loop i from 1 to n\n          → Step 6: Generate random int 1-6 using random.randint(1,6)\n          → Step 7: Append to results\n      End Loop\n      → Step 8: Return results\nEnd\n\nBut we need to ensure each line has \"虛擬碼步驟 // 解釋\". Provide arrows.\n\nLet's format. Use Start, End. Provide arrow lines.\n\nWe'll use \"→\" to indent for steps inside function or loop.\n\nMake sure each line contains the arrow. For nested lines, we can indent with arrow again.\n\nLet's produce.\n\nAlso we can include decision indentation.\n\nWill produce as plain text lines.\n\nLet's generate final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 引入 random 模組以便產生隨機數  \n→ Step 2: Define function roll_dice(n) // 定義 roll_dice 函式，接收一次擲骰次數  \n → Step 3: Initialize empty list results // 建立空列表儲存所有擲骰結果  \n → Decision: If n <= 0? // 檢查擲骰次數是否為非正數  \n  Yes → Step 4: Return empty list // 若次數非正，直接回傳空列表  \n  No  → Step 5: Loop i from 1 to n // 依次擲 n 次骰子  \n   → Step 6: Generate random int between 1 and 6 using random.randint(1,6) // 產生 1~6 的隨機整數  \n   → Step 7: Append result to results // 將擲出的數字加入列表  \n  → End Loop  \n → Step 8: Return results // 擲完後回傳所有結果列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量函式 func 執行所需秒數，並回傳四捨五入到小數點 3 位的耗時。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取整個標準輸入並執行其中的程式碼。\n    \"\"\"\n    code = sys.stdin.read()\n    # 執行讀入的程式碼，globals() 允許其中的函式使用上面定義的 measure_time\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, each line with explanation. No actual code. Use virtual arrows. The function measure_time(func, *args) uses time module, measure seconds, return rounded to 3 decimal places.\n\nWe need to produce Start, End, etc. Virtual code structure. So:\n\nStart\n→ Import time module\n→ Define function measure_time(func, *args)\n    → Record start_time = time.time()\n    → Call result = func(*args)\n    → Record end_time = time.time()\n    → Calculate elapsed = end_time - start_time\n    → Round elapsed to 3 decimal places\n    → Return elapsed, result? Wait spec: \"並回傳結果 (四捨五入到小數點 3 位)\" It likely means return elapsed time. But maybe also return result. The wording ambiguous: \"用來測量函數 func 執行所需的秒數，並回傳結果\" Could mean return the elapsed time. So we return elapsed. Or maybe return (elapsed, result). But I'll assume return elapsed.\n\nSo steps. Provide each line explanation.\n\nLet's produce. Use arrows and indentation with spaces.\n\nAlso maybe show a Decision? No.\n\nWe'll structure:\n\nStart // ...\n→ Import time module // ...\n→ Function measure_time(func, *args) // ...\n    → Record start time // ...\n    → Execute func(*args) // ...\n    → Record end time // ...\n    → Compute elapsed time // ...\n    → Round elapsed time to 3 decimal places // ...\n    → Return elapsed time // ...\nEnd // ...\n\nLet's write accordingly. Use virtual code lines. Ensure each line ends with // explanation. Use arrow.\n\nAlso ensure no actual code: we don't write \"import time\" as code; we write \"Import time module\". Ok.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Import time module // 載入 time 模組以取得時間戳\n→ Define function measure_time(func, *args) // 宣告 measure_time，接受目標函式與任意參數\n    → Record start_time = current time // 記錄執行前的時間點\n    → Execute func(*args) → result // 呼叫目標函式並取得其回傳值\n    → Record end_time = current time // 記錄執行後的時間點\n    → Compute elapsed = end_time - start_time // 計算兩者差距即耗時\n    → Round elapsed to 3 decimal places // 將耗時四捨五入到小數點第 3 位\n    → Return elapsed // 回傳測得的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"學生類別，包含姓名與分數屬性。\"\"\"\n    def __init__(self, name: str, score: int):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"輸出學生姓名與分數。\"\"\"\n        print(f\"{self.name} 的分數是 {self.score}\")\n\ndef main():\n    \"\"\"\n    主程式入口。\n    1. 從標準輸入讀取資料；若無輸入則使用預設學生。\n    2. 解析每行資料為姓名與分數，建立 Student 物件。\n    3. 呼叫 show_info() 以輸出結果。\n    \"\"\"\n    raw_data = sys.stdin.read().strip()\n    students = []\n\n    if raw_data:\n        # 每行格式為「姓名 分數」或多個欄位，以空白分隔，取前兩個為資料\n        for line in raw_data.splitlines():\n            parts = line.split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    continue\n                students.append(Student(name, score))\n    else:\n        # 無輸入時使用預設值\n        students.append(Student(\"Alice\", 90))\n        students.append(Student(\"Bob\", 80))\n\n    for student in students:\n        student.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. No actual code. Use virtual code with arrows and Start, End, Decision. The user wants to define a Student class with attributes name, score, __init__ initialize, method show_info prints formatted string, then create two instances and call show_info. We'll output virtual code. Use lines like \"Start // 程式開始執行\" etc. Each line: \"虛擬碼步驟 // 解釋\". Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class: Student // 定義名為 Student 的類別  \n→ Define Method: __init__(self, name, score) // 建構子，用於初始化名稱與分數  \n → Assign Attribute: self.name ← name // 將傳入的姓名儲存到物件屬性  \n → Assign Attribute: self.score ← score // 將傳入的分數儲存到物件屬性  \n→ End Define Method: __init__ // 結束建構子定義  \n→ Define Method: show_info(self) // 定義顯示資訊的方法  \n → Print Statement: \"{self.name} 的分數是 {self.score}\" // 輸出格式化字串  \n→ End Define Method: show_info // 結束 show_info 定義  \n→ End Define Class: Student // 結束 Student 類別定義  \n→ Instantiate: student1 ← Student(\"小明\", 85) // 建立第一個學生物件，姓名小明，分數85  \n→ Call Method: student1.show_info() // 呼叫第一個物件的 show_info 方法  \n→ Instantiate: student2 ← Student(\"小華\", 92) // 建立第二個學生物件，姓名小華，分數92  \n→ Call Method: student2.show_info() // 呼叫第二個物件的 show_info 方法  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"melon\",\"orange\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'melon', 'orange', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略任何輸入，確保程式可以從 stdin 接收資料\n    sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'（不會拋錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終結果\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line, with each line as: \"虛擬碼步驟 // 解釋\" and use arrows etc. Use Start, End, Decision maybe but not necessary. Just show steps.\n\nWe need to cover initialization, add, update, remove, discard, output.\n\nUse \"Start // 程式開始執行\".\n\nThen line: \"→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立集合\" etc.\n\nWe need to show usage of add, update, remove, discard, output.\n\nWe need to output collection. Use Step 6: Output fruits.\n\nNo need for decisions.\n\nLet's craft.\n\nWe must ensure each line ends with \"// 解釋\".\n\nUse arrow for each step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'  \n→ Step 6: 輸出 fruits // 顯示最終集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.7600TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.7600 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate() -> float:\n    \"\"\"\n    從 https://api.exchangerate-api.com/v4/latest/USD 取得 TWD 匯率。\n    若失敗則拋出 Exception。\n    \"\"\"\n    url = 'https://api.exchangerate-api.com/v4/latest/USD'\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()\n    data = response.json()\n    return data['rates']['TWD']\n\ndef create_gui() -> None:\n    \"\"\"\n    建立一個簡易的 tkinter GUI，顯示 TWD 匯率並可按鈕更新。\n    \"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label() -> None:\n        try:\n            rate = fetch_rate()\n            label.config(text=f'目前美元匯率：約 {rate:.4f} TWD')\n        except Exception:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    button = tk.Button(win, text='更新匯率', command=update_label)\n    button.pack(pady=5)\n\n    win.mainloop()\n\ndef main() -> None:\n    \"\"\"\n    主程式：讀取標準輸入，如果包含「更新匯率」字樣，則取得最新匯率並輸出。\n    \"\"\"\n    input_data = sys.stdin.read().strip()\n    if '更新匯率' in input_data:\n        try:\n            rate = fetch_rate()\n            print(f'目前美元匯率：約 {rate:.4f} TWD')\n        except Exception:\n            print('取得失敗，請檢查網路連線')\n    else:\n        # 若沒有相關輸入，直接啟動 GUI\n        create_gui()\n\nif __name__ == '__main__':\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow arrows and explanations. We must not output actual code. Steps: import tkinter, requests, define function to fetch rate, create GUI with label and button, update function to fetch and display. We should use \"→\" arrow, indentation indicated maybe with spaces. Use Decision etc if necessary. Let's produce sequential steps.\n\nLet's produce:\n\nStart\n→ Import tkinter as tk\n→ Import requests\n→ Function: fetch_rate → get JSON from API, parse TWD, return rate\n→ GUI: create root window\n→ Label: show initial text\n→ Button: on click call update function\n→ update function: rate = fetch_rate(); label.config(text=f\"USD/TWD: {rate}\")\n→ Bind button command\n→ Start mainloop\nEnd\n\nInclude decisions? Not needed. But could include decision if fetch fails. Provide simple flow. Ensure each line has a comment after //.\n\nMake sure to include arrow and maybe indentation with spaces. Use \"→\" at start of each line after Start. Use \"End\". Provide explanation after comment. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import tkinter as tk // 匯入 tkinter 模組以建立 GUI  \n→ Import requests // 匯入 requests 模組以進行 HTTP 請求  \n→ Function: fetch_rate // 定義函式以取得匯率  \n    → Step 1: response ← requests.get(\"https://api.exchangerate-api.com/v4/latest/USD\") // 發送 GET 請求取得 USD 基礎的匯率資料  \n    → Step 2: data ← response.json() // 解析 JSON 回應  \n    → Step 3: rate ← data[\"rates\"][\"TWD\"] // 取出 TWD 的匯率值  \n    → Step 4: Return rate // 回傳匯率  \n→ GUI: root ← tk.Tk() // 建立主視窗  \n→ GUI: root.title(\"USD ↔ TWD 匯率查詢\") // 設定視窗標題  \n→ GUI: rate_label ← tk.Label(root, text=\"匯率未取得\", font=(\"Helvetica\", 16)) // 建立顯示匯率的標籤  \n→ GUI: rate_label.pack(pady=20) // 將標籤放置於視窗中  \n→ Function: update_rate // 定義更新匯率的函式  \n    → Step 1: try  \n        → Step 2: rate ← fetch_rate() // 取得最新匯率  \n        → Step 3: rate_label.config(text=f\"USD/TWD: {rate:.4f}\") // 更新標籤文字  \n    → Step 4: except Exception as e  \n        → Step 5: rate_label.config(text=\"取得失敗\") // 發生錯誤時顯示失敗訊息  \n→ GUI: button ← tk.Button(root, text=\"更新匯率\", command=update_rate) // 建立按鈕並綁定更新函式  \n→ GUI: button.pack(pady=10) // 將按鈕放置於視窗中  \n→ Call update_rate() // 初始時立即取得並顯示匯率  \n→ GUI: root.mainloop() // 啟動 tkinter 事件迴圈，等待使用者操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[0,0],[2,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [0, 0], [2, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining zero cells\n        self.flipped = {}           # mapping for used indices\n\n    def flip(self):\n        # pick a random index among the remaining zeros\n        r = random.randint(0, self.total - 1)\n        # get the actual index, using mapping if it exists\n        index = self.flipped.get(r, r)\n        self.total -= 1\n        # swap the used index with the last available one\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # convert 1D index to 2D coordinates\n        return [index // self.n, index % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    # read the entire stdin\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # parse the input as a tuple of two lists: ops and args\n    ops_and_args = ast.literal_eval('(' + raw + ')')\n    ops, args_list = ops_and_args[0], ops_and_args[1]\n\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n        else:\n            # ignore unknown operations\n            res.append(None)\n\n    # output results with JSON formatting (None -> null)\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to output pseudocode line by line, with explanation comments. We need to produce a solution algorithm. Use mapping of 1D indices to 2D coordinates, using reservoir or random selection with mapping array. Typical solution: maintain list of available indices count, use random index r between 0 and count-1, get actual index = mapping.get(r, r). Then swap mapping[r] with mapping[count-1] (or mapping[count-1] = r). Decrease count. Flip: returns coordinates. Reset: clear mapping and count = m*n.\n\nAlso we need to minimize random calls: one per flip. Complexity O(1) average.\n\nImplement virtual code with lines starting with \"Start\", etc. We'll produce step-by-step of class initialization, flip, reset.\n\nWe need to use arrows and structure.\n\nWe produce:\n\nStart\n→ Step 1: Initialize m, n, total = m*n // set size\n→ Step 2: Initialize available = total // remaining zero cells count\n→ Step 3: Initialize map = empty dictionary // mapping for random selection\n→ Step 4: Define reset() // resets matrix\n    → Step 5: available = total\n    → Step 6: map = empty\n→ Step 7: Define flip() // returns [i,j]\n    → Step 8: r = random integer from 0 to available-1 // pick random index\n    → Step 9: index = map.get(r, r) // map r to actual index if swapped\n    → Step 10: last = map.get(available-1, available-1) // get last available index\n    → Step 11: map[r] = last // swap r with last\n    → Step 12: remove map[available-1] if exists // remove mapping of last\n    → Step 13: available -= 1 // one less zero\n    → Step 14: i = index // row = index // m\n    → Step 15: j = index % n // col\n    → Step 16: return [i, j]\nEnd\n\nNeed to ensure each line with \"虛擬碼步驟\" + \"// 解釋\". We need to use arrow syntax. Provide structure with Decision if necessary? But no decision except maybe mapping get. We'll use mapping get as simple.\n\nLet's produce output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← input m; n ← input n; total ← m × n // 設定矩陣大小與總格數  \n→ Step 2: available ← total // 仍為 0 的格子數目  \n→ Step 3: map ← 空字典 // 用於把隨機選取的 1D 指標映射到實際格子  \n→ Step 4: Define reset() // 重置矩陣  \n    → Step 5: available ← total // 將剩餘 0 的格子數目恢復  \n    → Step 6: map ← 空字典 // 清空映射表  \n→ Step 7: Define flip() // 隨機選取一個 0 並轉為 1  \n    → Step 8: r ← 隨機整數(0, available−1) // 從剩餘格子中隨機挑選一個索引  \n    → Step 9: index ← map.get(r, r) // 若 r 已被映射，取映射值，否則取 r 本身  \n    → Step 10: last ← map.get(available−1, available−1) // 取得最後一個可用格子的實際索引  \n    → Step 11: map[r] ← last // 把 r 映射到 last，完成交換  \n    → Step 12: 若 available−1 存在於 map 中，則刪除 map[available−1] // 移除已交換的最後格子映射  \n    → Step 13: available ← available − 1 // 減少剩餘 0 的格子數  \n    → Step 14: i ← index // m  // 由 1D 索引算出行號  \n    → Step 15: j ← index mod n //  由 1D 索引算出列號  \n    → Step 16: 返回 [i, j] // 回傳轉為 1 的格子座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1_wybq13.py\", line 21, in <module>\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = sum(1 for a, b in zip(word, searchWord) if a != b)\n            if diff == 1:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    data = json.loads(sys.stdin.read())\n    functions, arguments = data[0], data[1]\n\n    results = []\n    obj = None\n\n    for func, arg in zip(functions, arguments):\n        if func == \"MagicDictionary\":\n            obj = MagicDictionary()\n            results.append(None)\n        elif func == \"buildDict\":\n            obj.buildDict(arg[0])\n            results.append(None)\n        elif func == \"search\":\n            results.append(obj.search(arg[0]))\n        else:\n            results.append(None)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Steps: initialize data structure; buildDict; search: iterate dictionary or use patterns.\n\nWe'll produce a simple implementation: store dictionary in set. For search, for each word in dictionary, compare if difference count==1. Use length check. Provide virtual code. Format each line.\n\nLet's create:\n\nStart\n\n→ Step 1: Initialize MagicDictionary class with empty set // Set to store words\n\n→ Step 2: buildDict(dictionary) // iterate over array, add to set\n\n→ Step 3: search(searchWord) // iterate over set, compare\n\nNeed decision: difference count.\n\nWe'll produce pseudo:\n\nStart\n\n→ Step 1: Define class MagicDictionary // Define class\n\n→ Decision: (construction?) But we can skip.\n\nWe need to produce virtual code lines, with arrow. Let's craft:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize an empty set wordSet // 用於存放字典中的單詞\n\n→ Step 2: buildDict(dictionary) // 設定字典\n\n    → Loop over each word in dictionary // 逐個加入集合\n\n        → Add word to wordSet // 存入集合\n\n→ Step 3: search(searchWord) // 查詢是否能改一個字\n\n    → For each word in wordSet // 逐個檢查\n\n        → If word.length != searchWord.length // 長度不同不可能改一個字\n\n            → Continue // 跳過\n\n        → Count diff = 0 // 記錄不同字母數\n\n        → For i from 0 to word.length-1 // 逐個字元比對\n\n            → If word[i] != searchWord[i] // 字元不同\n\n                → diff++ // 差異加一\n\n                → If diff > 1 // 差異已超過 1\n\n                    → Break // 退出內層迴圈\n\n        → If diff == 1 // 正好一個差異\n\n            → Return true // 找到符合條件\n\n    → Return false // 沒有符合條件\n\nEnd // 程式執行結束\n\nMake sure to use virtual code arrow style: \"→ Step ...\" and \"Decision:\" maybe optional. But requirement says use arrows and structure. We used arrow \"→\" for steps, but also included decisions like \"If\" with colon. That should be fine.\n\nLet's produce each line accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class MagicDictionary // 建立魔法字典類別  \n→ Step 2: 初始化空集合 wordSet // 用於儲存字典中的單詞  \n→ Step 3: buildDict(dictionary) // 設定字典  \n → Loop over each word in dictionary // 逐個單詞加入集合  \n  → Add word to wordSet // 存入集合  \n→ Step 4: search(searchWord) // 判斷是否能改一個字符合字典  \n → For each word in wordSet // 逐一檢查每個單詞  \n  → Decision: 若 word.length != searchWord.length? // 長度不符則不可能改一個字  \n   Yes → Continue // 跳過此單詞  \n   No → Continue // (保留結構，實際不改)  \n  → Count diff = 0 // 記錄不同字母數  \n  → For i from 0 to word.length-1 // 逐個字元比對  \n   → Decision: 若 word[i] != searchWord[i]? // 字元不同  \n    Yes → diff++ // 差異加一  \n     Decision: 若 diff > 1? // 差異已超過 1  \n      Yes → Break // 跳出內層迴圈  \n      No → Continue // 繼續比對  \n  → Decision: 若 diff == 1? // 正好一個差異  \n   Yes → Return true // 找到符合條件，返回真  \n   No → Continue // 繼續檢查下個單詞  \n → Return false // 沒有任何單詞符合條件，返回假  \nEnd // 程式執行結束"
    },
    {
      "title": "UTF-8 Validation",
      "source_file": "Leetcode/leetcode393.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsw2m_qmj.py\", line 40, in <module>\n    data = eval(input_str)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    data = [197,130,1]\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqdata133.py\", line 40, in <module>\n    data = eval(input_str)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    data = [235,140,4]\n         ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def validUtf8(self, data):\n        n_bytes = 0  # number of remaining continuation bytes to expect\n        for num in data:\n            b = num & 0xFF  # use only the lowest 8 bits\n\n            if n_bytes == 0:\n                # determine the number of leading 1 bits\n                if (b >> 7) == 0:  # 1‑byte character (0xxxxxxx)\n                    continue\n\n                count = 0\n                mask = 0x80\n                while mask & b:\n                    count += 1\n                    mask >>= 1\n\n                # first byte cannot start with 10 or have more than 4 leading 1s\n                if count == 1 or count > 4:\n                    return False\n                n_bytes = count - 1  # remaining continuation bytes\n            else:\n                # must be a continuation byte: 10xxxxxx\n                if (b >> 6) != 0x2:\n                    return False\n                n_bytes -= 1\n\n        return n_bytes == 0\n\nif __name__ == \"__main__\":\n    # Read the entire input, e.g. \"data = [197,130,1]\"\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        sys.exit()\n\n    # Evaluate the input to obtain the list of integers\n    # This works for inputs like \"data = [197,130,1]\"\n    data = eval(input_str)\n\n    solution = Solution()\n    result = solution.validUtf8(data)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanations. The problem: Given integer array data, check if valid UTF-8. Virtual code algorithm: iterate through array, determine bytes. Steps: Start, Step1: set i=0; Step2: while i < len(data): determine number of leading 1 bits in data[i] & 0xFF. If 0, single byte; i++ else if 2-4: check following bytes count; for j from 1 to count-1: check if i+j < len and data[i+j] has pattern 10xxxxxx (i.e., high bits 10). If not, return false. else i += count; Continue. After loop, return true. End.\n\nWe need to include virtual code lines with arrows and explanation. Use Decision steps. We should also include return statements. We need to follow format. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化索引\n→ Decision: i < len(data)? // 檢查是否還有未處理的位元組\n    Yes → Step 2: byte ← data[i] & 0xFF // 取得目前位元組的 8 位\n    Yes → Step 3: count ← 0 // 初始化連續 1 的數量\n    Yes → Step 4: while count < 8 and (byte >> (7 - count)) & 1 == 1: count ← count + 1 // 計算前導 1 的個數\n    Yes → Decision: count == 0? // 是單字節字元?\n        Yes → i ← i + 1 // 跳過此位元組\n        No  → Decision: count == 1 or count > 4? // 1 或 >4 為非法\n            Yes → Step 5: return False // 非法編碼\n            No  → Step 6: if i + count > len(data)? // 確保後續位元組足夠\n                Yes → Step 7: return False\n                No  → Step 8: for j from 1 to count-1: // 檢查每個後續位元組\n                    → Decision: (data[i+j] & 0xC0) == 0x80? // 最高兩位是否為 10\n                        Yes → continue\n                        No  → Step 9: return False\n                → Step 10: i ← i + count // 跳過整個多位元組字元\n    No  → (loop continues)\n→ Decision: i < len(data)? // 重複處理\n    Yes → (go back to Step 1)\n    No  → Step 11: return True // 所有位元組均合法\nEnd // 程式執行結束\n\nWe need to format properly with virtual code arrows. Use \"Decision:\" and \"Yes →\", \"No →\". Also include comments. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化索引\n→ Decision: i < len(data)? // 檢查是否還有未處理的位元組\n    Yes → Step 2: byte ← data[i] & 0xFF // 取得目前位元組的 8 位\n    Yes → Step 3: count ← 0 // 初始化連續 1 的數量\n    Yes → Step 4: while count < 8 and (byte >> (7 - count)) & 1 == 1: count ← count + 1 // 計算前導 1 的個數\n    Yes → Decision: count == 0? // 是單字節字元?\n        Yes → Step 5: i ← i + 1 // 跳過此位元組\n        No  → Decision: count == 1 or count > 4? // 1 或 >4 為非法\n            Yes → Step 6: return False // 非法編碼\n            No  → Step 7: if i + count > len(data)? // 確保後續位元組足夠\n                Yes → Step 8: return False\n                No  → Step 9: for j from 1 to count-1: // 檢查每個後續位元組\n                    → Decision: (data[i+j] & 0xC0) == 0x80? // 最高兩位是否為 10\n                        Yes → continue\n                        No  → Step 10: return False\n                → Step 11: i ← i + count // 跳過整個多位元組字元\n    No  → (回到判斷條件)\n→ Decision: i < len(data)? // 仍有位元組未處理\n    Yes → (回到 Step 1)\n    No  → Step 12: return True // 所有位元組均合法\nEnd // 程式執行結束"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4q4qe6bd.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp4q4qe6bd.py\", line 39, in main\n    nums1, nums2, k = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4q4qe6bd.py\", line 34, in parse_input\n    data = ast.literal_eval(data_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x77ae4e211890>"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppq2x0thu.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmppq2x0thu.py\", line 39, in main\n    nums1, nums2, k = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppq2x0thu.py\", line 34, in parse_input\n    data = ast.literal_eval(data_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7339a4611690>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass Solution:\n    def kSmallestPairs(self, nums1, nums2, k):\n        if not nums1 or not nums2 or k <= 0:\n            return []\n\n        heap = []\n        res = []\n\n        # 初始化堆：每個 nums1[i] 與 nums2[0] 的組合，最多 k 個\n        for i in range(min(k, len(nums1))):\n            heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n        # 取出最小和的對，直到得到 k 個\n        while heap and len(res) < k:\n            sum_val, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n            if j + 1 < len(nums2):\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n        return res\n\ndef parse_input(data_str: str):\n    \"\"\"\n    將類似 'nums1 = [1,7,11], nums2 = [2,4,6], k = 3' 的字串轉為 (nums1, nums2, k)\n    \"\"\"\n    # 將等號改為冒號，包裹成字典字串，然後安全地解析\n    data_str = data_str.strip()\n    data_str = data_str.replace('=', ':')\n    data_str = '{' + data_str + '}'\n    data = ast.literal_eval(data_str)\n    return data['nums1'], data['nums2'], data['k']\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums1, nums2, k = parse_input(raw_input)\n    sol = Solution()\n    pairs = sol.kSmallestPairs(nums1, nums2, k)\n\n    # 以無空格的格式輸出結果\n    output = '[' + ','.join('[' + ','.join(map(str, p)) + ']' for p in pairs) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: find k smallest sum pairs from two sorted arrays. Typical approach: min-heap with tuples (sum, i, j). Initially push (nums1[0]+nums2[0], 0,0). While result size<k and heap not empty: pop smallest, add pair, then push next pair from same i with j+1 and from i+1, j? Actually typical solution pushes (i+1, j) if not visited. Use visited set. Complexity O(k log k). Provide virtual code steps.\n\nWe produce lines like:\nStart\n→ Step 1: Initialize min-heap H and visited set V // ...\n→ Decision: 如果 k==0 或 nums1 为空 或 nums2 为空? // ...\nYes → Step 2: Return empty list\nNo → ...\n→ Step 3: 插入初始元組 (nums1[0]+nums2[0], 0, 0) 到 H 並標記 (0,0) 已訪問\n→ Step 4: 初始化結果列表 res\n→ Step 5: While H 不空 且 res.size < k: // ...\n    → Step 5.1: pop最小元組 (sum,i,j) from H\n    → Step 5.2: 將 (nums1[i], nums2[j]) 加入 res\n    → Step 5.3: 如果 (i+1, j) 未訪問 且 i+1 < nums1.length: 插入 (nums1[i+1]+nums2[j], i+1, j) 到 H 並標記\n    → Step 5.4: 如果 (i, j+1) 未訪問 且 j+1 < nums2.length: 插入 (nums1[i]+nums2[j+1], i, j+1) 到 H 並標記\n→ End // 返回 res\n\nAlso need to include decision for empty case. Provide each line with // explanation.\n\nLet's produce virtual code lines exactly as required: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow and indentation maybe with tab? Format example uses tabs or spaces? Provided sample uses tab indent. Use similar style. Provide decision blocks with Yes/No indent. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize min-heap H and visited set V // 建立最小堆和已訪問座標集合  \n→ Decision: 如果 k==0 或 nums1 為空 或 nums2 為空? // 判斷是否無需進一步計算  \n  Yes → Step 2: Return empty list // 直接回傳空結果  \n  No →  \n→ Step 3: Push initial tuple (nums1[0]+nums2[0], 0, 0) into H 並將 (0,0) 標記為已訪問 // 以第一對元素為起點  \n→ Step 4: Initialize result list res = [] // 儲存最小和對  \n→ Step 5: While H 不空 且 res.size < k: // 迴圈直到取得 k 對  \n  → Step 5.1: Pop最小元組 (sum, i, j) from H // 取出目前最小和的對  \n  → Step 5.2: Append (nums1[i], nums2[j]) to res // 將對加入結果  \n  → Step 5.3: 如果 (i+1, j) 未訪問 且 i+1 < nums1.length:  \n    → Push (nums1[i+1]+nums2[j], i+1, j) into H 並標記 (i+1, j) // 生成下一行相同列的新對  \n  → Step 5.4: 如果 (i, j+1) 未訪問 且 j+1 < nums2.length:  \n    → Push (nums1[i]+nums2[j+1], i, j+1) into H 並標記 (i, j+1) // 生成下一列相同行的新對  \n→ End // 回傳 res，程式執行結束"
    },
    {
      "title": "My Calendar III",
      "source_file": "Leetcode/leetcode732.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarThree\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, 1, 1, 2, 3, 3, 3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpm_fnsun1.py\", line 38, in <module>\n    args_list = json.loads(lists[1])\n                ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 4 (char 3)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\nimport bisect\n\nclass MyCalendarThree:\n    \"\"\"\n    MyCalendarThree keeps a sorted list of timeline events.\n    Each booking adds two markers: (start, +1) and (end, -1).\n    When a booking is added we scan the timeline to find the maximum\n    overlapping count and return it.\n    \"\"\"\n    def __init__(self):\n        self.timeline = []  # list of (time, delta) pairs, sorted by time\n\n    def book(self, start, end):\n        # Insert the start and end markers while keeping the list sorted\n        bisect.insort(self.timeline, (start, 1))\n        bisect.insort(self.timeline, (end, -1))\n\n        # Scan the timeline to find the current maximum overlap\n        active = 0\n        max_active = 0\n        for time, delta in self.timeline:\n            active += delta\n            if active > max_active:\n                max_active = active\n        return max_active\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read()\n    # Extract the two JSON arrays from the input string\n    lists = re.findall(r'\\[.*?\\]', raw_input, flags=re.S)\n    if len(lists) < 2:\n        sys.exit(0)\n    methods = json.loads(lists[0])\n    args_list = json.loads(lists[1])\n\n    calendar = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"MyCalendarThree\":\n            calendar = MyCalendarThree()\n            results.append(None)          # None corresponds to null in JSON\n        elif method == \"book\":\n            res = calendar.book(*args)\n            results.append(res)\n\n    # Output the results as a JSON array so that null is printed instead of None\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for MyCalendarThree. Essentially using segment tree or sweep line. We'll produce a simple algorithm: maintain events in a list and compute maximum overlapping by sweep line. For each book, add event to list, compute max overlaps via sorting all start/end points. But complexity might be O(n log n) per booking. Acceptable. We'll produce steps: store intervals, book method adds interval, compute max overlap by collecting all endpoints, sorting, scanning. We'll include steps with decisions. Provide each line with explanation.\n\nLet's craft pseudo-code:\n\nStart\n→ Step 1: Define MyCalendarThree class // Class definition\n→ Step 2: In constructor, initialize eventList as empty // store intervals\n→ Step 3: Define book(start, end) method // method to add event\n    → Step 4: Append (start, end) to eventList // store new event\n    → Step 5: Create empty list points // hold start/end markers\n    → Decision: For each (s, e) in eventList? // iterate over events\n        → Step 6: Append (s, +1) to points // start increases count\n        → Step 7: Append (e, -1) to points // end decreases count\n    → Step 8: Sort points by time, with starts before ends at same time // ordering\n    → Step 9: Initialize currentOverlap = 0, maxOverlap = 0 // counters\n    → Decision: For each (time, delta) in points? // sweep\n        → Step 10: currentOverlap += delta // update count\n        → Decision: If currentOverlap > maxOverlap? // check max\n            → Yes → Step 11: maxOverlap = currentOverlap // update\n    → Step 12: Return maxOverlap // result\nEnd\n\nWe need to format with arrow notation and comments. Use \"Decision:\" and \"Yes →\" \"No →\" but we don't have a \"No\" branch for decisions; we can just note check.\n\nLet's write each line accordingly. Use indentation. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCalendarThree 類別 // 建立類別結構  \n→ Step 2: 在建構子內初始化 eventList 為空陣列 // 用來儲存所有已預訂的區間  \n→ Step 3: 定義 book(start, end) 方法 // 進行一次預訂並回傳最大重疊數  \n  → Step 4: 將 (start, end) 加入 eventList // 把新事件記錄下來  \n  → Step 5: 建立空陣列 points // 用來放所有起止點與變化量  \n  → Decision: 逐一遍歷 eventList 中的每個區間? // 準備掃描線資料  \n    Yes → Step 6: 將 (start, +1) 加入 points // 起點時預訂數量增加  \n    Yes → Step 7: 將 (end, -1) 加入 points // 終點時預訂數量減少  \n  → Step 8: 按時間升序排序 points，若時間相同則 +1 先於 -1 // 確保正確掃描順序  \n  → Step 9: 設定 currentOverlap = 0, maxOverlap = 0 // 初始化計數器  \n  → Decision: 逐一遍歷 points 中的每個 (time, delta)? // 開始掃描  \n    Yes → Step 10: currentOverlap += delta // 更新當前重疊數  \n    Yes → Decision: currentOverlap > maxOverlap? // 檢查是否是新最大值  \n      Yes → Step 11: maxOverlap = currentOverlap // 更新最大重疊數  \n  → Step 12: 回傳 maxOverlap // 回傳目前最大的 k-booking  \nEnd // 程式執行結束"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdhvqtgv6.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpdhvqtgv6.py\", line 35, in main\n    commands, args = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 64 (char 63)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    commands, args = json.loads(data)\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MinStack\":\n            obj = MinStack()\n            results.append(None)\n        elif cmd == \"push\":\n            obj.push(arg[0])\n            results.append(None)\n        elif cmd == \"pop\":\n            obj.pop()\n            results.append(None)\n        elif cmd == \"top\":\n            results.append(obj.top())\n        elif cmd == \"getMin\":\n            results.append(obj.getMin())\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a MinStack supporting push, pop, top, getMin in O(1). We'll output line by line, each line with virtual code + // explanation. Use arrows and structure. Provide full algorithm.\n\nWe need to design data structures: two stacks: main stack and min stack. For push: push onto main stack; push onto min stack if val <= current min. For pop: pop from main stack; if popped equals current min, pop from min stack. top: peek main stack. getMin: peek min stack.\n\nWe need to also have initialization: create two stacks empty.\n\nWe'll produce pseudo-code with Start/End, Steps, Decisions. Each line should have \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe should not produce actual code. So we can use labels: Start MinStack // 初始化 MinStack 對象. We'll show functions: Push, Pop, Top, GetMin.\n\nLet's produce a structured flowchart style pseudo-code.\n\nUse arrow notation → for sequential.\n\nMake sure to include decisions.\n\nLet's produce as a single program flow. Provide entry points.\n\nOk.\n\nWe'll produce:\n\nStart MinStack // 初始化兩個空堆疊: 主堆疊和最小堆疊\n→ Init mainStack = empty // 主堆疊用於存儲所有元素\n→ Init minStack = empty // 最小堆疊用於跟蹤最小值\nEnd MinStack // 完成初始化\n\nThen push:\n\nStart push(val) // 將值加入堆疊\n→ Push val onto mainStack // 主堆疊放入新元素\n→ Decision: Is minStack empty? // 判斷最小堆疊是否為空\n    Yes → Push val onto minStack // 空時，該值即為最小值\n    No → Decision: Is val <= peek(minStack)? // 是否小於等於當前最小\n        Yes → Push val onto minStack // 更新最小堆疊\n        No  → No action on minStack // 不影響最小堆疊\nEnd push\n\nPop:\n\nStart pop() // 移除堆疊頂部元素\n→ Decision: Is mainStack empty? // 檢查是否有元素\n    Yes → No operation // 若空則直接返回\n    No  → \n        → Pop topVal from mainStack // 取得並移除頂部元素\n        → Decision: Is topVal == peek(minStack)? // 是否為最小值\n            Yes → Pop from minStack // 同時移除最小堆疊頂部\n            No  → No action // 只移除主堆疊\nEnd pop\n\nTop:\n\nStart top() // 取得堆疊頂部值\n→ Decision: Is mainStack empty? // 若空則返回錯誤或特殊值\n    Yes → Return error\n    No  → Return peek(mainStack) // 返回主堆疊頂部\nEnd top\n\nGetMin:\n\nStart getMin() // 取得最小值\n→ Decision: Is minStack empty? // 若空則錯誤\n    Yes → Return error\n    No  → Return peek(minStack) // 返回最小堆疊頂部\nEnd getMin\n\nAlso provide overall structure.\n\nWe should produce one pseudo-code per line. Provide each line with explanation. So each of above steps becomes a line.\n\nMake sure to use \"→\" arrow for flow.\n\nNeed to include indentation maybe? Use indentation with arrow.\n\nWe'll output as lines.\n\nLet's compose.\n\n...done thinking.\n\nStart MinStack // 初始化 MinStack 類別，建立兩個空堆疊：主堆疊 mainStack 與最小堆疊 minStack  \n→ Init mainStack = empty // 主堆疊用於存儲所有進入的元素  \n→ Init minStack = empty // 最小堆疊用於追蹤當前最小值  \nEnd MinStack // 結束初始化，物件已就緒  \n\nStart push(val) // 把 val 推入堆疊  \n→ Push val onto mainStack // 先把新值加入主堆疊  \n→ Decision: Is minStack empty? // 判斷最小堆疊是否為空  \n    Yes → Push val onto minStack // 空時，該值即為最小值，推入 minStack  \n    No → Decision: Is val <= peek(minStack)? // 比較新值與當前最小值  \n        Yes → Push val onto minStack // 新值更小或相等，更新 minStack  \n        No  → No action // 新值大於最小值，minStack 不變  \nEnd push // 推入完成  \n\nStart pop() // 移除堆疊頂部元素  \n→ Decision: Is mainStack empty? // 檢查是否有元素可彈出  \n    Yes → No operation // 空堆疊時直接返回，不做任何事  \n    No →  \n        → Pop topVal from mainStack // 取得並移除主堆疊頂部元素  \n        → Decision: Is topVal == peek(minStack)? // 判斷被彈出的是否是最小值  \n            Yes → Pop from minStack // 若是，亦同步從 minStack 彈出  \n            No  → No action // 只移除主堆疊，minStack 不變  \nEnd pop // 彈出完成  \n\nStart top() // 取得堆疊頂部值  \n→ Decision: Is mainStack empty? // 檢查主堆疊是否為空  \n    Yes → Return error // 若空，返回錯誤或特殊值  \n    No  → Return peek(mainStack) // 否則返回主堆疊頂部元素  \nEnd top // 完成 top 操作  \n\nStart getMin() // 取得目前最小值  \n→ Decision: Is minStack empty? // 檢查最小堆疊是否為空  \n    Yes → Return error // 空時返回錯誤或特殊值  \n    No  → Return peek(minStack) // 否則返回 minStack 的頂部，即最小值  \nEnd getMin // 完成 getMin 操作  \n\nEnd // 程式結束，所有操作均為 O(1) 時間複雜度"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(res[::-1])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract all numeric strings from the input\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        # If only one number provided, assume second is 0\n        numbers.append('0')\n    num1, num2 = numbers[0], numbers[1]\n    solver = Solution()\n    result = solver.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The requirement: given two non-negative integer strings, return their sum as string, no big integer library, no direct conversion to integer. Essentially implement manual addition: iterate from end of strings, keep carry, etc.\n\nWe output:\n\nStart\n→ Step 1: 初始化指標 i = len(num1)-1, j = len(num2)-1, carry = 0, result = empty string builder // set up indices\n→ Decision: i >= 0 or j >= 0 or carry > 0? // loop condition\n    Yes → Step 2: digit1 = i >=0 ? int(num1[i]) : 0 // get digit\n    → Step 3: digit2 = j >=0 ? int(num2[j]) : 0 // get second digit\n    → Step 4: sum = digit1 + digit2 + carry // compute sum\n    → Step 5: carry = sum / 10 // update carry\n    → Step 6: result = (sum % 10) + result // prepend digit\n    → Step 7: i = i-1 // move left\n    → Step 8: j = j-1 // move left\n    → Go back to Decision\n    No → Step 9: return result // finished\nEnd\n\nWe should avoid actual code but use virtual code. Provide each line with // explanation.\n\nAlso maybe use virtual code arrow formatting exactly: \"→ Step X: ...\" Use \"Decision:\" etc.\n\nMake sure each line is one line. Use the virtual arrows: Start, End, Decision:.\n\nInclude comments: // 說明.\n\nAlso note that the requirement says \"逐行\" means each step on separate line. Should we include indentations? Example format: In example, \"→ Decision: ...\". For sub-branches, they use indentation.\n\nWe need to ensure proper formatting. So we can show indents using spaces. In example, they used four spaces for nested steps? Actually example shows each step indented by one tab? But we can mimic.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 i = num1.length - 1, j = num2.length - 1, carry = 0, result = \"\" // 初始化變數\n→ Decision: i >= 0 或 j >= 0 或 carry > 0? // 判斷是否還有位數需要處理\n    Yes → Step 2: digit1 = (i >= 0) ? int(num1[i]) : 0 // 取得 num1 的當前位數，若已越界則為 0\n    → Step 3: digit2 = (j >= 0) ? int(num2[j]) : 0 // 取得 num2 的當前位數，若已越界則為 0\n    → Step 4: sum = digit1 + digit2 + carry // 計算兩位數與進位的總和\n    → Step 5: carry = sum / 10 // 更新進位\n    → Step 6: result = (sum % 10) + result // 把本位數加到結果前面\n    → Step 7: i = i - 1 // 向左移動 num1 指標\n    → Step 8: j = j - 1 // 向左移動 num2 指標\n    → Decision: i >= 0 或 j >= 0 或 carry > 0? // 重新判斷是否繼續循環\n        Yes → (loop back) // 迴圈\n        No → Step 9: return result // 當無更多位數時回傳結果\n    No → Step 9: return result // 直接回傳結果（如果初始時就沒有任何位數）\nEnd // 程式執行結束\n\nBut we must ensure not to duplicate step numbers. Actually we used Step 9 in both No branches, but that's fine. Maybe we need to use separate steps for each path but they can share. But we need to be consistent. We can use Step 9 for return.\n\nWe also need to maintain indentation properly.\n\nLet's produce final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 設定 i = num1.length - 1, j = num2.length - 1, carry = 0, result = \"\" // 初始化指標、進位與結果字串\n→ Decision: i >= 0 或 j >= 0 或 carry > 0? // 判斷是否還有位數需要相加\n    Yes → Step 2: digit1 = (i >= 0) ? int(num1[i]) : 0 // 取得 num1 的當前位數，若已越界則為 0\n    → Step 3: digit2 = (j >= 0) ? int(num2[j]) : 0 // 取得 num2 的當前位數，若已越界則為 0\n    → Step 4: sum = digit1 + digit2 + carry // 計算兩位數與進位的總和\n    → Step 5: carry = sum / 10 // 更新進位\n    → Step 6: result = (sum % 10) + result // 把本位數加入結果前面\n    → Step 7: i = i - 1 // 向左移動 num1 指標\n    → Step 8: j = j - 1 // 向左移動 num2 指標\n    → Decision: i >= 0 或 j >= 0 或 carry > 0? // 重新判斷是否繼續循環\n        Yes → (回到上一層 Decision) // 迴圈繼續\n        No  → Step 9: return result // 所有位數處理完畢，回傳結果\n    No  → Step 9: return result // 初始時已無位數可相加，直接回傳結果\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"\n        建構子：把陣列 nums 轉成從數字到所有索引的映射，方便快速取得 target 的索引\n        \"\"\"\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        隨機挑選 nums 中等於 target 的索引\n        \"\"\"\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將兩個 list 包裝成 tuple，並安全解析\n    operations, args = ast.literal_eval(f\"({data})\")\n\n    obj = None\n    results = []\n\n    for op, arg in zip(operations, args):\n        if op == \"Solution\":\n            # 這裡 arg 是類似 [[1,2,3,3,3]]，取第一個元素作為 nums\n            obj = Solution(arg[0])\n            results.append(None)\n        else:\n            # 動態呼叫方法，arg 可能是多維列表，例如 [3] 或 [1]\n            res = getattr(obj, op)(*arg)\n            results.append(res)\n\n    # 以 JSON 形式輸出，方便得到 null 而非 None\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, each line with virtual code and explanation. The task: implement a class Solution with constructor and pick method that randomly chooses index where nums[i]==target with equal probability. Typical Reservoir Sampling approach. Virtual code steps: Start, Step 1: store array, Step 2: pick method receives target, initialize count and result, iterate over array, if match increment count, generate random number between 0 and count-1, if zero choose current index. Return result. End.\n\nAlso we need to show structure: Start, Decision, Yes/No arrows. Use virtual code. Provide comments. No actual code. Provide step by step. We should include multiple steps for initialization, pick method, loop, decision.\n\nLet's produce lines:\n\nStart\n→ Step 1: 建立 Solution 物件，將輸入陣列 nums 存入內部變數 // 儲存陣列供後續使用\n→ Step 2: 定義 pick(target) 方法 // 進行隨機挑選\n→ Step 3: 在 pick 方法內初始化 count ← 0，result ← -1 // 用於統計符合目標的個數與暫存索引\n→ Decision: 迭代 nums 之中每個索引 i // 遍歷整個陣列\n    → Step 4: 如果 nums[i] 等於 target? // 檢查是否符合目標值\n        Yes → Step 5: count ← count + 1 // 更新符合目標的數量\n        Yes → Step 6: 產生隨機整數 r 在 [0, count-1] // 隨機選擇\n        Yes → Decision: 若 r == 0? // reservoir sampling 條件\n            Yes → Step 7: result ← i // 把當前索引存為候選\n        No  → Step 8: // 不改變 result\n    No  → // 當 nums[i] != target，跳過\n→ Step 9: return result // 回傳等概率選中的索引\nEnd\n\nNeed to ensure each line includes explanation. Use \"→\" for steps and \"Decision:\" for condition.\n\nWe should format exactly as requested: \"虛擬碼步驟 [space] // 解釋/說明\". Include the arrow. Example:\n\nStart // 程式開始執行\n→ Step 1: ...\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Solution 物件，將輸入陣列 nums 存入內部變數 // 儲存陣列供後續使用  \n→ Step 2: 定義 pick(target) 方法 // 進行隨機挑選  \n→ Step 3: 在 pick 方法內初始化 count ← 0，result ← -1 // 用於統計符合目標的個數與暫存索引  \n→ Decision: 迭代 nums 之中每個索引 i // 遍歷整個陣列  \n  → Step 4: 如果 nums[i] 等於 target? // 檢查是否符合目標值  \n   Yes → Step 5: count ← count + 1 // 更新符合目標的數量  \n   Yes → Step 6: 產生隨機整數 r 在 [0, count-1] // 隨機選擇  \n   Yes → Decision: 若 r == 0? // reservoir sampling 條件  \n    Yes → Step 7: result ← i // 把當前索引存為候選  \n    No → Step 8: // 不改變 result  \n   No → // 當 nums[i] != target，跳過  \n→ Step 9: return result // 回傳等概率選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1], [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立「倒序單詞 -> 索引」對應表\n        reverse_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 處理可能的空字串\n        empty_idx = -1\n        for i, w in enumerate(words):\n            if w == \"\":\n                empty_idx = i\n                break\n        if empty_idx != -1:\n            for i, w in enumerate(words):\n                if i != empty_idx and w == w[::-1]:\n                    res.append([empty_idx, i])\n                    res.append([i, empty_idx])\n\n        # 逐字串尋找 palindrome pair\n        for i, w in enumerate(words):\n            L = len(w)\n            for j in range(L + 1):\n                prefix = w[:j]\n                suffix = w[j:]\n\n                # 前半部分為回文，後半部分倒序存在\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in reverse_map:\n                        k = reverse_map[rev_suffix]\n                        if k != i:\n                            res.append([k, i])\n\n                # 後半部分為回文，前半部分倒序存在（避免 j==L 重複）\n                if j != L and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in reverse_map:\n                        k = reverse_map[rev_prefix]\n                        if k != i:\n                            res.append([i, k])\n\n        return res\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 可能是 \"words = [...]\" 或直接是 [...]\n    if \"words\" in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n\n    # 解析成 Python list\n    try:\n        words = ast.literal_eval(list_part.strip())\n    except Exception:\n        # 若解析失敗直接退出\n        return\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    # 以預期格式輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step explaining algorithm. Problem: find palindrome pairs. Need O(total length) runtime. Use hash map for reversed words, etc. Approach: For each word, enumerate splits and check reverse matches. Need pseudo-code. We'll produce steps, using arrows and decisions. Provide each line with comment. Let's design algorithm:\n\nStart\nLoad words array, n.\nCreate map reverseWordToIndex mapping reversed string to index.\nPopulate map.\nInitialize result list.\n\nFor each index i, word w:\n    For each split position k from 0 to len(w):\n        prefix = w[0:k], suffix = w[k:]\n        If prefix is palindrome:\n            revSuffix = reverse(suffix)\n            if revSuffix in map and map[revSuffix] != i:\n                add (map[revSuffix], i)\n        If k != len(w) and suffix is palindrome:\n            revPrefix = reverse(prefix)\n            if revPrefix in map and map[revPrefix] != i:\n                add (i, map[revPrefix])\n\nEdge cases: empty string: handle separately.\n\nComplexities: O(total length) because each char processed constant times.\n\nPseudo-code lines accordingly.\n\nLet's produce each line with comment.\n\nNeed to incorporate decision arrows.\n\nLet's write:\n\nStart // program start\n→ Step 1: n ← length(words) // number of words\n→ Step 2: reverseMap ← empty map // reversed word -> index\n→ Decision: For each index i from 0 to n-1? // build reverse map\n    Yes → Step 3: rev ← reverse(words[i]) // reverse current word\n    → Step 4: reverseMap[rev] ← i // store index\nEnd // map built\n\n→ Step 5: result ← empty list // to hold pairs\n→ Decision: For each index i from 0 to n-1? // iterate words\n    Yes → Step 6: w ← words[i] // current word\n    → Step 7: L ← length(w) // word length\n    → Decision: For each split k from 0 to L? // split positions\n        Yes → Step 8: prefix ← substring(w,0,k)\n        → Step 9: suffix ← substring(w,k,L)\n        → Decision: IsPalindrome(prefix)? // check prefix\n            Yes → Step 10: revSuffix ← reverse(suffix)\n            → Step 11: if revSuffix in reverseMap and reverseMap[revSuffix] ≠ i:\n                → Step 12: add (reverseMap[revSuffix], i) to result\n        → Decision: k < L and IsPalindrome(suffix)? // check suffix not empty\n            Yes → Step 13: revPrefix ← reverse(prefix)\n            → Step 14: if revPrefix in reverseMap and reverseMap[revPrefix] ≠ i:\n                → Step 15: add (i, reverseMap[revPrefix]) to result\nEnd // pairs found\n\n→ Step 16: return result // output pairs\nEnd // program finish\n\nBut need to follow format with arrows and decisions. Also include comments. Also incorporate empty string handling: If any word is empty string, for each other word if word is palindrome, add pair. Might include before loops. Let's incorporate step for empty string.\n\nAdd after building map: find index of empty string if exists. Then for each word j not empty and is palindrome, add (emptyIndex, j) and (j, emptyIndex). We'll integrate.\n\nLet's produce final pseudo-code accordingly. Ensure each line is one step. Use Decision: If emptyIndex ≠ -1? etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(words) // 取得單詞數量  \n→ Step 2: reverseMap ← empty map // 建立「倒序單詞 → 索引」對應表  \n\nDecision: 是否要建立 reverseMap？  \n    Yes → Step 3: for i from 0 to n-1 do  \n        → Step 4: rev ← reverse(words[i]) // 取得 words[i] 的倒序  \n        → Step 5: reverseMap[rev] ← i // 將倒序對應到原索引  \n\nEnd // reverseMap 建立完畢  \n\n→ Step 6: result ← empty list // 存放所有符合的 (i, j)  \n→ Step 7: emptyIndex ← -1 // 先假設沒有空字串  \n→ Decision: 是否有空字串？  \n    Yes → Step 8: for i from 0 to n-1 do  \n        → Decision: words[i] == \"\"?  \n            Yes → Step 9: emptyIndex ← i // 記錄空字串索引  \n            No → Step 10: continue  \n\nEnd // 找到空字串索引  \n\nDecision: 若存在空字串，處理特殊情況  \n    Yes → Step 11: for i from 0 to n-1 do  \n        → Decision: i ≠ emptyIndex AND IsPalindrome(words[i])?  \n            Yes → Step 12: add (emptyIndex, i) to result // 空字串 + 其它回文  \n            Yes → Step 13: add (i, emptyIndex) to result // 其它回文 + 空字串  \n\nEnd // 空字串對應完成  \n\nDecision: 迭代每個單詞找所有可能的 palindrome pair  \n    Yes → Step 14: for i from 0 to n-1 do  \n        → Step 15: w ← words[i] // 目前單詞  \n        → Step 16: L ← length(w) // 單詞長度  \n        → Decision: 逐個分割位置 k 從 0 到 L  \n            Yes → Step 17: prefix ← substring(w, 0, k) // 前半部分  \n            → Step 18: suffix ← substring(w, k, L) // 後半部分  \n            → Decision: IsPalindrome(prefix)?  \n                Yes → Step 19: revSuffix ← reverse(suffix) // 對應後半倒序  \n                → Decision: revSuffix in reverseMap AND reverseMap[revSuffix] ≠ i?  \n                    Yes → Step 20: add (reverseMap[revSuffix], i) to result // (j, i)  \n            → Decision: k < L AND IsPalindrome(suffix)?  \n                Yes → Step 21: revPrefix ← reverse(prefix) // 對應前半倒序  \n                → Decision: revPrefix in reverseMap AND reverseMap[revPrefix] ≠ i?  \n                    Yes → Step 22: add (i, reverseMap[revPrefix]) to result // (i, j)  \n\nEnd // 所有單詞處理完畢  \n\n→ Step 23: return result // 回傳所有 palindrome pair  \nEnd // 程式執行結束"
    },
    {
      "title": "Maximum Length of Repeated Subarray",
      "source_file": "Leetcode/leetcode718.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef longest_common_subarray(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [0] * (n + 1)\n    max_len = 0\n    for i in range(1, m + 1):\n        for j in range(n, 0, -1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[j] = dp[j - 1] + 1\n                if dp[j] > max_len:\n                    max_len = dp[j]\n            else:\n                dp[j] = 0\n    return max_len\n\ndef parse_input(data):\n    parts = data.split('],')\n    nums = []\n    for part in parts:\n        start = part.find('[')\n        end = part.find(']', start)\n        if start == -1 or end == -1:\n            continue\n        segment = part[start+1:end]\n        nums.append([int(x) for x in re.findall(r'-?\\d+', segment)])\n    if len(nums) == 2:\n        return nums[0], nums[1]\n    # Fallback: if format differs, try to extract all ints and split roughly in half\n    all_ints = [int(x) for x in re.findall(r'-?\\d+', data)]\n    half = len(all_ints) // 2\n    return all_ints[:half], all_ints[half:]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n    nums1, nums2 = parse_input(data)\n    result = longest_common_subarray(nums1, nums2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for given problem: longest common subarray (max length of contiguous subarray present in both arrays). This is classic problem Leetcode 718. Approach: binary search on length, using hashing (rolling hash) or DP with O(n*m) but that's too slow. We can propose binary search + hash set: check if any subarray of length L appears in both arrays by hashing all subarrays of length L in nums1 into a set, then iterate subarrays of length L in nums2 and check existence. Use rolling hash (like Rabin-Karp) to compute hash in O(1) each.\n\nWe need to output steps, each line with explanation, using Start, End, Decision, arrow. We must be careful: we cannot output actual code, just pseudo steps. Each line must have \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe need to provide step by step pseudocode for this algorithm. Each line could be quite detailed. For example:\n\nStart // start\n→ Step 1: Define function longestCommonSubarray(nums1, nums2) // main function\n→ Step 2: Compute maxLen = min(len(nums1), len(nums2)) // upper bound for binary search\n→ Step 3: Set low = 0, high = maxLen // binary search range\n→ Decision: low <= high? // check loop condition\n  Yes → Step 4: mid = (low + high) // 2 // candidate length\n  → Step 5: If existsCommonSubarray(nums1, nums2, mid) then\n        Yes → low = mid + 1 // length possible, search higher\n        No  → high = mid - 1 // length not possible, search lower\n  No → End // binary search finished\n\nNow we need to define existsCommonSubarray with hashing.\n\nDefine existsCommonSubarray(nums1, nums2, L):\n    If L == 0: return True // empty subarray always exists\n    Compute base = 257, mod = 1e9+7\n    Compute power = base^(L-1) % mod // for rolling\n    → Step: Compute hash for first L elements of nums1\n    → Step: Add hash to set\n    → Step: For i from 1 to len(nums1)-L: update hash rolling, add to set\n    → Step: Compute hash for first L elements of nums2\n    → Step: Check if hash in set\n    → Step: For i from 1 to len(nums2)-L: update hash rolling, check if hash in set\n    → Step: Return True if found, else False\n\nWe need to produce each line with explanation. Let's structure as nested steps. Use indentation to show nested decisions but keep each line separate.\n\nWe should ensure each line has '虛擬碼步驟' like \"→ Step X:\".\n\nAlso, we need to incorporate arrow symbols like 'Yes →' 'No →' for decisions.\n\nLet's create pseudo steps:\n\nStart // 程式開始執行\n→ Step 1: 函數 longestCommonSubarray(nums1, nums2) // 定義主函數\n→ Step 2: 計算 maxLen = min(長度(nums1), 長度(nums2)) // 二分搜尋上界\n→ Step 3: 設定 low = 0, high = maxLen // 初始化二分搜尋範圍\n→ Decision: low <= high? // 判斷二分搜尋是否還有區間\n    Yes →\n        → Step 4: mid = (low + high) // 2 // 取中間長度\n        → Step 5: If existsCommonSubarray(nums1, nums2, mid) then // 判斷長度 mid 是否可行\n            Yes →\n                → Step 6: low = mid + 1 // 可行，往右邊查找更長\n            No  →\n                → Step 7: high = mid - 1 // 不可行，往左邊查找更短\n    No  →\n        → Step 8: Return high // high 為最大可行長度\nEnd // 程式執行結束\n\nNow define existsCommonSubarray function. Since we can't nest inside previous steps (just separate pseudo function). Use Start and End again.\n\n→ Step 9: 函數 existsCommonSubarray(nums1, nums2, L) // 檢查長度 L 的子陣列是否同時存在\n→ Step 10: If L == 0 then return True // 空子陣列總是存在\n→ Step 11: 定義 base = 257, mod = 1000000007 // 哈希基底與模數\n→ Step 12: 計算 power = base^(L-1) % mod // 用於移除最左邊元素的係數\n→ Step 13: 計算 nums1 前 L 個元素的哈希 hash1\n→ Step 14: 建立 set 哈希值集合 hashSet\n→ Step 15: 把 hash1 加入 hashSet\n→ Step 16: For i from 1 to len(nums1)-L:\n        → Step 17: 更新 hash1 = ((hash1 - nums1[i-1] * power) * base + nums1[i+L-1]) % mod // 滾動哈希\n        → Step 18: 把 hash1 加入 hashSet\n→ Step 19: 計算 nums2 前 L 個元素的哈希 hash2\n→ Step 20: If hash2 in hashSet then return True // 找到匹配\n→ Step 21: For i from 1 to len(nums2)-L:\n        → Step 22: 更新 hash2 = ((hash2 - nums2[i-1] * power) * base + nums2[i+L-1]) % mod\n        → Step 23: If hash2 in hashSet then return True // 匹配\n→ Step 24: Return False // 未找到匹配\n\nWe need to ensure each line is separate and includes explanation after //. The '→' arrow should precede each step except Start and End maybe. For nested decision, we use \"Yes →\" \"No →\". We should maintain consistent indentation but not required. Just each line separate.\n\nLet's produce final answer.\n\nWe need to use Chinese language for explanation: \"虛擬碼步驟\" etc. Also \"Start\" \"End\". We need to produce each line exactly: e.g.,\n\nStart // 程式開始執行\n\nWe should not output actual code but only pseudocode steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 函數 longestCommonSubarray(nums1, nums2) // 定義主函數  \n→ Step 2: 計算 maxLen = min(長度(nums1), 長度(nums2)) // 二分搜尋上界  \n→ Step 3: 設定 low = 0, high = maxLen // 初始化二分搜尋範圍  \n→ Decision: low <= high? // 判斷二分搜尋是否還有區間  \n Yes →  \n  → Step 4: mid = (low + high) // 2 // 取中間長度  \n  → Step 5: 如果 existsCommonSubarray(nums1, nums2, mid) then // 判斷長度 mid 是否可行  \n   Yes →  \n    → Step 6: low = mid + 1 // 可行，往右邊查找更長  \n   No →  \n    → Step 7: high = mid - 1 // 不可行，往左邊查找更短  \n No →  \n  → Step 8: 返回 high // high 為最大可行長度  \nEnd // 程式執行結束  \n\n→ Step 9: 函數 existsCommonSubarray(nums1, nums2, L) // 檢查長度 L 的子陣列是否同時存在  \n→ Step 10: 如果 L == 0 則 返回 True // 空子陣列總是存在  \n→ Step 11: 定義 base = 257, mod = 1000000007 // 哈希基底與模數  \n→ Step 12: 計算 power = base^(L-1) % mod // 用於移除最左邊元素的係數  \n→ Step 13: 計算 nums1 前 L 個元素的哈希 hash1 // 初始哈希  \n→ Step 14: 建立 hashSet // 儲存 nums1 的所有長度 L 子陣列哈希  \n→ Step 15: 把 hash1 加入 hashSet  \n→ Step 16: 從 i = 1 到 len(nums1)-L 迭代：  \n  → Step 17: 更新 hash1 = ((hash1 - nums1[i-1] * power) * base + nums1[i+L-1]) % mod // 滾動哈希  \n  → Step 18: 把 hash1 加入 hashSet  \n→ Step 19: 計算 nums2 前 L 個元素的哈希 hash2 // 初始哈希  \n→ Step 20: 如果 hash2 在 hashSet 中則 返回 True // 找到匹配  \n→ Step 21: 從 i = 1 到 len(nums2)-L 迭代：  \n  → Step 22: 更新 hash2 = ((hash2 - nums2[i-1] * power) * base + nums2[i+L-1]) % mod // 滾動哈希  \n  → Step 23: 如果 hash2 在 hashSet 中則 返回 True // 匹配  \n→ Step 24: 返回 False // 未找到匹配"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"Return all permutations of a list of distinct integers.\"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # append a copy of the current permutation\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap to place nums[i] at position start\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack: restore original order\n\n        backtrack(0)\n        return res\n\ndef parse_input(data):\n    \"\"\"Extract a list of integers from input such as 'nums = [1,2,3]'.\"\"\"\n    data = data.strip()\n    try:\n        l = data.index('[')\n        r = data.rindex(']')\n        return eval(data[l:r+1])\n    except ValueError:\n        # If the input is just a list literal, evaluate it directly\n        return eval(data)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating all permutations of an array of distinct integers. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". The code should be step-by-step: input array, maybe recursion or backtracking. So produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 permute(nums) // 主要入口\n→ Step 2: 初始化 result 為空陣列 // 儲存所有排列\n→ Decision: 如果 nums 為空? // 判斷是否已完成\n    Yes → Step 3: 回傳 result // 只剩一種排列\n    No  → Decision: 如果 nums 長度為 1? // 特殊處理\n        Yes → Step 4: 將 nums 直接加入 result // 單元素排列\n        No  → Step 5: for each index i in nums // 迭代每個元素\n            → Step 6: 取出 nums[i] 作為首元素\n            → Step 7: 創建剩餘陣列 remain = nums without i\n            → Step 8: 呼叫 permute(remain) 得到子排列\n            → Step 9: 對每個子排列 prepend 取出的元素，加入 result\n→ End // 程式結束\n\nBut we need arrow formatting: \"→\" for step lines, \"Decision:\" lines maybe with indentation. Also need \"Yes →\" \"No →\" with indentation. Provide explanation after //.\n\nLet's produce.\n\nWe need to keep each line separate. Use proper indentation for decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 permute(nums) // 主要入口，接受待排列的整數陣列  \n→ Step 2: 初始化 result 為空陣列 // 用於收集所有排列  \n→ Decision: 如果 nums 為空? // 判斷是否已經完成排列  \n    Yes → Step 3: 回傳 result // 空陣列只有一種排列，即空陣列本身  \n    No  → Decision: 如果 nums 長度為 1? // 特殊情況，只剩一個元素  \n        Yes → Step 4: 將 nums 直接加入 result // 把單元素陣列作為唯一排列  \n        No  → Step 5: 迭代遍歷 nums 的每個索引 i  \n            → Step 6: 取出 nums[i] 作為當前排列的首元素 // 固定首位  \n            → Step 7: 創建 remain = nums 刪除索引 i 的子陣列 // 準備剩餘元素  \n            → Step 8: 呼叫 permute(remain) 並取得子排列集合 subPerms // 進行遞迴  \n            → Step 9: 對 subPerms 中的每個子排列 p  \n                → Step 10: 將首元素 nums[i] + p 前綴並加入 result // 合併組成完整排列  \n→ End // 程式執行結束，結果已存於 result 中，並回傳給呼叫者"
    },
    {
      "title": "Sliding Window Maximum",
      "source_file": "Leetcode/leetcode239.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp73avmaey.py\", line 40, in <module>\n    exec(input_data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1,3,-1,-3,5,3,6,7], k = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprx_zn3mu.py\", line 40, in <module>\n    exec(input_data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1], k = 1\n    ^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        Return the maximum values of each sliding window of size k in the array nums.\n        Uses a deque to maintain indices of elements in decreasing order.\n        \"\"\"\n        if not nums or k == 0:\n            return []\n\n        deq = deque()      # stores indices of useful elements\n        res = []\n\n        for i, val in enumerate(nums):\n            # Remove indices that are out of the current window\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n\n            # Remove indices whose corresponding values are less than nums[i]\n            while deq and nums[deq[-1]] < val:\n                deq.pop()\n\n            # Add current index to the deque\n            deq.append(i)\n\n            # Once the first window is fully inside the array, start adding results\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin. Expected format:\n    # nums = [1, 3, -1, ...], k = 3\n    input_data = sys.stdin.read().strip()\n    local_vars = {}\n    # Execute the input string in a clean namespace to extract nums and k\n    exec(input_data, {}, local_vars)\n    nums = local_vars.get('nums', [])\n    k = local_vars.get('k', 0)\n\n    solution = Solution()\n    result = solution.maxSlidingWindow(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation after each. The requirement: use virtual code arrows and structure. We need to produce algorithm for sliding window maximum. We need to use typical approach with deque to maintain decreasing indices. We need to provide virtual steps.\n\nWe will output:\n\nStart\n→ Step: initialize deque empty\n→ Step: iterate i from 0 to n-1\n→ Decision: if deque front <= i-k? remove front // maintain window\n→ Step: while deque not empty and nums[deque back] <= nums[i], remove back // maintain decreasing order\n→ Step: push i to back\n→ Decision: if i >= k-1? add nums[deque front] to result // output max\nEnd\n\nExplain each.\n\nWe need to include the array input, k, output list. Provide comments. Must be structured. Use arrow →, Decision: etc.\n\nWe must not output real code.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化一個空的雙端佇列 (deque) // 用於存放滑動窗口內索引，保持數值遞減  \n→ Step: 建立空的結果陣列 res // 用於儲存每個窗口的最大值  \n→ Step: 取得陣列長度 n = nums.length  \n→ Step: 迭代 i 從 0 到 n-1 // 每個索引代表滑動窗口的右端位置  \n  Decision: 若 deque 前端索引 <= i - k? // 檢查是否已超出窗口左端  \n   Yes → Step: 移除 deque 前端 // 把已離開窗口的索引剔除  \n   No  →  // 不做任何事  \n  Decision: 若 deque 非空且 nums[deque 後端] <= nums[i]? // 比較新元素與佇列末端元素  \n   Yes → Step: 移除 deque 後端 // 保持佇列內的數值遞減，剔除較小的索引  \n   No  →  // 不做任何事  \n  Step: 將 i 推入 deque 後端 // 新索引加入窗口  \n  Decision: 若 i >= k-1? // 窗口已滿，開始輸出最大值  \n   Yes → Step: 將 nums[deque 前端] 加入 res // deque 前端存的是窗口內最大值的索引  \n   No  →  // 窗口還未滿，暫不輸出  \nEnd // 程式執行結束，res 為所有滑動窗口的最大值陣列"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmperr4e2mj.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmperr4e2mj.py\", line 50, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdlksnak0.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpdlksnak0.py\", line 50, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp82z7pek9.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmp82z7pek9.py\", line 50, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # build the line\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\n\ndef main():\n    # Read the whole input. The input format is expected to be:\n    # words = [...], maxWidth = X\n    data = sys.stdin.read()\n    # Execute the input in a local namespace to retrieve words and maxWidth\n    local_vars = {}\n    exec(data, {}, local_vars)\n    words = local_vars['words']\n    maxWidth = local_vars['maxWidth']\n\n    solution = Solution()\n    result = solution.fullJustify(words, maxWidth)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: text justification. Provide steps. Ensure each line includes \"→ Step X:\" etc. We can structure: Start, loop over words, group into line, calculate spaces, build string, add to result, continue. Provide explanation. Ensure no real code. Use \"→\" for transitions. Use Decision: for condition checks. Use \"Yes →\" \"No →\" style.\n\nLet's produce. We'll include Step numbers, but not necessary. Just steps. We'll ensure each line has explanation comment. Use Start/End. Use Decision nodes.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 lines ← 空列表 // 用來存放每一行的文字\n→ Step 2: 初始化索引 i ← 0 // i 用於遍歷 words\n→ Decision: i 是否小於 words 的長度？ // 判斷是否還有未處理的單字\n    Yes → Step 3: 設定 line_start ← i // 記錄當前行的第一個單字索引\n    → Step 4: 計算 line_len ← words[i].長度 // line_len 為行中單字的總長度\n    → Step 5: 設定 j ← i + 1 // j 用於尋找能放入同一行的後續單字\n    → Decision: j 是否小於 words 長度且 line_len + 1 + words[j].長度 ≤ maxWidth？ // 判斷下一個單字是否能加入行\n        Yes → Step 6: line_len ← line_len + 1 + words[j].長度 // 加入單字長度和至少一個空格\n        → Step 7: j ← j + 1 // 移動到下一個單字\n        → Decision: j 是否小於 words 長度且 line_len + 1 + words[j].長度 ≤ maxWidth？ // 重複檢查直到無法再加入\n            Yes → Step 6 重複 // (回到 Step 6)\n            No  → Step 8: 確定行結束於 j-1 // j-1 是最後一個能放入行的單字索引\n    No  → Step 8 重複 // (回到 Step 8)\n→ Step 9: 生成行字串 line ← words[line_start] // 先放第一個單字\n→ Decision: j - line_start 是否等於 1？ // 判斷是否只有一個單字\n    Yes → Step 10: line ← line + (maxWidth - words[line_start].長度) 個空格 // 將剩餘空格填充到行尾\n    No  → Step 11: 計算 total_space ← maxWidth - line_len + (j - line_start - 1) // total_space 為需要插入的空格總數\n    → Step 12: 計算 gaps ← j - line_start - 1 // gaps 為單字之間的空格槽數\n    → Step 13: 計算 space_per_gap ← total_space ÷ gaps // 每個空格槽的基本空格數\n    → Step 14: 計算 extra_spaces ← total_space mod gaps // 需要多餘空格的槽數\n    → Step 15: 從 line_start 到 j-2（倒數第二個單字）循環\n        → Step 16: line ← line + words[k] + (space_per_gap + (k - line_start < extra_spaces ? 1 : 0)) 個空格 // 為每個空格槽加基本空格，左側槽多加一個\n    → Step 17: line ← line + words[j-1] // 加上最後一個單字\n→ Decision: 是否是最後一行？ // j == words 的長度\n    Yes → Step 18: 將行右側填充空格直到 maxWidth // 以左對齊結束\n    No  → Step 19: 保持已構造好的行\n→ Step 20: 把 line 加入 lines 列表 // 這行已完成\n→ Step 21: i ← j // 設定下一行的起始索引\n→ Decision: i 是否小於 words 的長度？ // 循環至所有單字處理完畢\n    Yes → 回到 Step 3\n    No  → End // 程式執行結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0v0obn6i.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmp0v0obn6i.py\", line 57, in main\n    args = json.loads(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 34 (char 33)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用於存放所有元素的列表\n        self.data = []\n        # value -> set of indices where value occurs in self.data\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，返回此值是否第一次出現\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，若存在則返回 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 從 idx_map[val] 中取任意索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 若被刪除的不是最後一個元素，則把最後一個元素覆蓋到 remove_idx\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個元素\n        self.data.pop()\n\n        # 若此值已無其他實例，從字典中刪除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"返回隨機元素（概率與元素個數成正比）\"\"\"\n        return random.choice(self.data)\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 分離兩個列表：操作名列表和對應參數列表\n    ops_part, args_part = raw_input.split('],', 1)\n    ops_part += ']'\n    args_part = '[' + args_part.strip()\n    ops = json.loads(ops_part)\n    args = json.loads(args_part)\n\n    results = []\n    collection = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            collection = RandomizedCollection()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(collection.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(collection.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(collection.getRandom())\n        else:\n            # 若遇到未知操作，直接加入 None\n            results.append(None)\n\n    # 輸出結果，使用 JSON 形式以符合預期格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output a step-by-step pseudo-code that describes the algorithm, using Start, End, Decision. We must not output actual code, just pseudo-code steps. Each line with arrow \"→\" and then description. Should explain each step. Probably we need to outline entire implementation of class, including data structures: array/list, hashmap value->set of indices. Steps for constructor, insert, remove, getRandom. Use decision nodes. Provide explanation after each step. Should not include actual code. Just pseudo-code lines. So produce a sequence of steps describing the logic.\n\nWe need to show how to maintain mapping from value to set of indices. Use array list to hold elements. On insert: append to array, add index to map set. Return true if set was empty before insertion. For remove: check map if empty. If not, get an arbitrary index from set. Remove that index from set. If index is not last, swap last element into that index, update mapping for that last element. Then pop last element from array. Return true. For getRandom: generate random index in array and return element.\n\nWe need to produce a structured pseudo-code with decisions and actions. Use arrow. For each line, after arrow and step, we add comment // explanation. Must follow format. Use Start and End.\n\nLet's craft.\n\nStart\n→ Step 1: 初始化 空的數組 Elements // 用於存放所有元素\n→ Step 2: 初始化 空的映射 IndexMap // value → 集合(索引)\n→ Step 3: 定義 隨機數產生器 RandGen // 生成隨機索引\n\nInsert(val)\n→ Step 4: 在 Elements 尾部添加 val // 把新值加入數組\n→ Step 5: 將新索引 (Elements.size-1) 添加到 IndexMap[val] // 更新索引集合\n→ Decision: IndexMap[val] 的大小 是否為 1? // 判斷此值是否首次出現\n    Yes → Step 6: 返回 true // 首次插入\n    No  → Step 7: 返回 false // 已存在\n\nRemove(val)\n→ Decision: IndexMap[val] 是否為空? // 檢查值是否存在\n    Yes → Step 8: 返回 false // 無此元素，無法移除\n    No  → Step 9: 取得 IndexMap[val] 中任意索引 idx // 選取一個待刪元素的索引\n        → Step 10: 取得最後元素 lastVal = Elements.back() // 取數組最後一項\n        → Step 11: 取得最後索引 lastIdx = Elements.size - 1 // 最後元素索引\n        → Decision: idx 是否等於 lastIdx? // 判斷待刪元素是否為最後一項\n            Yes → Step 12: 從 Elements 刪除最後一項 // 直接刪除\n            No  → Step 13: 替換 Elements[idx] = lastVal // 用最後元素覆蓋待刪位置\n                → Step 14: 在 IndexMap[lastVal] 中將 lastIdx 移除 // 移除舊索引\n                → Step 15: 在 IndexMap[lastVal] 中加入 idx // 新索引\n                → Step 16: 從 Elements 刪除最後一項 // 完成移除\n        → Step 17: 在 IndexMap[val] 中移除 idx // 移除被刪元素的索引\n        → Decision: IndexMap[val] 是否為空? // 檢查是否還有此值的其他實例\n            Yes → Step 18: 從 IndexMap 中刪除 key val // 若無剩餘實例，移除映射條目\n        → Step 19: 返回 true // 成功移除一個實例\n\nGetRandom()\n→ Step 20: 生成隨機整數 r 在 [0, Elements.size-1] 之間 // 隨機索引\n→ Step 21: 返回 Elements[r] // 回傳隨機選取的元素\n\nEnd\n\nNeed to maintain comments. Should each step be one line? Yes. But we have to show indentation? The example uses indent for nested steps. Use spaces. Provide \"→\" arrow for each step. Use \"Decision:\" line with indent, then \"Yes →\" and \"No →\" lines with indent.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 空的數組 Elements // 用於存放所有元素  \n→ Step 2: 初始化 空的映射 IndexMap // value → 集合(索引)  \n→ Step 3: 定義 隨機數產生器 RandGen // 生成隨機索引  \n\nInsert(val)  \n→ Step 4: 在 Elements 尾部添加 val // 把新值加入數組  \n→ Step 5: 將新索引 (Elements.size-1) 添加到 IndexMap[val] // 更新索引集合  \n→ Decision: IndexMap[val] 的大小 是否為 1? // 判斷此值是否首次出現  \n  Yes → Step 6: 返回 true // 首次插入，返回 true  \n  No  → Step 7: 返回 false // 已存在，返回 false  \n\nRemove(val)  \n→ Decision: IndexMap[val] 是否為空? // 檢查值是否存在  \n  Yes → Step 8: 返回 false // 無此元素，無法移除  \n  No  → Step 9: 取得 IndexMap[val] 中任意索引 idx // 選取一個待刪元素的索引  \n   → Step 10: 取得最後元素 lastVal = Elements.back() // 取數組最後一項  \n   → Step 11: 取得最後索引 lastIdx = Elements.size - 1 // 最後元素索引  \n   → Decision: idx 是否等於 lastIdx? // 判斷待刪元素是否為最後一項  \n    Yes → Step 12: 從 Elements 刪除最後一項 // 直接刪除  \n    No  → Step 13: 替換 Elements[idx] = lastVal // 用最後元素覆蓋待刪位置  \n      → Step 14: 在 IndexMap[lastVal] 中將 lastIdx 移除 // 移除舊索引  \n      → Step 15: 在 IndexMap[lastVal] 中加入 idx // 新索引  \n      → Step 16: 從 Elements 刪除最後一項 // 完成移除  \n   → Step 17: 在 IndexMap[val] 中移除 idx // 移除被刪元素的索引  \n   → Decision: IndexMap[val] 是否為空? // 檢查是否還有此值的其他實例  \n    Yes → Step 18: 從 IndexMap 中刪除 key val // 若無剩餘實例，移除映射條目  \n   → Step 19: 返回 true // 成功移除一個實例  \n\nGetRandom()  \n→ Step 20: 生成隨機整數 r 在 [0, Elements.size-1] 之間 // 隨機索引  \n→ Step 21: 返回 Elements[r] // 回傳隨機選取的元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3bd9qv6r.py\", line 52, in main\n    params = ast.literal_eval(dict_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x777a07027290>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp3bd9qv6r.py\", line 70, in <module>\n    main()\n  File \"/tmp/tmp3bd9qv6r.py\", line 59, in main\n    params[key.strip()] = ast.literal_eval(val.strip())\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"AACCGGTA\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list[str]) -> int:\n        \"\"\"\n        使用 BFS 求從 start 轉變為 end 所需的最少突變步數。\n        若 end 不在 bank，直接返回 -1。\n        \"\"\"\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])   # (目前基因, 已完成突變數)\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            # 產生所有可能的單字突變\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n\n        # 若無法到達目標\n        return -1\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入格式：\n    startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    或者多行分隔的相同格式。\n    解析後呼叫 Solution.minMutation 並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試把輸入轉成字典\n    try:\n        # 將「=」改成「:」以符合 dict 语法，並包裝成大括號\n        dict_str = \"{\" + data.replace(\"=\", \":\") + \"}\"\n        params = ast.literal_eval(dict_str)\n    except Exception:\n        # 若上述失敗，逐段手動解析\n        params = {}\n        for part in data.split(\",\"):\n            if \"=\" in part:\n                key, val = part.split(\"=\", 1)\n                params[key.strip()] = ast.literal_eval(val.strip())\n\n    start = params.get(\"startGene\") or params.get(\"startgene\") or \"\"\n    end = params.get(\"endGene\") or params.get(\"endgene\") or \"\"\n    bank = params.get(\"bank\") or []\n\n    sol = Solution()\n    result = sol.minMutation(start, end, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described problem: find minimum mutations from startGene to endGene using BFS on graph of gene strings where edges connect if differ by one character and node exists in bank. Return min steps else -1. Provide step by step lines with explanation. Use arrow style. So start, define steps: convert bank to set, visited set, queue for BFS. Use BFS loop. At each level, increment depth. When found endGene return depth. If queue empty return -1. Should mention early check if endGene not in bank then return -1. Provide pseudocode lines. Use structure: Start, Decision, Step. Provide explanation after each line. Let's craft.\n\nWe need to be careful: The algorithm is BFS. Steps: convert bank to set. If endGene not in bank return -1. Initialize queue with startGene, depth 0. Mark visited. While queue not empty: size=queue length; for i in range size: pop; if node==endGene return depth; else generate all mutations: for each position 0..7, for each char in 'ACGT', if new != old, new string. If new in bank set and not visited: enqueue, mark visited. After processing level, depth++.\n\nReturn -1 if loop ends. End.\n\nAdd Start, Decision etc. Use virtual arrows. Provide explanation.\n\nLet's craft output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: bankSet ← Set(bank) // 把基因庫轉成集合，方便 O(1) 查找  \n→ Decision: 是否 endGene 存在於 bankSet? // 若目標基因不在合法集合，無法完成轉換  \n    Yes → Step 2: queue ← [(startGene, 0)] // 初始化 BFS，元素為 (基因, 已經做的突變數)  \n    No  → Step 3: return -1 // 直接回傳失敗，因為目標基因不合法  \n→ Step 4: visited ← {startGene} // 記錄已經探索過的基因，避免重複  \n→ Decision: queue 是否為空? // 若已無可探索的基因，則結束  \n    Yes → Step 5: return -1 // 所有可行路徑都已探索完畢，找不到目標  \n    No  → Step 6: current, dist ← queue.pop_front() // 取出最早進入佇列的基因及其距離  \n→ Decision: current 是否等於 endGene? // 檢查是否已到達目標  \n    Yes → Step 7: return dist // 找到最短突變步驟，直接回傳  \n    No  → Decision: 進行所有可能的單字突變? // 生成相鄰基因  \n        Yes → Step 8: for i in 0..7: // 逐個位置  \n        → Step 9: for ch in ['A','C','G','T']: // 四種可能字母  \n        → Decision: ch 是否等於 current[i]? // 不允許重複相同字母  \n            Yes → Step 10: continue // 跳過，避免產生相同基因  \n            No  → Step 11: newGene ← current[0:i] + ch + current[i+1:] // 產生新基因  \n            → Decision: newGene 是否在 bankSet 且未訪問? // 必須合法且未探索  \n                Yes → Step 12: queue.append((newGene, dist + 1)) // 加入佇列並遞增距離  \n                No  → Step 13: continue // 跳過無效或已訪問的基因  \n        → Step 14: visited.add(newGene) // 標記為已訪問，避免重複進入  \n    → Step 15: queue ← queue // 回到最外層 while，繼續處理下一個層級  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (invert values)\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse the two lists from the input\n    try:\n        # The input format is like: [\"cmd1\", \"cmd2\"], [[arg1], [arg2], ...]\n        cmds, args = json.loads('[' + data + ']')\n    except Exception:\n        # Fallback: input may be split into two lines\n        lines = data.splitlines()\n        cmds = json.loads(lines[0])\n        args = json.loads(lines[1])\n\n    result = []\n    mf = None\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            mf.addNum(arg[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            result.append(mf.findMedian())\n\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for MedianFinder class using typical approach: two heaps max-heap left and min-heap right. Steps: initialization, addNum, findMedian. Use decision structures. Need to output line by line with pseudo-code arrow etc.\n\nWe need to describe the algorithm. Provide step by step.\n\nLet's craft.\n\nStart\n→ Step: Define class MedianFinder\n→ Step: 初始化兩個堆: 左堆(max) left, 右堆(min) right\n→ Step: addNum(num)\n    → Decision: 左堆是否為空? or num <= 左堆頂?\n        Yes → 左堆加入 num\n        No  → 右堆加入 num\n    → Decision: 左堆大小是否 > 右堆大小 + 1? // 左堆多一個元素\n        Yes → 右堆頂移除並加入左堆\n        No  → Decision: 右堆大小 > 左堆大小? // 右堆多一個元素\n            Yes → 左堆頂移除並加入右堆\n            No  → Do nothing\n→ Step: findMedian()\n    → Decision: 左堆大小 == 右堆大小?\n        Yes → 返回 (左堆頂 + 右堆頂)/2\n        No  → 返回 左堆頂 // 左堆長一個\nEnd\n\nWe need to show each line with arrow and explanation comment. Also need to use arrow syntax like \"→\".\n\nLet's produce lines.\n\nWill also include Start/End tags.\n\nLet's craft each line.\n\nProbably need indentation but maintain line breaks.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Class MedianFinder // 定義 MedianFinder 類別\n→   Step 1: 初始化左堆 left 為最大堆, 右堆 right 為最小堆 // 準備兩個優先隊列\n→   Step 2: addNum(num) // 增加新數字\n→     → Decision: left 為空 或 num <= left.top? // 判斷應插入左堆\n→       Yes → left.push(num) // 插入左堆\n→       No  → right.push(num) // 插入右堆\n→     → Decision: left.size > right.size + 1? // 左堆太多\n→       Yes → right.push(left.top()); left.pop(); // 右堆多一個\n→       No  → Decision: right.size > left.size? // 右堆太多\n→         Yes → left.push(right.top()); right.pop(); // 左堆多一個\n→         No  → // 平衡已滿\n→   Step 3: findMedian() // 計算中位數\n→     → Decision: left.size == right.size? // 堆大小相等\n→       Yes → return (left.top + right.top)/2.0 // 兩中位數平均\n→       No  → return left.top; // 左堆長一個，取左堆頂\nEnd // 程式結束\n\nBut we need \"虛擬碼步驟\" followed by space then comment. Each line is separate. Need to use arrow and maybe indentation.\n\nAlso \"Start\" and \"End\" lines should follow same pattern: \"Start // 程式開始執行\" etc.\n\nOk produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MedianFinder // 定義 MedianFinder 類別  \n→   Step 1: 初始化左堆 left 為最大堆，右堆 right 為最小堆 // 準備兩個優先隊列  \n→   Step 2: addNum(num) // 新增數字  \n→     → Decision: left 為空 或 num <= left.top? // 判斷是否插入左堆  \n→       Yes → left.push(num) // 插入左堆  \n→       No  → right.push(num) // 插入右堆  \n→     → Decision: left.size > right.size + 1? // 左堆太多  \n→       Yes → right.push(left.top()); left.pop(); // 右堆多一個，平衡堆大小  \n→       No  → Decision: right.size > left.size? // 右堆太多  \n→         Yes → left.push(right.top()); right.pop(); // 左堆多一個，平衡堆大小  \n→         No  → // 堆已平衡，無需處理  \n→   Step 3: findMedian() // 計算目前中位數  \n→     → Decision: left.size == right.size? // 堆大小相等  \n→       Yes → return (left.top + right.top)/2.0 // 兩個中位數平均  \n→       No  → return left.top; // 左堆長一個，取左堆頂作中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\n# ---------- 主要解法 ----------\ndef solve(board: str, hand: str) -> int:\n    COLORS = ('R', 'Y', 'B', 'G', 'W')\n\n    # 把手中的球轉成各色個數的 tuple，方便哈希\n    hand_counts = [hand.count(c) for c in COLORS]\n    hand_tuple = tuple(hand_counts)\n\n    INF = 10 ** 9  # 代表無法解\n\n    # ---------- 連續相同顏色自動消除 ----------\n    def clean(s: str) -> str:\n        stack = []\n        for ch in s:\n            if stack and stack[-1][0] == ch:\n                stack[-1][1] += 1\n                if stack[-1][1] >= 3:\n                    stack.pop()\n            else:\n                stack.append([ch, 1])\n        return ''.join(ch * cnt for ch, cnt in stack)\n\n    # ---------- 以遞迴 + memo 解最小插入 ----------\n    @lru_cache(maxsize=None)\n    def dfs(cur_board: str, cur_hand: tuple) -> int:\n        if not cur_board:\n            return 0\n        if all(c == 0 for c in cur_hand):\n            return INF\n\n        best = INF\n        n = len(cur_board)\n        i = 0\n        while i < n:\n            j = i\n            while j + 1 < n and cur_board[j + 1] == cur_board[i]:\n                j += 1\n            seg_len = j - i + 1\n            color = cur_board[i]\n            idx = COLORS.index(color)\n            need = max(0, 3 - seg_len)\n\n            # 如果已能消除\n            if need == 0:\n                new_board = clean(cur_board[:i] + cur_board[j + 1:])\n                res = dfs(new_board, cur_hand)\n                if res < INF:\n                    best = min(best, res)\n            else:\n                # 需要插入球才能消除\n                if cur_hand[idx] >= need:\n                    new_hand = list(cur_hand)\n                    new_hand[idx] -= need\n                    new_board = clean(cur_board[:i] + cur_board[j + 1:])\n                    res = dfs(new_board, tuple(new_hand))\n                    if res < INF:\n                        best = min(best, res + need)\n            i = j + 1\n\n        return best\n\n    ans = dfs(board, hand_tuple)\n    return -1 if ans >= INF else ans\n\n# ---------- 主程式 ----------\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 解析形如 board = \"WRRBBW\", hand = \"RB\"\n    m = re.search(r'board\\s*=\\s*\"([^\"]*)\"\\s*,\\s*hand\\s*=\\s*\"([^\"]*)\"', data)\n    if not m:\n        # 若輸入格式不同，嘗試按行拆分\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        board = \"\"\n        hand = \"\"\n        for line in lines:\n            if line.startswith(\"board\"):\n                board = line.split('=')[1].strip().strip('\"')\n            elif line.startswith(\"hand\"):\n                hand = line.split('=')[1].strip().strip('\"')\n    else:\n        board = m.group(1)\n        hand = m.group(2)\n\n    result = solve(board, hand)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve this problem, in structured pseudocode with explanations. Should be line-by-line with arrow. We need algorithm: typical Zuma problem. Use DFS/backtracking with state as board string and hand counts. Use recursion and memoization. Steps: Define function minInsert(board, handCount) returns min steps or INF. If board empty -> 0. If hand empty -> INF. For each unique ball color in hand >0, try to insert between same color groups to form >=3. Or consider merging adjacent groups: find segments. For each position, check possibility: find i..j of same color, if len + 1 >=3, remove and recursively solve. Also consider using multiple balls to make group. Standard solution: iterate over board, find segments of same color. For each segment, if need >0 to clear, check hand count. If can use, then recursively call with new board after removal and updated hand. Keep track min. Use memoization on board+hand string.\n\nWe'll produce pseudocode steps. Ensure each line has arrow and explanation. We'll structure: Start, call main, define DFS, recursion logic, base cases, loop over segments, attempt removal, update hand, recursion, memoization, etc. Use Decision structures.\n\nLet's produce lines. Use arrows \"→\". Provide explanation after //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Call Main // 執行主流程  \n→ Step 1: Convert hand string to count map of colors // 將手中球轉成各顏色個數映射  \n→ Step 2: result ← DFS(board, handCount) // 呼叫遞迴解法得到最少插入數  \n→ Decision: 如果 result 為 INF? // 判斷是否無法完成  \n    Yes → Step 3: Return -1 // 無法清除全部球，回傳 -1  \n    No  → Step 4: Return result // 有解，回傳最少插入數  \nEnd // 程式執行結束  \n\nStep 1: Define DFS(board, handCount) → Recursive function to compute min insertions  \n→ Decision: 如果 board 為空? // 檢查棋盤是否已清空  \n    Yes → Step 5: Return 0 // 已清空，無需插入  \n    No  → Decision: 如果 handCount 所有值為 0? // 手中沒有球  \n        Yes → Step 6: Return INF // 無法再行動，視為無解  \n        No  → Step 7: Continue // 有球可用，進行下一步  \n\nStep 8: MemoKey ← board + \"#\" + sorted handCount // 產生可哈希的狀態鍵  \n→ Decision: 如果 MemoKey 已存在於 memo? // 檢查是否已計算  \n    Yes → Step 9: Return memo[MemoKey] // 直接回傳已知結果  \n    No  → Step 10: Initialize best ← INF // 設定目前最佳答案為無限大  \n\nStep 11: // 將 board 轉成相同顏色連續區塊的形式  \n→ For i = 0 to board.length-1  \n    → Track start = i  \n    → While i+1 < board.length and board[i+1] == board[start]  \n        → i++ // 找到同色區塊的結束位置  \n    → len = i - start + 1 // 這個區塊長度  \n    → color = board[start] // 區塊顏色  \n    → need = 3 - len // 需要額外插入的球數才能消除  \n\n    → Decision: 如果 need <= 0? // 已能直接消除  \n        Yes → // 直接消除此區塊，無需插入  \n            → newBoard ← board[0:start] + board[i+1:end] // 去掉此區塊  \n            → recursionResult ← DFS(newBoard, handCount) // 重新計算  \n            → best ← min(best, recursionResult) // 更新最佳答案  \n        No  → // 需要插入球  \n            → Decision: 如果 handCount[color] >= need? // 手中有足夠球  \n                Yes → // 使用需要的球來消除  \n                    → newHand ← handCount  \n                    → newHand[color] -= need // 消耗球  \n                    → newBoard ← board[0:start] + board[i+1:end] // 去掉區塊  \n                    → recursionResult ← DFS(newBoard, newHand) // 重新計算  \n                    → If recursionResult != INF  \n                        → best ← min(best, recursionResult + need) // 加上插入數  \n                No  → // 不能消除此區塊，繼續嘗試下一個區塊  \n                    → Continue  \n\n    → i++ // 移動到下一個區塊開始位置  \n\nStep 12: memo[MemoKey] ← best // 記錄此狀態的最佳答案  \n→ Step 13: Return best // 回傳最小插入數  \n\nStep 5: // Base case: board empty, no more insertion needed  \nStep 6: // Base case: no balls left, impossible  \nStep 7: // Continue searching  \nStep 9: // Retrieve cached result  \nStep 10: // Initialize best to a large number  \nStep 11: // Explore each same-color segment  \nStep 13: // Return computed minimal value or INF if impossible"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxhl8vuzg.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpxhl8vuzg.py\", line 37, in main\n    matrix, k = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxhl8vuzg.py\", line 31, in parse_input\n    matrix = ast.literal_eval(mat_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,5,9]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz83g6fg8.py\", line 42, in <module>\n    main()\n  File \"/tmp/tmpz83g6fg8.py\", line 37, in main\n    matrix, k = parse_input(data)\n                ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpz83g6fg8.py\", line 31, in parse_input\n    matrix = ast.literal_eval(mat_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[-5]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low, high = matrix[0][0], matrix[-1][-1]\n    while low < high:\n        mid = (low + high) // 2\n        count = 0\n        row, col = n - 1, 0\n        # count how many elements are <= mid\n        while row >= 0 and col < n:\n            if matrix[row][col] <= mid:\n                count += row + 1\n                col += 1\n            else:\n                row -= 1\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\ndef parse_input(data):\n    # Extract the matrix and k from the input string\n    mat_match = re.search(r'matrix\\s*=\\s*(\\[[\\s\\S]*?\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not mat_match or not k_match:\n        raise ValueError(\"Invalid input format\")\n    matrix = ast.literal_eval(mat_match.group(1))\n    k = int(k_match.group(1))\n    return matrix, k\n\ndef main():\n    data = sys.stdin.read()\n    matrix, k = parse_input(data)\n    result = kth_smallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for finding kth smallest in sorted matrix, n x n, sorted rows and columns ascending. Use binary search on value range, counting <= mid. Memory O(n). Provide steps with Start, End, Decision, Yes/No arrows. Provide line-by-line. Ensure not actual code. Use explanation after //.\n\nLet's craft.\n\nSteps:\n\nStart\n→ Define low = matrix[0][0], high = matrix[n-1][n-1] // bounds of values\n→ While low < high:\n    → mid = (low+high)/2 // middle value\n    → count = 0 // initialize count\n    → row = n-1 // start from bottom-left\n    → col = 0\n    → While row >=0 and col < n:\n        → If matrix[row][col] <= mid:\n            → count += row+1 // all elements in this column up to row are <= mid\n            → col += 1 // move right\n        → Else:\n            → row -=1 // move up\n    → Decision: If count >= k? // enough elements <= mid\n        Yes → high = mid // kth could be <= mid\n        No → low = mid +1 // kth greater\nEnd // low == high -> kth smallest\n\nReturn low\n\nBut we need to output virtual code lines, each with explanation.\n\nAlso we must ensure no actual code. Use pseudo steps.\n\nWe might also need to incorporate reading input. But not necessary.\n\nWe'll produce line by line.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 low = matrix[0][0], high = matrix[n-1][n-1] // 確定搜尋範圍的最小值與最大值\n\n→ Decision: while low < high? // 若仍有多個可能值需要判斷\n\n    Yes →\n\n        → Step 2: 計算 mid = (low + high) // 2 // 取得目前範圍的中間值\n\n        → Step 3: 初始化 count = 0, row = n-1, col = 0 // 計數器與游標設定\n\n        → Decision: while row >= 0 and col < n? // 逐行逐列遍歷矩陣\n\n            Yes →\n\n                → Decision: matrix[row][col] <= mid? // 判斷當前元素是否小於等於 mid\n\n                    Yes →\n\n                        → Step 4: count += row + 1 // 這一列所有元素到此列下標都 <= mid\n\n                        → Step 5: col += 1 // 移動到下一列\n\n                    No →\n\n                        → Step 6: row -= 1 // 移動到上一行\n\n            No → // 完成一次 count 計算\n\n        → Decision: count >= k? // 判斷目前已經有足夠元素小於等於 mid\n\n            Yes →\n\n                → Step 7: high = mid // kth 最小值一定 <= mid，縮小上限\n\n            No →\n\n                → Step 8: low = mid + 1 // kth 最小值 > mid，縮小下限\n\n    No → // while 結束，low == high\n\nEnd // low 即為第 k 個最小元素\n\nWe need to also include final return maybe.\n\nLet's add after End? But End indicates program finished. The return value is low. Might add \"→ Step 9: 回傳 low\" before End. But end already indicates finished. We can include as a step before End.\n\nLet's produce final code.\n\nLet's ensure each line is like \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's produce with proper indentation? Not required but nice.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low = matrix[0][0], high = matrix[n-1][n-1] // 確定搜尋範圍的最小值與最大值  \n→ Decision: while low < high? // 若仍有多個可能值需要判斷  \n Yes →  \n  → Step 2: 計算 mid = (low + high) // 2 // 取得目前範圍的中間值  \n  → Step 3: 初始化 count = 0, row = n-1, col = 0 // 計數器與游標設定  \n  → Decision: while row >= 0 and col < n? // 逐行逐列遍歷矩陣  \n   Yes →  \n    → Decision: matrix[row][col] <= mid? // 判斷當前元素是否小於等於 mid  \n     Yes →  \n      → Step 4: count += row + 1 // 這一列所有元素到此列下標都 <= mid  \n      → Step 5: col += 1 // 移動到下一列  \n     No →  \n      → Step 6: row -= 1 // 移動到上一行  \n   No → // 完成一次 count 計算  \n  → Decision: count >= k? // 判斷目前已經有足夠元素小於等於 mid  \n   Yes →  \n    → Step 7: high = mid // kth 最小值一定 <= mid，縮小上限  \n   No →  \n    → Step 8: low = mid + 1 // kth 最小值 > mid，縮小下限  \n No → // while 結束，low == high  \n→ Step 9: 回傳 low // low 為第 k 個最小元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"返回兩個列表的交集，每個元素出現次數以兩者最小出現次數決定。\"\"\"\n        # 建立第一個列表的頻率表\n        freq1 = {}\n        for num in nums1:\n            freq1[num] = freq1.get(num, 0) + 1\n\n        # 遍歷第二個列表，若元素在 freq1 中存在則加入結果並減少頻率\n        result = []\n        for num in nums2:\n            if freq1.get(num, 0) > 0:\n                result.append(num)\n                freq1[num] -= 1\n        return result\n\ndef parse_input(text):\n    \"\"\"從輸入文字中提取 nums1 與 nums2 的兩個列表。\"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[.*?\\])', text, re.S)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[.*?\\])', text, re.S)\n    if not nums1_match or not nums2_match:\n        return [], []\n    # 使用 literal_eval 以安全方式解析列表字面量\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    # 讀取全部標準輸入\n    raw_input = sys.stdin.read()\n    nums1, nums2 = parse_input(raw_input)\n    # 計算交集\n    solution = Solution()\n    intersection = solution.intersect(nums1, nums2)\n    # 輸出結果\n    print(intersection)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. Let's design steps: Start, create map for nums1 frequencies, iterate nums2 and reduce. Use array result. End.\n\nNeed to use arrow and Decision.\n\nLet's produce: \nStart\n→ Step 1: 建立 hash map freq1 // 將 nums1 中每個數字的出現次數存入字典\n→ Step 2: 初始化空陣列 result // 用於儲存交集元素\n→ Step 3: 遍歷 nums2 // 對每個 nums2 中的元素進行處理\n    → Decision: freq1[元素] 是否大於 0? // 檢查該元素在 nums1 中是否仍有剩餘次數\n        Yes → Step 4: 將元素加入 result // 交集加入結果\n        Yes → Step 5: 將 freq1[元素] 減 1 // 消耗一次出現次數\n        No → // 不做任何事，因為此元素不在交集中\n→ Step 6: 回傳 result // 輸出交集\nEnd\n\nEnsure each line has virtual code + comment. Use arrow \"→\". For Decision branch indent maybe with tab or spaces. Provide each line separately.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 hash map freq1 // 將 nums1 中每個數字的出現次數存入字典  \n→ Step 2: 初始化空陣列 result // 用於儲存交集元素  \n→ Step 3: 遍歷 nums2 // 對每個 nums2 中的元素進行處理  \n  Decision: freq1[元素] 是否大於 0? // 檢查該元素在 nums1 中是否仍有剩餘次數  \n   Yes → Step 4: 將元素加入 result // 交集加入結果  \n   Yes → Step 5: 將 freq1[元素] 減 1 // 消耗一次出現次數  \n   No  → // 不做任何事，因為此元素不在交集中  \n→ Step 6: 回傳 result // 輸出交集  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        # List of disjoint, sorted intervals [l, r)\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        inserted = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not inserted:\n                    new_ranges.append([left, right])\n                    inserted = True\n                new_ranges.append([l, r])\n            else:  # overlapping\n                left = min(left, l)\n                right = max(right, r)\n        if not inserted:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        # Find the first interval that starts after left\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        # Check if the interval at i-1 covers [left, right)\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:  # overlap\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\ndef parse_numbers(arg_str: str):\n    return [int(x.strip()) for x in arg_str.split(',')]\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    module = None\n    outputs = []\n\n    for raw_line in lines:\n        line = raw_line.strip()\n        if not line:\n            continue\n        line = line.rstrip(';')\n\n        if 'RangeModule' in line:\n            module = RangeModule()\n            outputs.append(None)\n            continue\n\n        if line.startswith('rangeModule.addRange'):\n            idx1 = line.find('(')\n            idx2 = line.rfind(')')\n            nums = parse_numbers(line[idx1+1:idx2])\n            module.addRange(nums[0], nums[1])\n            outputs.append(None)\n        elif line.startswith('rangeModule.removeRange'):\n            idx1 = line.find('(')\n            idx2 = line.rfind(')')\n            nums = parse_numbers(line[idx1+1:idx2])\n            module.removeRange(nums[0], nums[1])\n            outputs.append(None)\n        elif line.startswith('rangeModule.queryRange'):\n            idx1 = line.find('(')\n            idx2 = line.rfind(')')\n            nums = parse_numbers(line[idx1+1:idx2])\n            res = module.queryRange(nums[0], nums[1])\n            outputs.append(res)\n\n    # Format the output exactly like the example\n    formatted = '[' + ', '.join(\n        'null' if out is None else ('true' if out else 'false')\n        for out in outputs\n    ) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing RangeModule. The user wants step-by-step pseudocode with explanations. The pseudocode should not be actual code, just structure. We can design algorithm: maintain sorted list of disjoint intervals. Methods: addRange, queryRange, removeRange. We need to describe logic.\n\nWe must produce line-by-line, each with \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe can start with Start, class initialization, then methods. For each method, step-by-step.\n\nWe can use Decision, loops.\n\nProbably produce overall algorithm:\n\nInitialize: intervals empty.\n\nAddRange: find overlapping intervals, merge.\n\nQueryRange: check coverage.\n\nRemoveRange: cut intervals.\n\nWe'll produce pseudocode lines:\n\nStart // 程式開始\n\n→ Step 1: 定義 RangeModule // 建立類別\n\n→ Step 2: intervals ← 空列表 // 存儲不重疊區間\n\nThen methods.\n\nAddRange(left,right):\n\n→ Step 1: i ← 0 // 指標\n\n→ Step 2: while i < intervals.size() and intervals[i].right < left: i++ // 跳過不重疊左側\n\n→ Step 3: newLeft ← left, newRight ← right\n\n→ Step 4: while i < intervals.size() and intervals[i].left <= right: newLeft ← min(newLeft, intervals[i].left) newRight ← max(newRight, intervals[i].right) remove intervals[i]\n\n→ Step 5: insert [newLeft,newRight] at i\n\nQueryRange:\n\n→ Step 1: i ← 0\n\n→ Step 2: while i < intervals.size() and intervals[i].right < left: i++\n\n→ Step 3: if i == intervals.size() or intervals[i].left > left: return false\n\n→ Step 4: return intervals[i].right >= right\n\nRemoveRange:\n\n→ Step 1: i ← 0\n\n→ Step 2: while i < intervals.size() and intervals[i].right <= left: i++\n\n→ Step 3: if i == intervals.size() or intervals[i].left >= right: return\n\n→ Step 4: if intervals[i].left < left: insert [intervals[i].left, left] at i\n\n→ Step 5: if intervals[i].right > right: insert [right, intervals[i].right] at i+1\n\n→ Step 6: remove intervals[i] (the overlapped one)\n\n→ Step 7: i++ // continue for subsequent overlapping intervals\n\nBut we can produce as loops.\n\nWe must include arrow arrows.\n\nWe should output each line of pseudocode with explanation. No actual code. Provide structure.\n\nLet's produce the output.\n...done thinking.\n\n```\nStart // 程式開始\n\n→ Step 1: 定義 class RangeModule // 建立範圍模組類別\n    → Step 2: intervals ← 空列表 // 存放所有不重疊的區間 [left, right)\n\n→ Method: RangeModule() // 初始化建構子\n    → Step 3: intervals ← 空列表 // 初始時沒有任何被追蹤的區間\n    → Step 4: End // 建構完成\n\n→ Method: addRange(left, right) // 新增區間\n    → Step 5: i ← 0 // 初始化指標\n    → Decision: 當 i < intervals.size() 且 intervals[i].right < left? // 跳過左側不重疊區間\n        Yes → i ← i + 1\n        No  → \n    → Step 6: newLeft ← left\n    → Step 7: newRight ← right\n    → Decision: 當 i < intervals.size() 且 intervals[i].left <= right? // 合併所有重疊區間\n        Yes → newLeft ← min(newLeft, intervals[i].left)\n              newRight ← max(newRight, intervals[i].right)\n              remove intervals[i]\n              // 重新檢查同一索引，因為已移除\n        No  → \n    → Step 8: insert [newLeft, newRight] at position i // 插入合併後的新區間\n    → Step 9: End // 新增完成\n\n→ Method: queryRange(left, right) // 查詢區間是否完全被追蹤\n    → Step 10: i ← 0\n    → Decision: 當 i < intervals.size() 且 intervals[i].right < left? // 找到可能覆蓋左端點的區間\n        Yes → i ← i + 1\n        No  → \n    → Decision: i == intervals.size() 或 intervals[i].left > left? // 無法覆蓋左端點\n        Yes → return False\n        No  → \n    → Step 11: return intervals[i].right >= right // 判斷右端點是否被覆蓋\n    → Step 12: End // 查詢結束\n\n→ Method: removeRange(left, right) // 移除區間\n    → Step 13: i ← 0\n    → Decision: 當 i < intervals.size() 且 intervals[i].right <= left? // 跳過左側完全不重疊的區間\n        Yes → i ← i + 1\n        No  → \n    → Decision: i == intervals.size() 或 intervals[i].left >= right? // 沒有重疊區間\n        Yes → return // 無需移除\n        No  → \n    → Step 14: // 這裡 intervals[i] 與 [left, right) 有重疊\n        if intervals[i].left < left: // 左邊仍需保留\n            insert [intervals[i].left, left] at position i\n        if intervals[i].right > right: // 右邊仍需保留\n            insert [right, intervals[i].right] at position i+1\n    → Step 15: remove intervals[i] // 刪除被完全覆蓋或部分覆蓋的區間\n    → Step 16: i ← i + 1 // 前往下一個可能重疊的區間\n    → Decision: i < intervals.size() 且 intervals[i].left < right? // 仍有重疊\n        Yes → // 進入循環，重複 Step 14~15\n        No  → return\n    → Step 17: End // 移除完成\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.k = k                # 最大容量\n        self.buf = [0] * k        # 固定長度儲存區\n        self.head = 0             # 指向前端插入位置\n        self.count = 0            # 當前佔用數量\n\n    def insertFront(self, value):\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.k\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*arg)\n            results.append(None)\n        else:\n            func = getattr(obj, op)\n            res = func(*arg)\n            results.append(res)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. No actual code. Each line: virtual code step + // explanation. Use arrow arrows etc. We'll design the circular deque. Steps: start, initialize array of size k, head, tail pointers? Use circular buffer logic: head points to next insertion front? Usually use head, tail indices. We'll define head = 0, tail = 0, size = 0. Insert front: if full return false; head = (head -1 + k)%k; arr[head] = value; size++; true. Insert last: if full false; arr[tail] = value; tail = (tail +1)%k; size++; true. Delete front: if empty false; head = (head +1)%k; size--; true. Delete last: if empty false; tail = (tail -1 +k)%k; size--; true. getFront: if empty -1 else arr[head]. getRear: if empty -1 else arr[(tail -1 +k)%k]. isEmpty: size==0. isFull: size==k. We'll produce pseudocode lines. We'll start with class, constructor, then each method. We'll also mention internal fields. Use Start and End for each method? We'll maybe use Start at beginning of program, then each method Start... End. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別 // 建立類別容器\n→ Step 2: 在 MyCircularDeque 中宣告私有變數:\n    → capacity: 整數 // 最大容量 k\n    → arr: 整數陣列 // 儲存元素的固定長度陣列\n    → head: 整數 // 指向前端插入位置的指標\n    → tail: 整數 // 指向後端插入位置的指標\n    → size: 整數 // 當前佔用數量\n→ Decision: 如果需要初始化? // 檢查是否有建構子需要執行\n    Yes → Step 3: MyCircularDeque(int k) {\n        → Step 4: capacity ← k // 設定最大容量\n        → Step 5: arr ← 新的整數陣列長度 k // 建立固定長度陣列\n        → Step 6: head ← 0 // 前端指標初始為 0\n        → Step 7: tail ← 0 // 後端指標初始為 0\n        → Step 8: size ← 0 // 初始佔用為 0\n        } // 建構子結束\n→ Step 9: 定義方法 insertFront(value) 返回布林值 // 從前端插入元素\n    → Decision: 如果 isFull()? // 檢查是否已滿\n        Yes → Step 10: 返回 false // 插入失敗\n        No  → Step 11: head ← (head - 1 + capacity) % capacity // 往前移動指標\n                → Step 12: arr[head] ← value // 放入元素\n                → Step 13: size ← size + 1 // 更新佔用數\n                → Step 14: 返回 true // 插入成功\n    } // insertFront 結束\n→ Step 15: 定義方法 insertLast(value) 返回布林值 // 從後端插入元素\n    → Decision: 如果 isFull()? // 檢查是否已滿\n        Yes → Step 16: 返回 false // 插入失敗\n        No  → Step 17: arr[tail] ← value // 放入元素\n                → Step 18: tail ← (tail + 1) % capacity // 往後移動指標\n                → Step 19: size ← size + 1 // 更新佔用數\n                → Step 20: 返回 true // 插入成功\n    } // insertLast 結束\n→ Step 21: 定義方法 deleteFront() 返回布林值 // 從前端刪除元素\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 22: 返回 false // 刪除失敗\n        No  → Step 23: head ← (head + 1) % capacity // 往後移動指標\n                → Step 24: size ← size - 1 // 更新佔用數\n                → Step 25: 返回 true // 刪除成功\n    } // deleteFront 結束\n→ Step 26: 定義方法 deleteLast() 返回布林值 // 從後端刪除元素\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 27: 返回 false // 刪除失敗\n        No  → Step 28: tail ← (tail - 1 + capacity) % capacity // 往前移動指標\n                → Step 29: size ← size - 1 // 更新佔用數\n                → Step 30: 返回 true // 刪除成功\n    } // deleteLast 結束\n→ Step 31: 定義方法 getFront() 返回整數 // 取得前端元素\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 32: 返回 -1 // 空時返回 -1\n        No  → Step 33: 返回 arr[head] // 返回前端元素\n    } // getFront 結束\n→ Step 34: 定義方法 getRear() 返回整數 // 取得後端元素\n    → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step 35: 返回 -1 // 空時返回 -1\n        No  → Step 36: rearIndex ← (tail - 1 + capacity) % capacity // 計算實際後端索引\n                → Step 37: 返回 arr[rearIndex] // 返回後端元素\n    } // getRear 結束\n→ Step 38: 定義方法 isEmpty() 返回布林值 // 判斷是否為空\n    → Step 39: 返回 size == 0 // 若佔用數為 0 則為空\n    } // isEmpty 結束\n→ Step 40: 定義方法 isFull() 返回布林值 // 判斷是否已滿\n    → Step 41: 返回 size == capacity // 若佔用數等於最大容量則已滿\n    } // isFull 結束\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvytthlzj.py\", line 62, in <module>\n    main()\n  File \"/tmp/tmpvytthlzj.py\", line 42, in main\n    commands, args = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Handle single quotes that may appear in the input\n    data = data.replace(\"'\", '\"')\n    commands, args = json.loads(data)\n\n    result = []\n    obj = None\n    for cmd, param in zip(commands, args):\n        if cmd == \"WordDictionary\":\n            obj = WordDictionary()\n            result.append(None)\n        elif cmd == \"addWord\":\n            obj.addWord(param[0])\n            result.append(None)\n        elif cmd == \"search\":\n            result.append(obj.search(param[0]))\n        else:\n            result.append(None)\n\n    # json.dumps will output null, true, false as required\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We need to design data structure: WordDictionary with Trie to support '.' wildcard search.\n\nWe produce steps: Start, initialization, addWord: insert into Trie, search: DFS recursion handling '.'.\n\nWe need to use virtual code steps, arrows, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". For example:\n\nStart // 程式開始\n\n→ Class WordDictionary // 定義字典類別\n\n→ Constructor: WordDictionary() // 初始化\n\n→ Variable: root ← new TrieNode // Trie根節點\n\n→ Method: addWord(word) // 逐字插入到Trie\n\n→ Variable: node ← root\n\n→ For each char c in word\n\n    → If node.children[c] == null → node.children[c] = new TrieNode\n\n    → node ← node.children[c]\n\n→ End // addWord 完成\n\n→ Method: search(word) // 搜尋，支持 '.'\n\n→ Return: DFS(root, 0) // 從根節點開始索引0\n\n→ Function DFS(node, index):\n\n    → Decision: index == word.length? // 完全比對\n\n        Yes → Return node.isWord\n\n        No  → Decision: word[index] == '.'? // 如果是點\n\n            Yes → For each child in node.children\n\n                → If child != null and DFS(child, index+1) → Return true\n\n            No  → Decision: node.children[word[index]] != null? // 直接匹配\n\n                Yes → Return DFS(node.children[word[index]], index+1)\n\n                No  → Return false\n\n→ End // search\n\nEnd // 程式結束\n\nBut we need to show lines with '→' and 'Decision' arrow indentation.\n\nLet's produce step by step, with indentations and '→', 'Yes →', 'No →'.\n\nWe need to maintain the pattern exactly: each line starts with either \"Start\", \"End\", \"→\", \"Decision:\", \"Yes →\", \"No →\". We also add comment.\n\nWe'll produce each step as a line. Indentation: We could indent lines under Decision using space? Usually example shows indentation with spaces before lines: e.g.,\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: ...\n\nWe should replicate that style.\n\nSo we should output lines with proper indentation for nested decisions.\n\nLet's craft full virtual code:\n\nStart // 程式開始執行\n→ Class WordDictionary // 定義 WordDictionary 類別\n→ Constructor: WordDictionary() // 初始化資料結構\n    → Variable: root ← new TrieNode // Trie 根節點\nEnd // Constructor 完成\n→ Method: addWord(word) // 將單字加入字典\n    → Variable: node ← root\n    → For each character c in word\n        → Decision: node.children[c] == null? // 子節點是否存在\n            Yes → node.children[c] ← new TrieNode // 建立新節點\n        → node ← node.children[c] // 移動到子節點\nEnd // addWord 完成\n→ Method: search(word) // 搜尋字串，支援 '.' 通配符\n    → Return: DFS(root, 0) // 從根節點開始遞迴搜尋\n→ Function: DFS(node, index) // 遞迴搜尋輔助函式\n    → Decision: index == word.length()? // 是否已走到字串結尾\n        Yes → Return node.isWord // 若為終點，回傳是否為完整單字\n        No  → Decision: word[index] == '.'? // 當前字元是 '.' ?\n            Yes → For each child in node.children\n                → Decision: child != null? // 子節點是否存在\n                    Yes → Decision: DFS(child, index+1)? // 進一步搜尋\n                        Yes → Return true // 找到匹配\n                        No  → Continue // 試其他子節點\n                → End // child 處理完畢\n            No  → Decision: node.children[word[index]] != null? // 直接匹配字元\n                Yes → Return DFS(node.children[word[index]], index+1) // 進一步搜尋\n                No  → Return false // 沒有對應子節點，搜尋失敗\n→ End // DFS 定義結束\nEnd // 程式結束\n\nBut need to check indentation: Each line after Decision should be indented by four spaces? Example uses 4 spaces for lines under Decision. Let's replicate.\n\nAlso, we should avoid too many lines maybe but it's okay. Provide each step.\n\nMake sure each line ends with comment.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Class WordDictionary // 定義 WordDictionary 類別\n→ Constructor: WordDictionary() // 初始化資料結構\n    → Variable: root ← new TrieNode // Trie 根節點\nEnd // Constructor 完成\n→ Method: addWord(word) // 將單字加入字典\n    → Variable: node ← root\n    → For each character c in word\n        → Decision: node.children[c] == null? // 子節點是否存在\n            Yes → node.children[c] ← new TrieNode // 建立新節點\n        → node ← node.children[c] // 移動到子節點\nEnd // addWord 完成\n→ Method: search(word) // 搜尋字串，支援 '.' 通配符\n    → Return: DFS(root, 0) // 從根節點開始遞迴搜尋\n→ Function: DFS(node, index) // 遞迴搜尋輔助函式\n    → Decision: index == word.length()? // 是否已走到字串結尾\n        Yes → Return node.isWord // 若為終點，回傳是否為完整單字\n        No  → Decision: word[index] == '.'? // 當前字元是 '.' ?\n            Yes → For each child in node.children\n                → Decision: child != null? // 子節點是否存在\n                    Yes → Decision: DFS(child, index+1)? // 進一步搜尋\n                        Yes → Return true // 找到匹配\n                        No  → Continue // 試其他子節點\n                → End // child 處理完畢\n            No  → Decision: node.children[word[index]] != null? // 直接匹配字元\n                Yes → Return DFS(node.children[word[index]], index+1) // 進一步搜尋\n                No  → Return false // 沒有對應子節點，搜尋失敗\n→ End // DFS 定義結束\nEnd // 程式結束\n```"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjjblae0u.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpjjblae0u.py\", line 41, in main\n    result = solution.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjjblae0u.py\", line 15, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpjjblae0u.py\", line 10, in parse\n    raise ValueError(f\"Invalid complex number format: {s!r}\")\nValueError: Invalid complex number format: '1+-1i'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            # Match patterns like -1+2i, 3-4i, -5-6i, 7+8i\n            m = re.fullmatch(r'\\s*([+-]?\\d+)([+-]\\d+)i\\s*', s)\n            if not m:\n                raise ValueError(f\"Invalid complex number format: {s!r}\")\n            real = int(m.group(1))\n            imag = int(m.group(2))\n            return real, imag\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to extract quoted strings first\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        num1, num2 = quoted[0], quoted[1]\n    else:\n        # Fallback: split by comma\n        parts = [p.strip().strip('\"').strip(\"'\") for p in data.split(',')]\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            raise ValueError(\"Input must contain two complex numbers\")\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code step by step. Steps: parse strings, compute multiplication: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Then format back. Also need handle signs.\n\nWe produce lines with Start, Decision etc. Probably need to parse real and imag: split at '+' or '-'.\n\nSimplify: use regex? but virtual code. We can describe steps: Find 'i', remove it, split at '+' or '-', handle sign.\n\nOk produce.\n\nWe need to use arrows for decisions. Provide explanation.\n\nLet's craft lines:\n\nStart\n→ Step 1: Receive num1, num2 // input complex numbers\n→ Step 2: Parse num1 into a (real1) and b (imag1) // extract numeric parts\n→ Step 3: Parse num2 into c (real2) and d (imag2) // extract numeric parts\n→ Step 4: Compute real_part = a * c - b * d // multiplication real part\n→ Step 5: Compute imag_part = a * d + b * c // multiplication imaginary part\n→ Step 6: Format result = real_part + '+' + imag_part + 'i' // create output string\nEnd\n\nBut need to include decisions maybe for parsing sign.\n\nLet's add Decision: If num1 contains '-' before imag? Actually we need to detect sign between real and imaginary. Could be like \"1-1i\" or \"-1+2i\". So decision: find position of '+' or '-' after the first char? We'll add decision.\n\nOk produce.\n\nWe need to adhere to format: each line \"虛擬碼步驟 // 解釋\".\n\nUse arrows with '→' etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字符串 num1, num2 // 取得兩個複數的字串表示  \n\n→ Decision: num1 的形式是 \"real1+imag1i\" 還是 \"real1-imag1i\"? // 判斷實部與虛部之間的符號  \n  Yes → Step 2a: 將 \"+\" 替換成空格，拆分為 real1_str, imag1_str_i // 標準化分隔符  \n  No  → Step 2b: 將 \"-\" 替換成空格，拆分為 real1_str, imag1_str_i // 處理負虛部  \n\n→ Step 3: 去除 imag1_str_i 末尾的 'i' 並轉為整數 imag1 // 取得 imag1 整數  \n→ Step 4: 將 real1_str 轉為整數 real1 // 取得 real1 整數  \n\n→ Decision: num2 的形式是 \"real2+imag2i\" 還是 \"real2-imag2i\"? // 同樣判斷符號  \n  Yes → Step 5a: 將 \"+\" 替換成空格，拆分為 real2_str, imag2_str_i  \n  No  → Step 5b: 將 \"-\" 替換成空格，拆分為 real2_str, imag2_str_i  \n\n→ Step 6: 去除 imag2_str_i 末尾的 'i' 並轉為整數 imag2 // 取得 imag2 整數  \n→ Step 7: 將 real2_str 轉為整數 real2 // 取得 real2 整數  \n\n→ Step 8: 計算實部 result_real = real1 * real2 - imag1 * imag2 // 複數相乘實部公式  \n→ Step 9: 計算虛部 result_imag = real1 * imag2 + imag1 * real2 // 複數相乘虛部公式  \n\n→ Step 10: 將 result_real 轉為字串，結合 '+'、result_imag、'i' 成 result_str // 重新組成字串  \n  如果 result_imag 為負數，字串會自動帶 '-' 符號  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"Return list of groups of duplicate file paths.\"\"\"\n        content_map = defaultdict(list)\n\n        for path in paths:\n            parts = path.split()\n            root = parts[0]\n            for file_info in parts[1:]:\n                name, content = file_info.split('(')\n                content = content[:-1]          # remove trailing ')'\n                content_map[content].append(root + '/' + name)\n\n        # keep only groups with two or more files\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the list part (handles \"paths = [...]\" or just \"[...]\")\n    start = data.find('[')\n    if start == -1:\n        paths = []\n    else:\n        paths = ast.literal_eval(data[start:])   # safely evaluate the list\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode with explanation per line. The problem: find duplicate files by content from directory info strings. The input is list of strings; each string format: \"root/d1/... f1.txt(content) ...\". We need to output groups of paths with same content. Approach: iterate through input strings, split by spaces: first part is dir path, others are file info. For each file info, parse name and content using parentheses. Build map from content to list of full paths. After processing all, collect values with length >= 2. Return list of lists.\n\nWe must produce virtual code lines with arrows and decisions. Use Start, End, Decision. Provide each line with explanation comment.\n\nWe need to output only virtual code lines, no actual code.\n\nLet's create lines:\n\nStart\n\n→ Step 1: Initialize map contentToPaths as empty list dictionary // store content -> list of paths\n\n→ Step 2: For each dirInfo in inputList // iterate each directory string\n\n→ Decision: If dirInfo is empty? // check maybe skip\n\nYes → Step 3: Continue // skip empty\n\nNo → Step 4: Split dirInfo by space into parts // separate directory and file infos\n\n→ Step 5: dirPath = parts[0] // first part is directory path\n\n→ Step 6: For each fileInfo in parts[1:] // iterate file entries\n\n→ Decision: If fileInfo contains '(' and ')' ? // check format\n\nYes → Step 7: Split fileInfo at '(' to get fileName and rest // fileName before '('\n\n→ Step 8: content = rest without trailing ')' // content inside parentheses\n\n→ Step 9: fullPath = dirPath + '/' + fileName // construct full path\n\n→ Step 10: Append fullPath to contentToPaths[content] // add to map\n\nNo → Step 11: Continue // skip malformed\n\nAfter loop, collect groups:\n\n→ Step 12: Initialize result as empty list // list of duplicate groups\n\n→ Step 13: For each entry in contentToPaths // iterate map\n\n→ Decision: If entry.value length >= 2? // only duplicates\n\nYes → Step 14: Append entry.value to result // add group\n\nNo → Step 15: Continue // skip unique\n\n→ End // output result\n\nAlso need step to output.\n\nMaybe Step 16: Return result // final output\n\nMake sure each line has arrow? Start, Step, Decision. Use \"→\" before each step? In example they used \"→ Step 1:\" lines. Use that format. For decision lines, indent.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: contentToPaths ← Empty Dictionary // 建立內容到路徑的映射  \n→ Step 2: For each dirInfo in inputList // 遍歷每個目錄資訊字串  \n→ Decision: 如果 dirInfo 為空? // 檢查是否有資料  \n    Yes → Step 3: Continue // 空字串直接略過  \n    No  → Step 4: parts ← Split dirInfo by space // 分離目錄路徑與檔案資訊  \n→ Step 5: dirPath ← parts[0] // 取得目錄路徑  \n→ Step 6: For each fileInfo in parts[1:] // 逐一處理檔案資訊  \n→ Decision: fileInfo 包含 '(' 且 ')'? // 檢查格式是否正確  \n    Yes → Step 7: tokens ← Split fileInfo at '(' // 分離檔名與內容  \n    → Step 8: fileName ← tokens[0] // 檔名  \n    → Step 9: content ← tokens[1] minus trailing ')' // 取出檔案內容  \n    → Step 10: fullPath ← dirPath + '/' + fileName // 組成完整路徑  \n    → Step 11: Append fullPath to contentToPaths[content] // 加入映射  \n    No  → Step 12: Continue // 若格式錯誤則略過  \n→ Step 13: result ← Empty List // 建立結果集合  \n→ Step 14: For each (content, paths) in contentToPaths // 遍歷映射  \n→ Decision: paths 之長度 >= 2? // 是否為重複檔案群組  \n    Yes → Step 15: Append paths to result // 加入重複群組  \n    No  → Step 16: Continue // 單一檔案不加入  \n→ End // 程式執行結束；結果即為 result 變數中的重複檔案路徑群組。"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[4]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[4]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[9, 4]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[5,9,3]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[5, 9, 3]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7():\n    \"\"\"生成 1~7 的均勻隨機整數\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"使用 rand7() 生成 1~10 的均勻隨機整數\"\"\"\n        while True:\n            a = rand7()\n            b = rand7()\n            num = (a - 1) * 7 + b  # 合併兩個 rand7()，得到 1~49\n            if num <= 40:          # 只接受 1~40，保證均勻分佈\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 讀取整個輸入，提取第一個整數作為 n\n    data = sys.stdin.read()\n    if not data:\n        return\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group())\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10() using rand7() uniformly. Classic solution: use two calls to rand7() to generate numbers 1-49. Then reject if >40 and map to 1-10 via mod 10. Pseudocode: start; generate two rand7(); compute r = (first-1)*7 + second; if r <= 40 then return r%10+1 else repeat. That uses loops.\n\nWe need to output step-by-step virtual code lines with explanation. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". We'll produce steps.\n\nWe need to produce code for rand10() function.\n\nWe'll use: Start rand10(); → Step: repeat loop: generate a=rand7(); b=rand7(); r = (a-1)*7 + b; Decision: if r <= 40? Yes → return r % 10 + 1; No → repeat.\n\nBut we must ensure repeated loop. Use while True: ... At end, End.\n\nWe can show with Decision and arrows.\n\nLet's produce:\n\nStart rand10() // 開始定義函式\n→ Step 1: 循環開始 // 以防止接受到無效的數字\n    → Step 2: 取得 a = rand7() // 第一個亂數\n    → Step 3: 取得 b = rand7() // 第二個亂數\n    → Step 4: 計算 r = (a-1)*7 + b // 將兩個亂數合併為 1-49\n    → Decision: 如果 r <= 40? // 只接受 1-40，保證均勻分佈\n        Yes → Step 5: 返回 (r-1) mod 10 + 1 // 轉換為 1-10\n        No  → Step 6: 重複循環 // 超過 40 則重試\n\nEnd rand10() // 函式結束\n\nWe need to use arrow formatting: \"→\". For nested decisions, indent with tabs.\n\nWe also might add comment about uniform distribution.\n\nOk. Let's output accordingly.\n...done thinking.\n\nStart rand10() // 開始定義函式\n→ Decision: 進入重複循環? // 需要在獲得有效數字前重試\n    Yes → Step 1: a = rand7() // 取得第一個亂數\n    → Step 2: b = rand7() // 取得第二個亂數\n    → Step 3: r = (a-1) * 7 + b // 把兩個亂數合併為 1~49\n    → Decision: r ≤ 40? // 只接受 1~40，確保均勻分佈\n        Yes → Step 4: return (r-1) mod 10 + 1 // 轉換為 1~10\n        No  → Step 5: 重複循環 // r 超過 40，重新嘗試\nEnd rand10() // 函式結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMAX_INT = 2147483647\nMIN_INT = -2147483648\n\ndef reverse(x: int) -> int:\n    \"\"\"\n    反轉 32 位整數，若溢出則返回 0\n    \"\"\"\n    rev = 0\n    while x != 0:\n        pop = x % 10          # 取得最後一位，對負數也為負\n        x //= 10              # 去除已取出的位元\n\n        # 檢查正溢位\n        if rev > MAX_INT // 10 or (rev == MAX_INT // 10 and pop > 7):\n            return 0\n        # 檢查負溢位\n        if rev < MIN_INT // 10 or (rev == MIN_INT // 10 and pop < -8):\n            return 0\n\n        rev = rev * 10 + pop  # 將 pop 加到 rev 的末尾\n\n    return rev\n\ndef parse_input(data: str) -> int:\n    \"\"\"\n    從輸入字串中解析整數。支持 'x = 123'、'x=123' 或僅 123 等格式。\n    \"\"\"\n    # 找出第一個出現的整數（可帶符號）\n    match = re.search(r'(-?\\d+)', data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    return int(match.group(1))\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    x = parse_input(raw_input)\n    result = reverse(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution in Chinese with line-by-line explanation. No real code. Use Start, End, Decision, steps. Must handle reversing digits with sign, check overflow 32-bit. Cannot use 64-bit storage. Must handle in 32-bit operations only. Approach: use integer arithmetic, but careful about overflow by checking before multiplication/addition.\n\nAlgorithm: Use long? But not allowed. Instead use check: when building reversed number rev, we can check if rev will overflow when multiply by 10 and add digit. Use threshold: for 32-bit signed, min=-2^31, max=2^31-1. When rev>max/10 etc. Use division. We can use 32-bit arithmetic with division, but division safe.\n\nSo algorithm: sign = 1 or -1. x abs? Use negative to handle min.\n\nWe can handle by converting negative to positive? Use long? Can't. We can process absolute value. But min -2147483648 can't be represented as positive. So treat separately: use negative rev. Instead compute rev negative if x negative. Use xAbs? Actually we can take negative of negative to get positive but overflow. Instead use long? Not allowed. Approach: compute rev as negative value: rev=0; while x != 0: pop = x % 10; x /= 10; then check if rev will overflow when rev*10 + pop; but rev negative. Use checks with rev < INT_MIN/10 etc.\n\nBetter: treat rev as negative if sign negative: rev=0; pop negative digits? Actually pop = x % 10 yields last digit maybe negative. For negative x, x%10 yields negative remainder in many languages? In C, -123%10 = -3. So we can use that. So we can avoid sign conversion.\n\nThus algorithm: rev=0; while x != 0: pop = x % 10; x /= 10; //pop can be negative\n// Check overflow: if rev > INT_MAX/10 or rev == INT_MAX/10 and pop > 7 => overflow\n// if rev < INT_MIN/10 or rev == INT_MIN/10 and pop < -8 => overflow\n// else rev = rev*10 + pop\nReturn rev\n\nWe'll produce virtual code steps with decisions. Provide each line explanation.\n\nLet's craft.\n\nUse constants: MAX = 2147483647, MIN = -2147483648\n\nUse Step: Initialize rev = 0\n\nDecision: while x != 0? loop.\n\nInside loop: Step: pop = x % 10 // get last digit\n\nStep: x = x / 10 // remove last digit\n\nDecision: if rev > MAX/10 or rev == MAX/10 and pop > 7? overflow? Use Decision: overflow? Yes → return 0.\n\nDecision: if rev < MIN/10 or rev == MIN/10 and pop < -8? overflow? Yes → return 0.\n\nStep: rev = rev * 10 + pop // append digit\n\nLoop end\n\nReturn rev\n\nEdge: min value -2147483648; rev negative; pop negative; check works.\n\nLet's write virtual code lines.\n\nUse Start, End.\n\nWe need to use arrows \"→\".\n\nWe'll write each step with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義常數 MAX = 2147483647, MIN = -2147483648 // 32 位整數範圍  \n→ Step 2: rev ← 0 // 用來累積翻轉後的數字  \n→ Decision: x ≠ 0? // 若輸入為 0，直接返回 0  \n    Yes → Loop開始  \n        → Step 3: pop ← x % 10 // 取得 x 最右側的數位，對負數也會得到負數  \n        → Step 4: x ← x / 10 // 去除已取出的數位  \n        → Decision: rev > MAX / 10 或 (rev = MAX / 10 且 pop > 7)? // 正溢位檢查  \n            Yes → Step 5: Return 0 // 反轉後會超過正上限  \n            No  → Decision: rev < MIN / 10 或 (rev = MIN / 10 且 pop < -8)? // 負溢位檢查  \n                Yes → Step 6: Return 0 // 反轉後會超過負下限  \n                No  → Step 7: rev ← rev * 10 + pop // 將 pop 加到 rev 的末尾  \n        → Decision: x ≠ 0? // 仍有數位待處理  \n            Yes → Loop繼續  \n            No  → Loop結束  \n    No  → // x 原本為 0，直接執行結束  \nEnd // 程式執行結束，返回 rev（若未發生溢位）"
    },
    {
      "title": "Valid Square",
      "source_file": "Leetcode/leetcode593.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 2,
          "input": "p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef is_valid_square(points):\n    def dist_sq(a, b):\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n    dists = []\n    for i in range(4):\n        for j in range(i + 1, 4):\n            dists.append(dist_sq(points[i], points[j]))\n\n    dists.sort()\n    return (\n        dists[0] > 0\n        and dists[0] == dists[1] == dists[2] == dists[3]\n        and dists[4] == dists[5]\n        and dists[4] == 2 * dists[0]\n    )\n\ndef main():\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 8:\n        return\n    points = [(nums[i], nums[i + 1]) for i in range(0, 8, 2)]\n    result = is_valid_square(points)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudocode steps for solving: check if four points form a square. Approach: compute all six pairwise distances. There are only 6 distances. For a square, we should have exactly 2 distinct distances: side length (appearing 4 times) and diagonal length (appearing 2 times). The side distance must be >0. Also diagonal = side*sqrt(2). But we can avoid sqrt: check that diagonal distance = 2 * side^2? Wait distance squared: side^2 appears 4 times, diagonal^2 appears 2 times, and diagonal^2 = 2 * side^2. So we can use squared distances.\n\nSo algorithm: compute squared distances between all pairs of points. Put into array. Sort. Then check: arr[0] > 0 (positive), arr[0]==arr[3] (first four equal), arr[4]==arr[5] (last two equal), and arr[4]==2*arr[0]. If yes -> true.\n\nWe need to produce virtual code lines, each with arrow. Let's produce step by step:\n\nStart\n→ Step 1: Initialize empty list distances\n→ Step 2: For each pair of points among the four (6 pairs):\n    → Step 2.1: Compute squared distance: (xi - xj)^2 + (yi - yj)^2\n    → Step 2.2: Append to distances\n→ Step 3: Sort distances ascending\n→ Step 4: If distances[0] == 0 → return false // zero side length\n→ Step 5: Decision: if distances[0]==distances[3] and distances[4]==distances[5] and distances[4]==2*distances[0]?\n    Yes → Step 6: Return true // square\n    No  → Step 7: Return false // not a square\nEnd\n\nBut we need to adhere to format: \"虛擬碼步驟 [空格] // 解釋/說明\" and use arrows.\n\nWe also need indentation? Not necessary but we can use indentation for nested steps. Use arrow \"→\".\n\nBetter: Use structure:\n\nStart\n→ Step 1: Initialize empty list distances // 用來存放六條距離的平方\n→ Step 2: For each unordered pair of the four points:\n    → Step 2.1: Compute squared distance between the pair // (xi - xj)^2 + (yi - yj)^2\n    → Step 2.2: Append this value to distances // 收集所有距離\n→ Step 3: Sort distances ascending // 方便後續比較\n→ Step 4: Decision: 如果 distances[0] == 0? // 任何邊長為零都不是合法正方形\n    Yes → Step 5: Return false // 不合法\n    No  → Step 6: Decision: 如果 distances[0]==distances[3] and distances[4]==distances[5] and distances[4]==2*distances[0]? // 判斷兩種距離分布及比例\n        Yes → Step 7: Return true // 四邊相等且角度為90°\n        No  → Step 8: Return false // 不符合正方形條件\nEnd\n\nBut need to follow required format: Use \"虛擬碼步驟\" (like \"Step 1: ...\") with arrow arrow. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize list distances // 用於儲存六條點對之距離平方\n→ Step 2: For each pair (p_i, p_j) where i < j among p1,p2,p3,p4:\n    → Step 2.1: Compute d = (x_i - x_j)^2 + (y_i - y_j)^2 // 計算平方距離\n    → Step 2.2: Append d to distances // 加入列表\n→ Step 3: Sort distances ascending // 方便判斷相等距離\n→ Step 4: Decision: 如果 distances[0] == 0? // 檢查是否有零長度邊\n    Yes → Step 5: Return false // 不合法\n    No  → Step 6: Decision: 如果 distances[0]==distances[3] and distances[4]==distances[5] and distances[4]==2*distances[0]? // 判斷邊長與對角長比例\n        Yes → Step 7: Return true // 四邊相等且角度正方形\n        No  → Step 8: Return false // 不符合條件\nEnd // 程式結束\n\nCheck format: Each line has `虛擬碼步驟 [空格] // 解釋/說明`. We used \"Step 1:\" etc. Ensure we use the arrow \"→\" before each line after Start? Format requires: `虛擬碼步驟` + `[空格]` + `// 解釋/說明`. It also suggests using arrows `→` or `Yes →` etc. So we can write each line as:\n\nStart // 程式開始執行\n→ Step 1: Initialize list distances // 用於儲存六條點對之距離平方\n→ Step 2: For each pair (p_i, p_j) where i < j among p1,p2,p3,p4:\n    → Step 2.1: Compute d = (x_i - x_j)^2 + (y_i - y_j)^2 // 計算平方距離\n    → Step 2.2: Append d to distances // 加入列表\n→ Step 3: Sort distances ascending // 方便判斷相等距離\n→ Step 4: Decision: 如果 distances[0] == 0? // 檢查是否有零長度邊\n    Yes → Step 5: Return false // 不合法\n    No  → Step 6: Decision: 如果 distances[0]==distances[3] and distances[4]==distances[5] and distances[4]==2*distances[0]? // 判斷邊長與對角長比例\n        Yes → Step 7: Return true // 四邊相等且角度正方形\n        No  → Step 8: Return false // 不符合條件\nEnd // 程式結束\n\nEnsure each line uses proper spacing. The lines with nested steps we can indent but still keep arrow. For \"Step 2:\" line, we can put \"→ Step 2: ...\" then next lines indented with arrow. We need to make sure each line contains arrow. Example:\n\n→ Step 2: For each pair (p_i, p_j) where i < j among p1,p2,p3,p4:\n    → Step 2.1: Compute d = ... //...\n    → Step 2.2: Append d to distances //...\n\nBut indentation may not be part of required format but fine.\n\nWe might also need to ensure the arrow after \"Yes\" or \"No\" uses \"Yes →\" etc. So we did.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize list distances // 用於儲存六條點對之距離平方  \n→ Step 2: For each pair (p_i, p_j) where i < j among p1,p2,p3,p4:  \n  → Step 2.1: Compute d = (x_i - x_j)^2 + (y_i - y_j)^2 // 計算平方距離  \n  → Step 2.2: Append d to distances // 加入列表  \n→ Step 3: Sort distances ascending // 方便判斷相等距離  \n→ Step 4: Decision: 如果 distances[0] == 0? // 檢查是否有零長度邊  \n  Yes → Step 5: Return false // 不合法  \n  No  → Step 6: Decision: 如果 distances[0]==distances[3] and distances[4]==distances[5] and distances[4]==2*distances[0]? // 判斷邊長與對角長比例  \n    Yes → Step 7: Return true // 四邊相等且角度為90°  \n    No  → Step 8: Return false // 不符合條件  \nEnd // 程式結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp47ju_jre.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmp47ju_jre.py\", line 49, in main\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp47ju_jre.py\", line 44, in parse_input\n    data = ast.literal_eval('{' + cleaned + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7707e950d9d0>"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5_4keogk.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmp5_4keogk.py\", line 49, in main\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5_4keogk.py\", line 44, in parse_input\n    data = ast.literal_eval('{' + cleaned + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x739750a11a50>"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp144timvb.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmp144timvb.py\", line 49, in main\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp144timvb.py\", line 44, in parse_input\n    data = ast.literal_eval('{' + cleaned + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x75c617211a50>"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        # Build adjacency map with weights\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            # If either variable is unknown\n            if src not in graph or dst not in graph:\n                return -1.0\n            # Same variable -> ratio is 1\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor in visited:\n                    continue\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef parse_input(raw: str):\n    \"\"\"\n    Convert input string like:\n        equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"]]\n    into a dictionary {'equations': [...], 'values': [...], 'queries': [...]}\n    \"\"\"\n    # Replace assignment operators with dictionary syntax\n    cleaned = re.sub(r'(\\w+)\\s*=', r'\\1:', raw.strip())\n    # Wrap in braces to create a dict literal\n    data = ast.literal_eval('{' + cleaned + '}')\n    return data['equations'], data['values'], data['queries']\n\ndef main():\n    raw_input = sys.stdin.read()\n    equations, values, queries = parse_input(raw_input)\n    solution = Solution()\n    results = solution.calcEquation(equations, values, queries)\n    # Format each number to 5 decimal places\n    formatted = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving division queries using equations. Use union find or graph traversal. Use union find with weight. Provide steps: build graph, DFS for each query. So steps: Start, Step 1: build adjacency map, Step 2: DFS function, Step 3: answer queries. Provide decision flows for unknown variable or no path. Provide final End. Use virtual code with arrows and decision labels.\n\nLet's craft step-by-step lines. Use \"Step X:\" lines. For DFS, may include recursion. Provide decision if start or end nodes not present.\n\nLet's output lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接表 graph // 以 {變數: [{鄰接變數, 值}, ...]} 方式存儲方程式  \n→ Step 2: 將每條方程式 Ai / Bi = v 加入 graph  \n  → Decision: Ai 及 Bi 是否已存在於 graph?  \n   Yes → Append {Bi, v} 至 graph[Ai]，並附 {Ai, 1/v} 至 graph[Bi]  \n   No  → 先新建兩個空清單，再執行上述追加操作  \n→ Step 3: 定義遞迴函式 DFS(start, target, acc, visited) // acc 累積乘積  \n  → Decision: start == target?  \n   Yes → Return acc // 找到路徑，回傳累積值  \n   No → Add start 到 visited  \n   → For 每個 (neighbor, value) 在 graph[start]  \n    Decision: neighbor 是否已在 visited?  \n     Yes → Continue // 避免循環  \n     No → Result ← DFS(neighbor, target, acc * value, visited)  \n      Decision: Result 是否為 None?  \n       Yes → Continue // 該路徑無效，嘗試下一個鄰接  \n       No → Return Result // 找到有效路徑，回傳結果  \n   → Return None // 所有鄰接皆嘗試完畢仍未找到路徑  \n→ Step 4: 初始化 answers = []  \n→ Step 5: 對每個查詢 [C, D]  \n  → Decision: C 與 D 是否同時存在於 graph?  \n   Yes → Result ← DFS(C, D, 1, 空集合)  \n    Decision: Result 是否為 None?  \n     Yes → Append -1.0 至 answers // 無法確定  \n     No → Append Result 至 answers // 計算完成  \n   No → Append -1.0 至 answers // 任一變數未定義  \n→ Step 6: 回傳 answers // 所有查詢結果已計算完畢  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdrijbnu6.py\", line 90, in <module>\n    ops, args = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdrijbnu6.py\", line 60, in parse_input\n    raise ValueError(\"輸入格式錯誤\")\nValueError: 輸入格式錯誤"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"\n    用兩個 queue 實作 LIFO 堆疊。\n    queue1 存放目前堆疊元素，queue2 作為暫存區。\n    \"\"\"\n\n    def __init__(self):\n        self.q1 = deque()  # 主 queue\n        self.q2 = deque()  # 暫存 queue\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        把元素 x 推到堆疊頂部。\n        步驟：\n        1. 把 x 放入 q2（暫存區）。\n        2. 把 q1 中所有元素依序移到 q2（保持原順序）。\n        3. 交換 q1 與 q2 的引用，完成 push。\n        \"\"\"\n        self.q2.append(x)\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        \"\"\"\n        移除並回傳堆疊頂部元素。\n        直接從 q1 的前端 pop。\n        \"\"\"\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        \"\"\"\n        回傳堆疊頂部元素但不移除。\n        \"\"\"\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        檢查堆疊是否為空。\n        \"\"\"\n        return not self.q1\n\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串轉成兩個 list：\n    - ops: 操作名稱\n    - args: 參數列表\n    \"\"\"\n    # 去掉可能的「Input」前綴\n    if data.startswith(\"Input\"):\n        data = data[data.find('['):]\n    # 找到兩個 list 的字串\n    lists = re.findall(r'\\[[^\\]]*\\]', data)\n    if len(lists) != 2:\n        raise ValueError(\"輸入格式錯誤\")\n    ops = ast.literal_eval(lists[0])\n    args = ast.literal_eval(lists[1])\n    return ops, args\n\n\ndef format_output(res):\n    \"\"\"\n    將執行結果轉成與範例相同的文字格式。\n    None -> null，True -> true，False -> false\n    \"\"\"\n    out = []\n    for v in res:\n        if v is None:\n            out.append('null')\n        elif isinstance(v, bool):\n            out.append('true' if v else 'false')\n        else:\n            out.append(str(v))\n    return '[' + ', '.join(out) + ']'\n\n\nif __name__ == \"__main__\":\n    import re\n\n    # 讀取所有輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    ops, args = parse_input(raw)\n\n    stack = None\n    results = []\n\n    for op, param in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            results.append(None)\n        elif op == \"push\":\n            stack.push(param[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n        else:\n            # 忽略未知操作\n            pass\n\n    # 輸出結果\n    print(format_output(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation, step by step for implementing stack with two queues. Need to use virtual code lines with arrow etc. Provide Start, End, Decision. So produce steps for class MyStack, with internal queues q1, q2. Use push: push into q1. Pop: move all except last element from q1 to q2, pop last from q1, then swap q1 and q2. top similar but just peek last element. empty: check q1 empty. We'll produce pseudocode.\n\nLet's produce a step-by-step procedure. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision etc. We'll include class definition Start.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 MyStack 類別 // 建立堆疊類別\n→ Step 2: 宣告兩個 queue：q1, q2，皆為空 // 用於實作 LIFO\n→ Decision: 是否需要初始化? // 確認建構子執行\n    Yes → Step 3: 建構子內將 q1, q2 設為空 queue // 初始狀態\n    No  → // 省略\n\n// -------------------- push 方法 --------------------\n→ Step 4: push(x) // 將元素 x 推入堆疊\n→ Decision: q1 是否為空? // 決定是否直接 push\n    Yes → Step 5: q1.enqueue(x) // 直接加入尾部\n    No  → Step 6: q1.enqueue(x) // 仍然加入尾部\n\n// -------------------- pop 方法 --------------------\n→ Step 7: pop() // 移除並回傳堆疊頂部元素\n→ Decision: q1.isEmpty()? // 檢查是否有元素\n    Yes → Step 8: return null // 沒有元素，返回空值\n    No  → \n        → Step 9: 循環直到 q1.size() == 1\n            → Decision: q1.size() > 1? // 仍有多於一個元素\n                Yes → Step 10: temp = q1.dequeue() // 從前端取出\n                → Step 11: q2.enqueue(temp) // 放入第二個 queue\n                No  → // 只剩一個元素\n        → Step 12: topElement = q1.dequeue() // 取出最後一個元素（堆疊頂部）\n        → Step 13: 交換 q1, q2 // q1 重新成為工作 queue\n        → Step 14: return topElement // 回傳頂部元素\n\n// -------------------- top 方法 --------------------\n→ Step 15: top() // 回傳堆疊頂部但不移除\n→ Decision: q1.isEmpty()? // 檢查是否有元素\n    Yes → Step 16: return null // 沒有元素，返回空值\n    No  → \n        → Step 17: 循環直到 q1.size() == 1\n            → Decision: q1.size() > 1? \n                Yes → Step 18: temp = q1.dequeue()\n                → Step 19: q2.enqueue(temp)\n                No  → // 只剩一個元素\n        → Step 20: topElement = q1.dequeue()\n        → Step 21: q2.enqueue(topElement) // 把頂部元素放回第二個 queue\n        → Step 22: 交換 q1, q2 // 回到原始 queue\n        → Step 23: return topElement // 回傳頂部元素\n\n// -------------------- empty 方法 --------------------\n→ Step 24: empty() // 檢查堆疊是否為空\n→ Decision: q1.isEmpty()? \n    Yes → Step 25: return true // 空\n    No  → Step 26: return false // 非空\n\nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                parent_email = find(first_email)\n                parent_email2 = find(email)\n                parent[parent_email2] = parent_email\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入：支援「accounts = [...」或直接給列表字串\n    if data.startswith(\"accounts\"):\n        idx = data.find(\"=\")\n        if idx != -1:\n            data = data[idx + 1:].strip()\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        raise ValueError(\"無法解析輸入\") from e\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. It's about merging accounts by emails using DSU or graph.\n\nWe produce steps: Start, Step: create graph, iterate accounts, add edges between first email and others. Build email to name map. Then perform DFS/BFS to find connected components. Collect emails per component, sort, prepend name. Output. End.\n\nWe need to adhere to format: \"虛擬碼步驟 // 解釋\" Each line. Use arrows. Decision if needed? Probably no decision except for loops. Use →.\n\nWe'll produce lines like:\n\nStart // 程式開始\n\n→ Step 1: 建立鄰接表 graph 以及 emailToName map // 初始化資料結構\n\n→ Step 2: 對每個帳號 accounts 進行迴圈 // 逐帳號處理\n\n    → Step 2a: 取得 name = accounts[i][0] // 帳號名稱\n\n    → Step 2b: 取得 emails = accounts[i][1:] // 其餘為郵件\n\n    → Step 2c: 對每個 email 進行\n\n        → Step 2c1: 若 email 不在 graph 中則 graph[email] = 空列表 // 新增節點\n\n        → Step 2c2: 若 email 不在 emailToName 中則 emailToName[email] = name // 記錄名稱\n\n    → Step 2d: 若 emails 內至少兩個，則\n\n        → Decision: 是否存在多於一個? // 判斷\n\n            Yes → 迴圈遍歷 emails[1:]，對每個其他_email\n\n                → Step 2d1: graph[emails[0]].append(other_email)\n\n                → Step 2d2: graph[other_email].append(emails[0]) // 建立雙向邊\n\n        No → // 只有一個 email，無需邊\n\n...\n\nAfter building graph, we need visited set, result list.\n\n→ Step 3: 建立 visited 集合 // 用於追蹤已訪問節點\n\n→ Step 4: 對 graph 中每個 email 做 DFS\n\n    → Decision: email 是否已訪問? // 判斷\n\n        Yes → // 跳過\n\n        No →\n\n            → Step 4a: 進行 DFS 並收集 component_emails\n\n            → Step 4b: 取得 name = emailToName[component_emails[0]] // 取其中一個\n\n            → Step 4c: component_emails.sort() // 排序\n\n            → Step 4d: 建立 merged_account = [name] + component_emails\n\n            → Step 4e: 將 merged_account 加入 result\n\nEnd // 結束\n\nBut must follow the specified output format: each line \"虛擬碼步驟 // 解釋\". We need arrow syntax. For steps that have substeps, indent? We can use spaces or new lines? Format uses indentation with tabs/spaces. In example, they used:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n\nWe can mimic that.\n\nSo produce lines with indentation for substeps.\n\nWe should also avoid actual code. Use generic names like Step X: 建立圖, etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接表 graph 以及 emailToName 映射 // 初始化資料結構  \n\n→ Step 2: 逐帳號處理 accounts // 逐帳號遍歷  \n    → Step 2a: 取得帳號名稱 name = accounts[i][0] // 取得姓名  \n    → Step 2b: 取得郵件列表 emails = accounts[i][1:] // 取得所有郵件  \n    → Step 2c: 為每個 email 建立節點及名稱映射  \n        → Step 2c1: 若 email 不在 graph 中則 graph[email] ← 空列表 // 新增節點  \n        → Step 2c2: 若 email 不在 emailToName 中則 emailToName[email] ← name // 記錄名稱  \n    → Step 2d: 建立帳號內郵件間的連結  \n        → Decision: emails 長度是否大於 1? // 判斷是否需要連結  \n            Yes → 迴圈遍歷 emails[1:]  \n                → Step 2d1: graph[emails[0]].append(other_email) // 連結第一個郵件與其他  \n                → Step 2d2: graph[other_email].append(emails[0]) // 連結對方回第一個  \n            No → // 只有一個郵件，不需要建立邊  \n\n→ Step 3: 建立已訪問集合 visited // 用於 DFS  \n→ Step 4: 逐個未訪問的 email 進行 DFS 收集組件  \n    → Decision: email 是否已在 visited? // 判斷是否跳過  \n        Yes → // 已處理過，跳過  \n        No →  \n            → Step 4a: 執行 DFS，將所有可達的 email 加入 component_emails // 收集組件  \n            → Step 4b: 取得組件首個 email 的名稱 name = emailToName[component_emails[0]] // 取得姓名  \n            → Step 4c: component_emails.sort() // 依字典序排序郵件  \n            → Step 4d: 建立合併後帳號 merged_account ← [name] + component_emails // 組裝結果  \n            → Step 4e: 將 merged_account 加入結果列表 results // 收集所有合併帳號  \n\nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmq1w41pz.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpmq1w41pz.py\", line 29, in main\n    args_list = ast.literal_eval(data[1].strip())\n                                 ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyCalendar:\n    \"\"\"一個簡易日曆，避免時間重疊。\"\"\"\n\n    def __init__(self):\n        # 以列表儲存已經預約好的區間 (start, end)\n        self.bookings = []\n\n    def book(self, start, end):\n        \"\"\"\n        嘗試預約區間 [start, end)。若與已存在的任何區間重疊，\n        直接回傳 False，否則將此區間加入並回傳 True。\n        \"\"\"\n        for s, e in self.bookings:\n            # 判斷兩區間是否有交集：max(s, start) < min(e, end)\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行是命令列表，第二行是對應的參數列表\n    commands = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    results = []\n    calendar = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCalendar\":\n            calendar = MyCalendar()\n            results.append(None)  # 代表 null\n        elif cmd == \"book\":\n            # args 為 [start, end]\n            res = calendar.book(*args)\n            results.append(res)\n        else:\n            # 若有其他命令，直接跳過或處理\n            results.append(None)\n\n    # 將結果轉成 JSON 風格的字串：null、true、false\n    out = []\n    for r in results:\n        if r is None:\n            out.append(\"null\")\n        elif r is True:\n            out.append(\"true\")\n        elif r is False:\n            out.append(\"false\")\n        else:\n            out.append(str(r))\n    print(f\"[{', '.join(out)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing MyCalendar class with book method that prevents double booking. Virtual code lines with explanation. Use Start, End, Decision. Probably use a list of intervals stored sorted, and when booking, check overlapping.\n\nWe produce pseudocode: Initialize empty list of intervals. In book(start, end), iterate over intervals, if overlap, return false. Else insert new interval in sorted order.\n\nAlso might use binary search. But simple linear scan fine.\n\nWe'll produce steps: Start, declare class, constructor, initialize list. Then book method: start, input, iterate over existing intervals: Decision if overlap? If Yes -> return false. If loop completes: insert interval. Return true. End.\n\nUse arrows accordingly. Provide brief explanation after each line.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MyCalendar // 宣告 MyCalendar 類別  \n→ → Constructor MyCalendar() // 建構子，初始化日曆物件  \n→ → → intervals ← EmptyList // 建立一個空的事件清單，用來儲存已加入的 [start, end)  \n→ → End // 建構子結束  \n→ → Method book(start, end) // book 方法，接受開始與結束時間  \n→ → → // 步驟 1: 檢查所有已存在的事件，是否與新事件有重疊  \n→ → → → Decision: For each (s, e) in intervals, 是否 s < end AND start < e? // 判斷區間交集是否非空  \n→ → → →     Yes → Return False // 若有重疊，拒絕預約並回傳 False  \n→ → → →     No  → // 沒有重疊，繼續檢查下一個事件  \n→ → → → End Decision  \n→ → → // 步驟 2: 若所有檢查均無重疊，將新事件加入清單  \n→ → → → intervals.append((start, end)) // 把 (start, end) 加入 intervals  \n→ → → → Return True // 成功預約，回傳 True  \n→ → End // book 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,6,0,6,1,4,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 6, 0, 6, 1, 4, 6]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # size of the allowed set\n        self.size = n - len(blacklist)\n        # map for blacklisted numbers that are in [0, size-1]\n        self.mapping = {}\n        black_set = set(blacklist)\n        last = n - 1  # start from the largest number\n        for b in blacklist:\n            if b < self.size:\n                # find the next non‑blacklisted number from the high end\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # pick a random index in the compacted range\n        idx = random.randint(0, self.size - 1)\n        # return the mapped value if idx is blacklisted, otherwise idx itself\n        return self.mapping.get(idx, idx)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            results.append(None)\n        elif op == \"pick\":\n            results.append(obj.pick())\n\n    # Convert Python None to JSON null for printing\n    out = []\n    for r in results:\n        if r is None:\n            out.append(\"null\")\n        else:\n            out.append(str(r))\n    print(f\"[{', '.join(out)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm. Classic solution: compress blacklist to range [0,m-1] where m = n - len(blacklist). Map blacklisted numbers >= m to whitelist numbers. Use hash map for mapping. So steps: preprocess: create set of blacklist, build map for blacklisted numbers in [0, m-1] to available numbers >= m. Then pick() random in [0,m-1], if in map, return mapped value else return itself. Implementation steps: Start, init. Use map. Pick: generate random, check map.\n\nWe need step-by-step virtual code with comments. Provide lines. Use arrows, decision etc. Let's craft.\n\nUse Start for constructor: Start → Step: initialize m = n - len(blacklist) // number of allowed values. → Step: create set B from blacklist // for O(1) lookup. → Step: create empty map M // mapping. → Step: set x = m // start pointer for candidate in high range. → Step: For each b in blacklist: if b < m: while x in B: x++ // find next non-blacklisted >= m. → Step: M[b] = x // map blacklisted low to high available. → Step: x++ // advance. End // initialization done.\n\nPick: Start → Step: r = random_int(0, m-1) // random in allowed range. → Decision: if r in M? Yes → Step: return M[r] // mapped value. No → Step: return r // not blacklisted.\n\nAdd End for pick.\n\nWe need to use \"Decision:\" lines. Let's produce.\n\nMake sure each line includes comment. Also we need arrow notation. Provide each line separately.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set m = n - length(blacklist) // m 為可選數字的總數\n→ Step 2: Convert blacklist to set B for O(1) 查找\n→ Step 3: Create empty mapping M // 用於將低範圍的黑名單映射到高範圍可用值\n→ Step 4: Initialize pointer x = m // 從 m 開始尋找可用高範圍數字\n→ Step 5: For each b in blacklist:\n    → Decision: 如果 b < m? // 只處理落在 [0, m-1] 的黑名單\n        Yes → Step 6: While x in B: x = x + 1 // 找到第一個不在黑名單的高範圍數字\n        Yes → Step 7: Set M[b] = x // 將低範圍黑名單映射到可用高範圍數字\n        Yes → Step 8: x = x + 1 // 讓指標移至下一個候選值\n        No  → Step 9: Continue // b >= m 不需要映射\nEnd // 初始化完成\n\nStart // pick() 開始執行\n→ Step 10: Generate r = random_int(0, m-1) // 隨機選取 [0, m-1]\n→ Decision: 如果 r 在 M? // 判斷是否有映射\n    Yes → Step 11: Return M[r] // 返回映射後的高範圍數字\n    No  → Step 12: Return r // 直接返回未被黑名單的數字\nEnd // pick() 結束執行"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '98'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '98'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def singleNumber(self, nums):\n        # 兩個位元集合：ones 只記錄出現一次的位元\n        #             twos 只記錄出現兩次的位元\n        ones, twos = 0, 0\n        for num in nums:\n            # 更新 twos：加入同時在 ones 與 num 的位元\n            twos |= ones & num\n            # 更新 ones：xor 之後剔除已經出現兩次的位元\n            ones ^= num\n            # 清除 ones 已經轉為兩次的位元，保證 twos 只剩真正兩次的\n            twos &= ~ones\n        return ones\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，尋找第一個方括號內的內容作為列表\n    data = sys.stdin.read()\n    match = re.search(r'\\[.*?\\]', data)\n    if not match:\n        raise ValueError(\"Input must contain a list of integers, e.g., 'nums = [1,2,3]'\")\n    nums = eval(match.group(0))  # 解析列表字串\n\n    sol = Solution()\n    result = sol.singleNumber(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode lines with explanations, for algorithm that finds single element where others appear three times. Standard solution uses bitwise counting modulo 3 with two state variables (ones, twos). Or use bit masks. Pseudocode:\n\nStart\n→ Step 1: initialize ones = 0, twos = 0 // bitwise state\n→ Step 2: for each num in nums\n→ Decision: process num\n→ inside: twos = twos | (ones & num)\n→ ones = ones ^ num\n→ twos = twos & (~ones)\n→ End for\n→ Step 3: return ones // single element\nEnd\n\nNeed to explain each line. Also need decisions? There's decision inside loop maybe not needed. Provide explanation. Use arrows. Provide as requested.\n\nLet's produce lines with comments. Use \"→\" preceding steps. For for loop we might use \"→ Step 2: 遍歷陣列\" etc. We'll maintain readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 ones = 0, twos = 0 // 用於追蹤出現 1 次與 2 次的位元  \n→ Step 2: 遍歷陣列 nums // 對每個數字進行處理  \n→     Step 2.1: twos = twos | (ones & num) // 將同時出現在 ones 與 num 的位元標記為出現 2 次  \n→     Step 2.2: ones = ones ^ num // 將 num 的位元與 ones 進行 XOR，得到目前只出現 1 次的位元  \n→     Step 2.3: twos = twos & (~ones) // 清除已經轉為 1 次的位元，確保 twos 僅保留真正出現 2 次的位元  \n→ Step 3: 返回 ones // ones 中剩下的位元即為唯一出現一次的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.19729804745354285,-0.714214372389958],[-0.9153184294564695,-0.22927660053778343],[0.34893855591738426,0.7471839235570884]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.19729804745354285, -0.714214372389958], [-0.9153184294564695, -0.22927660053778343], [0.34893855591738426, 0.7471839235570884]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機半徑 (均勻分佈)\n        r = self.radius * math.sqrt(random.random())\n        # 隨機角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換為直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    ops = json.loads(data[0].strip())\n    args = json.loads(data[1].strip())\n\n    res = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            obj = Solution(*args[i])\n            res.append(None)\n        else:\n            func = getattr(obj, op)\n            res.append(func())\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step for generating random point uniformly in a circle given radius and center. Use method: generate random angle theta in [0,2π), random radius r = radius * sqrt(rand()). Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). Provide steps: Start, initialize variables, generate random angle, random radius, compute point, return.\n\nAlso we need a class Solution with constructor and randPoint method. Provide steps accordingly.\n\nWe must not output actual code, just virtual steps.\n\nLet's produce step-by-step:\n\nStart\n→ Step: Define class Solution // 定義類別\n→ Step: Constructor(radius, x_center, y_center) // 初始化\n    Store radius, x_center, y_center as attributes\n→ Step: randPoint() // 生成隨機點\n    Step: Generate uniform random angle θ in [0, 2π) // 產生隨機角度\n    Step: Generate uniform random number u in [0,1) // 產生隨機數\n    Step: Compute r = radius * sqrt(u) // 將半徑按均勻分佈調整\n    Step: Compute x = x_center + r * cos(θ) // 計算 x 坐標\n    Step: Compute y = y_center + r * sin(θ) // 計算 y 坐標\n    Step: Return [x, y] // 返回點\nEnd\n\nWe need arrow formatting: \"→\" etc. Use decision? Not needed. Just straight flow.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use \"Start\" \"End\". For constructor, maybe \"Step: Store attributes\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義類別 Solution // 建立儲存半徑與圓心的類別  \n→ Step: Constructor(radius, x_center, y_center) // 初始化物件  \n  → Step: 保存 radius 為 this.radius // 記錄半徑  \n  → Step: 保存 x_center 為 this.x_center // 記錄圓心 x 座標  \n  → Step: 保存 y_center 為 this.y_center // 記錄圓心 y 座標  \n→ Step: randPoint() // 生成均勻隨機點  \n  → Step: 產生 θ = 2π * rand() // 取得 0~2π 的隨機角度  \n  → Step: 產生 u = rand() // 取得 0~1 的隨機數  \n  → Step: 計算 r = this.radius * sqrt(u) // 根據均勻分布調整半徑  \n  → Step: 計算 x = this.x_center + r * cos(θ) // 求得 x 坐標  \n  → Step: 計算 y = this.y_center + r * sin(θ) // 求得 y 坐標  \n  → Step: 回傳 [x, y] // 返回隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # next[i] = next index after i with same char, -1 if none\n    next_pos = [-1] * n\n    last = [-1] * 26\n    for i in range(n - 1, -1, -1):\n        c = ord(s[i]) - 97\n        next_pos[i] = last[c]\n        last[c] = i\n\n    # prev[i] = previous index before i with same char, -1 if none\n    prev_pos = [-1] * n\n    last = [-1] * 26\n    for i in range(n):\n        c = ord(s[i]) - 97\n        prev_pos[i] = last[c]\n        last[c] = i\n\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                next_i = next_pos[i]\n                prev_j = prev_pos[j]\n                if next_i == -1 or next_i > j:\n                    dp[i][j] = 2\n                elif next_i == prev_j:\n                    dp[i][j] = 3\n                else:\n                    inner = dp[i + 1][j - 1]\n                    if next_i + 1 <= prev_j - 1:\n                        outer = dp[next_i + 1][prev_j - 1]\n                    else:\n                        outer = 0\n                    dp[i][j] = (inner * 2 - outer) % MOD\n            else:\n                dp[i][j] = (dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]) % MOD\n            dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1] % MOD\n\ndef main():\n    data = sys.stdin.read()\n    data = data.strip()\n    # Extract string inside quotes if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # remove possible surrounding quotes or whitespace\n        s = data.strip().strip('\"').strip()\n    result = count_palindromic_subsequences(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: count distinct non-empty palindromic subsequences modulo 1e9+7.\n\nWe need to output line by line: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. No actual code. Just steps. Should describe algorithm: DP over intervals, handling duplicate chars, using next and prev arrays. Steps:\n\n1. Start\n2. Input string s\n3. Initialize mod\n4. Compute length n\n5. Build next and prev arrays for each position\n6. Create 2D dp array n x n\n7. For l from 1 to n: dp[i][i]=1\n8. For len from 2 to n: for i...\n9. For each interval [i,j], find next_i = next[i], prev_j = prev[j]\n10. If s[i]==s[j]:\n  a. if next_i>prev_j: dp[i][j] = 2\n  b. else if next_i==prev_j: dp[i][j] = 3\n  c. else: dp[i][j] = (dp[i+1][j-1]*2 - dp[next_i+1][prev_j-1]) % mod\n11. Else: dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % mod\n12. Ensure positive mod\n13. Result dp[0][n-1]\n14. Output result\n15. End\n\nNeed to format with arrow and decisions. Use Decision lines for if s[i]==s[j]. Use sub-decisions for next_i > prev_j etc.\n\nEnsure each line has explanation. Provide no actual code, just pseudo.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 取得待分析的字串\n→ Step 2: 設定常數 MOD = 1_000_000_007 // 取模值\n→ Step 3: 取得字串長度 n = length(s) // 方便後續索引\n→ Step 4: 建立陣列 next[0…n-1] 及 prev[0…n-1] // 用來記錄每個字符下一個相同字符的位置和上一個相同字符的位置\n→ Step 5: For each character c in 'a'..'z' // 初始化 next 與 prev\n    → Decision: 如果 c 在 s 中出現\n        Yes → 記錄該字符在 s 中的所有位置 idxList\n        → 對 idxList 從左到右\n            → Set next[idx] = idxList[nextIndex] 或 -1\n            → 設定 prev[idx] = idxList[prevIndex] 或 -1\n→ Step 6: 建立 2D 陣列 dp[n][n] 初始化為 0 // dp[i][j] 代表子字串 s[i..j] 的不同非空回文子序列數量\n→ Step 7: For i = 0 to n-1\n    → dp[i][i] = 1 // 單字元子序列本身就是回文\n→ Step 8: For len = 2 to n // 子字串長度遞增\n    → For i = 0 to n - len\n        → j = i + len - 1 // 子字串結尾索引\n        → Decision: s[i] == s[j] ? // 字首與字尾相同\n            Yes → Step 9: next_i = next[i] // 下個相同字符位置\n            → Step 10: prev_j = prev[j] // 上一個相同字符位置\n            → Decision: next_i > prev_j ? // 兩個相同字符之間無其他相同字符\n                Yes → dp[i][j] = 2 // 只包含兩種回文：單字符和兩字符回文\n                No  → Decision: next_i == prev_j ?\n                    Yes → dp[i][j] = 3 // 有且僅有一個中間相同字符，回文數為 3\n                    No  → Step 11: inner = dp[i+1][j-1] // 內部子字串的回文數\n                    → Step 12: outer = dp[next_i+1][prev_j-1] // 內部被跳過相同字符的回文數\n                    → dp[i][j] = (inner * 2 - outer) mod MOD // 將兩邊鏡像並減去重疊\n            No  → Step 13: dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) mod MOD // 字首字尾不同，合併兩種情況並扣除重疊\n→ Step 14: 確保 dp[i][j] 在 0 ~ MOD-1 之間 // 修正負數模\n→ Step 15: 結果 ans = dp[0][n-1] // 整個字串的答案\n→ Step 16: 輸出 ans // 顯示結果\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Palindromic Substring",
      "source_file": "Leetcode/leetcode5.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'bab'\nGot (Norm):      'aba'\n--- (Raw) ---\nRaw Expected: \"'bab'\"\nRaw Got:      'aba'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        使用「以中心展開」演算法尋找最長的回文子字串。\n        兩種情況：\n        1. 奇數長度：中心為單一字元 (i, i)\n        2. 偶數長度：中心為相鄰兩字元 (i, i+1)\n        \"\"\"\n        if not s:\n            return \"\"\n\n        start, end = 0, 0  # 目前已知最長回文子字串的起始與結束索引\n\n        for i in range(len(s)):\n            # 奇數長度回文\n            odd_len = self._expand(s, i, i)\n            # 偶數長度回文\n            even_len = self._expand(s, i, i + 1)\n            max_len = max(odd_len, even_len)\n\n            # 若新回文比目前已知更長，更新起始與結束索引\n            if max_len > end - start:\n                start = i - (max_len - 1) // 2\n                end = i + max_len // 2\n\n        return s[start:end + 1]\n\n    def _expand(self, s: str, left: int, right: int) -> int:\n        \"\"\"\n        從左、右指標開始，當 s[left] == s[right] 時繼續向外擴展。\n        回傳擴展後的回文長度。\n        \"\"\"\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1  # 右指標在回文外一格，左指標亦同\n\n\ndef _parse_input(raw: str) -> str:\n    \"\"\"\n    解析輸入，支援以下兩種常見格式：\n    1. 直接輸入字串，例如：babad\n    2. 帶有前綴的賦值式，例如：s = 'babad' 或 s=\"babad\"\n    \"\"\"\n    raw = raw.strip()\n    if raw.lower().startswith(\"s\"):\n        # 找到等號後的內容\n        try:\n            _, value = raw.split(\"=\", 1)\n        except ValueError:\n            # 無等號，直接使用原字串\n            return raw.strip(\" '\\\"\")\n        value = value.strip()\n        # 移除可能的單/雙引號\n        if (value.startswith(\"'\") and value.endswith(\"'\")) or \\\n           (value.startswith('\"') and value.endswith('\"')):\n            value = value[1:-1]\n        return value\n    return raw.strip(\" '\\\"\")\n\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    s = _parse_input(input_text)\n    sol = Solution()\n    result = sol.longestPalindrome(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm to find longest palindromic substring. Use center expansion approach. Provide each step line with explanation. Must not output actual code. Use Start, End, Decision, etc. Each line: virtual code step + space + // explanation.\n\nLet's create steps: Start; input string; initialize variables for start and end indices; for each index i as center; expand odd and even; update start and end; after loop output substring; End.\n\nAlso include decisions for expanding. Each step line may include arrow.\n\nLet's produce. Ensure each line has \"虛擬碼步驟\" text? The example: \"→ Step 1: 輸入使用者數字\". We'll use similar.\n\nWe need to include arrow only for step lines? The example uses \"→\" before each step. So we should start with \"Start\". Then \"→\" lines. Then \"End\". Use Decision lines with indent. Provide explanation.\n\nMake sure no actual code. Use \"Step\" maybe.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 讀取需要分析的字串  \n→ Step 2: 初始化 start = 0, end = 0 // 記錄目前找到的最大回文子字串起始與結束位置  \n→ Decision: 對於每個索引 i 從 0 到 s.length - 1? // 逐個遍歷字串作為中心  \n    Yes → Step 3: 計算 oddLen = expandAroundCenter(s, i, i) // 奇數長度回文 (中心為單一字符)  \n    Yes → Step 4: 計算 evenLen = expandAroundCenter(s, i, i + 1) // 偶數長度回文 (中心為相鄰兩字符)  \n    Yes → Step 5: maxLen = max(oddLen, evenLen) // 取兩種擴展方式中較長的回文長度  \n    Yes → Decision: maxLen > end - start? // 是否比目前已知最大回文長度更長  \n        Yes → Step 6: 更新 start = i - (maxLen - 1) / 2 // 重新計算回文子字串的起始位置  \n        Yes → Step 7: 更新 end = i + maxLen / 2 // 重新計算回文子字串的結束位置  \n→ Step 8: 回傳子字串 s[start:end+1] // 將最長回文子字串輸出  \nEnd // 程式執行結束\n\n// Helper: expandAroundCenter(s, left, right) // 在給定左右指標開始向外擴展，返回回文長度  \n// 迭代當 s[left] == s[right] 時 left--, right++，最後長度為 right - left - 1 。"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3' 的輸入。\n    \"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) < 3:\n        raise ValueError(\"輸入格式不正確\")\n\n    # 解析 strs\n    list_match = re.search(r'\\[(.*?)\\]', parts[0])\n    if list_match:\n        list_content = list_match.group(1)\n        strs = re.findall(r'\"([^\"]*)\"', list_content)\n    else:\n        strs = []\n\n    # 解析 m\n    m_match = re.search(r'm\\s*=\\s*(\\d+)', parts[1])\n    m = int(m_match.group(1)) if m_match else 0\n\n    # 解析 n\n    n_match = re.search(r'n\\s*=\\s*(\\d+)', parts[2])\n    n = int(n_match.group(1)) if n_match else 0\n\n    return strs, m, n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    strs, m, n = parse_input(data)\n    solution = Solution()\n    result = solution.findMaxForm(strs, m, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for solving the problem: Largest subset of binary strings with at most m zeros and n ones. It's like DP knapsack 2D. We'll produce pseudocode lines. Use Start, Decision, etc. Must include each line with explanation. Provide lines for reading input, DP table init, iterate strings, count zeros ones, nested loops for DP update, etc.\n\nWe need to be careful to use virtual code with arrows. Use “→” after Start, etc.\n\nWe'll produce something like:\n\nStart // program start\n→ Input array strs, integers m, n // obtain inputs\n→ Initialize DP table dp[0..m][0..n] to 0 // 2D DP\n→ For each string s in strs // iterate over strings\n    → Count zeros z in s\n    → Count ones o in s\n    → Decision: if z > m or o > n? // skip strings that exceed limits\n        Yes → Continue // skip\n        No  →\n            → For i from m down to z // iterate backwards to avoid reuse\n                → For j from n down to o\n                    → Update dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // add this string\n← (end for strings)\n→ Result = dp[m][n] // largest subset size\n→ Output result\nEnd // program end\n\nAdd explanations after each line.\n\nAlso need to show the decision branches with arrow. Use indentation? The example shows indentation via spaces.\n\nWe'll produce each line with the arrow at start. Use indentation for decision block.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ Input strs, m, n // 讀取字串陣列和限制數量\n→ Initialize dp[0..m][0..n] to 0 // 建立二維 DP 表，初始為 0\n→ For each string s in strs // 處理每個二進位字串\n    → Count zeros z in s // 計算此字串中的 0 個數\n    → Count ones o in s // 計算此字串中的 1 個數\n    → Decision: z > m or o > n? // 這個字串是否超出限制\n        Yes → Continue // 超出限制，跳過此字串\n        No  → // 仍可加入\n            → For i from m down to z // 以遞減方式更新 DP，避免重複使用\n                → For j from n down to o\n                    → dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // 更新子問題答案\n← (end for each string)\n→ Result = dp[m][n] // 取最大子集大小\n→ Output Result // 顯示答案\nEnd // 程式結束\n\nMake sure each line ends with // 解釋.\n\nWe need to use \"→\" at start of each line except Start and End? In example they start with \"Start\" no arrow. Then each step line begins with \"→\". Decision block uses indentation and \"Yes →\" and \"No →\". Also \"← (end for strings)\" but that is not a virtual code step? The example didn't include '←' but just shows 'End'. So we can just close for loops with indentation and no arrow. But to be safe, we can write \"→\" for the start of inner loops, but need to show indentation. Eg:\n\n→ For each string s in strs // ...\n    → Count zeros z in s // ...\n    → Count ones o in s // ...\n    → Decision: z > m or o > n? // ...\n        Yes → Continue // ...\n        No  → \n            → For i from m down to z // ...\n                → For j from n down to o // ...\n                    → dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // ...\n\nThis matches.\n\nWe should include indentation spaces before inner lines. In the example, they used 4 spaces indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input strs, m, n // 讀取字串陣列與最大 0 與 1 的限制  \n→ Initialize dp[0..m][0..n] to 0 // 建立二維 DP 表，初始值為 0  \n→ For each string s in strs // 逐一處理每個二進位字串  \n    → Count zeros z in s // 計算該字串中的 0 數量  \n    → Count ones o in s // 計算該字串中的 1 數量  \n    → Decision: z > m or o > n? // 該字串是否超出可用的 0 或 1 限制  \n        Yes → Continue // 超出限制，跳過此字串  \n        No → // 仍可加入集合  \n            → For i from m down to z // 以遞減方式更新 DP，避免重複使用同一字串  \n                → For j from n down to o  \n                    → dp[i][j] = max(dp[i][j], dp[i‑z][j‑o] + 1) // 更新子問題答案  \n→ Result = dp[m][n] // 取得可達到的最大子集大小  \n→ Output Result // 顯示答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Target Sum",
      "source_file": "Leetcode/leetcode494.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpofvgzsfg.py\", line 21, in <module>\n    nums, target = eval(data)\n                   ^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [1,1,1,1,1], target = 3\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg7j_6gra.py\", line 21, in <module>\n    nums, target = eval(data)\n                   ^^^^^^^^^^\n  File \"<string>\", line 1\n    nums = [1], target = 1\n         ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        dp = defaultdict(int)\n        dp[0] = 1\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s in dp:\n                next_dp[s + num] += dp[s]\n                next_dp[s - num] += dp[s]\n            dp = next_dp\n        return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # The input is in the form: 'nums = [...], target = ...'\n    nums, target = eval(data)\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: given array nums, target, count number of expressions using + or - before each integer that evaluate to target. This is typical target sum problem. Approach: dynamic programming or recursion with memoization. Provide virtual code steps line by line with explanations. Let's produce Start, steps: input, define DP or recursion. Provide decisions. Use arrow for each step. Should avoid actual code but represent algorithmically.\n\nWe need to output steps. Let's produce a generic algorithm: Use recursion with memoization or DP with map of sums. Let's produce DP: dp[i][sum] = number of ways to reach sum after processing first i numbers. We'll shift sums by offset due to negative. Or use HashMap incremental.\n\nSimplify: Use recursion with memoization: function dfs(index, current_sum) returns count. If index==len(nums): if current_sum==target return 1 else 0. Else: return dfs(index+1, current_sum+nums[index]) + dfs(index+1, current_sum-nums[index]). Use memoization on (index,current_sum). Provide steps accordingly.\n\nLet's produce virtual code steps:\n\nStart\n→ Step 1: Read array nums and integer target // Input acquisition\n→ Step 2: Define memoization map memo // For caching intermediate results\n→ Step 3: Define recursive function DFS(i, sum) // Compute ways from index i with current sum\n→ Step 4: Decision: 如果 i == length(nums)? // Base case check\n    Yes → Step 5: Decision: 如果 sum == target? // Check if expression equals target\n        Yes → Step 6: Return 1 // Found a valid expression\n        No  → Step 7: Return 0 // Not valid\n    No  → Step 8: Check memo for key (i,sum) // Avoid recomputation\n        Yes → Step 9: Return memo value // Cached result\n        No  → Step 10: Step 11: Call DFS(i+1, sum + nums[i]) // Add '+' before current number\n            → Step 12: Call DFS(i+1, sum - nums[i]) // Add '-' before current number\n            → Step 13: Sum results from step 11 and 12 // total ways from this state\n            → Step 14: Store in memo key (i,sum) // Cache\n            → Step 15: Return total // Return computed ways\n→ Step 16: Call DFS(0, 0) // Start from first number with initial sum 0\n→ Step 17: Store result as totalWays // Final answer\n→ End // Program ends\n\nWe also need to adhere to format: each line \"虛擬碼步驟 // 解釋\". Use arrows \"→\" and indent. Should we include indentation? They used indentation with Decision etc. Use spaces after arrows. Provide indentation for decision branches. Let's produce accordingly.\n\nWe need to ensure each line includes the virtual step and explanation after a single space. Use // comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums 與目標值 target // 取得輸入\n→ Step 2: 建立空的快取結構 memo // 用於儲存已計算過的子問題\n→ Step 3: 定義遞迴函式 DFS(i, sum) // 計算從第 i 個數字開始，已累加 sum 時的合法表達式數量\n→ Decision: i == nums.length? // 判斷是否已處理完所有數字\n    Yes → Decision: sum == target? // 判斷目前累加值是否等於目標\n        Yes → Step 4: 回傳 1 // 找到一個符合目標的表達式\n        No  → Step 5: 回傳 0 // 不是符合目標的表達式\n    No  → Step 6: 檢查 memo 中是否已存在鍵 (i, sum) // 若已計算過則直接取用\n        Yes → Step 7: 回傳 memo[(i, sum)] // 取快取結果\n        No  → Step 8: 呼叫 DFS(i+1, sum + nums[i]) // 為第 i 個數字加上正號\n            → Step 9: 呼叫 DFS(i+1, sum - nums[i]) // 為第 i 個數字加上負號\n            → Step 10: 取得 step 8 與 step 9 的結果之和 // 總共有幾個合法表達式\n            → Step 11: 將 (i, sum) → 這個和 存入 memo // 記錄快取\n            → Step 12: 回傳 step 10 的和 // 回傳此子問題的答案\n→ Step 13: 設定 totalWays ← DFS(0, 0) // 從第一個數字開始，初始累加值為 0\n→ End // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 保存原始陣列的拷貝\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的拷貝，確保不被外部改動\n        return list(self.original)\n\n    def shuffle(self):\n        # Fisher‑Yates 洗牌演算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得兩個 JSON 陣列：操作名稱與對應參數\n    close_bracket = data.find(']')\n    ops_str = data[:close_bracket + 1]\n    args_str = data[close_bracket + 1:].lstrip(',').strip()\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    outputs = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])  # arg[0] 是傳入的 nums 陣列\n            outputs.append(None)     # 初始化時回傳 null\n        elif op == \"reset\":\n            outputs.append(obj.reset())\n        elif op == \"shuffle\":\n            outputs.append(obj.shuffle())\n\n    # 輸出結果，None 會被轉成 JSON 的 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: constructor stores original array and a copy, reset returns original copy, shuffle uses Fisher-Yates. Provide lines with arrow, decision.\n\nLet's craft steps:\n\nStart\n\n→ Step 1: Store original array reference\n\n→ Step 2: Create a mutable copy of original array for shuffling\n\n→ Decision: None\n\n→ Step 3: Method reset()\n\n   → Step 3.1: Return a copy of original array\n\n→ Step 4: Method shuffle()\n\n   → Step 4.1: Create a copy of original array to shuffle\n\n   → Step 4.2: For i from 0 to length-1\n\n      → Decision: i < n-1? Actually loop\n\n   We can express loop: → Loop over indices\n\n   → Step 4.3: Randomly select j between i and n-1\n\n   → Step 4.4: Swap elements at i and j\n\n   → Step 4.5: End loop\n\n   → Step 4.6: Return shuffled array\n\nEnd\n\nBut need to use arrow and Decision, structure. Let's produce.\n\nLet's do:\n\nStart\n\n→ Step 1: Store original array reference // Save original configuration\n\n→ Step 2: Create a mutable copy of original array // For shuffling\n\nEnd // end constructor\n\nThen methods: we need to indicate methods separately. Maybe:\n\n→ Step 3: Method reset() // Define reset function\n\n   → Step 3.1: Return a copy of original array // Ensure original remains unchanged\n\n→ Step 4: Method shuffle() // Define shuffle function\n\n   → Step 4.1: Create a copy of original array // Start with original values\n\n   → Step 4.2: For i from 0 to n-1\n\n      → Decision: i < n-1? Actually for loop covers all indices; we can simply express loop\n\n   Provide loop: → Loop i = 0 to n-1\n\n      → Step 4.3: Randomly pick j between i and n-1 // Random index in remaining range\n\n      → Step 4.4: Swap arr[i] with arr[j] // Perform Fisher-Yates swap\n\n   → Step 4.5: Return arr // Return shuffled array\n\nEnd // end program\n\nLet's format with arrows.\n\nWe need to follow example: Use indentation for decisions. Use `Yes →` `No →`. For loops we can show as `Loop` maybe.\n\nExample:\n\n→ Step 4.2: Loop i from 0 to n-1 // Iterate over array indices\n\n→ Step 4.3: Random j in [i, n-1] // Random index\n\n→ Step 4.4: Swap arr[i], arr[j] // Swap elements\n\nBetter include `Decision:` for if j==i? Not necessary.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store original array reference // 先將傳入的 nums 存成原始配置  \n→ Step 2: Create a mutable copy of original array // 建立一份可變動的拷貝用於洗牌  \nEnd // 建構子結束  \n\n→ Step 3: Method reset() // 定義重設方法  \n   → Step 3.1: Return a copy of original array // 回傳原始順序，確保不改變原始資料  \n\n→ Step 4: Method shuffle() // 定義洗牌方法  \n   → Step 4.1: Create a copy of original array // 先用原始資料作為洗牌起點  \n   → Step 4.2: Loop i from 0 to n-1 // 逐一遍歷每個索引  \n      → Step 4.3: Random j in [i, n-1] // 隨機選取從 i 到最後一個位置的索引  \n      → Step 4.4: Swap arr[i], arr[j] // 交換 i 與 j 的元素，執行 Fisher-Yates 洗牌  \n   → Step 4.5: Return arr // 回傳已洗好的陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    res = []\n    def backtrack(start, path):\n        res.append(path[:])                     # 把目前的子集加入結果\n        for i in range(start, len(nums)):\n            path.append(nums[i])                # 加入下一個元素\n            backtrack(i + 1, path)              # 進一步遞迴\n            path.pop()                          # 回溯，移除最後加入的元素\n    backtrack(0, [])\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 從輸入中提取方括號內的內容並安全地轉成列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = []\n    else:\n        nums = ast.literal_eval(data[start:end+1])\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of a unique integer array. Use recursion or iterative, but virtual code. Use Start, Decision, etc. Provide each line: virtual step + comment. We'll use recursion/backtracking. Steps:\n\nStart\n→ Read input array nums\n→ Initialize result list subsets as empty list\n→ Call Backtrack(index=0, current=[])\n→ Backtrack(index):\n   - Add copy of current to subsets // record subset\n   - For each i from index to len(nums)-1:\n        - Append nums[i] to current\n        - Call Backtrack(i+1, current)\n        - Pop last from current // backtrack\n→ Return subsets\nEnd\n\nWe'll produce virtual code lines accordingly. Use arrows and decisions. Need to include arrow \"→\" at each step. Provide explanation after space. Use virtual code arrow syntax. Ensure each line is separate. Let's craft.\n\nStart\n→ Step 1: 接收輸入陣列 nums // 取得唯一整數元素的列表\n→ Step 2: 初始化結果 subsets 為空清單 // 用於存放所有子集\n→ Step 3: 定義遞迴函式 Backtrack(index, current) // index: 當前處理的起始位置\n→ Decision: 是否已處理完所有元素? // 判斷 index 是否超過陣列長度\n    Yes → Step 4: 把 current 的拷貝加入 subsets // 記錄目前的子集\n    No  → Step 5: 把 current 的拷貝加入 subsets // 記錄子集\n        → Step 6: 循環 i 從 index 到 len(nums)-1\n            → Step 7: 把 nums[i] 加入 current // 將元素加入子集\n            → Step 8: 呼叫 Backtrack(i+1, current) // 進一步處理剩餘元素\n            → Step 9: 移除 current 的最後一個元素 // 回溯\n→ Step 10: 呼叫 Backtrack(0, []) // 從起始位置開始\n→ Step 11: 回傳 subsets // 輸出所有子集\nEnd\n\nBut need arrow format: use \"→\" before each step, not indentation maybe. Use Decision with Yes →, No → lines. Provide explanations. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得唯一整數元素的列表  \n→ Step 2: 初始化結果集合 subsets 為空清單 // 用於存放所有子集  \n→ Step 3: 定義遞迴函式 Backtrack(index, current) // index 為當前起始位置，current 為正在構建的子集  \n→ Decision: 是否已處理完所有元素? // 判斷 index 是否超過陣列長度  \n Yes → Step 4: 把 current 的拷貝加入 subsets // 記錄目前已完成的子集  \n No  → Step 5: 把 current 的拷貝加入 subsets // 無論是否完成，先把當前子集加入結果  \n  → Step 6: 循環 i 從 index 到 len(nums)-1 // 對每個可選元素進行遞迴  \n   → Step 7: 把 nums[i] 加入 current // 把元素加入正在構建的子集  \n   → Step 8: 呼叫 Backtrack(i+1, current) // 進一步處理剩餘元素  \n   → Step 9: 移除 current 的最後一個元素 // 回溯，恢復到上一狀態  \n→ Step 10: 呼叫 Backtrack(0, []) // 從起始位置開始生成子集  \n→ Step 11: 回傳 subsets // 輸出所有生成的子集集合  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}               # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> keys in order of usage\n\n    def _update(self, key: int):\n        \"\"\"Increase frequency of key by one and reposition it.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from its current frequency list\n        del self.freq_to_keys[freq][key]\n        # If this freq list becomes empty and it was the minimum, bump min_freq\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        # Update stored frequency\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value, then refresh frequency\n            _, freq = self.key_to_val_freq[key]\n            self.key_to_val_freq[key] = (value, freq)\n            self._update(key)\n            return\n        # If cache is full, evict least frequently used key\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict the oldest key in the min_freq list\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Split the two top‑level lists: operations and arguments\n    split_idx = data.find('],')\n    if split_idx == -1:\n        # Input might be a single line with both lists separated by comma\n        split_idx = data.find('],')\n    ops_str = data[:split_idx + 1]          # include closing bracket\n    args_str = data[split_idx + 2:].strip()  # skip '],'\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    cache = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            results.append(cache.get(arg[0]))\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for LFUCache with get and put in O(1). Use typical approach: hash map key->Node (value, freq, iterator). freq->LinkedHashSet of keys (ordered by recency). minFreq tracking. Steps: init, get, put, update freq. Provide step by step with comments.\n\nWe must produce each line with virtual code + comment. Use arrows. Use Start, End, Decision. Should include all steps. We'll write in a pseudocode style but with explanatory lines.\n\nWe need to design data structures: capacity, minFreq, keyToNode map, freqToKeys map.\n\nDefine Node: value, freq. In freqToKeys, use linked list (LRU within same freq). We can represent with list of keys. We'll just mention operations: addToFreq, removeFromFreq, evict.\n\nWe'll produce virtual code for initialization, get, put, updateFreq, evict. Provide step-by-step.\n\nLet's structure as:\n\nStart\n→ Step: 初始化 capacity, minFreq=0, keyMap=空, freqMap=空\nDefine functions: get, put, updateFreq, evict.\n\nIn get:\n→ Decision: key存在?\n    Yes → Step: val=keyMap[key].value\n          → Call updateFreq(key)\n          → Return val\n    No → Return -1\n\nIn put:\n→ Decision: capacity==0? → Return\n→ Decision: key存在?\n    Yes → Update value, call updateFreq\n    No → Decision: size==capacity?\n        Yes → evict()\n        No →\n    → Insert new node with freq=1, update maps, minFreq=1\n\nupdateFreq:\n→ Remove key from freqMap[oldFreq]\n→ If freqMap[oldFreq] empty and oldFreq==minFreq -> minFreq++\n→ freq = oldFreq+1\n→ Add key to freqMap[freq]\n→ Update keyMap[key].freq = freq\n\nevict:\n→ Get freqMap[minFreq] -> keys list\n→ KeyToEvict = first key in list (least recent)\n→ Remove key from freqMap[minFreq]\n→ Remove key from keyMap\n\nWe need to show lines.\n\nLet's craft accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: 初始化 LFUCache // 建立容量、最小頻率以及兩張映射表\n    capacity ← input\n    minFreq ← 0\n    keyMap ← 空映射 (key → Node{value, freq})\n    freqMap ← 空映射 (freq → LinkedHashSet of keys) // 以插入順序保持 LRU\n\n→ Step 2: 定義函式 get(key) // 取得鍵值\n    → Decision: 若 key 存於 keyMap? // 檢查鍵是否存在\n        Yes →\n            value ← keyMap[key].value\n            → Call updateFreq(key) // 更新頻率\n            → Return value\n        No  → Return -1\n\n→ Step 3: 定義函式 put(key, value) // 插入或更新鍵值\n    → Decision: 若 capacity == 0? // 空容量直接返回\n        Yes → Return\n    → Decision: 若 key 存於 keyMap? // 已存在則更新\n        Yes →\n            keyMap[key].value ← value\n            → Call updateFreq(key)\n        No  →\n            → Decision: 若 keyMap.size == capacity? // 必須先移除\n                Yes → → Call evict()\n                No  →\n            keyMap[key] ← Node{value, freq: 1}\n            → Add key 到 freqMap[1]\n            minFreq ← 1 // 新鍵加入後最小頻率重置\n\n→ Step 4: 定義函式 updateFreq(key) // 由頻率遞增 1\n    oldFreq ← keyMap[key].freq\n    → Remove key from freqMap[oldFreq]\n    → Decision: 若 freqMap[oldFreq] 為空 AND oldFreq == minFreq? // 若最小頻率表空\n        Yes → minFreq ← minFreq + 1\n    newFreq ← oldFreq + 1\n    → Add key 到 freqMap[newFreq]\n    keyMap[key].freq ← newFreq\n\n→ Step 5: 定義函式 evict() // 刪除最少使用的鍵\n    → Get firstKey ← freqMap[minFreq].first() // 最舊的鍵\n    → Remove firstKey from freqMap[minFreq]\n    → Remove firstKey from keyMap\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsi9k2sbb.py\", line 22, in <module>\n    indexDiff = int(parts[1].split('=')[1].strip())\n                    ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqdx_dxpg.py\", line 22, in <module>\n    indexDiff = int(parts[1].split('=')[1].strip())\n                    ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\ndef containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff):\n    if indexDiff <= 0 or valueDiff < 0:\n        return False\n    n = len(nums)\n    for i in range(n):\n        max_j = min(i + indexDiff, n - 1)\n        for j in range(i + 1, max_j + 1):\n            if abs(nums[i] - nums[j]) <= valueDiff:\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expected format: 'nums = [...], indexDiff = X, valueDiff = Y'\n    parts = data.split(',')\n    nums_str = parts[0].split('=')[1].strip()\n    indexDiff = int(parts[1].split('=')[1].strip())\n    valueDiff = int(parts[2].split('=')[1].strip())\n\n    nums = eval(nums_str)\n    result = containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to output virtual code lines. We need to process array, check pairs with constraints. Probably use nested loops but better use sliding window and hash map to find near indices difference <= indexDiff. However since we want simple, we can use nested loops with break on condition.\n\nGiven we only output pseudo code lines, no actual code. Must use arrow \"→\". We can design algorithm: for i from 0 to n-1: for j from i+1 to min(i+indexDiff, n-1): if abs(nums[i]-nums[j]) <= valueDiff: return true. After loops return false.\n\nWe'll produce Start, loops, decisions, return. Use Decision lines.\n\nWe need to be concise: Use Step numbers optional? We can just give steps.\n\nWe must use format: 虛擬碼步驟 [space] // 解釋\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 定義 n = nums.length // 取得陣列長度\n→ Step 2: 對 i 從 0 到 n-1 迴圈 // 外層循環遍歷所有索引\n    → Step 3: 定義 maxJ = min(i + indexDiff, n-1) // j 的最大可達索引\n    → Step 4: 對 j 從 i+1 到 maxJ 迴圈 // 內層循環只檢查相距 <= indexDiff 的索引\n        → Decision: abs(nums[i] - nums[j]) <= valueDiff? // 檢查值差條件\n            Yes → Step 5: 返回 true // 找到符合條件的對，結束\n            No  → // 繼續內層循環\n    → // 內層循環結束，繼續外層\n→ // 外層循環結束\n→ Step 6: 返回 false // 未找到任何符合條件的對\nEnd // 程式結束\n\nMake sure each line follows \"虛擬碼步驟 // 解釋\" with no extra.\n\nAlso we should indent lines properly but keep arrow format.\n\nWe'll produce exactly that.\n\nCheck requirement: Use arrows (→, Yes →, No →) and structure (Start, End, Decision:). Good.\n\nAlso \"Step\" can be considered \"虛擬碼步驟\". We'll use \"Step X:\".\n\nAlso we need each line separated, no blank lines except maybe indentation. We'll indent inner lines with spaces but still include arrow at beginning.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 n = nums.length // 取得陣列長度  \n→ Step 2: 對 i 從 0 到 n-1 迴圈 // 外層循環遍歷所有索引  \n → Step 3: 定義 maxJ = min(i + indexDiff, n-1) // j 的最大可達索引  \n → Step 4: 對 j 從 i+1 到 maxJ 迴圈 // 內層循環只檢查相距 <= indexDiff 的索引  \n  → Decision: abs(nums[i] - nums[j]) <= valueDiff? // 檢查值差條件  \n   Yes → Step 5: 返回 true // 找到符合條件的對，結束  \n   No  → // 繼續內層循環  \n → // 內層循環結束，繼續外層  \n→ // 外層循環結束  \n→ Step 6: 返回 false // 未找到任何符合條件的對  \nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Completing Word",
      "source_file": "Leetcode/leetcode748.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]",
          "expected_output": "\"steps\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwz6k7uqe.py\", line 35, in <module>\n    license_plate, words = parse_input(raw_input)\n                           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwz6k7uqe.py\", line 27, in parse_input\n    data_dict = ast.literal_eval('{' + data.replace('=', ':') + '}')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x75d20c2f7b50>"
        },
        {
          "example_index": 1,
          "input": "licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"]",
          "expected_output": "\"pest\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppo66ykd3.py\", line 35, in <module>\n    license_plate, words = parse_input(raw_input)\n                           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppo66ykd3.py\", line 27, in parse_input\n    data_dict = ast.literal_eval('{' + data.replace('=', ':') + '}')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x79753fffbb90>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport collections\n\ndef shortest_completing_word(license_plate: str, words):\n    \"\"\"Return the shortest word that contains all letters of license_plate.\"\"\"\n    # Count letters in license_plate (case‑insensitive, ignore non‑letters)\n    plate_count = collections.Counter(c.lower() for c in license_plate if c.isalpha())\n\n    best_word = None\n    for word in words:\n        # Count letters in the candidate word (case‑insensitive)\n        word_count = collections.Counter(word.lower())\n        # Check if word satisfies all required letter counts\n        if all(word_count[ch] >= plate_count[ch] for ch in plate_count):\n            # Keep the first shortest word encountered\n            if best_word is None or len(word) < len(best_word):\n                best_word = word\n    return best_word\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n    licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"]\n    \"\"\"\n    # Replace '=' with ':' to turn it into a valid dict literal\n    data_dict = ast.literal_eval('{' + data.replace('=', ':') + '}')\n    return data_dict['licensePlate'], data_dict['words']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    license_plate, words = parse_input(raw_input)\n    answer = shortest_completing_word(license_plate, words)\n    # Output with surrounding double quotes as required by the examples\n    print(f'\"{answer}\"')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We must parse licensePlate, count letters ignoring digits and spaces, case-insensitive. Then iterate over words in order, check if word satisfies counts. Track shortest length and first occurrence. At end return word.\n\nNeed to use virtual steps with arrows. Format:\n\nStart\n→ Step: 解析 licensePlate\n→ Step: 建立字母計數表\n→ Step: 迴圈遍歷 words\n    → Decision: word 長度 >= 最短長度? // optional\n    → Decision: word 是否滿足計數? // check\n        Yes → Update 最短word\nEnd\n\nWe must output each line with comment. Use virtual code arrow syntax. No actual code.\n\nLet's craft detailed step-by-step with explanations.\n\nWe must include lines for reading licensePlate and words array, building count map, etc.\n\nLet's produce.\n\nAlso mention case-insensitive: convert to lowercase.\n\nWe must ignore non letters: filter char.isalpha().\n\nImplement count map as dictionary.\n\nWhen checking a word, create a temporary map of counts of letters in word, or iterate through licensePlate counts and count occurrences in word.\n\nSimpler: for each letter and required count, count in word using a loop or dictionary.\n\nIn pseudo, we can say \"Count occurrences of each letter in word\".\n\nAlso need to maintain bestWord and bestLen.\n\nReturn bestWord.\n\nEdge cases: if multiple shortest, first occurrence is chosen because we update only if length < bestLen or (length == bestLen and first? Actually we choose first occurrence, so we only update if length < bestLen. For same length, keep earlier. So no update if equal length.\n\nLet's craft steps.\n\nNow produce the output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: licensePlate ← 輸入字串 // 取得題目給定的 licensePlate  \n→ Step 2: words ← 輸入字串陣列 // 取得候選單字列表  \n→ Step 3: licenseMap ← 空字典 // 建立字母計數表  \n→ Step 4: 對於每個字符 ch 在 licensePlate  \n  → Decision: ch 是否為字母? // 忽略數字與空格  \n   Yes → Step 5: ch ← 小寫 ch  \n    → Decision: ch 是否已存在於 licenseMap?  \n     Yes → Step 6: licenseMap[ch] ← licenseMap[ch] + 1  \n     No  → Step 7: licenseMap[ch] ← 1  \n→ Step 8: bestWord ← 空字串 // 儲存目前最短完成字  \n→ Step 9: bestLen ← 無限大 // 初始化最短長度  \n→ Step 10: 對於每個 word 在 words（順序）  \n  → Decision: word 長度 < bestLen? // 先排除已比最佳更長的字  \n   Yes → Step 11: wordMap ← 空字典 // 建立字母計數表 (用於檢驗)  \n    → Step 12: 對於每個字符 c 在 word  \n     → Decision: c 是否為字母?  \n      Yes → c ← 小寫 c  \n       → Decision: c 是否已存在於 wordMap?  \n        Yes → wordMap[c] ← wordMap[c] + 1  \n        No  → wordMap[c] ← 1  \n      No  → 跳過此字元  \n    → Step 13: isComplete ← True // 判斷是否滿足 licenseMap  \n     → Decision: licenseMap 是否為空?  \n      Yes → isComplete ← True // 無字母需完成  \n      No  → Decision: 每個 (letter, count) 在 licenseMap  \n       → Decision: wordMap[letter] ≥ count?  \n        Yes → 繼續檢查下一個字母  \n        No  → isComplete ← False；離開迴圈  \n    → Decision: isComplete?  \n     Yes → Step 14: bestWord ← word // 更新最佳字  \n            bestLen ← word 長度 // 記錄最短長度  \n     No  → 繼續檢查下一個 word  \n→ End // 程式執行結束，bestWord 為答案 (可透過回傳或輸出)"
    },
    {
      "title": "Excel Sheet Column Number",
      "source_file": "Leetcode/leetcode171.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '521'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '521'"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '28'\nGot (Norm):      '13548'\n--- (Raw) ---\nRaw Expected: '28'\nRaw Got:      '13548'"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '701'\nGot (Norm):      '14221'\n--- (Raw) ---\nRaw Expected: '701'\nRaw Got:      '14221'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"\n        將 Excel 標題轉換為對應的列號。\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result\n\ndef extract_title(input_str: str) -> str:\n    \"\"\"\n    從輸入字串中提取 Excel 標題。  \n    支援兩種常見格式：\n    1. 僅包含字母，例如 \"AB\" 或 \"ZY\"。  \n    2. 包含「columnTitle = '...'」形式，例如 \"columnTitle = 'A'\"。\n    \"\"\"\n    # 取出所有大寫英文字母，直接合併\n    matches = re.findall(r\"[A-Z]+\", input_str)\n    return \"\".join(matches) if matches else \"\"\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    # 擷取標題\n    title = extract_title(raw_input)\n    # 轉換並輸出結果\n    solution = Solution()\n    print(solution.titleToNumber(title))",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line with comments. So typical algorithm: Initialize result=0, for each char in string: result = result*26 + (ord(char)-ord('A')+1). Return result.\n\nWe'll produce steps with Start, Decision maybe not necessary, but we can use loop and conversion. Use virtual code style: Start, → Step, Decision, End. Also include a Decision: If char is last? But we can just loop.\n\nWe'll produce like:\n\nStart // start\n→ Step 1: Set result = 0 // 初始化\n→ Step 2: Convert columnTitle to char array // 取得每個字元\n→ Decision: 是否有未處理字元? // 判斷是否還有字元\n   Yes → Step 3: 取下一個字元 ch // 取得下一個字元\n   → Step 4: result = result * 26 + (ch - 'A' + 1) // 更新列號\n   → Step 5: 移動到下一個字元 // 進行下一輪\n   → Decision: 是否還有字元? // 重複\n      Yes → 回到 Step 3\n      No → Step 6: 回傳 result // 返回結果\n   No → Step 6: 回傳 result // 返回結果\nEnd // 程式結束\n\nBut better to keep simple:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化列號\n→ Step 2: i ← 0 // 索引指向字串起始\n→ Decision: i < len(columnTitle)? // 是否還有字元待處理\n    Yes → Step 3: ch ← columnTitle[i] // 取得當前字元\n    → Step 4: result ← result * 26 + (ch - 'A' + 1) // 更新列號\n    → Step 5: i ← i + 1 // 移動索引\n    → Decision: i < len(columnTitle)? // 檢查是否仍有字元\n        Yes → 回到 Step 3\n        No → Step 6: return result // 回傳結果\n    No → Step 6: return result // 回傳結果\nEnd // 程式結束\n\nWe must include arrow syntax: \"→\" before steps, and \"Decision:\".\n\nMake sure each line has \" // 解釋\". Use Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化列號為 0  \n→ Step 2: i ← 0 // 索引指向字串起始位置  \n→ Decision: i < len(columnTitle) ? // 是否還有未處理字元？  \n    Yes → Step 3: ch ← columnTitle[i] // 取得當前字元  \n    → Step 4: result ← result * 26 + (ch - 'A' + 1) // 以 26 為基底更新列號  \n    → Step 5: i ← i + 1 // 移動到下一個字元  \n    → Decision: i < len(columnTitle) ? // 檢查是否仍有字元待處理  \n        Yes → 回到 Step 3 // 繼續處理下一個字元  \n        No  → Step 6: return result // 所有字元處理完畢，返回結果  \n    No  → Step 6: return result // 若起始就無字元，直接返回結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpikhyq3tb.py\", line 20, in <module>\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe0txdjju.py\", line 20, in <module>\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = json.loads(sys.stdin.read())\n    ops = data[0]          # list of operation names\n    args = data[1]         # list of argument lists\n    results = []\n    sol = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            sol = Solution(arg[0])   # arg[0] is the weight list\n            results.append(None)     # constructor has no return value\n        elif op == \"pickIndex\":\n            results.append(sol.pickIndex())\n        else:\n            # Unsupported operation, ignore or raise error\n            results.append(None)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: random weighted index selection. Provide step-by-step, with Start, End, Decision, etc.\n\nWe need to incorporate initialization (prefix sums), random number generation, binary search maybe. We'll produce generic pseudocode lines.\n\nWe should output lines like:\n\nStart // start program\n→ Step 1: 建立前綴和陣列 prefix[0..n-1] // compute cumulative weights\n→ Decision: 如果 prefix[0] > 0? // not needed maybe\n...\nWe'll need a function pickIndex().\n\nBetter structure: Initialization in constructor, then pickIndex uses random.\n\nLet's produce something like:\n\nStart // 程式開始\n→ Step 1: 定義變數 n ← w.length // 記錄長度\n→ Step 2: 建立空陣列 prefix[n] // 前綴和\n→ Step 3: prefix[0] ← w[0] // 第一個前綴和\n→ Step 4: 對 i 從 1 到 n-1 做\n    → Step 4.1: prefix[i] ← prefix[i-1] + w[i] // 更新前綴和\n→ Step 5: sum ← prefix[n-1] // 總重量\nEnd // 初始化結束\n\nThen pickIndex:\n\nStart // pickIndex 開始\n→ Step 1: r ← 隨機整數 0 ≤ r < sum // 產生隨機數\n→ Decision: 如果 r < prefix[0]? // 判斷是否在第一段\n    Yes → Step 2: 回傳 0 // 直接回傳\n    No → Decision: 1 < n-1?\n        Yes → Step 3: 用二分搜尋尋找最小 i 使得 prefix[i] > r // 找索引\n        → Step 4: 回傳 i // 返回\n        No → Step 5: 回傳 n-1 // 只有一個元素\nEnd // pickIndex 結束\n\nBut we should be more explicit with binary search pseudocode lines.\n\nMaybe produce a separate function findIndex(r) using binary search.\n\nOk produce:\n\nStart // pickIndex 開始\n→ Step 1: r ← 亂數 0 <= r < sum // 產生隨機數\n→ Step 2: left ← 0, right ← n-1 // 二分搜尋初始化\n→ Decision: left <= right? // 確保範圍\n    Yes → Step 3: mid ← floor((left+right)/2) // 計算中點\n        → Decision: prefix[mid] <= r? // r 是否小於等於前綴和\n            Yes → left ← mid + 1 // r 在右半區\n            No → right ← mid - 1 // r 在左半區\n        → Decision: left <= right? // 仍在範圍\n            Yes → repeat Step 3\n            No → Step 4: 回傳 left // left 為最小索引使得 prefix[left] > r\n    No → Step 5: 回傳 0 // 只一個索引的情況\nEnd\n\nBut need to maintain clarity.\n\nWe will output each line as \"虛擬碼步驟 // 解釋\" exactly.\n\nWe need to include \"Start\" \"End\" lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始，執行初始化與函式定義  \n→ Step 1: 定義變數 n ← w.length // 取得陣列長度  \n→ Step 2: 建立空陣列 prefix[n] // 前綴和陣列  \n→ Step 3: prefix[0] ← w[0] // 計算第一個前綴和  \n→ Step 4: 對 i 從 1 到 n-1 做  \n  → Step 4.1: prefix[i] ← prefix[i-1] + w[i] // 逐步累加得到前綴和  \n→ Step 5: sum ← prefix[n-1] // 總重量，用於隨機數上限  \n→ Step 6: 定義函式 pickIndex() // 從這裡開始實作隨機選取  \n  Start // pickIndex 開始  \n  → Step 1: r ← 亂數 0 ≤ r < sum // 產生 0~sum-1 之間的隨機整數  \n  → Step 2: left ← 0, right ← n-1 // 二分搜尋範圍初始化  \n  → Decision: left ≤ right? // 確認搜尋範圍仍有效  \n   Yes → Step 3: mid ← floor((left+right)/2) // 計算中點  \n    → Decision: prefix[mid] ≤ r? // 判斷 r 是否落在右側區間  \n     Yes → left ← mid + 1 // r 在右側，左界移動  \n     No  → right ← mid - 1 // r 在左側，右界移動  \n    → Decision: left ≤ right? // 若仍可繼續搜尋  \n     Yes → repeat Step 3 // 重新進行二分搜尋  \n     No  → Step 4: 回傳 left // left 為最小索引使 prefix[left] > r  \n   No → Step 5: 回傳 0 // n = 1 時直接回傳唯一索引  \n  End // pickIndex 結束  \nEnd // 程式執行結束"
    }
  ]
}