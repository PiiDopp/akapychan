{
  "run_index": 23,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 393,
  "generation_or_validation_failure_count": 46,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,4,6,6,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 4, 6, 6, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n: int):\n    \"\"\"\n    擲 n 次六面骰，回傳結果列表。\n    \"\"\"\n    # 如果 n 小於等於 0，直接回傳空列表\n    if n <= 0:\n        return []\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    input_code = sys.stdin.read().strip()\n\n    if not input_code:\n        # 沒有輸入，直接結束\n        sys.exit(0)\n\n    # 若輸入是形如 \"print(roll_dice(5))\" 的完整表達式\n    if input_code.startswith(\"print(\") and input_code.endswith(\")\"):\n        expr = input_code[6:-1]          # 去除 print( 與 )，得到實際表達式\n        try:\n            result = eval(expr, globals())\n            print(result)\n        except Exception as e:\n            print(f\"執行錯誤: {e}\")\n    else:\n        # 直接評估輸入，並將結果印出\n        try:\n            result = eval(input_code, globals())\n            print(result)\n        except Exception as e:\n            print(f\"執行錯誤: {e}\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with \"虛擬碼步驟\" and comment. Use arrows →, Start, End, Decision: etc. Use random module to generate random ints 1-6. The function roll_dice(n). Steps: Start, define function, initialize list, loop n times, generate random integer, append to list, return list, End. Also could include Decision if n <=0? maybe. But simple.\n\nLet's produce:\n\nStart\n→ Step 1: 定義函數 roll_dice(n) // 開始定義函數\n→ Step 2: 初始化結果列表 results = [] // 建立空列表儲存擲骰結果\n→ Decision: 如果 n <= 0? // 檢查擲骰次數是否合法\n    Yes → Step 3: 回傳空列表 [] // 次數非正，直接返回空列表\n    No  → Step 4: 進入迴圈 for i in range(n) // 擲 n 次\n        → Step 5: 產生 random.randint(1, 6) 並存入 variable roll // 產生單次擲骰結果\n        → Step 6: 將 roll 加入 results // 將結果加入列表\n→ Step 7: 回傳 results // 迴圈結束後回傳完整結果\nEnd\n\nWe need to include arrow for decisions. Each line \"虛擬碼步驟\" includes arrow and comment. Let's format accordingly.\n\nAlso we need to use \"Yes →\", \"No →\" for decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 roll_dice(n) // 開始定義函數  \n→ Step 2: 初始化結果列表 results = [] // 建立空列表儲存擲骰結果  \n→ Decision: 如果 n <= 0? // 檢查擲骰次數是否合法  \n Yes → Step 3: 回傳空列表 [] // 次數非正，直接返回空列表  \n No  → Step 4: 進入迴圈 for i in range(n) // 擲 n 次  \n  → Step 5: 產生 random.randint(1, 6) 並存入 variable roll // 產生單次擲骰結果  \n  → Step 6: 將 roll 加入 results // 將結果加入列表  \n→ Step 7: 回傳 results // 迴圈結束後回傳完整結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 的執行時間（秒），四捨五入至小數點 3 位。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入中的全部程式碼，執行並輸出結果。\n    \"\"\"\n    code = sys.stdin.read()\n    # 執行時的命名空間，已經將 measure_time 以及 time 模組放入\n    global_ns = {'measure_time': measure_time, 'time': time}\n    exec(code, global_ns)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line, with explanation. Use arrow, start, end, decision. No actual code. So steps: import time, define function measure_time, record start time, call func(*args), record end time, compute elapsed, round to 3 decimals, return result. Also maybe return both elapsed and function result? The requirement: \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\" Probably means return the elapsed time rounded. But \"回傳結果\" ambiguous: maybe return elapsed time. We'll do that.\n\nProvide steps: Start, Step 1: Import time module, Step 2: Define function measure_time(func, *args), Step 3: Record start time, Step 4: Call func(*args) to execute, Step 5: Record end time, Step 6: Calculate elapsed time, Step 7: Round elapsed time to 3 decimals, Step 8: Return elapsed time, End. Use decisions? Not needed. But maybe include decision to handle if func returns something? Not required. We'll just keep simple.\n\nMake sure each line has arrow. For function definition and return, arrow lines. Use \"→\" for steps, \"Decision:\" if needed.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 導入 time 模組 // 準備計時\n→ Step 2: 定義函式 measure_time(func, *args) // 接收要測量的函式和參數\n→ Step 3: 記錄開始時間 start = time.time() // 標記執行前時間\n→ Step 4: 執行目標函式 result = func(*args) // 執行傳入的函式\n→ Step 5: 記錄結束時間 end = time.time() // 標記執行後時間\n→ Step 6: 計算耗時 elapsed = end - start // 得到秒數\n→ Step 7: 四捨五入到 3 位 elapsed = round(elapsed, 3) // 保留三位小數\n→ Step 8: 回傳耗時 elapsed // 將結果返回\nEnd // 程式執行結束\n\nBut \"回傳結果\" maybe return elapsed. That's fine.\n\nWe don't need Decision.\n\nMake sure each line includes \"虛擬碼步驟\" + space + comment. So \"→ Step 1: ... // ...\". Good.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 time 模組 // 準備使用 time.time() 進行計時  \n→ Step 2: 定義函式 measure_time(func, *args) // 接收待測函式與任意參數  \n→ Step 3: 記錄開始時間 start = time.time() // 標記執行前時間點  \n→ Step 4: 執行目標函式 result = func(*args) // 執行傳入的函式  \n→ Step 5: 記錄結束時間 end = time.time() // 標記執行後時間點  \n→ Step 6: 計算耗時 elapsed = end - start // 得到函式執行所需秒數  \n→ Step 7: 四捨五入到 3 位 elapsed = round(elapsed, 3) // 保留三位小數  \n→ Step 8: 回傳耗時 elapsed // 將計算結果返回  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n\n    if not lines:\n        # 若無輸入，使用預設兩個學生\n        s1 = Student('Alice', 90)\n        s2 = Student('Bob', 80)\n        s1.show_info()\n        s2.show_info()\n    else:\n        # 每一行預期為 \"name score\"\n        for line in lines:\n            parts = line.split()\n            if len(parts) >= 2:\n                name = parts[0]\n                try:\n                    score = int(parts[1])\n                except ValueError:\n                    score = 0\n                student = Student(name, score)\n                student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, each line preceded by arrow or structure. Need to include Start, End. Use arrows like \"→ Step ...\". Provide steps for class definition, initialization, method, instantiation, calls.\n\nWe must follow the format: \"虛擬碼步驟 [space] // 解釋/說明\". Each line. Use arrows. Let's craft.\n\nStart\n→ Define Class Student // 定義 Student 類別\n→ Class Student:\n→     → Step: __init__(self, name, score) // 建構子初始化 name 與 score\n→         → Step: self.name = name // 設定姓名屬性\n→         → Step: self.score = score // 設定分數屬性\n→     → Step: show_info(self) // 定義 show_info 方法\n→         → Step: output f\"{self.name} 的分數是 {self.score}\" // 輸出訊息\n→ End // 結束類別定義\n→ Instantiate Student1 = Student(\"小明\", 88) // 建立第一個 Student 物件\n→ Instantiate Student2 = Student(\"小華\", 92) // 建立第二個 Student 物件\n→ Call Student1.show_info() // 呼叫第一個物件的 show_info\n→ Call Student2.show_info() // 呼叫第二個物件的 show_info\nEnd // 程式結束\n\nNeed to ensure formatting with arrow for each step. We might need indentation for class body lines with arrow maybe \"→ Class Student:\" then indentation arrow. In example, they used indentation inside. Use consistent format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class Student // 定義 Student 類別  \n→ Class Student:  \n→     → Step: __init__(self, name, score) // 建構子初始化姓名與分數  \n→         → Step: self.name = name // 設定 name 屬性  \n→         → Step: self.score = score // 設定 score 屬性  \n→     → Step: show_info(self) // 定義 show_info 方法  \n→         → Step: output f\"{self.name} 的分數是 {self.score}\" // 輸出學生資訊  \n→ End // 結束類別定義  \n→ Instantiate Student1 = Student(\"小明\", 88) // 建立第一個 Student 物件  \n→ Instantiate Student2 = Student(\"小華\", 92) // 建立第二個 Student 物件  \n→ Call Student1.show_info() // 呼叫第一個物件的 show_info  \n→ Call Student2.show_info() // 呼叫第二個物件的 show_info  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"grape\",\"apple\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'grape', 'apple', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # Consume any input from stdin (even if empty) to satisfy the requirement\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Use Start, End, Decision maybe not needed. It's simple sequence. We can use arrows. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 加入橘子\n→ Step 3: fruits.update(['grape', 'melon']) // 同時加入葡萄與哈蜜瓜\n→ Step 4: fruits.remove('banana') // 移除香蕉\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的鳳梨\n→ Step 6: print(fruits) // 輸出集合內容\nEnd // 程式執行結束\n\nMake sure format: each line: 虛擬碼步驟 [space] // 解釋. Use arrow \"→\" maybe at start of line? In example, arrow after Start line. We'll use same. Each line start with \"→ \" maybe. Also Start line no arrow? example shows Start line directly. We'll follow.\n\nLet's craft output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'\n→ Step 6: print(fruits) // 輸出最終的集合內容\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\n# ---------- 取得匯率 ----------\ndef get_rate():\n    \"\"\"\n    取得 USD → TWD 匯率，若失敗回傳 None。\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=5)\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\n# ---------- GUI ----------\ndef create_gui():\n    \"\"\"\n    建立 tkinter 視窗，顯示目前匯率並提供更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    # 文字顯示區\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    # 按鈕功能\n    def update_rate():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update_rate).pack(pady=5)\n\n    # 初次取得匯率\n    update_rate()\n\n    win.mainloop()\n\n# ---------- 主程式 ----------\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    input_text = sys.stdin.read().strip()\n\n    # 若輸入包含「按下「更新匯率」按鈕」，即模擬按鈕事件\n    if '按下「更新匯率」按鈕' in input_text:\n        rate = get_rate()\n        if rate is not None:\n            print(f'目前美元匯率：約 {rate} TWD')\n        else:\n            print('更新失敗，請檢查網路連線')\n\n    # 同時啟動 GUI 介面\n    create_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Should use virtual code with arrows. Use Start, End, Decision, etc. Must not output real code. Use lines like \"Start\", \"→ Step: Import modules\", etc. The user wants to use requests, tkinter, fetch API, display. Should have button to update. So we need to outline flow: Start, Import modules, Define function fetch_rate, set up tkinter root, label, button, bind click to fetch_rate, mainloop, End.\n\nAlso need to include decision for error handling maybe. Provide simple. Use virtual code. Provide \"→ Step 1: Import requests, tkinter\". Then \"→ Step 2: Define fetch_rate\". Inside fetch_rate: \"→ Step 3: Send GET request\" \"→ Decision: If response status 200? Yes→ parse JSON and update label text; No→ set error message\". Then create UI: \"→ Step 4: Create root window\". \"→ Step 5: Create label to show rate\". \"→ Step 6: Create button '更新' bound to fetch_rate\". \"→ Step 7: Call fetch_rate initially to show first value\". \"→ Step 8: root.mainloop()\". \"End\".\n\nMake sure each line has \"虛擬碼步驟\" followed by \" // 解釋\". Use arrow characters.\n\nLet's produce. Ensure each line starts with appropriate indent for decisions. Use indentation for nested lines.\n\nAlso mention that Step 1: Import modules. Use virtual code \"Start\". Should we include \"Step 1:\"? Yes.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter // 引入請求與圖形介面庫\n→ Step 2: 定義 fetch_rate() 函式 // 用來抓取匯率並更新畫面\n    → Step 3: 發送 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n    → Decision: 檢查回應碼是否為 200? // 確認請求成功\n        Yes → Step 4: 解析 JSON，提取 'rates' -> 'TWD' // 取出美元兌台幣匯率\n        Yes → Step 5: 更新 label 文本為 \"1 USD = {rate} TWD\" // 將匯率顯示在畫面\n        No  → Step 6: 設定 label 文本為 \"取得匯率失敗\" // 錯誤訊息\n→ Step 7: 建立 tkinter 主視窗 root // 初始化 GUI\n→ Step 8: 建立 label 顯示匯率 // 顯示匯率文字\n→ Step 9: 建立按鈕 '更新匯率' 並綁定 fetch_rate // 用戶可手動更新\n→ Step 10: 呼叫 fetch_rate() 一次以載入初始匯率 // 程式啟動即顯示匯率\n→ Step 11: 執行 root.mainloop() // 進入 GUI 事件迴圈\nEnd // 程式結束\n\nMake sure each line is separate. Use arrow and decisions. Use indentation. Also ensure that decision branch lines have indentation. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter // 引入請求與圖形介面庫\n→ Step 2: 定義 fetch_rate() 函式 // 用來抓取匯率並更新畫面\n    → Step 3: 發送 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n    → Decision: 檢查回應碼是否為 200? // 確認請求成功\n        Yes → Step 4: 解析 JSON，提取 'rates' -> 'TWD' // 取出美元兌台幣匯率\n        Yes → Step 5: 更新 label 文本為 \"1 USD = {rate} TWD\" // 將匯率顯示在畫面\n        No  → Step 6: 設定 label 文本為 \"取得匯率失敗\" // 錯誤訊息\n→ Step 7: 建立 tkinter 主視窗 root // 初始化 GUI\n→ Step 8: 建立 label 顯示匯率 // 顯示匯率文字\n→ Step 9: 建立按鈕 '更新匯率' 並綁定 fetch_rate // 用戶可手動更新\n→ Step 10: 呼叫 fetch_rate() 一次以載入初始匯率 // 程式啟動即顯示匯率\n→ Step 11: 執行 root.mainloop() // 進入 GUI 事件迴圈\nEnd // 程式結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[0,0],[1,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [0, 0], [1, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining zeros\n        self.mapping = {}           # virtual mapping of indices\n\n    def flip(self):\n        # 隨機選取一個剩餘的 0 的索引\n        r = random.randint(0, self.total - 1)\n\n        # 取得實際映射的索引\n        actual = self.mapping.get(r, r)\n\n        # 把 r 換成最後一個可用索引\n        last = self.total - 1\n        last_val = self.mapping.get(last, last)\n        self.mapping[r] = last_val\n\n        # 如果 last 有映射，移除它\n        if last in self.mapping:\n            del self.mapping[last]\n\n        # 更新剩餘可選數量\n        self.total -= 1\n\n        # 轉換為二維座標\n        return [actual // self.n, actual % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析兩個列表\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = parts[1].strip()\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n        else:\n            # ignore unknown ops\n            res.append(None)\n\n    # 輸出結果，將 None 轉為 JSON null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: matrix flipping, random pick among zeros. Standard solution: treat matrix as flattened array of size m*n. Keep a mapping dict from index to value. Use reservoir: keep track of remaining count. At flip, pick random index r from 0 to remaining-1. Map r to actual index: if mapping contains r, actual = mapping[r], else actual=r. Then we want to swap r with last available index: last = remaining-1. If mapping contains last, lastIndex= mapping[last], else lastIndex=last. Then update mapping[r]=lastIndex, mapping[last] removed (if present). Decrement remaining. Return actual index converted to 2D.\n\nReset: clear mapping and set remaining to m*n.\n\nAlso random calls minimized: each flip uses one random call.\n\nTime O(1), space O(k) where k is number of flipped cells.\n\nImplement virtual code.\n\nLet's produce step-by-step:\n\nStart: initialize variables: m, n, total = m*n, remaining = total, map = {}.\n\nflip:\n  - Decision: if remaining == 0? // all flipped, cannot flip\n  - Random r in [0, remaining-1]\n  - Decision: if map contains r? // map lookup\n  - actual = map[r] else r\n  - last = remaining-1\n  - Decision: if map contains last? \n  - lastIndex = map[last] else last\n  - map[r] = lastIndex\n  - if last in map: remove map[last]\n  - remaining -=1\n  - Convert actual to (i,j)\n  - Return [i,j]\n\nreset:\n  - Clear map\n  - remaining = total\n\nEdge: need to show mapping operations.\n\nLet's write virtual code lines.\n\nRemember to follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows and decisions.\n\nWe can nest decisions.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 m, n, total = m * n, remaining = total, map = {} // 設定矩陣大小、剩餘可選位置及對應映射表  \n→ Decision: 是否調用 flip()？ // 判斷是否需要進行翻轉  \n    Yes → Step 2: 檢查 remaining 是否為 0  \n        Decision: 如果 remaining == 0? // 檢查是否已經全為 1  \n            Yes → Step 3: 返回 null / raise error // 無可選位置  \n            No  → Step 4: 呼叫隨機函式產生 r ∈ [0, remaining-1] // 隨機選取剩餘位置索引  \n    → Decision: map 是否包含 key r？  \n        Yes → Step 5: actual = map[r] // 若 r 已映射，取得對應的實際索引  \n        No  → Step 6: actual = r // 若未映射，實際索引即為 r  \n    → Step 7: 計算 last = remaining - 1 // 最後一個可用索引  \n    → Decision: map 是否包含 key last？  \n        Yes → Step 8: lastIndex = map[last] // 若 last 已映射，取得其實際索引  \n        No  → Step 9: lastIndex = last // 若未映射，實際索引即為 last  \n    → Step 10: 將 map[r] 更新為 lastIndex // 將 r 的位置指向 last 的實際索引  \n    → Decision: map 是否包含 key last？  \n        Yes → Step 11: 移除 map[last] // 若 last 已映射，刪除其舊映射以保持映射表大小  \n        No  → Step 12: 無操作 // 若 last 未映射，無需移除  \n    → Step 13: remaining -= 1 // 更新剩餘可選位置數  \n    → Step 14: 將 actual 轉換為二維座標 (i = actual // n, j = actual % n) // 取得行列索引  \n    → Step 15: 返回 [i, j] // 回傳翻轉後的位置  \n→ Decision: 是否調用 reset()？ // 判斷是否需要重置矩陣  \n    Yes → Step 16: 清空 map // 移除所有映射  \n    → Step 17: remaining = total // 重置剩餘可選位置數回總數  \n    No  → Step 18: 無操作 // 其他情況保持不變  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj0p6hdeg.py\", line 62, in <module>\n    magic_dict.buildDict(arg)\n  File \"/tmp/tmpj0p6hdeg.py\", line 12, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MagicDictionary:\n    \"\"\"資料結構：儲存字典單字集合，提供單字搜尋功能。\"\"\"\n\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        \"\"\"建立字典，覆寫現有集合。\"\"\"\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        \"\"\"\n        搜尋：若能改正好一個字元得到字典中任一單字，回傳 True，否則 False。\n        \"\"\"\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\n\ndef parse_input(data: str):\n    \"\"\"\n    將 stdin 內容轉成兩個列表：commands 與 arguments。\n    例：'[\"MagicDictionary\",\"buildDict\",\"search\"], [[],[\"hello\"],[\"hhllo\"]]'\n    轉為 (['MagicDictionary','buildDict','search'], [[],['hello'],['hhllo']])\n    \"\"\"\n    data = data.strip()\n    # 若多行，將其合併為一行\n    data = \"\".join(data.splitlines())\n    # 以逗號分隔兩個列表，並包裝成 tuple\n    data = f\"({data})\"\n    return ast.literal_eval(data)\n\n\nif __name__ == \"__main__\":\n    # 讀取全部標準輸入\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit()\n\n    commands, args = parse_input(raw_input)\n\n    result = []\n    magic_dict = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MagicDictionary\":\n            magic_dict = MagicDictionary()\n            result.append(None)\n        elif cmd == \"buildDict\":\n            magic_dict.buildDict(arg)\n            result.append(None)\n        elif cmd == \"search\":\n            result.append(magic_dict.search(arg))\n        else:\n            # 未定義的指令，回傳 None\n            result.append(None)\n\n    # 輸出結果清單\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing the MagicDictionary as described. Provide step-by-step virtual code. Each line: Virtual code step + space + // explanation. Use arrows, Start, End, Decision.\n\nNeed to design data structure. Usually, we can use a hashmap mapping mask patterns to words or count. For each word, generate patterns with one char replaced by '*', store mapping to list or count. Then search: for each position in searchWord, replace char with '*', check if pattern exists and either word count>1 or word not equal to searchWord. Need to handle case when searchWord matches dictionary exactly but needs exactly one change, so if pattern exists but same word, need check count>1.\n\nBut we can keep map pattern -> count of words that produce this pattern. Implementation details.\n\nSo we produce virtual code:\n\nStart // ...\n→ Step 1: Initialize data structure dictionaryMap ← empty hashmap // store pattern to count\n\n→ Step 2: buildDict(dictionary) // set up dictionary\n\n→   For each word in dictionary:\n        → Generate all patterns by replacing each character with '*'\n        → For each pattern: if pattern not in dictionaryMap: dictionaryMap[pattern] ← 1 else dictionaryMap[pattern] +=1\n\n→ Step 3: search(searchWord)\n        → For i in 0..len(searchWord)-1:\n                → pattern ← replace char at i with '*'\n                → Decision: pattern exists in dictionaryMap?\n                     Yes → If dictionaryMap[pattern] > 1 or searchWord not equal to pattern replacement? Actually need to check if any word other than searchWord matches. So:\n                          Decision: pattern exists and (dictionaryMap[pattern] > 1 or searchWord differs from the word that generated the pattern)\n                          But easier: if dictionaryMap[pattern] > 1 or pattern matches and searchWord not equal to word? However we don't store which words. We can check if pattern count>1 or if the word in dictionary is same as searchWord? Wait. Alternative approach: we can check if dictionary contains the word formed by replacing char with '*', and ensure that searchWord not equal to that word. But we don't have mapping of pattern to words.\n\nBetter approach: use set of words. In search, we can attempt to change one character and check if resulting word is in set, and not equal to original word. But that is O(n*len*alphabet). We can also use mapping pattern->list of words. We'll store mapping pattern to set of words. Then search: for each pattern, get set, iterate over words: if any word != searchWord return true.\n\nSimpler: use set words. For each position, try replacing with all 'a' to 'z', check if new word in set and new word != searchWord. Complexity acceptable.\n\nThus Virtual code: Step 3: search\n\n→ For each position i:\n        → For each letter c from 'a' to 'z':\n                → if c == original char continue\n                → newWord ← replace char at i with c\n                → Decision: newWord in dictionarySet?\n                     Yes → If newWord != searchWord → return true\n→ Return false\n\nAlso maintain dictionarySet.\n\nLet's produce steps accordingly.\n\nUse arrows.\n\nMake sure each line ends with // explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: dictionarySet ← empty set // 存放所有字典單字\n→ Step 2: patternMap ← empty map // (可選) 若使用模式匹配，這裡保持為空\n→ Step 3: buildDict(dictionary) // 初始化字典\n→   For each word in dictionary:\n        → dictionarySet ← dictionarySet ∪ {word} // 加入單字\n        // 這裡可同時建立模式映射，略\n→ Step 4: search(searchWord) // 判斷是否能改一個字母得到字典中的單字\n        → For i from 0 to len(searchWord)-1:\n                → originalChar ← searchWord[i]\n                → For each letter c in 'a'..'z':\n                        → If c == originalChar: continue\n                        → newWord ← searchWord with i-th char replaced by c\n                        → Decision: newWord in dictionarySet?\n                            Yes → Decision: newWord ≠ searchWord?\n                                Yes → Return true // 找到合法變換\n                                No  → Continue // 這種情況不會發生因為 c≠originalChar\n                        → No → Continue\n        → Return false // 無法改一個字母得到字典單字\nEnd // 程式結束\n\nBut we need \"逐行\" with arrows. Also \"→ Decision:\" style.\n\nWe should structure: Start, → Step 1, etc.\n\nLet's produce final output with each line as specified.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: dictionarySet ← empty set // 建立集合存放所有字典單字  \n→ Step 2: buildDict(dictionary) // 初始化字典資料結構  \n→   For each word in dictionary: // 逐一處理每個單字  \n→     dictionarySet ← dictionarySet ∪ {word} // 將單字加入集合  \n→ Step 3: search(searchWord) // 判斷是否可改一個字母得到字典中的單字  \n→   For i from 0 to len(searchWord)-1: // 逐個位置嘗試改字  \n→     originalChar ← searchWord[i] // 取得原始字母  \n→     For each letter c in 'a'..'z': // 遍歷所有可能的替換字母  \n→       Decision: c == originalChar? // 若替換字母與原字母相同則跳過  \n→         Yes → Continue // 不需要嘗試相同字母  \n→         No  → newWord ← searchWord with i-th char replaced by c // 產生新字串  \n→         Decision: newWord in dictionarySet? // 檢查新字串是否存在於字典  \n→           Yes → Decision: newWord ≠ searchWord? // 確保不是原始字串本身  \n→             Yes → Return true // 找到合法變換，結束搜尋  \n→             No  → Continue // 實際上不會發生，因為 c≠originalChar  \n→           No  → Continue // 該變換不在字典中，繼續嘗試  \n→ Return false // 所有變換皆不符合條件，搜尋結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdkrpr84x.py\", line 70, in <module>\n    main()\n  File \"/tmp/tmpdkrpr84x.py\", line 64, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdkrpr84x.py\", line 17, in __init__\n    self.lookup[(prefix, suffix)] = idx\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    \"\"\"\n    建立一個字典，鍵為 (前綴, 後綴) 的 tuple，值為對應單字的最大索引。\n    \"\"\"\n    def __init__(self, words):\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            # 先產生所有前綴，再產生所有後綴，組合成鍵\n            for i in range(L + 1):\n                prefix = word[:i]\n                for j in range(L + 1):\n                    suffix = word[j:]\n                    self.lookup[(prefix, suffix)] = idx\n\n    def f(self, prefix, suffix):\n        \"\"\"\n        回傳符合前綴與後綴的單字最大索引，若不存在則回傳 -1。\n        \"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\n\ndef split_input(s: str):\n    \"\"\"\n    把輸入字串拆成兩部分：第一個方括號包住的 words，第二個方括號包住的 query。\n    \"\"\"\n    stack = 0\n    for i, ch in enumerate(s):\n        if ch == '[':\n            stack += 1\n        elif ch == ']':\n            stack -= 1\n        elif ch == ',' and stack == 0:\n            left = s[:i].strip()\n            right = s[i + 1 :].strip()\n            return left, right\n    return s, ''\n\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    left_str, right_str = split_input(raw_input)\n\n    # 解析成 Python 物件\n    try:\n        words = ast.literal_eval(left_str)\n        query = ast.literal_eval(right_str)\n    except Exception as e:\n        print(\"Invalid input format\", file=sys.stderr)\n        return\n\n    if not isinstance(query, (list, tuple)) or len(query) != 2:\n        print(\"Query should be a pair of strings\", file=sys.stderr)\n        return\n\n    prefix, suffix = query[0], query[1]\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to design algorithm: likely trie with prefix and suffix? Approach: Build a trie for words, but we need prefix + suffix search. Known Leetcode 745: WordFilter uses combined trie of prefix+suffix. Build a map from word to index. For each word, for all prefixes and suffixes produce key pref + \"#\" + suff with index. Use trie with combined. Or use hashmap from key to index, store max index.\n\nSimplify: Use hashmap where key is prefix + \"#\" + suffix and value is max index. Preprocess: for each word, for all prefixes, for all suffixes store.\n\nBut complexity: words length up to 10, maybe fine. But for demonstration we produce virtual code.\n\nWe'll produce pseudo steps:\n\nStart\n→ Step 1: Initialize empty map keyToIndex\n→ Decision: For each word index i and word\n   → Step 2: For each prefix length from 0 to len(word)\n        → Step 3: Extract prefix\n        → Step 4: For each suffix length from 0 to len(word)\n            → Step 5: Extract suffix\n            → Step 6: Build key = prefix + \"#\" + suffix\n            → Step 7: keyToIndex[key] = i (since we iterate i ascending, keep max index)\n→ Step 8: Store keyToIndex for later\nEnd initialization\n\nFor query f(pref,suff):\n→ Step 9: key = pref + \"#\" + suff\n→ Decision: If key in keyToIndex\n    Yes → Step 10: return keyToIndex[key]\n    No → Step 11: return -1\n\nThis is pseudo. We also need WordFilter class structure.\n\nLet's produce stepwise.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 keyToIndex // 用來儲存「前綴#後綴」→索引對應關係\n→ Decision: 逐一遍歷輸入陣列 words, 其長度為 N\n    Yes → Step 2: 對每個單字 words[i] (索引 i)\n        → Step 3: 計算單字長度 L\n        → Step 4: 逐個建立所有前綴\n            → Decision: 前綴長度 p 從 0 到 L\n                Yes → Step 5: prefix = words[i].substr(0, p) // 取前 p 個字元\n                → Step 6: 逐個建立所有後綴\n                    → Decision: 後綴長度 s 從 0 到 L\n                        Yes → Step 7: suffix = words[i].substr(L - s, s) // 從右往左取 s 個字元\n                        → Step 8: key = prefix + \"#\" + suffix // 組合成鍵\n                        → Step 9: keyToIndex[key] = i // 儲存最大索引 (覆寫即可)\n                No → End 循環後綴\n        No → End 循環前綴\n    No → End 遍歷所有單字\n→ Step 10: 完成建構，將 keyToIndex 置於 WordFilter 物件內部\nEnd // 完成 WordFilter 建構\n\n// 以下為 WordFilter 類別中 f 方法的虛擬碼\n\nStart // f 方法開始執行\n→ Step 11: key = pref + \"#\" + suff // 生成查詢鍵\n→ Decision: key 是否存在於 keyToIndex\n    Yes → Step 12: return keyToIndex[key] // 回傳最大索引\n    No  → Step 13: return -1 // 沒有符合的單字\nEnd // f 方法結束執行"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List, Set\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        \"\"\"返回所有唯一且最小刪除後合法的括號字符串\"\"\"\n        res: Set[str] = set()\n\n        # 計算需要刪除的左括號與右括號數量\n        lrem, rrem = 0, 0\n        for ch in s:\n            if ch == '(':\n                lrem += 1\n            elif ch == ')':\n                if lrem > 0:\n                    lrem -= 1\n                else:\n                    rrem += 1\n\n        def dfs(idx: int, cur: str, lrem: int, rrem: int, bal: int) -> None:\n            \"\"\"\n            idx   : 當前處理的位置\n            cur   : 當前已構造的字符串\n            lrem  : 還剩下要刪除的左括號數\n            rrem  : 還剩下要刪除的右括號數\n            bal   : 當前左括號與右括號的平衡計數 (左括號 - 右括號)\n            \"\"\"\n            if idx == len(s):\n                if bal == 0:\n                    res.add(cur)\n                return\n\n            ch = s[idx]\n\n            if ch.isalpha():  # 字母直接保留\n                dfs(idx + 1, cur + ch, lrem, rrem, bal)\n                return\n\n            # 處理左括號 '('\n            if ch == '(':\n                # 刪除左括號\n                if lrem > 0:\n                    dfs(idx + 1, cur, lrem - 1, rrem, bal)\n                # 保留左括號\n                dfs(idx + 1, cur + ch, lrem, rrem, bal + 1)\n            else:  # 處理右括號 ')'\n                # 刪除右括號\n                if rrem > 0:\n                    dfs(idx + 1, cur, lrem, rrem - 1, bal)\n                # 保留右括號，前提是有左括號可配對\n                if bal > 0:\n                    dfs(idx + 1, cur + ch, lrem, rrem, bal - 1)\n\n        dfs(0, \"\", lrem, rrem, 0)\n        return list(res)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入中提取字符串內容（支持雙引號或單引號）\n    match = re.search(r'\\\"([^\"]*)\\\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        match = re.search(r\"\\'([^']*)\\'\", data)\n        if match:\n            s = match.group(1)\n        else:\n            s = data.strip()\n\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The task: Given string s containing parentheses and letters, remove minimum number of invalid parentheses to make string valid. Return list of unique valid strings with min removals. Classic LeetCode problem 301. Approach: compute number of left and right to remove using a loop. Then DFS with pruning.\n\nSo we need to produce virtual code lines explaining steps. Use Start, Decision, etc.\n\nWe'll produce step-by-step pseudo-code. We'll include steps: compute lrem, rrem. Then DFS recursion.\n\nWe'll also include helper to build result set.\n\nUse \"→\" arrow.\n\nWe need each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 計算要刪除的左括號數 lrem 與右括號數 rrem // 先遍歷字串確定最少刪除數\n    → Decision: 如果遇到 '('? // 當遇到左括號時\n        Yes → lrem += 1 // 加一\n        No → Decision: 如果遇到 ')' and lrem > 0? // 右括號時若有未匹配左括號\n            Yes → lrem -= 1 // 與左括號配對，減一\n            No  → rrem += 1 // 無匹配左括號，需刪除此右括號\n→ Step 2: 建立結果集合 res = {} // 用集合儲存唯一有效字串\n→ Step 3: 定義遞迴函式 dfs(index, path, lrem, rrem, bal) // index: 目前位置，path: 當前字串，bal: 左右括號平衡計數\n    → Decision: index == s.length? // 遞迴終止條件\n        Yes → Decision: bal == 0? // 字串有效時\n            Yes → res.add(path) // 加入結果\n            No  → Return // 不合法，回溯\n        No  → \n            → Decision: s[index] is letter? // 文字不影響平衡\n                Yes → dfs(index+1, path + s[index], lrem, rrem, bal) // 保留字母\n                No  → Decision: s[index] == '('? // 左括號處理\n                    Yes → Decision: lrem > 0? // 可以刪除\n                        Yes → dfs(index+1, path, lrem-1, rrem, bal) // 刪除 '('\n                        No  →  // 不刪除\n                    No → dfs(index+1, path + '(', lrem, rrem, bal+1) // 保留 '('，平衡+1\n                No  → Decision: s[index] == ')'?\n                    Yes → Decision: rrem > 0? // 可以刪除\n                        Yes → dfs(index+1, path, lrem, rrem-1, bal) // 刪除 ')'\n                        No  →\n                    No → Decision: bal > 0? // 有左括號可配對\n                        Yes → dfs(index+1, path + ')', lrem, rrem, bal-1) // 保留 ')', 平衡-1\n                        No  → Return // 無左括號可配對，非法\n→ Step 4: 呼叫 dfs(0, \"\", lrem, rrem, 0) // 開始遞迴\n→ Step 5: 回傳 res 作為結果 // 將集合轉為列表輸出\n\nBut must maintain format: Each line must start with arrow and \"虛擬碼步驟\". Let's ensure proper arrow. Use \"→\" at start of each step, except Start and End. Indent decisions maybe. Use consistent formatting.\n\nWe need \"Start\" and \"End\".\n\nLet's produce full virtual code:\n\nStart // 程式開始\n→ Step 1: 計算 lrem, rrem // 計算需要刪除的左右括號數\n    → Decision: s[i] == '('? // 左括號\n        Yes → lrem += 1\n        No  → Decision: s[i] == ')' and lrem > 0? // 右括號且有未配對左括號\n            Yes → lrem -= 1\n            No  → rrem += 1\n→ Step 2: res = {} // 儲存唯一有效字串\n→ Step 3: 定義遞迴函式 dfs(idx, cur, lrem, rrem, bal)\n    → Decision: idx == s.length? // 到末尾\n        Yes → Decision: bal == 0?\n            Yes → res.add(cur)\n            No  → Return\n        No  →\n            → Decision: s[idx] 是字母? // 非括號\n                Yes → dfs(idx+1, cur + s[idx], lrem, rrem, bal)\n                No  → Decision: s[idx] == '('?\n                    Yes → Decision: lrem > 0? // 可刪除\n                        Yes → dfs(idx+1, cur, lrem-1, rrem, bal)\n                        No  → // 留下\n                    No → dfs(idx+1, cur + '(', lrem, rrem, bal+1)\n                No  → Decision: s[idx] == ')'?\n                    Yes → Decision: rrem > 0? // 可刪除\n                        Yes → dfs(idx+1, cur, lrem, rrem-1, bal)\n                        No  →\n                    No → Decision: bal > 0? // 有左括號可配對\n                        Yes → dfs(idx+1, cur + ')', lrem, rrem, bal-1)\n                        No  → Return\n→ Step 4: dfs(0, \"\", lrem, rrem, 0) // 開始遞迴\n→ Step 5: return list(res) // 將集合轉列表回傳\nEnd // 程式結束\n\nNeed to ensure each line includes the \"虛擬碼步驟\" part, but we can just write like \"Start\" or \"→ Step\". That is acceptable.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 計算 lrem, rrem // 計算需要刪除的左括號與右括號數  \n  → Decision: s[i] == '('? // 遇到左括號  \n   Yes → lrem += 1 // 增加左括號刪除計數  \n   No  → Decision: s[i] == ')' and lrem > 0? // 遇到右括號且還有未配對左括號  \n    Yes → lrem -= 1 // 與左括號配對，減少左括號刪除計數  \n    No  → rrem += 1 // 無可配對左括號，右括號需刪除  \n→ Step 2: res = {} // 建立集合儲存唯一有效字串  \n→ Step 3: 定義遞迴函式 dfs(idx, cur, lrem, rrem, bal) // idx: 現在索引, cur: 當前字串, bal: 左右括號平衡  \n  → Decision: idx == s.length? // 到達字串末尾  \n   Yes → Decision: bal == 0? // 字串是否有效  \n    Yes → res.add(cur) // 有效則加入集合  \n    No  → Return // 無效則回溯  \n   No  →  \n    → Decision: s[idx] 是字母? // 非括號字符  \n     Yes → dfs(idx+1, cur + s[idx], lrem, rrem, bal) // 直接保留  \n     No  → Decision: s[idx] == '('? // 左括號  \n      Yes → Decision: lrem > 0? // 可選刪除  \n       Yes → dfs(idx+1, cur, lrem-1, rrem, bal) // 刪除左括號  \n       No  → // 不刪除  \n      No → dfs(idx+1, cur + '(', lrem, rrem, bal+1) // 保留左括號，平衡+1  \n     No  → Decision: s[idx] == ')'? // 右括號  \n      Yes → Decision: rrem > 0? // 可選刪除  \n       Yes → dfs(idx+1, cur, lrem, rrem-1, bal) // 刪除右括號  \n       No  → // 不刪除  \n      No → Decision: bal > 0? // 有左括號可配對  \n       Yes → dfs(idx+1, cur + ')', lrem, rrem, bal-1) // 保留右括號，平衡-1  \n       No  → Return // 無可配對左括號，非法  \n→ Step 4: dfs(0, \"\", lrem, rrem, 0) // 啟動遞迴  \n→ Step 5: return list(res) // 將集合轉成列表作為結果  \nEnd // 程式結束"
    },
    {
      "title": "Parse Lisp Expression",
      "source_file": "Leetcode/leetcode736.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfzmvthd3.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpfzmvthd3.py\", line 49, in main\n    result = eval_expr(expr, {})\n             ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfzmvthd3.py\", line 36, in eval_expr\n    return eval_expr(tokens[-1], new_env)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfzmvthd3.py\", line 27, in eval_expr\n    return eval_expr(tokens[1], env.copy()) * eval_expr(tokens[2], env.copy())\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfzmvthd3.py\", line 36, in eval_expr\n    return eval_expr(tokens[-1], new_env)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfzmvthd3.py\", line 25, in eval_expr\n    return eval_expr(tokens[1], env.copy()) + eval_expr(tokens[2], env.copy())\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfzmvthd3.py\", line 6, in eval_expr\n    return env[expr]\n           ~~~^^^^^^\nKeyError: 'y)'"
        },
        {
          "example_index": 1,
          "input": "expression = \"(let x 3 x 2 x)\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpedud222b.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpedud222b.py\", line 49, in main\n    result = eval_expr(expr, {})\n             ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpedud222b.py\", line 36, in eval_expr\n    return eval_expr(tokens[-1], new_env)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpedud222b.py\", line 6, in eval_expr\n    return env[expr]\n           ~~~^^^^^^\nKeyError: 'x)'"
        },
        {
          "example_index": 2,
          "input": "expression = \"(let x 1 y 2 x (add x y) (add x y))\"",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc35ijcg1.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpc35ijcg1.py\", line 49, in main\n    result = eval_expr(expr, {})\n             ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc35ijcg1.py\", line 36, in eval_expr\n    return eval_expr(tokens[-1], new_env)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc35ijcg1.py\", line 25, in eval_expr\n    return eval_expr(tokens[1], env.copy()) + eval_expr(tokens[2], env.copy())\n                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc35ijcg1.py\", line 6, in eval_expr\n    return env[expr]\n           ~~~^^^^^^\nKeyError: 'y)'"
        }
      ],
      "generated_code": "import sys\n\ndef eval_expr(expr: str, env: dict) -> int:\n    if expr[0] != '(':\n        if expr[0].isalpha():\n            return env[expr]\n        return int(expr)\n\n    inner = expr[1:-1]\n    tokens = []\n    balance = 0\n    start = 0\n    for i, ch in enumerate(inner):\n        if ch == '(':\n            balance += 1\n        elif ch == ')':\n            balance -= 1\n        elif ch == ' ' and balance == 0:\n            tokens.append(inner[start:i])\n            start = i + 1\n    tokens.append(inner[start:])\n\n    op = tokens[0]\n    if op == 'add':\n        return eval_expr(tokens[1], env.copy()) + eval_expr(tokens[2], env.copy())\n    if op == 'mult':\n        return eval_expr(tokens[1], env.copy()) * eval_expr(tokens[2], env.copy())\n    if op == 'let':\n        new_env = env.copy()\n        i = 1\n        while i < len(tokens) - 1:\n            var = tokens[i]\n            val = eval_expr(tokens[i + 1], new_env)\n            new_env[var] = val\n            i += 2\n        return eval_expr(tokens[-1], new_env)\n\n    # should not reach here\n    return env.get(op, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    start = data.find('(')\n    if start == -1:\n        return\n    expr = data[start:].strip()\n    result = eval_expr(expr, {})\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user asks for virtual code steps to evaluate a Lisp-like expression. They want a step-by-step virtual code, not actual code. Provide lines with \"Start\", \"→ Step\", \"Decision:\" etc. Use virtual code with arrows. Provide explanation per line. Must be in Traditional Chinese.\n\nWe need to produce algorithmic steps: parse expression, evaluate recursively, handle let, add, mult, variable, integer. Provide stack/scope handling. So produce a high-level algorithm. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's design:\n\nStart\n→ Step 1: Initialize global scope as empty dictionary // Setup outermost scope\n→ Step 2: Call Evaluate(expression, scope) // Evaluate top-level\nEvaluation function:\nDecision: If expression starts with '('?\n    Yes → Decision: Check operator token (add, mult, let)\n        Yes (add) → Step: Evaluate e1, e2, return sum\n        Yes (mult) → Step: Evaluate e1, e2, return product\n        Yes (let) → Step: Parse pairs, create new scope, evaluate sequentially, return last expr\n    No → Decision: If expression is integer?\n        Yes → Step: Convert to int and return\n        No → Step: Lookup variable in scopes, return its value\nScope handling: when evaluating let, push new scope onto stack, after evaluation pop.\n\nAlso handle variable lookup: search from innermost to outermost.\n\nAlso need to parse tokens: maybe we skip actual parsing details but mention tokenization.\n\nLet's produce 20-30 lines.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use \"Decision:\" etc.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建一個空的全域範圍 `globalScope` // 用於存放最外層變數  \n→ Step 2: 呼叫 `Evaluate(expression, [globalScope])` 並將結果存入 `result` // 開始評估整個表達式  \n→ End // 執行完畢，輸出 `result`\n\nFunction `Evaluate(expr, scopeStack)`  \n→ Decision: 是否為括號包裹的表達式? // 判斷是否需要進一步解析  \n  Yes → Step 3: 解析 `expr` 為一個 token 列表 `tokens`（去除最外層括號並分割） // 方便後續判斷  \n    Decision: `tokens[0]` 是什麼關鍵字? // 確認表達式類型  \n      add → Step 4:  \n        ① Evaluate `tokens[1]` → `val1` // 評估第一個子表達式  \n        ② Evaluate `tokens[2]` → `val2` // 評估第二個子表達式  \n        ③ 回傳 `val1 + val2` // 返回加法結果  \n      mult → Step 5:  \n        ① Evaluate `tokens[1]` → `val1` // 評估第一個子表達式  \n        ② Evaluate `tokens[2]` → `val2` // 評估第二個子表達式  \n        ③ 回傳 `val1 * val2` // 返回乘法結果  \n      let → Step 6:  \n        ① 建立一個新的範圍 `newScope` 並推入 `scopeStack` // 開啟 let 的作用域  \n        ② 對於每對 `(var, valExpr)` 直到最後一個表達式 `body`  \n          a) Evaluate `valExpr` → `varVal` // 先計算右側表達式  \n          b) 在 `newScope` 中設定 `var = varVal` // 存入變數  \n        ③ Evaluate `body` → `bodyVal` // 計算 let 的最後表達式  \n        ④ 從 `scopeStack` 中移除 `newScope` // 退出 let 的範圍  \n        ⑤ 回傳 `bodyVal` // let 的結果  \n      其他關鍵字 → Step 7: 把 `tokens[0]` 作為變數名稱，跳至 Variable Lookup  \n    No → Step 8:  \n      Decision: `expr` 是否為數字字串? // 判斷是否為純數字  \n       Yes → Step 9: 轉成整數並回傳 // 整數表達式直接返回  \n       No → Step 10: // 變數查找  \n        ① 從 `scopeStack` 由內向外遍歷  \n          a) 若 `expr` 在當前範圍中，取得其值並回傳  \n          b) 若未找到，繼續到上一個範圍  \n          c) 如果最外層也沒找到，拋出錯誤（此情形不會發生，因題目保證合法）  \n\nScope Management  \n→ Step 11: 每當進入 `let` 時，將一個空字典作為新範圍推入 `scopeStack`  \n→ Step 12: 每完成 `let` 評估後，從 `scopeStack` 弹出該範圍，恢復外層作用域  \n\nTokenization（輔助步驟）  \n→ Step 13: `tokens = Tokenize(expr)` // 將字符串拆分為字串、括號、變數等，忽略空格  \n→ Step 14: `Tokenize` 會保證：`tokens[0]` 為關鍵字或變數名，之後是相應的子表達式或數字字串  \n\n結果返回  \n→ Step 15: `result` 是最終的整數值，輸出或返回給呼叫者。 // 程式結束，得到所需值"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnjj3r_5s.py\", line 40, in <module>\n    exec(raw_input, globals())\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2u8r0g7r.py\", line 40, in <module>\n    exec(raw_input, globals())\n  File \"<string>\", line 1\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n    ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        使用 BFS 找到最短轉換序列長度。\n        \"\"\"\n        word_set = set(wordList)          # 轉成集合，O(1) 查詢\n        if endWord not in word_set:       # 若目標字不在字典，直接返回 0\n            return 0\n\n        queue = deque([(beginWord, 1)])   # (目前單詞, 已走的長度)\n        visited = set([beginWord])        # 記錄已訪問的單詞\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:          # 找到目標，返回長度\n                return length\n\n            # 產生所有相鄰的單詞\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, length + 1))\n        return 0  # 若 BFS 結束仍未找到，則無法轉換\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 將輸入字符串當作 Python 代碼執行，取得 beginWord、endWord、wordList\n    # 假設輸入格式為: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",...]\n    exec(raw_input, globals())\n\n    # 產生答案並輸出\n    solution = Solution()\n    result = solution.ladderLength(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for BFS shortest transformation sequence problem. The requirement: produce virtual code lines with comments. Use virtual code arrows and decision. Provide explanation after each line. Not actual code. Just steps. Ok. We'll structure: Start, input, preprocess, BFS queue, visited, loop, generate neighbors, check end, etc. Also return length or 0. Use End. Provide line by line.\n\nNeed to handle dictionary as set for O(1). We produce a variable for wordSet. Steps: check if endWord in wordSet else return 0. BFS: queue contains tuple(word, level). Use visited set. While queue not empty: pop, for each position generate all letters 'a'-'z', create newWord, if newWord in wordSet and not visited: if newWord == endWord return level+1. else add to queue, visited. If exit loop return 0. End.\n\nWe need to write virtual code lines. Use arrows like →, Decision:, Yes→, No→. Also include Start and End.\n\nWe need to include explanation after each line. We'll write each line with virtual code and comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 beginWord、endWord 與 wordList // 取得輸入的三個項目  \n→ Step 2: 將 wordList 轉成 Set wordSet // 方便 O(1) 查詢  \n→ Decision: 若 endWord 不在 wordSet? // 檢查目標字是否存在於字典  \n Yes → Step 3: 輸出 0 // 若不存在，直接返回 0  \n No  → Step 4: 判斷 beginWord 是否已在 wordSet? // 需要排除重複  \n     Yes → Remove beginWord from wordSet // 防止在 BFS 中再加入自身  \n     No → 省略 // 若不在字典，無需移除  \n→ Step 5: 建立 BFS Queue // 用來層層搜尋最短路徑  \n  Queue ← [(beginWord, 1)] // 每項包含單詞與其層級(長度)  \n→ Step 6: 建立 Visited Set // 標記已訪問過的單詞  \n  Visited ← {beginWord}  \n→ Decision: Queue 是否為空? // 檢查是否仍有節點可處理  \n Yes → Step 7: 輸出 0 // 沒有路徑可行，返回 0  \n No  → Step 8: 進入主循環 // 開始 BFS  \n→ Step 8: 從 Queue 取出 (currentWord, level) // 取出當前節點及其深度  \n→ Decision: currentWord 是否等於 endWord? // 確認是否已到達目標  \n Yes → Step 9: 輸出 level // 找到最短路徑長度  \n No  → Step 10: 生成所有相鄰字  \n     For i from 0 to len(currentWord)-1  \n      For c in 'a'..'z'  \n        newWord ← currentWord 之第 i 位改成 c  \n        Decision: newWord 是否在 wordSet 且未被訪問?  \n         Yes → Decision: newWord 是否等於 endWord?  \n           Yes → Step 11: 輸出 level+1 // 找到最短路徑  \n           No → Step 12: 加入 Queue (newWord, level+1) // 進一步搜尋  \n            並將 newWord 加入 Visited // 標記已訪問  \n            End If  \n           No → 省略 // 不是合法相鄰或已訪問  \n→ End // 程式執行結束（若上述流程未回傳）"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 將每個數值對應到其所有索引\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選擇一個對應索引\n        return random.choice(self.indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離指令列與參數列\n    parts = data.split('],', 1)\n    commands_str = parts[0] + ']'\n    args_str = parts[1]\n\n    commands = json.loads(commands_str)\n    args = json.loads(args_str)\n\n    obj = None\n    output = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(arg[0])\n            output.append(None)          # 代表 null\n        elif cmd == \"pick\":\n            result = obj.pick(arg[0])\n            output.append(result)\n        else:\n            # 以防未知指令\n            output.append(None)\n\n    # 使用 json.dumps 以得到 Python 樣式的 null\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Problem: random index pick from array with duplicates. We need to store positions. Approach: HashMap target->list of indices. In constructor, iterate array, add index to map. pick: get list, generate random index among list length, return element. Also handle randomness: use random number generator. Need to mention that each index equal probability. Virtual code step by step.\n\nLet's craft.\n\nStart\n→ Step 1: 定義一個哈希表 targetToIndices // 存放目標值到其所有索引的映射\n→ Step 2: 建立隨機數生成器 rand // 用於隨機選取索引\n→ Step 3: 建構子: Solution(nums) // 初始化\n    → Decision: 遍歷 nums 並填充哈希表\n        → Step 3.1: For i from 0 to nums.length-1\n            → Step 3.1.1: key = nums[i]\n            → Step 3.1.2: 若 key 不在 targetToIndices 則建立新空列表\n            → Step 3.1.3: 將 i 加入 targetToIndices[key] // 儲存索引\n→ Step 4: pick(target) // 隨機選取索引\n    → Step 4.1: indices = targetToIndices[target] // 取得對應索引列表\n    → Decision: len = indices.size()\n        Yes → Step 4.2: r = rand.nextInt(len) // 產生 [0, len) 的隨機整數\n        → Step 4.3: return indices[r] // 以等概率返回選中的索引\nEnd\n\nWe need to output each line with comment. Use indentation maybe but each line starts with arrow? They used arrow for steps. We'll mimic their style: \"Start\", \"→ Step ...\". Decision blocks indent. Provide explanation after //.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 targetToIndices 為空哈希表 // 用來存放每個目標值對應的所有索引  \n→ Step 2: 初始化 rand 為隨機數生成器 // 以確保隨機選擇的公平性  \n→ Step 3: 定義建構子 Solution(nums) // 接收數組並預處理  \n  Decision: 遍歷 nums 並填充哈希表  \n   Yes → Step 3.1: 對 i 從 0 到 nums.length-1 進行迴圈 // 為每個元素取得索引  \n    Step 3.1.1: key ← nums[i] // 取得當前元素的值  \n    Step 3.1.2: 若 key 不在 targetToIndices，則 targetToIndices[key] ← 空列表 // 建立新鍵值對  \n    Step 3.1.3: targetToIndices[key].append(i) // 將索引 i 加入對應列表  \n→ Step 4: 定義 pick(target) // 隨機返回目標值的索引  \n  Step 4.1: indices ← targetToIndices[target] // 取得所有符合的索引列表  \n  Decision: len ← indices.size()  \n   Yes → Step 4.2: r ← rand.nextInt(len) // 產生 0 ≤ r < len 的隨機整數  \n    Step 4.3: return indices[r] // 以等概率返回選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3,2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立「倒序字串 → 索引」的映射\n        rev_to_index = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        def is_pal(s: str) -> bool:\n            return s == s[::-1]\n\n        for i, word in enumerate(words):\n            # 1. 直接倒序配對\n            rev = word[::-1]\n            if rev in rev_to_index and rev_to_index[rev] != i:\n                res.append([i, rev_to_index[rev]])\n\n            # 2. 逐位分割，檢查前後綴是否回文\n            for cut in range(1, len(word)):\n                prefix, suffix = word[:cut], word[cut:]\n\n                # 前綴為回文，後綴倒序存在於映射中\n                if is_pal(prefix):\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_to_index and rev_to_index[rev_suffix] != i:\n                        res.append([rev_to_index[rev_suffix], i])\n\n                # 後綴為回文，前綴倒序存在於映射中\n                if is_pal(suffix):\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_to_index and rev_to_index[rev_prefix] != i:\n                        res.append([i, rev_to_index[rev_prefix]])\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入被外層單引號/雙引號包住，先移除\n    if data[0] in ('\"', \"'\") and data[0] == data[-1]:\n        data = data[1:-1].strip()\n\n    # 如果輸入形如 words = [...]\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        words = ast.literal_eval(arr_str.strip())\n    else:\n        words = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n\n    # 輸出格式與範例保持一致（無空格）\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. Provide step by step for algorithm with O(total length). Classic solution: For each word, reverse and use hash map of words to index. Also check prefixes/suffixes splits. Provide high-level steps: build map, iterate words, for each word split at each position to check palindrome prefix/suffix, look for reversed counterpart. We'll produce pseudocode lines.\n\nLet's craft. Use Start, End, Decision etc. Each line as \"虛擬碼步驟 // 解釋\". Ensure each line has arrow, etc.\n\nWe need to output step by step pseudocode. Let's produce:\n\nStart\n→ Build a map: word_to_index ← empty dictionary\n→ For each word, index in words\n    → Store word_to_index[word] = index\n→ Initialize result ← empty list\n→ For each word, i in words\n    → Let reversed_word ← reverse(word)\n    → If reversed_word in word_to_index and word_to_index[reversed_word] != i\n        → Append (i, word_to_index[reversed_word]) to result // reverse pair\n    → For each cut position from 1 to len(word)-1\n        → prefix ← word[0:cut]\n        → suffix ← word[cut:]\n        → If prefix is palindrome\n            → rev_suffix ← reverse(suffix)\n            → If rev_suffix in word_to_index and word_to_index[rev_suffix] != i\n                → Append (word_to_index[rev_suffix], i) to result // rev suffix before word\n        → If suffix is palindrome\n            → rev_prefix ← reverse(prefix)\n            → If rev_prefix in word_to_index and word_to_index[rev_prefix] != i\n                → Append (i, word_to_index[rev_prefix]) to result // word before rev prefix\n→ End\n\nBut we need to follow arrow formatting. We'll produce step by step with decision blocks.\n\nAlso O(sum len). Provide explanation after each line.\n\nLet's format each line with \"→\" or \"Decision:\" etc.\n\nWe need each line to contain code step and comment after //.\n\nMake sure each line is separate.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典 word_to_index ← {} // 建立單字到其索引的映射  \n→ Step 2: 初始化結果列表 result ← [] // 存放所有回文對  \n→ Step 3: 建立映射：對於每個 word, index in words  \n  → word_to_index[word] = index // 將單字與其索引存入字典  \n→ Step 4: 遍歷每個單字：對於每個 word, i in words  \n  → Step 4.1: 計算反向單字 reversed_word ← reverse(word) // 取 word 的倒序  \n   → Decision: 是否存在 reversed_word 且索引不同?  \n    Yes → Step 4.1.1: result.append((i, word_to_index[reversed_word])) // (i, j) 為回文對  \n    No → // 無直接倒序對  \n  → Step 4.2: 對 word 的每個可能切分位置 cut 從 1 到 len(word)-1  \n   → Step 4.2.1: prefix ← word[0:cut] // 前綴子字串  \n   → Step 4.2.2: suffix ← word[cut:] // 後綴子字串  \n   → Decision: prefix 是否為回文?  \n    Yes → Step 4.2.2.1: rev_suffix ← reverse(suffix) // 取後綴的倒序  \n     Decision: rev_suffix 在字典且索引不同?  \n      Yes → Step 4.2.2.1.1: result.append((word_to_index[rev_suffix], i)) // (j, i) 為回文對  \n      No → // 無此前綴回文對  \n   → Decision: suffix 是否為回文?  \n    Yes → Step 4.2.2.2: rev_prefix ← reverse(prefix) // 取前綴的倒序  \n     Decision: rev_prefix 在字典且索引不同?  \n      Yes → Step 4.2.2.2.1: result.append((i, word_to_index[rev_prefix])) // (i, j) 為回文對  \n      No → // 無此後綴回文對  \n→ End // 程式執行結束，result 為所有回文對的列表"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,1,false]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, 1, false]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyQueue:\n    \"\"\"實作只用兩個堆疊的 FIFO 隊列\"\"\"\n    def __init__(self):\n        # stack_in 用於 push 新元素\n        self.stack_in = []\n        # stack_out 用於 pop / peek 前端元素\n        self.stack_out = []\n\n    def push(self, x: int) -> None:\n        \"\"\"將元素 x 推進堆疊 stack_in\"\"\"\n        self.stack_in.append(x)\n\n    def pop(self) -> int:\n        \"\"\"移除並返回隊列前端元素\"\"\"\n        self.peek()            # 確保 stack_out 有元素\n        return self.stack_out.pop()\n\n    def peek(self) -> int:\n        \"\"\"返回隊列前端元素但不移除\"\"\"\n        if not self.stack_out:\n            # 將 stack_in 的所有元素倒轉到 stack_out\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self) -> bool:\n        \"\"\"判斷隊列是否為空\"\"\"\n        return not self.stack_in and not self.stack_out\n\ndef main() -> None:\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 如果第一行是字串 \"Input\"，則略過\n    if data[0].strip() == \"Input\":\n        data = data[1:]\n    if len(data) < 3:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n    # 若第二行包含列表，第三行是參數\n    if isinstance(args, list) and len(args) == 1:\n        args = args[0]\n    # 若第一行已是列表，第二行是參數，第三行忽略\n    # 這裡假設輸入符合格式\n    res = []\n    queue = None\n    for op, a in zip(ops, args):\n        if op == \"MyQueue\":\n            queue = MyQueue()\n            res.append(None)\n        elif op == \"push\":\n            queue.push(a[0])\n            res.append(None)\n        elif op == \"pop\":\n            res.append(queue.pop())\n        elif op == \"peek\":\n            res.append(queue.peek())\n        elif op == \"empty\":\n            res.append(queue.empty())\n        else:\n            # 忽略未知操作\n            res.append(None)\n    # 輸出結果，使用 JSON 以符合範例格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments. Must implement MyQueue class with push, pop, peek, empty. Using two stacks. Should output virtual code only, no actual code. Use arrows. Steps: Start, initialization of two stacks stack1, stack2. Push: push onto stack1. Pop: if stack2 empty, move all from stack1 to stack2. Then pop from stack2. Peek similar but peek top of stack2. Empty: both stacks empty. Provide comments. Each line: \"虛擬碼步驟 // 解釋\". Use arrows: Start, End. Use Decision blocks where needed. Probably like:\n\nStart\n→ Step 1: 初始化 stack1 ← 空堆疊 // 用於存入新元素\n→ Step 2: 初始化 stack2 ← 空堆疊 // 用於彈出/查看前端\n→ Method: push(x) // 向後端推送元素\n    → Step 3: stack1.push(x) // 將 x 推入 stack1\n→ Method: pop() // 從前端移除並返回元素\n    → Decision: 如果 stack2.isEmpty()? // 確認後端堆疊是否有元素\n        Yes → Step 4: While stack1.notEmpty(): stack2.push(stack1.pop()) // 將所有 stack1 元素倒轉到 stack2\n        No →\n    → Step 5: return stack2.pop() // 從 stack2 弹出前端元素\n→ Method: peek() // 返回前端元素而不移除\n    → Decision: 如果 stack2.isEmpty()? // 同樣檢查是否需要轉移\n        Yes → Step 6: While stack1.notEmpty(): stack2.push(stack1.pop())\n        No →\n    → Step 7: return stack2.peek() // 查看 stack2 顶部元素\n→ Method: empty() // 判斷隊列是否為空\n    → Step 8: return stack1.isEmpty() AND stack2.isEmpty() // 兩堆疊皆空則為空\nEnd\n\nEnsure each line includes comment. Provide indentation maybe. Use arrows for decisions: Decision: if? then Yes →. Might need newline after decision lines. Provide consistent format. We'll produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack1 ← 空堆疊 // 用於存入新元素\n→ Step 2: 初始化 stack2 ← 空堆疊 // 用於彈出/查看前端\n\n→ Method: push(x) // 向後端推送元素\n    → Step 3: stack1.push(x) // 將 x 推入 stack1\n\n→ Method: pop() // 從前端移除並返回元素\n    → Decision: 如果 stack2.isEmpty()? // 判斷是否已有待處理元素\n        Yes → Step 4: While stack1.notEmpty(): stack2.push(stack1.pop()) // 將所有 stack1 元素倒轉到 stack2\n        No  → \n    → Step 5: return stack2.pop() // 從 stack2 弹出前端元素\n\n→ Method: peek() // 返回前端元素而不移除\n    → Decision: 如果 stack2.isEmpty()? // 判斷是否需轉移元素\n        Yes → Step 6: While stack1.notEmpty(): stack2.push(stack1.pop()) // 倒轉 stack1 到 stack2\n        No  → \n    → Step 7: return stack2.peek() // 查看 stack2 顶部元素\n\n→ Method: empty() // 判斷隊列是否為空\n    → Step 8: return stack1.isEmpty() AND stack2.isEmpty() // 兩堆疊皆空即為空\n\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出最長的不常見子序列長度。\n        只要有一個字串在陣列中唯一，整個字串本身即為不常見子序列，\n        因此只需要找出唯一字串中長度最大的那一個即可。\n        \"\"\"\n        freq = Counter(strs)          # 計算每個字串的出現次數\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1:          # 只出現一次的字串\n                if len(s) > max_len:\n                    max_len = len(s)\n        return max_len\n\ndef main():\n    # 讀取整個輸入，並解析為 Python 的 list\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若輸入不是合法 JSON，視為單一字串\n        strs = [data]\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Understand the problem: Given array strs, need longest uncommon subsequence length. Approach: If any string not equal to others, then answer is length of longest string that is unique. Because longest uncommon subsequence exists only if there is a string that is not equal to any other; its entire string is subsequence of itself and not of others. Return its length. If all strings same, return -1. Also if duplicates but some longer unique: need check.\n\nSo algorithm: Count frequencies of each string. For each string, if freq==1, track its length; answer is max length among such strings. If none, return -1.\n\nEdge: empty string? If only empty strings? freq==1? If single empty string, answer length 0? According to problem, longest uncommon subsequence may be empty string? If no others, empty string is subsequence of itself but not others; length 0. So return 0. If multiple empty strings, freq>1, no answer, -1.\n\nVirtual code steps: Start, compute freq map, iterate, find max length where freq==1. Decision: If maxLength>0? But if zero? Accept zero. If maxLength stays -inf? Return -1. End.\n\nNow produce step lines.\n\nLet's craft.\n\nStep: Start // begin\n\n→ Step 1: Initialize empty map freq // store counts\n\n→ Step 2: For each string s in strs: increment freq[s] // count occurrences\n\n→ Step 3: Set maxLen = -1 // sentinel for no uncommon subsequence\n\n→ Step 4: For each string s in strs: // iterate again to find unique strings\n\n    → Decision: if freq[s] == 1? // string appears only once\n\n        Yes → Step 5: Update maxLen = max(maxLen, length of s) // keep longest\n\n        No → Step 6: Continue // skip duplicates\n\n→ Step 7: Decision: if maxLen == -1? // no unique string found\n\n        Yes → Step 8: Return -1 // no uncommon subsequence\n\n        No  → Step 9: Return maxLen // longest uncommon subsequence length\n\nEnd // program ends\n\nBut we must follow format exactly: each line includes \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow arrow syntax. Let's format.\n\nNeed to include indentation? Not mandatory, but can indent to show branches.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 freq // 用於記錄每個字串出現次數\n→ Step 2: 對 strs 中每個字串 s 執行: freq[s] += 1 // 逐一計數\n→ Step 3: 設置變數 maxLen = -1 // 初始為不存在不常見子序列\n→ Step 4: 對 strs 中每個字串 s 執行:\n    → Decision: freq[s] == 1? // 字串只出現一次\n        Yes → Step 5: maxLen = max(maxLen, length(s)) // 更新最大長度\n        No  → Step 6: 進行下一個字串 // 跳過重複字串\n→ Step 7: Decision: maxLen == -1? // 是否找不到唯一字串\n    Yes → Step 8: 回傳 -1 // 沒有不常見子序列\n    No  → Step 9: 回傳 maxLen // 返回最長不常見子序列長度\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" but we can use Step numbers. Use \"→ Step X\" etc. Should not output actual code.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 freq // 用於記錄每個字串出現次數  \n→ Step 2: 對 strs 中每個字串 s 執行: freq[s] += 1 // 逐一計數  \n→ Step 3: 設置變數 maxLen = -1 // 初始為不存在不常見子序列  \n→ Step 4: 對 strs 中每個字串 s 執行:  \n  → Decision: freq[s] == 1? // 字串只出現一次  \n   Yes → Step 5: maxLen = max(maxLen, length(s)) // 更新最大長度  \n   No  → Step 6: 進行下一個字串 // 跳過重複字串  \n→ Step 7: Decision: maxLen == -1? // 是否找不到唯一字串  \n  Yes → Step 8: 回傳 -1 // 沒有不常見子序列  \n  No  → Step 9: 回傳 maxLen // 返回最長不常見子序列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef permute(nums):\n    \"\"\"返回 nums 所有排列的列表。\"\"\"\n    res = []\n\n    def backtrack(start):\n        if start == len(nums):\n            # 完整排列時，將當前排列加入結果\n            res.append(nums[:])\n            return\n        for i in range(start, len(nums)):\n            # 交換位置，選擇 nums[i] 作為首位\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            # 回溯：還原交換\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析類似 \"nums = [1,2,3]\" 的輸入\n    parts = data.split('=', 1)\n    if len(parts) == 2:\n        nums = ast.literal_eval(parts[1].strip())\n    else:\n        nums = []\n\n    # 計算排列並以 JSON 格式輸出，無空格\n    result = permute(nums)\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of an array of distinct integers. Must use virtual code syntax: Start, → Step n, Decision, Yes→, No→, End. Each line: virtual code step + space + // explanation. No actual code. Provide step-by-step algorithm.\n\nWe should produce pseudocode for backtracking. Outline: Start; → Input array; → Initialize result list; → Define recursive function backtrack(current, remaining); → Decision if remaining empty? Yes→ add current to result; No→ for each element in remaining: choose it, call backtrack(current+element, remaining-remove element); → End. Finally, return result.\n\nNeed to format as lines. Each line must be one step. Use → for normal steps, Decision for condition. Use Yes → and No → under Decision.\n\nWe must use the syntax: \"Start\" and \"End\". Use \"Decision:\" label.\n\nSo produce lines:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 從使用者處取得整數陣列\n→ Step 2: 初始化空列表 result // 用於存放所有排列\n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // 建立回溯函式\n→ Decision: 如果 remaining 為空? // 檢查是否已排列完成\n    Yes → Step 4: 將 current 加入 result // 完整排列，加入結果\n    No  → Step 5: 遍歷 remaining 中每個元素 element // 逐個選擇\n        → Step 6: 移除 element 從 remaining 新列表 next_remaining // 準備下一階段\n        → Step 7: 追加 element 到 current 新列表 next_current // 更新目前排列\n        → Step 8: 呼叫 backtrack(next_current, next_remaining) // 進行下一層遞迴\n→ Step 9: 呼叫 backtrack([], nums) // 開始回溯，從空排列開始\n→ Step 10: 返回 result // 回傳所有排列\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". So each line: e.g., \"Start // 程式開始執行\". Use arrow for steps. For decisions: \"Decision: 如果 remaining 為空?\" etc. Then under Yes/No.\n\nMake sure no actual code lines like for loops, but the steps can mention \"遍歷 remaining 中每個元素\". That's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者處取得整數陣列  \n→ Step 2: 初始化空列表 result // 用於存放所有排列  \n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // 建立回溯函式  \n→ Decision: 如果 remaining 為空? // 檢查是否已排列完成  \n  Yes → Step 4: 將 current 加入 result // 完整排列，加入結果  \n  No  → Step 5: 遍歷 remaining 中每個元素 element // 逐個選擇  \n        → Step 6: 移除 element 從 remaining 新列表 next_remaining // 準備下一階段  \n        → Step 7: 追加 element 到 current 新列表 next_current // 更新目前排列  \n        → Step 8: 呼叫 backtrack(next_current, next_remaining) // 進行下一層遞迴  \n→ Step 9: 呼叫 backtrack([], nums) // 開始回溯，從空排列開始  \n→ Step 10: 返回 result // 回傳所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []                      # 存放所有元素的陣列\n        self.idx_map = collections.defaultdict(set)  # 值 -> 所有索引的集合\n\n    def insert(self, val):\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若是第一次插入該值，返回 True；否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        if not self.idx_map[val]:\n            return False\n        # 從集合中取出一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 如果要刪除的不是最後一個元素，先把最後一個元素搬到刪除的位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        self.data.pop()  # 刪除最後一個元素\n        # 若此值已無剩餘，移除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 將輸入轉換為兩個列表，例如 [[\"RandomizedCollection\",\"insert\"], [[],[1]]]\n    wrapped = '[' + raw_input + ']'\n    commands, args_list = ast.literal_eval(wrapped)\n\n    obj = None\n    results = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)\n        elif cmd == \"insert\":\n            res = obj.insert(args[0])\n            results.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(args[0])\n            results.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            results.append(res)\n        else:\n            # 其他不會出現的指令，直接忽略\n            results.append(None)\n\n    # json.dumps 會把 None, True, False 轉成 null, true, false\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for a RandomizedCollection with insert, remove, getRandom, all O(1) average. We should describe the algorithm: use vector (list) to store values and a hash map from value to set of indices. Insert: push_back to list, add index to map set, return true if map size 1. Remove: if val not in map, return false. else get an index from set, remove it: swap with last element in list, update map for swapped element, pop_back, delete index from map set, if set empty, remove key. getRandom: random index from list.\n\nWe need to output line by line, each with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows.\n\nWe'll produce overall structure: Start, Initialize data structures, then functions. Might include function definitions as separate blocks. Each function: Start function, steps. Use Decision for checking presence etc.\n\nWe should ensure each line ends with comment. Provide pseudo-code with arrows.\n\nLet's draft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize list `nums` to store all elements in order // 1. 用陣列儲存所有元素  \n→ Initialize map `idxMap` mapping value → set of indices in `nums` // 2. 用哈希表紀錄每個值的所有位置  \n\n// ---------- 插入 ----------\n→ Define `insert(val)` // 3. 定義插入方法  \n→ Decision: 如果 `val` 尚未存在於 `idxMap`? // 4. 檢查值是否第一次出現  \n    Yes → Set `isNew` to true // 5. 第一次出現，標記為新  \n    No  → Set `isNew` to false // 6. 不是新值  \n→ Append `val` to `nums` // 7. 把值加入陣列  \n→ Add index `len(nums)-1` to `idxMap[val]` // 8. 記錄新位置  \n→ Return `isNew` // 9. 回傳是否為新值  \n\n// ---------- 刪除 ----------\n→ Define `remove(val)` // 10. 定義刪除方法  \n→ Decision: 如果 `val` 不在 `idxMap`? // 11. 檢查是否存在  \n    Yes → Return false // 12. 不存在，直接回傳 false  \n    No  → Proceed // 13. 存在，繼續刪除  \n→ Obtain an arbitrary index `removeIdx` from `idxMap[val]` // 14. 取一個該值的索引  \n→ Remove `removeIdx` from `idxMap[val]` // 15. 從集合移除此索引  \n→ Set `lastIdx` = `len(nums)-1` // 16. 取得最後一個元素的索引  \n→ Decision: 如果 `removeIdx` 等於 `lastIdx`? // 17. 判斷刪除的元素是否是最後一個  \n    Yes → Pop `nums` // 18. 若是，直接移除最後一個  \n    No  →  \n        Set `lastVal` = `nums[lastIdx]` // 19. 取得最後一個元素值  \n        Replace `nums[removeIdx]` with `lastVal` // 20. 把最後一個元素放到被刪除的位置  \n        Pop `nums` // 21. 移除陣列最後一個元素  \n        Remove `lastIdx` from `idxMap[lastVal]` // 22. 從最後一個元素的索引集合移除舊位置  \n        Add `removeIdx` to `idxMap[lastVal]` // 23. 加入新位置到集合  \n→ Decision: 如果 `idxMap[val]` 為空? // 24. 檢查是否已無此值剩餘  \n    Yes → Delete key `val` from `idxMap` // 25. 若無，刪除哈希表鍵  \n    No  → Keep // 26. 若有，保留  \n→ Return true // 27. 刪除成功  \n\n// ---------- 隨機取值 ----------\n→ Define `getRandom()` // 28. 定義隨機取值方法  \n→ Generate random integer `randIdx` in range [0, len(nums)-1] // 29. 產生隨機索引  \n→ Return `nums[randIdx]` // 30. 回傳該位置的值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv4wx0rgz.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpv4wx0rgz.py\", line 55, in main\n    intervals, new_interval = parse_input(data)\n                              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpv4wx0rgz.py\", line 47, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp90xie07b.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmp90xie07b.py\", line 55, in main\n    intervals, new_interval = parse_input(data)\n                              ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp90xie07b.py\", line 47, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, new_interval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals\n        and merge any overlapping intervals.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals ending before new_interval starts\n        while i < n and intervals[i][1] < new_interval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with new_interval\n        while i < n and intervals[i][0] <= new_interval[1]:\n            new_interval[0] = min(new_interval[0], intervals[i][0])\n            new_interval[1] = max(new_interval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged new_interval\n        result.append(new_interval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    Parse input of the form:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    \"\"\"\n    # Find the two list expressions\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[.*?\\])', text, re.S)\n    new_interval_match = re.search(r'newInterval\\s*=\\s*(\\[.*?\\])', text, re.S)\n    if not intervals_match or not new_interval_match:\n        raise ValueError(\"Input format is incorrect\")\n\n    intervals = ast.literal_eval(intervals_match.group(1))\n    new_interval = ast.literal_eval(new_interval_match.group(1))\n    return intervals, new_interval\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    intervals, new_interval = parse_input(data)\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for inserting new interval into sorted non-overlapping intervals, merging overlapping ones. Provide each line with virtual code step and comment explanation. Use Start, Decision, Yes/No, etc.\n\nWe need to be thorough but concise. Provide steps like: initialize result array, iterate over intervals, compare with newInterval.\n\nLet's craft steps:\n\nStart\n\n→ Initialize empty result list // result\n\n→ Set i=0 // index\n\n→ While i < intervals.length and intervals[i].end < newInterval.start // skip intervals ending before new\n\n   → Append intervals[i] to result\n\n   → i++\n\n→ While i < intervals.length and intervals[i].start <= newInterval.end // intervals overlapping\n\n   → newInterval.start = min(newInterval.start, intervals[i].start)\n\n   → newInterval.end = max(newInterval.end, intervals[i].end)\n\n   → i++\n\n→ Append newInterval to result // after merging\n\n→ While i < intervals.length // remaining intervals\n\n   → Append intervals[i] to result\n\n   → i++\n\n→ End\n\nNeed to use Decision lines where appropriate. For while loops we can show as Decision? but simpler to show as Step.\n\nBut the requirement: use Decision and arrows.\n\nWe can represent loop as Decision: While condition? Yes → ... No → ... ; but can keep simpler.\n\nLet's use Decision: For skip intervals:\n\nDecision: i < intervals.length AND intervals[i].end < newInterval.start? Yes → Step: append & i++ No → ...\n\nSimilarly for overlapping.\n\nBut we need to produce each line of virtual code.\n\nLet's structure:\n\nStart // 程式開始執行\n\n→ Step 1: result ← empty list // 儲存最終區間\n\n→ Step 2: i ← 0 // 索引\n\n→ Decision: i < len(intervals) AND intervals[i].end < newInterval.start? // 跳過不重疊且在 newInterval 前的區間\n\n    Yes → Step 3: result.append(intervals[i]) // 加入結果\n\n    Yes → Step 4: i ← i + 1 // 移動索引\n\n    No  → ...\n\nBut this loop representation is messy.\n\nAlternative: Use While representation: While ... // loops. It's acceptable? Not explicit in format. They didn't forbid While. Example only shows Decision but we can show loops. But to be safe, use Decision and Yes/No.\n\nMaybe better:\n\nDecision: i < len(intervals) AND intervals[i].end < newInterval.start? // 若當前區間結束在 newInterval 之前\n\n    Yes → Step: result.append(intervals[i]) // 加入結果\n\n    Yes → Step: i ← i + 1 // 進入下一個\n\n    No  → Step: break // 跳出循環\n\nBut then we need to loop again; we could embed in a higher level loop Decision: i < len(intervals)? // 仍有區間\n\n    Yes → Decision: intervals[i].end < newInterval.start? // ...\n    No → ...\n\nSimplify: Use high-level loop: While i < len(intervals) and intervals[i].end < newInterval.start: append and i++ . This is clearer.\n\nOk maybe allowed.\n\nBut they said use virtual code arrows and structure. But example only uses Decision. I think loops are acceptable.\n\nLet's produce:\n\nStart\n\n→ Step 1: result ← [] // result list\n\n→ Step 2: i ← 0 // index\n\n→ While i < len(intervals) and intervals[i].end < newInterval.start // 過去不重疊的區間\n\n    → Step 3: result.append(intervals[i]) // 加入\n\n    → Step 4: i ← i + 1 // 前進\n\n→ While i < len(intervals) and intervals[i].start <= newInterval.end // 重疊區間\n\n    → Step 5: newInterval.start ← min(newInterval.start, intervals[i].start) // 合併起點\n\n    → Step 6: newInterval.end ← max(newInterval.end, intervals[i].end) // 合併終點\n\n    → Step 7: i ← i + 1 // 前進\n\n→ Step 8: result.append(newInterval) // 插入合併後的新區間\n\n→ While i < len(intervals) // 剩餘不重疊的區間\n\n    → Step 9: result.append(intervals[i]) // 加入\n\n    → Step 10: i ← i + 1 // 前進\n\nEnd\n\nThis includes loops. Provide comments. The format: each line virtual code plus // explanation. For while loops, maybe combine. But okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 初始化儲存最終區間的列表  \n→ Step 2: i ← 0 // 初始化區間索引  \n\n→ While i < len(intervals) AND intervals[i].end < newInterval.start // 遍歷所有不重疊且在新區間之前的區間  \n    → Step 3: result.append(intervals[i]) // 把這些區間直接加入結果  \n    → Step 4: i ← i + 1 // 移動到下一個區間  \n\n→ While i < len(intervals) AND intervals[i].start <= newInterval.end // 遍歷所有與新區間重疊的區間  \n    → Step 5: newInterval.start ← min(newInterval.start, intervals[i].start) // 合併起始點  \n    → Step 6: newInterval.end ← max(newInterval.end, intervals[i].end) // 合併結束點  \n    → Step 7: i ← i + 1 // 移動到下一個區間  \n\n→ Step 8: result.append(newInterval) // 把合併後的新區間加入結果  \n\n→ While i < len(intervals) // 將剩餘所有不重疊的區間加入結果  \n    → Step 9: result.append(intervals[i]) // 加入結果  \n    → Step 10: i ← i + 1 // 移動到下一個區間  \n\nEnd // 程式執行結束，返回 result。"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiaa90stu.py\", line 30, in <module>\n    ops = ast.literal_eval(ops_part.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"LRUCache\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to the end (most recent)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove least recently used\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    ops_part, args_part = data.split(',', 1)\n    ops = ast.literal_eval(ops_part.strip())\n    args = ast.literal_eval(args_part.strip())\n\n    result = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            result.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)\n        elif op == \"get\":\n            result.append(cache.get(arg[0]))\n    # Output as JSON to match LeetCode format (None -> null)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Each line has the virtual code step + space + // explanation. Use arrows, decisions, Start, End. Should not output real code. Just steps. Provide a virtual code for designing LRUCache: need to describe using hash map + doubly linked list. Steps for initialization, get, put, eviction. Each line should be a step, not multiple code lines. Provide explanation after //.\n\nLet's produce a sequence: Start, initialize capacity, create hashmap, create doubly linked list with dummy head/tail. Then get operation: check hashmap, if not exist return -1. If exist, move node to front, return value. Put: if key exists, update value, move node to front. Else create node, add to front, add to hashmap. If size > capacity, remove tail node, delete from hashmap. End.\n\nNeed to include Decision steps for existence check. Use arrow for steps. Use indentation for nested decisions maybe.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: LRUCache(int capacity) 初始化 LRU 緩存並存儲最大容量 capacity // 建立緩存物件並記錄容量  \n→ Step 2: 建立 HashMap key_to_node // 用於 O(1) 查找節點  \n→ Step 3: 建立雙向鏈表並加入 dummy head 與 dummy tail // 方便快速移動與刪除節點  \n→ Step 4: 設定 head <-> tail 之間無節點，並維持 size 為 0 // 初始鏈表狀態  \n→ Step 5: Store capacity, head, tail, map, size 於 LRUCache 物件 // 完成建構  \n\n→ Step 6: int get(int key) // 呼叫取得方法  \n    → Decision: key 是否存在於 map? // 判斷 key 是否已緩存  \n        Yes → Step 7: node ← map[key] // 取得對應節點  \n        Yes → Step 8: move_node_to_front(node) // 將節點標記為最近使用  \n        Yes → Step 9: return node.value // 返回值  \n        No  → Step 10: return -1 // key 不存在  \n\n→ Step 11: void put(int key, int value) // 呼叫新增/更新方法  \n    → Decision: key 是否存在於 map? // 判斷是否已緩存  \n        Yes → Step 12: node ← map[key] // 取得節點  \n        Yes → Step 13: node.value ← value // 更新值  \n        Yes → Step 14: move_node_to_front(node) // 標記為最近使用  \n        No  → Step 15: node ← new Node(key, value) // 新建節點  \n        No  → Step 16: add_node_to_front(node) // 加入鏈表頭  \n        No  → Step 17: map[key] ← node // 進入哈希表  \n        No  → Step 18: size ← size + 1 // 更新大小  \n        No  → Decision: size > capacity? // 檢查是否超過容量  \n            Yes → Step 19: lru_node ← tail.prev // 最舊節點  \n            Yes → Step 20: remove_node(lru_node) // 從鏈表移除  \n            Yes → Step 21: delete map[lru_node.key] // 從哈希表刪除  \n            Yes → Step 22: size ← size - 1 // 更新大小  \n            No  → Step 23: // 不超過容量，無需淘汰  \n\n→ End // 程式執行結束"
    },
    {
      "title": "Minimum Index Sum of Two Lists",
      "source_file": "Leetcode/leetcode599.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb8gherq7.py\", line 26, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]",
          "expected_output": "[\"Shogun\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk55z3nhf.py\", line 26, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]",
          "expected_output": "[\"sad\",\"happy\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpi6_7vayy.py\", line 26, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findRestaurant(self, list1, list2):\n        # 建立字典以快速查找 list1 中每個餐廳的索引\n        index_map = {name: i for i, name in enumerate(list1)}\n        min_sum = float('inf')\n        res = []\n\n        # 遍歷 list2，找尋共通餐廳並計算索引和\n        for j, name in enumerate(list2):\n            if name in index_map:\n                total_index = j + index_map[name]\n                if total_index < min_sum:\n                    min_sum = total_index\n                    res = [name]          # 找到更小的索引和，更新結果\n                elif total_index == min_sum:\n                    res.append(name)      # 同樣的最小索引和，加入結果\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整段文字\n    data = sys.stdin.read()\n    local_vars = {}\n    # 使用 exec 解析類似 python 語法的輸入\n    exec(data, {}, local_vars)\n\n    list1 = local_vars.get('list1', [])\n    list2 = local_vars.get('list2', [])\n\n    solution = Solution()\n    result = solution.findRestaurant(list1, list2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code in Chinese (繁體) following format. For each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Provide algorithm: map list1 to index, iterate list2 find common, compute sum, track min sum, list of results.\n\nWe must produce one line per pseudo-step, not too many but logically separated. Could use composite steps: \"Start\", \"Step 1: 建立字典 map1\" etc.\n\nAlso incorporate decision branches: decision if common found and sum less than minSum, etc.\n\nNeed to show loops: For i in list1: store index; For j in list2: check existence, compute sum; update.\n\nWe must keep step-by-step. Possibly use \"Loop\" pseudo syntax? They didn't specify but we can use \"Step 3: 對 list2 逐一遍歷\" etc.\n\nAlso need to use arrow (→). Format: \"Start // 程式開始執行\" etc.\n\nWe can do: \nStart // 程式開始執行\n→ Step 1: 建立空字典 indexMap // 用於存 list1 中字符串對應的索引\n→ Step 2: 建立空變數 minSum = 無限 // 追蹤目前已知的最小索引和\n→ Step 3: 建立空列表 result // 儲存最小索引和的共通字串\n→ Decision: 是否遍歷 list1? // 對 list1 進行遍歷\n    Yes → Loop for each (idx, str) in list1\n          → Step 4: indexMap[str] = idx // 將字串映射到其索引\n          → Step 5: 進入下一項\n    No → End // 若 list1 為空，直接結束\n\n→ Decision: 是否遍歷 list2? // 對 list2 進行遍歷\n    Yes → Loop for each (j, str2) in list2\n          → Step 6: 如果 str2 在 indexMap 中\n                Yes → Step 7: 計算 sum = j + indexMap[str2] // 取得索引和\n                → Step 8: Decision: sum < minSum?\n                    Yes → Step 9: minSum = sum // 更新最小值\n                        → Step 10: 清空 result 並加入 str2 // 新的最小索引和結果\n                    No → Step 11: Decision: sum == minSum?\n                        Yes → Step 12: result.append(str2) // 同為最小值，加入\n                        No → Step 13: 省略 // 不是最小，忽略\n          → Step 14: 進入下一項\n    No → End\n\n→ End // 返回 result\n\nBut need to maintain proper formatting: each line with \"→\" before step? They used \"→ Step 1:\" etc. Indent decision branches with \"Yes →\" etc. We'll produce lines accordingly.\n\nEnsure each line ends with comment.\n\nWe should include \"Start // 程式開始執行\" etc.\n\nMake sure not to output actual code; just pseudo.\n\nLet's craft.\n\nWe may produce a block:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 indexMap // 用於存 list1 中字串與其索引的映射\n→ Step 2: 建立變數 minSum = Infinity // 追蹤目前已知的最小索引和\n→ Step 3: 建立空列表 result // 儲存最小索引和的共通字串\n→ Decision: 若 list1 非空? // 判斷是否需要遍歷 list1\n    Yes → Loop: for i, str1 in enumerate(list1)\n          → Step 4: indexMap[str1] = i // 將字串映射到其索引\n          → Step 5: 繼續遍歷\n    No  → // 無需處理 list1，直接跳到下一步\n→ Decision: 若 list2 非空? // 判斷是否需要遍歷 list2\n    Yes → Loop: for j, str2 in enumerate(list2)\n          → Step 6: Decision: str2 是否在 indexMap? // 檢查是否為共通字串\n                Yes → Step 7: sum = j + indexMap[str2] // 計算索引和\n                    → Decision: sum < minSum? // 是否比目前最小值更小\n                        Yes → Step 8: minSum = sum // 更新最小值\n                            → Step 9: result = [str2] // 清空並加入新的最小結果\n                        No  → Decision: sum == minSum? // 是否等於最小值\n                            Yes → Step 10: result.append(str2) // 加入同樣最小的字串\n                            No  → // 不是最小值，忽略\n                No  → // str2 不在 list1，跳過\n          → Step 11: 繼續遍歷\n    No  → // list2 為空，直接結束\n→ End // 程式結束，返回 result\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". So each line above is separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 indexMap // 用於存 list1 中字串與其索引的映射  \n→ Step 2: 建立變數 minSum = Infinity // 追蹤目前已知的最小索引和  \n→ Step 3: 建立空列表 result // 儲存最小索引和的共通字串  \n→ Decision: 若 list1 非空? // 判斷是否需要遍歷 list1  \n Yes → Loop: for i, str1 in enumerate(list1)  \n  → Step 4: indexMap[str1] = i // 將字串映射到其索引  \n  → Step 5: 繼續遍歷  \n No  → // 無需處理 list1，直接跳到下一步  \n→ Decision: 若 list2 非空? // 判斷是否需要遍歷 list2  \n Yes → Loop: for j, str2 in enumerate(list2)  \n  → Step 6: Decision: str2 是否在 indexMap? // 檢查是否為共通字串  \n   Yes → Step 7: sum = j + indexMap[str2] // 計算索引和  \n    → Decision: sum < minSum? // 是否比目前最小值更小  \n     Yes → Step 8: minSum = sum // 更新最小值  \n      → Step 9: result = [str2] // 清空並加入新的最小結果  \n     No  → Decision: sum == minSum? // 是否等於最小值  \n      Yes → Step 10: result.append(str2) // 加入同樣最小的字串  \n      No  → // 不是最小值，忽略  \n   No  → // str2 不在 list1，跳過  \n  → Step 11: 繼續遍歷  \n No  → // list2 為空，直接結束  \n→ End // 程式結束，返回 result"
    },
    {
      "title": "K Inverse Pairs Array",
      "source_file": "Leetcode/leetcode629.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 3, k = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1000000006'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1000000006'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nMOD = 10**9 + 7\n\ndef count_inversions(n: int, k: int) -> int:\n    \"\"\"\n    Return the number of permutations of 1..n that have exactly k inversion pairs,\n    modulo 10^9+7.\n    \"\"\"\n    # If k is larger than the maximum possible inversions, answer is 0\n    max_inv = n * (n - 1) // 2\n    if k > max_inv:\n        return 0\n\n    # dp_prev[j] = number of permutations of length i-1 with j inversions\n    dp_prev = [0] * (k + 1)\n    dp_prev[0] = 1  # base case: empty permutation\n\n    for i in range(1, n + 1):\n        dp_cur = [0] * (k + 1)\n        dp_cur[0] = 1  # exactly 0 inversions when all elements are in order\n\n        prefix = 0\n        for j in range(1, k + 1):\n            # Build prefix sum of dp_prev up to j\n            prefix = (prefix + dp_prev[j]) % MOD\n\n            # dp_cur[j] = sum_{t=0}^{min(j, i-1)} dp_prev[j - t]\n            val = prefix\n            if j >= i:\n                # Subtract the part that exceeds i-1 inversions\n                val = (val - dp_prev[j - i] + MOD) % MOD\n            dp_cur[j] = val\n\n        dp_prev = dp_cur\n\n    return dp_prev[k]\n\ndef solve() -> None:\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = count_inversions(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for DP solution: Count arrays of 1..n with exactly k inversions. Classic problem: number of permutations with k inversions: DP[n][k] = sum_{i=0 to min(k,n-1)} DP[n-1][k-i]. Use prefix sums optimization. Return modulo MOD.\n\nSo virtual code: start, define MOD. Then initialize dp array 2D of size (n+1)*(k+1). dp[0][0]=1. For i from 1 to n: compute prefix sum of previous row. For j 0..k: dp[i][j] = prefix[j] - (j-i>=0?prefix[j-i]:0) mod. Actually standard recurrence: dp[i][j] = dp[i][j-1] + dp[i-1][j] - (j-i>=0?dp[i-1][j-i]:0). Or use prefix.\n\nWe'll produce step-by-step pseudocode.\n\nNeed to use arrow and Decision if needed.\n\nWe'll include loops. Provide each line.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MOD ← 10^9 + 7 // 用來取模  \n→ Step 2: 建立 2D 陣列 dp[0…n][0…k] 並初始化為 0 // dp[i][j] 代表長度 i 的排列有 j 個逆序對的數量  \n→ Step 3: 設定 dp[0][0] ← 1 // 空排列只有一種，逆序對數為 0  \n→ Step 4: 針對 i 從 1 到 n 執行 // 處理長度 i 的排列  \n  → Step 5: 建立 1D 陣列 prefix[0…k] 為 0 // prefix 用來快速計算前綴和  \n  → Step 6: 針對 j 從 0 到 k 執行 // 計算 dp[i-1] 的前綴和  \n    → Step 7: 若 j = 0 則 prefix[0] ← dp[i-1][0]  \n    → Step 8: 否則 prefix[j] ← (prefix[j-1] + dp[i-1][j]) mod MOD // 前綴和累加  \n  → Step 9: 針對 j 從 0 到 k 執行 // 使用前綴和計算 dp[i][j]  \n    → Step 10: 定義 left ← j - i // 代表超出範圍的部分  \n    → Decision: 如果 left < 0? // 若 j 小於 i，則不需要減去任何項  \n        Yes → Step 11: dp[i][j] ← prefix[j] // 直接取前綴和  \n        No  → Step 12: dp[i][j] ← (prefix[j] - prefix[left] + MOD) mod MOD // 減去不合法的部分，並取正模  \n→ Step 13: End of i loop // 完成所有長度的 DP 計算  \n→ Step 14: 回傳 dp[n][k] // 需要的答案  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '13'\nGot (Norm):      '[1,5,9]'\n--- (Raw) ---\nRaw Expected: '13'\nRaw Got:      '[1, 5, 9]'"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-5'\nGot (Norm):      '[-5]'\n--- (Raw) ---\nRaw Expected: '-5'\nRaw Got:      '[-5]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef count_less_equal(matrix, target):\n    \"\"\"計算矩陣中小於等於 target 的元素個數\"\"\"\n    n = len(matrix)\n    count = 0\n    row, col = n - 1, 0          # 從最左下角開始\n    while row >= 0 and col < n:\n        if matrix[row][col] <= target:\n            # 這行至上方所有元素都 <= target\n            count += row + 1\n            col += 1\n        else:\n            row -= 1\n    return count\n\ndef kth_smallest(matrix, k):\n    \"\"\"利用二分搜尋找出第 k 個最小元素\"\"\"\n    n = len(matrix)\n    low, high = matrix[0][0], matrix[n-1][n-1]\n    while low < high:\n        mid = (low + high) // 2\n        cnt = count_less_equal(matrix, mid)\n        if cnt < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\ndef parse_input(raw):\n    \"\"\"解析輸入字串得到 matrix 與 k\"\"\"\n    # 將所有換行符號轉成空格，方便分割\n    raw = raw.replace('\\n', ' ')\n    if 'k =' in raw:\n        mat_part, k_part = raw.split('k =', 1)\n        k = int(k_part.strip())\n    else:\n        raise ValueError(\"Missing k value in input\")\n    if '=' in mat_part:\n        _, mat_str = mat_part.split('=', 1)\n        mat_str = mat_str.strip()\n    else:\n        mat_str = mat_part.strip()\n    matrix = ast.literal_eval(mat_str)\n    return matrix, k\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        return\n    matrix, k = parse_input(raw_input)\n    result = kth_smallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step, with explanations. Use virtual code with arrows and decisions. Must solve: find kth smallest in sorted matrix (each row and column sorted ascending). Use binary search on value range with count of <= mid. Complexity O(n log(max-min)). Memory O(1). Provide steps.\n\nWe need to include steps: start, read matrix, define bounds, binary search loop, count function, decisions, return value, end.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision: etc.\n\nUse arrow: →.\n\nWe should show loops? Possibly use While loop pseudo.\n\nNeed to explain each line.\n\nLet's write.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 定義 n ← matrix row count // 取得矩陣維度\nLine 3: → Step 2: 定義 low ← matrix[0][0] // 最小值\nLine 4: → Step 3: 定義 high ← matrix[n-1][n-1] // 最大值\nLine 5: → While low < high: // 進行二分搜尋\nLine 6: → Step 4: 定義 mid ← (low + high) // 計算中間值\nLine 7: → Step 5: 定義 count ← CountLessEqual(mid) // 計算 <= mid 的元素數\nLine 8: → Decision: 如果 count < k? // 若小於 k，答案在右側\nLine 9: -> Yes → Step 6: low ← mid + 1 // 移動左邊界\nLine 10: -> No → Step 7: high ← mid // 移動右邊界\nLine 11: End While // 迴圈結束\nLine 12: → Step 8: return low // low 即為第 k 小元素\nLine 13: End // 程式結束\n\nNow define CountLessEqual function: we can incorporate as separate subroutine.\n\nAdd lines: Step 4 earlier? Maybe separate.\n\nLet's produce separate subroutine:\n\nLine 6 maybe: → Step 4: 定義 count ← CountLessEqual(mid) // 子程式計算 <= mid 的元素數\n\nWe need to provide definition:\n\nLine 6? Actually we need to add lines for subroutine:\n\nDefine subroutine CountLessEqual(x):\n    Start\n    → Step A: 初始化 count ← 0\n    → Step B: 初始化 row ← n-1, col ← 0\n    → While row >= 0 and col < n: // 遍歷矩陣\n    → Step C: 如果 matrix[row][col] <= x:\n        → Yes → count ← count + 1 + row // 數到所有上方元素\n        → Yes → col ← col + 1 // 移到右邊\n      No → row ← row - 1 // 移到上一行\n    → End While\n    → Step D: return count\n    End\n\nNeed to integrate into pseudo flow.\n\nSimplify: Provide subroutine after main.\n\nLet's produce final answer. Ensure each line has \"//\" explanation. Use Chinese.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 n ← matrix 行數 // 取得矩陣的大小  \n→ Step 2: 定義 low ← matrix[0][0] // 最小值  \n→ Step 3: 定義 high ← matrix[n-1][n-1] // 最大值  \n\n→ While low < high: // 進行二分搜尋  \n    → Step 4: 定義 mid ← (low + high) // 計算中間值  \n    → Step 5: 定義 count ← CountLessEqual(mid) // 計算小於等於 mid 的元素數量  \n    → Decision: 如果 count < k? // 如果數量不足 k，答案在右側  \n        Yes → Step 6: low ← mid + 1 // 移動左邊界  \n        No  → Step 7: high ← mid // 移動右邊界  \nEnd While // 二分搜尋結束  \n\n→ Step 8: return low // low 即為第 k 小元素  \nEnd // 程式結束  \n\n// ================== CountLessEqual 子程式 ==================  \n→ Subroutine CountLessEqual(x):  \n    Start // 子程式開始  \n    → Step 1: 初始化 count ← 0 // 累計計數  \n    → Step 2: 初始化 row ← n-1, col ← 0 // 從最左下角開始  \n    → While row >= 0 且 col < n: // 遍歷矩陣  \n        → Decision: 如果 matrix[row][col] <= x? // 判斷是否小於等於 x  \n            Yes → Step 3: count ← count + 1 + row // 這列至上方所有元素都 <= x  \n            Yes → Step 4: col ← col + 1 // 向右移動  \n            No  → Step 5: row ← row - 1 // 向上移動  \n    End While // 遍歷完成  \n    → Step 6: return count // 回傳計數  \n    End // 子程式結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        # intervals are stored as a sorted list of [left, right)\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    lines = [line.strip() for line in input_text.splitlines() if line.strip()]\n    results = []\n\n    # Assume only one RangeModule instance, name can be arbitrary\n    instance = None\n\n    # Regex to parse method calls: var.method(arg1, arg2);\n    call_re = re.compile(r'(\\w+)\\.(\\w+)\\(([^)]*)\\);')\n\n    for line in lines:\n        if line.startswith(\"RangeModule\"):\n            # Create new instance\n            instance = RangeModule()\n            results.append(None)\n            continue\n\n        m = call_re.match(line)\n        if not m:\n            continue  # skip invalid lines\n\n        var_name, method, args_str = m.groups()\n        # Parse integer arguments\n        args = [int(x.strip()) for x in args_str.split(',') if x.strip() != '']\n        if method == \"addRange\":\n            instance.addRange(*args)\n            results.append(None)\n        elif method == \"removeRange\":\n            instance.removeRange(*args)\n            results.append(None)\n        elif method == \"queryRange\":\n            res = instance.queryRange(*args)\n            results.append(res)\n\n    # Prepare output in the required format\n    out_items = []\n    for r in results:\n        if r is None:\n            out_items.append(\"null\")\n        else:\n            out_items.append(str(r).lower())\n    print(f\"[{', '.join(out_items)}]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing RangeModule class with operations. Use typical approach: maintain sorted list of non-overlapping intervals. For addRange, merge. For queryRange, check coverage. For removeRange, split intervals. We'll output steps. Each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nWe need to present algorithm, not code. We need to describe class and methods.\n\nLet's produce steps for initializing, adding, querying, removing. Also maybe helper functions like find intervals etc.\n\nLet's produce in order: Start, Step: Initialize intervals list, etc.\n\nLet's write virtual code in English but explanation in Chinese.\n\nUse Start/End.\n\nLet's produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 RangeModule 類別，內部使用有序、非重疊的區間列表 intervals // 初始化資料結構  \n→ Step 2: 定義 addRange(left, right) 方法 // 以 [left, right) 加入區間  \n    → Step 3: 找出所有與 [left, right) 重疊或相鄰的區間，記錄最小左端 minL 與最大右端 maxR  \n    → Step 4: 刪除所有重疊區間於 intervals 中  \n    → Step 5: 插入新的合併區間 [minL, maxR) 回 intervals，保持升序  \n→ Step 6: 定義 queryRange(left, right) 方法 // 檢查 [left, right) 是否完全被覆蓋  \n    → Step 7: 在 intervals 中搜尋最接近 left 的區間，若不存在或左端 > left，回傳 False  \n    → Step 8: 若找到區間且右端 >= right，回傳 True；否則回傳 False  \n→ Step 9: 定義 removeRange(left, right) 方法 // 移除 [left, right) 中的範圍  \n    → Step 10: 找出所有與 [left, right) 重疊的區間  \n    → Step 11: 對每個重疊區間，根據重疊情況產生 0~2 個剩餘區間  \n        → Yes → 若左端 < left，產生新區間 [left, originalRight) → 插入回 intervals  \n        → Yes → 若右端 > right，產生新區間 [right, originalRight) → 插入回 intervals  \n    → Step 12: 刪除所有原本重疊區間，完成移除操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp07b271pj.py\", line 102, in <module>\n    main()\n  File \"/tmp/tmp07b271pj.py\", line 62, in main\n    ops = json.loads(lines[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        return self.count == self.k\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    lines = data.splitlines()\n    ops = json.loads(lines[0])\n    params = json.loads(lines[1])\n\n    obj = None\n    results = []\n\n    for op, param in zip(ops, params):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(param[0])\n            results.append(None)\n        elif op == \"insertFront\":\n            results.append(obj.insertFront(param[0]))\n        elif op == \"insertLast\":\n            results.append(obj.insertLast(param[0]))\n        elif op == \"deleteFront\":\n            results.append(obj.deleteFront())\n        elif op == \"deleteLast\":\n            results.append(obj.deleteLast())\n        elif op == \"getFront\":\n            results.append(obj.getFront())\n        elif op == \"getRear\":\n            results.append(obj.getRear())\n        elif op == \"isEmpty\":\n            results.append(obj.isEmpty())\n        elif op == \"isFull\":\n            results.append(obj.isFull())\n        else:\n            results.append(None)\n\n    output = []\n    for val in results:\n        if val is None:\n            output.append(\"null\")\n        elif isinstance(val, bool):\n            output.append(\"true\" if val else \"false\")\n        else:\n            output.append(str(val))\n    print(f\"[{', '.join(output)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with comments. Provide step-by-step design of MyCircularDeque. We need to show initialization, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Use virtual code arrow format.\n\nWe should outline internal state: array of size k, front index, rear index, size. Need to handle circular wrap.\n\nWe'll produce virtual code with steps for each method, with decision points.\n\nWe need to output as lines with \"→\" etc. Start and End.\n\nLet's produce something like:\n\nStart\n→ Initialize: set capacity, array, front = 0, rear = 0, size = 0 // init\n→ Methods:\n    // InsertFront\n    → Decision: if size == capacity? // full?\n        Yes → Return false\n        No → front = (front - 1 + capacity) mod capacity // move front back\n            array[front] = value\n            size++\n            Return true\n    // InsertLast\n    → Decision: if size == capacity?\n        Yes → Return false\n        No → array[rear] = value\n            rear = (rear + 1) mod capacity\n            size++\n            Return true\n    // DeleteFront\n    → Decision: if size == 0?\n        Yes → Return false\n        No → front = (front + 1) mod capacity\n            size--\n            Return true\n    // DeleteLast\n    → Decision: if size == 0?\n        Yes → Return false\n        No → rear = (rear - 1 + capacity) mod capacity\n            size--\n            Return true\n    // getFront\n    → Decision: if size == 0? Return -1\n        Else return array[front]\n    // getRear\n    → Decision: if size == 0? Return -1\n        Else rearIdx = (rear - 1 + capacity) mod capacity\n             return array[rearIdx]\n    // isEmpty\n    → Decision: size == 0? Return true else false\n    // isFull\n    → Decision: size == capacity? Return true else false\nEnd\n\nWe need each line as \"虛擬碼步驟 [space] // 解釋\". Use Start, End. Use arrow. We'll write each step.\n\nAlso we need to keep consistent formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize MyCircularDeque with capacity k // 建構子初始化\n    front = 0 // 指向前端索引\n    rear  = 0 // 指向後端索引\n    size  = 0 // 當前元素數量\n    array = new int[k] // 儲存元素的固定大小陣列\n\n→ Method: insertFront(value) // 在前端插入元素\n    Decision: 如果 size == capacity? // 檢查是否已滿\n        Yes → Return false // 不能插入\n        No  → front = (front - 1 + capacity) % capacity // 往前移動前端索引\n              array[front] = value // 放入新值\n              size++ // 數量加一\n              Return true // 插入成功\n\n→ Method: insertLast(value) // 在後端插入元素\n    Decision: 如果 size == capacity? // 檢查是否已滿\n        Yes → Return false // 不能插入\n        No  → array[rear] = value // 放入新值\n              rear = (rear + 1) % capacity // 往後移動後端索引\n              size++ // 數量加一\n              Return true // 插入成功\n\n→ Method: deleteFront() // 刪除前端元素\n    Decision: 如果 size == 0? // 檢查是否為空\n        Yes → Return false // 無法刪除\n        No  → front = (front + 1) % capacity // 往後移動前端索引\n              size-- // 數量減一\n              Return true // 刪除成功\n\n→ Method: deleteLast() // 刪除後端元素\n    Decision: 如果 size == 0? // 檢查是否為空\n        Yes → Return false // 無法刪除\n        No  → rear = (rear - 1 + capacity) % capacity // 往前移動後端索引\n              size-- // 數量減一\n              Return true // 刪除成功\n\n→ Method: getFront() // 取得前端元素\n    Decision: 如果 size == 0? // 檢查是否為空\n        Yes → Return -1 // 沒有元素\n        No  → Return array[front] // 回傳前端值\n\n→ Method: getRear() // 取得後端元素\n    Decision: 如果 size == 0? // 檢查是否為空\n        Yes → Return -1 // 沒有元素\n        No  → rearIdx = (rear - 1 + capacity) % capacity // 真正的後端索引\n              Return array[rearIdx] // 回傳後端值\n\n→ Method: isEmpty() // 判斷是否為空\n    Decision: 如果 size == 0? // 直接以 size 判斷\n        Yes → Return true\n        No  → Return false\n\n→ Method: isFull() // 判斷是否已滿\n    Decision: 如果 size == capacity? // 直接以 size 判斷\n        Yes → Return true\n        No  → Return false\nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef find_duplicate(paths):\n    \"\"\"Return list of groups of duplicate file paths.\"\"\"\n    content_map = defaultdict(list)\n    for path in paths:\n        parts = path.split()\n        root = parts[0]\n        for file_info in parts[1:]:\n            name, content = file_info.split('(')\n            content = content.rstrip(')')\n            content_map[content].append(f\"{root}/{name}\")\n    return [files for files in content_map.values() if len(files) > 1]\n\ndef parse_input():\n    \"\"\"Parse the input from stdin into a Python list.\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n    # Try to find the '=' sign that separates variable name from value\n    idx = data.find('=')\n    if idx != -1:\n        expr = data[idx + 1:].strip()\n    else:\n        expr = data\n    # Use ast.literal_eval for safety\n    try:\n        return ast.literal_eval(expr)\n    except Exception:\n        # Fallback to eval if literal_eval fails (unlikely for given format)\n        return eval(expr, {})\n\nif __name__ == \"__main__\":\n    paths = parse_input()\n    result = find_duplicate(paths)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line-by-line with explanations. The input: list of strings. Output: list of lists of duplicate file paths. Algorithm: parse each directory info string, split by space, first part is path, rest are file info. For each file info, extract file name and content within parentheses. Build a map from content to list of file paths. After processing all, collect values with length >= 2. Output list of lists. Represent using pseudocode with arrows, Start, End, Decision.\n\nWe need to output steps only, each line: \"虛擬碼步驟 // 解釋\". Use arrows. We'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty map contentToPaths // 建立內容對應路徑的映射\n→ Step 2: For each dirInfo in paths // 逐個處理每個目錄資訊\n    → Step 2a: Split dirInfo by space into parts // 拆分路徑和檔案資訊\n    → Step 2b: dirPath = parts[0] // 取得目錄路徑\n    → Step 2c: For each fileInfo in parts[1..] // 逐個處理檔案資訊\n        → Step 2c1: Extract fileName = substring before '(' // 取得檔名\n        → Step 2c2: Extract fileContent = substring between '(' and ')' // 取得內容\n        → Step 2c3: fullPath = dirPath + '/' + fileName // 組合完整路徑\n        → Step 2c4: If fileContent not in contentToPaths, add empty list // 初始\n        → Step 2c5: Append fullPath to contentToPaths[fileContent] // 加入路徑\n→ Step 3: Initialize result = empty list // 結果集\n→ Step 4: For each entry in contentToPaths // 檢查每個內容\n    → Decision: If entry.paths length >= 2? // 是否有重複\n        Yes → Step 4a: Append entry.paths to result // 加入結果\n        No  → Step 4b: Do nothing // 不足兩個不加入\n→ End // 結束程式\n\nAdd comments. Ensure no real code. Use Chinese. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空映射 contentToPaths // 建立內容對應完整路徑的映射表  \n→ Step 2: 對於輸入列表 paths 中的每一個 dirInfo // 逐行處理目錄資訊  \n    → Step 2a: 用空格分割 dirInfo 為 parts // 第一個為目錄路徑，後面為檔案資訊  \n    → Step 2b: dirPath ← parts[0] // 取得目錄完整路徑  \n    → Step 2c: 對於 parts[1..] 中的每一個 fileInfo // 逐個處理檔案  \n        → Step 2c1: 取得 fileName 為 '(' 前的字串 // 拿到檔名  \n        → Step 2c2: 取得 fileContent 為 '(' 與 ')' 之間的字串 // 拿到檔案內容  \n        → Step 2c3: fullPath ← dirPath + '/' + fileName // 組合成完整檔案路徑  \n        → Decision: 如果 fileContent 尚未出現在 contentToPaths? // 是否已有此內容  \n            Yes → Step 2c4a: 建立 contentToPaths[fileContent] 為空列表 // 初始化  \n            No  → Step 2c4b: 直接使用現有列表  \n        → Step 2c5: 將 fullPath 加入 contentToPaths[fileContent] // 記錄此路徑  \n→ Step 3: 初始化 result 為空列表 // 用於存放重複檔案的群組  \n→ Step 4: 遍歷 contentToPaths 中的每一個 entry // 每個內容對應一個路徑列表  \n    → Decision: 如果 entry.paths 的長度 ≥ 2? // 是否至少兩個檔案相同  \n        Yes → Step 4a: 將 entry.paths 加入 result // 加入重複群組  \n        No  → Step 4b: 不做任何事 // 不足兩個不算重複  \n→ End // 程式執行結束，result 為最終輸出  \n\n---  \n上述虛擬碼逐行描述了解析輸入、建立內容到路徑的映射、篩選重複檔案群組並輸出結果的完整流程。"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[4,4]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[4, 4]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,6,1]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 6, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport re\n\n# API: 生成 1~7 的均勻隨機整數\ndef rand7() -> int:\n    return random.randint(1, 7)\n\n# 依據 rand7() 生成 1~10 的均勻隨機整數\ndef rand10() -> int:\n    while True:\n        # 兩次 rand7() 組合得到 1~49 的均勻分布\n        num = (rand7() - 1) * 7 + rand7()  # 1~49\n        if num <= 40:  # 只保留 1~40，其他丟棄\n            return 1 + (num - 1) % 10  # 映射到 1~10\n\ndef main() -> None:\n    # 讀取整個輸入，找出第一個整數 n\n    data = sys.stdin.read()\n    m = re.search(r'\\d+', data)\n    n = int(m.group()) if m else 0\n\n    # 呼叫 rand10() n 次，收集結果\n    results = [rand10() for _ in range(n)]\n\n    # 輸出結果列表\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for generating uniform 1-10 from 1-7 random generator, using rejection sampling.\n\nWe must not produce actual code, only virtual steps.\n\nWe need step-by-step: generate two rand7() to produce base-7 representation? Approach: 1-49 mapping. Generate two rand7 to produce 1-49 uniform. If 1-40 accept, map to 1-10 by (value-1)%10+1. If 41-49 reject, repeat.\n\nAlternatively use 7x7 grid, use rejection. Use steps: Start, generate a = rand7(), b = rand7(), num = (a-1)*7 + b; Decision: if num <= 40? Yes: return (num-1)%10+1; No: repeat.\n\nWe'll need loop until accepted.\n\nVirtual code with arrows.\n\nWe must use Step lines.\n\nLet's produce:\n\nStart // begin\n→ Step 1: repeat loop // repeat until success\n    → Step 1.1: num ← (rand7() - 1) * 7 + rand7() // produce 1-49\n    → Decision: num <= 40? // check if within acceptable range\n        Yes → Step 1.2: result ← ((num - 1) mod 10) + 1 // map to 1-10\n              → Step 1.3: return result // output\n              → Step 1.4: End // exit loop\n        No → Step 1.5: go to Step 1.1 // retry\n\nEnd // done\n\nBut we need use arrow for loop? We can express repeat loop with Decision: maybe \"Decision: 是否接受?\" or \"Loop:\". Use \"Decision: num <= 40?\" with Yes path returning, No path loop again.\n\nLet's produce as per format.\n\nAlso we might include explanation after each line.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 開始重複迴圈 // 需要不斷嘗試直到得到合法值  \n    → Step 1.1: num ← (rand7() - 1) * 7 + rand7() // 兩次 rand7() 組合得到 1~49 的均勻分布  \n    → Decision: num ≤ 40? // 檢查是否落在可接受的範圍內  \n        Yes → Step 1.2: result ← ((num - 1) mod 10) + 1 // 將 1~40 映射到 1~10  \n        Yes → Step 1.3: return result // 返回最終隨機數  \n        Yes → End // 程式結束  \n        No → Step 1.4: goto Step 1.1 // 若 num>40，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '14'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '14'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '11'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '11'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport threading\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Build a dict from the input string\n    # Example input: 'price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]'\n    try:\n        data = data.replace('=', ':')\n        # Wrap with braces to make a dict literal\n        data_dict = ast.literal_eval('{' + data + '}')\n    except Exception:\n        # If parsing fails, exit gracefully\n        return\n\n    price = data_dict.get('price', [])\n    special = data_dict.get('special', [])\n    needs = data_dict.get('needs', [])\n\n    n = len(price)\n    memo = {}\n\n    def dfs(curr_needs):\n        key = tuple(curr_needs)\n        if key in memo:\n            return memo[key]\n        # Cost without any special offers\n        res = sum(curr_needs[i] * price[i] for i in range(n))\n        for offer in special:\n            temp = []\n            for i in range(n):\n                if offer[i] > curr_needs[i]:\n                    break\n                temp.append(curr_needs[i] - offer[i])\n            else:\n                res = min(res, offer[-1] + dfs(temp))\n        memo[key] = res\n        return res\n\n    result = dfs(needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    threading.Thread(target=solve).start()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm to solve LeetCode Shopping Offers problem (shopping deals). Provide step-by-step pseudo-code lines with explanation.\n\nWe need to produce algorithm: maybe DFS with memoization (state compression) or DP. Use recursion with state key as tuple of needs. At each step, try each special offer if it does not exceed needs. Compute cost: offer price + dfs(remaining). Also compare with cost without offers: sum(need[i]*price[i]). Use memo.\n\nWe'll generate pseudo-code lines accordingly, following format. Use Start, End, Decision, arrows, etc.\n\nMake sure each line has \"虛擬碼步驟\" and \"// 解釋\". We'll produce sequential lines.\n\nLet's craft.\n\nStart // 開始執行\n\n→ Initialize memo as map // 用於記錄已計算狀態\n\n→ Define function dfs(state) // state: current needs tuple\n\n→ Decision: 如果 state all zeros? // 若沒有需要購買任何物品\n\n→ Yes → Return 0 // 無需支付\n\n→ No → // 否則\n\n→ Set minCost = sum(state[i]*price[i]) // 直接按單價購買的成本\n\n→ For each offer in special // 遍歷所有特價方案\n\n→ Decision: 是否可用此 offer? // 檢查每個項目不超過剩餘需求\n\n→ Yes → Compute newState = state - offerQuantities // 更新需求\n\n→ Recursively compute cost = offerPrice + dfs(newState) // 使用此特價\n\n→ Decision: cost < minCost? // 若更便宜\n\n→ Yes → minCost = cost // 更新最低成本\n\n→ No → // 仍保持\n\n→ End for // 結束特價遍歷\n\n→ memo[state] = minCost // 記錄結果\n\n→ Return minCost // 返回此狀態最小成本\n\n→ End // 函數結束\n\n→ Return dfs(tuple(needs)) // 開始遞迴\n\nEnd // 程式結束\n\nNeed to follow format: each line: `虛擬碼步驟 // 解釋`. Use arrows etc. Let's produce each line accordingly.\n\nAlso need to include indentation? Not required, but we can use arrows for decisions. Provide each line separately. Use \"Start\" \"End\". Use \"→\" for flow lines. For decision blocks, use \"Decision:\" lines and then indented lines with Yes→ etc. But we can keep simple.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize memo as Map() // 用於儲存已計算的狀態  \n→ Define function dfs(state) // state 代表目前剩餘購買需求的向量  \n→ Decision: state 是否全為 0? // 檢查是否沒有需要購買的物品  \n    Yes → Return 0 // 所有需求已滿，無需額外支付  \n    No  → // 需求尚未滿足，進行計算  \n→ Set minCost = sum(state[i] * price[i]) // 直接按單價購買的成本  \n→ For each offer in special // 遍歷每個特價方案  \n→ Decision: 是否可以使用此 offer? // 每項商品數量不超過剩餘需求  \n    Yes →  \n        Compute newState = state - offerQuantities // 減去本次購買的數量  \n        Compute cost = offerPrice + dfs(newState) // 使用此特價後遞迴計算剩餘需求成本  \n        Decision: cost < minCost? // 是否比目前最小成本更低  \n            Yes → minCost = cost // 更新最小成本  \n            No → // 保持現有最小成本  \n    No → // 本次特價不可用，跳過  \n→ End for // 完成所有特價方案的檢查  \n→ memo[state] = minCost // 記錄此狀態的最小成本  \n→ Return minCost // 返回此狀態的最小成本  \n→ End // dfs 函式結束  \n→ Return dfs(tuple(needs)) // 從原始需求開始遞迴求解  \nEnd // 程式執行結束"
    },
    {
      "title": "My Calendar II",
      "source_file": "Leetcode/leetcode731.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"], [[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]",
          "expected_output": "[null, true, true, true, false, true, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,true,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, true, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendarTwo:\n    def __init__(self):\n        self.booked = []   # 所有已預訂的單一事件區間\n        self.overlaps = [] # 已形成兩重重疊的區間\n\n    def book(self, start: int, end: int) -> bool:\n        # 檢查是否會造成三重預訂\n        for s, e in self.overlaps:\n            if max(s, start) < min(e, end):\n                return False\n        # 將與單重事件重疊的區間加入 overlaps\n        for s, e in self.booked:\n            if max(s, start) < min(e, end):\n                self.overlaps.append((max(s, start), min(e, end)))\n        # 加入新事件\n        self.booked.append((start, end))\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入為兩個列表\n    # 將第一個列表與第二個列表分開\n    first_part, second_part = data.split('],', 1)\n    first_part = first_part.strip() + ']'\n    second_part = '[' + second_part.strip() + ']'\n    ops = json.loads(first_part)\n    args = json.loads(second_part)\n\n    output = []\n    calendar = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MyCalendarTwo\":\n            calendar = MyCalendarTwo()\n            output.append(None)\n        elif op == \"book\":\n            result = calendar.book(arg[0], arg[1])\n            output.append(result)\n\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for implementing MyCalendarTwo with booking logic. Provide line-by-line steps with explanation. We can design algorithm: maintain list of intervals for single bookings, and list for double bookings. On book, for each existing single interval, check overlap with new interval; if overlap count > 2 return false. We also maintain double intervals. Actually algorithm: keep list of intervals that overlap with others to track double bookings. When booking, first check that new interval does not overlap any interval in double bookings more than once (i.e., would create triple). For each overlap with double, if overlap, return false. Then for each overlap with single, add overlap to double list. Finally add new interval to single list. Return true.\n\nImplement virtual code accordingly.\n\nNeed to produce \"Start\" etc. Provide lines like \"Start // 程式開始執行\". Provide pseudo-code lines.\n\nWe'll structure:\n\nStart\n→ Step 1: 初始化 MyCalendarTwo 類別，創建兩個空列表 singleEvents, doubleEvents\n→ Decision: 是否已存在單重事件列表？ // etc. but not necessary.\n\nBetter: We'll define methods.\n\nLet's produce a clear step-by-step algorithm:\n\nStart\n→ Step 1: 定義 MyCalendarTwo 類別\n    → Step 1a: 定義構造函數 MyCalendarTwo() // 建立空事件列表\n        → Step 1a1: singleEvents ← 空列表 // 儲存所有已預訂的單一事件\n        → Step 1a2: doubleEvents ← 空列表 // 儲存所有重疊兩個事件的區間\n    → Step 1b: 定義 book(start, end) 方法 // 嘗試新增事件\n        → Step 1b1: // 檢查新事件是否會形成三重預訂\n            → Decision: 是否存在 doubleEvents 與 [start, end) 的重疊？\n                Yes → Return false // 三重預訂將發生\n                No  → Continue\n        → Step 1b2: // 將新事件與單重事件的重疊區間加入 doubleEvents\n            → For each (s, e) in singleEvents\n                → Decision: 是否與 [start, end) 重疊？\n                    Yes → overlapStart ← max(s, start)\n                          overlapEnd ← min(e, end)\n                          doubleEvents ← doubleEvents ∪ [(overlapStart, overlapEnd)]\n        → Step 1b3: // 將新事件加入 singleEvents\n            → singleEvents ← singleEvents ∪ [(start, end)]\n        → Return true // 成功加入\n\nEnd\n\nAlso need to explain each line. Provide arrow. Use arrow for substeps.\n\nLet's produce lines accordingly. Each line includes explanation.\n\nAlso ensure using arrow \"→\" and decision.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCalendarTwo 類別 // 建立一個類別來管理日曆  \n  → Step 1a: 定義 MyCalendarTwo() 構造函數 // 初始化兩個空列表  \n    → Step 1a1: singleEvents ← 空列表 // 儲存所有已預訂的單一事件區間  \n    → Step 1a2: doubleEvents ← 空列表 // 儲存所有已形成兩重重疊的區間  \n  → Step 1b: 定義 book(start, end) 方法 // 嘗試新增一個事件  \n    → Step 1b1: // 先檢查新事件是否會造成三重預訂  \n      Decision: 是否存在 doubleEvents 與 [start, end) 的重疊？ // 任何重疊都會導致三重預訂  \n       Yes → Return false // 三重預訂發生，拒絕加入  \n       No  → Continue // 無三重預訂，繼續檢查  \n    → Step 1b2: // 把新事件與已存在單重事件的重疊區間加入 doubleEvents  \n      For each (s, e) in singleEvents  \n       Decision: 是否與 [start, end) 重疊？  \n        Yes → overlapStart ← max(s, start)  \n          overlapEnd ← min(e, end)  \n          doubleEvents ← doubleEvents ∪ [(overlapStart, overlapEnd)] // 加入新的雙重區間  \n        No  → // 不重疊，無需處理  \n    → Step 1b3: // 最後把新事件加入單重事件列表  \n      singleEvents ← singleEvents ∪ [(start, end)]  \n    → Return true // 事件成功加入，未造成三重預訂  \nEnd // 程式執行結束"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppmxmrfvz.py\", line 73, in <module>\n    s1, n1, s2, n2 = values\n    ^^^^^^^^^^^^^^\nValueError: too many values to unpack (expected 4)"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxwjehi6p.py\", line 73, in <module>\n    s1, n1, s2, n2 = values\n    ^^^^^^^^^^^^^^\nValueError: too many values to unpack (expected 4)"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        # If s1 is repeated 0 times, we can't form any s2\n        if n1 == 0:\n            return 0\n\n        s1_count = 0   # number of s1 processed\n        s2_count = 0   # number of complete s2 obtained\n        index = 0      # current position in s2\n        recall = {}    # map index -> (s1_count, s2_count)\n\n        # Process s1 repeatedly until we either finish all n1 or find a cycle\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n            if index in recall:\n                # Found a cycle\n                s1_prev, s2_prev = recall[index]\n                pre_loop_s1, pre_loop_s2 = s1_prev, s2_prev\n                loop_s1 = s1_count - s1_prev\n                loop_s2 = s2_count - s2_prev\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:\n            # No cycle found, finished all s1 without repeating an index\n            return s2_count // n2\n\n        # Compute result using the detected cycle\n        remaining_s1 = n1 - pre_loop_s1\n        num_loops = remaining_s1 // loop_s1\n        total_s2 = pre_loop_s2 + num_loops * loop_s2\n\n        # Handle the leftover part after full cycles\n        leftover_s1 = remaining_s1 % loop_s1\n        index_rest = index\n        for _ in range(leftover_s1):\n            for ch in s1:\n                if ch == s2[index_rest]:\n                    index_rest += 1\n                    if index_rest == len(s2):\n                        index_rest = 0\n                        total_s2 += 1\n\n        return total_s2 // n2\n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read()\n\n    # Extract string literals and integer values in order\n    # The expected format is like: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n    pattern = r'\"([^\"]+)\"|(\\d+)'\n    matches = re.findall(pattern, raw_input)\n\n    values = []\n    for str_val, int_val in matches:\n        if str_val:\n            values.append(str_val)\n        else:\n            values.append(int(int_val))\n\n    # Unpack values\n    s1, n1, s2, n2 = values\n\n    # Compute and output result\n    sol = Solution()\n    result = sol.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for solving the problem. Should be a step-by-step algorithm explanation, not actual code. Provide steps and explanations. The problem is known Leetcode 466 Max Consecutive Subsequence? Actually it's \"Max Number of Times\" from Leetcode. We need algorithm: use mapping of positions in s2 to next occurrence in s1 etc. The typical solution: simulate traversing s1 to find how many s2 sequences can be formed, then compute how many s2 repeated m times can be formed in s1 repeated n1 times. Use dictionary mapping of index in s2 to (count of s2 encountered, index in s1). Then compute cycles. Provide steps.\n\nWe need to output in required format: \"Start // ...\", \"→ Step X: ... // ...\", \"→ Decision: ...\", etc. Need to be line by line.\n\nLet's design steps:\n\nStart\n→ Input s1, n1, s2, n2\n→ Initialize variables: index_s2=0, count_s1=0, count_s2=0\n→ Initialize map = {} // store mapping from index_s2 to (count_s1, count_s2)\n→ While count_s1 < n1\n    → For each character in s1\n        → If character == s2[index_s2]\n            → index_s2 +=1\n            → If index_s2 == len(s2)\n                → count_s2 +=1\n                → index_s2=0\n    → count_s1 +=1\n    → If index_s2 in map\n        → Found cycle: pre_count_s1, pre_count_s2 = map[index_s2]\n        → cycle_s1 = count_s1 - pre_count_s1\n        → cycle_s2 = count_s2 - pre_count_s2\n        → Break loop\n    → Else map[index_s2] = (count_s1, count_s2)\n→ After loop\n    → If no cycle detected (count_s1==n1)\n        → result = count_s2 // n2\n        → Return result\n    → Else\n        → pre_s1, pre_s2 = map[index_s2]\n        → remaining_s1 = n1 - pre_s1\n        → times_cycle = remaining_s1 // cycle_s1\n        → total_s2 = pre_s2 + times_cycle * cycle_s2\n        → remaining_s1_after = remaining_s1 % cycle_s1\n        → For i in range(remaining_s1_after)\n            → For each char in s1\n                → if char == s2[index_s2]\n                    → index_s2 +=1\n                    → if index_s2 == len(s2)\n                        → total_s2 +=1\n                        → index_s2=0\n        → result = total_s2 // n2\n        → Return result\n\nExplain each step.\n\nLet's produce virtual code lines with explanations.\n\nBe careful with formatting: Each line is \"虛擬碼步驟 // 解釋\". Use arrows \"→\" to denote steps. Use Decision lines. Use End at end.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入變數 s1, n1, s2, n2 // 取得兩個字串及其重複次數\n→ Step 2: 初始化 index_s2 ← 0, count_s1 ← 0, count_s2 ← 0 // 追蹤 s2 的位置、已處理的 s1 次數與已完成的 s2 次數\n→ Step 3: 建立字典 map ← {} // 用於紀錄每次到達某個 s2 位置時的 s1 次數與 s2 次數\n→ Decision: 若 count_s1 < n1? // 是否還有未處理的 s1 重複\n    Yes → Step 4: 循環處理 s1 中每個字符 c\n        → Decision: c == s2[index_s2]? // 字符是否匹配 s2 的當前位置\n            Yes → Step 5: index_s2 ← index_s2 + 1 // 匹配成功，往後移動\n            No  → 無操作 // 不匹配，直接跳過\n        → Decision: index_s2 == len(s2)? // 是否完成一個 s2\n            Yes → Step 6: count_s2 ← count_s2 + 1; index_s2 ← 0 // 完成一個 s2，重置 index_s2\n            No  → 無操作\n    → Step 7: count_s1 ← count_s1 + 1 // 完成一個 s1 的處理\n    → Decision: index_s2 在 map 中? // 是否已經遇到相同的 s2 位置，檢測循環\n        Yes → Step 8: pre_count_s1, pre_count_s2 ← map[index_s2] // 取得之前的 s1、s2 次數\n              Step 9: cycle_s1 ← count_s1 - pre_count_s1 // 循環所消耗的 s1 次數\n              Step 10: cycle_s2 ← count_s2 - pre_count_s2 // 循環所得到的 s2 次數\n              Step 11: 退出 while 迴圈 // 找到循環，結束初步模擬\n        No  → Step 12: map[index_s2] ← (count_s1, count_s2) // 存入目前位置的 s1、s2 次數\n→ Step 13: Decision: 已無循環? // 判斷是否沒有找到循環，直接使用已完成的結果\n    Yes → Step 14: result ← count_s2 // n2 // 最大 m 為已完成的 s2 次數除以 n2\n              → End // 回傳結果，程式結束\n    No  → Step 15: pre_s1, pre_s2 ← map[index_s2] // 從字典取得前段已完成的 s1、s2 次數\n              Step 16: remaining_s1 ← n1 - pre_s1 // 還剩下多少 s1 可再處理\n              Step 17: times_cycle ← remaining_s1 // cycle_s1 // 能重複多少完整循環\n              Step 18: total_s2 ← pre_s2 + times_cycle * cycle_s2 // 先加上完整循環得到的 s2 次數\n              Step 19: remaining_s1_after ← remaining_s1 % cycle_s1 // 循環後剩下的 s1 次數\n              → 循環處理剩餘 s1，重複 Step 4-10 直到 remaining_s1_after 次\n                  → Step 20: For i in 0..remaining_s1_after-1\n                        → For each character c in s1\n                            → Decision: c == s2[index_s2]? \n                                Yes → index_s2 ← index_s2 + 1\n                                No  → 無操作\n                            → Decision: index_s2 == len(s2)? \n                                Yes → total_s2 ← total_s2 + 1; index_s2 ← 0\n                                No  → 無操作\n              Step 21: result ← total_s2 // n2 // 最終能得到的最大 m\n              → End // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def wiggleSort(self, nums):\n        # 一次遍歷，根據索引奇偶性交換\n        for i in range(1, len(nums)):\n            if i % 2 == 1:\n                # 奇數位應該大於前一位\n                if nums[i] < nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            else:\n                # 偶數位應該小於前一位\n                if nums[i] > nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n        return nums\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 允許輸入形式如 \"nums = [1,5,1,1,6,4]\"\n    # 移除可能的變數名與等號\n    if raw.lower().startswith(\"nums\"):\n        raw = raw.split(\"=\", 1)[1].strip()\n\n    # 將字串轉成 Python list\n    try:\n        nums = eval(raw, {\"__builtins__\": None}, {})\n    except Exception as e:\n        print(\"Error parsing input:\", e)\n        sys.exit(1)\n\n    # 執行 wiggle sort\n    result = Solution().wiggleSort(nums)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for rearranging array into wiggle order: nums[0] < nums[1] > nums[2] < nums[3]... Usually algorithm: iterate i from 1 to n-1, if i odd and nums[i] < nums[i-1] swap; if i even and nums[i] > nums[i-1] swap. Or simpler: for each i, if (i%2==1 && nums[i] < nums[i-1]) swap; else if (i%2==0 && nums[i] > nums[i-1]) swap.\n\nWe need to output step-by-step virtual code with arrow and decision.\n\nWe'll produce steps: Start, Step 1: Input array, Step 2: Iterate i from 1 to len-1, Decision: if i odd? -> sub-decision: if nums[i] < nums[i-1] swap; else proceed; No -> Decision: if nums[i] > nums[i-1] swap.\n\nEnd.\n\nAlso include explanation comments. Ensure each line with arrow and comment. Use spaces appropriately.\n\nLet's craft.\n\nProbably use Start // Start program.\n\n→ Step 1: Read nums // Input array.\n\n→ Step 2: Set n = length(nums) // Determine array length.\n\n→ Step 3: For i = 1 to n-1 // Iterate over indices starting from 1.\n\n    → Decision: i is odd? // Check parity.\n\n        Yes → Decision: nums[i] < nums[i-1]? // If current less than previous.\n\n            Yes → Step 4: Swap nums[i] and nums[i-1] // Ensure ascending at odd index.\n\n            No  → // Nothing to do.\n\n        No  → Decision: nums[i] > nums[i-1]? // For even index, need descending.\n\n            Yes → Step 5: Swap nums[i] and nums[i-1] // Ensure descending at even index.\n\n            No  → // Nothing to do.\n\n→ End // Done.\n\nAdd comments. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得使用者提供的整數陣列\n→ Step 2: 設定 n ← length(nums) // 取得陣列長度\n→ Step 3: 對 i 從 1 到 n-1 逐個處理 // 逐位檢查並調整\n    → Decision: i 為奇數? // 判斷索引奇偶\n        Yes → Decision: nums[i] < nums[i-1]? // 奇數位須小於前一位\n            Yes → Step 4: 交換 nums[i] 與 nums[i-1] // 使 nums[i-1] < nums[i]\n            No  → // 已符合條件，繼續\n        No  → Decision: nums[i] > nums[i-1]? // 偶數位須大於前一位\n            Yes → Step 5: 交換 nums[i] 與 nums[i-1] // 使 nums[i-1] > nums[i]\n            No  → // 已符合條件，繼續\n→ End // 程式執行結束，陣列已按 wiggle 順序排列"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy8qik75n.py\", line 47, in <module>\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpy8qik75n.py\", line 31, in parse_input\n    node = ast.parse(data, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx3b9mmgg.py\", line 47, in <module>\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx3b9mmgg.py\", line 31, in parse_input\n    node = ast.parse(data, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9_lzulj4.py\", line 47, in <module>\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9_lzulj4.py\", line 31, in parse_input\n    node = ast.parse(data, mode='exec')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef parse_input(data: str):\n    node = ast.parse(data, mode='exec')\n    equations = values = queries = None\n    for stmt in node.body:\n        if isinstance(stmt, ast.Assign):\n            target = stmt.targets[0]\n            if isinstance(target, ast.Name):\n                if target.id == 'equations':\n                    equations = ast.literal_eval(stmt.value)\n                elif target.id == 'values':\n                    values = ast.literal_eval(stmt.value)\n                elif target.id == 'queries':\n                    queries = ast.literal_eval(stmt.value)\n    return equations, values, queries\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    equations, values, queries = parse_input(raw_input)\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n    formatted = \"[\" + \",\".join(f\"{x:.5f}\" for x in results) + \"]\"\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps that explain solving equations graph and queries. Each line: virtual code step and comment. Use arrows and decisions. Should not output actual code. Provide line-by-line pseudo steps. For each step, comment.\n\nWe need to explain building graph, DFS or union find. Provide algorithm. Use Start, End. Use Decision blocks.\n\nLet's craft.\n\nWe should show:\n\nStart\n→ Step 1: Build adjacency map from equations and values // create graph edges with weights\n→ Step 2: For each query [C,D] // process queries\n   → Decision: If C or D not in graph? // check undefined\n      Yes → Append -1.0 to results // unknown\n      No  → Step 3: Initialize visited set // for DFS\n           → Step 4: Define DFS(current, target, accumulated) // recursion\n              → Decision: If current==target? // reached\n                  Yes → Return accumulated // found ratio\n                  No  → For each neighbor of current\n                          → Decision: If neighbor not visited? // avoid cycles\n                               Yes → Mark visited\n                                    → Step 5: Recurse DFS(neighbor, target, accumulated * weight)\n                                         → Decision: If result != -1? // found\n                                            Yes → Return result\n                          No → Continue\n              → End DFS // return -1 if not found\n           → Step 6: result = DFS(C, D, 1.0) // start\n           → Step 7: Append result to results // store\nEnd\n\nBut we need to incorporate arrows and decisions properly. Use \"Yes →\" \"No →\" formatting.\n\nMake sure each line ends with // comment. Use arrows \"→\" at beginning of each step line, but also maybe \"Start\". We'll follow format.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立鄰接表 graph ← {} // 建立圖表以存儲變量間的比例關係  \n→ Decision: 是否有 equations? // 檢查輸入是否存在  \n    Yes →  \n        → For 每一個 (A, B, val) in equations  \n            → graph[A].append((B, val)) // A / B = val  \n            → graph[B].append((A, 1/val)) // B / A = 1/val  \n    No → // 若無方程式則 graph 仍為空  \n\n→ Step 2: results ← [] // 用於儲存每個查詢的答案  \n→ For 每一個 (C, D) in queries  \n    → Decision: C 或 D 不在 graph? // 變量未定義  \n        Yes → results.append(-1.0) // 回傳 -1.0  \n        No  →  \n            → Step 3: visited ← set() // 追蹤已訪問節點  \n            → Step 4: 定義函式 DFS(cur, target, acc)  \n                → Decision: cur == target? // 是否達到目標變量  \n                    Yes → return acc // 找到比例值  \n                    No  →  \n                        → For 每一個 (next, w) in graph[cur]  \n                            → Decision: next 未在 visited?  \n                                Yes → visited.add(next)  \n                                    → result ← DFS(next, target, acc * w) // 進一步搜尋  \n                                    → Decision: result != -1? // 是否成功找到  \n                                        Yes → return result  \n                                No → continue // 已訪問，跳過  \n                        → return -1.0 // 未能找到路徑  \n            → Step 5: ans ← DFS(C, D, 1.0) // 從 C 開始，初始比例 1.0  \n            → results.append(ans) // 將查詢答案加入結果  \n\nEnd // 程式執行結束，結果已存於 results 中"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "source_file": "Leetcode/leetcode4.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp59e6ct5j.py\", line 85, in <module>\n    main()\n  File \"/tmp/tmp59e6ct5j.py\", line 80, in main\n    median = solution.findMedianSortedArrays(nums1, nums2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp59e6ct5j.py\", line 19, in findMedianSortedArrays\n    return (nums2[n // 2 - 1] + nums2[n // 2]) / 2.0\n            ~~~~~^^^^^^^^^^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        Find median of two sorted arrays in O(log(min(m, n))) time.\n        \"\"\"\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n\n        # If the smaller array is empty, the median is just the median of the other array\n        if m == 0:\n            if n % 2 == 1:\n                return float(nums2[n // 2])\n            return (nums2[n // 2 - 1] + nums2[n // 2]) / 2.0\n\n        imin, imax, half_len = 0, m, (m + n + 1) // 2\n\n        while imin <= imax:\n            i = (imin + imax) // 2\n            j = half_len - i\n\n            # i is too small, must increase it\n            if i < m and j > 0 and nums2[j - 1] > nums1[i]:\n                imin = i + 1\n            # i is too big, must decrease it\n            elif i > 0 and j < n and nums1[i - 1] > nums2[j]:\n                imax = i - 1\n            else:\n                # i is perfect\n                if i == 0:\n                    max_of_left = nums2[j - 1]\n                elif j == 0:\n                    max_of_left = nums1[i - 1]\n                else:\n                    max_of_left = max(nums1[i - 1], nums2[j - 1])\n\n                # Odd total length\n                if (m + n) % 2 == 1:\n                    return float(max_of_left)\n\n                # Even total length: need the min of the right part\n                if i == m:\n                    min_of_right = nums2[j]\n                elif j == n:\n                    min_of_right = nums1[i]\n                else:\n                    min_of_right = min(nums1[i], nums2[j])\n\n                return (max_of_left + min_of_right) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse input like: nums1 = [1,3], nums2 = [2]\n    nums1 = []\n    nums2 = []\n    for part in data.split(','):\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        try:\n            arr = ast.literal_eval(val)\n        except Exception:\n            arr = []\n        if key == 'nums1':\n            nums1 = arr\n        elif key == 'nums2':\n            nums2 = arr\n\n    solution = Solution()\n    median = solution.findMedianSortedArrays(nums1, nums2)\n    # Print with 5 decimal places as shown in examples\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with explanations, line by line. Problem: find median of two sorted arrays in O(log(m+n)). Standard approach: binary search partition method. We'll write pseudocode steps. Each line: \"虛擬碼步驟\" + \"// 解釋\". Use arrow. Use Start, End, Decision. Use Yes→, No→. Must not produce actual code. Provide pseudocode only. We'll write steps.\n\nLet's craft algorithm: assume nums1 length m, nums2 length n. Ensure nums1 is smaller. Binary search over nums1. Variables: imin=0, imax=m, halfLen=(m+n+1)/2. While imin <= imax: i = (imin+imax)/2, j = halfLen - i. If i < m and nums2[j-1] > nums1[i], increase i: imin = i+1. Else if i > 0 and nums1[i-1] > nums2[j], decrease i: imax = i-1. Else correct partition found. Then compute max_of_left: if i==0 then nums2[j-1] else if j==0 then nums1[i-1] else max(nums1[i-1], nums2[j-1]). If (m+n)%2==1 return max_of_left. Then min_of_right: if i==m then nums2[j] else if j==n then nums1[i] else min(nums1[i], nums2[j]). Return (max_of_left + min_of_right)/2.\n\nWe need to output steps with explanations. Use arrow. We need to incorporate decision branches.\n\nLet's draft.\n\nStart // 程式開始執行\n→ Step 1: 計算 m ← length(nums1), n ← length(nums2) // 取得兩陣列長度\n→ Decision: 如果 m > n? // 讓較小陣列作為 nums1\n    Yes → Swap nums1, nums2 ; Swap m, n // 交換以保證 nums1 為較小陣列\n    No  → // 兩陣列已符合條件\n→ Step 2: 設定 imin ← 0, imax ← m, halfLen ← (m + n + 1) / 2 // 初始化二分搜尋參數\n→ Decision: 迴圈條件 imin ≤ imax? // 開始二分搜尋\n    Yes → Step 3: i ← (imin + imax) / 2, j ← halfLen - i // 取得分割點\n    → Decision: 如果 i < m 且 nums2[j-1] > nums1[i]? // 分割不平衡，左邊太小\n        Yes → imin ← i + 1 // 移動左邊界\n        No  → Decision: 如果 i > 0 且 nums1[i-1] > nums2[j]? // 分割不平衡，左邊太大\n            Yes → imax ← i - 1 // 移動右邊界\n            No  → // 正確分割點已找到\n                → Step 4: max_of_left ← If i == 0 Then nums2[j-1] Else If j == 0 Then nums1[i-1] Else Max(nums1[i-1], nums2[j-1]) // 計算左半邊最大值\n                → Decision: (m + n) % 2 == 1? // 判斷總長度奇偶\n                    Yes → End // Return max_of_left as median\n                    No  → // 總長度偶\n                        → Step 5: min_of_right ← If i == m Then nums2[j] Else If j == n Then nums1[i] Else Min(nums1[i], nums2[j]) // 計算右半邊最小值\n                        → Step 6: Return (max_of_left + min_of_right) / 2 // 計算並返回中位數\n    No → End // 迴圈結束 (實際情況下已在上一步返回)\n\nBut we need to produce line-by-line pseudocode. Each line must contain \"虛擬碼步驟\" and // explanation. Use arrow. We can separate lines with newline. Ensure formatting.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← length(nums1) ; n ← length(nums2) // 取得兩陣列長度  \n→ Decision: 如果 m > n? // 讓較小陣列作為 nums1  \n Yes → Swap nums1, nums2 ; Swap m, n // 交換兩陣列與長度  \n No  → // 兩陣列已符合條件  \n→ Step 2: imin ← 0 ; imax ← m ; halfLen ← (m + n + 1) / 2 // 初始化二分搜尋參數  \n→ Decision: 迴圈條件 imin ≤ imax? // 開始二分搜尋  \n Yes → Step 3: i ← (imin + imax) / 2 ; j ← halfLen - i // 取得分割點  \n  → Decision: 如果 i < m 且 nums2[j-1] > nums1[i]? // 左半邊太小  \n   Yes → imin ← i + 1 // 移動左邊界  \n   No  → Decision: 如果 i > 0 且 nums1[i-1] > nums2[j]? // 左半邊太大  \n    Yes → imax ← i - 1 // 移動右邊界  \n    No  → // 正確分割點已找到  \n     → Step 4: max_of_left ← If i == 0 Then nums2[j-1] Else If j == 0 Then nums1[i-1] Else Max(nums1[i-1], nums2[j-1]) // 計算左半邊最大值  \n     → Decision: (m + n) % 2 == 1? // 判斷總長度奇偶  \n      Yes → End // Return max_of_left as median  \n      No  → // 總長度偶  \n       → Step 5: min_of_right ← If i == m Then nums2[j] Else If j == n Then nums1[i] Else Min(nums1[i], nums2[j]) // 計算右半邊最小值  \n       → Step 6: Return (max_of_left + min_of_right) / 2 // 計算並返回中位數  \n No → End // 迴圈結束（實際情況下已在上一步返回）"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        # Union-Find data structure\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            # Merge all emails in the same account\n            for email in acc[1:]:\n                parent_email = find(first_email)\n                parent_email2 = find(email)\n                parent[parent_email2] = parent_email\n                email_to_name[email] = name\n\n        # Group emails by their root parent\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        # Prepare final result\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\ndef main():\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Support two possible input formats:\n    # 1) \"accounts = [...]\"  (as in the examples)\n    # 2) just the list representation\n    if raw_input.lower().startswith('accounts'):\n        # Split on the first '='\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # Safely evaluate the list expression\n    try:\n        accounts = ast.literal_eval(expr)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    # Print the result in Python list format\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Use Start, End, Decision, etc. Should explain each line. Provide step-by-step algorithm: build graph of emails, union-find, mapping emails to names, then grouping and sorting.\n\nWe produce steps line by line, each with comment. Use arrow and indentation. Let's craft.\n\nRemember not to output actual code. Just virtual steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 email_to_name // 將每個 email 先映射其擁有者姓名  \n→ Step 2: 建立空字典 graph // 用於儲存 email 之間的連結  \n→ Step 3: 建立空集合 all_emails // 追蹤所有 email  \n→ Step 4: 針對每個帳戶 accounts  \n  → Step 4.1: 取得帳戶名稱 name ← accounts[i][0] // 第一個元素是姓名  \n  → Step 4.2: 針對帳戶內每個 email e  \n    → Decision: 如果 e 未在 email_to_name?  \n      Yes → Step 4.2.1: email_to_name[e] ← name // 第一次看到此 email，記錄姓名  \n      No  → Step 4.2.2: // 只記錄姓名，不重複  \n    → Step 4.3: all_emails.add(e) // 加入所有 email 集合  \n  → Decision: 如果帳戶內 email 數 > 1? // 需要建立連結  \n    Yes → Step 4.4: 針對帳戶內每個 email e1  \n      → 針對帳戶內每個 email e2 (e2 > e1)  \n       → Step 4.4.1: 若 e1 與 e2 不在 graph, 則 graph[e1] ← 空集合, graph[e2] ← 空集合  \n       → Step 4.4.2: graph[e1].add(e2) // 將兩個 email 連結  \n       → Step 4.4.3: graph[e2].add(e1)  \n    No  → Step 4.5: // 只剩一個 email，不需要連結  \n→ Step 5: 建立 Union-Find 結構 uf，含 all_emails  \n  → Step 5.1: 初始化 parent[e] ← e // 每個 email 初始指向自己  \n  → Step 5.2: find(x) 函式: 路徑壓縮查找根節點  \n  → Step 5.3: union(x, y) 函式: 合併兩個 email 的根  \n→ Step 6: 對 graph 內每個節點 e  \n  → 針對每個相鄰節點 nei in graph[e]  \n    → Step 6.1: uf.union(e, nei) // 把相鄰 email 合併  \n→ Step 7: 建立空字典 root_to_emails // 以根節點為鍵，存該根節點下的所有 email  \n  → Step 7.1: 針對每個 email e in all_emails  \n    → Step 7.2: 根 r ← uf.find(e) // 找到 e 的根節點  \n    → Decision: r 是否已在 root_to_emails?  \n      Yes → root_to_emails[r].add(e) // 加入集合  \n      No → root_to_emails[r] ← {e} // 新增集合  \n→ Step 8: 建立結果列表 result  \n  → Step 8.1: 針對每個根節點 r in root_to_emails  \n    → Step 8.2: emails_sorted ← sort(root_to_emails[r]) // 將 email 依字典序排序  \n    → Step 8.3: name ← email_to_name[next(iter(root_to_emails[r]))] // 取任一 email 的姓名  \n    → Step 8.4: result.append([name] + emails_sorted) // 加入整個帳戶  \n→ End // 程式執行結束，result 為合併後的帳戶列表\n\n# Explanation  \n// 步驟 1-3 初始化資料結構  \n// 步驟 4 對每個帳戶建立 email 與姓名映射，收集所有 email，並把同一帳戶內的 email 兩兩連結  \n// 步驟 5 建立 Union‑Find，方便合併相同帳戶的 email  \n// 步驟 6 用 Union‑Find 把圖中相連的 email 合併  \n// 步驟 7 把同一根節點（即同一人）下的 email 收集起來  \n// 步驟 8 把每個組合整理成姓名+排序後的 email，存入結果  \n// End 標示結束，結果即為要求的合併帳戶列表。"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find shortest distances and parents for each word\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Extract key=value pairs using regex\n    pattern = re.compile(r'(\\w+)\\s*=\\s*(.+?)(?:,|$)')\n    matches = pattern.findall(raw_input)\n\n    data = {}\n    for key, val in matches:\n        try:\n            # Safely evaluate literals (strings, lists, etc.)\n            data[key] = ast.literal_eval(val)\n        except Exception:\n            # Fallback: strip spaces if eval fails\n            data[key] = val.strip()\n\n    beginWord = data.get('beginWord')\n    endWord = data.get('endWord')\n    wordList = data.get('wordList', [])\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate a virtual code algorithm for word ladder II: find all shortest transformation sequences from beginWord to endWord. Should produce pseudo-code with steps, decision arrows, etc. No actual code, just pseudocode.\n\nWe need to output line-by-line steps, each line: virtual code step + space + // explanation.\n\nWe should structure with Start, End, Decision, arrows, etc. Use \"→\" arrow for sequential steps, \"Yes →\" \"No →\" for decisions. Use indentation perhaps. But keep format consistent.\n\nLet's plan algorithm: BFS to find levels, build adjacency graph, then DFS/backtracking to enumerate paths.\n\nPseudo steps:\n\nStart\n→ Build graph: for each word in wordList + beginWord, generate all generic states, map to words. // build adjacency using wildcard patterns\n→ BFS: initialize queue with beginWord, visited map level. // find shortest path length\n→ While queue not empty: pop word, for each neighbor: if not visited, add to queue and set level. // standard BFS\n→ If endWord not reached: return empty list // no path\n→ After BFS, we have level dict, and adjacency list\n→ DFS from beginWord to endWord: backtrack paths only using neighbors that are level+1 // ensures shortest\n→ Collect paths\nEnd\n\nAlso need to record neighbors only if level[neighbor] == level[word] + 1.\n\nImplementation details: Use adjacency list constructed from wordList + beginWord. For generic mapping: for each word, for each position replace char with '*', map key->list of words. Then for each word, neighbors are union of lists for each generic key, excluding itself.\n\nPseudo steps need to reflect that.\n\nLet's produce the lines:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 level map, graph map, queue // 初始化必要資料結構\n→ Step 2: 將 beginWord 加入 wordList // 確保起點在詞彙表中\n→ Decision: 如果 endWord 不在 wordList? // 檢查終點是否可達\n    Yes → End // 無效終點，直接結束並返回空結果\n    No  → Step 3: 建立通用模式到單詞的映射 table // 以 '*' 取代每個字母建立鄰接關係\n→ Step 4: 透過 table 建立 graph 的鄰接清單 // 每個單詞的相鄰單詞\n→ Step 5: BFS: 初始化 queue 以 beginWord, 設 level[beginWord]=0 // 開始層級搜尋\n→ Decision: queue 是否空? // 判斷是否還有節點可探索\n    Yes → End // 完成 BFS，無路徑\n    No  → Step 6: 取出 current 從 queue\n→ Decision: current 是否等於 endWord? // 途中是否已找到終點\n    Yes → Step 7: 紀錄最短層級 depth = level[current] // 記錄終點層級\n    No  → Step 8: 對於每個 neighbor in graph[current]\n        Decision: level[neighbor] 是否已存在? // 是否已訪問\n            Yes → No → // 跳過已訪問節點\n            No  → Decision: level[neighbor] > level[current] + 1? // 只允許更短層級\n                Yes → No → // 跳過\n                No  → Step 9: 設 level[neighbor] = level[current] + 1, queue.push(neighbor) // 探索下一層\n→ Decision: queue 是否空? // 重複 BFS\n    Yes → // 轉向 DFS\n    No  → 回到 Step 6\n→ Decision: endWord 是否存在 level? // 檢查是否找到終點\n    Yes → Step 10: 初始化 results list, path list with beginWord // 準備回溯\n    No  → End // 沒有路徑，返回空\n→ Step 11: 定義 recursive DFS(current):\n        Decision: current == endWord?\n            Yes → results.push(copy of path) // 成功路徑\n            No  → For each neighbor in graph[current]:\n                Decision: level[neighbor] == level[current] + 1? // 確保層級正確\n                    Yes → path.push(neighbor), DFS(neighbor), path.pop()\n                    No  → // 跳過\n→ Step 12: 呼叫 DFS(beginWord) // 開始枚舉\n→ End // 程式結束\n\nBut need to ensure each line has \"虛擬碼步驟\" and comment. Use arrows \"→\" for flow. For decisions indent with Yes → and No → maybe nested.\n\nWe need to maintain structure like example. Let's produce each line exactly.\n\nAlso include \"Start\" line.\n\nWe need to use Chinese comments. Let's craft.\n\nWe might need to ensure each line is one step. For decisions, we can include the block indentation with tabs maybe, but it's not necessary. The example uses indentation like:\n\nDecision: ...\n    Yes → ...\n    No  → ...\n\nWe'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 level map、graph map、queue 等資料結構 // 初始化必要資料  \n→ Step 2: 若 beginWord 不在 wordList，將其加入 // 以便於後續搜尋  \nDecision: endWord 是否在 wordList? // 檢查終點是否可達  \n Yes → End // 無效終點，直接結束並返回空結果  \n No  → Step 3: 建立通用模式（* 取代每個字母）到單詞列表的映射 table // 用於快速尋找鄰接  \n→ Step 4: 透過 table 建立 graph 的鄰接清單 // 每個單詞的相鄰單詞  \n→ Step 5: BFS: 將 beginWord 放入 queue，設 level[beginWord] = 0 // 開始層級搜尋  \nDecision: queue 是否空? // 判斷是否還有節點可探索  \n Yes → End // 完成 BFS，無路徑  \n No  → Step 6: 從 queue 取出 current // 取下一個節點  \nDecision: current 是否等於 endWord? // 途中是否已找到終點  \n Yes → Step 7: 記錄最短層級 depth = level[current] // 記錄終點層級  \n No  → Step 8: 對於每個 neighbor in graph[current]  \n  Decision: level[neighbor] 是否已存在? // 是否已訪問  \n   Yes → No → // 跳過已訪問節點  \n   No  → Decision: level[neighbor] > level[current] + 1? // 只允許更短層級  \n    Yes → No → // 跳過  \n    No  → Step 9: 設 level[neighbor] = level[current] + 1，queue.push(neighbor) // 探索下一層  \nDecision: queue 是否空? // 重複 BFS  \n Yes → // 轉向 DFS  \n No  → 回到 Step 6  \nDecision: endWord 是否存在 level? // 檢查是否找到終點  \n Yes → Step 10: 初始化 results 列表、path 列表並加入 beginWord // 準備回溯  \n No  → End // 沒有路徑，返回空  \n→ Step 11: 定義遞迴 DFS(current) // 用於枚舉所有最短路徑  \n Decision: current == endWord? // 是否到達終點  \n  Yes → results.push(copy of path) // 成功路徑加入結果  \n  No  → For 每個 neighbor in graph[current]  \n   Decision: level[neighbor] == level[current] + 1? // 確保層級正確  \n    Yes → path.push(neighbor)，DFS(neighbor)，path.pop() // 深入搜尋  \n    No  → // 跳過  \n→ Step 12: 呼叫 DFS(beginWord) // 開始枚舉  \nEnd // 程式執行結束"
    },
    {
      "title": "Super Washing Machines",
      "source_file": "Leetcode/leetcode517.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinMoves(self, machines):\n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        target = total // n\n        ans = 0\n        cum_diff = 0\n        for load in machines:\n            cum_diff += load - target\n            ans = max(ans, abs(cum_diff))\n        return ans\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    machines = ast.literal_eval(data)\n    sol = Solution()\n    result = sol.findMinMoves(machines)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode for the algorithm. Problem: Leetcode \"1109. Robot Room Cleaner\"? No actually \"1109. \" is something else. But this is \"1109. Super Washing Machines\" Leetcode problem. The algorithm: compute total dresses, if total % n != 0 return -1. Let target = total / n. Then iterate through machines, compute prefix sum and track max moves. For each i, compute current cumulative dresses = sum[0..i]. The difference from target*(i+1) indicates how many dresses need to move across boundary between i and i+1. The number of moves required is max of abs(diff) and cumulative moves to left side. The answer is max over i of max(abs(diff), moves). Implementation: moves = 0; answer=0; sum=0; for each machine count: sum += count; diff = sum - target*(index+1); moves = max(moves, diff); answer = max(answer, max(abs(diff), moves)). Actually diff can be negative; moves is the maximum cumulative load left to send to right? Actually algorithm: For each i, compute diff = sum - target*(i+1). The maximum of abs(diff) and moves so far gives moves needed. moves is max of moves and diff. but diff can be negative, we use max moves as max(moves, diff). But if diff negative, we need to handle. Usually we use \"left\" and \"right\" concept: left diff = sum - target*(i+1) (excess or shortage). The answer is max(abs(left diff), left max). left max is maximum of left diff encountered so far. Implementation uses two variables: maxSend = 0, maxReceive = 0. Actually standard solution: let maxMove = 0; let total = 0; For i from 0 to n-1: total += machines[i]; diff = total - target*(i+1); maxMove = max(maxMove, abs(diff)); Also keep maxSend = max(maxSend, diff). But I think simpler: ans = max(ans, max(abs(diff), moves)), moves = max(moves, diff). But need to handle negative diff: we want max of moves (max positive diff so far). So we can maintain maxPositiveDiff = max(maxPositiveDiff, diff). And answer = max(answer, max(abs(diff), maxPositiveDiff)). But negative diff means shortage, no need to move leftwards. So algorithm: maxMove = 0; maxSend = 0; for each i: total += machines[i]; diff = total - target*(i+1); if diff > 0: maxSend = max(maxSend, diff); maxMove = max(maxMove, diff); maxMove = max(maxMove, -diff); answer = max(answer, maxMove). Actually typical solution: ans = 0; total = 0; for i in range(n): total += machines[i]; diff = total - target*(i+1); ans = max(ans, abs(diff), diff); return ans. But that's not accurate? Wait known solution: let moves = 0; let sum = 0; for i in range(n): sum += machines[i]; diff = sum - target*(i+1); moves = max(moves, abs(diff)); return moves. But check example: machines = [1,0,5]; total=6, target=2. i=0: sum=1, diff=1-2= -1; abs=1. moves=1. i=1: sum=1, diff=1-4= -3; abs=3, moves=3. i=2: sum=6, diff=6-6=0; abs=0, moves stays 3. answer=3. correct. Another example: [0,3,0] total=3 target=1. i=0: sum=0 diff=-1 abs1 moves1. i=1 sum=3 diff=3-2=1 abs1 moves1. i=2 sum=3 diff=3-3=0 abs0 moves1. answer 1. Works. So algorithm: ans = 0; sum = 0; for i: sum += machines[i]; diff = sum - target*(i+1); ans = max(ans, abs(diff), diff); return ans. Wait diff might be negative, max(diff) may not be needed as abs covers. But consider diff positive: abs=diff, so max(diff,abs(diff)) same. But diff negative: abs>0 but diff negative. So max(diff,abs(diff)) = abs(diff). So we can just use abs. But we also need to consider that sometimes the moves required is max of abs(diff) and maxSend. But diff negative may need moves due to previous positive. But abs(diff) covers because when diff negative, abs diff might be less than maxSend from earlier steps. Eg: machines=[10,0,0], target=10/3? total=10 not divisible by 3 -> -1. But case machines=[0,0,10] n=3 target=10/3? not divisible. Hard to find example where abs(diff) insufficient? Known formula uses max(abs(diff), maxSend). But tests show abs(diff) works? Let's test: machines=[0,3,0] we saw works. Another: [0,2,2] total=4 target=1.333? not divisible. Hard.\n\nBetter to follow standard algorithm: ans = 0; sum = 0; for i: sum += machines[i]; diff = sum - target*(i+1); ans = max(ans, abs(diff)); return ans. This is accepted solution. So pseudocode will reflect that.\n\nWe'll produce steps: compute total, check divisible, target; then iterate accumulate sum, compute diff, update ans; end return ans.\n\nLet's output each step line with explanation.\n\nWe'll include Start, End, Decision.\n\nWe'll include arrows for flow.\n\nLet's write lines.\n\nUse \"→\" for steps, \"Decision:\" for branching.\n\nWe must include \"[空格] // 解釋/說明\" after each line.\n\nLet's produce.\n\nNote: no actual code, just pseudocode. Let's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算洗衣機總數量 total = sum(machines) // 求所有衣服總數  \n→ Decision: 如果 total % n ≠ 0? // 檢查是否能平均分配  \n    Yes → Step 2: 回傳 -1 // 若不能平均，直接失敗  \n    No  → Step 3: 計算目標值 target = total / n // 每台洗衣機需要的衣服數  \n→ Step 4: 初始化變數 sum = 0, ans = 0 // sum 用於前綴總和，ans 用於記錄最小移動次數  \n→ Loop i from 0 to n-1: // 逐一遍歷每台洗衣機  \n    → Step 5: sum += machines[i] // 累加到前綴總和  \n    → Step 6: 計算差值 diff = sum - target * (i + 1) // 這一步驟表示在 i 號洗衣機右側需要平衡的衣服數  \n    → Step 7: ans = max(ans, abs(diff)) // 更新答案，取目前差值絕對值與已知最大值之較大者  \n→ End // 程式執行結束  \n→ Step 8: 回傳 ans // 最終得到的最小移動次數\n\n--- 以上為逐行虛擬碼與簡短說明 ---"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, false, true]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCalendar:\n    \"\"\"\n    MyCalendar keeps a list of non-overlapping half-open intervals.\n    The book method checks for conflicts and adds the interval if possible.\n    \"\"\"\n    def __init__(self):\n        self.bookings = []  # stores tuples of (start, end)\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"\n        Try to book an interval [start, end).\n        Return True if successful, False otherwise.\n        \"\"\"\n        for s, e in self.bookings:\n            # Overlap occurs if max(s,start) < min(e,end)\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Parse the input which is expected to be two lists: commands and arguments\n    try:\n        commands, args = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # If input is not a valid JSON, exit gracefully\n        sys.exit()\n\n    outputs = []\n    calendar = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MyCalendar\":\n            calendar = MyCalendar()\n            outputs.append(None)          # Constructor returns null\n        elif cmd == \"book\" and calendar is not None:\n            start, end = arg\n            result = calendar.book(start, end)\n            outputs.append(result)\n        else:\n            # Unsupported command or missing calendar instance\n            outputs.append(None)\n\n    # Print results in JSON format (None -> null, True/False -> true/false)\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for MyCalendar implementation. Use virtual code lines with explanations. Use start/end and decision arrows. Should be step-by-step. Should be per line. Probably we can describe class, constructor, book function, maintain intervals list, check for overlap, insert if no conflict. Use simple algorithm: maintain list of intervals sorted; for each booking, iterate over list to check overlap; if any overlap, return false; else add and return true.\n\nWe'll produce code structure: Start, define class, constructor, intervals list, book function, decision loops.\n\nUse pseudo-code language: \"MyCalendar\" class, \"Start\", \"End\".\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: Define class MyCalendar // 建立 MyCalendar 類別\n\n→ Step 2: MyCalendar() // 建構子\n\n→ Step 3: intervals ← empty list // 用來儲存已預約的時間區間\n\n→ Step 4: book(start, end) // 方法\n\n→ Decision: For each interval in intervals? // 逐個檢查\n\nYes → Decision: 如果 start < interval.end AND end > interval.start? // 判斷有無重疊\n\n    Yes → Step 5: Return False // 有重疊，不能預約\n\n    No  → Continue // 無重疊，檢查下一個\n\n→ Step 6: Append (start, end) to intervals // 無重疊，新增\n\n→ Step 7: Return True // 成功預約\n\nEnd // 程式結束\n\nAdd some sorting optional.\n\nAlso need to handle insertion order.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MyCalendar // 建立 MyCalendar 類別  \n→ Step 2: MyCalendar() // 建構子，初始化物件  \n→ Step 3: intervals ← 空列表 // 用來儲存已預約的 [start, end) 互不重疊區間  \n→ Step 4: book(start, end) // 定義預約方法，參數為開始與結束時間  \n→ Decision: 逐一檢查 intervals 中已存在的區間? // 遍歷已預約區間  \n  Yes → Decision: 如果 start < interval.end 且 end > interval.start? // 判斷兩區間是否有重疊  \n    Yes → Step 5: Return False // 有重疊，預約失敗  \n    No  → Step 6: 轉到下一個 interval // 無重疊，繼續檢查  \n  No  → Step 7: intervals ← intervals + [(start, end)] // 所有檢查完畢且無重疊，新增區間  \n    → Step 8: Return True // 預約成功  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,0,1,6,4,4,0,1]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 0, 1, 6, 4, 4, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        self.mapping = {}\n        self.size = n - len(blacklist)\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        index = random.randint(0, self.size - 1)\n        return self.mapping.get(index, index)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        elif cmd == \"pick\":\n            results.append(obj.pick())\n        else:\n            results.append(None)  # Undefined command handling\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate a virtual code algorithm for the solution: typical solution uses mapping from [0, m-1] to whitelist. Steps: compute M = n - blacklist.length. Map blacklisted numbers < M to whitelisted numbers >= M via a hash map. In pick(), get random int x from 0..M-1, if x in map, return map[x], else return x.\n\nWe need to produce line-by-line virtual code with explanation.\n\nWe need Start, End, Decision.\n\nLet's craft:\n\nStart // initialize Solution object\n→ Step 1: Set M = n - length(blacklist) // compute whitelist size\n→ Step 2: Create empty HashMap map // mapping for blacklisted < M\n→ Step 3: Create set blackSet from blacklist // for O(1) membership\n→ Step 4: Initialize pointer w = M // start of whitelist candidates\n→ Decision: For each b in blacklist // iterate blacklisted numbers\n    → Step 5: If b < M // only those in range affect mapping\n        → Step 6: While w in blackSet // skip blacklisted whitelist candidates\n            → w = w + 1 // move to next whitelist candidate\n        → Step 7: map[b] = w // map blacklist to whitelist candidate\n        → Step 8: w = w + 1 // advance pointer\n    → End if\n→ End for\n→ Store M for pick()\n\nThen pick():\nStart pick()\n→ Step 9: r = random integer between 0 and M-1 // uniform random\n→ Decision: If r in map // check mapping\n    → Step 10: return map[r] // mapped whitelist\n    → Else\n        → Step 11: return r // not mapped, use r\nEnd pick()\n\nReturn final. Provide explanation comments. Let's format.\n...done thinking.\n\nStart // 建構 Solution 物件，執行初始化\n→ Step 1: M ← n − len(blacklist) // 計算合法數字的總數\n→ Step 2: map ← 空 HashMap // 用於存放黑名單內小於 M 的映射\n→ Step 3: blackSet ← Set(blacklist) // 方便 O(1) 判斷是否為黑名單\n→ Step 4: w ← M // 從 M 開始尋找合法的右側候選\n→ Decision: for 每個 b 在 blacklist // 逐一處理黑名單\n    Yes → Step 5: if b < M // 只有小於 M 的才需要映射\n        Yes → Step 6: while w ∈ blackSet // 跳過右側仍為黑名單的數\n            Yes → w ← w + 1\n        End while\n        Yes → Step 7: map[b] ← w // 把 b 映射到合法的右側數字\n        Yes → Step 8: w ← w + 1 // 更新 w，準備下一個候選\n    No → // b ≥ M 時不需要映射，直接略過\n    End if\nEnd for\n→ Step 9: Store M, map 供 pick() 之後使用\nEnd // 初始化結束\n\nStart pick() // 產生隨機合法數字\n→ Step 10: r ← randomInt(0, M−1) // 取得 0~M-1 的隨機數\n→ Decision: if r ∈ map // r 是否需要映射\n    Yes → Step 11: return map[r] // 回傳映射後的合法數字\n    No → Step 12: return r // r 本身即合法\nEnd pick()"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.4653920747690126,-0.8666057724611412],[-0.46312783244249506,0.7636997333826435],[-0.7933770674317953,0.35646597734536023]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.4653920747690126, -0.8666057724611412], [-0.46312783244249506, 0.7636997333826435], [-0.7933770674317953, 0.35646597734536023]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 使用極座標隨機生成點，確保點在圓內均勻分布\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    # 從標準輸入讀取操作序列和對應參數\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    result = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)          # 建構式不回傳任何值，輸出為 null\n        elif op == \"randPoint\":\n            result.append(obj.randPoint())\n        else:\n            # 若有未知操作，亦回傳 None\n            result.append(None)\n\n    # 將結果輸出為 JSON 格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode for this problem. Step by step. Provide lines with explanation. Let's produce structure:\n\nStart // start program\n→ Step 1: Store radius, center coordinates // initialization\n→ Step 2: In randPoint, generate random angle theta in [0, 2π) // uniform\n→ Step 3: Generate random radius r' such that area uniform: r' = sqrt(random()) * radius // explanation\n→ Step 4: Compute x = x_center + r' * cos(theta)\n→ Step 5: Compute y = y_center + r' * sin(theta)\n→ Step 6: Return [x, y] // output\n\nWe need to include Decision if necessary? Not really. Maybe include random uniform generation. But structure as per requirement. Also we may include \"Decision:\" for radius >0? but radius always >0. Keep simple.\n\nAlso need to show constructor initialization steps and method steps separately. Provide pseudo code lines like:\n\n→ Constructor: Solution(radius, x_center, y_center) // store values\n\n→ Method: randPoint() // generate random point\n\nLet's format each line with // explanation. Use arrow '→'. Use Start, End. Let's produce.\n\nAlso maybe include random function calls: rand() or random().\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Constructor: Solution(radius, x_center, y_center) // 儲存圓半徑與中心座標  \n→ Step 1: Store radius in variable R; store center in (Xc, Yc) // 建立類別成員  \n→ End // 建構完成  \n\nStart // 呼叫 randPoint 方法時執行  \n→ Step 2: theta ← RandomUniform(0, 2π) // 產生均勻分布的角度  \n→ Step 3: u ← RandomUniform(0, 1) // 產生均勻分布的隨機數  \n→ Step 4: r ← sqrt(u) * R // 透過 sqrt 調整半徑，使面積均勻  \n→ Step 5: x ← Xc + r * cos(theta) // 計算點的 x 座標  \n→ Step 6: y ← Yc + r * sin(theta) // 計算點的 y 座標  \n→ Step 7: Return [x, y] // 回傳隨機點  \nEnd // randPoint 執行結束"
    },
    {
      "title": "Count Different Palindromic Subsequences",
      "source_file": "Leetcode/leetcode730.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"bccb\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '8'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '8'"
        },
        {
          "example_index": 1,
          "input": "s = \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
          "expected_output": "104860361",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '104860361'\nGot (Norm):      '1808'\n--- (Raw) ---\nRaw Expected: '104860361'\nRaw Got:      '1808'"
        }
      ],
      "generated_code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef count_palindromic_subsequences(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # next[i] : next index after i where s[next[i]] == s[i]\n    # prev[i] : previous index before i where s[prev[i]] == s[i]\n    next_occ = [-1] * n\n    prev_occ = [-1] * n\n\n    last = {}\n    for i in range(n - 1, -1, -1):\n        c = s[i]\n        next_occ[i] = last.get(c, -1)\n        last[c] = i\n\n    last.clear()\n    for i in range(n):\n        c = s[i]\n        prev_occ[i] = last.get(c, -1)\n        last[c] = i\n\n    # dp[i][j] : number of distinct palindromic subsequences in s[i..j]\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            base = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]\n            base %= MOD\n            if s[i] != s[j]:\n                dp[i][j] = base\n            else:\n                left = next_occ[i]\n                right = prev_occ[j]\n                if left == -1 or left > right:\n                    add = 2\n                elif left == right:\n                    add = 3\n                else:\n                    add = 4\n                dp[i][j] = (base + add) % MOD\n    return dp[0][n - 1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Try to extract the string value\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    # Remove surrounding quotes if any\n    if data and ((data[0] == '\"' and data[-1] == '\"') or (data[0] == \"'\" and data[-1] == \"'\")):\n        data = data[1:-1]\n    s = data\n    result = count_palindromic_subsequences(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm. Problem: count distinct non-empty palindromic subsequences modulo 1e9+7. Standard DP solution using dp[i][j] for substring s[i..j]. recurrence: dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + add, where add depends on s[i]==s[j]. If equal: if next[i]==prev[j] etc. Use next occurrence of char. We'll produce virtual steps: start, compute next/prev arrays, DP loops, etc. Need to produce lines with \"虛擬碼步驟 // 解釋\".\n\nLet's craft pseudo-code line by line:\n\nStart\n→ Step 1: Let MOD = 10^9 + 7\n→ Step 2: Let n = length of s\n→ Step 3: Create arrays next[n] and prev[n] to store next and previous occurrence indices for each position\n→ Step 4: Initialize next[n-1] = -1; for i from n-2 down to 0: if s[i+1]==s[i]?? Actually next occurrence: For each position i, find next index j>i where s[j]==s[i]. We'll compute using lastSeen dict. Similarly prev using lastSeen forward.\n\nBut we need step-by-step; we can break loops into steps. Provide explanation each line.\n\nThen DP: dp = 2D array size n x n, initialize dp[i][i] = 1\n\nThen for len from 2 to n: for i from 0 to n-len: j = i+len-1\n- compute base = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]\n- if s[i] != s[j]: dp[i][j] = base mod MOD\n- else: // s[i]==s[j]\n  - let left = next[i]; right = prev[j];\n  - if left == -1 or left > right: // no same char inside\n       add = 2\n  - else if left == right: // one same char inside\n       add = 3\n  - else: // more than one same char inside\n       add = 4\n  - dp[i][j] = (base + add) mod MOD\n\nFinally answer = dp[0][n-1] % MOD\n\nReturn answer\n\nWe need to produce lines for each of these. Provide virtual code lines with arrow '→'.\n\nLet's produce about 30 lines.\n\nMake sure each line contains \"虛擬碼步驟 // 解釋\". Use arrow at start of each line except maybe start line. Use \"Start // 程式開始執行\".\n\nWe can incorporate loops by summarizing.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: MOD ← 1000000007 // 定義取模的常數\n→ Step 2: n ← length(s) // 取得字串長度\n→ Step 3: next ← array of size n, prev ← array of size n // 用於存儲下一個相同字母的位置\n→ Step 4: last ← empty map // 暫存每個字母最近一次出現的位置\n→ Step 5: For i from n-1 downto 0 // 從尾部掃描，填寫 next\n    → If s[i] in last then next[i] ← last[s[i]] else next[i] ← -1\n    → last[s[i]] ← i\n→ Step 6: Clear last // 重用 map 用於 prev\n→ Step 7: For i from 0 to n-1 // 從頭部掃描，填寫 prev\n    → If s[i] in last then prev[i] ← last[s[i]] else prev[i] ← -1\n    → last[s[i]] ← i\n→ Step 8: dp ← 2D array n×n, initialize all entries to 0 // DP 表\n→ Step 9: For i from 0 to n-1 // 單字符子串都只是一個回文\n    → dp[i][i] ← 1\n→ Step 10: For len from 2 to n // 考慮所有長度大於 1 的子串\n    → For i from 0 to n-len\n        → j ← i + len - 1\n        → base ← dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] // 合併左右兩部分，扣除重疊\n        → base ← (base mod MOD + MOD) mod MOD // 保證非負\n        → If s[i] != s[j] then\n            → dp[i][j] ← base\n        → Else // s[i] == s[j]\n            → left ← next[i]\n            → right ← prev[j]\n            → If left == -1 or left > right then\n                → add ← 2 // 兩個端字符不重複，僅加「a」和「aa」\n            → Else If left == right then\n                → add ← 3 // 端字符相同且中間只有一個同字符，加入「a」、「aa」、「aaa」\n            → Else\n                → add ← 4 // 端字符相同且中間至少兩個同字符，加入「a」、「aa」、「aba」等四種\n            → dp[i][j] ← (base + add) mod MOD\n→ Step 11: result ← dp[0][n-1] // 全部字串的回文子序列數\n→ End // 程式執行結束\n\nNeed to ensure each line is a single line with arrow and explanation. Also use \"Decision:\" when necessary? Could use Decision block for if else but not strictly required. However we can incorporate Decision style for clarity. Use \"Decision: s[i] != s[j]?\" with Yes/No.\n\nLet's rewrite with Decision style for if statements to match spec.\n\nSo Step 10: Use Decision.\n\nLet's produce.\n\nUse indentation? The spec shows indentation by spaces. Use 4 spaces indent for nested. We can replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MOD ← 1000000007 // 定義取模的常數  \n→ Step 2: n ← length(s) // 取得字串長度  \n→ Step 3: next ← array of size n, prev ← array of size n // 用於存儲下一個相同字母的位置  \n→ Step 4: last ← empty map // 暫存每個字母最近一次出現的位置  \n→ Step 5: For i from n-1 downto 0 // 從尾部掃描，填寫 next  \n  → If s[i] in last then next[i] ← last[s[i]] else next[i] ← -1 // 找到下一個相同字母的位置  \n  → last[s[i]] ← i // 更新最近一次的位置  \n→ Step 6: Clear last // 重用 map 用於 prev  \n→ Step 7: For i from 0 to n-1 // 從頭部掃描，填寫 prev  \n  → If s[i] in last then prev[i] ← last[s[i]] else prev[i] ← -1 // 找到上一個相同字母的位置  \n  → last[s[i]] ← i // 更新最近一次的位置  \n→ Step 8: dp ← 2D array n×n, initialize all entries to 0 // DP 表，用於存儲子串的答案  \n→ Step 9: For i from 0 to n-1 // 單字符子串都是回文  \n  → dp[i][i] ← 1  \n→ Step 10: For len from 2 to n // 考慮所有長度大於 1 的子串  \n  → For i from 0 to n-len  \n   → j ← i + len - 1  \n   → base ← dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] // 合併左右兩部分，扣除重疊  \n   → base ← (base mod MOD + MOD) mod MOD // 保證非負  \n   → Decision: s[i] != s[j]? // 檢查兩端字符是否相同  \n     Yes → dp[i][j] ← base // 不同字符，直接使用 base  \n     No → Decision: next[i] == -1 or next[i] > prev[j]? // 兩端相同，判斷中間是否有相同字符  \n      Yes → add ← 2 // 兩端相同且中間無同字符，只能形成「a」和「aa」  \n      No → Decision: next[i] == prev[j]? // 中間是否只有一個相同字符  \n        Yes → add ← 3 // 中間只有一個相同字符，形成「a」、「aa」、「aaa」  \n        No → add ← 4 // 中間至少兩個相同字符，還能形成「aba」等四種  \n         → dp[i][j] ← (base + add) mod MOD // 更新答案  \n         ← // 內部 Decision 結束  \n        → dp[i][j] ← (base + add) mod MOD // 計算完成  \n        ← // Decision 結束  \n      → dp[i][j] ← (base + add) mod MOD // 給出最終答案  \n     ← // Decision 結束  \n   ← // i 循環結束  \n  ← // len 循環結束  \n→ Step 11: result ← dp[0][n-1] // 全部字串的回文子序列數  \n→ End // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnxda1iec.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmpnxda1iec.py\", line 26, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3bfe71_n.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmp3bfe71_n.py\", line 26, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 若單個字串已超出限制，直接跳過\n            if zeros > m or ones > n:\n                continue\n            # 逆序遍歷以避免同一字串被重複計算\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # 使用 exec 將輸入字串轉成變數\n    local_vars = {}\n    exec(data, {}, local_vars)\n    strs = local_vars.get('strs', [])\n    m = local_vars.get('m', 0)\n    n = local_vars.get('n', 0)\n\n    solution = Solution()\n    result = solution.findMaxForm(strs, m, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: given array of binary strings, and integers m, n, return size of largest subset such that at most m zeros and n ones. Classic DP. We need to produce step-by-step virtual code lines, with arrows and decisions. Not actual code. Provide each line with explanation. Format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Provide algorithm steps. For DP, we use 2D DP array of size (m+1)*(n+1). For each string, count zeros and ones. For i from m down to zeros: for j from n down to ones: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1). After processing all strings, answer is dp[m][n].\n\nWe need to output each step line. Use arrow \"→\". Provide decisions. For loops, may be shown as steps. Provide initialization etc.\n\nLet's craft:\n\nStart // Program starts\n\n→ Step 1: 初始化 dp 数组尺寸 (m+1)*(n+1) 所有值为 0 // Initialize dp array\n\n→ Step 2: 遍历每个二进制字符串 str 在 strs // For each string\n\n    → Step 3: 计数 zeros = count of '0' in str, ones = count of '1' in str // Count zeros and ones\n\n    → Decision: 如果 zeros > m 或 ones > n? // Skip strings that exceed limits\n\n        No → Step 4: 对 i 从 m 到 zeros 步骤递减 // Iterate i\n\n            → Step 5: 对 j 从 n 到 ones 步骤递减 // Iterate j\n\n                → Step 6: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // Update dp\n\nEnd // 输出 dp[m][n] 作为答案 // Program ends\n\nBut we need more lines? Each line separate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列 (m+1) x (n+1)，所有值初始化為 0 // 初始化動態規劃表\n→ Step 2: 針對每個字串 str 於 strs 中逐一處理 // 開始遍歷輸入串\n    → Step 3: 計算 str 中 0 的個數 zeros 與 1 的個數 ones // 取得本字串的 0/1 數量\n    → Decision: 若 zeros > m 或 ones > n？ // 檢查字串是否超過總限制\n        Yes → Step 4: 跳過此字串 // 超過限制直接不處理\n        No  → Step 5: 由 i = m 降至 zeros 迭代 // 更新 dp 的 i 維度\n            → Step 6: 由 j = n 降至 ones 迭代 // 更新 dp 的 j 維度\n                → Step 7: dp[i][j] ← max(dp[i][j], dp[i-zeros][j-ones] + 1) // 選擇是否加入此字串\n→ Step 8: 回傳 dp[m][n] 作為最大子集合大小 // 結束並輸出結果\nEnd // 程式執行結束\n\nMake sure each line uses arrow? Only lines with → maybe. The format example shows each line preceded by arrow. But we can include arrow on each line. But Start and End lines don't need arrow. Use the example.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列 (m+1) x (n+1)，所有值初始化為 0 // 初始化動態規劃表  \n→ Step 2: 針對每個字串 str 於 strs 中逐一處理 // 開始遍歷輸入串  \n    → Step 3: 計算 str 中 0 的個數 zeros 與 1 的個數 ones // 取得本字串的 0/1 數量  \n    → Decision: 若 zeros > m 或 ones > n？ // 檢查字串是否超過總限制  \n        Yes → Step 4: 跳過此字串 // 超過限制直接不處理  \n        No  → Step 5: 由 i = m 降至 zeros 迭代 // 更新 dp 的 i 維度  \n            → Step 6: 由 j = n 降至 ones 迭代 // 更新 dp 的 j 維度  \n                → Step 7: dp[i][j] ← max(dp[i][j], dp[i-zeros][j-ones] + 1) // 選擇是否加入此字串  \n→ Step 8: 回傳 dp[m][n] 作為最大子集合大小 // 結束並輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[[1,2,3]],[[1,2,3]],[[1,2,3]]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [[1, 2, 3]], [[1, 2, 3]], [[1, 2, 3]]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)   # 保存原始陣列\n        self.current = list(nums)    # 用於隨機排列的副本\n\n    def reset(self):\n        \"\"\"恢復到原始配置並回傳結果。\"\"\"\n        self.current = list(self.original)\n        return self.current\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法隨機排列陣列並回傳。\"\"\"\n        n = len(self.current)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            self.current[i], self.current[j] = self.current[j], self.current[i]\n        return self.current\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得第一個閉括號的位置，分離兩個 JSON 陣列\n    end_first = data.find(']')\n    commands_str = data[:end_first + 1]\n    rest_str = data[end_first + 1:].lstrip(',').strip()\n\n    commands = json.loads(commands_str)\n    args = json.loads(rest_str)\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(arg)\n            outputs.append(None)          # 建構函式回傳 null\n        elif cmd == \"reset\":\n            outputs.append(obj.reset())\n        elif cmd == \"shuffle\":\n            outputs.append(obj.shuffle())\n\n    # 輸出結果，使用 JSON 格式 (None 將轉為 null)\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, following format: each line \"虛擬碼步驟 // 解釋\". Use arrow (→). Provide start, end, decisions. Need to design algorithm for shuffle (Fisher-Yates). Also methods reset and constructor. Steps: Start, Step 1: store original array, Step 2: copy array for operations, etc. Provide decision for reset? Actually reset returns original array. But need to copy to avoid reference issues. We'll outline steps in order: initialization, reset, shuffle.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Store original array copy as original // Save original configuration\n→ Step 2: Initialize current array copy as original // For shuffling\n→ End // End of constructor\n\nThen separate function blocks? We can treat each function as separate blocks with start and end.\n\nBut requirement: \"逐行地產生對應的虛擬碼\" maybe need to present full algorithm across all functions. We can include each function's steps. Provide decisions for resetting? No decisions. For shuffle: for i from 0 to n-1, pick random j from i to n-1, swap. Provide decisions: \"Yes →\" not needed. Use loop arrows? Could show loop with Decision: \"是否已遍歷完所有元素?\" or similar.\n\nWe can write:\n\nStart // 整體程式開始\n\n→ Step 1: Solution(int[] nums) 初始化 // 構造函式\n    → Step 1.1: original = copy(nums) // 複製輸入陣列作為原始版本\n    → Step 1.2: current = copy(nums) // 複製作為可變陣列\n→ End // 構造完成\n\n→ Step 2: reset() // 重置方法\n    → Step 2.1: current = copy(original) // 重新複製原始陣列\n    → Step 2.2: return current // 回傳重置後陣列\n→ End // reset 完成\n\n→ Step 3: shuffle() // 隨機排列方法\n    → Step 3.1: n = length(current) // 取得陣列長度\n    → Step 3.2: for i from 0 to n-1 // 遍歷每個索引\n        → Decision: i < n? // 檢查是否已完成\n            Yes → Step 3.3: j = randomInt(i, n-1) // 隨機選取 i 到 n-1\n            → Step 3.4: swap(current[i], current[j]) // 交換\n            → Step 3.5: i = i + 1 // 移動到下一個\n            No  → Step 3.6: return current // 返回隨機排列\n→ End // shuffle 完成\n\nBut need to use arrow syntax. Let's follow format: each line ends with comment. For loops, we can use Decision: \"i < n?\" etc. Use \"Yes →\" etc.\n\nWe'll produce final answer accordingly. Ensure using arrow `→` and `Yes →`, `No →`. Provide `Start` and `End`. Use Chinese explanation.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Solution(int[] nums) 初始化 // 建構函式：接收輸入陣列  \n → Step 1.1: original = copy(nums) // 複製輸入陣列作為原始配置  \n → Step 1.2: current = copy(nums) // 產生一個可變的副本以供 shuffle 使用  \n→ End // 建構完成  \n\n→ Step 2: reset() // 重置方法：恢復陣列到原始狀態  \n → Step 2.1: current = copy(original) // 將原始配置重新複製到 current  \n → Step 2.2: return current // 回傳已重置的陣列  \n→ End // reset 完成  \n\n→ Step 3: shuffle() // 隨機排列方法  \n → Step 3.1: n = length(current) // 取得陣列長度  \n → Step 3.2: i = 0 // 初始化索引  \n → Decision: i < n? // 判斷是否已遍歷所有位置  \n  Yes → Step 3.3: j = randomInt(i, n-1) // 隨機選擇從 i 到 n-1 的索引  \n   → Step 3.4: swap(current[i], current[j]) // 交換 current[i] 與 current[j]  \n   → Step 3.5: i = i + 1 // 移動到下一個位置  \n  No  → Step 3.6: return current // 所有位置處理完畢，回傳隨機排列  \n→ End // shuffle 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找到第一個 [] 包裹的內容並評估成列表\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        nums = []\n    else:\n        try:\n            nums = eval(match.group(0))\n        except Exception:\n            nums = []\n    solution = Solution()\n    subsets = solution.subsets(nums)\n    # 將結果格式化為不含空格的字串\n    subset_strs = ['[' + ','.join(map(str, subset)) + ']' for subset in subsets]\n    output = '[' + ','.join(subset_strs) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code for generating all subsets of a unique-element array. We'll use recursion/backtracking. Each line includes the step and comment. We'll follow the specified format: `Start // 程式開始執行` etc.\n\nWe need to produce virtual code line by line. Let's produce:\n\nStart\n→ Step 1: 定義結果集 subsets 為空集合 // 初始化結果\n→ Step 2: 呼叫 Backtrack(0, 空列表) // 從索引 0 開始\n→ Decision: 是否已到達陣列末尾? // 判斷是否生成完一個子集\n    Yes → Step 3: 將目前子集 copy 加入 subsets // 存儲子集\n    No  → Step 4: 添加 nums[索引] 到子集 // 選取當前元素\n        → Step 5: 呼叫 Backtrack(索引+1, 子集) // 進一步探索\n        → Step 6: 從子集移除 nums[索引] // 回溯\nEnd\n\nBut we must include arrow and indent properly. The decision structure: `Decision: 如果到達末尾?`. For Yes, we add subset. For No, we do include element, then recurse, then backtrack. We may need separate decisions for adding or not adding element? We can structure as: Decision: 是否加入? but typical algorithm: we either include or exclude. But we can do recursion that explores inclusion then exclusion. But simpler: for each index, we first add current subset, then for each remaining element, we include and recurse.\n\nLet's produce algorithm that uses recursion exploring both include and exclude. Use decisions.\n\nWe'll produce:\n\nStart\n→ Step 1: 初始化 subsets 為空集合 // 用來儲存所有子集\n→ Step 2: 定義遞迴函式 Backtrack(start, current) // 參數: 起始索引、目前子集\n→ Decision: 是否已到達陣列結尾? // 判斷是否已選完所有元素\n    Yes → Step 3: 將 current 的複本加入 subsets // 存入結果\n    No  → Step 4: 將 current 複本加入 subsets // 每一步都存一次子集\n        → Step 5: 從 start 到 nums.length-1 進行迴圈\n            → Decision: 當前索引 i 是否已超過陣列長度? // 迴圈結束判斷\n                Yes → No 行為 // 迴圈結束\n                No  → Step 6: 將 nums[i] 加入 current // 選取此元素\n                    → Step 7: 呼叫 Backtrack(i+1, current) // 深入下一層\n                    → Step 8: 從 current 移除最後一個元素 // 回溯\n→ End // 程式結束\n\nBut we need to produce line by line with arrow lines. We need to maintain structure: use indentation for nested steps, but keep format simple: use arrow and Decision: ... with Yes → etc.\n\nWe can produce like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 subsets 為空集合 // 用來儲存所有子集\n→ Step 2: 定義遞迴函式 Backtrack(start, current) // 參數: 起始索引、目前子集\n    → Decision: start 是否等於 nums.length? // 判斷是否已遍歷完所有位置\n        Yes → Step 3: 將 current 複本加入 subsets // 存入結果\n        No  → Step 4: 將 current 複本加入 subsets // 每一次遞迴都儲存一次子集\n            → Decision: start 是否已超過 nums.length-1? // 迴圈結束判斷\n                Yes → No 行為 // 迴圈結束\n                No  → Step 5: 將 nums[start] 加入 current // 選取元素\n                    → Step 6: 呼叫 Backtrack(start+1, current) // 深入遞迴\n                    → Step 7: 從 current 移除最後一個元素 // 回溯\n→ End // 程式執行結束\n\nBut this structure may not reflect typical algorithm exactly. We can also do simple recursion: at each index, add subset, then include element and recurse, then exclude and recurse. But we can choose to produce a simpler algorithm: use binary mask enumeration. But typical requirement: backtracking.\n\nSimpler: use for loop from start to n-1.\n\nPseudo:\n\nfunction backtrack(start, path):\n    add path to subsets\n    for i from start to n-1:\n        path.append(nums[i])\n        backtrack(i+1, path)\n        path.pop()\n\nWe can represent this.\n\nLet's produce virtual code accordingly.\n\nWill include `Start`, `End`. Use `Decision:` for base case.\n\nLine by line:\n\nStart // 程式開始執行\n→ Step 1: 初始化 subsets 為空集合 // 用來儲存所有子集\n→ Step 2: 定義遞迴函式 Backtrack(start, path) // start 為當前索引，path 為目前子集\n    → Step 3: 將 path 複本加入 subsets // 把目前子集加入結果\n    → Decision: start 是否大於等於 nums.length? // 檢查是否已經到達陣列結尾\n        Yes → No 行為 // 若已到末尾則不進一步遍歷\n        No  → Step 4: 從 i = start 到 nums.length-1 進行迴圈\n            → Step 5: 將 nums[i] 加入 path // 選取此元素\n                → Step 6: 呼叫 Backtrack(i+1, path) // 深入遞迴\n                → Step 7: 從 path 移除最後一個元素 // 回溯\n→ End // 程式執行結束\n\nBut we need to include the loop as a step. Use Decision: i 是否超過? but we can omit because loop structure is obvious.\n\nBut the format expects indentation maybe. Let's produce with arrow and indentation.\n\nWe'll use indentation for nested steps with spaces maybe 4 spaces.\n\nWe should maintain arrow '→' before each step. For Decision we indent.\n\nLet's produce final answer accordingly.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 subsets 為空集合 // 用來儲存所有子集\n→ Step 2: 定義遞迴函式 Backtrack(start, path) // start: 當前索引，path: 目前子集\n    → Step 3: 將 path 複本加入 subsets // 把目前子集加入結果\n    → Decision: start 是否等於 nums.length? // 檢查是否已到達陣列結尾\n        Yes → No 行為 // 若已到末尾則不再遞迴\n        No  → Step 4: 從 i = start 到 nums.length-1 進行迴圈 // 選擇下一個可能的元素\n            → Step 5: 將 nums[i] 加入 path // 將元素加入子集\n                → Step 6: 呼叫 Backtrack(i+1, path) // 深入遞迴處理剩餘元素\n                → Step 7: 從 path 移除最後一個元素 // 回溯，恢復狀態\n→ End // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph565c4dk.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmph565c4dk.py\", line 54, in main\n    args = ast.literal_eval(data[1].strip())\n                            ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from its current frequency bucket\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Insert key into the next frequency bucket\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (and LRU if tie)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    results = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            results.append(None)\n        elif op == \"get\":\n            results.append(cache.get(arg[0]))\n    # Convert None to 'null' for output\n    out_str = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, following the format. The task: design a data structure for LFU Cache. Provide pseudocode for LFUCache class: constructor, get, put. Need to implement O(1). Common approach: use hashmap for key->node, use hashmap freq->DLL of keys, and maintain minFreq. Each node holds key, value, freq. On get: if key missing return -1, else update freq: remove from old freq list, increment freq, add to new freq list, update minFreq if necessary. On put: if capacity 0 return. If key exists: update value and freq as get. Else if cache full: evict key from minFreq list's head (least recently used in that freq), remove from key map. Then insert new node with freq=1, add to freq=1 list, set minFreq=1. Provide pseudocode step by step.\n\nWe need to output line by line with arrow and explanation comments. Use arrow syntax: \"Start\", \"→ Step ...\" etc.\n\nWe should break into steps: Start, Step: Initialize data structures, etc.\n\nProbably we should produce pseudocode in a single flow covering class initialization, get, put methods, maybe separate sections for each.\n\nLet's produce a structured pseudo-code:\n\nStart\n→ Initialize LFUCache with capacity\n    Step: Set capacity\n    Step: Set size=0\n    Step: Create keyMap (key->Node)\n    Step: Create freqMap (freq->DoubleLinkedList)\n    Step: Set minFreq=0\n\n→ Function get(key)\n    Step: If key not in keyMap return -1\n    Step: node = keyMap[key]\n    Step: oldFreq = node.freq\n    Step: Remove node from freqMap[oldFreq] list\n    Step: If freqMap[oldFreq] empty and oldFreq==minFreq then minFreq++\n    Step: node.freq++\n    Step: Add node to freqMap[node.freq] list\n    Step: Return node.value\n\n→ Function put(key, value)\n    Step: If capacity==0 return\n    Step: If key exists in keyMap\n        Step: Update node.value = value\n        Step: Call get(key) to update freq (or replicate logic)\n        End if\n    Step: Else\n        Step: If size==capacity\n            Step: lfuNode = freqMap[minFreq].head\n            Step: Remove lfuNode from freqMap[minFreq]\n            Step: Remove lfuNode.key from keyMap\n            Step: size--\n        Step: Create newNode with key,value,freq=1\n        Step: Add newNode to freqMap[1]\n        Step: keyMap[key] = newNode\n        Step: minFreq = 1\n        Step: size++\nEnd\n\nAlso need double linked list operations.\n\nWe can also include pseudo code for list operations: AddNodeToTail, RemoveNode, etc. But maybe just mention them as steps.\n\nWe need to produce lines with arrow and explanation. Let's produce each step on a separate line.\n\nUse \"Start // 程式開始執行\" at top. Use \"→ Step\" for actions. Use \"Decision:\" for if. Use \"Yes →\" \"No →\".\n\nLet's structure:\n\nStart\n→ Initialize LFUCache(capacity) // store capacity, create maps, set size and minFreq\n→ Decision: capacity <= 0? // handle zero capacity\n    Yes → End // nothing to do\n    No →\n\nThen define methods.\n\nBut to keep concise, maybe separate sections for each method.\n\nOk produce.\n\nLet's begin:\n\nStart // 程式開始執行\n→ Step 1: Create LFUCache(capacity) // 初始化容量與資料結構\n→ Step 2: size ← 0 // 目前已存儲項目數量\n→ Step 3: keyMap ← {} // key -> node\n→ Step 4: freqMap ← {} // freq -> 双链表 (最近使用在尾部)\n→ Step 5: minFreq ← 0 // 最小使用頻率\n→ Step 6: Define Node(key, value, freq) // 代表快取項目\n→ Step 7: Define DoubleLinkedList // 包含 head、tail、size\n→ Step 8: DoubleLinkedList.add(node) // 將節點加入尾部\n→ Step 9: DoubleLinkedList.remove(node) // 移除指定節點\n→ Step 10: End // 初始化結束\n\nThen method get:\n\n→ Function get(key)\n    → Decision: key ∉ keyMap? // 是否存在於快取\n        Yes → Return -1 // 不存在返回 -1\n        No  → // 存在\n            → Step: node ← keyMap[key] // 取得節點\n            → Step: oldFreq ← node.freq // 取得舊頻率\n            → Step: freqMap[oldFreq].remove(node) // 從舊頻率表移除\n            → Decision: freqMap[oldFreq].size == 0 AND oldFreq == minFreq? // 是否為最小頻率且表空\n                Yes → minFreq ← minFreq + 1 // 更新最小頻率\n                No  →\n            → Step: node.freq ← node.freq + 1 // 頻率加 1\n            → Step: if freqMap[node.freq] does not exist then freqMap[node.freq] ← new DoubleLinkedList()\n            → Step: freqMap[node.freq].add(node) // 加入新頻率表\n            → Step: Return node.value // 回傳值\n    End\n\nMethod put:\n\n→ Function put(key, value)\n    → Decision: capacity == 0? // 無容量\n        Yes → Return // 無法儲存\n        No  →\n    → Decision: key ∈ keyMap? // 是否已存在\n        Yes → // 更新已存在的鍵\n            → Step: node ← keyMap[key]\n            → Step: node.value ← value // 更新值\n            → // 同時更新頻率\n            → Decision: key ∉ keyMap? // no\n                No → // 呼叫 get 以更新頻率\n                    → Step: Call get(key) // 內部會處理頻率\n            → End\n        No  → // 新增鍵\n            → Decision: size == capacity? // 是否已滿\n                Yes → // 需要淘汰\n                    → Step: lfuNode ← freqMap[minFreq].head // 最舊使用節點\n                    → Step: freqMap[minFreq].remove(lfuNode)\n                    → Step: delete keyMap[lfuNode.key]\n                    → Step: size ← size - 1\n                No  →\n            → Step: newNode ← Node(key, value, 1) // 初始頻率為 1\n            → Step: if freqMap[1] does not exist then freqMap[1] ← new DoubleLinkedList()\n            → Step: freqMap[1].add(newNode) // 加入頻率 1 列表\n            → Step: keyMap[key] ← newNode // 存入 keyMap\n            → Step: minFreq ← 1 // 重置最小頻率\n            → Step: size ← size + 1\n    End\n\nEnd // 程式結束\n\nNeed to keep arrow formatting consistent: \"→ Step\" and \"Decision:\" etc. Provide explanations after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: capacity ← given capacity // 存儲快取容量\n→ Step 2: size ← 0 // 現有項目數量\n→ Step 3: keyMap ← {} // key → node 映射\n→ Step 4: freqMap ← {} // freq → 双链表 映射\n→ Step 5: minFreq ← 0 // 最小使用頻率\n→ Step 6: Define Node(key, value, freq) // 代表快取項目的結構\n→ Step 7: Define DoubleLinkedList() with head, tail, size // 用於同頻率的最近使用排序\n→ Step 8: DoubleLinkedList.add(node) // 把節點加到尾部（最新使用）\n→ Step 9: DoubleLinkedList.remove(node) // 從列表中刪除節點\n→ End // 初始化結束\n\n→ Function get(key) // 取得鍵對應的值，若存在則更新頻率\n    → Decision: key ∉ keyMap? // 判斷鍵是否在快取中\n        Yes → Return -1 // 鍵不存在，回傳 -1\n        No  → // 鍵存在\n            → Step: node ← keyMap[key] // 取出節點\n            → Step: oldFreq ← node.freq // 取出舊頻率\n            → Step: freqMap[oldFreq].remove(node) // 從舊頻率表中移除\n            → Decision: freqMap[oldFreq].size == 0 AND oldFreq == minFreq? // 若該頻率表已空且是最小頻率\n                Yes → minFreq ← minFreq + 1 // 更新最小頻率\n                No  → // 不需要改變 minFreq\n            → Step: node.freq ← node.freq + 1 // 頻率遞增\n            → Decision: freqMap[node.freq] does not exist? // 若新頻率表尚未建立\n                Yes → freqMap[node.freq] ← new DoubleLinkedList()\n                No  →\n            → Step: freqMap[node.freq].add(node) // 加入新頻率表\n            → Step: Return node.value // 回傳值\n    End\n\n→ Function put(key, value) // 插入或更新鍵值\n    → Decision: capacity == 0? // 若容量為 0，無法儲存\n        Yes → Return\n        No  →\n    → Decision: key ∈ keyMap? // 判斷鍵是否已存在\n        Yes → // 鍵已存在，更新值並提升頻率\n            → Step: node ← keyMap[key]\n            → Step: node.value ← value // 更新數值\n            → // 直接呼叫 get 以更新頻率，保持程式一致\n            → Step: Call get(key)\n        No  → // 新鍵插入\n            → Decision: size == capacity? // 快取已滿，需淘汰\n                Yes → // 淘汰最少使用的鍵\n                    → Step: lfuNode ← freqMap[minFreq].head // 最舊使用節點\n                    → Step: freqMap[minFreq].remove(lfuNode)\n                    → Step: delete keyMap[lfuNode.key]\n                    → Step: size ← size - 1\n                No  →\n            → Step: newNode ← Node(key, value, 1) // 新節點初始頻率為 1\n            → Decision: freqMap[1] does not exist? // 若頻率 1 表不存在\n                Yes → freqMap[1] ← new DoubleLinkedList()\n                No  →\n            → Step: freqMap[1].add(newNode) // 加入頻率 1 列表\n            → Step: keyMap[key] ← newNode // 建立 key → node 映射\n            → Step: minFreq ← 1 // 重置最小頻率為 1\n            → Step: size ← size + 1\n    End\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvbyrn92s.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpvbyrn92s.py\", line 45, in main\n    obj = Solution(*args[0])  # args[0] contains the list of weights\n          ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvbyrn92s.py\", line 10, in __init__\n    for weight in w:\nTypeError: 'int' object is not iterable"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptj2ch0ek.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmptj2ch0ek.py\", line 45, in main\n    obj = Solution(*args[0])  # args[0] contains the list of weights\n          ^^^^^^^^^^^^^^^^^^\nTypeError: Solution.__init__() takes 2 positional arguments but 3 were given"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # pick a target between 1 and total inclusive\n        target = random.randint(1, self.total)\n        # find the first index whose prefix sum is >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef split_top_level(s: str):\n    \"\"\"Split a string into two parts separated by the top‑level comma.\"\"\"\n    depth = 0\n    for i, ch in enumerate(s):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            return s[:i], s[i + 1:]\n    raise ValueError(\"Input format error\")\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    part1, part2 = split_top_level(data)\n    method_names = json.loads(part1.strip())\n    method_args  = json.loads(part2.strip())\n\n    results = []\n    obj = None\n    for name, args in zip(method_names, method_args):\n        if name == \"Solution\":\n            obj = Solution(*args[0])  # args[0] contains the list of weights\n            results.append(None)\n        else:  # other methods\n            res = getattr(obj, name)(*args)\n            results.append(res)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps with explanation in Chinese (Traditional). Use arrow notation. Steps: start, preprocess to prefix sum array, total sum, random number, binary search or linear scan. Then return index. Each line with explanation.\n\nLet's craft.\n\nLines:\n\nStart\n→ Step 1: Build prefix sum array ps where ps[i] = sum_{j=0..i} w[j] // create cumulative weights\n→ Step 2: total = ps[last] // total weight\n→ Decision: Initialize random generator // maybe not a decision\nBut we can include random generation as step.\n\n→ Step 3: r = random() * total // random number in [0, total)\n→ Decision: Find smallest i such that ps[i] > r // binary search\n    Yes → Step 4: return i // chosen index\n    No → ... but binary search will always find.\n\nBut we need to include a decision block for binary search: we can do:\n\n→ Decision: Use binary search to locate index // choose index where cumulative sum exceeds random value\n    Yes → Step 4: return i // found index\n\nMaybe also fallback linear search:\n\n→ Decision: If binary search not implemented? Not needed.\n\nWe can present decision as:\n\n→ Decision: Find index i where ps[i] > r? // Determine chosen index\n    Yes → Step 4: return i\n\nWe also need to end.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 生成前綴和陣列 ps，其中 ps[i] = w[0] + w[1] + … + w[i] // 建立累積權重  \n→ Step 2: total ← ps[length(w)-1] // 計算所有權重之總和  \n→ Step 3: r ← random() × total // 產生 0 ≤ r < total 的隨機數  \n→ Decision: 找到最小的索引 i 使得 ps[i] > r // 確定對應權重區間  \n    Yes → Step 4: return i // 返回隨機選取的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,0,3]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[2,0,3]'\nRaw Got:      '[0]'"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n\n    # Normalize whitespace and newlines\n    data = data.replace('\\n', ' ').replace('\\r', ' ')\n    # Find the position of 'k ='\n    k_pos = data.find('k =')\n    if k_pos == -1:\n        k_pos = data.find('k=')\n    if k_pos == -1:\n        # Fallback: assume last token is k\n        parts = data.split()\n        k = int(parts[-1])\n        mat_part = ' '.join(parts[:-1])\n        if mat_part.startswith('mat'):\n            mat_part = mat_part[mat_part.find('=') + 1:].strip()\n        mat = ast.literal_eval(mat_part)\n    else:\n        mat_part = data[:k_pos].strip()\n        k_part = data[k_pos + 3 :].strip()  # after 'k ='\n        # Extract the matrix part\n        if mat_part.startswith('mat'):\n            mat_part = mat_part[mat_part.find('=') + 1 :].strip()\n        mat = ast.literal_eval(mat_part)\n        k = int(k_part)\n\n    result = Solution().kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. It's a typical Leetcode problem \"Weakest Rows in a Matrix\". Provide step-by-step pseudocode. Use arrows, decision, etc. We need to produce lines:\n\nStart\n→ Step: iterate rows, compute soldier count via binary search or sum\n→ Step: store (count, index)\n→ Decision: after collecting all rows, sort by count then index\n→ Step: extract first k indices\nEnd\n\nAdd explanations after each line.\n\nLet's write as per format. Use \"→\" for steps, \"Decision:\" for decision nodes. Might need loops. Use \"→ Loop: for each row\" etc. Provide detailed but concise.\n\nMake sure each line: \"虛擬碼步驟\" + space + \"// 解釋\". No actual code. Use \"Start\", \"End\". Let's generate.\n\nWe'll need to mention binary search for count, as it's efficient. Provide steps:\n\nStart\n→ Step 1: Initialize empty list rowsInfo // store tuple(count, index)\n→ Loop: i from 0 to m-1 // iterate each row\n    → Step: count = number_of_soldiers_in_row(mat[i]) // compute via binary search\n    → Step: Append (count, i) to rowsInfo // record count and index\n→ Step: Sort rowsInfo by count ascending, then index ascending // weaker rows first\n→ Step: result = [index for each of first k elements in rowsInfo] // extract indices\nEnd\n\nWe need to include \"Decision\" maybe for sorting? No, sorting is just action. For number_of_soldiers_in_row we can include a Decision: binary search until find first 0 etc.\n\nLet's craft lines:\n\nStart // 程式開始執行\n\n→ Step: rowsInfo ← empty list // 用於儲存 (兵力, 行索引)\n\n→ Loop: i ← 0 to m-1 // 逐行處理\n\n    → Decision: 是否需要 binary search? // 用 binary search 找第一個 0\n\n        Yes → Step: low ← 0, high ← n // 初始搜尋區間\n\n        → While low < high // 二分搜尋\n\n            → Step: mid ← (low + high) / 2\n\n            → Decision: mat[i][mid] == 1? // 若為 1 則兵力還在右側\n\n                Yes → low ← mid + 1 // 搜尋右半\n\n                No  → high ← mid // 搜尋左半\n\n        → Step: count ← low // low 即為兵力數\n\n        No  → Step: count ← 0 // 直接為 0\n\n    → Step: Append (count, i) to rowsInfo // 儲存\n\n→ Step: Sort rowsInfo by count ascending, then index ascending // 依兵力與索引排序\n\n→ Step: result ← empty list // 儲存最弱 k 行索引\n\n→ Loop: j ← 0 to k-1\n\n    → Step: Append rowsInfo[j].index to result // 取前 k 個\n\n→ End // 程式結束\n\nBut the decision for binary search is inside each loop; we might use simpler: count = binarySearch(mat[i]) but provide explanation.\n\nSimplify: Provide Step: count = binarySearch(mat[i]) // find number of 1's.\n\nBut need to explain binarySearch.\n\nLet's produce a final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: rowsInfo ← empty list // 用於儲存每行的 (兵力數, 行索引) 資訊\n→ Loop: i ← 0 to m-1 // 逐行處理整個矩陣\n    → Decision: 需要二分搜尋取得兵力數? // 若行中包含 1，使用二分搜尋尋找第一個 0\n        Yes → Step: low ← 0, high ← n // 初始化搜尋區間\n        → While low < high // 二分搜尋\n            → Step: mid ← (low + high) / 2 // 取中點\n            → Decision: mat[i][mid] == 1? // 若中點為 1，兵力仍在右側\n                Yes → low ← mid + 1 // 搜尋右半區間\n                No  → high ← mid // 搜尋左半區間\n        → Step: count ← low // low 為此行 1 的個數\n        No  → Step: count ← 0 // 若行全為 0，兵力為 0\n    → Step: Append (count, i) to rowsInfo // 儲存此行的兵力與索引\n→ Step: Sort rowsInfo by count ascending, then index ascending // 先按兵力再按行號排序，確保較弱的在前\n→ Step: result ← empty list // 用於儲存最弱 k 行的索引\n→ Loop: j ← 0 to k-1 // 取排序後的前 k 個\n    → Step: Append rowsInfo[j].index to result // 將行索引加入結果\nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 若任一數字為零，直接回傳 \"0\"\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        # 結果位數最多為 m + n\n        pos = [0] * (m + n)\n\n        # 從右往左遍歷兩個數字\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])          # 單位相乘\n                p1, p2 = i + j, i + j + 1                 # 位移位置\n                sum_ = mul + pos[p2]                      # 加上現有值\n\n                pos[p1] += sum_ // 10                     # 進位\n                pos[p2] = sum_ % 10                       # 記錄當前位\n\n        # 把位數轉成字串，並去掉前導零\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並從中擷取兩個整數字串\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n\n    if len(numbers) >= 2:\n        num1, num2 = numbers[0], numbers[1]\n        solution = Solution()\n        product = solution.multiply(num1, num2)\n        print(product)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Essentially multiplication of big numbers as strings. We'll provide algorithm: handle zero, reverse strings, use array for result digits, nested loops multiplication and carry. Build string. Provide each line with virtual code and comment. Use Start, End, Decision etc. Ensure each line is separate. Let's craft.\n\nWe need to follow format: \"虛擬碼步驟 [空格] // 解釋/說明\"\n\nUse arrows.\n\nLet's produce:\n\nStart // program start\n\n→ Decision: num1 == \"0\" or num2 == \"0\"? // check zero\n\n    Yes → Step 1: Return \"0\" // product is zero\n\n    No → Step 2: Reverse num1 into rev1 // reverse for easier multiplication\n\n    → Step 3: Reverse num2 into rev2 // reverse\n\n    → Step 4: Initialize array result of length rev1.length + rev2.length with zeros // to hold digits\n\n    → For i from 0 to rev1.length-1 // loop digits of first number\n\n        → For j from 0 to rev2.length-1 // loop digits of second number\n\n            → Compute mul = (digit of rev1 at i) * (digit of rev2 at j) // multiply single digits\n\n            → Add mul to result[i+j] plus current carry? Actually we will add to result[i+j] + mul\n\n            → Add carry = result[i+j] / 10 // compute new carry\n\n            → Set result[i+j] = result[i+j] % 10 // keep digit\n\n            → Add carry to result[i+j+1] // propagate\n\n    → After loops, remove leading zeros from highest index of result // trim\n\n    → Build output string by iterating result from end to start // concatenate digits\n\n    → Return output string // final product\n\nEnd // program end\n\nBut we need each line separately with arrow. We need to use \"Decision:\", \"→\", \"Yes →\", \"No →\" etc. For loops, we can use \"→ For i...\" etc. Provide explanation.\n\nWe should ensure each line has explanation comment.\n\nWe also need to mention string conversion of digits: use char - '0'.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: num1 == \"0\" 或 num2 == \"0\"? // 檢查是否有一個數字為零  \n Yes → Step 1: Return \"0\" // 若任一數字為零，直接回傳結果為零  \n No  → Step 2: Reverse num1 為 rev1 // 逆轉第一個數字方便逐位相乘  \n → Step 3: Reverse num2 為 rev2 // 逆轉第二個數字方便逐位相乘  \n → Step 4: 初始化 result 陣列，長度為 rev1.length + rev2.length，全部填 0 // 用來儲存乘積各位  \n → For i = 0 到 rev1.length-1 // 逐位遍歷第一個數字  \n  → For j = 0 到 rev2.length-1 // 逐位遍歷第二個數字  \n   → Step 5: 取出第 i 位數字 a = rev1[i] - '0'  \n   → Step 6: 取出第 j 位數字 b = rev2[j] - '0'  \n   → Step 7: 乘法結果 mul = a * b // 單位相乘  \n   → Step 8: 加入現有值：sum = result[i+j] + mul // 先加到相對位置  \n   → Step 9: 計算進位 carry = sum / 10  \n   → Step 10: 更新 result[i+j] = sum % 10 // 存下當前位數  \n   → Step 11: 加進位到下一位：result[i+j+1] += carry // 進位累加  \n → Decision: 去除 result 末尾多餘的 0? // 清除高位空洞  \n  Yes → Step 12: 從 result 最高位開始往前掃，直到遇到非零為止，記錄 index  \n   → Step 13: 建立輸出字串 output = \"\"  \n   → For k = index 到 0 // 從高位到低位  \n    → Append result[k] to output // 逐位拼接  \n → Step 14: Return output // 回傳最終乘積字串  \nEnd // 程式執行結束"
    }
  ]
}