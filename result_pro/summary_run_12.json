{
  "run_index": 12,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 392,
  "generation_or_validation_failure_count": 47,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "def main():\n    import sys\n\n    # 讀取 stdin（如果有輸入，這裡會忽略它，符合「從標準輸入讀取」的要求）\n    sys.stdin.read()\n\n    try:\n        # 以 with 語法開啟檔案，確保檔案正確關閉\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()          # 讀取所有行\n            print('檔案共有', len(lines), '行')  # 輸出行數\n    except FileNotFoundError:\n        # 檔案不存在時的處理\n        print('找不到檔案！')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use with and try/except.\n\nWe need to show step: Start, Decision: file exists? But we will open file inside try, catch FileNotFoundError. So structure: Start, → Step: try open file with with, inside try block, read lines, count, output count, except FileNotFoundError, output message, End.\n\nBut we need virtual code step per line. Let's design:\n\nStart\n→ Step 1: try\n    → Step 2: with open('data.txt', 'r') as f:  // 開啟檔案\n        → Step 3: lines = f.readlines()  // 讀取所有行\n        → Step 4: count = len(lines)  // 計算行數\n        → Step 5: print('共', count, '行')  // 輸出行數\n→ Decision: FileNotFoundError? // 是否拋出檔案不存在錯誤\n    Yes → Step 6: print('找不到檔案！')  // 顯示錯誤訊息\nEnd\n\nBut we must use \"Decision\" before except? Actually we can use Decision: if FileNotFoundError? But the error arises in try. Maybe we can structure:\n\nStart\n→ Step 1: try\n    → Step 2: with open('data.txt', 'r') as f:\n        → Step 3: lines = f.readlines()\n        → Step 4: count = len(lines)\n        → Step 5: print(f'共 {count} 行')\n→ Decision: if FileNotFoundError occurs? // 處理例外\n    Yes → Step 6: print('找不到檔案！')\nEnd\n\nBut we need to reflect try/except. Perhaps we can denote \"Decision: 如果發生 FileNotFoundError?\" after try block. Use Yes to handle.\n\nAlternatively, we can present:\n\nStart\n→ Step 1: try\n    → Step 2: with open('data.txt', 'r') as f:\n        → Step 3: lines = f.readlines()\n        → Step 4: count = len(lines)\n        → Step 5: print(f'共 {count} 行')\n→ Decision: 例外? // 是否捕捉例外\n    Yes → Step 6: print('找不到檔案！')\nEnd\n\nBut the virtual code should use \"Decision:\" format. For clarity, maybe use:\n\nStart // 程式開始\n→ Step 1: try // 開始嘗試區塊\n    → Step 2: with open('data.txt', 'r') as f: // 用 with 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print(f'共 {count} 行') // 輸出行數\n→ Decision: 是否發生 FileNotFoundError? // 檢查是否捕捉到檔案不存在的錯誤\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut we need to ensure each line contains \"虛擬碼步驟\" and comment. Also need to include \"→\" properly. The \"Decision:\" block should be indented lines.\n\nBetter to represent:\n\nStart // 程式開始\n→ Step 1: try // 嘗試執行以下程式\n    → Step 2: with open('data.txt', 'r') as f: // 開啟檔案\n        → Step 3: lines = f.readlines() // 讀取所有行\n        → Step 4: count = len(lines) // 計算行數\n        → Step 5: print(f'共 {count} 行') // 輸出行數\n→ Decision: 例外 FileNotFoundError? // 檢查是否發生檔案不存在錯誤\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut \"Decision:\" lines: we need to include \"Decision:\" preceding? Actually the example shows \"Decision: 如果數字大於 0?\" and then indent with Yes → Step etc. So we can mimic that. So we need:\n\nDecision: 例外 FileNotFoundError? // 檢查是否發生檔案不存在錯誤\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n\nBut we might want to include \"No\" branch but there is none; we can omit.\n\nBut we must ensure that after try block we go to Decision: maybe we need to close try? But we can show as:\n\n→ Decision: 例外? // if exception\n    Yes → Step 6: print('找不到檔案！')\nEnd\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: try // 嘗試執行以下程式  \n    → Step 2: with open('data.txt', 'r') as f: // 用 with 開啟檔案  \n        → Step 3: lines = f.readlines() // 讀取所有行  \n        → Step 4: count = len(lines) // 計算行數  \n        → Step 5: print(f'共 {count} 行') // 輸出行數  \n→ Decision: 是否發生 FileNotFoundError? // 檢查是否捕捉到檔案不存在錯誤  \n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,5,1,4,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 5, 1, 4, 5]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"\n    模擬擲 n 次六面骰，並回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"\n    讀取標準輸入的程式碼並執行。\n    這樣即可處理如 'print(roll_dice(5))' 之類的輸入，\n    並將結果直接輸出到標準輸出。\n    \"\"\"\n    code = sys.stdin.read()\n    if code.strip():                     # 若有輸入才執行\n        exec(code, globals())            # 執行輸入程式碼，使用全域環境\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanations. The requirement: \"請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。\"\n\nWe should produce virtual code in lines, each line: \"虛擬碼步驟 // 解釋\". Use arrow and structure: Start, End, Decision.\n\nWe need a function definition, import, loop, random.randint(1,6), append to list, return. Possibly we also need input of n, but the function receives parameter n.\n\nWe produce steps.\n\nStart // 程式開始執行\n\n→ Step 1: 導入 random 模組 // 引入隨機數生成庫\n\n→ Step 2: 定義函數 roll_dice(n) // 建立函式，接收擲骰次數\n\nWithin function:\n\n→ Step 3: 初始化 empty list results = [] // 建立空列表儲存每次擲骰結果\n\n→ Step 4: 對於 i in range(n) // 迴圈 n 次\n\nInside loop:\n\n→ Step 5: 生成隨機數 dice = random.randint(1,6) // 擲一次六面骰\n\n→ Step 6: 將 dice 加入 results // 保存結果\n\nEnd of loop\n\n→ Step 7: 回傳 results // 回傳所有結果\n\nEnd // 程式結束\n\nWe need to format lines with arrows properly. For lines inside function, maybe indent but arrow is fine. We can include nested arrows.\n\nLet's produce.\n\nAlso note that the \"Decision:\" structure may not be needed, but we can include for the loop? Usually a loop can be represented with \"Repeat\" but we can use Decision: For i in range(n)? Eh. The instructions said use arrows and structure. We can use a Decision: 迴圈? Actually we can use \"Loop:\".\n\nWe can create:\n\nStart // 程式開始執行\n→ Step 1: 導入 random 模組 // 引入隨機數生成庫\n→ Step 2: 定義函數 roll_dice(n) // 建立函式，接收擲骰次數\n    → Step 3: 初始化 empty list results = [] // 建立空列表儲存每次擲骰結果\n    → Step 4: 迴圈: i 取值於 0 到 n-1 // 為每一次擲骰進行迴圈\n        → Step 5: 生成 dice = random.randint(1,6) // 擲一次六面骰\n        → Step 6: results.append(dice) // 將結果加入列表\n    → Step 7: 回傳 results // 回傳所有結果\nEnd // 程式結束\n\nBut we need each line to have \"虛擬碼步驟\" + space + \"// 解釋\".\n\nThus each line should start with the virtual step, not nested lines? We can indent but keep arrow.\n\nBut each line's arrow may be at start: \"→\" etc.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 導入 random 模組 // 引入隨機數生成庫\n→ Step 2: 定義函數 roll_dice(n) // 建立函式，接收擲骰次數\n    → Step 3: 初始化空列表 results = [] // 建立空列表儲存每次擲骰結果\n    → Decision: 迴圈 i 在 0 到 n-1? // 迴圈控制擲骰次數\n        Yes → Step 4: 生成 dice = random.randint(1,6) // 擲一次六面骰\n        Yes → Step 5: results.append(dice) // 將結果加入列表\n    → Step 6: 回傳 results // 回傳所有結果\nEnd // 程式結束\n\nBut we need \"Yes →\" and \"No →\" but for loop we don't have No path, but we can use Decision: while i < n? No. Use Decision: 迴圈開始? No. Might be better to use a simple \"Loop:\" line.\n\nBut guidelines didn't forbid loop, but used arrow. They said use arrow (→, Yes →, No →) and structure (Start, End, Decision:). No mention of Loop: but we can use Decision for loop? Eh.\n\nWe can simply write:\n\n→ Step 4: 對於 i in range(n) // 迴圈 n 次\n\nBut \"對於\" maybe not necessary but okay.\n\nBetter: \"→ Step 4: 迴圈: for i in range(n) // 執行 n 次擲骰\"\n\nBut still need explanation.\n\nThus:\n\n→ Step 4: 迴圈: for i in range(n) // 為每一次擲骰進行迴圈\n\nInside loop:\n\n→ Step 5: 生成 dice = random.randint(1,6) // 擲一次六面骰\n\n→ Step 6: results.append(dice) // 將結果加入列表\n\nBut we need to maintain line numbers? No.\n\nLet's produce final output lines:\n\nStart // 程式開始執行\n→ Step 1: 導入 random 模組 // 引入隨機數生成庫\n→ Step 2: 定義函數 roll_dice(n) // 建立函式，接收擲骰次數\n    → Step 3: 初始化空列表 results = [] // 建立空列表儲存每次擲骰結果\n    → Step 4: 迴圈: for i in range(n) // 為每一次擲骰進行迴圈\n        → Step 5: 生成 dice = random.randint(1,6) // 擲一次六面骰\n        → Step 6: results.append(dice) // 將結果加入列表\n    → Step 7: 回傳 results // 回傳所有結果\nEnd // 程式結束\n\nBut indent lines may not be necessary; each line should start with arrow, but we have indentation to show inside function. The guidelines didn't specify indentation, but we can use spaces for readability. It's okay.\n\nMake sure each line ends with comment after //.\n\nThus produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 random 模組 // 引入隨機數生成庫  \n→ Step 2: 定義函數 roll_dice(n) // 建立函式，接收擲骰次數  \n    → Step 3: 初始化空列表 results = [] // 建立空列表儲存每次擲骰結果  \n    → Step 4: 迴圈: for i in range(n) // 為每一次擲骰進行迴圈  \n        → Step 5: 生成 dice = random.randint(1,6) // 擲一次六面骰  \n        → Step 6: results.append(dice) // 將結果加入列表  \n    → Step 7: 回傳 results // 回傳所有結果  \nEnd // 程式結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需的秒數，並四捨五入到小數點 3 位。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整段程式碼並執行\n    source = sys.stdin.read()\n    exec(source, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code with arrows and explanation. Format: each line: virtual code step + space + // explanation. Use Start, End, Decision: etc.\n\nWe need a function measure_time(func, *args). Steps: start, record start time, call func with args, record end time, compute elapsed, round to 3 decimals, return result. Also return the function's result? Problem: \"回傳結果 (四捨五入到小數點 3 位)\" – ambiguous whether return time or function output. Likely return time. But maybe return time and result? Let's assume return elapsed time.\n\nWe'll include import time.\n\nSteps:\n\nStart\n→ Step 1: Import time module // include time\n→ Step 2: Define function measure_time(func, *args) // function header\n→ Step 3: Record start = time.time() // start timestamp\n→ Step 4: Call result = func(*args) // execute function\n→ Step 5: Record end = time.time() // end timestamp\n→ Step 6: Compute elapsed = end - start // duration\n→ Step 7: Round elapsed_rounded = round(elapsed, 3) // round\n→ Step 8: Return elapsed_rounded // return duration\nEnd\n\nWe can include decision? None needed. Maybe decision: if func throws error? Not needed.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 載入 time 模組以使用時間函式  \n→ Step 2: Define function measure_time(func, *args) // 定義 measure_time 函數，接受任意參數  \n→ Step 3: Record start = time.time() // 取得執行開始時的秒數  \n→ Step 4: Call result = func(*args) // 執行傳入的函式，傳遞所有參數  \n→ Step 5: Record end = time.time() // 取得執行結束時的秒數  \n→ Step 6: Compute elapsed = end - start // 計算耗時（秒）  \n→ Step 7: Round elapsed_rounded = round(elapsed, 3) // 將耗時四捨五入到小數點 3 位  \n→ Step 8: Return elapsed_rounded // 回傳四捨五入後的耗時  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"melon\",\"orange\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'melon', 'orange', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略所有輸入\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增單一元素\n    fruits.add('orange')\n\n    # 一次新增多個元素\n    fruits.update(['grape', 'melon'])\n\n    # 移除指定元素\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的元素，無錯誤\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate a virtual code line by line, each line with arrow and comment. Use Start, End, Decision? Not necessary. Just steps. Provide virtual steps with explanations. Use Chinese. Each line: `虛擬碼步驟 // 解釋`. Use arrow `→`. Format: `Start // 程式開始執行`. Then each step. We'll use `→` for each step. Use `Step 1:` etc. Use `End`.\n\nMake sure no actual code, just virtual code. Use sets concept. We'll create `fruits = {'apple', 'banana'}` then operations. Let's produce:\n\nStart\n→ Step 1: 初始化集合 fruits 包含 'apple' 與 'banana' // 建立起始集合\n→ Step 2: 呼叫 add() 將 'orange' 加入 fruits // 新增單一元素\n→ Step 3: 呼叫 update() 加入 'grape' 與 'melon' // 一次新增多個元素\n→ Step 4: 呼叫 remove() 刪除 'banana' // 移除指定元素\n→ Step 5: 呼叫 discard() 嘗試移除 'pineapple' // 不存在元素不會錯誤\n→ Step 6: 輸出 fruits 集合 // 顯示最終集合\nEnd\n\nBut each line must be exactly \"虛擬碼步驟 // 解釋\". Use arrow.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化集合 fruits 包含 'apple' 與 'banana' // 建立起始集合  \n→ Step 2: 呼叫 add() 將 'orange' 加入 fruits // 新增單一元素  \n→ Step 3: 呼叫 update() 加入 'grape' 與 'melon' // 一次新增多個元素  \n→ Step 4: 呼叫 remove() 刪除 'banana' // 移除指定元素  \n→ Step 5: 呼叫 discard() 嘗試移除 'pineapple' // 不存在元素不會錯誤  \n→ Step 6: 輸出 fruits 集合 // 顯示最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\n# ------------------------ 取得匯率 ------------------------\ndef fetch_rate() -> float:\n    \"\"\"\n    連接匯率 API 取得美元兌台幣的匯率\n    回傳匯率值；失敗時拋出例外\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()  # 若 HTTP 狀態碼不是 200，拋出例外\n    data = response.json()\n    return float(data[\"rates\"][\"TWD\"])\n\n# ------------------------ GUI 組件 ------------------------\ndef create_gui():\n    \"\"\"\n    建立 tkinter 視窗，包含顯示匯率與更新按鈕\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    # 標籤：顯示目前匯率或提示訊息\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    # 更新匯率函式，更新標籤文字\n    def update_rate():\n        try:\n            rate = fetch_rate()\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        except Exception:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    # 按鈕：按下時呼叫 update_rate\n    btn = tk.Button(win, text=\"更新匯率\", command=update_rate)\n    btn.pack(pady=5)\n\n    return win\n\n# ------------------------ 主程式入口 ------------------------\nif __name__ == \"__main__\":\n    # 從標準輸入讀取指令字串\n    command = sys.stdin.read().strip()\n\n    # 如果指令包含「更新匯率」，即使不啟動 GUI 也直接輸出匯率\n    if \"更新匯率\" in command:\n        try:\n            rate = fetch_rate()\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        except Exception:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 其他情況仍啟動 GUI\n        pass\n\n    # 啟動 tkinter GUI\n    window = create_gui()\n    window.mainloop()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Steps: Start, import modules, define function fetch_rate, create Tk window, label, button, button command to update, main loop. Use decision? maybe error handling? Use Decision: 若無法取得? Yes → error label else update. Use arrow. Ensure each line has \"虛擬碼步驟 [space] // 解釋\". Use virtual code arrow like \"→\". We'll include Start and End.\n\nLet's craft:\n\nStart\n→ Import requests and tkinter modules // 導入所需模組\n→ 定義函式 fetch_rate() // 用於呼叫 API 並返回 TWD 匯率\n    → Step: 送出 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率資料\n    → Decision: 如果回應狀態為 200? // 檢查請求是否成功\n        Yes → Parse JSON and 提取 rates.TWD // 解析 JSON 並取得台幣匯率\n        No  → Return None // 失敗時回傳 None\n→ 建立 Tkinter 視窗 root // 建立主視窗\n→ 建立 Label lbl_rate 文字 '匯率待更新' // 顯示匯率文字\n→ 建立 Button btn_update 文字 '更新匯率' // 按鈕\n    → Button command: \n        → Step: rate = fetch_rate() // 取得匯率\n        → Decision: 如果 rate 不是 None? // 匯率取得成功？\n            Yes → 更新 lbl_rate 文字為 '1 USD = rate TWD' // 顯示匯率\n            No  → 更新 lbl_rate 文字為 '無法取得匯率' // 顯示錯誤\n→ 佈局 lbl_rate 和 btn_update // 放置元件\n→ 執行 mainloop // 啟動事件循環\nEnd\n\nNeed to use arrow for each step, maybe indent decision lines. Use \"→ Decision:\" lines with indentation.\n\nMake sure each line has virtual code step and comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests and tkinter modules // 導入所需的網路與 GUI 模組  \n\n→ 定義函式 fetch_rate() // 建立取得匯率的功能  \n → Step: 送出 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 取得最新美元匯率資料  \n → Decision: 如果回應狀態為 200? // 檢查請求是否成功  \n  Yes → Step: 解析 JSON 並取得 rates.TWD // 從回應中提取台幣匯率  \n  No  → Step: Return None // 失敗時回傳 None  \n\n→ 建立 Tkinter 視窗 root // 建立主視窗  \n→ 建立 Label lbl_rate 文字 '匯率待更新' // 顯示匯率文字  \n→ 建立 Button btn_update 文字 '更新匯率' // 按鈕  \n\n → Button command:  \n  → Step: rate = fetch_rate() // 取得匯率  \n  → Decision: 如果 rate 不是 None? // 匯率取得成功？  \n   Yes → Step: 更新 lbl_rate 文字為 '1 USD = ' + rate + ' TWD' // 顯示匯率  \n   No  → Step: 更新 lbl_rate 文字為 '無法取得匯率' // 顯示錯誤訊息  \n\n→ 佈局 lbl_rate 和 btn_update // 放置元件於視窗  \n→ 執行 mainloop // 啟動事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe9a0zwb8.py\", line 42, in <module>\n    args = json.loads('[' + match.group(2) + ']')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 4 (char 3)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport re\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析格式: [\"op1\",\"op2\",...], [arg1, arg2, ...]\n    match = re.match(r'\\s*\\[(.*?)\\]\\s*,\\s*\\[(.*?)\\]\\s*', data, re.S)\n    if not match:\n        sys.exit()\n    ops = json.loads('[' + match.group(1) + ']')\n    args = json.loads('[' + match.group(2) + ']')\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)            # None -> null in JSON\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n\n    # 輸出結果，使用 JSON 以得到 null 而不是 None\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for implementing RandomizedSet with average O(1) operations: using hash map and array list. We'll write step-by-step pseudo code for methods: constructor, insert, remove, getRandom. Each line with explanation. Use arrow notation.\n\nWe need to output in Chinese. The code steps should represent algorithmic logic.\n\nWe will start with Start, then step for initialization, then method insert steps: check if val present in map, if not add to list and map. return true/false. Similarly remove: check, if present swap with last element in list, update map, pop, delete. getRandom: generate random index, return element.\n\nWe must use pseudo-code lines with arrow. Let's format:\n\nStart\n→ Step 1: 定義 RandomizedSet // 定義類別\n→ Step 2: 成員變數: list, map // list 儲存元素，map 儲存元素到索引\n→ Step 3: Constructor() // 初始化\n    → list ← 空列表 // 空列表\n    → map ← 空映射 // 空 hash map\n→ Step 4: Method insert(val)\n    → Decision: 如果 val 在 map? // 檢查是否已存在\n        Yes → Return False // 已存在，返回 false\n        No  → Append val 到 list // 新增元素\n             map[val] ← list.size - 1 // 將索引存入 map\n             Return True // 成功插入\n→ Step 5: Method remove(val)\n    → Decision: 如果 val 在 map? // 檢查是否存在\n        No  → Return False // 不存在，返回 false\n        Yes → lastVal ← list.last() // 取得最後一個元素\n              idx ← map[val] // 目標元素索引\n              list[idx] ← lastVal // 將最後元素移到目標位置\n              map[lastVal] ← idx // 更新最後元素的索引\n              list.pop() // 移除最後一個元素\n              map.delete(val) // 刪除目標元素的映射\n              Return True // 成功移除\n→ Step 6: Method getRandom()\n    → randIdx ← Random(0, list.size-1) // 隨機索引\n    → Return list[randIdx] // 回傳隨機元素\nEnd\n\nWe need to output each line with `虛擬碼步驟` + `// 解釋`. The lines must start with arrow or Start.\n\nWe need to ensure each line is separate. Use indentation for decisions. We'll produce lines accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedSet // 宣告類別  \n→ Step 2: 成員變數: list, map // list 儲存元素，map 儲存元素對應的索引  \n\n→ Step 3: Constructor() // 初始化方法  \n    → list ← 空列表 // 建立空動態陣列  \n    → map ← 空映射 // 建立空 hash map  \n\n→ Step 4: Method insert(val) // 插入函式  \n    → Decision: 是否存在 val 在 map? // 檢查 val 是否已存在  \n        Yes → Return False // 已存在，回傳 false  \n        No  → Append val 到 list // 新增 val 至陣列末尾  \n             map[val] ← list.size - 1 // 存入 val 的索引  \n             Return True // 成功插入，回傳 true  \n\n→ Step 5: Method remove(val) // 刪除函式  \n    → Decision: 是否存在 val 在 map? // 檢查 val 是否存在  \n        No  → Return False // 不存在，回傳 false  \n        Yes → lastVal ← list.last() // 取得最後一個元素  \n              idx ← map[val] // 目標元素索引  \n              list[idx] ← lastVal // 把最後一個元素放到目標位置  \n              map[lastVal] ← idx // 更新最後元素的索引  \n              list.pop() // 移除陣列最後一個元素  \n              map.delete(val) // 刪除 val 的映射  \n              Return True // 成功刪除，回傳 true  \n\n→ Step 6: Method getRandom() // 取得隨機元素  \n    → randIdx ← Random(0, list.size-1) // 產生 0~size-1 的隨機索引  \n    → Return list[randIdx] // 回傳隨機索引位置的元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[0,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1,0], [0,0], [2,0], null, [2,0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef serialize(res_list):\n    out = '['\n    for i, val in enumerate(res_list):\n        if i:\n            out += ', '\n        if val is None:\n            out += 'null'\n        elif isinstance(val, list):\n            out += '[' + ','.join(str(v) for v in val) + ']'\n        else:\n            out += str(val)\n    out += ']'\n    return out\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Wrap the input so that it becomes a valid JSON list of two elements\n    data = '[' + data + ']'\n    calls, params = json.loads(data)\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(calls, params):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        elif cmd == \"flip\":\n            results.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            results.append(None)\n\n    print(serialize(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanation. Must not output real code. Provide steps for algorithm: Use reservoir-like method: maintain list of available indices as linear mapping. Use array mapping for \"swapping\" technique: maintain mapping from 0..m*n-1 to actual index. Keep count of remaining zeros. flip picks random k < remaining, maps to actual index using mapping or identity, then decrement remaining, and if mapping exists for k store mapping[remaining]=mapping[k] or identity. For reset, reinitialize mapping and remaining. Also need to output row and column from index. Use integer division and modulus. Also need to initialize mapping. For initialization: create empty map (dictionary). For m and n store. For flip: pick rand between 0 and remaining-1, then map. Then update. Also need to convert linear index to row and col: i = idx / n, j = idx % n.\n\nWe need to express steps line by line. For each line include \"虛擬碼步驟\" and \"// 解釋/說明\". Use arrows for flow.\n\nWe need to include Start, End. Provide Decision nodes where needed. Provide mapping logic.\n\nLet's produce the virtual code.\n\nPossible structure:\n\nStart\n→ Step: Initialize variables m, n, remaining = m*n, map = empty dictionary // store mapping of indices\n→ Step: reset() // reset all to 0\n→ Step: flip() // return random zero index\n    → Decision: remaining == 0? // no zeros left\n        Yes → Step: raise exception or return null // no available indices\n        No  → Step: k = random integer in [0, remaining-1] // pick random index among remaining zeros\n              // map linear index to actual\n              → Step: idx = map.get(k, k) // use mapping if exists else k\n              → Step: map[k] = map.get(remaining-1, remaining-1) // replace k with last available\n              → Step: decrement remaining\n              → Step: i = idx // n\n              → Step: j = idx % n\n              → Step: return [i, j]\n→ Step: reset() // reinitialize mapping and remaining\nEnd\n\nBut must show each step line separately.\n\nLet's produce step by step.\n\nWe'll use syntax like:\n\nStart // 程式開始執行\n→ Step 1: m ← input m // 存儲行數\n→ Step 2: n ← input n // 存儲列數\n→ Step 3: total ← m * n // 計算總格數\n→ Step 4: remaining ← total // 剩餘可被翻轉的格數\n→ Step 5: map ← empty dictionary // 建立映射表\n→ Step 6: reset() // 初始化矩陣\n\nReset function steps:\n→ Step 7: map.clear() // 清空映射\n→ Step 8: remaining ← total // 重置剩餘格數\n\nFlip function steps:\n→ Step 9: if remaining == 0 → raise error // 無可翻轉格\n→ Step 10: k ← random integer between 0 and remaining-1 // 隨機選擇剩餘格\n→ Step 11: idx ← map.get(k, k) // 取得實際線性索引\n→ Step 12: map[k] ← map.get(remaining-1, remaining-1) // 把最終索引放到 k 號\n→ Step 13: remaining ← remaining - 1 // 更新剩餘格數\n→ Step 14: i ← idx // n // 計算行\n→ Step 15: j ← idx % n // 計算列\n→ Step 16: return [i, j] // 回傳座標\n\nReturn to main.\n\nEnd\n\nNeed to maintain proper indentation for Decision? Provide Decision for remaining==0. Use Decision: remaining == 0? Yes → Step 9a: return error, No → rest.\n\nLet's format accordingly. Use \"Decision:\" line. Each line must have \"虛擬碼步驟\" then space then comment. So we need to include \"Decision:\" and arrow lines.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: m ← input m // 存儲矩陣的行數  \n→ Step 2: n ← input n // 存儲矩陣的列數  \n→ Step 3: total ← m * n // 計算總格數  \n→ Step 4: remaining ← total // 初始化剩餘可翻轉的格數  \n→ Step 5: map ← empty dictionary // 建立線性索引到實際索引的映射表  \n→ Step 6: reset() // 先將矩陣重設為全 0  \n\nreset() // 重置所有格子為 0  \n→ Step 7: map.clear() // 清空映射表  \n→ Step 8: remaining ← total // 將剩餘格數重新設為總格數  \n\nflip() // 隨機返回一個仍為 0 的索引並將其翻轉為 1  \n→ Decision: remaining == 0? // 是否還有可翻轉的格子？  \n    Yes → Step 9a: raise exception // 沒有可翻轉格子，拋出錯誤  \n    No  → Step 9b: k ← random integer in [0, remaining-1] // 從剩餘格子中隨機選一個  \n→ Step 10: idx ← map.get(k, k) // 取得實際線性索引（若已映射則取映射值）  \n→ Step 11: map[k] ← map.get(remaining-1, remaining-1) // 把最後一個可用索引放到 k 的位置  \n→ Step 12: remaining ← remaining - 1 // 更新剩餘格數  \n→ Step 13: i ← idx // n // 計算行號  \n→ Step 14: j ← idx % n // 計算列號  \n→ Step 15: return [i, j] // 回傳翻轉後的座標  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbyb19er_.py\", line 26, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbyb19er_.py\", line 13, in __init__\n    self.lookup[(prefix, suffix)] = idx\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        self.lookup = {}\n        for idx, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                prefix = word[:i]\n                for j in range(L + 1):\n                    suffix = word[j:]\n                    self.lookup[(prefix, suffix)] = idx\n\n    def f(self, prefix, suffix):\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 將輸入包裝成元組形式，方便一次解析\n    data = f\"({data})\"\n    words, query = ast.literal_eval(data)\n    pref, suff = query\n    wf = WordFilter(words)\n    print(wf.f(pref, suff))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step to design special dictionary with prefix and suffix search. Use data structures. Likely use Trie for prefixes and suffixes. But we can use combined prefix-suffix trie with combined key pref#suff. But easier: for each word index, add all possible prefixes and suffixes pairs into a hash map mapping (prefix + \"#\" + suffix) to index. But that would be O(n * L^2). Another approach: use trie for prefixes and store indices. For suffix, we can reverse words and use suffix trie. For f, we need to find all words with given prefix and suffix. We could traverse prefix trie to get list of indices, and suffix trie (reverse) to get list, then intersect. But we need largest index. Instead, we can precompute mapping from prefix to list of indices sorted descending, and from suffix to list sorted descending. Then f: get listA, listB, iterate from largest index, check if in both sets. Or maintain combined map: For each word index i, for each prefix p of word, for each suffix s of word, set map[p#s] = i (overwriting ensures largest index). But this is too large. Usually solution uses Trie where each node stores list of indices sorted descending. Then f uses prefix trie to get node for pref, and for each suffix suffix reversed? Actually typical LeetCode 745 Word Filter problem uses Trie with combined key pref + \"#\" + suff. The solution builds a trie for all words reversed with '#' + word inserted. Then f traverses combined string. That is okay.\n\nBut we just need virtual code steps, not actual code. So produce steps: Initialize TrieNode with children map and weight(index). Build trie: For each word with index i, create combined string pref + \"#\" + suff for all possible pref and suff? Actually typical solution: For each word with index i, we insert into trie all suffixes of word prefixed with word reversed? Wait: The typical solution for Word Filter uses a trie where each node stores the highest index of words that have the prefix of the inserted string. For each word, we insert all suffixes of word followed by '#' and then the whole word. That way, a query with prefix pref and suffix suff can be answered by searching for suff + \"#\" + pref in the trie. But our problem may be similar but simpler: prefix search + suffix search. We can just build two tries: prefix trie with list of indices, suffix trie (reverse) similarly. But for f, we need intersection. We can use two lists and find max index common. We can precompute for each word index its set of prefixes and suffixes. But intersection each time may be heavy.\n\nBut as virtual code, we can outline approach: Build prefix trie, each node stores list of indices descending. Build suffix trie (reverse). For f: traverse prefix trie to node for pref, get listA. Traverse suffix trie to node for reversed suff, get listB. Then use two-pointer to find max common index. Complexity O(len(pref)+len(suff)+k). That is acceptable.\n\nWe'll produce virtual code lines.\n\nNeed to produce step-by-step algorithm:\n\n- Define TrieNode structure: children dict, indices list (descending).\n- WordFilter constructor: create rootPrefix, rootSuffix. For each word with index i:\n  - Insert into prefix trie: for each character in word, create child, append index to node.indices list (ensure descending).\n  - Insert into suffix trie: traverse reversed word similarly, but reversed order. Append index.\n- f function: \n  - Find node in prefix trie by traversing pref; if node not found return -1; else listA.\n  - Find node in suffix trie by traversing reversed suff; if not found return -1; else listB.\n  - Two-pointer from start of listA and listB (both sorted descending), find common index: if listA[idxA]==listB[idxB] return it; else advance the pointer with larger index.\n  - If none found return -1.\n\nThis is straightforward.\n\nWe need to output virtual code lines with explanation. Use arrow style.\n\nLet's produce.\n\nWe'll need to use indentation for decision branches.\n\nProbably no loops for building? We'll just outline.\n\nOk produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Define TrieNode // 建立 Trie 節點結構\n    → children: Map<Char, TrieNode> // 子節點字典\n    → indices: List<Int> // 以降序存放所有經過此節點的單字索引\nEnd // TrieNode 定義完成\n\n→ Define WordFilter // WordFilter 類別\n    → rootPref: TrieNode // 前綴 Trie 根節點\n    → rootSuff: TrieNode // 後綴 Trie 根節點\n    → Constructor(words: Array<String>) // 建構子\n        → For each (word, index) in words // 遍歷單字與其索引\n            → // 插入前綴 Trie\n            → curr = rootPref\n            → For each char c in word // 從左到右\n                → If curr.children[c] is null → create new TrieNode\n                → curr = curr.children[c]\n                → curr.indices.append(index) // 加入索引\n            → // 插入後綴 Trie（使用逆序單字）\n            → curr = rootSuff\n            → For each char c in reverse(word) // 從右到左\n                → If curr.children[c] is null → create new TrieNode\n                → curr = curr.children[c]\n                → curr.indices.append(index) // 加入索引\n        → End For\n    → f(pref: String, suff: String): Int // 查詢函式\n        → // 取得前綴節點\n        → nodePref = rootPref\n        → For each char c in pref\n            → If nodePref.children[c] is null → return -1\n            → nodePref = nodePref.children[c]\n        → listA = nodePref.indices // 以降序排列\n        → // 取得後綴節點（逆序搜尋）\n        → nodeSuff = rootSuff\n        → For each char c in reverse(suff)\n            → If nodeSuff.children[c] is null → return -1\n            → nodeSuff = nodeSuff.children[c]\n        → listB = nodeSuff.indices // 以降序排列\n        → // 兩指標尋找最大共同索引\n        → i = 0; j = 0\n        → While i < listA.size AND j < listB.size\n            → If listA[i] == listB[j] → return listA[i] // 取得最大索引\n            → Else if listA[i] > listB[j] → i++ // listA 较大，向下移動\n            → Else → j++ // listB 较大，向下移動\n        → End While\n        → return -1 // 沒有符合條件的單字\n    → End f\nEnd // WordFilter 定義完成\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb2r8r3za.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmpb2r8r3za.py\", line 44, in main\n    ops = json.loads(ops_str)\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 12 (char 11)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    \"\"\"最小值堆疊，支持 O(1) push/pop/top/getMin\"\"\"\n\n    def __init__(self):\n        self.stack = []        # 主堆疊\n        self.min_stack = []    # 儲存最小值的堆疊\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        # 若最小堆疊為空或新值更小，則把它存進 min_stack\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -> None:\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        # 若彈出的值正好是最小值，則同步彈出 min_stack\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\ndef main() -> None:\n    \"\"\"主函式：讀取標準輸入、執行指令、輸出結果\"\"\"\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 輸入格式為兩個 JSON 陣列，中間用逗號分隔\n    ops_str, args_str = data.split(',', 1)\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    results = []\n    stack = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            stack = MinStack()\n            results.append(None)\n        elif op == \"push\":\n            # arg 為單個元素的列表，例如 [-2]\n            stack.push(arg[0] if isinstance(arg, list) else arg)\n            results.append(None)\n        elif op == \"pop\":\n            stack.pop()\n            results.append(None)\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"getMin\":\n            results.append(stack.getMin())\n        else:\n            # 任何未知操作都忽略\n            results.append(None)\n\n    # 將 None 轉成 JSON 的 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a MinStack supporting push/pop/top/getMin in O(1). Need to output line by line with \"→\" arrows and explanations. Should be a structured flowchart style pseudocode. We'll start with Start, then initialize two stacks: data stack and min stack. Then define push, pop, top, getMin. Use decisions if necessary. We'll represent each method as separate sub-blocks. We'll show steps inside each method. Use arrows and explanation. Avoid actual code. Provide all steps.\n\nLet's produce.\n\nAlso need to include Decision: for min comparisons.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的主堆疊 mainStack // 用於存儲所有進入的元素  \n→ Step 2: 建立空的最小堆疊 minStack   // 用於同時追蹤最小值  \n\n// ---------- Push 方法 ----------\n→ Step 3: Function push(val) // 推入新元素  \n → Step 4: Push val 到 mainStack // 主堆疊加入元素  \n → Decision: 是否 minStack 為空?  \n  Yes → Step 5: Push val 到 minStack // 第一次進入時，最小值即為 val  \n  No  → Step 6: 取得 minStack.top() 為 currentMin // 取得目前最小值  \n   → Decision: val 小於 currentMin?  \n    Yes → Step 7: Push val 到 minStack // 新值更小，更新最小值堆疊  \n    No  → Step 8: Push currentMin 到 minStack // 保持最小值不變，重複存入  \n\n// ---------- Pop 方法 ----------\n→ Step 9: Function pop() // 移除頂部元素  \n → Decision: mainStack 是否為空?  \n  Yes → Step 10: Error // 空堆疊不能 pop  \n  No  → Step 11: Pop mainStack.top() // 主堆疊移除元素  \n    Pop minStack.top() // 同時移除對應的最小值\n\n// ---------- Top 方法 ----------\n→ Step 12: Function top() // 回傳頂部元素  \n → Decision: mainStack 是否為空?  \n  Yes → Step 13: Error // 空堆疊無頂部  \n  No  → Step 14: Return mainStack.top() // 取得主堆疊頂部值\n\n// ---------- GetMin 方法 ----------\n→ Step 15: Function getMin() // 取得最小值  \n → Decision: minStack 是否為空?  \n  Yes → Step 16: Error // 空堆疊無最小值  \n  No  → Step 17: Return minStack.top() // 取得最小堆疊頂部，即全局最小值\n\nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb1t2dsx_.py\", line 36, in parse_input\n    data = eval(f\"{{{input_str}}}\")\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpb1t2dsx_.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpb1t2dsx_.py\", line 49, in main\n    begin_word, end_word, word_list = parse_input(raw_input)\n                                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpb1t2dsx_.py\", line 38, in parse_input\n    raise ValueError(f\"Invalid input format: {e}\")\nValueError: Invalid input format: invalid syntax. Maybe you meant '==' or ':=' instead of '='? (<string>, line 1)"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc2r0oe3t.py\", line 36, in parse_input\n    data = eval(f\"{{{input_str}}}\")\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpc2r0oe3t.py\", line 54, in <module>\n    main()\n  File \"/tmp/tmpc2r0oe3t.py\", line 49, in main\n    begin_word, end_word, word_list = parse_input(raw_input)\n                                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpc2r0oe3t.py\", line 38, in parse_input\n    raise ValueError(f\"Invalid input format: {e}\")\nValueError: Invalid input format: invalid syntax. Maybe you meant '==' or ':=' instead of '='? (<string>, line 1)"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\ndef ladder_length(begin_word: str, end_word: str, word_list: list) -> int:\n    \"\"\"Return length of shortest transformation sequence from begin_word to end_word.\"\"\"\n    word_set = set(word_list)\n    if end_word not in word_set:\n        return 0\n\n    queue = deque([(begin_word, 1)])  # (current_word, path_length)\n    visited = {begin_word}\n\n    while queue:\n        word, length = queue.popleft()\n        if word == end_word:\n            return length\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == word[i]:\n                    continue\n                new_word = word[:i] + c + word[i+1:]\n                if new_word in word_set and new_word not in visited:\n                    visited.add(new_word)\n                    queue.append((new_word, length + 1))\n    return 0\n\ndef parse_input(input_str: str):\n    \"\"\"Parse input string of the form:\n       beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\"]\n    and return (beginWord, endWord, wordList).\"\"\"\n    # Wrap with braces to make a dict literal\n    input_str = input_str.strip()\n    if not input_str:\n        return None, None, None\n    try:\n        data = eval(f\"{{{input_str}}}\")\n    except Exception as e:\n        raise ValueError(f\"Invalid input format: {e}\")\n    begin_word = data.get(\"beginWord\") or data.get(\"beginWord =\") or data.get(\"beginWord\")\n    end_word = data.get(\"endWord\") or data.get(\"endWord =\") or data.get(\"endWord\")\n    word_list = data.get(\"wordList\") or data.get(\"wordList =\") or data.get(\"wordList\")\n    # In case keys are missing due to eval quirks\n    if begin_word is None or end_word is None or word_list is None:\n        raise ValueError(\"Missing required keys in input.\")\n    return begin_word, end_word, word_list\n\ndef main():\n    raw_input = sys.stdin.read()\n    begin_word, end_word, word_list = parse_input(raw_input)\n    result = ladder_length(begin_word, end_word, word_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo-code) step-by-step for algorithm: find length of shortest transformation sequence from beginWord to endWord using wordList, each step changes one letter, words must be in wordList except beginWord. Return length of shortest path (number of words including beginWord and endWord). Classic Word Ladder problem solved by BFS. Virtual code lines with explanation. Ensure no actual code. Use Start, End, Decision, etc. We must include arrow lines. Provide one line per step. Need to reflect BFS, visited set, queue, level count. Let's produce.\n\nWe will produce lines: Start, Step 1: check if endWord in wordList else return 0. Step 2: create set wordSet from wordList. Step 3: create queue with beginWord, level=1. Step 4: visited set. Step 5: BFS loop while queue not empty: dequeue word, level = queueLevel. For each position in word, for each char a-z, generate newWord. If newWord equals endWord: return level+1. If newWord in wordSet and not visited: add to queue with level+1, mark visited. After loop, return 0.\n\nUse arrows accordingly. Let's format.\n\nWe need arrow syntax: \"→\" preceding each line after Start? Example in sample: \"→ Step 1: ...\" and nested decisions with indentation. We'll mimic that.\n\nWill also use \"Decision:\" for condition checks. Use \"Yes →\", \"No →\".\n\nLet's produce. Ensure explanation after //.\n\nLet's write:\n\nStart // 程式開始執行\n→ Decision: 是否 endWord 在 wordList? // 檢查目標字是否存在於字典\n    Yes → Step 1: 將 wordList 轉為 set wordSet // 建立 O(1) 查詢字典\n    No  → Step 2: 回傳 0 // 無法達成轉換\n→ Step 3: 初始化 BFS: queue = [(beginWord, 1)], visited = {beginWord} // 以 (字, 級別) 方式存入\n→ Decision: queue 是否為空? // 檢查是否還有字可處理\n    No  → Step 4: 取出首個元素 (word, level) ← queue.pop(0) // 取得目前字與深度\n    Yes → Step 5: 回傳 0 // 無法達成轉換\n→ Step 6: 迴圈 for i from 0 to len(word)-1: // 遍歷字母位置\n→ Step 7: 迴圈 for ch in 'a'..'z': // 嘗試所有可能字母\n→ Decision: ch 是否等於 word[i]? // 檢查是否需要改變\n        Yes → Continue // 跳過同字母\n        No  → Step 8: newWord ← word[0:i] + ch + word[i+1:] // 產生新的字\n→ Decision: newWord 是否等於 endWord? // 檢查是否到達目標\n            Yes → Step 9: 回傳 level + 1 // 找到最短路徑長度\n            No  → Decision: newWord 是否在 wordSet 且 未訪問? // 檢查是否合法且未處理\n                Yes → Step 10: 將 (newWord, level+1) 加入 queue // 進一步 BFS\n                        → visited.add(newWord) // 標記已訪問\n                No  → Continue // 忽略不合法或已訪問的字\n→ End // 程式執行結束\n\nNeed to ensure indentation for nested decisions. Use \"→\" for each line. The sample used indentation for nested lines: \"→ Decision: ...\" then \"    Yes → Step 2:\" etc. We'll mimic.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 是否 endWord 在 wordList? // 檢查目標字是否存在於字典  \n  Yes → Step 1: 將 wordList 轉為 set wordSet // 建立 O(1) 查詢字典  \n  No  → Step 2: 回傳 0 // 無法達成轉換  \n→ Step 3: 初始化 BFS: queue = [(beginWord, 1)], visited = {beginWord} // 以 (字, 級別) 方式存入  \n→ Decision: queue 是否為空? // 檢查是否還有字可處理  \n  No  → Step 4: 取出首個元素 (word, level) ← queue.pop(0) // 取得目前字與深度  \n  Yes → Step 5: 回傳 0 // 無法達成轉換  \n→ Step 6: 迴圈 for i from 0 to len(word)-1: // 遍歷字母位置  \n  → Step 7: 迴圈 for ch in 'a'..'z': // 嘗試所有可能字母  \n    → Decision: ch 是否等於 word[i]? // 檢查是否需要改變  \n      Yes → Continue // 跳過同字母  \n      No  → Step 8: newWord ← word[0:i] + ch + word[i+1:] // 產生新的字  \n      → Decision: newWord 是否等於 endWord? // 檢查是否到達目標  \n        Yes → Step 9: 回傳 level + 1 // 找到最短路徑長度  \n        No  → Decision: newWord 是否在 wordSet 且 未訪問? // 檢查是否合法且未處理  \n         Yes → Step 10: 將 (newWord, level+1) 加入 queue // 進一步 BFS  \n           → visited.add(newWord) // 標記已訪問  \n         No  → Continue // 忽略不合法或已訪問的字  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(res[::-1])\n\ndef main():\n    # 讀取全部輸入，無論是多行或單行\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取出第一個兩個數字序列\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        # 若沒有足夠的數字，直接退出\n        return\n\n    num1, num2 = nums[0], nums[1]\n\n    sol = Solution()\n    result = sol.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for adding two large numbers as strings, without BigInteger, no direct conversion to integers. So typical approach: simulate addition digit by digit from right to left, manage carry, build result.\n\nWe need to produce lines with \"虛擬碼步驟 // 解釋\".\n\nWe need to start with Start, End, and Decision arrows. Use \"→ Step X:\" etc.\n\nWe need to generate step-by-step algorithm in pseudo-code. Each line should be a step. We need to include decisions. Use Decision: ... with Yes → and No →.\n\nWe must not output actual code, just pseudo. So we need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Initialize pointers i, j to last indices of num1 and num2 // ...\n→ Step 2: Initialize carry = 0 and empty result string // ...\n→ Decision: While i>=0 or j>=0 or carry>0? // ...\n    Yes → Step 3: Extract digit1 = (i>=0 ? num1[i] - '0' : 0) // ...\n    Yes → Step 4: Extract digit2 = (j>=0 ? num2[j] - '0' : 0) // ...\n    Yes → Step 5: sum = digit1 + digit2 + carry // ...\n    Yes → Step 6: carry = sum / 10 // ...\n    Yes → Step 7: result = (sum % 10) + result // ...\n    Yes → Step 8: Decrement i and j accordingly // ...\n    No → (loop ends) // ...\n→ Step 9: Return result // ...\nEnd\n\nAlso we need Decision with Yes→, No→. Use indentation.\n\nMake sure each line ends with // Explanation.\n\nWe need to ensure the structure includes Decision: and Yes →, No →. For loops, we can use Decision. Eg Decision: i>=0 or j>=0 or carry>0? Yes→ ... No→.\n\nAlso need to handle negative? The numbers are non-negative. So we can skip sign.\n\nLet's produce.\n\nAlso we should note that digits extraction uses char to int conversion. But we cannot convert whole string to int; char to int is allowed.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set i = length(num1) - 1, j = length(num2) - 1 // 指向兩個字串的最後一個字元  \n→ Step 2: Initialize carry = 0, result = \"\" // 用來儲存進位和結果字串  \n→ Decision: i >= 0 or j >= 0 or carry > 0? // 判斷是否還有位數或進位需要處理  \n  Yes → Step 3: digit1 = (i >= 0) ? (num1[i] - '0') : 0 // 取得 num1 的當前位數，若已結束則為 0  \n  Yes → Step 4: digit2 = (j >= 0) ? (num2[j] - '0') : 0 // 取得 num2 的當前位數，若已結束則為 0  \n  Yes → Step 5: sum = digit1 + digit2 + carry // 計算兩位數與進位的總和  \n  Yes → Step 6: carry = sum / 10 // 計算新的進位（十進制）  \n  Yes → Step 7: result = (sum % 10) + result // 將此位數放到結果字串前面  \n  Yes → Step 8: i = i - 1, j = j - 1 // 移動到更高位的字元  \n  Yes → Decision: i >= 0 or j >= 0 or carry > 0? // 回到循環判斷  \n    Yes → (回到 Step 3)  \n    No → (離開循環)  \n  No → (不再進行任何操作)  \n→ Step 9: Return result // 傳回相加後的字串結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum II",
      "source_file": "Leetcode/leetcode40.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptj9uvr5g.py\", line 30, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    candidates = [10,1,2,7,6,1,5], target = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0sf031i9.py\", line 30, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    candidates = [2,5,2,1,2], target = 5\n    ^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n    local_vars = {}\n    exec(data, {}, local_vars)\n    candidates = local_vars.get(\"candidates\", [])\n    target = local_vars.get(\"target\", 0)\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve combination sum II problem (each candidate used once, unique combinations). Provide step-by-step algorithm, likely backtracking with sorting and skip duplicates.\n\nWe must output in specified format, each line with virtual code step and comment. Use Start, Decision, →, Yes →, No → etc.\n\nMake sure to reflect sorting, recursion, backtracking, skip duplicates.\n\nWe need to output each step line. Let's craft lines:\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 方便後續跳過重複\n→ Step 2: Initialize result list // 存儲所有合法組合\n→ Step 3: Define backtrack(start, current_combination, remaining_target) // 回溯函式\n→ Decision: remaining_target == 0? // 檢查是否已達目標\n    Yes → Step 4: Add copy of current_combination to result // 完整組合加入結果\n    No  → Decision: start >= length(candidates)? // 是否已遍歷完所有候選\n        Yes → Step 5: Return // 走到尾端不再進行\n        No  → Step 6: For i from start to length(candidates)-1 // 遍歷剩餘候選\n→ Decision: i > start AND candidates[i] == candidates[i-1]? // 檢查是否重複元素\n            Yes → Step 7: Continue // 跳過重複的起始位置\n            No  → Step 8: If candidates[i] > remaining_target? // 檢查是否已超過目標\n                Yes → Step 9: Break // 之後不再有合法數字\n                No  → Step 10: Append candidates[i] to current_combination // 加入當前數字\n→ Decision: remaining_target - candidates[i] >= 0? // 確認剩餘可為非負\n    Yes → Step 11: backtrack(i+1, current_combination, remaining_target - candidates[i]) // 深入下一層\n    No  → Step 12: Continue // 不進行回溯\n→ Step 13: Remove last element from current_combination // 回溯，移除剛加入的數字\n→ Step 14: End // 結束回溯\n→ Step 15: Call backtrack(0, [], target) // 開始回溯\n→ Step 16: Return result // 返回所有唯一組合\n\nBut need arrow formatting. Each line must have arrow \"→\" for normal steps, and for decisions \"Decision:\" etc.\n\nAlso we must ensure the formatting exactly: Each line must be \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe need to use \"Start\" and \"End\" with comment. Use \"Step X:\" etc.\n\nLet's format carefully:\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 方便後續跳過重複\n→ Step 2: Initialize result list // 存儲所有合法組合\n→ Step 3: Define backtrack(start, current_combination, remaining_target) // 回溯函式\n→ Decision: remaining_target == 0? // 檢查是否已達目標\n    Yes → Step 4: Add copy of current_combination to result // 完整組合加入結果\n    No  → Decision: start >= length(candidates)? // 是否已遍歷完所有候選\n        Yes → Step 5: Return // 走到尾端不再進行\n        No  → Step 6: For i from start to length(candidates)-1 // 遍歷剩餘候選\n→ Decision: i > start AND candidates[i] == candidates[i-1]? // 檢查是否重複元素\n            Yes → Step 7: Continue // 跳過重複的起始位置\n            No  → Step 8: If candidates[i] > remaining_target? // 檢查是否已超過目標\n                Yes → Step 9: Break // 之後不再有合法數字\n                No  → Step 10: Append candidates[i] to current_combination // 加入當前數字\n→ Decision: remaining_target - candidates[i] >= 0? // 確認剩餘可為非負\n    Yes → Step 11: backtrack(i+1, current_combination, remaining_target - candidates[i]) // 深入下一層\n    No  → Step 12: Continue // 不進行回溯\n→ Step 13: Remove last element from current_combination // 回溯，移除剛加入的數字\n→ Step 14: End // 結束回溯\n→ Step 15: Call backtrack(0, [], target) // 開始回溯\n→ Step 16: Return result // 返回所有唯一組合\nEnd // 程式執行結束\n\nWe need to maintain indentation? The format example had indent of decisions. We need to replicate similar style.\n\nBut requirement: Use arrow '→', 'Yes →', 'No →'. Must keep formatting similar. Provide each line separate. We should include indentation spaces for decisions but maybe not required. But example shows indentation.\n\nLet's produce lines with proper indentation. Use two spaces for indent? Example:\n\nDecision: 如果數字大於 0? // ...\n    Yes → Step 2...\n    No  → Decision: 如果數字等於 0? ...\n\nThus we should indent Yes → and No → by 4 spaces? They used 4 spaces then Yes→. Let's replicate:\n\nDecision: ... \n    Yes → ...\n    No  → ...\n\nSo we should indent each nested decision by 4 spaces.\n\nLet's produce accordingly.\n\nAlso need to ensure no extra spaces before 'Start' or 'End'.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 方便後續跳過重複\n→ Step 2: Initialize result list // 存儲所有合法組合\n→ Step 3: Define backtrack(start, current_combination, remaining_target) // 回溯函式\n→ Decision: remaining_target == 0? // 檢查是否已達目標\n    Yes → Step 4: Add copy of current_combination to result // 完整組合加入結果\n    No  → Decision: start >= length(candidates)? // 是否已遍歷完所有候選\n        Yes → Step 5: Return // 走到尾端不再進行\n        No  → Step 6: For i from start to length(candidates)-1 // 遍歷剩餘候選\n→ Decision: i > start AND candidates[i] == candidates[i-1]? // 檢查是否重複元素\n            Yes → Step 7: Continue // 跳過重複的起始位置\n            No  → Step 8: If candidates[i] > remaining_target? // 檢查是否已超過目標\n                Yes → Step 9: Break // 之後不再有合法數字\n                No  → Step 10: Append candidates[i] to current_combination // 加入當前數字\n→ Decision: remaining_target - candidates[i] >= 0? // 確認剩餘可為非負\n    Yes → Step 11: backtrack(i+1, current_combination, remaining_target - candidates[i]) // 深入下一層\n    No  → Step 12: Continue // 不進行回溯\n→ Step 13: Remove last element from current_combination // 回溯，移除剛加入的數字\n→ Step 14: End // 結束回溯\n→ Step 15: Call backtrack(0, [], target) // 開始回溯\n→ Step 16: Return result // 返回所有唯一組合\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport json\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立從值到索引清單的映射\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 的其中一個索引\n        indices = self.num_indices[target]\n        return random.choice(indices)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分成兩個部分：操作列表和對應的參數列表\n    split_idx = data.find('],')\n    if split_idx == -1:\n        # 若沒有找到 '],'，直接解析整個輸入\n        ops, args = ast.literal_eval(data)\n    else:\n        ops_str = data[:split_idx + 1]\n        args_str = data[split_idx + 2:].strip()\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            obj = Solution(arg[0])\n            results.append(None)          # constructor 的回傳值是 None\n        else:\n            results.append(obj.pick(arg[0]))\n\n    # 用 json.dumps 將 None 轉成 null，符合題目輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode in the format given, line by line. The user wants to output the index randomly among indices where nums[i]==target. This is a standard random sampling problem. Approach: Preprocess mapping from number to list of indices. In constructor: iterate over nums, build map. In pick: retrieve list for target, random index selection. We'll produce pseudocode accordingly.\n\nNeed to use arrow syntax: \"→\". For decision: \"Decision:\".\n\nAlso must add comments // after each line.\n\nWe must adhere to \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nThus each line will be like:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 宣告 Solution 類別\n...\n\nBut we need to produce a step-by-step algorithm. Let's design:\n\nStart\n→ Step 1: 建立 Solution 類別\n→ Step 2: Constructor receives nums\n    → Step 3: 建立空 map: value_to_indices\n    → Step 4: 對於每個 index, value in nums\n        → Step 5: 若 value not in map, 建立新 list\n        → Step 6: 將 index 加入 map[value]\n→ Step 3: pick(target)\n    → Step 4: 取得 indices = map[target]\n    → Step 5: 確保 indices 非空 (given existence)\n    → Step 6: 隨機選取一個位置 offset = random integer 0..len(indices)-1\n    → Step 7: 回傳 indices[offset]\nEnd\n\nBut we must include Decision arrows? In this case, there are decisions like if value not in map. We'll show Decision steps.\n\nAlso we need to include random selection; we can use \"random_int(0, len(indices)-1)\".\n\nLet's produce the lines accordingly.\n\nNeed to maintain the formatting: \"Start\" line; arrow lines with steps; each line ends with comment.\n\nAlso we need to maintain the indentation for nested steps? Not required but can.\n\nWe should produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Solution // 宣告 Solution 類別  \n→ Step 2: Constructor 接收整數陣列 nums // 建構函式初始化物件  \n  → Step 3: 建立空的映射 value_to_indices // Map: 數值 -> 所有索引清單  \n  → Decision: nums 是否為空？ // 檢查輸入陣列是否為空  \n   Yes → End // 若空則直接結束（此情況在題目中不會發生）  \n   No → Step 4: 從 index = 0 到 nums.length - 1 逐一遍歷 nums  \n    → Step 5: current_value ← nums[index] // 取得目前元素值  \n    → Decision: current_value 是否已在 value_to_indices？ // 判斷映射是否已存在此鍵  \n     Yes → Step 6: 把 index 加入 value_to_indices[current_value] 的清單中 // 索引加入對應鍵的清單  \n     No → Step 7: 建立 value_to_indices[current_value] 為新清單，並加入 index // 建立新鍵並加入索引  \n→ Step 8: 完成建構，物件已備妥索引映射  \n→ Step 9: pick(target) 方法呼叫時  \n  → Step 10: indices ← value_to_indices[target] // 取得所有對應 target 的索引清單  \n  → Decision: indices 為空？ // 檢查是否存在 target（題目保證存在）  \n   Yes → End // 若空則結束（此情況不會發生）  \n   No → Step 11: n ← indices.length // 取得清單長度  \n   → Step 12: rand_index ← random_int(0, n - 1) // 隨機產生 0~n-1 的整數  \n   → Step 13: 返回 indices[rand_index] // 回傳隨機選出的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出在 strs 中唯一的字串（即不等於其他任何字串）的最大長度。\n        若不存在唯一字串，回傳 -1。\n        \"\"\"\n        freq = {}\n        for s in strs:\n            freq[s] = freq.get(s, 0) + 1\n\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1 and len(s) > max_len:\n                max_len = len(s)\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n        sys.exit(0)\n\n    # 解析輸入為 Python list，輸入格式類似 '[\"aba\",\"cdc\",\"eae\"]'\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若解析失敗，視為無效輸入，回傳 -1\n        print(-1)\n        sys.exit(0)\n\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for solving problem: longest uncommon subsequence length. Classic solution: if any string is unique (i.e., not equal to any other), answer is its length, else -1. Steps: iterate over each string, count occurrences, track longest length of unique string. If none unique, return -1.\n\nWe need to output line by line with \"虛擬碼步驟 // 解釋\" format. Use arrows, Start, Decision etc. We'll create pseudo-code: Start → Step: Build frequency map → Step: Initialize result = -1 → For each string s: if freq[s]==1: result = max(result, length(s)) → End → Output result.\n\nLet's structure with Decision: maybe we can include Decision to check if result updated. But we can just produce linear. Use arrows to indicate flow.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字串頻率表 frequency ← 空字典 // 讀取輸入陣列 strs  \n→ Step 2: For each string s in strs  \n  → Decision: s 已存在於 frequency?  \n   Yes → frequency[s] ← frequency[s] + 1 // 已有，次數+1  \n   No  → frequency[s] ← 1 // 第一次出現，次數=1  \n→ Step 3: 初始化 result ← -1 // 若無不重複字串，回傳 -1  \n→ Step 4: For each string s in strs  \n  → Decision: frequency[s] == 1? // 是否為唯一字串  \n   Yes → result ← max(result, length(s)) // 更新最大長度  \n   No  →  // 不是唯一字串，忽略  \n→ End // 程式結束  \n→ Output result // 回傳最長不常見子序列長度或 -1"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef format_output(permutations):\n    \"\"\"Convert list of permutations into the required string format without spaces.\"\"\"\n    perms_str = []\n    for perm in permutations:\n        perms_str.append('[' + ','.join(map(str, perm)) + ']')\n    return '[' + ','.join(perms_str) + ']'\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list part from the input, handling formats like \"nums = [1,2,3]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n\n    nums = ast.literal_eval(list_part)\n\n    solution = Solution()\n    result = solution.permute(nums)\n\n    output = format_output(result)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode (Virtual Code) for generating all permutations of a distinct integer array, returning list of lists. It's backtracking. Provide steps line by line with comments. Use Start, End, Decision, → etc.\n\nWe'll produce pseudocode lines:\n\nStart\n→ Step 1: Initialize result list // empty list to store permutations\n→ Step 2: Define backtrack(current, remaining) // recursive function\n→ Decision: 如果 remaining 為空? // if no numbers left\n   Yes → Step 3: Append copy of current to result // add permutation\n   No  → Step 4: For each num in remaining: // iterate options\n        → Step 5: Add num to current // include num\n        → Step 6: Create newRemaining = remaining without num // remove\n        → Step 7: Call backtrack(current, newRemaining) // recurse\n        → Step 8: Remove last element from current // backtrack\n→ End // finish\n\nBut must include virtual arrows, like Yes →, No →. Provide \"Start\" line. Use indentation maybe but not necessary. The format example uses indentation inside Decision. So we will mimic that.\n\nLet's produce each line:\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 results = [] // 用於儲存所有排列\n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current 為目前組成的排列\n→ Decision: 如果 remaining 為空? // 是否已經用完所有數字\n    Yes → Step 3: 把 current 的拷貝加入 results // 完整排列加入結果\n    No  → Step 4: 遍歷 remaining 中每個 num // 選擇下一個要加入的數字\n        → Step 5: current.append(num) // 把 num 加到目前排列\n        → Step 6: newRemaining = remaining 去除 num // 創建剩餘集合\n        → Step 7: backtrack(current, newRemaining) // 進一步遞迴\n        → Step 8: current.pop() // 回溯，移除剛剛加入的 num\n→ Step 9: 呼叫 backtrack([], nums) // 從空排列開始\n→ End // 程式執行結束\n\nMake sure every line ends with // 解釋. Indent decisions lines properly. Use arrow for Yes, No. Provide no actual code. Should be okay. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果列表 results = [] // 用於儲存所有排列  \n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current 為目前組成的排列  \n→ Decision: 如果 remaining 為空? // 是否已經用完所有數字  \n    Yes → Step 3: 把 current 的拷貝加入 results // 完整排列加入結果  \n    No  → Step 4: 遍歷 remaining 中每個 num // 選擇下一個要加入的數字  \n        → Step 5: current.append(num) // 把 num 加到目前排列  \n        → Step 6: newRemaining = remaining 去除 num // 創建剩餘集合  \n        → Step 7: backtrack(current, newRemaining) // 進一步遞迴  \n        → Step 8: current.pop() // 回溯，移除剛剛加入的 num  \n→ Step 9: 呼叫 backtrack([], nums) // 從空排列開始  \nEnd // 程式執行結束"
    },
    {
      "title": "Sliding Window Maximum",
      "source_file": "Leetcode/leetcode239.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,3,5,5,6,7]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[3,3,5,5,6,7]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[1]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or k == 0:\n            return []\n        deq = deque()\n        res = []\n        for i in range(len(nums)):\n            # Remove indices that are out of the current window\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n            # Remove indices whose corresponding values are less than nums[i]\n            while deq and nums[deq[-1]] < nums[i]:\n                deq.pop()\n            deq.append(i)\n            # Once the window is fully inside the array, record the maximum\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    # 用 exec 解析輸入，將變數放入 local_vars\n    local_vars = {}\n    try:\n        exec(raw_input, {}, local_vars)\n    except Exception as e:\n        # 若解析失敗，直接輸出空列表\n        print([])\n        sys.exit(0)\n    nums = local_vars.get('nums')\n    k = local_vars.get('k')\n    # 若缺少必要變數，輸出空列表\n    if nums is None or k is None:\n        print([])\n    else:\n        sol = Solution()\n        result = sol.maxSlidingWindow(nums, k)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to generate a virtual code algorithm for the sliding window maximum problem. Output format: line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure Start, Decision, etc. Need to provide steps: e.g., initialize deque, iterate array, maintain deque of indices of potential max, etc. Should produce pseudocode lines. We need to use \"→\" arrows, \"Start\", \"End\", \"Decision:\" etc. We need to include all lines. Provide explanatory comment after space. So produce:\n\nStart // ...\n→ Step 1: 初始化一个双端队列 deque // 用来存储窗口内元素的索引，保持递减顺序\n→ Step 2: 遍历数组 nums，索引为 i // 逐个处理每个元素\n   → Decision: i >= k-1? // 判断窗口已满，开始输出最大值\n      Yes → Step 3: 当前窗口最大值 = nums[deque[0]] // deque 前端为窗口最大元素的索引\n      Yes → Step 4: 将最大值加入结果数组 // 记录结果\n      No  → (nothing) // 未满窗口时不输出\n   → Decision: deque 非空且 deque[0] <= i-k? // 检查队列首元素是否已离开窗口\n      Yes → Step 5: 删除 deque[0] // 移除已不在窗口的索引\n      No  → (nothing)\n   → Decision: deque 非空且 nums[deque[-1]] <= nums[i]? // 清除小于当前元素的索引\n      Yes → Step 6: 删除 deque[-1] // 让 deque 保持递减顺序\n      No  → (nothing)\n   → Step 7: 将 i 添加到 deque 末尾 // 将当前索引加入队列\nEnd // 完成\n\nWe should include \"→\" arrow for each step. We must keep arrow consistent. For nested decisions we indent? Provide lines with indentation maybe. Format: lines start with arrow, maybe nested indentation. The sample uses indentation under Decision. Use that. So produce code accordingly. Ensure each line ends with comment // explanation. Ensure line numbers? Not required. Each line has code step and comment.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個雙端佇列 deque // 用來存儲當前窗口內元素的索引，保持索引對應的數值遞減  \n→ Step 2: 初始化結果陣列 result = [] // 用於存放每個窗口的最大值  \n→ Step 3: 循環遍歷 nums，索引為 i // 逐個處理數組中的每個元素  \n  → Decision: i >= k-1? // 判斷窗口是否已經充滿 k 個元素  \n   Yes → Step 4: result.append(nums[deque[0]]) // deque 的首元素對應窗口中的最大值，加入結果  \n   No  → // 未達到窗口大小時不輸出  \n  → Decision: deque 不是空且 deque[0] <= i - k? // 檢查佇列首元素是否已離開窗口  \n   Yes → Step 5: deque.popleft() // 移除已不在窗口範圍內的索引  \n   No  → // 仍在窗口內，無需移除  \n  → Decision: deque 不是空且 nums[deque[-1]] <= nums[i]? // 清除所有小於等於當前元素的索引  \n   Yes → Step 6: deque.pop() // 讓佇列保持數值遞減，以保證前端始終是最大值  \n   No  → // 目前末尾元素已大於當前元素，保持不變  \n  → Step 7: deque.append(i) // 將當前索引加入佇列末尾，作為潛在最大值  \nEnd // 程式執行結束，result 即為滑動窗口最大值序列"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\nimport json\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []  # 存放所有元素\n        self.idx_map = collections.defaultdict(set)  # value -> set of indices in data\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，返回是否首次插入\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個元素，若存在則返回 True，否則 False\"\"\"\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 若不是最後一個元素，將最後一個元素移到要刪除的位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        self.data.pop()\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.data)\n\ndef parse_input(input_str: str):\n    \"\"\"解析輸入字串，得到命令列表和參數列表\"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return [], []\n    # 分離兩個列表\n    parts = input_str.split('], [', 1)\n    cmds_str = parts[0] + ']'\n    args_str = '[' + parts[1]\n    commands = ast.literal_eval(cmds_str)\n    args = ast.literal_eval(args_str)\n    return commands, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    commands, args = parse_input(raw_input)\n\n    results = []\n    collection = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"RandomizedCollection\":\n            collection = RandomizedCollection()\n            results.append(None)  # constructor的結果為 null\n        elif cmd == \"insert\":\n            res = collection.insert(arg[0])\n            results.append(res)\n        elif cmd == \"remove\":\n            res = collection.remove(arg[0])\n            results.append(res)\n        elif cmd == \"getRandom\":\n            res = collection.getRandom()\n            results.append(res)\n        else:\n            # 若有未知命令，直接忽略或記錄 None\n            results.append(None)\n\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式\n    output_str = json.dumps(results, separators=(', ', ' '))\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing RandomizedCollection with methods insert, remove, getRandom. Provide each line with explanation. Need use virtual code arrow symbols. We need to represent data structures: an array list to store values, a hashmap from value to set of indices. For each method, we describe steps. Let's produce a pseudo algorithm with lines:\n\nStart\n→ Initialize data structures\n→ Define insert\n→ Define remove\n→ Define getRandom\nEnd\n\nBut must show per line explanation.\n\nWe can write:\n\nStart // 程式開始\n→ Step 1: 建立空的 List arr // 存放所有元素\n→ Step 2: 建立 Map valToIndices mapping value to Set of positions // 追蹤元素位置\n→ Step 3: Define function insert(val) // 插入元素\n    → Step 4: Append val to arr // 將新值加入末尾\n    → Step 5: Add arr.size-1 to valToIndices[val] // 記錄新位置\n    → Step 6: If valToIndices[val] size == 1 then return true else false // 判斷是否首次出現\n→ Step 7: Define function remove(val) // 移除元素\n    → Step 8: If val not in valToIndices or set empty then return false // 無此元素\n    → Step 9: Pick an arbitrary index idx from valToIndices[val] // 取任意一個位置\n    → Step 10: Remove idx from valToIndices[val] // 移除該位置\n    → Step 11: Let lastVal = arr.last // 取得陣列最後一個值\n    → Step 12: Let lastIdx = arr.size-1 // 最後位置\n    → Step 13: If idx != lastIdx then\n        → Step 14: Overwrite arr[idx] = lastVal // 把最後一個值搬到要刪除的位置\n        → Step 15: Update valToIndices[lastVal] remove lastIdx add idx // 更新位置集合\n    → Step 16: Remove last element from arr // 真的刪除最後元素\n    → Step 17: If valToIndices[val] now empty then delete key // 清理空集合\n    → Step 18: Return true // 成功刪除\n→ Step 19: Define function getRandom() // 取得隨機元素\n    → Step 20: Generate random index r in [0, arr.size-1] // 隨機索引\n    → Step 21: Return arr[r] // 返回對應值\nEnd // 程式結束\n\nNeed ensure each line has '虛擬碼步驟 [space] // 解釋'. Use arrows. Let's produce.\n\nNote: Use \"→\" for continuation lines, indent. Provide Decision structure for existence checks.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: 初始化 arr 為空 List // 存放所有元素\n→ Step 2: 初始化 valToIndices 為空 Map< int, Set< int > > // 對應每個值其在 arr 中的索引集合\n→ Step 3: 定義 function insert(val) // 插入元素\n    → Step 4: arr.append(val) // 將新值加到陣列尾部\n    → Step 5: valToIndices[val].add(arr.size-1) // 記錄新位置\n    → Step 6: Decision: 是否為第一次出現 val? // 判斷是否首次插入\n        Yes → Step 7: return true // 第一次插入，返回 true\n        No  → Step 8: return false // 已存在，返回 false\n→ Step 9: 定義 function remove(val) // 移除元素\n    → Step 10: Decision: val 在 valToIndices 且集合非空? // 檢查是否存在\n        No  → Step 11: return false // 沒有此值，直接返回 false\n        Yes → Step 12: 取 valToIndices[val] 中任意一個索引 idx // 選取要移除的位置\n            → Step 13: valToIndices[val].remove(idx) // 移除該索引\n            → Step 14: lastVal = arr.last // 取陣列最後一個值\n            → Step 15: lastIdx = arr.size-1 // 最後位置\n            → Step 16: Decision: idx != lastIdx? // 判斷是否為最後一個元素\n                Yes → Step 17: arr[idx] = lastVal // 把最後一個值覆蓋到要刪除的位置\n                    → Step 18: valToIndices[lastVal].remove(lastIdx) // 移除舊位置\n                    → Step 19: valToIndices[lastVal].add(idx) // 新增新位置\n                No  → Step 20: // idx 為最後一個位置，無需覆蓋\n            → Step 21: arr.removeLast() // 真正從陣列刪除最後一個元素\n            → Step 22: Decision: valToIndices[val] 是否已空? // 檢查集合是否清空\n                Yes → Step 23: valToIndices.delete(val) // 清理空集合\n            → Step 24: return true // 成功移除\n→ Step 25: 定義 function getRandom() // 隨機取值\n    → Step 26: r = randomInt(0, arr.size-1) // 產生隨機索引\n    → Step 27: return arr[r] // 返回對應元素\nEnd // 程式結束\n```"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小堆（max-heap）存放較小的一半，用負數實現\n        self.small = []\n        # 大堆（min-heap）存放較大的一半\n        self.large = []\n\n    def addNum(self, num):\n        # 把新數先放進小堆\n        heapq.heappush(self.small, -num)\n        # 保證小堆最大不大於大堆最小\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 平衡兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入的兩個列表\n    parts = data.split('], [', 1)\n    ops_str = parts[0] + ']'\n    args_str = '[' + parts[1]\n    ops = json.loads(ops_str)\n    args_list = json.loads(args_str)\n\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            res.append(None)\n        elif op == \"addNum\":\n            obj.addNum(args[0])\n            res.append(None)\n        elif op == \"findMedian\":\n            res.append(obj.findMedian())\n        else:\n            res.append(None)\n\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for the class with methods: constructor, addNum, findMedian. Implementation likely using two heaps: max-heap for lower half, min-heap for upper half. Steps: maintain size difference <=1. When adding, push to appropriate heap, rebalance, then find median: if same size, average; else larger heap's top.\n\nWe must output each line as \"虛擬碼步驟 // 解釋\". Use arrows etc. Provide start, end.\n\nWe need to produce a step-by-step algorithm for the whole class, not per method. Provide pseudo-code lines that describe algorithmic flow.\n\nLet's design pseudo-code:\n\nStart\n→ Initialize two heaps: MaxHeap low, MinHeap high\n→ Define addNum(num):\n    → If low is empty OR num <= top(low):\n        → low.push(num)\n    → Else:\n        → high.push(num)\n    → If size(low) > size(high)+1:\n        → high.push(low.pop()) // move largest from low to high\n    → Else if size(high) > size(low)+1:\n        → low.push(high.pop()) // move smallest from high to low\n→ Define findMedian():\n    → If size(low) == size(high):\n        → Return (low.top() + high.top()) / 2.0\n    → Else if size(low) > size(high):\n        → Return low.top()\n    → Else:\n        → Return high.top()\nEnd\n\nWe need each line as separate line with arrow if branching.\n\nWe must use the syntax: \"Start // 程式開始執行\". Then lines with arrows. Use \"→\" for steps. For decisions, use \"Decision:\" etc. For example: \"Decision: low size > high size + 1?\" with Yes → etc.\n\nLet's structure pseudo-code:\n\nStart\n→ Initialize low as max-heap // 儲存較小一半\n→ Initialize high as min-heap // 儲存較大一半\n\n→ Function addNum(num): // 新增數字\n    → Decision: low is empty OR num <= low.top() ?\n        Yes → low.push(num) // 放進較小一半\n        No  → high.push(num) // 放進較大一半\n    → Decision: size(low) > size(high)+1 ?\n        Yes → high.push(low.pop()) // 平衡：把低堆最大移至高堆\n        No → Decision: size(high) > size(low)+1 ?\n            Yes → low.push(high.pop()) // 平衡：把高堆最小移至低堆\n            No  → // 已平衡\n\n→ Function findMedian(): // 求中位數\n    → Decision: size(low) == size(high) ?\n        Yes → Return (low.top() + high.top()) / 2.0 // 平均\n        No  → Decision: size(low) > size(high) ?\n            Yes → Return low.top() // 低堆多時取最大\n            No  → Return high.top() // 高堆多時取最小\n\nEnd\n\nWe need to ensure each line has the \"虛擬碼步驟\" plus space plus comment.\n\nAlso include arrows and indentation? The example uses arrow then step. For decisions, we use \"Decision:\".\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ low ← MaxHeap // 儲存較小一半的數值  \n→ high ← MinHeap // 儲存較大一半的數值  \n\n→ Function addNum(num) // 新增一個數字  \n    → Decision: low 為空 OR num ≤ low.top() ?  \n        Yes → low.push(num) // 放進較小一半  \n        No  → high.push(num) // 放進較大一半  \n    → Decision: low.size() > high.size() + 1 ?  \n        Yes → high.push(low.pop()) // 平衡：把低堆最大移到高堆  \n        No  → Decision: high.size() > low.size() + 1 ?  \n            Yes → low.push(high.pop()) // 平衡：把高堆最小移到低堆  \n            No  → // 已平衡  \n\n→ Function findMedian() // 回傳目前所有數字的中位數  \n    → Decision: low.size() == high.size() ?  \n        Yes → Return (low.top() + high.top()) / 2.0 // 平均兩中間值  \n        No  → Decision: low.size() > high.size() ?  \n            Yes → Return low.top() // 低堆多時取最大值  \n            No  → Return high.top() // 高堆多時取最小值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe5693mul.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpe5693mul.py\", line 46, in main\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppi08mre_.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmppi08mre_.py\", line 46, in main\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals,\n        merging any overlapping intervals.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged new interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Extract the two lists using regular expressions\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[[^\\]]*\\])', data)\n    new_interval_match = re.search(r'newInterval\\s*=\\s*(\\[[^\\]]*\\])', data)\n\n    if intervals_match and new_interval_match:\n        intervals = ast.literal_eval(intervals_match.group(1))\n        new_interval = ast.literal_eval(new_interval_match.group(1))\n    else:\n        # Fallback parsing if the format differs slightly\n        parts = [p.strip() for p in data.replace('\\n', ' ').split(',')]\n        intervals = ast.literal_eval(parts[0].split('=')[1])\n        new_interval = ast.literal_eval(parts[1].split('=')[1])\n\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for inserting a new interval into sorted non-overlapping intervals, merging as needed. We output lines like \"Start // 程式開始執行\", \"→ Step 1: ...\" etc. Provide explanation. We should produce a step-by-step algorithm in pseudo-code, with decisions and merging. Use arrows. Must not output real code. Just virtual steps.\n\nLet's plan algorithm: Given intervals sorted by start. newInterval [newStart, newEnd]. We want to output merged list.\n\nAlgorithm steps:\n1. Initialize result array.\n2. For each interval in intervals:\n   - If interval.end < newStart: no overlap, interval ends before new starts. Append interval to result.\n   - Else if interval.start > newEnd: no overlap, interval starts after new ends. Append newInterval (if not already added) then append remaining intervals and break (since sorted).\n   - Else: overlapping, merge: newStart = min(newStart, interval.start), newEnd = max(newEnd, interval.end). Continue to next interval.\n3. After loop, if newInterval not added yet, append it.\n4. Return result.\n\nBut we need to handle not added. We can use a flag inserted.\n\nAlternatively, we can build result by iterating and merging.\n\nLet's produce virtual code lines with decisions.\n\nWe need to incorporate steps for initializations, loop, decisions, merging.\n\nWe need to use Start, End, Decision.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立空結果陣列 result // 用來儲存最終區間\n→ Step 2: 設置布林變數 inserted = False // 標記新區間是否已加入\n→ Decision: 是否存在 intervals? // 若 intervals 可能為空\n    Yes → Step 3: 若 intervals 為空，則直接將 newInterval 加入 result 並返回 // 沒有其他區間，直接回傳\n    No  → Step 4: 迭代遍歷 intervals // 逐個處理原始區間\n        → For each interval [start, end] in intervals\n            → Decision: end < newStart? // 原始區間完全在新區間左側\n                Yes → Step 5: 將 interval 加入 result // 保留\n                No  → Decision: start > newEnd? // 原始區間完全在新區間右側\n                    Yes → Decision: inserted? // 是否已加入新區間\n                        Yes → Step 6: 將 interval 加入 result // 只需要把剩下區間加入\n                        No  → Step 7: 將 newInterval 加入 result // 插入新區間\n                               → Step 8: 將 interval 加入 result // 再把剩下區間加入\n                               → Step 9: 設置 inserted = True // 標記已插入\n                               → Step 10: 跳出迴圈 // 因為其餘區間已處理完畢\n                    No  → Step 11: 新區間與 interval 重疊，合併\n                              → Step 12: newStart = min(newStart, start) // 更新新區間開始\n                              → Step 13: newEnd = max(newEnd, end) // 更新新區間結束\n    → Decision: inserted? // 迴圈結束後判斷新區間是否已加入\n        Yes → Step 14: 返回 result // 完成\n        No  → Step 15: 將 newInterval 加入 result // 若未加入，加入\n              → Step 16: 返回 result // 完成\n\nEnd // 程式執行結束\n\nMake sure each line has arrow and explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空結果陣列 result // 用來儲存最終區間\n→ Step 2: 設置布林變數 inserted = False // 標記新區間是否已加入\n→ Decision: intervals 是否為空? // 若沒有任何區間，直接處理\n    Yes → Step 3: result ← [newInterval] // 新區間本身就是答案\n          → Step 4: 返回 result // 結束\n    No  → Step 5: 迭代遍歷 intervals // 逐個處理原始區間\n        → For each interval [start, end] in intervals\n            → Decision: end < newStart? // 原始區間完全在新區間左側\n                Yes → Step 6: result ← result + [interval] // 保留此區間\n                No  → Decision: start > newEnd? // 原始區間完全在新區間右側\n                    Yes → Decision: inserted? // 是否已將新區間加入\n                        Yes → Step 7: result ← result + [interval] // 只加入剩下區間\n                        No  → Step 8: result ← result + [newInterval] // 插入新區間\n                              → Step 9: result ← result + [interval] // 再加入剩下區間\n                              → Step 10: inserted ← True // 標記已插入\n                              → Step 11: 跳出迴圈 // 因為其餘區間已被處理\n                    No  → Step 12: // 新區間與 interval 重疊，進行合併\n                              → newStart ← min(newStart, start) // 更新開始時間\n                              → newEnd   ← max(newEnd,   end)   // 更新結束時間\n    → Decision: inserted? // 迴圈結束後判斷新區間是否已加入\n        Yes → Step 13: 返回 result // 完成\n        No  → Step 14: result ← result + [newInterval] // 若未加入，加入\n              → Step 15: 返回 result // 完成\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Largest Divisible Subset",
      "source_file": "Leetcode/leetcode368.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9pjpbdz7.py\", line 39, in <module>\n    nums = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9pjpbdz7.py\", line 35, in parse_input\n    return ast.literal_eval(data[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1,2,3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgueclfoj.py\", line 39, in <module>\n    nums = parse_input(raw)\n           ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgueclfoj.py\", line 35, in parse_input\n    return ast.literal_eval(data[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1,2,4,8\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef largest_divisible_subset(nums):\n    if not nums:\n        return []\n    nums.sort()\n    n = len(nums)\n    dp = [1] * n\n    prev = [-1] * n\n    max_index = 0\n\n    for i in range(n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                dp[i] = dp[j] + 1\n                prev[i] = j\n        if dp[i] > dp[max_index]:\n            max_index = i\n\n    result = []\n    while max_index >= 0:\n        result.append(nums[max_index])\n        max_index = prev[max_index]\n    return result[::-1]\n\ndef parse_input(data):\n    \"\"\"\n    解析形如 'nums = [1,2,3]' 的輸入，返回數字列表。\n    \"\"\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    return ast.literal_eval(data[start:end])\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    nums = parse_input(raw)\n    answer = largest_divisible_subset(nums)\n    print(answer)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm to solve the problem: find largest subset such that each pair divisible. This is a known problem \"Largest Divisible Subset\" from LeetCode. Approach: sort nums ascending; dp[i] = length of largest divisible subset ending at nums[i]; parent[i] to reconstruct. For each i, for j < i, if nums[i] % nums[j]==0 and dp[j]+1 > dp[i], update dp[i] and parent[i]. After processing, find max index, reconstruct subset by following parent.\n\nWe must produce step-by-step virtual code lines with explanation, using arrows and structure. Provide Start, Steps, Decision, End. We need to output just the virtual code, no actual code, just structure. Each line: \"虛擬碼步驟 // 解釋\". Should be in Chinese.\n\nLet's craft. Use \"Start // 程式開始執行\". Then \"→ Step 1: Sort nums ascending // 對輸入陣列進行排序\". Then allocate arrays: \"→ Step 2: Initialize dp[i] = 1 for all i // 每個數字至少能成為長度 1 的子集\". \"→ Step 3: Initialize parent[i] = -1 // 用於重建答案\". Then nested loops: \"→ Decision: For each i from 0 to n-1? // 處理每個數字作為子集終點\". Actually we need nested loops: outer i, inner j. Use steps.\n\nWe need to express loops via steps: \"→ Step 4: For i in 0..n-1\". Then inside: \"→ Step 5: For j in 0..i-1\". \"→ Decision: If nums[i] % nums[j] == 0? // 檢查可整除關係\". \"    Yes → Step 6: If dp[j] + 1 > dp[i]? // 找更長子集\". \"        Yes → Step 7: Update dp[i] = dp[j] + 1 // 更新長度\". \"        Yes → Step 8: Set parent[i] = j // 記錄前驅\". Then after loops: \"→ Step 9: Find index maxIdx with maximum dp[maxIdx] // 找到子集最大長度\". \"→ Step 10: Reconstruct subset by tracing parent from maxIdx // 從最大索引回溯\". Use a while loop: \"→ Step 11: Initialize subset = []\". \"→ Step 12: While maxIdx != -1\". \"    Append nums[maxIdx] to subset\". \"    Set maxIdx = parent[maxIdx]\". After that reverse subset to ascending order? But we can just note. \"→ Step 13: Reverse subset to original order if needed\". \"→ End // 完成輸出答案\".\n\nMake sure each line is in format: \"虛擬碼步驟 // 解釋\".\n\nAlso we need arrow syntax: \"→\" and indentation. In example they use indentation for decisions.\n\nWe need to include \"Decision:\" and \"Yes →\", \"No →\" lines. For loops, we might treat them as \"Step X: For i in 0..n-1\".\n\nAlso need to show that we only output virtual code, no actual code.\n\nLet's craft.\n\nCheck each line: we need to include arrow. In example they use \"→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\". So use \"→ Step X: ...\" Good.\n\nFor decision: \"Decision: ...\". Then \"Yes → ...\". \"No → ...\". Indentation inside decision.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 對輸入的正整數陣列進行升序排序\n→ Step 2: Let n = nums.length // 獲取陣列長度\n→ Step 3: Initialize dp[0..n-1] = 1 // 每個元素至少能形成長度為1的子集\n→ Step 4: Initialize parent[0..n-1] = -1 // 用於重建最終子集\n→ Step 5: For i from 0 to n-1 // 對每個元素作為子集終點進行處理\n    → Step 6: For j from 0 to i-1 // 與之前的所有元素比較\n        → Decision: If nums[i] % nums[j] == 0? // 檢查是否可整除\n            Yes → Decision: If dp[j] + 1 > dp[i]? // 是否能得到更長的子集\n                Yes → Step 7: Set dp[i] = dp[j] + 1 // 更新子集長度\n                Yes → Step 8: Set parent[i] = j // 記錄前驅元素\n                No  → // 不更新\n            No  → // 不進行比較\n→ Step 9: Find index maxIdx where dp[maxIdx] is maximum // 找到最大子集長度對應的索引\n→ Step 10: Initialize result = [] // 用於存儲答案\n→ Step 11: While maxIdx != -1 // 從最大索引回溯\n    → Step 12: Append nums[maxIdx] to result // 加入當前元素\n    → Step 13: Set maxIdx = parent[maxIdx] // 移動到前驅\n→ Step 14: Reverse result // 使子集按升序排列\n→ End // 程式執行結束\n\nBut we need to format each line with \"虛擬碼步驟\" and comment. For steps within loops, we can indent with spaces. They used example: \"→ Decision: ...\". We can indent.\n\nMake sure each line contains \"→\" at start, except \"Start\" and \"End\" lines.\n\nAlso \"Decision:\" lines need \"Yes →\" and \"No →\".\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 對輸入的正整數陣列進行升序排序  \n→ Step 2: Let n = nums.length // 取得陣列長度  \n→ Step 3: Initialize dp[0..n-1] = 1 // 每個元素至少能形成長度為 1 的子集  \n→ Step 4: Initialize parent[0..n-1] = -1 // 用於重建最終子集  \n→ Step 5: For i from 0 to n-1 // 對每個元素作為子集終點進行處理  \n  → Step 6: For j from 0 to i-1 // 與之前的所有元素比較  \n    → Decision: If nums[i] % nums[j] == 0? // 檢查是否可整除  \n     Yes → Decision: If dp[j] + 1 > dp[i]? // 是否能得到更長的子集  \n      Yes → Step 7: Set dp[i] = dp[j] + 1 // 更新子集長度  \n      Yes → Step 8: Set parent[i] = j // 記錄前驅元素  \n      No → // 不更新  \n     No → // 不進行比較  \n→ Step 9: Find index maxIdx where dp[maxIdx] is maximum // 找到最大子集長度對應的索引  \n→ Step 10: Initialize result = [] // 用於存儲答案  \n→ Step 11: While maxIdx != -1 // 從最大索引回溯  \n    → Step 12: Append nums[maxIdx] to result // 加入當前元素  \n    → Step 13: Set maxIdx = parent[maxIdx] // 移動到前驅  \n→ Step 14: Reverse result // 使子集按升序排列  \n→ End // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\nGot (Norm):      '[[\"ate\",\"eat\",\"tea\"],[\"bat\"],[\"nat\",\"tan\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\nRaw Got:      '[[\"ate\", \"eat\", \"tea\"], [\"bat\"], [\"nat\", \"tan\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        Group anagrams from a list of strings.\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            # Use sorted characters as key\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Expected format: \"strs = [ ... ]\"\n    if data.startswith('strs'):\n        _, rest = data.split('=', 1)\n        rest = rest.strip()\n    else:\n        rest = data\n\n    try:\n        strs = ast.literal_eval(rest)\n    except Exception:\n        strs = []\n\n    solution = Solution()\n    result = solution.groupAnagrams(strs)\n\n    # Optional: sort inner lists and outer list for deterministic output\n    for group in result:\n        group.sort()\n    result.sort(key=lambda x: x[0] if x else \"\")\n\n    # Output using JSON to get double quotes like the examples\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. Use Start, End, Decision, arrow. Provide algorithm: group anagrams by sorted string or char count. Provide steps: initialize hash map, iterate each string, compute key (sorted), insert to list. Finally collect values. Also handle empty array. Use decision for empty. Provide lines accordingly. Ensure each line ends with // explanation. Use virtual arrow. Provide steps like \"→ Step 1: Initialize hash map\". Use Decision for empty input. Provide End. Let's craft.\n\nWe'll write:\n\nStart\n→ Decision: 如果 strs 為空? (if empty array)\n    Yes → Step 1: Return 空 list // return empty result\n    No → Step 2: Initialize map // hash map key->list\n→ Step 3: 針對每個 str in strs\n    → Step 4: 計算 key = sort(str) // 按字母排序作為 key\n    → Decision: 是否存在 map[key]?\n        Yes → Step 5: Append str 到 map[key] // 已有鍵，加入\n        No  → Step 6: map[key] = [str] // 新鍵，建立列表\n→ Step 7: 將 map.values() 收集為結果 list\nEnd\n\nWe need each line separate. Use arrow for decisions. Provide explanation after //. Should be in Traditional Chinese. Use Chinese characters for code description. Use 'Step' etc. Provide '→' arrow. Provide indentation? In example they indent inside decision. We'll use indent.\n\nMake sure each line contains: 虛擬碼步驟 + space + // 解釋. Use // Chinese. Provide arrow inside. For decisions use \"Decision: ...\" with Yes →, No →. Provide indentation with spaces. Let's craft.\n\nAlso need to start with Start line. End line. Provide Step numbers.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 strs 為空? // 檢查輸入陣列是否為空  \n    Yes → Step 1: Return 空 list // 空陣列直接回傳空結果  \n    No  → Step 2: Initialize map // 建立雜湊表，key 為字母排序，value 為字串清單  \n→ Step 3: 針對每個 str in strs  \n    → Step 4: 計算 key = sort(str) // 將字串中的字母排序，作為分組鍵  \n    → Decision: 是否存在 map[key]? // 判斷該鍵是否已在雜湊表中  \n        Yes → Step 5: Append str 到 map[key] // 已有分組，將字串加入對應清單  \n        No  → Step 6: map[key] = [str] // 新分組，建立字串清單並加入字串  \n→ Step 7: 將 map.values() 收集為結果 list // 取出所有分組，形成最終結果  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '13'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '13'\nRaw Got:      '9'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        left, right = matrix[0][0], matrix[n-1][n-1]\n        while left < right:\n            mid = (left + right) // 2\n            # Count how many elements <= mid\n            count = 0\n            i, j = 0, n - 1  # start from the right‑top corner\n            while i < n and j >= 0:\n                if matrix[i][j] <= mid:\n                    count += n - i   # all elements in this column to the right are <= mid\n                    j -= 1\n                else:\n                    i += 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input format: \"matrix = [...], k = ...\"\n    try:\n        matrix_start = data.index('matrix = ') + len('matrix = ')\n        k_start = data.index(', k = ') + len(', k = ')\n        matrix_str = data[matrix_start:k_start - len(', k = ')]\n        k_str = data[k_start:].strip()\n        matrix = eval(matrix_str)\n        k = int(k_str)\n    except Exception as e:\n        # Fallback: try to evaluate entire input as a tuple\n        try:\n            matrix, k = eval(data)\n        except:\n            raise ValueError('Invalid input format') from e\n\n    sol = Solution()\n    result = sol.kthSmallest(matrix, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: Given n x n sorted matrix, find kth smallest element. Use binary search on value range, counting elements <= mid. Complexity O(n log(max-min)). Memory O(1). So we need to output virtual code lines with arrow and explanation.\n\nWe'll produce steps:\n\nStart\n→ Step 1: 定義 left = matrix[0][0], right = matrix[n-1][n-1] // 找到矩陣最小最大值\n→ Decision: while left < right? // 迴圈直到範圍收斂\n    → Step 2: mid = (left + right) // 2 // 計算中值\n    → Step 3: count = 0 // 初始化小於等於 mid 的元素個數\n    → Step 4: i = 0, j = n-1 // 以右上角開始遍歷\n    → Decision: while i < n and j >= 0? // 遍歷整個矩陣\n        → Decision: if matrix[i][j] <= mid? // 判斷當前元素是否小於等於 mid\n            → Step 5: count += n - i // 所有在此列右側的元素都 <= mid\n            → Step 6: j -= 1 // 移動到左一列\n            → No → Step 7: i += 1 // 移動到下一行\n    → Decision: if count < k? // 根據計數判斷範圍\n        → Step 8: left = mid + 1 // k 大於 count，往右邊尋找\n        → No → Step 9: right = mid // k 小於等於 count，往左邊尋找\n→ Step 10: return left // 左右範圍收斂，left 為答案\nEnd\n\nAlso need to include explanation after each line. Provide arrow lines properly with indentation. Use \"Yes →\" and \"No →\" for decisions.\n\nWe need to follow format: each line: virtual code step [space] // 解釋/說明.\n\nFor decisions, we need to show arrow to steps with indentation and Yes/No. For example:\n\nDecision: while left < right? \n    Yes → ... // loop body\n    No  → ... // exit loop\n\nBut \"Decision\" line may have Yes/No arrows for each possible branch. For while loop, we treat as condition that loops.\n\nBut typical format: \"Decision: while left < right?\" then \"Yes → ... \" lines for inside loop, \"No → ... \" for after loop. But we need to end loop with \"End while\" maybe.\n\nSimplify: Use while loop represented as Decision.\n\nAlternatively use \"Decision: left < right?\" with Yes branch containing loop body; No branch proceeding to return.\n\nBut we can structure: Decision: while left < right? \nYes → Step 2... (body)\nNo  → Step 10: return left // after loop\n\nBut we need to represent internal steps inside loop. So we can indent.\n\nLet's craft output accordingly.\n\nWe must use Start, End markers.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: left ← matrix[0][0] // 設定最小值為矩陣左上角\n→ Step 2: right ← matrix[n-1][n-1] // 設定最大值為矩陣右下角\n→ Decision: left < right? // 只要搜尋區間還有多個值，就繼續迴圈\n    Yes → Step 3: mid ← (left + right) // 取區間中點作為候選值\n    → Step 4: count ← 0 // 初始化小於等於 mid 的元素個數\n    → Step 5: i ← 0, j ← n-1 // 從右上角開始遍歷矩陣\n    → Decision: i < n and j >= 0? // 逐行逐列計數\n        Yes → Decision: matrix[i][j] <= mid? // 判斷當前元素是否小於等於 mid\n            Yes → Step 6: count ← count + (n - i) // 所有此列右側的元素均 <= mid\n            → Step 7: j ← j - 1 // 向左移動到上一列\n            No → Step 8: i ← i + 1 // 向下移動到下一行\n        No  → // 走出內層 while 循環\n    → Decision: count < k? // 根據計數判斷 k 是否在右側區間\n        Yes → Step 9: left ← mid + 1 // k 在右側，更新左邊界\n        No  → Step 10: right ← mid // k 在左側，更新右邊界\n    No  → // 走出外層 while 循環，搜尋區間已收斂\n→ Step 11: return left // left 即為第 k 小的元素\nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # 建立 nums1 的頻率字典\n        freq = {}\n        for x in nums1:\n            freq[x] = freq.get(x, 0) + 1\n\n        # 遍歷 nums2，若有匹配就加入結果並減少頻率\n        result = []\n        for y in nums2:\n            if freq.get(y, 0) > 0:\n                result.append(y)\n                freq[y] -= 1\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n\n    # 先從輸入中找出兩個列表\n    list_strs = re.findall(r'\\[([^\\]]*)\\]', data)\n\n    if len(list_strs) >= 2:\n        # 解析兩個列表為整數列表\n        nums1 = [int(x) for x in list_strs[0].split(',') if x.strip() != '']\n        nums2 = [int(x) for x in list_strs[1].split(',') if x.strip() != '']\n    else:\n        # 若找不到列表，可嘗試逐行讀取\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            nums1 = [int(x) for x in lines[0].split(',') if x.strip() != '']\n            nums2 = [int(x) for x in lines[1].split(',') if x.strip() != '']\n        else:\n            nums1 = []\n            nums2 = []\n\n    # 計算交集並輸出\n    sol = Solution()\n    ans = sol.intersect(nums1, nums2)\n    print(ans)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for intersection of two integer arrays. Each element appears as many times as it appears in both arrays. Output array any order.\n\nWe need to output step-by-step virtual code lines. We need to use Start, Decision, End, arrows. Each line: \"虛擬碼步驟 // 解釋\". We need to produce steps like:\n\nStart\n→ Step 1: 初始化空集合/字典 for freq1\n→ Step 2: 遍歷 nums1, 計算頻率\n→ Decision: 如果 nums2 为空? ...\nBut we can also produce simple algorithm: use hash map counts for nums1, iterate nums2 subtract, push to result.\n\nLet's produce simple steps:\n\nStart\n→ Step 1: 建立哈希表 count1 用於存儲 nums1 中每個數字的頻率 // 用字典記錄 nums1 的頻次\n→ Step 2: 對 nums1 中每個元素 x，若 x 在 count1 中則 count1[x]++，否則 count1[x] = 1 // 填充哈希表\n→ Step 3: 建立空列表 result 用於存儲交集元素 // 初始化結果列表\n→ Step 4: 遍歷 nums2 中每個元素 y // 逐一處理 nums2\n    → Decision: y 是否存在於 count1 且 count1[y] > 0? // 檢查 y 是否還有剩餘匹配\n        Yes → Step 5: 將 y 加入 result // 將匹配元素加入結果\n        Yes → Step 6: 將 count1[y] 減 1 // 佔用一次頻次\n        No  → // 若不存在或頻次為 0，跳過\n→ End // 返回 result\n\nWe need to produce step numbers maybe not needed but okay.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows.\n\nLet's craft.\n\nMake sure to include arrow before each step except Start? The example shows Start then arrow for each step. Yes.\n\nWe need to include \"Decision:\" line for if. For yes/no arrow, indent.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 count1 // 用於儲存 nums1 中每個數字的頻率\n→ Step 2: 遍歷 nums1，對每個數字 x：\n    → Step 2a: 若 count1 已包含 x，則 count1[x] += 1，否則 count1[x] = 1 // 計算頻率\n→ Step 3: 建立空列表 result // 用於儲存交集元素\n→ Step 4: 遍歷 nums2，對每個數字 y：\n    → Decision: y 在 count1 中且 count1[y] > 0? // 檢查是否還有匹配\n        Yes → Step 5: 將 y 加入 result // 添加到結果\n        Yes → Step 6: count1[y] -= 1 // 消耗一個頻次\n        No  → // 不匹配，忽略\nEnd // 程式執行結束\n\nWe might need to use \"→\" for arrows and \"Yes →\" \"No →\". In example, after Decision, indent and use Yes → and No →. Also the step numbers may be sequential.\n\nLet's format exactly:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 count1 // 用於儲存 nums1 中每個數字的頻率\n→ Step 2: 遍歷 nums1，對每個數字 x：\n    → Step 2a: 若 count1 已包含 x，則 count1[x] += 1，否則 count1[x] = 1 // 計算頻率\n→ Step 3: 建立空列表 result // 用於儲存交集元素\n→ Step 4: 遍歷 nums2，對每個數字 y：\n    → Decision: y 是否存在於 count1 且 count1[y] > 0? // 檢查 y 是否還有匹配\n        Yes → Step 5: 將 y 加入 result // 添加到結果\n        Yes → Step 6: count1[y] -= 1 // 消耗一個頻次\n        No  → // 不匹配，忽略\nEnd // 程式執行結束\n\nCheck for arrow after Decision: Yes → Step 5, etc. The \"Yes\" line maybe not required but we keep.\n\nWe also need to ensure the comment is after a space: `//` with a space after. They used a single space. We'll match.\n\nLet's output exactly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 count1 // 用於儲存 nums1 中每個數字的頻率\n→ Step 2: 遍歷 nums1，對每個數字 x：\n    → Step 2a: 若 count1 已包含 x，則 count1[x] += 1，否則 count1[x] = 1 // 計算頻率\n→ Step 3: 建立空列表 result // 用於儲存交集元素\n→ Step 4: 遍歷 nums2，對每個數字 y：\n    → Decision: y 是否存在於 count1 且 count1[y] > 0? // 檢查 y 是否還有匹配\n        Yes → Step 5: 將 y 加入 result // 添加到結果\n        Yes → Step 6: count1[y] -= 1 // 消耗一個頻次\n        No  → // 不匹配，忽略\nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzjdyvjfr.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzjdyvjfr.py\", line 30, in parse_input\n    nums = ast.literal_eval(val)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # dp[i] 代表能組成總額 i 的組合數\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 只有一種方式組成 0，即不選任何數\n\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef parse_input(data: str):\n    \"\"\"\n    從字串中擷取 nums 與 target\n    期望格式類似: \"nums = [1,2,3], target = 4\"\n    \"\"\"\n    nums = None\n    target = None\n    for part in data.split(','):\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key == 'nums':\n            nums = ast.literal_eval(val)\n        elif key == 'target':\n            target = int(val)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    nums, target = parse_input(raw_input)\n\n    # 若輸入格式不符，直接終止\n    if nums is None or target is None:\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.combinationSum4(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines: Start, steps, decisions. Problem: number of combinations to sum to target from array of distinct integers. We want number of ordered combinations? Usually Leetcode 377: Combination Sum IV. That's number of possible combinations where order matters. Use DP: dp[0] = 1; for i in 1..target: for num in nums: if num <= i: dp[i] += dp[i-num]. So produce pseudo-code.\n\nWe need to output line by line: Each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow →. Also include Decision blocks.\n\nLet's write steps:\n\nStart // 程式開始\n→ Step 1: 初始化 dp[0] = 1, dp[1..target] = 0 // 基礎 dp 陣列\n→ Step 2: For i from 1 to target // 逐個目標總額\n    → Decision: 是否已經進入 i 迴圈? // 進入迴圈\n        Yes → Step 3: For each num in nums // 逐個元素\n            → Decision: 若 num <= i? // 可用於組合\n                Yes → Step 4: dp[i] = dp[i] + dp[i - num] // 加總組合數\n                No  → Step 5: 省略此 num // 不符合條件\nEnd // 結束所有迴圈\n→ Step 6: 返回 dp[target] // 結果\n\nBut need arrow syntax and decisions. We can embed decisions for loop? Maybe simpler: For i... and for each num. We can incorporate decisions inside loops.\n\nLet's produce.\n\nWe should have Step labels unique.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 target+1，並設 dp[0] = 1, 其餘 0 // 初始化動態規劃表\n→ Step 2: 迴圈 i 取值 1 到 target // 遞增目標金額\n    → Decision: i 是否已經小於等於 target? // 判斷是否進入迴圈\n        Yes → Step 3: 內層迴圈 遍歷 nums // 每個數字作為選項\n            → Decision: num <= i? // 是否能用此數字達到目標\n                Yes → Step 4: dp[i] = dp[i] + dp[i - num] // 更新組合數\n                No  → Step 5: 繼續下一個 num // 不適用\nEnd // 所有迴圈結束\n→ Step 6: 回傳 dp[target] // 結果輸出\n\nBut we must ensure arrow and indentation. According to format: use \"→ Step...\" and \"Decision:\" blocks.\n\nBetter to follow format strictly:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 陣列 // dp[0] = 1 其餘 0\n→ Decision: 迴圈 i 取值 1~target? // 判斷是否進入\n    Yes → Step 2: for i in 1..target\n        → Decision: 內層迴圈 nums? // 是否開始遍歷\n            Yes → Step 3: for each num in nums\n                → Decision: num <= i? // 可用\n                    Yes → Step 4: dp[i] = dp[i] + dp[i - num] // 更新\n                    No  → Step 5: 繼續\nEnd // 程式結束\n→ Step 6: 回傳 dp[target] // 輸出\n\nBut we need to show step numbers sequentially? The format doesn't require numbering but uses \"Step 1:\" etc. Provide each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立長度為 target+1 的 dp 陣列，並將 dp[0] 設為 1，其他皆為 0 // 初始化動態規劃表  \n→ Decision: 是否需要進行迴圈 i 取值 1~target? // 檢查是否有目標金額  \n Yes → Step 2: 迴圈 i 從 1 迭代到 target // 處理每一個可能的總額  \n  → Decision: 進入內層迴圈遍歷 nums? // 檢查是否開始使用每個數字  \n   Yes → Step 3: 內層迴圈 for 每個 num 在 nums 中  \n    → Decision: num 是否小於等於 i? // 判斷此數字是否可用於組合  \n     Yes → Step 4: dp[i] = dp[i] + dp[i - num] // 將以 num 組成 i 的方法數累加  \n     No → Step 5: 繼續到下一個 num // 當 num > i 時跳過  \nEnd // 所有迴圈結束  \n→ Step 6: 回傳 dp[target] // 輸出符合目標的組合總數"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left, right):\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left, right):\n        i = 0\n        # find the interval that might contain 'left'\n        for idx, (l, r) in enumerate(self.ranges):\n            if l <= left < r:\n                i = idx\n                break\n        else:\n            return False\n        return left >= self.ranges[i][0] and right <= self.ranges[i][1]\n\n    def removeRange(self, left, right):\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    variables = {}\n    outputs = []\n\n    for line in data:\n        line = line.strip()\n        if not line:\n            continue\n\n        # constructor\n        if '=' in line and 'new RangeModule' in line:\n            left_part, _ = line.split('=', 1)\n            var_name = left_part.strip().split()[-1]\n            variables[var_name] = RangeModule()\n            outputs.append(None)\n            continue\n\n        # method call\n        if '.' in line:\n            var_part, rest = line.split('.', 1)\n            var_name = var_part.strip()\n            obj = variables.get(var_name)\n            if obj is None:\n                continue\n            rest = rest.strip().rstrip(';')\n            method_name = rest.split('(')[0]\n            args_str = rest[rest.find('(')+1:rest.rfind(')')]\n            args = []\n            if args_str.strip():\n                for part in args_str.split(','):\n                    args.append(int(part.strip()))\n            if method_name == 'queryRange':\n                res = getattr(obj, method_name)(*args)\n                outputs.append(res)\n            else:\n                getattr(obj, method_name)(*args)\n                outputs.append(None)\n\n    # format output as [null, null, true, ...]\n    mapping = {None: 'null', True: 'true', False: 'false'}\n    formatted = '[' + ', '.join(mapping.get(x, str(x)) for x in outputs) + ']'\n    print(formatted)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for designing RangeModule. Likely using interval tree or sorted list. Provide steps: initialization, addRange, queryRange, removeRange. Each step explain. Provide start, decisions. Use virtual code with arrow. No actual code. Use typical algorithm: maintain list of non-overlapping intervals sorted. For add: merge. For query: check coverage. For remove: split. Provide steps.\n\nLet's create generic structure: Start → Step1: init intervals list → etc. For each method. Provide decisions. Use simplified pseudocode.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個有序、無重疊的區間列表 intervals = [] // 只存已追蹤的區間  \n→ End // 初始化完成  \n\n---  \n\nStart // addRange 方法開始  \n→ Step 2: 輸入 left, right // 取得需要加入的區間  \n→ Decision: intervals 是否為空？  \n Yes → Step 3: 將 [left, right) 直接加入 intervals，並排序 // 沒有區間可合併  \n No → Step 4: 尋找所有與 [left, right) 重疊或相鄰的區間  \n  → Step 5: 合併這些區間與 [left, right)，得到 newLeft = min(left, 最小左端)  \n    newRight = max(right, 最大右端)  \n  → Step 6: 刪除所有重疊/相鄰區間並插入 [newLeft, newRight)  \n→ End // addRange 執行完畢  \n\n---  \n\nStart // queryRange 方法開始  \n→ Step 7: 輸入 left, right  \n→ Decision: intervals 中是否存在一個區間 [l, r) 使得 l <= left 且 right <= r？  \n Yes → Step 8: 回傳 true // 這段區間完全被追蹤  \n No  → Step 9: 回傳 false // 不是完整覆蓋  \n→ End // queryRange 執行完畢  \n\n---  \n\nStart // removeRange 方法開始  \n→ Step 10: 輸入 left, right  \n→ Decision: intervals 中是否存在與 [left, right) 重疊的區間？  \n Yes → Step 11: 對每個重疊區間 [l, r)：  \n   → Decision: l < left < r？  \n    Yes → Step 12: 保留左側區間 [l, left)  \n   → Decision: l < right < r？  \n    Yes → Step 13: 保留右側區間 [right, r)  \n  → Step 14: 刪除原始重疊區間  \n No  → Step 15: 不做任何事 // 沒有重疊區間  \n→ End // removeRange 執行完畢  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,true,true,false,2,true,true,true,4]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, true, true, false, 2, true, true, true, 4]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass MyCircularDeque:\n    def __init__(self, k: int):\n        \"\"\"初始化雙端佇列，容量為 k\"\"\"\n        self.k = k\n        self.buf = [0] * k          # 用於存儲元素的緩衝區\n        self.head = 0               # head 指向目前前端元素的位置\n        self.count = 0              # 目前佇列中元素的數量\n\n    def insertFront(self, value: int) -> bool:\n        \"\"\"在前端插入元素，若已滿則返回 False\"\"\"\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        \"\"\"在後端插入元素，若已滿則返回 False\"\"\"\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self) -> bool:\n        \"\"\"刪除前端元素，若佇列為空則返回 False\"\"\"\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self) -> bool:\n        \"\"\"刪除後端元素，若佇列為空則返回 False\"\"\"\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self) -> int:\n        \"\"\"取得前端元素，若佇列為空則返回 -1\"\"\"\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self) -> int:\n        \"\"\"取得後端元素，若佇列為空則返回 -1\"\"\"\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self) -> bool:\n        \"\"\"判斷佇列是否為空\"\"\"\n        return self.count == 0\n\n    def isFull(self) -> bool:\n        \"\"\"判斷佇列是否已滿\"\"\"\n        return self.count == self.k\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data or len(data) < 2:\n        sys.exit(0)\n\n    # 解析操作名稱與對應參數\n    ops = ast.literal_eval(data[0])   # 例如 [\"MyCircularDeque\", \"insertLast\", ...]\n    args_list = ast.literal_eval(data[1])  # 例如 [[3], [1], ...]\n\n    results = []\n    obj = None\n\n    for i, op in enumerate(ops):\n        args = args_list[i]\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            results.append(None)          # 建構子返回值視為 null\n        else:\n            # 呼叫對應方法並將結果加入\n            method = getattr(obj, op)\n            res = method(*args)\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, following the format. Use arrow symbols, decisions. The code describes MyCircularDeque class implementation. We need to detail initialization, operations, conditions. Use virtual code, not real code. Each line ends with // 解釋.\n\nWe should start with Start, then Step definitions.\n\nWe need to cover constructor, insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Use decision nodes for checks.\n\nLet's produce step lines. Use consistent naming. Use \"→\" for flow. For decision: \"Decision:\" then Yes →, No →.\n\nWe should outline initialization: set array of size k, front and rear pointers, count.\n\nWe can create array buffer, front index pointing to current front, rear index pointing to current rear, but typical circular deque uses front and rear pointers. Implementation: use array of size k, front index pointing to next insertion at front? Could use front pointer to index of front element, rear pointer to index of rear element. For empty, set front = -1, rear = -1.\n\nImplement insertFront: if full -> false. If empty -> set front = rear = 0; else front = (front - 1 + k) % k; set data[front] = value; return true.\n\nSimilarly insertLast: if full -> false; if empty -> front = rear = 0; else rear = (rear + 1) % k; set data[rear] = value; return true.\n\nDeleteFront: if empty -> false; if front == rear -> front = rear = -1; else front = (front + 1) % k; return true.\n\nDeleteLast: similar.\n\ngetFront: if empty -> -1 else data[front].\n\ngetRear: if empty -> -1 else data[rear].\n\nisEmpty: front == -1.\n\nisFull: ((rear + 1) % k == front).\n\nWe'll produce virtual steps accordingly.\n\nWe need to cover decision branching. Let's start.\n\nUse Start, then Step 1: Initialize attributes. Use Decision nodes for empty/full.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: MyCircularDeque(k) // 建構子，接收最大容量 k\n    → Step 2: 建立長度為 k 的數組 buffer // 用於儲存元素\n    → Step 3: 設定 front = -1 // 前端指標初始為空\n    → Step 4: 設定 rear = -1 // 後端指標初始為空\n    → Step 5: 設定 size = k // 最大容量\n→ End // 完成初始化\n\nThen insertFront: \nStart Operation insertFront(value)\n→ Decision: 是否已滿? (isFull?) // 判斷是否能插入\n    Yes → Step: 回傳 false // 已滿則失敗\n    No  → Decision: 是否為空? (isEmpty?) // 檢查空狀態\n        Yes → Step: front = rear = 0 // 第一個元素\n        No  → Step: front = (front - 1 + size) % size // 往前移\n        → Step: buffer[front] = value // 存值\n        → Step: 回傳 true // 成功\n\nSimilar for insertLast.\n\nDeleteFront: Decision isEmpty? etc.\n\nWe need to maintain consistent style: \"→\" then \"Step\". Use \"Yes →\" and \"No →\". Provide explanation after each.\n\nLet's generate lines.\n\nWe'll need to include comments after each line.\n\nLet's produce a comprehensive step-by-step virtual code.\n\nUse \"Start\" and \"End\" for each method? Probably not necessary. Just use for each function.\n\nWe'll output:\n\nStart // 程式開始執行\n\n→ Step 1: MyCircularDeque(k) // 建構子，接收最大容量 k\n→ Step 2: buffer = new array of size k // 用於儲存元素\n→ Step 3: front = -1 // 前端指標初始為空\n→ Step 4: rear = -1 // 後端指標初始為空\n→ Step 5: size = k // 記錄容量\n→ End // 完成初始化\n\nThen for insertFront:\n\nStart // insertFront 操作開始\n→ Decision: 如果 isFull()? // 檢查是否已滿\n    Yes → Step: return false // 已滿，插入失敗\n    No  → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step: front = rear = 0 // 空時將兩指標設為 0\n        No  → Step: front = (front - 1 + size) % size // 往前移動指標\n        → Step: buffer[front] = value // 存入值\n        → Step: return true // 插入成功\n→ End // insertFront 完成\n\nSimilarly for insertLast:\n\nStart // insertLast 操作開始\n→ Decision: 如果 isFull()? // 檢查是否已滿\n    Yes → Step: return false // 已滿，插入失敗\n    No  → Decision: 如果 isEmpty()? // 檢查是否為空\n        Yes → Step: front = rear = 0 // 空時兩指標設為 0\n        No  → Step: rear = (rear + 1) % size // 往後移動指標\n        → Step: buffer[rear] = value // 存值\n        → Step: return true // 插入成功\n→ End // insertLast 完成\n\nDeleteFront:\n\nStart // deleteFront 操作開始\n→ Decision: 如果 isEmpty()? // 檢查是否為空\n    Yes → Step: return false // 空，刪除失敗\n    No  → Decision: 如果 front == rear? // 只剩一個元素\n        Yes → Step: front = rear = -1 // 刪除後空\n        No  → Step: front = (front + 1) % size // 移動前端指標\n        → Step: return true // 刪除成功\n→ End // deleteFront 完成\n\nDeleteLast:\n\nStart // deleteLast 操作開始\n→ Decision: 如果 isEmpty()? // 檢查是否為空\n    Yes → Step: return false // 空，刪除失敗\n    No  → Decision: 如果 front == rear? // 只剩一個元素\n        Yes → Step: front = rear = -1 // 刪除後空\n        No  → Step: rear = (rear - 1 + size) % size // 往前移動後端指標\n        → Step: return true // 刪除成功\n→ End // deleteLast 完成\n\ngetFront:\n\nStart // getFront 操作開始\n→ Decision: 如果 isEmpty()? // 檢查是否為空\n    Yes → Step: return -1 // 空，返回 -1\n    No  → Step: return buffer[front] // 返回前端值\n→ End // getFront 完成\n\ngetRear:\n\nStart // getRear 操作開始\n→ Decision: 如果 isEmpty()? // 檢查是否為空\n    Yes → Step: return -1 // 空，返回 -1\n    No  → Step: return buffer[rear] // 返回後端值\n→ End // getRear 完成\n\nisEmpty:\n\nStart // isEmpty 操作開始\n→ Step: return front == -1 // 判斷前端是否為 -1\n→ End // isEmpty 完成\n\nisFull:\n\nStart // isFull 操作開始\n→ Step: return (rear + 1) % size == front // 判斷是否已滿\n→ End // isFull 完成\n\nMake sure each line ends with \"// 解釋\".\n\nWe also need to include comments for decision outcomes.\n\nLet's format accordingly.\n\nWe need to include \"Decision:\" lines with Yes →, No →. Each decision line must have comment. Also steps after each.\n\nWe should produce the lines exactly as requested.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MyCircularDeque(k) // 建構子，接收最大容量 k  \n→ Step 2: buffer = new array of size k // 用於儲存元素  \n→ Step 3: front = -1 // 前端指標初始為空  \n→ Step 4: rear = -1 // 後端指標初始為空  \n→ Step 5: size = k // 記錄容量  \n→ End // 完成初始化  \n\nStart // insertFront 操作開始  \n→ Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Step: return false // 已滿，插入失敗  \n    No → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Step: front = rear = 0 // 空時將兩指標設為 0  \n        No → Step: front = (front - 1 + size) % size // 往前移動指標  \n    → Step: buffer[front] = value // 存入值  \n    → Step: return true // 插入成功  \n→ End // insertFront 完成  \n\nStart // insertLast 操作開始  \n→ Decision: 如果 isFull()? // 檢查是否已滿  \n    Yes → Step: return false // 已滿，插入失敗  \n    No → Decision: 如果 isEmpty()? // 檢查是否為空  \n        Yes → Step: front = rear = 0 // 空時兩指標設為 0  \n        No → Step: rear = (rear + 1) % size // 往後移動指標  \n    → Step: buffer[rear] = value // 存值  \n    → Step: return true // 插入成功  \n→ End // insertLast 完成  \n\nStart // deleteFront 操作開始  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Step: return false // 空，刪除失敗  \n    No → Decision: 如果 front == rear? // 只剩一個元素  \n        Yes → Step: front = rear = -1 // 刪除後空  \n        No → Step: front = (front + 1) % size // 移動前端指標  \n    → Step: return true // 刪除成功  \n→ End // deleteFront 完成  \n\nStart // deleteLast 操作開始  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Step: return false // 空，刪除失敗  \n    No → Decision: 如果 front == rear? // 只剩一個元素  \n        Yes → Step: front = rear = -1 // 刪除後空  \n        No → Step: rear = (rear - 1 + size) % size // 往前移動後端指標  \n    → Step: return true // 刪除成功  \n→ End // deleteLast 完成  \n\nStart // getFront 操作開始  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Step: return -1 // 空，返回 -1  \n    No → Step: return buffer[front] // 返回前端值  \n→ End // getFront 完成  \n\nStart // getRear 操作開始  \n→ Decision: 如果 isEmpty()? // 檢查是否為空  \n    Yes → Step: return -1 // 空，返回 -1  \n    No → Step: return buffer[rear] // 返回後端值  \n→ End // getRear 完成  \n\nStart // isEmpty 操作開始  \n→ Step: return front == -1 // 判斷前端是否為 -1  \n→ End // isEmpty 完成  \n\nStart // isFull 操作開始  \n→ Step: return (rear + 1) % size == front // 判斷是否已滿  \n→ End // isFull 完成"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjn0wdjxt.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpjn0wdjxt.py\", line 48, in main\n    result = solver.complexNumberMultiply(a_str, b_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjn0wdjxt.py\", line 17, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpjn0wdjxt.py\", line 13, in parse\n    real_part = int(s[:split_pos])\n                ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '1+'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"將兩個複數字串相乘並回傳結果字串\"\"\"\n        def parse(s: str):\n            \"\"\"解析複數字串，回傳 (real, imag) 的整數對\"\"\"\n            s = s.rstrip('i')                # 移除尾端的 'i'\n            # 找出最後一個 '+' 或 '-' 以切分實部與虛部\n            pos_plus = s.rfind('+')\n            pos_minus = s.rfind('-')\n            split_pos = max(pos_plus, pos_minus)\n            real_part = int(s[:split_pos])\n            imag_part = int(s[split_pos:])\n            return real_part, imag_part\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a+bi)(c+di) = (ac-bd) + (ad+bc)i\n        real_res = a_real * b_real - a_imag * b_imag\n        imag_res = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_res}+{imag_res}i\"\n\ndef main():\n    \"\"\"主程式：從 stdin 讀取兩個複數字串，輸出相乘結果\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入字串拆成兩個項目\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) < 2:\n        # 若未以逗號分隔，嘗試以換行分隔\n        parts = [p.strip() for p in data.splitlines() if p.strip()]\n    if len(parts) < 2:\n        raise ValueError(\"輸入格式錯誤，需兩個複數字串\")\n\n    def strip_quotes(s: str) -> str:\n        \"\"\"移除字串兩端的雙引號（若存在）\"\"\"\n        return s[1:-1] if s.startswith('\"') and s.endswith('\"') else s\n\n    a_str = strip_quotes(parts[0])\n    b_str = strip_quotes(parts[1])\n\n    solver = Solution()\n    result = solver.complexNumberMultiply(a_str, b_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line has code step and comment. Need to output in Traditional Chinese. Format: Start, → Step, Decision, Yes →, No →, End. Must avoid actual code, just pseudo. Provide explanation after space and //. Must produce all steps. Complexity: parse string, compute product: (a+bi)*(c+di)= (ac - bd) + (ad+bc)i. Must produce string. Steps: Start. Step: parse num1: extract real1, imag1. Step: parse num2. Step: compute real product. Step: compute imag product. Step: build string. End.\n\nAlso need to handle plus/minus signs and i. Could use decision for plus sign. But we can assume input format always \"real+imaginaryi\" or \"real-imaginaryi\". For simplicity, parse by splitting at 'i', removing 'i', then split at '+' or '-' except first char. Could include decision: if '+' after first char else '-'. But pseudo can be simple.\n\nI'll write steps: Step 1: Parse num1 into real1, imag1. Explanation: split string to get real and imag. Step 2: Parse num2 similarly. Step 3: Compute real part: real1*real2 - imag1*imag2. Step 4: Compute imaginary part: real1*imag2 + imag1*real2. Step 5: Convert result to string: realPart + sign + abs(imagPart) + 'i'. Step 6: Return string. End.\n\nWe can add decision for sign: Decision: imagPart >= 0? Yes → use '+', else use '-'. Step for building string accordingly. Use string building.\n\nLet's produce virtual code lines.\n\nNeed arrow formatting: Start //, → Step 1: ... //, → Step 2: ... //, etc.\n\nInclude decisions: Decision: imagPart >= 0? // etc.\n\nWe'll produce maybe Step 5: Build sign. Yes → part: resultStr = realPart + '+' + imagPart + 'i'; No → resultStr = realPart + '-' + abs(imagPart) + 'i'. Actually need abs.\n\nBetter: Step 5: Determine sign. Decision: imagPart >= 0? // check if imag part non-negative\n   Yes → Step 5a: resultStr = realPart + '+' + imagPart + 'i' // positive sign\n   No → Step 5b: resultStr = realPart + '-' + abs(imagPart) + 'i' // negative sign\nStep 6: Return resultStr.\n\nWe need to use appropriate syntax: Use → for arrow, Decision: if. Use Yes → and No → under Decision.\n\nMake sure each line ends with // explanation.\n\nLet's craft.\n\nWe also need to ensure we don't use actual code. Use descriptive steps: \"Parse string into components\", etc.\n\nLet's produce.\n\nAlso include parsing step: e.g., Step 1: Split num1 at 'i' to separate real+imag part. Then split at '+' or '-' to get real and imag. But we can summarise: Extract real1, imag1.\n\nOk. We'll produce 12-15 lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 num1 的字串表示 // 從輸入取得第一個複數字串  \n→ Step 2: 解析 num1 成實部 real1 與虛部 imag1  \n    // 先移除尾端 'i'，再以 '+' 或 '-'（非首字元）分割，得到整數值  \n→ Step 3: 取得 num2 的字串表示 // 從輸入取得第二個複數字串  \n→ Step 4: 解析 num2 成實部 real2 與虛部 imag2  \n    // 同步方式處理 num2  \n→ Step 5: 計算實部乘積 realPart = real1 * real2 - imag1 * imag2  \n    // (ac - bd)  \n→ Step 6: 計算虛部乘積 imagPart = real1 * imag2 + imag1 * real2  \n    // (ad + bc)  \n→ Step 7: 建立結果字串前的符號判斷  \n    Decision: imagPart >= 0? // 判斷虛部正負  \n        Yes → Step 7a: resultStr = realPart + '+' + imagPart + 'i'  \n            // 正數時直接加 '+' 符號  \n        No  → Step 7b: resultStr = realPart + '-' + abs(imagPart) + 'i'  \n            // 負數時加 '-' 並取絕對值顯示  \n→ Step 8: 回傳 resultStr // 將最終字串輸出為結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        找出重複檔案的路徑，根據檔案內容做分組。\n        \"\"\"\n        content_map = defaultdict(list)  # 內容 -> 其檔案完整路徑列表\n\n        for path in paths:\n            parts = path.split()            # 以空白分隔，第一個是目錄路徑\n            root = parts[0]                # 目錄完整路徑\n            for file_info in parts[1:]:    # 後面都是檔案資訊\n                name, content = file_info.split('(')  # 取得檔名與內容\n                content = content[:-1]    # 去掉最後的 ')'\n                full_path = f\"{root}/{name}\"   # 組成完整路徑\n                content_map[content].append(full_path)\n\n        # 只保留重複的組別 (至少兩個檔案)\n        return [files for files in content_map.values() if len(files) > 1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析 'paths = [...]' 的格式，取得右側列表\n    try:\n        rhs = raw_input.split('=', 1)[1].strip()\n        paths = ast.literal_eval(rhs)\n    except Exception as e:\n        # 如果輸入格式不符，直接終止\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code lines. For given problem: find duplicate file paths by content. Steps: Start, parse each input string: split by space to separate path and file info. For each file info: extract filename and content via parentheses. Build map content->list of file paths. Finally filter list for size>=2. Return list.\n\nWe must produce each line with comment. Use arrows. Need to maintain hierarchy with decisions. Probably not many decisions. We could include decisions: if content already in map? etc.\n\nWe need each line as \"虛擬碼步驟 // 解釋\". So line starts with e.g., \"Start // 程式開始\". Then \"→ Step 1: 初始化映射 contentMap = {} // 建立內容到檔案路徑的映射\". Then \"→ Step 2: 遍歷每個 directoryInfo in paths // 逐一處理每個目錄資訊\". Then inside: \"→ Step 2.1: 分割 directoryInfo 為 dirPath 與 fileInfos // 取得目錄路徑及檔案資訊\". Then \"→ Step 2.2: 對每個 fileInfo 做處理\". \"→ Step 2.2.1: 解析 fileName 與 content\". \"→ Step 2.2.2: 建立 fullPath = dirPath + '/' + fileName\". \"→ Step 2.2.3: 若 content 存於 contentMap，則 append fullPath; 否則新建 list\". Then after loop: \"→ Step 3: 建立 result = []\". \"→ Step 3.1: 對 contentMap.values 進行過濾，只保留 size>=2\". \"→ Step 3.1.1: 將符合條件的 list 加入 result\". \"End // 結束\".\n\nAdd decisions? We can add a decision: \"Decision: content 是否已存在?\" etc.\n\nOk produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化映射 contentMap = {} // 建立內容到檔案路徑的映射  \n→ Step 2: 遍歷每個 directoryInfo in paths // 逐一處理每個目錄資訊  \n → Decision: 是否為空字串?  \n  Yes → Skip // 空字串直接跳過  \n  No → Step 2.1: 分割 directoryInfo 為 dirPath 與 fileInfos // 取得目錄路徑及檔案資訊  \n   → Step 2.1.1: 取第一個空格前為 dirPath  \n   → Step 2.1.2: 其後所有片段為 fileInfos 列表 // 每個片段格式為 fileName(content)  \n  → Step 2.2: 遍歷每個 fileInfo in fileInfos // 逐一處理檔案  \n   → Step 2.2.1: 解析 fileName 與 content  \n    → Step 2.2.1.1: 以 '(' 為分隔符取得 fileName  \n    → Step 2.2.1.2: 以 ')' 為分隔符取得 content  \n   → Step 2.2.2: 建立完整路徑 fullPath = dirPath + '/' + fileName // 生成檔案完整路徑  \n   → Decision: content 是否已在 contentMap?  \n    Yes → Step 2.2.3: contentMap[content].append(fullPath) // 追加至已存在的清單  \n    No  → Step 2.2.4: contentMap[content] = [fullPath] // 建立新的清單  \n→ Step 3: 建立 result = [] // 用於儲存重複檔案組別  \n→ Step 4: 遍歷 contentMap.values // 逐一檢查每個內容對應的檔案清單  \n → Decision: 清單長度 >= 2?  \n  Yes → Step 4.1: result.append(list) // 加入重複檔案組別  \n  No  → Skip // 只保留重複的組別  \nEnd // 程式執行結束，返回 result 其中包含所有重複檔案路徑組別"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdj24wbno.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmpdj24wbno.py\", line 51, in main\n    ops = ast.literal_eval(match.group(1))\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app']\n                                                                              ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass TrieNode:\n    \"\"\"Trie 節點，保存子節點映射與單詞結尾標記。\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    \"\"\"前綴樹實作，支援插入、搜尋與前綴判斷。\"\"\"\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main() -> None:\n    \"\"\"主程式：讀取操作與參數，執行前綴樹操作並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：兩個列表，中間以逗號分隔\n    match = re.match(r'\\s*(\\[.*\\])\\s*,\\s*(\\[.*\\])\\s*$', data, re.S)\n    if not match:\n        raise ValueError(\"輸入格式錯誤，應為兩個列表\")\n\n    ops = ast.literal_eval(match.group(1))\n    args = ast.literal_eval(match.group(2))\n\n    if len(ops) != len(args):\n        raise ValueError(\"操作數與參數數量不匹配\")\n\n    result = []\n    trie_obj = None\n\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie_obj = Trie()\n            result.append(None)          # LeetCode 樣式返回 null\n        else:\n            func = getattr(trie_obj, op)\n            res = func(*arg)\n            result.append(res)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. It's a pseudo-code of implementing a Trie class with methods. Should produce lines with \"虛擬碼步驟 // 解釋\". Use arrows. Probably structure: Start, Step: instantiate root, etc. Use Decision? For methods: insert, search, startsWith. We'll represent as high-level algorithm.\n\nLet's create:\n\nStart\n→ Step 1: 定義 TrieNode 類別 // Node with children map and end flag\n→ Step 2: 定義 Trie 類別\n   → Step 2.1: 構造函式：初始化根節點 // Root node with empty children\n→ Step 3: 定義 insert 方法\n   → Step 3.1: 設定 current = root // 開始於根\n   → Step 3.2: 對於每個字母 ch in word\n        → Step 3.2.1: 如果 ch 不在 current.children\n              → Step 3.2.1.1: 新增 child node for ch\n        → Step 3.2.2: current = current.children[ch] // 移動到子節點\n   → Step 3.3: current.isEnd = true // 標記為單詞結尾\n→ Step 4: 定義 search 方法\n   → Step 4.1: 設定 current = root\n   → Step 4.2: 對於每個字母 ch in word\n        → Decision: 如果 ch 不在 current.children? // 是否存在此字母\n            Yes → current = current.children[ch]\n            No → Return false // 沒有路徑，字串不存在\n   → Step 4.3: Return current.isEnd // 只在單詞結尾時為真\n→ Step 5: 定義 startsWith 方法\n   → Step 5.1: 設定 current = root\n   → Step 5.2: 對於每個字母 ch in prefix\n        → Decision: 如果 ch 不在 current.children?\n            Yes → current = current.children[ch]\n            No → Return false\n   → Step 5.3: Return true // 所有前綴字母都存在\nEnd\n\nLet's format each line: \"虛擬碼步驟 // 解釋\" using arrows.\n\nEnsure each line contains arrow or decision. We'll use \"→\" before each step. For decisions, indent maybe. For clarity, we can indent lines after decisions.\n\nWe'll output each line separate. Ensure we follow example. Use \"Start // 程式開始執行\". Use \"End // 程式執行結束\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別 // 建立節點類別，包含子節點映射與結尾標記  \n→ Step 2: 定義 Trie 類別 // 主資料結構  \n → Step 2.1: 構造函式：初始化 root 為 TrieNode // 根節點初始為空  \n→ Step 3: 定義 insert 方法 // 插入單詞  \n → Step 3.1: 設定 current = root // 從根開始  \n → Step 3.2: 對於每個字母 ch 在 word  \n  → Decision: 如果 ch 不在 current.children? // 是否已有此字母子節點  \n   Yes → Step 3.2.1: current.children[ch] = new TrieNode // 新增節點  \n   No → // 已存在，無需新增  \n  → Step 3.2.2: current = current.children[ch] // 移動到子節點  \n → Step 3.3: current.isEnd = true // 標記單詞結尾  \n→ Step 4: 定義 search 方法 // 查找完整單詞  \n → Step 4.1: 設定 current = root  \n → Step 4.2: 對於每個字母 ch 在 word  \n  → Decision: 如果 ch 不在 current.children? // 路徑是否存在  \n   Yes → current = current.children[ch] // 進一步搜尋  \n   No → Return false // 路徑斷開，單詞不存在  \n → Step 4.3: Return current.isEnd // 只有在結尾處才算成功  \n→ Step 5: 定義 startsWith 方法 // 判斷前綴  \n → Step 5.1: 設定 current = root  \n → Step 5.2: 對於每個字母 ch 在 prefix  \n  → Decision: 如果 ch 不在 current.children? // 路徑是否存在  \n   Yes → current = current.children[ch] // 進一步搜尋  \n   No → Return false // 前綴不存在  \n → Step 5.3: Return true // 所有字母均存在，前綴有效  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[6]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,1]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 1]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,5,4]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 5, 4]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\n# 先定義 rand7()，這是題目給的 API\ndef rand7() -> int:\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        while True:\n            # 兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10  # 1~10 的均勻分布\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw = sys.stdin.read().strip()\n    # 從輸入中擷取數字，例如 \"n = 3\"\n    n = int(''.join(filter(str.isdigit, raw)))\n    \n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code steps for rand10 using rand7. Common approach: use two rand7 to create 49 possibilities, reject >40 to get uniform 1-10. Use rejection sampling.\n\nSo steps:\n\nStart\n→ Generate a = rand7() // first roll\n→ Generate b = rand7() // second roll\n→ Compute result = (a-1)*7 + b // maps 1-49\n→ Decision: if result <= 40? // 40 acceptable\n    Yes → output result % 10 + 1 // map to 1-10\n    No → go back to start // repeat\n\nNeed to consider remainders? Actually mapping: 1-40 to 1-10: result%10 + 1 gives 1-10 uniformly because 40 divisible by 10.\n\nThus pseudocode.\n\nBut must use \"Step X\" format.\n\nLet's produce.\n\nNote: For rejection loop we might use while true. Use a decision. Use \"Decision:\" with Yes/No.\n\nWe need each line of virtual code with explanation. Use \"Start\", \"End\". Use arrow \"→\" to indicate next.\n\nWe need to use only rand7.\n\nSo produce steps:\n\nStart\n→ Step 1: a ← rand7() // first random number 1-7\n→ Step 2: b ← rand7() // second random number 1-7\n→ Step 3: res ← (a-1)*7 + b // combine to 1-49\n→ Decision: res ≤ 40? // check if within usable range\n    Yes → Step 4: return (res % 10) + 1 // map 1-40 to 1-10 uniformly\n    No  → Step 5: Go back to Step 1 // retry until success\nEnd\n\nBut \"Step 5: Go back to Step 1\" maybe use loop arrow. We can express with \"→ Step 1\" again.\n\nHowever we must keep step numbers sequential? It's okay to have step 5 refer to Step 1.\n\nWe need to keep formatting: \"虛擬碼步驟 [空格] // 解釋\". So for each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: a ← rand7() // 取得第一個 1~7 的隨機數  \n→ Step 2: b ← rand7() // 取得第二個 1~7 的隨機數  \n→ Step 3: res ← (a-1)*7 + b // 把兩個 1~7 組合成 1~49 的隨機數  \n→ Decision: res ≤ 40? // 檢查結果是否落在可接受範圍內  \n Yes → Step 4: return (res % 10) + 1 // 1~40 平均映射為 1~10，回傳結果  \n No  → Step 5: Go back to Step 1 // 超過 40 時重試，重新開始  \nEnd // 程式執行結束"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvly7dkne.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvly7dkne.py\", line 27, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp86a0wxlx.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp86a0wxlx.py\", line 27, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnjurzy2i.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnjurzy2i.py\", line 27, in parse_input\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        Binary search to find the index of target or insertion point.\n        Time complexity: O(log n)\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(data: str):\n    \"\"\"\n    解析類似 'nums = [1,3,5,6], target = 5' 的輸入字串。\n    \"\"\"\n    parts = data.split(',')\n    nums_part = parts[0].strip()\n    target_part = parts[1].strip()\n    # 取得列表字串\n    nums_str = nums_part[len('nums = '):]\n    nums = eval(nums_str)\n    # 取得目標值\n    target = int(target_part[len('target = '):])\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    nums, target = parse_input(raw_input)\n    sol = Solution()\n    result = sol.searchInsert(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for binary search insertion position problem. Use Start, End, Decision, arrows. We need line by line.\n\nWe need to output virtual code lines with explanation after //.\n\nStructure: Start, → Set low = 0 // start index; → Set high = len(array)-1 // end index; → Decision: while low <= high? Actually typical loop. But we need binary search. Use loop.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: low ← 0 // 設定搜尋區間左端\n→ Step 2: high ← len(array) - 1 // 設定搜尋區間右端\n→ Decision: low <= high? // 判斷是否還有未搜尋區間\n    Yes → Step 3: mid ← low + (high - low) // 計算中間索引\n    → Decision: array[mid] == target? // 判斷是否找到目標\n        Yes → Step 4: Return mid // 找到則回傳索引\n        No  → Decision: array[mid] < target? // 若中間值小於目標\n            Yes → Step 5: low ← mid + 1 // 移動左端至 mid+1\n            No  → Step 6: high ← mid - 1 // 移動右端至 mid-1\n    No → Step 7: Return low // 搜尋結束，回傳插入位置\nEnd // 程式結束\n\nWe need to include End at end. Provide each line with explanation. Should be exactly that. Use 虛擬碼步驟, e.g. \"Start\", \"→ Step 1: low ← 0\", etc. Use arrow for each step.\n\nAlso note \"Decision:\" lines.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0 // 設定搜尋區間左端  \n→ Step 2: high ← len(array) - 1 // 設定搜尋區間右端  \n→ Decision: low <= high? // 判斷是否還有未搜尋區間  \n Yes → Step 3: mid ← low + (high - low) // 計算中間索引，避免溢位  \n  → Decision: array[mid] == target? // 判斷是否找到目標  \n   Yes → Step 4: Return mid // 找到則回傳索引  \n   No → Decision: array[mid] < target? // 若中間值小於目標  \n    Yes → Step 5: low ← mid + 1 // 移動左端至 mid+1，縮小搜尋範圍  \n    No  → Step 6: high ← mid - 1 // 移動右端至 mid-1，縮小搜尋範圍  \n No → Step 7: Return low // 搜尋結束，low 即為插入位置  \nEnd // 程式結束執行"
    },
    {
      "title": "Delete and Earn",
      "source_file": "Leetcode/leetcode740.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[2,2,3,3,3,4]",
          "expected_output": "9",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '9'\nGot (Norm):      '13'\n--- (Raw) ---\nRaw Expected: '9'\nRaw Got:      '13'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def deleteAndEarn(self, nums):\n        if not nums:\n            return 0\n        # Build frequency map\n        freq = Counter(nums)\n        # Sort unique numbers\n        unique_nums = sorted(freq.keys())\n        prev_num = 0\n        take = 0   # max points if we take current number\n        skip = 0   # max points if we skip current number\n        for num in unique_nums:\n            cur = freq[num] * num\n            if num == prev_num + 1:\n                # Adjacent: must consider previous skip\n                new_take = skip + cur\n                new_skip = max(take, skip)\n                take, skip = new_take, new_skip\n            else:\n                # Not adjacent: we can add cur to the best of previous\n                take = max(take, skip) + cur\n                skip = max(take, skip)  # skip is best of previous (after updating take)\n            prev_num = num\n        return max(take, skip)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n    else:\n        # Parse input like '[3,4,2]'\n        nums = ast.literal_eval(data)\n        solution = Solution()\n        result = solution.deleteAndEarn(nums)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solution of \"Delete and Earn\" problem (Leetcode 740). Provide line-by-line steps, using virtual code, with arrows and decisions.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, End.\n\nWe need to produce algorithm: count frequency, sort keys, dynamic programming.\n\nLet's craft.\n\n- Start\n- Step 1: Build frequency map of numbers\n- Step 2: Get sorted unique numbers\n- Step 3: Initialize prev=0, take=0, skip=0\n- Loop through numbers:\n    - Decision: if current - prev == 1 (adjacent)\n        - Yes: new_take = skip + current*freq\n                new_skip = max(take, skip)\n                take=new_take, skip=new_skip\n    - No: (non adjacent)\n                take = max(take, skip) + current*freq\n                skip = max(take, skip) (but careful after update)\nWe can simplify: use prevNum variable. Use DP: dp[i] = max(dp[i-1], dp[i-2] + value). But we need to implement virtual.\n\nLet's produce simplified steps:\n\n- Step 4: For each number in sorted list:\n    - Decision: if number == prev+1? // adjacent\n        - Yes: new_take = prev_skip + number*freq\n              new_skip = max(prev_take, prev_skip)\n              prev_take = new_take\n              prev_skip = new_skip\n    - No: // non adjacent\n        - prev_take = max(prev_take, prev_skip) + number*freq\n        - prev_skip = max(prev_take, prev_skip) // but prev_take updated\n    - Update prev to number\n- End: Return max(prev_take, prev_skip)\n\nWe must also handle initial prev=0, prev_take=0, prev_skip=0.\n\nLet's produce pseudocode lines accordingly.\n\nMake sure each line includes comment.\n\nAlso, we should include variable definitions: freqMap, uniqueNums, etc.\n\nLet's output.\n\nWe need to maintain that the virtual code arrow lines use '→', 'Decision:'. Also indent for branches.\n\nLet's produce.\n\nExample:\n\nStart // 程式開始\n\n→ Step 1: 初始化頻率映射 freqMap ← 空字典 // 建立數字頻率表\n\n→ Step 2: 對 nums 中每個 num: freqMap[num] ← freqMap.get(num,0)+1 // 計算每個數字出現次數\n\n→ Step 3: 取得所有鍵並排序 uniqueNums ← sorted(freqMap.keys()) // 取得升序唯一數字\n\n→ Step 4: 初始化 prevNum ← 0 // 上一個處理的數字\n\n→ Step 5: 初始化 take ← 0, skip ← 0 // DP：上一次選擇或不選擇的最大分數\n\n→ Decision: 是否進入迴圈? // 判斷 uniqueNums 是否非空\n\n    Yes → 迴圈: 對每個 num in uniqueNums: // 逐一處理每個數字\n\n        → Step 6: freq ← freqMap[num] // 取得當前數字的頻率\n\n        → Decision: 如果 num == prevNum + 1? // 檢查是否相鄰\n\n            Yes → // 相鄰，必須更新 take、skip\n                → Step 7: newTake ← skip + num * freq // 若選擇此數字\n                → Step 8: newSkip ← max(take, skip) // 若跳過此數字\n                → Step 9: take ← newTake\n                → Step 10: skip ← newSkip\n\n            No → // 不相鄰，可把前一次最大分數加上此數字的分數\n                → Step 11: take ← max(take, skip) + num * freq\n                → Step 12: skip ← max(take, skip) // 更新跳過的分數\n\n        → Step 13: prevNum ← num // 更新上一個數字\n\n→ Step 14: result ← max(take, skip) // 取兩種狀態中的最大值\n\nEnd // 程式結束\n\nWe need to output each line with '//' comment.\n\nLet's ensure correct formatting: Each line begins with \"→\" for steps inside loops, etc. Indentation indicated by spaces or tabs? Provide spaces.\n\nBetter to include indentation for branches: e.g.,\n\n→ Decision: ...  \n    Yes → Step ...  \n    No → Step ...\n\nBut in the example, they used indentation: each branch line has two spaces indent.\n\nWe need to produce similar.\n\nLet's craft final output.\n\nAlso note that \"Step 1:\" etc.\n\nLet's output final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化頻率映射 freqMap ← 空字典 // 建立數字頻率表  \n→ Step 2: 對 nums 中每個 num: freqMap[num] ← freqMap.get(num,0)+1 // 計算每個數字出現次數  \n→ Step 3: 取得所有鍵並排序 uniqueNums ← sorted(freqMap.keys()) // 取得升序唯一數字  \n→ Step 4: 初始化 prevNum ← 0 // 上一個處理的數字  \n→ Step 5: 初始化 take ← 0, skip ← 0 // DP：上一次選擇或不選擇的最大分數  \n\n→ Decision: 是否進入迴圈? // 判斷 uniqueNums 是否非空  \n    Yes → 迴圈: 對每個 num in uniqueNums: // 逐一處理每個數字  \n        → Step 6: freq ← freqMap[num] // 取得當前數字的頻率  \n        → Decision: 如果 num == prevNum + 1? // 檢查是否相鄰  \n            Yes → // 相鄰，必須更新 take、skip  \n                → Step 7: newTake ← skip + num * freq // 若選擇此數字  \n                → Step 8: newSkip ← max(take, skip) // 若跳過此數字  \n                → Step 9: take ← newTake  \n                → Step 10: skip ← newSkip  \n            No → // 不相鄰，可把前一次最大分數加上此數字的分數  \n                → Step 11: take ← max(take, skip) + num * freq  \n                → Step 12: skip ← max(take, skip) // 更新跳過的分數  \n        → Step 13: prevNum ← num // 更新上一個數字  \n→ Step 14: result ← max(take, skip) // 取兩種狀態中的最大值  \nEnd // 程式結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            rest = acc[2:]\n            for email in [first_email] + rest:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        return [[email_to_name[root]] + sorted(emails) for root, emails in merged.items()]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input; expect format like \"accounts = [[...], [...]]\" or just the list\n    if '=' in data:\n        _, accounts_str = data.split('=', 1)\n        accounts = eval(accounts_str.strip())\n    else:\n        accounts = eval(data)\n    solution = Solution()\n    result = solution.accountsMerge(accounts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for merging accounts, step-by-step with explanations. Use Start, End, Decision, etc. No actual code. Must be in Traditional Chinese.\n\nWe produce algorithm: Build graph of emails, union find, map email to name, union edges if same account. Then group emails by root, sort each, prepend name. Return list.\n\nNeed to be line-by-line with virtual code. Let's produce:\n\nStart\n→ Step 1: 初始化 UnionFind 结构 // 为每个邮箱创建独立集合\n→ Step 2: 建立 email → name 映射 // 记录每个邮箱对应的姓名\n→ Decision: 遍历 accounts // 处理每个账号\n    → Step 3: 取账号的第一个元素作为姓名 // accounts[i][0]\n    → Step 4: 取账号的剩余元素为 emails // accounts[i][1:]\n    → Decision: 处理 emails\n        → Step 5: 对于 emails[0] 作为基准邮箱\n            → Step 6: 对于剩余每个邮箱\n                → Step 7: Union(基准邮箱, 当前邮箱) // 合并集合\n→ Step 8: 初始化 字典 groups // 根 → 邮箱列表\n→ Decision: 遍历所有邮箱\n    → Step 9: 找到根 = Find(email) // 取得集合根\n    → Step 10: groups[根].append(email) // 将邮箱加入对应组\n→ Step 11: 初始化结果列表 res\n→ Decision: 遍历 groups\n    → Step 12: 取根，获取对应邮箱列表 list_emails\n    → Step 13: 将 list_emails 按字典序排序\n    → Step 14: 取 email_to_name[根] 获取姓名 // 用根邮箱的姓名\n    → Step 15: 组合 [姓名] + sorted_emails 成一条记录\n    → Step 16: res.append(记录)\n→ End // 返回 res\n\nWe must keep virtual code line by line, each line ending with // 解釋.\n\nWe need to use arrow \"→\". For decisions we need indentation.\n\nLet's format with proper indentation:\n\nStart // 程式開始執行\n→ Step 1: 初始化 UnionFind 结构 // 建立每個電郵的獨立集合\n→ Step 2: 建立 email → name 映射 // 記錄每個電郵對應的姓名\n→ Decision: 遍歷 accounts // 處理每個帳號\n    → Step 3: 取 accounts[i][0] 為 name // 第一個元素為姓名\n    → Step 4: 取 accounts[i][1:] 為 emails // 後續為電郵列表\n    → Decision: 處理 emails\n        → Step 5: 若 emails 非空，取 emails[0] 為基準電郵 // 用於 Union\n        → Decision: 遍歷 emails[1:]\n            → Step 6: Union(基準電郵, 當前電郵) // 合併同一人\n→ Step 7: 初始化 groups 字典 // 根 → 電郵列表\n→ Decision: 遍歷所有電郵\n    → Step 8: root = Find(電郵) // 找到集合根\n    → Step 9: groups[root].append(電郵) // 加入對應組\n→ Step 10: 初始化結果列表 res\n→ Decision: 遍歷 groups\n    → Step 11: list_emails = groups[root] // 取得該組電郵\n    → Step 12: list_emails.sort() // 字典序排序\n    → Step 13: name = email_to_name[root] // 用根電郵取姓名\n    → Step 14: record = [name] + list_emails // 組成一筆資料\n    → Step 15: res.append(record) // 加入結果\n→ End // 程式執行結束\n\nNeed to include explanation after each line. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 UnionFind 结构 // 為每個電郵建立獨立集合  \n→ Step 2: 建立 email → name 映射 // 記錄每個電郵對應的姓名  \n→ Decision: 遍歷 accounts // 處理每個帳號  \n → Step 3: 取 accounts[i][0] 為 name // 第一個元素為姓名  \n → Step 4: 取 accounts[i][1:] 為 emails // 後續為電郵列表  \n → Decision: 取 emails  \n  → Step 5: 若 emails 非空，取 emails[0] 為基準電郵 // 用於 Union  \n  → Decision: 遍歷 emails[1:]  \n   → Step 6: Union(基準電郵, 當前電郵) // 合併同一人的電郵集合  \n→ Step 7: 初始化 groups 字典 // 根 → 電郵列表  \n→ Decision: 遍歷所有電郵  \n → Step 8: root = Find(電郵) // 找到集合根  \n → Step 9: groups[root].append(電郵) // 加入對應組  \n→ Step 10: 初始化結果列表 res // 用於儲存合併後的帳號  \n→ Decision: 遍歷 groups  \n → Step 11: list_emails = groups[root] // 取得該組電郵  \n → Step 12: list_emails.sort() // 按字典序排序  \n → Step 13: name = email_to_name[root] // 用根電郵取得姓名  \n → Step 14: record = [name] + list_emails // 組成一筆完整帳號  \n → Step 15: res.append(record) // 加入結果列表  \n→ End // 程式執行結束，返回 res 供使用者查看\n\n> **說明**：上述虛擬碼描述了使用 Union‑Find（合併集合）演算法，將擁有共同電郵的帳號合併；最後將每個集合內的電郵排序，並與對應姓名一起輸出。"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n\n        # BFS 取得最短距離與前驅字典\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path: list[str], word: str) -> None:\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(s: str) -> tuple[str, str, list[str]]:\n    \"\"\"Parse input like:\n       beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    \"\"\"\n    parts = [p.strip() for p in s.split(',')]\n    data = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # 使用 literal_eval 解析字串、列表等\n        try:\n            data[key] = ast.literal_eval(val)\n        except Exception:\n            data[key] = val.strip('\"\\'')\n    return data['beginWord'], data['endWord'], data['wordList']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    begin, end, word_list = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findLadders(begin, end, word_list)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for word ladder all shortest paths. Use BFS to find shortest level, then DFS/backtracking to build all paths. Provide virtual code lines. Ensure use of arrows and decision structures. Each line with explanation. Let's craft.\n\nWe need steps: Start, initialize. Check endWord in wordList else return empty. Build adjacency via generic states. BFS to get distance map. Then DFS build paths. We'll write steps line by line. Use indents maybe? Use arrow →. For decisions use Decision:.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 endWord 不在 wordList? // 檢查終點是否可達  \n  Yes → Step 1: 回傳空清單 // 無有效路徑  \n  No  → Step 2: 建立字典字典 {word: 可達距離} // 用 BFS 先求最短距離  \n→ Step 3: 初始化 BFS 隊列 Q ← {beginWord} // 從起始字開始探索  \n→ Step 4: 設定距離 Map dist[beginWord] ← 0  \n→ Step 5: 迴圈 While Q 非空  \n  → Step 6: 取出 front = Q.pop()  \n  → Step 7: 若 front == endWord? // 到達終點  \n    Yes → Break // BFS 結束，距離已確定  \n    No → Decision: 對每個位置 i 產生 allPossible = {front[0..i-1] + c + front[i+1..] | c in 'a'..'z'} // 產生所有單字變化  \n       Yes → Decision: 若 allPossible[i] in wordList 且 (i 未在 dist 或 dist[i] == dist[front]+1)? // 可行且是最短或等距  \n         Yes → Step 8: 設定 dist[變化] ← dist[front]+1  \n           → Q.push(變化) // 加入下一層探索  \n           → Step 9: 建立父關係 parents[變化] ← parents[變化] ∪ {front} // 記錄前驅節點  \n           No → Continue  \n       No → Continue  \n→ Step 10: 若 endWord 不在 dist? // BFS 未找到路徑  \n    Yes → Step 11: 回傳空清單 // 無路徑  \n    No  → Step 12: 建立結果列表 paths ← []  \n→ Step 13: 進行 DFS( current = endWord, path = [endWord] ) // 從終點回溯到起點  \n  → Decision: 若 current == beginWord? // 完成一條路徑  \n    Yes → Step 14: paths.add( reverse(path) ) // 加入反轉後的完整路徑  \n    No  → Decision: 若 parents[current] 存在? // 有前驅節點  \n      Yes → 迴圈 for each p in parents[current]  \n        → DFS( current = p, path = [p] + path ) // 递归继续  \n       No → Return // 無前驅，終止此分支  \n→ Step 15: 回傳 paths // 所有最短變換序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,0,4,6,1,0,6,0]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 0, 4, 6, 1, 0, 6, 0]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # 建立黑名單集合與映射表\n        self.mapping = {}\n        self.size = n - len(blacklist)          # 可用數量\n        black_set = set(blacklist)\n        last = n - 1                            # 從最高數字開始尋找\n\n        for b in blacklist:\n            if b < self.size:                   # 只對前 size 個位置進行映射\n                while last in black_set:        # 找到一個非黑名單的高端數字\n                    last -= 1\n                self.mapping[b] = last          # 建立映射\n                last -= 1\n\n    def pick(self):\n        # 隨機產生 0 ~ size-1 之間的索引\n        idx = random.randint(0, self.size - 1)\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    # 讀取兩行 JSON 格式的輸入\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    names = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    outputs = []\n\n    for name, args in zip(names, args_list):\n        if name == \"Solution\":\n            obj = Solution(*args)\n            outputs.append(None)\n        else:\n            method = getattr(obj, name)\n            result = method(*args)\n            outputs.append(result)\n\n    # 以 JSON 格式輸出結果\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to output pseudo-code line by line, with comments. The algorithm is typical: map allowed numbers from 0..n-1 but excluding blacklist. Approach: let m = n - len(blacklist). Create a map for white numbers in first m that might be blacklisted. For each blacklisted number < m, map it to a whitelisted number from the high end (>= m). Then pick a random integer r in [0, m-1], if r is in map return map[r], else return r.\n\nWe need to provide constructor and pick method.\n\nWe should explain each line.\n\nUse Start/End and Decision structures. Use arrow.\n\nLet's produce pseudo-code.\n\nWe need to keep line-by-line with comment. Use \"Solution: ...\" etc. Use Start at beginning of class. Probably:\n\nStart // 程式開始執行\n→ Step 1: 定義 m = n - blacklist.length // 計算有效數字個數\n\nBut we need to maintain inside constructor and pick.\n\nWe'll create variables:\n\nn, m, map.\n\nLet's produce.\n\nWe need to use \"Decision:\" lines for loops maybe? For loop is not a decision but we can treat as step. Use arrow.\n\nOk.\n\nLet's produce.\n\nWill include pseudocode for constructor:\n\nSolution(n, blacklist):\n\n→ Step 1: set this.n = n\n→ Step 2: set this.m = n - length(blacklist)\n→ Step 3: initialize empty map whiteMap\n\n→ Step 4: create set blackSet from blacklist for quick lookup\n\n→ Step 5: Initialize pointer high = n - 1\n\n→ Step 6: For each b in blacklist:\n    → Decision: 如果 b < m? // 只有在前 m 個位置被黑名單才需要映射\n        Yes → Step 7: While high in blackSet:\n                    high = high - 1 // 找到一個非黑名單的高端數字\n                 End // 跳出 while\n        Yes → Step 8: whiteMap[b] = high // 將黑名單映射到高端白名單\n        Yes → Step 9: high = high - 1 // 移動高端指針\n    No → Continue // 黑名單數字在後半段不需要映射\nEnd // for loop\n\nNow pick method:\n\npick():\n\n→ Step 10: r = randomInt(0, m-1) // 取得隨機數\n\n→ Decision: r in whiteMap? // 判斷是否需要映射\n    Yes → Return whiteMap[r]\n    No  → Return r\n\nEnd // 程式結束\n\nAlso we need to mark start and end of constructor and method. Use arrow.\n\nLet's format accordingly.\n\nWe must include arrow symbols and decisions indent.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution(n, blacklist) // 建立 Solution 物件  \n    → Step 2: this.n = n // 儲存總範圍  \n    → Step 3: this.m = n - length(blacklist) // 計算可選數量  \n    → Step 4: this.map = empty map // 建立映射表  \n    → Step 5: blackSet = set(blacklist) // 快速判斷黑名單  \n    → Step 6: high = n - 1 // 指向範圍高端數字  \n    → Decision: for each b in blacklist? // 逐一處理黑名單  \n        Yes → Step 7: if b < this.m? // 只處理前 m 個位置  \n            Yes → Step 8: while high in blackSet? // 找非黑高端數字  \n                Yes → high = high - 1 // 下降至下一個候選  \n                No  → End // 找到可用數字  \n            End  \n            Yes → Step 9: this.map[b] = high // 建立映射  \n            Yes → Step 10: high = high - 1 // 更新高端指針  \n            No  → Continue // b 在後半段不需要映射  \n        No  → Continue // b 在後半段不需要處理  \n    End // for 迴圈  \nEnd // 建構子結束  \n\n→ Method: pick() // 隨機挑選一個非黑名單數字  \n    → Step 11: r = randomInt(0, this.m - 1) // 取得 0~m-1 之間的隨機數  \n    → Decision: r in this.map? // 判斷是否需要映射  \n        Yes → Return this.map[r] // 回傳映射後的白名單數字  \n        No  → Return r // 原數字即為合法數字  \nEnd // pick 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[None,None,0,None,0]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[None, None, 0, None, 0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    __slots__ = (\"children\", \"sum\")\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_val = {}\n\n    def insert(self, key: str, val: int) -> None:\n        old = self.key_val.get(key, 0)\n        delta = val - old\n        if delta == 0:\n            return\n        self.key_val[key] = val\n        node = self.root\n        node.sum += delta\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入轉成兩個列表\n    data = '(' + data + ')'\n    try:\n        cmds, args = ast.literal_eval(data)\n    except Exception:\n        # 若輸入格式不符直接返回\n        return\n\n    result = []\n    map_sum = None\n    for cmd, arg in zip(cmds, args):\n        if cmd == \"MapSum\":\n            map_sum = MapSum()\n            result.append(None)\n        elif cmd == \"insert\":\n            key, val = arg\n            map_sum.insert(key, val)\n            result.append(None)\n        elif cmd == \"sum\":\n            prefix = arg\n            result.append(map_sum.sum(prefix))\n        else:\n            result.append(None)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (not actual code) for MapSum with operations insert and sum. Use Start, End, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to design algorithm: use trie with sums at nodes. Also need a hashmap to track current key values. Implementation steps: initialize trie root, hashmap. insert: compute delta = newVal - oldVal (if exists), update hashmap, traverse trie adding delta to each node. sum: traverse trie following prefix, return node.sum. Provide pseudocode.\n\nWe output line by line, using arrow. Each line must be step or decision. Provide comments after //.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 keyToVal // 追蹤每個 key 的目前值\n→ Step 2: 建立 TrieNode root // Trie 根節點，含 children、sum\n→ End // 初始化完成\n\nInsert operation:\n→ Step 1: 取得舊值 old = keyToVal[key] if 存在 else 0 // 取決於是否已存在\n→ Step 2: 計算 delta = val - old // 差值用於更新 Trie\n→ Step 3: keyToVal[key] = val // 更新字典\n→ Step 4: node = root // 開始從根節點遍歷\n→ Decision: 如果 delta ≠ 0? // 只有值變更時才需更新 Trie\n    Yes →\n        → Step 5: node.sum += delta // 更新根節點的 sum\n        → Step 6: 針對 key 的每個字符 c\n            → Step 7: 若 node.children 沒有 c 則新增 TrieNode // 建立新節點\n            → Step 8: node = node.children[c] // 移到下一節點\n            → Step 9: node.sum += delta // 更新此節點的 sum\n        → End\n    No → End // 沒有變化，跳過\n→ End // insert 完成\n\nSum operation:\n→ Step 1: node = root // 從根節點開始\n→ Decision: 若 prefix 為空字串? // 特殊情況\n    Yes → Step 2: return node.sum // 所有鍵的總和\n    No →\n        → Step 3: 針對 prefix 的每個字符 c\n            → Decision: 若 node.children 没有 c? // 前綴不存在\n                Yes → Step 4: return 0 // 沒有符合的鍵\n                No →\n                    → Step 5: node = node.children[c] // 移到子節點\n            → End\n        → Step 6: return node.sum // 前綴下所有鍵的總和\n→ End // sum 完成\n\nWe need to format each line with 虛擬碼步驟 plus comment. Use arrow → for steps. Use Decision blocks. Provide indentation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立空字典 keyToVal // 用於追蹤每個 key 的目前值\n→ Step 2: 建立 TrieNode root // Trie 根節點，包含 children、sum\nEnd // 初始化完成\n\n// ----------------- 插入操作 -----------------\n→ Step 1: old = keyToVal[key] if key 存在 else 0 // 取得舊值，若不存在則為 0\n→ Step 2: delta = val - old // 計算差值，用於更新 Trie\n→ Step 3: keyToVal[key] = val // 更新字典中的值\n→ Step 4: node = root // 從根節點開始\n→ Decision: delta ≠ 0? // 只有值改變時才需要更新 Trie\n    Yes →\n        → Step 5: node.sum += delta // 更新根節點的 sum\n        → Step 6: for each character c in key\n            → Decision: node.children 沒有 c? // 若沒有該子節點則建立\n                Yes → Step 7: node.children[c] = new TrieNode // 新增子節點\n            → Step 8: node = node.children[c] // 移到子節點\n            → Step 9: node.sum += delta // 更新子節點的 sum\n        → End\n    No → End // delta 為 0 時不需要任何更新\n→ End // insert 完成\n\n// ----------------- sum 操作 -----------------\n→ Step 1: node = root // 從根節點開始\n→ Decision: prefix 為空字串? // 特殊情況：空前綴代表所有鍵\n    Yes → Step 2: return node.sum // 返回整棵樹的 sum\n    No →\n        → Step 3: for each character c in prefix\n            → Decision: node.children 沒有 c? // 前綴不存在\n                Yes → Step 4: return 0 // 沒有符合的鍵，總和為 0\n                No →\n                    → Step 5: node = node.children[c] // 移到子節點\n            → End\n        → Step 6: return node.sum // 前綴下所有鍵的總和\n→ End // sum 完成\n```"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.7952318533831552,-0.3661323400696635],[-0.3495866267227796,0.894660518319911],[0.9449789176241353,-0.2205368808452186]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.7952318533831552, -0.3661323400696635], [-0.3495866267227796, 0.894660518319911], [0.9449789176241353, -0.2205368808452186]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機產生半徑 r，使點在圓內均勻分佈\n        r = self.radius * math.sqrt(random.random())\n        # 隨機角度 theta\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換為笛卡兒座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    # 讀取整個輸入，分成兩行\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 第一行：指令列表，第二行：對應的參數\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    outputs = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 初始化 Solution 物件\n            obj = Solution(*args)\n            outputs.append(None)  # 代表 null\n        elif cmd == \"randPoint\":\n            # 呼叫 randPoint 並儲存結果\n            outputs.append(obj.randPoint())\n        else:\n            # 若有未知指令，可忽略或處理\n            pass\n\n    # 將結果輸出為 JSON\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. Must be line-by-line, each line \"虛擬碼步驟 // 解釋\". Use arrows and structure. Include Start, End, Decision. Should include generating random radius r with sqrt, random angle theta. Then compute x,y. Use uniform distribution: r = sqrt(random()) * radius, theta = random() * 2π. Steps: class Solution { variables radius, x_center, y_center; constructor; randPoint method: generate random double u in [0,1], r = sqrt(u) * radius; generate random double v in [0,1], theta = v * 2π; x = x_center + r * cos(theta); y = y_center + r * sin(theta); return [x,y] }. Use virtual code. Each line separate. Use comments. Ensure to mention random functions. No actual code.\n\nLet's produce virtual code lines. Use \"→\" for step. Use Decision for random? Not needed. But maybe include a decision: if random() < something? Not needed.\n\nWe need to follow output format: each line \"虛擬碼步驟 // 解釋\". Should include Start, End. We'll produce:\n\nStart\n→ Step 1: 定義類別 Solution // 建立類別\n→ Step 2: 宣告變數 radius, x_center, y_center // 儲存圓參數\n→ Step 3: Constructor(radius, x_center, y_center) // 初始化\n    → Step 4: 設定 this.radius = radius\n    → Step 5: 設定 this.x_center = x_center\n    → Step 6: 設定 this.y_center = y_center\n→ Step 7: 定義方法 randPoint() // 產生隨機點\n    → Step 8: 產生 u = RandomDouble(0,1) // 隨機數 0~1\n    → Step 9: 計算 r = sqrt(u) * this.radius // 取距離確保均勻分布\n    → Step 10: 產生 v = RandomDouble(0,1)\n    → Step 11: 計算 theta = v * 2π // 角度\n    → Step 12: 計算 x = this.x_center + r * cos(theta) // 將角度映射到座標\n    → Step 13: 計算 y = this.y_center + r * sin(theta)\n    → Step 14: 回傳 [x, y] // 返回隨機點\nEnd\n\nBut each line must contain \"虛擬碼步驟 // 解釋\". Provide arrow and steps. Need to ensure each line is a single step. Should use indentation? The example shows indentation for decision branches. But we can keep simple.\n\nWe may need to show arrow for each step. For nested steps, use indentation? The example used indentation under Decision. So we can indent nested steps with spaces. We'll produce lines accordingly. Each line: e.g., \"→ Step 3: Constructor(radius, x_center, y_center) // 初始化\" then indent lines under it with spaces before arrow? Example: \"    → Step 4: ...\". We'll follow.\n\nAlso include Start, End. Provide final. No actual code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立類別\n→ Step 2: 宣告變數 radius, x_center, y_center // 儲存圓的半徑與中心座標\n→ Step 3: Constructor(radius, x_center, y_center) // 初始化物件\n    → Step 4: 設定 this.radius = radius // 內部儲存半徑\n    → Step 5: 設定 this.x_center = x_center // 內部儲存中心 x 座標\n    → Step 6: 設定 this.y_center = y_center // 內部儲存中心 y 座標\n→ Step 7: 定義方法 randPoint() // 產生隨機點\n    → Step 8: 產生 u = RandomDouble(0,1) // 取得一個均勻分布的隨機數 0~1\n    → Step 9: 計算 r = sqrt(u) * this.radius // 以 r = √u 方式取得距離，確保點均勻分布於圓內\n    → Step 10: 產生 v = RandomDouble(0,1) // 再取得一個 0~1 的隨機數\n    → Step 11: 計算 theta = v * 2π // 將 v 轉換為角度 0~2π\n    → Step 12: 計算 x = this.x_center + r * cos(theta) // 將極座標轉換為笛卡兒座標\n    → Step 13: 計算 y = this.y_center + r * sin(theta) // 產生 y 座標\n    → Step 14: 回傳 [x, y] // 將點以陣列形式回傳\nEnd // 程式執行結束"
    },
    {
      "title": "Repeated String Match",
      "source_file": "Leetcode/leetcode686.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "a = \"abcd\", b = \"cdabcdab\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "a = \"a\", b = \"aa\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\n\ndef repeated_string_match(a: str, b: str) -> int:\n    \"\"\"\n    將字串 a 重複若干次，找到最小重複次數，使得 b 成為其子字串。\n    若無法滿足，回傳 -1。\n    \"\"\"\n    len_a = len(a)\n    len_b = len(b)\n\n    # 計算最少需要重複多少次才能至少覆蓋 b 的長度\n    repeat = (len_b + len_a - 1) // len_a  # ceil(len_b / len_a)\n    s = a * repeat\n\n    # 先檢查一次重複\n    if b in s:\n        return repeat\n\n    # 再嘗試多一次重複\n    s += a\n    if b in s:\n        return repeat + 1\n\n    return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援以下幾種格式：\n    1. 兩行分別為 a 與 b\n    2. 一行中以空格或逗號分隔的兩個字串\n    3. 以引號包住的字串，例如 a = \"abcd\", b = \"cdabcdab\"\n    \"\"\"\n    tokens = []\n    i = 0\n    n = len(data)\n\n    while i < n:\n        # skip whitespace\n        while i < n and data[i].isspace():\n            i += 1\n        if i >= n:\n            break\n\n        if data[i] in ('\"', \"'\"):\n            # 以引號包住的字串\n            quote = data[i]\n            i += 1\n            start = i\n            while i < n and data[i] != quote:\n                i += 1\n            tokens.append(data[start:i])\n            i += 1  # skip closing quote\n        else:\n            # 普通 token，直到空白或逗號\n            start = i\n            while i < n and not data[i].isspace() and data[i] != ',':\n                i += 1\n            tokens.append(data[start:i])\n\n        # skip optional comma\n        while i < n and data[i] in (',', ' '):\n            i += 1\n\n    if len(tokens) < 2:\n        raise ValueError(\"輸入資料不足兩個字串\")\n    return tokens[0], tokens[1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    try:\n        a_str, b_str = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    result = repeated_string_match(a_str, b_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. The requirement: Given strings a and b, return minimal repeats of a to make b substring, else -1. So algorithm: compute minimal repeats count. Approach: repeated string s = a repeated k times until length >= len(b)+len(a). Actually we can compute minimal repeats = ceil(len(b)/len(a)). Then test if b in repeated string of that many repeats, if not test with one more repeat. If still not, return -1.\n\nEdge cases: If b longer than a repeated many times. We can test up to len(b)/len(a)+2. Implementation steps: start count = ceil(len(b)/len(a)). Build repeated string s = a repeated count times. If b in s, return count. Else build s2 = a repeated count+1 times. If b in s2, return count+1 else -1.\n\nAlso consider if a and b empty? Not specified but typical constraints: non-empty.\n\nVirtual code: Start, Step: input a,b. Step: compute lenA, lenB. Step: compute minCount = (lenB + lenA -1) / lenA. Step: build repeatString = a repeated minCount times. Decision: if b in repeatString? Yes → return minCount. No → build repeatString2 = a repeated (minCount+1) times. Decision: if b in repeatString2? Yes → return minCount+1. No → return -1. End.\n\nAdd comments accordingly.\n\nEnsure using arrow notation and decisions indentation. Provide each line with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字串 a 與 b // 取得使用者輸入的兩個字串  \n→ Step 2: 計算 lenA ← length(a) 與 lenB ← length(b) // 求出兩字串長度  \n→ Step 3: 計算最小重複次數 minCount ← (lenB + lenA - 1) ÷ lenA // ceil(lenB / lenA)  \n→ Step 4: 產生重複字串 repeat ← a 重複 minCount 次 // 建立候選字串  \n→ Decision: 是否存在 b 作為 repeat 的子字串? // 判斷是否已滿足條件  \n    Yes → Step 5: 回傳 minCount // 最小重複數已足夠  \n    No → Step 6: 產生 repeat2 ← a 重複 (minCount + 1) 次 // 再嘗試多重一次  \n    → Decision: 是否存在 b 作為 repeat2 的子字串? // 再次判斷  \n        Yes → Step 7: 回傳 minCount + 1 // 需要多一次重複  \n        No → Step 8: 回傳 -1 // 無法使 b 成為子字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null,[1,2,3],[1,2,3],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    Solution 方案\n    1. 在建構子中把傳入的 nums 拷貝到原始陣列 self.original，避免外部修改影響。\n    2. reset() 回傳原始陣列的拷貝，確保不會被後續操作改變。\n    3. shuffle() 先拷貝原始陣列，然後使用 Fisher–Yates 洗牌演算法做隨機交換，最後回傳打亂後的結果。\n    \"\"\"\n    def __init__(self, nums):\n        self.original = list(nums)          # 原始陣列拷貝\n\n    def reset(self):\n        \"\"\"回傳原始陣列的拷貝\"\"\"\n        return list(self.original)\n\n    def shuffle(self):\n        \"\"\"使用 Fisher–Yates 演算法隨機打亂陣列\"\"\"\n        arr = list(self.original)          # 拷貝後再打亂，保護原始陣列\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 將輸入包裝成外層陣列，方便 json.loads 解析\n    # 例: '[\"Solution\", \"shuffle\"], [[[1,2,3]], []]'  ->  [[...], [...]]\n    wrapped_input = '[' + raw_input + ']'\n    try:\n        commands, arguments = json.loads(wrapped_input)\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"輸入格式錯誤: {e}\")\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"Solution\":\n            # args 形式為 [[1,2,3]]，取第一個元素作為 nums\n            obj = Solution(args[0])\n            result.append(None)  # LeetCode 風格輸出 null\n        elif cmd == \"reset\":\n            res = obj.reset()\n            result.append(res)\n        elif cmd == \"shuffle\":\n            res = obj.shuffle()\n            result.append(res)\n        else:\n            # 若有其他未知方法，可自行處理或忽略\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的 null 風格\n    print(json.dumps(result, separators=(\",\", \":\")))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with comments. Use structure. Provide steps for class, constructor, reset, shuffle. Use Fisher-Yates. Let's produce steps.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 這個類別\n→ Step 2: 宣告私有屬性 original: 整數陣列 // 儲存原始陣列\n→ Step 3: 宣告私有屬性 current: 整數陣列 // 儲存目前陣列的狀態\n→ Step 4: Constructor Solution(nums): // 初始化物件\n    → Assignment: original ← nums // original 指向輸入陣列\n    → Assignment: current ← copy_of(nums) // current 為 original 的副本，避免直接引用\n    → Return: None // 建構完成\n→ Step 5: Method reset(): // 重設陣列\n    → Assignment: current ← copy_of(original) // 重新複製原始陣列\n    → Return: current // 返回重設後的陣列\n→ Step 6: Method shuffle(): // 隨機打亂陣列\n    → Loop i from 0 to length(current)-1: // Fisher–Yates 演算法\n        → Generate random integer j in [i, length(current)-1] // 隨機選取交換位置\n        → Swap current[i] 與 current[j] // 交換元素\n    → End Loop\n    → Return: current // 返回打亂後的陣列\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            # 把目前子集加入結果\n            res.append(path[:])\n            # 從 start 開始嘗試選取剩餘元素\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()  # 回溯\n        backtrack(0, [])\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取列表。\n    支援形如 \"nums = [1,2,3]\" 或僅有列表 \"[1,2,3]\"。\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        # 取得等號右側\n        data = data.split('=', 1)[1].strip()\n    # 找到第一個 '[' 和最後一個 ']'\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1:\n        return []\n    list_str = data[left:right+1]\n    return ast.literal_eval(list_str)\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of unique elements. Use backtracking. Use structure. Provide each line with comment. Must be in Traditional Chinese. Follow format exactly: \"虛擬碼步驟 [space] // 解釋\". Use arrows, Decision, etc. Start, End. We need step by step. Let's craft.\n\nSteps:\n\nStart\n\n→ Step 1: 初始化結果 list result = [] // 記錄所有子集\n\n→ Step 2: 定義遞迴函式 backtrack(start, current) // backtrack 開始索引與目前子集\n\n→ Decision: 如果 start 等於 len(nums)? // 檢查是否已走完\n\n    Yes → Step 3: 複製 current 並加入 result // 完整子集加入結果\n\n    No  → Step 4: backtrack(start+1, current) // 先不選 current 索引元素\n\n    No  → Step 5: current.append(nums[start]) // 選取元素\n\n    No  → Step 6: backtrack(start+1, current) // 繼續遞迴\n\n    No  → Step 7: current.pop() // 回溯，移除最後加入的元素\n\n→ Step 8: 呼叫 backtrack(0, []) // 從索引 0 開始\n\n→ Step 9: 回傳 result // 返回所有子集\n\nEnd\n\nNeed to use arrows correctly. But structure: each line with arrow before step. For decisions, use indentation. Provide arrows. Use Yes →, No →. Need to be consistent.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: Set result = [] // 初始化結果列表\n\n→ Step 2: Define backtrack(start, current) // 定義遞迴函式\n\n    → Decision: If start == len(nums)? // 判斷是否遍歷完陣列\n\n        Yes → Step 3: Append copy of current to result // 加入完整子集\n\n        No  → Step 4: backtrack(start + 1, current) // 先不選取 nums[start]\n\n        No  → Step 5: Append nums[start] to current // 選取元素\n\n        No  → Step 6: backtrack(start + 1, current) // 遞迴處理剩餘\n\n        No  → Step 7: Remove last element from current // 回溯\n\n→ Step 8: backtrack(0, []) // 開始遞迴\n\n→ Step 9: Return result // 返回所有子集\n\nEnd // 程式結束\n\nBut need to keep consistent arrow formatting: Use → before Step, Yes →, No →. The arrow before step and inside decisions. Let's produce accordingly.\n\nRemember each line must contain virtual code and comment. The arrow \"→\" at start of step line. For decisions, indent, maybe use indentation and \"Decision:\" line. Provide \"Decision:\" line then options.\n\nWe'll craft.\n\nAlso ensure no actual code. Use placeholders like \"Set result = []\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set result = [] // 初始化結果列表  \n→ Step 2: Define backtrack(start, current) // 定義遞迴函式  \n  → Decision: If start == len(nums)? // 判斷是否已遍歷完所有元素  \n   Yes → Step 3: Append copy of current to result // 把完整子集加入結果  \n   No  → Step 4: backtrack(start + 1, current) // 先不選取 nums[start]  \n   No  → Step 5: Append nums[start] to current // 把 nums[start] 加入目前子集  \n   No  → Step 6: backtrack(start + 1, current) // 進一步遞迴處理剩餘元素  \n   No  → Step 7: Remove last element from current // 回溯，移除剛加入的元素  \n→ Step 8: backtrack(0, []) // 從索引 0 開始遞迴  \n→ Step 9: Return result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef originalDigits(s: str) -> str:\n    count = Counter(s)\n    out = {}\n    out['0'] = count['z']\n    out['2'] = count['w']\n    out['4'] = count['u']\n    out['6'] = count['x']\n    out['8'] = count['g']\n    out['3'] = count['h'] - out['8']\n    out['5'] = count['f'] - out['4']\n    out['7'] = count['s'] - out['6']\n    out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n    out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n    res = ''.join(k * out[k] for k in sorted(out.keys()))\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    letters = re.findall(r'[a-z]', data)\n    s = ''.join(letters)\n    print(originalDigits(s))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for problem: given string s containing out-of-order English representation of digits 0-9, return the digits in ascending order. We need to output pseudo code line by line with explanations. Use arrow, Start, End, Decision: etc. Should not output real code. Should be in Traditional Chinese. Must include step descriptions.\n\nWe need to think of algorithm: We can count letters and deduce digits using unique letters. Approach: count frequency of each letter. Then identify digits with unique letters: 0:'z', 2:'w', 4:'u', 6:'x', 8:'g', then remove them. Then 3:'h' after 8 removed, 5:'f' after 4 removed, 7:'s' after 6 removed, 1:'o' after 0,2,4 removed, 9:'i' after 5,6,8 removed. Then build output digits ascending.\n\nBut in pseudo we can describe generic method.\n\nWe need to produce each line with explanation. Use arrow, Start, End, Decision.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化字母頻率表 freq[26] 為 0 // 用來統計字串中每個字母出現次數\n\n→ Step 2: 遍歷字串 s，對每個字母 c 將 freq[c - 'a'] 加 1 // 建立頻率表\n\n→ Step 3: 初始化結果列表 digits 為空 // 用於存放檢測到的數字\n\n→ Decision: 是否仍有未處理的數字? // 檢查是否需要繼續判斷\n\nThen for each unique letter mapping:\n\nYes → Step 4: 若 freq['z'] > 0, 那麼對於 count = freq['z'] 循環: 將 0 加入 digits, 並減去 'z','e','r','o' 的頻率 // 0 的唯一字母 z\n\nBut we can just outline sequentially: 0,2,4,6,8,3,5,7,1,9.\n\nBetter to use Steps for each digit.\n\nWe need to incorporate decisions maybe not necessary for each, just simple steps.\n\nWe can produce pseudo code:\n\nStep 4: 處理數字 0 // 以字母 'z' 為唯一標誌\n→ If freq['z'] > 0:\n    - count = freq['z']\n    - 將 0 放入 digits count 次\n    - 減去 'z','e','r','o' 的頻率 count\n\nSimilar for others.\n\nAfter all digits processed, sort digits ascending. Or we can count number of each digit and produce string accordingly.\n\nWe can do: result = \"\" ; for d from 0 to 9: result += string(d, count[d]) ; return result.\n\nPseudo code accordingly.\n\nLet's produce final output lines. Use Traditional Chinese comments.\n\nNeed to keep each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe must use arrow (→) before each step, except maybe Start and End.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 建立字母頻率表 freq[26] 為 0 // 用於統計字串 s 中每個字母出現的次數\n\n→ Step 2: 對 s 中每個字母 c 做: freq[c - 'a']++ // 填充頻率表\n\n→ Step 3: 建立整數陣列 count[10] 為 0 // 存儲每個數字的實際出現次數\n\nThen process digits in order of unique letters:\n\n→ Step 4: 以 'z' 為唯一標誌處理數字 0\n→   count[0] = freq['z']\n→   freq['z'] -= count[0]; freq['e'] -= count[0]; freq['r'] -= count[0]; freq['o'] -= count[0] // 移除對應字母\n\nSimilarly for 2,4,6,8:\n\n→ Step 5: 以 'w' 處理數字 2\n→   count[2] = freq['w']; ... // 移除 't','w','o'\n\n→ Step 6: 以 'u' 處理數字 4\n→   count[4] = freq['u']; ... // 移除 'f','o','u','r'\n\n→ Step 7: 以 'x' 處理數字 6\n→   count[6] = freq['x']; ... // 移除 's','i','x'\n\n→ Step 8: 以 'g' 處理數字 8\n→   count[8] = freq['g']; ... // 移除 'e','i','g','h','t'\n\nThen digits that share letters after removal:\n\n→ Step 9: 以 'h' 處理數字 3\n→   count[3] = freq['h']; ... // 移除 't','h','r','e','e'\n\n→ Step 10: 以 'f' 處理數字 5\n→   count[5] = freq['f']; ... // 移除 'f','i','v','e'\n\n→ Step 11: 以 's' 處理數字 7\n→   count[7] = freq['s']; ... // 移除 's','e','v','e','n'\n\n→ Step 12: 以 'o' 處理數字 1\n→   count[1] = freq['o']; ... // 移除 'o','n','e'\n\n→ Step 13: 以 'i' 處理數字 9\n→   count[9] = freq['i']; ... // 移除 'n','i','n','e'\n\nAfter all counts computed, construct result string:\n\n→ Step 14: 建立空字串 result // 用來保存最終的數字序列\n\n→ Step 15: 從 0 到 9 迭代: 對於每個 d, 將 char('0'+d) 重複 count[d] 次並追加到 result // 生成升序數字字串\n\n→ End // 程式執行結束\n\nWe need to ensure each line uses \"虛擬碼步驟\" part. Example: \"Start // 程式開始執行\".\n\nWe also need arrow before each step: \"→ Step 1: ...\" etc. But we need to include \"虛擬碼步驟\" maybe like \"Step 1: ...\". The format: \"虛擬碼步驟 [space] // 解釋/說明\". The arrow is part of the step, but the sample uses arrow before each step: \"→ Step 1: ...\". So we should use arrow. The requirement says: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we should follow. For steps, use \"→\" before step text. So we produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化字母頻率表 freq[26] 為 0 // 用於統計字串中每個字母的出現次數\n→ Step 2: 遍歷字串 s，對每個字母 c：freq[c - 'a']++ // 填充頻率表\n→ Step 3: 初始化整數陣列 count[10] 為 0 // 存放每個數字的實際數量\n→ Decision: 是否需要處理數字? // 檢查是否還有未處理的數字\nYes → Step 4: 處理數字 0，唯一字母為 'z' // ...\nBut we can skip decision, but maybe not necessary.\n\nThe requirement includes \"Decision:\" lines. We might include one decision for each unique letter? But we can avoid decision for simplicity. But requirement says \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". It doesn't require that we use Decision, but can use them.\n\nWe can optionally use a Decision step to process each unique letter: if freq['z'] > 0. But easier: we can just compute directly.\n\nBut maybe we can add Decision for each mapping:\n\n→ Decision: freq['z'] > 0? // check if 0 appears\n    Yes → Step 4: count[0] = freq['z']; ...\n    No → (skip)\n\nBut not necessary. But requirement says we must use Decision structure? It says \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". It might expect we use at least some Decision. But it's optional. But we can incorporate at least one decision for demonstration. For each unique letter maybe we can show.\n\nHowever, to keep output concise, we can have Decision for each unique letter group:\n\nDecision: freq['z'] > 0? -> Yes: process 0, No: skip. Similarly for other digits.\n\nBut it's a lot of lines. But we can show a pattern: for each digit, we use Decision.\n\nBetter produce:\n\n→ Decision: freq['z'] > 0? // 是否有數字 0\n    Yes → Step 4: count[0] = freq['z']; ... // 0 的處理\n    No  → // 無 0\n\nSimilarly for each.\n\nBut we need to maintain each line. But maybe we can summarise.\n\nBut the requirement: \"逐行輸出。每行必須包含：`虛擬碼步驟` + `[空格]` + `// 解釋/說明`\". So each line must contain the arrow and step and comment. We cannot embed multiple lines in one step. So we need to produce separate lines for each step.\n\nBut we cannot embed Decision block as multiple lines? Actually we can use a Decision line that introduces indentation. Example from sample:\n\nDecision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nThus we need indentation lines. We can produce that. But each step line remains separate.\n\nOk.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 freq[26] 為 0 // 統計字母頻率\n→ Step 2: 遍歷 s，對每個字母 c: freq[c - 'a']++ // 填充頻率表\n→ Step 3: 建立 count[10] 為 0 // 存儲每個數字的實際出現次數\n\nThen we can use Decision to process each digit:\n\nDecision: freq['z'] > 0? // 檢查是否有數字 0\n    Yes → Step 4: count[0] = freq['z'] // 取得 0 的數量\n    Yes → Step 5: 減去 'z','e','r','o' 的頻率 count[0] // 移除 0 的字母\n    No  → // 沒有 0，直接跳過\n\nDecision: freq['w'] > 0? // 檢查是否有數字 2\n    Yes → Step 6: count[2] = freq['w'] // 取得 2 的數量\n    Yes → Step 7: 減去 't','w','o' 的頻率 count[2] // 移除 2 的字母\n    No  → // 無 2\n\nSimilarly for 4,6,8,3,5,7,1,9.\n\nBut this is many lines. But it's okay. But we need to maintain consistent pattern.\n\nBut each Decision block can contain multiple steps, but each step is its own line.\n\nBut we need to indent lines under Decision? In sample they indent by 4 spaces? It shows:\n\nDecision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nThus we need indentation. We'll use 4 spaces indentation for steps under Decision.\n\nOk.\n\nSo produce block for each unique letter:\n\nDecision: freq['z'] > 0? // 是否存在數字 0\n    Yes → Step 4: count[0] = freq['z'] // 取得 0 的個數\n    Yes → Step 5: freq['z'] -= count[0]; freq['e'] -= count[0]; freq['r'] -= count[0]; freq['o'] -= count[0] // 移除 0 對應字母\n    No  → // 無 0\n\nBut we cannot have both Yes steps with same indent? Actually in sample they use Yes → Step ... . So we can use two Yes lines: Yes → Step 4, Yes → Step 5. That seems acceptable.\n\nSimilarly for each.\n\nOk.\n\nWe'll produce all 10 decisions and steps. After all decisions, we produce building result.\n\nLet's produce the final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立字母頻率表 freq[26] 為 0 // 用於統計字串中每個字母的出現次數\n→ Step 2: 遍歷字串 s，對每個字母 c 做: freq[c - 'a']++ // 填充頻率表\n→ Step 3: 建立整數陣列 count[10] 為 0 // 用於儲存每個數字實際出現的次數\n\nDecision: freq['z'] > 0? // 是否存在數字 0\n    Yes → Step 4: count[0] = freq['z'] // 取得 0 的個數\n    Yes → Step 5: freq['z'] -= count[0]; freq['e'] -= count[0]; freq['r'] -= count[0]; freq['o'] -= count[0] // 移除 0 的字母\n    No  → // 無 0\n\nDecision: freq['w'] > 0? // 是否存在數字 2\n    Yes → Step 6: count[2] = freq['w'] // 取得 2 的個數\n    Yes → Step 7: freq['t'] -= count[2]; freq['w'] -= count[2]; freq['o'] -= count[2] // 移除 2 的字母\n    No  → // 無 2\n\nDecision: freq['u'] > 0? // 是否存在數字 4\n    Yes → Step 8: count[4] = freq['u'] // 取得 4 的個數\n    Yes → Step 9: freq['f'] -= count[4]; freq['o'] -= count[4]; freq['u'] -= count[4]; freq['r'] -= count[4] // 移除 4 的字母\n    No  → // 無 4\n\nDecision: freq['x'] > 0? // 是否存在數字 6\n    Yes → Step 10: count[6] = freq['x'] // 取得 6 的個數\n    Yes → Step 11: freq['s'] -= count[6]; freq['i'] -= count[6]; freq['x'] -= count[6] // 移除 6 的字母\n    No  → // 無 6\n\nDecision: freq['g'] > 0? // 是否存在數字 8\n    Yes → Step 12: count[8] = freq['g'] // 取得 8 的個數\n    Yes → Step 13: freq['e'] -= count[8]; freq['i'] -= count[8]; freq['g'] -= count[8]; freq['h'] -= count[8]; freq['t'] -= count[8] // 移除 8 的字母\n    No  → // 無 8\n\nDecision: freq['h'] > 0? // 是否存在數字 3（在 8 移除後）\n    Yes → Step 14: count[3] = freq['h'] // 取得 3 的個數\n    Yes → Step 15: freq['t'] -= count[3]; freq['h'] -= count[3]; freq['r'] -= count[3]; freq['e'] -= 2 * count[3] // 移除 3 的字母\n    No  → // 無 3\n\nDecision: freq['f'] > 0? // 是否存在數字 5（在 4 移除後）\n    Yes → Step 16: count[5] = freq['f'] // 取得 5 的個數\n    Yes → Step 17: freq['f'] -= count[5]; freq['i'] -= count[5]; freq['v'] -= count[5]; freq['e'] -= count[5] // 移除 5 的字母\n    No  → // 無 5\n\nDecision: freq['s'] > 0? // 是否存在數字 7（在 6 移除後）\n    Yes → Step 18: count[7] = freq['s'] // 取得 7 的個數\n    Yes → Step 19: freq['s'] -= count[7]; freq['e'] -= 2 * count[7]; freq['v'] -= count[7]; freq['n'] -= count[7] // 移除 7 的字母\n    No  → // 無 7\n\nDecision: freq['o'] > 0? // 是否存在數字 1（在 0,2,4 移除後）\n    Yes → Step 20: count[1] = freq['o'] // 取得 1 的個數\n    Yes → Step 21: freq['o'] -= count[1]; freq['n'] -= count[1]; freq['e'] -= count[1] // 移除 1 的字母\n    No  → // 無 1\n\nDecision: freq['i'] > 0? // 是否存在數字 9（在 5,6,8 移除後）\n    Yes → Step 22: count[9] = freq['i'] // 取得 9 的個數\n    Yes → Step 23: freq['n'] -= count[9]; freq['i'] -= count[9]; freq['n'] -= count[9]; freq['e'] -= count[9] // 移除 9 的字母\n    No  → // 無 9\n\n→ Step 24: 建立空字串 result // 用於保存最終升序的數字字串\n→ Step 25: 從 0 到 9 迭代: 對於每個 d，將字元('0'+d) 重複 count[d] 次並追加到 result // 生成升序的結果\n→ Step 26: 回傳 result // 將升序字串作為函式輸出\nEnd // 程式執行結束"
    },
    {
      "title": "Binary Search",
      "source_file": "Leetcode/leetcode704.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxhp_fvd0.py\", line 30, in <module>\n    exec(processed, {}, namespace)\n  File \"<string>\", line 1\n    nums= [-1,0,3,5,9,12], target= 9\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx4wksdud.py\", line 30, in <module>\n    exec(processed, {}, namespace)\n  File \"<string>\", line 1\n    nums= [-1,0,3,5,9,12], target= 2\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "class Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Convert the input string into a form that can be executed\n    # Example input: 'nums = [-1,0,3,5,9,12], target = 9'\n    # We want to execute it so that nums and target become variables.\n    # Replace the spaces around '=' to avoid syntax errors.\n    processed = raw_input.replace(\"nums =\", \"nums=\").replace(\"target =\", \"target=\")\n\n    # Execute the processed string in a temporary namespace\n    namespace = {}\n    exec(processed, {}, namespace)\n\n    nums = namespace.get(\"nums\")\n    target = namespace.get(\"target\")\n\n    result = Solution().search(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search algorithm. Use Start, Decision, etc. Each line: virtual code step + // explanation. Must not output actual code. Provide step-by-step algorithm. Each line uses arrow →. We can include variable names: left, right, mid, nums, target. Must maintain O(log n). Use while loop, but in virtual code can use Decision: while left <= right? We need to show loop. Virtual code may use \"While left <= right:\" maybe represent as Decision loop. Let's structure:\n\nStart\n→ Step 1: Set left = 0, right = length(nums) - 1 // 初始化左右指標\n→ Decision: left <= right? // 判斷是否還有區間可搜尋\n    Yes → Step 2: mid = (left + right) // 2 // 計算中間索引\n    → Decision: nums[mid] == target? // 檢查中間值是否為目標\n        Yes → Step 3: Return mid // 找到目標，返回索引\n        No  → Decision: nums[mid] < target? // 中間值小於目標\n            Yes → Step 4: left = mid + 1 // 將左指標移至右半區\n            No  → Step 5: right = mid - 1 // 將右指標移至左半區\n    No → Step 6: Return -1 // 未找到目標，返回 -1\nEnd\n\nBut we need while loop; maybe Decision loop. Actually we can show \"Decision: left <= right?\" and if Yes we loop, else exit. Use a loop with arrow \"→\" to loop back to Decision after Step 5 etc. So we can use \"→ Decision: left <= right?\" again after adjusting. We can indicate \"→\" back to Decision. But we need structure with arrow. We can use \"→ Decision: left <= right?\" as a loop condition; after adjusting left or right we need to go back to Decision. In virtual code we can show \"→ Decision: left <= right?\" repeated.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = length(nums)-1 // 初始化左右指標\n→ Decision: left <= right? // 是否還有搜尋區間\n    Yes → Step 2: mid = (left + right) // 2 // 取得中間索引\n    → Decision: nums[mid] == target? // 中間值是否等於目標\n        Yes → Step 3: Return mid // 找到目標，返回索引\n        No  → Decision: nums[mid] < target? // 中間值是否小於目標\n            Yes → Step 4: left = mid + 1 // 目標在右半區\n            No  → Step 5: right = mid - 1 // 目標在左半區\n    → Decision: left <= right? // 重新判斷是否還有搜尋區間（迴圈）\n        Yes → 回到 Step 2 // 循環\n        No  → Step 6: Return -1 // 未找到目標，返回 -1\nEnd // 程式結束\n\nBut need to keep arrow structure. The \"回到 Step 2\" can be represented by \"→ Decision: left <= right?\" again. We can show loops by repeating the Decision. Maybe simpler: use \"While left <= right\" as Decision loop. After adjusting left or right, go back to Decision. We'll produce a simple representation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = length(nums) - 1 // 初始化左右指標  \n→ Decision: left <= right? // 判斷是否還有可搜尋的區間  \n Yes → Step 2: mid = (left + right) // 2 // 計算中間索引  \n → Decision: nums[mid] == target? // 中間值是否等於目標  \n  Yes → Step 3: Return mid // 找到目標，返回其索引  \n  No → Decision: nums[mid] < target? // 中間值是否小於目標  \n   Yes → Step 4: left = mid + 1 // 目標在右半區，調整左指標  \n   No → Step 5: right = mid - 1 // 目標在左半區，調整右指標  \n → Decision: left <= right? // 重新判斷是否還有區間（迴圈）  \n  Yes → 回到 Step 2 // 進行下一輪搜尋  \n  No → Step 6: Return -1 // 未找到目標，返回 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Shortest Unsorted Continuous Subarray",
      "source_file": "Leetcode/leetcode581.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,6,4,8,10,9,15]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '-3'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '-3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findUnsortedSubarray(self, nums):\n        \"\"\"\n        Find the length of the shortest continuous subarray which, if sorted,\n        would make the entire array non‑decreasing.\n        \"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        # left_boundary: rightmost index where nums[i] < max so far\n        left_boundary = -1\n        max_so_far = nums[0]\n        for i in range(1, n):\n            if nums[i] < max_so_far:\n                left_boundary = i\n            else:\n                max_so_far = nums[i]\n\n        # right_boundary: leftmost index where nums[i] > min so far\n        right_boundary = -1\n        min_so_far = nums[-1]\n        for i in range(n - 2, -1, -1):\n            if nums[i] > min_so_far:\n                right_boundary = i\n            else:\n                min_so_far = nums[i]\n\n        if left_boundary == -1:          # already sorted\n            return 0\n        return right_boundary - left_boundary + 1\n\ndef parse_input_to_nums(input_str: str):\n    \"\"\"\n    Parse the input string to extract the list of integers.\n    Supports formats like 'nums = [1,2,3]' or just '[1, 2, 3]'.\n    \"\"\"\n    # Find the first '[' and the last ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        return []  # no list found\n    list_str = input_str[start:end+1]\n    try:\n        # Safely evaluate the list string\n        return eval(list_str)\n    except Exception:\n        # Fallback: use regex to extract numbers\n        nums = re.findall(r'-?\\d+', list_str)\n        return [int(x) for x in nums]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums = parse_input_to_nums(data)\n    solution = Solution()\n    result = solution.findUnsortedSubarray(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to find shortest subarray that if sorted results array sorted. Known problem: find left and right boundaries where array deviates from sorted order. Approach: traverse from left find last index where a[i] < max so far. from right find first index where a[i] > min so far. length = max(0, right-left+1). Provide steps. We produce each line with arrow. Let's craft. Ensure each step line has \"虛擬碼步驟\" then space then comment. Use arrow. Start, End. Use Decision: for conditions.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 max_so_far ← nums[0] // 用來追蹤從左到右的最大值  \n→ Step 2: 定義變數 left_boundary ← -1 // 右邊界的起始值，預設為未找到  \n→ Step 3: 從索引 1 開始遍歷 nums →  \n  Decision: 若 nums[i] < max_so_far? // 檢查當前值是否小於已知最大值  \n   Yes → left_boundary ← i // 更新左邊界為當前索引  \n   No → max_so_far ← nums[i] // 更新最大值  \n→ Step 4: 定義變數 min_so_far ← nums[-1] // 從右到左的最小值  \n→ Step 5: 定義變數 right_boundary ← -1 // 左邊界的起始值，預設為未找到  \n→ Step 6: 從倒數第二個元素倒序遍歷 nums →  \n  Decision: 若 nums[i] > min_so_far? // 檢查當前值是否大於已知最小值  \n   Yes → right_boundary ← i // 更新右邊界為當前索引  \n   No → min_so_far ← nums[i] // 更新最小值  \n→ Step 7: Decision: 若 left_boundary == -1? // 若未發現任何需要排序的子陣列  \n  Yes → Step 8: 輸出 0 // 整個陣列已經排序  \n  No → Step 9: 輸出 right_boundary - left_boundary + 1 // 需要排序的最短子陣列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}            # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Insert key into next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (LRU within same freq)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Expect input like '[\"LFUCache\", \"put\", ...], [[2], [1, 1], ...]'\n    # Split into two parts at the first comma that separates the lists\n    # Using ast.literal_eval on the whole string might fail because of the comma\n    # Instead, find the index of '],', then split\n    try:\n        parts = data.split('],', 1)\n        ops = ast.literal_eval(parts[0] + ']')\n        params = ast.literal_eval('[' + parts[1])\n    except Exception:\n        # Fallback: if the format is just two lists separated by comma\n        ops, params = ast.literal_eval(data)\n    cache = None\n    output = []\n    for op, args in zip(ops, params):\n        if op == \"LFUCache\":\n            cache = LFUCache(args[0])\n            output.append(None)\n        elif op == \"get\":\n            result = cache.get(args[0])\n            output.append(result)\n        elif op == \"put\":\n            cache.put(args[0], args[1])\n            output.append(None)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudocode lines for implementing LFUCache with O(1). Use frequency doubly linked lists, etc. We'll produce step-by-step algorithm for initialization, get, put. Provide lines like \"Start\", \"→ Step: ...\" Each line explanation. We'll produce code structure with decision. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 LFUCache 類別並初始化容量 capacity, 最小頻率 minFreq, keyTable, freqTable // 用於存儲 key → (value, freq, node) 與 freq → 連結串列\n→ Step 2: 在 keyTable 初始化為空字典 // key -> Node\n→ Step 3: 在 freqTable 初始化為空字典 // freq -> LinkedList of Node\n→ Step 4: minFreq 設為 0 // 目前最小頻率\n\n// ---------- get 方法 ----------\n→ Step 5: 定義 get(key) 方法\n→ Step 6: Decision: key 是否存在於 keyTable? // 檢查 key 是否在快取中\n    Yes → Step 7: 從 keyTable 取得 node (value, freq) // 取出節點\n    → Step 8: Call updateFreq(node) // 更新頻率\n    → Step 9: Return node.value // 返回對應值\n    No  → Step 10: Return -1 // key 不存在，返回 -1\n\n// ---------- put 方法 ----------\n→ Step 11: 定義 put(key, value) 方法\n→ Step 12: Decision: capacity 是否為 0? // 快取容量為 0 時直接返回\n    Yes → Step 13: Return // 無法存儲任何項目\n    No  → Step 14: Decision: key 是否存在於 keyTable? // 更新已存在 key\n        Yes → Step 15: keyTable[key].value = value // 更新值\n        → Step 16: Call updateFreq(keyTable[key]) // 更新頻率\n        No  → Step 17: Decision: keyTable 大小是否已達 capacity? // 判斷是否需要淘汰\n            Yes → Step 18: 淘汰 minFreq 的最舊節點\n                → Step 19: nodeToRemove = freqTable[minFreq].popTail() // 取得最舊節點\n                → Step 20: 從 keyTable 刪除 nodeToRemove.key // 刪除鍵值對\n            No → Step 21: // 無需淘汰\n            // 以上為淘汰流程結束\n            // 之後插入新節點\n            → Step 22: 建立新 Node(key, value, freq=1) // 新節點頻率設為 1\n            → Step 23: keyTable[key] = newNode // 存入 keyTable\n            → Step 24: freqTable[1].append(newNode) // 加入頻率 1 的連結串列\n            → Step 25: minFreq = 1 // 新節點為最小頻率\n\n// ---------- updateFreq 方法 ----------\n→ Step 26: 定義 updateFreq(node) 方法\n→ Step 27: currentFreq = node.freq\n→ Step 28: freqTable[currentFreq].remove(node) // 從舊頻率串列移除\n→ Step 29: Decision: freqTable[currentFreq] 是否為空? // 若該頻率串列已空\n    Yes → Step 30: 刪除 freqTable[currentFreq] // 刪除空串列\n    No → Step 31: // 保留\n→ Step 32: Decision: currentFreq == minFreq 且 freqTable[currentFreq] 為空? // 更新 minFreq\n    Yes → Step 33: minFreq += 1 // 進一步遞增\n    No  → Step 34: // minFreq 保持不變\n→ Step 35: node.freq += 1 // 更新節點頻率\n→ Step 36: freqTable[node.freq].append(node) // 加入新頻率串列\n→ Step 37: End // updateFreq 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0204tsa5.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmp0204tsa5.py\", line 38, in main\n    exec(data, {}, env)\n  File \"<string>\", line 1\n    nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0dc_0x12.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmp0dc_0x12.py\", line 38, in main\n    exec(data, {}, env)\n  File \"<string>\", line 1\n    nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\n    ^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        判斷是否存在索引差不超過 k 且數值差不超過 t 的索引對。\n        使用滑動窗口 + 平衡二元搜尋樹 (用 Python list + bisect 模擬)。\n        \"\"\"\n        if k <= 0 or t < 0:\n            return False\n\n        window = []  # 已經排序好的窗口\n        for i, num in enumerate(nums):\n            # 在窗口中尋找最靠近 num - t 的位置\n            pos = bisect.bisect_left(window, num - t)\n            # 若該位置的元素與 num 的差距仍小於等於 t，則成立\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n\n            # 將當前數字加入窗口，保持排序\n            bisect.insort(window, num)\n\n            # 若窗口長度超過 k，移除最舊的元素\n            if len(window) > k:\n                # 找到要移除的元素在窗口中的位置\n                remove_idx = bisect.bisect_left(window, nums[i - k])\n                window.pop(remove_idx)\n\n        return False\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n\n    # 使用 exec 解析變數，環境安全性已經不再重要\n    env = {}\n    exec(data, {}, env)\n\n    nums = env.get('nums', [])\n    indexDiff = env.get('indexDiff', 0)\n    valueDiff = env.get('valueDiff', 0)\n\n    solution = Solution()\n    result = solution.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n\n    # 輸出結果\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the problem: find if any pair satisfies conditions. Approach: use sliding window with balanced BST (e.g., TreeSet) to maintain numbers within indexDiff. For each i, find floor/ceil within valueDiff. Complexity O(n log n). Or simpler: use hash buckets: bucket size valueDiff+1 to map to bucket id = nums[i]/(valueDiff+1). Check neighbor buckets. But we can produce pseudocode with decision steps.\n\nWe need to output line by line with arrow and explanation. Use Start, End, Decision, Step. Use arrow. Provide for each step.\n\nWe need to explain each step: read input, loop over indices, maintain window, check neighbors, etc.\n\nWe will produce something like:\n\nStart // begin\n→ Step 1: initialize empty TreeSet S // for storing numbers in window\n→ Step 2: for i from 0 to n-1 // iterate indices\n    → Decision: i > indexDiff? // check if window too large\n        Yes → Step 3: remove nums[i-indexDiff-1] from S // shrink window\n    → Step 4: find lower = S.floor(nums[i]+valueDiff) // candidate within range\n        Step 5: find higher = S.ceiling(nums[i]-valueDiff)\n        → Decision: lower != null and lower >= nums[i]-valueDiff? // found close value\n            Yes → Step 6: return true\n    → Step 7: add nums[i] to S // add current element\n→ Step 8: return false\nEnd\n\nBut we need more detailed step lines: each step with arrow and explanation.\n\nWe also might include initialization of variables indexDiff, valueDiff, nums. The algorithm: sliding window with balanced BST. Could also use bucket but maybe simpler to explain BST.\n\nWe need to provide virtual code lines: each line like \"→ Step X: ...\" and a comment.\n\nAlso we need decisions. We'll include Decision blocks.\n\nWe'll use arrow indentation for nested decisions. Provide lines like:\n\n→ Decision: i > indexDiff? // decide if window size exceeded\n    Yes → Step ... // remove element\n    No  → ... // do nothing\n\nAlso check for candidate in S within valueDiff: can use floor and ceiling. Actually we need to find any number in S that is within valueDiff of nums[i]. That can be done by checking floor of (nums[i] + valueDiff) and ceiling of (nums[i] - valueDiff). If either is not null and abs difference <= valueDiff, we return true.\n\nLet's produce pseudocode.\n\nEdge: if valueDiff < 0? Not necessary.\n\nWe need to mention removal: remove nums[i - indexDiff - 1].\n\nWe need to mention S as balanced BST.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← 輸入整數陣列 // 取得題目給定的數字序列  \n→ Step 2: indexDiff ← 輸入整數 // 取得索引差的上限  \n→ Step 3: valueDiff ← 輸入整數 // 取得數值差的上限  \n→ Step 4: S ← 空的平衡二元搜尋樹 // 用來快速搜尋符合條件的數值  \n→ Decision: nums 不是空陣列? // 檢查陣列是否至少有一個元素  \n    Yes → Step 5: for i in 0 .. nums.length-1 // 從左到右逐個檢查索引  \n        → Decision: i > indexDiff? // 判斷是否已經超出允許的索引距離  \n            Yes → Step 6: S.remove(nums[i - indexDiff - 1]) // 從集合中刪除最舊的元素，維持窗口大小  \n            No  → // 不需要刪除，窗口仍在允許範圍內  \n        → Step 7: low ← S.floor(nums[i] + valueDiff) // 取得小於等於 nums[i]+valueDiff 的最大值  \n        → Step 8: high ← S.ceiling(nums[i] - valueDiff) // 取得大於等於 nums[i]-valueDiff 的最小值  \n        → Decision: (low != null and abs(low - nums[i]) <= valueDiff) OR (high != null and abs(high - nums[i]) <= valueDiff)?  \n            Yes → Step 9: return true // 找到符合條件的索引對，直接返回真  \n            No  → // 尚未找到，繼續進行下一步  \n        → Step 10: S.add(nums[i]) // 把目前元素加入集合，供未來索引使用  \n    End for // 迴圈結束  \n→ Step 11: return false // 所有索引都檢查完畢仍無符合條件，返回假  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp02av3bjg.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp02av3bjg.py\", line 40, in main\n    obj = Solution(*args[0])\n          ^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp02av3bjg.py\", line 11, in __init__\n    for weight in w:\nTypeError: 'int' object is not iterable"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp60mpeyqi.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp60mpeyqi.py\", line 40, in main\n    obj = Solution(*args[0])\n          ^^^^^^^^^^^^^^^^^^\nTypeError: Solution.__init__() takes 2 positional arguments but 3 were given"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # choose a random target in [1, total] (inclusive)\n        target = random.randint(1, self.total)\n        # find the first index whose prefix sum >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    # Read entire stdin and strip whitespace\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the input with parentheses to form a tuple and parse it\n    try:\n        commands, args_list = ast.literal_eval(f'({data})')\n    except Exception as e:\n        # In case the input is not exactly a tuple, try splitting manually\n        parts = data.split('],', 1)\n        commands = ast.literal_eval(parts[0] + ']')\n        args_list = ast.literal_eval(parts[1])\n    outputs = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # args should be a list like [[1,3]] (outer list for constructor)\n            obj = Solution(*args[0])\n            outputs.append(None)\n        elif cmd == \"pickIndex\":\n            outputs.append(obj.pickIndex())\n    # Print results in JSON format (None -> null)\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanation. Provide steps: Start, compute prefix sums, random number, binary search. Use Decision, End. Provide lines accordingly. Use arrows. Let's produce a step-by-step.\n\nWe need to show: Start; compute prefix sums array; total sum; pick random float between 0 and total; binary search to find index; return index; End.\n\nLet's produce in the format:\n\nStart // ...\n→ Step 1: Initialize prefix array // ...\n→ Step 2: Compute total sum // ...\n→ Step 3: Generate random number // ...\n→ Step 4: Binary search prefix for random // ...\n→ Decision: If found? // etc.\n\nBut the structure may need arrow with decision. Use arrow. Let's produce lines:\n\nStart // 程式開始\n→ Step 1: 建立 prefixSum 陣列 // 以 w 的長度初始化\n→ Step 2: 逐元素累加至 prefixSum // 每個索引 i 的值為 w[0] + ... + w[i]\n→ Step 3: 取得總重量 total = prefixSum[last] // total 為所有 w 的和\n→ Step 4: 產生隨機數 r，範圍 0 ≤ r < total // r 用於決定索引\n→ Step 5: 用二分搜尋在 prefixSum 找到第一個 ≥ r 的位置 // 該位置即為選中的索引\n→ Decision: r 是否小於 prefixSum[0]? // 檢查 r 是否落在第一段\n    Yes → Step 6: index = 0 // 直接返回 0\n    No  → Step 7: binarySearch(prefixSum, r) // 執行搜尋\n→ Step 8: 回傳 index // 完成 pickIndex\nEnd // 程式結束\n\nBut better to combine search into step. Use decision for search result. Provide explanation for binary search.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化 prefixSum 陣列，長度與 w 相同 // 用來存儲前綴和  \n→ Step 2: 逐個累加 w[i] 進入 prefixSum[i] // prefixSum[i] = w[0] + … + w[i]  \n→ Step 3: 取得總重量 total = prefixSum[w.length - 1] // total 為所有權重之和  \n→ Step 4: 產生隨機數 r，範圍 0 ≤ r < total // r 用於決定要選哪個索引  \n→ Step 5: 用二分搜尋在 prefixSum 找到第一個大於或等於 r 的位置 // 該位置即為返回的索引  \n→ Decision: r 是否小於 prefixSum[0]? // 檢查是否落在第一段  \n  Yes → Step 6: index = 0 // 直接返回 0  \n  No  → Step 7: binarySearch(prefixSum, r) // 執行搜尋以取得 index  \n→ Step 8: 回傳 index // 完成 pickIndex  \nEnd // 程式結束"
    },
    {
      "title": "Arithmetic Slices II - Subsequence",
      "source_file": "Leetcode/leetcode446.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9uyr_io7.py\", line 36, in <module>\n    nums = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    nums = [2,4,6,8,10]\n         ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp9uyr_io7.py\", line 42, in <module>\n    nums = list(map(int, raw_input.split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'nums'"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0aqpn2or.py\", line 36, in <module>\n    nums = ast.literal_eval(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    nums = [7,7,7,7,7]\n         ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp0aqpn2or.py\", line 42, in <module>\n    nums = list(map(int, raw_input.split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'nums'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    計算長度至少 3 的等差子序列數量\n    \"\"\"\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        # dp[i] 以 nums[i] 為結尾、差值為 diff 的子序列個數（至少長度 2）\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count_j = dp[j][diff]          # 在 j 位置結束且差值為 diff 的子序列個數\n                total += count_j                # 延伸得到長度至少 3 的子序列\n                dp[i][diff] += count_j + 1      # +1 為 (j, i) 這個長度 2 的子序列\n\n        return total\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 先嘗試解析為 Python 表達式，例如 '[1,2,3]' 或 '1 2 3'\n    try:\n        nums = ast.literal_eval(raw_input)\n        if not isinstance(nums, (list, tuple)):\n            raise ValueError\n        nums = list(map(int, nums))\n    except Exception:\n        # 如果解析失敗，假設輸入是空格或換行分隔的整數\n        nums = list(map(int, raw_input.split()))\n\n    solution = Solution()\n    result = solution.numberOfArithmeticSlices(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting arithmetic subsequences of at least length 3 in array nums. The typical solution uses DP with map for each index storing counts of sequences ending at that index with difference d, counts of subsequences of length>=2. Then number of arithmetic subsequences of length>=3 is sum of contributions when extending. Steps: iterate i, for each j<i compute diff, update map[j][diff], add to map[i][diff] etc. We'll produce pseudocode.\n\nWe need to use \"Start\", \"End\", \"Decision:\" etc. Each line \"虛擬碼步驟 // 解釋\". We'll produce step by step:\n\nStart\n→ Initialize answer = 0 // total arithmetic subsequences length >=3\n→ Initialize dp array of maps of length n // dp[i] map diff->count of subseq length>=2 ending at i\n→ For i from 0 to n-1\n    → For j from 0 to i-1\n        → Compute diff = nums[i]-nums[j] // integer difference\n        → Let count_j = dp[j].get(diff,0) // number of subseq length>=2 ending at j with this diff\n        → Increase answer by count_j // each such seq extended by nums[i] becomes length>=3\n        → Increase dp[i][diff] by count_j + 1 // add new seq of length2 (j,i) and extensions\n→ End // return answer\n\nNeed to include decision maybe not needed. But we can add if statements for n<3. But it's okay.\n\nLet's format lines with \"→\". Each line with step. Use \"Decision:\" maybe for n <3 case. Provide explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize answer = 0 // 目前已找到的長度至少為3的等差子序列數量  \n→ Initialize dp[0…n-1] 為空的字典 // dp[i] 會存放以 nums[i] 結束、差值為 diff 的子序列個數（至少長度為2）  \n→ Decision: 如果 n < 3? // 先判斷是否有足夠元素可組成長度至少3的序列  \n    Yes → End // 直接結束，答案為0  \n    No → Continue  \n→ For i = 0 to n-1  \n    → For j = 0 to i-1  \n        → Compute diff = nums[i] - nums[j] // 兩個元素之差  \n        → Get count_j = dp[j].get(diff, 0) // 在 j 位置結束且差值為 diff 的子序列個數  \n        → answer += count_j // 把每個長度至少2的子序列延伸到 i，得到長度至少3的新子序列  \n        → dp[i][diff] += count_j + 1 // 1 是由 (j,i) 本身形成的新長度2子序列，另外加上所有延伸後的長度≥2子序列  \n→ End // 回傳 answer（即所有長度至少3的等差子序列總數）"
    }
  ]
}