{
  "run_index": 44,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 397,
  "generation_or_validation_failure_count": 42,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,6,6,6,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 6, 6, 6, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳結果串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼，並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output pseudo-code line by line, with each line \"虛擬碼步驟 // 解釋\" and use arrows and structure. Use Start, End, Decision. So we start with Start. Then maybe import random? We can include that step. Then define function roll_dice(n). Then initialize list. Then for i in range(n): roll = random.randint(1,6); append. After loop, return list. Then End.\n\nWe need to incorporate arrow arrow \"→\" for each step. Let's produce lines:\n\nStart\n→ Step 1: Import random module // 引入 random\n→ Step 2: Define function roll_dice(n) // 建立函式\n→ Step 3: 初始化結果串列 results = [] // 空串列存放擲骰結果\n→ Step 4: For i from 1 to n: // 重複 n 次\n    → Step 5: 擲骰: roll = random.randint(1, 6) // 產生 1-6 隨機數\n    → Step 6: Append roll to results // 存進結果串列\n→ Step 7: Return results // 回傳所有結果\nEnd\n\nNeed to use Decision? There's no decision. Could use Decision: if n <=0? But not needed. So no decision.\n\nBut the format example uses arrows after Start, e.g., \"Start // 程式開始執行\". Then \"→ Step 1: ...\". The \"→\" can be used. For loops, we can write \"→ Step 4: For i in range(n): // 重複 n 次\". Then indent sub steps with arrow or maybe same level. We could also indent with \"→\" lines preceded by space. The format uses indentation.\n\nWe should include explanation after each line.\n\nLet's craft lines accordingly. We'll keep consistent.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 引入 random 模組以使用亂數功能  \n→ Step 2: Define function roll_dice(n) // 建立 roll_dice 函式，接受擲骰次數 n  \n→ Step 3: Initialize results = [] // 建立空串列來存放每次擲骰的結果  \n→ Step 4: For i in range(n): // 進行 n 次迴圈  \n  → Step 5: roll = random.randint(1, 6) // 在 1 至 6 之間產生隨機整數  \n  → Step 6: Append roll to results // 把本次擲骰結果加入結果串列  \n→ Step 7: Return results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需時間，回傳四捨五入到小數點 3 位的秒數。\"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    # 讀取所有標準輸入\n    code = sys.stdin.read()\n    # 建立執行環境，並把 measure_time 放進去\n    namespace = {'measure_time': measure_time}\n    # 執行輸入的程式碼；程式碼內部的 print 會直接輸出到標準輸出\n    exec(code, namespace)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Format: \"虛擬碼步驟 // 解釋\". Use arrows etc. Should include time module usage, define function measure_time, call func with *args, capture time before/after, compute elapsed, round to 3 decimals, return. Possibly also return result of func? Problem: measure_time returns result? It says 回傳結果 (四捨五入到小數點 3 位)。 Might refer to elapsed time. So return elapsed. Provide virtual steps.\n\nAlso need to include Start End, Decision maybe not needed. Just steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 匯入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 建立 measure_time 函式\n→     Step 3: 記錄開始時間 start = time.perf_counter() // 取得開始時間\n→     Step 4: 執行 func 之後的結果 result = func(*args) // 呼叫目標函式\n→     Step 5: 記錄結束時間 end = time.perf_counter() // 取得結束時間\n→     Step 6: 計算 elapsed = end - start // 計算執行時間\n→     Step 7: 四捨五入到 3 位 elapsed_rounded = round(elapsed, 3) // 四捨五入\n→     Step 8: 回傳 elapsed_rounded // 回傳經過時間\nEnd // 程式執行結束\n\nBut need to use 虛擬碼 arrow syntax. Use \"→\" before each step. Also maintain indent for nested? Not necessary. Use \"Start\" and \"End\".\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 匯入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 建立 measure_time 函式  \n→     Step 3: Record start time start = time.perf_counter() // 取得執行開始時間  \n→     Step 4: Call target function result = func(*args) // 執行 func 並傳入所有參數  \n→     Step 5: Record end time end = time.perf_counter() // 取得執行結束時間  \n→     Step 6: Compute elapsed = end - start // 計算執行所需秒數  \n→     Step 7: Round to 3 decimal places elapsed_rounded = round(elapsed, 3) // 四捨五入到 3 位小數  \n→     Step 8: Return elapsed_rounded // 回傳經過時間  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.7800TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.7800 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"向匯率 API 取得美元兌台幣的匯率，回傳格式化字串。\"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        resp = requests.get(url, timeout=5)\n        resp.raise_for_status()\n        data = resp.json()\n        rate = data['rates']['TWD']\n        return f'目前美元匯率：約 {rate:.4f} TWD'\n    except Exception:\n        return '更新失敗，請檢查網路連線'\n\ndef gui_app():\n    \"\"\"啟動 tkinter GUI，顯示匯率並提供更新按鈕。\"\"\"\n    root = tk.Tk()\n    root.title('匯率查詢')\n\n    label = tk.Label(root, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        label.config(text=fetch_rate())\n\n    tk.Button(root, text='更新匯率', command=update_label).pack(pady=5)\n\n    # 初始時即更新一次\n    update_label()\n    root.mainloop()\n\ndef main():\n    \"\"\"主執行區塊，從標準輸入讀取資料並輸出結果；若無輸入則啟動 GUI。\"\"\"\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 若收到任何輸入，視為「按下更新匯率」指令，直接印出結果\n        print(fetch_rate())\n    else:\n        gui_app()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step, with arrow and decision, etc. The code involves requests, tkinter, button click to update exchange rate from API. Use Start, End. Each line: \"虛擬碼步驟 // 解釋\". Use arrow (→). So produce something like:\n\nStart // 程式開始執行\n→ Step 1: 匯入 requests, tkinter, json // 導入必要模組\n→ Step 2: 定義函式 fetch_rate() // 函式取得匯率\n→ Decision: 是否成功取得 API 響應? // 檢查請求是否成功\n    Yes → Step 3: 解析 JSON 並取出 TWD 交換率 // 取得匯率值\n    No → Step 4: 返回 '無法取得匯率' // 錯誤處理\n→ Step 5: 定義函式 update_label() // 更新視窗顯示\n→ Step 6: 建立 tkinter 視窗 root // 初始化 GUI\n→ Step 7: 建立 label 以顯示匯率 // 文字顯示\n→ Step 8: 建立按鈕，點擊時呼叫 update_label // 互動按鈕\n→ Step 9: 初次顯示匯率 (呼叫 update_label) // 讓初始畫面有值\n→ Step 10: 啟動 mainloop // 進入事件循環\nEnd // 程式結束\n\nBut must include arrows like →. The decision block: indent and use Yes → ... No → ... Provide comments. Also must use Start and End. Use each line as separate line. Use the virtual code syntax: \"→ Step 1: ...\". The decision: \"Decision:\" line and then indent. Use \"Yes →\" and \"No →\" lines. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests、tkinter、json // 導入網路請求、GUI 與 JSON 處理模組  \n→ Step 2: 定義函式 fetch_rate() // 用來向匯率 API 發送請求並回傳 TWD 匯率  \n→ Decision: 取得 API 響應成功? // 檢查 HTTP 狀態碼是否為 200  \n    Yes → Step 3: 解析 JSON 並提取 TWD 兌換率 // 從回傳資料中抓取匯率值  \n    No → Step 4: 返回 '無法取得匯率' // 失敗時返回錯誤訊息  \n→ Step 5: 定義函式 update_label() // 取得最新匯率並更新 tkinter 標籤內容  \n→ Step 6: 建立 tkinter 主視窗 root // 初始化 GUI 主視窗  \n→ Step 7: 建立 label widget 顯示匯率 // 用於呈現匯率訊息  \n→ Step 8: 建立按鈕 widget，點擊時執行 update_label() // 供使用者手動更新  \n→ Step 9: 初次呼叫 update_label() 以顯示當前匯率 // 在啟動時顯示一次  \n→ Step 10: 執行 root.mainloop() // 進入 tkinter 事件循環等待使用者互動  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m, n):\n        self.rows = m\n        self.cols = n\n        self.total = m * n\n        self.mapping = {}\n\n    def flip(self):\n        # 隨機選擇一個尚未翻轉的索引\n        r = random.randint(0, self.total - 1)\n        # 若映射存在則取映射值，否則取自身索引\n        x = self.mapping.get(r, r)\n        # 之後把最後一個可用索引映射到 r\n        last = self.total - 1\n        self.mapping[r] = self.mapping.get(last, last)\n        # 若 last 在映射中，移除它（因為已被「移走」）\n        if last in self.mapping:\n            del self.mapping[last]\n        self.total -= 1\n        # 轉換為行列座標\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.mapping.clear()\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入轉為兩個列表\n    try:\n        commands, args = ast.literal_eval(f\"({data})\")\n    except Exception:\n        # 若輸入格式不符合，直接退出\n        sys.exit(1)\n\n    obj = None\n    outputs = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)\n            outputs.append(None)\n        elif cmd == \"flip\":\n            outputs.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            outputs.append(None)\n        else:\n            # 忽略未知指令\n            outputs.append(None)\n\n    # 輸出結果，使用 json 以保證 null 的格式\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce pseudo code line by line with explanations, using arrows. For this algorithm: typical solution uses reservoir sampling-like mapping: maintain a map from index to another available index; maintain remaining count. flip: pick random number between 0 and remaining-1; map to actual index using dictionary mapping; then decrement remaining; update map. reset: clear mapping and set remaining=m*n.\n\nLet's generate steps: Start; constructor: set m, n, remaining = m*n; map = empty; etc.\n\nWe need to produce pseudo code lines with comments. Use Start, End, Decision. Use arrow → for each line.\n\nAlso need to include the algorithm steps. Provide for flip and reset.\n\nWe might structure like:\n\nStart\n→ Step 1: Initialize variables m, n, remaining, map\n→ Step 2: ... etc.\n\nBut we should show pseudo-code for the whole class. Let's produce separate pseudo-code for constructor, flip, reset. But the instruction: \"逐行生成虛擬碼 (Virtual Code)\" presumably the entire algorithm steps, not code skeleton. We can produce high-level pseudo-code with decision structures.\n\nLet's create:\n\nStart\n→ Step 1: Input m, n // 初始化矩陣尺寸\n→ Step 2: Set remaining = m*n // 可用空位數\n→ Step 3: map = empty dictionary // 位置映射\n→ Step 4: // flip 方法\n   → Step 4.1: If remaining == 0 → Return null? // no available, but assumption there is at least one\n   → Step 4.2: randIdx = random(0, remaining-1) // 隨機選擇剩餘範圍\n   → Step 4.3: actualIdx = map.get(randIdx, randIdx) // 若映射存在則取映射值\n   → Step 4.4: lastIdx = remaining-1\n   → Step 4.5: map[randIdx] = map.get(lastIdx, lastIdx) // 把最後一個位置映射到選中的位置\n   → Step 4.6: Remove map[lastIdx] if exists // 清除映射\n   → Step 4.7: remaining -= 1\n   → Step 4.8: i = actualIdx // / n; j = actualIdx % n // 轉換為二維坐標\n   → Step 4.9: Return [i, j]\n→ Step 5: // reset 方法\n   → Step 5.1: remaining = m*n\n   → Step 5.2: map.clear()\nEnd\n\nWe should show decision structure? The only decision is remaining==0 but we can skip.\n\nUse \"Decision:\" for conditional.\n\nLet's produce formatted lines.\n\nWe need to use \"→\" for each line and \"Decision:\" where needed. For mapping we can use \"map\" as dictionary.\n\nWe'll keep each line separate.\n\nLet's generate final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: input m, n // 初始化矩陣尺寸  \n→ Step 2: remaining ← m * n // 可用空位總數  \n→ Step 3: map ← {} // 空位索引對應映射表  \n→ Step 4: // flip 方法開始  \n→ Decision: 如果 remaining == 0? // 檢查是否還有空位可選  \n  Yes → Return null // 沒有空位，回傳空值（可選處理）  \n  No  → // 有空位可隨機選擇  \n→ Step 5: randIdx ← random(0, remaining - 1) // 產生 0~remaining-1 的隨機整數  \n→ Step 6: actualIdx ← map.get(randIdx, randIdx) // 若映射存在則取映射值，否則取自身索引  \n→ Step 7: lastIdx ← remaining - 1 // 最後一個可用索引  \n→ Step 8: map.put(randIdx, map.get(lastIdx, lastIdx)) // 把最後一個索引映射到選中的位置  \n→ Step 9: map.remove(lastIdx) // 移除最後一個索引的映射（若存在）  \n→ Step 10: remaining ← remaining - 1 // 可用空位減 1  \n→ Step 11: i ← actualIdx // n // 計算行座標  \n→ Step 12: j ← actualIdx % n // 計算列座標  \n→ Step 13: Return [i, j] // 回傳隨機選取的座標  \n→ Step 14: // reset 方法開始  \n→ Step 15: remaining ← m * n // 重置可用空位數  \n→ Step 16: map.clear() // 清空映射表  \nEnd // 程式執行結束"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwvv_s1um.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpwvv_s1um.py\", line 24, in main\n    data = ast.literal_eval('{' + formatted + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7275255f7890>"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpowgllad_.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpowgllad_.py\", line 24, in main\n    data = ast.literal_eval('{' + formatted + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7095233fba90>"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration\n        return total\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入轉換為字典形式，例如\n    # timeSeries = [1,4], duration = 2\n    # 轉成 {'timeSeries': [1,4], 'duration': 2}\n    formatted = raw.replace('timeSeries =', 'timeSeries:') \\\n                   .replace(', duration =', ', duration:')\n    data = ast.literal_eval('{' + formatted + '}')\n    timeSeries = data['timeSeries']\n    duration = data['duration']\n\n    sol = Solution()\n    result = sol.findPoisonedDuration(timeSeries, duration)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step to solve this problem, with explanations. We must not output actual code, just pseudocode with arrows and comments.\n\nWe need to handle array timeSeries sorted non-decreasing, duration. The algorithm: iterate over timeSeries, sum total poisoned time. For each attack time t: if t > lastAttack + duration - 1? Actually we need to add min(duration, t_next - t). Standard solution: sum += duration for first, then for each subsequent attack, add min(duration, t_i - t_{i-1}). For last one, add duration.\n\nThus pseudocode:\n\nStart\nInitialize total = 0\nIf timeSeries empty → return 0\n\nLoop i from 0 to len-1\n    If i==0:\n        total += duration\n    Else:\n        diff = timeSeries[i] - timeSeries[i-1]\n        total += min(duration, diff)\nEnd loop\nReturn total\n\nNeed to use virtual code structure.\n\nWe need to output lines with \"虛擬碼步驟\" plus comments.\n\nWe need to use arrows (→), Decision: if etc. Also structure: Start, End.\n\nLet's produce step-by-step.\n\nUse lines like:\n\nStart // 程式開始執行\n→ Decision: timeSeries 是否為空? // 檢查是否有攻擊紀錄\n    Yes → Step 1: 返回 0 // 沒有攻擊，毒藥時間為 0\n    No  → Step 2: 初始化 total = 0, prev = timeSeries[0] // 用於累計毒藥時間，prev 追蹤上一個攻擊時間\n→ Step 3: total += duration // 第一個攻擊的毒藥持續 duration 秒\n→ Step 4: 循環 i 從 1 到 timeSeries.length-1 // 處理其餘攻擊\n    → Step 5: diff = timeSeries[i] - prev // 兩次攻擊之間的時間差\n    → Decision: diff 是否小於 duration? // 判斷兩次攻擊是否重疊\n        Yes → total += diff // 若重疊，僅累計差距\n        No  → total += duration // 若不重疊，累計完整 duration\n    → Step 6: prev = timeSeries[i] // 更新上一攻擊時間\n→ Step 7: 返回 total // 完成計算\nEnd // 程式執行結束\n\nWe also need to maintain structure: maybe use loop arrow and decisions.\n\nBetter: use \"→ Decision:\" for loops? We can just show step 4: Start loop, then inside.\n\nLet's produce final output. Ensure each line has \"虛擬碼步驟\" and comment. Use Chinese comments.\n\nReturn final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: timeSeries 是否為空? // 檢查是否有攻擊紀錄  \n  Yes → Step 1: 返回 0 // 沒有攻擊，毒藥時間為 0  \n  No  → Step 2: 初始化 total = 0, prev = timeSeries[0] // 用於累計毒藥時間，prev 追蹤上一個攻擊時間  \n→ Step 3: total += duration // 第一個攻擊的毒藥持續 duration 秒  \n→ Step 4: 循環 i 從 1 到 timeSeries.length-1 // 處理其餘攻擊  \n  → Step 5: diff = timeSeries[i] - prev // 計算兩次攻擊之間的時間差  \n  → Decision: diff 小於 duration? // 判斷兩次攻擊是否重疊  \n    Yes → total += diff // 若重疊，僅累計差距  \n    No  → total += duration // 若不重疊，累計完整 duration  \n  → Step 6: prev = timeSeries[i] // 更新上一攻擊時間  \n→ Step 7: 返回 total // 完成計算  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpffw0fh2x.py\", line 41, in <module>\n    magic_dict.buildDict(arg)\n  File \"/tmp/tmpffw0fh2x.py\", line 10, in buildDict\n    self.words = set(dictionary)\n                 ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 把兩個列表包裝成一個元組，方便 ast.literal_eval 解析\n    data = '(' + data + ')'\n    ops, args_list = ast.literal_eval(data)\n\n    result = []\n    magic_dict = None\n    for op, arg in zip(ops, args_list):\n        if op == \"MagicDictionary\":\n            magic_dict = MagicDictionary()\n            result.append(None)\n        elif op == \"buildDict\":\n            magic_dict.buildDict(arg)\n            result.append(None)\n        elif op == \"search\":\n            res = magic_dict.search(arg)\n            result.append(res)\n        else:\n            # 未知操作，返回 None\n            result.append(None)\n\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, no real code, just structure. Steps: Start, buildDict: store words in array or set, also maybe preprocess. search: iterate over words and check if exactly one char difference. Use nested loops. Provide steps with decision and arrows.\n\nLet's produce pseudo algorithm:\n\nStart\n→ Step: Initialize data structure\n→ Step: buildDict(dictionary) // store words\n→ Step: search(searchWord) // iterate words\n→ Decision: If any word length != searchWord length? Skip\n→ For each word\n→ Decision: Count diff == 1? If yes return true\n→ End of search return false\n\nAlso could use map of patterns with wildcard etc. But simple.\n\nLet's write in requested format.\n\nWe must include `Start` and `End` markers. Use arrows.\n\nUse indent for nested decision.\n\nWill produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 MagicDictionary 物件 // 建立空資料結構\n→ Step 2: buildDict(dictionary) // 將單詞集合儲存\n    → Decision: 將 dictionary 存入內部陣列 words // 方便後續搜尋\n→ Step 3: search(searchWord) // 進行搜尋\n    → Decision: 有任何單詞長度與 searchWord 不同嗎? // 跳過不同長度的單詞\n        Yes → Continue // 跳過\n        No  → Continue // 仍進行\n    → Step 4: For each word in words\n        → Step 5: 初始化差異計數 diff = 0\n        → Step 6: For i from 0 to length-1\n            → Decision: words[i] ≠ searchWord[i]? // 是否不同\n                Yes → diff = diff + 1\n                No  → 仍不變\n            → Decision: diff > 1? // 超過 1 則可直接跳過\n                Yes → Break // 退出內層迴圈\n                No  → 仍執行\n        → Decision: diff == 1? // 恰好一個不同\n            Yes → Return true // 找到符合條件\n            No  → 仍繼續下一個單詞\n    → Return false // 沒有任何單詞符合\nEnd // 程式執行結束\n\nLet's make each line separate, use arrows appropriately. Need to format like: `Step 1: ... // 說明` etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 MagicDictionary 物件 // 初始化內部儲存結構  \n→ Step 2: buildDict(dictionary) // 將字典中的單詞存入資料結構  \n  Decision: 將 dictionary 存入陣列 words? // 方便後續逐字比對  \n   Yes → Step 3: words ← dictionary // 存儲所有單詞  \n→ Step 4: search(searchWord) // 開始搜尋是否能改一字匹配  \n  Decision: 有 words[i] 的長度與 searchWord 不同? // 不同長度的單詞無法匹配  \n   Yes → Continue // 跳過此單詞  \n   No  → Continue // 繼續檢查  \n  Step 5: For each word in words  \n   → Step 6: diff ← 0 // 差異字元計數器  \n   → Step 7: For j from 0 to length-1  \n     Decision: word[j] ≠ searchWord[j]? // 兩字元不同  \n      Yes → diff ← diff + 1 // 變化數增 1  \n      No  → 仍保持 diff  \n     Decision: diff > 1? // 超過一個差異即不符合條件  \n      Yes → Break // 跳出內層迴圈，檢查下一個單詞  \n      No  → 仍執行下一位  \n    Decision: diff == 1? // 恰好一個差異  \n     Yes → Return true // 找到符合的單詞，搜尋成功  \n     No  → 仍檢查下一個單詞  \n  Decision: 所有單詞檢查完畢仍未匹配? // 無法改一字匹配  \n   Yes → Return false // 搜尋失敗  \nEnd // 程式執行結束"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpesb_v3mm.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmpesb_v3mm.py\", line 44, in main\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpesb_v3mm.py\", line 21, in __init__\n    self.lookup[(pref, suff)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    \"\"\"特殊字典：根據前綴與後綴搜尋單字。\"\"\"\n\n    def __init__(self, words):\n        \"\"\"\n        建構函式：把所有單字的前綴和後綴組合存到字典中。\n        key 形式為 (prefix, suffix)，value 為單字在 words 中的最大索引。\n        \"\"\"\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            # 產生所有前綴（從空字串到完整字串）\n            for i in range(L + 1):\n                pref = word[:i]\n                # 產生所有後綴（從空字串到完整字串）\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        \"\"\"回傳符合前綴 prefix 與後綴 suffix 的最大索引，若不存在則回傳 -1。\"\"\"\n        return self.lookup.get((prefix, suffix), -1)\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 把兩個列表用逗號分隔的字串轉成 Python 物件\n    # 例如： '[[\"apple\"]], [\"a\", \"e\"]'  -> ([\"apple\"], [\"a\", \"e\"])\n    expr = f'({raw})'\n    words, query = ast.literal_eval(expr)\n\n    # query 可能是 ['prefix', 'suffix'] 或者單一字串（如果只提供前綴）\n    if isinstance(query, (list, tuple)):\n        prefix, suffix = query[0], query[1]\n    else:\n        prefix, suffix = query, ''\n\n    wf = WordFilter(words)\n    result = wf.f(prefix, suffix)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for design of special dictionary with prefix-suffix search. Steps: build data structure with Trie for prefixes and suffixes? Probably use trie mapping of words with all suffixes? Or use combined key pref + '#' + suff. Known solution: use dictionary mapping from pref+ '#' + suff to max index. Build for each word, all prefixes and suffixes combinations. Complexity large but acceptable. Provide virtual steps. We just need to output virtual code steps with explanation. Let's produce Start, Build dictionary mapping, f method. We'll include decisions. Use loops. Let's write virtual code step by step.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: WordFilter(words) // 建構函式，接受字串陣列  \n    → Step 1.1: 建立空字典 dict // 用來儲存所有(prefix + '#' + suffix) → 最大索引  \n    → Decision: 迭代每個單字 word 及其索引 idx 在 words 之中?  \n        → Yes → Step 1.2: 生成所有前綴 pref_list ← AllPrefixes(word) // 包含空字串  \n        → Decision: 迭代每個前綴 pref 在 pref_list?  \n            → Yes → Step 1.3: 生成所有後綴 suff_list ← AllSuffixes(word) // 包含空字串  \n            → Decision: 迭代每個後綴 suff 在 suff_list?  \n                → Yes → Step 1.4: key ← pref + '#' + suff // 組合鍵  \n                → Step 1.5: dict[key] ← idx // 覆寫或更新為最大索引（因 idx 逐步遞增）  \n            → No → 迭代結束  \n        → No → 迭代結束  \n    → No → 迭代結束  \n    → Step 1.6: 儲存 dict 為實例屬性 // 為後續查詢做準備  \n→ End // 建構完成  \n\n→ Step 2: f(pref, suff) // 查詢函式  \n    → Step 2.1: key ← pref + '#' + suff // 與建構時相同格式  \n    → Decision: key 是否存在於 dict?  \n        → Yes → Step 2.2: Return dict[key] // 取得最大索引  \n        → No  → Step 2.3: Return -1 // 無符合條件之單字  \n→ End // 函式結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Remove the minimum number of invalid parentheses to make the input string valid.\n        Return all possible results in a list.\n        \"\"\"\n        # Helper to check if a string is valid\n        def is_valid(string: str) -> bool:\n            count = 0\n            for ch in string:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        # BFS level set\n        level = {s}\n        while level:\n            # Find all valid strings in current level\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n\n            # Generate next level by removing one parenthesis\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        if next_item not in next_level:\n                            next_level.add(next_item)\n            level = next_level\n\n        return []\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    Parse input data to extract the string s.\n    Handles formats like: 's = \"()())()\"' or just '\"()())()\"'\n    \"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n    else:\n        value = data\n    # Remove surrounding quotes if present\n    if len(value) >= 2 and value[0] == value[-1] and value[0] in ('\"', \"'\"):\n        return value[1:-1]\n    return value\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    results = solution.removeInvalidParentheses(s)\n    # Print results as a JSON array to match the example output format\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudocode for algorithm: given string s containing parentheses and letters, remove minimal invalid parentheses to produce all valid strings. It's classic problem Leetcode 301. We need algorithm: BFS or DFS with pruning, computing min removals. Approach: compute leftRem and rightRem counts (number of extra '(' and ')') to remove. Then backtrack to generate all possible valid strings. Use recursion to explore removals and skip duplicates.\n\nSimplify: Use DFS with parameters index, leftCount, rightCount, leftRem, rightRem, path string, results set. At each char: if char is letter, just add. If '(' and leftRem>0, we can skip. If ')' and rightRem>0, skip. If '(' add and leftCount++. If ')' add if leftCount>0 else skip. At end, if index==len and leftRem==0 && rightRem==0 && leftCount==rightCount, add to set.\n\nBut we also need minimal removals; the counts computed ensure that.\n\nAlternate BFS approach: generate all strings by removing one char at a time, use set to avoid duplicates, and stop when we find first level of valid strings.\n\nBut pseudocode easier: BFS.\n\nWe'll produce pseudocode lines with steps and explanation. Use virtual code arrows. We'll produce Start, BFS queue, visited set, result set. While queue not empty: pop current. If valid: add to result, set found flag. Continue exploring deeper only if not found. For each position in current string: if char is '(' or ')', generate new string with that char removed. If new string not visited, add to queue.\n\nReturn result.\n\nInclude explanation each line.\n\nLet's produce lines accordingly. Use virtual code with arrows. Provide explanation after //.\n\nMake sure each line is \"虛擬碼步驟 // 解釋/說明\". Use \"Start\" \"End\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 queue ← [s] // 將原始字串加入 BFS 隊列  \n→ Step 2: 初始化 visited ← {s} // 記錄已處理的字串以避免重複  \n→ Step 3: 初始化 result ← ∅ // 儲存符合條件的最小刪除結果  \n→ Step 4: 初始化 found ← False // 判斷是否已找到最小刪除層級的有效字串  \n\n→ Decision: 若 queue 非空? // 若還有字串待處理  \n    Yes → Step 5: 從 queue 取出 front → current // 取下一個字串進行檢查  \n        → Decision: 若 current 為有效字串? // 檢查括號配對是否正確  \n            Yes → Step 6: 加入 current 至 result // 符合條件的字串加入結果集  \n                → Step 7: 設定 found ← True // 只需要同層級的最小刪除結果  \n                → Decision: 若已經找到最小刪除字串? // 是否停止進一步搜尋同層級字串  \n                    Yes → Step 8: 跳過後續生成新字串，直接返回隊列下一項  \n                    No  → Step 9: (實際上已在 found 為 True 時不會執行此路徑)  \n            No  → Decision: 若已找到最小刪除字串? // 若已找到，則不再生成更深層字串  \n                Yes → Step 10: 跳過生成後續子字串，繼續 while 迴圈  \n                No  → Step 11: 從 current 產生所有可能的子字串  \n                    → Decision: 對每個位置 i (0 ≤ i < len(current))?  \n                        Yes → Step 12: 若 current[i] 為 '(' 或 ')'  \n                            → Step 13: 生成 new ← current[0:i) + current(i+1:)] // 刪除位置 i 的括號  \n                                → Decision: 若 new 未在 visited?  \n                                    Yes → Step 14: 加入 new 至 queue // 新字串加入待處理隊列  \n                                        → Step 15: 加入 new 至 visited // 標記已處理  \n                                    No  → Step 16: 跳過，因已處理  \n                        No  → Step 17: 位置 i 不是括號，跳過  \n\n→ Decision: queue 是否空?  \n    Yes → End // BFS 完成，返回結果  \n    No  → 迴圈回到 Step 4 開始下一輪  \n\n// 之後輸出 result 集合中的所有字串即可。"
    },
    {
      "title": "Two Sum",
      "source_file": "Leetcode/leetcode1.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1q3nkdmo.py\", line 46, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1q3nkdmo.py\", line 32, in parse_input\n    nums = ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp27ztd9mk.py\", line 46, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp27ztd9mk.py\", line 32, in parse_input\n    nums = ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiyym9gmi.py\", line 46, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpiyym9gmi.py\", line 32, in parse_input\n    nums = ast.literal_eval(m.group(1))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"找出兩個數字的索引，使其和等於目標值。\"\"\"\n        dic = {}\n        for i, val in enumerate(nums):\n            # 檢查是否已經存在相差為 target - val 的數字\n            if target - val in dic:\n                return [dic[target - val], i]\n            # 若不存在，將目前數字及其索引存入字典\n            dic[val] = i\n        # 根據題目說明，必定有唯一解，若此行執行則表示輸入錯誤\n        return []\n\ndef parse_input(input_str: str):\n    \"\"\"從輸入字串中解析出 nums 與 target。\"\"\"\n    # 先把所有換行符轉成逗號，方便分割\n    cleaned = input_str.replace(\"\\n\", \",\")\n    parts = cleaned.split(\",\")\n    nums = None\n    target = None\n    for part in parts:\n        part = part.strip()\n        # 解析 nums\n        if part.lower().startswith(\"nums\"):\n            m = re.search(r\"nums\\s*=\\s*(.*)\", part, re.IGNORECASE)\n            if m:\n                # 使用 literal_eval 解析列表，安全性高\n                nums = ast.literal_eval(m.group(1))\n        # 解析 target\n        if part.lower().startswith(\"target\"):\n            m = re.search(r\"target\\s*=\\s*(-?\\d+)\", part, re.IGNORECASE)\n            if m:\n                target = int(m.group(1))\n    if nums is None or target is None:\n        raise ValueError(\"輸入格式錯誤，請提供 'nums' 與 'target'\")\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的全部內容\n    raw_input = sys.stdin.read()\n    # 解析出 nums 與 target\n    nums, target = parse_input(raw_input)\n    # 計算答案\n    result = Solution().twoSum(nums, target)\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for two-sum problem, line by line with comments. Use Start, Decision, etc. Let's produce steps: iterate over array, maintain hash map of complement to index. So steps: Start, Input array and target, Initialize hash map, Iterate i from 0 to len-1, compute complement, Decision: if complement in map? Yes -> return indices, No -> store current number in map. End. Need line numbers? Not necessary. Provide each line as \"→ Step: ...\" with comment.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums, target // 取得數字陣列與目標值  \n→ Decision: 初始化空 hash_map // 建立空字典存放數值與其索引  \n    Yes → Step: hash_map ← {} // hash_map 用於快速查找已遇過的數字  \n→ Step: 對每個索引 i 以及對應值 val 循環 (i 0 到 len(nums)-1) // 逐一檢查每個數字  \n    → Decision: 是否存在 hash_map[ target - val ]? // 檢查是否已找到能配對的數字  \n        Yes → Step: 返回 [ hash_map[ target - val ], i ] // 找到答案即返回兩個索引  \n        No  → Step: hash_map[ val ] ← i // 若未找到，將目前數字及其索引加入 hash_map  \nEnd // 程式執行結束"
    },
    {
      "title": "Bulls and Cows",
      "source_file": "Leetcode/leetcode299.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A3B'\nGot (Norm):      '1A0B'\n--- (Raw) ---\nRaw Expected: '\"1A3B\"'\nRaw Got:      '1A0B'"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A1B'\nGot (Norm):      '1A0B'\n--- (Raw) ---\nRaw Expected: '\"1A1B\"'\nRaw Got:      '1A0B'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef get_hint(secret: str, guess: str) -> str:\n    \"\"\"Return the Bulls and Cows hint for the given secret and guess.\"\"\"\n    bulls = cows = 0\n    # count[d] stores the difference between the number of digit d\n    # in secret and in guess for the positions that are not bulls.\n    count = [0] * 10\n\n    for s, g in zip(secret, guess):\n        if s == g:\n            bulls += 1\n        else:\n            # If the guess digit has been seen more times in guess\n            # than in secret up to this point, it forms a cow.\n            if count[int(g)] < 0:\n                cows += 1\n            # If the secret digit has been seen more times in secret\n            # than in guess up to this point, it also forms a cow.\n            if count[int(s)] > 0:\n                cows += 1\n            count[int(s)] += 1\n            count[int(g)] -= 1\n\n    return f\"{bulls}A{cows}B\"\n\ndef parse_input(data: str):\n    \"\"\"Parse the stdin data into secret and guess strings.\"\"\"\n    lines = data.strip().splitlines()\n    if not lines:\n        raise ValueError(\"No input provided\")\n    if len(lines) == 1:\n        # Try to extract the two quoted strings\n        quoted = re.findall(r'\"([^\"]*)\"', lines[0])\n        if len(quoted) >= 2:\n            return quoted[0], quoted[1]\n        # Fallback: split by comma\n        parts = lines[0].split(',')\n        secret = parts[0].split('=')[1].strip().strip('\"')\n        guess = parts[1].split('=')[1].strip().strip('\"')\n        return secret, guess\n    # Two separate lines: first secret, second guess\n    secret = lines[0].strip().strip('\"')\n    guess = lines[1].strip().strip('\"')\n    return secret, guess\n\ndef main():\n    data = sys.stdin.read()\n    secret, guess = parse_input(data)\n    print(get_hint(secret, guess))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Must follow format: each line: virtual code step + space + // explanation. Use arrows, Start, End, Decision etc. Need to implement logic: count bulls and cows. Use arrays to track frequency. We'll produce high-level pseudocode.\n\nLet's outline algorithm:\n\n- Start\n- Step 1: initialize bulls = 0, cows = 0\n- Step 2: create array count[10] = 0 for digits frequency in secret not matched\n- Step 3: loop i from 0 to len(secret)-1\n   - if secret[i] == guess[i] then bulls++ else:\n       - count[secret[i]]++ // secret digit\n       - count[guess[i]]-- // guess digit\n- After loop, cows = sum over digits of abs(count[d])? Actually count is net: positive means more secret, negative more guess. Cows = sum of min(secretCount, guessCount). Equivalent to sum over digits of max(0, count[d])? Wait algorithm: after loop, for each digit, if count[d] > 0 then we have more secret than guess; if <0 more guess. For cows, we sum min(secretCount, guessCount) which is sum over digits of max(0, -count[d])? Let's think: Standard algorithm: we increment count[secret[i]] and decrement count[guess[i]] for mismatches. After loop, cows = sum of max(0, -count[d])? Actually if secret has 3 of digit 1, guess has 1 of digit 1, mismatch: count[1] would be +2 (3-1). Cows should be 1. We need min(secretCount, guessCount). After loop, count[1] = 2 >0 meaning extra secret. We can compute cows as sum over d of max(0, -count[d])? For this case -count[1] = -2, so max(0,-2)=0 not correct. Alternatively we can accumulate cows during loop: when secret[i] != guess[i], if count[guess[i]] < 0 then cows++ ; if count[secret[i]] > 0 then cows++. Standard approach: When mismatched, if the count for the guess digit is negative (meaning this digit already appeared in guess earlier but not in secret yet), we increment cows. Similarly for secret digit. Let's use that.\n\nSo algorithm:\n\n- Initialize bulls=0, cows=0, count[10]=0\n- Loop over i:\n   - if secret[i]==guess[i] then bulls++\n   - else:\n       - if count[guess[i]] < 0 then cows++\n       - if count[secret[i]] > 0 then cows++\n       - count[secret[i]]++\n       - count[guess[i]]--\n- End loop\n- Output bulls and cows formatted.\n\nWe'll produce pseudocode.\n\nNeed to ensure lines with arrows etc.\n\nLet's craft:\n\nStart // 程式開始\n\n→ Step 1: 初始化 bulls = 0, cows = 0 // 計算貝利和牛的數量\n\n→ Step 2: 初始化 count[10] 為 0 // 追蹤各數字在不匹配位置的差異\n\n→ Step 3: 對 i 從 0 到 len(secret)-1 迴圈 // 遍歷每個位元\n\n    → Decision: 如果 secret[i] 等於 guess[i]? // 判斷是否為貝利\n\n        Yes → Step 4: bulls++ // 找到一個貝利\n\n        No  → Step 5: 進行牛的檢查與計數\n\n            → Step 5.1: 如果 count[guess[i]] < 0? // guess 的數字在先前不匹配中多出來\n\n                Yes → Step 5.1.1: cows++ // 為牛\n\n                No  → Step 5.1.2: // 不執行\n\n            → Step 5.2: 如果 count[secret[i]] > 0? // secret 的數字在先前不匹配中多出來\n\n                Yes → Step 5.2.1: cows++ // 為牛\n\n                No  → Step 5.2.2: // 不執行\n\n            → Step 5.3: count[secret[i]]++ // 更新 secret 的計數\n\n            → Step 5.4: count[guess[i]]-- // 更新 guess 的計數\n\n← End of loop\n\n→ Step 6: 回傳 字串 \"${bulls}A${cows}B\" // 格式化輸出\n\nEnd // 程式結束\n\nBut we need each line formatted with \"虛擬碼步驟\" and explanation. Use arrows and structure.\n\nLet's produce final answer accordingly. Use Start, End. Use arrow arrow for each line. Provide explanation after //.\n\nMake sure no actual code, just pseudocode steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 bulls = 0, cows = 0 // 設定貝利與牛的計數器為零  \n→ Step 2: 初始化 count[10] 為 0 // 用於追蹤每個數字在不匹配位置的差異  \n→ Step 3: 對 i 從 0 到 len(secret)-1 進行迴圈 // 遍歷每個位元  \n  → Decision: 如果 secret[i] 等於 guess[i]? // 判斷是否為貝利  \n   Yes → Step 4: bulls++ // 找到一個貝利，計數器加一  \n   No → Step 5: 進行牛的檢查與計數  \n    → Step 5.1: 如果 count[guess[i]] < 0? // guess 的數字在先前不匹配中已出現多一次  \n     Yes → Step 5.1.1: cows++ // 確定為牛，計數器加一  \n     No → Step 5.1.2: // 無動作  \n    → Step 5.2: 如果 count[secret[i]] > 0? // secret 的數字在先前不匹配中已出現多一次  \n     Yes → Step 5.2.1: cows++ // 確定為牛，計數器加一  \n     No → Step 5.2.2: // 無動作  \n    → Step 5.3: count[secret[i]]++ // 更新 secret 的計數器  \n    → Step 5.4: count[guess[i]]-- // 更新 guess 的計數器  \n→ Step 6: 回傳字串 \"${bulls}A${cows}B\" // 格式化輸出為 xAyB  \nEnd // 程式執行結束"
    },
    {
      "title": "Merge Intervals",
      "source_file": "Leetcode/leetcode56.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,6],[8,10],[15,18]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[1,6],[8,10],[15,18]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,5]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[1,5]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,7]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[1,7]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\nfrom ast import literal_eval\n\ndef merge(intervals):\n    if not intervals:\n        return []\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for current in intervals[1:]:\n        prev = merged[-1]\n        if current[0] <= prev[1]:\n            prev[1] = max(prev[1], current[1])\n        else:\n            merged.append(current)\n    return merged\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 從輸入字串中提取區間列表\n    match = re.search(r'=\\s*(\\[[^\\]]*\\])', raw)\n    list_str = match.group(1) if match else raw\n    try:\n        intervals = literal_eval(list_str)\n    except Exception:\n        intervals = []\n    result = merge(intervals)\n    # 以 JSON 格式輸出，保持無空格的簡潔表示\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for merging overlapping intervals. Provide each line with arrow or decision etc. Start, End, Decision. Should be virtual code with \"Step 1:\" etc. Provide explanation after //.\n\nWe need to output only the pseudocode lines with explanation. Use Start and End markers. Use arrow. Use Decision. Should not output actual code. Must be in Traditional Chinese.\n\nLet's design steps:\n\n1. Start\n2. Step 1: Input intervals array\n3. Step 2: If intervals empty → return empty\n4. Step 3: Sort intervals by start ascending\n5. Step 4: Initialize merged list with first interval\n6. Step 5: For each interval from second to last:\n   - Decision: if current.start <= lastMerged.end?\n       Yes → update lastMerged.end = max(lastMerged.end, current.end) // merge\n       No  → Append current to merged // no overlap\n7. Step 6: Return merged\n8. End\n\nWe need to include arrow for loops? maybe use → for Step 5 loop. Use Decision inside.\n\nWe need to represent \"for each interval\". Use \"Loop: for i from 1 to len-1\". Use \"→\" for inside.\n\nLet's produce lines.\n\nUse \"→ Step ...\" and \"Decision: ...\".\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: intervals ← Input // 取得輸入的區間陣列\n→ Decision: intervals 為空? // 檢查是否沒有區間\n    Yes → Return [] // 若為空，直接回傳空陣列\n    No  → Continue // 否則進行排序\n→ Step 2: intervals ← Sort(intervals, by start ascending) // 按起點排序\n→ Step 3: merged ← [intervals[0]] // 以第一個區間開始合併清單\n→ Loop: for i ← 1 to len(intervals)-1 // 從第二個區間開始遍歷\n    → Current ← intervals[i] // 取得當前區間\n    → Last ← merged[-1] // 取得已合併清單的最後一個區間\n    → Decision: Current.start ≤ Last.end? // 判斷是否重疊\n        Yes → Last.end ← max(Last.end, Current.end) // 重疊則更新終點\n        No  → Append merged ← Current // 不重疊則加入新區間\n→ Step 4: Return merged // 回傳合併後的區間列表\nEnd // 程式執行結束\n\nBut we need to include each line with \"虛擬碼步驟\". Use \"Step\" etc. Use arrow \"→\" before each step. For loop we can use \"Loop:\" but it's not typical in given format. They want arrow for structure. We could use \"→ Loop: for i...\" but we can also just embed inside Decision.\n\nBetter to keep simple: Use \"→ Step 5: For i in 1..len-1\" etc. Use \"Decision\" inside.\n\nLet's craft final answer accordingly. Ensure each line is separate, with arrow. Use \"Decision:\" lines as nested. Use indentation? The example uses indentation for nested lines. We'll mimic that.\n\nMake sure to maintain Traditional Chinese for comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: intervals ← Input // 取得輸入的區間陣列  \n→ Decision: intervals 為空? // 檢查是否沒有區間  \n  Yes → Return [] // 若為空，直接回傳空陣列  \n  No  → Continue // 否則進行排序  \n→ Step 2: intervals ← Sort(intervals, by start ascending) // 按起點排序  \n→ Step 3: merged ← [intervals[0]] // 以第一個區間開始合併清單  \n→ Loop: for i ← 1 to len(intervals)-1 // 從第二個區間開始遍歷  \n  → Current ← intervals[i] // 取得當前區間  \n  → Last ← merged[-1] // 取得已合併清單的最後一個區間  \n  → Decision: Current.start ≤ Last.end? // 判斷是否重疊  \n    Yes → Last.end ← max(Last.end, Current.end) // 重疊則更新終點  \n    No  → Append merged ← Current // 不重疊則加入新區間  \n→ Step 4: Return merged // 回傳合併後的區間列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 找出所有非負整數字串\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        # 如果輸入是兩行，每行一個數字\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            nums = [lines[0], lines[1]]\n    if len(nums) < 2:\n        return\n\n    num1, num2 = nums[0], nums[1]\n    sol = Solution()\n    result = sol.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. The requirement: two non-negative integers as strings, sum as string, no BigInteger, no converting to integer directly. So we need to simulate addition digit by digit.\n\nWe produce steps: Start, Input strings, Initialize carry, set i pointing to end of strings, loop while i>=0 or j>=0 or carry. Add digits by converting char to int via subtract '0'. Sum = digit1 + digit2 + carry, new digit = sum % 10, carry = sum /10. Append digit to result (build reversed). After loop reverse or build in correct order. Then output result.\n\nWe need to use pseudocode arrows, Decision. Provide each line. Format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce step by step.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Input num1, num2 // 取得兩個數字字串\n→ Set i = length(num1) - 1 // 指向 num1 最右端\n→ Set j = length(num2) - 1 // 指向 num2 最右端\n→ Set carry = 0 // 初始進位\n→ Set result = empty string // 存放累加結果\n→ Decision: i >= 0 or j >= 0 or carry > 0? // 檢查是否還有位數或進位\n    Yes → Step: digit1 = 0 if i < 0 else int(num1[i]) // 取得 num1 目前位數\n    → Step: digit2 = 0 if j < 0 else int(num2[j]) // 取得 num2 目前位數\n    → Step: sum = digit1 + digit2 + carry // 計算本位總和\n    → Step: result = (sum % 10) appended to front of result // 取個位並加入結果\n    → Step: carry = sum / 10 // 取進位\n    → Step: i = i - 1 // 移到 num1 前一位\n    → Step: j = j - 1 // 移到 num2 前一位\n    → Go back to Decision\n    No → End of loop\n→ End // 程式結束\n\nBut we must provide per line. Also we can include \"Start\" and \"End\". Use arrow notation as required. Let's produce.\n\nWe must include \"Start // ...\", \"→ Step\" etc. Use decision with Yes/No branches. Provide explanation after //.\n\nLet's write each line.\n\nWe should ensure that each line ends with // explanation.\n\nWe must use \"Start\" and \"End\" as separate lines.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input num1, num2 // 取得兩個數字字串  \n→ Set i = length(num1) - 1 // 讓 i 指向 num1 最右端的索引  \n→ Set j = length(num2) - 1 // 讓 j 指向 num2 最右端的索引  \n→ Set carry = 0 // 初始進位值為 0  \n→ Set result = \"\" // 用於累積計算出的每一位數字，最終將是答案  \n→ Decision: i >= 0 or j >= 0 or carry > 0? // 判斷是否還有位數需要處理或進位仍未歸零  \n    Yes → Step: digit1 = 0 if i < 0 else int(num1[i]) // 取得 num1 目前位數，若已越界則為 0  \n    → Step: digit2 = 0 if j < 0 else int(num2[j]) // 取得 num2 目前位數，若已越界則為 0  \n    → Step: sum = digit1 + digit2 + carry // 計算本位總和（包括進位）  \n    → Step: result = str(sum % 10) + result // 取個位數字並放在 result 前面  \n    → Step: carry = sum // 10 // 計算新的進位  \n    → Step: i = i - 1 // 移動到 num1 的上一位  \n    → Step: j = j - 1 // 移動到 num2 的上一位  \n    → Go back to Decision // 回到條件判斷繼續處理下一位  \n    No → End // 所有位數及進位都已處理完畢，結束循環  \nEnd // 程式執行結束，result 為兩數相加的字串結果"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"初始化，將每個目標值對應的所有索引存於字典中\"\"\"\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"隨機選取 target 的索引，若存在多個索引則機率均等\"\"\"\n        return random.choice(self.indices[target])\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析為兩個列表：commands 與 arguments\n    # 例如輸入: '[\"Solution\", \"pick\", \"pick\"], [[[1, 2, 3]], [1], [2]]'\n    # 會得到 commands=['Solution','pick','pick'], args=[[1,2,3],[1],[2]]\n    commands, args_list = ast.literal_eval(raw)\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構物件\n            obj = Solution(*args)\n            results.append(None)  # 按題目輸出 null\n        else:\n            # 呼叫方法\n            res = getattr(obj, cmd)(*args)\n            results.append(res)\n\n    # 輸出結果，使用 json.dumps 讓 None 變成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. For this problem, typical solution: store mapping from target to list of indices; pick random from list. Or reservoir sampling during pick. Let's outline: In constructor, iterate array, map target to list of indices. In pick, get list and random choice. Virtual code lines.\n\nWe output with arrows. Use \"Start\", \"End\", \"Decision:\".\n\nLet's craft:\n\nStart\n→ Step 1: 初始化哈希表 targetToIndices // 建立目標到索引列表的映射\n→ Step 2: 迭代 nums 並填充 targetToIndices // 為每個值將其索引加入對應列表\nEnd // 建構完成\n\nThen pick method:\n\nStart // pick 方法開始\n→ Step 3: 取得 target 對應的索引列表 idxList = targetToIndices[target] // 獲取所有符合目標的索引\n→ Decision: 如果 idxList 為空? // 檢查是否有匹配\n    Yes → Step 4: 回傳 -1 // 雖然題目保證存在，但此處作安全處理\n    No  → Step 5: 生成隨機整數 r 於 0 到 len(idxList)-1 // 隨機選擇一個位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束\n\nBut we need to output each line with virtual code arrow and comment. We need to use \"→\" arrow. For decisions, use \"Decision:\" with indentation.\n\nMake sure each line is separate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 targetToIndices: Map<int, List<int>> // 用於儲存每個目標值對應的索引列表\n→ Step 2: 從 nums 迭代 i = 0 至 nums.length-1\n    → Decision: 若 nums[i] 尚未在 targetToIndices 中? // 檢查鍵是否存在\n        Yes → Step 3a: 建立新列表 targetToIndices[nums[i]] = [] // 初始化列表\n        No  →\n    → Step 3b: 將索引 i 加入 targetToIndices[nums[i]] // 將索引加入對應列表\nEnd // 建構完成\n\nStart // pick 方法開始\n→ Step 4: 取得 idxList = targetToIndices[target] // 取得所有符合目標的索引\n→ Decision: 若 idxList 為空? // 安全檢查，實際不會發生\n    Yes → Step 5a: 回傳 -1 // 不合法情況返回 -1\n    No  →\n→ Step 5b: 產生隨機整數 r 在 0 與 len(idxList)-1 之間 // 隨機選取索引位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束\n\nBut need to follow the format exactly: each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow. Also \"Start\" \"End\". We need indent for nested lines. In sample, they had indentation with spaces before arrow.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 targetToIndices: Map<int, List<int>> // 用於儲存每個目標值對應的索引列表\n→ Step 2: 從 nums 迭代 i = 0 至 nums.length-1\n    → Decision: 若 nums[i] 尚未在 targetToIndices 中? // 檢查鍵是否存在\n        Yes → Step 3a: 建立新列表 targetToIndices[nums[i]] = [] // 初始化列表\n        No  →\n    → Step 3b: 將索引 i 加入 targetToIndices[nums[i]] // 將索引加入對應列表\nEnd // 建構完成\n\nStart // pick 方法開始\n→ Step 4: 取得 idxList = targetToIndices[target] // 取得所有符合目標的索引\n→ Decision: 若 idxList 為空? // 安全檢查，實際不會發生\n    Yes → Step 5a: 回傳 -1 // 不合法情況返回 -1\n    No  →\n→ Step 5b: 產生隨機整數 r 在 0 與 len(idxList)-1 之間 // 隨機選取索引位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束\n\nBut the format maybe expects each line with arrow and comment. Indentation may use spaces. Provide exactly as sample: use 4 spaces before inner lines? They used 4 spaces before \"Yes →\". So replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 targetToIndices: Map<int, List<int>> // 用於儲存每個目標值對應的索引列表\n→ Step 2: 從 nums 迭代 i = 0 至 nums.length-1\n    → Decision: 若 nums[i] 尚未在 targetToIndices 中? // 檢查鍵是否存在\n        Yes → Step 3a: 建立新列表 targetToIndices[nums[i]] = [] // 初始化列表\n        No  →\n    → Step 3b: 將索引 i 加入 targetToIndices[nums[i]] // 將索引加入對應列表\nEnd // 建構完成\n\nStart // pick 方法開始\n→ Step 4: 取得 idxList = targetToIndices[target] // 取得所有符合目標的索引\n→ Decision: 若 idxList 為空? // 安全檢查，實際不會發生\n    Yes → Step 5a: 回傳 -1 // 不合法情況返回 -1\n    No  →\n→ Step 5b: 產生隨機整數 r 在 0 與 len(idxList)-1 之間 // 隨機選取索引位置\n→ Step 6: 回傳 idxList[r] // 返回隨機索引\nEnd // pick 方法結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立以反向詞為鍵、索引為值的字典\n        rev_dict = {w[::-1]: i for i, w in enumerate(words)}\n        res = []\n        # 遍歷每個詞\n        for i, word in enumerate(words):\n            n = len(word)\n            # 分割點從 0 到 n（含 n）\n            for cut in range(n + 1):\n                prefix = word[:cut]\n                suffix = word[cut:]\n\n                # 前綴為回文時，檢查反向後綴是否存在\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    j = rev_dict.get(rev_suffix)\n                    if j is not None and j != i:\n                        res.append([j, i])\n\n                # 後綴為回文時（且 cut != n 防止重複），檢查反向前綴\n                if cut != n and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    j = rev_dict.get(rev_prefix)\n                    if j is not None and j != i:\n                        res.append([i, j])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 解析輸入，例如 \"words = ['abcd','dcba']\"\n    if data.startswith(\"words\"):\n        _, words_part = data.split(\"=\", 1)\n        words_str = words_part.strip()\n    else:\n        words_str = data\n    # 使用 ast.literal_eval 以安全方式解析列表字面量\n    words = ast.literal_eval(words_str)\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for algorithm to find palindrome pairs in O(total length). This is typical problem: for each word, we consider prefixes and suffixes, and store reversed words in hash map, check for splits. Complexity O(total length). We'll write pseudocode lines with explanation. Use Start, End, Decision, etc. Ensure each line ends with // explanation.\n\nLet's produce step-by-step.\n\nStart\n→ Step 1: 建立哈希表 map，鍵為詞語的倒序，值為該詞在 words 陣列中的索引 // 用於快速查找反向詞\n→ Step 2: 初始化結果 list pairs // 用於儲存符合條件的索引對\n→ Step 3: 遍歷 words，對於每個索引 i 和詞 word // 主迴圈\n    → Step 3a: 取得 word 長度 n\n    → Step 3b: 對於分割位置 cut 從 0 到 n（包括 n）進行迴圈 // 包含全字母分割\n        → Decision: 前綴 word[0:cut] 是否為回文？ // 檢查左側\n            Yes → 取反向前綴 revPre = reverse(word[cut:]) // 從分割點到末尾\n                 → Decision: revPre 是否存在於 map 且 map[revPre] != i？ // 找到匹配的右側詞\n                     Yes → Step 3b1: 加入 (map[revPre], i) 到 pairs // 右側詞 + word 形成回文\n                     No  → No action\n            No  → No action\n        → Decision: 後綴 word[cut:] 是否為回文？ // 檢查右側\n            Yes → 取反向後綴 revSuf = reverse(word[0:cut]) // 從開頭到分割點\n                 → Decision: revSuf 是否存在於 map 且 map[revSuf] != i？\n                     Yes → Step 3b2: 加入 (i, map[revSuf]) 到 pairs // word + 右側詞形成回文\n                     No  → No action\n            No  → No action\n    → Step 3c: 特殊處理：當 word 本身為回文且空字符串在 map 中存在，避免重複\nEnd\n\nNeed to incorporate handling of empty string. Use step 3d.\n\nBut we must maintain O(total length). The loops are within each word's length. So overall O(total length). Provide pseudocode accordingly.\n\nLet's produce final output. Ensure each line has the arrow and explanation. Use indentation.\n\nAlso use arrow → for steps. Use Decision: for branching. Indent inside decisions with 4 spaces maybe.\n\nWe need to include lines for building map, result list, main loop, etc.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立哈希表 map，鍵為 words[i] 的倒序，值為 i // 方便快速查找反向詞  \n→ Step 2: 初始化空列表 pairs 用於儲存所有 (i, j)  \n→ Step 3: 遍歷 words，對每個索引 i 與詞 word  \n    → Step 3a: 設置 n = len(word) // 詞長度  \n    → Step 3b: 對於切割位置 cut 從 0 到 n（含 n）  \n        → Decision: 前綴 word[0:cut] 是否為回文？ // 檢查左側是否已經對稱  \n            Yes → Step 3b1: 取 revPre = reverse(word[cut:]) // 從切割點到結尾的反向  \n                → Decision: revPre 是否存在於 map 且 map[revPre] != i？ // 找到匹配右側詞  \n                    Yes → Step 3b1a: 加入 (map[revPre], i) 到 pairs // 右側詞 + word 為回文  \n                    No → No action  \n            No → No action  \n        → Decision: 後綴 word[cut:] 是否為回文？ // 檢查右側是否已經對稱  \n            Yes → Step 3b2: 取 revSuf = reverse(word[0:cut]) // 從開頭到切割點的反向  \n                → Decision: revSuf 是否存在於 map 且 map[revSuf] != i？ // 找到匹配左側詞  \n                    Yes → Step 3b2a: 加入 (i, map[revSuf]) 到 pairs // word + 右側詞為回文  \n                    No → No action  \n            No → No action  \n    → Step 3c: 若 word 本身為回文且空字串 \"\" 在 map 中，且 map[\"\"] != i，加入 (i, map[\"\"]) 和 (map[\"\"], i) // 處理空字串特殊情況  \nEnd // 程式執行結束並返回 pairs"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeun83gyn.py\", line 33, in <module>\n    ops = ast.literal_eval(data[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x750fb4326c90>"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        # No operations to process\n        print([])\n        sys.exit(0)\n\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MyQueue\":\n            obj = MyQueue()\n            result.append(None)\n        elif op == \"push\":\n            obj.push(arg[0])\n            result.append(None)\n        elif op == \"pop\":\n            result.append(obj.pop())\n        elif op == \"peek\":\n            result.append(obj.peek())\n        elif op == \"empty\":\n            result.append(obj.empty())\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing a queue using two stacks. Provide step-by-step explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Provide Start, End. Include decision structure. Need to be line by line. Let's craft.\n\nPseudo code for MyQueue class:\n\nStart\n→ Define stack1 // 主堆，用於push\n→ Define stack2 // 助堆，用於pop/peek\n\nDefine push(x)\n    → stack1.push(x) // 把元素推入主堆\n\nDefine pop()\n    → Decision: If stack2 is empty? // 檢查助堆是否有元素\n        Yes → Step: While stack1 not empty:\n                → temp = stack1.pop()\n                → stack2.push(temp) // 把主堆的元素倒轉到助堆\n        No → // nothing\n    → result = stack2.pop() // 取出前端元素\n    → Return result\n\nDefine peek()\n    → Decision: If stack2 is empty?\n        Yes → Step: While stack1 not empty:\n                → temp = stack1.pop()\n                → stack2.push(temp)\n        No → // nothing\n    → result = stack2.peek() // 取得前端元素但不移除\n    → Return result\n\nDefine empty()\n    → Decision: If stack1 is empty AND stack2 is empty?\n        Yes → Return true\n        No → Return false\n\nEnd\n\nWe need to write each line as virtual code with explanation. Use \"Start //\". Use arrows \"→\". Provide indentation maybe not necessary.\n\nLet's produce lines.\n\nWe must show each line of pseudo code. Also each line includes explanation. Let's produce.\n\nBe careful: Use \"Start\" and \"End\" at beginning and end.\n\nLet's write.\n\n```\nStart // 程式開始執行\n→ Define stack1 // 主堆，儲存入列元素\n→ Define stack2 // 助堆，用於出列與取首元素\n→ Define push(x) // 推送元素到佇列尾部\n    → stack1.push(x) // 將 x 放到主堆頂部\n→ Define pop() // 從佇列頭部移除並回傳元素\n    → Decision: stack2.isEmpty()? // 判斷助堆是否已有元素\n        Yes → While stack1 is not empty? // 若助堆空，將主堆倒轉進助堆\n                → temp = stack1.pop() // 取主堆頂\n                → stack2.push(temp) // 推入助堆\n        No → // 助堆已有元素，直接使用\n    → result = stack2.pop() // 從助堆頂取出佇列首元素\n    → Return result\n→ Define peek() // 取得佇列頭部元素但不移除\n    → Decision: stack2.isEmpty()? // 同樣判斷助堆是否空\n        Yes → While stack1 is not empty?\n                → temp = stack1.pop()\n                → stack2.push(temp)\n        No →\n    → result = stack2.peek() // 取得助堆頂元素\n    → Return result\n→ Define empty() // 檢查佇列是否為空\n    → Decision: stack1.isEmpty() AND stack2.isEmpty() ?\n        Yes → Return true // 兩堆皆空，佇列空\n        No  → Return false // 至少有一堆有元素\nEnd // 程式執行結束\n```\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". We need to avoid indentation? We can keep indentation for readability. Each line including indentation still counted as line. Provide arrow \"→\". For nested blocks we might indent lines with 4 spaces.\n\nBut the format sample shows indentation like \"→ Decision: ... //\" and then lines inside with indentation \"    Yes → Step ...\" etc. So we can replicate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Define stack1 // 主堆，儲存入列元素\n→ Define stack2 // 助堆，用於出列與取首元素\n→ Define push(x) // 推送元素到佇列尾部\n    → stack1.push(x) // 將 x 放到主堆頂部\n→ Define pop() // 從佇列頭部移除並回傳元素\n    → Decision: stack2.isEmpty()? // 判斷助堆是否已有元素\n        Yes → While stack1.isNotEmpty()? // 若助堆空，將主堆倒轉進助堆\n                → temp = stack1.pop() // 取主堆頂\n                → stack2.push(temp) // 推入助堆\n        No → // 助堆已有元素，直接使用\n    → result = stack2.pop() // 從助堆頂取出佇列首元素\n    → Return result\n→ Define peek() // 取得佇列頭部元素但不移除\n    → Decision: stack2.isEmpty()? // 同樣判斷助堆是否空\n        Yes → While stack1.isNotEmpty()?\n                → temp = stack1.pop()\n                → stack2.push(temp)\n        No →\n    → result = stack2.peek() // 取得助堆頂元素\n    → Return result\n→ Define empty() // 檢查佇列是否為空\n    → Decision: stack1.isEmpty() AND stack2.isEmpty() ?\n        Yes → Return true // 兩堆皆空，佇列空\n        No  → Return false // 至少有一堆有元素\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef findLUSlength(strs):\n    \"\"\"\n    回傳陣列中最長的不常見子序列長度。\n    若不存在，回傳 -1。\n    \"\"\"\n    if not strs:\n        return -1\n\n    # 計算每個字串的出現頻率\n    freq = Counter(strs)\n\n    # 找出所有唯一字串（頻率為 1）的長度，取最大值\n    max_len = -1\n    for s in strs:\n        if freq[s] == 1:\n            max_len = max(max_len, len(s))\n\n    return max_len\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，並移除前後空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n    else:\n        # 解析 JSON 格式的字串陣列\n        try:\n            strs = json.loads(raw_input)\n        except json.JSONDecodeError:\n            # 若解析失敗，直接輸出 -1\n            print(-1)\n        else:\n            # 確保輸入為字串列表\n            if isinstance(strs, list) and all(isinstance(x, str) for x in strs):\n                result = findLUSlength(strs)\n                print(result)\n            else:\n                print(-1)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve longest uncommon subsequence length between strings array. Problem: from LeetCode \"Longest Uncommon Subsequence II\". The solution: if any string not equal to any other, answer length of that string. If all strings same, answer -1.\n\nSteps: read array, find duplicates. Use map count. For each string, if its count==1, candidate length. Take max. If max found, return that, else -1.\n\nLet's produce steps:\n\nStart\n→ Step 1: Build frequency map of all strings // Count occurrences\n→ Step 2: Initialize maxLen = -1 // Default result\n→ Decision: For each string in array // Iterate\n    Yes → Decision: If frequency of string == 1? // Unique string\n        Yes → Step 3: Update maxLen = max(maxLen, length of string) // Update longest unique\n        No → Step 4: // Skip duplicate strings\nEnd\n→ Step 5: Return maxLen // Final answer (may be -1)\n\nNeed to show virtual code arrow and explanation. Use Decision arrow for loops. Use Yes/No arrow for condition. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字串頻率表 freq_map 以計算每個字串在陣列中的出現次數 // 方便判斷是否唯一  \n→ Step 2: 初始化 maxLen 為 -1，表示目前尚未找到不常見子序列長度 // -1 代表不存在  \n→ Decision: 針對陣列中的每個字串 str 進行迭代 // 逐一檢查  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Decision: 若 freq_map[str] == 1？ // 判斷字串是否唯一  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: maxLen = max(maxLen, len(str)) // 更新目前最長的不常見子序列長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 4: // 字串重複，忽略不作處理  \nEnd // 迭代結束  \n→ Step 5: 回傳 maxLen // 若 maxLen 為 -1 表示不存在，否則為最長不常見子序列長度"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"找出 DNA 序列中重複出現的 10 字母子序列。\"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    # 讀取所有輸入資料\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 從輸入中抽取 DNA 序列\n    # 例如: \"s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'\"\n    # 也可能直接輸入 DNA 字串本身\n    match = re.search(r\"['\\\"](.+?)['\\\"]\", data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data.strip()\n\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(s)\n\n    # 以列表字面量形式輸出，逗號後不留空格\n    if result:\n        print(f'[\"' + '\",\"'.join(result) + '\"]')\n    else:\n        print('[]')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find all 10-letter-long substrings that appear more than once in string s. Classic LeetCode 187. Approach: sliding window of length 10, hash set for seen, result set. Use dictionary. Complexity O(n). We'll produce step-by-step pseudocode lines with explanations.\n\nWe must follow format: \"Start // 程式開始執行\" etc.\n\nUse arrow lines. Should produce each step line.\n\nProbably steps:\n\nStart\n→ Step 1: If length of s < 10 then return empty // early exit\n→ Step 2: 初始化空集合 seen // track substrings seen once\n→ Step 3: 初始化空集合 repeated // track substrings seen >1\n→ Step 4: 循環 i from 0 to len(s)-10 // sliding window\n    → Step 5: substring = s[i:i+10] // current 10-char sequence\n    → Decision: substring in seen? // has appeared before?\n        Yes → Step 6: add substring to repeated // record duplicate\n        No  → Step 7: add substring to seen // first occurrence\n→ Step 8: 返回 repeated // convert to list or set\nEnd\n\nWe can also mention use of hash sets. Provide each line with explanation.\n\nMake sure each line ends with // 解釋.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 s 的長度 < 10? // 檢查輸入是否足夠長以包含 10 字母序列  \n  Yes → Step 1: 返回空集合 // 沒有足夠長度，直接回傳空結果  \n  No  → Step 2: 初始化空集合 seen // 用於儲存第一次遇到的 10 字母子序列  \n→ Step 3: 初始化空集合 repeated // 用於儲存已重複出現的 10 字母子序列  \n→ Step 4: 循環 i 從 0 到 len(s)-10 // 以滑動視窗方式遍歷所有長度為 10 的子序列  \n  → Step 5: substring ← s[i:i+10] // 取得目前的 10 字母子序列  \n  → Decision: substring 是否已存在於 seen? // 判斷此子序列是否已出現過  \n    Yes → Step 6: 將 substring 加入 repeated // 已重複，記錄下來  \n    No  → Step 7: 將 substring 加入 seen // 第一次出現，加入 seen 集合  \n→ Step 8: 返回 repeated // 將重複出現的子序列作為結果回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef permute(nums):\n    \"\"\"返回 nums 的所有排列\"\"\"\n    res = []\n\n    def backtrack(start):\n        # ① 基本情況：當 start 等於長度時，已得到完整排列\n        if start == len(nums):\n            res.append(nums[:])  # ② 把目前排列複製加入結果\n            return\n        # ③ 迭代每個可能的交換位置\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]   # ④ 交換\n            backtrack(start + 1)                         # ⑤ 進一步遞迴\n            nums[start], nums[i] = nums[i], nums[start]   # ⑥ 反向交換回原來\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 從輸入中提取數字列表，例如 \"nums = [1,2,3]\"\n    try:\n        # 找到第一個 '[' 和最後一個 ']' 之間的子字串\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        nums_str = data[start:end]\n        nums = ast.literal_eval(nums_str)  # 安全地解析為列表\n    except (ValueError, SyntaxError):\n        # 若解析失敗，直接使用 eval（假設輸入合法）\n        nums = eval(data.split('=')[-1].strip())\n\n    # 計算所有排列\n    result = permute(nums)\n\n    # 輸出結果，與範例輸出的格式保持一致\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation after each line, no actual code. Use Start, End, Decision. Provide algorithm for generating all permutations of array of distinct integers. Use backtracking recursion. Provide steps: Start, initialize result list, call backtrack with path and used set. Then in backtrack: if path length == len(nums) -> add copy to result. Else iterate each num: if not used then mark used, add to path, backtrack, then backtrack (unmark, remove). After recursion finish, End. Provide explanations. Ensure each line has virtual code step + space + // explanation. Use arrow lines for steps. Use decisions for base case. Use Yes/No. Should maintain arrow format as examples: \"→ Step 1: ...\" etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 generatePermutations(nums) // 接收整數陣列作為輸入  \n→ Step 2: 初始化 result 為空列表 // 用於儲存所有排列  \n→ Step 3: 初始化 path 為空列表 // 目前正在構造的排列  \n→ Step 4: 初始化 used 為空集合 // 追蹤已被選用的數字  \n→ Step 5: 定義遞迴函式 backtrack() // 進行深度優先搜尋  \n→ Step 6: Decision: 如果 len(path) == len(nums)? // 檢查是否已組成完整排列  \n  Yes → Step 7: 將 path 的複製加入 result // 完整排列完成，加入結果  \n  No → Step 8: For each num in nums // 循環所有可能的數字  \n   Decision: 如果 num 未在 used? // 判斷此數字是否已被使用  \n    Yes → Step 9: 將 num 加入 path // 將數字加入當前排列  \n      Step 10: 將 num 加入 used // 標記為已使用  \n      Step 11: 呼叫 backtrack() // 進一步遞迴構造  \n      Step 12: 從 used 中移除 num // 退回，取消標記  \n      Step 13: 從 path 中移除最後一個元素 // 退回，取消加入  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[None,True,False,True,2,True,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[None, True, False, True, 2, True, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用於存儲所有元素\n        self.data = []\n        # 字典，key 為元素值，value 為包含該元素索引的集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 把新元素放到列表尾部\n        self.data.append(val)\n        # 把新索引加入到對應值的集合\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此值之前不存在，返回 True；否則返回 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 若此值不存在或集合為空，直接返回 False\n        if not self.idx_map[val]:\n            return False\n        # 隨機取出一個索引（任何一個都可）\n        remove_idx = self.idx_map[val].pop()\n        # 取最後一個元素的值\n        last_val = self.data[-1]\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n        # 更新最後一個元素索引集合\n        self.idx_map[last_val].add(remove_idx)\n        # 刪除舊索引\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        # 刪除列表最後一個元素\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選擇並返回一個元素\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析為兩個列表\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        # 可能輸入跨多行，先把換行符替換空格再解析\n        raw_input = raw_input.replace('\\n', ' ')\n        ops, args = ast.literal_eval(raw_input)\n        # 結果列表\n        res = []\n        # 先執行第一個操作，通常是構造器\n        obj = None\n        for op, arg in zip(ops, args):\n            if op == \"RandomizedCollection\":\n                obj = RandomizedCollection()\n                res.append(None)\n            elif op == \"insert\":\n                res.append(obj.insert(*arg))\n            elif op == \"remove\":\n                res.append(obj.remove(*arg))\n            elif op == \"getRandom\":\n                res.append(obj.getRandom())\n        # 輸出結果\n        print(res)\n    else:\n        # 若輸入為空，直接退出\n        pass",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line with comments. Provide structure: Start, End, Decision. The pseudocode is for RandomizedCollection operations: insert, remove, getRandom. Use data structures: list/array for values, hashmap value->set of indices. Also maintain total size. Provide steps for each function. Also include initialization. Provide high-level pseudocode of whole class, not actual code. Provide steps for each method with decisions. Ensure each step has comment. Use \"→\" for next step. Provide line by line. Let's produce.\n\nWe'll start with Start // program starts. Then we define class RandomizedCollection. Steps inside: initialization: create array/list, map. Then methods: insert, remove, getRandom.\n\nWe need to output pseudocode with step lines. Let's produce a structured approach:\n\nStart\n→ Step 1: Initialize empty list `values` // 存儲所有元素\n→ Step 2: Initialize empty map `indices` from int to set of positions // 每個值對應的索引集合\n→ Step 3: Initialize counter `size = 0` // 目前元素數量\n\nThen methods:\n\n// Insert\nStart // 插入方法\n→ Step 1: Append `val` to `values` // 在末尾加入新元素\n→ Step 2: Add `size` to `indices[val]` // 將新索引加入集合\n→ Step 3: If `indices[val]` had size 1 after adding? // 判斷是否首次出現\n    Yes → Step 4: Return true // 未出現過\n    No  → Step 4: Return false // 已存在\n→ Step 5: Increment `size` // 更新總數\n\nBut note we need to decide before or after increment. We'll incorporate size before increment? Actually we push value at index size (current length). So before increment, size = len(values). After push, we update indices. So we can compute result based on whether there was earlier presence: before addition, check if val existed. So we can do: existed = indices[val] non-empty before adding? Or easier: Check before adding; but we need to add anyway. So algorithm:\n\nStep 1: Get current index = size\nStep 2: Append val\nStep 3: If val not in indices: create new set\nStep 4: Add index to indices[val]\nStep 5: If size==index before adding? Actually size is before push; but we can use existed bool before push.\nSimplify: existed = val in indices (and indices[val] not empty). Then after push, return not existed.\n\nWe'll produce steps accordingly.\n\nSimilarly remove:\n\nDecision: If val not in indices or empty? Return false.\nElse: Take an index idx from indices[val] (any). Remove idx from indices[val]. Get lastIndex = size-1. If idx != lastIndex: replace values[idx] with values[lastIndex]; update indices for the moved value: remove lastIndex from its set; add idx to its set. Then pop last element from values. Remove lastIndex from indices[val] maybe already removed. Decrement size. Return true.\n\nWe'll pseudocode with decisions.\n\ngetRandom:\n\nReturn values[randomIndex] where randomIndex between 0 and size-1. Use random function.\n\nWe'll produce line by line.\n\nLet's format as required: each line \"虛擬碼步驟 // 解釋/說明\"\n\nUse arrows for steps. Indent decision branches with indentation and Yes/No lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n\n// ---------- 初始化 RandomizedCollection ----------\n→ Step 1: Create list `values` // 用來存放所有元素\n→ Step 2: Create map `indices` : int → set of int // 每個值對應其在 values 中的索引集合\n→ Step 3: Set integer `size = 0` // 當前元素總數\nEnd // 初始化完成\n\n// ---------- insert(val) ----------\nStart // insert 方法開始\n→ Decision: 是否已經存在 `val`? // 檢查 `indices` 中是否已有 `val`\n    Yes → Step 1: Set `firstInsert = false` // 已存在\n    No  → Step 1: Set `firstInsert = true`  // 首次插入\n→ Step 2: Let `idx = size` // 新元素將放在末尾，索引為目前大小\n→ Step 3: Append `val` to `values` // 將元素加到列表末尾\n→ Step 4: If `indices[val]` does not exist, create an empty set // 為新值建立索引集合\n→ Step 5: Insert `idx` into `indices[val]` // 記錄新索引\n→ Step 6: Increment `size` // 更新總數\n→ Decision: `firstInsert` 為 true? // 判斷是否為首次出現\n    Yes → Step 7: Return true // 新值未曾出現\n    No  → Step 7: Return false // 已存在\nEnd // insert 方法結束\n\n// ---------- remove(val) ----------\nStart // remove 方法開始\n→ Decision: `indices[val]` 為空或不存在? // 檢查是否有此值可移除\n    Yes → Step 1: Return false // 沒有該值\n    No  → \n        → Step 2: Let `removeIdx` be an arbitrary index from `indices[val]` // 隨便取一個索引\n        → Step 3: Remove `removeIdx` from `indices[val]` // 從集合移除該索引\n        → Step 4: Let `lastIdx = size - 1` // 末尾元素索引\n        → Decision: `removeIdx` 等於 `lastIdx`? // 判斷是否為最後一個元素\n            Yes → \n                → Step 5: Remove last element from `values` // 直接 pop\n                → Step 6: Decrement `size` // 更新總數\n            No  → \n                → Step 5: Let `lastVal = values[lastIdx]` // 取最後一個值\n                → Step 6: Set `values[removeIdx] = lastVal` // 用最後一個值覆蓋要移除的位置\n                → Step 7: Remove `lastIdx` from `indices[lastVal]` // 從最後一個值的集合中刪除舊索引\n                → Step 8: Insert `removeIdx` into `indices[lastVal]` // 新索引加入集合\n                → Step 9: Remove last element from `values` // pop last\n                → Step 10: Decrement `size` // 更新總數\n        → Step 11: Return true // 成功移除一個元素\nEnd // remove 方法結束\n\n// ---------- getRandom() ----------\nStart // getRandom 方法開始\n→ Step 1: Let `randIdx = RandomInteger(0, size-1)` // 隨機產生索引\n→ Step 2: Return `values[randIdx]` // 回傳隨機元素\nEnd // getRandom 方法結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdif52vsm.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpdif52vsm.py\", line 42, in main\n    args_list = ast.literal_eval('[' + args_str + ']')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1], [2], [], [3], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (invert sign)\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        # If the largest in small is greater than smallest in large, swap them\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # Balance sizes\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists: operations and arguments\n    split_pos = data.find('], [')\n    if split_pos == -1:\n        raise ValueError(\"Invalid input format\")\n    ops_str = data[:split_pos + 1]          # include the closing bracket\n    args_str = data[split_pos + 3:-1]       # exclude the surrounding brackets\n    operations = ast.literal_eval(ops_str)\n    args_list = ast.literal_eval('[' + args_str + ']')\n    obj = None\n    outputs = []\n    for op, args in zip(operations, args_list):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)\n        elif op == \"addNum\":\n            obj.addNum(args[0])\n            outputs.append(None)\n        elif op == \"findMedian\":\n            outputs.append(obj.findMedian())\n        else:\n            raise ValueError(f\"Unknown operation {op}\")\n    # Convert Python None to JSON null when dumping\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step for implementing MedianFinder class with methods: constructor, addNum, findMedian. Use two heaps approach: max-heap for lower half, min-heap for upper half. Steps: maintain sizes difference <=1, balance. findMedian depends on sizes: if equal, return average of top of both heaps, else return top of larger heap. Provide step-by-step.\n\nWe need to output in Chinese. Use structure: Start, End, Decision, arrows. Provide explanation per line. Ensure each line includes \"虛擬碼步驟 [空格] // 解釋/說明\".\n\nWe don't output real code; just pseudo steps.\n\nLet's craft. We'll show Start, constructor, addNum, findMedian, End.\n\nAlso maybe include helper functions: balanceHeaps. But can inline.\n\nNeed step-by-step for each method.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立 MedianFinder 物件 // 初始化兩個堆疊\n    → Variable: 小堆（max-heap）為 lowerHalf // 存放較小的一半數字\n    → Variable: 大堆（min-heap）為 upperHalf // 存放較大的另一半數字\n    → Decision: 若兩堆皆為空? // 檢查是否為第一次初始化\n        Yes → Step 2: 兩堆皆空 // 初始狀態\n        No  → // 由於此時尚未執行任何操作，直接跳過\n\n→ Step 3: 方法 addNum(num) // 新數字加入資料結構\n    → Decision: 小堆是否空或 num ≤ 小堆頂點? // 判斷新數字屬於哪半段\n        Yes → 小堆入堆 // 加入小堆\n        No  → 大堆入堆 // 加入大堆\n    → Step 4: 調整堆疊平衡 // 保持兩堆大小差 ≤ 1\n        → Decision: 小堆大小 > 大堆大小 + 1? // 小堆過大\n            Yes → 大堆入堆(小堆頂點) // 取小堆最大值移入大堆\n            No  → // 無需調整\n        → Decision: 大堆大小 > 小堆大小 + 1? // 大堆過大\n            Yes → 小堆入堆(大堆頂點) // 取大堆最小值移入小堆\n            No  → // 無需調整\n\n→ Step 5: 方法 findMedian() // 取得目前所有數字的中位數\n    → Decision: 小堆大小 == 大堆大小? // 堆大小相等時\n        Yes → Result = (小堆頂點 + 大堆頂點) / 2.0 // 取兩頂點平均值\n        No  → Decision: 小堆大小 > 大堆大小? // 小堆較多\n            Yes → Result = 小堆頂點 // 取小堆最大值\n            No  → Result = 大堆頂點 // 取大堆最小值\n    → Return Result // 回傳計算出的中位數\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find K-th Smallest Pair Distance",
      "source_file": "Leetcode/leetcode719.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,1], k = 1",
          "expected_output": "0",
          "actual_output_or_error": "File \"/tmp/tmpc10w289e.py\", line 69\n    result = solution.something? Wait; Let's correct.Thinking...\n                                          ^\nSyntaxError: unterminated string literal (detected at line 69)"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1], k = 2",
          "expected_output": "0",
          "actual_output_or_error": "File \"/tmp/tmpwb29xhut.py\", line 69\n    result = solution.something? Wait; Let's correct.Thinking...\n                                          ^\nSyntaxError: unterminated string literal (detected at line 69)"
        },
        {
          "example_index": 2,
          "input": "nums = [1,6,1], k = 3",
          "expected_output": "5",
          "actual_output_or_error": "File \"/tmp/tmpfd16joy6.py\", line 69\n    result = solution.something? Wait; Let's correct.Thinking...\n                                          ^\nSyntaxError: unterminated string literal (detected at line 69)"
        }
      ],
      "generated_code": "import sys\nimport re\nimport bisect\nfrom typing import List\n\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        n = len(nums)\n\n        def count_pairs(mid: int) -> int:\n            count = 0\n            left = 0\n            for right in range(n):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            return count\n\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            if count_pairs(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(data: str):\n    \"\"\"Parse input data to extract nums list and k.\"\"\"\n    # Try to match the format: nums = [...], k = ...\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    k_match = re.search(r'k\\s*=\\s*([-\\d]+)', data)\n\n    if nums_match and k_match:\n        nums_str = nums_match.group(1)\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n        k = int(k_match.group(1))\n        return nums, k\n\n    # Fallback: try to interpret as two separate lines\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        try:\n            nums = eval(lines[0], {\"__builtins__\": None}, {})\n        except Exception:\n            nums = [int(x) for x in lines[0].replace('[', '').replace(']', '').split(',') if x.strip()]\n        k = int(lines[1])\n        return nums, k\n\n    # Final fallback: single line with two parts separated by comma\n    parts = data.split(',')\n    if len(parts) >= 2:\n        try:\n            nums = eval(parts[0], {\"__builtins__\": None}, {})\n        except Exception:\n            nums = [int(x) for x in parts[0].replace('[', '').replace(']', '').split() if x.strip()]\n        k = int(parts[1])\n        return nums, k\n\n    raise ValueError(\"Unable to parse input\")\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit(0)\n    nums, k = parse_input(raw_data)\n    solution = Solution()\n    result = solution.something? Wait; Let's correct.Thinking...\nWe made a mistake: we didn't write result call properly. Let's fix: solution.something? We need to call solution.smallestDistancePair. Also final line print(result). Let's rewrite code block correctly.\n...done thinking.",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm that finds k-th smallest distance among all pairs. Typically solution: sort array, binary search on distance d, count number of pairs with distance <= d, adjust. Steps: sort, binary search low=0, high=max-min, loop while low<high, mid=(low+high)/2, count pairs <= mid using two-pointer sliding window, if count>=k low=mid+1 else high=mid, finally answer low? Actually after loop, low is smallest distance >? We want kth smallest. If count(mid) >= k, then high=mid else low=mid+1. After loop low==high. That distance. Implementation details.\n\nWe need to output virtual code lines with explanations. Use arrows and decisions. We'll produce steps.\n\nLet's outline:\n\nStart\n→ Step: Sort nums ascending\n→ Step: Initialize low=0, high= max(nums)-min(nums)\n→ Decision: While low < high?\n    Yes → Step: mid = (low+high)/2\n    → Step: count = 0\n    → Step: left=0\n    → Decision: For right from 1 to n-1?\n        Yes → Decision: while nums[right]-nums[left] > mid? \n                Yes → left++ (move left pointer)\n                No  → No action\n            End While\n        → Step: count += right-left\n        End For\n    → Decision: if count >= k?\n            Yes → high = mid\n            No  → low = mid + 1\n    → End Decision\n→ End While\n→ Step: return low // kth smallest distance\n\nInclude comments.\n\nLet's produce each line.\n\nWe need structure with arrows and decision. Use indentation.\n\nWe need to produce each line with // explanation.\n\nMake sure to include Start, End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Sort nums in ascending order // 先排序以便後續滑動窗口判斷距離  \n→ Step: low ← 0 // 可能的最小距離  \n→ Step: high ← nums[nums.length-1] - nums[0] // 可能的最大距離  \n→ Decision: low < high? // 是否還有距離區間需要搜尋  \n    Yes → Step: mid ← (low + high) / 2 // 計算中間距離作為查詢  \n    → Step: count ← 0 // 用來統計距離 ≤ mid 的對數  \n    → Step: left ← 0 // 左指標開始於陣列起點  \n    → Decision: for right = 1 to nums.length-1? // 右指標掃描整個陣列  \n        Yes → Decision: while nums[right] - nums[left] > mid? // 若距離過大，左指標右移  \n                Yes → left ← left + 1 // 移動左指標以縮小窗口  \n                No  → // 不需動作，距離已符合條件  \n            End While  \n        → Step: count ← count + (right - left) // 以 current right 為右端，所有合法左端形成對  \n        End For  \n    → Decision: count ≥ k? // 這個距離能否滿足至少 k 個對？  \n        Yes → high ← mid // 可以，縮小上限  \n        No  → low ← mid + 1 // 不行，需增大距離  \n    → End Decision  \n→ End While  \n→ Step: return low // low 即為第 k 小的距離  \nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc2ma36m_.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpc2ma36m_.py\", line 36, in main\n    args = ast.literal_eval(second_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        value = self.cache[key]\n        del self.cache[key]\n        self.cache[key] = value\n        return value\n\n    def put(self, key, value):\n        if key in self.cache:\n            del self.cache[key]\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入分成兩個列表\n    match = re.search(r'\\],\\s*\\[', data)\n    if match:\n        first_part = data[:match.start() + 1]      # 包含第一個 ]\n        second_part = data[match.start() + 1:]     # 從第二個 [\n        commands = ast.literal_eval(first_part)\n        args = ast.literal_eval(second_part)\n    else:\n        # 若輸入已經是包含兩個列表的形式\n        arr = ast.literal_eval(data)\n        commands, args = arr[0], arr[1]\n\n    cache = None\n    outputs = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            outputs.append(None)\n        elif cmd == \"put\":\n            cache.put(arg[0], arg[1])\n            outputs.append(None)\n        elif cmd == \"get\":\n            res = cache.get(arg[0])\n            outputs.append(res)\n\n    # 格式化輸出為 [null, null, ...] 形式\n    out_str = '[' + ', '.join('null' if v is None else str(v) for v in outputs) + ']'\n    print(out_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for LRUCache design, with steps line by line. Use Start, End, Decision, arrows, etc. Each line: \"虛擬碼步驟 // 解釋\". Provide explanation in Chinese. Should not output actual code.\n\nWe need to describe initialization, get, put, internal structures: use doubly linked list + hash map. Provide step-by-step pseudocode: Start, initialize capacity, create hashmap, create head/tail sentinel nodes for list. Then define helper functions: addNode, removeNode, moveToHead, popTail. Then implement get: check map, if not found return -1, else move node to head and return value. Implement put: if key exists, update value, move to head. Else create new node, add to map, add to head. If size>capacity, pop tail, remove from map. End.\n\nWe must produce each step line, with explanation. Use arrow for flow: → Step ... But each line is a step. For decisions, use Decision: ... Yes → ... No → ... Provide indentation maybe but keep same formatting. Use the same format example.\n\nWe need to list steps for initialization, functions, helpers. Provide virtual code with labels: Step 1, Step 2 etc. Use Start at top.\n\nLet's produce a thorough flow. Probably 20-30 lines.\n\nRemember each line: \"虛擬碼步驟 // 解釋\". So after each step, a space then comment. The comment must be brief.\n\nLet's start:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 LRUCache(capacity) // 設定最大容量\n\n→ Step 2: 建立 hashMap<key, node> // 快速存取節點\n\n→ Step 3: 建立雙向鏈表 dummyHead, dummyTail // 兩個哨兵節點\n\n→ Step 4: dummyHead.next = dummyTail; dummyTail.prev = dummyHead // 連結哨兵\n\n→ Step 5: 定義 helper 函式 addNode(node) // 把節點加入到 head\n\n→ Step 6: 在 addNode 中 // 步驟1: node.prev = dummyHead\n\n→ Step 7: addNode 中 // 步驟2: node.next = dummyHead.next\n\n→ Step 8: addNode 中 // 步驟3: dummyHead.next.prev = node\n\n→ Step 9: addNode 中 // 步驟4: dummyHead.next = node\n\n→ Step 10: 定義 helper 函式 removeNode(node) // 移除節點\n\n→ Step 11: removeNode 中 // node.prev.next = node.next\n\n→ Step 12: removeNode 中 // node.next.prev = node.prev\n\n→ Step 13: 定義 helper moveToHead(node) // 移動節點到 head\n\n→ Step 14: moveToHead 中 // 呼叫 removeNode(node)\n\n→ Step 15: moveToHead 中 // 呼叫 addNode(node)\n\n→ Step 16: 定義 helper popTail() // 刪除最舊節點\n\n→ Step 17: popTail 中 // target = dummyTail.prev\n\n→ Step 18: popTail 中 // 呼叫 removeNode(target)\n\n→ Step 19: popTail 中 // 回傳 target\n\n→ Step 20: 定義函式 get(key) // 取得值\n\n→ Step 21: get 中 // if key not in hashMap, return -1\n\n→ Step 22: get 中 // node = hashMap[key]\n\n→ Step 23: get 中 // 呼叫 moveToHead(node)\n\n→ Step 24: get 中 // return node.value\n\n→ Step 25: 定義函式 put(key, value) // 插入/更新\n\n→ Step 26: put 中 // if key in hashMap\n\n→ Step 27: put 中 Yes → node = hashMap[key]; node.value = value\n\n→ Step 28: put 中 Yes → 呼叫 moveToHead(node)\n\n→ Step 29: put 中 No  → node = new Node(key, value)\n\n→ Step 30: put 中 No → hashMap[key] = node\n\n→ Step 31: put 中 No → 呼叫 addNode(node)\n\n→ Step 32: put 中 No → size++ // 追蹤容量\n\n→ Step 33: put 中 // if size > capacity\n\n→ Step 34: put 中 Yes → tail = popTail()\n\n→ Step 35: put 中 Yes → 移除 hashMap[tail.key]\n\n→ Step 36: put 中 Yes → size--\n\n→ End // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". The above has each line. But we need \"虛擬碼步驟\" part: e.g., \"Start\" etc. Provide comment. Good.\n\nWe must be careful that each line has \"虛擬碼步驟\" and comment. We can use labels like \"Step 1:\". The comment should be short but intuitive. Provide Chinese. Use arrow for flow? The format says to use virtual code arrows: \"→\" etc. We can incorporate arrow before steps to denote flow. But each line is separate. Use \"→\" at beginning maybe. Example given: \"→ Step 1: ...\" Good. Use \"→\" for steps. Decision lines: \"Decision: ...\" etc. For decision branches, we need indentation. But not necessary to indent; can just use separate lines with \"Yes →\" and \"No →\". We need to show Yes/No branches.\n\nMake sure to use \"Decision:\" lines with conditions. We need to include \"Decision:\" for get check and put check.\n\nLet's refine.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: LRUCache(capacity) // 設定最大容量\n→ Step 2: hashMap = {} // 建立 key->node 的映射\n→ Step 3: dummyHead, dummyTail = Node(0,0), Node(0,0) // 哨兵節點\n→ Step 4: dummyHead.next = dummyTail; dummyTail.prev = dummyHead // 連結\n→ Step 5: size = 0 // 目前元素數量\n\n→ Step 6: Function addNode(node) // 把 node 放到 head\n→     node.prev = dummyHead\n→     node.next = dummyHead.next\n→     dummyHead.next.prev = node\n→     dummyHead.next = node\n\n→ Step 7: Function removeNode(node) // 從鏈表中移除\n→     node.prev.next = node.next\n→     node.next.prev = node.prev\n\n→ Step 8: Function moveToHead(node) // 移動到 head\n→     removeNode(node)\n→     addNode(node)\n\n→ Step 9: Function popTail() // 移除並回傳最舊節點\n→     tail = dummyTail.prev\n→     removeNode(tail)\n→     return tail\n\n→ Step 10: Function get(key) // 取得 key 的值\n→     Decision: key 在 hashMap 中嗎? // 檢查存在性\n→         Yes → node = hashMap[key]\n→             moveToHead(node)\n→             return node.value\n→         No  → return -1\n\n→ Step 11: Function put(key, value) // 插入或更新\n→     Decision: key 在 hashMap 中嗎? // 檢查是否已存在\n→         Yes → node = hashMap[key]\n→             node.value = value\n→             moveToHead(node)\n→         No  → node = Node(key, value)\n→             hashMap[key] = node\n→             addNode(node)\n→             size += 1\n→             Decision: size > capacity? // 超過容量則淘汰\n→                 Yes → tail = popTail()\n→                     delete hashMap[tail.key]\n→                     size -= 1\n\nEnd // 程式執行結束\n\nBut we must keep each line as separate, no multi-line functions. Each line needs to be one \"虛擬碼步驟\". But multi-step function definitions need separate lines. However we might combine into multi-step definitions. Example: \"Function addNode(node) // ...\" Then subsequent lines starting with \"→\" etc. The example had \"Decision:\" inside indentation.\n\nWe should produce lines like:\n\n→ Step 6: Function addNode(node) // 把 node 放到 head\n→     node.prev = dummyHead\n→     node.next = dummyHead.next\n→     dummyHead.next.prev = node\n→     dummyHead.next = node\n\nBut each line must be separate. However the line with \"node.prev = dummyHead\" has indentation. The comment should follow the code line. Good.\n\nSimilarly for other functions.\n\nWe also need to ensure each line is consistent: \"→\" at start? The example uses \"→\" before step, and within decision branches \"Yes →\". So for each line we should use \"→\". The initial \"Start\" didn't have arrow, just \"Start\". But we can keep as \"Start\". Example: \"Start // 程式開始執行\".\n\nThus each step line should start with \"→\". For function lines, we might need to indent with \"→\" then spaces, but okay.\n\nMake sure to use \"Decision:\" for branches. We must include \"Yes →\" and \"No →\" lines.\n\nWe should keep the comment after space.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: LRUCache(capacity) // 初始化 LRUCache 並設定容量  \n→ Step 2: hashMap = {} // 建立 key → node 的映射表  \n→ Step 3: dummyHead, dummyTail = Node(0,0), Node(0,0) // 建立雙向鏈表的哨兵節點  \n→ Step 4: dummyHead.next = dummyTail; dummyTail.prev = dummyHead // 連接哨兵  \n→ Step 5: size = 0 // 記錄目前元素數量  \n\n→ Step 6: Function addNode(node) // 將節點插入到頭部  \n→     node.prev = dummyHead  \n→     node.next = dummyHead.next  \n→     dummyHead.next.prev = node  \n→     dummyHead.next = node  \n\n→ Step 7: Function removeNode(node) // 從鏈表中移除節點  \n→     node.prev.next = node.next  \n→     node.next.prev = node.prev  \n\n→ Step 8: Function moveToHead(node) // 把節點移到最近使用位置  \n→     removeNode(node)  \n→     addNode(node)  \n\n→ Step 9: Function popTail() // 刪除最舊節點並回傳  \n→     tail = dummyTail.prev  \n→     removeNode(tail)  \n→     return tail  \n\n→ Step 10: Function get(key) // 取得 key 的值  \n→     Decision: key 在 hashMap 中嗎?  \n→         Yes → node = hashMap[key]  \n→             moveToHead(node)  \n→             return node.value  \n→         No  → return -1  \n\n→ Step 11: Function put(key, value) // 插入或更新鍵值對  \n→     Decision: key 在 hashMap 中嗎?  \n→         Yes → node = hashMap[key]  \n→             node.value = value  \n→             moveToHead(node)  \n→         No  → node = Node(key, value)  \n→             hashMap[key] = node  \n→             addNode(node)  \n→             size += 1  \n→             Decision: size > capacity?  \n→                 Yes → tail = popTail()  \n→                     delete hashMap[tail.key]  \n→                     size -= 1  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "File \"/tmp/tmp4wtton10.py\", line 63\n    inside = line[line.find('(')+1:line.find(')'))\n                                                 ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        # 儲存的區間是非重疊、按左端排序的列表\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:                      # 完全在左側\n                new_ranges.append([l, r])\n            elif right < l:                   # 完全在右側\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:                             # 有重疊\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:                         # 新區間在最右側\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        # 找到最後一個左端 <= left 的區間\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        l, r = self.ranges[i-1]\n        return l <= left and right <= r\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:       # 與 [left, right) 完全不相交\n                new_ranges.append([l, r])\n            else:\n                if l < left:                  # 左邊剩餘部分\n                    new_ranges.append([l, left])\n                if r > right:                 # 右邊剩餘部分\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\nif __name__ == \"__main__\":\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    outputs = []\n    rm = None\n\n    for line in lines:\n        line = line.rstrip(';')          # 移除結尾的分號\n        if line.startswith(\"RangeModule\"):\n            rm = RangeModule()\n            outputs.append(\"null\")\n        elif line.startswith(\"rangeModule.addRange\"):\n            inside = line[line.find('(')+1:line.find(')')]\n            left, right = map(int, inside.split(','))\n            rm.addRange(left, right)\n            outputs.append(\"null\")\n        elif line.startswith(\"rangeModule.removeRange\"):\n            inside = line[line.find('(')+1:line.find(')'))\n            left, right = map(int, inside.split(','))\n            rm.removeRange(left, right)\n            outputs.append(\"null\")\n        elif line.startswith(\"rangeModule.queryRange\"):\n            inside = line[line.find('(')+1:line.find(')')]\n            left, right = map(int, inside.split(','))\n            res = rm.queryRange(left, right)\n            outputs.append(\"true\" if res else \"false\")\n        else:\n            # 若有不符合預期格式的行，可忽略或報錯\n            continue\n\n    print(\"[\" + \", \".join(outputs) + \"]\")",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. It's a design for RangeModule with operations addRange, queryRange, removeRange. Likely use interval set, maybe tree or sorted list. Provide algorithm in pseudocode: maintain list of non-overlapping intervals sorted. add: merge with overlapping. query: check coverage. remove: cut intervals. We'll produce step-by-step for each method? The task: generate virtual code for the design. Probably provide class structure with methods. We'll write pseudo-code lines: Start, initialize, addRange, queryRange, removeRange, End. Each line with explanation. Need arrow structure. We'll use Decision, etc. We'll show loops for iterating intervals. Use indices. Provide high-level logic.\n\nLet's output something like:\n\nStart\n→ Initialize empty interval list // store non-overlapping intervals sorted\n→ Method: addRange(left,right) //...\n→ Decision: find first interval with end >= left? etc.\n\nWe must produce line by line, each with comment. We'll include indentation maybe but still same line format.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Set intervals ← empty list // 用於儲存已追蹤的非重疊半開區間，按左端排序  \n→ Method: addRange(left, right) // 新增區間  \n    → Find idx ← 最小索引，使 intervals[idx].right >= left // 找到可能重疊的第一個區間  \n    → Decision: idx 是否存在?  \n        Yes → While idx < intervals.length AND intervals[idx].left <= right  \n            → Update left ← min(left, intervals[idx].left) // 合併左端  \n            → Update right ← max(right, intervals[idx].right) // 合併右端  \n            → Remove intervals[idx] // 刪除已合併的區間  \n            → idx ← idx // 因為已刪除，索引保持不變  \n        No → // 無重疊區間，直接跳過  \n    → Insert [left, right] at idx // 插入新的合併後區間，保持排序  \n→ Method: queryRange(left, right) // 查詢區間是否完全被追蹤  \n    → Find idx ← 最小索引，使 intervals[idx].left <= left < intervals[idx].right OR idx+1 ... // 找到左端落在或左於區間的區間  \n    → Decision: idx 是否存在?  \n        No → Return false // 沒有區間包含左端  \n        Yes → Decision: intervals[idx].right >= right?  \n            Yes → Return true // 整個查詢區間被單個區間覆蓋  \n            No → // 需要檢查連續區間  \n            → Set curEnd ← intervals[idx].right  \n            → idx ← idx + 1  \n            → While curEnd < right AND idx < intervals.length AND intervals[idx].left <= curEnd  \n                → curEnd ← intervals[idx].right  \n                → idx ← idx + 1  \n            → Decision: curEnd >= right?  \n                Yes → Return true // 連續區間覆蓋整個查詢範圍  \n                No → Return false // 尚未覆蓋完整  \n→ Method: removeRange(left, right) // 移除區間  \n    → Find idx ← 最小索引，使 intervals[idx].right > left // 找到可能受影響的第一個區間  \n    → Decision: idx 是否存在?  \n        No → Return // 沒有區間受影響  \n        Yes → While idx < intervals.length AND intervals[idx].left < right  \n            → Decision: intervals[idx].left < left AND intervals[idx].right > right?  \n                Yes → // 檢查區間被完全覆蓋，需拆成兩個  \n                    → Set newRight ← left  \n                    → Set newLeft ← right  \n                    → intervals[idx].right ← newRight // 左半段保留  \n                    → Insert [newLeft, intervals[idx].right] at idx+1 // 右半段插入  \n                    → idx ← idx + 2 // 跳過新插入區間  \n                No → Decision: intervals[idx].left < left?  \n                    Yes → intervals[idx].right ← left // 刪除右邊覆蓋部分  \n                    No → // intervals[idx].left >= left  \n                    → Decision: intervals[idx].right <= right?  \n                        Yes → Remove intervals[idx] // 整個區間被移除  \n                        No → intervals[idx].left ← right // 只移除左邊覆蓋部分  \n            → idx ← idx + 1  \n→ End // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplyo6q9y5.py\", line 62, in <module>\n    commands = json.loads(data[0])\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 140 (char 139)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value):\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            res = method(*args)\n            results.append(res)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the design of a circular deque. Each line must be in format: \"虛擬碼步驟 // 解釋\". Use arrows. Use structure. No actual code. We'll create steps: Start, initialize array, front, rear pointers, size, capacity. Provide methods insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull. Provide decision logic. Let's craft sequentially.\n\nWe need to output step by step, maybe pseudo-code lines with arrows. Provide explanation after each.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 MyCircularDeque 類別，包含容量 k、陣列 data、前指標 front、後指標 rear、當前長度 size // 建立資料結構\n→ Decision: 初始化時將 front = 0, rear = 0, size = 0 // 初始空 deque\n→ Method: insertFront(value) // 向前端插入\n    → Decision: if size == k? // 判斷是否已滿\n        Yes → Return false // 若滿，插入失敗\n        No  → front = (front - 1 + k) mod k // 往前移動 front\n            → data[front] = value\n            → size += 1\n            → Return true\n→ Method: insertLast(value) // 往後端插入\n    → Decision: if size == k?\n        Yes → Return false\n        No  → data[rear] = value\n            → rear = (rear + 1) mod k // 往後移動 rear\n            → size += 1\n            → Return true\n→ Method: deleteFront() // 刪除前端\n    → Decision: if size == 0?\n        Yes → Return false // 空則失敗\n        No  → front = (front + 1) mod k // 前移\n            → size -= 1\n            → Return true\n→ Method: deleteLast() // 刪除後端\n    → Decision: if size == 0?\n        Yes → Return false\n        No  → rear = (rear - 1 + k) mod k // 後移\n            → size -= 1\n            → Return true\n→ Method: getFront() // 取得前端值\n    → Decision: if size == 0?\n        Yes → Return -1\n        No  → Return data[front]\n→ Method: getRear() // 取得後端值\n    → Decision: if size == 0?\n        Yes → Return -1\n        No  → idx = (rear - 1 + k) mod k\n            → Return data[idx]\n→ Method: isEmpty() // 判斷是否空\n    → Return size == 0\n→ Method: isFull() // 判斷是否滿\n    → Return size == k\nEnd // 程式結束\n\nWe need to include arrow arrows \"→\" for steps. Each line must contain the virtual code step and comment after //. We can nest decisions with indentation? The sample shows indentation. We'll produce similar.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MyCircularDeque 類別，包含容量 k、陣列 data、前指標 front、後指標 rear、當前長度 size // 建立資料結構  \n→ Decision: 初始化時將 front = 0, rear = 0, size = 0 // 初始空 deque  \n\n→ Method: insertFront(value) // 向前端插入  \n → Decision: 如果 size == k? // 判斷是否已滿  \n  Yes → Return false // 若滿，插入失敗  \n  No  → front = (front - 1 + k) mod k // 往前移動 front  \n   → data[front] = value  \n   → size += 1  \n   → Return true  \n\n→ Method: insertLast(value) // 往後端插入  \n → Decision: 如果 size == k?  \n  Yes → Return false  \n  No  → data[rear] = value  \n   → rear = (rear + 1) mod k // 往後移動 rear  \n   → size += 1  \n   → Return true  \n\n→ Method: deleteFront() // 刪除前端  \n → Decision: 如果 size == 0?  \n  Yes → Return false // 空則失敗  \n  No  → front = (front + 1) mod k // 前移  \n   → size -= 1  \n   → Return true  \n\n→ Method: deleteLast() // 刪除後端  \n → Decision: 如果 size == 0?  \n  Yes → Return false  \n  No  → rear = (rear - 1 + k) mod k // 後移  \n   → size -= 1  \n   → Return true  \n\n→ Method: getFront() // 取得前端值  \n → Decision: 如果 size == 0?  \n  Yes → Return -1  \n  No  → Return data[front]  \n\n→ Method: getRear() // 取得後端值  \n → Decision: 如果 size == 0?  \n  Yes → Return -1  \n  No  → idx = (rear - 1 + k) mod k  \n   → Return data[idx]  \n\n→ Method: isEmpty() // 判斷是否空  \n → Return size == 0  \n\n→ Method: isFull() // 判斷是否滿  \n → Return size == k  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Size Subarray Sum",
      "source_file": "Leetcode/leetcode209.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpthmzct9e.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpthmzct9e.py\", line 39, in main\n    target, nums = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpthmzct9e.py\", line 32, in parse_input\n    values[key] = eval(val)\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpls0o8t58.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpls0o8t58.py\", line 39, in main\n    target, nums = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpls0o8t58.py\", line 32, in parse_input\n    values[key] = eval(val)\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfew8411b.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpfew8411b.py\", line 39, in main\n    target, nums = parse_input(input_data)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfew8411b.py\", line 32, in parse_input\n    values[key] = eval(val)\n                  ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def minSubArrayLen(self, target: int, nums: list[int]) -> int:\n        left = 0\n        total = 0\n        min_len = float('inf')\n        for right in range(len(nums)):\n            total += nums[right]\n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n        return 0 if min_len == float('inf') else min_len\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'target = 7, nums = [2,3,1,2,4,3]' 或多行形式的輸入。\n    返回 target 整數和 nums 列表。\n    \"\"\"\n    # 將所有換行視為逗號分隔\n    data = data.replace('\\n', ',')\n    parts = [p.strip() for p in data.split(',') if p.strip()]\n    values = {}\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # 使用 eval 解析數值（安全性假設輸入合法）\n        values[key] = eval(val)\n    target = values.get('target')\n    nums = values.get('nums')\n    return target, nums\n\ndef main():\n    input_data = sys.stdin.read()\n    target, nums = parse_input(input_data)\n    solution = Solution()\n    result = solution.minSubArrayLen(target, nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanation. It's sliding window. We produce start, input array, target. Use variables: start, end, sum, minLen = INF. Loop end over array, add nums[end], while sum >= target: update minLen, subtract nums[start], increment start. After loop, if minLen == INF, return 0 else minLen.\n\nWe produce lines accordingly. Ensure each line has arrow → or Start, End. Use Decision. Provide comments in Chinese.\n\nLet's craft lines. We'll include lines for initialization, for loop, addition, decision, update, removal, etc. Ensure we adhere to format: each line: \"虛擬碼步驟 // 解釋\". The arrow may be part of step: \"→ Step 1: ...\".\n\nLet's produce.\n\nAlso mention reading input: Step 1: Initialize variables. Step 2: Start loop over indices. Step 3: Add current number to sum. Step 4: While sum >= target. Inside while: update minLen. Subtract from sum, increment start. After loop end, decide output. Then End.\n\nWe'll use \"Decision:\" for while condition? Actually while is loop; we can write \"Decision: sum >= target?\" with Yes → block. Let's produce accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 start = 0, sum = 0, minLen = 無限大 // 設定滑動窗口指標與最小長度  \n→ Step 2: 迭代 i 從 0 到 nums.length - 1 // 遍歷每個元素  \n    → Step 3: sum = sum + nums[i] // 將當前元素加入窗口總和  \n    → Decision: sum >= target? // 檢查窗口總和是否已達目標  \n        Yes → Step 4: minLen = min(minLen, i - start + 1) // 更新最小長度  \n        Yes → Step 5: sum = sum - nums[start] // 從窗口左端移除元素  \n        Yes → Step 6: start = start + 1 // 左指標右移  \n        Yes → Decision: sum >= target? // 重新檢查，若仍滿足則重複步驟 4-6  \n            Yes → ...  \n            No  → 回到 Step 2 的迴圈  \n        No  → 回到 Step 2 的迴圈  \n→ Decision: minLen == 無限大? // 判斷是否找到符合條件的子陣列  \n    Yes → Step 7: return 0 // 未找到任何子陣列，回傳 0  \n    No  → Step 8: return minLen // 返回最小子陣列長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptd3_iof7.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmptd3_iof7.py\", line 42, in main\n    commands, args_list = json.loads(data)\n                          ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，預期格式為兩個 JSON 陣列\n    commands, args_list = json.loads(data)\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        else:\n            method = getattr(obj, cmd)\n            # args 可能為空列表\n            res = method(*args) if args else method()\n            results.append(res)\n    # 將結果轉為 LeetCode 風格輸出\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append(\"null\")\n        elif isinstance(r, bool):\n            out_parts.append(\"true\" if r else \"false\")\n        else:\n            out_parts.append(str(r))\n    print(\"[\" + \",\".join(out_parts) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. We need to design WordDictionary using trie perhaps. Provide steps: start, initialize root node with children dict and isEnd flag. addWord: iterate characters, create child nodes. search: recursively match dot. Use decision nodes. Let's produce steps.\n\nThe virtual code format: Start // 程式開始執行\n→ Step 1: 定義 TrieNode // 定義 trie 節點\n→ Step 2: 初始化 WordDictionary // 建構函式\n→ Step 3: addWord 方法\n→ Step 4: search 方法\nBut need decision flows for search. Provide recursion.\n\nWe need to maintain virtual code lines with arrow and explanation. Use Yes → No → for decisions.\n\nLet's produce step-by-step.\n\nWe might produce the following lines:\n\nStart // 程式開始執行\n→ Step 1: 創建 TrieNode 類別 // 定義節點結構\n    // 包含 children（map）和 isEnd（布林）\n→ Step 2: WordDictionary 初始化 // 建立根節點\n    → Step 2.1: root = new TrieNode() // 根節點\n→ Step 3: addWord(word) // 添加新單詞\n    → Decision: word 為空? // 檢查空字串\n        Yes → End // 空字串不處理\n        No  → Step 3.1: current = root // 從根節點開始\n    → Step 3.2: 對每個字符 c in word\n        → Decision: current.children 是否包含 c? // 檢查子節點\n            Yes → Step 3.3: current = current.children[c] // 進入已有節點\n            No  → Step 3.4: current.children[c] = new TrieNode(); current = current.children[c] // 建立新節點\n    → Step 3.5: current.isEnd = true // 標記單詞結尾\n→ Step 4: search(word) // 搜尋\n    → Decision: word 為空? // 檢查空字串\n        Yes → Step 4.1: return root.isEnd // 根節點是否為單詞\n        No  → Step 4.2: return searchRecursive(root, word, 0) // 進行遞迴搜尋\n    // 搜尋遞迴函式\n    → Step 4.3: 定義 searchRecursive(node, word, index)\n        → Decision: index == len(word)? // 到達字串結尾\n            Yes → Step 4.3.1: return node.isEnd // 是否匹配到單詞\n            No  → Step 4.3.2: currentChar = word[index] // 取得當前字符\n                → Decision: currentChar == '.'? // 點號特殊處理\n                    Yes → Step 4.3.3: 對每個子節點 child in node.children\n                            → Step 4.3.3.1: if searchRecursive(child, word, index+1) return true // 若任意子節點匹配成功則返回\n                    No  → Step 4.3.4: Decision: node.children 是否包含 currentChar? // 是否存在對應子節點\n                        Yes → Step 4.3.4.1: return searchRecursive(node.children[currentChar], word, index+1) // 進一步遞迴\n                        No  → Step 4.3.4.2: return false // 沒有匹配節點\nEnd // 程式執行結束\n\nBut we need to output each line as virtual code step with arrow and explanation. We need to format exactly as specified: Each line: `虛擬碼步驟` + space + `// 解釋/說明`. Use arrow `→` or `Yes →`, `No →`. Also we need to use `Start`, `End`. And maybe use indentation to reflect decision structure? But in the example, they used indentation lines with `Yes →` and `No →`. We'll mimic.\n\nLet's produce final output accordingly.\n\nWe need to ensure that we don't output actual code, just virtual steps. We should use comments to explain.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別 // 建立 trie 節點結構  \n  // 屬性：children（字典）、isEnd（布林）  \n→ Step 2: WordDictionary 初始化 // 建構 WordDictionary 物件  \n  → Step 2.1: root = 新 TrieNode() // 創造根節點  \n→ Step 3: addWord(word) // 新增單詞  \n  → Decision: word 為空?  \n   Yes → End // 空字串不處理  \n   No  → Step 3.1: current = root // 從根節點開始  \n    → Step 3.2: 對每個字元 c in word  \n     → Decision: current.children 包含 c?  \n      Yes → Step 3.2.1: current = current.children[c] // 進入已存在子節點  \n      No  → Step 3.2.2: current.children[c] = 新 TrieNode(); current = current.children[c] // 建立新節點  \n     → Step 3.3: current.isEnd = True // 標記單詞結尾  \n→ Step 4: search(word) // 搜尋匹配  \n  → Decision: word 為空?  \n   Yes → Step 4.1: return root.isEnd // 空字串匹配檢查  \n   No  → Step 4.2: return searchRecursive(root, word, 0) // 開始遞迴搜尋  \n  // 定義遞迴搜尋函式  \n  → Step 4.3: searchRecursive(node, word, index)  \n   → Decision: index == len(word)?  \n    Yes → Step 4.3.1: return node.isEnd // 已到末尾，檢查是否為完整單詞  \n    No  → Step 4.3.2: currentChar = word[index] // 取得當前字元  \n     → Decision: currentChar == '.'?  \n      Yes → Step 4.3.3: 對每個子節點 child in node.children  \n       → Step 4.3.3.1: if searchRecursive(child, word, index+1) return True // 任一子節點成功即為匹配  \n      No  → Step 4.3.4: Decision: node.children 包含 currentChar?  \n       Yes → Step 4.3.4.1: return searchRecursive(node.children[currentChar], word, index+1) // 直接往下遞迴  \n       No  → Step 4.3.4.2: return False // 沒有對應子節點，匹配失敗  \nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppz0w1wov.py\", line 51, in <module>\n    result = solution.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppz0w1wov.py\", line 22, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmppz0w1wov.py\", line 19, in parse\n    raise ValueError(f\"Invalid complex number format: {s}\")\nValueError: Invalid complex number format: 1+-1i"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"\n        Multiply two complex numbers given as strings in the form \"real+imaginaryi\".\n        The returned string is also in the same form.\n        \"\"\"\n        def parse(s: str):\n            \"\"\"\n            Parse a string like \"1+-1i\" or \"-3-2i\" into a tuple (real, imag).\n            \"\"\"\n            s = s.strip()\n            # Regular expression to capture real and imaginary parts\n            pattern = re.compile(r'(?P<real>[+-]?\\d+)(?P<imag>[+-]\\d+)i')\n            m = pattern.fullmatch(s)\n            if not m:\n                raise ValueError(f\"Invalid complex number format: {s}\")\n            return int(m.group('real')), int(m.group('imag'))\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a+bi) * (c+di) = (ac - bd) + (ad + bc)i\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n\n        return f\"{real_part}+{imag_part}i\"\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # The input format is: \"num1\", \"num2\"\n    # Split on the first comma to separate the two numbers\n    parts = data.split(',', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Expected two complex numbers separated by a comma.\")\n\n    # Strip surrounding whitespace and quotes from each part\n    def clean(part: str) -> str:\n        return part.strip().strip('\"').strip(\"'\")\n\n    num1 = clean(parts[0])\n    num2 = clean(parts[1])\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The user wants multiplication of complex numbers represented as strings like \"a+bi\". Need parse, multiply, return string. Steps: Start, parse first number, parse second, compute real and imaginary parts of product: (a*c - b*d) + (a*d + b*c)i. Build string. End. We need to provide virtual code with explanation per line. Also use Decision? Not necessary. But maybe decisions for parsing sign? Could include. Keep simple. Provide each line. Use arrows. Format exactly as example: each line \"虛擬碼步驟 // 解釋\". Use \"→\" arrow. Use Start End. Use Step 1 etc. Provide explanation after each. Use decision if needed. Use maybe \"Decision: if num contains '-'? parse accordingly.\" But we can assume format always \"real+imaginaryi\" or \"real-imaginaryi\" maybe. Provide generic parse: split by '+' or '-' before i. Use Decision to determine sign. Let's produce steps.\n\nWe should produce virtual code lines, not actual code. Use arrows and decision statements. Provide simple steps. Let's craft.\n\nStart // 程式開始\n\n→ Step 1: 讀取字符串 num1, num2 // 取得兩個複數輸入\n\n→ Step 2: 解析 num1 為 (real1, imag1) // 從格式中提取實部與虛部\n\n→ Decision: num1 是否包含 '-' 作為分隔符? // 判斷虛部符號\n\n    Yes → Step 3: 取負虛部 imag1 = -abs(imag1) // 虛部為負\n\n    No  → Step 3: 取正虛部 imag1 = abs(imag1) // 虛部為正\n\n同樣對 num2\n\n→ Step 4: 解析 num2 為 (real2, imag2) // 同上\n\n→ Decision: num2 是否包含 '-'? // 判斷虛部符號\n\n    Yes → Step 5: imag2 = -abs(imag2)\n\n    No  → Step 5: imag2 = abs(imag2)\n\n→ Step 6: 計算乘積實部 resultReal = real1*real2 - imag1*imag2 // 複數相乘公式\n\n→ Step 7: 計算乘積虛部 resultImag = real1*imag2 + imag1*real2 // 公式\n\n→ Step 8: 構造輸出字符串 resultStr = resultReal + \"+\" + resultImag + \"i\" // 轉回格式\n\n→ Decision: resultImag 是否小於 0? // 虛部負號處理\n\n    Yes → Step 9: resultStr = resultReal + \"-\" + abs(resultImag) + \"i\" // 加上負號\n\n    No  → Step 9: resultStr = resultReal + \"+\" + resultImag + \"i\" // 正號\n\n→ Step 10: 返回 resultStr // 結果輸出\n\nEnd // 程式執行結束\n\nBut we might compress decision for parsing: use find. It's okay. Ensure each line follows format: \"虛擬碼步驟 // 解釋\". Must include Start, End. Use arrows. The arrow lines start with \"→\". We need to include arrow in virtual code step. Also decision lines: \"Decision: ...\" but we used Step numbers. Should we use \"Decision:\" lines? The example shows Decision: block. For clarity maybe include:\n\nDecision: num1 中 '+' 還是 '-'? // ?\n\nBut we can show as:\n\nDecision: num1 是否包含 '-' 作為分隔符? // 判斷虛部符號\n\n    Yes → Step ... etc.\n\nWe need to ensure the format exactly: each line \"虛擬碼步驟 [space] // 解釋\". So we must not use indent? Indentation may be allowed but keep simple. Use spaces before arrow? In example they had \"→ Step 1:\" etc. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取字符串 num1, num2 // 取得兩個複數輸入  \n→ Step 2: 解析 num1 為 (real1, imag1) // 從格式中提取實部與虛部  \nDecision: num1 是否包含 '-' 作為分隔符? // 判斷虛部符號  \n Yes → Step 3: imag1 = -abs(imag1) // 虛部為負  \n No  → Step 3: imag1 = abs(imag1) // 虛部為正  \n→ Step 4: 解析 num2 為 (real2, imag2) // 同樣提取實部與虛部  \nDecision: num2 是否包含 '-' 作為分隔符? // 判斷虛部符號  \n Yes → Step 5: imag2 = -abs(imag2) // 虛部為負  \n No  → Step 5: imag2 = abs(imag2) // 虛部為正  \n→ Step 6: 計算乘積實部 resultReal = real1*real2 - imag1*imag2 // 複數相乘公式  \n→ Step 7: 計算乘積虛部 resultImag = real1*imag2 + imag1*real2 // 公式  \n→ Step 8: 構造輸出字符串 resultStr = resultReal + \"+\" + resultImag + \"i\" // 轉回格式  \nDecision: resultImag 是否小於 0? // 虛部負號處理  \n Yes → Step 9: resultStr = resultReal + \"-\" + abs(resultImag) + \"i\" // 加上負號  \n No  → Step 9: resultStr = resultReal + \"+\" + resultImag + \"i\" // 正號  \n→ Step 10: 返回 resultStr // 結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"找出所有重複檔案的完整路徑。\"\"\"\n        content_map = defaultdict(list)\n\n        for path_str in paths:\n            # 先分割成目錄跟檔案資訊\n            parts = path_str.split()\n            if not parts:\n                continue\n            root = parts[0]                       # 目錄路徑\n            for file_info in parts[1:]:\n                # 例： \"1.txt(abcd)\" => name=\"1.txt\", content=\"abcd\"\n                if '(' not in file_info or not file_info.endswith(')'):\n                    continue  # 跳過格式錯誤的項目\n                name, content = file_info.split('(', 1)\n                content = content[:-1]  # 去掉最後的 ')'\n                full_path = f\"{root}/{name}\"\n                content_map[content].append(full_path)\n\n        # 只保留重複的內容\n        return [paths for paths in content_map.values() if len(paths) > 1]\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 移除可能的前綴 \"paths =\" 以及多餘空白\n    if raw_input.lower().startswith(\"paths\"):\n        raw_input = raw_input.split('=', 1)[1].strip()\n    try:\n        paths_list = ast.literal_eval(raw_input)\n    except Exception as e:\n        # 如果解析失敗，印空列表並結束\n        print([])\n        return\n\n    sol = Solution()\n    result = sol.findDuplicate(paths_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. We should output line by line, each line with virtual code step and comment. Use arrows. Start, End, Decision. We need to handle parsing of input list of strings, build map content->list of paths, then collect groups with size>=2. Steps: Start, Step 1 parse input array, Step 2 iterate each string, Step 3 split by space to separate directory and file entries, Step 4 for each file entry parse filename and content, Step 5 construct full path, Step 6 map content to list, Step 7 after loop, Step 8 iterate map to collect groups of size>1, Step 9 return result. Use decision for size>1. Use End. Provide comments. Provide arrow.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空字典 `contentMap`，鍵為檔案內容，值為檔案完整路徑列表 // 準備儲存相同內容的檔案  \n→ Step 2: 對輸入陣列 `paths` 逐個迭代 // 逐行處理每個目錄資訊  \n  → Step 3: 用空格切割 `pathStr`，第一段為目錄路徑 `dirPath`，其餘為檔案條目 // 分離目錄與檔案  \n    → Step 4: 對 `pathStr` 的每個檔案條目 `fileEntry` 進行迭代  \n      → Step 5: 使用 `(` 找到檔案名稱與內容的分界點  \n        → Decision: 若 `fileEntry` 包含 '('? // 確認格式合法  \n          Yes → Step 6: 取得 `fileName` 為 `fileEntry` 的子字串從開始到 '(' 前  \n          No → Step 6: 跳過此檔案條目 // 若格式不符，直接跳過  \n        → Step 7: 取得 `fileContent` 為 `fileEntry` 的子字串從 '(' 後到 ')' 前  \n      → Step 8: 組合完整路徑 `fullPath = dirPath + \"/\" + fileName` // 建立完整路徑  \n      → Step 9: 若 `contentMap` 尚無此 `fileContent` 鍵，則新增空清單  \n      → Step 10: 將 `fullPath` 加入 `contentMap[fileContent]` // 分類相同內容的檔案  \n→ Step 11: 初始化結果清單 `duplicates` // 用來儲存重複檔案組  \n→ Step 12: 對 `contentMap` 的每一項 `content, pathList` 進行迭代  \n    → Decision: `pathList` 的長度 > 1? // 需要至少兩個檔案才算重複  \n      Yes → Step 13: 將 `pathList` 加入 `duplicates` // 收集重複組  \n      No → Step 13: 不做任何事 // 單一檔案不加入  \n→ Step 14: 返回 `duplicates` // 完成重複檔案的搜尋  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[7,9]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[7, 9]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[10,7,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[10, 7, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\n# 這裡的 rand7() 是唯一允許的隨機數產生器\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"\n        產生 1~10 的均勻隨機數，僅使用 rand7()\n        \"\"\"\n        while True:\n            # 使用兩次 rand7() 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                # 只保留 1~40 的數字，並映射到 1~10\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 從標準輸入讀取格式為 \"n = X\" 的字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析 n 的值\n    try:\n        _, value = data.split('=')\n        n = int(value.strip())\n    except Exception:\n        # 若解析失敗，直接返回\n        return\n\n    solver = Solution()\n    # 呼叫 rand10() n 次並收集結果\n    results = [solver.rand10() for _ in range(n)]\n    # 將結果輸出為 Python 列表字面量\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, no actual code, using virtual steps with arrow, etc. The problem: need rand10() using rand7(). Classic approach: generate two rand7() calls to get 1-49 range; accept 1-40; map to 1-10 using modulo; if out, repeat. Or use rejection sampling. So we will produce steps: Start, call rand7() twice to get first, second, produce combined number: (first-1)*7 + second => 1-49. Then Decision: if number <= 40? Yes → map to 1-10: (number-1)%10 +1; No → repeat. We need to express recursively or loop. Virtual code lines: Start, define function rand10, inside: loop start label, Step: call rand7, assign a, Step: call rand7, assign b, compute num = (a-1)*7 + b, Decision: if num <= 40? Yes → return ((num-1)%10)+1; No → goto loop start. End. Provide explanation each line.\n\nAlso mention that we cannot call other APIs. Provide steps accordingly. Use arrow syntax. We'll provide lines with step numbers maybe but not necessary. We just need \"虛擬碼步驟\" and explanation. Each line start with \"→\". Use \"Start\" and \"End\". For loops we can use \"Decision:\" with Yes/No. Maybe use label \"Loop:\".\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Function rand10() // 定義生成 1~10 的函式\n→ Loop: // 進入重試迴圈\n    → Step 1: a ← rand7() // 產生第一個 1~7 的隨機數\n    → Step 2: b ← rand7() // 產生第二個 1~7 的隨機數\n    → Step 3: num ← (a-1)*7 + b // 組合為 1~49 的數\n    → Decision: 如果 num ≤ 40? // 檢查是否在可接受範圍\n        Yes → Step 4: result ← ((num-1) mod 10) + 1 // 將 1~40 映射為 1~10\n        Yes → Return result // 回傳最終結果\n        No  → Go to Loop // 重新開始迴圈\nEnd // 程式結束\n\nWe should add \"→\" before each step; the Decision block uses indentation. Provide explanation after //.\n\nNeed to ensure no actual code. The \"Go to Loop\" maybe represented as \"→ Loop:\" but we cannot duplicate arrow. Perhaps use \"No → Loop:\" to jump. So Decision block:\n\nDecision: num ≤ 40? \n    Yes → Step 4: result ← ((num-1) mod 10) + 1 // 映射\n    Yes → Return result // 回傳\n    No  → Loop // 重新嘗試\n\nBut we used \"Yes\" twice, not allowed. We can combine: Yes → Step 4: result ← ... // mapping, then Next: Return result. Or use Yes → Return ((num-1) mod 10) + 1.\n\nSimplify: Yes → Return ((num-1) mod 10) + 1\n\nOk.\n\nLet's produce final output with each line in order. Ensure each line has virtual code step and explanation. We'll start with \"Start\". Then function definition line, etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function rand10() // 定義生成 1~10 的函式  \n→ Loop: // 進入重試迴圈  \n    → Step 1: a ← rand7() // 產生第一個 1~7 的隨機數  \n    → Step 2: b ← rand7() // 產生第二個 1~7 的隨機數  \n    → Step 3: num ← (a-1)*7 + b // 組合為 1~49 的數  \n    → Decision: num ≤ 40? // 檢查是否在可接受範圍  \n        Yes → Return ((num-1) mod 10) + 1 // 把 1~40 映射為 1~10 並回傳  \n        No  → Loop // 超出範圍，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjc068l4w.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpjc068l4w.py\", line 47, in main\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjc068l4w.py\", line 36, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp376p0i5r.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmp376p0i5r.py\", line 47, in main\n    price, special, needs = parse_input(data)\n                            ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp376p0i5r.py\", line 36, in parse_input\n    raise ValueError(\"Input format is incorrect.\")\nValueError: Input format is incorrect."
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo = {}\n\n        def dfs(curr_needs: List[int]) -> int:\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n            # cost without using any special offer\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n            # try each special offer\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:  # offer can be used\n                    res = min(res, offer[-1] + dfs(temp))\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(data: str):\n    # Regex pattern to extract the three lists\n    pattern = r'price\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*special\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*needs\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    price_str, special_str, needs_str = match.group(1), match.group(2), match.group(3)\n    price = ast.literal_eval(price_str)\n    special = ast.literal_eval(special_str)\n    needs = ast.literal_eval(needs_str)\n    return price, special, needs\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    price, special, needs = parse_input(data)\n    sol = Solution()\n    result = sol.shoppingOffers(price, special, needs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: find minimal cost to buy exact needs of items with special offers. This is a typical DP with memoization/backtracking search (DFS with memo). Need to handle up to 6 items (LeetCode constraints). We'll produce algorithm: define function dfs(remainingNeeds) -> min cost. Use dictionary memo. Base: if all zeros => 0. Try each special offer that can be applied (offer counts <= remaining). Compute newNeeds = remaining - offer. cost = offerPrice + dfs(newNeeds). Also compute direct cost: sum(need[i]*price[i]). Return min of these.\n\nWe produce pseudocode lines.\n\nWe need \"逐行\" output: each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nOk. Let's craft.\n\nWe start with Start. Define variables. Then define function.\n\nWill use recursion.\n\nPseudo:\n\nStart // 程式開始執行\n→ Define price[], needs[], special[][] // 初始化價格、需求與特價\n→ Define memo as empty map // 用於記錄已計算的需求組合\n→ Define Function dfs(curNeeds) // 以需求組合為參數的遞迴\n    → If curNeeds all 0 → Return 0 // 無需購買任何商品，成本為0\n    → If curNeeds in memo → Return memo[curNeeds] // 若已計算過，直接回傳\n    → baseCost = sum(curNeeds[i] * price[i]) // 直接購買未使用特價的成本\n    → minCost = baseCost\n    → For each offer in special:\n        → canUse = True\n        → For i in 0..n-1:\n            → If offer[i] > curNeeds[i]: canUse = False; break // 特價不能超過需求\n        → If canUse:\n            → newNeeds = curNeeds - offer // 逐項減去特價購買數量\n            → offerCost = offer[n] + dfs(newNeeds) // 特價價格加下次遞迴成本\n            → If offerCost < minCost: minCost = offerCost\n    → memo[curNeeds] = minCost\n    → Return minCost\n→ 最終結果 = dfs(needs) // 從原始需求開始遞迴\n→ End // 程式執行結束\n\nBut each line needs arrow or structure. We need to indicate decisions. Use \"Decision:\" etc.\n\nWe can structure:\n\nStart\n→ Initialize variables\n→ Define memo\n→ Define function dfs\n    → Decision: if all curNeeds zero?\n        Yes → Return 0\n    → Decision: if curNeeds in memo?\n        Yes → Return memo[curNeeds]\n    → baseCost = ...\n    → minCost = baseCost\n    → For each offer:\n        → Decision: can use offer?\n            Yes → compute newNeeds, offerCost, update minCost\n    → memo[curNeeds] = minCost\n    → Return minCost\n→ Result = dfs(needs)\nEnd\n\nNeed to use \"→\" arrow. Use indentation. Use \"Decision:\" lines. Use \"Yes →\", \"No →\".\n\nOk produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define price[], needs[], special[][] // 初始化價格、需求與特價  \n→ Define memo as empty map // 用於記錄已計算的需求組合  \n→ Define Function dfs(curNeeds) // 以需求組合為參數的遞迴  \n    → Decision: curNeeds 全為 0? // 判斷是否已購完所有商品  \n        Yes → Return 0 // 無需再購買，成本為 0  \n    → Decision: curNeeds 在 memo? // 檢查是否已計算過此需求組合  \n        Yes → Return memo[curNeeds] // 直接回傳已存的最小成本  \n    → baseCost = sum( curNeeds[i] * price[i] ) // 直接按原價購買的成本  \n    → minCost = baseCost // 先以直接購買為基礎的最小成本  \n    → For each offer in special: // 遍歷所有特價方案  \n        → Decision: offer 可使用? // 檢查此特價的數量不超過剩餘需求  \n            Yes →  \n                → newNeeds = curNeeds - offer // 將需求減去此特價購買的數量  \n                → offerCost = offer[n] + dfs(newNeeds) // 特價價格加遞迴計算的新需求成本  \n                → Decision: offerCost < minCost? // 判斷是否更新最小成本  \n                    Yes → minCost = offerCost // 更新為更低成本  \n            No → // 若特價不合法，跳過此方案  \n    → memo[curNeeds] = minCost // 記錄此需求組合的最小成本  \n    → Return minCost // 回傳計算得到的最小成本  \n→ result = dfs(needs) // 從原始需求開始遞迴計算  \nEnd // 程式執行結束"
    },
    {
      "title": "Elimination Game",
      "source_file": "Leetcode/leetcode390.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\n\ndef last_remaining(n: int) -> int:\n    \"\"\"Return the last remaining number after repeatedly removing every other element\n    while alternating direction.\"\"\"\n    # Find the largest power of two less than or equal to n\n    power = 1\n    while power << 1 <= n:\n        power <<= 1\n\n    remainder = n - power\n    # If n is exactly a power of two, the last number is n itself.\n    # Otherwise, the last number is twice the remainder.\n    return n if remainder == 0 else 2 * remainder\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract integer n from possible formats like \"n = 9\" or just \"9\"\n    if '=' in data:\n        try:\n            n = int(data.split('=')[1].strip())\n        except ValueError:\n            n = int(data.strip())\n    else:\n        n = int(data)\n\n    print(last_remaining(n))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find last remaining number after repeatedly removing every other element, alternating direction. It's essentially Josephus problem variant. For n, the solution: find highest power of 2 <= n, let L = n - 2^k. If L==0 return n, else return 2*L. That is the last remaining. But the user asked for virtual code steps with explanations. Must produce line by line, using Start, Decision, etc. We should not give actual code, but pseudo steps. Provide steps to compute. We can incorporate calculation of highest power of 2. Use loops or bit operations. Provide virtual code that returns result.\n\nThus output lines:\n\nStart // start program\n→ Step 1: Initialize n from input // get n\n→ Decision: If n <= 0? // check valid\n    Yes → Step 2: Return error // invalid\n    No  → Step 3: Compute highest power of 2 ≤ n // find 2^k\n... but can use bit shifting or loop. Use loop: Set power=1; while power*2 <= n: power*=2.\n\nContinue:\n\n→ Step 4: Compute L = n - power // remainder\n→ Decision: If L == 0? // if n is power of two\n    Yes → Step 5: Result = n // last number is n\n    No  → Step 6: Result = 2 * L // else double remainder\n→ Step 7: Output Result // return final number\nEnd // finish\n\nBut also maybe incorporate explanation of alternate directions algorithm? Provide explanation. Provide virtual code steps accordingly. Should have arrow lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 n // 從使用者取得整數 n  \n→ Decision: n 是否小於等於 0? // 檢查輸入是否合法  \n  Yes → Step 2: 輸出錯誤訊息並結束 // n 必須為正整數  \n  No  → Step 3: 初始化 power = 1 // 設定最小 2 的冪  \n→ Decision: power * 2 小於等於 n? // 判斷是否可再乘 2  \n  Yes → Step 4: power = power * 2 // 將 power 更新為下一個 2 的冪  \n  No  → Step 5: 跳出迴圈 // 已得到最大的 2 的冪  \n→ Step 6: 計算 L = n - power // 計算 n 超過最大 2 的冪的餘數  \n→ Decision: L 等於 0? // 判斷 n 是否正好是 2 的冪  \n  Yes → Step 7: Result = n // 若是 2 的冪，最後剩下的數字就是 n  \n  No  → Step 8: Result = 2 * L // 否則最後剩下的數字是 2 乘餘數  \n→ Step 9: 輸出 Result // 回傳最後剩下的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnt6h7zmm.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpnt6h7zmm.py\", line 35, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]}\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpl6jztcj8.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpl6jztcj8.py\", line 35, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]}\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp1ikd3vw.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpp1ikd3vw.py\", line 35, in main\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]}\n     ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Convert the input string into a dictionary\n    # Wrap it with braces to create a valid dict literal\n    data = eval('{' + raw + '}')\n    equations = data.get('equations', [])\n    values = data.get('values', [])\n    queries = data.get('queries', [])\n\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n    output = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem is typical \"evaluate division\" using graph or union-find. We need to outline steps: build graph mapping variable to neighbors and ratios. For each query, run DFS or use union-find to get ratio. Return -1 if no path. We'll produce pseudo steps. Should be line by line.\n\nLet's produce start. Then Build graph. For each equation add edges both directions. Then process queries: For each query, if both variables present and find path, compute ratio else -1. We'll use DFS function.\n\nWill produce pseudocode structure. Use decisions, loops, recursion. Let's write each line with explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化一個空圖 Graph // 建立變數與相鄰變數及比例的映射  \n→ Decision: 是否有任何等式? // 檢查 equations 是否為空  \n    No → End // 沒有等式直接結束 (所有查詢都回 -1)  \n→ Step 2: 對於每一個等式 (Ai, Bi, value) 做  \n    → Sub-Step: Graph[Ai][Bi] ← value // Ai / Bi = value  \n    → Sub-Step: Graph[Bi][Ai] ← 1 / value // Bi / Ai = 1/value  \n→ Step 3: 建立一個空答案列表 Answers  \n→ Step 4: 對於每一個查詢 (Cj, Dj) 做  \n    → Decision: Cj 與 Dj 是否都在 Graph? // 檢查變數是否已定義  \n        Yes → Step 5: 呼叫 DFS(Cj, Dj, visited=set(), acc=1) // 計算比例  \n            → Decision: DFS 是否回傳 None? // 找不到路徑  \n                Yes → Sub-Step: Append -1.0 到 Answers // 回傳 -1  \n                No  → Sub-Step: Append 回傳值到 Answers // 回傳計算結果  \n        No  → Step 6: Append -1.0 到 Answers // 任何一個變數未定義  \n→ Step 7: 回傳 Answers // 所有查詢結果  \nEnd // 程式執行結束  \n\n// DFS 函式  \n→ Function DFS(current, target, visited, acc): // 目前節點, 目標節點, 已訪問集合, 累積比例  \n    → Decision: current == target? // 是否達到目標  \n        Yes → Return acc // 成功，返回累積比例  \n        No  → visited.add(current) // 標記已訪問  \n    → For each neighbour, ratio in Graph[current]: // 遍歷相鄰節點  \n        → Decision: neighbour not in visited? // 避免循環  \n            Yes → Result ← DFS(neighbour, target, visited, acc * ratio) // 進一步遞迴  \n            → Decision: Result 不是 None? // 找到路徑  \n                Yes → Return Result // 傳回結果  \n                No  → Continue // 继续搜尋其他相鄰  \n    → Return None // 所有相鄰均失敗，回傳 None  \n// 以上即為虛擬碼及逐行解釋的結構化步驟。"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3us2dv4n.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmp3us2dv4n.py\", line 53, in main\n    stack.push(arg[0])\n               ~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented with two queues.\"\"\"\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        # Enqueue to auxiliary queue\n        self.q2.append(x)\n        # Move all elements from main queue to auxiliary\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        # Swap queues: q2 becomes the new main queue\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self) -> int:\n        # Front of q1 is the top of stack\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove leading 'Input' keyword if present\n    if data.lower().startswith('input'):\n        data = data[data.find('['):]\n\n    # Wrap with brackets to parse as a list of two lists\n    try:\n        commands, args_list = ast.literal_eval('[' + data + ']')\n    except Exception:\n        print('[]')\n        return\n\n    # The first command is the class name; ignore it\n    commands = commands[1:]\n    stack = MyStack()\n    output = []\n\n    for cmd, arg in zip(commands, args_list):\n        if cmd == 'push':\n            stack.push(arg[0])\n            output.append('null')\n        elif cmd == 'pop':\n            output.append(str(stack.pop()))\n        elif cmd == 'top':\n            output.append(str(stack.top()))\n        elif cmd == 'empty':\n            output.append('false' if stack.empty() else 'true')\n        else:\n            # Unknown command: append null\n            output.append('null')\n\n    print('[' + ', '.join(output) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The task: Implement LIFO stack using two queues. Provide steps for push, pop, top, empty. Use virtual code lines. Must follow format: \"Start // 程式開始執行\" etc. Provide arrow lines. Use only queue operations.\n\nWe need to design algorithm. Two common ways: (1) Use one queue as main, another as helper during push to keep order. (2) Use one queue as main, maintain size, push new element to helper, move all others, then swap.\n\nSimplest: For push, enqueue x into queue2, then move all elements from queue1 to queue2, swap names. This way, queue1 always has elements in stack order: front is top.\n\nFor pop: dequeue from queue1.\n\nTop: peek front of queue1.\n\nEmpty: check if queue1 is empty.\n\nSo we need to write virtual code for class MyStack with init, push, pop, top, empty.\n\nAlso need to show start and end of program? The sample shows Start/End around algorithm but might just be demonstration of each method.\n\nWe can produce Start for initialization. Then each method is separate block? They want \"逐行\" produce lines. So we produce a sequence of steps that covers all functionalities, but maybe separate methods with comment.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Initialize queue1 and queue2 // 兩個空隊列\n\n→ Method: push(x)\n\n    → Step 1.1: Enqueue x into queue2 // 將新元素放到輔助隊列\n    → Step 1.2: While queue1 not empty:\n        → Move front of queue1 to queue2 // 把舊元素移到輔助隊列\n    → Step 1.3: Swap queue1 and queue2 // 使queue1為新的堆疊\n\n→ Method: pop()\n\n    → Step 2.1: Dequeue from queue1 and store as result // 移除並返回頂部\n    → Step 2.2: Return result\n\n→ Method: top()\n\n    → Step 3.1: Peek front of queue1 // 取得頂部元素不移除\n    → Step 3.2: Return that value\n\n→ Method: empty()\n\n    → Step 4.1: Return whether queue1 is empty\n\nEnd // 程式結束\n\nBut we must follow exact format: each line \"虛擬碼步驟 [空格] // 解釋/說明\". And use arrow \"→\" and structure \"Decision:\" etc.\n\nSo we can do:\n\nStart // 程式開始執行\n→ Step: 初始化 queue1, queue2 // 兩個空隊列\n→ Method: push(x)\n    → Step: enqueue x into queue2 // 新元素放入輔助隊列\n    → Decision: queue1 不是空? // 檢查主隊列是否有元素\n        Yes → Step: 移動 queue1 前端到 queue2 // 把舊元素轉移\n        No  → // 不做任何事\n    → Step: 交換 queue1 與 queue2 // 讓 queue1 為堆疊\n→ Method: pop()\n    → Step: 從 queue1 前端出列並儲存為 result // 移除頂部\n    → Step: 回傳 result\n→ Method: top()\n    → Step: 取得 queue1 前端元素（peek） // 顯示頂部但不移除\n    → Step: 回傳該元素\n→ Method: empty()\n    → Step: 判斷 queue1 是否為空 // 回傳布林值\nEnd // 程式結束\n\nWe need to be careful about indentation? Not necessary but can use spaces. Each line separate.\n\nAlso for decision blocks, we should use \"Decision:\" line then \"Yes →\" or \"No →\". In sample they did indent with 4 spaces before the decision lines. We can mimic.\n\nLet's produce accordingly.\n\nAlso mention that all operations are standard queue ops.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 queue1, queue2 // 建立兩個空隊列  \n\n→ Method: push(x) // 將元素 x 推到堆疊頂部  \n    → Step: enqueue x into queue2 // 把新元素放進輔助隊列  \n    → Decision: queue1 是否為空? // 檢查主隊列是否有舊元素  \n        Yes → Step: 移動 queue1 前端元素至 queue2 // 把舊元素轉移到輔助隊列  \n        No  → // 主隊列已空，無需移動  \n    → Step: 交換 queue1 與 queue2 // 讓 queue1 為新的堆疊，queue2 清空  \n\n→ Method: pop() // 移除並返回堆疊頂部元素  \n    → Step: dequeue from queue1 並存為 result // 移除頂部元素  \n    → Step: return result // 回傳被移除的元素  \n\n→ Method: top() // 取得堆疊頂部元素但不移除  \n    → Step: peek front of queue1 // 查看前端元素  \n    → Step: return that value // 回傳頂部元素  \n\n→ Method: empty() // 判斷堆疊是否為空  \n    → Step: return queue1.isEmpty() // 回傳布林值  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    data = data.strip()\n    if data.startswith(\"accounts\"):\n        data = data.split(\"=\", 1)[1]\n    data = data.strip()\n    accounts = ast.literal_eval(data)\n    solution = Solution()\n    merged_accounts = solution.accountsMerge(accounts)\n    print(merged_accounts)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines, each line with // explanation. We need to use the arrow notation and Decision, etc. We'll produce a pseudocode to merge accounts using union-find or DFS. Steps: build graph mapping email to name and adjacency. Then DFS to group emails. Then sort each group, prepend name. Output list.\n\nWe must use \"Start\" and \"End\". Provide each step with explanation. Use indentation for decisions. Use arrow syntax. Provide lines: \"Start\", \"→ Step 1: Initialize graph and name mapping\", etc. Use arrow for decisions like \"Decision: If email already visited?\" but we might not need many decisions.\n\nWe can do:\n\nStart // program starts\n→ Step 1: Create adjacency map emailToNeighbors and map email to name // map each email to its name and connect emails within same account\n→ Decision: For each account in accounts? // iterate accounts\n    → Step 2: For i from 1 to len(account)-1:\n        → Step 3: Add edge between account[0] and account[i] in adjacency map // connect emails within same account\n        → Step 4: Store name mapping for account[i] // record name\n→ Step 5: Initialize visited set // to keep track of processed emails\n→ Step 6: Initialize result list // to hold merged accounts\n→ Decision: For each email in adjacency map? // iterate all emails\n    → Decision: If email not visited? // if new component\n        → Step 7: Perform DFS starting at email to collect all emails in this component // gather emails\n        → Step 8: Sort collected emails // sort\n        → Step 9: Prepend name retrieved from email-to-name map // add name\n        → Step 10: Append merged account to result // add to output\n→ End // program ends\n\nWe need to use arrows and Decision syntax exactly as required. Each line must have \"虛擬碼步驟\" and then // 解釋/說明.\n\nWe'll output in Traditional Chinese.\n\nLet's construct. Use \"→\" before steps, \"Decision:\" lines. Use indentation maybe 4 spaces? Provide as sample. We'll keep consistent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 emailToNeighbors 與 emailToName 的兩個字典 // 先將每個 email 連接同一帳號的其他 email，並記錄 email 對應的姓名  \n→ Decision: 針對每筆帳號 accounts 做迴圈? // 逐一處理所有帳號  \n  → Step 2: 取帳號中的姓名 name = account[0] // 取得此帳號的姓名  \n  → Decision: 針對帳號中的每個 email 做迴圈? // 連結同帳號內所有 email  \n    → Step 3: 對每個 email e，將 e 加入 emailToNeighbors[name]，並把 e 的鄰居設為帳號中其他 email // 形成圖的邊  \n    → Step 4: 在 emailToName 記錄 email e 對應的姓名 name // 方便後續取得姓名  \n→ Step 5: 建立空集合 visited 用於標記已訪問的 email // 避免重複 DFS  \n→ Step 6: 建立空清單 result 存放合併後的帳號 // 最終輸出結果  \n→ Decision: 對 emailToNeighbors 中的每個 email 做迴圈? // 探索所有 email  \n  → Decision: 若 email 尚未在 visited? // 新的組合  \n    → Step 7: 執行 DFS，收集從此 email 開始能夠到達的所有 email // 找出同一個人的所有 email  \n    → Step 8: 把收集到的 email 集合轉成 list 並排序 // 依字典序排好  \n    → Step 9: 取得其中一個 email 的姓名，並以 [name] + sortedEmails 作為合併帳號 // 加入姓名作為首項  \n    → Step 10: 把合併後的帳號 append 到 result // 將結果加入輸出清單  \n→ End // 程式執行結束"
    },
    {
      "title": "My Calendar I",
      "source_file": "Leetcode/leetcode729.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCalendar\", \"book\", \"book\", \"book\"], [[], [10, 20], [15, 25], [20, 30]]",
          "expected_output": "[null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true]'\nGot (Norm):      '[None,True,False,True]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true]'\nRaw Got:      '[None, True, False, True]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyCalendar:\n    \"\"\"簡易的日曆，防止時間重疊。\"\"\"\n\n    def __init__(self):\n        # 存儲已預約的事件，格式為 (start, end)\n        self.bookings = []\n\n    def book(self, start: int, end: int) -> bool:\n        \"\"\"若能成功預約則回傳 True，否則回傳 False。\"\"\"\n        for s, e in self.bookings:\n            # 兩個區間有重疊的條件\n            if max(s, start) < min(e, end):\n                return False\n        self.bookings.append((start, end))\n        return True\n\ndef parse_input(data: str):\n    \"\"\"把輸入的字串轉成 ops 與 params。\"\"\"\n    # 找到第一個 '],'，把前面作為 ops，後面作為 params\n    idx = data.find('],')\n    if idx == -1:\n        raise ValueError(\"Input format error\")\n    ops_str = data[:idx+1]\n    params_str = data[idx+2:].strip()\n    ops = ast.literal_eval(ops_str)\n    params = ast.literal_eval(params_str)\n    return ops, params\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    ops, params = parse_input(raw)\n\n    result = []\n    calendar = None\n    for op, param in zip(ops, params):\n        if op == \"MyCalendar\":\n            calendar = MyCalendar()\n            result.append(None)\n        elif op == \"book\":\n            start, end = param\n            res = calendar.book(start, end)\n            result.append(res)\n        else:\n            # 其他操作未實作，略過\n            result.append(None)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this task. We need to explain step by step. Use Start, End, Decision: etc. No actual code. Virtual code lines. We need to represent algorithm: maintain a list of intervals, when book called, check for conflicts. Use binary search or sorted list. We can just present logic: on book, for each existing event, if overlap, return false else add and return true. But better to keep sorted list and find insertion position, then check neighbors for overlap. Virtual code: maintain sorted list of pairs.\n\nThus steps:\n\nStart // init MyCalendar\n→ Step: initialize empty event list // list of intervals\n\nWhen book(start, end):\n\n→ Step: create new interval [start, end)\n→ Decision: find index to insert sorted by start // binary search\n    Yes -> index determined\n→ Decision: check previous event if exists and end > prev.start? // actually need check prev.end > start\n    Yes → Step: return false // overlap\n→ Decision: check next event if exists and end > next.start? // Actually check end > next.start\n    Yes → Step: return false\n→ Step: insert event at index // insert into list\n→ Step: return true\n\nEnd // End of book method.\n\nWe also have MyCalendar() constructor.\n\nThus produce lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 MyCalendar 物件 // 建立一個空的事件列表  \n→ Step: events ← 空列表 // 用來儲存已預約的 [start, end) 事件  \n\n---  \nStart Book(start, end) // 呼叫 book 方法  \n→ Step: newInterval ← [start, end) // 先建立欲加入的區間  \n→ Decision: 在 events 中找出可插入的新區間起始位置 idx (按 start 排序) // 以二分搜尋取得索引  \n    Yes → Step: idx ← 計算得到的插入索引 // idx 為插入位置  \n→ Decision: 若 idx > 0 且 events[idx-1].end > start? // 檢查前一個事件是否與新區間重疊  \n    Yes → Step: return false // 有重疊，拒絕預約  \n    No  → Decision: 若 idx < events.size() 且 end > events[idx].start? // 檢查後一個事件是否重疊  \n        Yes → Step: return false // 有重疊，拒絕預約  \n        No  → Step: events.insert(idx, newInterval) // 插入新事件到正確位置  \n→ Step: return true // 預約成功  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,0,0,4,1,4,6]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 0, 0, 4, 1, 4, 6]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        # Number of allowed integers\n        self.size = n - len(blacklist)\n        # Map blacklisted numbers < size to whitelisted numbers >= size\n        self.mapping = {}\n        black_set = set(blacklist)\n        last = n - 1\n        for b in blacklist:\n            if b < self.size:\n                # Find next whitelisted number from the top\n                while last in black_set:\n                    last -= 1\n                self.mapping[b] = last\n                last -= 1\n\n    def pick(self):\n        # Random index in the compact range\n        idx = random.randint(0, self.size - 1)\n        # Return mapped value if it exists, otherwise the index itself\n        return self.mapping.get(idx, idx)\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    # Parse commands and arguments\n    commands = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)  # Constructor returns null\n        else:\n            method = getattr(obj, cmd)\n            results.append(method(*args))\n\n    # Output results in JSON format (None -> null)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the algorithm design. Not actual code. We need to produce virtual pseudocode lines. The algorithm: typical solution is mapping blacklisted numbers above a threshold. Steps: compute M = n - len(blacklist). Build a set of blacklisted numbers. For each blacklisted number less than M, map to a whitelisted number from top. Then pick random integer in [0,M-1], if mapped, return mapping else return original. Provide explanation each line. Let's produce steps:\n\nStart, initialize, etc.\n\nWe need to produce line by line pseudocode.\n\nLet's produce:\n\nStart\n→ Step 1: Compute M = n - |blacklist| // number of allowed numbers\n→ Step 2: Create set B from blacklist // for O(1) lookup\n→ Step 3: Initialize empty map W // for blacklisted numbers below M\n→ Step 4: Set pointer w = n-1 // start from top of range\n→ Decision: If w in B? // find whitelisted numbers from top\n    Yes → Decrement w until w not in B // skip blacklisted\n    No  → Continue\n→ Decision: While there exists b in B with b < M? // map low blacklisted to high whitelisted\n    Yes → W[b] = w // map\n        w = w-1 // move pointer\n        continue loop\n    No  → Exit loop\n→ End Initialization // mapping ready\n→ Step 5: pick() // method\n    → Generate k = random integer in [0, M-1] // uniform\n    → Decision: If k in W? // is mapped\n        Yes → Return W[k] // whitelisted number\n        No  → Return k // allowed number\n\nAdd End.\n\nWe need to include \"End\" for whole algorithm? Use End after pick method.\n\nLet's output.\n\nEnsure each line has virtual code and comment. Use arrow \"→\" preceding each step? The example uses \"→ Step 1:\". We should follow that. Use indentation for nested decision branches. Use \"Decision:\" lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: M = n - |blacklist| // 計算可用數字的總數\n→ Step 2: B = Set(blacklist) // 建立黑名單集合，方便 O(1) 查詢\n→ Step 3: W = EmptyMap() // 用於映射低於 M 的黑名單數字到高位的白名單數字\n→ Step 4: w = n - 1 // 從最大值開始向下尋找可用白名單數字\n→ Decision: w in B? // 若 w 仍是黑名單，需遞減\n    Yes → w = w - 1 // 跳過黑名單數字\n    No  → // w 現在是白名單\n→ Decision: Exists b in B where b < M? // 是否還有低於 M 的黑名單數字需要映射\n    Yes → \n        → W[b] = w // 把低位黑名單映射到高位白名單\n        → w = w - 1 // 更新指標至下一個可能的白名單\n        → // 重複判斷\n    No  → // 所有必要的映射已完成\nEnd // 初始化完成\n\n→ Method: pick() // 取得隨機合法數字\n    → Step 5: k = RandomInt(0, M-1) // 在 [0, M-1] 之間均勻抽取\n    → Decision: k in W? // k 是否被映射（即原本是黑名單）\n        Yes → Return W[k] // 回傳映射後的合法數字\n        No  → Return k // 直接回傳合法數字\nEnd // 程式結束執行"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxlf1jh7z.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpxlf1jh7z.py\", line 43, in main\n    args = ast.literal_eval(lines[1])     # 例如 [[], [\"apple\", 3], [\"ap\"], ...]\n                            ~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.key_map = {}\n\n    def insert(self, key: str, val: int) -> None:\n        # 計算差值，方便更新前綴總和\n        delta = val - self.key_map.get(key, 0)\n        self.key_map[key] = val\n\n        node = self.root\n        node.sum += delta\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix: str) -> int:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main() -> None:\n    # 讀取所有非空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if not lines:\n        return\n\n    ops = ast.literal_eval(lines[0])      # 例如 [\"MapSum\", \"insert\", \"sum\", ...]\n    args = ast.literal_eval(lines[1])     # 例如 [[], [\"apple\", 3], [\"ap\"], ...]\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MapSum\":\n            obj = MapSum()\n            result.append(None)           # null 對應於 None\n        elif op == \"insert\":\n            obj.insert(*arg)\n            result.append(None)\n        elif op == \"sum\":\n            result.append(obj.sum(*arg))\n\n    # 輸出 JSON 格式，None 會自動轉為 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, explaining. We need to design a MapSum class that can insert key-value and sum prefixes. This is a classic Trie with sum values. We need to produce steps, including initialization, insert, sum. Use virtual code syntax with arrows. Provide explanation after each line.\n\nWe need to output lines like \"Start // 程式開始執行\" etc. But we need to produce steps that define the algorithm.\n\nWe might structure as:\n\nStart // initialize MapSum\n→ Step 1: Define Node structure with children map and sum field // Trie node\n→ Step 2: Define MapSum class with root node // Root\n→ Step 3: Define insert method // Insert key\n→ Step 4: In insert, traverse and update sum\n→ Step 5: Define sum method // Sum prefix\n→ Step 6: In sum, traverse and return sum\nEnd\n\nBut we need to output \"逐行\" lines, each with \"虛擬碼步驟\" + \" // 解釋\". Use arrows for steps. Use \"Start\" \"End\" for program. Use \"Decision:\" if needed. The design may not need decisions.\n\nWe must not output actual code. Just pseudo-steps.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode，包含 children: map<char, TrieNode> 和 sum: int // 節點儲存子節點與前綴總和\n→ Step 2: 定義 MapSum 類別，包含 root: TrieNode 和 keyMap: map<string, int> // 以便更新已存在鍵的差值\n→ Step 3: MapSum() 初始化 root 為空節點，keyMap 為空 // 建構子\n→ Step 4: insert(key, val) // 插入或更新鍵值\n→     Decision: key 是否已存在?\n        Yes → oldVal ← keyMap[key] // 取得舊值\n        No  → oldVal ← 0 // 無舊值\n→     delta ← val - oldVal // 需要更新的差值\n→     keyMap[key] ← val // 更新 keyMap\n→     node ← root // 從根節點開始\n→     For each ch in key:\n→         node.sum ← node.sum + delta // 更新前綴總和\n→         If ch 不在 node.children:\n→             node.children[ch] ← new TrieNode() // 建立子節點\n→         node ← node.children[ch] // 移動到子節點\n→     node.sum ← node.sum + delta // 最後節點的總和也更新\n→ Step 5: sum(prefix) // 計算前綴總和\n→     node ← root // 從根節點開始\n→     For each ch in prefix:\n→         If ch 不在 node.children: Return 0 // 無此前綴\n→         node ← node.children[ch] // 移動到子節點\n→     Return node.sum // 前綴總和\nEnd // 程式執行結束\n\nWe need to ensure we include arrows and decisions properly. Use \"Decision:\" lines with indent. Also note that inside loop, we need to show steps. Use \"For each ch in key:\" etc.\n\nWe should keep it simple but show logic. Ensure each line has virtual code + // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode，包含 children: map<char, TrieNode> 與 sum: int // Trie 節點儲存子節點與該節點前綴的總和  \n→ Step 2: 定義 MapSum 類別，包含 root: TrieNode 與 keyMap: map<string, int> // keyMap 方便更新已存在鍵的差值  \n→ Step 3: MapSum() 初始化 root 為新 TrieNode，keyMap 為空 map // 建構子設定初始狀態  \n→ Step 4: insert(key, val) // 插入或更新鍵值  \n→     Decision: key 是否已存在? // 判斷是否為更新操作  \n        Yes → oldVal ← keyMap[key] // 取得舊值  \n        No  → oldVal ← 0 // 無舊值  \n→     delta ← val - oldVal // 計算需要更新的差值  \n→     keyMap[key] ← val // 更新 keyMap 以備未來查詢  \n→     node ← root // 從根節點開始遍歷  \n→     For each ch in key: // 逐字處理鍵  \n→         node.sum ← node.sum + delta // 更新目前節點的前綴總和  \n→         If ch 不在 node.children: // 若子節點不存在  \n→             node.children[ch] ← new TrieNode() // 創建新節點  \n→         node ← node.children[ch] // 轉到子節點  \n→     node.sum ← node.sum + delta // 最後節點也需更新總和  \n→ Step 5: sum(prefix) // 計算前綴總和  \n→     node ← root // 從根節點開始  \n→     For each ch in prefix: // 逐字遍歷前綴  \n→         If ch 不在 node.children: // 若不存在該前綴  \n→             Return 0 // 沒有任何鍵符合  \n→         node ← node.children[ch] // 移動到子節點  \n→     Return node.sum // 回傳前綴對應的總和值  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.8400636824342482,0.017543703110113135],[0.15135165753317772,-0.8987176855177527],[-0.021313481589751757,-0.30744713050589356]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.8400636824342482, 0.017543703110113135], [0.15135165753317772, -0.8987176855177527], [-0.021313481589751757, -0.30744713050589356]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 隨機半徑，sqrt 保證均勻分佈\n        r = self.radius * math.sqrt(random.random())\n        # 轉換為直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    results = []\n    instance = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(instance, method)\n            results.append(func(*args))\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: given radius and center, generate uniform random point inside circle. Use polar coordinates: random angle theta uniform [0,2π), random radius r = sqrt(random_uniform[0,1]) * radius. Then x = x_center + r*cos(theta), y = y_center + r*sin(theta). We'll write steps: initialize radius, x_center, y_center; randPoint: generate uniform u1, u2; theta = 2π*u1; r = sqrt(u2)*radius; x = x_center + r*cos(theta); y = y_center + r*sin(theta); return [x,y].\n\nWe need virtual code lines with explanation. Use arrow \"→\". Start and End. Provide decision if any? Not necessary. We can show random generation. Use Step labels.\n\nWe produce lines. Use \"Start\" then \"→ Step 1: 讀取半徑 radius, x_center, y_center\" but that's inside constructor. We'll produce constructor steps then method. Probably need to show entire class. So structure: Start, Step: 初始化Solution, End? Actually we need method randPoint. So maybe \"Start\" then \"→ Step 1: 存儲半徑 radius, x_center, y_center\" then \"→ Step 2: randPoint() 函數\" then inside generate random. We'll produce separate steps inside randPoint.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\" format.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: Solution(radius, x_center, y_center) // 初始化物件並儲存半徑與圓心座標\n→ Step 2: randPoint() // 定義產生隨機點的函式\n    → Step 2.1: u1 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於角度\n    → Step 2.2: u2 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於半徑\n    → Step 2.3: theta = 2π * u1 // 將 u1 轉換為 0~2π 的角度\n    → Step 2.4: r = sqrt(u2) * radius // 取平方根確保半徑分佈均勻\n    → Step 2.5: x = x_center + r * cos(theta) // 轉換為 Cartesian 坐標\n    → Step 2.6: y = y_center + r * sin(theta) // 轉換為 Cartesian 坐標\n    → Step 2.7: return [x, y] // 返回隨機點座標\nEnd // 程式執行結束\n\nYes. Provide explanation after each line. Ensure each line includes explanation. The lines inside method should be indented? Not required but we can maintain. Use arrow lines. Provide \"→\" for each step. For nested steps maybe indent. Use \"→\" for each line. We can also use \"→\" for each step inside method. Provide explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Solution(radius, x_center, y_center) // 初始化物件並儲存半徑與圓心座標  \n→ Step 2: randPoint() // 定義產生隨機點的函式  \n    → Step 2.1: u1 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於角度  \n    → Step 2.2: u2 = random_uniform_0_1() // 產生 0~1 之間的隨機數，用於半徑  \n    → Step 2.3: theta = 2π * u1 // 將 u1 轉換為 0~2π 的角度  \n    → Step 2.4: r = sqrt(u2) * radius // 取平方根確保半徑分佈均勻  \n    → Step 2.5: x = x_center + r * cos(theta) // 轉換為 Cartesian 坐標  \n    → Step 2.6: y = y_center + r * sin(theta) // 轉換為 Cartesian 坐標  \n    → Step 2.7: return [x, y] // 返回隨機點座標  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的副本\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return self.original\n\n    def shuffle(self):\n        # 使用 Fisher-Yates 洗牌算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入包裝成一個 tuple，方便用 ast.literal_eval 解析\n    try:\n        commands, args = ast.literal_eval(f'({data})')\n    except Exception as e:\n        # 若解析失敗，直接結束\n        sys.exit(1)\n\n    outputs = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == 'Solution':\n            obj = Solution(arg[0])  # arg[0] 是 nums 列表\n            outputs.append(None)\n        elif obj is not None:\n            # 呼叫對應的方法\n            method = getattr(obj, cmd)\n            result = method(*arg)\n            outputs.append(result)\n        else:\n            # 如果沒有實例化就呼叫方法，忽略\n            outputs.append(None)\n\n    # 使用 json.dumps 來格式化輸出，確保 None 轉為 null\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm design: shuffle algorithm. The algorithm likely uses Fisher-Yates shuffle.\n\nWe need to output each step line with explanation. Need to include class methods.\n\nUse Start, End, Decision.\n\nWe need to include initialization, reset, shuffle.\n\nLet's outline:\n\nStart\n→ Step: Store original array copy // store original for reset\n→ Decision: ?\n\nMaybe we need to show structure: In constructor: copy array.\n\nreset method: return original copy.\n\nshuffle method: perform Fisher-Yates: iterate i from last to 1: choose random j between 0 and i inclusive; swap arr[i] with arr[j].\n\nWe need to show algorithm in virtual code.\n\nLet's produce steps:\n\nStart // Program start\n→ Step: Store original array // Save copy for reset\n→ End // End of constructor\n\nBut we need separate for methods.\n\nWe could do:\n\nStart // Program start\n→ Step: Constructor with nums\n    → Decision: None? maybe just assignment.\n→ End // end constructor\nSimilarly for reset and shuffle.\n\nBut to show algorithm, include loops.\n\nLet's produce pseudo-code lines:\n\nStart\n→ Step: Initialize Solution with nums // constructor\n    → Step: original ← copy(nums) // deep copy\n    → Step: current ← copy(nums) // working array\n→ End // constructor end\n→ Step: reset() // method\n    → Return original // restore original array\n→ End // reset method end\n→ Step: shuffle() // method\n    → Step: arr ← copy(current) // copy for shuffling\n    → Step: n ← length(arr)\n    → Step: for i from n-1 downto 1\n        → Decision: generate random j between 0 and i inclusive\n            → Step: swap arr[i] with arr[j]\n    → Return arr\n→ End // shuffle method end\nEnd\n\nBut we need to output each line individually.\n\nLet's produce each line as a step with comment.\n\nWe also need to use arrow \"→\".\n\nUse indent? The example shows indent for decisions.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step: Constructor(Solution) receives nums // 建構子接收原始陣列\nLine 3: → Step: original ← copy(nums) // 先備份原始陣列以便重設\nLine 4: → Step: current ← copy(nums) // 設定工作陣列為原始值\nLine 5: → End // 結束建構子\nLine 6: → Step: reset() // 方法：重設陣列\nLine 7: → Decision: 需返回原始陣列? // 直接返回備份\nLine 8:     Yes → Step: return original // 回傳原始順序\nLine 9:     No  → Step: return current // 若想返回工作陣列\nLine 10: → End // 結束 reset 方法\nLine 11: → Step: shuffle() // 方法：隨機打亂陣列\nLine 12: → Step: arr ← copy(current) // 複製一份工作陣列以進行打亂\nLine 13: → Step: n ← length(arr) // 取得陣列長度\nLine 14: → Step: for i from n-1 downto 1\nLine 15:     → Decision: choose j in [0, i] 隨機整數 // 產生隨機索引\nLine 16:         Yes → Step: swap arr[i] and arr[j] // 交換元素\nLine 17: → End // 迴圈結束\nLine 18: → Step: return arr // 回傳打亂後陣列\nLine 19: → End // 結束 shuffle 方法\nLine 20: End // 程式執行結束\n\nBut we should reflect that shuffle uses Fisher-Yates.\n\nNeed to avoid too many decision lines.\n\nBetter to show simpler.\n\nUse the arrow.\n\nLet's produce.\n\nAlso include indentation for nested steps.\n\nMake sure each line is unique.\n\nWe should maintain clarity.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Constructor(Solution) receives nums // 建構子接收原始陣列  \n→ Step: original ← copy(nums) // 儲存原始陣列備份以供 reset  \n→ Step: current ← copy(nums) // 建立工作陣列，初始值為原始陣列  \n→ End // 結束建構子  \n\n→ Step: reset() // 方法：重設陣列  \n→ Decision: 需要回傳原始陣列? // 直接使用備份  \n Yes → Step: return original // 回傳原始順序  \n No  → Step: return current // 若需回傳工作陣列  \n→ End // 結束 reset 方法  \n\n→ Step: shuffle() // 方法：隨機打亂陣列  \n→ Step: arr ← copy(current) // 複製工作陣列進行打亂，保持 current 不變  \n→ Step: n ← length(arr) // 取得陣列長度  \n→ Step: for i from n-1 downto 1 // Fisher‑Yates 迴圈  \n → Decision: generate random j in [0, i] // 隨機選擇交換索引  \n  Yes → Step: swap arr[i] and arr[j] // 交換元素  \n→ End // 迴圈結束  \n→ Step: return arr // 回傳打亂後的陣列  \n→ End // 結束 shuffle 方法  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 加入目前子集\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                # 包含 nums[i]\n                path.append(nums[i])\n                # 進一步遞迴\n                backtrack(i + 1, path)\n                # 回溯，移除最後加入的元素\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，移除換行、空白\n    data = sys.stdin.read().strip()\n    # 從輸入中提取列表字串\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums = eval(match.group(0))\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for generating all subsets of a set of unique elements. Use virtual code with arrow. Provide step-by-step, with decisions, recursion or iterative. Provide explanation after each line.\n\nLet's design a DFS/backtracking approach. Steps:\n\nStart\n→ Step 1: Input nums // array of unique integers\n→ Step 2: Initialize result as empty list // store subsets\n→ Step 3: Define function backtrack(start, current) // recursive\n    → Step 3a: Append copy of current to result // add subset\n    → Step 3b: For i from start to len(nums)-1\n        → Decision: If i within bounds\n            Yes → Step 3b1: Append nums[i] to current // include element\n            Yes → Step 3b2: backtrack(i+1, current) // recurse\n            Yes → Step 3b3: Remove last from current // backtrack\n→ Step 4: Call backtrack(0, []) // start recursion\n→ Step 5: Return result // output subsets\n\nWe need arrow formatting exactly. Each line: \"虛擬碼步驟 // 解釋\". Use arrows as described.\n\nLet's produce.\n\nAlso, include Start, End.\n\nLet's craft.\n\nUse indentation? The example shows indentation with spaces and new lines for Decision and Yes/No lines. We'll use similar.\n\nWe'll show \"Step 1:\", \"Step 2:\" etc.\n\nWe need to include the Decision step lines. In this design, the Decision for loop boundaries may be omitted or can just use the for loop.\n\nBetter to show Decision: 是否超出界限? But not necessary.\n\nWe'll show:\n\nStart // 程式開始執行\n→ Step 1: nums ← Input() // 取得唯一元素整數陣列\n→ Step 2: result ← [] // 儲存所有子集\n→ Step 3: Define backtrack(start, current) // 遞迴函式\n    → Step 3a: result.append(copy(current)) // 加入目前子集\n    → Step 3b: For i from start to len(nums)-1\n        → Decision: i < len(nums) ?\n            Yes → Step 3b1: current.append(nums[i]) // 加入元素\n            Yes → Step 3b2: backtrack(i+1, current) // 繼續遞迴\n            Yes → Step 3b3: current.pop() // 移除元素回溯\n→ Step 4: backtrack(0, []) // 開始遞迴\n→ Step 5: Return result // 回傳所有子集\nEnd // 程式執行結束\n\nNeed to ensure \"→\" at beginning of each line. Indentation within function maybe spaces, but each line starts with \"→\" for top-level. For nested, we can indent with spaces before \"→\". The example uses spaces before arrows. We'll mimic.\n\nUse \"→\" preceded by 4 spaces for nested lines. Eg \"    →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← Input() // 取得唯一元素整數陣列  \n→ Step 2: result ← [] // 儲存所有子集  \n→ Step 3: Define backtrack(start, current) // 遞迴函式  \n    → Step 3a: result.append(copy(current)) // 加入目前子集  \n    → Step 3b: For i from start to len(nums)-1  \n        → Decision: i < len(nums) ?  \n            Yes → Step 3b1: current.append(nums[i]) // 加入元素  \n            Yes → Step 3b2: backtrack(i+1, current) // 繼續遞迴  \n            Yes → Step 3b3: current.pop() // 移除元素回溯  \n→ Step 4: backtrack(0, []) // 開始遞迴  \n→ Step 5: Return result // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '5,nums=[1,1,2,2,3,\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      \"5, nums = [1, 1, 2, 2, 3, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7,nums=[0,0,1,1,2,3,3,_,_]'\nGot (Norm):      '7,nums=[0,0,1,1,2,3,3,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '7, nums = [0,0,1,1,2,3,3,_,_]'\nRaw Got:      \"7, nums = [0, 0, 1, 1, 2, 3, 3, '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        if not nums:\n            return 0\n        write_index = 2  # 保留前兩個元素\n        for i in range(2, len(nums)):\n            if nums[i] != nums[write_index - 2]:\n                nums[write_index] = nums[i]\n                write_index += 1\n        return write_index\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if data.startswith(\"nums =\"):\n        data = data.split(\"=\", 1)[1].strip()\n    nums = ast.literal_eval(data)\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n    result = nums[:k] + [\"_\"] * (len(nums) - k)\n    print(f\"{k}, nums = {result}\")",
      "virtual_code": "Thinking...\nWe need to generate virtual code (pseudocode) line by line, each line with explanation comment. Need to use Start, End, Decision:, arrow syntax.\n\nUser requirement: remove duplicates from sorted array so each element appears at most twice. Return k and modify array in place. O(1) memory. Classic Leetcode 80: Remove Duplicates from Sorted Array II.\n\nWe need to produce pseudocode: Approach: use two-pointer method. Write pseudo lines with arrow and comments.\n\nWe should start: Start. Then Step: If nums length <= 2: return length. Then init i pointer? Usually use writeIndex starting at 2, and iterate from index 2 to end. For each index j, if nums[j] != nums[writeIndex-2] then nums[writeIndex] = nums[j]; writeIndex++.\n\nAlso explain decisions: check if current element is equal to element two positions behind writeIndex; if not equal, copy.\n\nAlso return writeIndex.\n\nNeed to output lines: each line like \"→ Step: ...\" with comment after //. Use indentation? Example shows indent with spaces. We need to keep consistent.\n\nWe should include Decision: maybe not necessary but could include.\n\nLet's produce step by step:\n\nStart\n→ Step 1: n ← length(nums) // 獲取陣列長度\n→ Decision: 如果 n ≤ 2? // 若長度 ≤ 2，直接返回\n    Yes → Step 2: return n // 陣列長度不超過 2，已符合條件\n    No  → Step 3: writeIndex ← 2 // 初始化寫入指標，保留前兩個位置\n→ Step 4: 從 index 2 開始遍歷整個陣列 // 循環檢查每個元素\n    → Step 5: current ← nums[i] // 取得當前元素\n    → Decision: 如果 current 與 nums[writeIndex-2] 相等? // 判斷是否已出現兩次\n        Yes → Step 6: // 跳過此元素，已達到最大重複數量\n        No  → Step 7: nums[writeIndex] ← current // 複製元素到寫入位置\n            → Step 8: writeIndex ← writeIndex + 1 // 移動寫入指標\n→ Step 9: return writeIndex // 回傳有效元素個數\nEnd\n\nBut we need each line separate. Indentation for Decision branches might be represented by nested lines or indent spaces. The example shows indentation with 4 spaces per indent. We'll follow similar style.\n\nWe need each line with virtual code step plus // explanation. The line content may be \"Decision: ...?\" with arrow indent. Let's produce as lines.\n\nWe must not include actual code. Just virtual steps.\n\nLet's produce final answer in Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: n ≤ 2? // 若長度不超過 2，已符合條件  \n  Yes → Step 2: return n // 直接回傳長度  \n  No  → Step 3: writeIndex ← 2 // 初始化寫入指標，保留前兩個元素位置  \n→ Step 4: 從 i = 2 開始遍歷到 n-1 // 循環檢查每個元素  \n  → Step 5: current ← nums[i] // 取得當前元素  \n  → Decision: current == nums[writeIndex-2]? // 判斷是否已出現兩次  \n    Yes → // 跳過此元素，已達到最大重複數量  \n    No  → Step 6: nums[writeIndex] ← current // 複製元素到寫入位置  \n      → Step 7: writeIndex ← writeIndex + 1 // 移動寫入指標  \n→ Step 8: return writeIndex // 回傳有效元素個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建立前綴和，方便快速查找索引\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機選擇一個索引，機率與權重成正比\"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入（可能包含多行），並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    # LeetCode 的測試格式為：[\"Solution\",\"pickIndex\"], [[[1]],[]]\n    # 把整個輸入包成一個 JSON 陣列，方便解析\n    json_str = '[' + raw_input + ']'\n    ops, args = json.loads(json_str)\n\n    results = []\n    instance = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 形如 [[1]]，取內部列表作為 w\n            instance = Solution(arg[0])\n            results.append(None)  # 建構子不回傳值\n        elif op == \"pickIndex\":\n            results.append(instance.pickIndex())\n        else:\n            # 若有其他方法，直接呼叫\n            results.append(getattr(instance, op)(*arg))\n    # 輸出結果，使用 JSON 形式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for a weighted random selection algorithm, likely using prefix sums and binary search. Provide line-by-line with explanation. Use Start, End, Decision. Include array precomputation. Let's craft.\n\nWe'll have steps:\n\nStart // start\n→ Step 1: 初始化前綴和陣列 prefix // compute cumulative weights\n→ Step 2: 計算總重量 total = prefix.last // total weight\n→ Step 3: 定義函數 pickIndex()\n    → Step 3.1: 產生 random 數 r in [1, total] // inclusive\n    → Step 3.2: 在 prefix 陣列中做二分查找 r\n        → Decision: r <= prefix[mid]? // binary search condition\n            Yes → Step 3.2.1: 將 right = mid-1 // move left\n            No  → Step 3.2.2: 將 left = mid+1 // move right\n    → Step 3.3: 回傳 left // found index\n→ End // 完成\n\nAlso need explanation. We'll format each line with code and comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立前綴和陣列 prefix ← [] // 用於儲存累積權重  \n→ Step 2: 對於每個 weight w[i]  \n  → Step 2.1: prefix.append( (prefix.last ?? 0) + w[i] ) // 加上上一個累積值  \n→ Step 3: 計算總重量 total ← prefix.last! // 最後一個前綴和即為總和  \n→ Step 4: 定義函數 pickIndex()  \n  → Step 4.1: 產生隨機整數 r ← randomInt(1, total) // 1 到 total 之間  \n  → Step 4.2: 初始化 left ← 0, right ← prefix.count - 1 // 二分搜尋範圍  \n  → Step 4.3: Decision: r <= prefix[mid]? // 判斷是否在左半邊  \n    Yes → Step 4.3.1: right ← mid - 1 // 右邊界左移  \n    No  → Step 4.3.2: left ← mid + 1 // 左邊界右移  \n  → Step 4.4: 回傳 left // 找到對應的索引  \nEnd // 程式執行結束"
    }
  ]
}