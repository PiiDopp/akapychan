{
  "run_index": 50,
  "total_files_found": 496,
  "total_files_processed": 428,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 439,
  "generation_and_validation_success_count": 393,
  "generation_or_validation_failure_count": 46,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,2,1,4,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 2, 1, 4, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line. Need to include virtual code arrow arrows. Start, End, Decision. Function roll_dice(n). We need to import random, create list, loop n times, generate random int 1-6, append. Then return list. Provide explanation after each line. Must not output actual code. Just virtual steps. So:\n\nStart // 程式開始執行\n→ Step 1: Import random module // 引入 random\n→ Step 2: Define function roll_dice(n) // 宣告函數\n→ Step 3: 初始化空列表 results // 用於儲存結果\n→ Step 4: 初始化計數器 i = 0 // 用於迴圈\n→ Decision: 是否 i < n? // 判斷是否還有擲骰\n    Yes → Step 5: 產生 rand = random.randint(1,6) // 擲骰\n        → Step 6: 把 rand 加入 results // 收集結果\n        → Step 7: i = i + 1 // 更新計數器\n        → Decision: 是否 i < n? // 重新判斷\n        (loop back)\n    No  → Step 8: 回傳 results // 回傳結果串列\nEnd // 程式執行結束\n\nBut we should format as per arrow. Use \"→\" at each line. For decisions, indent? In example they indent under Decision. So we replicate.\n\nWe need to include Start and End. Provide explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 引入 random 模組  \n→ Step 2: Define function roll_dice(n) // 宣告 roll_dice 函式  \n→ Step 3: Initialize empty list results // 建立儲存結果的空串列  \n→ Step 4: Initialize counter i = 0 // 設定迴圈計數器  \n→ Decision: 是否 i < n? // 判斷是否已擲完 n 次  \n  Yes → Step 5: Generate rand = random.randint(1, 6) // 擲一次六面骰  \n   → Step 6: Append rand to results // 將擲出的點數加入結果串列  \n   → Step 7: Increment i by 1 // 更新計數器  \n   → Decision: 是否 i < n? // 再次判斷是否需要繼續擲骰  \n    (回到 Yes 分支或跳出)  \n  No  → Step 8: Return results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需秒數，並回傳四捨五入到小數點 3 位的時間。\n    \"\"\"\n    start = time.time()          # 記錄開始時間\n    func(*args)                  # 執行目標函式\n    end = time.time()            # 記錄結束時間\n    return round(end - start, 3) # 回傳耗時，保留 3 位小數\n\nif __name__ == \"__main__\":\n    # 讀取 stdin 中的完整程式碼，並使用 exec 執行\n    user_code = sys.stdin.read()\n    # exec 的全域字典需要包含 measure_time 及 time 模組，這樣使用者程式才能正常執行\n    exec(user_code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step, with each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow etc. Should include Start, End, Decision. We need to include measure_time function, using time module, take func and args, record start, call func, record end, compute duration, round to 3 decimal, return result. Also the function returns result. But we measure time and return the function's return? The requirement: \"回傳結果\" maybe means return the measured time. Likely return the duration. Provide code steps accordingly.\n\nWe need to use decision? maybe not necessary. But we can include a Decision to check if args provided? We can just call func(*args). Provide a Step to import time. Step to define function. Step to start timer. Step to call function. Step to end timer. Step to compute duration. Step to round. Step to return duration.\n\nUse arrow lines.\n\nLet's produce:\n\nStart\n→ Step 1: Import time module // 引入時間模組\n→ Step 2: 定義函數 measure_time(func, *args) // 宣告測量函數\n→     Step 3: 取得 start = time.time() // 記錄開始時間\n→     Step 4: 執行 result = func(*args) // 執行傳入函數\n→     Step 5: 取得 end = time.time() // 記錄結束時間\n→     Step 6: 計算 duration = end - start // 計算耗時\n→     Step 7: 四捨五入 duration 到 3 位小數 // 轉為小數點三位\n→     Step 8: 回傳 duration // 返回測量時間\nEnd\n\nWe should include arrow indent style. Use \"→\" each line. Provide explanation. Add maybe decision if args empty? Not needed.\n\nLet's output as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入時間模組  \n→ Step 2: Define function measure_time(func, *args) // 宣告測量函數  \n → Step 3: Record start = time.time() // 記錄開始時間  \n → Step 4: Execute result = func(*args) // 執行傳入函數，並取得返回值  \n → Step 5: Record end = time.time() // 記錄結束時間  \n → Step 6: Compute duration = end - start // 計算耗時  \n → Step 7: Round duration to 3 decimal places // 四捨五入到小數點 3 位  \n → Step 8: Return duration // 回傳測量到的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      '輸入格式錯誤，請輸入兩行，格式為：姓名分數'\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      '輸入格式錯誤，請輸入兩行，格式為：姓名 分數'"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    \"\"\"學生類別，儲存姓名與分數，並可顯示資訊。\"\"\"\n    def __init__(self, name: str, score: int):\n        self.name = name\n        self.score = score\n\n    def show_info(self) -> None:\n        \"\"\"印出「姓名 的分數是 分數」的字串。\"\"\"\n        print(f\"{self.name} 的分數是 {self.score}\")\n\ndef main() -> None:\n    \"\"\"主程式：從標準輸入讀取資料，建立兩個 Student 物件並顯示資訊。\"\"\"\n    # 讀取所有非空白行\n    raw_lines = [line.strip() for line in sys.stdin if line.strip()]\n\n    # 若沒有輸入或第一行是「無」，使用預設資料\n    if not raw_lines or raw_lines[0] == \"無\":\n        s1 = Student(\"Alice\", 90)\n        s2 = Student(\"Bob\", 80)\n    else:\n        # 期望輸入格式：<name1> <score1>\\n<name2> <score2>\n        try:\n            name1, score1 = raw_lines[0].split()\n            name2, score2 = raw_lines[1].split()\n            s1 = Student(name1, int(score1))\n            s2 = Student(name2, int(score2))\n        except (ValueError, IndexError):\n            # 如果輸入格式不符，顯示錯誤訊息並終止\n            print(\"輸入格式錯誤，請輸入兩行，格式為：姓名 分數\")\n            return\n\n    # 呼叫方法印出資訊\n    s1.show_info()\n    s2.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step. The user wants a Student class with attributes name and score. __init__ initializes them. show_info prints \"XXX 的分數是 YYY\". Create two Student objects and call show_info. Need to use virtual code format with arrows and decisions. But no if statements needed except maybe for class definition. Just structure.\n\nWe need to output each line: \"Start // 程式開始執行\" then \"→ Step 1: 定義 Student 類別\" etc. Use virtual code. We'll show class definition with steps inside. Show initialization, method, create objects, call methods, End.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Student 類別 // 建立一個 Student 類別\n    → Step 2: 在 Student 類別中定義 __init__(self, name, score) // 初始化屬性\n        → Step 3: 設定 self.name = name // 存儲姓名\n        → Step 4: 設定 self.score = score // 存儲分數\n    → Step 5: 在 Student 類別中定義 show_info(self) // 定義顯示資訊的方法\n        → Step 6: 輸出 f\"{self.name} 的分數是 {self.score}\" // 印出格式化字串\n→ Step 7: 建立 student1 = Student(\"Alice\", 90) // 創建第一個學生物件\n→ Step 8: 建立 student2 = Student(\"Bob\", 75) // 創建第二個學生物件\n→ Step 9: 呼叫 student1.show_info() // 顯示第一個學生的資訊\n→ Step 10: 呼叫 student2.show_info() // 顯示第二個學生的資訊\nEnd // 程式執行結束\n\nMake sure each line has arrow. For nested steps, use indentation? We can keep indent. Use arrows as shown. Might need to maintain \"→\" before each step.\n\nAlso \"Decision:\" not needed.\n\nReturn only virtual code lines.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Student 類別 // 建立一個 Student 類別  \n    → Step 2: 在 Student 類別中定義 __init__(self, name, score) // 初始化屬性  \n        → Step 3: 設定 self.name = name // 存儲姓名  \n        → Step 4: 設定 self.score = score // 存儲分數  \n    → Step 5: 在 Student 類別中定義 show_info(self) // 定義顯示資訊的方法  \n        → Step 6: 輸出 f\"{self.name} 的分數是 {self.score}\" // 印出格式化字串  \n→ Step 7: 建立 student1 = Student(\"Alice\", 90) // 創建第一個學生物件  \n→ Step 8: 建立 student2 = Student(\"Bob\", 75) // 創建第二個學生物件  \n→ Step 9: 呼叫 student1.show_info() // 顯示第一個學生的資訊  \n→ Step 10: 呼叫 student2.show_info() // 顯示第二個學生的資訊  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"apple\",\"orange\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'apple', 'orange', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取輸入（此問題無須使用，但依規範仍要從 stdin 讀取）\n    _ = sys.stdin.read()\n\n    # 建立集合並進行各項操作\n    fruits = {'apple', 'banana'}          # 初始集合\n    fruits.add('orange')                  # 新增 'orange'\n    fruits.update(['grape', 'melon'])     # 一次新增 'grape' 與 'melon'\n    fruits.remove('banana')               # 移除 'banana'\n    fruits.discard('pineapple')           # 嘗試移除 'pineapple'（不存在時不報錯）\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanations. The user wants to create a set fruits, then add, update, remove, discard, then output. Use Start, End, Decision maybe not needed. Just sequence steps.\n\nFollow format: each line: \"虛擬碼步驟 // 解釋\"\n\nUse arrow notation: \"→ Step X: ...\". Need \"Start\" and \"End\".\n\nOk produce:\n\nStart\n→ Step 1: Set fruits ← {'apple', 'banana'} // 建立集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，不存在時不錯誤\n→ Step 6: Output fruits // 輸出最終集合\nEnd\n\nNeed to ensure format exactly: each line has code and comment. Use // for comment. Provide arrow symbol.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set fruits ← {'apple', 'banana'} // 建立集合 fruits，初始包含 'apple' 與 'banana'  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange' 到集合  \n→ Step 3: fruits.update({'grape', 'melon'}) // 一次性新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 刪除 'banana'（若不存在會拋錯誤）  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，元素不存在時不報錯  \n→ Step 6: Output fruits // 輸出最終集合 fruits  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.78TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.78 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\nAPI_URL = 'https://api.exchangerate-api.com/v4/latest/USD'\n\ndef fetch_rate() -> float | None:\n    \"\"\"取得 USD 對 TWD 的匯率，失敗時回傳 None。\"\"\"\n    try:\n        r = requests.get(API_URL, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef run_gui() -> None:\n    \"\"\"啟動 tkinter GUI，並提供按鈕更新匯率。\"\"\"\n    win = tk.Tk()\n    win.title('美元兌台幣匯率')\n\n    rate_var = tk.StringVar(value='請按下按鈕更新匯率')\n    label = tk.Label(win, textvariable=rate_var, font=('Arial', 14))\n    label.pack(pady=10)\n\n    def update_rate() -> None:\n        rate = fetch_rate()\n        if rate is not None:\n            rate_var.set(f'目前美元匯率：約 {rate} TWD')\n        else:\n            rate_var.set('更新失敗，請檢查網路連線')\n\n    button = tk.Button(win, text='更新匯率', command=update_rate)\n    button.pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 先嘗試從標準輸入讀取資料\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 任意輸入皆視為「按下更新匯率」指令，直接印出匯率\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 沒有輸入則啟動 GUI\n        run_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The user wants to fetch exchange rate via requests, display in tkinter window, update on button click. We must not output actual code, just virtual code. We should use Start, End, Decision, etc. Each line with \"→ Step ...\" and explanation.\n\nWe need to include imports, define main window, label, button, function to fetch rate, update label, button command, run mainloop.\n\nUse virtual code steps:\n\nStart\n→ Step 1: Import required modules (requests, tkinter)\n→ Step 2: Define function fetch_rate // uses requests to get JSON, parse TWD rate\n→ Decision: If request success? // check response status\n    Yes → Step 3: Extract TWD rate from JSON\n    No → Step 4: Set rate = 'Error' // or default\n→ Step 5: Create main window // instantiate Tk\n→ Step 6: Create label to display rate // with initial text\n→ Step 7: Create button '更新匯率' // binds to fetch_rate\n→ Step 8: Place label and button in window\n→ Step 9: Define update function that calls fetch_rate and updates label\n→ Step 10: Bind button command to update function\n→ Step 11: Run mainloop\n\nBut we should integrate fetch_rate and update logic. We might define fetch_and_update function that fetches rate and updates label. Use lambda or command.\n\nAlso ensure we handle thread? Not necessary.\n\nLet's craft. We need \"虛擬碼步驟\" then space then \"// 解釋\".\n\nUse arrow \"→\" for sequence.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Import requests, tkinter // 引入 HTTP 與 GUI 模組\n→ Step 2: Define fetch_rate() // 取得 USD→TWD 匯率\n→     → Step 2.1: Send GET request to API_URL // 呼叫匯率 API\n→     → Decision: If response status 200? // 檢查請求成功\n→         Yes → Step 2.2: Parse JSON, get rate = data['rates']['TWD'] // 取得台幣匯率\n→         No  → Step 2.3: Set rate = None // 失敗時標記為 None\n→     → Step 2.4: Return rate // 回傳匯率值\n→ Step 3: Create root = Tk() // 建立主視窗\n→ Step 4: Set root.title('美元兌台幣匯率') // 視窗標題\n→ Step 5: Create rate_var = StringVar() // 文字變數以更新 label\n→ Step 6: Create label = Label(root, textvariable=rate_var, font=('Arial', 14)) // 匯率顯示框\n→ Step 7: Create button = Button(root, text='更新匯率') // 按鈕\n→ Step 8: Define update_rate() // 取得匯率並更新 label\n→     → Step 8.1: rate = fetch_rate() // 呼叫 API\n→     → Decision: If rate is not None? // 匯率有效\n→         Yes → Step 8.2: rate_var.set(f'USD → TWD: {rate}') // 更新顯示文字\n→         No  → Step 8.3: rate_var.set('錯誤: 無法取得匯率') // 顯示錯誤訊息\n→ Step 9: button.config(command=update_rate) // 把按鈕點擊連結到更新函式\n→ Step 10: layout: place label and button using pack or grid // 佈局\n→ Step 11: Call update_rate() // 初始取得一次匯率\n→ Step 12: root.mainloop() // 開始 GUI 事件迴圈\nEnd // 程式執行結束\n\nBut we need to use \"→\" for steps. For substeps, we could indent but keep arrow. Use \"→\" for each step. For decisions, we use \"Decision:\".\n\nWe must follow the output format: \"虛擬碼步驟\" + space + \"// 解釋\". So each line like \"→ Step 1: Import...\" but we should keep \"虛擬碼步驟\" part maybe includes \"Step 1:\" etc. Provide arrow at start.\n\nAlso for decisions: \"→ Decision: ...\" with indent.\n\nBetter to maintain indentation by spaces.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests, tkinter // 引入 HTTP 與 GUI 模組  \n→ Step 2: Define fetch_rate() // 取得 USD→TWD 匯率  \n→     → Step 2.1: Send GET request to API_URL // 呼叫匯率 API  \n→     → Decision: If response status 200? // 檢查請求成功  \n→         Yes → Step 2.2: Parse JSON, get rate = data['rates']['TWD'] // 取得台幣匯率  \n→         No  → Step 2.3: Set rate = None // 失敗時標記為 None  \n→     → Step 2.4: Return rate // 回傳匯率值  \n→ Step 3: Create root = Tk() // 建立主視窗  \n→ Step 4: Set root.title('美元兌台幣匯率') // 視窗標題  \n→ Step 5: Create rate_var = StringVar() // 文字變數以更新 label  \n→ Step 6: Create label = Label(root, textvariable=rate_var, font=('Arial', 14)) // 匯率顯示框  \n→ Step 7: Create button = Button(root, text='更新匯率') // 按鈕  \n→ Step 8: Define update_rate() // 取得匯率並更新 label  \n→     → Step 8.1: rate = fetch_rate() // 呼叫 API  \n→     → Decision: If rate is not None? // 匯率有效  \n→         Yes → Step 8.2: rate_var.set(f'USD → TWD: {rate}') // 更新顯示文字  \n→         No  → Step 8.3: rate_var.set('錯誤: 無法取得匯率') // 顯示錯誤訊息  \n→ Step 9: button.config(command=update_rate) // 把按鈕點擊連結到更新函式  \n→ Step 10: layout: place label and button using pack or grid // 佈局  \n→ Step 11: Call update_rate() // 初始取得一次匯率  \n→ Step 12: root.mainloop() // 開始 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        # 雜湊表：value -> index 在 values 陣列中的位置\n        self.val_to_index = {}\n        # 動態陣列：儲存所有元素\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"若元素已存在則回傳 False，否則插入並回傳 True。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若元素不存在則回傳 False，否則刪除並回傳 True。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素的索引\n        idx = self.val_to_index[val]\n        # 用最後一個元素覆蓋要刪除的位置\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機回傳一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入解析為兩個列表：ops 與 args\n    # 允許輸入如 [\"RandomizedSet\", \"insert\", ...], [[], [1], ...]\n    try:\n        ops, args = ast.literal_eval(data)\n    except Exception:\n        # 若輸入格式不同，可嘗試使用 json.loads\n        ops, args = json.loads(data)\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)   # None 代表 null\n        else:\n            method = getattr(obj, op)\n            res = method(*arg)\n            results.append(res)\n    # 輸出 JSON 形式，以符合範例\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedSet class implementation. We should use virtual code steps: Start, Decision, etc. Each line with \"虛擬碼步驟 // 解釋\". Should produce line by line. Let's think about typical solution: Use hashmap val->index, and array list of values. Insert: check hashmap, if not present, push to array, store index in map. Remove: check map, if present, swap with last element in array, update map for swapped element, pop last, delete from map. getRandom: pick random index from array. Need average O(1).\n\nWe produce virtual code lines: Start, initialize array and map. For each method, step by step. Use Decision: if present? etc.\n\nWe must ensure using arrow lines. Example: \"→ Step 1: ...\" etc. Use arrows for nested decision. We need to include \"Yes →\" and \"No →\".\n\nLet's produce the code:\n\nStart\n→ Initialize list [] and map {}\n→ Method: insert(val)\n    → Decision: If val in map? // check presence\n        Yes → Return false // already present\n        No  → Append val to list // add new value\n           → Set map[val] = index_of_new_element\n           → Return true\n→ Method: remove(val)\n    → Decision: If val in map? \n        Yes → Get index = map[val]\n           → Get last_val = list[last_index]\n           → Set list[index] = last_val // overwrite\n           → Update map[last_val] = index\n           → Remove last element from list\n           → Delete map[val]\n           → Return true\n        No  → Return false\n→ Method: getRandom()\n    → Generate random_index in [0, list_length-1]\n    → Return list[random_index]\nEnd\n\nWe need to include each line with explanation. Use arrow and spaces accordingly. We need to include indentation for nested lines. We need to show \"→ Decision:\" lines. For nested, indent by 4 spaces maybe.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 初始化空的動態陣列 list 和雜湊表 map // 用來存儲元素與其索引\n→ Step 2: 定義 insert(val) 方法 // 插入元素\n    → Decision: val 是否已存在於 map?\n        Yes → Step 3: 返回 false // 已存在，插入失敗\n        No  → Step 4: 將 val 加入 list\n           → Step 5: 設置 map[val] = list 最後索引\n           → Step 6: 返回 true // 插入成功\n→ Step 7: 定義 remove(val) 方法 // 刪除元素\n    → Decision: val 是否存在於 map?\n        Yes → Step 8: 取得 index = map[val]\n           → Step 9: 取得 last_val = list 最後一個元素\n           → Step 10: 用 last_val 覆蓋 list[index]\n           → Step 11: 更新 map[last_val] = index\n           → Step 12: 從 list 刪除最後一個元素\n           → Step 13: 刪除 map[val]\n           → Step 14: 返回 true // 刪除成功\n        No  → Step 15: 返回 false // 元素不存在\n→ Step 16: 定義 getRandom() 方法 // 隨機取得元素\n    → Step 17: 隨機產生 index 介於 0 與 list 長度-1 之間\n    → Step 18: 返回 list[index] // 隨機元素\nEnd // 程式執行結束\n\nBut need to use \"→\" arrows. Use \"Yes →\" \"No →\" indentation. Let's write exactly:\n\nStart // 程式開始執行\n→ Step 1: 初始化 list 為空陣列 // 用於儲存元素\n→ Step 2: 初始化 map 為空雜湊表 // 用於儲存元素到其索引的映射\n→ Step 3: 定義 insert(val) 方法 // 插入元素\n    → Decision: val 是否已存在於 map?\n        Yes → Step 4: 返回 false // 已存在，插入失敗\n        No  → Step 5: 將 val 加入 list\n           → Step 6: 設置 map[val] = list 最後索引\n           → Step 7: 返回 true // 插入成功\n→ Step 8: 定義 remove(val) 方法 // 刪除元素\n    → Decision: val 是否存在於 map?\n        Yes → Step 9: 取得 index = map[val]\n           → Step 10: 取得 last_val = list 最後一個元素\n           → Step 11: 覆寫 list[index] = last_val\n           → Step 12: 更新 map[last_val] = index\n           → Step 13: 刪除 list 最後一個元素\n           → Step 14: 刪除 map[val]\n           → Step 15: 返回 true // 刪除成功\n        No  → Step 16: 返回 false // 元素不存在\n→ Step 17: 定義 getRandom() 方法 // 隨機取得元素\n    → Step 18: 隨機產生 index ∈ [0, list.length-1]\n    → Step 19: 返回 list[index] // 隨機元素\nEnd // 程式執行結束\n\nBut we must keep the format: Each line: 虛擬碼步驟 + space + // 解釋. So \"Start\" line: \"Start // 程式開始執行\". Then \"→ Step 1: 初始化 list 為空陣列 // 用於儲存元素\". Use arrow at beginning of each step? In example, they use \"→ Step 1:\". So we keep that. For nested, indent by spaces. We'll do exactly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 list 為空陣列 // 用於儲存元素\n→ Step 2: 初始化 map 為空雜湊表 // 用於儲存元素到其索引的映射\n→ Step 3: 定義 insert(val) 方法 // 插入元素\n    → Decision: val 是否已存在於 map?\n        Yes → Step 4: 返回 false // 已存在，插入失敗\n        No  → Step 5: 將 val 加入 list\n           → Step 6: 設置 map[val] = list 最後索引\n           → Step 7: 返回 true // 插入成功\n→ Step 8: 定義 remove(val) 方法 // 刪除元素\n    → Decision: val 是否存在於 map?\n        Yes → Step 9: 取得 index = map[val]\n           → Step 10: 取得 last_val = list 最後一個元素\n           → Step 11: 覆寫 list[index] = last_val\n           → Step 12: 更新 map[last_val] = index\n           → Step 13: 刪除 list 最後一個元素\n           → Step 14: 刪除 map[val]\n           → Step 15: 返回 true // 刪除成功\n        No  → Step 16: 返回 false // 元素不存在\n→ Step 17: 定義 getRandom() 方法 // 隨機取得元素\n    → Step 18: 隨機產生 index ∈ [0, list.length-1]\n    → Step 19: 返回 list[index] // 隨機元素\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Magic Dictionary",
      "source_file": "Leetcode/leetcode676.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"], [[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]",
          "expected_output": "[null, null, false, true, false, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnley67pb.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpnley67pb.py\", line 31, in main\n    ops = json.loads(ops_line)\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass MagicDictionary:\n    def __init__(self):\n        self.words = set()\n\n    def buildDict(self, dictionary):\n        self.words = set(dictionary)\n\n    def search(self, searchWord):\n        for word in self.words:\n            if len(word) != len(searchWord):\n                continue\n            diff = 0\n            for a, b in zip(word, searchWord):\n                if a != b:\n                    diff += 1\n                    if diff > 1:\n                        break\n            if diff == 1:\n                return True\n        return False\n\ndef main():\n    # 讀取兩行輸入：操作名稱列表與對應參數列表\n    ops_line = sys.stdin.readline().strip()\n    args_line = sys.stdin.readline().strip()\n\n    # 解析 JSON 格式的輸入\n    ops = json.loads(ops_line)\n    args = json.loads(args_line)\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MagicDictionary\":\n            obj = MagicDictionary()\n            outputs.append(None)        # 建構器無回傳值\n        elif op == \"buildDict\":\n            obj.buildDict(arg[0])\n            outputs.append(None)        # buildDict 無回傳值\n        elif op == \"search\":\n            res = obj.search(arg[0])\n            outputs.append(res)         # 搜尋回傳布林值\n        else:\n            # 若有未知操作，直接回傳 None\n            outputs.append(None)\n\n    # 用 json.dumps 產生符合 LeetCode 範例格式的輸出\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm that implements MagicDictionary class with buildDict and search. Provide step-by-step pseudo code line by line with explanations. Use arrow syntax. Use Start, End. Provide steps like initializing dictionary, building a map of patterns with wildcard, searching. We need to use decision statements. So each line: virtual code step + \" // explanation\". Use Chinese comments. Provide steps: Start, Step 1: create map, etc. Provide buildDict algorithm: iterate over words, for each word create patterns with * at each position, store in map: pattern -> list of words. Search: iterate over searchWord positions, create pattern, check map for that pattern and ensure that not exactly same word. Return true if found. Provide steps accordingly.\n\nWe must not output actual code, just pseudocode. Use arrow arrow etc.\n\nLet's craft.\n\nStart\n→ Step 1: Initialize an empty map PatternDict // 存放模式到單詞列表\n→ Step 2: Store dictionary list // 供搜索時比對\n→ Step 3: For each word in dictionary // 建立所有可能的一位錯字模式\n    → Step 4: For i from 0 to length(word)-1\n        → Step 5: Create pattern by replacing char at i with '*' // 代表可變位置\n        → Step 6: Append word to PatternDict[pattern] // 將單詞加入該模式\n→ Step 7: End buildDict // 建立完成\n\nSearch:\nStart search\n→ Step 8: For i from 0 to length(searchWord)-1\n    → Step 9: Create pattern by replacing char at i with '*'\n    → Step 10: If pattern exists in PatternDict\n        → Step 11: For each candidate in PatternDict[pattern]\n            → Step 12: If candidate != searchWord\n                → Yes → Step 13: Return true // 找到符合條件的單詞\n→ Step 14: Return false // 沒有任何單詞符合條件\nEnd search\n\nWrap in class methods etc. Use decisions. Provide final End. Provide Start and End for overall. Also use Decision: maybe check pattern existence.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空字典 PatternDict // 用於儲存「*」位置對應的單詞集合\n→ Step 2: 建立空列表 WordList // 用於保存原始字典中的單詞\n→ Step 3: 建構 MagicDictionary() // 物件初始化\n    → End // 建構完成\n→ Step 4: 建構 buildDict(dictionary) // 接收字典陣列\n    → Decision: dictionary 是否為空？ // 檢查輸入\n        Yes → Step 5: 直接返回 // 空字典不需要處理\n        No  → Step 6: 進行字典構建 // 進行後續處理\n    → Step 7: WordList ← dictionary // 保存原始字典\n    → Step 8: For each word in dictionary // 針對每個單詞\n        → Step 9: For i from 0 to length(word)-1 // 逐個位置建立模式\n            → Step 10: pattern ← word[0:i] + '*' + word[i+1:] // 把第 i 個字元換成 '*'\n            → Step 11: 若 PatternDict[pattern] 不存在，則建立空集合\n            → Step 12: PatternDict[pattern].add(word) // 將單詞加入相應模式的集合\n    → End // 字典構建完成\n→ Step 13: 建構 search(searchWord) // 搜尋方法\n    → Decision: searchWord 是否為空？ // 檢查輸入\n        Yes → Step 14: 返回 False // 空字串無法匹配\n        No  → Step 15: 進行搜尋\n    → Step 16: For i from 0 to length(searchWord)-1 // 逐個位置嘗試改字\n        → Step 17: pattern ← searchWord[0:i] + '*' + searchWord[i+1:] // 生成模式\n        → Decision: PatternDict 是否包含 pattern？ // 是否有任何單詞可匹配此模式\n            Yes → Step 18: For each candidate in PatternDict[pattern] // 遍歷可能匹配的單詞\n                → Decision: candidate != searchWord？ // 確保不是完全相同\n                    Yes → Step 19: 返回 True // 找到可改一次字能匹配的單詞\n                    No  → Step 20: 繼續檢查下一個候選\n            No  → Step 21: 繼續下一個位置\n    → Step 22: 返回 False // 所有位置都未能匹配\nEnd // 程式執行結束"
    },
    {
      "title": "Bulb Switcher II",
      "source_file": "Leetcode/leetcode672.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "n = 2, presses = 1",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '4'"
        },
        {
          "example_index": 2,
          "input": "n = 3, presses = 1",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '8'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '8'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef solve(n: int, presses: int) -> int:\n    if presses == 0:\n        return 1  # only the initial state\n\n    # Build the four button masks as integers (bit i corresponds to bulb i+1)\n    full_mask = (1 << n) - 1          # Button 1: all bulbs\n    even_mask = 0\n    odd_mask = 0\n    mod3_mask = 0\n    for i in range(1, n + 1):\n        bit = 1 << (i - 1)\n        if i % 2 == 0:\n            even_mask |= bit\n        else:\n            odd_mask |= bit\n        if (i - 1) % 3 == 0:          # j = 3k + 1  ->  i-1 = 3k\n            mod3_mask |= bit\n\n    masks = [full_mask, even_mask, odd_mask, mod3_mask]\n    parity = presses & 1  # 0 for even, 1 for odd\n\n    result_set = set()\n    # Enumerate all 4-bit parity combinations (0 or 1 for each button)\n    for p in range(16):\n        # Count number of 1 bits in p\n        if bin(p).count('1') & 1 != parity:\n            continue  # parity does not match the required presses parity\n        state = 0\n        for i in range(4):\n            if p >> i & 1:\n                state ^= masks[i]\n        result_set.add(state)\n\n    return len(result_set)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 2:\n        n, presses = nums[0], nums[1]\n    else:\n        # If input is two separate numbers per line\n        lines = data.strip().splitlines()\n        n, presses = map(int, lines[0].split())\n    print(solve(n, presses))",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The task: determine number of distinct possible bulb statuses after exactly presses presses. We need to produce algorithm description: use state space of bulb statuses mod 2. Buttons correspond to toggling subsets. We can consider the 4 operations as vectors in GF(2)^n. The number of distinct states reachable by applying any sequence of exactly presses steps? Since we can choose any button each press, the reachable set after exactly m steps is the set of all sums of m vectors (with repetition allowed). This equals the set {sum_{i=1}^m v_{b_i}}. Since we can repeat, the set equals all sums of m elements from multiset of 4 vectors where order matters? But since addition commutes, order irrelevant; we only care about count of distinct sums. This is like number of distinct results from selecting counts of each button (x1,x2,x3,x4) such that x1+x2+x3+x4=presses. Then resulting state = x1*v1 + x2*v2 + x3*v3 + x4*v4 (mod 2). Equivalent to: choose nonnegative integers x_i summing to presses. Number of distinct resulting vectors. So we need to compute size of {∑ x_i * v_i}. This is linear combinations with coefficients in {0,1} times parity of x_i. Because 2 toggles cancel. So only parity of each x_i matters: x_i mod 2. But sum constraint mod 2: x1+x2+x3+x4 = presses. So parity of total presses = parity of sum of parities. So only 16 combinations of parity (xi%2). For each parity vector p=(p1,p2,p3,p4) with sum parity = presses mod 2, we get state = p1*v1 ⊕ p2*v2 ⊕ p3*v3 ⊕ p4*v4. So number of distinct states ≤ 8? Actually at most 8 combinations. But some might be same.\n\nThus algorithm: compute vectors v1..v4 as length n binary arrays. Then compute unique XOR combinations for all parity tuples with sum parity matches. Count unique. Complexity O(n*8). Provide virtual code.\n\nNow produce step-by-step pseudocode. Use steps: Start, create vectors, generate parity combos, compute XOR, add to set, count. Provide explanation. Ensure each line has comment. Use arrow and Decision. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 vector[4][n] // 用來存放四個按鈕對燈泡的切換模式  \n→ Decision: 確認 n 大於 0?  \n  Yes → Step 2: 對 i 從 1 到 n 逐一設定  \n    → Decision: i 為偶數?  \n      Yes → vector[1][i] = 1 // 按鈕1：所有燈泡  \n       No  → vector[1][i] = 1 // 同樣全部切換  \n       （此處實際上所有元素均設 1，僅示範流程）  \n         \n      Yes → vector[2][i] = 1 if i%2==0 else 0 // 按鈕2：偶數標號燈泡  \n         \n      Yes → vector[3][i] = 1 if i%2==1 else 0 // 按鈕3：奇數標號燈泡  \n         \n      Yes → vector[4][i] = 1 if (i-1)%3==0 else 0 // 按鈕4：1,4,7,…  \n         \n      No → End // 若 n <= 0，直接結束  \n→ Step 3: 計算 presses 的奇偶性 parityPress = presses mod 2 // 只有奇偶會影響結果  \n→ Step 4: 建立空集合 resultSet // 用來記錄不同的燈泡狀態  \n→ Step 5: 產生所有 4 位元組合 (p1,p2,p3,p4) 其中 p_i ∈ {0,1}  \n  → Decision: (p1+p2+p3+p4) mod 2 == parityPress?  \n    Yes → Step 6: state = XOR of vector[i] where p_i==1  \n      → Step 7: 把 state 加入 resultSet  \n    No → 跳過此組合  \n→ Step 8: 計算 resultSet 的大小 uniqueCount = |resultSet| // 代表可達到的不同狀態數  \n→ End // 程式執行結束，uniqueCount 為最終答案\n\n說明：\n- Step 1 建立四個按鈕對應的切換模式，僅需一遍遍歷即可。\n- Step 2 只要確定 n>0 就執行填充，否則不需計算。\n- Step 3 只關心 presses 的奇偶性，因為重複按一次相同按鈕會互相抵消。\n- Step 5 產生 2^4=16 可能的奇偶組合，僅保留總奇偶相符的組合。\n- Step 6 用 XOR (⊕) 合併選中的按鈕模式得到實際燈泡開關狀態。\n- Step 7 將得到的二進位狀態（可用字串或整數表示）存入集合，避免重複。\n- Step 8 回傳集合大小即為可得到的不同燈泡狀態數。"
    },
    {
      "title": "Prefix and Suffix Search",
      "source_file": "Leetcode/leetcode745.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[[\"apple\"]], [\"a\", \"e\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvtvw0nsl.py\", line 47, in <module>\n    wf = WordFilter(words)\n         ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvtvw0nsl.py\", line 14, in __init__\n    self.lookup[(pref, suff)] = weight\n    ~~~~~~~~~~~^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass WordFilter:\n    def __init__(self, words):\n        # 建立一個字典，用 (prefix, suffix) 為 key，存放最大的索引\n        self.lookup = {}\n        for weight, word in enumerate(words):\n            L = len(word)\n            for i in range(L + 1):\n                pref = word[:i]\n                for j in range(L + 1):\n                    suff = word[j:]\n                    self.lookup[(pref, suff)] = weight\n\n    def f(self, prefix, suffix):\n        # 直接查詢字典，如果沒有就回傳 -1\n        return self.lookup.get((prefix, suffix), -1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將輸入分成兩部分：words 與 query\n    # 假設輸入格式為: '[[\"apple\"]], [\"a\", \"e\"]'\n    split_idx = data.find('],')\n    if split_idx == -1:\n        # 另一種可能的輸入方式：兩行分別給出\n        parts = data.splitlines()\n        words_part = parts[0]\n        query_part = parts[1] if len(parts) > 1 else '[]'\n    else:\n        words_part = data[:split_idx + 1]  # 包含第一個 ]\n        query_part = data[split_idx + 2:]  # 跳過 ],\n\n    # 轉成 Python 物件\n    words = ast.literal_eval(words_part)\n    query = ast.literal_eval(query_part)\n\n    # 只要 query 是兩個元素的列表，分別是前綴和後綴\n    if isinstance(query, (list, tuple)) and len(query) == 2:\n        pref, suff = query\n    else:\n        pref, suff = '', ''\n\n    wf = WordFilter(words)\n    result = wf.f(pref, suff)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for designing such a special dictionary. The algorithm: Build a Trie for prefixes and suffixes? Typically LeetCode problem 745 Word Filter uses a combined trie with prefix and suffix combined. Approach: Build a trie where each node stores max index. For each word, insert all suffixes + '#' + word? Wait typical solution: For each word with index i, for each prefix length p from 0..len(word), for each suffix length s from 0..len(word) maybe combine. But easier: Build trie of all words where keys are suffix + '#' + word. For query (pref, suff), we search for suff + '#' + pref. That returns max index. Steps: Preprocess words: for each word with index i, for each suffix starting at j, form key = word[j:] + '#' + word. Insert into trie with max index. Then f queries: key = suff + '#' + pref; search trie; return node.val or -1. We need to produce virtual code lines and comments. Not actual code. Provide each step with explanation. Ensure format: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's design pseudocode:\n\nStart\n→ Step: 定義 WordFilter 類別\n→ Step: WordFilter(words) // 建構函式\n    → Step: 建立空 Trie 根節點\n    → Decision: 是否需要預處理單詞列表? Yes\n        → Step: 循環索引 i 從 0 到 words.length-1\n            → Step: word ← words[i]\n            → Step: len ← word.length\n            → Step: 循環 j 從 0 到 len // 所有後綴位置\n                → Step: suffix ← word.substring(j, len)\n                → Step: key ← suffix + \"#\" + word\n                → Step: InsertIntoTrie(key, i) // 插入關鍵字並更新最大索引\n→ Step: Define InsertIntoTrie(key, index) // 插入功能\n    → Step: node ← root\n    → Step: 循環每個字符 c in key\n        → Decision: 如果 node.children[c] 不存在? Yes\n            → Step: node.children[c] ← new TrieNode()\n        → Step: node ← node.children[c]\n        → Step: node.maxIndex ← index // 更新最大索引\n    → Step: Done\n→ Step: f(pref, suff) // 查詢功能\n    → Step: key ← suff + \"#\" + pref\n    → Step: node ← root\n    → Step: 循環每個字符 c in key\n        → Decision: 如果 node.children[c] 不存在? Yes\n            → Step: Return -1 // 無此路徑\n        → Step: node ← node.children[c]\n    → Step: Return node.maxIndex\n→ End\n\nAdd explanation comments for each step.\n\nWe need to format each line as: \"虛擬碼步驟 // 解釋\". Use arrows accordingly. Use \"→\" for next step. Use \"Decision:\" for branches.\n\nWe'll produce lines with proper indentation. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define WordFilter class // 定義 WordFilter 類別  \n→ WordFilter(words) // 建構函式：接收單詞陣列  \n → Initialize empty Trie root node // 建立空的 Trie 根節點  \n → Decision: 是否要預處理單詞列表? Yes // 進行預處理  \n  → Loop i from 0 to words.length-1 // 為每個單詞分配索引  \n   → word ← words[i] // 取得當前單詞  \n   → len ← word.length // 單詞長度  \n   → Loop j from 0 to len // 產生所有後綴  \n    → suffix ← word.substring(j, len) // 從位置 j 到結尾的後綴  \n    → key ← suffix + \"#\" + word // 建立查詢鍵值  \n    → InsertIntoTrie(key, i) // 將鍵值插入 Trie，並更新最大索引  \n→ Define InsertIntoTrie(key, index) // 插入函式  \n → node ← root // 從根節點開始  \n → Loop each character c in key // 遍歷鍵字的每個字符  \n  → Decision: node.children[c] 不存在? Yes // 若子節點不存在  \n   → node.children[c] ← new TrieNode() // 創建新節點  \n  → node ← node.children[c] // 進入子節點  \n  → node.maxIndex ← index // 更新此節點的最大索引  \n → End // 插入完成  \n→ Define f(pref, suff) // 查詢函式  \n → key ← suff + \"#\" + pref // 根據前綴後綴組合查詢鍵  \n → node ← root // 從根節點開始  \n → Loop each character c in key // 遍歷鍵字的每個字符  \n  → Decision: node.children[c] 不存在? Yes // 路徑不存在  \n   → Return -1 // 沒有符合條件的單詞  \n  → node ← node.children[c] // 進入子節點  \n → Return node.maxIndex // 回傳最大的索引值  \nEnd // 程式執行結束"
    },
    {
      "title": "Valid Anagram",
      "source_file": "Leetcode/leetcode242.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \"\"\"Return True if t is an anagram of s.\"\"\"\n        return Counter(s) == Counter(t)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，嘗試抓取第一個兩個字串。\n    1. 先找出所有被單/雙引號包住的字串。\n    2. 如果找不到，就直接以空白分割（假設每行一個字串）。\n    \"\"\"\n    # 找出所有被單/雙引號包住的字串\n    quoted = re.findall(r'\"([^\"]*)' r'|\\'([^\\']*)\\'', data)\n    # quoted 會是 tuple (q1, q2); 只取非空的\n    words = [q[0] or q[1] for q in quoted]\n    if len(words) >= 2:\n        return words[0], words[1]\n\n    # 如果沒有引號，則直接以換行或空白分割\n    parts = data.strip().replace('\\n', ' ').split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 如果還是不到兩個，回傳空字串避免錯誤\n    return '', ''\n\ndef main():\n    raw = sys.stdin.read()\n    s, t = parse_input(raw)\n\n    sol = Solution()\n    result = sol.isAnagram(s, t)\n\n    # 按題目要求輸出小寫的 true/false\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. Need to check anagram. Approach: check length, then count frequency via dictionary or array of 26. We'll produce generic virtual code.\n\nLet's produce:\n\nStart // start program\n→ Step 1: 若 s 长度 ≠ t 长度 → Decision: 若长度不同? // 判断长度是否相同\n    Yes → Step 2: 返回 false // 长度不等直接返回\n    No → Step 3: 初始化计数数组 count[26] 为 0 // 用于记录字符出现次数\n→ Step 4: 遍历 s 的每个字符 c: 增加 count[索引(c)] // 统计 s 的字符频率\n→ Step 5: 遍历 t 的每个字符 c: 减少 count[索引(c)] // 减去 t 的字符频率\n→ Decision: 所有 count[i] 是否都为 0? // 检查两字符串字符是否完全相同\n    Yes → Step 6: 返回 true // anagram\n    No  → Step 7: 返回 false // not anagram\nEnd // 结束\n\nAdd comments. Need to use 虚拟码步驟 e.g., \"Step 1: 如果 s 长度 ≠ t 长度?\".\n\nLet's format accordingly. Use arrow \"→\" preceding each step. For decisions use \"Decision:\" lines. Each line ends with \"// ...\". Ensure each line includes a space after code. Use Chinese explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 若 s 與 t 長度不同? // 檢查兩字串長度是否一致  \n Yes → Step 2: 返回 false // 長度不等，無法為字母異位  \n No  → Step 3: 初始化 count[26] 為 0 // 用 26 個位置存儲每個英文字母的頻次  \n→ Step 4: 對於 s 中的每個字元 c: count[索引(c)] += 1 // 統計 s 的字母頻率  \n→ Step 5: 對於 t 中的每個字元 c: count[索引(c)] -= 1 // 把 t 的字母頻率扣回  \n→ Decision: 所有 count[i] 是否皆為 0? // 判斷兩字串字母頻次完全相同  \n Yes → Step 6: 返回 true // t 為 s 的字母異位  \n No  → Step 7: 返回 false // 字母頻次不匹配  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        # 先算出需要刪除的左右括號數量\n        left_remove, right_remove = 0, 0\n        for ch in s:\n            if ch == '(':\n                left_remove += 1\n            elif ch == ')':\n                if left_remove > 0:\n                    left_remove -= 1\n                else:\n                    right_remove += 1\n\n        results = set()\n\n        def dfs(index, left_count, right_count, left_rem, right_rem, path):\n            # 當已刪除的括號數量達到計算值時，判斷剩餘字符串是否合法\n            if left_rem == 0 and right_rem == 0:\n                if left_count == right_count:\n                    results.add(path)\n                return\n\n            if index == len(s):\n                return\n\n            ch = s[index]\n\n            # 1. 如果當前字符是 '('\n            if ch == '(':\n                # 2. 可選擇刪除它\n                if left_rem > 0:\n                    dfs(index + 1, left_count, right_count, left_rem - 1, right_rem, path)\n                # 3. 或保留它\n                dfs(index + 1, left_count + 1, right_count, left_rem, right_rem, path + ch)\n\n            # 4. 如果當前字符是 ')'\n            elif ch == ')':\n                # 5. 可選擇刪除它\n                if right_rem > 0:\n                    dfs(index + 1, left_count, right_count, left_rem, right_rem - 1, path)\n                # 6. 或保留它（前提是左括號比右括號多）\n                if left_count > right_count:\n                    dfs(index + 1, left_count, right_count + 1, left_rem, right_rem, path + ch)\n\n            # 7. 如果是普通字母，直接保留\n            else:\n                dfs(index + 1, left_count, right_count, left_rem, right_rem, path + ch)\n\n        dfs(0, 0, 0, left_remove, right_remove, \"\")\n        return list(results)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    # 解析輸入：若包含 's ='，則擷取等號後面的內容\n    match = re.search(r's\\s*=\\s*[\\'\"]?(.*?)[\\'\"]?$', raw_input, re.DOTALL)\n    if match:\n        s = match.group(1).strip()\n    else:\n        s = raw_input.strip('\\'\"')\n\n    solution = Solution()\n    output = solution.removeInvalidParentheses(s)\n\n    # 以 JSON 格式輸出，保持雙引號\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. The user wants algorithm for removing minimum number of invalid parentheses to produce all valid strings. Classic BFS or DFS with pruning. Provide steps.\n\nWe must adhere to format: each line: virtual code step + space + comment. Use arrow symbols and structure.\n\nWe should provide something like:\n\nStart // 程式開始\n→ Step 1: 計算需要刪除的左括號數目 L 和右括號數目 R //...\n→ Step 2: 定義 DFS 函式 remove(s, index, leftCount, rightCount, leftRem, rightRem, path, result) // ...\n→ Decision: 是否還有左括號可刪除? // ...\n etc.\n\nAlso need to include BFS approach maybe? But we can choose one.\n\nWe need to produce the virtual code only, no actual code, but steps. Use \"→\" for next step, \"Decision:\" for if.\n\nWe should produce algorithm explanation. Provide all steps until End.\n\nLet's craft.\n\nWe need to generate unique strings: use set to avoid duplicates.\n\nWe'll use DFS recursion with pruning.\n\nPseudo steps:\n\nStart\n→ Step 1: Calculate number of misplaced left and right parentheses: L = 0, R = 0 //...\n→ Decision: iterate over string to compute L and R // ...\n→ Step 2: Initialize result set // ...\n→ Step 3: Define recursive function DFS(s, index, leftCount, rightCount, leftRem, rightRem, path) // ...\n→ Decision: if leftRem == 0 and rightRem == 0 // ...\n→ Step 4: If index == len(s) // ...\n→ Decision: if leftCount == rightCount // ...\n→ Step 5: Append path to result set // ...\n→ Decision: else return // ...\n→ Step 6: else // still chars left\n→ Decision: if current char is '(' // ...\n→ Step 7: If leftRem > 0, skip this '(' // call DFS with leftRem-1 // ...\n→ Step 8: Always keep this '(' // call DFS with leftCount+1 // ...\n→ Decision: else if current char is ')' // ...\n→ Step 9: If rightRem > 0, skip this ')' // call DFS with rightRem-1 // ...\n→ Step 10: If leftCount > rightCount, keep this ')' // call DFS with rightCount+1 // ...\n→ Decision: else // current char is letter // ...\n→ Step 11: Append char and call DFS // ...\n→ End\n\nBut we need to structure as lines with arrow, decision.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: 計算需要刪除的左括號數目 leftRemove 與右括號數目 rightRemove // 迭代 s\n→ Decision: 為每個字符 c in s\n    → Step 1.1: 如果 c == '(' 則 leftRemove++\n    → Step 1.2: 否則如果 c == ')' 且 leftRemove > 0 則 leftRemove--\n    → Step 1.3: 否則如果 c == ')' 則 rightRemove++\n→ End // 取得左右刪除數量\n\n→ Step 2: 初始化空集合 results // 存放唯一合法字串\n→ Step 3: 定義遞迴函式 DFS(index, leftCount, rightCount, leftRem, rightRem, path) // 參數說明\n→ Decision: index == len(s)?\n    Yes → Step 3.1: 如果 leftCount == rightCount 將 path 加入 results // 完整合法\n    No → Step 3.2: 取得 s[index] 為 char\n→ Decision: char == '(' ?\n    Yes →\n        → Decision: leftRem > 0 ?\n            Yes → Step 3.2.1: DFS(index+1, leftCount, rightCount, leftRem-1, rightRem, path) // 刪除 '('\n            No →\n        → Step 3.2.2: DFS(index+1, leftCount+1, rightCount, leftRem, rightRem, path + char) // 保留 '('\n    No →\n        → Decision: char == ')' ?\n            Yes →\n                → Decision: rightRem > 0 ?\n                    Yes → Step 3.2.3: DFS(index+1, leftCount, rightCount, leftRem, rightRem-1, path) // 刪除 ')'\n                    No →\n                → Decision: leftCount > rightCount ?\n                    Yes → Step 3.2.4: DFS(index+1, leftCount, rightCount+1, leftRem, rightRem, path + char) // 保留 ')'\n                    No →\n            No → // 字母\n                → Step 3.2.5: DFS(index+1, leftCount, rightCount, leftRem, rightRem, path + char) // 直接加入\n→ End // 結束遞迴\n\n→ Step 4: 呼叫 DFS(0, 0, 0, leftRemove, rightRemove, \"\") // 開始\n→ Step 5: 將 results 轉成列表並回傳 // 最終答案\n\nEnd // 程式結束\n\nWe need to ensure each line uses virtual code arrow or decision. Provide comment after //.\n\nAlso note that we must include Start and End lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算需要刪除的左括號數目 leftRemove 與右括號數目 rightRemove // 迭代字符串 s  \n→ Decision: for each char c in s  \n  Yes → Step 1.1: 如果 c == '(' 則 leftRemove++ // 記錄左括號缺口  \n  No → Step 1.2: 否則如果 c == ')' 且 leftRemove > 0 則 leftRemove-- // 先匹配左括號  \n  No → Step 1.3: 否則如果 c == ')' 則 rightRemove++ // 未匹配到左括號，記錄右括號缺口  \nEnd // leftRemove 與 rightRemove 已計算完成  \n\n→ Step 2: 初始化空集合 results // 用來儲存唯一合法字串  \n→ Step 3: 定義遞迴函式 DFS(index, leftCount, rightCount, leftRem, rightRem, path) // 參數說明  \n  Decision: index == len(s)?  \n   Yes → Step 3.1: 如果 leftCount == rightCount 將 path 加入 results // 完整合法  \n   No → Step 3.2: 取得 s[index] 為 char // 進行處理  \n\n  Decision: char == '('?  \n   Yes →  \n    Decision: leftRem > 0?  \n     Yes → Step 3.2.1: DFS(index+1, leftCount, rightCount, leftRem-1, rightRem, path) // 刪除 '('  \n     No →  \n    Step 3.2.2: DFS(index+1, leftCount+1, rightCount, leftRem, rightRem, path + char) // 保留 '('  \n\n  No → Decision: char == ')' ?  \n   Yes →  \n    Decision: rightRem > 0?  \n     Yes → Step 3.2.3: DFS(index+1, leftCount, rightCount, leftRem, rightRem-1, path) // 刪除 ')'  \n     No →  \n    Decision: leftCount > rightCount?  \n     Yes → Step 3.2.4: DFS(index+1, leftCount, rightCount+1, leftRem, rightRem, path + char) // 保留 ')'  \n     No →  \n   No → // 字母  \n    Step 3.2.5: DFS(index+1, leftCount, rightCount, leftRem, rightRem, path + char) // 直接加入  \n\nEnd // 遞迴定義完成  \n\n→ Step 4: 呼叫 DFS(0, 0, 0, leftRemove, rightRemove, \"\") // 開始遞迴搜索  \n→ Step 5: 將 results 轉成列表並回傳 // 最終答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = ord(num1[i]) - 48 if i >= 0 else 0\n            y = ord(num2[j]) - 48 if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(res[::-1])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出所有的數字序列\n    numbers = re.findall(r'\\d+', data)\n    if len(numbers) < 2:\n        sys.exit(0)\n    num1, num2 = numbers[0], numbers[1]\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for adding two large numbers represented as strings without using big integer libs or direct integer conversion. It's typical manual addition algorithm. We produce steps: initialize result string builder, set carry 0, iterate from end to start. So virtual code lines: Start, Step 1: 初始化carry, i, j indices, result builder, etc. Then Decision to check indices. Use Decision: if i>=0 or j>=0? Yes => compute digit addition. else exit loop. After loop, if carry>0 add digit. Then reverse result or build from front? Usually build in reverse then reverse at end. Use string builder.\n\nWe need to format with virtual code and explanation.\n\nLet's produce line by line.\n\nAlso need to consider that we cannot convert to integer directly. So we need char to int conversion by subtracting '0' char.\n\nWe will show steps:\n\nStart\n→ Step 1: 初始化 i = len(num1)-1, j = len(num2)-1, carry = 0, result = empty list // 设置索引和进位\n→ Step 2: Decision: i>=0 或 j>=0? // 检查是否还有待处理位\n    Yes → Step 3: digit1 = (i>=0)? ord(num1[i])-48 : 0 // 取当前位数字\n    Yes → Step 4: digit2 = (j>=0)? ord(num2[j])-48 : 0 // 取当前位数字\n    Yes → Step 5: sum = digit1 + digit2 + carry // 计算总和\n    Yes → Step 6: result.append(str(sum % 10)) // 记录当前位结果\n    Yes → Step 7: carry = sum // 10 // 更新进位\n    Yes → Step 8: i = i - 1 // 移动到上一位\n    Yes → Step 9: j = j - 1 // 移动到上一位\n    Yes → Step 10: 回到 Step 2 // 继续循环\n    No  → Step 11: Decision: carry > 0? // 检查是否还有进位\n        Yes → Step 12: result.append(str(carry)) // 追加最高位进位\n        No  → Step 13: // 进位为0，跳过\n→ Step 14: result.reverse() // 反转结果\n→ Step 15: return ''.join(result) // 拼接成字符串返回\nEnd\n\nNeed to ensure proper formatting with virtual code arrow \"→\" before each step, but decision lines indent.\n\nWe need to maintain \"Start\", \"End\". The arrow lines for steps. For decision, \"Decision:\".\n\nFor nested decision, indent. Provide explanation after comment.\n\nLet's produce accordingly.\n\nEnsure no actual code printed. Use virtual code syntax only. Provide each line with explanation comment.\n\nAlso note we cannot use built-in integer conversion like int(num1). So we use char to int via subtract 48.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← len(num1) - 1, j ← len(num2) - 1, carry ← 0, result ← [] // 初始化索引、進位與儲存結果的空清單  \n→ Step 2: Decision: i ≥ 0 或 j ≥ 0? // 判斷是否還有位數未處理  \n  Yes → Step 3: digit1 ← (i ≥ 0) ? (ord(num1[i]) - 48) : 0 // 取 num1 的目前位，若已遍歷完則為 0  \n  Yes → Step 4: digit2 ← (j ≥ 0) ? (ord(num2[j]) - 48) : 0 // 取 num2 的目前位，若已遍歷完則為 0  \n  Yes → Step 5: sum ← digit1 + digit2 + carry // 計算兩位相加與進位之和  \n  Yes → Step 6: result.append(str(sum % 10)) // 將當前位的餘數追加到結果清單  \n  Yes → Step 7: carry ← sum // 10 // 更新進位值  \n  Yes → Step 8: i ← i - 1 // 移動到 num1 的前一位  \n  Yes → Step 9: j ← j - 1 // 移動到 num2 的前一位  \n  Yes → Step 10: 回到 Step 2 // 繼續處理下一位  \n  No  → Step 11: Decision: carry > 0? // 所有位已處理，檢查是否仍有進位  \n    Yes → Step 12: result.append(str(carry)) // 追加最高位進位  \n    No  → Step 13: // 進位為 0，無需額外處理  \n→ Step 14: result.reverse() // 逆轉結果以得到正確順序  \n→ Step 15: return ''.join(result) // 將清單轉成字串並回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays",
      "source_file": "Leetcode/leetcode349.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[9,4]'\nGot (Norm):      '[4,9]'\n--- (Raw) ---\nRaw Expected: '[9,4]'\nRaw Got:      '[4,9]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"返回兩個整數列表的唯一交集，結果以列表形式回傳。\"\"\"\n        return sorted(set(nums1) & set(nums2))\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 使用正則表達式提取兩個列表字串\n    pattern = r'nums1\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*nums2\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"輸入格式錯誤，請使用 'nums1 = [...], nums2 = [...]'\")\n\n    # 轉換字串為實際列表\n    nums1_str, nums2_str = match.group(1), match.group(2)\n    nums1 = ast.literal_eval(nums1_str)\n    nums2 = ast.literal_eval(nums2_str)\n\n    # 計算交集\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n\n    # 以不帶空格的格式輸出列表\n    output = '[' + ','.join(str(x) for x in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for intersection of two integer arrays, unique elements. Steps: Start, convert to set, compute intersection, output array. Provide explanation each line.\n\nLet's craft lines with arrow \"→\". We might use Decision if needed but it's straightforward. Let's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 將 nums1 轉成 Set1 // 建立 nums1 的集合，去重\n→ Step 2: 將 nums2 轉成 Set2 // 建立 nums2 的集合，去重\n→ Step 3: 產生 IntersectionSet = Set1 ∩ Set2 // 找出兩集合共有元素\n→ Step 4: 轉換 IntersectionSet 為 List // 把集合轉成陣列回傳\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋. Use format: \"Step 1: ...\" etc. Use arrow after Start and before each Step. Provide decisions? Not needed. Just simple steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 nums1 轉成 Set1 // 建立 nums1 的集合，去除重複值  \n→ Step 2: 將 nums2 轉成 Set2 // 建立 nums2 的集合，去除重複值  \n→ Step 3: 產生 IntersectionSet = Set1 ∩ Set2 // 找出兩集合的公共元素  \n→ Step 4: 將 IntersectionSet 轉成 List // 把集合轉成陣列作為結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6n2fjxg5.py\", line 25, in <module>\n    ops, args = json.loads(raw)\n                ^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 37 (char 36)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"Return a random index of target in self.nums using reservoir sampling.\"\"\"\n        count = 0\n        result = -1\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                if random.randint(1, count) == 1:\n                    result = i\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入並解析為 JSON\n    raw = sys.stdin.read()\n    if not raw.strip():\n        sys.exit()\n    ops, args = json.loads(raw)\n\n    outputs = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 形如 [[1, 2, 3, 3, 3]]，取內部列表\n            nums = arg[0] if isinstance(arg, list) and len(arg) == 1 else arg\n            obj = Solution(nums)\n            outputs.append(None)\n        elif op == \"pick\":\n            result = obj.pick(arg[0])\n            outputs.append(result)\n        else:\n            outputs.append(None)\n\n    # 輸出結果，將 None 轉為 JSON null\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step for the solution. It's a classic random index pick problem. Outline: constructor stores nums; pick uses reservoir sampling to select an index with equal probability among occurrences of target. Steps: count = 0, result = -1; iterate through array with index i, if nums[i]==target: count++; if random 1/count == true: result = i; return result.\n\nWe need to output virtual code line by line with explanation after //.\n\nWe need Start and End. Use arrow →. We may include Decision: with Yes → and No →. Also we need steps for constructor and pick method.\n\nWe need separate steps maybe: Start, Step 1: define class Solution // class definition, Step 2: constructor: store array, etc. Then pick method: Step: initialize count, result, iterate, Decision: if nums[i]==target? then nested Decision: if random 1/count? etc.\n\nLet's produce. Use \"Start\" at top of algorithm maybe separate for constructor and pick? Provide within one flow? Probably provide both methods. We can do:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 開始定義 Solution 類\n→ Step 2: Constructor: Solution(nums) // 初始化物件\n    → Step 2.1: this.nums ← nums // 儲存陣列\n→ Step 3: Method: pick(target) // 定義 pick 方法\n    → Step 3.1: count ← 0 // 計數器\n    → Step 3.2: result ← -1 // 暫存結果\n    → Step 3.3: For i from 0 to nums.length-1 // 遍歷陣列\n        → Decision: 如果 nums[i] == target? // 檢查元素是否為目標\n            Yes → Step 3.3.1: count ← count + 1 // 有效位置增加計數\n            Yes → Step 3.3.2: Decision: 隨機選擇 1/count? // 檢查是否選中\n                Yes → Step 3.3.2.1: result ← i // 選中則更新結果\n                No → Step 3.3.2.2: // 保持結果不變\n            No → Step 3.3.3: // 若不是目標則不做任何事\n    → Step 3.4: return result // 回傳隨機索引\nEnd // 程式執行結束\n\nNeed ensure each line has arrow. Use indentation to reflect nested. Use \"Decision:\" with Yes → etc. Provide explanation after //. Make sure every line has the pattern. Provide Start and End.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 開始定義 Solution 類  \n→ Step 2: Constructor: Solution(nums) // 初始化物件  \n → Step 2.1: this.nums ← nums // 儲存陣列供後續使用  \n→ Step 3: Method: pick(target) // 定義 pick 方法  \n → Step 3.1: count ← 0 // 計數已找到的目標數量  \n → Step 3.2: result ← -1 // 暫存目前已選中的索引  \n → Step 3.3: For i from 0 to nums.length - 1 // 遍歷整個陣列  \n  → Decision: 如果 nums[i] == target? // 檢查目前元素是否為目標  \n   Yes → Step 3.3.1: count ← count + 1 // 目標出現一次，計數加一  \n   Yes → Step 3.3.2: Decision: 隨機選擇 1/count? // 以 1/count 的機率選中  \n    Yes → Step 3.3.2.1: result ← i // 選中則更新結果為目前索引  \n    No → Step 3.3.2.2: // 未選中，保持結果不變  \n   No → Step 3.3.3: // 若不是目標則不執行任何操作  \n → Step 3.4: return result // 回傳隨機選中的目標索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef find_lus_length(strs):\n    \"\"\"Return the length of the longest uncommon subsequence.\"\"\"\n    # Count occurrences of each string\n    freq = {}\n    for s in strs:\n        freq[s] = freq.get(s, 0) + 1\n\n    # Find the maximum length among strings that appear only once\n    max_len = -1\n    for s in strs:\n        if freq[s] == 1 and len(s) > max_len:\n            max_len = len(s)\n\n    return max_len\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse the input string into a Python list\n    # The input format is a literal list, e.g. '[\"aba\",\"cdc\",\"eae\"]'\n    strs = ast.literal_eval(data)\n\n    # Compute and print the result\n    result = find_lus_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for the problem: longest uncommon subsequence length. Classic Leetcode problem: LUSlength. The algorithm: If any string appears only once, answer is its length; else -1. Because the longest uncommon subsequence is either the longest string that is unique in array; if none unique, cannot find uncommon subsequence. So produce steps: read array, count occurrences, find max length of unique string, else -1.\n\nWe must produce each line with \"虛擬碼步驟\" and comment.\n\nWe use virtual code arrows, decision. Must not output actual code, only steps. So we produce steps like:\n\nStart // start\n\n→ Step 1: Initialize a map to count frequencies of each string // count occurrences\n\n→ Step 2: For each string s in array: increment count in map // counting\n\n→ Decision: Check if any string occurs exactly once // uniqueness check\n\n    Yes → Step 3: Find maximum length among strings with count 1 // longest unique\n\n        → Step 4: Return that length // output\n\n    No  → Step 5: Return -1 // no unique\n\nEnd // finish\n\nNeed to show decision with Yes and No branches. Use format exactly: \"Decision: ...? // comment\" then indent \"Yes →\" etc.\n\nAlso need to include \"→\" before steps. The code lines must be one per step. Indent lines properly.\n\nMake sure each line has \"虛擬碼步驟\" like \"Start\" etc.\n\nWe must not output actual code. So we will use step names but not actual code. Just explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個字典 `freq` 用於計算每個字串出現的次數 // 初始化計數結構  \n→ Step 2: 逐一遍歷 `strs`，將每個字串對應的計數加一 // 統計頻率  \n→ Decision: 是否存在至少一個字串 `s` 其 `freq[s] == 1`? // 檢查是否有唯一字串  \n    Yes → Step 3: 在所有 `freq[s] == 1` 的字串中尋找長度最大的字串 `maxLen` // 找到最大長度  \n        → Step 4: 回傳 `maxLen` // 輸出最長不常見子序列長度  \n    No  → Step 5: 回傳 `-1` // 沒有唯一字串時無法存在不常見子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        返回 nums 的所有排列。\n        使用深度優先回溯 + 原地交換，避免額外的「已使用」集合。\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 當 start 指向最後一個位置時，已形成完整排列\n            if start == len(nums):\n                # 把目前的排列複製一份加入結果\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                # 交換把 nums[i] 放到 start 位置\n                nums[start], nums[i] = nums[i], nums[start]\n                # 進行下一層遞迴\n                backtrack(start + 1)\n                # 回溯：恢復原始順序\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析 nums 並輸出所有排列。\n    輸入格式示例： nums = [1,2,3]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到第一個 '['，從那裡開始解析為 list\n    idx = data.find('[')\n    if idx != -1:\n        nums_str = data[idx:]\n    else:\n        nums_str = data\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        # 若解析失敗，直接結束\n        return\n\n    solution = Solution()\n    perms = solution.permute(nums)\n\n    # 產生不帶空格的格式化輸出\n    out = '[' + ','.join('[' + ','.join(map(str, perm)) + ']' for perm in perms) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. Use Start, Decision, Yes→, No→, End. For generating all permutations. We can use backtracking recursion, but in virtual code, we can illustrate steps. Provide steps: start, define function permute(nums), call backtrack([], set()), etc.\n\nWe need to produce simple step list. Provide decisions: if current permutation length equals len(nums) then add to result. Else iterate over nums, skip used, add, recursive, remove. We can describe with decision if element not used. Provide pseudo.\n\nLet's produce lines:\n\nStart\n→ Step 1: Define function permute(nums) // Entry point\n→ Step 2: Initialize result list // Store permutations\n→ Step 3: Define helper backtrack(current, used) // Recursive function\n→ Decision: 如果 current.length == nums.length? // Check if permutation complete\n    Yes → Step 4: Add copy of current to result // Store completed permutation\n    No  → Decision: For each num in nums? // Iterate numbers\n        → Step 5: Decision: 如果 num 未在 used? // Check if already used\n            Yes → Step 6: Add num to current // Include number\n            → Step 7: Add num to used // Mark used\n            → Step 8: Call backtrack(current, used) // Recurse\n            → Step 9: Remove last element from current // Backtrack\n            → Step 10: Remove num from used // Unmark\n            No  → Step 11: Continue // Skip used number\n→ Step 12: Call backtrack([], empty set) // Start recursion\n→ Step 13: Return result // Output all permutations\nEnd\n\nMake sure each line ends with comment.\n\nAlso maybe include Decision: For each num in nums? It's not a typical decision but an iteration. But we can treat as a decision: For each num, but we can incorporate in loop.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 permute(nums) // 程式入口，接收整數陣列  \n→ Step 2: 初始化 result 為空列表 // 用於儲存所有排列結果  \n→ Step 3: 定義遞迴輔助函式 backtrack(current, used) // current: 目前已建立的排列，used: 已使用的數字集合  \n→ Decision: 如果 current.length == nums.length? // 判斷排列是否已完整  \n    Yes → Step 4: 把 current 的拷貝加入 result // 完整排列加入結果集  \n    No → Decision: 對 nums 中每個 num 進行處理? // 迭代所有可能的下一個數字  \n        → Step 5: Decision: 如果 num 未在 used? // 確認此數字尚未被加入 current  \n            Yes → Step 6: 把 num 加入 current // 進行選擇  \n            → Step 7: 把 num 加入 used // 標記已使用  \n            → Step 8: 呼叫 backtrack(current, used) // 進一步遞迴  \n            → Step 9: 從 current 移除最後一個元素 // 回溯，移除選擇  \n            → Step 10: 從 used 移除 num // 回溯，取消標記  \n            No → Step 11: 繼續迴圈 // 跳過已使用的數字  \n→ Step 12: 呼叫 backtrack([], 空集合) // 從空排列開始遞迴  \n→ Step 13: 回傳 result // 將所有排列輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Sliding Window Maximum",
      "source_file": "Leetcode/leetcode239.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7p01hs86.py\", line 54, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7p01hs86.py\", line 49, in parse_input\n    k = int(k_str.strip())\n        ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 3'"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7_mzi2o6.py\", line 54, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7_mzi2o6.py\", line 49, in parse_input\n    k = int(k_str.strip())\n        ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 1'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or k == 0:\n            return []\n\n        deq = deque()\n        res = []\n\n        for i in range(len(nums)):\n            # Remove indices that are out of the current window\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n            # Remove indices whose corresponding values are smaller than nums[i]\n            while deq and nums[deq[-1]] < nums[i]:\n                deq.pop()\n            deq.append(i)\n\n            # Once we have a full window, record the maximum\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    Parses input of the form:\n        nums = [1,3,-1,-3,5,3,6,7], k = 3\n    and returns (nums, k).\n    \"\"\"\n    data = data.strip()\n    # Find the list of numbers\n    start = data.find('[')\n    end = data.find(']', start)\n    nums = ast.literal_eval(data[start:end+1])\n\n    # Find k\n    k_part = data[end+1:]\n    k_index = k_part.find('k')\n    k_str = k_part[k_index+2:]  # skip 'k ='\n    k = int(k_str.strip())\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    sol = Solution()\n    result = sol.maxSlidingWindow(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step. We should follow the output format: each line \"虛擬碼步驟 // 解釋\" with arrow symbols etc. Need to implement sliding window maximum. Use deque approach. Provide pseudocode lines with decisions and loops.\n\nLet's write lines:\n\nStart\n→ Step 1: 初始化空 deque d // 用於儲存索引\n→ Step 2: 初始化空結果 list res // 存放每個窗口最大值\n→ Step 3: 循環遍歷 nums 以 i 為索引 // 遍歷整個數組\n    → Decision: 如果 i >= k? // 是否已經形成完整窗口\n        Yes →\n            → Decision: d[0] <= i-k? // 检查左侧索引是否已离开窗口\n                Yes → → Step 4: 移除 d[0] // 从deque头部移除过期索引\n            → Step 5: 将 nums[i] 对应索引 i 添加到 d 并维护单调递减 // 维护队列单调\n            → Step 6: res.append(nums[d[0]]) // 当前窗口最大值\n        No →\n            → Step 5: 将 nums[i] 对应索引 i 添加到 d 并维护单调递减 // 对前 k-1 个元素同样维护\n    → Step 5 continues? We need unify.\n\nLet's produce a structured pseudocode with indentation.\n\nWe need to use \"Decision:\" lines with \"Yes →\" \"No →\". Use \"→\" arrow to next step.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空 deque d // 用於儲存索引，保持單調遞減  \n→ Step 2: 初始化空結果 list res // 存放每個滑動窗口的最大值  \n→ Step 3: 循環遍歷 nums 以 i 為索引 // 整個數組一次掃描  \n  → Decision: i >= k? // 判斷是否已形成完整窗口  \n   Yes →  \n    → Decision: d[0] <= i - k? // 檢查左側索引是否已離開窗口  \n     Yes →  \n      → Step 4: 移除 d[0] // 先將過期索引從頭部移除  \n     No  →  \n      → // 不做任何事，索引仍在窗口內  \n    → Step 5: 從 d 的尾部移除所有小於等於 nums[i] 的索引 // 以維持遞減  \n     → Step 6: 將索引 i 添加到 d 的尾部 // 把當前元素納入窗口  \n    → Step 7: res.append(nums[d[0]]) // d[0] 為窗口最大值，加入結果  \n   No →  \n    → Step 5: 從 d 的尾部移除所有小於等於 nums[i] 的索引 // 先前窗口尚未完整也保持遞減  \n     → Step 6: 將索引 i 添加到 d 的尾部 // 將當前元素納入暫時窗口  \nEnd // 程式執行結束，res 為最終結果。"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2t4j2f0s.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp2t4j2f0s.py\", line 45, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp69983ruz.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp69983ruz.py\", line 45, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwlxyc63g.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpwlxyc63g.py\", line 45, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # 先算出這一行能裝多少個單字\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # 這一行的單字\n            line_words = words[i:j]\n            # 需要補的空格數量\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # 最後一行或只有一個單字：左對齊\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # 完全對齊\n                space, extra = divmod(spaces_needed, gaps)\n                parts = []\n                for k in range(gaps):\n                    parts.append(line_words[k] + ' ' * (space + (1 if k < extra else 0)))\n                parts.append(line_words[-1])\n                line = ''.join(parts)\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 用 exec 產生 words 與 maxWidth 兩個變數\n    local_vars = {}\n    exec(data, {}, local_vars)\n    words = local_vars.get('words')\n    maxWidth = local_vars.get('maxWidth')\n    # 呼叫解法\n    sol = Solution()\n    result = sol.fullJustify(words, maxWidth)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for the problem description: full justification. Provide steps, decisions, loops, etc. We don't output actual code. Just virtual steps. Use arrows. Each line with explanation.\n\nWe should cover: Start, index i, loop over words, accumulate words until adding next exceeds maxWidth, build line, compute spaces, handle last line. Then output lines, End.\n\nWe need to output a series of lines, each with virtual step and explanation. Use arrow →. For decision: Decision:. Use Yes → and No → indent.\n\nLet's produce pseudo algorithm. Use index i=0. While i < words.length: start new line. Count words. lineWords = [], lineLen=0. While i < words.length and lineLen + words[i].length + lineWords.size <= maxWidth: add words[i] to lineWords, lineLen += words[i].length, i++. After loop, if i==words.length: last line: left-justify. Else: fully justify. For fully justify: gaps = lineWords.size-1. totalSpaces = maxWidth - lineLen. spacePerGap = totalSpaces // gaps, extra = totalSpaces % gaps. Build line: for j in 0..gaps-1: append lineWords[j] + spaces(spacePerGap + (j<extra?1:0)). Append last word. For last line: line = join words with single space, then pad end with spaces to maxWidth. Append to output.\n\nReturn output.\n\nLet's produce virtual code steps.\n\nWe need each line with explanation.\n\nWe need to keep indentation for decisions. Use arrow lines.\n\nOk let's craft.\n\nWe will include variable declarations in comments. Keep readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set i = 0 // 初始化字串索引  \n→ Set output = [] // 用於存儲最終每一行的結果  \n→ Decision: i < words.length? // 檢查是否還有未處理的字串  \n    Yes → Step 1: Initialize lineWords = [] // 新行的字串集合  \n    → Set lineLen = 0 // 新行已佔用的字符數  \n    → While i < words.length AND lineLen + words[i].length + lineWords.size <= maxWidth? // 判斷能否將下個字串放進本行  \n        Yes → Add words[i] to lineWords // 將字串加入本行  \n        → lineLen += words[i].length // 更新已佔用字符數  \n        → i++ // 移動到下一個字串  \n        No  → // 無法再加入，結束 while  \n    → Decision: i == words.length? // 判斷這是否為最後一行  \n        Yes → // 最後一行：左對齊  \n        → line = Join(lineWords, ' ') // 用單個空格連接字串  \n        → PadRight(line, maxWidth, ' ') // 在右側補空格至 maxWidth  \n        → Append line to output // 加入結果  \n        No  → // 非最後一行：完全對齊  \n        → gaps = lineWords.size - 1 // 行中空格槽數  \n        → totalSpaces = maxWidth - lineLen // 需要插入的總空格數  \n        → spacePerGap = totalSpaces // gaps // 每個空格槽基本空格數  \n        → extraSpaces = totalSpaces % gaps // 多餘空格數，左側多  \n        → line = \"\" // 建立本行文字  \n        → For j = 0 to gaps-1? // 為每個空格槽添加字串和空格  \n            Yes → Append lineWords[j] to line // 加入字串  \n            → Append spaces(spacePerGap + (j < extraSpaces ? 1 : 0)) to line // 加入相應空格  \n            No  → // 循環結束  \n        → Append lineWords[last] to line // 加入最後一個字串  \n        → Append line to output // 加入結果  \n    → // 本行處理完畢  \n→ // 回到 Decision 以檢查是否還有字串  \n→ // (上面 Decision: i < words.length? 會自動迴圈)  \n→ End // 程式執行結束，輸出 output (每行長度已為 maxWidth)"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,2,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 2, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport collections\nimport ast\nimport json\n\n# -------------------------------------------------------------\n# RandomizedCollection: 支持重複元素的插入、刪除與隨機取值\n# -------------------------------------------------------------\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的動態陣列\n        self.data = []\n        # 值 -> 索引集合，追蹤每個值在 data 中的位置\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        將 val 插入集合。\n        若 val 之前不存在，回傳 True；否則回傳 False。\n        \"\"\"\n        # 是否為首次插入\n        is_new = val not in self.idx_map\n        # 把元素加到 data 的末尾\n        self.data.append(val)\n        # 記錄索引\n        self.idx_map[val].add(len(self.data) - 1)\n        return is_new\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        若 val 存在，移除其中一個實例，回傳 True；否則回傳 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取出任一索引待刪\n        remove_idx = self.idx_map[val].pop()\n        # 取得 data 最後一個元素\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 覆蓋待刪元素\n        self.data[remove_idx] = last_val\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 移除 data 最後一個位置\n        self.data.pop()\n\n        # 若 val 的索引集合已空，刪除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回目前集合中的一個元素，機率與其出現次數成正比。\n        \"\"\"\n        return random.choice(self.data)\n\n# -------------------------------------------------------------\n# 主程式：從 stdin 讀取測試用例，執行並輸出結果\n# -------------------------------------------------------------\ndef main() -> None:\n    \"\"\"\n    輸入格式：\n        兩個 list 以逗號分隔，例如\n        [\"RandomizedCollection\", \"insert\", \"insert\"],\n        [[], [1], [1]]\n    代表先建立 RandomizedCollection，然後執行 insert(1)、insert(1)。\n    \"\"\"\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        return\n\n    # 用 '(' + input + ')' 包裝成 tuple，方便 ast.literal_eval 解析\n    try:\n        ops, args = ast.literal_eval(f\"({input_str})\")\n    except Exception as e:\n        # 若解析失敗，印出錯誤並結束\n        print(f\"Input parsing error: {e}\")\n        return\n\n    result = [None]  # 第一個操作是建構子，結果為 null\n    obj = RandomizedCollection()\n\n    for op, arg in zip(ops[1:], args[1:]):  # 從第二個操作開始\n        if op == \"insert\":\n            res = obj.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = obj.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = obj.getRandom()\n            result.append(res)\n        else:\n            # 若有未知操作，直接跳過\n            result.append(None)\n\n    # 輸出符合 LeetCode 樣式的 JSON 列表\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the RandomizedCollection class. We need to describe steps: initialization, insert, remove, getRandom. Each step with explanation.\n\nWe should use Start, End, Decision:, Yes→, No→ etc.\n\nWe need to produce virtual code in Chinese comments. Use each line. Let's produce code steps: Start, initialize array list, hash map val->set of indices. Insert: append to array, add index to set. Return whether first occurrence. Remove: if not present return false. else get an index from set. Remove that index: swap with last element in array, update mapping sets accordingly. Remove last. Return true. getRandom: random index from array and return element.\n\nLet's write steps.\n\nEnsure we use arrow notation. Use → for steps.\n\nLet's produce:\n\nStart // Initialize class\n→ Step 1: 建立空動態陣列 elements // 存放所有元素\n→ Step 2: 建立映射 valToIndices：值 → 集合的索引 // 追蹤每個值所在的位置\n→ Step 3: 建立隨機數生成器 rng // 用於 getRandom\nEnd // 初始化完成\n\nInsert(val)\nStart\n→ Step 1: 確認 val 是否存在於 valToIndices // 判斷是否為新值\n    Yes → Step 2: 設置 isNew = false // 不是新值\n    No  → Step 3: 建立空集合 valToIndices[val]\n          → Step 4: 設置 isNew = true // 是新值\n→ Step 5: 取得插入位置 idx = elements.size() // 新元素索引\n→ Step 6: 在 elements 中 append val // 加入元素\n→ Step 7: 在 valToIndices[val] 中加入 idx // 更新索引集合\n→ Step 8: 回傳 isNew // 根據是否新值回傳\nEnd\n\nRemove(val)\nStart\n→ Step 1: 檢查 val 是否存在於 valToIndices\n    Yes → Step 2: 取得任一 idx 從 valToIndices[val] 中\n          → Step 3: 取得 lastIdx = elements.size() - 1\n          → Step 4: 取得 lastVal = elements[lastIdx]\n          → Step 5: 將 elements[idx] = lastVal // 覆蓋待刪元素\n          → Step 6: 在 valToIndices[lastVal] 中移除 lastIdx\n          → Step 7: 在 valToIndices[lastVal] 中加入 idx // 更新索引\n          → Step 8: 從 valToIndices[val] 中移除 idx\n          → Step 9: 從 elements 刪除最後一個元素 // 降低長度\n          → Step 10: 若 valToIndices[val] 為空，刪除該鍵\n          → Step 11: 回傳 true // 成功刪除\n    No  → Step 12: 回傳 false // 無此值\nEnd\n\nGetRandom()\nStart\n→ Step 1: 產生隨機整數 r 在 [0, elements.size() - 1]\n→ Step 2: 回傳 elements[r] // 隨機元素\nEnd\n\nWe need each line with comment. Also maybe combine steps into fewer lines? The requirement: each line must contain virtual code step + comment. Use arrows. Let's produce each step as separate line.\n\nWe need to ensure \"→\" used. For nested decisions, use indentation. We'll use spaces to indicate hierarchy. Ensure lines like \"Yes →\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空動態陣列 elements // 存放所有元素\n→ Step 2: 建立映射 valToIndices：值 → 集合的索引 // 追蹤每個值所在的位置\n→ Step 3: 建立隨機數生成器 rng // 用於 getRandom\nEnd // 初始化完成\n\nInsert(val) // 插入元素\nStart // 插入過程開始\n→ Decision: val 是否存在於 valToIndices? // 判斷是否為新值\n    Yes → Step 1: 設置 isNew = false // 不是新值\n    No  → Step 2: 建立空集合 valToIndices[val]\n          → Step 3: 設置 isNew = true // 是新值\n→ Step 4: 取得插入位置 idx = elements.size() // 新元素索引\n→ Step 5: 在 elements 中 append val // 加入元素\n→ Step 6: 在 valToIndices[val] 中加入 idx // 更新索引集合\n→ Step 7: 回傳 isNew // 根據是否新值回傳\nEnd // 插入結束\n\nRemove(val) // 刪除元素\nStart // 刪除過程開始\n→ Decision: val 是否存在於 valToIndices? // 判斷是否有該值\n    Yes → Step 1: 取得任一 idx 從 valToIndices[val] 中\n          → Step 2: 取得 lastIdx = elements.size() - 1\n          → Step 3: 取得 lastVal = elements[lastIdx]\n          → Step 4: 將 elements[idx] = lastVal // 覆蓋待刪元素\n          → Step 5: 在 valToIndices[lastVal] 中移除 lastIdx\n          → Step 6: 在 valToIndices[lastVal] 中加入 idx // 更新索引\n          → Step 7: 從 valToIndices[val] 中移除 idx\n          → Step 8: 從 elements 刪除最後一個元素 // 降低長度\n          → Step 9: 若 valToIndices[val] 為空，刪除該鍵\n          → Step 10: 回傳 true // 成功刪除\n    No  → Step 11: 回傳 false // 無此值\nEnd // 刪除結束\n\nGetRandom() // 隨機取值\nStart // 隨機取值開始\n→ Step 1: 產生隨機整數 r 在 [0, elements.size() - 1] // 隨機索引\n→ Step 2: 回傳 elements[r] // 隨機元素\nEnd // 隨機取值結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp09o8tfsq.py\", line 34, in <module>\n    coins, amount = parse_input(raw_input)\n                    ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp09o8tfsq.py\", line 25, in parse_input\n    amount_part = parts[1].split('=', 1)[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\ndef coin_change(coins, amount):\n    \"\"\"\n    Return the minimum number of coins needed to make up the given amount.\n    If it cannot be made up, return -1.\n    \"\"\"\n    # dp[i] 表示湊成金額 i 所需最少硬幣數，初始化為無限大\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # 零金額不需要硬幣\n\n    # 動態規劃：對每個硬幣更新 dp\n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n\n    return dp[amount] if dp[amount] != float('inf') else -1\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從類似 'coins = [1,2,5], amount = 11' 的字串中提取 coins 列表與 amount 整數。\n    \"\"\"\n    parts = input_str.split(',')\n    coins_part = parts[0].split('=', 1)[1].strip()\n    amount_part = parts[1].split('=', 1)[1].strip()\n    coins = eval(coins_part)          # 直接解析列表字串\n    amount = int(amount_part)         # 解析整數\n    return coins, amount\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        coins, amount = parse_input(raw_input)\n        result = coin_change(coins, amount)\n        print(result)\n    else:\n        # 若無輸入則不輸出任何東西\n        pass",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the coin change problem. Use Start, Step, Decision. We need to include dynamic programming? Likely use DP. Steps: initialize array dp[amount+1] with INF, dp[0]=0. Loop i 1..amount, for each coin, if coin <= i: dp[i] = min(dp[i], dp[i-coin]+1). After loops, if dp[amount] == INF return -1 else dp[amount]. Provide each step line with explanation. Use arrow notation. Let's produce a step by step algorithm in pseudocode with decision. We'll need loops. Represent loops with Step 1: Initialize dp array. Step 2: For each amount i from 1 to target. Step 3: For each coin. Step 4: Update dp. After loops, Decision: If dp[amount] is INF? Yes → return -1, No → return dp[amount]. End.\n\nMake sure to use arrow notation. Provide line numbers? Not necessary but we can label. Provide each line.\n\nLet's produce.\n\nWe should avoid actual code, just virtual steps. We'll use \"Start\", \"→\" arrow. Use \"Decision:\" for if statements.\n\nLet's produce the output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義常數 INF 為一個很大的數 // 代表「無限大」  \n→ Step 2: 建立長度為 amount+1 的 dp 陣列，全部初始化為 INF // dp[i] 將存放組成金額 i 所需的最少硬幣數  \n→ Step 3: 設定 dp[0] = 0 // 零金額不需要硬幣  \n→ Step 4: 循環 i 從 1 到 amount // 逐一計算每個金額  \n  → Decision: 如果 i 小於任何硬幣面額?  \n   Yes → Skip 此金額 // 沒有可用硬幣，dp[i] 仍為 INF  \n   No  → Step 5: 循環每個硬幣 coin in coins // 嘗試每一種面額  \n     → Decision: 如果 coin <= i? // 只能用小於等於剩餘金額的硬幣  \n      Yes → Step 6: 計算 newCount = dp[i-coin] + 1 // 使用此硬幣後的硬幣數  \n      → Decision: 如果 newCount < dp[i]? // 若比目前已知更少  \n       Yes → Step 7: 更新 dp[i] = newCount // 儲存最少硬幣數  \n       No  → 跳過更新 // 保留較小的值  \n      No  → 跳過此硬幣 // 不能用此硬幣  \n→ Step 8: 循環結束 // 所有金額已計算完畢  \n→ Decision: 如果 dp[amount] 等於 INF? // 仍無法組成目標金額  \n  Yes → Step 9: 輸出 -1 // 無法找出任何組合  \n  No  → Step 10: 輸出 dp[amount] // 輸出最少硬幣數  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"Maintain a dynamic stream of numbers and return median quickly.\"\"\"\n    def __init__(self):\n        # max‑heap for the lower half (store negatives)\n        self.small = []\n        # min‑heap for the upper half\n        self.large = []\n\n    def addNum(self, num: int):\n        # Push to max‑heap\n        heapq.heappush(self.small, -num)\n\n        # If both heaps non‑empty and the largest in small > smallest in large,\n        # swap them to maintain order property.\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # Balance sizes: small can have at most one more element than large.\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        # If total number of elements is odd, the median is top of small.\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        # If even, average the two middle values.\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    # Read entire stdin and strip whitespace\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # Wrap the two JSON arrays into a single list to parse easily\n    try:\n        ops, args = json.loads(f'[{raw_input}]')\n    except json.JSONDecodeError:\n        # In case the input is malformed, exit silently\n        return\n\n    output = []\n    obj = None  # instance of MedianFinder\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            output.append(None)\n        elif op == \"addNum\":\n            if obj is not None:\n                obj.addNum(arg[0])\n            output.append(None)\n        elif op == \"findMedian\":\n            if obj is not None:\n                median = obj.findMedian()\n                output.append(median)\n            else:\n                output.append(None)\n\n    # Convert Python None to JSON null for printing\n    print(json.dumps(output))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for median finder class with addNum and findMedian. Should be using two heaps approach. Provide step-by-step virtual code lines with explanations.\n\nWe need to output line by line: Start, etc. Should include the class definition steps? Probably:\n\nStart\n→ Step: Define MedianFinder class // create class\n→ Step: Initialize two heaps // max heap left, min heap right\n→ Step: addNum(num) // logic: if left empty or num <= top of left\n→ Decision...\n→ Step: findMedian() // if sizes equal -> average top of both, else return top of larger heap.\n\nWe need to use decision arrows. Ensure each line with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類別 // 建立 MedianFinder 物件  \n→ Step 2: 初始化左堆（最大堆）和右堆（最小堆） // 用來維持數值分布  \n→ Decision: 左堆是否為空？ // 檢查左堆是否沒有元素  \n  Yes → Step 3: 將 num 插入左堆 // 若左堆為空直接加入  \n  No  → Step 4: 如果 num ≤ 左堆頂點？ // 判斷 num 需要放在哪一邊  \n   Yes → Step 5: 將 num 插入左堆 // 小於等於左堆頂的放左堆  \n   No  → Step 6: 將 num 插入右堆 // 大於左堆頂的放右堆  \n→ Step 7: 平衡兩堆大小：如果左堆比右堆多 2 個元素？ // 檢查是否超過允許差距  \n  Yes → Step 8: 從左堆彈出頂點，插入右堆 // 將多餘的元素搬到右堆  \n  No  → Step 9: 平衡右堆（右堆比左堆多 2 個元素）?  \n   Yes → Step 10: 從右堆彈出頂點，插入左堆 // 將多餘的元素搬到左堆  \n   No → Step 11: 堆已平衡 // 無需動作  \n→ End // addNum 執行結束  \n\n→ Step 12: 定義 findMedian 函式 // 取得目前中位數  \n→ Decision: 左堆大小是否等於右堆大小？ // 判斷堆大小是否相等  \n  Yes → Step 13: 回傳 (左堆頂 + 右堆頂) / 2.0 // 兩堆相等時平均兩頂點  \n  No  → Step 14: 若左堆大小大於右堆大小？ // 決定哪一邊元素多  \n   Yes → Step 15: 回傳 左堆頂 // 左堆多時左堆頂即為中位數  \n   No  → Step 16: 回傳 右堆頂 // 右堆多時右堆頂即為中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Set Mismatch",
      "source_file": "Leetcode/leetcode645.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2,4]",
          "expected_output": "[2,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3]'\nGot (Norm):      '[2,5]'\n--- (Raw) ---\nRaw Expected: '[2,3]'\nRaw Got:      '[2, 5]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,2]'\nGot (Norm):      '[1,3]'\n--- (Raw) ---\nRaw Expected: '[1,2]'\nRaw Got:      '[1, 3]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def findErrorNums(self, nums: List[int]) -> List[int]:\n        \"\"\"\n        Find the duplicated number and the missing number in the array.\n        Uses a set to detect duplicates and arithmetic sum to compute the missing number.\n        \"\"\"\n        n = len(nums)\n        seen = set()\n        duplicate = -1\n\n        for num in nums:\n            if num in seen:\n                duplicate = num          # duplicate found\n            else:\n                seen.add(num)\n\n        # Sum of 1..n\n        total = n * (n + 1) // 2\n        # Sum of all numbers in the array\n        sum_nums = sum(nums)\n        # Sum of unique numbers (excluding duplicate)\n        sum_unique = sum(seen)\n\n        missing = total - (sum_unique - duplicate)\n        return [duplicate, missing]\n\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse the list of numbers,\n    invoke the solution, and print the result.\n    Expected input format examples:\n        nums = [1,2,2,4]\n        [1,1]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Attempt to extract the list part from the input string\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_str = list_part.strip()\n    else:\n        list_str = data.strip()\n\n    # Safely evaluate the list string\n    try:\n        nums = eval(list_str, {\"__builtins__\": None}, {})\n    except Exception:\n        # If eval fails, exit silently\n        return\n\n    result = Solution().findErrorNums(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that finds duplicate and missing numbers in array 1..n with one duplicate and one missing. The output array [duplicate, missing]. Provide step-by-step virtual code lines. Must use Start, End, Decision, arrows, etc. Provide explanation after space. Must not output real code. Just pseudo steps. Let's produce algorithm:\n\nStart\n→ Step 1: Initialize two variables: duplicate = -1, missing = -1\n→ Step 2: Initialize array visited of size n+1 all false (or a set)\n→ Step 3: For each number num in nums:\n→ Decision: If visited[num] is true? // already seen\n→     Yes → Set duplicate = num // record duplicate\n→     No  → Set visited[num] = true\n→ Step 4: For i from 1 to n:\n→ Decision: If visited[i] is false? // not seen\n→     Yes → Set missing = i\n→ End // output [duplicate, missing]\n\nBut must be line by line with arrows and explanations. Use virtual code syntax: Start, → Step, Decision, Yes →, No →, End. Let's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 duplicate = -1, missing = -1 // 初始化重複與遺失數字變數  \n→ Step 2: 建立布林陣列 visited[1..n] 全為 false // 用來標記每個數字是否已出現  \n→ Step 3: 對陣列 nums 中每個 num 執行  \n→     Decision: visited[num] 是否為 true? // 判斷此數字是否已被標記  \n→         Yes → Step 4: duplicate = num // 若已標記，表示此數字重複  \n→         No  → Step 5: visited[num] = true // 若未標記，將其標記為已出現  \n→ Step 6: 迴圈 i 從 1 到 n  \n→     Decision: visited[i] 是否為 false? // 判斷此數字是否未出現  \n→         Yes → Step 7: missing = i // 未出現即為遺失數字  \n→ End // 程式執行結束，輸出 [duplicate, missing]"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '7'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # dp[i] 表示組合成 i 的方式數量\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 基本情況：目標為 0 時有 1 種方式（空組合）\n\n        # 先按外層遍歷 nums，再內層累加到 target\n        for num in nums:\n            for i in range(num, target + 1):\n                dp[i] += dp[i - num]\n        return dp[target]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 假設輸入格式為 \"nums = [1,2,3], target = 4\"\n    parts = raw.split(', target = ')\n    nums_part = parts[0].strip()\n    target_part = parts[1].strip()\n\n    # 取得數字清單\n    nums_str = nums_part[len('nums ='):].strip()\n    nums = ast.literal_eval(nums_str)\n\n    # 取得目標值\n    target = int(target_part)\n\n    # 計算結果並輸出\n    sol = Solution()\n    result = sol.combinationSum4(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need virtual code for computing number of combinations to sum to target given distinct integers array. Classic combination sum count using DP: dp[0]=1, for each num in nums, for i from num to target: dp[i] += dp[i-num]. Return dp[target].\n\nWe need to produce step-by-step virtual code with explanations. Each line: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision etc. We need to include arrays, loops. The code is pseudo, but we must follow format.\n\nWe should outline steps: Start, Input array and target, Initialize dp array of size target+1 with zeros, Set dp[0]=1, Loop over each num in nums, inner loop from num to target, update dp[i] += dp[i-num], After loops, result = dp[target], Output result, End.\n\nWe might also include decision if target==0? etc. But can keep simple.\n\nEnsure each line ends with comment. Use arrow for loops: \"→ For each num in nums:\" etc.\n\nLet's produce. Use Start, End. Include Decision: maybe if nums empty? but not necessary.\n\nI'll produce:\n\nStart\n→ Input nums, target\n→ Decision: If target < 0? No → etc but we can skip.\n\nWe'll just produce.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Input nums, target // 取得使用者輸入的數字陣列與目標值\n→ Decision: 如果 target 為負? // 檢查目標是否為負數\n    Yes → Return 0 // 負數無法組合，直接回傳 0\n    No  → // 繼續以下步驟\n→ Initialize dp array of size target+1 with 0 // 建立 DP 陣列存儲子問題解\n→ Set dp[0] = 1 // 目標為 0 時有一種組合（空組合）\n→ For each num in nums: // 遍歷每個可用數字\n    → For i from num to target: // 由小到大累加\n        → dp[i] = dp[i] + dp[i-num] // 更新到 i 的組合數\n→ Set result = dp[target] // 目標值的組合數\n→ Output result // 顯示結果\nEnd // 程式執行結束"
    },
    {
      "title": "Range Module",
      "source_file": "Leetcode/leetcode715.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "RangeModule rangeModule = new RangeModule();\\nrangeModule.addRange(10, 20);\\nrangeModule.removeRange(14, 16);\\nrangeModule.queryRange(10, 14);\\nrangeModule.queryRange(13, 15);\\nrangeModule.queryRange(16, 17);",
          "expected_output": "[null, null, null, true, false, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,true,false,true]'\nGot (Norm):      '[null]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, true, false, true]'\nRaw Got:      '[null]'"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass RangeModule:\n    def __init__(self):\n        self.ranges = []\n\n    def addRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        placed = False\n        for l, r in self.ranges:\n            if r < left:\n                new_ranges.append([l, r])\n            elif right < l:\n                if not placed:\n                    new_ranges.append([left, right])\n                    placed = True\n                new_ranges.append([l, r])\n            else:\n                left = min(left, l)\n                right = max(right, r)\n        if not placed:\n            new_ranges.append([left, right])\n        self.ranges = new_ranges\n\n    def queryRange(self, left: int, right: int) -> bool:\n        i = bisect.bisect_right(self.ranges, [left, float('inf')])\n        if i == 0:\n            return False\n        return self.ranges[i-1][0] <= left and right <= self.ranges[i-1][1]\n\n    def removeRange(self, left: int, right: int) -> None:\n        new_ranges = []\n        for l, r in self.ranges:\n            if r <= left or l >= right:\n                new_ranges.append([l, r])\n            else:\n                if l < left:\n                    new_ranges.append([l, left])\n                if r > right:\n                    new_ranges.append([right, r])\n        self.ranges = new_ranges\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # Split by semicolon or newline and strip whitespace\n    commands = []\n    for part in data.replace('\\r', '').split(';'):\n        line = part.strip()\n        if line:\n            commands.append(line)\n\n    module = None\n    outputs = []\n\n    for cmd in commands:\n        if cmd.startswith('RangeModule'):\n            # Instantiate the module\n            module = RangeModule()\n            outputs.append(None)\n        elif cmd.startswith('rangeModule.addRange'):\n            nums = cmd[cmd.find('(')+1:cmd.find(')')]\n            left, right = map(int, nums.split(','))\n            module.addRange(left, right)\n            outputs.append(None)\n        elif cmd.startswith('rangeModule.removeRange'):\n            nums = cmd[cmd.find('(')+1:cmd.find(')')]\n            left, right = map(int, nums.split(','))\n            module.removeRange(left, right)\n            outputs.append(None)\n        elif cmd.startswith('rangeModule.queryRange'):\n            nums = cmd[cmd.find('(')+1:cmd.find(')')]\n            left, right = map(int, nums.split(','))\n            res = module.queryRange(left, right)\n            outputs.append(res)\n\n    # Convert outputs to the required string format\n    def conv(x):\n        if x is None:\n            return 'null'\n        if x is True:\n            return 'true'\n        if x is False:\n            return 'false'\n        return str(x)\n\n    print('[' + ', '.join(conv(o) for o in outputs) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for implementing RangeModule. Should be virtual code, step-by-step lines with explanation. We can design with tree/interval tree or sorted list of non-overlapping intervals. We'll produce steps: start, initialize data structure (maybe sorted list), addRange, queryRange, removeRange, end.\n\nEach line includes \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows and Decision. Let's outline:\n\nStart\n\n→ Step 1: Initialize an empty sorted list intervals // list of [l,r)\n\n→ addRange method: takes left,right\n\n→ Step: Find position to insert left, using binary search for intervals that overlap.\n\n→ Merge overlapping intervals with [left,right] and remove old intervals.\n\n→ Insert merged interval.\n\n→ queryRange: binary search to find interval that could contain left\n\n→ If found interval's right >= right, return true else false.\n\n→ removeRange: find overlapping intervals\n\n→ If interval fully inside [left,right], remove it\n\n→ If interval partially overlaps left side, shrink to [old_l, left)\n\n→ If partially overlaps right side, shrink to [right, old_r)\n\n→ Handle splitting intervals that cover [left,right] entirely: split into two [old_l,left) and [right,old_r)\n\n→ End\n\nWe need to output line by line. We need to decide what format: each line a virtual code step. The pseudo includes methods and maybe loops. We can produce hierarchical lines with indentation using spaces or newlines. Each line has arrow arrow? In sample, they used \"→ Step 1: ...\". We'll use \"→\" for steps. For decisions, use \"Decision:\".\n\nLet's produce for initialization:\n\nStart // 程式開始執行\n\n→ Step 1: 定義空的 sorted list intervals // 儲存已追蹤的半開區間\n\nDefine RangeModule() // 初始化物件\n\n→ Step 2: intervals ← [] // 空列表\n\nNow methods:\n\n→ Step 3: 方法 addRange(left, right) // 加入區間\n\nInside addRange:\n\n→ Step 4: i ← binarySearchLeft(intervals, left) // 找到可能重疊的起點\n\n→ Step 5: newLeft ← left // 初始化合併區間左端\n\n→ Step 6: newRight ← right // 初始化合併區間右端\n\n→ Step 7: While i < len(intervals) and intervals[i].left <= right: // 遍歷所有重疊區間\n\n    → Decision: intervals[i].left <= right? // 是否與新區間重疊\n\n        Yes → Step 8: newLeft ← min(newLeft, intervals[i].left) // 更新左端\n\n        Yes → Step 9: newRight ← max(newRight, intervals[i].right) // 更新右端\n\n        Yes → Step 10: remove intervals[i] // 刪除舊區間\n\n        Yes → Step 11: i ← i - 1 // 後面移動指標回調\n\n        No\n\n→ Step 12: insert new interval [newLeft, newRight] at position i+1 // 插入合併後區間\n\nSimilar for queryRange:\n\n→ Step 13: 方法 queryRange(left, right)\n\n→ Step 14: i ← binarySearchRight(intervals, left) // 找到左側可能覆蓋的區間\n\n→ Step 15: If i < len(intervals) and intervals[i].left <= left and intervals[i].right >= right:\n\n    → Step 16: return true // 完全覆蓋\n\n→ Step 17: return false // 未完全覆蓋\n\nRemoveRange:\n\n→ Step 18: 方法 removeRange(left, right)\n\n→ Step 19: i ← binarySearchLeft(intervals, left)\n\n→ Step 20: While i < len(intervals) and intervals[i].left < right:\n\n    → Decision: intervals[i].right <= left? // 完全在左側\n\n        Yes → i ← i + 1 // 跳過\n\n        No → Decision: intervals[i].left >= right? // 完全在右側\n\n            Yes → Break // 無需繼續\n\n            No → Decision: intervals[i].left < left and intervals[i].right > right? // 包含整個區間\n\n                Yes → Step 21: split into [intervals[i].left, left) and [right, intervals[i].right)\n\n                Yes → Step 22: intervals[i] ← [intervals[i].left, left) // 更新左半段\n\n                Yes → Step 23: insert [right, intervals[i].right) after i\n\n                No → Decision: intervals[i].left < left? // 左側重疊\n\n                    Yes → Step 24: intervals[i].right ← left // 截短右端\n\n                    No\n\n                No → Decision: intervals[i].right > right? // 右側重疊\n\n                    Yes → Step 25: intervals[i].left ← right // 截短左端\n\n                    No\n\n                No\n\n→ Step 26: End\n\nWe need to include End // 程式執行結束\n\nBut we need to keep hierarchical lines. In sample they had indentation after Decision. We'll mimic.\n\nMake sure each line has \"虛擬碼步驟\" and comment.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空的 sorted list intervals // 儲存已追蹤的半開區間  \n\nRangeModule() // 初始化物件  \n→ Step 2: intervals ← [] // 先建立一個空的區間列表  \n\naddRange(left, right) // 加入區間  \n→ Step 3: i ← binarySearchLeft(intervals, left) // 找到第一個可能與新區間重疊的區間位置  \n→ Step 4: newLeft ← left // 初始合併區間左端  \n→ Step 5: newRight ← right // 初始合併區間右端  \n→ Step 6: While i < len(intervals) and intervals[i].left <= right: // 遍歷所有重疊的區間  \n  Decision: intervals[i].left <= right? // 判斷是否與新區間重疊  \n   Yes → Step 7: newLeft ← min(newLeft, intervals[i].left) // 更新左端  \n   Yes → Step 8: newRight ← max(newRight, intervals[i].right) // 更新右端  \n   Yes → Step 9: remove intervals[i] // 刪除舊區間  \n   Yes → Step 10: i ← i - 1 // 由於刪除，索引回調一位以便再次檢查  \n   No  \n→ Step 11: insert new interval [newLeft, newRight] at position i+1 // 將合併後的區間插入列表  \n\nqueryRange(left, right) // 查詢區間是否完全被追蹤  \n→ Step 12: i ← binarySearchRight(intervals, left) // 找到左端可能被覆蓋的區間  \n→ Step 13: Decision: i < len(intervals) and intervals[i].left <= left and intervals[i].right >= right? // 檢查該區間是否覆蓋整個查詢範圍  \n  Yes → Step 14: return true // 完全覆蓋  \n  No → Step 15: return false // 未完全覆蓋  \n\nremoveRange(left, right) // 移除區間  \n→ Step 16: i ← binarySearchLeft(intervals, left) // 找到第一個可能與要移除區間重疊的區間  \n→ Step 17: While i < len(intervals) and intervals[i].left < right: // 只需考慮左側小於右端的區間  \n  Decision: intervals[i].right <= left? // 完全在左側，無需處理  \n   Yes → i ← i + 1 // 跳過此區間  \n   No → Decision: intervals[i].left >= right? // 完全在右側，結束循環  \n    Yes → Break  \n    No → Decision: intervals[i].left < left and intervals[i].right > right? // 包含整個要移除區間  \n     Yes → Step 18: split intervals[i] into [intervals[i].left, left) and [right, intervals[i].right)  \n     Yes → Step 19: intervals[i] ← [intervals[i].left, left) // 更新左半段  \n     Yes → Step 20: insert [right, intervals[i].right) after i // 插入右半段  \n     No → Decision: intervals[i].left < left? // 左側有重疊  \n      Yes → Step 21: intervals[i].right ← left // 截短右端到左端  \n      No  \n     No → Decision: intervals[i].right > right? // 右側有重疊  \n      Yes → Step 22: intervals[i].left ← right // 截短左端到右端  \n      No  \n     No  \n    No  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Circular Deque",
      "source_file": "Leetcode/leetcode641.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]",
          "expected_output": "[null, true, true, true, false, 2, true, true, true, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_oc29a6o.py\", line 90, in <module>\n    main()\n  File \"/tmp/tmp_oc29a6o.py\", line 65, in main\n    ops = ast.literal_eval(ops_line)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"MyCircularDeque\", \"insertLast\", \"insertLast\", \"insertFront\", \"insertFront\", \"getRear\", \"isFull\", \"deleteLast\", \"insertFront\", \"getFront\"]\\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n                                                                                                                                                ^\nSyntaxError: unexpected character after line continuation character"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyCircularDeque:\n    def __init__(self, k):\n        self.k = k\n        self.buf = [0] * k\n        self.head = 0\n        self.count = 0\n\n    def insertFront(self, value):\n        if self.count == self.k:\n            return False\n        self.head = (self.head - 1) % self.k\n        self.buf[self.head] = value\n        self.count += 1\n        return True\n\n    def insertLast(self, value):\n        if self.count == self.k:\n            return False\n        idx = (self.head + self.count) % self.k\n        self.buf[idx] = value\n        self.count += 1\n        return True\n\n    def deleteFront(self):\n        if self.count == 0:\n            return False\n        self.head = (self.head + 1) % self.k\n        self.count -= 1\n        return True\n\n    def deleteLast(self):\n        if self.count == 0:\n            return False\n        self.count -= 1\n        return True\n\n    def getFront(self):\n        if self.count == 0:\n            return -1\n        return self.buf[self.head]\n\n    def getRear(self):\n        if self.count == 0:\n            return -1\n        idx = (self.head + self.count - 1) % self.k\n        return self.buf[idx]\n\n    def isEmpty(self):\n        return self.count == 0\n\n    def isFull(self):\n        return self.count == self.k\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops_line = data[0]\n    args_line = data[1] if len(data) > 1 else '[]'\n\n    ops = ast.literal_eval(ops_line)\n    args_list = ast.literal_eval(args_line)\n\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MyCircularDeque\":\n            obj = MyCircularDeque(*args)\n            res.append(None)\n        else:\n            func = getattr(obj, op)\n            ret = func(*args)\n            res.append(ret)\n\n    out = []\n    for val in res:\n        if val is None:\n            out.append('null')\n        elif isinstance(val, bool):\n            out.append('true' if val else 'false')\n        else:\n            out.append(str(val))\n    print('[' + ','.join(out) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code, step by step, with each line having \"虛擬碼步驟 // 解釋\". Use arrow →, Decision: etc. It's design of circular double-ended queue. We need to describe the implementation: probably using array and front/back indices, with size variable. Provide pseudocode for class and methods. Each step maybe each line of pseudocode. We should produce sequential lines, with indent for Decision. Use Start/End.\n\nWe need to produce a design; not actual code. Each line must contain virtual code step + // explanation. Use arrow.\n\nLet's produce a structured pseudocode for the class MyCircularDeque.\n\nStart\n→ Step 1: Declare class MyCircularDeque // 定義類別\n→ Step 2: Declare array items of size k // 儲存元素的固定大小陣列\n→ Step 3: Declare integer front = 0 // 指向前端位置\n→ Step 4: Declare integer rear = 0 // 指向後端位置\n→ Step 5: Declare integer count = 0 // 當前元素數量\n\nThen constructor:\n→ Step 6: MyCircularDeque(int k) // 初始化\n    → Step 7: Set items = new array of size k // 建立陣列\n    → Step 8: Set front = 0 // 前端指標初始值\n    → Step 9: Set rear = 0 // 後端指標初始值\n    → Step 10: Set count = 0 // 元素數量初始值\n\nInsertFront:\n→ Step 11: boolean insertFront(int value) // 添加到前端\n    → Step 12: Decision: If isFull()?\n        Yes → Step 13: Return false // 不成功\n        No  → Step 14: front = (front - 1 + k) mod k // 前移\n        → Step 15: items[front] = value // 放值\n        → Step 16: count = count + 1 // 增加數量\n        → Step 17: Return true\n\nInsertLast:\n→ Step 18: boolean insertLast(int value) // 添加到後端\n    → Step 19: Decision: If isFull()?\n        Yes → Step 20: Return false\n        No  → Step 21: items[rear] = value // 放值\n        → Step 22: rear = (rear + 1) mod k // 後移\n        → Step 23: count = count + 1\n        → Step 24: Return true\n\nDeleteFront:\n→ Step 25: boolean deleteFront() // 刪除前端\n    → Step 26: Decision: If isEmpty()?\n        Yes → Step 27: Return false\n        No  → Step 28: front = (front + 1) mod k // 前移\n        → Step 29: count = count - 1\n        → Step 30: Return true\n\nDeleteLast:\n→ Step 31: boolean deleteLast() // 刪除後端\n    → Step 32: Decision: If isEmpty()?\n        Yes → Step 33: Return false\n        No  → Step 34: rear = (rear - 1 + k) mod k // 後移\n        → Step 35: count = count - 1\n        → Step 36: Return true\n\nGetFront:\n→ Step 37: int getFront() // 取得前端值\n    → Step 38: Decision: If isEmpty()?\n        Yes → Step 39: Return -1\n        No  → Step 40: Return items[front] // 返回前端值\n\nGetRear:\n→ Step 41: int getRear() // 取得後端值\n    → Step 42: Decision: If isEmpty()?\n        Yes → Step 43: Return -1\n        No  → Step 44: index = (rear - 1 + k) mod k // 後端指標實際位置\n        → Step 45: Return items[index] // 返回後端值\n\nIsEmpty:\n→ Step 46: boolean isEmpty() // 判斷是否為空\n    → Step 47: Return count == 0\n\nIsFull:\n→ Step 48: boolean isFull() // 判斷是否為滿\n    → Step 49: Return count == k\n\nEnd\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". Use Start and End. Also use arrow. For decisions, indent with tabs or spaces. Use \"Decision:\" line and then Yes → ... No → ... lines. Use \"→\" before each step. Provide all lines. Ensure no actual code, just virtual.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Declare class MyCircularDeque // 定義類別  \n→ Step 2: Declare array items of size k // 用固定大小陣列儲存元素  \n→ Step 3: Declare integer front = 0 // 前端指標初始位置  \n→ Step 4: Declare integer rear = 0 // 後端指標初始位置  \n→ Step 5: Declare integer count = 0 // 當前元素數量  \n\n→ Step 6: MyCircularDeque(int k) // 建構子，初始化資料結構  \n  → Step 7: Set items = new array of size k // 建立陣列  \n  → Step 8: Set front = 0 // 前端指標重設  \n  → Step 9: Set rear = 0 // 後端指標重設  \n  → Step 10: Set count = 0 // 元素數量重設  \n\n→ Step 11: boolean insertFront(int value) // 在前端插入元素  \n  → Step 12: Decision: If isFull()? // 檢查是否已滿  \n   Yes → Step 13: Return false // 插入失敗  \n   No  → Step 14: front = (front - 1 + k) mod k // 前指標前移（環形）  \n    → Step 15: items[front] = value // 放入新值  \n    → Step 16: count = count + 1 // 元素數量加一  \n    → Step 17: Return true // 插入成功  \n\n→ Step 18: boolean insertLast(int value) // 在後端插入元素  \n  → Step 19: Decision: If isFull()? // 檢查是否已滿  \n   Yes → Step 20: Return false // 插入失敗  \n   No  → Step 21: items[rear] = value // 放入新值  \n    → Step 22: rear = (rear + 1) mod k // 後指標後移（環形）  \n    → Step 23: count = count + 1 // 元素數量加一  \n    → Step 24: Return true // 插入成功  \n\n→ Step 25: boolean deleteFront() // 從前端刪除元素  \n  → Step 26: Decision: If isEmpty()? // 檢查是否為空  \n   Yes → Step 27: Return false // 刪除失敗  \n   No  → Step 28: front = (front + 1) mod k // 前指標後移（環形）  \n    → Step 29: count = count - 1 // 元素數量減一  \n    → Step 30: Return true // 刪除成功  \n\n→ Step 31: boolean deleteLast() // 從後端刪除元素  \n  → Step 32: Decision: If isEmpty()? // 檢查是否為空  \n   Yes → Step 33: Return false // 刪除失敗  \n   No  → Step 34: rear = (rear - 1 + k) mod k // 後指標前移（環形）  \n    → Step 35: count = count - 1 // 元素數量減一  \n    → Step 36: Return true // 刪除成功  \n\n→ Step 37: int getFront() // 取得前端元素值  \n  → Step 38: Decision: If isEmpty()? // 檢查是否為空  \n   Yes → Step 39: Return -1 // 無元素返回 -1  \n   No  → Step 40: Return items[front] // 返回前端值  \n\n→ Step 41: int getRear() // 取得後端元素值  \n  → Step 42: Decision: If isEmpty()? // 檢查是否為空  \n   Yes → Step 43: Return -1 // 無元素返回 -1  \n   No  → Step 44: index = (rear - 1 + k) mod k // 計算實際後端位置  \n    → Step 45: Return items[index] // 返回後端值  \n\n→ Step 46: boolean isEmpty() // 判斷是否為空  \n  → Step 47: Return count == 0 // 若計數為零即為空  \n\n→ Step 48: boolean isFull() // 判斷是否為滿  \n  → Step 49: Return count == k // 若計數等於容量即為滿  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_ilp_u7j.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmp_ilp_u7j.py\", line 41, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                child = node.children.get(word[i])\n                if child is None:\n                    return False\n                return dfs(child, i + 1)\n        return dfs(self.root, 0)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = json.loads(data)\n    obj = None\n    result = []\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            result.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            result.append(None)\n        elif op == \"search\":\n            res = obj.search(arg[0])\n            result.append(res)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a WordDictionary that supports addWord and search with '.' wildcard. Use a trie.\n\nSteps: Start, initialize root node with children dict and isWord flag. addWord: iterate characters, create node if missing, mark isWord true. search: recursion or DFS over trie, handle '.' by exploring all children.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows. We'll produce a step-by-step algorithm. Use Decision, recursion.\n\nWe should output step by step for WordDictionary class, maybe pseudo-construct. Use indentation? In sample, indentation is spaces for decisions. We'll replicate similar.\n\nMake sure each line has \"→\" arrow at beginning for steps, or \"Decision:\" lines. Provide comments.\n\nLet's create:\n\nStart\n→ Class WordDictionary // 定義 WordDictionary\n    → Node Structure: children[26], isWord // Trie 節點\n→ Method: WordDictionary() // 建構子\n    → root ← new Node // 初始化根節點\n→ Method: addWord(word) // 添加單字\n    → current ← root\n    → For each char c in word:\n        → If current.children[c] is null:\n            → current.children[c] ← new Node\n        → current ← current.children[c]\n    → current.isWord ← true // 標記完整單字\n→ Method: search(word) // 搜尋單字\n    → Return DFS(0, root, word) // 開始遞迴\n→ Function: DFS(index, node, word)\n    → Decision: index == length(word)?\n        Yes → Return node.isWord // 完成字串檢查\n        No  → Decision: word[index] == '.' ?\n            Yes → // 點號，遍歷所有子節點\n                → For each child in node.children:\n                    → If child != null and DFS(index+1, child, word) == true:\n                        → Return true\n                → Return false\n            No  → // 普通字母\n                → child ← node.children[word[index]]\n                → Decision: child == null?\n                    Yes → Return false\n                    No  → Return DFS(index+1, child, word)\nEnd\n\nAlso include Start and End.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Class WordDictionary // 定義 WordDictionary 類別\n    → Node: children[26], isWord // Trie 節點結構\n→ Method WordDictionary() // 建構子\n    → root ← new Node // 初始化根節點\n→ Method addWord(word) // 添加新單字\n    → current ← root\n    → For each character c in word:\n        → If current.children[c] == null:\n            → current.children[c] ← new Node\n        → current ← current.children[c]\n    → current.isWord ← true // 標記完整單字\n→ Method search(word) // 搜尋字串，可能含 '.' 通配符\n    → Return DFS(0, root, word) // 從根節點開始遞迴搜尋\n→ Function DFS(index, node, word) // 以 index 為目前位置進行遞迴\n    → Decision: index == length(word)? // 已到字串結尾\n        Yes → Return node.isWord // 若節點標記為單字則匹配成功\n        No  → Decision: word[index] == '.'? // 字元為通配符\n            Yes → // 遍歷所有子節點\n                → For each child in node.children:\n                    → If child != null and DFS(index+1, child, word) == true:\n                        → Return true\n                → Return false // 沒有子節點能匹配\n            No  → // 字元為具體字母\n                → child ← node.children[word[index]]\n                → Decision: child == null? // 沒有對應節點\n                    Yes → Return false // 匹配失敗\n                    No  → Return DFS(index+1, child, word) // 進行下一層遞迴\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp67x3bsb3.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmp67x3bsb3.py\", line 57, in main\n    result = multiply_complex(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp67x3bsb3.py\", line 20, in multiply_complex\n    a_real, a_imag = parse_complex(a)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp67x3bsb3.py\", line 11, in parse_complex\n    raise ValueError(f\"無效的複數字串: {s}\")\nValueError: 無效的複數字串: 1+-1i"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef parse_complex(s: str):\n    \"\"\"\n    解析形如 real+imagi 的複數字串，回傳 (real, imag) 整數對。\n    支援正負號，例如 \"-3-2i\" 或 \"1+-1i\"。\n    \"\"\"\n    m = re.fullmatch(r'([+-]?\\d+)([+-]\\d+)i', s)\n    if not m:\n        raise ValueError(f\"無效的複數字串: {s}\")\n    real = int(m.group(1))\n    imag = int(m.group(2))\n    return real, imag\n\ndef multiply_complex(a: str, b: str):\n    \"\"\"\n    計算兩個複數字串的乘積，並以字串形式回傳。\n    \"\"\"\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n\n    real_part = a_real * b_real - a_imag * b_imag\n    imag_part = a_real * b_imag + a_imag * b_real\n\n    # 虛部符號處理\n    if imag_part >= 0:\n        sign = '+'\n    else:\n        sign = ''  # 負號已包含於 imag_part\n\n    return f\"{real_part}{sign}{imag_part}i\"\n\ndef main():\n    \"\"\"\n    從標準輸入讀取兩個複數字串，計算乘積並輸出結果。\n    輸入格式預期為形如\n        \"1+1i\", \"1+1i\"\n    或是兩行分別給出：\n        1+1i\n        1+1i\n    \"\"\"\n    data = sys.stdin.read().strip()\n\n    # 先嘗試找出被雙引號包住的字串\n    quoted = re.findall(r'\"([^\"]+)\"', data)\n    if len(quoted) >= 2:\n        num1, num2 = quoted[0], quoted[1]\n    else:\n        # 直接以逗號或換行分割\n        parts = re.split(r',|\\n', data)\n        if len(parts) < 2:\n            raise ValueError(\"輸入不足兩個複數\")\n        num1 = parts[0].strip().strip('\"')\n        num2 = parts[1].strip().strip('\"')\n\n    result = multiply_complex(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo). We need to parse two strings \"a+bi\" format. Multiply complex numbers. Output \"real+imaginaryi\". Need to handle negative parts: strings may be like \"-3-2i\" maybe. Format: \"real+imaginaryi\" where real and imaginary parts integer range [-100,100]. So string could be \"1+1i\", \"-1-1i\", etc. So parse: split at '+', but if there is minus sign before imaginary part, it's actually \"real-imaginaryi\". But since format is \"real+imaginaryi\", maybe always plus sign. But imaginary part could be negative, so format like \"1-2i\". We'll parse accordingly: find last '+' or '-' before the 'i', but easier: replace 'i' with '', then split by '+'? Actually handle negative: we can parse by regex: ^([+-]?\\d+)([+-]\\d+)i$.\n\nThen compute multiplication: (a+bi)*(c+di)= (ac - bd) + (ad + bc)i.\n\nThen produce string: real + '+' or '-' + imaginary + 'i' with no spaces. But imaginary sign is included automatically. For imaginary part negative, string should be like \"real-2i\".\n\nEdge cases: if imaginary part 0, still produce e.g., \"3+0i\". And if real part 0, produce \"0+5i\".\n\nImplementation steps: parse numbers into integers a,b,c,d. Multiply. Output string.\n\nNow produce virtual code lines.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrow.\n\nSo: Start, Step to parse num1: Extract real1, imag1. Then parse num2 similarly. Then compute resultReal=real1*real2 - imag1*imag2. resultImag=real1*imag2 + imag1*real2. Then format string: result = resultReal + (if resultImag >=0 then \"+\" else \"\") + resultImag + \"i\". Then output result. End.\n\nNeed to show decision for sign formatting.\n\nWe need to use arrow arrows. E.g.:\n\nStart // 程式開始\n\n→ Step 1: Set temp1 = num1, temp2 = num2 // 取得輸入\n\n→ Step 2: Parse temp1 to real1, imag1 // 解析第一個複數\n\nUse regex or split.\n\nWe can use pseudo steps: replace 'i' with '', then find split between real and imag.\n\nBut we can provide step \"ParseComplex(str) → (real, imag)\" as a subroutine.\n\nSo we can define subroutine.\n\nLet's create a subroutine:\n\n→ Function ParseComplex(str) // 解析複數字串\n\n   → Replace 'i' with '' in str // 去除 i\n\n   → If str contains '+': split by '+' into realStr and imagStr // 正號\n\n   → Else: // 處理負號\n\n        Find last '-' before last char // handle negative imaginary part\n\n   → Convert realStr, imagStr to integers real, imag\n\n   → Return real, imag\n\nBut perhaps simpler: assume format always \"real+imaginaryi\" where imaginary part sign included. So we can just replace 'i', then split at last '+'? But if imag negative, there is '-' not '+', but then string has '-' sign. So we could split at '+' first; if no '+', split at '-' after first char? That is too complex.\n\nBetter: Use regex: real = match group1, imag = match group2.\n\nSo Step 2: Parse num1: real1 = int(match group1), imag1 = int(match group2)\n\nSimilarly for num2.\n\nThen Step 3: Compute multiplication.\n\nThen Step 4: Format.\n\nUse Decision: If resultImag >=0 → format with '+' else not.\n\nAlso could have decision: if resultReal==0? but we still output 0.\n\nLet's produce lines accordingly.\n\nMake sure to use \"→\" arrows. Also use Decision: etc.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Define function ParseComplex(str) // 解析複數字串\n\n    → Step 1.1: Remove trailing 'i' from str // 去除 i\n\n    → Step 1.2: Use regex pattern ^([+-]?\\d+)([+-]\\d+)$ to capture real and imag parts\n\n    → Step 1.3: Convert captured groups to integers real, imag\n\n    → Step 1.4: Return real, imag // 取得兩個整數\n\nEnd function\n\n→ Step 2: (real1, imag1) = ParseComplex(num1) // 解析第一個複數\n\n→ Step 3: (real2, imag2) = ParseComplex(num2) // 解析第二個複數\n\n→ Step 4: resultReal = real1 * real2 - imag1 * imag2 // 計算實部\n\n→ Step 5: resultImag = real1 * imag2 + imag1 * real2 // 計算虛部\n\n→ Step 6: If resultImag >= 0\n\n        Yes → sign = \"+\" // 正號\n\n        No  → sign = \"\" // 虛部負號已包含於數字\n\n→ Step 7: resultStr = resultReal + sign + resultImag + \"i\" // 組合輸出字串\n\n→ Step 8: Output resultStr // 回傳結果\n\nEnd // 程式結束\n\nBut need each line separate, not nested indent lines? But spec allows indentation? We can use nested but each line still \"虛擬碼步驟 // 解釋\". Use \"→\" for each step, but for subroutine we may need to indent? They didn't forbid indentation. But better to keep each line top-level arrow.\n\nWe can write subroutine as:\n\n→ Function ParseComplex(str) // 解析複數字串\n\n    → Step: ... // but we still need arrow? The spec: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" So inside function we may need to use similar arrow lines.\n\nWe can keep each line with \"→\" and indent by 4 spaces.\n\nBut maybe easier: Just inline parse steps in main: use a function concept but show as step.\n\nOk.\n\nLet's produce as:\n\nStart // 程式開始\n\n→ Step 1: Parse num1 to real1 and imag1 // 解析第一個複數字串\n\n→   → Remove trailing 'i' // 去除字串末尾的 i\n\n→   → Apply regex ^([+-]?\\d+)([+-]\\d+)$ to capture real and imag // 拆解實部與虛部\n\n→   → Convert captured groups to integers // 轉換為整數\n\n→   → Return real1, imag1 // 取得數值\n\nSimilarly for num2.\n\nBut maybe too nested.\n\nMaybe simpler: Provide step \"ParseComplex(str) → (real, imag) // 解析複數\" as one step.\n\nOk.\n\nLet's produce final answer with each line separate and arrow at start, explanation at end.\n\nEnsure no actual code.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始\n\n→ Function ParseComplex(str) // 解析複數字串，傳回實部與虛部\n→   → Remove trailing 'i' from str // 去除字串末尾的 i\n→   → Apply regex pattern ^([+-]?\\d+)([+-]\\d+)$ // 取得實部與虛部的兩個數字\n→   → Convert captured groups to integers real, imag // 轉成整數\n→   → Return real, imag // 傳回解析結果\n\n→ (real1, imag1) = ParseComplex(num1) // 解析第一個複數\n→ (real2, imag2) = ParseComplex(num2) // 解析第二個複數\n\n→ resultReal = real1 * real2 - imag1 * imag2 // 計算乘積的實部\n→ resultImag = real1 * imag2 + imag1 * real2 // 計算乘積的虛部\n\n→ Decision: resultImag >= 0? // 判斷虛部正負以決定符號\n    Yes → sign = \"+\" // 虛部為正，需加上正號\n    No  → sign = \"\" // 虛部為負，數字本身已含負號\n\n→ resultStr = resultReal + sign + resultImag + \"i\" // 組合成輸出字串\n\n→ Output resultStr // 回傳最終複數字串\n\nEnd // 程式結束"
    },
    {
      "title": "Find Duplicate File in System",
      "source_file": "Leetcode/leetcode609.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/4.txt\",\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/4.txt', 'root/a/2.txt', 'root/c/d/4.txt'], ['root/a/1.txt', 'root/c/3.txt']]\""
        },
        {
          "example_index": 1,
          "input": "paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]",
          "expected_output": "[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nGot (Norm):      '[[\"root/a/1.txt\",\"root/c/3.txt\"],[\"root/a/2.txt\",\"root/c/d/4.txt\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]'\nRaw Got:      \"[['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findDuplicate(self, paths):\n        \"\"\"\n        找出所有內容相同的檔案路徑群組。\n        :param paths: List[str]，每個元素為「目錄 路徑 內容」的字串\n        :return: List[List[str]]，每個子列表為相同內容的檔案完整路徑\n        \"\"\"\n        content_to_paths = defaultdict(list)\n\n        for entry in paths:\n            # 以空格分割，第一個是目錄路徑，其餘是檔案資訊\n            parts = entry.split()\n            if not parts:\n                continue\n            root = parts[0]\n            for file_info in parts[1:]:\n                # file_info 的格式為 \"name(content)\"\n                name, content = file_info.split('(')\n                content = content.rstrip(')')          # 去掉最後的 ')'\n                full_path = f\"{root}/{name}\"\n                content_to_paths[content].append(full_path)\n\n        # 只保留重複的群組\n        duplicates = [paths for paths in content_to_paths.values() if len(paths) > 1]\n        return duplicates\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n\n    # 取出列表字串（無論是否有「paths =」前綴）\n    left = raw_input.find('[')\n    right = raw_input.rfind(']')\n    if left == -1 or right == -1 or left > right:\n        paths = []\n    else:\n        list_str = raw_input[left:right + 1]\n        try:\n            paths = ast.literal_eval(list_str)\n        except Exception:\n            paths = []\n\n    # 呼叫解法\n    solution = Solution()\n    result = solution.findDuplicate(paths)\n\n    # 為了可預測輸出，對內部與外部做排序\n    result = [sorted(group) for group in result]\n    result.sort(key=lambda x: x[0] if x else \"\")\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving problem. Use structure. Provide line by line. Use arrows. Provide explanation after //.\n\nWe need algorithm: parse each directory string, split into parts: first part is path, rest are files with content. For each file, build full path and content. Use hash map content -> list of paths. After processing all, collect lists with size >1. Return list of lists.\n\nWe'll produce virtual code with Start, End. Use Decision: etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 `content_to_paths` // 用於存儲內容對應的檔案路徑清單  \n→ Step 2: 對於輸入列表 `paths` 中的每一個字串 `path_info`  \n  → Decision: 是否已處理完所有字串?  \n   No → Step 3: 把 `path_info` 用空格分割成陣列 `parts` // 第一項為目錄路徑，其餘為檔案與內容  \n    → Step 4: 設定 `directory` 為 `parts[0]` // 取得目錄完整路徑  \n    → Step 5: 從 `parts[1:]` 逐一處理每個 `file_info`  \n      → Step 6: 從 `file_info` 取出檔名 `file_name` 與內容 `file_content`（使用 `(` 與 `)` 分隔）  \n      → Step 7: 組合成完整檔案路徑 `full_path = directory + \"/\" + file_name`  \n      → Step 8: 若 `file_content` 未出現在 `content_to_paths`，則新增空清單  \n      → Step 9: 把 `full_path` 加入 `content_to_paths[file_content]`  \n      → Step 10: 回到 Step 5 處理下一個 `file_info`  \n    → Step 11: 回到 Step 3 處理下一個 `path_info`  \n    → Decision: 是否已處理完所有字串?  \n     Yes → End // 所有檔案已被索引  \nEnd // 迴圈結束，字典已填充  \nStart // 建立最終答案  \n→ Step 12: 建立空列表 `result`  \n→ Step 13: 對於字典 `content_to_paths` 的每個鍵值對 `content, paths_list`  \n  → Decision: `paths_list` 的長度是否大於 1?  \n   Yes → Step 14: 把 `paths_list` 加入 `result` // 只保留重複檔案組  \n   No → Skip // 只出現一次的內容不加入  \n→ Step 15: 回傳 `result` // 輸出所有重複檔案路徑群組  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaxio3a11.py\", line 83, in <module>\n    main()\n  File \"/tmp/tmpaxio3a11.py\", line 59, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport json\n\nclass TrieNode:\n    \"\"\"節點結構，包含子節點字典與是否為單詞結束的標記\"\"\"\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        \"\"\"初始化 Trie，建立根節點\"\"\"\n        self.root = TrieNode()\n\n    def insert(self, word: str):\n        \"\"\"將單詞插入 Trie\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        \"\"\"檢查單詞是否已完全存在於 Trie\"\"\"\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"檢查是否存在以 prefix 為前綴的單詞\"\"\"\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得兩個列表字串（操作與參數）\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) >= 2:\n        ops_str, args_str = lists[0], lists[1]\n    else:\n        # 若無法正確拆分，嘗試直接分割\n        parts = data.split(',', 1)\n        ops_str, args_str = parts[0], parts[1]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    trie = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            output.append(None)\n        elif op == 'insert':\n            word = arg[0] if isinstance(arg, list) else arg\n            trie.insert(word)\n            output.append(None)\n        elif op == 'search':\n            word = arg[0] if isinstance(arg, list) else arg\n            output.append(trie.search(word))\n        elif op == 'startsWith':\n            prefix = arg[0] if isinstance(arg, list) else arg\n            output.append(trie.startsWith(prefix))\n\n    # 以 JSON 格式輸出，None 會轉成 null，True/False 轉成 true/false\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation, step by step, for a Trie class with methods: constructor, insert, search, startsWith. Provide pseudo-code lines. Use Start, End, Decision. Provide arrow and explanation. Must be in Traditional Chinese.\n\nWe should include definitions of node structure. Each line: \"虛擬碼步驟 // 解釋\". Let's produce code.\n\nWe need to outline: Node has children array/dict, isEnd flag.\n\nWe need steps for Insert: iterate characters, create child if not exists, move, finally set isEnd.\n\nSearch: iterate, if child missing return false, else after loop return node.isEnd.\n\nstartsWith: similar but no need to check isEnd.\n\nAlso include main class structure.\n\nLet's produce.\n\nWe need \"Start\" at top, maybe \"Start // 程式開始\". Then define class Trie and its constructor. Then methods.\n\nBetter to break into sections.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義節點結構 Node { children: map, isEnd: bool } // 節點包含子節點與終止標記\n→ Step 2: 定義類別 Trie\n    → Step 3: Trie() 初始化 root = new Node() // 根節點\n    → Step 4: insert(word) // 插入單詞\n        → Step 5: current = root\n        → Decision: 迭代每個字元 c in word? // 逐字處理\n            → Yes → Step 6: 如果 current.children 沒有 c 則 current.children[c] = new Node() // 建立子節點\n            → Yes → Step 7: current = current.children[c] // 移動到子節點\n        → Step 8: current.isEnd = true // 標記單詞結束\n    → Step 9: search(word) // 搜尋單詞\n        → Step 10: current = root\n        → Decision: 迭代每個字元 c in word?\n            → Yes → Step 11: 如果 current.children 沒有 c 則 return false // 找不到字元\n            → Yes → Step 12: current = current.children[c]\n        → Step 13: return current.isEnd // 只若終止標記為 true 才為真\n    → Step 14: startsWith(prefix) // 前綴搜尋\n        → Step 15: current = root\n        → Decision: 迭代每個字元 c in prefix?\n            → Yes → Step 16: 如果 current.children 沒有 c 則 return false // 找不到字元\n            → Yes → Step 17: current = current.children[c]\n        → Step 18: return true // 已成功遍歷完前綴\nEnd // 程式結束\n\nBut we must include arrows and \"Yes →\" \"No →\" lines. The Decision lines can be like:\n\nDecision: 迭代每個字元 c in word? // 逐字處理\n    Yes → Step 6...\n    No  → ??? No? But we don't need No branch for iteration; maybe we can just show loop structure. But we can show that for each char, we check and create.\n\nBetter structure: Use a while loop representation? But virtual code can be simplified.\n\nMaybe structure:\n\n→ Step 4: insert(word) // 插入單詞\n    → Step 5: current = root\n    → Decision: 對每個字元 c in word? // 逐字遍歷\n        Yes → Step 6: If child missing then create\n        Yes → Step 7: current = child\n\nBut \"Decision\" expects Yes/No branches. Use a loop but we can represent as \"Decision: 是否已遍歷完 word?\" with Yes/No.\n\nBut easier: use while loop concept: \"Decision: 遍歷完? No: continue\".\n\nBut we can present as:\n\nDecision: 是否到達字串結尾? // 判斷是否已處理完所有字元\n    No  → Step 6: 取得下一字元 c\n    No  → Decision: 子節點是否存在 c? \n        Yes → Step 7: current = child\n        No  → Step 8: 建立 child 並 current = child\n    No  → 回到第一條 Decision\n    Yes → Step 9: current.isEnd = true\n\nThis is messy.\n\nBut requirement: Use arrows and structure. Maybe we can produce a high-level flow like above.\n\nBut maybe simpler: treat for loop as a repeated Decision. Let's produce simpler pseudo:\n\nStart\n→ Step 1: 定義 Node  // 節點結構\n→ Step 2: 定義 Trie 類別\n    → Step 3: Trie() // 初始化\n        → Step 4: root = new Node()\n    → Step 5: insert(word) // 插入\n        → Step 6: current = root\n        → Step 7: for char c in word:\n            → Decision: child exists?\n                Yes → Step 8: current = current.children[c]\n                No  → Step 9: current.children[c] = new Node()\n                     → Step 10: current = current.children[c]\n        → Step 11: current.isEnd = true\n    → Step 12: search(word) // 搜尋\n        → Step 13: current = root\n        → Step 14: for char c in word:\n            → Decision: child exists?\n                Yes → Step 15: current = current.children[c]\n                No  → Step 16: return false\n        → Step 17: return current.isEnd\n    → Step 18: startsWith(prefix) // 前綴搜尋\n        → Step 19: current = root\n        → Step 20: for char c in prefix:\n            → Decision: child exists?\n                Yes → Step 21: current = current.children[c]\n                No  → Step 22: return false\n        → Step 23: return true\nEnd\n\nThis is simple. We need arrow signs and decisions. That fits requirement.\n\nAdd // after each line.\n\nOk. Provide final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義 Node  // 節點結構，包含子節點與是否為字串結束標記\n→ Step 2: 定義 Trie 類別\n    → Step 3: Trie() // 初始化\n        → Step 4: root = new Node() // 創建根節點\n    → Step 5: insert(word) // 插入單詞\n        → Step 6: current = root // 從根節點開始\n        → Step 7: for char c in word: // 逐字元遍歷\n            → Decision: 子節點是否存在 c?\n                Yes → Step 8: current = current.children[c] // 直接移至現有子節點\n                No  → Step 9: current.children[c] = new Node() // 建立新子節點\n                     → Step 10: current = current.children[c] // 移至新建立的子節點\n        → Step 11: current.isEnd = true // 標記此路徑結束於一個完整單詞\n    → Step 12: search(word) // 搜尋單詞\n        → Step 13: current = root // 從根節點開始\n        → Step 14: for char c in word: // 逐字元遍歷\n            → Decision: 子節點是否存在 c?\n                Yes → Step 15: current = current.children[c] // 移至子節點\n                No  → Step 16: return false // 字串不存在\n        → Step 17: return current.isEnd // 只有在終止標記為 true 時才回傳 true\n    → Step 18: startsWith(prefix) // 前綴搜尋\n        → Step 19: current = root // 從根節點開始\n        → Step 20: for char c in prefix: // 逐字元遍歷\n            → Decision: 子節點是否存在 c?\n                Yes → Step 21: current = current.children[c] // 移至子節點\n                No  → Step 22: return false // 前綴不存在\n        → Step 23: return true // 成功遍歷完前綴，表示至少有一個單詞以此前綴開始\nEnd // 程式結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7_xk58ak.py\", line 29, in <module>\n    main()\n  File \"/tmp/tmp7_xk58ak.py\", line 25, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmp7_xk58ak.py\", line 14, in rand10\n    num = (rand7() - 1) * 7 + rand7()   # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg_5izfky.py\", line 29, in <module>\n    main()\n  File \"/tmp/tmpg_5izfky.py\", line 25, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpg_5izfky.py\", line 14, in rand10\n    num = (rand7() - 1) * 7 + rand7()   # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpswaxot0m.py\", line 29, in <module>\n    main()\n  File \"/tmp/tmpswaxot0m.py\", line 25, in main\n    results = [sol.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^\n  File \"/tmp/tmpswaxot0m.py\", line 14, in rand10\n    num = (rand7() - 1) * 7 + rand7()   # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 假設已經有一個 API rand7() 可用，題目會提供此函式\n# def rand7():\n#     # 這裡不要實作，直接使用題目給的 rand7()\n#     pass\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"使用 rand7 產生 1~10 的均勻分布\"\"\"\n        while True:\n            # 兩次 rand7 組成 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()   # 1~49\n            if num <= 40:                       # 可接受區間 1~40\n                return 1 + (num - 1) % 10       # 轉成 1~10\n\ndef main():\n    # 從 stdin 讀取資料，例如 \"n = 3\"\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for rand10 using rand7. The classic approach: use rejection sampling with 7x7=49 range, use 4 or 5 to generate 1-10. Example: generate two digits: first rand7 gives a, second rand7 gives b; compute num = (a-1)*7 + b; gives 1-49. If num <= 40 (4*10), map to (num-1)%10+1; else repeat. Alternative: could use 7^2 - 21 leftover etc.\n\nWe need step-by-step pseudocode. Also note that no built-in random. So we will call rand7 only.\n\nWe'll produce steps: Start, loop, generate a,b, compute num, check <=40, return mapping; else loop again.\n\nWe also need to maybe include explanation for each line.\n\nWe need to format with arrows and Decision etc.\n\nWe can structure like:\n\nStart\n→ Step 1: Initialize loop // Start loop to generate\n→ Decision: repeat? // but easier to use infinite loop until return\n    → Step 2: Call rand7() → a // first random\n    → Step 3: Call rand7() → b // second random\n    → Step 4: Compute num = (a - 1) * 7 + b // map to 1-49\n    → Decision: num <= 40? // check acceptance\n        Yes → Step 5: Return (num - 1) mod 10 + 1 // map to 1-10\n        No  → Step 6: Repeat loop // discard and retry\nEnd\n\nBut we must ensure we use the same format: Each line must be \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step, decision uses \"Decision:\".\n\nAlso \"Yes →\" and \"No →\" for branches.\n\nWe should ensure Start and End labels.\n\nAlso each line includes arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 進入無限迴圈 // 循環生成直到成功取得 1-10  \n→ Step 2: 呼叫 rand7() → a // 取得第一個隨機數 (1~7)  \n→ Step 3: 呼叫 rand7() → b // 取得第二個隨機數 (1~7)  \n→ Step 4: 計算 num = (a - 1) * 7 + b // 把兩個數合併成 1~49 的整數  \n→ Decision: num <= 40? // 判斷是否落在可接受區間（4*10）  \n  Yes → Step 5: 回傳 (num - 1) % 10 + 1 // 映射到 1~10，確保均勻  \n  No  → Step 6: 重複迴圈 // 若超過 40，拋棄並重新產生  \nEnd // 程式執行結束"
    },
    {
      "title": "Shopping Offers",
      "source_file": "Leetcode/leetcode638.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]",
          "expected_output": "14",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph95rszjy.py\", line 53, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmph95rszjy.py\", line 43, in parse_input\n    raise ValueError(\"Input format incorrect. Expected three list literals.\")\nValueError: Input format incorrect. Expected three list literals."
        },
        {
          "example_index": 1,
          "input": "price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]",
          "expected_output": "11",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_z838ota.py\", line 53, in <module>\n    price, special, needs = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_z838ota.py\", line 43, in parse_input\n    raise ValueError(\"Input format incorrect. Expected three list literals.\")\nValueError: Input format incorrect. Expected three list literals."
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom typing import List, Dict, Tuple\n\nclass Solution:\n    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:\n        n = len(price)\n        memo: Dict[Tuple[int, ...], int] = {}\n\n        def dfs(curr_needs: List[int]) -> int:\n            key = tuple(curr_needs)\n            if key in memo:\n                return memo[key]\n\n            # cost without any special offers\n            res = sum(curr_needs[i] * price[i] for i in range(n))\n\n            for offer in special:\n                temp = []\n                for i in range(n):\n                    if offer[i] > curr_needs[i]:\n                        break\n                    temp.append(curr_needs[i] - offer[i])\n                else:\n                    # offer can be applied\n                    res = min(res, offer[-1] + dfs(temp))\n\n            memo[key] = res\n            return res\n\n        return dfs(needs)\n\ndef parse_input(data: str) -> Tuple[List[int], List[List[int]], List[int]]:\n    \"\"\"\n    Parse input string like:\n    'price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]'\n    into three Python objects.\n    \"\"\"\n    # Find all list literals\n    list_strings = re.findall(r'\\[.*?\\]', data)\n    if len(list_strings) != 3:\n        raise ValueError(\"Input format incorrect. Expected three list literals.\")\n    price = ast.literal_eval(list_strings[0])\n    special = ast.literal_eval(list_strings[1])\n    needs = ast.literal_eval(list_strings[2])\n    return price, special, needs\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    price, special, needs = parse_input(raw_input)\n    solution = Solution()\n    result = solution.shoppingOffers(price, special, needs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving LeetCode 638 Shopping Offers. The solution: DFS + memoization with pruning. Steps: define dfs(needs). If memo exists return. Compute total price without offers. For each offer: if it can be applied (needs >= offer counts) then newneeds = needs - offercounts; cost = offer price + dfs(newneeds); keep min. Return min and store in memo.\n\nAlso need to handle offers that might not be beneficial if price >= sum of individual items. So we can prune or remove such offers.\n\nWe need to output each line as virtual code with comment after space.\n\nWe should produce steps:\n\nStart\n→ Step: 初始化 memo dict // store computed needs to min price\n→ Step: 處理 offers: 去除不划算的 offers // remove offers whose price >= sum of items\n→ Step: 定義遞迴函式 DFS(needs)\n   → Decision: if needs in memo? // base case\n        Yes → Return memo[needs]\n        No → 計算不使用任何特價的總價 // sum price[i]*needs[i]\n        → minPrice = that total\n        → For 每個 offer in offers\n            → Decision: canApply? // check all needs >= offer counts\n                Yes → newNeeds = needs - offer counts\n                → cost = offer price + DFS(newNeeds)\n                → If cost < minPrice: minPrice = cost\n        → memo[needs] = minPrice\n        → Return minPrice\n→ Step: 呼叫 DFS(needs) // initial needs\n→ End\n\nWe need to output each line individually, including indentation perhaps. The example uses indentation for decisions and sublines. We'll follow similar.\n\nWe'll write \"Start // 程式開始執行\" etc. Provide each line.\n\nNeed to include arrow lines: \"→\" before each step. For decision lines: \"Decision:\" etc.\n\nWe need to use the special arrow patterns.\n\nLet's produce.\n\nMake sure we include each line separated. Provide comments after a space.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 memo 以存放已計算的需求組合到最小價格 // memo 用於記錄已解決的需求組合  \n→ Step: 處理特價清單：移除價格不低於個別購買總價的特價 // 篩選掉不划算的特價  \n→ Step: 定義遞迴函式 DFS(需要) // 主要計算函式  \n    → Decision: 如果需要已在 memo 中? // 判斷是否已計算過  \n        Yes → Return memo[需要] // 直接回傳已知最小價格  \n        No → Step: 計算不使用任何特價的總價 // 初始最小價格為單價購買  \n        → Variable: basePrice = Σ (price[i] * 需要[i])  \n        → Variable: minPrice = basePrice  \n        → Step: 遍歷每個特價 offer  \n            → Decision: 這個 offer 能否使用? // 檢查需要是否足夠減去 offer 內的數量  \n                Yes → Step: 計算新的需求 newNeeds = 需要 - offerCount  \n                → Variable: cost = offerPrice + DFS(newNeeds) // 遞迴計算剩餘需求的最小價格  \n                → Decision: cost < minPrice? // 判斷是否更新最小價格  \n                    Yes → Step: minPrice = cost  \n                    No  → // 留下舊的 minPrice  \n                No  → // 這個 offer 無法使用，直接跳過  \n        → Step: memo[需要] = minPrice // 將結果存入 memo  \n        → Return minPrice // 回傳此需求組合的最小價格  \n→ Step: 呼叫 DFS(需要) 取得最終答案 // 開始遞迴計算  \nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catdog\"]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[\"catdog\"]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef findAllConcatenatedWordsInADict(words):\n    word_set = set(words)\n    res = []\n\n    for w in words:\n        if not w:\n            continue\n\n        # DP to check if w can be segmented into words from word_set\n        n = len(w)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and w[j:i] in word_set:\n                    dp[i] = True\n                    break\n\n        if not dp[n]:\n            continue\n\n        # Minimum number of segments needed\n        INF = float('inf')\n        min_split = [INF] * (n + 1)\n        min_split[0] = 0\n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and w[j:i] in word_set:\n                    if min_split[j] + 1 < min_split[i]:\n                        min_split[i] = min_split[j] + 1\n\n        if min_split[n] >= 2:\n            res.append(w)\n\n    return res\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the list literal from the input\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if not match:\n        words = []\n    else:\n        list_str = match.group(0)\n        try:\n            words = ast.literal_eval(list_str)\n            if not isinstance(words, list):\n                words = []\n        except Exception:\n            words = []\n\n    result = findAllConcatenatedWordsInADict(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code. Steps: Build set of words. For each word, check if it can be segmented into at least two words from set (except itself). Use DP. But we need to produce a step-by-step pseudocode. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". The steps must be per line. Let's outline:\n\nStart\n→ Initialize set all_words with words\n→ Initialize result list\n→ For each word in words:\n    → Remove word from set temporarily? No, we can handle by allowing word itself but need at least two words. We can use DP where dp[0] = true. For each i from 1 to len(word):\n        → dp[i] = false\n        → For j from 0 to i-1:\n            → Decision: if dp[j] and substring(word, j, i) in set? // check subword\n                → Yes → set dp[i] = true\n                → Break // optimization\n    → Decision: if dp[len(word)] and count of used words >= 2? Actually need to ensure at least two words. We can modify DP to count segments or we can do second DP that counts. Alternatively use recursive with memo. But for pseudocode, we can do: if dp[len(word)] and number_of_parts(word) >= 2 => add to result.\n\nBut need to check number of parts. We could run a separate check: count segments using DP that stores min splits. For each i, minSplit[i] = INF; if dp[j] and sub in set: minSplit[i] = min(minSplit[i], minSplit[j] + 1). Then at end, if minSplit[len] >= 2 add word.\n\nSimplify: Use a Decision: if word can be segmented into at least two words? then add.\n\nBut we need to show steps.\n\nWe need to produce each line with virtual code and comment. Must use arrow and Decision.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: all_words ← Set(words) // 建立包含所有單詞的集合\n→ Step 2: result ← [] // 存放所有連接詞\n→ Step 3: For each w in words: // 逐一檢查每個單詞\n    → Step 4: dp ← Array(len(w)+1) filled with False // dp[i]表示前i個字可被拆分\n    → dp[0] ← True // 空字串可拆分\n    → Step 5: For i from 1 to len(w): // 逐個位置進行 DP\n        → Step 6: For j from 0 to i-1: // 從前面切分\n            → Decision: if dp[j] and w[j:i] in all_words? // 子字串是否為合法單詞\n                → Yes → dp[i] ← True\n                → Break // 找到一種拆分即可\n    → Decision: if dp[len(w)]? // 能否被拆分\n        → Yes → Step 7: minSplit ← Array(len(w)+1) filled with INF // 最小切分數\n            → minSplit[0] ← 0\n            → Step 8: For i from 1 to len(w):\n                → Step 9: For j from 0 to i-1:\n                    → Decision: if dp[j] and w[j:i] in all_words?\n                        → Yes → minSplit[i] ← min(minSplit[i], minSplit[j] + 1)\n            → Decision: if minSplit[len(w)] >= 2? // 至少兩個子單詞\n                → Yes → result.append(w)\n    → No → Continue // 如果無法拆分，跳過\n→ End // 結束\n\nBut we need to include the comment for each line. Also use \"Yes →\" and \"No →\" for decisions.\n\nAlso we should indent decisions with spaces to reflect structure.\n\nBetter: For readability, show Decision lines with indents.\n\nAlso each line should be \"虛擬碼步驟 // 解釋\". So the code part ends before comment.\n\nLet's produce final. Ensure we use arrow characters. Use `→` before steps. Use `Decision:` lines.\n\nWill we need Step numbers? Not required, but can include. We'll keep them.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: all_words ← Set(words) // 建立一個包含所有單詞的集合  \n→ Step 2: result ← [] // 用於儲存所有可被拆分成至少兩個單詞的連接詞  \n→ Step 3: For each w in words: // 逐一檢查每個單詞  \n  → Step 4: dp ← Array(len(w)+1) filled with False // dp[i] 表示前 i 個字符是否能被拆分  \n   → dp[0] ← True // 空字串可被視為已拆分  \n  → Step 5: For i from 1 to len(w): // 遍歷所有可能的結尾位置  \n   → Step 6: For j from 0 to i-1: // 嘗試在位置 j 處切分  \n    → Decision: if dp[j] and w[j:i] in all_words? // 子字串是否為合法單詞  \n      Yes → dp[i] ← True // 找到一種合法拆分  \n      No  → Continue // 继续尝试其他 j  \n  → Decision: if dp[len(w)]? // 当前单词能否被拆分  \n    Yes → Step 7: minSplit ← Array(len(w)+1) filled with INF // 用於計算最小切分數  \n      minSplit[0] ← 0  \n    → Step 8: For i from 1 to len(w): // 重新計算最小切分數  \n      → Step 9: For j from 0 to i-1:  \n        → Decision: if dp[j] and w[j:i] in all_words?  \n         Yes → minSplit[i] ← min(minSplit[i], minSplit[j] + 1) // 更新最小值  \n    → Decision: if minSplit[len(w)] >= 2? // 至少兩個子單詞  \n      Yes → result.append(w) // 加入結果集合  \n      No  → Continue // 不是連接詞，跳過  \n   No → Continue // 不能拆分，跳過  \nEnd // 程式執行結束"
    },
    {
      "title": "Accounts Merge",
      "source_file": "Leetcode/leetcode721.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]",
          "expected_output": "[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nGot (Norm):      '[[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]'\nRaw Got:      \"[['Gabe', 'Gabe0@m.co', 'Gabe1@m.co', 'Gabe3@m.co'], ['Kevin', 'Kevin0@m.co', 'Kevin3@m.co', 'Kevin5@m.co'], ['Ethan', 'Ethan0@m.co', 'Ethan4@m.co', 'Ethan5@m.co'], ['Hanzo', 'Hanzo0@m.co', 'Hanzo1@m.co', 'Hanzo3@m.co'], ['Fern', 'Fern0@m.co', 'Fern1@m.co', 'Fern5@m.co']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def accountsMerge(self, accounts):\n        parent = {}\n\n        def find(x):\n            parent.setdefault(x, x)\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        email_to_name = {}\n        for acc in accounts:\n            name = acc[0]\n            first_email = acc[1]\n            for email in acc[1:]:\n                root1 = find(first_email)\n                root2 = find(email)\n                parent[root2] = root1\n                email_to_name[email] = name\n\n        merged = defaultdict(list)\n        for email in email_to_name:\n            root = find(email)\n            merged[root].append(email)\n\n        result = []\n        for root, emails in merged.items():\n            result.append([email_to_name[root]] + sorted(emails))\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 若輸入以 accounts = 開頭，剔除變數名稱與等號\n    if data.startswith(\"accounts\"):\n        eq_index = data.find(\"=\")\n        if eq_index != -1:\n            data = data[eq_index + 1 :].strip()\n\n    # 解析為 Python 物件\n    try:\n        accounts = ast.literal_eval(data)\n    except Exception as e:\n        # 若解析失敗，輸出空列表\n        print([])\n        sys.exit(0)\n\n    sol = Solution()\n    merged_accounts = sol.accountsMerge(accounts)\n    print(merged_accounts)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for merging accounts as described. Use virtual code arrows etc. Provide explanation per line. Must not output actual code. Just structured steps. We'll produce steps: Start, Step 1: Build graph mapping emails to name and edges between emails in same account. Use union-find or DFS. Then build connected components, group emails, sort, attach name. Output accounts. Provide End. Use Decision blocks where needed. We should produce lines with \"虛擬碼步驟\" like \"Step 1: Build email → name mapping\". Provide explanation.\n\nWe need to output each line with a space between step and comment. Use arrow notation for flows: \"→\". Also Decision lines with Yes →, No → etc. So we need to structure pseudo-algorithm with decisions.\n\nWe might use iterative loops. Use Start, End. Let's produce.\n\nThe user wants pseudocode, not actual code. So we need to show conceptual steps.\n\nLet's craft:\n\nStart // Start algorithm\n→ Step 1: 初始化資料結構: emailToName, emailGraph // Map email to name and adjacency list for email connections\n→ Step 2: 遍歷每個帳號 accounts[i] // For each account\n    → For each email in accounts[i] from index 1\n        → If email not in emailToName: emailToName[email] ← accounts[i][0] // Associate email with name\n    → For each pair of emails in the same account (adjacent in list)\n        → Add undirected edge between email1 and email2 in emailGraph // Connect emails of same account\n→ Decision: 是否完成遍歷所有帳號? // Check if all accounts processed\n    Yes → Step 3: 初始化 visited set\n→ Step 4: 對每個 email in emailGraph\n    → Decision: email 是否已訪問? // If email already visited\n        No  → DFS從 email 開始, 收集連通子集 emails // Depth-first search to gather component\n            → Decision: 是否訪問所有相鄰 email?\n                Yes → Step 5: 將收集的 emails 按字典序排序\n                No  → Continue DFS\n            → Step 6: 取得 component 內任意 email 的 name from emailToName\n            → Step 7: 建立 mergedAccount = [name] + sortedEmails\n            → Step 8: 將 mergedAccount 加入結果列表\n→ End // 結束，返回結果\n\nBut we must format each line as \"虛擬碼步驟 [space] // 解釋\".\n\nWe also need to use arrow notation \"→\" between steps. For decisions, we use \"Decision:\" with Yes → and No →. The indentation may be indicated by spaces? The example shows indentation by spaces. We'll mimic.\n\nWe need to ensure each line begins with \"Start\" or \"→\". For decisions, \"Decision:\" preceded by arrow? The example: \n```\n→ Decision: 如果數字大於 0? \n    Yes → Step 2: ...\n    No  → Decision: ...\n```\nSo we will use same.\n\nAlso we need to ensure each line ends with comment after \"//\".\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 emailToName 映射與 emailGraph 邊集合 // 建立 email ↦ name 的映射與 email 之間的連接表  \n→ Step 2: 遍歷每個帳號 accounts[i] // 逐筆處理輸入資料  \n    → For each email 在 accounts[i][1..] // 取帳號內所有 email  \n        → If email 未在 emailToName 中: emailToName[email] ← accounts[i][0] // 將 email 與對應姓名關聯  \n    → For each adjacent pair (email_j, email_{j+1}) 在 accounts[i][1..] // 連接同一帳號內的 email  \n        → emailGraph[email_j].add(email_{j+1}) ; emailGraph[email_{j+1}].add(email_j) // 無向邊  \n→ Decision: 已處理完所有帳號? // 確認輸入已全部解析  \n    Yes → Step 3: 初始化 visited 集合 // 用於 DFS 訪問標記  \n→ Step 4: 對於每個 email 在 emailGraph.keys()  \n    → Decision: email 已被訪問? // 判斷是否已屬於某個集合  \n        No → Step 5: DFS(email) 收集連通子集 connectedEmails // 深度優先搜尋，獲得所有相關 email  \n        → Step 6: connectedEmails ← Sort(connectedEmails) // 以字典序排序  \n        → Step 7: name ← emailToName[任意 connectedEmails[0]] // 取集合中任一 email 的姓名  \n        → Step 8: mergedAccount ← [name] + connectedEmails // 組成合併後的帳號  \n        → Step 9: results.add(mergedAccount) // 加入最終結果  \n→ End // 程式執行結束，返回 results 其中每項為 [姓名, 排序後的 email 列表]"
    },
    {
      "title": "Partition Labels",
      "source_file": "Leetcode/leetcode763.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"ababcbacadefegdehijhklij\"",
          "expected_output": "[9,7,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[9,7,8]'\nGot (Norm):      '[1,3,26]'\n--- (Raw) ---\nRaw Expected: '[9,7,8]'\nRaw Got:      '[1, 3, 26]'"
        },
        {
          "example_index": 1,
          "input": "s = \"eccbbbbdec\"",
          "expected_output": "[10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[10]'\nGot (Norm):      '[1,3,12]'\n--- (Raw) ---\nRaw Expected: '[10]'\nRaw Got:      '[1, 3, 12]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef partition_labels(s: str) -> list[int]:\n    \"\"\"\n    Partition the string into the maximum number of parts such that\n    each letter appears in at most one part.\n    \"\"\"\n    # Record the last index at which each character appears\n    last_index = {c: i for i, c in enumerate(s)}\n\n    result = []\n    start = end = 0\n\n    # Scan the string, expanding the current partition's end to\n    # the furthest last occurrence of any character seen so far.\n    for i, char in enumerate(s):\n        end = max(end, last_index[char])\n        if i == end:\n            # Current partition ends here\n            result.append(i - start + 1)\n            start = i + 1  # Start a new partition\n\n    return result\n\ndef extract_string_from_input(text: str) -> str:\n    \"\"\"\n    Extract the quoted string from input like:\n        s = \"ababcbacadefegdehijhklij\"\n    or just a plain string.\n    \"\"\"\n    # Search for a quoted substring (double or single quotes)\n    match = re.search(r'\"([^\"]*)' + r\"'\" + r\"([^\\']*)'\", text)\n    if match:\n        return match.group(1) or match.group(2)\n    # If no quotes found, treat the whole line as the string\n    return text.strip()\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the string value from the input\n    s = extract_string_from_input(raw_input)\n    # Compute the partition sizes\n    partitions = partition_labels(s)\n    # Print the result in Python list format\n    print(partitions)",
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps for partitioning string so each letter appears at most once across parts. Classic Leetcode 763: Partition Labels. Approach: record last occurrence index of each character, then iterate, keep current maxLast, when i==maxLast, cut. Output sizes.\n\nNeed to output step by step, with comments. Use arrows.\n\nWe'll produce steps: Start, input s. Compute last indices. Then iterate. Count parts. Finally output list. End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收字串 s // 取得輸入的字串  \n→ Step 2: 建立字典 lastIndex 以記錄每個字母最後一次出現的位置 // 用來判斷分割點  \n    → Decision: 遍歷 s 的每個字母 c 以及其索引 i  \n        → Step 2a: lastIndex[c] ← i // 更新字母 c 的最後出現位置  \n→ Step 3: 初始化變數 maxLast ← -1 // 目前分割區域的最遠結束位置  \n→ Step 4: 初始化變數 currSize ← 0 // 當前區塊的大小  \n→ Step 5: 建立空列表 result 以儲存各區塊大小  \n→ Decision: 遍歷 s 的每個字母 c 以及其索引 i  \n    → Step 5a: maxLast ← max(maxLast, lastIndex[c]) // 更新目前區塊的最大結束索引  \n    → Step 5b: currSize ← currSize + 1 // 加一個字元到目前區塊  \n    → Decision: i == maxLast? // 是否到達該區塊的最終位置？  \n        → Yes → Step 5c: result.append(currSize) // 將區塊大小加入結果  \n        → Yes → Step 5d: currSize ← 0 // 重置區塊大小，開始新區塊  \n        → No  → Step 5e: 继续循环 // 尚未到達分割點，繼續累加  \n→ Step 6: 返回 result // 回傳所有區塊的大小列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Replace Words",
      "source_file": "Leetcode/leetcode648.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"",
          "expected_output": "\"the cat was rat by the bat\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0esqb5b1.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmp0esqb5b1.py\", line 42, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"",
          "expected_output": "\"a a b c\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd0qzvcgq.py\", line 49, in <module>\n    main()\n  File \"/tmp/tmpd0qzvcgq.py\", line 42, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def replaceWords(self, dictionary, sentence):\n        \"\"\"\n        用 Trie (字典樹) 來快速找出最短符合前綴的根字。\n        \"\"\"\n        trie = {}                 # Trie 根節點\n        END = True                # 特殊鍵表示此節點為完整根字結束\n\n        # 建立 Trie\n        for root in dictionary:\n            node = trie\n            for ch in root:\n                node = node.setdefault(ch, {})\n            node[END] = root     # 在節點上存根字本身\n\n        def replace(word):\n            \"\"\"\n            依序走 Trie，若遇到 END 就回傳對應的根字。\n            若沒找到任何前綴則回傳原單字。\n            \"\"\"\n            node = trie\n            for ch in word:\n                if ch not in node:\n                    break\n                node = node[ch]\n                if END in node:\n                    return node[END]\n            return word\n\n        # 逐個單字替換後再拼接回句子\n        return ' '.join(map(replace, sentence.split()))\n\ndef main():\n    \"\"\"\n    讀取整個 stdin，將內容當作 Python 程式碼執行，取得 dictionary 與 sentence。\n    然後呼叫 Solution.replaceWords，最後輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 允許使用簡單的 exec，因為輸入格式固定且可信\n    exec(data, globals())\n    sol = Solution()\n    result = sol.replaceWords(dictionary, sentence)\n    # 根據範例輸出，將結果包在雙引號內\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for replacing words in a sentence using dictionary of roots, replace words that start with any root and choose shortest root. Input: dictionary list of strings, sentence string. Output: modified sentence. Algorithm: maybe build a trie or sort dictionary by length ascending. For each word in sentence, iterate over roots sorted ascending, check if word startswith root, replace with that root, break. If none, keep word. Then join words. Complexity.\n\nWe produce virtual code steps line by line. Use arrows, Start, End, Decision. Provide explanation comment each line.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得根字典 `rootDict` 與句子 `sentence` // 從輸入取得資料  \n→ Step 2: 以長度升序排序 `rootDict` → sortedRoots // 方便先找最短根  \n→ Decision: `sortedRoots` 是否為空?  \n  Yes → Step 3: 輸出 `sentence` // 若沒有根字，直接回傳原句  \n  No → Step 4: 將 `sentence` 以空白切分成單字列表 `words`  \n→ Step 5: 建立空列表 `newWords` 用於儲存處理後的單字  \n→ For each `word` in `words`:  \n  → Step 6: 設 `foundRoot` 為空  \n  → Decision: `sortedRoots` 是否為空?  \n    Yes → Step 7: 將 `word` 加入 `newWords` // 無根可比對  \n    No → Step 8: For each `root` in `sortedRoots`:  \n      → Decision: `word` 以 `root` 開頭?  \n       Yes → Step 9: 設 `foundRoot = root` 并跳出內層迴圈 // 找到最短根  \n       No → Step 10: 繼續檢查下一個 `root`  \n  → Decision: `foundRoot` 是否不為空?  \n    Yes → Step 11: 將 `foundRoot` 加入 `newWords` // 取代衍生詞  \n    No → Step 12: 將原始 `word` 加入 `newWords` // 無匹配時保留原詞  \n→ Step 13: 用空白字元將 `newWords` 重新組合成字串 `result`  \n→ Step 14: 輸出 `result` // 回傳處理後的句子  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Blacklist",
      "source_file": "Leetcode/leetcode710.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\", \"pick\"]\n[[7, [2, 3, 5]], [], [], [], [], [], [], []]",
          "expected_output": "[null, 0, 4, 1, 6, 1, 0, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,0,4,1,6,1,0,4]'\nGot (Norm):      '[null,1,4,0,6,1,4,4]'\n--- (Raw) ---\nRaw Expected: '[null, 0, 4, 1, 6, 1, 0, 4]'\nRaw Got:      '[null, 1, 4, 0, 6, 1, 4, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, n, blacklist):\n        \"\"\"\n        建構子：預先建立黑名單與白名單之間的映射表。\n        n: 整體範圍為 [0, n-1]\n        blacklist: 黑名單集合\n        \"\"\"\n        self.mapping = {}                    # map[black] = white\n        self.size = n - len(blacklist)       # 可用白名單的長度\n        black_set = set(blacklist)           # 快速判斷是否在黑名單\n        last = n - 1                         # 從最右端開始尋找白名單\n\n        for b in blacklist:\n            if b < self.size:                # 只處理白名單區域內的黑名單\n                while last in black_set:    # 找到不在黑名單中的白名單\n                    last -= 1\n                self.mapping[b] = last      # 建立映射\n                last -= 1\n\n    def pick(self):\n        \"\"\"\n        隨機挑選一個不在黑名單中的數字。\n        \"\"\"\n        index = random.randint(0, self.size - 1)   # 在白名單長度內隨機取值\n        return self.mapping.get(index, index)      # 若是黑名單則取映射後的白名單\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    ops = ast.literal_eval(data[0])      # 取得操作序列\n    args_list = ast.literal_eval(data[1])  # 取得對應參數\n\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)           # 代表初始化返回 null\n        elif op == \"pick\":\n            result.append(obj.pick())\n\n    # 輸出為 JSON 格式，Python 的 None 會轉為 null\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this algorithm. Classic solution: map blacklisted numbers in [0, n-1] to white numbers in [n - blackCount, n-1] via hash map. On pick, generate random from 0 to M-1 (where M = n - blacklist.size). If result is in map, return map[result]; else return result. Also need initialization: build map. Provide explanation per line.\n\nWe'll produce virtual code steps. Use virtual code structure. Start, steps. We'll need to mention variables: n, blacklist, M, mapping. Use decision structure.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 宣告變數 n, blacklist, M ← n - blacklist.length // 計算白色區域長度\n→ Step 2: 建立空 hash map map // 用於將黑名單中的數映射到白名單末端\n→ Step 3: 宣告變數 whiteStart ← M // 以白名單的起始索引為基準\n    // 下面的迴圈將黑名單中小於 M 的數映射到白名單區域\n→ Step 4: Decision: 若 whitelist 需要映射? // 如果 blacklist 不為空\n        Yes →\n            → Step 5: 對每個 b ∈ blacklist:\n                // 若 b 在白名單內，必須將其映射到一個白名單數\n                → Decision: 如果 b < M? // 只處理白名單範圍內的黑名單\n                    Yes →\n                        → Step 6: Decision: 如果 whiteStart 已經在 blacklist? // 確保映射到的白名單數不再是黑名單\n                            Yes →\n                                → Step 7: whiteStart++ // 移動至下個可能的白名單索引\n                                → Step 8: Decision: 白名單索引是否仍在 blackList? // 繼續尋找可用白名單\n                                    Yes → goto Step 7\n                                    No  →\n                                // 這裡 whiteStart 指向一個合法白名單\n                            No  →\n                        → Step 9: map[b] ← whiteStart // 將黑名單數映射到合法白名單\n                        → Step 10: whiteStart++ // 移動到下一個白名單索引\n                    No →\n                        // b >= M，已經在白名單區域外，無需映射\n        No → // blacklist 為空，無需任何映射\n→ End // 初始化結束\n\n// ----------------- pick() 函式 -----------------\nStart // pick 函式開始\n→ Step 11: 產生隨機數 r ← random(0, M-1) // 只在白名單長度內產生\n→ Step 12: Decision: 如果 map[r] 存在? // r 是否為黑名單內的數\n    Yes →\n        → Step 13: Return map[r] // 取映射後的白名單數\n    No  →\n        → Step 14: Return r // r 本身就在白名單內，直接回傳\nEnd // pick 函式結束\n\n// ----------------- 完整結構 -----------------\nStart // 程式開始執行\n→ Step 1-10 // 初始化：建立映射表\n→ Step 11-14 // pick 函式實作\nEnd // 程式執行結束"
    },
    {
      "title": "Map Sum Pairs",
      "source_file": "Leetcode/leetcode677.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"], [[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]",
          "expected_output": "[null, null, 3, null, 5]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,3,null,5]'\nGot (Norm):      '[None,None,3,None,5]'\n--- (Raw) ---\nRaw Expected: '[null, null, 3, null, 5]'\nRaw Got:      '[None, None, 3, None, 5]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.sum = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.val_map = {}\n\n    def insert(self, key, val):\n        delta = val - self.val_map.get(key, 0)\n        self.val_map[key] = val\n        node = self.root\n        node.sum += delta\n        for ch in key:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n            node.sum += delta\n\n    def sum(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return 0\n            node = node.children[ch]\n        return node.sum\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Find the separator between the two lists\n    sep_index = data.find('],')\n    first_part = data[:sep_index + 1]\n    second_part = data[sep_index + 2 :].strip()\n    commands = ast.literal_eval(first_part)\n    args_list = ast.literal_eval(second_part)\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MapSum\":\n            obj = MapSum()\n            results.append(None)\n        elif cmd == \"insert\":\n            key, val = args\n            obj.insert(key, val)\n            results.append(None)\n        elif cmd == \"sum\":\n            prefix = args[0]\n            results.append(obj.sum(prefix))\n        else:\n            results.append(None)  # 未知指令，視為無輸出\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for designing a MapSum class that supports insert and sum with prefix. Provide pseudocode line by line with explanations. Must use arrows, Start, End, Decision etc. Use \"→\" arrow. Provide each line with // explanation. Must not output actual code. Just structured steps.\n\nWe need to describe the data structure: use Trie where each node stores sum of values of all keys in its subtree. Also maintain a dictionary to track previous value for a key to handle overrides.\n\nSteps: initialize root, map.\n\nInsert: compute delta = newVal - oldVal (if key existed). Update map. Then traverse Trie adding delta to each node's sum along path. If node missing, create new.\n\nSum: traverse prefix to node, if node found return sum, else 0.\n\nLet's produce virtual code lines.\n\nAlso maybe decision: if key exists? yes no.\n\nAlso maybe decision: if node exists? yes no.\n\nLet's produce.\n\nWe need to include Start, End.\n\nAlso ensure each line includes \"虛擬碼步驟\" and explanation.\n\nWe should use consistent arrow formatting.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化 MapSum // 建立 Trie 根節點及 key->value map\n\n→ Step 2: 定義 TrieNode 類別 // 每節點含 children、sum\n\n→ Step 3: MapSum 插入方法 (insert) // 接收 key, val\n\n→ Step 4: Decision: key 是否已存在? // 檢查是否覆蓋\n\n    Yes → Step 5: oldVal = map[key] // 取舊值\n\n    No  → Step 5: oldVal = 0 // 沒有舊值\n\n→ Step 6: delta = val - oldVal // 計算值變化\n\n→ Step 7: map[key] = val // 更新 key->value\n\n→ Step 8: node = root // 從 Trie 根開始\n\n→ Step 9: Step 10: 對 key 的每個字符 c 遍歷\n\n    → Step 11: Decision: node.children 有 c? // 檢查子節點\n\n        Yes → Step 12: node = node.children[c] // 進入子節點\n\n        No  → Step 12: node.children[c] = new TrieNode() ; node = node.children[c] // 新建子節點\n\n    → Step 13: node.sum += delta // 更新該節點子樹總和\n\n→ Step 14: End insert 方法 // 插入完成\n\n→ Step 15: sum 方法 (sum) // 接收 prefix\n\n→ Step 16: node = root\n\n→ Step 17: Step 18: 對 prefix 的每個字符 c 遍歷\n\n    → Step 19: Decision: node.children 有 c? // 找到節點\n\n        Yes → Step 20: node = node.children[c] // 進入\n\n        No  → Step 20: Return 0 // 前綴不存在\n\n→ Step 21: Return node.sum // 前綴子樹總和\n\n→ End // 程式結束\n\nBut need to use arrow formatting. Also maintain indentation.\n\nLet's produce final answer with each line as per format.\n\nMake sure each line has \"虛擬碼步驟\" plus explanation.\n\nBut the specification says \"虛擬碼步驟 [space] // 解釋/說明\". So the line must contain the pseudocode step and then comment. Eg: \"Start // 程式開始執行\". They also mention using arrow like \"→\". We need to show arrow for each step maybe preceded by \"→\".\n\nIn the example they used \"Start\" no arrow, then \"→ Step 1: ...\". So we can follow.\n\nThus first line: \"Start // 程式開始執行\".\n\nSecond line: \"→ Step 1: 建立 Trie 根節點 root 及 key->value map kv\" // explanation.\n\nLet's produce lines accordingly.\n\nWe need to include decisions with indent. In example they used indentation with spaces.\n\nSo produce:\n\nStart // 程式開始執行\n\n→ Step 1: 建立 Trie 根節點 root 及空字典 kv // 初始化資料結構\n\n→ Step 2: 定義 TrieNode 類別，包含 children map 與 sum // 方便存放前綴子樹總和\n\n→ Step 3: MapSum.insert(key, val) 方法開始 // 插入或覆寫鍵值對\n\n    → Step 4: Decision: kv 包含 key? // 判斷是否為覆寫\n\n        Yes → Step 5: oldVal = kv[key] // 取舊值\n\n        No  → Step 5: oldVal = 0 // 無舊值\n\n    → Step 6: delta = val - oldVal // 計算增量\n\n    → Step 7: kv[key] = val // 更新字典\n\n    → Step 8: node = root // 從根節點開始\n\n    → Step 9: 遍歷 key 中每個字元 c\n\n        → Step 10: Decision: node.children 包含 c? // 檢查子節點\n\n            Yes → Step 11: node = node.children[c] // 移至子節點\n\n            No  → Step 11: node.children[c] = new TrieNode() ; node = node.children[c] // 新建子節點\n\n        → Step 12: node.sum += delta // 更新該節點子樹總和\n\n→ Step 13: MapSum.sum(prefix) 方法開始 // 計算前綴總和\n\n    → Step 14: node = root\n\n    → Step 15: 遍歷 prefix 中每個字元 c\n\n        → Step 16: Decision: node.children 包含 c? // 找到節點\n\n            Yes → Step 17: node = node.children[c] // 移至子節點\n\n            No  → Step 17: Return 0 // 前綴不存在，總和為 0\n\n    → Step 18: Return node.sum // 返回前綴子樹的總和\n\nEnd // 程式結束\n\nMake sure each line ends with comment after //.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Trie 根節點 root 及空字典 kv // 初始化資料結構  \n→ Step 2: 定義 TrieNode 類別，包含 children map 與 sum // 方便存放前綴子樹總和  \n\n→ Step 3: MapSum.insert(key, val) 方法開始 // 插入或覆寫鍵值對  \n    → Step 4: Decision: kv 包含 key? // 判斷是否為覆寫  \n        Yes → Step 5: oldVal = kv[key] // 取舊值  \n        No  → Step 5: oldVal = 0 // 無舊值  \n    → Step 6: delta = val - oldVal // 計算增量  \n    → Step 7: kv[key] = val // 更新字典  \n    → Step 8: node = root // 從根節點開始  \n    → Step 9: 遍歷 key 中每個字元 c  \n        → Step 10: Decision: node.children 包含 c? // 檢查子節點  \n            Yes → Step 11: node = node.children[c] // 移至子節點  \n            No  → Step 11: node.children[c] = new TrieNode() ; node = node.children[c] // 新建子節點  \n        → Step 12: node.sum += delta // 更新該節點子樹總和  \n\n→ Step 13: MapSum.sum(prefix) 方法開始 // 計算前綴總和  \n    → Step 14: node = root  \n    → Step 15: 遍歷 prefix 中每個字元 c  \n        → Step 16: Decision: node.children 包含 c? // 找到節點  \n            Yes → Step 17: node = node.children[c] // 移至子節點  \n            No  → Step 17: Return 0 // 前綴不存在，總和為 0  \n    → Step 18: Return node.sum // 返回前綴子樹的總和  \n\nEnd // 程式結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.49186007352451855,0.7974306319925673],[0.1493299360875852,0.330782513105945],[-0.47025703540057096,0.031476039762427216]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.49186007352451855, 0.7974306319925673], [0.1493299360875852, 0.330782513105945], [-0.47025703540057096, 0.031476039762427216]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 讀取兩行輸入：命令列與對應參數列\n    commands_line = sys.stdin.readline().strip()\n    args_line = sys.stdin.readline().strip()\n\n    # 解析字串為 Python 資料結構\n    commands = ast.literal_eval(commands_line)\n    args = ast.literal_eval(args_line)\n\n    results = []\n    obj = None\n\n    # 執行命令\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(*arg)   # 建構物件\n            results.append(None)   # 以 null 表示建構結果\n        else:\n            method = getattr(obj, cmd)\n            res = method(*arg)\n            results.append(res)\n\n    # 輸出結果，使用 JSON 格式以得到 null 而非 None\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing Solution class with constructor and randPoint method. It should generate uniform random point inside circle: standard method: generate random radius r = sqrt(rand()) * radius; random angle theta = 2π*rand(); x = x_center + r*cos(theta); y = y_center + r*sin(theta); return [x, y].\n\nWe produce step-by-step pseudo code with decisions? There's no decision except maybe checking if radius > 0. But we can ignore. Provide Start, End.\n\nWe should output lines like:\n\nStart // 程式開始執行\n→ Step 1: Define class Solution with properties radius, x_center, y_center // 初始化類別\n→ Step 2: Constructor(radius, x_center, y_center) // 接收參數\n    → Assign this.radius = radius // 儲存半徑\n    → Assign this.x_center = x_center // 儲存中心 x\n    → Assign this.y_center = y_center // 儲存中心 y\n→ Step 3: Method randPoint() // 產生隨機點\n    → Generate random angle θ = 2π * rand() // 隨機角度\n    → Generate random radius r = sqrt(rand()) * this.radius // 使距離分佈均勻\n    → Compute x = this.x_center + r * cos(θ) // 轉換為座標\n    → Compute y = this.y_center + r * sin(θ) // 轉換為座標\n    → Return [x, y] // 返回點\nEnd // 程式結束\n\nWe must use virtual code arrows. Use \"→\" before each step. Use \"Decision:\" if necessary. No need.\n\nEnsure each line ends with // 解釋. We must include \"Start\" and \"End\". Use spaces as required. Provide each step on separate line.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class Solution with properties radius, x_center, y_center // 初始化類別與屬性  \n→ Step 2: Constructor(radius, x_center, y_center) // 接收半徑與中心座標  \n  → Assign this.radius = radius // 儲存半徑  \n  → Assign this.x_center = x_center // 儲存中心的 x 座標  \n  → Assign this.y_center = y_center // 儲存中心的 y 座標  \n→ Step 3: Method randPoint() // 產生一個隨機點  \n  → Generate random angle θ = 2π * rand() // 隨機角度，範圍 0~2π  \n  → Generate random radius r = sqrt(rand()) * this.radius // 隨機半徑，使分佈均勻  \n  → Compute x = this.x_center + r * cos(θ) // 將極座標轉換為直角座標的 x  \n  → Compute y = this.y_center + r * sin(θ) // 將極座標轉換為直角座標的 y  \n  → Return [x, y] // 回傳隨機點的座標  \nEnd // 程式執行結束"
    },
    {
      "title": "4Sum",
      "source_file": "Leetcode/leetcode18.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_rkgf8jm.py\", line 47, in <module>\n    target_str = target_part.split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgbe8ngwc.py\", line 47, in <module>\n    target_str = target_part.split('=')[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        n = len(nums)\n        res: List[List[int]] = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Expected input format: 'nums = [...], target = X'\n    parts = raw_input.split(',')\n    nums_part = parts[0].strip()\n    target_part = parts[1].strip()\n\n    # Extract the list of numbers and the target value\n    nums_str = nums_part.split('=')[1].strip()\n    target_str = target_part.split('=')[1].strip()\n\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n\n    # Compute the result\n    result = Solution().fourSum(nums, target)\n\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for four sum problem. Must output line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. Let's produce algorithm: sort array, use nested loops i, j then two pointers left, right. Avoid duplicates. Steps: Start, Step 1: sort, Step 2: iterate i, check duplicates, Step 3: iterate j, etc. Provide decisions for duplicates and target sum comparisons. End. Ensure each line has arrow and explanation. Use Start and End. Use Decision: If ...? lines. Use Yes → and No → lines. Also need to mention result array initialization. Ok. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums ← sort(nums) // 先將輸入陣列排序，方便後續雙指標與去重  \n→ Step 2: result ← [] // 建立結果列表，用於儲存符合條件的四元組  \n→ Decision: 如果 nums 長度 < 4? // 先檢查是否足夠取四個數字  \n  Yes → End // 不足四個，直接結束  \n  No  → Step 3: for i from 0 to len(nums)-4 // 第一個指標 i  \n→ Decision: 如果 i > 0 且 nums[i] == nums[i-1]? // 去重第一個數字  \n  Yes → Continue // 跳過重複的 i  \n  No  → Step 4: for j from i+1 to len(nums)-3 // 第二個指標 j  \n→ Decision: 如果 j > i+1 且 nums[j] == nums[j-1]? // 去重第二個數字  \n  Yes → Continue // 跳過重複的 j  \n  No  → Step 5: left ← j+1, right ← len(nums)-1 // 設定左、右雙指標  \n→ Decision: 當 left < right? // 只要左指標在右指標左邊  \n  Yes → Step 6: sum ← nums[i] + nums[j] + nums[left] + nums[right] // 計算四個數的和  \n    Decision: sum == target? // 是否正好等於目標值  \n      Yes → Step 7: result.append([nums[i], nums[j], nums[left], nums[right]]) // 加入結果"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[None,[1,2,3],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[None, [1, 2, 3], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"封裝陣列的隨機洗牌與重設功能。\"\"\"\n    def __init__(self, nums):\n        # 原始陣列，保持不變\n        self._original = list(nums)\n\n    def reset(self):\n        \"\"\"\n        回傳原始陣列。\n        為避免外部修改，回傳原始陣列的複製。\n        \"\"\"\n        return list(self._original)\n\n    def shuffle(self):\n        \"\"\"\n        依照 Fisher‑Yates 演算法，隨機打亂陣列。\n        這裡不改變原始陣列，而是回傳一個新的亂序列表。\n        \"\"\"\n        arr = list(self._original)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef _parse_input(data: str):\n    \"\"\"\n    解析輸入字串，輸入格式為兩個 JSON 陣列\n    以逗號分隔，兩個陣列的深度不為 0 時不做分割。\n    例：'[\"Solution\", \"shuffle\"], [[[1,2,3]], []]'\n    \"\"\"\n    depth = 0\n    split_pos = None\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_pos = i\n            break\n    if split_pos is None:\n        raise ValueError(\"輸入格式錯誤\")\n    left = data[:split_pos].strip()\n    right = data[split_pos + 1 :].strip()\n    return json.loads(left), json.loads(right)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    commands, args = _parse_input(raw_input)\n\n    results = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(arg[0])\n            results.append(None)\n        elif cmd == \"reset\":\n            results.append(obj.reset())\n        elif cmd == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            raise ValueError(f\"未知的命令: {cmd}\")\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation. The user wants algorithm: shuffle array uniformly. That's Fisher-Yates. Also need reset.\n\nWe need to produce virtual code: class Solution with constructor storing original, a copy current array. reset returns original, but should reset current array to original copy. shuffle performs Fisher-Yates on current array copy. Provide virtual code steps. The requirement: each line is \"虛擬碼步驟 [space] // 解釋\". Use arrow → etc. Must be incremental steps. Probably need Start, End. Use Decision: etc.\n\nLet's produce a structure:\n\nStart // program start\n→ Step 1: Define class Solution // declare class\n→ Step 2: Declare property originalNums // store original\n→ Step 3: Declare property nums // current array\n→ Step 4: Constructor nums input\n   → Step 4.1: originalNums ← copy(nums) // deep copy\n   → Step 4.2: nums ← copy(nums) // initialize current\n→ Step 5: reset method\n   → Step 5.1: nums ← copy(originalNums) // reset\n   → Step 5.2: return nums // return\n→ Step 6: shuffle method\n   → Step 6.1: for i from length-1 downto 1\n        → Step 6.1.1: j ← random integer [0, i] // pick index\n        → Step 6.1.2: swap nums[i] with nums[j] // Fisher-Yates\n   → Step 6.2: return nums // shuffled array\nEnd\n\nAlso explain each step.\n\nAlso need to include decision maybe not needed. But we can keep simple.\n\nLet's produce each line accordingly.\n\nNote: Virtual code arrow \"→\". Use colon. Provide comment.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 宣告成員 originalNums // 用於儲存原始陣列  \n→ Step 3: 宣告成員 nums // 用於儲存目前陣列（會被 shuffle 或 reset 改寫）  \n\n→ Step 4: 建構子 Solution(int[] nums) // 接收初始陣列  \n  → Step 4.1: originalNums ← copy(nums) // 深複製原始陣列，確保不被修改  \n  → Step 4.2: nums ← copy(nums) // 初始化目前陣列為原始值  \n\n→ Step 5: 方法 reset() : int[] // 重設陣列  \n  → Step 5.1: nums ← copy(originalNums) // 重新複製原始陣列到 nums  \n  → Step 5.2: return nums // 回傳重設後的陣列  \n\n→ Step 6: 方法 shuffle() : int[] // 隨機洗牌  \n  → Step 6.1: for i from nums.length - 1 downto 1  \n     → Step 6.1.1: j ← random integer in [0, i] // 隨機選取 0~i 的索引  \n     → Step 6.1.2: swap nums[i] with nums[j] // Fisher‑Yates 交換  \n  → Step 6.2: return nums // 回傳已洗牌的陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])          # store a copy of the current subset\n            for i in range(start, len(nums)):\n                path.append(nums[i])     # include nums[i]\n                backtrack(i + 1, path)   # recurse with next start index\n                path.pop()               # backtrack, remove nums[i]\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # Read the entire input; expected format e.g. \"nums = [1,2,3]\"\n    data = sys.stdin.read().strip()\n    if not data:\n        nums = []\n    else:\n        # Extract the list part after the '=' sign\n        if '=' in data:\n            _, list_str = data.split('=', 1)\n        else:\n            list_str = data\n        nums = eval(list_str.strip(), {\"__builtins__\": {}})\n    # Compute all subsets\n    sol = Solution()\n    result = sol.subsets(nums)\n    # Output without spaces, matching the example format\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to output virtual code with explanations for generating all subsets of unique elements array, no duplicates. Use recursion or iterative. We'll create Start, read input, define recursive function to generate subsets. We'll use index, current subset, result list. Use decision to handle inclusion/exclusion. Then End. Provide explanation. Ensure each line has virtual code step then comment. Use arrows. Provide indentation maybe. But each line separate.\n\nLet's produce:\n\nStart\n→ Step 1: 接收陣列 nums // 取得輸入數組\n→ Step 2: 定義 result 為空列表 // 儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(index, path) // index 為目前處理的元素位置，path 為已選元素\n    → Decision: 如果 index 等於 nums 長度? // 確定已處理完所有元素\n        Yes → Step 4: result 加入 path 的複製 // 存入一個完整子集\n        No  → Step 5: 進行兩個遞迴分支\n            → Step 5a: backtrack(index + 1, path + [nums[index]]) // 包含當前元素\n            → Step 5b: backtrack(index + 1, path) // 不包含當前元素\n→ Step 6: 呼叫 backtrack(0, []) // 從第一個元素開始，路徑初始為空\n→ Step 7: 回傳 result // 返回所有子集\nEnd\n\nMake sure each line includes comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收陣列 nums // 取得輸入數組  \n→ Step 2: 定義 result 為空列表 // 儲存所有子集  \n→ Step 3: 定義遞迴函式 backtrack(index, path) // index 為目前處理的元素位置，path 為已選元素  \n  → Decision: 如果 index 等於 nums 長度? // 確定已處理完所有元素  \n   Yes → Step 4: result 加入 path 的複製 // 存入一個完整子集  \n   No  → Step 5: 進行兩個遞迴分支  \n    → Step 5a: backtrack(index + 1, path + [nums[index]]) // 包含當前元素  \n    → Step 5b: backtrack(index + 1, path) // 不包含當前元素  \n→ Step 6: 呼叫 backtrack(0, []) // 從第一個元素開始，路徑初始為空  \n→ Step 7: 回傳 result // 返回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Binary Search",
      "source_file": "Leetcode/leetcode704.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprhd8c0m7.py\", line 41, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmprhd8c0m7.py\", line 28, in parse_input\n    raise ValueError(\"無法找到 nums 列表\")\nValueError: 無法找到 nums 列表"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwu8v0fyw.py\", line 41, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwu8v0fyw.py\", line 28, in parse_input\n    raise ValueError(\"無法找到 nums 列表\")\nValueError: 無法找到 nums 列表"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\ndef parse_input(data: str):\n    \"\"\"\n    將輸入字串解析成 nums 列表與 target 整數。\n    例子: 'nums = [-1,0,3,5,9,12], target = 9'\n    \"\"\"\n    # 拆分成兩部分\n    nums_part, target_part = data.split(',', 1)\n\n    # 取得列表字串並轉換為整數列表\n    nums_match = re.search(r'\\[(.*?)\\]', nums_part)\n    if not nums_match:\n        raise ValueError(\"無法找到 nums 列表\")\n    nums_str = nums_match.group(1)\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n\n    # 取得 target 整數\n    target = int(target_part.split('=')[1].strip())\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    nums, target = parse_input(raw_input)\n    sol = Solution()\n    result = sol.search(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for binary search algorithm. Each line with explanation.\n\nUse Start, End, Decision: with arrow syntax. Provide line by line. Use 虛擬碼步驟 and explanation. Should use Chinese. Use \"Start\" etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 low = 0, high = nums.length - 1 // 設定搜尋區間\n→ Decision: 如果 low <= high? // 檢查區間是否仍有效\n    Yes → Step 2: mid = (low + high) // 2 // 計算中間索引\n    → Decision: 如果 nums[mid] 等於 target? // 檢查中間元素是否為目標\n        Yes → Step 3: 回傳 mid // 找到目標，返回索引\n        No → Decision: 如果 nums[mid] < target? // 目標在右半邊？\n            Yes → Step 4: low = mid + 1 // 將 low 移到右半邊的起點\n            No  → Step 5: high = mid - 1 // 將 high 移到左半邊的終點\n        → 回到 Decision: 如果 low <= high? // 重新檢查區間\n    No  → Step 6: 回傳 -1 // 目標不存在，返回 -1\nEnd // 程式執行結束\n\nNeed to format exactly. Each line must be \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before steps.\n\nAlso indent? It's okay to use indentation but not necessary. Provide each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0, high = nums.length - 1 // 設定搜尋區間  \n→ Decision: low <= high? // 檢查區間是否仍有效  \n Yes → Step 2: mid = (low + high) // 2 // 計算中間索引  \n  → Decision: nums[mid] == target? // 檢查中間元素是否為目標  \n   Yes → Step 3: return mid // 找到目標，返回索引  \n   No → Decision: nums[mid] < target? // 目標在右半邊？  \n    Yes → Step 4: low = mid + 1 // 將 low 移到右半邊的起點  \n    No  → Step 5: high = mid - 1 // 將 high 移到左半邊的終點  \n   → 回到 Decision: low <= high? // 重新檢查區間  \n No  → Step 6: return -1 // 目標不存在，返回 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"建構時計算前綴和與總權重。\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機挑選一個索引，符合權重比例。\"\"\"\n        # 產生 1~total 的隨機整數\n        target = random.randint(1, self.total)\n        # 二分搜尋找到對應的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 把輸入包在一個外層方括號中，便於使用 json.loads 解析\n    data = json.loads('[' + raw + ']')\n    methods, args_list = data[0], data[1]\n\n    results = []\n    obj = None  # 會在遇到 \"Solution\" 時實例化\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子只接受一次，使用 *args 展開\n            obj = Solution(*args)\n            results.append(None)  # 构造函数返回 None\n        else:\n            # 呼叫對應的方法並收集返回值\n            func = getattr(obj, method)\n            results.append(func(*args))\n\n    # 輸出結果，使用 json.dumps 以符合範例格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for implementing pickIndex that picks weighted random index. The virtual code should use arrow notation. We need to do initialization, prefix sum array, random number generation, binary search.\n\nWe should produce line by line: Start, build prefix sums, function pickIndex.\n\nWe must avoid actual code; use pseudo.\n\nInclude explanation after //.\n\nLet's design:\n\nStart // program start\n\n→ Step 1: Input array w // read weights\n\n→ Step 2: Compute prefixSum array ps where ps[i] = sum w[0..i] // cumulative weights\n\n→ Step 3: Set total = ps[last] // total sum\n\n→ Step 4: Define function pickIndex() // function\n\n→ Decision: 在 pickIndex 中\n\n→ Step 5: Generate random integer r in [1, total] // random weight threshold\n\n→ Step 6: Perform binary search on ps to find smallest index i such that ps[i] >= r // mapping\n\n→ Step 7: Return i // output\n\nEnd\n\nAlso maybe mention that we use random number generator.\n\nAdd explanations.\n\nMake sure each line has arrow and explanation.\n\nUse \"→\" for steps.\n\nWe also need Decision lines: maybe for binary search. But we can keep simple.\n\nLet's produce.\n\nUse \"Start // 程式開始執行\"\n\n\"→ Step 1: Initialize weights array w\" etc.\n\nOk.\n\nWe should produce output with lines separated.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收正整數陣列 w // 取得每個索引的權重\n→ Step 2: 建立前綴和陣列 ps，並逐個計算 ps[i] = ps[i-1] + w[i]（i>0）// 前綴和用於快速查找累積權重\n→ Step 3: 設定 total = ps[last] // total 為所有權重之和\n→ Step 4: 定義函式 pickIndex() // 進行隨機挑選\n→     Decision: 在 pickIndex 內部\n→         Step 5: 產生隨機整數 r，範圍為 1 到 total（包含兩端）// r 代表一個「虛擬」權重點\n→         Step 6: 在 ps 陣列上執行二分搜尋，尋找最小的索引 i 使得 ps[i] ≥ r // 對應 r 在累積權重區間內的索引\n→         Step 7: 回傳索引 i // 返回符合權重比例的索引\nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn_b13neg.py\", line 23, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5pklel5u.py\", line 23, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 使用 exec 解析輸入，假設輸入格式為: mat = [[...]], k = ...\n    namespace = {}\n    exec(data, {}, namespace)\n    mat = namespace['mat']\n    k = namespace['k']\n    result = Solution().kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code with explanation per line, in Traditional Chinese. The problem: find k weakest rows. We need steps: read matrix, compute count of soldiers per row using binary search or count. Then store pairs (count, index). Sort by count ascending, index ascending. Pick first k indices.\n\nImplement virtual code: Start, Step: count soldiers per row, etc.\n\nUse Decision, loops.\n\nWe must output line by line, each line with virtual code + space + // explanation.\n\nWe need to use arrows →, Yes →, No → etc.\n\nWe should include Start and End.\n\nLet's write.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: 讀取矩陣 mat 和整數 k // 取得輸入資料\n\nLine3: → Step 2: 初始化空陣列 rows // 用於存儲行資訊\n\nLine4: → Decision: 是否已處理完所有行? // 檢查是否還有行待處理\n\nBut we need loop. Let's create loop.\n\nWe can use while i < m.\n\nLine4: → Step 3: 設定 i = 0 // 行索引初始值\n\nLine5: → Decision: i < m? // 判斷是否還有行\n\n   Yes → Step 4: 計算 rowCount = 二分搜尋 mat[i] 1 的個數 // 找出行 i 的士兵數\n\n   Step 5: 將 (rowCount, i) 加入 rows // 存入行資訊\n\n   Step 6: i = i + 1 // 移至下一行\n\n   → Decision: 回到 Step 5? // 迴圈\n\nBut we need proper arrow format: Maybe we show loop with Decision and Yes →.\n\nBetter:\n\nLine5: → Decision: i < m? // 是否還有行未處理\n\n   Yes → Step 4: rowCount = 二分搜尋 mat[i] 1 的個數 // 取得第 i 行的士兵數\n\n   → Step 5: rows.append((rowCount, i)) // 存行資訊\n\n   → Step 6: i = i + 1 // 移到下一行\n\n   → Decision: i < m? // 重複循環\n\n       Yes → (回到 Step 4) // 迴圈\n\n       No → Step 7: 對 rows 進行排序，先按 rowCount，再按 index // 排序\n\nLine8: → Step 8: 提取 rows 前 k 個的 index // 取得最弱的 k 行\n\nLine9: → Step 9: 輸出結果 // 回傳索引列表\n\nLine10: End // 程式結束\n\nBut need to incorporate arrow for recursion. Format: For Decision, we show Yes → and No → lines.\n\nWe can format:\n\n→ Decision: i < m? // 判斷是否還有行\n\n    Yes → Step 4: ...\n\n    No  → Step 7: ...\n\nBut inside Yes we may need sub-steps. Let's structure:\n\nStart\n\n→ Step 1: 讀取 mat 和 k\n\n→ Step 2: 初始化 rows 為空\n\n→ Step 3: i = 0\n\n→ Decision: i < m? // 仍有行\n\n    Yes → Step 4: rowCount = 二分搜尋 mat[i] 1 的個數\n\n    → Step 5: rows.append((rowCount, i))\n\n    → Step 6: i = i + 1\n\n    → Decision: i < m? // 迴圈\n\n        Yes → (跳回 Step 4)\n\n        No  → Step 7: 對 rows 依 rowCount 與 index 排序\n\n→ Step 8: result = 取 rows 前 k 個的 index\n\n→ Step 9: 輸出 result\n\nEnd\n\nWe need to provide explanation after each line.\n\nAlso need to handle binary search for number of soldiers in each row: \"二分搜尋 mat[i] 1 的個數\" could be described as \"利用二分搜尋計算行中的 1 的數量\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取矩陣 mat 以及整數 k // 取得輸入資料  \n→ Step 2: 初始化空陣列 rows // 用於存放 (士兵數, 行號)  \n→ Step 3: i ← 0 // 行索引初始值  \n→ Decision: i < m? // 是否還有未處理的行  \n Yes → Step 4: rowCount ← 二分搜尋 mat[i] 中 1 的個數 // 計算第 i 行的士兵數  \n  → Step 5: rows.append((rowCount, i)) // 存入行資訊  \n  → Step 6: i ← i + 1 // 前進到下一行  \n  → Decision: i < m? // 迴圈判斷  \n   Yes → (回到 Step 4) // 重新處理下一行  \n   No  → Step 7: 對 rows 按 rowCount 升序、若相同則按行號升序排序 // 確定弱行順序  \n→ Step 8: result ← rows 前 k 個元素的行號 // 取得最弱的 k 行  \n→ Step 9: 輸出 result // 回傳索引列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        if n == 1:\n            # For n=1, the minimal string is simply all digits in order\n            return ''.join(str(i) for i in range(k))\n\n        seen = set()\n        res = []\n\n        def dfs(node: str):\n            for x in map(str, range(k)):\n                nei = node + x\n                if nei not in seen:\n                    seen.add(nei)\n                    dfs(nei[1:])\n                    res.append(x)\n\n        start = \"0\" * (n - 1)\n        dfs(start)\n        # Append the starting node to make the string linear\n        return ''.join(res) + start\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) >= 2:\n        n, k = nums[0], nums[1]\n        solution = Solution()\n        result = solution.crackSafe(n, k)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps describing algorithm to produce minimal length string that guarantees unlocking safe: this is essentially shortest supersequence containing all k^n sequences? Actually requirement: need string such that when scanning sliding window of size n, at some point window equals the password. For arbitrary unknown password? Wait \"the correct password is unknown\" but we want string that will guarantee unlocking at some point for any possible password? It says return any string of minimum length that will unlock the safe at some point of entering it. So we need a string that covers all possible passwords as substrings of length n. So minimal length is de Bruijn sequence of order n over alphabet size k. The string should be of length k^n + n -1? Actually a de Bruijn sequence of length k^n and cyclic, but linear version to guarantee all length-n strings appear as substrings of a linear string: can output de Bruijn sequence of length k^n + n -1 to include wrap-around. So algorithm: construct de Bruijn sequence via DFS or Hierholzer on de Bruijn graph. So virtual steps.\n\nWe need to produce pseudocode with explanation. Each line as per format. Let's produce steps:\n\nStart\n→ Step: define alphabet [0, k-1]\n→ Step: construct directed graph nodes are (n-1)-length strings, edges labeled by digits, edge from node u to v by appending digit d to u and dropping first char\n→ Step: perform Hierholzer to find Eulerian circuit\n→ Step: output sequence of digits along circuit, start with node string, then each edge label\n→ Step: append first n-1 digits to end to make linear string\n→ End\n\nAdd decisions: if n==1? handle base.\n\nProvide explanation comments.\n\nWe need to be careful: \"逐行\" means each line separate. Provide steps like:\n\nStart // 程式開始執行\n→ Step 1: 如果 k 或 n 小於 1 → Error // 檢查輸入合法性\nYes → Step 2: 定義字母表 A = {0, 1, ..., k-1} // 字母表\nNo  → ...\n\nBut we don't need error handling. Just simple.\n\nWe must use arrows etc.\n\nLet's produce:\n\nStart // 開始執行\n→ Step: 建立節點集合：所有長度為 n-1 的字串 // 每個節點代表窗口前 n-1 位\n→ Step: 為每個節點 u 和每個字母 a ∈ A 建立有向邊 u → v，其中 v = (u 的後 n-2 位 + a) // 邊標記為 a\n→ Decision: 檢查每個節點是否有出邊數等於 k? // 確保圖是 Eulerian\n    Yes → Step: 執行 Hierholzer 演算法取得 Eulerian 循環 // 遞迴 DFS\n    No  → Step: 失敗 // 但在此問題中總是成立\n→ Step: 從循環得到邊序列，將第一個節點的字串加入輸出序列 // 初始 n-1 位\n→ Step: 對於每條邊的標籤 a，將 a 加到輸出序列 // 生成 de Bruijn 序列長度 k^n\n→ Step: 將前 n-1 位字串再次附加到輸出尾部 // 形成線性序列長度 k^n + n -1\n→ End // 結束\n\nAdd explanation after each line.\n\nWe must keep each line with \"虛擬碼步驟 [space] // 解釋\". Use arrows \"→\". Use decision blocks.\n\nLet's produce lines accordingly. Ensure no actual code. Use placeholders like \"Step 1\". Use Chinese.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立節點集合：所有長度為 n-1 的字串 // 每個節點代表滑動窗口的前 n-1 位  \n→ Step 2: 為每個節點 u 與每個字母 a∈{0,…,k-1} 建立有向邊 u→v，其中 v = (u 的後 n-2 位 + a) 並以 a 為邊標籤 // 构造 De Bruijn 图  \n→ Decision: 檢查每個節點是否有出邊數等於 k? // 確保圖是 Eulerian，這在 De Bruijn 圖中必定成立  \n  Yes → Step 3: 執行 Hierholzer 演算法取得 Eulerian 循環 // 以 DFS 方式遍歷所有邊  \n  No → Step 4: 失敗 // 在此問題中不會發生  \n→ Step 5: 從得到的 Eulerian 循環中取出邊序列，將起始節點的字串放入輸出序列 // 產生 de Bruijn 序列的前 n-1 位  \n→ Step 6: 按循環順序，將每條邊的標籤 a 依序附加到輸出序列 // 完成長度 kⁿ 的循環序列  \n→ Step 7: 將最初的 n-1 位字串再次附加到輸出序列尾部 // 形成線性序列長度 kⁿ + n - 1，確保所有長度 n 的子序列皆出現  \nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        m, n = len(num1), len(num2)\n        pos = [0] * (m + n)\n        for i in range(m-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n                pos[p1] += sum_ // 10\n                pos[p2] = sum_ % 10\n        # Convert to string, strip leading zeros\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\ndef main():\n    data = sys.stdin.read()\n    # Try to extract numbers from input\n    numbers = re.findall(r\"\\d+\", data)\n    if len(numbers) >= 2:\n        num1, num2 = numbers[0], numbers[1]\n    else:\n        # fallback: split by whitespace\n        tokens = data.strip().split()\n        num1 = tokens[0] if tokens else ''\n        num2 = tokens[1] if len(tokens) > 1 else ''\n    sol = Solution()\n    print(sol.multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is multiplication of large numbers represented as strings without converting to int. We need to implement multiplication algorithm, probably schoolbook multiplication using arrays of digits. Steps: convert strings to array of ints reversed, create result array of length len1+len2, nested loops multiply and accumulate with carry. Then convert to string removing leading zeros. Let's produce step-by-step virtual code with decision nodes. Use Start, End. Use arrows and decisions. Each line: 虛擬碼步驟 // 解釋\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: If num1 == \"0\" or num2 == \"0\" → Step 2: Return \"0\" // Quick zero check\n→ Step 3: Convert num1 and num2 to reversed integer arrays // 把字串轉為倒序整數陣列\n→ Step 4: 初始化 result array of length len1 + len2 為 0 // 用於儲存乘積\n→ For i from 0 to len1-1: // 外層迴圈\n    → For j from 0 to len2-1: // 內層迴圈\n        → temp = num1Digits[i] * num2Digits[j] + result[i+j] // 乘法加上已有值\n        → result[i+j] = temp % 10 // 存入位數\n        → result[i+j+1] += temp / 10 // 把進位加到下一位\n→ Step 5: 將 result 轉回字串，跳過最高位的 0 // 去除前導零並轉為字串\n→ End // 結束\n\nNeed to also handle leading zeros removal after conversion. Decision: If result last index zero? But we will skip zeros.\n\nWe can incorporate decisions: While last element is zero and length >1, pop.\n\nSo steps:\n\nStart // 程式開始\n→ Decision: If num1 == \"0\" or num2 == \"0\"? // 判斷是否有零\n    Yes → Step 0: Return \"0\" // 直接回傳\n    No → Proceed\n\nBut cannot use return until End.\n\nWe'll produce: Step 0: Quick zero check.\n\nBut virtual code we can embed decision and return.\n\nBetter:\n\nStart\n→ Step 1: 將 num1、num2 轉為倒序整數陣列 // 方便從低位開始計算\n→ Step 2: 建立 result 陣列長度 len1+len2 全零 // 用於累積乘積\n→ Step 3: For i in 0..len1-1:\n    → For j in 0..len2-1:\n        → temp = num1Digits[i] * num2Digits[j] + result[i+j]\n        → result[i+j] = temp % 10\n        → result[i+j+1] += temp / 10\n→ Step 4: 移除結果中最高位的 0 直到只剩一位或遇到非零 // 去除前導零\n→ Step 5: 反轉 result 並轉為字串 // 形成最終輸出\n→ End\n\nAlso need Decision for zero check: Step 0.\n\nLet's craft lines with arrow syntax. Use \"→\" and \"Decision:\" with Yes →, No →.\n\nWe need to adhere to format: each line \"虛擬碼步驟 [space] // 解釋/說明\".\n\nThus each line must contain a virtual code step. For nested loops we need separate lines for each iteration maybe but we can show the structure.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Decision: 是否 num1 為 \"0\" 或 num2 為 \"0\"? // 快速檢查是否有零\n    Yes → Step 0: 回傳 \"0\" // 直接返回\n    No  → Step 1: 把 num1 與 num2 轉為倒序整數陣列 // 方便低位優先計算\n→ Step 2: 初始化 result 陣列長度 len1+len2 為 0 // 用於儲存乘積\n→ For i 0 到 len1-1:\n    → For j 0 到 len2-1:\n        → temp = num1Digits[i] * num2Digits[j] + result[i+j] // 乘法加上已有值\n        → result[i+j] = temp % 10 // 存入單位位\n        → result[i+j+1] += temp / 10 // 將進位加到下一位\n→ Step 3: 處理結果中的前導零 // 去除多餘的最高位 0\n    → While result 最後一個元素 == 0 且長度 > 1: // 只保留一個零\n        → 移除最後一個元素\n→ Step 4: 反轉 result 並轉為字串 // 產生最終乘積字串\n→ End // 程式執行結束\n\nWe should include decision inside loop? No need.\n\nThe lines after decision \"Yes\" and \"No\" we have sublines. Format shows \"Yes →\" etc. So we need to indent the steps under decisions maybe but we just keep each line. Use indentation? It's optional but easier to read.\n\nWe must ensure each line is a single line of code with explanation. The Decision line must have two arrows: Yes → and No → each with following step. So we should produce lines like:\n\n→ Decision: num1 == \"0\" 或 num2 == \"0\"? // 判斷是否為零\n    Yes → Step 0: 回傳 \"0\" // 直接返回\n    No  → Step 1: 把 num1 與 num2 轉為倒序整數陣列 // 方便低位優先計算\n\nBut we might need to keep each line separate; but the Decision line and the Yes/No lines are separate. But we can treat the Yes and No lines as part of the decision. Provide them as separate lines following the Decision line. But the example in prompt shows nested indentation. Let's follow that pattern:\n\n→ Decision: If 數字大於 0? // ...\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nSo we can copy that style.\n\nThus:\n\n→ Decision: num1 == \"0\" 或 num2 == \"0\"? // 快速檢查是否有零\n    Yes → Step 0: 回傳 \"0\" // 直接返回\n    No  → Step 1: 把 num1 與 num2 轉為倒序整數陣列 // 方便低位優先計算\n\nWe need to maintain that. Let's produce accordingly.\n\nAlso we need to use \"Start\" and \"End\".\n\nAlso ensure no actual code, only virtual. So no actual loops syntax but we can show \"For i 0 到 len1-1:\" etc. That's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: num1 == \"0\" 或 num2 == \"0\"? // 快速檢查是否有零  \n    Yes → Step 0: 回傳 \"0\" // 直接返回乘積為零  \n    No  → Step 1: 把 num1 與 num2 轉為倒序整數陣列 // 方便從最低位開始計算  \n→ Step 2: 初始化 result 陣列長度 len1+len2 為 0 // 用於累積乘積  \n→ For i 0 到 len1-1: // 外層迴圈遍歷 num1 的每一位  \n    → For j 0 到 len2-1: // 內層迴圈遍歷 num2 的每一位  \n        → temp = num1Digits[i] * num2Digits[j] + result[i+j] // 乘法加上已存在的值  \n        → result[i+j] = temp % 10 // 將單位位存回 result  \n        → result[i+j+1] += temp / 10 // 把進位加到下一個位置  \n→ Step 3: 處理 result 中的前導零 // 去除多餘的最高位 0  \n    → While result 最後一個元素 == 0 且長度 > 1: // 只保留一個零  \n        → 移除最後一個元素  \n→ Step 4: 反轉 result 並轉為字串 // 產生最終乘積字串  \n→ End // 程式執行結束"
    }
  ]
}