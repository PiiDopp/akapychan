{
  "run_index": 21,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 288,
  "generation_or_validation_failure_count": 46,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef count_file_lines():\n    \"\"\"讀取 data.txt 檔案並輸出行數，若檔案不存在則印出錯誤訊息。\"\"\"\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\ndef main():\n    # 讀取 stdin（符合測試規範），但不將其作為計算資料\n    _ = sys.stdin.read()\n    count_file_lines()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Use arrows, Start, End, Decision, etc. Should include try/except and with. Steps: Start, try: open file, with open... readlines, count lines, print count. Except FileNotFoundError: print error. End.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use \"→\" before each step maybe. Use decision? There's no decision? We could include decision for existence but it's handled by exception. But can add decision after reading lines? Not needed. Just simple.\n\nBut requirement: use with syntax with try/except. Use Decision? Might use decision for exception? We can use Decision to check if file opened successfully? But try/except covers. We could add Decision: 如果檔案存在? But we don't check directly.\n\nBetter: Start, → Decision: if file exists? But can't easily check.\n\nMaybe structure:\n\nStart // 程式開始\n→ Decision: 檢查檔案是否存在? // 先決定是否進行開啟\n    Yes → Step: 開啟檔案並讀取行數\n    No  → Step: 顯示錯誤訊息\n\nBut we need try/except. Maybe we skip decision, just try/except.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 嘗試使用 try 語句打開檔案 // 準備檔案處理\n    → Step: with open('data.txt', 'r') as f: // 使用 with 確保正確關閉\n        → Step: 讀取所有行 into lines = f.readlines() // 讀取檔案內容\n        → Step: 計算行數 count = len(lines) // 計算行數\n        → Step: 輸出 count // 顯示行數\n→ Except: FileNotFoundError as e: // 檔案不存在的例外處理\n    → Step: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\" at start of each step. For decision maybe not needed. Use Indentation? We can just indent steps after try/except. Use \"→ Decision:\" if needed but not mandatory. But guidelines mention using Decision if needed. We can skip.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step: 嘗試使用 try 語句打開檔案 // 準備檔案處理\n    → Step: with open('data.txt', 'r') as f: // 使用 with 確保正確關閉\n        → Step: 讀取所有行 into lines = f.readlines() // 讀取檔案內容\n        → Step: 計算行數 count = len(lines) // 計算行數\n        → Step: 輸出 count // 顯示行數\n→ Except: FileNotFoundError as e: // 檔案不存在的例外處理\n    → Step: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut each line must be single line, no indentation? In example they use indentation for decision branches. We can use indentation as above. So we need to keep each line as separate line. The lines starting with \"→\" and nested inside indent. That seems acceptable.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 嘗試使用 try 語句打開檔案 // 準備檔案處理\n    → Step: with open('data.txt', 'r') as f: // 使用 with 確保正確關閉\n        → Step: 讀取所有行 into lines = f.readlines() // 讀取檔案內容\n        → Step: 計算行數 count = len(lines) // 計算行數\n        → Step: 輸出 count // 顯示行數\n→ Except: FileNotFoundError as e: // 檔案不存在的例外處理\n    → Step: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,4,4,1,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 4, 4, 1, 4]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的清單。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取整個標準輸入的內容\n    code = sys.stdin.read()\n    # 執行輸入的程式碼，讓使用者自行呼叫 roll_dice 或其他操作\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrow (→) and Decision: etc. Start and End. For function definition and loop and random import. Must not output actual code, just pseudocode. The user wants: using random module, function roll_dice(n) simulate n times six-sided dice, return list of results. Provide virtual code with explanations.\n\nWe need to output line by line: Start, → Step ... etc. Include import random, function definition, local list, loop, random.randint(1,6), append, return, End.\n\nMake sure to follow format: \"Start // 程式開始執行\" etc. Each line uses virtual arrow. For function definition, maybe \"Step 1: Define function roll_dice(n)\". Then import random maybe before? Typically import at top: \"Step 0: Import random module\".\n\nThen loop: Decision: if n > 0? Not necessary but could add.\n\nSimpler: just loop for i in range(n): append random 1-6.\n\nOk.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 0: Import random 模組 // 引入 random 模組以產生隨機數\n→ Step 1: 定義函數 roll_dice(n) // 宣告 roll_dice 函數，參數為擲骰次數\n    → Step 2: 初始化結果清單 results = [] // 建立空清單儲存每次擲骰結果\n    → Decision: n 是否大於 0? // 確認擲骰次數是否有效\n        Yes → Step 3: 開始 for 迴圈 i 從 1 到 n // 逐次擲骰\n            → Step 4: 產生隨機數 roll = random.randint(1,6) // 擲一顆六面骰\n            → Step 5: 將 roll 加入 results // 儲存結果\n        No → Step 6: // 若 n 為 0 或負數，直接跳過迴圈\n    → Step 7: 回傳 results // 返回所有擲骰結果清單\nEnd // 程式執行結束\n\nEnsure each line with arrow. Use \"→\" for each step after Start. For nested steps inside function, indent maybe with spaces. But still maintain arrow. For Decision, show Yes/No lines.\n\nCheck formatting: each line must be \"虛擬碼步驟 [space] // 解釋\". The decision line should include \"Decision:\" and then Yes→ and No→ lines each preceded by arrow? Example in sample: \"Decision: 如果數字大於 0?\" then \"Yes → Step 2:\" etc. So we follow that.\n\nThus output lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: Import random 模組 // 引入 random 模組以產生隨機數  \n→ Step 1: 定義函數 roll_dice(n) // 宣告 roll_dice 函數，參數為擲骰次數  \n → Step 2: 初始化結果清單 results = [] // 建立空清單儲存每次擲骰結果  \n → Decision: n 是否大於 0? // 確認擲骰次數是否有效  \n  Yes → Step 3: 開始 for 迴圈 i 從 1 到 n // 逐次擲骰  \n   → Step 4: 產生隨機數 roll = random.randint(1,6) // 擲一顆六面骰  \n   → Step 5: 將 roll 加入 results // 儲存結果  \n  No → // 若 n 為 0 或負數，直接跳過迴圈  \n → Step 6: 回傳 results // 返回所有擲骰結果清單  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量 func 執行所需的秒數，並四捨五入到小數點 3 位。\n    \"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    主函式：從標準輸入讀取整個程式碼，執行並輸出結果。\n    \"\"\"\n    # 讀取整個輸入（預期為一段 Python 程式碼）\n    code = sys.stdin.read()\n\n    # 準備執行環境，確保 measure_time 在全域可見\n    exec_globals = {\n        \"measure_time\": measure_time,\n        \"time\": time,\n    }\n\n    # 執行讀取到的程式碼，程式碼中的 print 將直接輸出到 stdout\n    exec(code, exec_globals)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation, following format. Each line: `虛擬碼步驟 // 解釋/說明`. Use arrows, Start, End, Decision. We'll create steps: Start, import time (virtual code), define function measure_time, record start time, call func(*args), record end time, compute elapsed, round to 3 decimals, return elapsed. Then End.\n\nLet's produce step lines. Ensure each line follows format. Use indentation or nested? Example shows indentation for decisions. We'll follow similar style.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Import time module // 匯入 time 模組\n→ Step 1: 定義函數 measure_time(func, *args) // 定義要測量時間的函數\n    → Step 2: 記錄開始時間 start = time.perf_counter() // 開始計時\n    → Step 3: 執行目標函數 result = func(*args) // 呼叫傳入的函數\n    → Step 4: 記錄結束時間 end = time.perf_counter() // 結束計時\n    → Step 5: 計算耗時 elapsed = end - start // 求出經過秒數\n    → Step 6: 四捨五入到小數點 3 位 rounded = round(elapsed, 3) // 四捨五入\n    → Step 7: 回傳結果 rounded // 返回時間\n→ End // 程式執行結束\n\nBut each line must contain arrow maybe? For lines inside function, can we indent? Example uses indentation. We'll mimic. Provide each step with arrow. For Step 1 etc. Might need colon at end? Use `Step 1:`. Provide explanation after `//`.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time module // 匯入 time 模組  \n\n→ Step 1: 定義函數 measure_time(func, *args) // 建立測量時間的函式  \n  → Step 2: 記錄開始時間 start = time.perf_counter() // 開始計時  \n  → Step 3: 執行目標函數 result = func(*args) // 呼叫傳入的函數  \n  → Step 4: 記錄結束時間 end = time.perf_counter() // 結束計時  \n  → Step 5: 計算耗時 elapsed = end - start // 求出經過秒數  \n  → Step 6: 四捨五入到小數點 3 位 rounded = round(elapsed, 3) // 四捨五入結果  \n  → Step 7: 回傳結果 rounded // 回傳已四捨五入的時間  \n\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"melon\",\"orange\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'melon', 'orange', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有標準輸入（雖然此問題不需要實際使用輸入）\n    sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 使用 discard() 嘗試移除 'pineapple'（不存在）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with comments. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: if any. But here it's straightforward steps, not decisions. Just show steps. Use arrow \"→\" for each step. Should start with Start line, then steps, then End line. Steps: 1. create set, 2. add, 3. update, 4. remove, 5. discard, 6. output. Provide explanation each line. Use \"→ Step X:\" for each step. Provide explanation after //. Also maybe include \"Decision:\"? Not needed. But we can show \"→ Step 1: Create set fruits = {'apple', 'banana'} // 初始化集合\". We'll follow example. Use \"Start // 程式開始執行\". Use \"End // 程式執行結束\". Provide each step with \"→\". For each step, we provide explanation.\n\nWe don't output actual code, only virtual steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立集合 fruits = {'apple', 'banana'} // 初始化集合並存入兩個水果  \n→ Step 2: 使用 add() 新增 'orange' 到 fruits // 把 'orange' 加入集合  \n→ Step 3: 使用 update() 一次新增 'grape' 與 'melon' // 同時把兩個水果加入集合  \n→ Step 4: 使用 remove() 移除 'banana' 從 fruits // 刪除指定元素  \n→ Step 5: 使用 discard() 嘗試移除 'pineapple'（不存在） // 會安全忽略，集合不變  \n→ Step 6: 輸出 fruits // 顯示最終集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.7TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.7 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef get_rate() -> float:\n    \"\"\"\n    取得美元對台幣的匯率。\n    若發生任何錯誤，拋出例外。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    resp = requests.get(url, timeout=10)\n    resp.raise_for_status()               # 任何非 200 的狀態碼都會拋出\n    data = resp.json()\n    return float(data[\"rates\"][\"TWD\"])\n\ndef run_gui():\n    \"\"\"\n    建立 Tkinter GUI，顯示匯率並提供更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update():\n        try:\n            rate = get_rate()\n            label.config(text=f\"目前美元匯率：約 {rate:.1f} TWD\")\n        except Exception:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n\n    win.mainloop()\n\ndef main():\n    \"\"\"\n    主函式：從標準輸入讀取指令，\n    若有輸入則直接取得匯率並輸出，否則啟動 GUI。\n    \"\"\"\n    # 讀取全部 stdin，並去除首尾空白\n    cmd = sys.stdin.read().strip()\n\n    if cmd:\n        # 若 stdin 有任何內容，假設為「更新匯率」指令，直接輸出結果\n        try:\n            rate = get_rate()\n            print(f\"目前美元匯率：約 {rate:.1f} TWD\")\n        except Exception:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # stdin 無內容，啟動 GUI\n        run_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Use requests and tkinter. Should be in lines with arrow notation. Should include start, steps, decisions, end. The user wants code to fetch API and display in Tkinter window, button updates rate. We need to outline steps: import, create window, label, button, function to fetch, update label, bind button, run mainloop. Also error handling maybe.\n\nWe need to produce virtual code in lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for steps. Use Decision. Not actual code. Let's craft. Ensure each line includes arrow and comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: requests, tkinter // 匯入網路請求與視窗模組  \n→ Decision: 依賴庫已安裝?  \n  Yes → Continue  \n  No → Exit // 若缺少庫則終止執行  \n→ Step 1: 初始化 Tkinter 視窗 (root) // 建立主視窗  \n→ Step 2: 設定視窗標題 '美元兌台幣匯率' // 讓使用者辨識  \n→ Step 3: 建立 Label (rate_label) 以顯示匯率 // 預留匯率顯示區域  \n  ← 在 root 上放置 rate_label 並設定初始文字 '匯率待更新'  \n→ Step 4: 定義函式 fetch_rate() // 取得最新匯率的核心流程  \n  → 將 API URL 設為 'https://api.exchangerate-api.com/v4/latest/USD'  \n  → Decision: 送出 GET 請求成功?  \n    Yes → Step 5: 解析 JSON 回傳內容  \n     → 取出 'rates' -> 'TWD' 值  \n     → Step 6: 更新 rate_label 文字為 '1 USD = X TWD'  \n    No → Step 7: rate_label 文字設為 '取得匯率失敗' // 顯示錯誤訊息  \n→ Step 8: 建立 Button (update_btn) 文字 '更新匯率' // 供使用者觸發更新  \n  ← 設定 Button 的 command 為 fetch_rate  \n  ← 放置於 root 上  \n→ Step 9: 立即呼叫 fetch_rate() // 首次載入時就顯示匯率  \n→ Step 10: 執行 root.mainloop() // 啟動 Tkinter 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[None,True,False,True,2,True,False,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[None, True, False, True, 2, True, False, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # 使用字典儲存每個元素對應的索引，方便 O(1) 查找\n        self.val_to_index = {}\n        # 使用列表存放所有元素，方便隨機存取\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，若已存在則返回 False\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"刪除元素，若不存在則返回 False\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素的位置與最後一個元素\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # 用最後一個元素覆蓋要刪除的位置\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回集合中任意元素\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入字串包裝成一個外層列表，使用 ast.literal_eval 解析\n    # 這樣可以安全解析類似 [\"RandomizedSet\", ...], [[], ...] 的格式\n    try:\n        ops_and_args = ast.literal_eval(f'[{data}]')\n    except Exception:\n        # 若解析失敗，直接結束\n        return\n\n    if len(ops_and_args) != 2:\n        return\n\n    ops, args = ops_and_args\n    res = []\n\n    # 依序執行操作\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            # 未知操作，忽略\n            res.append(None)\n\n    # 輸出結果列表，符合題目要求的 JSON 格式\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for implementing RandomizedSet with average O(1) operations. Use dictionary for value to index, array for values. Provide steps for constructor, insert, remove, getRandom.\n\nWe must output line by line with \"虛擬碼步驟\" then comment. Use arrow and decision.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize an empty list `values` // 用於存放所有元素，方便隨機存取\n→ Step 2: Initialize an empty dictionary `indices` // 用於記錄每個元素在列表中的索引\nEnd // 初始化完成\n\nStart // insert(val) 開始\n→ Step 1: Decision: 如果 val 已存在於 `indices`? // 檢查是否已在集合中\n    Yes → Step 2: Return false // 已存在，插入失敗\n    No  → Step 3: Append val 到 `values` // 新元素加入末尾\n        → Step 4: 記錄 indices[val] = len(values) - 1 // 其索引位置\n        → Step 5: Return true // 插入成功\nEnd // insert 完成\n\nStart // remove(val) 開始\n→ Step 1: Decision: 如果 val 不存在於 `indices`? // 檢查是否在集合中\n    Yes → Step 2: Return false // 不存在，刪除失敗\n    No  → Step 3: 取得 last_val = values[-1] // 取得列表最後一個元素\n        → Step 4: 取得 idx = indices[val] // 目標元素的索引\n        → Step 5: 覆蓋 values[idx] = last_val // 用最後一個元素覆蓋目標位置\n        → Step 6: 更新 indices[last_val] = idx // 更新被覆蓋元素的新索引\n        → Step 7: 移除 values 最後一個元素 // 刪除已複製的最後元素\n        → Step 8: 刪除 indices[val] // 移除目標元素的索引紀錄\n        → Step 9: Return true // 刪除成功\nEnd // remove 完成\n\nStart // getRandom() 開始\n→ Step 1: 產生隨機整數 r 介於 0 與 len(values)-1 // 隨機索引\n→ Step 2: Return values[r] // 取出對應元素\nEnd // getRandom 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[1,0],[0,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [1, 0], [0, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    設計一個能隨機挑選矩陣中 0 的格子並把它翻轉為 1 的類別。\n    為了避免重複使用 random，使用「映射（mapping）」方法。\n    \"\"\"\n\n    def __init__(self, m, n):\n        # 行列數\n        self.rows = m\n        self.cols = n\n        # 總格子數\n        self.total = m * n\n        # 存放已翻轉格子的映射\n        self.flipped = {}\n\n    def flip(self):\n        \"\"\"\n        隨機挑選一個仍為 0 的格子，翻轉為 1，並回傳其座標 [i, j]。\n        \"\"\"\n        # 隨機產生一個可用的索引\n        r = random.randint(0, self.total - 1)\n        # 如果 r 已被映射，則取映射值；否則使用 r 本身\n        x = self.flipped.get(r, r)\n        # 把 r 這個格子視為已翻轉，減少可用格子數\n        self.total -= 1\n        # 把 r 這個索引映射到最後一個可用格子，確保未被映射的格子仍可被選\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # 回傳行列座標\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        \"\"\"\n        將所有格子重設為 0，並清空映射。\n        \"\"\"\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    # 從標準輸入讀取整個字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析成兩個列表：操作序列和對應參數\n    ops, args = ast.literal_eval(data)\n    # 結果列表\n    res = []\n    # 物件參考，初始化時為 None\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構子，參數為 [m, n]\n            obj = Solution(*arg)\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n    # 輸出結果，使用 json.dumps 以符合 LeetCode 的輸出格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The algorithm: use reservoir sampling like approach with mapping. Maintain map from index to value, total cells, etc. Steps: initialize, flip, reset. Use map dictionary to simulate. Complexity O(1) expected. Let's produce.\n\nWe need to output \"虛擬碼步驟\" followed by // 解釋.\n\nLet's structure: Start, Step 1: initialize variables, etc. Use Decision steps. Provide mapping logic.\n\nWe need to include arrows and Decision structure. Let's produce a clear stepwise description.\n\nProceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set m, n 為矩陣尺寸 // 取得行列數  \n→ Step 2: total ← m * n // 總格子數  \n→ Step 3: mapping ← empty dictionary // 用於紀錄已翻轉的格子  \n→ Step 4: remaining ← total // 仍可翻轉的格子數  \n\n// flip() 方法  \n→ Function flip() // 開始 flip 方法  \n → Decision: 如果 remaining == 0? // 檢查是否所有格子已翻轉  \n  Yes → Return error // 不能再翻轉，返回錯誤訊息  \n  No  → Continue  \n → Step 5: r ← random integer in [0, remaining - 1] // 隨機選擇一個可翻轉的索引  \n → Step 6: idx ← mapping.get(r, r) // 取得實際格子索引，若未映射則直接使用 r  \n → Step 7: last ← mapping.get(remaining - 1, remaining - 1) // 取得最後一個可翻轉格子的實際索引  \n → Step 8: mapping[r] ← last // 把 r 映射到最後一個格子，模擬移除 r  \n → Step 9: Delete mapping[remaining - 1] if exists // 刪除最後一個格子的映射，因已被移除  \n → Step 10: remaining ← remaining - 1 // 更新可翻轉格子數  \n → Step 11: i ← idx / n // 計算行號  \n → Step 12: j ← idx % n // 計算列號  \n → Return [i, j] // 返回隨機格子座標  \n\n// reset() 方法  \n→ Function reset() // 開始 reset 方法  \n → Step 13: mapping ← empty dictionary // 清空映射  \n → Step 14: remaining ← total // 將剩餘格子數恢復為總數  \n → End // reset 方法結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5_exzlh7.py\", line 53, in <module>\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5_exzlh7.py\", line 11, in findMaximizedCapital\n    n = len(Projects)\n            ^^^^^^^^\nNameError: name 'Projects' is not defined. Did you mean: 'projects'?"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkizpz6bd.py\", line 53, in <module>\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkizpz6bd.py\", line 11, in findMaximizedCapital\n    n = len(Projects)\n            ^^^^^^^^\nNameError: name 'Projects' is not defined. Did you mean: 'projects'?"
        }
      ],
      "generated_code": "import sys\nimport re\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        # 將專案按資本需求排序\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []\n        i = 0\n        n = len(Projects)\n        for _ in range(k):\n            # 把所有資本需求不超過目前資本的專案放進最大堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])  # 用負值做最大堆\n                i += 1\n            if max_heap:\n                # 取出最高利潤，更新資本\n                W -= heapq.heappop(max_heap)  # pop回負利潤，減去即加利潤\n            else:\n                break\n        return W\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 解析 k、w\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    w_match = re.search(r'w\\s*=\\s*(-?\\d+)', data)\n    if not k_match or not w_match:\n        sys.exit(0)\n    k = int(k_match.group(1))\n    w = int(w_match.group(1))\n\n    # 解析 profits 列表\n    profits_match = re.search(r'profits\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if profits_match:\n        profits_str = profits_match.group(1).strip()\n        profits = list(map(int, profits_str.split(','))) if profits_str else []\n    else:\n        profits = []\n\n    # 解析 capital 列表\n    capital_match = re.search(r'capital\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if capital_match:\n        capital_str = capital_match.group(1).strip()\n        capital = list(map(int, capital_str.split(','))) if capital_str else []\n    else:\n        capital = []\n\n    # 執行解題邏輯\n    sol = Solution()\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for this LeetCode problem: maximum capital after selecting up to k projects with given profits and capital requirements, starting capital w. Classic solution: use a max-heap of profits for projects whose capital <= current capital; each iteration choose the max profit, add to capital, repeat k times. Use min-heap for capital.\n\nWe need to produce pseudo-code with each line followed by explanation comment, using arrow notation. Provide steps. No actual code. Use Start, End, Decision. Use \"→\" arrows. Use \"Yes →\" \"No →\". Provide explanation after comment. Provide steps like:\n\nStart // start program\n→ Step 1: initialize two priority queues: minCapitalHeap, maxProfitHeap\n→ Step 2: insert all projects into minCapitalHeap sorted by capital\n→ Decision: If k == 0 or minCapitalHeap empty? etc.\n\nBetter structure: iterate up to k times: For each iteration, while minCapitalHeap not empty and top project's capital <= current capital: pop and push profit into maxProfitHeap. After that, if maxProfitHeap empty: break. Else pop max profit, add to capital. After loop, return capital.\n\nWe need to produce step-by-step. Use decision: check if k > 0, etc.\n\nWe need each line with explanation after //. Must include arrows.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立一個按最低資本排序的最小堆 minCapitalHeap，並將所有 (capital[i], profits[i]) 插入 // 將所有專案依資本需求排入最小堆\n→ Step 2: 建立一個按最大利潤排序的最大堆 maxProfitHeap // 用來快速取出可行專案中的最高利潤\n→ Step 3: 設 currentCapital = w // 初始可用資本\n→ Step 4: 設 loopCount = 0 // 已選取專案數\n→ Decision: 如果 loopCount < k? // 是否還可以再選專案\n    Yes →\n        → Step 5: Decision: 是否有專案的資本需求 <= currentCapital? // 將可行專案移入最大利潤堆\n            Yes →\n                → Step 6: 取出 minCapitalHeap 中資本需求最小的專案 (cap, prof)\n                → Decision: 若 cap <= currentCapital?\n                    Yes →\n                        → Step 7: 將 prof 插入 maxProfitHeap // 將可行專案利潤加入\n                        → Decision: minCapitalHeap 是否還有項目? // 迭代將所有可行專案加入最大堆\n                            Yes → jump to Step 6\n                            No  → 轉回決定是否還能選專案\n                    No  → 轉回決定是否還能選專案\n            No  →\n                → Decision: maxProfitHeap 是否有可取的專案?\n                    Yes →\n                        → Step 8: 取出 maxProfitHeap 中最大利潤 prof\n                        → Step 9: currentCapital += prof // 完成專案後更新資本\n                        → Step 10: loopCount += 1 // 計數已完成專案\n                        → 回到 Decision: loopCount < k?\n                    No  → // 沒有可行專案且沒有可取利潤，無法再進一步\n                        → End // 結束程式\n    No  → End // 已達到 k 次選擇或無法再選，結束程式\n→ End // 回傳最終資本\n\nBut we need to keep each line as a single step, and include arrow and comment. We must use Start and End. Use Decision:... and Yes →, No →. Each line must be a single step; but can include nested decisions. We need to use the arrow notation.\n\nWe should produce a structured algorithm. Provide step lines.\n\nLet's craft final output. Use proper indenting? Not required but easier to read.\n\nWe'll keep each line like \"Start // 程式開始執行\". Then \"→ Step 1: ...\" etc. For nested decisions, we can indent but not necessary. Use indentation to show flow. Use \"Decision:\" and \"Yes →\" \"No →\".\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 minCapitalHeap 為按 capital 排序的最小堆，並將所有 (capital[i], profits[i]) 插入 // 將所有專案依資本需求排入最小堆\n→ Step 2: 初始化 maxProfitHeap 為按 profit 排序的最大堆 // 用來快速取出可行專案中的最高利潤\n→ Step 3: currentCapital ← w // 初始可用資本\n→ Step 4: completedCount ← 0 // 已完成專案數\n→ Decision: completedCount < k? // 是否還可以再選專案\n    Yes →\n        → Step 5: Decision: minCapitalHeap 內是否存在專案且其 capital ≤ currentCapital? // 將所有可行專案移入最大利潤堆\n            Yes →\n                → Step 6: (cap, prof) ← minCapitalHeap.pop() // 取出最小資本需求的專案\n                → Decision: cap ≤ currentCapital? // 確認此專案仍可行\n                    Yes →\n                        → Step 7: maxProfitHeap.push(prof) // 加入可行專案利潤\n                        → Decision: minCapitalHeap 仍有項目? // 重複將所有可行專案加入\n                            Yes → jump to Step 6\n                            No → jump to Decision: maxProfitHeap 內是否有項目? \n                    No  → jump to Decision: maxProfitHeap 內是否有項目?\n            No  →\n                → Decision: maxProfitHeap 內是否有項目? // 若已無可行專案，判斷是否可以挑選利潤\n                    Yes →\n                        → Step 8: prof ← maxProfitHeap.pop() // 取出最大利潤\n                        → Step 9: currentCapital += prof // 完成專案後更新資本\n                        → Step 10: completedCount += 1 // 增加已完成專案數\n                        → jump to Decision: completedCount < k? // 重新檢查是否可再選\n                    No  → End // 無法再進一步，結束程式\n    No  → End // 已達到 k 次選擇或無法再選，結束程式\n→ End // 回傳最終資本\n\nWe also need to output final capital at end. In pseudo-code, maybe Step 11: return currentCapital. We can add at end.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 minCapitalHeap 為按 capital 排序的最小堆，並將所有 (capital[i], profits[i]) 插入 // 將所有專案依資本需求排入最小堆\n→ Step 2: 初始化 maxProfitHeap 為按 profit 排序的最大堆 // 用來快速取出可行專案中的最高利潤\n→ Step 3: currentCapital ← w // 初始可用資本\n→ Step 4: completedCount ← 0 // 已完成專案數\n→ Decision: completedCount < k? // 是否還可以再選專案\n    Yes →\n        → Step 5: Decision: minCapitalHeap 內是否存在專案且其 capital ≤ currentCapital? // 將所有可行專案移入最大利潤堆\n            Yes →\n                → Step 6: (cap, prof) ← minCapitalHeap.pop() // 取出最小資本需求的專案\n                → Decision: cap ≤ currentCapital? // 確認此專案仍可行\n                    Yes →\n                        → Step 7: maxProfitHeap.push(prof) // 加入可行專案利潤\n                        → Decision: minCapitalHeap 仍有項目? // 重複將所有可行專案加入\n                            Yes → jump to Step 6\n                            No → jump to Decision: maxProfitHeap 內是否有項目? \n                    No  → jump to Decision: maxProfitHeap 內是否有項目?\n            No  →\n                → Decision: maxProfitHeap 內是否有項目? // 若已無可行專案，判斷是否可以挑選利潤\n                    Yes →\n                        → Step 8: prof ← maxProfitHeap.pop() // 取出最大利潤\n                        → Step 9: currentCapital += prof // 完成專案後更新資本\n                        → Step 10: completedCount += 1 // 增加已完成專案數\n                        → jump to Decision: completedCount < k? // 重新檢查是否可再選\n                    No  → End // 無法再進一步，結束程式\n    No  → End // 已達到 k 次選擇或無法再選，結束程式\n→ End // 回傳最終資本\n\n※在程式實際執行結束時，返回 currentCapital 作為最終可最大化的資本。"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\nfrom typing import List, Set\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        if not s:\n            return [\"\"]\n\n        # 計算最少要刪除的左括號和右括號數\n        left_remove = right_remove = 0\n        for ch in s:\n            if ch == '(':\n                left_remove += 1\n            elif ch == ')':\n                if left_remove == 0:\n                    right_remove += 1\n                else:\n                    left_remove -= 1\n\n        results: Set[str] = set()\n\n        def dfs(index: int, left_count: int, right_count: int,\n                left_rem: int, right_rem: int, path: List[str]) -> None:\n            if index == len(s):\n                if left_rem == 0 and right_rem == 0:\n                    results.add(''.join(path))\n                return\n\n            ch = s[index]\n            if ch == '(':\n                # 1. 刪除當前 '('\n                if left_rem > 0:\n                    dfs(index + 1, left_count, right_count,\n                        left_rem - 1, right_rem, path)\n                # 2. 保留當前 '('\n                path.append(ch)\n                dfs(index + 1, left_count + 1, right_count,\n                    left_rem, right_rem, path)\n                path.pop()\n            elif ch == ')':\n                # 1. 刪除當前 ')'\n                if right_rem > 0:\n                    dfs(index + 1, left_count, right_count,\n                        left_rem, right_rem - 1, path)\n                # 2. 保留當前 ')', 但必須有未匹配的 '('\n                if left_count > right_count:\n                    path.append(ch)\n                    dfs(index + 1, left_count, right_count + 1,\n                        left_rem, right_rem, path)\n                    path.pop()\n            else:  # 字母\n                path.append(ch)\n                dfs(index + 1, left_count, right_count,\n                    left_rem, right_rem, path)\n                path.pop()\n\n        dfs(0, 0, 0, left_remove, right_remove, [])\n        return list(results)\n\ndef parse_input(data: str) -> str:\n    \"\"\"從輸入字串中提取實際要處理的字符串\n    例如：`s = \"()())()\"` 或僅 `()())()`。\n    \"\"\"\n    data = data.strip()\n    if 's' in data:\n        parts = data.split('=', 1)\n        if len(parts) == 2:\n            part = parts[1].strip()\n            # 取雙引號之間的內容\n            if part.startswith('\"') and part.endswith('\"'):\n                return part[1:-1]\n            if part.startswith(\"'\") and part.endswith(\"'\"):\n                return part[1:-1]\n            return part\n    # 如果沒有 s=，直接返回整行\n    return data\n\ndef main() -> None:\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    sol = Solution()\n    outputs = sol.removeInvalidParentheses(s)\n    # 為了與範例一致，輸出為 JSON 風格的列表字串\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm: remove minimum number of invalid parentheses, return all unique valid strings. Classic Leetcode 301.\n\nWe need step-by-step pseudocode with decisions and arrows. Provide explanation after each line.\n\nWe must output each line with format: `<虛擬碼步驟> // <解釋>`.\n\nWe need to show the algorithm: compute left and right removals needed via scanning. Then DFS/backtracking to generate all possibilities, using skip logic. Also use set to avoid duplicates. Return list.\n\nWe need to output step-by-step structure, including Start, End, Decision, etc. Each line must include virtual code, space, comment. Use arrows: `→`. Decision lines.\n\nOk let's craft.\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Step 1: 計算需要刪除的左括號 countLeft 與右括號 countRight // 先掃描串找出最少刪除數\n→ Decision: s 為空? // 若無字符則直接返回空列表\n    Yes → Step 2: Return [] // 空字符串已有效\n    No  → Step 3: 初始化集合 results = {} // 用來存放唯一的有效字串\n→ Step 4: 定義遞迴函數 DFS(index, leftCount, rightCount, leftRem, rightRem, path) // 探索所有刪除組合\n    → Decision: index == s.length? // 到達字串結尾\n        Yes → Decision: leftRem==0 AND rightRem==0? // 刪除數滿足\n            Yes → Step 5: results.add(path) // 加入結果\n            No  → Step 6: // 不是最小刪除，忽略\n        No  → Step 7: char = s[index] // 取得當前字符\n            → Decision: char == '('? // 左括號\n                Yes → Decision: leftRem>0? // 可刪除\n                    Yes → Step 8: DFS(index+1, leftCount, rightCount, leftRem-1, rightRem, path) // 刪除此左括號\n                No → Step 9: DFS(index+1, leftCount+1, rightCount, leftRem, rightRem, path+'(') // 保留此左括號\n                Yes → Decision: rightCount+1 <= leftCount? // 需要平衡\n                    Yes → Step 10: DFS(index+1, leftCount, rightCount+1, leftRem, rightRem, path+'(') // 保留\n            No → Decision: char == ')'?\n                Yes → Decision: rightRem>0? // 可刪除\n                    Yes → Step 11: DFS(index+1, leftCount, rightCount, leftRem, rightRem-1, path) // 刪除此右括號\n                No → Decision: leftCount>rightCount? // 有未匹配左括號\n                    Yes → Step 12: DFS(index+1, leftCount, rightCount+1, leftRem, rightRem, path+')') // 保留\n            No → // 字母\n                Step 13: DFS(index+1, leftCount, rightCount, leftRem, rightRem, path+char) // 保留\n→ Step 14: DFS(0,0,0,countLeft,countRight,\"\") // 開始遞迴\n→ Step 15: Return Array.from(results) // 將集合轉為陣列返回\nEnd // 程式結束\n\nBut we need to follow strict formatting: each line must be \"虛擬碼步驟\" + space + \"// 解釋\". Also we need to use arrow `→`, `Yes →`, `No →` for decisions.\n\nEnsure each decision has Yes and No branches as separate lines. Also we might need indentation? Not specified but arrow indicates new branch.\n\nWe might use indent lines like:\n\n→ Decision: ...\n    Yes → ...\n    No  → ...\n\nYes lines after indentation maybe.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 計算需要刪除的左括號 countLeft 與右括號 countRight // 先掃描字串找出最小刪除數\n→ Decision: s 為空？ // 若無字符則直接返回空列表\n    Yes → Step 2: Return [] // 空字符串已有效\n    No  → Step 3: 初始化集合 results = {} // 用來存放唯一的有效字串\n\n→ Step 4: 定義遞迴函數 DFS(index, leftCount, rightCount, leftRem, rightRem, path) // 探索所有刪除組合\n\n    → Decision: index == s.length？ // 到達字串結尾\n        Yes → Decision: leftRem == 0 AND rightRem == 0？ // 刪除數滿足\n            Yes → Step 5: results.add(path) // 加入結果\n            No  → Step 6: // 不是最小刪除，忽略\n        No  → Step 7: char = s[index] // 取得當前字符\n\n            → Decision: char == '('？ // 左括號\n                Yes → Decision: leftRem > 0？ // 可刪除\n                    Yes → Step 8: DFS(index+1, leftCount, rightCount, leftRem-1, rightRem, path) // 刪除此左括號\n                No  → Step 9: DFS(index+1, leftCount+1, rightCount, leftRem, rightRem, path + '(') // 保留此左括號\n\n                Yes → Decision: rightCount + 1 <= leftCount？ // 需要平衡\n                    Yes → Step 10: DFS(index+1, leftCount, rightCount+1, leftRem, rightRem, path + '(') // 保留此左括號\n            No → Decision: char == ')'？ // 右括號\n                Yes → Decision: rightRem > 0？ // 可刪除\n                    Yes → Step 11: DFS(index+1, leftCount, rightCount, leftRem, rightRem-1, path) // 刪除此右括號\n                No → Decision: leftCount > rightCount？ // 有未匹配左括號\n                    Yes → Step 12: DFS(index+1, leftCount, rightCount+1, leftRem, rightRem, path + ')') // 保留此右括號\n            No → // 字母\n                Step 13: DFS(index+1, leftCount, rightCount, leftRem, rightRem, path + char) // 保留字母\n\n→ Step 14: DFS(0, 0, 0, countLeft, countRight, \"\") // 開始遞迴\n→ Step 15: Return Array.from(results) // 將集合轉為陣列返回\n\nEnd // 程式結束"
    },
    {
      "title": "Merge Sorted Array",
      "source_file": "Leetcode/leetcode88.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp2ytrptv.py\", line 40, in <module>\n    nums1, m, nums2, n = parse_input(raw)\n                         ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp2ytrptv.py\", line 32, in parse_input\n    data[key] = eval(val, {})\n                ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"Merge two sorted lists in-place into nums1.\"\"\"\n        i, j, k = m - 1, n - 1, m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        # If any elements remain in nums2, copy them\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(s: str):\n    \"\"\"Parse input string of the form\n       'nums1 = [..], m = 3, nums2 = [..], n = 3'.\"\"\"\n    parts = re.split(r',(?=\\s*\\w)', s)\n    data = {}\n    for part in parts:\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key in ('nums1', 'nums2'):\n            data[key] = eval(val, {})\n        else:  # m or n\n            data[key] = int(val)\n    return data['nums1'], data['m'], data['nums2'], data['n']\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if raw:\n        nums1, m, nums2, n = parse_input(raw)\n        # Ensure nums1 has enough space; the extra slots are already zeros\n        sol = Solution()\n        sol.merge(nums1, m, nums2, n)\n        print(nums1)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. This is merging two sorted arrays with given sizes. Virtual code uses Start, Decision, etc. We need to show algorithm: pointers i from m-1, j from n-1, k from m+n-1. While i>=0 or j>=0, place largest element at nums1[k], decrement pointers accordingly. This is typical. So produce steps: Start, set pointers, Decision loop, etc. Provide explanation after each line. Ensure each line has arrow. Use \"→\" for steps. Use \"Decision:\" with Yes/No. Provide End. Use plain text. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set i = m - 1 // i 指向 nums1 的最後一個有效元素  \n→ Set j = n - 1 // j 指向 nums2 的最後一個有效元素  \n→ Set k = m + n - 1 // k 指向 nums1 的最後一個位置（合併後的結束位置）  \n→ Decision: i >= 0 OR j >= 0? // 判斷是否還有元素未被放入 nums1  \n    Yes → Decision: i < 0? // 如果 nums1 已無剩餘元素  \n        Yes → Step: nums1[k] = nums2[j] // 把 nums2 的元素放入 nums1  \n            → Decrement j by 1 // j 往前移動  \n            → Decrement k by 1 // k 往前移動  \n            → Go back to Decision: i >= 0 OR j >= 0? // 重新判斷是否還有元素  \n        No → Decision: j < 0? // 如果 nums2 已無剩餘元素  \n            Yes → Step: nums1[k] = nums1[i] // 把 nums1 的元素放回自己（不變）  \n                → Decrement i by 1 // i 往前移動  \n                → Decrement k by 1 // k 往前移動  \n                → Go back to Decision: i >= 0 OR j >= 0? // 重新判斷是否還有元素  \n            No → Step: Compare nums1[i] and nums2[j]  \n                → Decision: nums1[i] > nums2[j]? // 比較兩個元素的大小  \n                    Yes → nums1[k] = nums1[i] // 取 nums1 中較大的元素放入 nums1  \n                        → Decrement i by 1 // i 往前移動  \n                    No  → nums1[k] = nums2[j] // 取 nums2 中較大的元素放入 nums1  \n                        → Decrement j by 1 // j 往前移動  \n                → Decrement k by 1 // k 往前移動  \n                → Go back to Decision: i >= 0 OR j >= 0? // 重新判斷是否還有元素  \n    No → End // 所有元素已合併，程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1, num2):\n        i, j = len(num1)-1, len(num2)-1\n        carry = 0\n        res = []\n        while i>=0 or j>=0 or carry:\n            x = int(num1[i]) if i>=0 else 0\n            y = int(num2[j]) if j>=0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n        return ''.join(res[::-1])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # if not enough numbers, default to empty strings\n        num1, num2 = nums[0] if nums else '', nums[1] if len(nums)>1 else ''\n    sol = Solution()\n    result = sol.addStrings(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for addition of big numbers represented as strings, step by step, with arrow and decision structure. Each line: virtual code step + // explanation.\n\nWe must not output real code. Just structured steps. Use Start, End, Decision. Use arrows.\n\nLet's write steps: Start, set indices to end of strings, carry = 0, result string builder, loop while i>=0 or j>=0 or carry>0, get digit1, digit2, sum, carry, prepend digit to result, decrement indices, after loop, return result.\n\nWe'll also include Decision for loop condition.\n\nUse Yes → Next step.\n\nWe must ensure no actual code syntax. Just pseudo steps. Let's produce.\n\nAlso we might add initialization of result as empty string.\n\nWe should keep each line as:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // 準備索引與暫存\n\n→ Decision: i>=0 或 j>=0 或 carry>0? // 判斷是否還有位數未處理\n\n   Yes → Step 2: digit1 = (i>=0)? num1[i]-'0' : 0 // 取得 num1 的當前位或 0\n\n   Yes → Step 3: digit2 = (j>=0)? num2[j]-'0' : 0 // 取得 num2 的當前位或 0\n\n   Yes → Step 4: sum = digit1 + digit2 + carry // 計算總和\n\n   Yes → Step 5: carry = sum / 10 // 取進位\n\n   Yes → Step 6: digit = sum % 10 // 取本位數\n\n   Yes → Step 7: result = char('0'+digit) + result // 把位數加入結果前面\n\n   Yes → Step 8: i = i-1 // 移動到上一位\n\n   Yes → Step 9: j = j-1 // 移動到上一位\n\n   Yes → Decision: 循環結束條件? // 重新判斷\n\n   No  → Step 10: return result // 回傳合計\n\nEnd // 程式執行結束\n\nBut we must show the Decision arrow properly. Use indentation maybe. We need to show arrow like \"→ Decision: ...\". And inside decisions we need Yes → and No →. For loops we can use Decision to continue loop.\n\nLet's produce properly formatted. Ensure each line has arrow. For steps inside Decision, we can indent. Use multiple lines maybe.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 i = len(num1) - 1, j = len(num2) - 1, carry = 0, result = \"\" // 設定索引與暫存\n→ Decision: i >= 0 或 j >= 0 或 carry > 0? // 判斷是否還有位數未處理\n    Yes → Step 2: digit1 = (i >= 0) ? num1[i] - '0' : 0 // 取得 num1 的當前位數，若已走完則為 0\n    Yes → Step 3: digit2 = (j >= 0) ? num2[j] - '0' : 0 // 取得 num2 的當前位數，若已走完則為 0\n    Yes → Step 4: sum = digit1 + digit2 + carry // 計算兩位數與進位的總和\n    Yes → Step 5: carry = sum / 10 // 計算新的進位\n    Yes → Step 6: digit = sum % 10 // 獲得本位數\n    Yes → Step 7: result = char('0' + digit) + result // 把本位數字加到結果前面\n    Yes → Step 8: i = i - 1 // 移動 num1 的索引到前一位\n    Yes → Step 9: j = j - 1 // 移動 num2 的索引到前一位\n    Yes → Decision: 循環結束條件? // 重新檢查是否需要繼續\n    No  → Step 10: return result // 回傳完整的和\nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum II",
      "source_file": "Leetcode/leetcode40.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4g4i1v5_.py\", line 37, in <module>\n    candidates = eval(cand_part)\n                 ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [10\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp4g4i1v5_.py\", line 41, in <module>\n    candidates = ast.literal_eval(cand_part)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [10\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsyq13xlr.py\", line 37, in <module>\n    candidates = eval(cand_part)\n                 ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpsyq13xlr.py\", line 41, in <module>\n    candidates = ast.literal_eval(cand_part)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        res: List[List[int]] = []\n\n        def backtrack(start: int, path: List[int], total: int) -> None:\n            if total == target:\n                res.append(path[:])\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                # skip duplicates at the same recursion level\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                if total + candidates[i] > target:\n                    break  # further numbers will be larger\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expected format: \"candidates = [10,1,2,7,6,1,5], target = 8\"\n    parts = data.split(',')\n    # Parse candidates\n    cand_part = parts[0].split('=')[1].strip()\n    try:\n        candidates = eval(cand_part)\n    except Exception:\n        # Fallback if eval fails\n        import ast\n        candidates = ast.literal_eval(cand_part)\n    # Parse target\n    target_part = parts[1].split('=')[1].strip()\n    target = int(target_part)\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step, in Chinese. We need to output in the format: \"虛擬碼步驟 // 解釋\". Each line starting with \"Start\", \"→ Step x: ...\", \"→ Decision: ...\", indenting using spaces maybe. We need to show the algorithm: backtracking DFS with sorting to skip duplicates, using recursion. Provide virtual code lines.\n\nWe must not output actual code, only virtual steps.\n\nWe need to think about structure: Start, Sort candidates, define recursive function backtrack(startIndex, remainingTarget, currentCombination). In recursion, iterate i from startIndex to len(candidates). If i > startIndex and candidates[i]==candidates[i-1] then skip. If candidates[i] > remainingTarget break. Else, add to combination, backtrack(i+1, remainingTarget - candidates[i], combination). After recursion, remove last.\n\nReturn results.\n\nWe output step by step.\n\nLet's produce maybe about 20-25 lines.\n\nWe should keep each line short but explanatory. Use arrow, Decision.\n\nOk. Let's craft.\n\nMake sure to include \"Start // 程式開始執行\" and \"End // 程式執行結束\".\n\nAdd \"Sort candidates in non-decreasing order // 方便後續跳過重複\".\n\nDefine \"Initialize result list // 用來存所有組合\".\n\nDefine function \"Backtrack(startIndex, remainingTarget, currentCombination)\".\n\nWithin: if remainingTarget == 0, add copy to result // 找到一組合法組合.\n\nLoop i from startIndex to len(candidates)-1:\n\n- Decision: 如果 i > startIndex 且 candidates[i]==candidates[i-1]? // 跳過重複值\n\n- Yes → Continue // 跳過此循環\n\n- No → Decision: 如果 candidates[i] > remainingTarget? // 若選取後和已超出目標\n\n- Yes → Break // 之後的數字更大，直接跳出迴圈\n\n- No → Decision: 把 candidates[i] 加入 currentCombination // 進行選取\n\n- Yes → (no need to write sub steps? We can say \"Add candidate to currentCombination\")\n\nThen recursive call \"Backtrack(i+1, remainingTarget - candidates[i], currentCombination)\".\n\nAfter recursion, remove last element from currentCombination // 回溯。\n\nAfter loop, return.\n\nFinally, call Backtrack(0, target, empty list). Return result.\n\nOk.\n\nLet's format lines with \"→\" and indent for decisions maybe 4 spaces.\n\nRemember to use Chinese for explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort candidates in non‑decreasing order // 方便後續跳過重複  \n→ Initialize result list // 用來存所有合法組合  \n→ Define function Backtrack(startIndex, remainingTarget, currentCombination) // 進行遞迴回溯  \n  → Decision: 如果 remainingTarget == 0? // 檢查是否已達到目標  \n    Yes → Add copy of currentCombination to result // 找到一組合法組合  \n    No  → Decision: 循環 i 從 startIndex 到 len(candidates)-1? // 開始遍歷候選數  \n      Yes → Loop i from startIndex to len(candidates)-1 // 遍歷每個位置  \n        Decision: 如果 i > startIndex 且 candidates[i] == candidates[i-1]? // 跳過重複值  \n         Yes → Continue // 跳過此循環  \n         No  → Decision: 如果 candidates[i] > remainingTarget? // 若超過目標就不需要再往下  \n          Yes → Break // 之後的數字更大，直接跳出迴圈  \n          No  → Decision: 將 candidates[i] 加入 currentCombination // 選取此數字  \n           Yes → Add candidates[i] to currentCombination // 加入組合  \n           No  → (無操作)  \n          Decision: 進行遞迴呼叫 Backtrack(i+1, remainingTarget - candidates[i], currentCombination) // 進一步搜尋  \n           Yes → Call Backtrack(i+1, remainingTarget - candidates[i], currentCombination) // 遞迴  \n           No  → (無操作)  \n          Decision: 從 currentCombination 移除最後一個元素 // 回溯  \n           Yes → Remove last element from currentCombination // 回溯到上一層  \n           No  → (無操作)  \n          End // 完成此次循環  \n        End // 完成所有循環  \n       End // 迴圈結束  \n      End // Decision 結束  \n     End // Backtrack 函式結束  \n→ Call Backtrack(0, target, empty list) // 開始回溯搜尋  \n→ Return result // 將所有組合回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        return random.choice(self.num_indices[target])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the input so it can be parsed as a tuple of two lists\n    tuple_str = f\"({data})\"\n    methods, args = ast.literal_eval(tuple_str)\n\n    outputs = []\n    obj = None  # the current Solution instance\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            # arg is a list containing one list: the nums array\n            nums = arg[0]\n            obj = Solution(nums)\n            outputs.append(None)\n        else:\n            # other methods take a single argument\n            result = getattr(obj, method)(arg[0])\n            outputs.append(result)\n\n    # Convert None to null in JSON output\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Need to outline steps for class initialization and pick method. Steps: store array, map target to list of indices. For pick, random selection. Provide virtual steps line by line. Let's craft.\n\nWe need to use Start, End, Decision, etc. We need to show steps inside class? We can treat algorithm.\n\nSteps:\n\nStart // begin\n→ Step 1: initialize empty hash map // store target to indices list\n→ Step 2: For each index i in nums: add i to map[nums[i]] list // build mapping\nEnd // init done\n\npick method:\nStart // start pick\n→ Step 3: Retrieve list = map[target] // get indices\n→ Decision: if list length == 1? // only one index\n    Yes → Step 4: Return that index // deterministic\n    No → Step 5: Generate random integer r in [0, list.size-1] // random selection\n        → Step 6: Return list[r] // chosen index\nEnd // pick end\n\nAlso need to mention constructor class and pick method. Let's structure: \"Start // 程式開始執行\" etc.\n\nLet's produce.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\". Use arrow notation. We'll show \"Start\", \"→\", \"Decision:\", \"Yes →\", \"No →\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的雜湊表 targetToIndices // 用於儲存每個數值對應的所有索引  \n→ Step 2: 逐個索引 i 從 nums 取值 v → targetToIndices[v].add(i) // 為每個數值建立索引清單  \nEnd // 物件初始化完成  \n\nStart // pick 方法開始  \n→ Step 3: 取 list = targetToIndices[target] // 取得目標值對應的索引清單  \n→ Decision: list 大小是否等於 1? // 檢查是否只有一個可能的索引  \n  Yes → Step 4: 回傳 list[0] // 直接回傳唯一索引  \n  No → Step 5: 產生隨機整數 r，範圍為 0 到 list.size() - 1 // 隨機選取索引位置  \n   → Step 6: 回傳 list[r] // 回傳隨機選取的索引  \nEnd // pick 方法結束\n\nStart // 程式結束執行  \nEnd"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      '\"eetr\"'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      '\"cccaaa\"'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        # Count frequency of each character\n        count = Counter(s)\n        # Sort characters by frequency in descending order\n        # most_common returns a list of (char, freq) sorted by freq descending\n        return ''.join([char * freq for char, freq in count.most_common()])\n\ndef main():\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract the string inside double quotes\n    first_quote = raw_input.find('\"')\n    if first_quote == -1:\n        s = \"\"\n    else:\n        second_quote = raw_input.find('\"', first_quote + 1)\n        s = raw_input[first_quote + 1:second_quote] if second_quote != -1 else \"\"\n\n    # Compute the sorted string\n    result = Solution().frequencySort(s)\n    # Print the result surrounded by double quotes as required\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to sort string by frequency descending. We produce steps: Start, Input string, Count frequencies, Sort characters by freq descending, Build result string by repeating char count times, End. Also handle ties: any order. Provide each line with comment.\n\nMake sure to use \"虛擬碼步驟\" and comment. Should be simple. Use arrows, decisions maybe not necessary but can include.\n\nLet's produce:\n\nStart\n→ Step 1: Input s // get string\n→ Step 2: 初始化空字典 freq // map char->count\n→ Step 3: For each char c in s: increment freq[c] // count frequencies\n→ Step 4: 將字典項轉為列表 entries // (char, count)\n→ Step 5: Sort entries 按 count 降序 // 排序\n→ Step 6: 初始化空結果 res\n→ Step 7: For每項 (c, count) in entries: res += c*count // 重複\n→ End\n\nAdd comments.\n\nWe should produce one line per step. Use arrow \"→\" for steps. Decision not needed.\n\nEnsure each line: 虛擬碼步驟 // 解釋.\n\nWe must output exactly like sample. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得要排序的字串  \n→ Step 2: 初始化空字典 freq // 用於紀錄每個字元的出現頻率  \n→ Step 3: 對 s 中每個字元 c 執行: freq[c] ← freq.get(c, 0) + 1 // 逐字計數  \n→ Step 4: 將 freq 的項目轉為列表 entries ← list(freq.items()) // 取得 (字元, 頻率)  \n→ Step 5: 按頻率降序排序 entries ← sorted(entries, key = λ x: x[1], reverse = True) // 依頻率排列  \n→ Step 6: 初始化空字串 res ← \"\" // 用於累積結果  \n→ Step 7: 對 entries 中每個 (c, cnt) 執行: res ← res + c * cnt // 重複字元並加入結果  \n→ End // 程式執行結束，res 為按頻率降序排列的字串"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[1,0],[0,1],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[1, 0], [0, 1], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典：每個單字反轉後作為 key，原索引作為 value\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            # 逐個拆分字串，檢查左右兩段是否為回文\n            for j in range(len(word) + 1):\n                left, right = word[:j], word[j:]\n\n                # 如果左半部是回文，且右半部的反轉存在於字典，則可配對\n                if left == left[::-1]:\n                    if right in rev_map and rev_map[right] != i:\n                        res.append([rev_map[right], i])\n\n                # 如果右半部是回文，且不是完整字串，且左半部的反轉存在於字典，則可配對\n                if right == right[::-1] and j != len(word):\n                    if left in rev_map and rev_map[left] != i:\n                        res.append([i, rev_map[left]])\n\n        return res\n\ndef main():\n    # 從標準輸入讀取整個資料\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式，例如：words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        words = ast.literal_eval(expr.strip())\n    else:\n        words = ast.literal_eval(data.strip())\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: Find palindrome pairs in array of unique strings. Complexity O(total length). Classic solution: Use hash map of reversed strings to index. For each word, iterate over splits, check palindrome prefixes/suffixes. We'll produce virtual code. Need to be line by line, each with comment. Must not output actual code, just virtual steps. Provide algorithm in natural steps.\n\nWe produce something like:\n\nStart\n→ Build hash map revMap: reversed(word) -> index\n→ For each index i and word w:\n   → For each split position j from 0 to len(w):\n       → left = w[0:j], right = w[j:]\n       → If left is palindrome:\n            → If reversed(right) exists and not same index:\n                → Record pair (revMap[right], i)\n       → If right is palindrome and j != len(w):\n            → If reversed(left) exists and not same index:\n                → Record pair (i, revMap[left])\n→ End\n\nAlso handle empty string special case: all palindromes with empty string.\n\nWe need to output in the required format.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 revMap，將每個單字反轉後作為 key，原索引作為 value // 用於快速查找反轉匹配\n→ Step 2: 若 words 包含空字串，對於每個非空單字 w，若 w 為回文，則將 (空字串索引, w 的索引) 與 (w 的索引, 空字串索引) 加入結果 // 空字串可與任何回文字配對\n→ Decision: 是否有空字串? Yes/No // 這裡已處理\n\n→ Step 3: 對於每個索引 i 與單字 w：\n    → For split j 從 0 到 len(w)：\n        → 計算 left = w[0:j]、right = w[j:] // 將字串拆成前後兩段\n        → Decision: left 是否為回文? Yes/No\n            Yes → Decision: right 的反轉是否存在於 revMap 且不同於 i? Yes/No\n                Yes → Step 4: 將 (revMap[right], i) 加入結果 // 前半為回文，後半為反轉可配對\n            No → // 不做任何事\n        → Decision: right 是否為回文且 j != len(w)? Yes/No\n            Yes → Decision: left 的反轉是否存在於 revMap 且不同於 i? Yes/No\n                Yes → Step 5: 將 (i, revMap[left]) 加入結果 // 後半為回文，前半為反轉可配對\n            No → // 不做任何事\n→ End // 程式執行結束\n\nNeed to output each step line with comment. Also include decision indentation.\n\nLet's produce accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 建立哈希表 revMap，將每個單字反轉後作為 key，原索引作為 value // 用於快速查找反轉匹配\n→ Step 2: 若 words 包含空字串，對於每個非空單字 w，若 w 為回文，則將 (空字串索引, w 的索引) 與 (w 的索引, 空字串索引) 加入結果 // 空字串可與任何回文字配對\n→ Decision: words 中是否有空字串? Yes → 已在 Step 2 處理，No → 直接跳至 Step 3\n→ Step 3: 對於每個索引 i 與單字 w：\n    → For split j 從 0 到 len(w)：\n        → 計算 left = w[0:j]、right = w[j:] // 將字串拆成前後兩段\n        → Decision: left 是否為回文? Yes → Decision: right 的反轉是否存在於 revMap 且不同於 i? Yes → Step 4: 將 (revMap[right], i) 加入結果 // 前半為回文，後半為反轉可配對\n        → Decision: right 是否為回文且 j != len(w)? Yes → Decision: left 的反轉是否存在於 revMap 且不同於 i? Yes → Step 5: 將 (i, revMap[left]) 加入結果 // 後半為回文，前半為反轉可配對\n→ End // 程式執行結束\n```"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import json\nfrom collections import Counter\nimport sys\n\ndef find_lus_length(strs):\n    \"\"\"\n    回傳陣列 strs 中，能成為「唯一子序列」的字串之最大長度。\n    若不存在則回傳 -1。\n    \"\"\"\n    # 計算每個字串出現的次數\n    freq = Counter(strs)\n    max_len = 0\n\n    # 遍歷所有字串，找出唯一字串並更新最大長度\n    for s in strs:\n        if freq[s] == 1:           # 只出現一次\n            if len(s) > max_len:\n                max_len = len(s)\n\n    # 若找不到唯一字串，回傳 -1\n    return max_len if max_len > 0 else -1\n\ndef main():\n    # 讀取輸入，預期為 JSON 格式的字串陣列\n    data = sys.stdin.read().strip()\n    if not data:\n        print(-1)\n        return\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若輸入不是合法 JSON，直接輸出 -1\n        print(-1)\n        return\n\n    # 確保輸入為字串列表\n    if not isinstance(strs, list) or not all(isinstance(x, str) for x in strs):\n        print(-1)\n        return\n\n    result = find_lus_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the problem: longest uncommon subsequence length between strings in array. Standard solution: if all strings same, return -1. Else if there exists a string that appears exactly once, return its length. Else return -1? Actually standard solution: longest uncommon subsequence between an array of strings is defined as a string that is a subsequence of one string but not the others. We need maximum length. Observation: if there exists a string that is unique (not duplicate), then that string itself is uncommon subsequence of itself and not of any other. So longest length is max length among unique strings. If all strings same, no uncommon subsequence, return -1.\n\nEdge case: duplicates with different lengths? For two identical strings, duplicates, but maybe a string that is unique but longer than duplicates? Standard solution: if there exists any string that is unique, return its length; else return -1.\n\nThus algorithm: count frequencies. For each string, if freq==1, track max length. If max remains 0 -> return -1 else return max.\n\nNow produce virtual code lines. Use Start, Decision, etc.\n\nWe should include steps: Start, Step 1: count frequencies, Step 2: initialize maxLen=0, Step 3: iterate strings, Step 4: if freq==1 update maxLen, Step 5: Decision: if maxLen>0? Yes -> return maxLen No -> return -1, End.\n\nAlso need explanation comments. Use arrow. Use \"Decision:\" lines with Yes → and No →. Provide comments.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 freq 用於統計每個字串出現次數 // 收集輸入陣列中每個字串的頻率  \n→ Step 2: 初始化 maxLen = 0 // 追蹤唯一字串中最長的長度  \n→ Step 3: 逐一遍歷 strs  \n  → Decision: 若 freq[str] == 1? // 判斷字串是否唯一  \n    Yes → Step 3a: maxLen = max(maxLen, len(str)) // 更新最大長度  \n    No → Step 3b: 繼續下一個字串 // 若非唯一，跳過  \n→ Step 4: Decision: 若 maxLen > 0? // 判斷是否存在唯一字串  \n   Yes → Step 4a: 回傳 maxLen // 最長的唯一字串即為最長非共有子序列長度  \n   No  → Step 4b: 回傳 -1 // 全部字串相同或無唯一字串時無效子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef permute(nums):\n    \"\"\"\n    產生所有排列的遞迴實作\n    \"\"\"\n    res = []\n\n    def backtrack(start):\n        # 基本情況：已形成完整排列\n        if start == len(nums):\n            res.append(nums[:])          # 追加目前排列的副本\n            return\n        # 嘗試把每個位置的元素放到 start\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]  # 交換\n            backtrack(start + 1)                         # 進一步遞迴\n            nums[start], nums[i] = nums[i], nums[start]  # 回溯\n\n    backtrack(0)\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得第一個 '[' 與最後一個 ']' 之間的子字串並轉成 list\n    l = data.find('[')\n    r = data.rfind(']')\n    if l == -1 or r == -1 or r < l:\n        nums = []\n    else:\n        nums_str = data[l:r+1]\n        nums = ast.literal_eval(nums_str)\n\n    result = permute(nums)\n    # 依題目格式產生輸出字串（無空格）\n    out = '[' + ','.join('[' + ','.join(map(str, sub)) + ']' for sub in result) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step by step, with each line containing virtual code step + \" // 解釋/說明\" in Traditional Chinese. Use Start, End, Decision. The algorithm: generate all permutations of array nums distinct integers. Use backtracking. Provide step-by-step pseudocode. Let's craft:\n\nStart\n→ Step 1: Define result list // initialize result container\n→ Step 2: Define backtrack function(current, visited) // recursive helper\n→ Decision: 如果 current length == nums length? // base case\n   Yes → Step 3: Append copy of current to result // add permutation\n   No  → Step 4: 循環遍歷 nums 每個索引 i // iterate each element\n        → Decision: 如果 visited[i] 為 true? // skip used\n            Yes → Continue\n            No  → Step 5: Mark visited[i] 為 true // choose element\n            → Step 6: Append nums[i] 到 current // add to permutation\n            → Step 7: 調用 backtrack(current, visited) // recurse\n            → Step 8: 移除 current 最後元素 // backtrack\n            → Step 9: Mark visited[i] 為 false // unmark\n→ Step 10: 調用 backtrack([], visited array false) // start recursion\n→ Step 11: 返回 result // 結果\nEnd\n\nWe need each line with arrow formatting and comment. Use \"→\" arrow. For decisions, we can use \"Decision:\".\n\nMake sure each line has virtual code step + space + // explanation.\n\nLet's produce lines. Use arrow for indentation? In example they used indentation inside decision. We'll replicate: For decisions, we indent the Yes/No branches with spaces before arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義 result 為空列表 // 初始化結果容器\n→ Step 2: 定義 backtrack(current, visited) 函式 // 遞迴輔助函式\n→ Decision: 如果 current 長度等於 nums 長度? // 基本情況：已形成完整排列\n    Yes → Step 3: 把 current 複製後加入 result // 將完整排列加入結果\n    No  → Step 4: 循環遍歷 nums 的每個索引 i // 嘗試添加每個元素\n        → Decision: 如果 visited[i] 為真? // 已選過的元素\n            Yes → Continue // 跳過已使用的元素\n            No  → Step 5: 設置 visited[i] 為真 // 標記元素已使用\n                → Step 6: 把 nums[i] 加入 current // 將元素加入排列\n                → Step 7: 調用 backtrack(current, visited) // 深度遞迴\n                → Step 8: 從 current 刪除最後一個元素 // 回溯\n                → Step 9: 設置 visited[i] 為假 // 取消標記\n→ Step 10: 調用 backtrack([], 新建長度為 nums 長度的 false 陣列) // 開始遞迴\n→ Step 11: 回傳 result // 返回所有排列\nEnd // 程式執行結束\n\nCheck format: each line should have virtual code step + space + // explanation. For branches we indent with spaces before arrow? Example: \"Yes → Step 3: ...\" is fine. For Continue, we need to have an arrow? In example they use \"Continue\" not arrow? They used \"Continue\" with arrow? They used \"Continue\" within branches, but no arrow. But we can keep \"Continue\" as step.\n\nLet's ensure each line ends with comment. Good. Use Traditional Chinese. All good.\n\nReturn the output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 result 為空列表 // 初始化結果容器  \n→ Step 2: 定義 backtrack(current, visited) 函式 // 遞迴輔助函式  \n→ Decision: 如果 current 長度等於 nums 長度? // 基本情況：已形成完整排列  \n    Yes → Step 3: 把 current 複製後加入 result // 將完整排列加入結果  \n    No  → Step 4: 循環遍歷 nums 的每個索引 i // 嘗試添加每個元素  \n        → Decision: 如果 visited[i] 為真? // 已選過的元素  \n            Yes → Continue // 跳過已使用的元素  \n            No  → Step 5: 設置 visited[i] 為真 // 標記元素已使用  \n                → Step 6: 把 nums[i] 加入 current // 將元素加入排列  \n                → Step 7: 調用 backtrack(current, visited) // 深度遞迴  \n                → Step 8: 從 current 刪除最後一個元素 // 回溯  \n                → Step 9: 設置 visited[i] 為假 // 取消標記  \n→ Step 10: 調用 backtrack([], 新建長度為 nums 長度的 false 陣列) // 開始遞迴  \n→ Step 11: 回傳 result // 返回所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxky7lt0t.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpxky7lt0t.py\", line 52, in main\n    result = Solution().fullJustify(words, maxWidth)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxky7lt0t.py\", line 24, in fullJustify\n    line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n           ^^^^^^^^^^^^^^^^^^^^\nTypeError: sequence item 0: expected str instance, list found"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7jb47t6f.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp7jb47t6f.py\", line 52, in main\n    result = Solution().fullJustify(words, maxWidth)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7jb47t6f.py\", line 24, in fullJustify\n    line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n           ^^^^^^^^^^^^^^^^^^^^\nTypeError: sequence item 0: expected str instance, list found"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe_bywlsy.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpe_bywlsy.py\", line 52, in main\n    result = Solution().fullJustify(words, maxWidth)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe_bywlsy.py\", line 24, in fullJustify\n    line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n           ^^^^^^^^^^^^^^^^^^^^\nTypeError: sequence item 0: expected str instance, list found"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # 找出能放進這一行的單字數量\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # 建立本行\n            line_words = words[i:j]\n            gaps = len(line_words) - 1\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n\n            if j == n or gaps == 0:            # 最後一行或單一單字\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:                               # 完全左右對齊\n                space, extra = divmod(spaces_needed, gaps)\n                parts = []\n                for k in range(gaps):\n                    parts.append(line_words[k] + ' ' * (space + (1 if k < extra else 0)))\n                parts.append(line_words[-1])\n                line = ''.join(parts)\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入\n    # 假設輸入形如: words = [\"This\", \"is\", ...], maxWidth = 16\n    parts = data.split('maxWidth =')\n    words_part = parts[0].strip()\n    width_part = parts[1].strip() if len(parts) > 1 else ''\n    list_str = words_part.split('=', 1)[1].strip()\n    words = ast.literal_eval(list_str)\n    maxWidth = int(width_part)\n\n    result = Solution().fullJustify(words, maxWidth)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for text justification. Each line: gather words greedily until adding next would exceed maxWidth. Then compute spaces distribution. Last line left-justified.\n\nWe need to output step-by-step lines with virtual code and comment. Use arrows: Start, →, Decision: if..., Yes→, No→, End.\n\nShould be in Traditional Chinese.\n\nLet's craft.\n\nStart\n→ Step 1: 初始化 result 為空列表 // 用於儲存格式化後的行\n→ Step 2: 初始化 index = 0 // 記錄當前處理到的單詞索引\nDecision: 如果 index < words.Length? // 檢查是否還有未處理的單詞\n    Yes → Step 3: 將 startIndex = index // 記錄行首單詞位置\n    → Step 4: 計算行內單詞總長 lineLen = 0 // 追蹤行中單詞總長度\n    → Step 5: 初始化 count = 0 // 追蹤單詞數\n    → Step 6: Decision: 如果 index < words.Length AND lineLen + words[index].Length + count <= maxWidth? // 判斷是否可將該單詞加入本行\n        Yes → Step 7: lineLen += words[index].Length // 累加單詞長度\n        → Step 8: count += 1 // 單詞數加一\n        → Step 9: index += 1 // 移動到下一個單詞\n        → Step 6 // 回到判斷條件\n        No  → Step 10: 如果 count == 1? // 行只有一個單詞\n            Yes → Step 11: line = words[startIndex] + repeatSpace(maxWidth - lineLen) // 該行右填空格\n            No  → Step 12: 計算總空格 totalSpace = maxWidth - lineLen // 剩餘空格數\n            → Step 13: 計算空格槽 slots = count - 1 // 單詞之間的槽數\n            → Step 14: 計算每槽空格 baseSpace = totalSpace // slots // 每槽基本空格\n            → Step 15: 計算多餘空格 extra = totalSpace % slots // 右側較少空格\n            → Step 16: 初始化 line = \"\" // 建立行字串\n            → Step 17: Decision: 如果 startIndex < words.Length? // 用於迴圈組裝單詞與空格\n                Yes → Step 18: line += words[startIndex] // 加入單詞\n                → Decision: 如果 startIndex < words.Length - 1? // 判斷是否還有下一個單詞\n                    Yes → Step 19: spacesToAdd = baseSpace + (extra > 0 ? 1 : 0) // 左側多加一個空格\n                    → Step 20: line += repeatSpace(spacesToAdd) // 加入空格\n                    → Step 21: if extra > 0 → extra -= 1 // 減少多餘空格計數\n                    → Step 22: startIndex += 1 // 移動到下一個單詞\n                    → Step 17 // 回到判斷條件\n                    No  → Step 23: startIndex += 1 // 移動到下一個單詞\n                    → Step 17\n                No  → Step 24: // 迴圈結束\n            → Step 25: result.append(line) // 將行加入結果\n        No → Step 26: // 迴圈結束\n    → Step 27: Decision: 如果 index == words.Length? // 判斷是否處理完所有單詞\n        Yes → Step 28: // 所有行已處理，結束主迴圈\n        No  → Step 29: // 回到主循環的開始，處理下一行\nEnd // 程式結束\n\nBut we need to also handle last line left-justified. In above we didn't check last line. Let's adjust: after gathering words for a line, check if index == words.Length. If yes, last line. Then build line differently: join words with single space, then pad with spaces to the right to reach maxWidth.\n\nWe need to modify Step 10 to handle last line case.\n\nLet's restructure:\n\nAfter Step 6 when no more words can fit, we decide if index == words.Length? That indicates last line. So we should compute differently.\n\nLet's rewrite Steps after Step 6 No branch.\n\nLet's outline entire algorithm:\n\n- While index < words.Length:\n  - start = index\n  - lineLen = 0\n  - count = 0\n  - While index < words.Length and lineLen + words[index].length + count <= maxWidth:\n      - lineLen += words[index].length\n      - count += 1\n      - index += 1\n  - If index == words.Length: // last line\n      - line = join words[start to index-1] with single space\n      - line += repeatSpace(maxWidth - line.length)\n  - Else:\n      - if count == 1:\n          line = words[start] + repeatSpace(maxWidth - lineLen)\n      - else:\n          totalSpace = maxWidth - lineLen\n          slots = count - 1\n          baseSpace = totalSpace // slots\n          extra = totalSpace % slots\n          line = \"\"\n          for i from start to index-1:\n              line += words[i]\n              if i < index-1:\n                  spaces = baseSpace + (extra > 0 ? 1 : 0)\n                  line += repeatSpace(spaces)\n                  if extra > 0: extra -= 1\n  - result.append(line)\n\nOk.\n\nLet's produce virtual code accordingly.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\".\n\nWe'll use arrows: Start, →, Decision:.\n\nUse \"RepeatSpace(n)\" as a helper.\n\nLet's write step-by-step.\n\nStart\n→ Step 1: result ← [] // 存放所有行\n→ Step 2: index ← 0 // 當前單詞索引\n→ Decision: index < words.Length? // 是否還有未處理單詞\n    Yes → Step 3: start ← index // 本行起始單詞索引\n    → Step 4: lineLen ← 0 // 本行單詞總長\n    → Step 5: count ← 0 // 本行單詞數\n    → Step 6: Decision: index < words.Length AND lineLen + words[index].length + count ≤ maxWidth? // 可否把 words[index] 加入本行\n        Yes → Step 7: lineLen ← lineLen + words[index].length // 加總長度\n        → Step 8: count ← count + 1 // 單詞數加一\n        → Step 9: index ← index + 1 // 移至下一單詞\n        → Step 6 // 重新判斷\n        No  → Step 10: Decision: index == words.Length? // 是否為最後一行\n                Yes → Step 11: line ← join words[start … index-1] with single space // 只用單個空格連接\n                → Step 12: line ← line + RepeatSpace(maxWidth - length(line)) // 右側填充空格\n                No  → Step 13: Decision: count == 1? // 本行只有一個單詞\n                    Yes → Step 14: line ← words[start] + RepeatSpace(maxWidth - lineLen) // 右填空格\n                    No  → Step 15: totalSpace ← maxWidth - lineLen // 需要分配的空格數\n                    → Step 16: slots ← count - 1 // 空格槽數\n                    → Step 17: baseSpace ← totalSpace // slots // 每槽基本空格\n                    → Step 18: extra ← totalSpace % slots // 右側較少空格的個數\n                    → Step 19: line ← \"\" // 初始化行字串\n                    → Step 20: i ← start // 從行首單詞開始\n                    → Step 21: Decision: i < index? // 迴圈：遍歷行內所有單詞\n                        Yes → Step 22: line ← line + words[i] // 加入單詞\n                        → Decision: i < index - 1? // 是否還有下一個單詞需要插空格\n                            Yes → Step 23: spaces ← baseSpace + (extra > 0 ? 1 : 0) // 左側多加一個空格\n                            → Step 24: line ← line + RepeatSpace(spaces) // 插入空格\n                            → Decision: extra > 0? // 更新多餘空格計數\n                                Yes → Step 25: extra ← extra - 1\n                            No  → // 無操作\n                            → Step 26: i ← i + 1 // 移到下一單詞\n                            → Step 21 // 重新判斷\n                        No  → Step 27: i ← i + 1\n                        → Step 21\n                    → Step 28: // 迴圈結束，line 已完整\n                → Step 29: result.append(line) // 將行加入結果\n        No → // 迴圈結束\n    → Step 30: // 從頭開始處理下一行\n→ Step 31: // 回到 Decision index < words.Length? 的檢查\nEnd\n\nBut we should also ensure we appended line at correct point. In above we appended inside Step 29. But if it's last line, we appended at Step 12? Actually we should append after building line. So we can move append after both cases.\n\nSimplify: After building line, we append.\n\nThus restructure: After Step 10/12/14/28 etc, after building line we append before next iteration.\n\nLet's craft more concise and accurate virtual code.\n\nI'll write:\n\nStart\n→ Step 1: result ← [] // 儲存所有行\n→ Step 2: i ← 0 // 當前單詞索引\n→ Decision: i < words.Length? // 是否還有單詞\n    Yes → Step 3: start ← i // 本行起始單詞\n    → Step 4: lineLen ← 0 // 本行單詞總長\n    → Step 5: count ← 0 // 本行單詞數\n    → Step 6: Decision: i < words.Length AND lineLen + words[i].length + count ≤ maxWidth? // 是否可加入\n        Yes → Step 7: lineLen ← lineLen + words[i].length\n        → Step 8: count ← count + 1\n        → Step 9: i ← i + 1\n        → Step 6\n        No  → Step 10: Decision: i == words.Length? // 最後一行\n                Yes → Step 11: line ← words[start … i-1] joined by single space\n                → Step 12: line ← line + RepeatSpace(maxWidth - length(line))\n                No  → Step 13: Decision: count == 1? // 只有一個單詞\n                    Yes → Step 14: line ← words[start] + RepeatSpace(maxWidth - lineLen)\n                    No  → Step 15: totalSpace ← maxWidth - lineLen\n                    → Step 16: slots ← count - 1\n                    → Step 17: baseSpace ← totalSpace // slots\n                    → Step 18: extra ← totalSpace % slots\n                    → Step 19: line ← \"\"\n                    → Step 20: j ← start\n                    → Step 21: Decision: j < i? // 迴圈\n                        Yes → Step 22: line ← line + words[j]\n                        → Decision: j < i - 1? // 需要插空格\n                            Yes → Step 23: spaces ← baseSpace + (extra > 0 ? 1 : 0)\n                            → Step 24: line ← line + RepeatSpace(spaces)\n                            → Decision: extra > 0? \n                                Yes → Step 25: extra ← extra - 1\n                            No\n                            → Step 26: j ← j + 1\n                            → Step 21\n                        No  → Step 27: j ← j + 1\n                        → Step 21\n                    → Step 28: // 行已完成\n                → Step 29: result.append(line)\n        No → // 無操作\n    → Step 30: // 從頭開始處理下一行\n→ Step 31: // 回到 Decision i < words.Length?\nEnd\n\nWe need to ensure Step 29 after building line; also after last line case we appended earlier at Step 29? Wait Step 29 is inside No branch of Decision i==words.Length? else? We need to place append after each case.\n\nLet's reorganize: after Step 12 for last line, we should append line. Similarly after Step 14 and Step 28. So we can place a generic Step X: result.append(line) after each of those branches.\n\nSimplify:\n\nAfter Step 12: Step 12a: result.append(line)\n\nAfter Step 14: Step 14a: result.append(line)\n\nAfter Step 28: Step 28a: result.append(line)\n\nBetter to write accordingly.\n\nLet's produce final version with these.\n\nAlso need to ensure we have a helper RepeatSpace(n) defined. Not necessary to declare but can assume exists.\n\nLet's produce the final virtual code.\n\nAlso, we should note we may need to re-evaluate Step 30 and Step 31: after appending, we go back to Decision.\n\nNow produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: result ← [] // 儲存所有已排版好的行\n→ Step 2: i ← 0 // 當前處理的單詞索引\n→ Decision: i < words.Length? // 是否還有未處理的單詞\n    Yes →\n        Step 3: start ← i // 本行起始單詞的位置\n        → Step 4: lineLen ← 0 // 本行已累加的單詞長度\n        → Step 5: count ← 0 // 本行單詞個數\n        → Step 6: Decision: i < words.Length AND lineLen + words[i].length + count ≤ maxWidth? // 該單詞能否加入本行\n            Yes →\n                Step 7: lineLen ← lineLen + words[i].length // 累加單詞長度\n                → Step 8: count ← count + 1 // 單詞個數加一\n                → Step 9: i ← i + 1 // 移動到下一個單詞\n                → Step 6 // 重新判斷是否還能加入\n            No →\n                Step 10: Decision: i == words.Length? // 這是否為最後一行\n                    Yes →\n                        Step 11: line ← join words[start … i-1] with single space // 只用單個空格連接單詞\n                        → Step 12: line ← line + RepeatSpace(maxWidth - length(line)) // 右側填充空格\n                        → Step 12a: result.append(line) // 將最後一行加入結果\n                    No →\n                        Step 13: Decision: count == 1? // 本行只有一個單詞\n                            Yes →\n                                Step 14: line ← words[start] + RepeatSpace(maxWidth - lineLen) // 右填空格\n                                → Step 14a: result.append(line) // 將單詞行加入結果\n                            No →\n                                Step 15: totalSpace ← maxWidth - lineLen // 需要分配的空格總數\n                                → Step 16: slots ← count - 1 // 空格槽數\n                                → Step 17: baseSpace ← totalSpace // slots // 每槽基本空格\n                                → Step 18: extra ← totalSpace % slots // 右側較少空格的個數\n                                → Step 19: line ← \"\" // 初始化行字串\n                                → Step 20: j ← start // 從行首單詞開始\n                                → Step 21: Decision: j < i? // 迴圈遍歷本行單詞\n                                    Yes →\n                                        Step 22: line ← line + words[j] // 加入單詞\n                                        → Decision: j < i - 1? // 是否還有下一個單詞需要插入空格\n                                            Yes →\n                                                Step 23: spaces ← baseSpace + (extra > 0 ? 1 : 0) // 左側多一個空格\n                                                → Step 24: line ← line + RepeatSpace(spaces) // 插入空格\n                                                → Decision: extra > 0? // 更新多餘空格計數\n                                                    Yes → Step 25: extra ← extra - 1\n                                                No\n                                                → Step 26: j ← j + 1 // 移到下一單詞\n                                                → Step 21 // 回到判斷條件\n                                            No →\n                                                Step 27: j ← j + 1 // 迴圈結束\n                                                → Step 21\n                                    No →\n                                        Step 28: // 行已完成\n                                → Step 28a: result.append(line) // 將行加入結果\n        → Step 30: // 本行處理完畢，開始下一行\n→ Step 31: // 回到 Decision i < words.Length? 重新檢查是否還有單詞\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # 使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        \n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        \n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        \n        return slow\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 去除可能的前置文字，例如 \"nums = \"\n    if \"=\" in data:\n        _, list_str = data.split(\"=\", 1)\n    else:\n        list_str = data\n\n    # 用 ast.literal_eval 解析列表，確保安全\n    nums = ast.literal_eval(list_str.strip())\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: find duplicate in array without modifying array, constant extra space. The standard solution: Floyd's Tortoise and Hare (cycle detection). Steps: treat array as linked list; find intersection point; then find start of cycle.\n\nWe produce virtual code lines step-by-step. Each line: \"虛擬碼步驟 // 解釋\". Use arrow syntax. Provide Start, End. Provide Decision branches. For algorithm, it's straightforward: define slow, fast pointers, loop until they meet, then reset pointer to start and move both one step until they meet again, that's duplicate.\n\nWe need to break into steps: Start, Step 1: initialize pointers, etc. Use decision for loop condition. Use arrow for steps. Also use Decision: if slow != fast? Actually while loop. In pseudocode, we can do:\n\nStart\n→ Step 1: Set slow = nums[0], fast = nums[0] // Initialize pointers at first element\n→ Step 2: Repeat: slow = nums[slow]; fast = nums[nums[fast]] until slow == fast // Find intersection\n→ Decision: If slow == fast? Yes -> proceed to find entry\n→ Step 3: Set fast = nums[0] // Move fast to start\n→ Step 4: While slow != fast: slow = nums[slow]; fast = nums[fast] // Find cycle start\n→ Step 5: Return slow // Duplicate number\nEnd\n\nWe can add decisions for loops: while conditions. But we can keep simple. Use arrow for steps. Might incorporate \"Decision: 循環結束條件?\" Not necessary but could show. Use \"Decision: slow == fast?\" then Yes-> Step 3.\n\nAlso mention constant space. Provide explanation per line.\n\nOk. We'll output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow = nums[0], fast = nums[0] // 將慢指標與快指標初始化為陣列第一個元素  \n→ Step 2: Repeat // 進入尋找交點的循環  \n  slow = nums[slow] // 慢指標每次移動一步  \n  fast = nums[nums[fast]] // 快指標每次移動兩步  \n  until slow == fast // 直到兩指標相遇為止  \n→ Decision: slow == fast? // 檢查是否已相遇（必定會）  \n  Yes → Step 3: fast = nums[0] // 把快指標重新移到陣列起點  \n→ Step 4: While slow != fast: // 進入尋找循環入口的循環  \n  slow = nums[slow] // 慢指標每次移動一步  \n  fast = nums[fast] // 快指標也每次移動一步  \n→ Step 5: Return slow // 當兩指標再次相遇時，slow 指向重複數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[None,True,False,True,1,True,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[None, True, False, True, 1, True, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # list 存放所有元素，方便隨機取值\n        self.data = []\n        # 字典映射 val -> set of indices 在 data 中的位置\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 新增元素到 data\n        self.data.append(val)\n        # 位置為新元素的索引\n        idx = len(self.data) - 1\n        # 加入索引集合\n        self.idx_map[val].add(idx)\n        # 若是第一次出現則返回 True，否則 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 若不存在任何此 val，直接回傳 False\n        if not self.idx_map[val]:\n            return False\n\n        # 從集合中取得任意一個索引\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n\n        # 如果要移除的不是最後一個元素，則把最後一個元素移到此位置\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n\n        # 移除 data 最後一個元素\n        self.data.pop()\n\n        # 若此 val 的索引集合已空，移除該鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機取一個索引並返回對應值\n        return random.choice(self.data)\n\nif __name__ == \"__main__\":\n    # 讀入整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 找到第一個閉括號的位置，分離兩個列表\n    first_bracket = raw_input.find(']')\n    ops_str = raw_input[:first_bracket + 1]\n    args_str = raw_input[first_bracket + 2:].strip()\n\n    # 轉成 Python 對象\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    result = []\n    collection = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            collection = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            result.append(collection.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(collection.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(collection.getRandom())\n\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing RandomizedCollection class with insert, remove, getRandom O(1). Provide line-by-line pseudocode with explanations. Should use arrow structure Start, End, Decision. Let's design steps: Data structures: vector/list for values, map from val to set of indices. Insertion: append to list, add index to map. Return true if first time. Remove: if val not in map return false. else get one index from map set. Remove from list: swap with last element, update map for swapped value. Remove last. Return true. getRandom: random index from list size.\n\nNow produce pseudo-code with line-by-line steps. Use arrow style. Each line includes // explanation. Should not output actual code. So use high-level steps like \"Start\", \"→ Initialize data structures\", etc.\n\nWe should include function definitions. Perhaps:\n\nStart // 開始\n→ Initialize RandomizedCollection // 建構子初始化\n\n→ Function insert(val)\n    → If val not in map: add new entry, set is empty\n    → Append val to list\n    → Add index to map[val]\n    → If this is first occurrence return true else false\n    → End insert\n\n→ Function remove(val)\n    → Decision: val exists in map?\n        Yes → Get any index from map[val]\n              → Remove index from map[val]\n              → Get last element index\n              → If index not last: swap list[index] with last element\n                    → Update map of swapped value: remove old index, add new index\n              → Remove last element from list\n              → If map[val] empty, delete entry\n              → Return true\n        No → Return false\n\n→ Function getRandom()\n    → Random index 0..size-1\n    → Return list[index]\n\nEnd // 結束\n\nBut need line-by-line with arrows and explanations. Let's format accordingly.\n\nWe might break into multiple steps per function but maintain readability.\n\nUse \"→\" for each line. Use \"Decision:\" for branching.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize RandomizedCollection() // 建構子：初始化資料結構\n    → values ← 空列表 // 用來儲存所有元素，支持隨機存取\n    → indicesMap ← 空映射 <int, set<int>> // 每個值對應其在 values 中的索引集合\n\n→ Function insert(val) // 插入函式\n    → Decision: indicesMap 是否包含 val? // 檢查 val 是否已存在\n        Yes → existed ← true // 已存在\n        No  → existed ← false // 首次出現\n    → Append val 至 values // 在列表尾部新增元素\n    → currentIndex ← values.size() - 1 // 新增元素的索引\n    → Insert currentIndex 至 indicesMap[val] // 更新索引集合\n    → Return !existed // 若首次出現返回 true，否則返回 false\nEnd // 插入完成\n\n→ Function remove(val) // 移除函式\n    → Decision: indicesMap 是否包含 val? // 檢查是否有可移除的元素\n        No → Return false // 沒有該元素\n        Yes → // 有元素可移除\n            → anyIndex ← indicesMap[val].任意元素 // 取出任意一個索引\n            → indicesMap[val].移除 anyIndex // 從集合中移除此索引\n            → lastIndex ← values.size() - 1 // 列表最後一個索引\n            → lastValue ← values[lastIndex] // 最後一個元素值\n            → If anyIndex ≠ lastIndex // 若被移除元素不是最後一個\n                → values[anyIndex] ← lastValue // 用最後一個元素覆蓋\n                → indicesMap[lastValue].移除 lastIndex // 刪除舊索引\n                → indicesMap[lastValue].插入 anyIndex // 插入新索引\n            → Remove values 的最後一個元素 // 刪除尾部\n            → If indicesMap[val] 為空集合 // 若該值已無剩餘索引\n                → 刪除 indicesMap[val] // 從映射中移除鍵\n            → Return true // 成功移除\nEnd // 移除完成\n\n→ Function getRandom() // 隨機取值\n    → randIndex ← 隨機數 0 ~ values.size() - 1 // 產生隨機索引\n    → Return values[randIndex] // 回傳隨機元素\nEnd // 隨機取值完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp00sp9p_7.py\", line 35, in <module>\n    coins, amount = parse_input(input_data)\n                    ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp00sp9p_7.py\", line 27, in parse_input\n    coins = eval(coins_part, {}, {})\n            ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # 初始化 dp 陣列，dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析類似 'coins = [1,2,5], amount = 11' 的字串。\n    \"\"\"\n    # 移除多餘的關鍵字與空白\n    data = data.strip().replace('coins =', '').replace('amount =', '').strip()\n    # 分割成兩部分：列表與數字\n    parts = data.split(',', 1)\n    coins_part = parts[0].strip()\n    amount_part = parts[1].strip() if len(parts) > 1 else ''\n    # 使用 eval 解析列表\n    coins = eval(coins_part, {}, {})\n    amount = int(amount_part)\n    return coins, amount\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    if not input_data.strip():\n        sys.exit(0)\n    coins, amount = parse_input(input_data)\n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for coin change DP (minimum number of coins). Use dynamic programming.\n\nWe must produce step-by-step pseudo-code with arrows and decision etc.\n\nWe need to handle DP array of size amount+1, initialize with large value except dp[0]=0.\n\nThen iterate over coins, for each coin iterate amount from coin to target, update dp[j] = min(dp[j], dp[j-coin]+1).\n\nFinally, if dp[amount] > amount then return -1 else dp[amount].\n\nWe should output each line with \"虛擬碼步驟 // 解釋\". Use Start, End. Use Decision. Use arrows. The pseudo-code lines should reflect steps.\n\nWe need to avoid actual code, but use generic names.\n\nWe need to include arrow \"→\". And decisions \"Decision:\".\n\nWe can break into steps: Start, initialize dp, for each coin, for each j, update, decision at end.\n\nLet's write:\n\nStart\n→ Step 1: 定義 dp 陣列長度 amount+1 // 建立 DP 表\n→ Step 2: 設定 dp[0] = 0, 其餘 dp[i] = ∞ // 基本情況\n→ Decision: coins 為空? // 檢查是否有硬幣\n    Yes → End // 無硬幣直接結束\n    No  → Step 3: 循環每個 coin in coins // 處理每個硬幣面額\n→ Step 4: 內層循環 j 從 coin 到 amount // 逐個金額更新\n→ Step 5: 計算新值 = dp[j - coin] + 1 // 以當前硬幣組成\n→ Decision: 新值 < dp[j]? // 是否更少硬幣\n    Yes → Step 6: dp[j] = 新值 // 更新\n    No  → Step 7: 保持 dp[j] // 不更新\n→ Decision: 所有 j 已遍歷? // 完成一個硬幣\n    Yes → Step 8: 前往下一個 coin\n    No  → Step 4 // 內層循環\n→ Decision: 所有 coin 已遍歷? // 完成 DP\n    Yes → Step 9: 判斷 dp[amount] 是否仍為 ∞ // 檢查是否可達\n        Yes → Step 10: 返回 -1 // 無解\n        No  → Step 11: 返回 dp[amount] // 最小硬幣數\n    No  → Step 3 // 外層循環\nEnd\n\nBut we need to ensure arrows formatting: \"→\" preceding steps, indent decisions.\n\nLet's produce final output.\n\nRemember each line: \"虛擬碼步驟 // 解釋\"\n\nWe must use Start and End.\n\nLet's format properly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列，長度為 amount + 1 // 用於存放每個金額所需的最小硬幣數  \n→ Step 2: 設定 dp[0] = 0，其他 dp[i] = ∞ // 金額為 0 時不需要硬幣，其他先設為無限大  \n→ Decision: coins 是否為空? // 判斷是否有可用硬幣  \n  Yes → End // 沒有硬幣直接結束，返回 -1  \n  No  → Step 3: 依序處理每個 coin in coins // 開始對每個硬幣面額做 DP 更新  \n→ Step 4: 內層循環 j 從 coin 到 amount // 對每個可能的金額更新 dp[j]  \n→ Step 5: 新值 = dp[j - coin] + 1 // 若使用當前硬幣，可得到的硬幣數  \n→ Decision: 新值 < dp[j]? // 判斷是否比目前已知的更少硬幣  \n  Yes → Step 6: dp[j] = 新值 // 更新為更優解  \n  No  → Step 7: 不改變 dp[j] // 保持現有值  \n→ Decision: j 是否已達 amount? // 完成內層循環  \n  Yes → Step 8: 前往下一個 coin // 結束本硬幣的更新  \n  No  → Step 4 // 繼續更新下一個金額  \n→ Decision: 所有 coin 是否已處理完? // 完成 DP 計算  \n  Yes → Step 9: 判斷 dp[amount] 是否仍為 ∞ // 檢查是否可達目標金額  \n    Yes → Step 10: 返回 -1 // 無法組成目標金額  \n    No  → Step 11: 返回 dp[amount] // 回傳最少硬幣數  \n  No  → Step 3 // 處理下一個硬幣  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6nf1hwwc.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmp6nf1hwwc.py\", line 43, in main\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 75 (char 74)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"使用兩個堆（大根堆 + 小根堆）維護中位數。\"\"\"\n    def __init__(self):\n        # small 為大根堆，存儲負值以利用 heapq 的最小堆實現\n        self.small = []  # 小半部，負值的最大值對應實際最小值\n        self.large = []  # 大半部，最小堆\n\n    def addNum(self, num: int) -> None:\n        \"\"\"將新數字加入資料結構。\"\"\"\n        # 先推入 small（負值堆），保持小半部總是先被填充\n        heapq.heappush(self.small, -num)\n\n        # 若 small 的最大值（實際最小值）大於 large 的最小值，則交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 重新平衡兩個堆，保證大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"返回目前所有數字的中位數。\"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    \"\"\"主函式：讀取操作序列，執行並輸出結果。\"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    # 兩行分別是操作名稱與參數列表，使用 json.loads 解析\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            res.append(None)          # 建構子返回 null\n        elif op == \"addNum\":\n            obj.addNum(arg[0])        # arg 為 [num]\n            res.append(None)          # addNum 也返回 null\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            res.append(median)        # 將實際中位數加入結果\n        else:\n            # 若出現未知操作，可忽略或拋出例外\n            res.append(None)\n\n    # 使用 json.dumps 直接輸出符合 LeetCode 期望的格式\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder, with operations addNum and findMedian. Use two heaps approach. Provide step-by-step pseudocode with explanations. Must not produce actual code but virtual steps. Use arrows, decisions. Output line by line. Probably start with class, initialize two heaps: maxHeap for lower half, minHeap for upper half. For addNum: if maxHeap empty or num <= maxHeap.peek, push to maxHeap else push to minHeap. Then rebalance: if size difference >1, move top from one heap to other. For findMedian: if sizes equal, median = (maxHeap.peek + minHeap.peek)/2. Else median = top of larger heap. Provide each step as virtual step with explanation. Use `Start`, `End`. Provide decisions with Yes/No. Provide variable names. Each line with explanation. Use `→` arrow. Should be clear. Let's write.\n\nWe'll treat each major operation as separate function. Provide steps for constructor, addNum, findMedian. Possibly also steps for helper functions like balanceHeaps. We'll produce steps.\n\nRemember to use \"虛擬碼步驟\" and explanation comment. Format each line: `虛擬碼步驟 // 解釋`. Use arrow `→`. Ok. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Declare MedianFinder // 建立 MedianFinder 類別\n    → MaxHeap lowerHalf // 儲存較小的一半，最大堆\n    → MinHeap upperHalf // 儲存較大的一半，最小堆\n→ End // 建構子完成\n\nStart // addNum 函式開始執行\n    → Step 1: 接收 num // 取得要加入的整數\n    → Decision: lowerHalf 是否空? // 判斷左半堆是否還沒有元素\n        Yes → Step 2: lowerHalf 插入 num // 若左半堆空，直接放進去\n        No  → Decision: num <= lowerHalf.Peek() ? // 否則比較 num 與左半堆最大值\n            Yes → Step 3: lowerHalf 插入 num // 小於等於最大值，放入左半堆\n            No  → Step 4: upperHalf 插入 num // 大於最大值，放入右半堆\n    → Step 5: Call BalanceHeaps() // 重新平衡兩堆大小\n→ End // addNum 完成\n\nStart // BalanceHeaps 函式開始執行\n    → Decision: lowerHalf.Size() > upperHalf.Size() + 1 ? // 左半堆太大\n        Yes → Step 6: Move top of lowerHalf 到 upperHalf // 從左到右移動最大值\n        No  → Decision: upperHalf.Size() > lowerHalf.Size() + 1 ? // 右半堆太大\n            Yes → Step 7: Move top of upperHalf 到 lowerHalf // 從右到左移動最小值\n            No  → Step 8: Do nothing // 大小差已在允許範圍內\n→ End // BalanceHeaps 完成\n\nStart // findMedian 函式開始執行\n    → Decision: lowerHalf.Size() == upperHalf.Size() ? // 堆大小相等\n        Yes → Step 9: median = (lowerHalf.Peek() + upperHalf.Peek()) / 2.0 // 取平均\n        No  → Decision: lowerHalf.Size() > upperHalf.Size() ? // 左半堆更大\n            Yes → Step 10: median = lowerHalf.Peek() // 取左半堆最大值\n            No  → Step 11: median = upperHalf.Peek() // 取右半堆最小值\n    → Step 12: 返回 median // 傳回計算出的中位數\n→ End // findMedian 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbbck9ny7.py\", line 69, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbbck9ny7.py\", line 57, in parse_input\n    raise ValueError(\"Input does not contain two list expressions.\")\nValueError: Input does not contain two list expressions."
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwqvz33a6.py\", line 69, in <module>\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwqvz33a6.py\", line 57, in parse_input\n    raise ValueError(\"Input does not contain two list expressions.\")\nValueError: Input does not contain two list expressions."
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted list of non-overlapping intervals,\n        merging overlaps if necessary.\n\n        Parameters\n        ----------\n        intervals : List[List[int]]\n            Sorted list of non-overlapping intervals.\n        newInterval : List[int]\n            The interval to insert.\n\n        Returns\n        -------\n        List[List[int]]\n            The updated list of intervals after insertion and merging.\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Append the merged (or original) new interval\n        result.append(newInterval)\n\n        # Append the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse the input string to extract the intervals list and the new interval.\n\n    The expected format is something like:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    \"\"\"\n    # Find all bracketed expressions which correspond to lists\n    brackets = re.findall(r'\\[.*?\\]', input_str)\n    if len(brackets) != 2:\n        raise ValueError(\"Input does not contain two list expressions.\")\n    intervals = eval(brackets[0])\n    new_interval = eval(brackets[1])\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Parse input into intervals and newInterval\n    intervals, new_interval = parse_input(raw_input)\n\n    # Solve the problem\n    sol = Solution()\n    merged = sol.insert(intervals, new_interval)\n\n    # Output the result\n    print(merged)",
      "virtual_code": "Thinking...\nWe need produce pseudocode for interval insertion merging. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and Decision structure. Should be step-by-step.\n\nWe will output steps: start, initialize result array, iterate intervals. Cases: before newInterval, after newInterval, overlapping. Then at end, append newInterval if not yet appended. Then return result. Use virtual code syntax with arrows.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 result // 用於存放最終的非重疊區間  \n→ Step 2: 設定 i = 0 // 指標指向 intervals 的第一個區間  \n→ Step 3: 取得 new_start, new_end ← newInterval[0], newInterval[1] // 取出新區間的起始與結束  \n\n→ Decision: i < intervals.length 且 intervals[i].end < new_start? // 檢查目前區間是否完全在新區間之前  \n    Yes → Step 4: result.append(intervals[i]) // 加入原區間  \n          → Step 5: i = i + 1 // 移到下一個區間  \n          → Decision: 轉回 Step 3  \n    No  → Decision: i < intervals.length 且 intervals[i].start > new_end? // 檢查目前區間是否完全在新區間之後  \n        Yes → Step 6: result.append(newInterval) // 將新區間加入結果  \n              → Step 7: 從 i 到 intervals.length - 1 全部加入 result // 把剩餘區間直接加進去  \n              → End // 程式執行結束  \n        No  → Step 8: 計算 merge_start ← min(intervals[i].start, new_start)  \n              → Step 9: 計算 merge_end ← max(intervals[i].end, new_end)  \n              → Step 10: 設定 new_start = merge_start, new_end = merge_end // 更新新區間為合併後的區間  \n              → Step 11: i = i + 1 // 進行下一個區間的合併判斷  \n              → Decision: 轉回 Step 3  \n\n// 如果所有區間都已檢查完畢，仍未加入 newInterval，則在最後加入  \n→ Decision: new_start <= new_end? // 檢查是否還有新區間待加入  \n    Yes → Step 12: result.append([new_start, new_end]) // 加入合併後的區間  \n    No  → No action  \n\n→ Step 13: Return result // 回傳最終的非重疊區間列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import defaultdict\n\ndef group_anagrams(strs):\n    \"\"\"\n    Group anagrams from the list of strings.\n\n    :param strs: List[str]\n    :return: List[List[str]]\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))          # 排序後的元組作為鍵\n        anagrams[key].append(s)\n    return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入格式：strs = [...]\n    if data.startswith(\"strs\"):\n        # 取等號之後的部分並剔除前後空白\n        _, value_part = data.split(\"=\", 1)\n        value_part = value_part.strip()\n        # 使用 literal_eval 解析為 Python 物件\n        try:\n            strs_list = ast.literal_eval(value_part)\n        except Exception:\n            # 若解析失敗，則視為空列表\n            strs_list = []\n    else:\n        # 若輸入格式不符合，視為空列表\n        strs_list = []\n\n    # 取得結果並以 JSON 格式輸出（使用雙引號）\n    result = group_anagrams(strs_list)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Traditional Chinese, with \"虛擬碼步驟\" and comment. Use arrows, Start, End, Decision. Need to group anagrams: sort each string to key, map to list. So steps: Start, input array, initialize map, loop over each string, compute sorted key, if key exists append, else new list, after loop produce list of values, output. Use Decision for key existence.\n\nMake sure each line: \"Start // 程式開始執行\" etc.\n\nFollow output format exactly. Each line \"虛擬碼步驟 [space] // 解釋\". Use arrows (→). Indentation: maybe no indentation, just plain. Use Decision lines with Yes → and No →.\n\nWe produce lines:\n\nStart // 程式開始執行\n→ Step 1: Input array strs // 取得輸入的字串陣列\n→ Step 2: Initialize empty map map<string, list<string>> // 建立哈希表存放排序後的鍵與對應字串列表\n→ Step 3: For each string s in strs // 逐一處理每個字串\n    → Step 3a: key = sorted characters of s // 將字串排序得到鍵\n    → Decision: key 是否已在 map? // 檢查鍵是否已存在\n        Yes → Step 3b: Append s to map[key] // 若存在，加入對應列表\n        No  → Step 3c: map[key] = new list containing s // 若不存在，建立新列表\n→ Step 4: Output list of map values // 取得所有分組並輸出\nEnd // 程式執行結束\n\nBut we must follow exact format: Each line must be a \"虛擬碼步驟\" followed by space then comment. Use arrow arrows as in example. For loop: Use Step 3: For each s in strs // 逐一處理。 But need arrow for inner steps? In example they used nested arrows with indentation maybe not required but show hierarchical.\n\nWe should keep lines exactly one virtual step each. Use \"→\" at start of each step. For decisions: \"→ Decision: ...\". Use \"Yes →\" and \"No →\" indent with space after.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Input strs // 取得輸入的字串陣列\n→ Step 2: 初始化 map key→list<string> // 建立哈希表\n→ Step 3: For each s in strs // 逐一遍歷字串\n    → Step 3a: key = sort(s) // 將字串字符排序作為鍵\n    → Decision: key 是否存在於 map? // 檢查鍵是否已經有對應\n        Yes → Step 3b: map[key].append(s) // 已存在則加入列表\n        No  → Step 3c: map[key] = [s] // 不存在則建立新列表\n→ Step 4: Output map.values() // 取出所有分組作為結果\nEnd // 程式結束\n\nMake sure each line ends with comment. Indentation lines may be included, but we need to maintain format: each line must have \"虛擬碼步驟\" at start. For nested, we can keep indentation but still include arrow at start. Eg \"→ Step 3a: ...\" line. Good.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input strs // 取得輸入的字串陣列  \n→ Step 2: 初始化 map key→list<string> // 建立哈希表以存放排序後的鍵與對應字串列表  \n→ Step 3: For each s in strs // 逐一遍歷字串  \n → Step 3a: key = sort(s) // 將字串字符排序作為鍵  \n → Decision: key 是否存在於 map? // 檢查鍵是否已經有對應  \n  Yes → Step 3b: map[key].append(s) // 已存在則加入列表  \n  No  → Step 3c: map[key] = [s] // 不存在則建立新列表  \n→ Step 4: Output map.values() // 取出所有分組作為結果  \nEnd // 程式結束"
    },
    {
      "title": "Palindrome Number",
      "source_file": "Leetcode/leetcode9.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'false'\nGot (Norm):      'true'\n--- (Raw) ---\nRaw Expected: 'false'\nRaw Got:      'true'"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 判斷給定整數是否為回文數\ndef is_palindrome(x: int) -> bool:\n    # 負數永遠不是回文\n    if x < 0:\n        return False\n    rev = 0\n    # 只需要反轉一半的數字即可判斷\n    while x > rev:\n        rev = rev * 10 + x % 10\n        x //= 10\n    # 奇數長度時中間數位不需要比較，偶數長度則直接比較\n    return x == rev or x == rev // 10\n\ndef main():\n    # 從標準輸入讀取所有內容\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 用正則表達式抓取第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        print(\"false\")\n        return\n    num = int(match.group())\n    # 判斷是否為回文並輸出結果（小寫字母）\n    print(str(is_palindrome(num)).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for checking if integer is palindrome. Use virtual code structure: Start, Decision, etc. Provide each line with \"//\" explanation. Use arrow lines. Must be in Traditional Chinese. No actual code. Provide step-by-step logic: convert to string or use digit extraction. Let's produce simple algorithm: if x<0 return false, if x%10==0 && x!=0 return false. Then reverse half and compare. Provide steps.\n\nWe'll produce lines:\n\nStart\n→ Step 1: if x < 0 then return false // negative not palindrome\n→ Step 2: if x % 10 == 0 and x != 0 then return false // trailing zero cannot be palindrome\n→ Step 3: Initialize rev = 0 // reversed number\n→ Decision: While x > rev? // compare\n    Yes → Step 4: rev = rev * 10 + x % 10; x = x / 10 // build reversed half\n    No  → Decision: If x == rev or x == rev/10? // check equality\n        Yes → Step 5: return true // palindrome\n        No  → Step 6: return false // not palindrome\nEnd\n\nBut we need to include decisions properly. Use \"Decision:\" lines and Yes/No arrow lines. Ensure each line ends with // explanation.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 x 小於 0? // 判斷負數  \n    Yes → Step 1: 回傳 false // 負數永遠不是回文  \n    No  → Decision: 如果 x 結尾為 0 且 x 不為 0? // 末尾 0 不是回文除非數字本身是 0  \n        Yes → Step 2: 回傳 false // 例如 10、20 等不是回文  \n        No  → Step 3: 初始化 rev = 0 // 反轉數字的一半  \n→ Decision: 當 x > rev? // 只需要反轉一半即可判斷  \n    Yes → Step 4: rev = rev * 10 + x % 10 // 把 x 的最後一位加到 rev  \n           → Step 5: x = x / 10 // 把 x 右移一位  \n        No  → Decision: x == rev 或 x == rev / 10? // 奇偶位長度相同或不同時比較  \n            Yes → Step 6: 回傳 true // 符合回文條件  \n            No  → Step 7: 回傳 false // 不符合回文條件  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字轉換為整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0\n    prev_value = 0\n    # 逆序遍歷，若前一個值更大則進行減法\n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef extract_roman(s: str) -> str:\n    \"\"\"\n    從輸入文字中抽取羅馬數字。\n    支援形式如 's = \"III\"'、'Input: s = \"MCMXCIV\"' 或單純 'III'。\n    \"\"\"\n    # 先嘗試在雙引號內抓取\n    match = re.search(r'\"([IVXLCDM]+)\"', s)\n    if match:\n        return match.group(1)\n    # 若無雙引號，直接去除前後空白、字串引號及前綴\n    s = s.strip()\n    if s.startswith('s'):\n        s = s.split('=', 1)[-1].strip()\n    return s.strip('\"').strip()\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    roman_str = extract_roman(data)\n    result = roman_to_int(roman_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for converting Roman numeral string to integer. Steps: Start, initialize sum, iterate over characters with index. For each char, get value. If next char exists and current value < next value, subtract else add. After loop, End. Also handle mapping.\n\nWe should produce lines with arrow → and Decision etc.\n\nLet's structure:\n\nStart\n→ Step 1: 定義符號對應值映射 // mapping table\n→ Step 2: 初始化 total = 0 // 計算結果\n→ Step 3: 取得輸入字串 s // Roman numeral input\n→ Decision: s 是否為空？ // check empty\n    Yes → Step 4: 輸出 0 // 空輸入回傳 0\n    No  →\n→ Step 5: 對於每個索引 i 從 0 到 length(s)-1 循環 // 遍歷字符\n    → Decision: 是否存在下一個字符？ // 有下標 i+1 嗎\n        Yes → \n            → Step 6: current = value(s[i]) // 獲取當前字符值\n            → Step 7: next = value(s[i+1]) // 獲取下一字符值\n            → Decision: current < next? // 判斷減法情況\n                Yes → \n                    → Step 8: total = total - current // 減去\n                No  → \n                    → Step 9: total = total + current // 加上\n        No →\n            → Step 10: total = total + value(s[i]) // 最後一個字符直接加\n→ Step 11: 輸出 total // 回傳整數\nEnd\n\nBut we should also use arrow formatting exactly: \"→ Step ...\". Decision block indentation: each Yes/No branch lines also have arrows.\n\nAlso the mapping definition step maybe like \"→ Step 1: 定義字典 map = {...}\".\n\nMake sure to use \"→ Decision:\" with indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義符號對應值映射 // 建立字典：I→1, V→5, X→10, L→50, C→100, D→500, M→1000  \n→ Step 2: 初始化 total = 0 // 用於累加整數值  \n→ Step 3: 取得輸入字串 s // 讀取羅馬數字輸入  \n→ Decision: s 是否為空？ // 檢查輸入是否為空字串  \n Yes → Step 4: 輸出 0 // 空輸入直接回傳 0  \n No  →  \n → Step 5: 對於每個索引 i 從 0 到 length(s)-1 循環 // 遍歷每個字符  \n  → Decision: 是否存在下一個字符？ // 判斷是否還有 i+1  \n   Yes →  \n    → Step 6: current = value(s[i]) // 取得當前字符對應值  \n    → Step 7: next = value(s[i+1]) // 取得下一字符對應值  \n    → Decision: current < next? // 判斷是否為減法情況  \n     Yes →  \n      → Step 8: total = total - current // 進行減法  \n     No →  \n      → Step 9: total = total + current // 進行加法  \n   No  →  \n    → Step 10: total = total + value(s[i]) // 最後一個字符直接加  \n→ Step 11: 輸出 total // 回傳最終整數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpau86p984.py\", line 50, in <module>\n    main()\n  File \"/tmp/tmpau86p984.py\", line 44, in main\n    nums, target = parse_input(first_line)\n                   ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpau86p984.py\", line 29, in parse_input\n    nums = ast.literal_eval(val.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # dp[i] 表示能組成總和 i 的組合數量\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 基本情況：只有一種方式達到總和 0（不選任何數字）\n        \n        # 動態規劃：對於每個子目標 i，嘗試使用 nums 中的每個數字\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef parse_input(line):\n    \"\"\"\n    解析形如 'nums = [1,2,3], target = 4' 的輸入行。\n    返回 nums（列表）與 target（整數）。\n    \"\"\"\n    nums = None\n    target = None\n    # 先把可能的空白去掉，然後以逗號分隔\n    parts = [p.strip() for p in line.strip().split(',')]\n    for part in parts:\n        if part.startswith('nums'):\n            _, val = part.split('=', 1)\n            nums = ast.literal_eval(val.strip())\n        elif part.startswith('target'):\n            _, val = part.split('=', 1)\n            target = int(val.strip())\n    if nums is None or target is None:\n        raise ValueError(\"輸入格式不正確\")\n    return nums, target\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 只取第一行作為測試輸入\n    first_line = data.splitlines()[0]\n    nums, target = parse_input(first_line)\n    sol = Solution()\n    result = sol.combinationSum4(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for counting number of combinations to reach target using array of distinct ints. This is classic coin change combinations count. We need to output pseudocode line by line with explanation. Use virtual code structure. We need to show steps: Start, maybe initialize dp array of size target+1, dp[0]=1. For each num in nums: for i from num to target: dp[i] += dp[i-num]. Then output dp[target]. End.\n\nWe'll produce steps line by line with explanations. Use arrow →, Decision if needed. No actual code, just virtual. Let's output.\n\nWe need to obey format: each line: virtual step + space + // explanation.\n\nInclude Start, End, Decision if needed.\n\nNo actual loops syntax, just conceptual.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 建立長度為 target+1 的 dp 陣列，所有值初始化為 0 // 用於儲存到達各個子目標的組合數\n→ Step 2: 設定 dp[0] = 1 // 只有一種方式達到目標 0，即不選任何數字\n→ Step 3: 依序遍歷陣列 nums 中的每個數字 num // 外層循環\n    → Step 3.1: 對於每個 num，從 num 到 target 逐一更新 dp[i] // 內層循環\n        → Step 3.1.1: dp[i] = dp[i] + dp[i - num] // 加上使用 num 所能達到的組合數\n→ Step 4: 回傳 dp[target] // 結果為目標值可達成的所有組合數\nEnd // 程式執行結束\n\nEnsure each line has arrow maybe not needed for inner lines? But each line separate. Use → for steps. For nested steps use indentation but maintain arrow. Could also use No arrows for inside? Format example had nested steps indented under Decision. We'll mimic.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立長度為 target+1 的 dp 陣列，所有值初始化為 0 // 用於儲存到達各個子目標的組合數  \n→ Step 2: 設定 dp[0] = 1 // 只有一種方式達到目標 0，即不選任何數字  \n→ Step 3: 依序遍歷陣列 nums 中的每個數字 num // 外層循環  \n    → Step 3.1: 對於每個 num，從 num 到 target 逐一更新 dp[i] // 內層循環  \n        → Step 3.1.1: dp[i] = dp[i] + dp[i - num] // 加上使用 num 所能達到的組合數  \n→ Step 4: 回傳 dp[target] // 結果為目標值可達成的所有組合數  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[4,5]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[4, 5]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,8,2]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 8, 2]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\ndef rand7():\n    # 假設這裡是題目提供的 API\n    return random.randint(1, 7)\n\ndef rand10():\n    while True:\n        num = (rand7() - 1) * 7 + rand7()  # 1~49\n        if num <= 40:\n            return 1 + (num - 1) % 10\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析出 n\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n    results = [rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for rand10 using rand7. Classic method: use two rand7 to create 49 outcomes. Map 1-40 to 1-10, reject 41-49. So loop until result. Provide step-by-step pseudocode with arrows, decision. Also mention the random number generation. Each line should be \"虛擬碼步驟 // 解釋\". Use Chinese. Format. Use Start End. Use decision lines. Provide each step.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 產生 rand7() 的結果 x // 從 rand7() 取得第一個隨機數\n→ Step 2: 產生 rand7() 的結果 y // 產生第二個隨機數\n→ Step 3: 計算 idx = (x - 1) * 7 + y // 將兩個數映射到 1-49 的序號\n→ Decision: 如果 idx ≤ 40? // 檢查是否在可接受範圍內\n    Yes → Step 4: 產生 rand10() 結果 = ((idx - 1) mod 10) + 1 // 轉換為 1-10\n    No  → Step 5: 重新執行 Step 1-3 // 重新嘗試，丟棄 41-49\nEnd // rand10() 執行結束\n\nBut we also need to loop until result. So incorporate loop: maybe use While True. Use Decision to exit. Provide steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 產生 rand7() 的結果 x // 取得第一個隨機數（1~7）  \n→ Step 2: 產生 rand7() 的結果 y // 取得第二個隨機數（1~7）  \n→ Step 3: 計算 idx = (x - 1) * 7 + y // 將兩個數映射為 1~49 的序號  \n→ Decision: 如果 idx ≤ 40? // 檢查是否在可接受範圍內（1~40）  \n  Yes → Step 4: 產生 rand10() 結果 = ((idx - 1) mod 10) + 1 // 轉換為 1~10，並返回  \n  No  → Step 5: 重複 Step 1-3 // idx 為 41~49，丟棄並重新嘗試  \nEnd // rand10() 執行結束"
    },
    {
      "title": "ZigZag Conversion",
      "source_file": "Leetcode/leetcode6.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmps8xkrgm9.py\", line 57, in <module>\n    main()\n  File \"/tmp/tmps8xkrgm9.py\", line 50, in main\n    numRows = int(tokens[1]) if len(tokens) > 1 else 1\n              ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        }
      ],
      "generated_code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        \"\"\"將字串 s 按 zig‑zag 方式排列，並逐行讀取回傳結果。\"\"\"\n        # 如果只有一行或行數超過字串長度，直接回傳原字串\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        # 建立各行的字串\n        rows = [''] * numRows\n        index, step = 0, 1  # index 為目前所在行，step 為方向\n\n        for c in s:\n            rows[index] += c  # 將字元放入對應行\n            if index == 0:          # 到第一行，改為往下走\n                step = 1\n            elif index == numRows - 1:  # 到最後一行，改為往上走\n                step = -1\n            index += step  # 移動到下一行\n\n        # 把所有行連接成最終結果\n        return ''.join(rows)\n\n\ndef main():\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試以換行分隔，若不符合再使用空白/逗號分隔\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        s_line = lines[0].strip()\n        n_line = lines[1].strip()\n        s = s_line.strip('\\'\"')\n        try:\n            numRows = int(n_line)\n        except ValueError:\n            # 可能是「s = 'xxx', numRows = 3」的格式\n            parts = n_line.replace(',', ' ').split()\n            if parts and parts[-1].isdigit():\n                numRows = int(parts[-1])\n            else:\n                numRows = 1\n    else:\n        # 以空白或逗號分隔，預期格式為「xxx 3」或「xxx,3」\n        tokens = data.replace(',', ' ').split()\n        s = tokens[0].strip('\\'\"')\n        numRows = int(tokens[1]) if len(tokens) > 1 else 1\n\n    sol = Solution()\n    print(sol.convert(s, numRows))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for converting a string to zigzag pattern and reading line by line. It's a typical LeetCode problem: ZigZag Conversion. We need to produce step-by-step pseudo code. Must not output actual code, just virtual code with arrows. Each line: virtual step + // explanation. Use Start, End, Decision, etc. The user wants conversion of string to zigzag pattern and read line by line. So algorithm: given string s and numRows, if numRows==1 or >len(s) then return s. Else, create array of strings for rows. Iterate over s with index i, compute row = i % cycleLen. But in zigzag, when row >= numRows, row = cycleLen - row. Append char to row string. After iteration, join rows. Return result. That's typical.\n\nWe need to output lines of virtual code.\n\nLet's think of step-by-step:\n\nStart\n→ Step 1: Receive input string s and integer numRows\n→ Decision: 如果 numRows <= 1 或 numRows >= s.length? \n   Yes → Step 2: 返回 s // 若只有一行或行数大于字符串长度，直接返回原字符串\n   No → Step 3: 計算 cycleLen = 2*numRows - 2 // 每個完整周期的長度\n→ Step 4: 建立 rows = 空陣列，長度 numRows // 用於存放每行字元\n→ Step 5: 初始化 currentRow = 0 // 當前所在行\n→ Step 6: 初始化 direction = -1 // 方向，-1 表示往上走，1 表示往下走\n→ Decision: 迭代每個字元 ch in s?\n   Yes → Step 7: rows[currentRow] 加上 ch // 將字元放入對應行\n   → Step 8: 如果 currentRow == 0 或 currentRow == numRows-1 → direction = -direction // 轉換方向\n   → Step 9: currentRow += direction // 移動到下一行\n   No → Step 10: 結合所有 rows 為 result // 把各行字串連接起來\n→ End\n\nBut we might want to use decision for cycle calculation? Let's incorporate step 3 with decision.\n\nBut the algorithm above uses direction and toggles at first/last row. That's an alternative to using cycleLen. Either is fine. We'll produce virtual code accordingly.\n\nBetter to maintain consistency: use row calculation with cycleLen; simpler.\n\nWe can produce steps:\n\nStart\n→ Step 1: 接收字串 s 和行數 numRows\n→ Decision: 如果 numRows <= 1 或 numRows >= s.length? \n   Yes → Step 2: 回傳 s // 直接回傳原字串\n   No → Step 3: 計算 cycleLen = 2*numRows - 2 // 斜向周期長度\n→ Step 4: 建立 rows = 空陣列長度 numRows\n→ Step 5: for i in 0..s.length-1:\n   → Step 6: row = i % cycleLen\n   → Decision: 如果 row >= numRows? \n       Yes → Step 7: row = cycleLen - row // 反轉行號\n       No → Step 7: row = row\n   → Step 8: rows[row] 加上 s[i] // 將字元加入對應行\n→ Step 9: result = 空字串\n→ Decision: 對於每一行 r in rows:\n   Yes → Step 10: result += r // 合併行\n   No → Step 10: result = result\n→ End\n\nBut the Decision for for loop is not typical; maybe we can just do step 9: concatenate rows.\n\nLet's produce final output with proper structure:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s 與行數 numRows // 取得需要轉換的字串與行數\n→ Decision: 如果 numRows <= 1 或 numRows >= s.length? // 檢查是否需要特殊處理\n    Yes → Step 2: 回傳 s // 只有一行或行數超過字串長度時，直接回傳原字串\n    No  → Step 3: 計算 cycleLen = 2*numRows - 2 // 一個完整 ZigZag 周期的長度\n→ Step 4: 建立 rows = 空陣列，長度 numRows // 用來存放每一行的字元\n→ Step 5: 對於 i 從 0 到 s.length-1:\n    → Step 6: row = i % cycleLen // 先取得在周期內的偏移\n    → Decision: 如果 row >= numRows? // 判斷是否已經超過最後一行\n        Yes → Step 7: row = cycleLen - row // 反向計算對應行號\n        No  → Step 7: row = row // 保持原行號\n    → Step 8: rows[row] 加上 s[i] // 將字元放入對應行\n→ Step 9: result = 空字串 // 用於儲存最終的讀取結果\n→ Step 10: 對於每一行 r in rows:\n    → Step 11: result += r // 把各行連接成一個字串\n→ End // 程式執行結束\n\nMake sure each line has \"虛擬碼步驟 [空格] // 解釋\".\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s 與行數 numRows // 取得需要轉換的字串與行數\n→ Decision: 如果 numRows <= 1 或 numRows >= s.length? // 檢查是否需要特殊處理\n    Yes → Step 2: 回傳 s // 只有一行或行數超過字串長度時，直接回傳原字串\n    No  → Step 3: 計算 cycleLen = 2*numRows - 2 // 一個完整 ZigZag 周期的長度\n→ Step 4: 建立 rows = 空陣列，長度 numRows // 用來存放每一行的字元\n→ Step 5: 對於 i 從 0 到 s.length-1:\n    → Step 6: row = i % cycleLen // 先取得在周期內的偏移\n    → Decision: 如果 row >= numRows? // 判斷是否已經超過最後一行\n        Yes → Step 7: row = cycleLen - row // 反向計算對應行號\n        No  → Step 7: row = row // 保持原行號\n    → Step 8: rows[row] 加上 s[i] // 將字元放入對應行\n→ Step 9: result = 空字串 // 用於儲存最終的讀取結果\n→ Step 10: 對於每一行 r in rows:\n    → Step 11: result += r // 把各行連接成一個字串\n→ End // 程式執行結束\n\nWe need to ensure the indent. But the format may not require indent. But the example uses indent for nested steps. We'll replicate style.\n\nOk produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入字串 s 與行數 numRows // 取得需要轉換的字串與行數\n→ Decision: 如果 numRows <= 1 或 numRows >= s.length? // 檢查是否需要特殊處理\n    Yes → Step 2: 回傳 s // 只有一行或行數超過字串長度時，直接回傳原字串\n    No  → Step 3: 計算 cycleLen = 2*numRows - 2 // 一個完整 ZigZag 周期的長度\n→ Step 4: 建立 rows = 空陣列，長度 numRows // 用來存放每一行的字元\n→ Step 5: 對於 i 從 0 到 s.length-1:\n    → Step 6: row = i % cycleLen // 先取得在周期內的偏移\n    → Decision: 如果 row >= numRows? // 判斷是否已經超過最後一行\n        Yes → Step 7: row = cycleLen - row // 反向計算對應行號\n        No  → Step 7: row = row // 保持原行號\n    → Step 8: rows[row] 加上 s[i] // 將字元放入對應行\n→ Step 9: result = 空字串 // 用於儲存最終的讀取結果\n→ Step 10: 對於每一行 r in rows:\n    → Step 11: result += r // 把各行連接成一個字串\n→ End // 程式執行結束\n```"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        current = sum(i * num for i, num in enumerate(nums))\n        max_val = current\n        for i in range(n - 1):\n            # Update rotation function value using the derived formula\n            current += total - n * nums[i]\n            if current > max_val:\n                max_val = current\n        return max_val\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n    # Extract the list of numbers from the input string\n    match = re.search(r'\\[(.*?)\\]', data, re.S)\n    if match:\n        nums_str = '[' + match.group(1) + ']'\n        nums = ast.literal_eval(nums_str)\n    else:\n        nums = []\n\n    # Compute and output the maximum rotation function value\n    result = Solution().maxRotateFunction(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for Leetcode problem \"Maximum Rotation Function\". We must give step-by-step pseudocode with explanations. The virtual code should be structured with Start, Decision, etc. We must not output real code. Just steps.\n\nWe must include the logic: compute sum of array, initial F(0), then iterate to compute next rotation values efficiently using formula F(k+1) = F(k) + sum - n*arr[k]. Return max.\n\nSo we need to produce virtual code with steps like: Start, compute sum, compute current rotation value, initialize max, loop for i from 0 to n-2, update current, update max, end loop, End.\n\nAlso we should include decision for n=0? But array length n. Typically at least 1. Could add Decision: If n==0? but not needed.\n\nOk produce:\n\nStart // program start\n\n→ Step 1: Initialize n ← length(nums) // get array length\n\n→ Step 2: Compute totalSum ← sum of all nums elements // used for rotation updates\n\n→ Decision: If n == 0? // optional\n\n    Yes → Step 3: Return 0 // no elements, rotation function is 0\n\n    No  → Continue\n\n→ Step 4: Compute current ← sum(i * nums[i]) for i=0..n-1 // F(0)\n\n→ Step 5: Initialize maxVal ← current // store maximum so far\n\n→ Step 6: For i from 0 to n-2 // iterate over rotations except last one\n\n    → Step 7: current ← current + totalSum - n * nums[i] // compute F(i+1) from F(i)\n\n    → Decision: If current > maxVal? // update maximum\n\n        Yes → Step 8: maxVal ← current\n\n        No  → No change\n\n→ Step 9: Return maxVal // maximum rotation function\n\nEnd // program ends\n\nWe also need to include arrow \"→\" lines and decisions inside indentation.\n\nMake sure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取出陣列長度 n ← length(nums) // 獲取 nums 的長度  \n→ Step 2: 計算總和 totalSum ← sum(nums[0] … nums[n-1]) // 用於快速更新旋轉函數  \n→ Decision: 如果 n = 0? // 空陣列情況  \n  Yes → Step 3: 回傳 0 // 無元素時旋轉函數為 0  \n  No → 繼續  \n→ Step 4: 計算初始旋轉函數 current ← Σ(i * nums[i]) for i = 0 … n-1 // F(0)  \n→ Step 5: 設定最大值 maxVal ← current // 目前已知的最大旋轉值  \n→ Step 6: 進入迴圈 i 從 0 到 n-2 // 逐個計算剩餘的 n-1 個旋轉  \n  → Step 7: 更新 current ← current + totalSum - n * nums[i] // 用公式得到 F(i+1)  \n  → Decision: 如果 current > maxVal? // 判斷是否為新最大值  \n   Yes → Step 8: maxVal ← current // 更新最大值  \n   No → 不改變 maxVal  \n→ Step 9: 回傳 maxVal // 最終最大旋轉函數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      '[\"1+2+3\", \"1*2*3\"]'"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      '[\"2+3*2\", \"2*3+2\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # Skip numbers with leading zeros\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    # First number, no operator\n                    backtrack(i, temp, curr, curr)\n                else:\n                    # Add '+'\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    # Add '-'\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    # Add '*', need to adjust for previous operand\n                    backtrack(i, path + '*' + temp,\n                              value - last + last * curr,\n                              last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    # Extract num and target from input like: num = \"123\", target = 6\n    match = re.search(r'num\\s*=\\s*\"(?P<num>\\d+)\"\\s*,\\s*target\\s*=\\s*(?P<target>-?\\d+)', data)\n    if match:\n        num_str = match.group('num')\n        target_val = int(match.group('target'))\n    else:\n        # Fallback: try to parse numbers from the text\n        num_str = \"\"\n        target_val = 0\n        for part in data.replace(\"\\n\", \" \").split(\",\"):\n            part = part.strip()\n            if part.startswith(\"num\"):\n                num_str = re.search(r'\"([^\"]*)\"', part).group(1)\n            elif part.startswith(\"target\"):\n                target_val = int(part.split(\"=\")[1].strip())\n\n    solution = Solution()\n    result = solution.addOperators(num_str, target_val)\n\n    # Output as JSON array to match the expected format\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm. This is essentially the \"Expression Add Operators\" problem from Leetcode. Need to produce pseudo steps line by line with explanations.\n\nWe need to output each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows and structure: Start, End, Decision, Yes →, No →.\n\nWe need to show a recursive backtracking approach: iterate over splits, skip leading zeros, for each operator call recursion with updated current value and last operand to handle multiplication. At top level, start with first number as initial operand.\n\nPseudo code: Start → Step: Initialize result list → Step: Define recursive function DFS(index, expr, currVal, lastOperand) → Decision: if index==len(num) → if currVal==target → add expr to result → return → else → return. For i from index to len(num)-1: substring = num[index:i+1]; if length > 1 and substring startswith '0' → break; val = int(substring); if index==0 → DFS(i+1, substring, val, val); else → DFS(i+1, expr+'+'+substring, currVal+val, val); → DFS(i+1, expr+'-'+substring, currVal-val, -val); → DFS(i+1, expr+'*'+substring, currVal - lastOperand + lastOperand*val, lastOperand*val); After recursion, return result.\n\nAlso include explanation lines.\n\nWe need to ensure each line uses \"虛擬碼步驟 // 解釋\". Use arrow \"→\" for steps, \"Decision:\" for decision, \"Yes →\" and \"No →\".\n\nLet's craft lines.\n\nStart // 程式開始執行\n→ Initialize result list to store valid expressions // 用來儲存符合目標值的表達式\n→ 定義遞迴函式 DFS(index, expr, currVal, lastOperand) // index: 下次分割起始位置，expr: 已組成的表達式，currVal: 當前計算結果，lastOperand: 上一步運算的數字，用於乘法調整\n    → Decision: index == len(num)? // 判斷是否已處理完所有數字\n        Yes → Decision: currVal == target? // 檢查是否符合目標值\n            Yes → Append expr to result // 成功的表達式加入結果\n            No  → // 不符合目標，返回\n        No  → // 尚未處理完所有數字，繼續切割\n    → For i from index to len(num)-1: // 嘗試所有可能的子串作為下一個操作數\n        → Substring = num[index:i+1] // 取子串\n        → Decision: substring has leading zero and length > 1? // 檢查是否為非法前導零\n            Yes → Break // 跳過後續更長的子串，因為更長也會以0開頭\n            No  → // 合法子串\n        → val = int(substring) // 轉成整數\n        → Decision: index == 0? // 是否為第一個操作數\n            Yes → DFS(i+1, substring, val, val) // 第一個數字直接作為初始值\n            No  → // 後續數字可選擇 + - *\n                → DFS(i+1, expr + '+' + substring, currVal + val, val) // 加法\n                → DFS(i+1, expr + '-' + substring, currVal - val, -val) // 減法\n                → DFS(i+1, expr + '*' + substring, currVal - lastOperand + lastOperand * val, lastOperand * val) // 乘法，需先撤回上一操作數再加上乘積\nEnd // 程式執行結束\n\nNeed to ensure each line ends with comment after // . Provide concise explanation. Also include the Start and End lines. Use arrow at each step: \"→ Step\". In the decision block, show indent? The example uses indentation lines for Decision, Yes→ etc. We can replicate similar structure. Ensure we include \"Decision:\" lines and Yes → etc. Provide them as separate lines. Let's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize result list to store valid expressions // 用來儲存符合目標值的表達式  \n\n→ Define recursive function DFS(index, expr, currVal, lastOperand) // index：下一個分割起始位置；expr：已組成的表達式；currVal：目前計算結果；lastOperand：上一步運算的數字，用於乘法調整  \n\n    → Decision: index == len(num)? // 判斷是否已處理完所有數字  \n        Yes → Decision: currVal == target? // 檢查是否符合目標值  \n            Yes → Append expr to result // 成功的表達式加入結果  \n            No  → // 不符合目標，返回  \n        No  → // 尚未處理完所有數字，繼續切割  \n\n    → For i from index to len(num)-1: // 嘗試所有可能的子串作為下一個操作數  \n        → Substring = num[index:i+1] // 取子串  \n        → Decision: substring has leading zero and length > 1? // 檢查是否為非法前導零  \n            Yes → Break // 跳過更長的子串，因為更長也會以 0 開頭  \n            No  → // 合法子串  \n        → val = int(substring) // 轉成整數  \n        → Decision: index == 0? // 是否為第一個操作數  \n            Yes → DFS(i+1, substring, val, val) // 第一個數字直接作為初始值  \n            No  → // 後續數字可選擇 + - *  \n                → DFS(i+1, expr + '+' + substring, currVal + val, val) // 加法  \n                → DFS(i+1, expr + '-' + substring, currVal - val, -val) // 減法  \n                → DFS(i+1, expr + '*' + substring, currVal - lastOperand + lastOperand * val, lastOperand * val) // 乘法，需先撤回上一操作數再加上乘積  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def wiggleSort(self, nums):\n        # 一次遍歷，根據奇偶位置交換，使得 nums[0] < nums[1] > nums[2] < ...\n        n = len(nums)\n        for i in range(n - 1):\n            if i % 2 == 0:          # 偶數位置需要 < 下個元素\n                if nums[i] >= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n            else:                   # 奇數位置需要 > 下個元素\n                if nums[i] <= nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 找出第一個方括號中的列表字串\n    match = re.search(r'\\[.*\\]', raw_input)\n    if not match:\n        print(\"[]\")\n        sys.exit(0)\n\n    # 使用 ast.literal_eval 解析成 Python 列表\n    nums = ast.literal_eval(match.group(0))\n\n    # 執行 wiggle sort\n    Solution().wiggleSort(nums)\n\n    # 輸出結果\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The problem: Given array, reorder to wiggle: nums[0] < nums[1] > nums[2] < nums[3] ... There is known solution: Iterate over array, for each i, if i%2==0 and nums[i] >= nums[i+1] swap; if i%2==1 and nums[i] <= nums[i+1] swap. That ensures wiggle property.\n\nWe produce steps accordingly. Each line with arrow. Use Start, End, Decision etc.\n\nWe need to output each line with \"虛擬碼步驟 [space] // 解釋\".\n\nWe must not output actual code, just steps.\n\nLet's structure:\n\nStart\n\n→ Step 1: Initialize index i = 0 // start at first element\n\n→ Decision: 是否 i < len(nums)-1? // check if not reached end\n\n    Yes → Step 2: 如果 i 為偶數? // determine parity\n\n        Yes → Decision: 如果 nums[i] >= nums[i+1]? // check condition\n\n            Yes → Step 3: 交換 nums[i] 與 nums[i+1] // swap to satisfy <\n\n            No → // nothing\n\n        No → Decision: 如果 nums[i] <= nums[i+1]? // for odd indices\n\n            Yes → Step 4: 交換 nums[i] 與 nums[i+1] // swap to satisfy >\n\n            No → // nothing\n\n    No → // end loop\n\n→ Step 5: i = i + 1 // move to next index\n\n→ Step 6: Go back to Decision (loop) // repeat\n\nEnd\n\nNeed to ensure proper indentation and arrow formatting.\n\nWe should use \"Yes →\" and \"No →\". Also use \"Decision:\".\n\nMake sure each line ends with comment. Use simplified.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化索引，從第一個元素開始\n→ Decision: i < len(nums)-1? // 檢查是否已到陣列結尾\n    Yes → Step 2: i % 2 == 0? // 判斷索引是偶數還是奇數\n        Yes → Decision: nums[i] >= nums[i+1]? // 偶數位置需滿足 nums[i] < nums[i+1]\n            Yes → Step 3: swap(nums[i], nums[i+1]) // 交換以符合 '<' 條件\n            No  → // 已符合，無需操作\n        No → Decision: nums[i] <= nums[i+1]? // 奇數位置需滿足 nums[i] > nums[i+1]\n            Yes → Step 4: swap(nums[i], nums[i+1]) // 交換以符合 '>' 條件\n            No  → // 已符合，無需操作\n    No  → // 迴圈結束，已處理完所有相鄰對\n→ Step 5: i ← i + 1 // 移動到下一個索引\n→ Step 6: Go back to Decision // 重新檢查條件，繼續迴圈\nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpngbdwwq4.py\", line 33, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0262ub4s.py\", line 33, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqugevlji.py\", line 33, in <module>\n    exec(data, {}, namespace)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\ndef calc_equation(equations, values, queries):\n    graph = defaultdict(dict)\n    for (a, b), val in zip(equations, values):\n        graph[a][b] = val\n        graph[b][a] = 1 / val\n\n    def dfs(src, dst, visited):\n        if src not in graph or dst not in graph:\n            return -1.0\n        if src == dst:\n            return 1.0\n        visited.add(src)\n        for neighbor, weight in graph[src].items():\n            if neighbor not in visited:\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n        return -1.0\n\n    res = []\n    for u, v in queries:\n        res.append(dfs(u, v, set()))\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    namespace = {}\n    exec(data, {}, namespace)\n    equations = namespace.get('equations', [])\n    values = namespace.get('values', [])\n    queries = namespace.get('queries', [])\n    results = calc_equation(equations, values, queries)\n    formatted = '[' + ','.join(f\"{x:.5f}\" for x in results) + ']'\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode) for solving this problem: evaluate division queries using equations given as variable pairs with values. Essentially graph weighted edges. We need to output virtual code line by line with comments. Use Start, Decision, End, arrows, etc.\n\nWe need to produce step-by-step algorithm: Build adjacency map, DFS/BFS for each query, return -1.0 if no path.\n\nWe need to ensure each line is a virtual code step with explanation. Use arrow → to go into next step. Use Decision: if... Yes → ... No → ... etc.\n\nWe need to cover building graph, processing queries, DFS function, etc.\n\nWe should keep it simple but cover key logic.\n\nLet's craft:\n\nStart\n\n→ Step 1: 建立鄰接圖 adj // 初始化 graph\n\n→ Step 2: For each equation i\n\n    → Decision: 如果 Ai 不在 adj? // 檢查是否已建立節點\n\n        Yes → Step 3: adj[Ai] = [] // 創建空陣列\n\n        No  → ...\n\n    → Decision: 如果 Bi 不在 adj? // 同上\n\n        Yes → Step 4: adj[Bi] = []\n\n        No  → ...\n\n    → Step 5: adj[Ai].append( (Bi, values[i]) ) // 加入 Ai → Bi\n\n    → Step 6: adj[Bi].append( (Ai, 1/values[i]) ) // 加入 Bi → Ai\n\nEnd // 完成圖\n\nStart // 開始處理查詢\n\n→ Step 7: 初始化答案列表 result\n\n→ Step 8: For each query j\n\n    → Step 9: C, D = queries[j] // 取查詢變量\n\n    → Decision: 如果 C 或 D 不在 adj? // 檢查是否定義\n\n        Yes → Step 10: result.append(-1.0) // 未定義，答案為 -1\n\n        No  → Step 11: result.append(DFS(C, D, adj)) // 進行 DFS\n\n→ End // 返回結果\n\nNow define DFS function:\n\nStart // DFS 定義\n\n→ Step 12: DFS(node, target, adj, visited) // 參數\n\n    → Decision: 如果 node == target? // 找到目標\n\n        Yes → Step 13: return 1.0 // 同一個變量\n\n        No  → Step 14: visited.add(node) // 標記已訪問\n\n        → For each neighbor, weight in adj[node] // 遍歷鄰居\n\n            → Decision: 如果 neighbor 已在 visited? // 避免循環\n\n                Yes → Step 15: continue\n\n                No  → Step 16: partial = DFS(neighbor, target, adj, visited) // 递归\n\n                → Decision: 如果 partial != -1.0? // 目標在子樹\n\n                    Yes → Step 17: return weight * partial // 乘以權重\n\n                    No  → Step 18: continue\n\n        → Step 19: return -1.0 // 沒有路徑\n\nEnd\n\nBut we need to keep each line as \"虛擬碼步驟 // 解釋\". We should ensure arrow style: \"→\" before each step.\n\nUse indentation with arrow? Use \"→\" to go deeper? The example shows indentation.\n\nWe can produce as:\n\nStart // 程式開始執行\n→ Step 1: 初始化鄰接圖 adj // 建立圖結構\n→ Step 2: 遍歷每條方程 i // 準備處理所有方程\n    → Decision: 如果 Ai 尚未在 adj? // 檢查是否已存在節點\n        Yes → Step 3: adj[Ai] = [] // 創建 Ai 節點\n        No  → // Ai 已存在，跳過\n    → Decision: 如果 Bi 尚未在 adj? // 同樣處理 Bi\n        Yes → Step 4: adj[Bi] = [] // 創建 Bi 節點\n        No  → // Bi 已存在\n    → Step 5: adj[Ai].append( (Bi, values[i]) ) // Ai → Bi 乘數\n    → Step 6: adj[Bi].append( (Ai, 1/values[i]) ) // Bi → Ai 乘數\nEnd // 建立完成\n\nStart // 處理查詢\n→ Step 7: result = [] // 儲存答案\n→ Step 8: 遍歷每個查詢 j\n    → Step 9: C, D = queries[j] // 取查詢對\n    → Decision: 若 C 或 D 不在 adj? // 變量未定義\n        Yes → Step 10: result.append(-1.0) // 回傳 -1\n        No  → Step 11: result.append(DFS(C, D, adj, set())) // 執行 DFS\n→ End // 回傳結果\n\n// 定義 DFS 函式\nStart // DFS\n→ Step 12: DFS(node, target, adj, visited) // 參數\n    → Decision: node == target? // 是否達到目標\n        Yes → Step 13: return 1.0 // 同一變量\n        No  → Step 14: visited.add(node) // 標記已訪問\n        → For each neighbor, weight in adj[node]\n            → Decision: neighbor in visited? // 避免循環\n                Yes → Step 15: continue\n                No  → Step 16: sub = DFS(neighbor, target, adj, visited) // 递归\n                → Decision: sub != -1.0? // 目標存在\n                    Yes → Step 17: return weight * sub // 乘以路徑權重\n                    No  → Step 18: continue\n        → Step 19: return -1.0 // 無路徑\nEnd\n\nBut we need to format exactly as requirement: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\" before each step. Use indentation lines as in example.\n\nWe should avoid extra lines like \"End\" inside function? In example, they used \"End\" after entire algorithm. For DFS function, we can include Start/End as well.\n\nLet's produce final answer accordingly.\n\nEnsure not to output real code. Use virtual code steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化鄰接圖 adj // 建立一個空的圖結構，用來存放變數間的除法關係  \n→ Step 2: 遍歷每條方程 i // 逐一處理給定的除法方程  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 Ai 尚未在 adj? // 檢查 Ai 是否已存在於圖中  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: adj[Ai] = [] // 創建 Ai 節點的鄰接列表  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // Ai 已存在，無需重複創建  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 Bi 尚未在 adj? // 同樣處理 Bi  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: adj[Bi] = [] // 創建 Bi 節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // Bi 已存在  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: adj[Ai].append( (Bi, values[i]) ) // 把 Ai → Bi 的乘數加入圖  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: adj[Bi].append( (Ai, 1/values[i]) ) // 把 Bi → Ai 的乘數加入圖  \nEnd // 圖建立完成  \n\nStart // 處理所有查詢  \n→ Step 7: result = [] // 用於儲存每個查詢的答案  \n→ Step 8: 遍歷每個查詢 j // 對每一個 [Cj, Dj] 做處理  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 9: C, D = queries[j] // 取出查詢的兩個變數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 若 C 或 D 不在 adj? // 變數未在圖中，答案不確定  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 10: result.append(-1.0) // 回傳 -1.0  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 11: result.append(DFS(C, D, adj, set())) // 執行 DFS 求值  \n→ End // 所有查詢處理完畢，返回結果列表  \n\n// 定義 DFS（深度優先搜尋）函式  \nStart // DFS  \n→ Step 12: DFS(node, target, adj, visited) // 參數: 當前節點、目標節點、圖、已訪問集合  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: node == target? // 是否已達到目標節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 13: return 1.0 // 相同變數的除法為 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 14: visited.add(node) // 標記已訪問  \n&nbsp;&nbsp;&nbsp;&nbsp;→ For each neighbor, weight in adj[node] // 遍歷當前節點的所有鄰居  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: neighbor in visited? // 避免循環  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 15: continue // 跳過已訪問的鄰居  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 16: sub = DFS(neighbor, target, adj, visited) // 递归搜尋子樹  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: sub != -1.0? // 子樹中找到目標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 17: return weight * sub // 乘以當前邊的權重  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 18: continue // 該路徑無效，繼續尋找  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 19: return -1.0 // 所有路徑都無法到達目標  \nEnd // DFS 定義完畢\n\nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef can_form(word, word_set):\n    \"\"\"判斷 word 能否由 word_set 內的字串組成（至少兩個）\"\"\"\n    if not word_set:\n        return False\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True  # 空前綴永遠是合法的\n    for i in range(1, n + 1):\n        for j in range(0, i):\n            if dp[j] and word[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[n]\n\ndef find_all_concatenated_words(words):\n    \"\"\"找出所有可由其他單字組合而成的字串\"\"\"\n    words.sort(key=len)          # 先按長度升序\n    word_set = set()\n    result = []\n\n    for w in words:\n        if w == \"\":\n            continue\n        if can_form(w, word_set):\n            result.append(w)\n        word_set.add(w)          # 把現在的字加入集合，供後面單字使用\n    return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中擷取 list 表達式\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n    try:\n        words = ast.literal_eval(list_part)\n    except Exception:\n        words = []\n\n    res = find_all_concatenated_words(words)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find concatenated words in list. We should describe steps line by line with arrow etc. So produce virtual code steps.\n\nNeed to be detailed: Start, build trie maybe, or use hash set, then for each word use DP to check if can be formed by other words. Exclude itself. Outline: Sort words by length, for each word, run DP, using set of words seen earlier. Add word to set after check. Then at end collect result.\n\nLet's produce virtual code steps:\n\nStart\n→ Sort words by length ascending // easier to ensure smaller words available\n→ Initialize WordSet empty // set to store words processed so far\n→ Initialize Result empty list // store concatenated words\n→ For each Word in sorted words // iterate\n    → Decision: If Word can be formed by concatenation of at least two words in WordSet? // use helper function\n        Yes → Add Word to Result // found concatenated\n    → Add Word to WordSet // now available for future checks\nEnd\n\nHelper function steps:\n\n→ Function CanForm(Word, WordSet)\n    → Initialize DP array of length Word.length+1, DP[0] = true // empty prefix is valid\n    → For i from 1 to Word.length\n        → For j from 0 to i-1\n            → Decision: If DP[j] is true AND substring(j,i) in WordSet? // check piece\n                Yes → DP[i] = true; break // found split\n    → Decision: If DP[Word.length] is true AND Word contains at least two pieces? // ensure at least two words\n        Yes → Return true\n        No  → Return false\n\nBut the DP alone ensures at least one word? Actually DP[Word.length] true may be true if word itself in set. But we will exclude self because we check before adding to set. So it's fine. But still need at least two pieces, but if word itself not in set, DP would need at least one split. But if word itself is in set, we wouldn't consider. But after we add word to set after check, so not present. So we can simply check DP[end]. That ensures at least one split. But to guarantee at least two words, we need that DP[end] true and we cannot use word itself. Since it's not in set, good.\n\nThus algorithm works.\n\nLet's produce virtual code lines accordingly with arrows.\n\nMake sure each line has arrow '→' or 'Start', 'End', 'Decision:'.\n\nWill format accordingly. Use Chinese comments. Use concise steps. We'll include loops and functions.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort words by length ascending // 先按長度升序排序，方便較短的字可以先被加入集合  \n→ Initialize WordSet = ∅ // 用於存放已經處理過且不重複的字  \n→ Initialize Result = ∅ // 用於收集所有被連接的字  \n\n→ For each Word in words // 逐字檢查  \n  Decision: Word 可否由 WordSet 中至少兩個字連接而成? // 呼叫判斷函式  \n   Yes → Add Word to Result // 若能形成，加入結果集合  \n  Add Word to WordSet // 無論能否形成，都將此字加入集合，以供後續字使用  \n\nEnd // 程式執行結束  \n\n// ---------- 判斷函式：CanForm ---------------------------------  \n→ Function CanForm(Word, WordSet) // 判斷 Word 是否能由 WordSet 內的字組成  \n  Initialize DP[0..len(Word)] = false  \n  DP[0] = true // 空前綴始終可行  \n  For i from 1 to len(Word) // 遍歷所有可能的前綴長度  \n   For j from 0 to i-1 // 嘗試將前綴切分為兩部分  \n    Decision: DP[j] is true AND Word[j:i] in WordSet? // 前綴可行且後綴是已知字  \n     Yes → DP[i] = true; break // 找到一種有效分割，結束內層循環  \n  Decision: DP[len(Word)] is true // 前綴到整個字可被切分  \n   Yes → Return true // 能形成，至少有一個切分（因為 Word 本身不在 WordSet）  \n   No  → Return false // 無法形成  \n\n// 這樣的 DP 只需確保 Word 本身不在 WordSet，因為主程式在加入 Word 前已先檢查。  \n\nEnd Function\n\n--- 以上即為完整的虛擬碼流程說明。"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyylpq6fc.py\", line 100, in <module>\n    main()\n  File \"/tmp/tmpyylpq6fc.py\", line 75, in main\n    arguments = ast.literal_eval('[' + args_str + ']')\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\nimport json\n\nclass MyStack:\n    \"\"\"Stack implemented with two queues (deque).\"\"\"\n\n    def __init__(self):\n        # q1 holds the current stack elements\n        # q2 is a temporary queue used during pop/top\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"Push element onto the stack.\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int | None:\n        \"\"\"Remove the element on top of the stack and return it.\"\"\"\n        if not self.q1:\n            return None  # stack is empty\n\n        # Move elements except the last one to q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n\n        # The remaining element is the top of the stack\n        top_elem = self.q1.popleft()\n\n        # Swap the queues to prepare for the next operation\n        self.q1, self.q2 = self.q2, self.q1\n\n        return top_elem\n\n    def top(self) -> int | None:\n        \"\"\"Return the element on the top of the stack without removing it.\"\"\"\n        if not self.q1:\n            return None\n\n        # Move elements except the last one to q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n\n        # The remaining element is the top of the stack\n        top_elem = self.q1.popleft()\n        # Put it back into q2 to keep the stack unchanged\n        self.q2.append(top_elem)\n\n        # Swap the queues\n        self.q1, self.q2 = self.q2, self.q1\n\n        return top_elem\n\n    def empty(self) -> bool:\n        \"\"\"Return True if the stack is empty.\"\"\"\n        return not self.q1\n\n\ndef main() -> None:\n    # Read the entire input\n    raw_input = sys.stdin.read().strip()\n\n    # The input format is: Input [operations], [arguments]\n    pattern = r'Input\\s*\\[(.*?)\\],\\s*\\[(.*?)\\]'\n    match = re.search(pattern, raw_input, re.S)\n    if not match:\n        # If pattern not found, assume empty operations\n        operations = []\n        arguments = []\n    else:\n        ops_str, args_str = match.groups()\n        operations = ast.literal_eval('[' + ops_str + ']')\n        arguments = ast.literal_eval('[' + args_str + ']')\n\n    # Prepare result list\n    result = []\n\n    # Instantiate the stack\n    stack = MyStack()\n\n    # Execute each operation\n    for op, args in zip(operations, arguments):\n        if op == 'push':\n            stack.push(args[0])\n            result.append(None)\n        elif op == 'pop':\n            result.append(stack.pop())\n        elif op == 'top':\n            result.append(stack.top())\n        elif op == 'empty':\n            result.append(stack.empty())\n\n    # Output in JSON format to match the example (null, false)\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MyStack with two queues, supporting push, pop, top, empty. Use virtual code with arrows etc. We need each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Use Decision: etc. Provide step-by-step. Let's design algorithm: Use two queues q1 and q2. For push: enqueue to q1. For pop: move all elements except last from q1 to q2, then dequeue last from q1, swap q1 and q2. For top: similar but instead of removing, peek the last. For empty: check q1 empty.\n\nWe can design methods separately. Use pseudo steps for class, methods. Provide algorithm steps. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 宣告 MyStack 類別，內部維持兩個 queue: q1, q2 // 用兩個 queue 來實作 stack\n→ Step 2: 取得 q1, q2 的初始化空 queue // 初始化兩個空 queue\nEnd // MyStack 類別結構定義完成\n\nStart // push 方法開始\n→ Step 3: push(x) // 接收要加入 stack 的元素\n→ Step 4: Enqueue x 到 q1 的後端 // 只使用 queue 的 push\n→ End // push 完成\n\nStart // pop 方法開始\n→ Step 5: pop() // 需要移除並回傳 stack 的頂部元素\n→ Decision: 如果 q1 為空? // 判斷是否有元素可 pop\n    Yes → Step 6: Return null or error // 空 stack 時回傳 null 或錯誤訊息\n    No  → Step 7: 進行下列循環直到 q1 只剩最後一個元素\n        → Step 8: Dequeue front element e from q1\n        → Decision: q1 是否只剩 1 個元素? // 檢查剩餘數量\n            Yes → Step 9: Store e 為待回傳值\n            No  → Step 10: Enqueue e 到 q2 的後端 // 把非頂部元素移到 q2\n    → Step 11: Swap q1 與 q2 // q1 成為新的空 queue\n→ Step 12: Return 存儲的待回傳值 // 回傳原 stack 的頂部元素\nEnd // pop 完成\n\nStart // top 方法開始\n→ Step 13: top() // 需要回傳 stack 的頂部元素但不移除\n→ Decision: 如果 q1 為空? // 判斷是否有元素可取\n    Yes → Step 14: Return null or error // 空 stack 時回傳 null 或錯誤訊息\n    No  → Step 15: 進行下列循環直到 q1 只剩最後一個元素\n        → Step 16: Dequeue front element e from q1\n        → Decision: q1 是否只剩 1 個元素? // 檢查剩餘數量\n            Yes → Step 17: Store e 為待回傳值\n            No  → Step 18: Enqueue e 到 q2 的後端 // 把非頂部元素移到 q2\n    → Step 19: Enqueue 存儲的待回傳值 e 到 q2 的後端 // 把頂部元素也放回 q2\n    → Step 20: Swap q1 與 q2 // q1 再次成為空 queue\n→ Step 21: Return 存儲的待回傳值 // 回傳原 stack 的頂部元素\nEnd // top 完成\n\nStart // empty 方法開始\n→ Step 22: empty() // 判斷 stack 是否為空\n→ Decision: q1 是否為空? // 只檢查 q1\n    Yes → Step 23: Return true // 空 stack\n    No  → Step 24: Return false // 非空 stack\nEnd // empty 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphyxs142i.py\", line 34, in <module>\n    match = re.search(pattern, input_data, re.S)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 177, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 745, in compile\n    p = _parser.parse(p, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 979, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 862, in _parse\n    p = _parse_sub(source, state, sub_verbose, nested + 1)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 568, in _parse\n    raise source.error(\"unterminated character set\",\nre.error: unterminated character set at position 61"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuc3rsj70.py\", line 34, in <module>\n    match = re.search(pattern, input_data, re.S)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 177, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 745, in compile\n    p = _parser.parse(p, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 979, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 862, in _parse\n    p = _parse_sub(source, state, sub_verbose, nested + 1)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 568, in _parse\n    raise source.error(\"unterminated character set\",\nre.error: unterminated character set at position 61"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqlvybk_9.py\", line 34, in <module>\n    match = re.search(pattern, input_data, re.S)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 177, in search\n    return _compile(pattern, flags).search(string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/__init__.py\", line 307, in _compile\n    p = _compiler.compile(pattern, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_compiler.py\", line 745, in compile\n    p = _parser.parse(p, flags)\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 979, in parse\n    p = _parse_sub(source, state, flags & SRE_FLAG_VERBOSE, 0)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 862, in _parse\n    p = _parse_sub(source, state, sub_verbose, nested + 1)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 460, in _parse_sub\n    itemsappend(_parse(source, state, verbose, nested + 1,\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/re/_parser.py\", line 568, in _parse\n    raise source.error(\"unterminated character set\",\nre.error: unterminated character set at position 61"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    pattern = r'numCourses\\s*=\\s*(\\d+)\\s*,\\s*prerequisites\\s*=\\s*(\\[\\[.*\\]\\]|[])'\n    match = re.search(pattern, input_data, re.S)\n    if not match:\n        print([])\n        sys.exit(0)\n\n    num_courses = int(match.group(1))\n    prereq_str = match.group(2)\n    prerequisites = ast.literal_eval(prereq_str)\n\n    sol = Solution()\n    result = sol.findOrder(num_courses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for topological sort (Kahn's algorithm) or DFS. Provide line-by-line pseudocode with comments. Use \"Start\", \"Decision:\" etc. Provide \"虛擬碼步驟\" then comment.\n\nWe need to include steps: build adjacency list, indegree array, queue, process, if cycle return empty.\n\nWe'll produce stepwise.\n\nEnsure each line: \"Start // 程式開始執行\" etc.\n\nWe'll include comments after each line. Use arrow →.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\n\nLine2: → Step 1: 初始化圖與入度 // 建立空的鄰接表與入度計數器\n\nLine3: → For i in 0..numCourses-1: add empty list adjacency[i]; indegree[i] = 0 // 為每門課建立節點\n\nLine4: → For each pair [a,b] in prerequisites: adjacency[b].add(a); indegree[a]++ // 建立邊與更新入度\n\nLine5: → Step 2: 將入度為0的節點加入佇列 // 可即刻修課的課程\n\nLine6: → For i in 0..numCourses-1: if indegree[i]==0: queue.enqueue(i)\n\nLine7: → Step 3: 建立結果清單 // 存放修課順序\n\nLine8: → result = []\n\nLine9: → Decision: queue是否為空? // 檢查是否還有可修課程\n\nLine10: →     Yes → End // queue空，循環結束\n\nLine11: →     No → Step 4: 取出佇列首節點 cur = queue.dequeue(); // 取得下一門課\n\nLine12: → Step 5: 添加cur至結果 // 已修課\n\nLine13: → result.append(cur)\n\nLine14: → For each neighbor in adjacency[cur]: // 逐一處理其後續課程\n\nLine15: →     indegree[neighbor]-- // 入度減1\n\nLine16: →     If indegree[neighbor]==0: queue.enqueue(neighbor) // 入度為0時可修\n\nLine17: → 回到 Decision: queue是否為空? // 重複處理\n\nLine18: → Step 6: 判斷是否完成所有課程 // 檢查結果長度\n\nLine19: → If result.length == numCourses: return result // 有效順序\n\nLine20: → Else return [] // 無法完成，循環存在\n\nLine21: End // 程式執行結束\n\nBut need format: each line with \"→\" maybe. For decision indent? Use spaces? Provide structure as example.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化圖與入度 // 建立空的鄰接表與入度計數器\n→ For i in 0..numCourses-1: adjacency[i] = [] ; indegree[i] = 0 // 為每門課建立節點\n→ For each pair [a,b] in prerequisites: adjacency[b].add(a) ; indegree[a]++ // 建立邊與更新入度\n→ Step 2: 將入度為0的節點加入佇列 // 可即刻修課的課程\n→ For i in 0..numCourses-1: if indegree[i] == 0: queue.enqueue(i)\n→ Step 3: 建立結果清單 // 存放修課順序\n→ result = [] // 空清單\n→ Decision: queue是否為空? // 檢查是否還有可修課程\n    Yes → End // 佇列空，全部處理完畢\n    No  → Step 4: 取出佇列首節點 cur = queue.dequeue() // 取得下一門課\n→ Step 5: 添加cur至結果 // 已修課\n→ result.append(cur)\n→ For each neighbor in adjacency[cur]: // 逐一處理其後續課程\n    → indegree[neighbor]-- // 入度減1\n    → If indegree[neighbor] == 0: queue.enqueue(neighbor) // 入度為0時可修\n→ 回到 Decision: queue是否為空? // 重複處理\n→ Step 6: 判斷是否完成所有課程 // 檢查結果長度\n→ If result.length == numCourses: return result // 有效順序\n→ Else: return [] // 無法完成，循環存在\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.19122850699824512,-0.8598990831564941],[-0.06534485003344499,-0.09615348216156781],[0.11396961677012393,0.5130210957269662]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.19122850699824512, -0.8598990831564941], [-0.06534485003344499, -0.09615348216156781], [0.11396961677012393, 0.5130210957269662]]'"
        }
      ],
      "generated_code": "import json\nimport math\nimport random\nimport sys\n\nclass Solution:\n    \"\"\"在給定半徑和圓心座標的情況下，隨機生成圓內的點。\"\"\"\n\n    def __init__(self, radius, x_center, y_center):\n        \"\"\"初始化圓的半徑和圓心座標。\"\"\"\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        生成一個在圓內均勻分布的隨機點。\n\n        方法：\n        1. 隨機生成一個 0~1 的數字 u1，用於計算半徑 r'。\n           r' = sqrt(u1) * radius，這樣可以保證點在圓內的分布均勻。\n        2. 隨機生成一個 0~1 的數字 u2，計算角度 theta。\n           theta = 2π * u2。\n        3. 使用極座標轉換為直角座標得到最終點 (x, y)。\n        \"\"\"\n        u1 = random.random()\n        u2 = random.random()\n        r_prime = math.sqrt(u1) * self.radius\n        theta = 2 * math.pi * u2\n        x = self.x_center + r_prime * math.cos(theta)\n        y = self.y_center + r_prime * math.sin(theta)\n        return [x, y]\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析方法調用順序與對應參數，\n    執行相應方法，並將結果輸出到標準輸出。\n\n    輸入格式（示例）：\n    [\"Solution\", \"randPoint\", \"randPoint\"]\n    [[1.0, 0.0, 0.0], [], []]\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    lines = raw.splitlines()\n    methods = json.loads(lines[0])\n    args_list = json.loads(lines[1]) if len(lines) > 1 else []\n\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # constructor 返回 null\n        elif method == \"randPoint\":\n            results.append(obj.randPoint())\n        else:\n            # 若有其他方法，可在此處添加處理\n            results.append(None)\n\n    # 使用 json.dumps 以符合 LeetCode 的輸出格式（null 代表 None）\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem: generate random point uniformly inside circle. Steps: use random radius sqrt(U)*r, random angle 0-2π. Compute x = center.x + r_random * cos(theta); y = center.y + r_random * sin(theta). Provide virtual code line by line with explanation. No actual code. Use Start, End, Decision, etc.\n\nWe'll need to show initialization in constructor and method randPoint.\n\nWe need to include random number generation: use random() uniform [0,1) for radius and angle.\n\nStructure: Start; Step to store radius, center coordinates; Step for randPoint: generate random; compute radius sqrt(random) * r; angle 2π * random; compute x, y; return array; End.\n\nWe can include decisions? maybe no decision but we can show steps.\n\nWill use virtual arrows and comments.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: Store radius, x_center, y_center // 初始化成員變數\n\n→ End // 建構完成\n\nFor randPoint:\n\n→ Step 2: 隨機生成 u1, u2 取自 [0,1) // 用於產生半徑與角度\n\n→ Step 3: 計算 r' = sqrt(u1) * radius // 確保均勻分布\n\n→ Step 4: 計算 θ = 2π * u2 // 隨機角度\n\n→ Step 5: 計算 x = x_center + r' * cos(θ) // 取得 x 座標\n\n→ Step 6: 計算 y = y_center + r' * sin(θ) // 取得 y 座標\n\n→ Step 7: 返回 [x, y] // 給回隨機點\n\nBut we need virtual code with arrow.\n\nAlso show Decision? maybe not needed.\n\nLet's format each line like:\n\nStart // 程式開始\n\n→ Store radius, x_center, y_center // 初始化物件屬性\n\nEnd // 建構完成\n\nBut this is not a method. For clarity, we might create pseudo-classes: Start of class, constructor, method.\n\nWe'll create:\n\nStart // 開始執行程式\n\n→ Class: Solution // 定義 Solution 類別\n\n    → Constructor(radius, x_center, y_center) // 建構子初始化\n\n        → Set self.radius = radius // 保存半徑\n\n        → Set self.x_center = x_center // 保存中心 x\n\n        → Set self.y_center = y_center // 保存中心 y\n\n    → Method: randPoint() // 隨機點生成\n\n        → Generate u1 = rand() // [0,1) 隨機數\n\n        → Generate u2 = rand() // [0,1) 隨機數\n\n        → Calculate r_prime = sqrt(u1) * self.radius // 轉換半徑\n\n        → Calculate theta = 2π * u2 // 角度\n\n        → Calculate x = self.x_center + r_prime * cos(theta) // x 座標\n\n        → Calculate y = self.y_center + r_prime * sin(theta) // y 座標\n\n        → Return [x, y] // 回傳隨機點\n\nEnd // 程式結束\n\nBut need arrow style: Use `→` after each step, nested lines maybe indicated by indentation.\n\nShould maintain `Decision:` only if used; we don't need decisions. We can use `→` for steps. For nested steps we indent.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class: Solution // 定義 Solution 類別  \n → Constructor(radius, x_center, y_center) // 建構子初始化參數  \n  → Set self.radius = radius // 存儲圓半徑  \n  → Set self.x_center = x_center // 存儲圓心 x 座標  \n  → Set self.y_center = y_center // 存儲圓心 y 座標  \n → Method: randPoint() // 產生隨機點  \n  → Generate u1 = rand() // 產生 [0,1) 隨機數，用於半徑轉換  \n  → Generate u2 = rand() // 產生 [0,1) 隨機數，用於角度  \n  → Compute r_prime = sqrt(u1) * self.radius // 轉換為均勻分布半徑  \n  → Compute theta = 2π * u2 // 產生隨機角度  \n  → Compute x = self.x_center + r_prime * cos(theta) // 計算 x 座標  \n  → Compute y = self.y_center + r_prime * sin(theta) // 計算 y 座標  \n  → Return [x, y] // 回傳隨機點座標  \nEnd // 程式結束執行"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 3, 0, 4, _, _, _]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除陣列中所有等於 val 的元素，返回剩餘元素數量。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"\n    從類似 'nums = [3,2,2,3], val = 3' 的字串中解析出 nums 與 val。\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    val_match  = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not val_match:\n        raise ValueError(\"Input format not recognized.\")\n    nums = ast.literal_eval(nums_match.group(1))\n    val  = int(val_match.group(1))\n    return nums, val\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums, val = parse_input(data)\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 建構輸出列表，前 k 個為保留元素，之後為底線\n    output_list = [str(nums[i]) if i < k else '_' for i in range(len(nums))]\n    print(f\"{k}, nums = [{', '.join(output_list)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with comments. For the problem: remove element in-place and return k. Typical two-pointer: fast and slow. Pseudocode steps. Use structure Start, Decision. Provide each line. Let's produce.\n\nWe need to consider the algorithm:\n\nStart\n→ Step 1: 初始化 slow = 0 // pointer for position to fill\n→ For each fast from 0 to len(nums)-1:\n    → Decision: nums[fast] ≠ val?\n        Yes → nums[slow] = nums[fast]; slow++; // copy non-val to slow\n        No  → // skip\n→ End // return slow as k\n\nWe need to include array size, return etc. Also sorting not part of algorithm. Provide lines with arrow. Provide code in lines. Let's generate.\n\nWe must obey format: each line \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce like:\n\nStart // 程式開始執行\n→ Step 1: slow = 0 // 初始化慢指標，用於指向下一個待寫位置\n→ Step 2: for fast = 0 to length(nums)-1 do // 遍歷整個陣列\n    → Decision: nums[fast] != val? // 判斷當前元素是否要保留\n        Yes → nums[slow] = nums[fast]; slow = slow + 1; // 把非 val 元素複製到慢指標位置，並移動慢指標\n        No  → // 元素等於 val，直接跳過\n→ Step 3: return slow // slow 即為不等於 val 的元素數量 k\nEnd // 程式執行結束\n\nAdd line numbers? Not necessary. Just lines.\n\nMake sure each line has arrow or indent. Use indentation for decision. Provide spaces.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow = 0 // 初始化慢指標，指向下一個可寫的位置  \n→ Step 2: for fast = 0 to length(nums)-1 do // 從前往後逐個檢查每個元素  \n    → Decision: nums[fast] != val? // 判斷此元素是否需要保留  \n        Yes → nums[slow] = nums[fast]; slow = slow + 1; // 把非 val 的元素拷到慢指標位置，慢指標往後移動  \n        No  → // 元素等於 val，直接忽略  \n→ Step 3: return slow // slow 即為不等於 val 的元素個數 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[None,[3,1,2],[3,2,1],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[None, [3, 1, 2], [3, 2, 1], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"初始化物件，儲存原始陣列與目前狀態\"\"\"\n        self.original = list(nums)  # 原始配置\n        self.nums = list(nums)      # 目前陣列\n\n    def reset(self):\n        \"\"\"重設陣列回原始配置並回傳\"\"\"\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法隨機打亂陣列並回傳\"\"\"\n        n = len(self.nums)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)          # 隨機選擇索引\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]  # 交換元素\n        return self.nums\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入轉成兩個列表：methods 與 args\n    methods, args = ast.literal_eval(f'[{data}]')\n\n    results = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            obj = Solution(arg[0])  # arg[0] 為陣列\n            results.append(None)\n        elif method == \"reset\":\n            results.append(obj.reset())\n        elif method == \"shuffle\":\n            results.append(obj.shuffle())\n\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm: Fisher-Yates shuffle for shuffle, storing original array copy for reset. Provide step by step lines with arrow and comments. Use Start, End, Decision. Provide steps: constructor, reset, shuffle, and internal state. Also need to mention random selection. Let's produce.\n\nUse format lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n...\n\nWe need to include arrows and decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 定義 Solution 類別\n→ Step 2: Solution(int[] nums) 初始化物件並儲存原始陣列 nums 的副本 // 建構子\n    → Store original array copy → original = nums.clone() // 儲存原始資料\n    → Store current array reference → arr = original.clone() // 初始為原始\n→ End // 完成建構子\n→ Step 3: int[] reset() 重設陣列並返回原始配置 // reset 方法\n    → arr = original.clone() // 重置為原始\n    → return arr // 返回重置後陣列\n→ End // reset 方法結束\n→ Step 4: int[] shuffle() 隨機打亂陣列並返回 // shuffle 方法\n    → for i from arr.length - 1 downto 1\n        → j = random integer between 0 and i // 隨機索引\n        → swap arr[i] with arr[j] // 交換元素\n    → return arr // 返回打亂後陣列\n→ End // shuffle 方法結束\nEnd // 程式結束\n\nBut need arrow lines like \"→ Step 1:\" etc. Use decision? Not needed. Ensure each line ends with comment. Let's produce.\n\nAlso might show Decision for random selection? Not necessary.\n\nWe will produce as per output format. Let's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: Solution(int[] nums) 初始化物件並儲存原始陣列 nums 的副本 // 建構子  \n  → Store original array copy → original = nums.clone() // 儲存原始資料的深複製  \n  → Store current array reference → arr = original.clone() // 初始為原始陣列的複製  \n→ End // 完成建構子  \n→ Step 3: int[] reset() 重設陣列並返回原始配置 // reset 方法  \n  → arr = original.clone() // 將陣列重設為原始配置的複製  \n  → return arr // 回傳重設後的陣列  \n→ End // reset 方法結束  \n→ Step 4: int[] shuffle() 隨機打亂陣列並返回 // shuffle 方法  \n  → for i from arr.length - 1 downto 1 // 從尾端到頭端迴圈  \n    → j = random integer between 0 and i // 隨機產生索引 j  \n    → swap arr[i] with arr[j] // 交換位置 i 與 j 的元素  \n  → return arr // 回傳打亂後的陣列  \n→ End // shuffle 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 支援「nums = [1,2,3]」或直接「[1,2,3]」等輸入格式\n    if '=' in data:\n        _, nums_str = data.split('=', 1)\n    else:\n        nums_str = data\n    nums_str = nums_str.strip()\n    nums = ast.literal_eval(nums_str)\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code for generating all subsets of a set of unique integers, no duplicates. Use typical backtracking approach. Provide line-by-line virtual code with explanation. Use \"Start\", \"End\", \"Decision\", arrow. Provide each step. For example:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 subsets(nums) // 主入口\n→ Step 2: 初始化 result 為空集合 // 存放所有子集\n→ Step 3: 定義遞歸函式 backtrack(start, current) // 回溯\n→ Step 4: 在 backtrack 裡，將 current 加到 result // 產生子集\n→ Decision: 如果 start >= len(nums) // 若已處理完所有元素\n    Yes → return // 结束递归\n→ Step 5: 循環 i 從 start 到 len(nums)-1\n    → Step 6: current.append(nums[i]) // 加入元素\n    → Step 7: backtrack(i+1, current) // 继续递归\n    → Step 8: current.pop() // 移除元素，回溯\n→ Step 9: 呼叫 backtrack(0, []) // 开始回溯\n→ Step 10: 回傳 result // 結果\n\nMake sure to use virtual arrow syntax exactly. Use \"→\" to indent. For Decision we indent. Provide explanation after //.\n\nLet's format.\n\nMake sure each line has \"虛擬碼步驟\" and comment after a space.\n\nWe must not output actual code, just virtual steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 subsets(nums) // 主入口，接收唯一整數陣列  \n→ Step 2: 初始化 result 為空集合 // 用於儲存所有子集  \n→ Step 3: 定義遞歸函式 backtrack(start, current) // 回溯核心  \n→ Step 4: 在 backtrack 裡，將 current 加到 result // 把目前組合加入結果  \n→ Decision: 如果 start >= len(nums) // 是否已經考慮完所有元素  \n  Yes → return // 結束此分支的遞迴  \n→ Step 5: 循環 i 從 start 到 len(nums)-1 // 嘗試加入每個後續元素  \n  → Step 6: current.append(nums[i]) // 將元素加入當前子集  \n  → Step 7: backtrack(i+1, current) // 以下一個位置繼續遞迴  \n  → Step 8: current.pop() // 回溯，移除剛加入的元素  \n→ Step 9: 呼叫 backtrack(0, []) // 從陣列起點開始回溯  \n→ Step 10: 回傳 result // 回傳完整的子集集合  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}\n        self.freq_to_keys = defaultdict(OrderedDict)\n\n    def _update(self, key: int) -> None:\n        value, freq = self.key_to_val_freq[key]\n        # Remove from current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Insert into next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (LRU within same freq)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string into two lists: ops and args.\n    Handles inputs like '[\"LFUCache\", \"put\"], [[2], [1,1]]'.\n    \"\"\"\n    depth = 0\n    split_index = None\n    for i, ch in enumerate(data):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_index = i\n            break\n    if split_index is None:\n        raise ValueError(\"Input format error\")\n    ops_str = data[:split_index].strip()\n    args_str = data[split_index+1:].strip()\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    ops, args = parse_input(raw_input)\n    res = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            res.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            res.append(None)\n        elif op == \"get\":\n            res.append(cache.get(arg[0]))\n    print(res)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations for implementing LFUCache with O(1). Should include structure: use hash map of key to node, doubly linked lists per frequency, freq map to list, minFreq. Steps for get and put. Each line with \"→\" etc. Provide stepwise algorithm. Let's outline:\n\nStart\n→ Step 1: 初始化 capacity, minFreq, keyNode map, freqList map // set up data structures\n→ Decision: 是否有可用容量? (but for put check)\nImplementation of get:\n    → Decision: key exists?\n        Yes → Step: incr freq of node, move node to higher freq list, return value\n        No → return -1\nImplementation of put:\n    → Decision: capacity == 0? // skip\n    → Decision: key exists?\n        Yes → update value, same as get (increase freq)\n        No → Decision: size == capacity?\n            Yes → evict minFreq list's head node\n            No → nothing\n        → Insert new node with freq 1, add to freqList[1], set minFreq=1\n\nNeed to mention helper functions: increment frequency, evict. Provide each as separate steps.\n\nLet's craft steps accordingly. Each line preceded by \"→\" unless Start or End.\n\nWe should ensure each line has explanation comment.\n\nLet's produce about maybe 20-30 lines. Ensure no actual code.\n\nLet's start.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 keyToNode: Map<key, Node> // 取得鍵對應的節點\n→ Step 2: 定義 freqToList: Map<freq, DoubleLinkedList> // 同頻率的節點列表\n→ Step 3: 定義 capacity, size = 0, minFreq = 0 // 初始化容量、大小與最小頻率\n→ Decision: 需要初始化頻率列表? // 若 freqToList 尚無 freq 1 列表則建立\n    Yes → Step 4: 建立空 DoubleLinkedList 並存入 freqToList[1] // 頻率為 1 的列表\n    No  →  // 已存在，無需處理\nEnd // 初始化結束\n\nStart // get(key) 處理\n→ Step 5: Decision: keyToNode 是否包含 key? // 檢查鍵是否存在\n    Yes → \n        → Step 6: Node node = keyToNode[key] // 取得節點\n        → Step 7: Call incrementFrequency(node) // 更新頻率並重新放入對應列表\n        → Step 8: Return node.value // 回傳值\n    No  → Step 9: Return -1 // 鍵不存在\n\nStart // put(key, value) 處理\n→ Step 10: Decision: capacity == 0? // 若容量為 0 直接返回\n    Yes → End // 無法儲存任何項目\n    No  → \n        → Step 11: Decision: keyToNode 是否包含 key? // 是否已存在\n            Yes →\n                → Step 12: keyToNode[key].value = value // 更新值\n                → Step 13: Call incrementFrequency(keyToNode[key]) // 更新頻率\n            No →\n                → Step 14: Decision: size == capacity? // 是否已滿\n                    Yes →\n                        → Step 15: Call evictLFU() // 淘汰最少頻率且最舊的節點\n                    No  → // 空間足夠，無需淘汰\n                → Step 16: Create new Node(key, value, freq=1) // 建立新節點\n                → Step 17: Insert node into freqToList[1] // 加入頻率 1 列表\n                → Step 18: keyToNode[key] = node // 更新鍵對應\n                → Step 19: size += 1 // 增加大小\n                → Step 20: minFreq = 1 // 最小頻率重設為 1\n\nStart // incrementFrequency(node) 子程序\n→ Step 21: int oldFreq = node.freq // 取得舊頻率\n→ Step 22: Remove node from freqToList[oldFreq] // 從舊列表移除\n→ Step 23: Decision: freqToList[oldFreq] 為空且 oldFreq == minFreq? // 若舊列表被清空且是最小頻率\n    Yes → Step 24: minFreq += 1 // 更新最小頻率\n    No  → // 無需改變 minFreq\n→ Step 25: node.freq += 1 // 使頻率加 1\n→ Step 26: Decision: freqToList[ node.freq ] 是否存在? // 檢查新頻率列表\n    Yes → // 已存在，直接使用\n    No  → Step 27: 建立空 DoubleLinkedList 並存入 freqToList[ node.freq ] // 新建列表\n→ Step 28: Insert node into freqToList[ node.freq ] // 加入新列表\n\nStart // evictLFU() 子程序\n→ Step 29: DoubleLinkedList list = freqToList[minFreq] // 取得最小頻率列表\n→ Step 30: Node nodeToEvict = list.removeHead() // 移除最舊節點（LFU）\n→ Step 31: Delete keyToNode[nodeToEvict.key] // 從鍵對應表刪除\n→ Step 32: size -= 1 // 尺寸減 1\n→ Step 33: Decision: list 是否為空? // 判斷是否需要更新 minFreq\n    Yes → Step 34: minFreq += 1 // 如果列表空了，最小頻率加 1\n    No  → // 保持 minFreq 不變\n\nEnd // LFUCache 功能實現完成"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 支援兩種輸入格式：expression = \"2-1-1\" 或僅輸入 2-1-1\n    if '=' in data:\n        _, expr_part = data.split('=', 1)\n        expression = expr_part.strip()\n    else:\n        expression = data\n    # 去除可能的雙引號\n    if expression.startswith('\"') and expression.endswith('\"'):\n        expression = expression[1:-1]\n    elif expression.startswith(\"'\") and expression.endswith(\"'\"):\n        expression = expression[1:-1]\n    # 計算所有結果並輸出\n    result = Solution().diffWaysToCompute(expression)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for computing all possible results from expression by different groupings. This is LeetCode 241: Different Ways to Add Parentheses.\n\nWe need to output step-by-step pseudo code lines with explanations. Use arrows, decision, Start, End. We must generate a structured algorithm, likely using recursion and memoization.\n\nWe need to produce lines like:\n\nStart // start\n→ Step 1: Parse expression to tokens // etc\n→ Decision: if expression contains no operators? // base case\nYes → Step 2: Convert token to integer and return list // etc\nNo → Step 3: Initialize results list\n→ Step 4: For each operator index\n...\n\nWe should show recursion.\n\nWe'll produce:\n\nStart // program start\n→ Step 1: Define function compute(expr) // main recursion\n→ Decision: if expr contains no operator? // base\nYes → Step 1a: Convert expr to integer, return [int]\nNo → Step 1b: Initialize results empty\n→ For i in range(len(expr)):\n    If expr[i] is operator:\n        left = expr[0:i]\n        right = expr[i+1:]\n        leftResults = compute(left)\n        rightResults = compute(right)\n        For each l in leftResults:\n            For each r in rightResults:\n                res = apply_operator(l, expr[i], r)\n                append res to results\n→ Return results\nEnd // end\n\nAlso we might add memoization dictionary to avoid recomputation.\n\nWe need to output as per format: each line with \"→\" or \"Decision:\" etc, followed by comment.\n\nAlso we need to mention caching.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: Define memo dictionary // 用於記錄已計算子表達式\n\n→ Step 2: Define recursive function diffWays(expr) // 計算 expr 的所有結果\n\n→ Decision: 如果 expr 中沒有運算符? // 判斷是否為單一數字\n\n    Yes → Step 2a: 轉成整數，回傳 [整數] // 基本情況\n\n    No  → Step 2b: 初始化 results 為空清單 // 用於存放所有結果\n\n→ For i in range(len(expr)):\n    If expr[i] 是運算符:\n        leftExpr = expr[0:i]\n        rightExpr = expr[i+1:]\n\n→ Step 3a: leftVals = diffWays(leftExpr) // 計算左子表達式\n\n→ Step 3b: rightVals = diffWays(rightExpr) // 計算右子表達式\n\n→ For each lv in leftVals:\n    For each rv in rightVals:\n        val = apply_operator(lv, expr[i], rv) // 執行運算\n        results.append(val)\n\n→ Decision: 是否已在 memo? // 事先檢查\n    Yes → Step 4a: skip recomputation\n    No  → Step 4b: memo[expr] = results // 缓存\n\n→ Return results\n\nEnd // 程式結束\n\nBut we need to maintain proper formatting with arrows. Actually we must use arrow for steps and decisions. So each line: \"→ Step X: ... // ...\" or \"Decision: ...\". Indentation for nested lines can use spaces but maintain arrow. We'll output as multiple lines with arrow. Use indentation maybe with tabs or spaces but still arrow lines.\n\nAlso for loops, we need to show steps within loop. Use arrows with spaces maybe.\n\nWe need to ensure we adhere to output format: Each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we need \"→ Step ...\" lines etc. Also \"Decision:\" lines.\n\nAlso we need to include \"Start\" and \"End\". Should we add \"→\" before Start? Format example uses \"Start\" with no arrow. So we can use \"Start // 程式開始執行\".\n\nWe need to produce lines exactly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 memo 作為字典 // 用來記錄已計算過的子表達式結果\n→ Step 2: 定義遞迴函式 diffWays(expr) // 計算 expr 的所有可能結果\n→ Decision: 若 expr 中不含任何運算符？ // 判斷是否為單一數字\n    Yes → Step 2a: 把 expr 轉成整數，回傳 [int(expr)] // 基本情況\n    No  → Step 2b: 建立空清單 results // 用於儲存所有可能結果\n→ Decision: 若 memo 已經有 expr 的結果？ // 檢查是否需要重新計算\n    Yes → Step 3a: 回傳 memo[expr] // 直接使用已緩存的結果\n    No  → Step 3b: 進行以下計算，並在最後緩存\n→ Step 4: 遍歷 expr 的每個字元，若為運算符\n    → Step 4a: 切割左子表達式 leftExpr = expr[0:i]\n    → Step 4b: 切割右子表達式 rightExpr = expr[i+1:]\n    → Step 4c: leftVals = diffWays(leftExpr) // 計算左子表達式的所有結果\n    → Step 4d: rightVals = diffWays(rightExpr) // 計算右子表達式的所有結果\n    → Step 4e: 對每一對左值 lv 與右值 rv\n        → Step 4e1: val = apply_operator(lv, expr[i], rv) // 執行對應運算\n        → Step 4e2: results.append(val) // 將結果加入清單\n→ Step 5: memo[expr] = results // 將本次計算結果緩存\n→ Step 6: 回傳 results // 回傳所有可能結果\n→ End // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp21ks_8xb.py\", line 43, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplq38fnkm.py\", line 43, in <module>\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\n    ^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport bisect\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        使用有序列表維持滑動窗口，檢查是否存在符合條件的索引對。\n        \"\"\"\n        if indexDiff <= 0 or valueDiff < 0:\n            return False\n\n        window = []  # 有序列表\n        for i, num in enumerate(nums):\n            # 在窗口中尋找最小符合 |x - num| <= valueDiff 的 x\n            pos = bisect.bisect_left(window, num - valueDiff)\n            if pos < len(window) and abs(window[pos] - num) <= valueDiff:\n                return True\n\n            # 把當前元素加入窗口\n            bisect.insort(window, num)\n\n            # 若窗口大小超過 indexDiff，移除最舊的元素\n            if len(window) > indexDiff:\n                # 找到要移除的元素在窗口中的位置\n                remove_val = nums[i - indexDiff]\n                remove_pos = bisect.bisect_left(window, remove_val)\n                # 由於可能有重複值，確保剔除正確位置\n                while remove_pos < len(window) and window[remove_pos] != remove_val:\n                    remove_pos += 1\n                if remove_pos < len(window):\n                    window.pop(remove_pos)\n\n        return False\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 使用 exec 將輸入的變量定義到 local_vars 字典\n    local_vars = {}\n    exec(data, {}, local_vars)\n\n    nums = local_vars['nums']\n    indexDiff = local_vars['indexDiff']\n    valueDiff = local_vars['valueDiff']\n\n    solution = Solution()\n    result = solution.containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that finds such pair. Need to output each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: etc. Provide step-by-step algorithm. We can use sliding window approach: iterate over indices, maintain a data structure (like balanced BST) to store nums[j] for j in window of size indexDiff. For each i, check if any value in set within valueDiff of nums[i]. But in virtual code, we don't need to specify BST; just mention \"check exists value within range\". Use Decision: if exists? etc.\n\nWe need to produce code line by line. Could include steps: Start, Input, Iterate, maintain window, Decision etc.\n\nLet's write steps:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums, 整數 indexDiff, valueDiff // 取得輸入參數\n→ Step 2: 初始化一個空的有序集合 window // 用於儲存可比對的數值\n→ Step 3: 從左到右遍歷 nums 的每個索引 i // 逐一檢查\n    → Step 3.1: Decision: 是否已超過窗口大小? // i > indexDiff\n        Yes → Step 3.1.1: 從 window 移除 nums[i - indexDiff - 1] // 移除最舊的元素\n        No → // 仍在窗口內\n    → Step 3.2: Decision: 在 window 中是否存在數值 x 使得 |x - nums[i]| <= valueDiff? // 檢查是否有符合差值的數\n        Yes → Step 3.2.1: Return true // 找到符合條件的索引對\n        No → // 沒有符合條件\n    → Step 3.3: 將 nums[i] 插入 window // 加入當前元素供未來索引使用\n→ End // 未找到符合條件，程式結束\n\nBut we need to output each line separately. The indentation may show hierarchical decisions. Use \"→ Decision:\" etc. Each line includes \"虛擬碼步驟 // 解釋\". Need to include \"Start\" and \"End\".\n\nWe should include a step for checking if i != j automatically satisfied by window removal? Actually we consider j != i because we only compare with window before inserting current i. So safe.\n\nAlso we may need to include variable names: idxDiff, valDiff.\n\nLet's produce final answer accordingly. Ensure each line has \"虛擬碼步驟\" then space then comment. Use Chinese. Use correct arrow characters.\n\nLet's craft lines:\n\n1. Start // 程式開始執行\n2. → Step 1: 輸入 nums, indexDiff, valueDiff // 取得輸入參數\n3. → Step 2: 初始化空的有序集合 window // 用於儲存可比對的數值\n4. → Step 3: 從 0 到 nums.length-1 逐一遍歷索引 i // 逐一檢查\n5.     → Decision: i > indexDiff? // 判斷是否需要移除最舊的元素\n6.         Yes → Step 3.1.1: 從 window 移除 nums[i - indexDiff - 1] // 移除超出窗口的元素\n7.         No  → // 當前索引仍在窗口內\n8.     → Decision: window 中是否存在 x 使得 |x - nums[i]| <= valueDiff? // 檢查是否有符合差值的數\n9.         Yes → Step 3.2.1: Return true // 找到符合條件的索引對\n10.        No  → // 無符合條件，繼續\n11.    → Step 3.3: 將 nums[i] 插入 window // 加入當前元素供未來索引使用\n12. End // 未找到符合條件，程式結束\n\nWe need to output exactly as requested, each line with \"虛擬碼步驟\" etc. Use \"→\" arrow at start of each step line. \"Decision:\" line uses \"Decision:\" and arrow after each branch? The example shows \"Decision: ... //\" then indentation with Yes →, No → etc.\n\nThus we need to follow that format. Provide lines with appropriate indentation using spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 nums, indexDiff, valueDiff // 取得輸入參數\n→ Step 2: 初始化空的有序集合 window // 用於儲存可比對的數值\n→ Step 3: 從 0 到 nums.length-1 逐一遍歷索引 i // 逐一檢查\n    → Decision: i > indexDiff? // 判斷是否需要移除最舊的元素\n        Yes → Step 3.1.1: 從 window 移除 nums[i - indexDiff - 1] // 移除超出窗口的元素\n        No  → // 當前索引仍在窗口內\n    → Decision: window 中是否存在 x 使得 |x - nums[i]| <= valueDiff? // 檢查是否有符合差值的數\n        Yes → Step 3.2.1: Return true // 找到符合條件的索引對\n        No  → // 無符合條件，繼續\n    → Step 3.3: 將 nums[i] 插入 window // 加入當前元素供未來索引使用\nEnd // 未找到符合條件，程式結束"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpg9tjq__z.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpg9tjq__z.py\", line 46, in main\n    prerequisites = eval(part.split('=', 1)[1].strip())\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpstb1b627.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpstb1b627.py\", line 46, in main\n    prerequisites = eval(part.split('=', 1)[1].strip())\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # 建立鄰接表與入度計數\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 依據前置關係建立圖\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 找出所有入度為 0 的課程\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        # Kahn 演算法進行拓撲排序\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若已訪問的課程數與總課程數相同，則能完成\n        return visited == numCourses\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串，例如: 'numCourses = 2, prerequisites = [[1,0]]'\n    parts = [p.strip() for p in data.split(',')]\n    numCourses = 0\n    prerequisites = []\n\n    for part in parts:\n        if part.startswith('numCourses'):\n            numCourses = int(part.split('=')[1].strip())\n        elif part.startswith('prerequisites'):\n            # 直接使用 eval 解析列表\n            prerequisites = eval(part.split('=', 1)[1].strip())\n\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for topological sort / cycle detection for course schedule. Provide step-by-step lines with explanations. Use Start, Decision, etc. Provide arrow format. Must be line by line. Provide each line with \"虛擬碼步驟 // 解釋\". Let's produce solution: Build graph, indegree, queue. While queue not empty, pop, decrease indegree, add new zero indegree to queue, count. After loop, if count == numCourses return true else false.\n\nLet's format.\n\nWe'll use arrow for transitions.\n\nLet's start: Start\n\n→ Step 1: Initialize adjacency list and indegree array // 建立鄰接表與入度計數\n\n→ Step 2: For each pair [a,b] in prerequisites: add edge b→a and indegree[a]++ // 根據前置關係建立圖\n\n→ Step 3: Initialize queue with courses having indegree 0 // 找出無前置課程的課程\n\n→ Decision: Queue 是否為空? // 判斷是否有可開課的課程\n\n    Yes → End // 若沒課程可開，結束流程\n\n    No  → Step 4: 取得並移除隊首元素 curr // 取一門可開課的課程\n\n    → Step 5: processedCount++ // 記錄已完成課程數\n\n    → Step 6: For each neighbour of curr: indegree[neighbour]-- // 更新相鄰課程入度\n\n        → Decision: indegree[neighbour] 是否為 0? // 判斷是否所有前置課程已完成\n\n            Yes → Step 7: 將 neighbour 加入 queue // 可以開這門課\n\n    → Step 8: 回到 Decision: Queue 是否為空? // 繼續處理\n\n→ Step 9: Decision: processedCount 是否等於 numCourses? // 判斷是否完成所有課程\n\n    Yes → Step 10: Return true // 能完成所有課程\n\n    No  → Step 11: Return false // 無法完成\n\nEnd\n\nNeed to ensure each line has \"虛擬碼步驟\" like \"Start\". And arrows: → etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 adjacency list 與 indegree 陣列 // 初始化圖結構與入度計數  \n→ Step 2: 對每個 pair [a, b] 在 prerequisites 中  \n  → Decision: 是否已存在鍵 b?  \n   Yes → Step 2a: 在 adjacency[b] 加入 a // 建立邊 b→a  \n   No  → Step 2b: 創建 adjacency[b] 為空 list，然後加入 a // 建立新鍵  \n  → Step 2c: indegree[a]++ // 更新 a 的入度  \n→ Step 3: 建立 queue 為所有 indegree 為 0 的課程 // 找出無前置課程的課程  \n→ Decision: queue 是否為空? // 判斷是否有可開課的課程  \n  Yes → End // 沒課程可開，結束流程  \n  No  → Step 4: 取出並移除 queue 的首元 curr // 取得一門可開課的課程  \n  → Step 5: processedCount++ // 記錄已完成課程數  \n  → Step 6: 對 adjacency[curr] 中的每個 neighbour 執行  \n   → Step 6a: indegree[neighbour]-- // 減少相鄰課程的入度  \n   → Decision: indegree[neighbour] 是否為 0?  \n    Yes → Step 6b: queue 加入 neighbour // 現可開這門課  \n  → 回到 Decision: queue 是否為空? // 繼續處理下一門課程  \n→ Step 9: Decision: processedCount 是否等於 numCourses? // 檢查是否完成所有課程  \n  Yes → Step 10: Return true // 能完成所有課程  \n  No  → Step 11: Return false // 無法完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6v_0wzf0.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmp6v_0wzf0.py\", line 20, in main\n    data = json.loads(sys.stdin.read().strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe1l7yj69.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpe1l7yj69.py\", line 20, in main\n    data = json.loads(sys.stdin.read().strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = json.loads(sys.stdin.read().strip())\n    methods, args_list = data[0], data[1]\n\n    # Instantiate the solution object using the first argument list\n    solution = Solution(*args_list[0])\n\n    results = [None]  # constructor returns null\n    for i in range(1, len(methods)):\n        method_name = methods[i]\n        method_args = args_list[i]\n        func = getattr(solution, method_name)\n        res = func(*method_args)\n        results.append(res)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the problem: Given array w, implement pickIndex() such that probability proportional to weight. We need to output in the specified format: each line is \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Must produce step-by-step algorithm: Preprocess prefix sums, total sum; in pickIndex generate random number between 1 and total inclusive; binary search to find index; return it.\n\nWe should produce each step as a line.\n\nLet's think: Steps:\n\nStart // begin\n\n→ Step 1: 計算 prefix sum array P where P[i] = sum of w[0..i] // Build cumulative weights\n\n→ Step 2: 計算總重 sumW = P[last] // Total weight\n\n→ Step 3: 計算隨機整數 r 介於 1 到 sumW 之間 // Generate random number\n\n→ Decision: r <= P[0]? // Binary search or linear scan. Could show binary search decision.\n\nBetter: Use binary search.\n\n→ Step 4: 設定 low = 0, high = len(P)-1 // Initialize binary search bounds\n\n→ Step 5: 循環 while low < high // Binary search loop\n\n→ Decision: P[mid] < r? // Check mid against r\n\n    Yes → low = mid + 1 // r greater, search right\n\n    No  → high = mid // r <= mid, search left\n\n→ Step 6: 迴圈結束後 low 即為選中的索引 // low holds index\n\n→ Step 7: 回傳 low // Return index\n\nBut need to indicate pickIndex function.\n\nSo perhaps separate steps: Start main, Step 1: initialize, Step 2: function definition.\n\nBetter: Outline: Preprocessing steps (in constructor) and pickIndex method.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 建立 class WeightedPicker // 定義類別\n\n→ Step 2: 在建構子中接收 w 並計算 prefix sum P 以及總重 sumW // 預處理\n\n→ Step 3: Store P 和 sumW 於物件屬性 // 方便 later\n\n→ Step 4: 定義方法 pickIndex() // 功能實作\n\n→ Step 5: 在 pickIndex 內產生隨機整數 r ∈ [1, sumW] // 隨機數生成\n\n→ Step 6: 使用二分搜尋尋找 r 在 P 中的位置 // 對應索引\n\n→ Step 7: 回傳找到的索引 // 結果\n\nBut must use 虛擬碼 lines with arrows. Provide detailed steps inside pickIndex.\n\nSo we will produce a list of lines, each with \"→ Step ...\" or \"Decision:\". Each line comment in Chinese.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立 WeightedPicker 類別並在建構子中接收 w // 初始化類別\n→ Step 2: 計算 prefix sum 陣列 P，P[i] = sum(w[0..i]) // 建立累積重量\n→ Step 3: 計算總重 sumW = P[w.length-1] // 總重量\n→ Step 4: 將 P 與 sumW 儲存於物件屬性 // 供 pickIndex 使用\n→ Step 5: 定義方法 pickIndex() // 開始實作隨機選取\n→ Step 6: 產生隨機整數 r 介於 1 與 sumW 之間 // 隨機數範圍\n→ Step 7: 初始化 low = 0, high = P.length-1 // 二分搜尋範圍\n→ Step 8: 進入 while low < high // 迴圈搜尋\n→ Decision: P[mid] < r? // 判斷中點是否小於 r\n    Yes → low = mid + 1 // r 在右半部，調整 low\n    No  → high = mid // r 在左半部或等於 mid，調整 high\n→ Step 9: 迴圈結束，low 為所需索引 // 二分搜尋完成\n→ Step 10: 回傳 low // 結果輸出\nEnd // 程式執行結束\n\nBut we need to include mid calculation: mid = low + (high - low)/2.\n\nSo add step: mid = low + (high - low) / 2.\n\nAlso note: The random integer generation should produce inclusive 1..sumW.\n\nAdd step: r = randomInt(1, sumW).\n\nAlso mention randomInt function.\n\nLet's structure:\n\nStart\n→ Step 1: WeightedPicker class\n→ Step 2: constructor(w)\n    → Step 3: compute P\n    → Step 4: compute sumW\n    → Step 5: store\n→ Step 6: method pickIndex()\n    → Step 7: r = randomInt(1, sumW)\n    → Step 8: low = 0; high = P.length-1\n    → Step 9: while low < high\n        → Step 10: mid = low + (high - low)/2\n        → Decision: P[mid] < r?\n            Yes → low = mid + 1\n            No  → high = mid\n    → Step 11: return low\n\nBut each line must be a single line with arrow or Decision. We can nest Decision inside while but each nested line with indentation? In example, they use indentation for nested lines. Use same style: indent sublines. Use arrow arrow.\n\nWe'll produce as above.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 WeightedPicker 類別 // 建立類別以包裝功能  \n→ Step 2: 在建構子內接收陣列 w // constructor(w)  \n→ Step 3: 建立 prefix sum 陣列 P // P[i] = sum(w[0..i])  \n→ Step 4: 計算總重 sumW = P[w.length-1] // 取得總重量  \n→ Step 5: 將 P 與 sumW 存入物件屬性 // 方便 pickIndex 取用  \n→ Step 6: 定義方法 pickIndex() // 開始實作隨機選取  \n→ Step 7: 產生隨機整數 r ∈ [1, sumW] // randomInt(1, sumW)  \n→ Step 8: 設定 low = 0, high = P.length-1 // 二分搜尋邊界  \n→ Step 9: 進入 while low < high // 進行二分搜尋  \n → Step 10: mid = low + (high - low) / 2 // 計算中點  \n → Decision: P[mid] < r? // 判斷 r 是否在右半部  \n   Yes → low = mid + 1 // r 大於 P[mid]，搜尋右半部  \n   No  → high = mid // r 小於或等於 P[mid]，搜尋左半部  \n→ Step 11: 迴圈結束後 low 即為選中的索引 // 二分搜尋完成  \n→ Step 12: 回傳 low // 返回最終選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmhh_m5r2.py\", line 40, in <module>\n    mat, k = parse_input(input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmhh_m5r2.py\", line 34, in parse_input\n    mat = ast.literal_eval(mat_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkmy6lwet.py\", line 40, in <module>\n    mat, k = parse_input(input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkmy6lwet.py\", line 34, in parse_input\n    mat = ast.literal_eval(mat_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\ndef parse_input(data: str):\n    # Find the matrix part\n    mat_match = re.search(r'mat\\s*=\\s*(\\[[\\s\\S]*?])', data)\n    if not mat_match:\n        raise ValueError(\"Cannot find matrix in input\")\n    mat_str = mat_match.group(1)\n\n    # Find the k part\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if not k_match:\n        raise ValueError(\"Cannot find k in input\")\n    k_str = k_match.group(1)\n\n    mat = ast.literal_eval(mat_str)\n    k = int(k_str)\n    return mat, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    mat, k = parse_input(input_data)\n    sol = Solution()\n    result = sol.kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line, no actual code. Should describe algorithm: count soldiers per row, store pairs, sort by count then index, select k. Provide explanation. Use Start, Decision. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's craft.\n\nWe need to adhere to formatting: each line contains \"虛擬碼步驟\" then space then comment.\n\nLet's produce:\n\nStart // 開始程式\n→ Step 1: 初始化 list rows = empty // 用於存放 (soldiers, index)\n→ Step 2: 取 mat 的行數 m\n→ Step 3: 迴圈 i 從 0 到 m-1 // 逐行計算\n    → Step 3.1: 用二分搜尋找到第 i 行中 1 的個數 count // 因為 1 在左側\n    → Step 3.2: 把 (count, i) 加入 rows // 儲存\n→ Step 4: 按 count 升序、若 count 相同按 index 升序排序 rows // 排序弱到強\n→ Step 5: 取前 k 個元素的 index，存入 result // 得到最弱 k 行\n→ Step 6: 輸出 result // 回傳結果\nEnd // 程式結束\n\nBut we need arrows? Use \"→\". For decision maybe binary search? Not necessary. Provide step 3.1 as Decision? It's a function. Keep simple.\n\nNeed each line separate. Use arrow after Step? Provided example: \"→ Step 1: 輸入使用者數字\". So we follow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 rows = 空列表 // 用來儲存每行的 (soldierCount, rowIndex)  \n→ Step 2: 設定 m = mat 的行數 // 取得矩陣的行數  \n→ Step 3: 迴圈 i 從 0 到 m-1 // 逐行處理  \n    → Step 3.1: 使用二分搜尋找到第 i 行中 1 的個數 count // 1 在左側，二分可 O(log n)  \n    → Step 3.2: 將 (count, i) 加入 rows // 存入該行資訊  \n→ Step 4: 對 rows 進行排序，排序條件是先按 count 升序，再按 rowIndex 升序 // 確保同數量士兵時行號較小的排前面  \n→ Step 5: 取 rows 前 k 個元素的 rowIndex，放入 result // 得到最弱的 k 行  \n→ Step 6: 輸出 result // 回傳結果  \nEnd // 程式執行結束"
    }
  ]
}