{
  "run_index": 46,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 293,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef count_lines_in_file(file_path: str = \"data.txt\") -> None:\n    \"\"\"\n    開啟指定的文字檔案，統計並輸出總行數。\n    若檔案不存在，則輸出錯誤訊息。\n    \"\"\"\n    try:\n        # 使用 with 語法確保檔案正確關閉\n        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n            lines = f.readlines()\n        print(f\"檔案共有 {len(lines)} 行\")\n    except FileNotFoundError:\n        # 檔案不存在時的處理\n        print(\"找不到檔案！\")\n\nif __name__ == \"__main__\":\n    # main 區塊不依賴任何輸入，直接執行計算\n    count_lines_in_file()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step with explanation. Format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision:, arrows. We need to include with and try/except. Let's produce steps.\n\nLine 1: Start\nLine 2: Decision: 檢查是否需要開啟檔案? maybe we just start with try block. Might use \"→ Step 1: 嘗試打開檔案\" etc. Use Decision: \"檔案是否成功開啟?\" No? Actually try/except handles.\n\nWe can show:\n\nStart\n→ Step 1: 使用 try 開始讀取檔案 // 試著打開並讀取檔案\n    → Decision: 讀取成功? // 是否成功進入 with\n        Yes → Step 2: 使用 with 打開 data.txt 為 file // 使用 with 讀取檔案\n            → Step 3: 讀取所有行並計算行數 // 取得行數\n            → Step 4: 輸出行數 // 顯示結果\n        No → Step 5: 捕捉 FileNotFoundError // 處理檔案不存在\n            → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd\n\nBut we need to incorporate try/except structure. Use Decision: 是否成功? maybe we use \"Decision: 是否捕捉到 FileNotFoundError?\" No. Let's design:\n\nStart\n→ Step 1: 開始 try 區塊 // 進入 try\n    → Decision: 進入 with data.txt? // 這裡先嘗試打開檔案\n        Yes → Step 2: 使用 with 打開檔案為 file // 開啟\n            → Step 3: 讀取所有行並計算行數 // 取得行數\n            → Step 4: 輸出行數 // 顯示結果\n        No → Decision: 是否發生 FileNotFoundError? // 捕捉錯誤\n            Yes → Step 5: 輸出 '找不到檔案！' // 顯示錯誤\nEnd\n\nBut need to represent try/except maybe:\n\n→ Step 1: 嘗試 { \n    → Step 2: 使用 with open('data.txt','r') as file // 開啟\n        → Step 3: 讀取行數\n        → Step 4: 輸出行數\n    } 捕捉 FileNotFoundError\n        → Step 5: 輸出 '找不到檔案！'\n\nBut our virtual code arrow representation might not support braces. We can use Decision to branch to except block.\n\nLet's craft:\n\nStart\n→ Decision: 是否進入 try 區塊? // 進入 try\n    Yes → Step 1: 使用 with open('data.txt','r') as file // 打開檔案\n        → Step 2: 讀取所有行到 lines // 讀取行\n        → Step 3: 計算行數 row_count = len(lines) // 計算\n        → Step 4: 輸出 row_count // 顯示\n    No  → Decision: 是否發生 FileNotFoundError? // 捕捉錯誤\n        Yes → Step 5: 輸出 '找不到檔案！' // 顯示\nEnd\n\nBut this representation is not precise. Maybe better:\n\nStart\n→ Step 1: 嘗試打開檔案 // 進入 try\n    → Decision: 開啟成功? // 若成功進入 with\n        Yes → Step 2: 使用 with open('data.txt','r') as file // 開啟\n            → Step 3: 讀取行並計算行數\n            → Step 4: 輸出行數\n        No  → Decision: 是否 FileNotFoundError? // 發生錯誤\n            Yes → Step 5: 輸出 '找不到檔案！'\nEnd\n\nBut we might need to explicitly show try/except. Use \"→ Try:\"? Could do \"→ Try: ...\" and \"→ Except FileNotFoundError:\".\n\nMaybe like:\n\nStart\n→ Try: 開啟檔案並讀取\n    → Step 1: 使用 with open('data.txt','r') as file // 打開檔案\n        → Step 2: 讀取行並計算行數 // 取得行數\n        → Step 3: 輸出行數 // 顯示\n→ Except FileNotFoundError: // 捕捉檔案不存在\n    → Step 4: 輸出 '找不到檔案！' // 顯示錯誤\nEnd\n\nBut we need arrows. Use \"→ Try:\" maybe not allowed. But we can use Decision: \"是否開啟成功?\" but that duplicates logic. I'll produce with explicit Decision: \"檔案開啟成功?\" Yes -> with block else -> except. That's simpler.\n\nLet's produce final output accordingly. Use each line as per format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 嘗試打開檔案 // 進入 try 區塊，準備讀取 data.txt  \n    → Decision: 開啟檔案成功? // 判斷是否能進入 with 區塊  \n        Yes → Step 2: 使用 with open('data.txt','r') as file // 用 with 語法安全開啟檔案  \n            → Step 3: 讀取所有行到 lines // 取得檔案的所有文字行  \n            → Step 4: 計算行數 row_count = len(lines) // 透過長度得到行數  \n            → Step 5: 輸出 row_count // 將行數顯示給使用者  \n        No  → Decision: 是否發生 FileNotFoundError? // 檔案不存在時進入 except  \n            Yes → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,3,5,1,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 3, 5, 1, 5]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 執行讀取到的程式碼\n    exec(code)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code with explanations. The user request: use random module, function roll_dice(n) simulate n rolls of a six-sided die and return list of results. So we produce virtual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Provide function start and end. Use pseudocode: Import random, define function, create list, loop, append random int 1-6, return list. End. Need to adhere to format.\n\nLet's produce:\n\nStart\n→ Import random // 引入 random 模組\n→ Function roll_dice(n): // 定義 roll_dice 函式，參數 n 為擲骰次數\n→     Initialize results ← empty list // 用於存放每一次擲骰結果\n→     Decision: if n <= 0? // 檢查擲骰次數是否有效\n        Yes → Return results // 無效時直接回傳空列表\n        No  →\n→         For i from 1 to n: // 迴圈 n 次\n→             roll ← random.randint(1, 6) // 產生 1-6 的隨機整數\n→             Append roll to results // 將擲骰結果加入列表\n→     Return results // 迴圈結束後回傳所有結果\nEnd\n\nMake sure each line ends with // 解釋. Use proper arrows.\n\nWe must produce step-by-step. Ensure no actual code. Use pseudo-code, but no actual code. The arrow for function start may use \"→ Function roll_dice(n):\" It's fine. We need \"Start\" and \"End\". Use Decision lines with Yes→ and No→. Provide correct indentation via arrow or indentation? Use arrow for nested lines as in example. We can indent with arrow but no code block.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 引入 random 模組  \n→ Function roll_dice(n): // 定義 roll_dice 函式，參數 n 為擲骰次數  \n→     Initialize results ← empty list // 用於存放每一次擲骰結果  \n→     Decision: n <= 0? // 檢查擲骰次數是否為非正整數  \n→         Yes → Return results // 無效次數時直接回傳空列表  \n→         No  →  \n→             For i from 1 to n: // 迴圈 n 次，模擬擲骰  \n→                 roll ← random.randint(1, 6) // 產生 1 到 6 的隨機整數  \n→                 Append roll to results // 將擲骰結果加入列表  \n→     Return results // 迴圈結束後回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間，回傳秒數，四捨五入到小數點 3 位。\"\"\"\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\ndef main():\n    # 讀取整個輸入（可能是 Python 程式碼）\n    code = sys.stdin.read()\n    # 建立執行環境，確保 measure_time 可用\n    exec_globals = {\n        'measure_time': measure_time,\n        'time': time,\n        '__builtins__': __builtins__,\n    }\n    exec(code, exec_globals)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with explanation. The user wants a function measure_time(func, *args) using time module. Virtual code: Start, define function, record start time, call func, record end time, compute elapsed, round to 3 decimal places, return elapsed. Maybe also return result? But requirement: measure_time(func, *args) returns time in seconds. But maybe also returns result? It says \"並回傳結果\" maybe means return the time. They didn't ask for func result. So just return elapsed. We'll produce virtual steps.\n\nUse virtual code syntax: Start, → Step 1: Import time module, etc. Use Decision? Not needed.\n\nWe need to include arrows and structure. Each line: \"虛擬碼步驟 // 解釋\". So we need to output each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 載入計時功能\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n    → Step 3: Record start_time ← time.perf_counter() // 紀錄起始時間\n    → Step 4: Execute result ← func(*args) // 執行目標函式\n    → Step 5: Record end_time ← time.perf_counter() // 紀錄結束時間\n    → Step 6: Compute elapsed ← end_time - start_time // 計算耗時\n    → Step 7: Round elapsed_time ← round(elapsed, 3) // 四捨五入到小數點三位\n    → Step 8: Return elapsed_time // 回傳測量時間\nEnd // 程式執行結束\n\nBut we need to output each line separately. Let's separate each step into its own line. For nested steps maybe indent? The sample didn't indent. They used lines with indentation for decision branches. We can simply use a new line for each nested step. Could use → Step 1: ... etc.\n\nBut each line must be \"虛擬碼步驟 // 解釋\". So we need to separate each. We'll include \"→\" for arrows. For nested steps maybe include additional arrow. We can treat all as linear.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Import time module // 載入計時功能\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: Record start_time ← time.perf_counter() // 紀錄起始時間\n→ Step 4: Execute result ← func(*args) // 執行目標函式\n→ Step 5: Record end_time ← time.perf_counter() // 紀錄結束時間\n→ Step 6: Compute elapsed ← end_time - start_time // 計算耗時\n→ Step 7: Round elapsed_time ← round(elapsed, 3) // 四捨五入到小數點三位\n→ Step 8: Return elapsed_time // 回傳測量時間\nEnd // 程式執行結束\n\nBut maybe we need to reflect function definition as a block. The sample uses \"Decision:\" etc. But not necessary. We'll keep simple.\n\nBut maybe need to reflect function body using indentation. But sample didn't show indentation. It's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 載入計時功能  \n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式  \n→ Step 3: Record start_time ← time.perf_counter() // 紀錄起始時間  \n→ Step 4: Execute result ← func(*args) // 執行目標函式  \n→ Step 5: Record end_time ← time.perf_counter() // 紀錄結束時間  \n→ Step 6: Compute elapsed ← end_time - start_time // 計算耗時  \n→ Step 7: Round elapsed_time ← round(elapsed, 3) // 四捨五入到小數點三位  \n→ Step 8: Return elapsed_time // 回傳測量時間  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"melon\",\"apple\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'melon', 'apple', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取可能的輸入（本題不需要，但依規範仍執行）\n    _ = sys.stdin.read()\n\n    # 建立集合並進行指定操作\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Format: Each line: virtual code step + space + // explanation.\n\nWe need to follow structure: Start, End, Decision if any, arrows.\n\nHere we just do sequential operations.\n\nVirtual code syntax: We can use \"Step 1: Create set\" etc. But need arrow →.\n\nWe can do:\n\nStart // 程式開始執行\n→ Step 1: Initialize fruits set with 'apple' and 'banana' // 建立集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: Output fruits // 輸出集合\nEnd // 程式執行結束\n\nWe can use \"→\" before each step. The format \"Step X:\" might not be required but okay.\n\nMake sure each line ends with // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize fruits set with 'apple' and 'banana' // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋出錯誤）  \n→ Step 6: Output fruits // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.60TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.60 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"從匯率 API 取得美元對台幣的匯率。若失敗回傳 None。\"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef format_rate(rate):\n    \"\"\"根據取得的匯率產生顯示字串。\"\"\"\n    if rate is None:\n        return \"更新失敗，請檢查網路連線\"\n    return f\"目前美元匯率：約 {rate:.2f} TWD\"\n\ndef start_gui():\n    \"\"\"啟動 tkinter GUI，並允許使用者手動更新匯率。\"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update_rate():\n        rate = fetch_rate()\n        label.config(text=format_rate(rate))\n\n    button = tk.Button(win, text=\"更新匯率\", command=update_rate)\n    button.pack(pady=5)\n\n    win.mainloop()\n\ndef main():\n    \"\"\"\n    若有輸入 (非 tty)，則讀取指令並輸出結果；否則啟動 GUI。\n    \"\"\"\n    if not sys.stdin.isatty():\n        # 讀取整個 stdin，去除首尾空白\n        command = sys.stdin.read().strip()\n        if command == \"按下「更新匯率」按鈕\":\n            rate = fetch_rate()\n            print(format_rate(rate))\n    else:\n        start_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation, no actual code. Should use virtual code syntax: Start, End, Decision:, arrow \"→\", \"Yes →\", \"No →\". Provide steps to import requests, define function fetch_rate, create tkinter window, button callback to update. Use virtual code.\n\nBe careful: each line must be \"虛擬碼步驟 // 解釋\". Use Chinese explanation. The virtual code lines should be sequential, with arrows. Should include decision for network error? Possibly. Let's include Decision to check if request successful. Use Yes/No arrow.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Import 'requests' 模組 // 導入 HTTP 請求模組\n→ Import 'tkinter' 模組 // 導入圖形介面模組\n→ Define Function: fetch_exchange_rate // 定義獲取匯率的函式\n    → Step: 送出 GET 請求到 https://api.exchangerate-api.com/v4/latest/USD // 向 API 發送請求\n    → Decision: 如果回傳碼為 200? // 檢查 HTTP 回應是否成功\n        Yes → Step: 解析 JSON 並取得 TWD 匯率 // 解析回應並提取台幣匯率\n        No  → Step: 回傳 None 並顯示錯誤訊息 // 失敗時返回空值\n→ Create Tkinter Window // 建立視窗\n    → Step: 建立標籤顯示匯率 // 標籤用於顯示匯率資訊\n    → Step: 建立更新按鈕 // 按鈕觸發匯率更新\n→ 定義 Button Callback: update_rate // 按鈕回調函式\n    → Step: 呼叫 fetch_exchange_rate() // 取得最新匯率\n    → Decision: 如果取得值不為 None? // 檢查是否成功取得\n        Yes → Step: 更新標籤文字為 'USD/TWD: {rate}' // 顯示新匯率\n        No  → Step: 更新標籤文字為 '無法取得匯率' // 顯示錯誤\n→ Start Tkinter 主迴圈 // 進入事件驅動循環\nEnd // 程式執行結束\n\nNeed to ensure each line follows format: \"虛擬碼步驟 // 解釋\". Use arrow or decision properly.\n\nLet's structure:\n\nStart // 程式開始執行\n→ Import 'requests' 模組 // 導入 HTTP 請求模組\n→ Import 'tkinter' 模組 // 導入圖形介面模組\n→ Define Function: fetch_exchange_rate // 定義函式以取得匯率\n    → Step: 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 向 API 發送請求\n    → Decision: 如果回傳碼為 200? // 檢查 HTTP 回應是否成功\n        Yes → Step: 解析 JSON 並提取 TWD 匯率 // 解析回應並取得台幣匯率\n        No  → Step: 回傳 None 並顯示錯誤訊息 // 失敗時返回 None\n→ 建立 Tkinter 視窗 // 建立主視窗\n    → Step: 建立 Label 控件顯示匯率 // 用於顯示匯率文字\n    → Step: 建立 Button 控件觸發更新 // 用於更新匯率\n→ 定義 Button 事件回調: update_rate // 按鈕按下時的函式\n    → Step: 呼叫 fetch_exchange_rate() // 取得最新匯率\n    → Decision: 如果匯率值不為 None? // 檢查取得是否成功\n        Yes → Step: 更新 Label 文字為 'USD/TWD: {rate}' // 顯示最新匯率\n        No  → Step: 更新 Label 文字為 '無法取得匯率' // 顯示錯誤\n→ 啟動 Tkinter 主迴圈 // 進入 GUI 事件循環\nEnd // 程式執行結束\n\nThis is fine. Let's output lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import 'requests' 模組 // 導入 HTTP 請求模組  \n→ Import 'tkinter' 模組 // 導入圖形介面模組  \n→ Define Function: fetch_exchange_rate // 定義取得匯率的函式  \n    → Step: 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 向 API 發送請求  \n    → Decision: 如果回傳碼為 200? // 檢查 HTTP 回應是否成功  \n        Yes → Step: 解析 JSON 並提取 TWD 匯率 // 解析回應並取得台幣匯率  \n        No  → Step: 回傳 None 並顯示錯誤訊息 // 失敗時返回 None  \n→ 建立 Tkinter 視窗 // 建立主視窗  \n    → Step: 建立 Label 控件顯示匯率 // 用於顯示匯率文字  \n    → Step: 建立 Button 控件觸發更新 // 用於更新匯率  \n→ 定義 Button 事件回調: update_rate // 按鈕按下時的函式  \n    → Step: 呼叫 fetch_exchange_rate() // 取得最新匯率  \n    → Decision: 如果匯率值不為 None? // 檢查取得是否成功  \n        Yes → Step: 更新 Label 文字為 'USD/TWD: {rate}' // 顯示最新匯率  \n        No  → Step: 更新 Label 文字為 '無法取得匯率' // 顯示錯誤  \n→ 啟動 Tkinter 主迴圈 // 進入 GUI 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[0,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [0, 0], [2, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        \"\"\"\n        初始化 m x n 的二進位矩陣\n        透過「映射」方式將可用的格子索引存於 dict，避免重複\n        \"\"\"\n        self.m = m\n        self.n = n\n        self.total = m * n          # 剩餘未翻轉的格子數\n        self.map = {}               # 索引映射：r -> 可用的最後一個索引\n\n    def flip(self):\n        \"\"\"\n        隨機挑選一個還未被翻轉的格子，翻轉為 1 並回傳其座標\n        \"\"\"\n        if self.total == 0:\n            # 所有格子已翻轉，返回 None（或可根據需求拋例外）\n            return None\n\n        # 1. 在剩餘範圍內隨機取一個索引\n        r = random.randint(0, self.total - 1)\n\n        # 2. 取得實際對應的索引（若已映射則使用映射值）\n        idx = self.map.get(r, r)\n\n        # 3. 取得最後一個可用索引\n        last = self.total - 1\n        last_idx = self.map.get(last, last)\n\n        # 4. 將 r 映射到 last_idx，確保未來不會再次被挑到\n        self.map[r] = last_idx\n\n        # 5. 剩餘格子數減 1\n        self.total -= 1\n\n        # 6. 將一次維度索引轉回 (i, j) 形式回傳\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        \"\"\"\n        重置矩陣，所有格子再次為 0\n        \"\"\"\n        self.total = self.m * self.n\n        self.map.clear()\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入，假設格式為 \"commands, params\"\n    # 透過 ast.literal_eval 包裝成 tuple 方便解析\n    commands, params = ast.literal_eval('(' + data + ')')\n\n    result = []\n    obj = None\n\n    for cmd, param in zip(commands, params):\n        if cmd == \"Solution\":\n            obj = Solution(param[0], param[1])\n            result.append(None)\n        elif cmd == \"flip\":\n            res = obj.flip()\n            result.append(res)\n        elif cmd == \"reset\":\n            obj.reset()\n            result.append(None)\n        else:\n            # 若出現未知命令，可忽略或處理\n            result.append(None)\n\n    # 使用 json.dumps 讓 None 轉為 null，符合題目輸出格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to generate virtual code step-by-step for algorithm to pick random zero, flip to one, and reset, with minimal random calls, optimize time/space. We need to produce virtual code lines with explanation. Use arrow, Decision, etc. The algorithm: Use reservoir like mapping technique. Represent matrix as flat indices 0..m*n-1. Maintain map of available indices: use dictionary mapping from chosen index to the last available index. Each flip: pick random integer from [0, remaining-1], let idx = random. If map contains idx, get mapped = map[idx]; else mapped=idx. Similarly get lastIndex = remaining-1; if map contains lastIndex, last = map[lastIndex]; else last = lastIndex. Then set map[idx] = last; decrement remaining. Return (idx//n, idx % n). Reset: clear map, set remaining = m*n.\n\nWe need to produce virtual code line by line with explanations. Let's create the pseudocode.\n\nLines:\n\nStart\n→ Step: Initialize Solution(m, n) // store m,n, total=mn, remaining=total, map empty\n→ Decision: None\n→ Step: flip() // returns random zero and flips\n    // Inside flip: if remaining==0? maybe error\n    → Step: r = random(0, remaining-1) // pick random index among remaining\n    → Decision: map contains r? // check mapping\n        Yes → idx = map[r]\n        No  → idx = r\n    → Step: last = remaining-1\n    → Decision: map contains last?\n        Yes → lastIdx = map[last]\n        No  → lastIdx = last\n    → Step: map[r] = lastIdx // update mapping to swap\n    → Step: remaining -=1 // one less available\n    → Step: return [idx//n, idx % n] // convert to (i,j)\n→ Step: reset() // reset map, remaining\n    → Step: map.clear()\n    → Step: remaining = total\nEnd\n\nBut we need each line with arrow. Let's produce. Use arrows only for start and steps. Use Decision: lines. Provide explanation after //.\n\nLet's produce lines exactly as requested.\n\nWe need each line with \"虛擬碼步驟\" and explanation. Should use arrow arrow. We'll produce.\n\nAlso need to include \"Start\" and \"End\". The arrow lines start with \"→\". For Decision we indent inside? Might show arrow and indentation.\n\nExample from spec: \n```\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\nEnd // 程式執行結束\n```\nSo we should follow that style. Use indentation spaces to show hierarchy.\n\nWe'll generate.\n...done thinking.\n\nStart // 程式開始執行  \n\n→ Step 1: Initialize Solution(m, n) // 儲存矩陣尺寸 m, n，計算總格數 total = m * n，剩餘可選格數 remaining = total，建立空映射 map  \n\n→ Decision: flip() 被呼叫? // 判斷是否需要隨機挑選並翻轉  \n\n&nbsp;&nbsp;Yes → Step 2: 如果 remaining == 0? // 若所有格已被翻轉，直接返回空或錯誤  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 3: 返回空 // 所有格已被翻轉，無可選格  \n\n&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 4: r = random(0, remaining - 1) // 產生一個在剩餘可選範圍內的隨機索引  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Decision: map 是否包含 r? // 檢查是否已經映射到最後一個可用索引  \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: idx = map[r] // 取得實際的格子索引  \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: idx = r // 直接使用 r 作為格子索引  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Step 7: last = remaining - 1 // 最後一個可用格子索引  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Decision: map 是否包含 last? // 檢查最後一個格子是否已被映射  \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 8: lastIdx = map[last] // 取得實際的最後一個格子索引  \n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: lastIdx = last // 直接使用 last 作為最後一個格子索引  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Step 10: map[r] = lastIdx // 用 lastIdx 取代 r，確保未來的隨機選擇不重複  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Step 11: remaining -= 1 // 已翻轉一格，剩餘可選格數減一  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Step 12: return [idx // n, idx % n] // 將一次維度索引轉回 (i, j)  \n\n&nbsp;&nbsp;No  → Step 13: reset() 被呼叫? // 判斷是否需要重置矩陣  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 14: map.clear() // 清空映射，恢復所有格子為 0  \n\n&nbsp;&nbsp;&nbsp;&nbsp;Step 15: remaining = total // 將剩餘可選格數重設為全部格子數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Repeating Character Replacement",
      "source_file": "Leetcode/leetcode424.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppk1glyet.py\", line 35, in <module>\n    k = int(data[1])\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdazj_ep6.py\", line 35, in <module>\n    k = int(data[1])\n        ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        # 26 個大寫英文字母的頻率表\n        count = [0] * 26\n        max_count = 0  # 當前窗口中最高頻字元的頻次\n        left = 0\n        res = 0\n\n        for right, ch in enumerate(s):\n            idx = ord(ch) - ord('A')\n            count[idx] += 1\n            # 更新最高頻字元的頻次\n            if count[idx] > max_count:\n                max_count = count[idx]\n\n            # 若需要改動的字元數超過 k，縮小窗口\n            while (right - left + 1) - max_count > k:\n                left_idx = ord(s[left]) - ord('A')\n                count[left_idx] -= 1\n                left += 1\n\n            # 更新答案\n            current_len = right - left + 1\n            if current_len > res:\n                res = current_len\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if len(data) >= 2:\n        s = data[0]\n        k = int(data[1])\n    else:\n        s = \"\"\n        k = 0\n    solution = Solution()\n    print(solution.characterReplacement(s, k))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: given string s and integer k, we can change up to k characters to any uppercase letter. Return length of longest substring containing same letter after operations. Classic problem: longest repeating character replacement. Sliding window.\n\nWe need to output steps line by line with comments. Use Start, End, Decision: etc. The steps need to cover algorithm: maintain window [left,right], track frequency, maxFreq; when window size - maxFreq > k, shrink left. Keep track of best. Provide explanation. Must use virtual code with arrows. Each line: \"→ Step X: ...\" etc. We can break into steps: read inputs, initialize variables, loop over right, update count, update maxFreq, check condition, if invalid shrink, update best, after loop return best. End. Use Decision: etc.\n\nWe need to include \"Start\" and \"End\". Use arrow \"→\" for steps. Use Decision lines for condition checks. Provide comments in Chinese. The code should be structured.\n\nLet's produce maybe 15 lines. Use incremental step numbering. Provide decisions inside loop. Use \"Yes →\" \"No →\" as needed.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s 與整數 k // 取得問題參數  \n→ Step 2: 設定 left ← 0, maxLen ← 0, maxFreq ← 0, freq[26] ← 0 // 初始化滑動窗口與統計  \n→ Step 3: 從 right = 0 到 right < s.length() 進行迴圈 // 遍歷字串  \n    → Step 3.1: let idx ← s[right] 的字母索引 // 取得當前字元對應的頻率索引  \n    → Step 3.2: freq[idx] ← freq[idx] + 1 // 更新頻率表  \n    → Step 3.3: maxFreq ← max(maxFreq, freq[idx]) // 更新窗口中最高頻字元的頻次  \n    → Decision: 如果 right - left + 1 - maxFreq > k? // 檢查是否需要縮小窗口  \n        Yes → Step 3.4: let idxLeft ← s[left] 的字母索引 // 取得左端字元索引  \n            → Step 3.4.1: freq[idxLeft] ← freq[idxLeft] - 1 // 移除左端字元的頻次  \n            → Step 3.4.2: left ← left + 1 // 左指標右移，縮小窗口  \n        No → // 窗口合法，無需調整  \n    → Step 3.5: maxLen ← max(maxLen, right - left + 1) // 更新最大子字串長度  \n→ Step 4: 回傳 maxLen // 輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpugp_f_ma.py\", line 52, in <module>\n    k, w, profits, capital = parse_input(raw)\n                             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpugp_f_ma.py\", line 46, in parse_input\n    data[key] = int(value)\n                ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2ivt5e85.py\", line 52, in <module>\n    k, w, profits, capital = parse_input(raw)\n                             ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2ivt5e85.py\", line 46, in parse_input\n    data[key] = int(value)\n                ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport heapq\n\ndef find_maximized_capital(k, w, profits, capital):\n    \"\"\"\n    對於給定的 k、初始資本 w、利潤列表 profits 以及資本需求列表 capital，\n    以貪心策略挑選最多 k 個專案，使最終資本最大化。\n    \"\"\"\n    # 先把每個專案的 (資本需求, 利潤) 以元組方式打包\n    projects = sorted(zip(capital, profits), key=lambda x: x[0])\n\n    max_heap = []          # 儲存已經可負擔專案的利潤（最大堆）\n    i = 0                  # 指向下個還未考慮的專案\n    n = len(projects)\n\n    for _ in range(k):\n        # 把所有現在可負擔的專案都塞進最大堆\n        while i < n and projects[i][0] <= w:\n            heapq.heappush(max_heap, -projects[i][1])  # 用負數模擬最大堆\n            i += 1\n\n        # 若堆裡沒有專案可選，直接結束\n        if not max_heap:\n            break\n\n        # 從堆裡拿到最利潤最高的專案，完成後把利潤加回資本\n        w += -heapq.heappop(max_heap)\n\n    return w\n\n\ndef parse_input(raw_input):\n    \"\"\"\n    從輸入字串中解析出 k、w、profits、capital 四個參數。\n    解析方式：以逗號分隔，對每個 key=value 進行拆解。\n    \"\"\"\n    pattern = re.compile(r'(\\w+)\\s*=\\s*(.*?)(?:,|$)')\n    data = {}\n    for key, value in pattern.findall(raw_input):\n        value = value.strip()\n        if value.startswith('[') and value.endswith(']'):\n            # 把字串轉成 list，使用 eval 方便解析整數列表\n            data[key] = eval(value)\n        else:\n            data[key] = int(value)\n    return data['k'], data['w'], data['profits'], data['capital']\n\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    k, w, profits, capital = parse_input(raw)\n    result = find_maximized_capital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanation. The problem is classic: choose at most k projects with profits and capital requirements to maximize capital. Greedy with priority queues: sort projects by required capital ascending, then maintain max-heap of profits of affordable projects. Iterate k times: add all projects with capital <= current capital into heap, then if heap empty break else pop max profit, add to capital. Return capital. Need virtual steps.\n\nWe must produce lines like:\n\nStart\n→ Step 1: Sort projects by capital ascending // etc\n\nInclude Decision steps.\n\nLet's produce a step-by-step algorithm in virtual code.\n\nWe must use Start, End, Decision: etc.\n\nLet's create:\n\nStart\n→ Step 1: Create array of pairs (capital[i], profits[i]) // combine inputs\n→ Step 2: Sort array by capital ascending // easier to pick projects\n\nThen we need variables: idx = 0; heap = empty max-heap; currentCapital = w;\n\nThen loop from 1 to k:\n\n→ Decision: k > 0? But we can do for i in 1..k.\n\nUse Decision inside loop: while idx < n and array[idx].capital <= currentCapital → push profits to heap; idx++\n\nAfter adding, Decision: heap not empty? Yes → pop maxProfit, add to currentCapital, continue; No → break loop.\n\nFinally End with result.\n\nNeed to produce each line with explanation.\n\nWe must keep arrow formatting. Use \"→\" arrow.\n\nAlso use indentation for decisions.\n\nLet's produce.\n\nWe need to keep code simple: Use pseudo like \"for i = 1 to k\".\n\nUse \"Decision:\".\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個 (capital, profit) 對陣列 projects // 將輸入的兩個陣列合併成一個可排序的資料結構  \n→ Step 2: 將 projects 按照 capital 從小到大排序 // 方便後續逐步挑選可執行的專案  \n→ Step 3: 初始化 idx = 0, currentCapital = w, profitHeap = 空最大堆 // idx 指向下一個未考慮的專案，heap 用來存放已可負擔專案的利潤  \n→ Step 4: 迴圈 i = 1 到 k // 至多執行 k 次專案  \n  Decision: idx < n 且 projects[idx].capital ≤ currentCapital? // 是否還有尚未考慮且能夠負擔的專案？  \n   Yes → Step 5: 將 projects[idx].profit 加入 profitHeap // 把可負擔專案的利潤加入堆中"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        # Count how many left and right parentheses need to be removed\n        l_remove, r_remove = 0, 0\n        for ch in s:\n            if ch == '(':\n                l_remove += 1\n            elif ch == ')':\n                if l_remove > 0:\n                    l_remove -= 1\n                else:\n                    r_remove += 1\n\n        result = set()\n\n        def dfs(idx, l_cnt, r_cnt, l_rem, r_rem, path):\n            if idx == len(s):\n                if l_rem == 0 and r_rem == 0:\n                    result.add(path)\n                return\n            ch = s[idx]\n            if ch == '(':\n                # Option 1: remove this '(' if we still need to remove\n                if l_rem > 0:\n                    dfs(idx + 1, l_cnt, r_cnt, l_rem - 1, r_rem, path)\n                # Option 2: keep this '('\n                dfs(idx + 1, l_cnt + 1, r_cnt, l_rem, r_rem, path + ch)\n            elif ch == ')':\n                # Option 1: remove this ')' if we still need to remove\n                if r_rem > 0:\n                    dfs(idx + 1, l_cnt, r_cnt, l_rem, r_rem - 1, path)\n                # Option 2: keep this ')' only if it doesn't make string invalid\n                if l_cnt > r_cnt:\n                    dfs(idx + 1, l_cnt, r_cnt + 1, l_rem, r_rem, path + ch)\n            else:\n                # Keep letters unchanged\n                dfs(idx + 1, l_cnt, r_cnt, l_rem, r_rem, path + ch)\n\n        dfs(0, 0, 0, l_remove, r_remove, \"\")\n        return list(result)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first quoted string if present; otherwise use the raw data\n    match = re.search(r'\"(.*?)\"', data)\n    s = match.group(1) if match else data\n    sol = Solution()\n    ans = sol.removeInvalidParentheses(s)\n    print(json.dumps(ans))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The problem: \"Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return a list of unique strings that are valid with the minimum number of removals.\"\n\nWe should produce a step-by-step pseudocode, using the defined format: Each line: \"虛擬碼步驟 // 解釋\". Use arrows: \"→\", \"Yes →\", \"No →\". Start, End, Decision:.\n\nGoal: generate pseudo-code for removing invalid parentheses with minimal removals and output unique valid strings. Approach: BFS or DFS with pruning. Common solution: count number of left and right to remove; then backtrack to generate all possibilities, skipping duplicates via a set.\n\nWe'll create steps:\n\nStart: compute removals of left and right\n→ Step: Count removals: initialize l_remove, r_remove\n→ Step: For each char in s: if '(' increment l_remove else if ')' then if l_remove>0 decrement else r_remove++\n→ Step: Initialize result set\n→ Step: DFS function dfs(index, l_count, r_count, l_remove, r_remove, path)\n→ Decision: If index == len(s)\n    Yes → If l_remove==0 and r_remove==0 → Add path to result set\n    No → (ignore)\n→ Step: char = s[index]\n→ Decision: If char is '('\n    Yes → // 1. remove it\n          → If l_remove>0 → dfs(index+1, l_count, r_count, l_remove-1, r_remove, path)\n    No\n    Yes → // 2. keep it\n          → dfs(index+1, l_count+1, r_count, l_remove, r_remove, path+'(')\n→ Decision: If char is ')'\n    Yes → // 1. remove it\n          → If r_remove>0 → dfs(index+1, l_count, r_count, l_remove, r_remove-1, path)\n    No\n    Yes → // 2. keep it if l_count > r_count\n          → If l_count > r_count → dfs(index+1, l_count, r_count+1, l_remove, r_remove, path+')')\n→ Decision: If char is letter\n    Yes → // keep it\n          → dfs(index+1, l_count, r_count, l_remove, r_remove, path+char)\n→ End // after DFS call from Start\n→ Step: Return list(result set)\n\nAlso add handling to avoid duplicate branches: but set will handle.\n\nLet's format each line. Use \"→\" for normal steps. Use \"Decision:\" for decisions with Yes/No branches.\n\nEnsure each line ends with // explanation. Use \"虛擬碼步驟\" placeholder.\n\nWe should not output actual code; but \"虛擬碼步驟\" can be like \"Step 1: ...\". But the requirement: \"虛擬碼步驟 + [空格] + // 解釋/說明\".\n\nAlso need arrow \"→\" and structure \"Start\", \"End\", \"Decision:\".\n\nSo first line: \"Start // 程式開始執行\"\n\nThen steps.\n\nLet's produce lines accordingly.\n\nLet's start:\n\nStart // 程式開始執行\n→ Step 1: 初始化 l_remove, r_remove 為 0 // 計算需要移除的左右括號數量\n→ Step 2: 從左到右遍歷字符串 s\n→ Decision: 如果當前字符為 '('? // 需要決定如何更新左括號移除計數\n    Yes → l_remove++ // 當前左括號視為可能需要移除\n    No  → Decision: 如果當前字符為 ')'?\n        Yes → 如果 l_remove > 0 → l_remove-- // 匹配到已計算的左括號，減少需要移除數\n        No  → r_remove++ // 右括號無法匹配，需要移除\n→ Step 3: 初始化結果集合 resultSet 為空 // 用於存放唯一的合法字符串\n→ Step 4: 定義遞迴函式 dfs(index, l_count, r_count, l_remove, r_remove, path) // 回溯生成所有合法字符串\n→ Step 5: 若 index == len(s) // 到達字符串結尾\n    Yes → Decision: l_remove==0 且 r_remove==0?\n        Yes → resultSet.add(path) // 只有在所有括號都已移除完畢時才加入結果\n        No  → // 不是最小移除情況，忽略\n→ Step 6: char = s[index] // 取得當前字符\n→ Decision: char 為 '('?\n    Yes → // 選擇不保留左括號\n        → Decision: l_remove > 0?\n            Yes → dfs(index+1, l_count, r_count, l_remove-1, r_remove, path)\n            No  → // 無法移除，跳過此分支\n    No  → // 留下左括號\n        → dfs(index+1, l_count+1, r_count, l_remove, r_remove, path + '(')\n→ Decision: char 為 ')'?\n    Yes → // 選擇不保留右括號\n        → Decision: r_remove > 0?\n            Yes → dfs(index+1, l_count, r_count, l_remove, r_remove-1, path)\n            No  → // 無法移除，跳過此分支\n    No  → // 留下右括號，但需確保左括號多於右括號\n        → Decision: l_count > r_count?\n            Yes → dfs(index+1, l_count, r_count+1, l_remove, r_remove, path + ')')\n            No  → // 右括號多於左括號，無法保留，跳過\n→ Decision: char 為字母?\n    Yes → // 字母始終保留\n        → dfs(index+1, l_count, r_count, l_remove, r_remove, path + char)\n→ End // 所有遞迴完成\n→ Step 7: 返回 resultSet 作為列表 // 最終結果為所有唯一合法字符串\n\nWe might adjust arrow formatting: Use \"→\" before each step. Decision: lines with Yes → etc. We need to be careful: we must use \"Decision:\" for decisions. Provide indentations? Not necessary.\n\nWe should ensure each line contains \"虛擬碼步驟\" phrase? The spec says \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So we need actual \"虛擬碼步驟\" content, not generic. Eg: \"Start // 程式開始執行\" is okay. Use \"Step 1: ...\". Provide arrow at beginning. Eg: \"→ Step 1: ...\". That is acceptable.\n\nLet's produce final answer accordingly. Ensure no extra spaces. Provide each line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 l_remove, r_remove 為 0 // 計算需要移除的左右括號數量  \n→ Step 2: 從左到右遍歷字符串 s  \n→ Decision: 如果當前字符為 '('? // 判斷左括號  \n Yes → l_remove++ // 暫時視為可能需要移除  \n No → Decision: 如果當前字符為 ')'? // 判斷右括號  \n  Yes → Decision: l_remove > 0?  \n   Yes → l_remove-- // 匹配到左括號，減少需要移除數  \n   No → r_remove++ // 無法匹配，右括號需要移除  \n→ Step 3: 初始化結果集合 resultSet 為空 // 用於存放唯一合法字符串  \n→ Step 4: 定義遞迴函式 dfs(index, l_count, r_count, l_remove, r_remove, path) // 回溯生成所有合法字符串  \n→ Step 5: 若 index == len(s) // 到達字符串結尾  \n Yes → Decision: l_remove == 0 且 r_remove == 0? // 是否已完成最小移除  \n  Yes → resultSet.add(path) // 加入合法結果  \n  No → // 非最小移除，忽略此路徑  \n→ Step 6: char = s[index] // 取得當前字符  \n→ Decision: char 為 '('?  \n Yes → // 選擇不保留左括號  \n  → Decision: l_remove > 0?  \n   Yes → dfs(index+1, l_count, r_count, l_remove-1, r_remove, path)  \n   No → // 無法移除，跳過此分支  \n No → // 留下左括號  \n  → dfs(index+1, l_count+1, r_count, l_remove, r_remove, path + '(')  \n→ Decision: char 為 ')'?  \n Yes → // 選擇不保留右括號  \n  → Decision: r_remove > 0?  \n   Yes → dfs(index+1, l_count, r_count, l_remove, r_remove-1, path)  \n   No → // 無法移除，跳過此分支  \n No → // 留下右括號，但需確保左括號多於右括號  \n  → Decision: l_count > r_count?  \n   Yes → dfs(index+1, l_count, r_count+1, l_remove, r_remove, path + ')')  \n   No → // 右括號多於左括號，無法保留，跳過  \n→ Decision: char 為字母?  \n Yes → // 字母始終保留  \n  → dfs(index+1, l_count, r_count, l_remove, r_remove, path + char)  \n→ End // 所有遞迴完成  \n→ Step 7: 返回 resultSet 作為列表 // 最終結果為所有唯一合法字符串"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfumlb5a7.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpfumlb5a7.py\", line 45, in main\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfumlb5a7.py\", line 39, in parse_input\n    return ast.literal_eval(data)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x719058926c90>"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyjbcpijo.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpyjbcpijo.py\", line 45, in main\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpyjbcpijo.py\", line 39, in parse_input\n    return ast.literal_eval(data)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7c9bed926c90>"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\ndef k_smallest_pairs(nums1, nums2, k):\n    \"\"\"Return k pairs with the smallest sums from two sorted arrays.\"\"\"\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    heap = []          # min-heap: (sum, index in nums1, index in nums2)\n    result = []\n\n    # Initialize heap with pairs (nums1[i], nums2[0]) for i in first k elements\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n    # Extract k smallest pairs\n    while heap and len(result) < k:\n        s, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n\n        # If there is a next element in nums2 for the same i, push it\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n    'nums1 = [1,7,11], nums2 = [2,4,6], k = 3'\n    into Python objects.\n    \"\"\"\n    # Replace '=' with ':' to make a valid dict string\n    data = data.replace('=', ':')\n    # Wrap in braces to form a dict\n    data = '{' + data + '}'\n    # Safely evaluate\n    return ast.literal_eval(data)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    params = parse_input(raw_input)\n    nums1 = params.get('nums1', [])\n    nums2 = params.get('nums2', [])\n    k = params.get('k', 0)\n    pairs = k_smallest_pairs(nums1, nums2, k)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, not actual code. Problem: find k smallest sum pairs from two sorted arrays. Usually solution uses min-heap. Steps: initialize heap with pairs of first element of nums1 and each of nums2? Actually standard: push (nums1[0]+nums2[i], 0, i). Use heap to pop smallest, push next element in nums1 for same i.\n\nWe'll produce steps accordingly.\n\nLet's outline steps:\n\nStart\n→ Initialize min-heap // create priority queue\n→ For i from 0 to min(k, len(nums2))-1: // push initial pairs\n    → Insert (nums1[0] + nums2[i], 0, i) into heap // store sum and indices\n→ Initialize result list // empty\n→ While result length < k and heap not empty:\n    → Decision: pop smallest from heap? Actually need to pop top\n    → Pop top entry (sum, i1, i2) // get smallest sum pair\n    → Append (nums1[i1], nums2[i2]) to result\n    → Decision: if i1 + 1 < len(nums1):\n        Yes → Insert (nums1[i1+1] + nums2[i2], i1+1, i2) into heap // next in nums1\n        No  → do nothing\n→ End // output result\n\nAdd comments accordingly.\n\nMake sure each line with // explanation.\n\nInclude arrow lines appropriately.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize min-heap // 建立優先佇列，以存放目前最小總和的元組  \n→ Decision: 先把 nums2 的前 k 個元素與 nums1 的第一個元素組成對，放進 heap  \n    Yes → For i from 0 to min(k, length(nums2))-1: // 只需前 k 個，避免過大  \n        → Insert (nums1[0] + nums2[i], 0, i) into heap // sum, index 在 nums1, index 在 nums2  \n→ Initialize result list // 用來收集最小的 k 個 (u, v)  \n→ Decision: while len(result) < k and heap not empty: // 需要找 k 個或 heap 空了  \n    Yes → Pop (sum, idx1, idx2) from heap // 取出目前最小總和的對  \n        → Append (nums1[idx1], nums2[idx2]) to result // 儲存對  \n        → Decision: if idx1 + 1 < length(nums1): // nums1 還有下一個元素  \n            Yes → Insert (nums1[idx1+1] + nums2[idx2], idx1+1, idx2) into heap // 推入新對  \n            No  → Do nothing // 這條路線已經到達 nums1 最後  \n→ End // 程式執行結束，result 即為所需的 k 個最小總和對"
    },
    {
      "title": "Evaluate Reverse Polish Notation",
      "source_file": "Leetcode/leetcode150.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpybt4pheb.py\", line 29, in <module>\n    data = eval(raw_input)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n           ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprupbw25e.py\", line 29, in <module>\n    data = eval(raw_input)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\n           ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1crtnk62.py\", line 29, in <module>\n    data = eval(raw_input)\n           ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\n           ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                elif token == '/':\n                    # 整數除法，向零取整\n                    stack.append(int(a / b) if a * b >= 0 else - (abs(a) // abs(b)))\n            else:\n                stack.append(int(token))\n        return stack[-1]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 解析輸入：期望類似 tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\n    # 先利用 eval 取得 dict，然後取 tokens 列表\n    data = eval(raw_input)\n    tokens = data['tokens']\n    result = Solution().evalRPN(tokens)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for evaluating RPN tokens array. Provide steps with Start, Decision, etc. Each line: \"Step X: ...\" with arrow. We need to output in Traditional Chinese. Provide explanation comments.\n\nLet's design algorithm: use stack. Iterate tokens. For each token: if token is operator: pop two operands (b then a), compute result (a op b), push. else push integer. After loop, stack top is result. Return.\n\nWe need to use virtual code with arrow and decisions. Show steps:\n\nStart\n→ Step 1: 初始化一個空堆疊 stack // 準備存放操作數\n→ For each token in tokens: // 逐一處理 RPN 元素\n    → Step 2: 讀取 token\n    → Decision: token 是操作符? // 判斷是否為 '+', '-', '*', '/'\n        Yes →\n            → Step 3: 從 stack 弹出 operand2 // 先取出右操作數\n            → Step 4: 再弹出 operand1 // 再取出左操作數\n            → Step 5: 計算 operand1 token operand2 // 進行算術運算\n            → Step 6: 將結果推回 stack // 存回結果\n        No →\n            → Step 7: 將 token 轉成整數並推回 stack // 存儲操作數\n→ Step 8: 從 stack 弹出最終結果 // 得到整體表達式值\nEnd // 完成\n\nWe need each line with arrow, and after space // explanation.\n\nLet's produce each line accordingly.\n\nWe should use arrow \"→\" preceding each step. For decisions use \"Decision:\" and indentation with Yes →, No → lines.\n\nLet's ensure each line separate. Use indentation for Yes/No. Provide Chinese explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 stack // 準備存放操作數  \n→ For each token in tokens: // 逐一處理 RPN 元素  \n    → Step 2: 讀取 token // 取得當前字串  \n    → Decision: token 是操作符? // 判斷是否為 '+', '-', '*', '/'  \n        Yes →  \n            → Step 3: 從 stack 弹出 operand2 // 先取右操作數  \n            → Step 4: 再弹出 operand1 // 再取左操作數  \n            → Step 5: 計算 operand1 token operand2 // 進行算術運算  \n            → Step 6: 將結果推回 stack // 存回計算結果  \n        No →  \n            → Step 7: 將 token 轉成整數並推回 stack // 存儲操作數  \n→ Step 8: 從 stack 弹出最終結果 // 得到整體表達式值  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets_with_dup(nums):\n    nums.sort()\n    res = [[]]\n    for num in nums:\n        new_subsets = []\n        for subset in res:\n            new_subsets.append(subset + [num])\n        res += new_subsets\n    unique_res = []\n    seen = set()\n    for subset in res:\n        t = tuple(subset)\n        if t not in seen:\n            seen.add(t)\n            unique_res.append(subset)\n    return unique_res\n\ndef main():\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Remove any leading/trailing text like 'nums =' and parse the list\n    # Example input: 'nums = [1,2,2]'\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    try:\n        nums = ast.literal_eval(data)\n    except Exception as e:\n        print(\"[]\")\n        return\n    if not isinstance(nums, list):\n        print(\"[]\")\n        return\n    result = subsets_with_dup(nums)\n    # Format output without spaces\n    formatted = '[' + ','.join([str(sub).replace(' ', '') for sub in result]) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for power set with duplicates handling. Use backtracking and sort array to group duplicates. Steps: Start, sort array, init result, start backtrack at index 0 with current empty subset. In backtrack, add current subset to result. Loop i from start to end: if i>start and nums[i]==nums[i-1] skip. Else include nums[i] into subset and recuse i+1. After loop, backtrack removal. End.\n\nProvide each line with \"虛擬碼步驟 // 解釋\". Use arrow style. Need to include arrows. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums // 取得輸入\n→ Step 2: 將 nums 排序 // 方便去重\n\nBut we need to use arrow and structure. Provide decisions etc.\n\nLet's produce code steps:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得輸入\n→ Step 2: 將 nums 排序 // 方便處理重複元素\n→ Step 3: 初始化結果 list res 為空 // 用於存儲所有子集\n→ Step 4: 初始化當前子集 current 為空 // 用於回溯\n→ Step 5: 呼叫 Backtrack(0) // 從索引0開始回溯\n\nThen define Backtrack function:\n\n→ Decision: 回溯函式 Backtrack(startIndex) // 進行遞迴\n    → Step: 將 current 的拷貝加入 res // 存儲當前子集\n    → For i from startIndex to nums.length-1 // 遍歷剩餘元素\n        → Decision: 如果 i>startIndex 且 nums[i]==nums[i-1]? // 檢查是否重複\n            Yes → Continue // 跳過重複元素\n            No  →\n                → Step: 將 nums[i] 加入 current // 選擇元素\n                → Step: 呼叫 Backtrack(i+1) // 遞迴\n                → Step: 移除 current 中最後一個元素 // 回溯\n\nEnd // 結束\n\nWe need to include arrow and decision indentations.\n\nLet's format accordingly.\n\nUse \"Decision:\" line and then Yes → ... No → ... indent. Use spaces.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums // 取得使用者傳入的整數陣列  \n→ Step 2: 將 nums 排序 // 方便後續處理重複元素  \n→ Step 3: 初始化結果列表 res 為空 // 用於儲存所有子集  \n→ Step 4: 初始化暫存子集 current 為空 // 用於回溯過程  \n→ Step 5: 呼叫 Backtrack(0) // 從索引 0 開始進行回溯  \n\n→ Decision: 定義回溯函式 Backtrack(startIndex) // 進行遞迴  \n    → Step: 將 current 的複本加入 res // 存儲目前子集  \n    → For i from startIndex 到 nums.length-1 // 遍歷剩餘元素  \n        → Decision: 如果 i > startIndex 且 nums[i] == nums[i-1]? // 判斷是否為重複元素  \n            Yes → Continue // 跳過重複元素  \n            No  →  \n                → Step: 把 nums[i] 加入 current // 選擇該元素  \n                → Step: 呼叫 Backtrack(i + 1) // 進一步遞迴  \n                → Step: 從 current 移除最後一個元素 // 回溯撤銷選擇  \n\nEnd // 程式執行結束，返回 res 作為所有不重複子集的集合"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    Solution class to randomly pick an index of a target number in an array.\n    The constructor builds a mapping from each number to the list of indices\n    where it occurs. The pick method then uses random.choice to return one\n    index uniformly among all indices with the target value.\n    \"\"\"\n    def __init__(self, nums):\n        # Build a dictionary mapping number -> list of indices\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        Return a random index i such that nums[i] == target.\n        \"\"\"\n        return random.choice(self.num_indices[target])\n\ndef main():\n    # Read entire stdin as a string\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # The input format is two JSON arrays separated by a comma.\n    # Wrap them into an outer list to parse with json.loads.\n    ops, args = json.loads('[' + data + ']')\n\n    result = []\n    sol = None\n\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            # arg is a list containing the nums array\n            sol = Solution(arg[0])\n            result.append(None)  # constructor returns null\n        elif op == 'pick':\n            # arg is a list containing the target value\n            res = sol.pick(arg[0])\n            result.append(res)\n\n    # Output the result list in JSON format (None -> null)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step by step for the given problem. Use arrows and decisions. Provide explanation per line.\n\nWe need to produce virtual code for solution with constructor and pick method.\n\nWe will propose: Store array, maybe store map from target to list of indices? But to handle random uniformly, we can in pick iterate through array and reservoir sample. Approach: Use reservoir sampling: iterate array, for each index where nums[i]==target, choose with probability 1/count.\n\nLet's produce steps:\n\nStart\n→ Step: Initialize Solution with nums // store array\n→ Step: pick(target) // function\n    → Step: count = 0 // count of target seen\n    → Step: result = -1 // placeholder\n    → Decision: For each index i from 0 to nums.length-1\n        Yes → If nums[i] == target\n            → Step: count = count + 1\n            → Decision: Random integer r in [1, count] // pick random\n                Yes → If r == 1\n                    → Step: result = i\n            → End if\n    → End for\n    → Step: return result\n\nWe need arrow formatting with \"→\" and \"Decision:\".\n\nAlso need to use Start and End markers.\n\nLet's produce each line. Use indentation for nested decisions. Use \"Yes →\" and \"No →\" maybe not necessary for some decisions. Provide explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 Solution( nums ) // 將傳入的陣列儲存為成員變數  \n→ Step: pick( target ) // 處理 pick 方法的執行  \n    → Step: count ← 0 // 用來記錄目前遇到的目標數值的個數  \n    → Step: result ← -1 // 預設回傳值，若找到目標則更新  \n    → Decision: 對每個索引 i 從 0 到 nums.length-1 進行迴圈? // 開始遍歷陣列  \n        Yes → Step: 如果 nums[i] == target? // 判斷當前元素是否為目標值  \n            Yes → Step: count ← count + 1 // 已經找到一個目標，計數加一  \n            → Decision: 產生隨機整數 r 在 1 到 count 之間? // 為了實現等機率選擇  \n                Yes → Decision: 如果 r == 1? // 只在隨機抽到 1 時才更新結果  \n                    Yes → Step: result ← i // 把目前索引設為候選結果  \n                    No → // r != 1 時保持現有結果  \n                No → // r 生成失敗 (理論上不會發生)  \n            → End decision  \n        No → // nums[i] 不是目標，直接跳過  \n    → End decision  \n    → Step: return result // 回傳被選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字串倒序對應索引的字典\n        rev_map = {w[::-1]: i for i, w in enumerate(words)}\n        res = []\n\n        # 判斷字串是否為回文\n        def is_pal(s: str) -> bool:\n            return s == s[::-1]\n\n        # 逐個字串檢查所有可能的切分\n        for i, word in enumerate(words):\n            L = len(word)\n            for j in range(L + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 如果前綴是回文，且後綴倒序存在\n                if is_pal(prefix):\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_map and rev_map[rev_suffix] != i:\n                        res.append([rev_map[rev_suffix], i])\n\n                # 如果後綴是回文，且切分位置不為0（避免重複）\n                if j != 0 and is_pal(suffix):\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_map and rev_map[rev_prefix] != i:\n                        res.append([i, rev_map[rev_prefix]])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        sys.exit()\n\n    # 解析輸入，支援像 \"words = [...]\" 或直接 \"[...]\"\n    if raw_input.startswith(\"words\"):\n        # 找到等號後面的內容\n        idx = raw_input.find(\"=\")\n        raw_input = raw_input[idx + 1:].strip()\n\n    try:\n        words = ast.literal_eval(raw_input)\n    except Exception:\n        # 若解析失敗，輸出空列表\n        print([])\n        sys.exit()\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode steps for algorithm solving palindrome pairs problem in O(total length). Standard approach: use a hashmap of reversed strings, check splits. Need to write virtual code lines and comments. Use Start, Decision, etc.\n\nWe'll write generic steps.\n\nLet's craft stepwise pseudocode.\n\nSteps: Build map from word to index. For each word index i, for each split position k from 0 to len(word) inclusive: prefix, suffix. If prefix palindrome then look for reversed suffix in map and not same index => add pair (revIndex, i). If suffix palindrome and k != len(word) to avoid duplicate, then reversed prefix exists => add pair (i, revIndex). Also handle empty string.\n\nEdge cases: duplicate pairs? unique words ensures.\n\nWe'll produce line per logical step.\n\nLet's craft lines.\n\nWe need to use arrow syntax:\n\nStart\n→ Step: Build reverseMap = {} // map reversed word -> index\n→ Loop over words with index i\n    → Compute reversed = reverse(word)\n    → reverseMap[reversed] = i\n→ End Loop\n\nThen find pairs:\n\n→ Step: result = []\n\n→ Loop over words with index i\n    → word = words[i]\n    → len = word.length\n    → For k from 0 to len\n        → prefix = word.slice(0, k)\n        → suffix = word.slice(k)\n        → If isPalindrome(prefix) then\n            → revSuffix = reverse(suffix)\n            → If revSuffix in reverseMap and reverseMap[revSuffix] != i\n                → result.append([reverseMap[revSuffix], i])\n        → If k != len and isPalindrome(suffix) then\n            → revPrefix = reverse(prefix)\n            → If revPrefix in reverseMap and reverseMap[revPrefix] != i\n                → result.append([i, reverseMap[revPrefix]])\n    → End For\n→ End Loop\n\nReturn result.\n\nNeed to add Decision arrows.\n\nLet's incorporate decisions: check palindrome? Use Decision.\n\nAlso we need O(total length). Loops: splits per word length => total O(total length^2)? Actually sum over splits length across all words equals sum lengths^2? Wait each word splits len+1 times. Total splits sum(len+1) = sum(len)+ n. Each split operations O(1) for palindrome check? We need palindrome check in O(1) amortized using precomputed? But typical algorithm uses O(total length^2) but there is optimization using prefix/suffix palindrome checks with caching. But we assume we can check palindrome in O(1) because we precompute? It's fine.\n\nWe'll keep it simple.\n\nAdd comment about runtime complexity.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立 reverseMap = {} // 用於快速查找字串倒序與其索引  \n→ Decision: 逐一遍歷 words 且取得 index i  \n    Yes → Step: reversed = reverse(words[i]) // 取得 words[i] 的倒序  \n    Yes → Step: reverseMap[reversed] = i // 把倒序映射到原始索引  \n    No  → End // 迴圈結束  \nEnd // reverseMap 準備完成  \n\n→ Step: result = [] // 儲存所有符合的 palindrome pair  \n→ Decision: 逐一遍歷 words 且取得 index i  \n    Yes → Step: word = words[i] // 目前處理的字串  \n    Yes → Step: len = word.length // 取得字串長度  \n    → Decision: 依序從 0 到 len 進行 split，取得 prefix 與 suffix  \n        Yes → Step: prefix = word.slice(0, k) // 取前綴  \n        Yes → Step: suffix = word.slice(k)   // 取後綴  \n        → Decision: 若 prefix 為 palindrome?  \n            Yes → Step: revSuffix = reverse(suffix) // 取 suffix 的倒序  \n            Yes → Decision: 若 revSuffix 在 reverseMap 且 reverseMap[revSuffix] ≠ i?  \n                Yes → Step: result.append([reverseMap[revSuffix], i]) // (j, i) pair  \n                No  → End // 不符合條件  \n            No  → End // prefix 不是 palindrome  \n        → Decision: 若 suffix 為 palindrome 且 k ≠ len? // 防止重複檢查整個字串  \n            Yes → Step: revPrefix = reverse(prefix) // 取 prefix 的倒序  \n            Yes → Decision: 若 revPrefix 在 reverseMap 且 reverseMap[revPrefix] ≠ i?  \n                Yes → Step: result.append([i, reverseMap[revPrefix]]) // (i, j) pair  \n                No  → End  \n            No  → End  \n    → End // split 完成  \n    No  → End // 迴圈結束  \nEnd // 所有字串處理完畢  \n\n→ Step: return result // 輸出所有 palindrome pair  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,1,false]'\nGot (Norm):      '[null,null,1,1,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, 1, false]'\nRaw Got:      '[null, null, 1, 1, false]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\ndef main():\n    # 讀取所有輸入行，忽略空行\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    # 如果第一行是標記文字(如 \"Input\")，去掉它\n    if lines and lines[0] in {\"Input\", \"Output\"}:\n        lines = lines[1:]\n    if len(lines) < 2:\n        return\n\n    methods = ast.literal_eval(lines[0])\n    args_list = ast.literal_eval(lines[1])\n\n    q = MyQueue()\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"push\":\n            q.push(args[0])\n            results.append(None)\n        elif method == \"pop\":\n            results.append(q.pop())\n        elif method == \"peek\":\n            results.append(q.peek())\n        elif method == \"empty\":\n            results.append(q.empty())\n\n    # 將結果轉成 LeetCode 風格的輸出\n    formatted = []\n    for r in results:\n        if r is None:\n            formatted.append(\"null\")\n        elif isinstance(r, bool):\n            formatted.append(\"true\" if r else \"false\")\n        else:\n            formatted.append(str(r))\n    output = \"[\" + \", \".join(formatted) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code for implementing a queue using two stacks, supporting push, pop, peek, empty. We output each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision, etc.\n\nWe need to consider entire class definition and methods. Should structure: Start // initialize class; then define push, pop, peek, empty. Within each method use logic: for push just push onto stack_in; for pop: if stack_out empty then transfer all from stack_in to stack_out; then pop from stack_out. Peek similar. Empty: return both stacks empty.\n\nWe need to present in pseudo-code lines sequentially, maybe grouped by method. The output must be sequential lines. Use indentation? Not necessary. Use arrows for decisions.\n\nLet's craft lines.\n\nStart // 程式開始執行\n\n→ Define MyQueue // 建立 MyQueue 類別\n\n→ 初始化兩個 stack: stack_in, stack_out // 兩個堆疊用於模擬佇列\n\nThen methods.\n\nPush method:\n\n→ Method push(x): // 推入元素到佇列尾部\n    → stack_in.push(x) // 直接 push 到 stack_in\n\nPop method:\n\n→ Method pop(): // 從佇列前端取出並移除\n    → Decision: 如果 stack_out 为空? // 檢查輸出堆疊是否有元素\n        Yes → stack_out.pop() // 從 stack_out 取出前端元素\n        No → Decision: stack_in 为空? // 若 stack_out 为空，需要將 stack_in 的元素轉移\n                Yes → Return null // 若兩個堆疊皆空，無元素可 pop\n                No → \n                    → While stack_in not empty: // 將 stack_in 的所有元素轉移至 stack_out\n                        → temp = stack_in.pop()\n                        → stack_out.push(temp)\n                    → stack_out.pop() // 取出轉移後的元素\n\nPeek method:\n\n→ Method peek(): // 查看佇列前端元素但不移除\n    → Decision: 如果 stack_out 为空? // 同樣先檢查輸出堆疊\n        Yes → Decision: stack_in 为空? \n                Yes → Return null\n                No → \n                    → While stack_in not empty:\n                        → temp = stack_in.pop()\n                        → stack_out.push(temp)\n                    → Return stack_out.peek() // 取得前端元素\n        No → Return stack_out.peek()\n\nEmpty method:\n\n→ Method empty(): // 檢查佇列是否為空\n    → Return stack_in.isEmpty() AND stack_out.isEmpty() // 兩個堆疊皆空則佇列空\n\nEnd // 程式執行結束\n\nBut we need each line with arrow. For loops, use \"While\". For condition lines: \"Decision:\" etc. Use consistent formatting: arrow and then step. For each line we add // explanation.\n\nLet's produce final answer. Ensure each line contains a space between virtual code and comment. Use arrow \"→\" at start for steps inside methods. For start and end we might not use arrow.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define MyQueue // 建立 MyQueue 類別  \n→ 初始化兩個 stack: stack_in, stack_out // 用兩個堆疊來模擬佇列  \n\n→ Method push(x): // 將元素 x 推入佇列尾部  \n    → stack_in.push(x) // 直接 push 到 stack_in  \n\n→ Method pop(): // 從佇列前端取出並移除元素  \n    → Decision: stack_out.isEmpty()? // 檢查輸出堆疊是否為空  \n        Yes → Decision: stack_in.isEmpty()? // 若輸出堆疊空，先檢查輸入堆疊  \n                Yes → Return null // 兩堆疊皆空，無元素可 pop  \n                No → \n                    → While stack_in.notEmpty(): // 將 stack_in 的所有元素轉移至 stack_out  \n                        → temp = stack_in.pop()  \n                        → stack_out.push(temp)  \n                    → Return stack_out.pop() // 從 stack_out 取出前端元素  \n        No → Return stack_out.pop() // stack_out 已有元素，直接 pop  \n\n→ Method peek(): // 查看佇列前端元素但不移除  \n    → Decision: stack_out.isEmpty()?  \n        Yes → Decision: stack_in.isEmpty()?  \n                Yes → Return null // 兩堆疊皆空  \n                No → \n                    → While stack_in.notEmpty(): // 將 stack_in 的所有元素轉移至 stack_out  \n                        → temp = stack_in.pop()  \n                        → stack_out.push(temp)  \n                    → Return stack_out.peek() // 取得前端元素  \n        No → Return stack_out.peek() // stack_out 有元素，直接 peek  \n\n→ Method empty(): // 檢查佇列是否為空  \n    → Return stack_in.isEmpty() AND stack_out.isEmpty() // 兩堆疊皆空即佇列空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        找出在 DNA 字串中重複出現的所有 10 字母長度子字串。\n        \"\"\"\n        seen = set()\n        repeated = set()\n        # 遍歷所有可能的 10 字母子字串\n        for i in range(len(s) - 9):\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)          # 第二次出現時加入結果\n            else:\n                seen.add(seq)              # 第一個出現\n        return list(repeated)\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取 DNA 字串，輸出重複子字串清單。\n    允許輸入形如 \"s = 'ACGT...'\" 或直接輸入字串。\n    \"\"\"\n    data = sys.stdin.read()\n    # 只保留大寫 A、C、G、T 字符，忽略其他文字\n    s = re.sub(r'[^ACGT]', '', data.upper())\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for solving this problem. The problem: find all 10-letter-long substrings that appear more than once in string s. So typical solution: sliding window of length 10, store counts in map, collect those with count>1. Complexity O(n). Use a dictionary or hash map.\n\nWe must produce step-by-step virtual code lines. Each line: \"虛擬碼步驟\" [space] \"// 解釋/說明\". Use arrows, decisions, etc.\n\nWe should produce in order.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize an empty map countMap to record frequency of each 10-letter substring // 用來統計每個 10 字母子字串出現次數\n→ Step 2: Initialize empty list result to store substrings occurring more than once // 用來儲存重複的子字串\n→ Decision: If length of s < 10? // 無法形成 10 字母子字串時直接結束\n    Yes → End // 如果字串長度不足 10，直接結束\n    No  → → Step 3: For i from 0 to length(s)-10 // 循環滑動窗口\n        → Step 3.1: Extract substring sub = s[i:i+10] // 取得當前 10 字母子字串\n        → Decision: If sub in countMap? // 是否已經紀錄過\n            Yes → countMap[sub] += 1 // 進一步加一\n            No  → countMap[sub] = 1 // 新增並設 1\n        → Decision: If countMap[sub] == 2? // 只在第二次出現時加入結果\n            Yes → result.append(sub) // 將子字串加入結果\n            No  → No action\n→ End // 程式結束\n\nWe can also mention return result.\n\nAdd Step: Step 4: Return result // 回傳重複子字串列表\n\nWe should also add a decision about if substring appears more than twice? But we add only once when count reaches 2. So we avoid duplicates.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 countMap 用來紀錄每個 10 字母子字串的出現次數 // 建立頻率表  \n→ Step 2: 初始化空清單 result 用來儲存重複出現的 10 字母子字串 // 建立結果容器  \n→ Decision: 若 s 的長度 < 10? // 無法形成 10 字母子字串  \n    Yes → End // 直接結束程式  \n    No  → → Step 3: 從 i = 0 到 i = len(s) - 10 逐一滑動窗口 // 開始遍歷所有 10 字母長度的子字串  \n        → Step 3.1: 取得子字串 sub = s[i:i+10] // 取出當前窗口的子字串  \n        → Decision: 若 sub 已存在於 countMap? // 判斷是否已記錄  \n            Yes → countMap[sub] += 1 // 已存在則計數加一  \n            No  → countMap[sub] = 1 // 未存在則新增並設為 1  \n        → Decision: 若 countMap[sub] == 2? // 只在第二次出現時加入結果  \n            Yes → result.append(sub) // 加入結果清單  \n            No  → No action // 其餘次數不再重複加入  \n→ Step 4: 返回 result // 將所有重複出現的 10 字母子字串傳回  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef permute(nums):\n    \"\"\"Return all permutations of the list `nums`.\"\"\"\n    res = []\n\n    def backtrack(start):\n        if start == len(nums):\n            res.append(nums[:])  # make a copy of current permutation\n            return\n        for i in range(start, len(nums)):\n            nums[start], nums[i] = nums[i], nums[start]   # swap to fix position `start`\n            backtrack(start + 1)                         # recurse to fill next position\n            nums[start], nums[i] = nums[i], nums[start]   # backtrack: restore order\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    # Read the entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list representation from the input\n    l, r = data.find('['), data.rfind(']')\n    if l != -1 and r != -1 and l < r:\n        list_str = data[l:r+1]\n    else:\n        # If no brackets found, try to parse the whole string directly\n        try:\n            nums = ast.literal_eval(data)\n            print(json.dumps(nums, separators=(',', ':')))\n            sys.exit()\n        except Exception:\n            nums = []\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = []\n\n    # Compute permutations and output in the required format\n    result = permute(nums)\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for generating permutations of an array of distinct integers. We need to output step-by-step lines with virtual code syntax and explanation comments. Use arrows, Decision, Start, End. For permutation, we can use backtracking. The code should reflect that.\n\nWe need to provide each line with \"虛擬碼步驟 // 解釋/說明\". Use the arrow \"→\" or \"Yes →\", \"No →\". Should include Start, End. Each line has a step: like Start, Step 1: Initialize result array, Step 2: Define backtrack function, etc.\n\nWe need to produce a clear algorithm.\n\nLet's structure:\n\nStart\n→ Step 1: 定義 result 為空陣列 // 用來儲存所有排列\n→ Step 2: 定義 backtrack(目前排列, 已選中集合) // 回溯函式\n    → Decision: 如果目前排列長度等於原陣列長度? // 判斷是否完成一個排列\n        Yes → Step 3: 複製目前排列到 result // 將完成的排列加入結果\n        No  → Step 4: 遍歷原陣列中未選中的元素\n            → Decision: 如果元素未在已選中集合? // 判斷是否已選\n                Yes → Step 5: 加入元素到目前排列, 標記為已選中 // 探索此分支\n                    → Step 6: 呼叫 backtrack(更新後的目前排列, 更新後的已選中集合) // 深度遞迴\n                    → Step 7: 移除元素從目前排列, 取消已選中標記 // 回溯到上一層\n                No  → Step 8: 跳過此元素 // 不是未選中元素\nEnd\n\nHowever we must ensure each line has the format: \"虛擬碼步驟 // 解釋/說明\".\n\nAlso need to use arrows: \"→\". For decisions we need indentation? In example, they used indentation for nested lines, but we can also use indentation.\n\nThe instruction: Use virtual code's arrow (→, Yes →, No →) and structure (Start, End, Decision:). So we need to incorporate Decision: and Yes→, No→ inside.\n\nSo something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空陣列 // 用於儲存所有排列\n→ Step 2: 定義 backtrack(目前排列, 已選中集合) // 回溯函式\n    → Decision: 如果 目前排列長度 == 原陣列長度? // 判斷是否已完成一個排列\n        Yes → Step 3: 複製目前排列到 result // 將完成的排列加入結果\n        No  → Step 4: 對於 每個元素 in nums\n            → Decision: 如果 元素未在 已選中集合? // 判斷是否未被選\n                Yes → Step 5: 把元素加入目前排列，標記為已選\n                    → Step 6: 呼叫 backtrack(更新後的排列, 更新後的已選集)\n                    → Step 7: 從目前排列移除元素，取消已選標記\n                No  → Step 8: 跳過此元素 // 已選過的元素不再使用\nEnd // 程式執行結束\n\nBut the instructions: each line must include \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we need to write each line with a line like \"Start // 程式開始執行\".\n\nWe must include \"Decision:\" lines too. For decisions we might do \"Decision: 如果 目前排列長度 == 原陣列長度? // 判斷是否已完成一個排列\". But the example had \"Decision:\" as a separate line and then Yes → and No → with indent.\n\nWe should follow the example structure:\n\nStart // 程式開始執行\n→ Step 1: ... // ...\n→ Decision: ...\n    Yes → Step ... // ...\n    No  → Decision: ...\n        Yes → ...\n        No  → ...\nEnd // 程式執行結束\n\nSo we need indentation for nested lines. For each nested decision, indent with 4 spaces maybe.\n\nLet's craft accordingly:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空陣列 // 用於儲存所有排列\n→ Step 2: 定義 backtrack(目前排列, 已選中集合) // 回溯函式\n    → Decision: 如果 目前排列長度 == 原陣列長度? // 判斷是否已完成一個排列\n        Yes → Step 3: 把目前排列的複製加入 result // 保存完整排列\n        No  → Decision: 對於 nums 中的每個元素? // 逐個考慮未選元素\n            Yes → Step 4: 如果 元素未在 已選中集合? // 選擇未使用的元素\n                Yes → Step 5: 將元素加入目前排列並標記為已選中 // 探索此路徑\n                    → Step 6: 呼叫 backtrack(更新後的排列, 更新後的已選中集合) // 深度遞迴\n                    → Step 7: 從目前排列移除元素，取消已選中標記 // 回溯\n                No  → Step 8: 跳過此元素 // 已選過的元素不再考慮\nEnd // 程式執行結束\n\nBut we need to make sure each line is exactly one step and has \"虛擬碼步驟 // 解釋\". For decisions, the line itself is \"Decision: ...\". For Yes/No branches, they also have lines.\n\nWe need to reflect the \"→\" arrow preceding each step. For decisions, the line should start with \"→ Decision: ...\" not \"Decision:\"? In example, they had:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo they had arrow before Decision. Good.\n\nThus we must use arrow for Decision lines and indent the Yes/No branches.\n\nFor nested decisions, indent further.\n\nThus final virtual code lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空陣列 // 用於儲存所有排列\n→ Step 2: 定義 backtrack(目前排列, 已選中集合) // 回溯函式\n    → Decision: 如果 目前排列長度 == 原陣列長度? // 判斷是否已完成一個排列\n        Yes → Step 3: 把目前排列的複製加入 result // 保存完整排列\n        No  → Decision: 對於 nums 中的每個元素? // 逐個考慮未選元素\n            Yes → Step 4: 如果 元素未在 已選中集合? // 選擇未使用的元素\n                Yes → Step 5: 將元素加入目前排列並標記為已選中 // 探索此路徑\n                    → Step 6: 呼叫 backtrack(更新後的排列, 更新後的已選中集合) // 深度遞迴\n                    → Step 7: 從目前排列移除元素，取消已選中標記 // 回溯\n                No  → Step 8: 跳過此元素 // 已選過的元素不再考慮\nEnd // 程式執行結束\n\nCheck formatting: For \"Decision: 對於 nums 中的每個元素?\" Should be \"Decision: 對於 nums 中的每個元素?\" Actually we need to consider if it's a decision of iterating. In algorithm, it's a loop, not decision. But we can represent as Decision for each element if not selected. Let's keep \"Decision: 對於 nums 中的每個元素?\".\n\nBut the example uses \"Decision: 如果數字大於 0?\" So we can do \"Decision: 對於 nums 中的每個元素?\" but maybe better to use \"Decision: 對 nums 進行迴圈\"? But let's keep as decision: \"Decision: 迴圈遍歷 nums?\".\n\nBetter: \"Decision: 遍歷 nums 以找未選元素?\" This could be considered decision of iterating over each element. But to keep simple: \"Decision: 對 nums 中的每個元素?\".\n\nBut the inner decision is \"如果 元素未在 已選中集合?\" That is correct.\n\nThe steps 5-7: Step 5, Step 6, Step 7.\n\nWe should include \"→\" before each step.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空陣列 // 用於儲存所有排列\n→ Step 2: 定義 backtrack(目前排列, 已選中集合) // 回溯函式\n    → Decision: 如果 目前排列長度 == 原陣列長度? // 判斷是否已完成一個排列\n        Yes → Step 3: 把目前排列的複製加入 result // 保存完整排列\n        No  → Decision: 對 nums 中的每個元素? // 逐個考慮未選元素\n            Yes → Step 4: 如果 元素未在 已選中集合? // 選擇未使用的元素\n                Yes → Step 5: 將元素加入目前排列並標記為已選中 // 探索此路徑\n                    → Step 6: 呼叫 backtrack(更新後的排列, 更新後的已選中集合) // 深度遞迴\n                    → Step 7: 從目前排列移除元素，取消已選中標記 // 回溯\n                No  → Step 8: 跳過此元素 // 已選過的元素不再考慮\nEnd // 程式執行結束"
    },
    {
      "title": "Sliding Window Maximum",
      "source_file": "Leetcode/leetcode239.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoc9bms7i.py\", line 41, in parse_input\n    data = ast.literal_eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x733d23af7790>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpoc9bms7i.py\", line 53, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpoc9bms7i.py\", line 44, in parse_input\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums' is not defined"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp69u4wq70.py\", line 41, in parse_input\n    data = ast.literal_eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x741358526210>\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp69u4wq70.py\", line 53, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp69u4wq70.py\", line 44, in parse_input\n    data = eval('{' + raw + '}')\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'nums' is not defined"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"Return the maximum values in each sliding window of size k.\"\"\"\n        if not nums or k == 0:\n            return []\n\n        deq = deque()          # store indices of potential maximums\n        res = []\n\n        for i, value in enumerate(nums):\n            # 1. 移除離開窗口的索引\n            while deq and deq[0] < i - k + 1:\n                deq.popleft()\n\n            # 2. 移除所有比當前元素小的索引（因為它們不可能成為最大值）\n            while deq and nums[deq[-1]] < value:\n                deq.pop()\n\n            # 3. 加入當前索引\n            deq.append(i)\n\n            # 4. 當窗口已形成，將最大值加入結果\n            if i >= k - 1:\n                res.append(nums[deq[0]])\n\n        return res\n\ndef parse_input(raw):\n    \"\"\"\n    解析形如 'nums = [1,3,-1,-3,5,3,6,7], k = 3' 的字串\n    返回 (nums, k)。\n    \"\"\"\n    # 把等號改成冒號，方便使用 ast.literal_eval 解析\n    raw = raw.replace('=', ':')\n    # 用大括號包起來，得到字典字面量\n    try:\n        data = ast.literal_eval('{' + raw + '}')\n    except Exception:\n        # 若解析失敗，嘗試直接 eval（非安全方式，但在此題可接受）\n        data = eval('{' + raw + '}')\n    return data['nums'], data['k']\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    nums, k = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.maxSlidingWindow(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for sliding window maximum problem. Use deque. Provide step-by-step. Should be in Traditional Chinese. Provide lines with arrow. Start, End, Decision. Provide brief comments. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個雙端佇列 deque，空的 // 用來儲存窗口內可能為最大值的元素索引  \n→ Step 2: 建立結果陣列 output，長度為 nums.length - k + 1 // 用來存放每個窗口的最大值  \n→ Step 3: 循環 i 從 0 到 nums.length - 1  \n  → Decision: 是否將 i 之前的舊索引從 deque 中移除? // 檢查是否有元素已離開窗口  \n   Yes → Step 4: 如果 deque.front < i - k + 1，移除 deque.front // 舊元素離開窗口  \n   No  →  // 沒有舊元素需要移除  \n  → Decision: 是否將 i 之前的較小索引從 deque 中移除? // 清除比當前值小的索引，因為它們不可能是最大值  \n   Yes → Step 5: 如果 nums[deque.back] <= nums[i]，移除 deque.back // 小值不再需要  \n   No  →  // 之前的索引已比當前大，保留  \n  → Step 6: 將 i 加入 deque.back // 把當前索引放進佇列  \n  → Decision: 是否已經形成完整窗口? // i >= k - 1  \n   Yes → Step 7: output[ i - k + 1 ] = nums[ deque.front ] // 當前窗口最大值是前端的元素  \n   No  →  // 窗口尚未形成，繼續移動  \nEnd // 程式執行結束，返回 output。"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_lc18yqj.py\", line 65, in <module>\n    main()\n  File \"/tmp/tmp_lc18yqj.py\", line 43, in main\n    ops = json.loads(input_data[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 91 (char 90)"
        }
      ],
      "generated_code": "import json\nimport random\nimport sys\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"Insert val into the collection.\n        Returns True if val was not present before, otherwise False.\"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"Remove one occurrence of val from the collection.\n        Returns True if val existed, otherwise False.\"\"\"\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"Return a random element from the collection.\"\"\"\n        return random.choice(self.data)\n\n\ndef main() -> None:\n    # Read all input from stdin\n    input_data = sys.stdin.read().strip().splitlines()\n    if not input_data:\n        return\n\n    # Parse operations and arguments (JSON format)\n    ops = json.loads(input_data[0])\n    args = json.loads(input_data[1])\n\n    res = [None]  # first operation is always constructor\n    obj = None\n\n    for op, arg in zip(ops[1:], args[1:]):  # skip the constructor\n        if op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            # Unknown operation; skip or raise error\n            pass\n\n    # Output the results as a JSON array (None -> null, bool -> true/false)\n    print(json.dumps(res))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step implementing the class with methods and internal data structures. Use virtual code lines with \"→\" and \"Decision:\" etc. Each line must contain the step and comment. No actual code. Just virtual algorithm steps.\n\nWe need to describe algorithm: maintain vector of values for random access, and hashmap from value to set of indices. Insert: push to vector, add index to map set. If new value, return true else false. Remove: if value not present return false. Else get an index from set, remove that index from set. If index not at end, swap last element into that position, update its index set accordingly. Pop last element. Return true. getRandom: random index from vector size.\n\nWe'll produce line-by-line pseudocode. Start, End. Use Decision for checking. We'll need steps for each method. Let's outline:\n\nStart\n→ Step 1: Initialize data structures: vector vals, map val->set of indices\n→ Step 2: Method insert(val): \n   Decision: Is val in map? \n     Yes → insert index into set, push val to vals, return false\n     No → create set, add index, push val, return true\n→ Step 3: Method remove(val): \n   Decision: Is val in map? \n     No → return false\n     Yes → get an index idx from set, remove idx from set\n          Decision: Is idx == last index? \n              Yes → pop last element, remove val entry if set empty, return true\n              No → move last element lastVal to idx, update lastVal's set: remove old lastIndex, add idx\n                   pop last element, if set empty remove val entry\n                   return true\n→ Step 4: Method getRandom():\n   Decision: Is vals not empty? (guaranteed by problem)\n      → randomIdx = random integer [0, size-1]\n         return vals[randomIdx]\nEnd\n\nBut need each line with comment. Use arrows. Use Decision: with Yes/No. Let's produce.\n\nWe might need to show mapping for indices set.\n\nOk. Ensure each line has a space after step text and comment. Use // explanation. Use proper indentation? The example uses tabs? We'll follow same pattern.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的向量 values 以及映射 indexMap，key 為元素值，value 為該值所在位置的集合 // 用於 O(1) 隨機存取與位置追蹤\n→ Step 2: 方法 insert(val) // 插入元素\n    → Decision: indexMap 是否包含 val? // 檢查該值是否已有\n        Yes → values.append(val) // 把 val 放到向量尾端\n              → indexMap[val].add(values.size-1) // 加入新位置到集合\n              → return false // 已存在，不算第一次插入\n        No  → values.append(val)\n              → indexMap[val] = {values.size-1} // 新集合只含此位置\n              → return true // 第一次插入\n→ Step 3: 方法 remove(val) // 移除元素\n    → Decision: indexMap 是否包含 val? // 檢查是否有可移除\n        No → return false // 沒有此值，直接回傳\n        Yes →\n            → 任意取出 indexMap[val] 中的一個 idx // 取得一個要移除的位置\n            → indexMap[val].remove(idx) // 從集合移除該位置\n            → Decision: idx == values.size-1? // 是否是最後一個元素\n                Yes → values.pop() // 直接移除最後一個\n                      → Decision: indexMap[val] 是否為空? // 檢查是否已無此值\n                          Yes → indexMap.remove(val) // 移除空集合\n                      → return true\n                No  → lastVal = values.last() // 取最後一個元素\n                      → lastIdx = values.size-1\n                      → values[idx] = lastVal // 把最後一個元素搬到 idx\n                      → values.pop() // 刪除最後一個位置\n                      → indexMap[lastVal].remove(lastIdx) // 移除舊位置\n                      → indexMap[lastVal].add(idx) // 加入新位置\n                      → Decision: indexMap[val] 是否為空? // 檢查被移除值是否已無\n                          Yes → indexMap.remove(val)\n                      → return true\n→ Step 4: 方法 getRandom() // 隨機取值\n    → Decision: values 非空? // 問題保證不會空\n        Yes → randomIdx = RandomInt(0, values.size-1) // 產生隨機索引\n              → return values[randomIdx] // 直接回傳\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # 小堆（最大堆的反向實現）存放左半區（較小的數）\n        self.small = []   # 以負值形式作為最大堆\n        # 大堆（最小堆）存放右半區（較大的數）\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 先將數字放入小堆（作為最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆都有元素且小堆頂大於大堆頂，則交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 保持小堆尺寸不比大堆大超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 若大堆比小堆大，則把大堆頂搬到小堆\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        # 若小堆多，取小堆頂作中位數\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        # 否則兩堆相等，取兩頂平均值\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：兩個列表，用逗號分隔\n    try:\n        # 將輸入包裝成元組，方便 eval 解析\n        ops_args = eval('(' + data + ')')\n    except Exception:\n        # 若解析失敗，直接退出\n        return\n\n    ops, args_list = ops_args\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            res.append(None)\n        elif op == \"addNum\":\n            obj.addNum(args[0])\n            res.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            res.append(median)\n        else:\n            res.append(None)\n    # 輸出結果，使用 JSON 以得到 null 表示\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code line by line, explaining each. Problem: median finder with addNum and findMedian. Use two heaps: max-heap for lower half, min-heap for upper half. Balance sizes. For median: if odd, top of larger heap; if even, average of tops. So we output pseudo-code steps. We need to adhere to format: \"虛擬碼步驟 // 解釋\". Use arrows. Let's produce:\n\nStart\n→ Step: 定義類 MedianFinder\n→ Step: 建立 maxHeap (大根堆) 用於左半\n→ Step: 建立 minHeap (小根堆) 用於右半\n→ Decision: (初始化) No\nBut we need to include methods.\n\nSimplify: Steps to addNum: compare with top of maxHeap. If maxHeap empty or num <= maxHeap.peek, push to maxHeap else push to minHeap. Then balance: if maxHeap.size > minHeap.size +1, move root to minHeap; if minHeap.size > maxHeap.size, move root to maxHeap.\n\nfindMedian: if sizes equal, median = (maxHeap.peek + minHeap.peek)/2.0 else median = maxHeap.peek.\n\nReturn.\n\nWe need line by line.\n\nLet's produce pseudo-code.\n\nUse \"Start\" at beginning of class? Might just start at \"Start // 程式開始\".\n\nBut need to define class. Let's produce:\n\nStart // 程式開始\n→ Step: 定義 MedianFinder 類 // 建立類別\n    → Step: 宣告 maxHeap 為最大堆 // 儲存小半部\n    → Step: 宣告 minHeap 為最小堆 // 儲存大半部\n→ Step: MedianFinder() // 建構子\n    → Step: 初始化 maxHeap 為空堆 // 只需要新建堆\n    → Step: 初始化 minHeap 為空堆\n→ Step: addNum(num) // 新增數字\n    → Decision: 如果 maxHeap 為空 或 num <= maxHeap.peek()?\n        Yes → Step: maxHeap.push(num) // 新數進左半\n        No  → Step: minHeap.push(num) // 新數進右半\n    → Decision: maxHeap.size() > minHeap.size() + 1?\n        Yes → Step: minHeap.push(maxHeap.pop()) // 平衡：左多\n        No  → Decision: minHeap.size() > maxHeap.size()?\n            Yes → Step: maxHeap.push(minHeap.pop()) // 平衡：右多\n            No  → Step: // 已平衡\n→ Step: findMedian() // 計算中位數\n    → Decision: maxHeap.size() == minHeap.size()?\n        Yes → Step: return (maxHeap.peek() + minHeap.peek()) / 2.0 // 均值\n        No  → Step: return maxHeap.peek() // 左堆較大\nEnd // 程式結束\n\nWe need each line preceded by virtual code step. Use \"→\". For decisions we need indent? Use \"Decision:\".\n\nEnsure each line ends with // 解釋.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step: 定義 MedianFinder 類 // 建立類別\n    → Step: 宣告 maxHeap 為最大堆 // 儲存小半部\n    → Step: 宣告 minHeap 為最小堆 // 儲存大半部\n→ Step: MedianFinder() // 建構子\n    → Step: 初始化 maxHeap 為空堆 // 新建左半堆\n    → Step: 初始化 minHeap 為空堆 // 新建右半堆\n→ Step: addNum(num) // 新增數字\n    → Decision: 如果 maxHeap 為空 或 num <= maxHeap.peek()?\n        Yes → Step: maxHeap.push(num) // 新數進左半堆\n        No  → Step: minHeap.push(num) // 新數進右半堆\n    → Decision: maxHeap.size() > minHeap.size() + 1?\n        Yes → Step: minHeap.push(maxHeap.pop()) // 平衡：左堆多時把最大搬到右堆\n        No  → Decision: minHeap.size() > maxHeap.size()?\n            Yes → Step: maxHeap.push(minHeap.pop()) // 平衡：右堆多時把最小搬到左堆\n            No  → Step: // 兩堆已平衡\n→ Step: findMedian() // 計算中位數\n    → Decision: maxHeap.size() == minHeap.size()?\n        Yes → Step: return (maxHeap.peek() + minHeap.peek()) / 2.0 // 兩堆相等，取平均\n        No  → Step: return maxHeap.peek() // 左堆多時，取左堆頂作中位數\nEnd // 程式結束"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[None,None,[[1,1]],None,[[1,1],[3,3]],None,[[1,1],[3,3],[7,7]],None,[[1,3],[7,7]],None,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[None, None, [[1, 1]], None, [[1, 1], [3, 3]], None, [[1, 1], [3, 3], [7, 7]], None, [[1, 3], [7, 7]], None, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, val):\n        new_interval = [val, val]\n        res = []\n        placed = False\n        for start, end in self.intervals:\n            if end + 1 < val:\n                res.append([start, end])\n            elif val + 1 < start:\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n        if not placed:\n            res.append(new_interval)\n        self.intervals = res\n\n    def getIntervals(self):\n        return self.intervals\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    commands = ast.literal_eval(data[0])\n    arguments = ast.literal_eval(data[1])\n\n    obj = None\n    result = []\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            result.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(args[0])\n            result.append(None)\n        elif cmd == \"getIntervals\":\n            result.append(obj.getIntervals())\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for SummaryRanges class, with methods: init, addNum, getIntervals. We'll produce virtual code lines. Use Start/End. Probably we need a data structure to store intervals, maybe a balanced BST or list of intervals. For simplicity, assume a list of intervals sorted by start. In addNum, we need to find insertion point, merge. Use binary search. Steps: AddNum: if list empty, add new [value,value]. Else find position using binary search: leftmost interval where start <= value <= end? If value lies in existing interval, nothing. Else check neighbors to merge.\n\nImplement pseudocode steps accordingly.\n\nWe'll output each line with explanation.\n\nLet's craft steps.\n\nStart\n\n→ Init: intervals = empty list // initialize summary\n\n→ Function addNum(value)\n\n    → Search: Find index i where intervals[i].start <= value <= intervals[i].end // inside an interval\n\n    → Decision: 如果找到? // if value in existing interval\n\n        Yes → Return // already present, nothing to do\n\n        No → Find index j: first interval with start > value // right neighbor\n\n        ← leftIndex = j-1 // left neighbor\n\n        ← rightIndex = j // right neighbor\n\n        → Decision: leftIndex >=0 AND intervals[leftIndex].end +1 == value? // adjacent left\n\n            Yes → mergeLeft = True\n\n            No → mergeLeft = False\n\n        → Decision: rightIndex < len(intervals) AND intervals[rightIndex].start -1 == value? // adjacent right\n\n            Yes → mergeRight = True\n\n            No → mergeRight = False\n\n        → Decision: mergeLeft AND mergeRight? // merge with both\n\n            Yes → intervals[leftIndex].end = intervals[rightIndex].end // extend left interval to include right\n\n                  → Delete intervals[rightIndex] // remove merged right\n\n            No → Decision: mergeLeft? // merge left only\n\n                Yes → intervals[leftIndex].end = value\n\n                No → Decision: mergeRight? // merge right only\n\n                    Yes → intervals[rightIndex].start = value\n\n                    No → // isolated new interval\n\n                        → Insert [value,value] at position j // maintain sorted order\n\n    End addNum\n\n→ Function getIntervals()\n\n    → Return copy of intervals // return list\n\nEnd\n\nNeed to format each line with arrow and comments.\n\nWe'll produce with indentation lines under decisions.\n\nEnsure to include Start/End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Init: intervals = [] // 初始化空的區間列表\n→ Function addNum(value) // 新增整數到流\n    → Search: i = binarySearch(intervals, value) // 找到可能包含 value 的區間索引\n    → Decision: i exists AND intervals[i].start <= value <= intervals[i].end? // value 已在某區間內？\n        Yes → Return // 已存在，無需任何變更\n        No → \n            ← leftIndex = i - 1 // 左側相鄰區間索引\n            ← rightIndex = i // 右側相鄰區間索引\n            → Decision: leftIndex >= 0 AND intervals[leftIndex].end + 1 == value? // 左側區間相鄰？\n                Yes → mergeLeft = True\n                No → mergeLeft = False\n            → Decision: rightIndex < len(intervals) AND intervals[rightIndex].start - 1 == value? // 右側區間相鄰？\n                Yes → mergeRight = True\n                No → mergeRight = False\n            → Decision: mergeLeft AND mergeRight? // 同時相鄰於左、右兩區間\n                Yes → \n                    intervals[leftIndex].end = intervals[rightIndex].end // 合併左右兩區間\n                    → Delete intervals[rightIndex] // 移除右側被合併的區間\n                No → \n                    → Decision: mergeLeft? // 僅與左側相鄰\n                        Yes → intervals[leftIndex].end = value // 延伸左側區間結尾\n                        No → \n                            → Decision: mergeRight? // 僅與右側相鄰\n                                Yes → intervals[rightIndex].start = value // 延伸右側區間起始\n                                No → // 完全獨立，需新增區間\n                                    → Insert [value, value] at index rightIndex // 插入新區間，保持排序\n    End addNum // addNum 完成\n→ Function getIntervals() // 取得目前的區間摘要\n    → Return copy of intervals // 回傳所有區間的副本\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp55mttv7q.py\", line 82, in <module>\n    main()\n  File \"/tmp/tmp55mttv7q.py\", line 50, in main\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgf62c0eg.py\", line 82, in <module>\n    main()\n  File \"/tmp/tmpgf62c0eg.py\", line 50, in main\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged new interval\n        result.append(newInterval)\n\n        # Append the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    intervals = None\n    newInterval = None\n\n    # Try to extract the lists using regex patterns\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[.*?\\])', data)\n    newinterval_match = re.search(r'newInterval\\s*=\\s*(\\[.*?\\])', data)\n\n    if intervals_match:\n        intervals = ast.literal_eval(intervals_match.group(1))\n    if newinterval_match:\n        newInterval = ast.literal_eval(newinterval_match.group(1))\n\n    # Fallback: if the format is two separate lines\n    if intervals is None or newInterval is None:\n        lines = [line for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            try:\n                intervals = ast.literal_eval(lines[0])\n                newInterval = ast.literal_eval(lines[1])\n            except Exception:\n                pass\n\n    # If still not parsed, try to interpret the whole input as a tuple\n    if intervals is None or newInterval is None:\n        try:\n            parsed = ast.literal_eval(data)\n            if isinstance(parsed, tuple) and len(parsed) == 2:\n                intervals, newInterval = parsed\n        except Exception:\n            pass\n\n    if intervals is None or newInterval is None:\n        # Unable to parse input; exit silently\n        return\n\n    sol = Solution()\n    result = sol.insert(intervals, newInterval)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce step-by-step pseudocode for merging intervals insertion. Provide lines with \"虛擬碼步驟\" then space then comment.\n\nWe must not output real code, just virtual code with arrows.\n\nSo outline: Start, initialize result array, iterate through intervals.\n\nPseudo steps: iterate intervals, before new interval, while current end < new start, add to result. Then merge overlapping ones: while current start <= new end, update new start = min(new start, current start), new end = max(new end, current end). After merging, add merged interval to result. Then add rest of intervals after new end.\n\nFinally return result.\n\nWe also need to consider that intervals sorted ascending. So algorithm.\n\nWe need to output each line. Let's produce maybe 12-15 lines.\n\nAlso note that use \"Decision:\" lines for conditions.\n\nLet's design:\n\nStart\n→ Step 1: 初始化 result 為空列表 // 建立結果儲存\n→ Step 2: 取得 intervals 長度 n // 用於迴圈\n→ Step 3: 初始化索引 i = 0 // 追蹤目前 interval\n\n→ Decision: i < n 且 intervals[i][1] < newInterval[0]? // 當前 interval 結束在新 interval 開始之前\n    Yes → Step 4: 將 intervals[i] 加入 result // 先把非重疊 interval 放入\n    Yes → Step 5: i += 1 // 移至下一個\n    Yes → Decision: i < n 且 intervals[i][1] < newInterval[0]? // 重複檢查\n        Yes → ... // loop\n        No  → Decision: i < n 且 intervals[i][0] <= newInterval[1]? // 是否有重疊\n            Yes → Step 6: 設 newStart = min(newInterval[0], intervals[i][0]) // 合併開始\n            Yes → Step 7: 設 newEnd = max(newInterval[1], intervals[i][1]) // 合併結束\n            Yes → Step 8: i += 1\n            Yes → Decision: i < n 且 intervals[i][0] <= newEnd? // 是否還有重疊\n                Yes → ... // loop merging\n                No  → Step 9: 將 [newStart, newEnd] 加入 result // 將合併後的 interval 放入\n                No → Decision: i < n? // 後續 intervals\n                    Yes → Step 10: 將 intervals[i] 後續加入 result // 添加剩下的\n                    Yes → Step 11: i += 1\n                    Yes → Decision: i < n? // 迴圈\n                    ...\n? This may be too complex.\n\nMaybe simpler: Use three parts: before, merging, after.\n\nSteps:\n\nStart\n→ Step 1: 初始化 result = []\n→ Step 2: i = 0\n→ Decision: i < len(intervals) and intervals[i][1] < newInterval[0]?\n    Yes → Step 3: result.append(intervals[i]); i += 1; goto Decision\n    No → Decision: i < len(intervals) and intervals[i][0] <= newInterval[1]?\n        Yes → Step 4: newStart = min(newInterval[0], intervals[i][0])\n        Yes → Step 5: newEnd = max(newInterval[1], intervals[i][1])\n        Yes → Step 6: i += 1; goto Decision\n        No → Step 7: result.append([newStart, newEnd]) if newStart defined else result.append(newInterval); goto Decision\nBut we need to track newStart/newEnd.\n\nOk maybe use variables: merged = False.\n\nLet's design more clear pseudo:\n\nStart\n→ Step 1: result = []\n→ Step 2: i = 0\n→ Step 3: merged = False\n\n→ Decision: i < len(intervals)?\n    Yes → Step 4: cur = intervals[i]\n    Yes → Decision: cur[1] < newInterval[0]?\n        Yes → Step 5: result.append(cur); i += 1; goto Decision\n        No → Decision: cur[0] > newInterval[1]?\n            Yes → Step 6: if not merged: result.append(newInterval); merged = True\n            Yes → Step 7: result.append(cur); i += 1; goto Decision\n            No → // overlap\n                Yes → Step 8: newInterval[0] = min(newInterval[0], cur[0])\n                Yes → Step 9: newInterval[1] = max(newInterval[1], cur[1])\n                Yes → Step 10: i += 1; goto Decision\n    No → Decision: not merged?\n        Yes → Step 11: result.append(newInterval)\n        No  → (nothing)\n→ End // 返回 result\n\nBut we need to produce \"虛擬碼步驟\" each line. We need to keep consistent.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: result ← [] // 建立空結果列表\n→ Step 2: i ← 0 // 初始索引\n→ Step 3: merged ← False // 是否已插入合併後的新區間\n→ Decision: i < len(intervals) ? // 是否還有未處理的區間\n    Yes → Step 4: cur ← intervals[i] // 取目前區間\n    Yes → Decision: cur[1] < newInterval[0] ? // 當前區間結束在新區間開始之前\n        Yes → Step 5: result.append(cur) // 加入結果\n        Yes → Step 6: i ← i + 1 // 移至下一個\n        Yes → Decision: i < len(intervals) ? // 迴圈\n            Yes → … // 繼續\n            No  → … // 走出迴圈\n        No → Decision: cur[0] > newInterval[1] ? // 當前區間完全在新區間之後\n            Yes → Step 7: if not merged then result.append(newInterval); merged ← True\n            Yes → Step 8: result.append(cur) // 加入當前區間\n            Yes → Step 9: i ← i + 1 // 移至下一個\n            Yes → Decision: i < len(intervals) ? // 迴圈\n                Yes → …\n                No  → …\n            No → // 覆蓋情況\n                Yes → Step 10: newInterval[0] ← min(newInterval[0], cur[0]) // 合併起始\n                Yes → Step 11: newInterval[1] ← max(newInterval[1], cur[1]) // 合併結束\n                Yes → Step 12: i ← i + 1 // 移至下一個\n                Yes → Decision: i < len(intervals) ? // 迴圈\n                    Yes → …\n                    No  → …\n    No → Decision: not merged ?\n        Yes → Step 13: result.append(newInterval) // 最後加入新區間\n        No  → (nothing)\nEnd // 回傳結果\n\nBut maybe we need to include explicit End line. The instruction: End // 程式執行結束. But we need to return result; maybe step to return.\n\nSo final lines:\n\n→ Step 14: return result // 回傳合併後的區間列表\n\nEnd // 程式執行結束\n\nBut the pseudocode includes start and end, but not return? The end can be just End.\n\nBut better: Step 14: return result // 回傳結果\n\nEnd // 程式結束\n\nBut they said End // 程式執行結束. We'll use End.\n\nOk.\n\nWe need to ensure we produce a valid pseudocode with arrows and decisions.\n\nWe should use proper indentation maybe but not necessary.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 建立空結果列表  \n→ Step 2: i ← 0 // 初始化區間索引  \n→ Step 3: merged ← False // 是否已插入新區間  \n\n→ Decision: i < len(intervals) ? // 是否還有未處理的區間  \n    Yes → Step 4: cur ← intervals[i] // 取目前區間  \n    Yes → Decision: cur[1] < newInterval[0] ? // 當前區間結束在新區間開始之前  \n        Yes → Step 5: result.append(cur) // 加入結果  \n        Yes → Step 6: i ← i + 1 // 移至下一個區間  \n        Yes → Decision: i < len(intervals) ? // 繼續迴圈  \n            Yes → … // 重複上述流程  \n            No  → … // 迴圈結束  \n        No → Decision: cur[0] > newInterval[1] ? // 當前區間完全在新區間之後  \n            Yes → Step 7: if not merged then result.append(newInterval); merged ← True // 插入新區間一次  \n            Yes → Step 8: result.append(cur) // 加入當前區間  \n            Yes → Step 9: i ← i + 1 // 移至下一個  \n            Yes → Decision: i < len(intervals) ? // 繼續迴圈  \n                Yes → … // 重複流程  \n                No  → …  \n            No → // 覆蓋情況，需合併  \n                Yes → Step 10: newInterval[0] ← min(newInterval[0], cur[0]) // 合併起始點  \n                Yes → Step 11: newInterval[1] ← max(newInterval[1], cur[1]) // 合併結束點  \n                Yes → Step 12: i ← i + 1 // 移至下一個  \n                Yes → Decision: i < len(intervals) ? // 繼續合併  \n                    Yes → … // 可能還有重疊  \n                    No  → …  \n    No → Decision: not merged ? // 沒有插入新區間  \n        Yes → Step 13: result.append(newInterval) // 最後插入  \n        No  → … // 已插入，無需再處理  \n\n→ Step 14: return result // 回傳合併後的區間列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom functools import lru_cache\n\nclass Solution:\n    COLORS = \"RYBGRW\"  # order of colors for index mapping\n\n    def findMinStep(self, board: str, hand: str) -> int:\n        # Count balls in hand\n        hand_count = [0] * 6\n        for c in hand:\n            hand_count[self.COLORS.index(c)] += 1\n\n        @lru_cache(maxsize=None)\n        def dfs(state: str, hand_counts: tuple) -> int:\n            if not state:\n                return 0  # board cleared\n            if sum(hand_counts) == 0:\n                return float('inf')  # no balls left\n\n            # Compress board into groups of same color\n            groups = []\n            i = 0\n            n = len(state)\n            while i < n:\n                j = i\n                while j < n and state[j] == state[i]:\n                    j += 1\n                groups.append((state[i], j - i, i))\n                i = j\n\n            best = float('inf')\n            for color, cnt, pos in groups:\n                idx = self.COLORS.index(color)\n                need = 3 - cnt\n                if need <= 0:\n                    continue  # group already removable, shouldn't happen\n                if hand_counts[idx] < need:\n                    continue  # not enough balls to insert\n\n                # Insert balls and remove groups\n                new_board = state[:pos] + color * need + state[pos:]\n                new_board = self.remove_groups(new_board)\n\n                new_hand = list(hand_counts)\n                new_hand[idx] -= need\n                steps = dfs(new_board, tuple(new_hand))\n                if steps != float('inf'):\n                    best = min(best, steps + 1)\n\n            return best\n\n        res = dfs(board, tuple(hand_count))\n        return res if res != float('inf') else -1\n\n    @staticmethod\n    def remove_groups(s: str) -> str:\n        \"\"\"Remove consecutive groups of 3 or more recursively.\"\"\"\n        stack = []  # each element is [color, count]\n        for c in s:\n            if stack and stack[-1][0] == c:\n                stack[-1][1] += 1\n                if stack[-1][1] == 3:\n                    stack.pop()  # remove the group\n            else:\n                stack.append([c, 1])\n\n        # Reconstruct string\n        return ''.join(color * count for color, count in stack)\n\ndef parse_input(data: str):\n    board_match = re.search(r'board\\s*=\\s*\"([^\"]*)\"', data)\n    hand_match = re.search(r'hand\\s*=\\s*\"([^\"]*)\"', data)\n    board = board_match.group(1) if board_match else ''\n    hand = hand_match.group(1) if hand_match else ''\n    return board, hand\n\ndef main():\n    data = sys.stdin.read()\n    board, hand = parse_input(data)\n    sol = Solution()\n    result = sol.findMinStep(board, hand)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving Zuma problem. We need to give a virtual algorithm. Probably backtracking + recursion. Provide steps: start, preprocess counts, DFS function, etc. Provide comments. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Should include loops, recursion, pruning. We'll produce high-level algorithm steps. Not actual code. Each step line can be multiple characters but we keep simple. Provide step count: e.g.,\n\nStart\n→ Step 1: Count balls in hand // freq\n→ Step 2: Define recursive DFS(board, handCount) // explore\n→ Decision: If board empty? Yes → Return 0; No → ...\n etc.\n\nWe need to maintain minimal insertions. Use backtracking with memoization. Use pruning: if remaining insertions exceed best. We'll produce virtual code lines. Should be clear.\n\nWe'll produce steps like:\n\nStart\n→ Step 1: Build map handCount from hand string // frequency of each color\n→ Step 2: Initialize global variable minInsert = INF // best answer\n→ Step 3: Call DFS(board, handCount) // search\n→ Step 4: If minInsert == INF return -1 else return minInsert\nEnd\n\nDefine DFS:\n\nDFS(board, handCount):\n    Decision: if board empty? Yes → minInsert = min(minInsert, 0) // no more inserts needed, return\n    No → ...\n    Decision: if all handCount zero? Yes → return // cannot continue\n    No → ...\n    For each index i in board:\n        color = board[i]\n        Count consecutive same color starting at i => runLen\n        need = 3 - runLen\n        if need <= 0: continue // already >=3? but we remove earlier? We consider after insert\n        if handCount[color] < need: continue // not enough\n        // create newBoard after inserting need balls at position i\n        newBoard = insertAndRemove(board, i, color, need)\n        handCount[color] -= need\n        DFS(newBoard, handCount)\n        handCount[color] += need\n        // prune: if currentInsert >= minInsert\n    End For\n\nFunction insertAndRemove:\n\n    Insert need balls of color at position i\n    Then while there is a group of >=3 same color, remove it and merge neighbors, repeat\n    Return resulting string\n\nNeed to use memoization: key = board + handCount as string.\n\nWe'll produce virtual steps accordingly. Use arrow and decisions.\n\nLet's write each step line with explanation. Use \"→\" for flow. Use \"Decision:\" lines. Use \"Yes →\" \"No →\" etc. We'll keep one line per logical step.\n\nWe might need nested decisions. We'll keep separate lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得手中每種顏色球的數量並存入 map handCount // 建立球顏色對應數量的快取  \n→ Step 2: 設定全域變數 minInsert = INF // 以儲存目前找到的最小插入數  \n→ Step 3: 呼叫 DFS(board, handCount) // 開始深度優先搜尋  \n→ Decision: minInsert 仍為 INF? // 判斷是否找不到可行解  \n    Yes → Step 4: 回傳 -1 // 無法清除所有球  \n    No  → Step 5: 回傳 minInsert // 返回最小插入數  \nEnd // 程式執行結束  \n\n---  \n\nDFS(board, handCount) // 定義遞迴搜尋函式  \n→ Decision: board 為空? // 判斷是否已清空棋盤  \n    Yes → Step 6: minInsert = min(minInsert, 0) // 目前不需再插入，更新最小值  \n    No → Step 7: 進行後續搜尋  \n\n→ Decision: 所有 handCount 都為 0? // 判斷手牌是否已用完  \n    Yes → Step 8: 返回 // 無法繼續，回到上一層  \n    No → Step 9: 進行遍歷  \n\n→ For each index i from 0 to board.length-1: // 遍歷棋盤位置  \n    → Step 10: 計算從 i 開始連續相同顏色球的長度 runLen // 獲取連續塊長度  \n    → Step 11: 計算需要插入的球數 need = 3 - runLen // 使連續塊達到 3  \n    → Decision: need <= 0? // 已經是 3 或以上  \n        Yes → Continue to next i // 無需插入，跳過  \n        No → Step 12: Decision: handCount[board[i]] < need? // 手牌是否足夠  \n            Yes → Continue to next i // 不能插入，跳過  \n            No  → Step 13: 進行插入與消除操作  \n\n---  \n\nStep 13:  \n→ Step 14: newBoard = insertAndRemove(board, i, board[i], need) // 插入並連續消除  \n→ Step 15: handCount[board[i]] -= need // 使用手牌  \n→ Step 16: DFS(newBoard, handCount) // 進一步搜尋  \n→ Step 17: handCount[board[i]] += need // 回朔手牌  \n\n---  \n\ninsertAndRemove(board, pos, color, k) // 定義插入並消除的子程式  \n→ Step 18: 在 pos 處插入 k 個 color 球，得到 tempBoard  \n→ Step 19: While tempBoard 內存在連續 ≥3 同色球群組: // 重複消除  \n    → Step 20: 找到第一個連續 ≥3 群組的起始與結束位置  \n    → Step 21: 移除該群組，將左右相鄰球連接起來  \n    → Step 22: 更新 tempBoard 為新的字串  \n→ Step 23: 回傳 tempBoard // 返回消除後的棋盤  \n\n---  \n\nMemoization（可選）  \n→ Step 24: 在 DFS 開頭生成 key = board + \"|\" + handCount  // 將棋盤與手牌編碼為字串  \n→ Step 25: Decision: key 已存在於 memo?  \n    Yes → Step 26: 若 memo[key] <= 目前已插入數, 返回 // 已經找到更優解，剪枝  \n    No  → Step 27: 執行 DFS 邏輯  \n→ Step 28: 在 DFS 結束前將 memo[key] = 最小插入數  \n\n---  \n\n此虛擬碼描述了使用深度優先搜尋與回溯的策略，結合連續消除規則與剪枝技巧，最終計算最小插入數或判斷不可行。"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd54_k1sb.py\", line 25, in <module>\n    data = json.loads(sys.stdin.read().strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 76 (char 75)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # move to end (most recently used)\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)  # remove old entry\n        self.cache[key] = value  # insert as most recent\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # evict least recently used\n\nif __name__ == \"__main__\":\n    data = json.loads(sys.stdin.read().strip())\n    ops, args = data[0], data[1]\n    res = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            res.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            res.append(None)\n        elif op == \"get\":\n            res.append(cache.get(arg[0]))\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nThe user wants virtual code with line-by-line explanation for LRUCache. We must output only virtual code steps, no actual code. Use the specified format with virtual steps, arrows, etc. Provide steps for initializing, get, put, eviction, etc.\n\nWe need to include virtual steps that show data structures: doubly linked list + hashmap. Use pseudocode style. Provide each line with explanation. Use \"Start\", \"End\" etc.\n\nWe should outline algorithm: On initialization, create hashmap and doubly linked list with dummy head/tail. get: if key in map, move node to head, return value, else -1. put: if key exists, update and move to head; else create new node, add to head, update map; if size>capacity, remove tail node, delete from map. All O(1). Provide step-by-step.\n\nWe need to output step-by-step lines. For each step, include comment.\n\nWe must use the arrow \"→\" to indicate flow. Also \"Decision:\" lines for condition checks.\n\nLet's craft.\n\nStart // Initialize\n→ Step 1: Create empty hashmap keyToNode // store key to node mapping\n→ Step 2: Create dummy head and dummy tail nodes for doubly linked list // simplify insertion/removal\n→ Step 3: Link head.next = tail; tail.prev = head // set up empty list\n→ Step 4: Set capacity = given capacity // store capacity\n→ Step 5: Set size = 0 // current number of elements\nEnd // initialization done\n\nNow get method:\n\nStart // get(key) called\n→ Decision: If key not in keyToNode? // check existence\n    No → Step 1: Return -1 // key missing\n    Yes → Step 2: node = keyToNode[key] // retrieve node\n        Step 3: Move node to head of list // update usage order\n            → Step 3a: Detach node from its current position\n            → Step 3b: Insert node right after head\n        Step 4: Return node.value // return cached value\nEnd // get finished\n\nNow put method:\n\nStart // put(key, value) called\n→ Decision: If key in keyToNode? // key exists?\n    Yes → Step 1: node = keyToNode[key]\n        → Step 1a: Update node.value = value\n        → Step 1b: Move node to head // refresh order\n        → Step 1c: End // no size change\n    No  → Step 2: Create new node with key, value // add new entry\n        → Step 2a: Insert node after head // add to most recent\n        → Step 2b: keyToNode[key] = node // add to map\n        → Step 2c: Increment size\n        → Decision: If size > capacity? // need eviction\n            Yes → Step 3: lruNode = tail.prev // least recently used\n                → Step 3a: Remove lruNode from list\n                → Step 3b: Delete keyToNode[lruNode.key] // remove mapping\n                → Step 3c: Decrement size\n            No → Step 4: Do nothing // size within capacity\nEnd // put finished\n\nWe also may need helper methods: moveToHead, removeNode, addNode, etc. But we can incorporate them as steps inside the above.\n\nMake sure each line ends with // comment. Use proper arrow and indentation.\n\nAlso include End for overall class? But we just need methods. Provide separate sections for initialization, get, put.\n\nWe should format using example. Provide Start, End for overall flow of each method.\n\nLet's produce final answer.\n...done thinking.\n\nStart // LRUCache 初始化\n→ Step 1: 建立 keyToNode 哈希表 // 儲存鍵到節點的映射\n→ Step 2: 創建 dummy head 與 dummy tail 節點 // 方便鏈表操作\n→ Step 3: head.next = tail ; tail.prev = head // 將兩個節點相連，形成空列表\n→ Step 4: capacity = 給定容量 // 儲存最大容量\n→ Step 5: size = 0 // 目前存儲數量\nEnd // 初始化完成\n\nStart // get(key) 被呼叫\n→ Decision: key 不在 keyToNode? // 檢查鍵是否存在\n    No → Step 1: Return -1 // 鍵不存在，直接返回 -1\n    Yes → Step 2: node = keyToNode[key] // 取得對應節點\n        → Step 3: Move node 到 head // 更新為最近使用\n            → Step 3a: Detach node from current position // 將節點脫離鏈表\n            → Step 3b: Insert node 之後 head // 插入到最前面\n        → Step 4: Return node.value // 返回節點值\nEnd // get 完成\n\nStart // put(key, value) 被呼叫\n→ Decision: key 已存在於 keyToNode? // 檢查鍵是否已在緩存\n    Yes → Step 1: node = keyToNode[key]\n        → Step 1a: node.value = value // 更新值\n        → Step 1b: Move node 到 head // 更新為最近使用\n        → Step 1c: // size 不變，直接結束\n    No → Step 2: 新建節點 node(key, value) // 新增鍵值對\n        → Step 2a: Insert node 之後 head // 加入最前面\n        → Step 2b: keyToNode[key] = node // 將鍵映射到節點\n        → Step 2c: size += 1 // 數量加一\n        → Decision: size > capacity? // 是否超出容量\n            Yes → Step 3: lruNode = tail.prev // 取得最舊節點\n                → Step 3a: Remove lruNode 從鏈表 // 解除鏈表連結\n                → Step 3b: Delete keyToNode[lruNode.key] // 移除映射\n                → Step 3c: size -= 1 // 數量減一\n            No  → Step 4: // 未超出容量，無需移除\nEnd // put 完成"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5f14bbdz.py\", line 41, in <module>\n    ops, args_list = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Parse the two lists: operations and arguments\n    ops, args_list = json.loads(data)\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(args[0])\n            results.append(None)\n        elif op == \"search\":\n            res = obj.search(args[0])\n            results.append(res)\n        else:\n            # Unsupported operation; append None as placeholder\n            results.append(None)\n\n    # Output the results in JSON format (None -> null, bools stay lower-case)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for WordDictionary with addWord and search, with '.' wildcard. So typical solution uses Trie with recursion for search. Virtual code line-by-line. So each line: \"Start //...\" then \"→ Step ...\". Use Decision. Provide explanation.\n\nLet's outline steps:\n\nStart\n→ Step 1: 初始化 Trie 根節點 // 建立根節點\n→ Step 2: 定義 addWord(word) // 添加詞\n  → Step 3: current = root\n  → Step 4: 對於每個字符 c in word\n    → Decision: 如果 c 為字母? // 檢查字符\n        Yes → Step 5: 如果 current.children[c] 不存在, 創建新節點\n        Yes → Step 6: current = current.children[c] // 移到子節點\n  → Step 7: 標記 current 為終端 // 記錄單詞結束\n→ Step 8: 定義 search(word) // 搜尋\n  → Step 9: 定義 recursive function dfs(index, node)\n    → Step 10: 如果 index 等於 word.length → return node.isEnd // 判斷是否到最後且為單詞\n    → Step 11: char c = word[index]\n    → Decision: 如果 c == '.'?\n        Yes → Step 12: 對每個 child in node.children\n            → Step 13: 如果 dfs(index+1, child) 返回 true → return true\n        Yes → return false // 沒有匹配子節點\n        No → Step 14: 如果 node.children[c] 存在\n            → Step 15: return dfs(index+1, node.children[c])\n        No → Step 16: return false\n  → Step 17: return dfs(0, root)\nEnd\n\nNeed to format each line with \"→\" indentation maybe, but each line separate. Use Decision with Yes→ etc.\n\nLet's output. Ensure each line has explanation after //. The arrow and indentation as per format. Use \"Decision:\" lines separate. Provide each step line.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 Trie 根節點 // 建立空白的根節點以存放字元\n→ Step 2: 定義 addWord(word) // 定義新增單詞的方法\n    → Step 3: current ← root // 從根節點開始遍歷\n    → Step 4: 對 word 的每個字符 c 執行\n        → Decision: c 是否為字母? // 判斷字符是否合法\n            Yes → Step 5: 如果 current.children[c] 不存在，創建新節點 // 建立缺失的子節點\n            Yes → Step 6: current ← current.children[c] // 移動到該子節點\n    → Step 7: current.isEnd ← true // 標記單詞結束位置\n→ Step 8: 定義 search(word) // 定義搜尋方法\n    → Step 9: 定義遞迴函式 dfs(idx, node) // 用於處理點號與字母\n        → Step 10: 如果 idx 等於 word.length，回傳 node.isEnd // 完成遍歷並判斷是否為完整單詞\n        → Step 11: c ← word[idx] // 取得當前字符\n        → Decision: c == '.'? // 判斷是否為通配符\n            Yes → Step 12: 對 node.children 的每個 child 執行\n                → Step 13: 如果 dfs(idx+1, child) 為 true，回傳 true // 找到匹配路徑\n            Yes → Step 14: 回傳 false // 所有子節點都未匹配\n            No  → Step 15: 如果 node.children[c] 存在\n                → Step 16: 回傳 dfs(idx+1, node.children[c]) // 直接遞迴到對應子節點\n            No  → Step 17: 回傳 false // 沒有對應子節點，匹配失敗\n    → Step 18: 回傳 dfs(0, root) // 從根節點開始搜尋\nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,5,5,8,8]'\nGot (Norm):      '[None,4,5,5,8,8]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 5, 5, 8, 8]'\nRaw Got:      '[None, 4, 5, 5, 8, 8]'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,7,7,7,8]'\nGot (Norm):      '[None,7,7,7,8]'\n--- (Raw) ---\nRaw Expected: '[null, 7, 7, 7, 8]'\nRaw Got:      '[None, 7, 7, 7, 8]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    ops, args = ast.literal_eval(data)\n    res = []\n    kth = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            kth = KthLargest(arg[0], arg[1])\n            res.append(None)\n        elif op == \"add\":\n            res.append(kth.add(arg[0]))\n    print(res)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for a class KthLargest with constructor and add method. Virtual code with steps, decisions, etc. Not actual code, just steps.\n\nWe need to maintain kth largest. Typical solution: min-heap of size k. Constructor builds heap from nums: push elements, if size > k pop. Add: push val, if size > k pop. Return top of heap (smallest among top k). Steps: start, initialize heap, fill, etc.\n\nWe produce line-by-line.\n\nUse Start, End. Use Decision etc. Provide brief explanation comments.\n\nWe need to follow format: each line: 虛擬碼步驟 [space] // 解釋/說明. Use arrow, etc.\n\nWe need to include class definition? The virtual code: maybe Step 1: Start class KthLargest // etc. We'll include Start at top.\n\nWe'll produce steps for constructor and add.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Define class KthLargest with properties k and minHeap // 宣告類別與必要屬性\n→ Step 2: Constructor(k, nums) // 初始化物件\n→ Decision: nums 為空? // 檢查初始分數陣列是否為空\n    Yes → Step 3: 初始化 minHeap 為空集合 // 沒有初始分數，直接空堆\n    No  → Step 4: For each score in nums: // 逐一處理初始分數\n        → Step 5: Insert score into minHeap // 加入堆\n        → Decision: minHeap.size > k? // 堆已超過 k 個\n            Yes → Step 6: Remove smallest from minHeap // 移除最小以維持大小\n            No  → No action\n→ Step 7: Store k in instance variable // 記錄 k 值\n→ End // 結束建構\n\nThen add method:\n\n→ Step 8: add(val) // 新增分數\n→ Step 9: Insert val into minHeap // 加入堆\n→ Decision: minHeap.size > k? // 堆超過 k 個\n    Yes → Step 10: Remove smallest from minHeap // 保持大小\n    No  → No action\n→ Step 11: Return minHeap.peek() // 返回第 k 大的分數\n→ End // add 方法結束\n\nWe can also wrap the methods as Steps inside class. Provide explanation comments.\n\nNeed to adhere to arrow and decisions. Use Start at top? They want Start and End for overall program. Might start with Start, then steps inside class. Then End.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 KthLargest // 建立類別\n    → Step 2: 宣告成員變數 k (int) 與 minHeap (最小堆) // 需要追蹤的資料結構\n→ Step 3: 定義 Constructor(k, nums) // 建構子\n    → Decision: nums 為空陣列? // 判斷是否有初始分數\n        Yes → Step 4: 將 minHeap 初始化為空堆 // 空資料\n        No  → Step 5: 對每個 score in nums:\n            → Step 6: 將 score 加入 minHeap // 插入堆\n            → Decision: minHeap.size > k? // 超過 k 個\n                Yes → Step 7: 移除堆中最小元素 // 保持大小\n                No  → No action\n    → Step 8: 設定實例變數 this.k = k // 儲存 k\n→ Step 9: 定義 add(val) 方法 // 新增分數\n    → Step 10: 將 val 加入 minHeap // 插入\n    → Decision: minHeap.size > k? // 超過 k 個\n        Yes → Step 11: 移除堆中最小元素 // 保持大小\n        No  → No action\n    → Step 12: 回傳 minHeap.peek() // 取得第 k 大分數\n→ End // 程式執行結束\n\nBut we need each line as separate with \"→\" arrows. The Start and End lines themselves.\n\nWe need to indent decisions properly. In the example, indentation inside Decision blocks is a new line with the decision and then lines for Yes and No. We'll mimic that.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Define class KthLargest // 建立類別\n    → Step 2: Declare member variable k (int) and minHeap (min-heap) // 需要的屬性\n→ Step 3: Constructor(k, nums) // 初始化\n    → Decision: nums is empty? // 檢查初始陣列\n        Yes → Step 4: Initialize minHeap as empty // 無初始分數\n        No  → Step 5: For each score in nums:\n            → Step 6: Insert score into minHeap // 加入堆\n            → Decision: minHeap.size > k? // 超過 k 個\n                Yes → Step 7: Remove smallest from minHeap // 保持大小\n                No  → No action\n    → Step 8: Set this.k = k // 儲存 k\n→ Step 9: Define add(val) // 新增分數\n    → Step 10: Insert val into minHeap // 加入堆\n    → Decision: minHeap.size > k? // 超過 k 個\n        Yes → Step 11: Remove smallest from minHeap // 保持大小\n        No  → No action\n    → Step 12: Return minHeap.peek() // 取得第 k 大分數\nEnd // 程式執行結束\n\nBut each line must be \"虛擬碼步驟 [空格] // 解釋\". We need to keep arrow and indentation but each line as separate. The example shows indent with spaces before Step. We'll follow.\n\nWe'll produce exactly each line.\n\nLet's write with \"→\" at start for all except Start and End.\n\nBut for decision branches, we need separate lines with \"Decision:\" and then Yes and No with arrow? In example, they used:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n\nSo we mimic that style.\n\nThus we need to produce lines with indentation accordingly.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Define class KthLargest // 建立類別\n    → Step 2: Declare member variable k (int) and minHeap (min-heap) // 需要追蹤的資料結構\n→ Step 3: Constructor(k, nums) // 初始化物件\n    → Decision: nums is empty? // 檢查是否有初始分數\n        Yes → Step 4: Initialize minHeap as empty // 沒有初始分數，空堆\n        No  → Step 5: For each score in nums:\n            → Step 6: Insert score into minHeap // 插入堆\n            → Decision: minHeap.size > k? // 堆已超過 k 個\n                Yes → Step 7: Remove smallest from minHeap // 移除最小以維持大小\n                No  → No action\n    → Step 8: Set this.k = k // 儲存 k 值\n→ Step 9: Define add(val) // 新增分數\n    → Step 10: Insert val into minHeap // 加入堆\n    → Decision: minHeap.size > k? // 堆超過 k 個\n        Yes → Step 11: Remove smallest from minHeap // 保持堆大小\n        No  → No action\n    → Step 12: Return minHeap.peek() // 返回第 k 大分數\nEnd // 程式執行結束\n\nWe need to ensure each line ends with comment. For \"No action\" maybe we need comment. We'll add comment after.\n\nThus: \"No  → No action // 保持堆大小不變\". Good.\n\nAlso \"No action\" maybe we skip but still comment.\n\nLet's adjust.\n\nAlso Step 4: Initialize minHeap as empty. Add comment.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class KthLargest // 建立類別  \n    → Step 2: Declare member variable k (int) and minHeap (min-heap) // 需要追蹤的資料結構  \n→ Step 3: Constructor(k, nums) // 初始化物件  \n    → Decision: nums is empty? // 檢查是否有初始分數  \n        Yes → Step 4: Initialize minHeap as empty // 沒有初始分數，空堆  \n        No  → Step 5: For each score in nums: // 逐一處理初始分數  \n            → Step 6: Insert score into minHeap // 插入堆  \n            → Decision: minHeap.size > k? // 堆已超過 k 個  \n                Yes → Step 7: Remove smallest from minHeap // 移除最小以維持大小  \n                No  → No action // 保持堆大小不變  \n    → Step 8: Set this.k = k // 儲存 k 值  \n→ Step 9: Define add(val) // 新增分數  \n    → Step 10: Insert val into minHeap // 加入堆  \n    → Decision: minHeap.size > k? // 堆超過 k 個  \n        Yes → Step 11: Remove smallest from minHeap // 保持堆大小  \n        No  → No action // 保持堆大小不變  \n    → Step 12: Return minHeap.peek() // 返回第 k 大分數  \nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpktdysz7m.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmpktdysz7m.py\", line 51, in main\n    result = multiply_complex(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpktdysz7m.py\", line 24, in multiply_complex\n    a_real, a_imag = parse_complex(a)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpktdysz7m.py\", line 17, in parse_complex\n    imag = int(s[pos:])\n           ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef parse_complex(s: str):\n    \"\"\"\n    將形如 'real+imagi' 的字串轉成兩個整數 (real, imag)。\n    這裡的 imag 可能為負數，例如 '1+-1i'。\n    \"\"\"\n    # 去除最後的 'i'\n    s = s.rstrip('i')\n    # 找到實部與虛部之間的分隔符號\n    if '+' in s[1:]:\n        pos = s.find('+', 1)\n    else:\n        pos = s.find('-', 1)\n    real = int(s[:pos])\n    imag = int(s[pos:])\n    return real, imag\n\ndef multiply_complex(a: str, b: str) -> str:\n    \"\"\"\n    計算兩個複數字串相乘，並回傳形如 'real+imagi' 的字串。\n    \"\"\"\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n\n    real_part = a_real * b_real - a_imag * b_imag\n    imag_part = a_real * b_imag + a_imag * b_real\n\n    return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    # 讀取整個輸入，預期是兩個帶引號的複數，逗號分隔\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 先嘗試從引號中擷取複數\n    parts = re.findall(r'\"([^\"]*)\"', raw)\n    if len(parts) >= 2:\n        num1, num2 = parts[0], parts[1]\n    else:\n        # 若沒有引號，直接以逗號分隔並去除空白\n        parts = [p.strip() for p in raw.split(',')]\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            # 無法解析輸入，直接退出\n            return\n\n    result = multiply_complex(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with explanation comments. Should include Start, End, Decision, etc. No actual code. Steps: parse strings into real1, imag1, real2, imag2. Multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i. Format result string: \"${real}+\" or \"-\". But spec: string format \"real+imaginaryi\". The imaginary part could be negative, but they still use '+'? Typically they'd use \"+\" sign then imaginary, but negative may use '-'? But we can just output \"real+imaginaryi\" even if negative. We'll just follow spec: use '+' sign then imaginary number then 'i', and imaginary may be negative so string shows e.g., \"3+-4i\". We'll keep simple.\n\nImplement parse function: find index of '+' or '-' before 'i', but real may be negative too. Approach: remove trailing 'i', find the position of the last '+' or '-' that separates real and imaginary. Use substring.\n\nBut pseudocode can assume we have functions. Use steps: Start, Step1: parse num1, Step2: parse num2, Step3: compute real part, Step4: compute imag part, Step5: format string, End.\n\nWe need to show decisions: For parse, we need decision: find separator index? but we can just parse by scanning from left.\n\nBut need arrow, decision lines. I'll produce simple decisions: If string contains '-' before last 'i'? But easier: find index of 'i', then search from left for last '+' or '-' after first char? Wait real part may start with '-'. So we search for the '+' or '-' that is not the first char and occurs before 'i'. So decision: if char before last 'i' after first char is '+' or '-'? Actually we can just find the position of '+' or '-' that separates. In pseudocode we can illustrate: Scan from index 1 to len-1 to find separator.\n\nWill produce steps with decisions.\n\nLet's craft lines:\n\nStart\n→ Step 1: Define function ParseComplex(str) // 將複數字串拆成實部和虛部\n    → Step 1.1: Remove trailing 'i' // 去掉最後的 'i'\n    → Step 1.2: Find separator position pos // 找出 '+' 或 '-' 之間的分隔符號\n        → Decision: 如果字串中有 '+' 在 index > 0? // 檢查是否存在 '+' 符號\n            Yes → pos = index of '+'\n            No  → pos = index of '-'  // 若無 '+'，則必有 '-' 分隔\n    → Step 1.3: realPart = substring(0, pos) // 取實部\n    → Step 1.4: imagPart = substring(pos) // 取虛部\n    → Step 1.5: return (int(realPart), int(imagPart)) // 轉成整數並回傳\n\n→ Step 2: (a, b) = ParseComplex(num1) // 解析第一個複數\n→ Step 3: (c, d) = ParseComplex(num2) // 解析第二個複數\n→ Step 4: realResult = a*c - b*d // 計算實部\n→ Step 5: imagResult = a*d + b*c // 計算虛部\n→ Step 6: resultStr = realResult + \"+\" + imagResult + \"i\" // 組合成字串\n→ End\n\nNeed to use arrow formatting. Ensure each line ends with comment after //.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 ParseComplex(str) // 先把複數字串拆成實部和虛部  \n    → Step 1.1: 移除字串末尾的 'i' // 去掉最後的 'i'  \n    → Step 1.2: 找出分隔符號 pos // 確定 '+' 或 '-' 的位置  \n        → Decision: 字串中是否存在 '+' 並且不是首字元? // 檢查是否有 '+'  \n            Yes → pos = 第一個 '+' 的索引  \n            No → pos = 第一個 '-' 的索引 // 若無 '+'，則必定是 '-'  \n    → Step 1.3: realPart = substring(0, pos) // 取得實部字串  \n    → Step 1.4: imagPart = substring(pos) // 取得虛部字串  \n    → Step 1.5: return (int(realPart), int(imagPart)) // 轉成整數並回傳  \n→ Step 2: (a, b) = ParseComplex(num1) // 解析第一個複數  \n→ Step 3: (c, d) = ParseComplex(num2) // 解析第二個複數  \n→ Step 4: realResult = a*c - b*d // 計算實部  \n→ Step 5: imagResult = a*d + b*c // 計算虛部  \n→ Step 6: resultStr = realResult + \"+\" + imagResult + \"i\" // 組合成輸出字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbdplfvgf.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpbdplfvgf.py\", line 29, in main\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbdplfvgf.py\", line 13, in rand10\n    a = rand7()          # 1~7\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdcmmpjft.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpdcmmpjft.py\", line 29, in main\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdcmmpjft.py\", line 13, in rand10\n    a = rand7()          # 1~7\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplgb2hffd.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmplgb2hffd.py\", line 29, in main\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmplgb2hffd.py\", line 13, in rand10\n    a = rand7()          # 1~7\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 假設 rand7() 會由測試環境提供，這裡不實作\n# def rand7():\n#     raise NotImplementedError(\"rand7() 必須由測試環境提供\")\n\nclass Solution:\n    def rand10(self):\n        \"\"\"使用兩次 rand7() 生成 1~49 的均勻分布，然後拒絕 41~49 的結果\n        最終返回 1~10 的均勻隨機數。\"\"\"\n        while True:\n            a = rand7()          # 1~7\n            b = rand7()          # 1~7\n            num = (a - 1) * 7 + b   # 1~49\n            if num <= 40:          # 可接受範圍\n                return 1 + (num - 1) % 10\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中提取第一個整數作為 n\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group())\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to implement rand10 using rand7. Classic method: use two rand7 to get 1-49, then reject >40 to map to 1-10 via modulo. Alternatively use rejection sampling with 7*7=49. Steps: start, get a = rand7, b = rand7, compute num = (a-1)*7 + b (range 1-49). If num > 40, repeat. Else return ((num-1)%10)+1. That suffices.\n\nWe need to output each line with \"虛擬碼步驟\" and explanation. Use Start, End, Decision. Use arrow syntax.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: result ← 0 // 初始化返回值\n→ Decision: 需要生成 rand10()？ // 循環調用直到生成成功\n    Yes → Step 2: a ← rand7() // 取得第一個隨機數\n    → Step 3: b ← rand7() // 取得第二個隨機數\n    → Step 4: num ← (a - 1) * 7 + b // 組合成 1~49\n    → Decision: num > 40 ? // 檢查是否在可接受範圍\n        Yes → // 若 >40，丟棄並重試\n            → Step 5: 跳回 Step 2 // 重新生成\n        No  → // 可接受，映射到 1~10\n            → Step 6: result ← ((num - 1) mod 10) + 1 // 轉換為 1~10\n            → Step 7: 返回 result // 給 caller\nEnd // 程式結束\n\nBut the decision tree might need correct formatting: Decision lines followed by Yes/No indents. Use appropriate arrows.\n\nMake sure each line includes \"→\" for steps, \"Decision:\" lines, \"Yes →\" \"No →\". Provide explanation after //. Let's craft.\n\nAlso maybe need a while loop: but using Decision structure. Use while loop logic via Decision.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化返回值  \n→ Decision: 需要生成 rand10()？ // 判斷是否要產生結果  \n    Yes → Step 2: a ← rand7() // 取得第一個隨機數  \n    → Step 3: b ← rand7() // 取得第二個隨機數  \n    → Step 4: num ← (a - 1) * 7 + b // 組合成 1~49 的隨機數  \n    → Decision: num > 40 ? // 檢查 num 是否在可接受範圍 1~40  \n        Yes → // 若超過 40，丟棄並重新嘗試  \n            → Step 5: 跳回 Step 2 // 重新生成 a、b  \n        No  → // num 在 1~40，進行映射到 1~10  \n            → Step 6: result ← ((num - 1) mod 10) + 1 // 將 num 映射到 1~10  \n            → Step 7: 返回 result // 結束函式，返回隨機數  \nEnd // 程式結束執行"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '789'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '789'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        Reverses the digits of a 32‑bit signed integer.\n        If the reversed integer overflows the 32‑bit range,\n        returns 0.\n        \"\"\"\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        rev = 0\n        while x != 0:\n            # pop the last digit, using truncation toward zero\n            pop = x % 10\n            x = int(x / 10)\n\n            # Check for overflow before it actually happens\n            if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n                return 0\n            if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n                return 0\n\n            rev = rev * 10 + pop\n\n        return rev\n\ndef main():\n    # Read all input and extract the first integer found\n    data = sys.stdin.read().strip()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    x = int(match.group())\n    sol = Solution()\n    result = sol.reverse(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step with explanation comments. It should not be actual code, but virtual code. Use arrows and structure. No real code. We'll implement reverse integer with overflow check without using 64-bit.\n\nWe will do algorithm: result = 0. sign = 1 or -1. abs_x = abs(x). While abs_x != 0: digit = abs_x % 10; abs_x = abs_x / 10; before append check overflow: if result > INT_MAX/10 or (result == INT_MAX/10 and digit > 7) for positive; for negative use 8? Actually when sign negative, we check against INT_MAX+1? We can handle by checking before appending: if result > INT_MAX/10 or (result == INT_MAX/10 and digit > 7) -> overflow. Then return 0. Then result = result*10 + digit. After loop, return sign*result.\n\nBut we cannot use 64-bit; we rely on 32-bit operations. Since we check overflow before multiplying.\n\nWe must also handle x=INT_MIN because abs(INT_MIN) cannot be represented as positive 32-bit. So we need to handle differently: we can use sign and work with negative numbers to avoid overflow? We can take negative numbers and work with abs but can't use abs(INT_MIN). Instead, we can work on negative numbers by storing negative result and building negative digits. Or we can convert to positive by using negative value: we can keep abs_x as x negative? Actually we can do while x != 0: digit = x % 10; x = x / 10; but remainder may be negative. We can get absolute digit: abs_digit = digit < 0 ? -digit : digit. Then use the same logic but building positive result, then apply sign. For INT_MIN, x % 10 yields -8, x/10 -> -214748364. Then abs_digit=8. Works fine.\n\nThus algorithm: result=0; sign=1; if x<0 sign=-1; abs_x = x; while abs_x != 0: digit = abs_x % 10; abs_x = abs_x / 10; abs_digit = digit<0? -digit:digit; // ensure positive digit\nCheck overflow: if result > INT_MAX/10 or (result == INT_MAX/10 and abs_digit > 7) -> return 0;\nresult = result*10 + abs_digit;\nAfter loop: return sign*result.\n\nEdge: x=0 return 0.\n\nAlso we need to consider 32-bit signed range: INT_MAX = 2147483647, INT_MIN = -2147483648. For negative sign, result*sign may produce overflow if result > 2147483648? But we already checked that result <= 2147483647; for negative sign, if result == 2147483648? Wait we cannot represent 2147483648 in 32-bit signed; but we cannot have that because we restrict digits. Actually for negative numbers, reversed may be -2147483648? Example x=-8463847412? But input is 32-bit. Let's think: x = -123456789, reverse = -987654321. That's within bounds. For negative reversed may be -2147483648 if x = -8463847412? But that's out-of-range input. For 32-bit input, reversed of -1463847412? Let's test: -1463847412 reversed digits: -2147483641 (within). The only case causing negative overflow is when result > 2147483648? But since we check result <= INT_MAX/10 and abs_digit <= 7, we guarantee result <= 214748364? Wait when sign negative we need to allow result <= 2147483648? Actually the negative limit is -2147483648; absolute value 2147483648. So we need to allow one more digit. In our check, we used abs_digit > 7 for both signs; but for negative case, if result == INT_MAX/10 and abs_digit == 8, then negative reversed may be -2147483648? Let's see: If result = 214748364, abs_digit=8 => result*10 + abs_digit = 2147483648 which is out of positive range; but after sign negative becomes -2147483648, which is allowed. However we cannot store 2147483648 in 32-bit signed. So we need to handle negative separately: we can use check for negative: if result > INT_MAX/10 or (result == INT_MAX/10 and abs_digit > 8) -> overflow? Actually we need to allow abs_digit=8 when sign negative. So we can perform sign-specific overflow check after computing potential new result. Since we cannot represent 2147483648, we need to keep result as 32-bit signed, but result currently positive. If result*10 + abs_digit overflows positive range, we will overflow. So we need to check before adding: if result > INT_MAX/10 or (result == INT_MAX/10 and abs_digit > 7) and sign==1 => overflow. If sign==-1 and result > INT_MAX/10 or (result == INT_MAX/10 and abs_digit > 8) => overflow? Wait we need to allow 8 for negative sign. But since result currently positive, result>INT_MAX/10? For INT_MAX/10 = 214748364. result can be 214748364. If abs_digit==8, result*10 + 8 = 2147483648 > INT_MAX. So we would overflow if we treat as positive. But we are going to apply sign afterwards. We cannot compute result as positive 2147483648; it would overflow. But we can allow it? We cannot store that in signed 32-bit. So we need to keep result as 32-bit and not exceed INT_MAX. But the negative reversed requires result to be 2147483648 (which cannot fit). But maybe we don't need to store that because we can store 2147483648 as unsigned? But environment does not allow 64-bit or unsigned 32-bit? It says cannot store 64-bit ints. But could store 32-bit unsigned? It's ambiguous. Usually can't store 64-bit. We can still store 32-bit unsigned maybe, but it's not guaranteed. Better to avoid exceeding INT_MAX. But if we can't represent 2147483648, we can't return negative reversed if it is -2147483648? But does any input produce reversed -2147483648? Let's check: x = -8463847412? That's out-of-range. But maybe x = -1463847412? reverse digits: -2147483641. So no. What input yields reversed -2147483648? That would be digits of 8463847412? Wait if we reverse -8463847412, digits are 2147483648, but input can't be that. For 32-bit integer input, the maximum magnitude is 2147483648 for INT_MIN. The only number that reversed yields -2147483648 would be -8463847412 which is not valid. So we can ignore that. The only potential overflow for negative is when result*10 + digit > INT_MAX, but if sign negative, we could allow up to 2147483648? Let's check example: x = -1563847412 reversed digits: -2147483651? Actually digits: 2,1,4,7,4,8,3,6,5,1? Not important. So maybe we can just use same overflow check as positive for simplicity, as we can't store 2147483648. But the official LeetCode solution uses same check with INT_MAX and INT_MIN. They check before multiplying: if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7) => overflow; and rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8) => overflow. But they use rev negative. But we are using positive rev. We can adapt accordingly.\n\nGiven complexity, we can produce pseudocode with checks for both sign cases. But easier: we can convert to negative result and operate with negative to avoid overflow for INT_MIN. Standard approach: use rev=0; while x !=0: pop = x %10; x /=10; if rev> INT_MAX/10 or rev==INT_MAX/10 and pop>7 => return 0; rev=rev*10 + pop; return rev. But that uses positive rev. For negative x, pop negative, but rev remains negative? Wait x%10 may produce negative remainder in C? In languages like Python, remainder has same sign as divisor? But we want to ensure rev stays negative. Actually standard approach is to use rev as integer, pop = x%10 (may be negative), then check overflow with rev and pop. They use rev*10 + pop. So rev stays same sign as x. This approach avoids abs() issue.\n\nWe can produce pseudocode accordingly: rev = 0; while x !=0: pop = x %10; x = x/10; if rev > INT_MAX/10 or (rev == INT_MAX/10 and pop > 7): return 0; if rev < INT_MIN/10 or (rev == INT_MIN/10 and pop < -8): return 0; rev = rev*10 + pop; return rev.\n\nThis uses signed 32-bit operations only.\n\nOk produce pseudocode lines accordingly.\n\nNeed to start with Start, then Step etc.\n\nWe need to include each line with explanation comment.\n\nLet's craft pseudocode:\n\nStart\n→ Step 1: 初始化 rev 為 0 // 用於存儲逆序結果\n→ Decision: x 是否等於 0? // 若為 0 直接返回\n    Yes → Step 2: 返回 0 // 逆序後仍為 0\n    No  → Step 3: 進入迴圈 // 開始處理每一位\n→ Loop Start // 迴圈：處理 x 的每個十進位\n    → Step 4: pop ← x mod 10 // 取 x 的最後一位數字（可能為負）\n    → Step 5: x ← x div 10 // 去掉已處理的最後一位\n    → Decision: rev > INT_MAX/10? // 檢查正向越界\n        Yes → Step 6: 返回 0 // 逆序後超出正整數上限\n        No  → Decision: rev = INT_MAX/10 且 pop > 7? // 邊界情況檢查\n            Yes → Step 6: 返回 0 // 逆序後正向越界\n            No  → Decision: rev < INT_MIN/10? // 檢查負向越界\n                Yes → Step 7: 返回 0 // 逆序後超出負整數下限\n                No  → Decision: rev = INT_MIN/10 且 pop < -8? // 邊界情況檢查\n                    Yes → Step 7: 返回 0 // 逆序後負向越界\n                    No  → Step 8: rev ← rev*10 + pop // 正常追加位數\n    → Decision: x 是否為 0? // 是否處理完所有位數\n        Yes → Step 9: 返回 rev // 逆序完成，返回結果\n        No  → (Loop back to Step 4) // 仍有位數未處理\n→ End\n\nBut we need to use virtual code style with arrows and decision indent. Each line separate.\n\nWe must avoid \"Loop Start\" maybe just indent steps inside the loop. Use \"Decision:\" with indent.\n\nAlso we need to indicate arrow before each line.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: rev ← 0 // 初始化逆序暫存\n→ Decision: x = 0? // 若輸入為 0\n    Yes → Step 2: return 0 // 逆序後仍為 0\n    No  → Step 3: // 進入主循環\n→ Step 4: pop ← x mod 10 // 取得最後一位數字\n→ Step 5: x ← x div 10 // 刪除最後一位\n→ Decision: rev > INT_MAX/10? // 正向越界檢查\n    Yes → Step 6: return 0 // 超出正上限\n    No  → Decision: rev = INT_MAX/10 ∧ pop > 7? // 邊界檢查\n        Yes → Step 6: return 0 // 正上限超出\n        No  → Decision: rev < INT_MIN/10? // 負向越界檢查\n            Yes → Step 7: return 0 // 超出負下限\n            No  → Decision: rev = INT_MIN/10 ∧ pop < -8? // 邊界檢查\n                Yes → Step 7: return 0 // 負下限超出\n                No  → Step 8: rev ← rev*10 + pop // 正常追加\n→ Decision: x = 0? // 所有位數已處理\n    Yes → Step 9: return rev // 完成逆序\n    No  → (Loop back to Step 4) // 繼續下一位\n\nBut we need to structure it like arrow and decision, and maybe \"Loop\" comment.\n\nWe need to output only these lines with explanation.\n\nWe should use \"Start\" and \"End\". Use \"→\" arrow before each line. For decision, use \"Decision:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: rev ← 0 // 初始化逆序暫存器  \n→ Decision: x = 0? // 檢查輸入是否為 0  \n Yes → Step 2: return 0 // 逆序後仍為 0，直接結束  \n No  → Step 3: // 進入主迴圈處理每一位  \n→ Step 4: pop ← x mod 10 // 取得 x 的最後一位數字（可能為負）  \n→ Step 5: x ← x div 10 // 去除已處理的最後一位  \n→ Decision: rev > INT_MAX / 10? // 檢查正向越界的先決條件  \n Yes → Step 6: return 0 // 逆序後會超出正整數上限  \n No  → Decision: rev = INT_MAX / 10 ∧ pop > 7? // 邊界情況檢查  \n  Yes → Step 6: return 0 // 正整數上限被超過  \n  No  → Decision: rev < INT_MIN / 10? // 檢查負向越界的先決條件  \n   Yes → Step 7: return 0 // 逆序後會超出負整數下限  \n   No  → Decision: rev = INT_MIN / 10 ∧ pop < -8? // 邊界情況檢查  \n    Yes → Step 7: return 0 // 負整數下限被超過  \n    No  → Step 8: rev ← rev * 10 + pop // 正常追加這一位數字  \n→ Decision: x = 0? // 判斷是否已處理完所有位數  \n Yes → Step 9: return rev // 逆序完成，返回結果  \n No  → (Loop back to Step 4) // 繼續處理下一位  \nEnd // 程式執行結束"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '0'"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        實作二分搜尋，返回目標值所在索引或插入位置\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(text):\n    \"\"\"\n    解析輸入字串，例如:\n        nums = [1,3,5,6], target = 5\n    轉成字典 {'nums': [1,3,5,6], 'target': 5}\n    \"\"\"\n    # 把等號改成冒號，並包成大括號即可使用 eval 解析\n    expr = \"{\" + text.replace('=', ':') + \"}\"\n    try:\n        data = eval(expr, {})\n    except Exception:\n        # 若解析失敗，回傳空字典\n        data = {}\n    return data\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入\n    data = parse_input(raw_input)\n    nums = data.get('nums', [])\n    target = data.get('target', 0)\n\n    # 進行搜尋插入位置\n    sol = Solution()\n    result = sol.searchInsert(nums, target)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for binary search insertion index. Provide each line with explanation. Must use Start, End, Decision etc. Format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows →. For decisions: Decision: condition. Then Yes→ and No→.\n\nWe need algorithm steps: Start, initialize low=0, high=len-1, while low <= high, mid=(low+high)//2, compare array[mid] to target: if equal return mid; if array[mid] < target, low = mid+1 else high = mid-1. After loop, low is insertion index return low. End.\n\nAdd explanation for each step.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: low ← 0, high ← len(array) - 1 // 初始化搜尋範圍\nLine 3: → Decision: low ≤ high? // 判斷是否還有未檢查區間\n   Yes → Step 2: mid ← (low + high) // 2 // 計算中點索引\n   Yes → Decision: array[mid] == target? // 檢查中點是否為目標\n       Yes → Step 3: Return mid // 找到目標，返回索引\n       No  → Decision: array[mid] < target? // 中點小於目標\n           Yes → Step 4: low ← mid + 1 // 搜尋右半區\n           No  → Step 5: high ← mid - 1 // 搜尋左半區\n   No  → Step 6: Return low // 目標不存在，low 為插入位置\nEnd // 程式執行結束\n\nMake sure each line is separate. Use correct indentation? It's fine.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: low ← 0, high ← len(array) - 1 // 初始化搜尋範圍\n→ Decision: low ≤ high? // 判斷是否還有未檢查區間\n    Yes → Step 2: mid ← (low + high) // 2 // 計算中點索引\n    Yes → Decision: array[mid] == target? // 檢查中點是否為目標\n        Yes → Step 3: Return mid // 找到目標，返回索引\n        No  → Decision: array[mid] < target? // 中點小於目標\n            Yes → Step 4: low ← mid + 1 // 搜尋右半區\n            No  → Step 5: high ← mid - 1 // 搜尋左半區\n    No  → Step 6: Return low // 目標不存在，low 為插入位置\nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjue394cm.py\", line 39, in <module>\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjue394cm.py\", line 34, in parse_input\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7a2016cf7a10>"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3xxbqih9.py\", line 39, in <module>\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3xxbqih9.py\", line 34, in parse_input\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7e5c36ef7a10>"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaboq2x7x.py\", line 39, in <module>\n    equations, values, queries = parse_input(raw_input)\n                                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpaboq2x7x.py\", line 34, in parse_input\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7184957fba50>"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef parse_input(input_str: str):\n    # Replace '=' with ':' to build a dictionary-like string\n    dict_str = '{' + input_str.replace('=', ':') + '}'\n    # Use literal_eval for safe parsing\n    data = ast.literal_eval(dict_str)\n    return data['equations'], data['values'], data['queries']\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    equations, values, queries = parse_input(raw_input)\n    solution = Solution()\n    answers = solution.calcEquation(equations, values, queries)\n    formatted = '[' + ','.join(f\"{ans:.5f}\" for ans in answers) + ']'\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem of evaluating division queries given equations. Provide step-by-step algorithm with explanation, using virtual code syntax. Must not output actual code, only pseudocode lines with arrow, decisions, etc.\n\nWe need to describe algorithm: build graph, do DFS or Union-Find with weights. Provide queries evaluation. We'll produce lines. Provide virtual code step lines.\n\nWe need to include start, end, decision, arrow. Use \"Start // 程式開始執行\" etc.\n\nLet's craft steps:\n\n- Start\n- Build graph adjacency list: for each equation, add edges both directions with weight values and reciprocal.\n- For each query, check if both variables exist in graph; if not, answer -1.0.\n- Else, perform DFS from numerator to denominator, accumulating product, keep visited.\n- If path found, return product; else -1.0.\n- Store answers.\n\nAlternatively, use Union-Find weighted.\n\nWe need to produce virtual steps per line with explanation. So each line will be a step. We can break into sub-steps like \"Step 1: Initialize graph\".\n\nLet's produce lines.\n\nWill incorporate decision steps for checking existence and path existence.\n\nLet's produce about maybe 15-20 lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的鄰接表 Graph // 用於存儲變數之間的比例關係  \n→ Step 2: 針對每個 equation[i] = [Ai, Bi] 與 values[i]  \n   → Step 3: 在 Graph[ Ai ] 加入 (Bi, values[i]) // Ai / Bi = values[i]  \n   → Step 4: 在 Graph[ Bi ] 加入 (Ai, 1 / values[i]) // Bi / Ai = 1/values[i]  \n→ Step 5: 建立答案陣列 Answers = [] // 用於儲存所有查詢的結果  \n→ Step 6: 針對每個 query[j] = [Cj, Dj]  \n   → Decision: 若 Cj 或 Dj 不在 Graph 中？ // 變數未定義  \n     Yes → Step 7: Answers.append(-1.0) // 無法計算，加入 -1.0  \n     No → Step 8: 呼叫 DFS(Cj, Dj, 1, visited=set()) // 從 Cj 開始搜尋  \n       → Decision: DFS 是否成功找到 Dj？ // 路徑存在？  \n        Yes → Step 9: Answers.append(DFS_result) // 取得比例值  \n        No → Step 10: Answers.append(-1.0) // 無法連結，加入 -1.0  \n→ Step 11: 回傳 Answers // 所有查詢的答案  \nEnd // 程式執行結束  \n\n// DFS(C, D, acc, visited)  \n→ Start // DFS 入口  \n   → Decision: 若 C == D？ // 起點即終點  \n     Yes → Return acc // 比例為 1.0  \n     No → visited.add(C) // 標記已訪問  \n   → Step 12: 針對每個 (neighbor, weight) 在 Graph[C]  \n     → Decision: 若 neighbor 未在 visited 中？  \n       Yes → Step 13: result = DFS(neighbor, D, acc * weight, visited)  \n           → Decision: 若 result != -1.0？  \n             Yes → Return result // 找到路徑，返回  \n             No → Continue // 試其他鄰居  \n   → Return -1.0 // 所有鄰居均已嘗試，無法到達 D  \nEnd // DFS 完成"
    },
    {
      "title": "Longest Palindromic Subsequence",
      "source_file": "Leetcode/leetcode516.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\n\ndef longest_palindrome_subseq(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    # dp[i][j] 代表 s[i:j+1] 的最长回文子序列长度\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1          # 单字符本身是回文\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    # 读取标准输入中的全部内容，去掉首尾空白字符\n    raw_input = sys.stdin.read().strip()\n    # 如果输入可能包含多行，只取第一行作为字符串\n    s = raw_input.splitlines()[0] if raw_input else \"\"\n    print(longest_palindrome_subseq(s))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for LPS length. Should include Start, steps, decisions. Use DP. Provide line by line. We should not output actual code, just steps. We need to use virtual arrows. So start, Step 1: get input string, Step 2: initialize DP matrix, etc. Provide decision steps for computing dp. Might also include nested loops.\n\nWe should produce something like:\n\nStart\n→ Step 1: 輸入字符串 s\n→ Step 2: 設定 n = s.length\n→ Step 3: 建立 2D 陣列 dp[n][n] 初始化為 0\n→ Step 4: for i = 0 to n-1: dp[i][i] = 1 // single char palindrome\n→ Step 5: for length = 2 to n: // subtring length\n    → Step 6: for i = 0 to n-length:\n        → Step 7: j = i + length - 1\n        → Decision: s[i] == s[j]?\n            Yes → dp[i][j] = dp[i+1][j-1] + 2\n            No → dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n→ Step 8: 輸出 dp[0][n-1] // 最長回文子序列長度\nEnd\n\nBut also need explanation after each line. Provide in Chinese. Use virtual arrows.\n\nWe must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows: \"→\" preceding each step. For decisions, use \"Decision:\" with nested Yes and No lines using \"Yes →\" \"No →\".\n\nAlso \"Start // 程式開始執行\" and \"End // 程式執行結束\".\n\nMake sure each step includes explanation. Provide as lines. Let's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字符串 s // 取得使用者輸入的字串  \n→ Step 2: 設定 n = s.length // 取得字串長度  \n→ Step 3: 建立 2D 陣列 dp[n][n]，所有元素初始化為 0 // 用於動態規劃存儲子問題答案  \n→ Step 4: for i = 0 to n-1: dp[i][i] = 1 // 單個字符本身即為長度為 1 的回文子序列  \n→ Step 5: for length = 2 to n: // 以子字串長度為主循環  \n    → Step 6: for i = 0 to n - length: // 子字串左端點  \n        → Step 7: j = i + length - 1 // 子字串右端點  \n        → Decision: s[i] == s[j]？ // 檢查兩端字符是否相同  \n            Yes → dp[i][j] = dp[i+1][j-1] + 2 // 相同，兩端字符可包住前面子字串的最長回文  \n            No  → dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 不同，取剔除左端或右端的較長回文子序列  \n→ Step 8: 輸出 dp[0][n-1] // 最長回文子序列的長度位於整體字串的 dp 表  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjykk7li5.py\", line 50, in parse_input\n    data = eval('{' + text.strip() + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpjykk7li5.py\", line 63, in <module>\n    begin, end, word_list = parse_input(input_text)\n                            ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjykk7li5.py\", line 57, in parse_input\n    parts[key.strip()] = eval(val.strip())\n                         ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n                   ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9r_3mw8u.py\", line 50, in parse_input\n    data = eval('{' + text.strip() + '}')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp9r_3mw8u.py\", line 63, in <module>\n    begin, end, word_list = parse_input(input_text)\n                            ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9r_3mw8u.py\", line 57, in parse_input\n    parts[key.strip()] = eval(val.strip())\n                         ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n                   ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return []\n\n        # BFS 取得每個單字的最短距離與前驅節點\n        level = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = level[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        if new_word not in level:\n                            level[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif level[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse input of the form:\n    beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    \"\"\"\n    # Wrap with braces to create a dictionary literal\n    try:\n        data = eval('{' + text.strip() + '}')\n    except Exception:\n        # Fallback: if input is split across lines\n        parts = {}\n        for line in text.strip().splitlines():\n            if '=' in line:\n                key, val = line.split('=', 1)\n                parts[key.strip()] = eval(val.strip())\n        data = parts\n    return data['beginWord'], data['endWord'], data['wordList']\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    begin, end, word_list = parse_input(input_text)\n    solution = Solution()\n    result = solution.findLadders(begin, end, word_list)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find all shortest transformation sequences (word ladder II). Use BFS for shortest path, then DFS/backtracking from end to begin using predecessors map.\n\nNeed to output step by step virtual code, each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow.\n\nLet's produce:\n\nStart\n→ Initialize wordSet from wordList\n→ If endWord not in wordSet → End with empty list (no sequences)\n→ Initialize queue with beginWord, level map with distance 0\n→ Initialize predecessors dict mapping word->list of prev words\n→ While queue not empty:\n    → Dequeue current word\n    → For each position i in word:\n        → For each letter 'a' to 'z':\n            → Build nextWord by replacing char\n            → If nextWord in wordSet:\n                → If nextWord not visited:\n                    → Set level[nextWord] = level[current]+1\n                    → Enqueue nextWord\n                    → Append current to predecessors[nextWord]\n                → Else if level[nextWord] == level[current]+1:\n                    → Append current to predecessors[nextWord]\n    → Continue BFS until level of endWord found, break\n→ If endWord not in level → End with empty list\n→ Initialize result list, path list with endWord\n→ DFS function backtrack(word):\n    → If word == beginWord:\n        → Append reversed path to result\n    → Else:\n        → For each prev in predecessors[word]:\n            → Append prev to path\n            → backtrack(prev)\n            → Pop prev from path\n→ Call backtrack(endWord)\n→ End // output result\n\nNow produce each step line with comments.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ 虛擬碼步驟: 初始化 wordSet 為 wordList 的集合 // 方便 O(1) 查找\n→ 虛擬碼步驟: 若 endWord 不在 wordSet → End // 沒有可達路徑，直接返回空\n→ 虛擬碼步驟: 建立 queue, level, predecessors // queue 用於 BFS，level 記錄最短距離，predecessors 存儲前驅關係\n→ 虛擬碼步驟: enqueue(beginWord)，level[beginWord] ← 0 // BFS 起點\n→ 虛擬碼步驟: Boolean foundEnd ← false // 標記是否已找到 endWord\n→ 虛擬碼步驟: Decision: queue 是否空？ // 確認是否還有節點可探索\n    Yes → End // queue 為空且未找到 endWord，返回空\n    No  → → 虛擬碼步驟: Dequeue currentWord // 取出下一個節點\n         → 虛擬碼步驟: For i in 0 .. length(currentWord)-1 // 逐位嘗試改字\n             → 虛擬碼步驟: For c in 'a'..'z'\n                 → 虛擬碼步驟: nextWord ← currentWord 的第 i 位改成 c // 生成候選詞\n                 → 虛擬碼步驟: Decision: nextWord 是否在 wordSet？\n                     Yes →\n                         → 虛擬碼步驟: Decision: nextWord 是否已在 level？\n                             Yes →\n                                 → 虛擬碼步驟: Decision: level[nextWord] == level[currentWord] + 1？\n                                     Yes →\n                                         → 虛擬碼步驟: Append currentWord 至 predecessors[nextWord] // 同層前驅\n                                     No  → No operation\n                             No  →\n                                 → 虛擬碼步驟: level[nextWord] ← level[currentWord] + 1 // 設定距離\n                                 → 虛擬碼步驟: Enqueue(nextWord) // 探索新節點\n                                 → 虛擬碼步驟: Append currentWord 至 predecessors[nextWord] // 新前驅\n                         → 虛擬碼步驟: Decision: nextWord == endWord？\n                             Yes → foundEnd ← true // 已找到最短層的終點\n                             No  → No operation\n                     No  → No operation\n         → 虛擬碼步驟: Decision: foundEnd？\n             Yes → Break // 只需完成當前層即可，保證最短\n             No  → No operation\n→ 虛擬碼步驟: Decision: endWord 是否在 level？\n    Yes → // 有路徑\n    No  → End // 無可行路徑，返回空\n→ 虛擬碼步驟: result ← [] // 儲存所有最短序列\n→ 虛擬碼步驟: path ← [endWord] // 從終點開始回溯\n→ 虛擬碼步驟: Function backtrack(word)\n    → 虛擬碼步驟: Decision: word == beginWord？\n        Yes →\n            → 虛擬碼步驟: Append reversed(path) 到 result // 完整序列已建立\n        No  →\n            → 虛擬碼步驟: For each prev in predecessors[word]\n                → 虛擬碼步驟: Append prev 至 path\n                → 虛擬碼步驟: backtrack(prev)\n                → 虛擬碼步驟: Pop prev 從 path // 回溯\n→ 虛擬碼步驟: Call backtrack(endWord) // 開始回溯構造所有路徑\n→ End // 程式執行結束，返回 result\n```"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.35791,0.7409],[-0.37521,-0.20081],[-0.39278,0.66336]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.35791, 0.7409], [-0.37521, -0.20081], [-0.39278, 0.66336]]'"
        }
      ],
      "generated_code": "import sys\nimport math\nimport random\nimport json\nimport ast\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 均勻生成極座標後轉為笛卡兒座標\n        r = self.radius * math.sqrt(random.random())      # sqrt 保證半徑均勻分布\n        theta = random.uniform(0, 2 * math.pi)           # 隨機角度\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = ast.literal_eval(data[0])           # 例如 [\"Solution\",\"randPoint\",...]\n    args = ast.literal_eval(data[1]) if len(data) > 1 else []   # 例如 [[1.0,0.0,0.0], [], ...]\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)                # 建構子回傳 null\n        else:\n            method = getattr(obj, op)\n            out = method(*arg)\n            results.append(out)\n\n    # 轉成 json 以符合要求的 null 表示\n    # 同時把浮點數四捨五入至 5 位小數\n    formatted = []\n    for item in results:\n        if isinstance(item, list):\n            formatted.append([round(v, 5) for v in item])\n        else:\n            formatted.append(item)\n    print(json.dumps(formatted))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the described functionality. We should describe how to initialize, how to generate random point uniformly inside circle. Use method: generate random radius sqrt(rnd) * radius, angle uniform [0,2π). Compute x = center_x + r * cosθ, y similarly. Steps: initialize parameters, create randPoint function, generate random number, etc. Also handle random uniform. Use standard library functions: random.random(), random.uniform(0,1), random.uniform(0,2π). But we use virtual code. Must not output actual code. Use virtual steps. Provide explanation after each line. Use Start, End, Decision, arrow. Ensure each line has \"虛擬碼步驟 [空格] // 解釋\". Let's produce. Ensure Chinese explanation.\n\nWe need to produce step-by-step virtual code. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution，初始化 radius, x_center, y_center // 存儲圓參數\n→ Step 2: 在建構函式中將參數存入成員變數 // 方便後續調用\n→ Decision: 是否需要生成隨機點？ // 呼叫 randPoint 方法\n    Yes → Step 3: 產生亂數 u 在 [0,1) // 用於半徑計算\n    → Step 4: 計算 r = sqrt(u) * radius // 確保均勻分佈\n    → Step 5: 產生亂數 theta 在 [0, 2π) // 隨機角度\n    → Step 6: 計算 x = x_center + r * cos(theta) // 將極坐標轉為笛卡兒\n    → Step 7: 計算 y = y_center + r * sin(theta) // 同上\n    → Step 8: 返回 [x, y] // 隨機點\nEnd // 程式執行結束\n\nBut need to maintain Start and End. Use arrow for steps. Might use Decision: but it's not really a decision. Maybe simpler: Start, Step, End. But we can include Decision? The requirement says use Decision arrow but not necessary. It's okay.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution，並在建構子中接受 radius, x_center, y_center 參數 // 以便保存圓的半徑與中心座標\n→ Step 2: 在建構子內將參數存入成員變數 this.radius、this.x_center、this.y_center // 方便在 randPoint 方法中使用\n→ Step 3: 定義方法 randPoint() // 生成並回傳隨機點\n    → Step 3.1: 產生一個均勻亂數 u ∈ [0,1) // 用於計算半徑\n    → Step 3.2: 計算 r = sqrt(u) * this.radius // sqrt 使半徑分佈均勻於圓面\n    → Step 3.3: 產生一個均勻亂數 theta ∈ [0, 2π) // 隨機角度\n    → Step 3.4: 計算 x = this.x_center + r * cos(theta) // 將極坐標轉為笛卡兒座標\n    → Step 3.5: 計算 y = this.y_center + r * sin(theta) // 同上\n    → Step 3.6: 回傳 [x, y] // 返回隨機點座標\nEnd // 程式執行結束"
    },
    {
      "title": "Edit Distance",
      "source_file": "Leetcode/leetcode72.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '9'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '9'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef min_distance(word1: str, word2: str) -> int:\n    \"\"\"計算將 word1 轉換成 word2 所需的最小操作數（插入、刪除、替換）\"\"\"\n    m, n = len(word1), len(word2)\n    # dp[i][j] 代表將 word1[:i] 轉換成 word2[:j] 的最小操作數\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    # 初始化第一行（將空字串轉換成前 j 個字元，必須插入 j 次）\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    # 初始化第一列（將前 i 個字元轉換成空字串，必須刪除 i 次）\n    for i in range(m + 1):\n        dp[i][0] = i\n\n    # 填充 DP 表\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                # 字元相同，遞移\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                # 字元不同，考慮插入、刪除、替換三種操作\n                insert_cost = dp[i][j - 1] + 1\n                delete_cost = dp[i - 1][j] + 1\n                replace_cost = dp[i - 1][j - 1] + 1\n                dp[i][j] = 1 + min(insert_cost, delete_cost, replace_cost)\n\n    return dp[m][n]\n\ndef parse_input(data: str) -> tuple[str, str]:\n    \"\"\"\n    從輸入字串中擷取兩個字串\n    例：'word1 = \"horse\", word2 = \"ros\"' 會得到 ('horse', 'ros')\n    \"\"\"\n    # 先嘗試從雙引號中抽取\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        return matches[0], matches[1]\n\n    # 若沒找到雙引號，則使用簡易分隔方式\n    parts = data.split(',')\n    w1 = parts[0].split('=')[1].strip().strip('\"')\n    w2 = parts[1].split('=')[1].strip().strip('\"')\n    return w1, w2\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    word1, word2 = parse_input(raw_input)\n    result = min_distance(word1, word2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for computing edit distance (Levenshtein distance) between two strings. Provide step-by-step pseudocode lines with comments. Use arrows and decisions. No actual code, just steps. Let's produce a standard DP algorithm: create DP table of size (len1+1)*(len2+1). Initialize first row/col. Then iterate and compute min of three options + cost. Finally return dp[len1][len2].\n\nWe should produce step-by-step. Each line is a \"虛擬碼步驟\" followed by comment. Use arrows \"→\" etc. Must be line by line. Let's format. Use Start, End. Use Decision for condition checks. We need to keep structure.\n\nLet's produce.\n\nWe'll start:\n\nStart // 程式開始\n\n→ Step 1: 定義 n = len(word1), m = len(word2) // 取得兩字串長度\n\n→ Step 2: 創建 DP 陣列 dp[n+1][m+1] // 初始化距離表\n\n→ Step 3: 初始化第一行 dp[0][j] = j for j in 0..m // 由空字串轉換到 word2 的插入數\n\n→ Step 4: 初始化第一列 dp[i][0] = i for i in 0..n // 由 word1 轉換到空字串的刪除數\n\n→ Decision: 是否還有 i, j 循環? // 開始填充 DP 表\n\n    → Step 5: 對 i from 1 to n\n\n        → Step 6: 對 j from 1 to m\n\n            → Decision: word1[i-1] == word2[j-1] // 字元相等嗎？\n\n                Yes → Step 7: dp[i][j] = dp[i-1][j-1] // 相等，無需操作\n\n                No  → Step 8: 計算 insert_cost = dp[i][j-1] + 1 // 插入\n\n                → Step 9: 計算 delete_cost = dp[i-1][j] + 1 // 刪除\n\n                → Step 10: 計算 replace_cost = dp[i-1][j-1] + 1 // 替換\n\n                → Step 11: dp[i][j] = min(insert_cost, delete_cost, replace_cost) // 取最小操作數\n\n→ Step 12: 回傳 dp[n][m] // 最小操作數\n\nEnd // 程式結束\n\nBut we need arrow indenting for nested loops? Format typical:\n\n→ Step 5: For i = 1 to n\n\n    → Step 6: For j = 1 to m\n\n        etc.\n\nWe'll produce as separate lines with arrow and indent spaces? They didn't specify indentation but we can show nested with indentation. We'll keep simple.\n\nAlso note that we might need to show Decision: with Yes → etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 n = len(word1), m = len(word2) // 取得兩字串長度  \n→ Step 2: 創建 DP 陣列 dp[n+1][m+1] // 初始化距離表  \n→ Step 3: 初始化第一行 dp[0][j] = j for j in 0..m // 由空字串轉換到 word2 的插入數  \n→ Step 4: 初始化第一列 dp[i][0] = i for i in 0..n // 由 word1 轉換到空字串的刪除數  \n\n→ Decision: 開始填充 DP 表? // 進入雙層迴圈  \n    → Step 5: 對 i from 1 to n  \n        → Step 6: 對 j from 1 to m  \n            → Decision: word1[i-1] == word2[j-1] // 字元相等嗎？  \n                Yes → Step 7: dp[i][j] = dp[i-1][j-1] // 相等，無需操作  \n                No  → Step 8: insert_cost = dp[i][j-1] + 1 // 插入操作成本  \n                → Step 9: delete_cost = dp[i-1][j] + 1 // 刪除操作成本  \n                → Step 10: replace_cost = dp[i-1][j-1] + 1 // 替換操作成本  \n                → Step 11: dp[i][j] = min(insert_cost, delete_cost, replace_cost) // 選擇最小成本  \n\n→ Step 12: 回傳 dp[n][m] // 最小操作數  \nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkhp87a_3.py\", line 40, in <module>\n    strs, m, n = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkhp87a_3.py\", line 29, in parse_input\n    strs = ast.literal_eval(val.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"10\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo37hgd4g.py\", line 40, in <module>\n    strs, m, n = parse_input(raw_input)\n                 ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpo37hgd4g.py\", line 29, in parse_input\n    strs = ast.literal_eval(val.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"10\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    將類似 'strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3' 的輸入轉換為\n    (strs, m, n) 的三元組。\n    \"\"\"\n    # 移除可能的換行並拆分為逗號分隔的片段\n    parts = [p.strip() for p in data.replace('\\n', ' ').split(',')]\n    strs = []\n    m = n = 0\n    for part in parts:\n        if part.startswith('strs'):\n            _, val = part.split('=', 1)\n            strs = ast.literal_eval(val.strip())\n        elif part.startswith('m'):\n            _, val = part.split('=', 1)\n            m = int(val.strip())\n        elif part.startswith('n'):\n            _, val = part.split('=', 1)\n            n = int(val.strip())\n    return strs, m, n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    strs, m, n = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for the problem: given array of binary strings strs and integers m, n, return size of largest subset such that at most m zeros and n ones. Classic DP 0-1 knapsack with two dimensions. We need to generate pseudo code line by line with explanations, following format. Provide Start, End, Decision, etc. Need to describe steps: initialize dp array (m+1)*(n+1) zero; iterate over each string, count zeros and ones; iterate i from m down to zeros, j from n down to ones; dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1); After processing all, answer is dp[m][n].\n\nAlso need to explain each line.\n\nMake sure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows and decisions accordingly.\n\nWe can use structure: Start, → Step ... etc.\n\nEnsure each line is separate.\n\nLet's craft.\n\nWe need to consider that each string count zeros/ones: Step: for each string.\n\nWe need loops: for each str in strs; then compute z, o; then nested loops for i from m down to z; for j from n down to o; update.\n\nFinally, End.\n\nAdd decisions? maybe Decision: if string has zeros > m or ones > n then skip? Not necessary but can include.\n\nWe should include \"Decision:\" before updating dp maybe.\n\nOk produce.\n\nLet's create lines:\n\nStart\n\n→ Step 1: 初始化 dp 矩陣大小 (m+1) × (n+1)，全部設為 0 // 設置動態規劃表\n\n→ For each string s in strs: // 遍歷所有二進制字串\n\n    → Step 2: 計算 s 中 0 的數量 z 和 1 的數量 o // 為後續 DP 更新做準備\n\n    → Decision: 是否能放入子集？ // 檢查 z <= m 且 o <= n\n\n        Yes → For i from m down to z:\n\n            → For j from n down to o:\n\n                → Step 3: dp[i][j] = max(dp[i][j], dp[i-z][j-o] + 1) // 更新子問題答案\n\n        No  → // 若超出限制，直接跳過此字串\n\nEnd // 回傳 dp[m][n] 作為最大子集大小\n\nBut the output requires each line. So we need to flatten loops: each line separate. Use indentation maybe but each line still counted. Use spaces. For nested loops, we might use arrows with indentation.\n\nWe should produce lines with \"→\" for steps, \"Decision:\" for decisions. For loops, maybe \"→ For i from m down to z:\" etc.\n\nWe need to ensure each line contains code + // explanation. Example.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 矩陣，大小為 (m+1) × (n+1)，所有值設為 0 // 建立 2 維動態規劃表  \n→ For each string s in strs: // 遍歷輸入的每個二進制字串  \n → Step 2: 計算 s 中 0 的數量 z 與 1 的數量 o // 為 DP 更新準備統計  \n → Decision: z ≤ m 且 o ≤ n? // 判斷此字串是否可能被加入子集  \n  Yes → For i from m down to z: // 從高到低遍歷 0 的容量，避免重複使用同一字串  \n   → For j from n down to o: // 同樣從高到低遍歷 1 的容量  \n    → Step 3: dp[i][j] = max(dp[i][j], dp[i‑z][j‑o] + 1) // 更新最佳子集大小  \n  No  → // 超過容量限制，直接跳過此字串  \nEnd // 程式結束，返回 dp[m][n] 作為答案，表示最大的可行子集大小"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列與工作副本\n        self.original = nums[:]\n        self.nums = nums[:]\n\n    def reset(self):\n        # 重置為原始陣列並回傳\n        self.nums = self.original[:]\n        return self.nums\n\n    def shuffle(self):\n        # Fisher–Yates 洗牌演算法\n        shuffled = self.nums[:]\n        n = len(shuffled)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        sys.exit()\n\n    # 將輸入包成外層列表方便解析\n    data = ast.literal_eval('[' + input_str + ']')\n    ops, args = data\n\n    outputs = []\n    solution = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 為 [[1,2,3]]，取第一個元素作為 nums\n            solution = Solution(arg[0])\n            outputs.append(None)          # 物件建立時不回傳值\n        elif op == \"shuffle\":\n            outputs.append(solution.shuffle())\n        elif op == \"reset\":\n            outputs.append(solution.reset())\n\n    # 以 JSON 形式輸出，Python 的 None 會轉成 null\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow, decision, etc. Provide the algorithm: store original, maintain array copy. shuffle uses Fisher-Yates. reset returns original copy.\n\nWe should describe steps. Provide Start, then steps for constructor, reset, shuffle.\n\nNeed to use virtual code syntax with arrow, Decision: etc. Provide explanation after each line with //.\n\nWe should not produce actual code, just pseudocode. Provide each step on separate line. For methods we need to show the process inside.\n\nLet's craft.\n\nStart\n\n→ Step 1: 初始化 class Solution with nums // store original array\n\nBut we need to show steps of constructor: set this.original = copy of nums; this.nums = copy of nums\n\nReset method: return copy of original\n\nShuffle method: for i from last to 1: pick random j between 0 and i inclusive; swap nums[i], nums[j]; return nums\n\nWe need to use arrow lines with explanation.\n\nAlso include Decision? maybe not needed.\n\nBut we might include decision for shuffle? Not necessary.\n\nBut we can include Decision: if i == 0? etc. Not needed.\n\nJust provide straightforward steps.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類別 Solution // 定義 Solution 類別\n\n→ Step 2: 宣告成員變數 original, nums // 用於保存原始和工作副本\n\n→ Step 3: Constructor: 接收參數 nums // 建構子初始化\n\n→ Step 4: original ← 複製 nums // 保存原始陣列\n\n→ Step 5: this.nums ← 複製 nums // 工作副本\n\n→ Step 6: End of Constructor\n\n→ Step 7: 方法 reset() // 重置並返回原始陣列\n\n→ Step 8: 返回 original 的複製 // 確保不被修改\n\n→ Step 9: 方法 shuffle() // 隨機打亂陣列\n\n→ Step 10: for i ← len(nums)-1 downto 1 // 從最後一個元素往前遍歷\n\n→ Step 11: 隨機產生 j 介於 0 和 i 之間 // Fisher–Yates 隨機索引\n\n→ Step 12: 交換 nums[i] 與 nums[j] // 進行元素交換\n\n→ Step 13: End for\n\n→ Step 14: 返回 nums // 返回打亂後的陣列\n\nEnd // 程式執行結束\n\nWe need each line to include \"虛擬碼步驟\" and explanation after space. Provide arrow and explanation. Use // for comments.\n\nWe must maintain format: \"虛擬碼步驟 [空格] // 解釋\"\n\nWe need to keep \"→\" arrow. For method start we can do \"→ Method: reset()\". Provide arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 宣告成員變數 original, nums // 用於保存原始陣列及其副本  \n→ Step 3: Constructor: 接收參數 nums // 建構子初始化輸入陣列  \n→ Step 4: original ← 複製 nums // 保留原始順序  \n→ Step 5: this.nums ← 複製 nums // 建立工作副本以進行操作  \n→ Step 6: End of Constructor // 建構完成  \n→ Step 7: 方法 reset() // 重置並返回原始陣列  \n→ Step 8: 返回 original 的複製 // 確保不被外部修改  \n→ Step 9: 方法 shuffle() // 隨機打亂陣列  \n→ Step 10: for i ← len(nums)-1 downto 1 // 從最後一個元素往前遍歷  \n→ Step 11: 隨機產生 j 介於 0 和 i 之間 // Fisher–Yates 隨機索引  \n→ Step 12: 交換 nums[i] 與 nums[j] // 進行元素交換  \n→ Step 13: End for // 迴圈結束  \n→ Step 14: 返回 nums // 返回打亂後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            # 把目前的子集加入結果\n            res.append(path[:])\n            # 從 start 開始嘗試加入每個元素\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()  # 回溯\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 取得第一個 [ 開始到 ] 結束的子字串\n    try:\n        start = data.index('[')\n        end = data.rindex(']')\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)  # 轉成 list\n    except (ValueError, SyntaxError):\n        # 若輸入格式不正確，直接結束\n        sys.exit()\n\n    solution = Solution()\n    subsets = solution.subsets(nums)\n\n    # 以逗號不加空格的格式輸出，符合範例\n    print(json.dumps(subsets, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of a set of unique elements. Use backtracking approach. Steps: Start, initialize result list, sort or not. Define DFS function with index and current subset. Append copy. Recurse with include or skip. End. No actual code. Provide each line with explanation. Use virtual code syntax: Start, → Step etc. Provide decision for include? Use backtracking. Provide pseudocode. Use arrow to denote flow. Ensure each line ends with // explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空清單 result 用以存放所有子集 // 初始化結果集  \n→ Step 2: 建立空清單 temp 用以暫存目前子集 // 暫存子集  \n→ Step 3: 呼叫 DFS(index = 0, temp) // 開始深度優先搜尋  \n→ Step 4: Return result // 程式結束，輸出所有子集  \n\nDecision: DFS(index, temp) // 定義遞迴搜尋函式  \n    → Step 5: 將 temp 的副本加入 result // 每一次遞迴都把目前子集加入結果  \n    → Decision: 如果 index == len(nums)? // 檢查是否已經走到陣列尾  \n        Yes → End of DFS // 結束此路徑  \n        No  →  \n            → Step 6: temp.append(nums[index]) // 將 nums[index] 加入目前子集  \n            → Step 7: DFS(index + 1, temp) // 進一步遞迴，包含當前元素  \n            → Step 8: temp.pop() // 移除最後加入的元素，回朔至不包含該元素的狀態  \n            → Step 9: DFS(index + 1, temp) // 進一步遞迴，排除當前元素  \nEnd // 程式結束執行"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp19co454p.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmp19co454p.py\", line 57, in main\n    methods = ast.literal_eval('[' + m.group(1) + ']')\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2]\n                                                                                                              ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)      # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)    # userId -> set of followees\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # 每位使用者自己都視為關注者\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        res = []\n        if userId not in self.following:\n            return res\n        heap = []\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid, [])\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n        # 保證自己被視為關注者\n        self.following[followerId].add(followerId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入為兩個列表\n    m = re.match(r'\\s*\\[(.*)\\]\\s*,\\s*\\[(.*)\\]\\s*', data, re.S)\n    if not m:\n        return\n    methods = ast.literal_eval('[' + m.group(1) + ']')\n    args = ast.literal_eval('[' + m.group(2) + ']')\n\n    results = []\n    obj = None\n    for method, arg in zip(methods, args):\n        if method == 'Twitter':\n            obj = Twitter()\n            results.append(None)\n        else:\n            func = getattr(obj, method)\n            if arg:\n                res = func(*arg)\n            else:\n                res = func()\n            results.append(res)\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with arrows, decisions, start end. Should outline design: initialize maps: user to set of followees, tweets list per user with timestamp maybe global counter. For getNewsFeed: collect tweets from followees + self, use min-heap to get 10 recent. Provide steps. Should not output real code but steps. Let's produce algorithm. We'll describe class structure, methods. Each method's steps. Use arrows for flow.\n\nMake sure to follow format: \"虛擬碼步驟 // 解釋\". Provide start end for class? Probably start of class design, but we can treat as initialization step. Use arrows to show flows.\n\nLet's produce:\n\nStart // 初始化Twitter物件\n\n→ Step 1: 建立全域時間戳計數器 timestamp ← 0 // 追蹤發佈時間\n\n→ Step 2: 建立 Map userId → Set of followees // 追蹤關注關係\n\n→ Step 3: 建立 Map userId → List of (tweetId, timestamp) // 追蹤使用者貼文\n\nEnd // 物件建立完成\n\nThen methods:\n\npostTweet:\n\nStart // 發佈推文\n→ Step 1: 若 userId 不在 followMap, 創建空 Set // 保證存在\n→ Step 2: 若 userId 不在 tweetMap, 創建空 List // 保證存在\n→ Step 3: timestamp ← timestamp + 1 // 增加全域時間\n→ Step 4: 在 tweetMap[userId] 加入 (tweetId, timestamp) // 存儲貼文\nEnd // 推文發佈完成\n\ngetNewsFeed:\n\nStart // 取最新 10 條推文\n→ Step 1: 若 userId 不在 followMap, 創建空 Set // 方便後續\n→ Step 2: 取得 followSet ← followMap[userId] ∪ {userId} // 包含自己\n→ Step 3: 初始化最小堆 (size ≤10) // 用於保存最近 10 條\n→ Step 4: 對每個 uid in followSet:\n          → Step 4a: 取 tweetList ← tweetMap[uid] // 若不存在則空\n          → Step 4b: 取該列表最後 10 個元素 (最近 10)\n          → Step 4c: 對於每個 (tid, ts) in 取出的元素:\n                    → Decision: 堆大小 <10? // 若未滿\n                        Yes → Push (ts, tid) 到堆 // 直接放\n                        No  → Decision: ts > 堆最小時間戳? // 是否比堆最小更新\n                            Yes → Pop 最小, Push (ts, tid) // 替換\n                            No  → 跳過\n        End for\n→ Step 5: 從堆中彈出所有元素並按時間倒序排列得到結果 list // 10 條最新\nEnd // 回傳結果\n\nfollow:\n\nStart // 追蹤\n→ Step 1: 若 followerId 不在 followMap, 創建空 Set\n→ Step 2: 在 followMap[followerId] 加入 followeeId // 追蹤\nEnd\n\nunfollow:\n\nStart // 取消追蹤\n→ Step 1: 若 followerId 不在 followMap, 創建空 Set // 免除異常\n→ Step 2: 從 followMap[followerId] 刪除 followeeId // 取消\nEnd\n\nWe must ensure each line ends with // explanation.\n\nAlso need to mention class methods start and end? Use Start/End tags.\n\nLet's produce lines accordingly.\n\nUse Chinese comments. Ensure format \"虛擬碼步驟 // 解釋\".\n\nLet's output.\n...done thinking.\n\nStart // 初始化 Twitter 物件  \n→ Step 1: timestamp ← 0 // 全域時間戳，用於排序貼文  \n→ Step 2: followMap ← Map<userId, Set<followeeId>> // 追蹤每位使用者的關注對象  \n→ Step 3: tweetMap ← Map<userId, List<(tweetId, timestamp)>> // 追蹤每位使用者的貼文及時間  \nEnd // 物件建立完成  \n\n---  \n\nStart // postTweet(userId, tweetId)  \n→ Step 1: 若 userId 不在 followMap, 創建空 Set // 保證資料結構存在  \n→ Step 2: 若 userId 不在 tweetMap, 創建空 List // 保證貼文列表存在  \n→ Step 3: timestamp ← timestamp + 1 // 增加全域時間，確保時間唯一且遞增  \n→ Step 4: tweetMap[userId].add((tweetId, timestamp)) // 將貼文存入使用者列表  \nEnd // 推文發佈完成  \n\n---  \n\nStart // getNewsFeed(userId)  \n→ Step 1: 若 userId 不在 followMap, 創建空 Set // 方便後續處理  \n→ Step 2: followSet ← followMap[userId] ∪ {userId} // 取得關注者加上自己  \n→ Step 3: heap ← MinHeap< (timestamp, tweetId) > (容量 ≤ 10) // 用於保留最最近 10 條  \n→ Step 4: 對每個 uid 在 followSet:\n      → Step 4a: tweetList ← tweetMap.getOrDefault(uid, []) // 取得該使用者貼文  \n      → Step 4b: recent ← 取 tweetList 最後 10 個元素 // 只考慮最近 10  \n      → Step 4c: 對每個 (tid, ts) 在 recent:\n                → Decision: heap.size < 10? // 堆未滿\n                    Yes → heap.push((ts, tid)) // 直接加入  \n                    No  → Decision: ts > heap.peek().timestamp? // 是否比最小時間戳新\n                        Yes → heap.pop(); heap.push((ts, tid)) // 替換  \n                        No  → 跳過 // 不是最近 10  \n      End for  \n→ Step 5: result ← 空 List  \n→ Step 6: 當 heap 不為空 時:\n      → Step 6a: pop 最小元素 (ts, tid)  \n      → Step 6b: result.insertAt(0, tid) // 先插到前面，最後得到從新到舊的順序  \n→ Step 7: 返回 result // 最多 10 條最新貼文  \nEnd // getNewsFeed 結束  \n\n---  \n\nStart // follow(followerId, followeeId)  \n→ Step 1: 若 followerId 不在 followMap, 創建空 Set // 初始化資料結構  \n→ Step 2: followMap[followerId].add(followeeId) // 新增關注  \nEnd // follow 完成  \n\n---  \n\nStart // unfollow(followerId, followeeId)  \n→ Step 1: 若 followerId 不在 followMap, 創建空 Set // 防止空指針  \n→ Step 2: followMap[followerId].remove(followeeId) // 移除關注  \nEnd // unfollow 完成"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport bisect\nimport ast\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 將兩個列表包在一個外層列表中，方便解析\n    data_str = '[' + raw_input + ']'\n    commands, args_list = ast.literal_eval(data_str)\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # args 是一個列表，裡面是權重列表\n            obj = Solution(args[0])\n            results.append(None)          # LeetCode 中的 null\n        elif cmd == \"pickIndex\":\n            results.append(obj.pickIndex())\n        else:\n            results.append(None)\n\n    # 輸出結果，None 會被轉成 JSON 的 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: Given array w, implement pickIndex with weighted random selection. Likely steps: preprocess prefix sums; pick random between 0 and total; binary search; return index.\n\nWe produce virtual code line by line. Let's craft steps:\n\nStart\n→ Step 1: 计算前缀和数组 prefix // 生成每个位置的累加权重\n→ Step 2: 计算 totalWeight = prefix[-1] // 总权重\n→ Decision: 需要重复调用 pickIndex? // 判断是否需要多次随机\n    Yes → Step 3: generate randomNumber in [1, totalWeight] // 随机整数\n    No  → Step 4: 结束 // 结束\n\nBut we need pickIndex function. So maybe structure:\n\nStart // 程式開始執行\n→ Step 1: Preprocess w to create prefix array // 计算前缀和\n    → Step 1.1: prefix[0] = w[0]\n    → Step 1.2: For i from 1 to n-1: prefix[i] = prefix[i-1] + w[i] // 累加\n→ Step 2: total = prefix[n-1] // 总权重\n→ Function pickIndex()\n    → Step 3: r = random integer between 1 and total // 产生随机数\n    → Decision: 找到第一个 prefix[i] >= r // 二分搜索\n        Yes → Step 4: return i\n        No → // loop or error\nEnd\n\nLet's produce final virtual code lines accordingly. Ensure each line has arrow, explanation. Use indentation maybe but keep as single line with arrow.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: n = length of w // 取得陣列長度\n→ Step 2: prefix = new array of size n // 用於存前綜合權重\n→ Step 3: prefix[0] = w[0] // 初始化首項\n→ Decision: 是否需要繼續填充前綜合? // 迴圈判斷\n    Yes → Step 4: For i from 1 to n-1: prefix[i] = prefix[i-1] + w[i] // 計算累加\n    No  → // 跳出\n→ Step 5: totalWeight = prefix[n-1] // 獲取總權重\n→ Function pickIndex() // 定義選擇函式\n    → Step 6: r = random integer between 1 and totalWeight // 產生隨機數\n    → Decision: 找到最小 i 使 prefix[i] >= r // 二分搜尋\n        Yes → Step 7: return i // 返回對應索引\n        No  → // 若未找到，返回 -1 或處理錯誤\nEnd // 程式結束\n\nNeed to ensure each line with arrow. Provide explanation comments.\n\nLet's format. Use \"→\" arrow each line.\n\nWe'll produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length of w // 取得陣列長度  \n→ Step 2: prefix = new array of size n // 用於存前綜合權重  \n→ Step 3: prefix[0] = w[0] // 初始化首項的累積權重  \n→ Decision: 是否需要繼續填充前綜合? // 判斷是否進入迴圈  \n  Yes → Step 4: For i from 1 to n-1: prefix[i] = prefix[i-1] + w[i] // 計算累加，得到每個索引的前綜合權重  \n  No  → // 迴圈結束  \n→ Step 5: totalWeight = prefix[n-1] // 獲取總權重，用於隨機選取  \n→ Function pickIndex() // 定義隨機選取函式  \n  → Step 6: r = random integer between 1 and totalWeight // 產生一個落在權重區間的隨機數  \n  → Decision: 找到最小 i 使 prefix[i] >= r // 透過二分搜尋確定對應索引  \n    Yes → Step 7: return i // 返回符合權重的索引  \n    No  → // 若未找到，處理錯誤（通常不會發生）  \nEnd // 程式執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptjo7lh4e.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmptjo7lh4e.py\", line 36, in main\n    mat = ast.literal_eval(matrix_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsci1dw94.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpsci1dw94.py\", line 36, in main\n    mat = ast.literal_eval(matrix_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract matrix and k using regex\n    matrix_match = re.search(r\"mat\\s*=\\s*(\\[.*?\\])\", data, re.S)\n    k_match = re.search(r\"k\\s*=\\s*(\\d+)\", data)\n    if not matrix_match or not k_match:\n        # If the input is simply two lines: first matrix, second k\n        parts = data.splitlines()\n        mat = ast.literal_eval(parts[0].strip())\n        k = int(parts[1].strip())\n    else:\n        matrix_str = matrix_match.group(1)\n        k_str = k_match.group(1)\n        mat = ast.literal_eval(matrix_str)\n        k = int(k_str)\n\n    result = Solution().kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode in the specified format. Should be in Chinese? The user said \"用繁體中文回答\". So comments should be Chinese. Each line: Virtual code step + space + // explanation. Use arrows and structure. No real code. Need to describe algorithm: count soldiers per row, sort indices by count, then index. For ties, lower index wins. We need k weakest rows.\n\nWe produce Start, then for each row compute count via while? Since each row is sorted. Use binary search or linear. We'll use binary search to find first zero. Then record count and index. Then sort list by (count, index). Then pick first k. Return indices. Provide pseudocode.\n\nLet's write:\n\nStart // 開始\n→ Step 1: 初始化空列表 rows // 用來存放 (index, soldiers) 資料\n→ Step 2: 取得矩陣行數 m, 列數 n\n→ Step 3: For i from 0 to m-1 // 遍歷每一行\n    → Step 3.1: count ← BinarySearchSoldiers(mat[i], n) // 找出行 i 的兵力數量\n    → Step 3.2: Append (i, count) 到 rows // 保存行號和兵力\n→ Step 4: Sort rows 依據 (count, index) 升序 // 先按兵力再按行號\n→ Step 5: result ← 空列表 // 儲存最弱的 k 行索引\n→ Step 6: For j from 0 to k-1\n    → Step 6.1: Append rows[j].index 到 result\n→ End // 結束並回傳 result\n\nNeed to explain binary search function: find first zero. So we might define:\n\n→ Function BinarySearchSoldiers(row, n)\n    → low ← 0, high ← n\n    → While low < high\n        → mid ← (low + high) // 2\n        → If row[mid] == 1\n            → low ← mid + 1\n        → Else\n            → high ← mid\n    → Return low // number of ones\n\nWe can integrate within steps.\n\nLet's produce in required format.\n\nNeed to maintain \"Start\", \"End\". Use arrows. Each line: Virtual code step + space + // explanation.\n\nWe may indent Decision steps but not necessary.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空列表 rows  // 用於存放 (行號, 兵力數量) 的資料\n→ Step 2: 取得矩陣行數 m 與列數 n  // m = mat.length, n = mat[0].length\n→ Step 3: For i from 0 to m-1  // 遍歷每一行\n    → Step 3.1: count ← BinarySearchSoldiers(mat[i], n)  // 用二分搜尋得到行 i 的兵力數量\n    → Step 3.2: Append (i, count) 到 rows  // 將行號與兵力存入列表\n→ Step 4: Sort rows 依據 (count, index) 升序  // 先按兵力，再按行號決定優先級\n→ Step 5: result ← 空列表  // 儲存最弱的 k 行索引\n→ Step 6: For j from 0 to k-1  // 選取前 k 個最弱的行\n    → Step 6.1: Append rows[j].index 到 result  // 加入行號到結果\n→ End // 程式執行結束，result 為最弱的 k 行索引\n\n// ---------------- Binary Search Helper Function ----------------\n→ Function BinarySearchSoldiers(row, n)\n    → low ← 0, high ← n  // 初始化搜尋範圍\n    → While low < high  // 進行二分搜尋\n        → mid ← (low + high) // 2  // 取中間索引\n        → If row[mid] == 1  // 中間位置為士兵\n            → low ← mid + 1  // 兵力在右半部\n        → Else  // 中間位置為平民\n            → high ← mid  // 兵力在左半部\n    → Return low  // low 為第一個 0 的索引，即兵力數量\nEnd // Function 結束"
    }
  ]
}