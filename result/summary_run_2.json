{
  "run_index": 2,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 293,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '找不到檔案！'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '找不到檔案！'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    主函式，先從標準輸入讀取所有資料（即使本題不需要任何輸入）。\n    接著嘗試讀取名為 data.txt 的檔案並計算行數。\n    如檔案不存在，則輸出相應提示。\n    \"\"\"\n    # 讀取所有輸入，避免程式在等待輸入時被卡住\n    _ = sys.stdin.read()\n\n    try:\n        # 以讀取模式打開檔案，使用 with 確保檔案正確關閉\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        # 若檔案不存在，顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in each line with explanation. Use arrows and structure. We need to start with Start. Then Step 1: open file with try. Use Decision: file found? Actually with try/except. We can step: Step 1: 嘗試打開文件 // etc. Step 2: 讀取所有行 // etc. Step 3: 計算行數 // etc. Step 4: 輸出行數 // etc. In except block: Step 5: 打印錯誤訊息 // etc. Use Decision? Actually try/except is flow. Might do: Step 1: 嘗試打開文件 // etc. Decision: 文件成功開啟? // not necessary because try catches. But we can use Decision to show if file open succeeded. Use Try and Except block as step. Let's structure:\n\nStart\n→ Step 1: 嘗試以讀取模式打開名為 'data.txt' 的檔案 // 進入 try 區塊\n→ Decision: 檔案成功開啟? // 判斷是否進入 try 成功\n    Yes → Step 2: 讀取所有行到 list // 取得所有行\n    → Step 3: 計算行數 = len(list) // 取得行數\n    → Step 4: 輸出行數 // 顯示結果\n    No → Step 5: 捕捉 FileNotFoundError // 進入 except 區塊\n        → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd\n\nBut we need to show try/except structure. We can represent except as Decision? Perhaps better: Step 1: 嘗試打開檔案 // Try\n→ Decision: 例外發生? // if yes go to except\n    Yes → Step 5: 輸出錯誤訊息 // except block\n    No → Step 2: 讀取行 // try block\n... But maybe simpler: Step 1: 開啟檔案（with） // try\n→ Decision: 例外? // etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 嘗試以讀取模式打開名為 'data.txt' 的檔案，使用 with 語法 // 進入 try 區塊\n→ Decision: 是否拋出 FileNotFoundError？ // 判斷檔案是否存在\n    No  → Step 2: 讀取檔案中的所有行到 list // 取得整個檔案的行列表\n    → Step 3: 計算行數 = len(list) // 取得行數\n    → Step 4: 輸出行數 // 顯示總行數\n    Yes → Step 5: 捕捉 FileNotFoundError // 進入 except 區塊\n        → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,3,2,2,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 3, 2, 2, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    return [random.randint(1, 6) for _ in range(n)]\n\ndef main():\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 執行輸入的程式碼，讓它可以呼叫 roll_dice\n    exec(code, {'roll_dice': roll_dice})\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line explanation. The requirement: \"請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。\" So virtual code steps:\n\nStart\n→ Step: Import random\n→ Step: 定義函數 roll_dice(n)\n→ Step: 初始化 empty list results\n→ Decision: n <=0? No? Actually we might handle negative. We'll just loop range(n)\n→ Loop: for i in range(n)\n→ Step: 隨機生成 1-6 using random.randint(1,6)\n→ Step: append to results\n→ After loop: return results\nEnd\n\nWe need to produce each line: Virtual code + // explanation\n\nUse arrow \"→\" for steps. Use \"Decision:\" for condition. Use \"Start\", \"End\".\n\nAlso need to show if loops? Use \"Loop:\"? The spec uses arrow and decision. But loops can be indicated by \"→ Loop:\" or \"→ Step:\".\n\nProbably use \"Loop: for i in range(n)\" but must keep arrow.\n\nBetter to produce:\n\nStart\n→ Step: Import random // 載入 random 模組\n→ Step: Define function roll_dice(n) // 建立函式\n→ Step: results ← [] // 初始化空串列\n→ Decision: if n <= 0? // 檢查是否需要擲零次\n    Yes → Step: return [] // 直接回傳空串列\n    No → Loop: for i in range(n) // 依次擲骰子\n        → Step: dice ← random.randint(1,6) // 產生 1~6 隨機數\n        → Step: results.append(dice) // 加入結果\n→ Step: return results // 回傳所有結果\nEnd\n\nNeed to ensure each line ends with // explanation. Also note each line must include virtual code then a space then comment. For lines with indentation, maybe use spaces but still same format.\n\nLet's produce as per spec.\n\nAlso note that \"Step:\" maybe includes step description. Use arrow preceding each step.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step: Import random // 載入 random 模組\n→ Step: Define function roll_dice(n) // 建立 roll_dice 函式\n→ Step: results ← [] // 初始化結果列表\n→ Decision: n <= 0? // 檢查是否需要擲零次\n    Yes → Step: return [] // 若 n 為 0 或負數，回傳空列表\n    No → Loop: for i in range(n) // 依序擲 n 次\n        → Step: dice ← random.randint(1,6) // 產生 1~6 的隨機數\n        → Step: results.append(dice) // 將骰子點數加入結果\n→ Step: return results // 回傳所有擲骰結果\nEnd // 程式執行結束\n\nBut each line must contain arrow. For nested lines, indentation? They might still include arrow? Might show as separate lines with indentation. But spec example uses indentation with \"Yes →\" etc. We'll follow that.\n\nSo produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: Import random // 載入 random 模組  \n→ Step: Define function roll_dice(n) // 建立 roll_dice 函式  \n→ Step: results ← [] // 初始化結果列表  \n→ Decision: n <= 0? // 檢查是否需要擲零次  \n    Yes → Step: return [] // 若 n 為 0 或負數，直接回傳空列表  \n    No  → Loop: for i in range(n) // 依序擲 n 次  \n        → Step: dice ← random.randint(1,6) // 產生 1~6 的隨機數  \n        → Step: results.append(dice) // 將骰子點數加入結果  \n→ Step: return results // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    import sys\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nThe user wants to produce virtual code for a function measure_time(func, *args) that measures the time of func execution using time module, returns the result rounded to 3 decimal places. Provide step-by-step virtual code with explanation. Each line must have virtual code and comment after space: \"// explanation\". Use arrows, Start, End, Decision. Let's produce.\n\nWe need to include the import of time. Maybe start: Start // program start. Then import time. Then define function measure_time(func, *args). Then inside: start_time ← time.time() // get current time. Then result ← func(*args) // call func with arguments. Then end_time ← time.time() // get current time after execution. Then duration ← end_time - start_time // calculate duration. Then rounded_duration ← round(duration, 3) // round to 3 decimals. Then return rounded_duration, result // return tuple. Then End // program ends.\n\nBut we might not need to return result? Problem statement: measure_time(func,*args) to measure time of function func execution and return result (rounded). But maybe the function returns the execution time? Actually \"並回傳結果 (四捨五入到小數點 3 位)\" means return result time? \"結果\" ambiguous; likely return execution time. Might also return result of func? Usually you'd want both. But I'll just return time. Provide code accordingly.\n\nLet's produce the virtual steps.\n\nWe need to use virtual code syntax: Start, → Step 1: something. Use arrows.\n\nMake sure each line ends with // comment. Provide decision? Not needed. Maybe decision for importing? Not necessary.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: import time // 載入 time 模組\n→ Step 2: 定義函式 measure_time(func, *args) // 建立測量時間的函式\n    → Step 3: start_time ← time.time() // 紀錄執行前的時間戳\n    → Step 4: result ← func(*args) // 執行傳入的函式並取得結果\n    → Step 5: end_time ← time.time() // 紀錄執行後的時間戳\n    → Step 6: duration ← end_time - start_time // 計算所需秒數\n    → Step 7: rounded_duration ← round(duration, 3) // 四捨五入到小數點三位\n    → Step 8: return rounded_duration // 回傳計算後的秒數\nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        # 沒有輸入時使用預設的兩個學生\n        students = [Student('Alice', 90), Student('Bob', 80)]\n    else:\n        lines = data.splitlines()\n        students = []\n        # 嘗試解析第一行為學生數量\n        try:\n            n = int(lines[0].strip())\n            for line in lines[1:n+1]:\n                parts = line.strip().split()\n                if len(parts) >= 2:\n                    name = parts[0]\n                    score = int(parts[1])\n                    students.append(Student(name, score))\n        except Exception:\n            # 如果解析失敗，直接把每行當作 \"name score\"\n            for line in lines:\n                parts = line.strip().split()\n                if len(parts) >= 2:\n                    name = parts[0]\n                    score = int(parts[1])\n                    students.append(Student(name, score))\n    for s in students:\n        s.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode lines. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision if any. We need to define class Student, init, method show_info, instantiate two objects, call method.\n\nWe need step by step: Start, Step 1: Define class Student, Step 2: Define __init__ with parameters name, score, assign to self. Step 3: Define method show_info. Step 4: Instantiate student1, Step5: student1.show_info. Step6: Instantiate student2, Step7: student2.show_info. End.\n\nWe need to use arrow syntax: \"→\" for lines following previous. Use \"Start\" then \"→\" lines. For method definitions we might have \"Step 1: Define class Student\" then \"→ Step 1.1: Define __init__()\" etc. But simpler: each line is a step; we can indent with arrow at each step. Use \"Start\" then \"→\" lines sequentially. Each line comment after // explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Student // 建立 Student 類別\n→ Step 1.1: 定義建構子 __init__(self, name, score) // 建構子用於初始化屬性\n→ Step 1.2: self.name = name // 設定姓名屬性\n→ Step 1.3: self.score = score // 設定分數屬性\n→ Step 2: 定義方法 show_info(self) // 顯示學生資訊\n→ Step 2.1: 輸出 f'{self.name} 的分數是 {self.score}' // 打印姓名與分數\n→ Step 3: 建立 student1 = Student('Alice', 90) // 建立第一個 Student 物件\n→ Step 4: 呼叫 student1.show_info() // 顯示第一個學生分數\n→ Step 5: 建立 student2 = Student('Bob', 75) // 建立第二個 Student 物件\n→ Step 6: 呼叫 student2.show_info() // 顯示第二個學生分數\nEnd // 程式執行結束\n\nBut the pseudocode may use arrow \"→\" after each step. We can write as above. Ensure each line includes \"虛擬碼步驟 // 解釋\". Use the arrow only for the first? The example uses \"Start\" then \"→ Step 1: ...\" etc. So we should use \"Start\" then lines prefixed with \"→\". For method definitions maybe use sub-steps? But no need for decision. Just linear. That matches.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Student // 建立 Student 類別  \n→ Step 1.1: 定義建構子 __init__(self, name, score) // 用於初始化姓名與分數屬性  \n→ Step 1.2: self.name = name // 儲存姓名到實例屬性  \n→ Step 1.3: self.score = score // 儲存分數到實例屬性  \n→ Step 2: 定義方法 show_info(self) // 用來顯示學生資訊  \n→ Step 2.1: 輸出 f'{self.name} 的分數是 {self.score}' // 印出姓名與分數  \n→ Step 3: 建立 student1 = Student('Alice', 90) // 創建第一個 Student 物件  \n→ Step 4: 呼叫 student1.show_info() // 顯示第一個學生的分數  \n→ Step 5: 建立 student2 = Student('Bob', 75) // 創建第二個 Student 物件  \n→ Step 6: 呼叫 student2.show_info() // 顯示第二個學生的分數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"melon\",\"orange\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'melon', 'orange', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin 的所有資料，若沒有輸入也能正常執行\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除 'pineapple'（若不存在不會發生錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with explanations. The user wants to create a set fruits = {'apple','banana'} and perform add, update, remove, discard, and then print. Use the specified format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows, decisions etc. Just straightforward. Let's produce steps:\n\nStart\n→ Step 1: Initialize fruits set with 'apple', 'banana' // 建立初始集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'（不存在，無錯誤）\n→ Step 6: Print fruits // 輸出最終集合\nEnd\n\nBut we must follow the format: each line includes \"虛擬碼步驟\" then space then comment. Use \"Start\", \"End\". Use arrows '→'. For Step 1 we write \"Start // 程式開始執行\" maybe. Then \"→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立初始集合\". For Step 2: \"→ Step 2: fruits.add('orange') // 新增 'orange'\". Step 3: \"→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'\". Step 4: \"→ Step 4: fruits.remove('banana') // 移除 'banana'\". Step 5: \"→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'，若不存在則不錯誤\". Step 6: \"→ Step 6: print(fruits) // 輸出集合\". End.\n\nWe need to include the arrow at each line after Start? Usually we start with \"Start // 程式開始執行\". Then \"→ Step 1:\" etc. End at \"End // 程式執行結束\".\n\nLet's produce exactly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 嘗試移除 'pineapple'（不存在則不產生錯誤）  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.82TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.82 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"取得美元兌台幣匯率，成功回傳數值，失敗回傳 None。\"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef main():\n    # 先從 stdin 讀取指令，若有「更新匯率」就直接取得並輸出\n    input_text = sys.stdin.read().strip()\n    if input_text and \"更新匯率\" in input_text:\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n        # 完成 stdin 相關處理後直接結束，避免 GUI 被觸發\n        return\n\n    # 若沒有 stdin 指令，啟動 tkinter GUI\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_label():\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update_label).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described requirement. Use steps: import requests, import tkinter, create main window, create label, button, function to fetch rate and update label, call function at start, mainloop. Provide virtual code lines with explanation. Use arrows and Decision only if necessary. Not actual code. Let's craft.\n\nWe should include Start, End. Use \"→\" for step lines. Use \"Decision:\" only if needed. Not many decisions. But we might check if request succeeded? maybe Decision. Could include error handling decision. Provide steps accordingly.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Import requests 模組 // 需要 HTTP 請求\n→ Step 2: Import tkinter 模組 // 用於 GUI\n→ Step 3: 建立主視窗 (root) // tkinter 主視窗\n→ Step 4: 建立 Label (rate_label) 並放入主視窗 // 用來顯示匯率\n→ Step 5: 建立 Button (update_btn)，文字為 \"更新匯率\"，綁定 fetch_rate 函式 // 觸發更新\n→ Step 6: 定義函式 fetch_rate()\n    → Step 7: 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率\n    → Decision: 如果回傳狀態碼 200? // 檢查是否成功\n        Yes → Step 8: 從 JSON 解析 'rates' -> 'TWD' // 取得美元兌台幣匯率\n        Yes → Step 9: 以文字 \"USD/TWD: 1 = {rate}\" 更新 rate_label 內容 // 顯示匯率\n        No  → Step 10: 設定 rate_label 內容為 \"取得匯率失敗\" // 顯示錯誤\n→ Step 11: 在程式啟動時先呼叫 fetch_rate() // 初始顯示\n→ Step 12: 執行 root.mainloop() // 開始事件迴圈\nEnd // 程式執行結束\n\nMake sure each line follows format: \"Step 1: ... // ...\". Use arrow for each step. For nested steps, indent? The example uses indentation for nested decisions. We can use indentation to show nested lines after Decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests 模組 // 需要 HTTP 請求  \n→ Step 2: Import tkinter 模組 // 用於 GUI  \n→ Step 3: 建立主視窗 (root) // tkinter 主視窗  \n→ Step 4: 建立 Label (rate_label) 並放入主視窗 // 用來顯示匯率  \n→ Step 5: 建立 Button (update_btn)，文字為 \"更新匯率\"，綁定 fetch_rate 函式 // 觸發更新  \n→ Step 6: 定義函式 fetch_rate()  \n  → Step 7: 送出 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新匯率  \n  → Decision: 如果回傳狀態碼 200? // 檢查是否成功  \n    Yes → Step 8: 從 JSON 解析 'rates' -> 'TWD' // 取得美元兌台幣匯率  \n    Yes → Step 9: 以文字 \"USD/TWD: 1 = {rate}\" 更新 rate_label 內容 // 顯示匯率  \n    No → Step 10: 設定 rate_label 內容為 \"取得匯率失敗\" // 顯示錯誤  \n→ Step 11: 在程式啟動時先呼叫 fetch_rate() // 初始顯示  \n→ Step 12: 執行 root.mainloop() // 開始事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedSet:\n    \"\"\"實作可在平均 O(1) 時間內完成插入、刪除與隨機取值的集合。\"\"\"\n\n    def __init__(self):\n        self.val_to_index = {}  # value -> index in values list\n        self.values = []        # 存放所有元素的動態陣列\n\n    def insert(self, val: int) -> bool:\n        \"\"\"若 val 不在集合中則插入，並回傳 True；否則回傳 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若 val 在集合中則刪除，並回傳 True；否則回傳 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素的索引\n        idx = self.val_to_index[val]\n        # 取得最後一個元素並移到要刪除的位置\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 移除最後一個元素\n        self.values.pop()\n        # 刪除被移除元素的映射\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回集合中一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    \"\"\"讀取標準輸入，執行操作並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入為兩個 JSON 陣列\n    # 例如: '[\"RandomizedSet\",\"insert\"], [[],[1]]'\n    end_first = data.find(']')\n    first_part = data[:end_first + 1]\n    second_part = data[end_first + 2:].strip()  # 跳過 ', '\n    ops = json.loads(first_part)\n    args = json.loads(second_part)\n\n    results = [None]  # 第一次呼叫是建構子，對應 null\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n        else:\n            # 若遇到未知方法，可選擇忽略或抛异常\n            results.append(None)\n\n    # 將結果輸出為 JSON 格式，符合 LeetCode 的預期輸出\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code lines for the RandomizedSet class with its methods, ensuring average O(1). Virtual code: use dictionary for value to index, list for values. Show Start, End, Decision. Must be line by line. Provide explanation after each line. Use arrows. Provide the pseudocode for class definition and methods. Let's create structure:\n\nStart // Program start\n→ Step 1: Define class RandomizedSet // Class declaration\n→ Step 2: Declare dictionary val_to_idx // Mapping from val to index\n→ Step 3: Declare list values // Dynamic array of values\n→ Step 4: Initialize constructor // Initialize empty structures\n→ Step 5: insert method // Insert value if not exists\n→ Decision: check if val in val_to_idx? // If already present\n→ Yes → Step 6: Return false // Not inserted\n→ No  → Step 7: Append val to values // Add to list\n→ Step 8: Set val_to_idx[val] = len(values)-1 // Record index\n→ Step 9: Return true // Insert successful\n→ Step 10: remove method // Remove value if present\n→ Decision: check if val in val_to_idx? // If present\n→ Yes → Step 11: idx = val_to_idx[val] // Get index\n→ Step 12: last_val = values[-1] // Last element\n→ Step 13: Move last_val to idx // Overwrite position\n→ Step 14: Update val_to_idx[last_val] = idx // Update mapping\n→ Step 15: Pop last element from values // Remove duplicate\n→ Step 16: Delete val_to_idx[val] // Remove mapping\n→ Step 17: Return true // Removal successful\n→ No  → Step 18: Return false // Not present\n→ Step 19: getRandom method // Return random element\n→ Step 20: rand_idx = random integer in [0, len(values)-1] // Choose index\n→ Step 21: Return values[rand_idx] // Return element\n→ End // Program end\n\nMake sure each line is \"虛擬碼步驟 // 解釋\". Use arrows appropriately. Ensure each step has explanation. Provide each line as separate line. Use the required format. Use \"Start\", \"End\". Use \"Decision:\" with indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class RandomizedSet // 建立 RandomizedSet 類別  \n→ Step 2: Declare dictionary val_to_idx // 用於存放值到其在列表中的索引  \n→ Step 3: Declare list values // 用於儲存所有元素，方便隨機存取  \n→ Step 4: Initialize constructor // 在建構子中初始化空資料結構  \n  → Step 5: val_to_idx = {} // 空字典  \n  → Step 6: values = [] // 空列表  \n→ Step 7: Define insert(val) method // 插入方法開始  \n  → Decision: if val in val_to_idx? // 檢查值是否已存在  \n   Yes → Step 8: return False // 已存在，插入失敗  \n   No → Step 9: values.append(val) // 將新值加入列表  \n   → Step 10: val_to_idx[val] = len(values) - 1 // 記錄新值的索引  \n   → Step 11: return True // 插入成功  \n→ Step 12: Define remove(val) method // 刪除方法開始  \n  → Decision: if val in val_to_idx? // 檢查值是否存在  \n   Yes → Step 13: idx = val_to_idx[val] // 取得要刪除值的索引  \n   → Step 14: last_val = values[-1] // 取得列表最後一個值  \n   → Step 15: values[idx] = last_val // 把最後一個值移到要刪除的位置  \n   → Step 16: val_to_idx[last_val] = idx // 更新最後一個值的新索引  \n   → Step 17: values.pop() // 刪除列表最後一個元素（已被移動）  \n   → Step 18: del val_to_idx[val] // 刪除被刪除值的映射  \n   → Step 19: return True // 刪除成功  \n   No → Step 20: return False // 值不存在，刪除失敗  \n→ Step 21: Define getRandom() method // 隨機取得方法開始  \n  → Step 22: rand_idx = random integer between 0 and len(values)-1 // 隨機產生索引  \n  → Step 23: return values[rand_idx] // 回傳對應的值  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.rows = m\n        self.cols = n\n        self.total = m * n          # remaining 0 cells\n        self.flipped = {}           # mapping of used indices\n\n    def flip(self):\n        # Pick a random index among remaining zeros\n        r = random.randint(0, self.total - 1)\n        # Actual position for r (may have been swapped earlier)\n        x = self.flipped.get(r, r)\n        # Decrease the pool size\n        self.total -= 1\n        # Map the chosen index to the last available index\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # Convert linear index back to 2D coordinates\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        # Reset the matrix to all zeros\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # The input is two top‑level lists separated by a comma.\n    # Wrap them in brackets to parse as a single JSON array.\n    ops, args = json.loads('[' + raw_input + ']')\n\n    outputs = []\n    sol = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            sol = Solution(*arg)\n            outputs.append(None)          # null for constructor\n        elif op == \"flip\":\n            outputs.append(sol.flip())\n        elif op == \"reset\":\n            sol.reset()\n            outputs.append(None)          # null for reset\n\n    # Print the results in JSON format (None -> null)\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to output pseudo code steps line by line with explanation. Use virtual code arrows. Need algorithm: Reservoir sampling or mapping approach. Approach: Use mapping of indices to track flipped ones. Represent all cells as linear index 0..mn-1. Maintain a map of free indices. For flip: choose random k in [0, remaining-1], map k to actual index via map or itself. Then map that index to last free index (remaining-1). decrement remaining. For reset: clear map, set remaining=mn. Complexity: O(1) per flip. Use random calls minimal: one random per flip. So we produce steps.\n\nWe need pseudo-code lines like:\n\nStart // Initialize\n→ Step 1: Set total = m * n // total cells\n→ Step 2: Set remaining = total // remaining zeros\n→ Step 3: Initialize empty map // mapping of used indices\n\nDecision: For flip\n→ Step 4: Generate random int k between 0 and remaining-1 // random selection\n→ Step 5: Get actual index idx = map.get(k, k) // mapping if exists else k\n→ Step 6: Get last index last = map.get(remaining-1, remaining-1)\n→ Step 7: map.put(k, last) // update mapping for next time\n→ Step 8: Decrement remaining\n→ Step 9: Convert idx to 2D coordinate: row = idx / n, col = idx % n\n→ Step 10: Return [row, col]\n\nReset:\n→ Step 11: Clear map\n→ Step 12: Set remaining = total\n\nAlso need to show class structure maybe but it's fine.\n\nWe must ensure each line has \"虛擬碼步驟 // 解釋\". Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: total ← m × n // 計算矩陣總格數\n→ Step 2: remaining ← total // 目前還未被翻轉的格子數\n→ Step 3: mapping ← {} // 空映射表，key: 隨機選取的索引，value: 真實索引\n\n→ Decision: 要進行 flip? // 這裡是 flip() 函式的主流程\n\n    → Step 4: k ← RandomInt(0, remaining - 1) // 隨機挑選一個可用索引\n    → Step 5: idx ← mapping.get(k, k) // 若 k 已映射則取映射值，否則取 k 本身\n    → Step 6: last ← mapping.get(remaining - 1, remaining - 1) // 取得最後一個可用格子的實際索引\n    → Step 7: mapping.put(k, last) // 把 k 的位置更新為 last，保持映射有效\n    → Step 8: remaining ← remaining - 1 // 失去一個未翻轉格子\n    → Step 9: row ← idx ÷ n // 將線性索引轉為行號\n    → Step 10: col ← idx mod n // 將線性索引轉為列號\n    → Step 11: Return [row, col] // 回傳被翻轉的座標\n\n→ Decision: 要進行 reset? // reset() 函式的主流程\n\n    → Step 12: mapping.clear() // 清除所有映射，恢復初始狀態\n    → Step 13: remaining ← total // 將未翻轉格子數恢復為總格數\n\nEnd // 程式執行結束"
    },
    {
      "title": "Next Greater Element I",
      "source_file": "Leetcode/leetcode496.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8i3q0clc.py\", line 29, in <module>\n    nums2_part = parts[1].split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2t7l2ci1.py\", line 29, in <module>\n    nums2_part = parts[1].split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElement(self, nums1, nums2):\n        stack = []\n        next_greater = {}\n\n        # 從左到右遍歷 nums2，使用堆疊找下一個較大元素\n        for num in nums2:\n            # 先把所有比目前元素小或相等的堆疊頂端元素彈出，並記錄它們的下一個較大元素\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n\n        # 對於 nums1 中的每個元素，查找其下一個較大元素，若不存在則為 -1\n        return [next_greater.get(x, -1) for x in nums1]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 假設輸入格式為：nums1 = [1,2,3], nums2 = [3,1,2]\n    # 分割出兩個子字串\n    parts = raw_input.split(',')\n    nums1_part = parts[0].split('=', 1)[1].strip()\n    nums2_part = parts[1].split('=', 1)[1].strip()\n\n    # 解析為實際的 Python list\n    nums1 = ast.literal_eval(nums1_part)\n    nums2 = ast.literal_eval(nums2_part)\n\n    # 計算結果並輸出\n    solution = Solution()\n    result = solution.nextGreaterElement(nums1, nums2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the described problem: Next Greater Element I. So produce step-by-step algorithm in pseudocode with explanation lines.\n\nWe must not output actual code, only virtual steps with arrows and comments.\n\nWe need to process two arrays nums1 and nums2, where nums1 subset of nums2. For each element in nums1, find its next greater element in nums2 to the right, else -1.\n\nStandard approach: use stack to compute next greater element for all elements in nums2. Map element value to its next greater. Then iterate nums1 to build answer.\n\nWe produce virtual code accordingly.\n\nStructure:\n\nStart\n→ Step: Initialize stack empty\n→ Step: Initialize map nextGreater\n→ Decision: Loop over nums2 from end to start\n  Yes: For each element, pop while stack not empty and top <= current\n  → Step: If stack empty then set nextGreater[current] = -1\n  → Step: Else nextGreater[current] = stack.top\n  → Step: Push current onto stack\n→ Step: Initialize ans array length nums1.length\n→ Loop over nums1 with index i\n  → Step: ans[i] = nextGreater[nums1[i]]\n→ End\n\nNeed to show decision with Yes/No? Only needed for loops. Provide explanation comments.\n\nLet's craft each line.\n\nLine 1: Start // 程式開始\n\nLine 2: → Step: 初始化空堆疊 S 用於追蹤候選較大元素 // 建立空堆疊\n\nLine 3: → Step: 建立空映射 map，key 為元素值，value 為其下一個較大元素 // 建立映射\n\nLine 4: → Decision: 以從右至左遍歷 nums2 // 需要從右往左找下一個較大\n\n    Yes → Step: 取出 nums2 的當前元素 cur // 取得當前元素\n\n    → Decision: 當堆疊非空且堆疊頂部 <= cur? // 移除不大於 cur 的元素\n\n        Yes → Step: 從堆疊中彈出頂部元素 // 弹出\n\n        No  → Step: 堆疊頂部已是第一個較大元素 // 找到\n\n    → Step: 若堆疊空則 map[cur] = -1 // 無下一個較大\n\n    → Step: 否則 map[cur] = 堆疊頂部 // 記錄下一個較大\n\n    → Step: 將 cur 推入堆疊 // 更新堆疊\n\nLine 5: → Step: 初始化答案陣列 ans，長度為 nums1.length // 準備答案\n\nLine 6: → Decision: 循環遍歷 nums1，索引 i\n\n    Yes → Step: ans[i] = map[nums1[i]] // 直接查表\n\nLine 7: End // 程式結束\n\nMake sure arrow formatting: use → for each step.\n\nUse \"Decision:\" with indent for nested.\n\nWe need to include explanation after each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化空堆疊 S 用於追蹤候選較大元素 // 建立空堆疊  \n→ Step: 建立空映射 map，key 為元素值，value 為其下一個較大元素 // 建立映射  \n→ Decision: 以從右至左遍歷 nums2 // 需要從右往左找下一個較大  \n  Yes → Step: 取出 nums2 的當前元素 cur // 取得當前元素  \n  → Decision: 當堆疊非空且堆疊頂部 <= cur? // 移除不大於 cur 的元素  \n   Yes → Step: 從堆疊中彈出頂部元素 // 弹出  \n   No  → Step: 堆疊頂部已是第一個較大元素 // 找到  \n  → Step: 若堆疊空則 map[cur] = -1 // 無下一個較大  \n  → Step: 否則 map[cur] = 堆疊頂部 // 記錄下一個較大  \n  → Step: 將 cur 推入堆疊 // 更新堆疊  \n→ Step: 初始化答案陣列 ans，長度為 nums1.length // 準備答案  \n→ Decision: 循環遍歷 nums1，索引 i // 逐一填充答案  \n  Yes → Step: ans[i] = map[nums1[i]] // 直接查表  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all unique valid strings with minimum removals.\n        \"\"\"\n        def is_valid(string: str) -> bool:\n            count = 0\n            for ch in string:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        level = {s}\n        while level:\n            # 找到所有有效字符串\n            valid = [item for item in level if is_valid(item)]\n            if valid:\n                return valid\n            # 建立下一層：對每個字符若是括號就刪除\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_item = item[:i] + item[i+1:]\n                        next_level.add(next_item)\n            level = next_level\n        return []\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從標準輸入讀取，處理可能的 `s = \"...` 格式。\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        # 取得等號右邊的內容\n        part = raw.split('=', 1)[1].strip()\n    else:\n        part = raw\n    # 盡量使用 literal_eval 取得真正的字串\n    try:\n        return ast.literal_eval(part)\n    except Exception:\n        return part\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # 以 JSON 方式輸出，使用雙引號\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudocode for removing invalid parentheses min times, return list unique strings. We should design algorithm: use BFS or DFS. Typical solution: use DFS with pruning. Approach: first compute lRem and rRem counts. Then DFS to remove. We'll output steps: Start, compute lRem rRem, DFS function, decision, etc. Also maintain result set. Let's produce step-by-step.\n\nWe must output line by line: \"Start // ...\" etc. We'll produce pseudocode lines like:\n\nStart // 開始\n→ Step 1: 計算需要刪除的左括號數量 lRem 和右括號數量 rRem // ...\n\nWe need arrow lines. Use \"→\". Use Decision: etc. Provide short explanation after //.\n\nLet's produce pseudocode.\n\nNeed to include unique strings result.\n\nWe can define recursive function Remove(s, start, lRem, rRem, resultSet).\n\nThe pseudocode might include loops etc.\n\nWe must not output actual code. Just pseudocode steps.\n\nLet's produce.\n\nAlso we need to include \"End\". Ensure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算字符串中多餘的左括號數 lRem 與右括號數 rRem // 先找出需刪除的括號數量\n    // 例： s = \"(a)())()\" → lRem=0, rRem=1\n→ Step 2: 建立空集合 results 用於儲存唯一有效字符串 // 以避免重複結果\n→ Step 3: 呼叫遞迴函式 Remove(s, 0, lRem, rRem, results) // 開始深度優先搜尋\nEnd // 程式執行結束\n\nStart // Remove 函式入口\n→ Decision: 如果 lRem == 0 且 rRem == 0? // 是否已將所有多餘括號刪除\n    Yes → Decision: 判斷 s 是否有效? // 確認剩餘字符串是否為合法括號配對\n        Yes → Add s to results // 有效，加入結果集合\n        No  → End // 無效，直接返回\n    No  → Step 4: 找出從索引 start 開始的第一個能被刪除的括號位置 // 避免重複刪除相同位置\n→ Step 5: 循環 i 從 start 到 s.length-1 // 遍歷可能刪除的位置\n    → Decision: 是否 i 為左括號 '(' 且 lRem > 0? // 能刪除左括號\n        Yes → Decision: i 不是重複左括號? // 避免重複刪除同類括號\n            Yes → Step 6: 呼叫 Remove(s.substring(0,i)+s.substring(i+1), i, lRem-1, rRem, results) // 刪除後遞迴\n            No  → No → // 跳過重複刪除\n        No  → Decision: 是否 i 為右括號 ')' 且 rRem > 0? // 能刪除右括號\n            Yes → Step 7: 呼叫 Remove(s.substring(0,i)+s.substring(i+1), i, lRem, rRem-1, results) // 刪除後遞迴\n            No  → No → // 不是可刪除括號，忽略\nEnd // Remove 函式結束\n\nStart // 判斷字符串有效性的輔助函式 IsValid\n→ Step 8: 設定 counter = 0 // 用於追蹤括號平衡\n→ Step 9: 循環每個字符 c 在 s 中\n    → Decision: c == '('? // 遇到左括號\n        Yes → counter++ // 進位\n        No  → Decision: c == ')'?\n            Yes → counter-- // 出位\n            No  → No → // 不是括號，忽略\n    → Decision: counter < 0? // 右括號多於左括號\n        Yes → Return False // 直接失敗\n→ Decision: counter == 0? // 仍保持平衡\n    Yes → Return True\n    No  → Return False\nEnd // IsValid 函式結束\n\nStart // 主函式結束後輸出結果\n→ Step 10: 將 results 集合轉成列表並返回 // 提供所有唯一有效字符串\nEnd // 程式執行結束"
    },
    {
      "title": "License Key Formatting",
      "source_file": "Leetcode/leetcode482.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "actual_output_or_error": ""
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "actual_output_or_error": ""
        }
      ],
      "generated_code": "import sys\n\ndef license_key_formatting(s: str, k: int) -> str:\n    \"\"\"Reformat the license key string according to the problem statement.\"\"\"\n    # 1. Remove dashes and convert to uppercase\n    cleaned = s.replace('-', '').upper()\n    n = len(cleaned)\n    if n == 0:\n        return \"\"\n\n    # 2. Determine the length of the first group\n    first_len = n % k or k\n\n    # 3. Build the result groups\n    groups = [cleaned[:first_len]]\n    for i in range(first_len, n, k):\n        groups.append(cleaned[i:i + k])\n\n    # 4. Join groups with dashes\n    return '-'.join(groups)\n\ndef parse_input(data: str):\n    \"\"\"Parse the input from stdin into the string s and integer k.\"\"\"\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n\n    s = None\n    k = None\n\n    # Try to find 's = ...' and 'k = ...' patterns\n    for line in lines:\n        if '=' in line:\n            key, val = line.split('=', 1)\n            key, val = key.strip(), val.strip()\n            if key == 's':\n                if val.startswith('\"') and val.endswith('\"'):\n                    val = val[1:-1]\n                s = val\n            elif key == 'k':\n                try:\n                    k = int(val)\n                except ValueError:\n                    pass\n\n    # Fallback: assume the first two non-empty lines are s and k\n    if s is None or k is None:\n        if len(lines) >= 2:\n            s = s if s is not None else lines[0]\n            if k is None:\n                try:\n                    k = int(lines[1])\n                except ValueError:\n                    pass\n\n    return s, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s, k = parse_input(raw_input)\n    if s is None or k is None:\n        # If parsing failed, exit silently\n        sys.exit(1)\n    result = license_key_formatting(s, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: reformat license key. We need to output lines of virtual code with explanation after //.\n\nThe steps:\n\nStart\n→ Remove dashes from s (maybe create cleaned string).\n→ Convert to uppercase.\n→ Determine length.\n→ Compute number of groups: (len + k -1)/k.\n→ Compute size of first group: len - (groups-1)*k\n→ Build result: first group of firstSize characters\n→ For i from 1 to groups-1: add dash, then next k chars\n→ End\n\nNeed to use decision, loops, etc. Provide virtual code in described format with arrows.\n\nWe need to use \"Decision:\" for conditions, \"Start\", \"End\". Provide each step.\n\nLet's design.\n\nStart\n→ Step 1: Clean string by removing dashes // remove all dashes from s\n→ Step 2: Convert cleaned string to uppercase // s = cleanedString.toUpperCase()\n→ Step 3: Calculate length of cleaned string // len = s.length\n→ Decision: 如果 len == 0? // check if string empty\n    Yes → Step 4: Return empty string // no characters to format\n    No  →\n→ Step 5: Calculate number of groups = (len + k -1) / k // integer division\n→ Step 6: Determine first group size = len - (groups-1)*k // first group may be shorter\n→ Step 7: Initialize result builder // res = \"\"\n→ Step 8: Append first group to result // res += s.substring(0, firstSize)\n→ Decision: 如果 groups > 1? // if more groups exist\n    Yes → For i = 1 to groups-1:\n                Start loop\n                → Append dash // res += '-'\n                → Append next k chars // res += s.substring(start, start+k)\n                → Update start // start += k\n            End loop\n    No  →\n→ End // return res\n\nBut we need to adhere to syntax: \"→ Step X:\" etc. And use \"Decision:\".\n\nAlso we should include loops with \"For\" structure.\n\nLet's produce step by step.\n\nWe need to keep each line separate, with no extra commentary outside.\n\nOk, produce.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: CleanString = Remove dashes from s // 去除所有 '-' 字元\n→ Step 2: CleanString = Convert CleanString to uppercase // 將所有字母轉成大寫\n→ Step 3: Len = Length of CleanString // 取得字串長度\n→ Decision: 如果 Len == 0? // 檢查是否為空字串\n    Yes → Step 4: Return empty string // 直接回傳空字串\n    No  →\n→ Step 5: Groups = (Len + k - 1) / k // 計算需要的群組數\n→ Step 6: FirstSize = Len - (Groups - 1) * k // 第一群的長度\n→ Step 7: Result = \"\" // 初始化結果字串\n→ Step 8: Result = Result + CleanString[0:FirstSize] // 加入第一群\n→ Decision: 如果 Groups > 1? // 是否還有後續群組\n    Yes → For i = 1 to Groups-1:\n                Start loop\n                → StartIdx = FirstSize + (i-1)*k // 計算本群開始位置\n                → Result = Result + '-' // 加入分隔符\n                → Result = Result + CleanString[StartIdx : StartIdx + k] // 加入本群\n            End loop\n    No  →\nEnd // 程式執行結束\n\nMake sure each line has \"虛擬碼步驟\" + \" // 解釋\". Need to keep one space between code and comment.\n\nAlso for loop, we may need to show the loop lines.\n\nWe can break loop into:\n\n→ For i = 1 to Groups-1: // 迴圈每個後續群組\n    Start loop\n    → StartIdx = FirstSize + (i-1)*k // 計算本群開始位置\n    → Result = Result + '-' // 加入分隔符\n    → Result = Result + CleanString[StartIdx : StartIdx + k] // 加入本群\n    End loop\n\nBut we need to include \"Decision\" lines properly.\n\nAlso for clarity, we might use \"Decision: ...\" lines with indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: CleanString = Remove dashes from s // 去除所有 '-' 字元  \n→ Step 2: CleanString = Convert CleanString to uppercase // 將所有字母轉成大寫  \n→ Step 3: Len = Length of CleanString // 取得字串長度  \n→ Decision: 如果 Len == 0? // 檢查是否為空字串  \n Yes → Step 4: Return empty string // 直接回傳空字串  \n No →  \n→ Step 5: Groups = (Len + k - 1) / k // 計算需要的群組數  \n→ Step 6: FirstSize = Len - (Groups - 1) * k // 第一群的長度  \n→ Step 7: Result = \"\" // 初始化結果字串  \n→ Step 8: Result = Result + CleanString[0 : FirstSize] // 加入第一群  \n→ Decision: 如果 Groups > 1? // 是否還有後續群組  \n Yes → For i = 1 to Groups - 1: // 迴圈每個後續群組  \n  Start loop  \n   → StartIdx = FirstSize + (i - 1) * k // 計算本群開始位置  \n   → Result = Result + '-' // 加入分隔符  \n   → Result = Result + CleanString[StartIdx : StartIdx + k] // 加入本群  \n  End loop  \n No →  \nEnd // 程式執行結束"
    },
    {
      "title": "Bulls and Cows",
      "source_file": "Leetcode/leetcode299.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A3B'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '\"1A3B\"'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A1B'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '\"1A1B\"'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        bulls = 0\n        cows = 0\n        secret_count = Counter()\n        guess_count = Counter()\n\n        # Count bulls and build frequency counters for non-bull digits\n        for s, g in zip(secret, guess):\n            if s == g:\n                bulls += 1\n            else:\n                secret_count[s] += 1\n                guess_count[g] += 1\n\n        # Count cows: minimal overlap of remaining digits\n        for digit in secret_count:\n            if digit in guess_count:\n                cows += min(secret_count[digit], guess_count[digit])\n\n        return f\"{bulls}A{cows}B\"\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    secret = data[0].strip()\n    guess = data[1].strip()\n    solution = Solution()\n    hint = solution.getHint(secret, guess)\n    print(hint)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code. The problem: Bulls and Cows. Input: secret, guess strings (or numbers). Need to produce hint \"xAyB\". We must use virtual code with arrows and decision etc. Provide each line: \"虛擬碼步驟 // 解釋\". We need to think of algorithm: Count bulls: iterate over indices compare. For cows: count occurrences of each digit in secret and guess, subtract bulls, compute min counts.\n\nBut we must produce \"逐行\" lines, use arrows. Use \"Start\", \"End\". Use \"Decision:\".\n\nOk produce steps.\n\nWe may produce pseudocode:\n\nStart\n→ Step 1: 設定 bulls = 0, cows = 0, secretCount[10] = 0, guessCount[10] = 0 // 初始化計數\n→ Step 2: 取得長度 n = len(secret) // 取得數字長度\n→ Decision: 是否還有未處理位? // 迴圈\n   Yes → Step 3: 如果 secret[i] == guess[i]? // 檢查是否為牛\n        Yes → bulls++ // 牛數 +1\n        No → secretCount[secret[i]]++ ; guessCount[guess[i]]++ // 將非牛數字加入計數\n   No → Step 4: 迴圈結束 // 完成遍歷\n→ Step 5: 針對每個數字 d 0-9 計算 cows += min(secretCount[d], guessCount[d]) // 計算奶牛\n→ Step 6: 返回字串 \"{bulls}A{cows}B\" // 組合結果\nEnd\n\nBut we need \"逐行\" each line. Use arrow for each step. Use Decision for the while loop. Could also use for loop.\n\nAlso maybe need to show \"i\" variable. We can express iterative process. Should we use \"for i = 0 to n-1\"? We can produce:\n\n→ Step 2: for i = 0 to n-1 // 遍歷每個位置\n\nBut we need to include Decision arrow? We can incorporate.\n\nSimplify: use for loop:\n\n→ Step 2: for i = 0 to n-1\n    → Decision: secret[i] == guess[i]?\n        Yes → bulls++ // 牛\n        No  → secretCount[secret[i]]++ ; guessCount[guess[i]]++ // 計數\n\nBut each line must be a line, we can't nest too many. But we can include nested decisions inside for loop line. The instructions: \"Use virtual code arrows and structure.\" The sample shows nested decisions lines with indentation.\n\nThus we can produce as:\n\nStart // 程式開始執行\n→ Step 1: 初始化 bulls = 0, cows = 0, secretCount[10] = 0, guessCount[10] = 0 // 設置計數器\n→ Step 2: n = len(secret) // 取得數字長度\n→ Decision: 循環 i 從 0 到 n-1? // 迴圈遍歷\n    Yes → Step 3: if secret[i] == guess[i]? // 判斷是否為牛\n        Yes → bulls++ // 牛數加一\n        No  → secretCount[secret[i]]++ ; guessCount[guess[i]]++ // 將非牛數字記錄\n    No  → Step 4: 循環結束 // 所有位已處理\n→ Step 5: for d from 0 to 9\n    → Decision: 兩邊計數都大於 0? // 計算奶牛\n        Yes → cows += min(secretCount[d], guessCount[d]) // 加入奶牛\n        No  → // 無操作\n→ Step 6: hint = str(bulls) + \"A\" + str(cows) + \"B\" // 組合字串\n→ Step 7: return hint // 返回結果\nEnd // 程式執行結束\n\nBut we need to ensure each line uses the format: \"虛擬碼步驟 // 解釋\". So each line as string. Use arrow \"→\".\n\nLet's craft final output with proper indentation. Use spaces for indentation after arrows? The sample uses arrow then step. We'll use \"→\" at each step line. For decisions, we indent with spaces. We'll keep each line on its own line. Provide explanation in Chinese.\n\nEdge: we may want to indicate that \"Step 2\" uses \"for i in 0..n-1\". The decision inside loops: \"Decision: secret[i] == guess[i]?\". Good.\n\nAlso we must mention we use arrays secretCount[10], guessCount[10] to count digits. Use min function.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 bulls = 0, cows = 0, secretCount[10] = 0, guessCount[10] = 0 // 設置計數器以儲存每位數字的頻率  \n→ Step 2: n = len(secret) // 取得秘密數字與猜測數字的長度  \n→ Decision: 迴圈 i 從 0 到 n-1? // 開始遍歷每個位置  \n  Yes → Step 3: if secret[i] == guess[i]? // 判斷是否為「牛」  \n    Yes → bulls++ // 牛數加一  \n    No  → secretCount[secret[i]]++ ; guessCount[guess[i]]++ // 將非牛數字加入對應計數表  \n  No → Step 4: 循環結束 // 所有位已處理  \n→ Step 5: for d from 0 to 9  \n  → Decision: secretCount[d] > 0 且 guessCount[d] > 0? // 兩邊都有此數字時才可算「奶牛」  \n    Yes → cows += min(secretCount[d], guessCount[d]) // 加入最小頻率作為奶牛數  \n    No  → // 無需任何操作  \n→ Step 6: hint = str(bulls) + \"A\" + str(cows) + \"B\" // 依照格式組合提示字串  \n→ Step 7: return hint // 回傳最終提示  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets_with_dup(nums):\n    \"\"\"Return all unique subsets of nums (allowing duplicates in input).\"\"\"\n    nums.sort()\n    result = [[]]  # start with empty subset\n\n    for num in nums:\n        # For each existing subset, create a new one that includes the current num\n        new_subsets = [subset + [num] for subset in result]\n        result += new_subsets\n\n    # Remove duplicates caused by repeated numbers\n    unique = []\n    seen = set()\n    for subset in result:\n        key = tuple(subset)\n        if key not in seen:\n            seen.add(key)\n            unique.append(subset)\n    return unique\n\ndef format_output(subsets):\n    \"\"\"Format the list of subsets as a string without spaces.\"\"\"\n    subset_strs = []\n    for subset in subsets:\n        inner = \",\".join(str(x) for x in subset)\n        subset_strs.append(f\"[{inner}]\")\n    return \"[\" + \",\".join(subset_strs) + \"]\"\n\nif __name__ == \"__main__\":\n    # Read entire stdin, e.g. \"nums = [1,2,2]\"\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list part from the input string\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        raise ValueError(\"Input must contain a list in brackets.\")\n    list_str = data[start:end+1]\n    nums = ast.literal_eval(list_str)\n\n    subsets = subsets_with_dup(nums)\n    output = format_output(subsets)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. Task: generate all subsets of array with duplicates, no duplicate subsets. Typical algorithm: sort array, backtracking, skip duplicates. Steps: Start, read nums, sort, define result list, define backtrack function, call, return. For each element, include or skip. For duplicates, skip if same as previous and not chosen.\n\nWe need to produce virtual code lines with arrow. Use arrow for steps and decisions.\n\nLet's craft:\n\nStart // program start\n→ Step 1: Read input array nums // get array\n→ Step 2: Sort nums ascending // sort to group duplicates\n→ Step 3: Initialize result list subsets with empty subset // start result\n→ Step 4: Define recursive function backtrack(index, path) // backtracking helper\n→ Decision: index equals length of nums? // base case\n    Yes → Step 5: Add copy of path to subsets // store subset\n    No  → Step 6: Include current element nums[index] in path\n        → Step 7: Call backtrack(index+1, path) // explore including\n        → Step 8: Remove last element from path // backtrack\n        → Decision: should skip duplicates? // to avoid duplicate subsets\n            Yes → Step 9: If nums[index] equals nums[index-1] and current element not already considered in this level? // skip duplicates\n                → Step 10: Call backtrack(index+1, path) // explore excluding but only once\n            No  → Step 11: Call backtrack(index+1, path) // skip current element normally\nBut need to handle duplicate skip logic properly. Typically we skip duplicate branches: after processing inclusion, we skip duplicates when excluding by moving index forward until next different number. Or simpler: in each level, if current element equals previous and previous was not taken, skip. But we are not tracking taken flag. Alternative: use for loop inside backtrack: for i from index to len-1: if i > index and nums[i]==nums[i-1] continue. Add nums[i] to path, backtrack(i+1), pop. That simpler.\n\nLet's design using for loop approach.\n\nStart\n→ Step 1: Read nums\n→ Step 2: Sort nums\n→ Step 3: Initialize result subsets = [[]]\n→ Step 4: Define function dfs(start, current) // current subset\n→ Decision: start == len(nums)? // if reached end\n    Yes → Step 5: Append copy of current to subsets\n    No  → Step 6: For i from start to len(nums)-1\n        → Decision: i > start and nums[i]==nums[i-1]?\n            Yes → Step 7: Continue // skip duplicate at this level\n            No  → Step 8: Append nums[i] to current\n                → Step 9: Call dfs(i+1, current) // explore\n                → Step 10: Pop last element from current // backtrack\nEnd\n\nWe need to output each line with explanation.\n\nLet's produce lines. Use arrow. For loops and decisions, format.\n\nWe can include indentation by spaces.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input array nums // 取得使用者提供的整數陣列  \n→ Step 2: Sort nums in ascending order // 先排序，方便後續跳過重複元素  \n→ Step 3: Initialize result subsets with an empty list subsets = [[]] // 開始時已包含空子集  \n→ Step 4: Define recursive function dfs(start, current) // backtracking 的核心函式  \n→ Decision: 是否已經到達陣列尾端? (start == len(nums)) // 基本情況  \n  Yes → Step 5: Append copy of current to subsets // 把目前子集加入結果  \n  No  → Step 6: For i from start to len(nums)-1 // 從當前索引開始遍歷每個元素  \n    Decision: i > start 且 nums[i] == nums[i-1] ? // 同一層級的重複元素  \n     Yes → Step 7: Continue // 跳過重複項以防產生重複子集  \n     No  → Step 8: Append nums[i] to current // 選擇當前元素  \n      → Step 9: Call dfs(i+1, current) // 深入下一層，使用 i+1 作為新的起點  \n      → Step 10: Pop last element from current // 回溯，移除剛才加入的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,2,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 2, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # Build a mapping from number to all its indices for O(1) pick\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # Randomly select one index among all indices of target\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Wrap the input string so that it becomes a list of two elements\n    # Example: '[\"Solution\", \"pick\"], [[[1,2,3]], [2]]' -> ['[\"Solution\", \"pick\"], [[[1,2,3]], [2]]']\n    wrapped = f'[{data}]'\n    ops, args = ast.literal_eval(wrapped)\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg for constructor is a list containing one element: the nums list\n            obj = Solution(arg[0])\n            results.append(None)          # Corresponds to null in output\n        elif op == \"pick\":\n            # arg for pick is a list containing one element: the target value\n            results.append(obj.pick(arg[0]))\n        else:\n            # In case of unexpected operation, append None\n            results.append(None)\n\n    # Print the results list\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this requirement. We should output line by line with arrow and comments. Provide the steps for class Solution with constructor and pick method.\n\nVirtual code structure: Start → Step 1: Define class Solution // class definition\n→ Step 2: Store array nums // store input array\n→ Step 3: For pick: Find indices with target // scan array\n→ Step 4: Randomly select one index from list // use random\n→ Step 5: Return selected index // output\nAlso handle random uniformly: maybe maintain mapping from target to indices using dictionary for O(1). But since requirement not explicit, can do simple. But typical solution uses hashmap for fast. Provide virtual code accordingly.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: Class Solution // 定義 Solution 類\n→ Step 2:   Variable: array nums // 儲存原始陣列\n→ Step 3:   Constructor(nums) // 初始化物件\n→ Step 4:     Set this.nums = nums // 存儲陣列\n→ Step 5:   Method pick(target) // 取得目標\n→ Step 6:     Initialize list indices = [] // 用於存儲符合目標的索引\n→ Step 7:     For i from 0 to nums.length-1\n→ Step 8:         If nums[i] == target\n→ Step 9:             Append i to indices // 收集索引\n→ Step 10:  Randomly choose one from indices\n→ Step 11:  Return chosen index // 返回隨機索引\n→ End // 程式結束\n\nWe need to include arrow in lines. Use \"→\" before each step. For steps inside loops, indentation indicated? Use indentation as sample. Use \"→\" for each step. For Decision lines, not needed.\n\nWe might show steps for constructor and method separately. For loops, show \"→\" lines nested, with indentation.\n\nWe must ensure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Class Solution // 定義 Solution 類  \n→ Step 2:   Variable: array nums // 儲存原始陣列  \n→ Step 3:   Constructor(nums) // 初始化物件  \n→ Step 4:     Set this.nums = nums // 存儲陣列到物件  \n→ Step 5:   Method pick(target) // 取得目標元素的隨機索引  \n→ Step 6:     Initialize list indices = [] // 用於收集所有符合 target 的索引  \n→ Step 7:     For i from 0 to this.nums.length - 1 // 遍歷整個陣列  \n→ Step 8:         If this.nums[i] == target // 找到目標元素  \n→ Step 9:             Append i to indices // 將索引加入列表  \n→ Step 10:   Randomly choose one from indices // 隨機選取一個索引  \n→ Step 11:   Return chosen index // 回傳隨機索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"Return string sorted by descending frequency of characters.\"\"\"\n        count = Counter(s)\n        # most_common returns items sorted by count descending\n        return ''.join(char * freq for char, freq in count.most_common())\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # Extract string inside quotes if present, otherwise use entire input\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        s = data\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The requirement: virtual code steps, with arrow notation. Provide line by line steps for algorithm. Use Start, End, Decision, arrow. Provide explanation after //.\n\nWe must not output actual code, only pseudo steps. The input: string s. Need to sort by frequency descending. Steps: Start, read input, count frequency, create list of pairs char, freq, sort descending, build result string by repeating char freq times. Return string. For multiple answers any.\n\nWe need to produce pseudo algorithm step lines. Each line: \"虛擬碼步驟 // 解釋\" . Use arrow for flow. Example uses \"→\". Use indentation to show sub decisions.\n\nLet's produce lines:\n\nStart\n→ Step 1: 讀取輸入字串 s // 獲取要排序的字串\n→ Step 2: 初始化空字典 freqMap // 用來存儲每個字符的頻率\n→ Decision: 遍歷 s? // 為每個字符統計頻率\n    Yes → Step 3: 對於 s 中每個字符 c\n        → Update freqMap[c] = freqMap.get(c,0)+1 // 計數\n        → Decision: 是否遍歷完所有字符? // 判斷是否完成統計\n            Yes → Step 4: 把 freqMap 轉成列表 items[(char,freq)] // 方便排序\n            No  → 回到 上一步 // 仍在遍歷\n→ Step 5: 排序 items 按 freq 降序 // 使高頻字符先出現\n→ Step 6: 初始化空結果字符串 result // 用於拼接最終答案\n→ Decision: 是否有剩餘項目? // 循環生成結果\n    Yes → Step 7: 取出首個項目 (c,f)\n        → Step 8: 將字串 c 重複 f 次並追加到 result\n        → Step 9: 移除已處理項目\n        → Decision: 是否還有項目? // 迴圈結束判斷\n            Yes → 回到 Decision 步驟\n            No  → Step 10: 返回 result // 完成\nEnd\n\nWe need to use arrow in each line. Provide explanation after //.\n\nLet's format properly. Use Start, End lines. Use \"Decision:\" lines. Indent using spaces maybe. Ensure each line has \"虛擬碼步驟\" and then // explanation. Use arrow \"→\" after each step? Example: \"→ Step 1: 讀取輸入字串 s // 獲取要排序的字串\" etc.\n\nMake sure to include indentation of sub steps. Use \"→\" inside sub steps as well.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得要排序的原始字串  \n→ Step 2: 初始化空字典 freqMap // 用於統計各字符頻率  \n\n→ Decision: 遍歷 s 的每個字符? // 為每個字符進行頻率累計  \n    Yes → Step 3: 取得 s 的下一個字符 c  \n        → Update freqMap[c] = freqMap.get(c,0)+1 // 將 c 的計數加 1  \n        → Decision: 是否已遍歷完 s? // 判斷是否完成統計  \n            Yes → Step 4: 將 freqMap 轉成列表 items[(char,freq)] // 方便後續排序  \n            No  → 回到 Step 3 // 仍在遍歷 s  \n\n→ Step 5: 排序 items 按 freq 降序 // 使頻率高的字符排在前面  \n→ Step 6: 初始化空結果字符串 result // 用於儲存最終輸出  \n\n→ Decision: items 是否還有剩餘項目? // 準備循環生成結果  \n    Yes → Step 7: 取出 items 的首個項目 (c,f)  \n        → Step 8: 將字符 c 重複 f 次並追加到 result // 建立該字符的子串  \n        → Step 9: 從 items 中移除已處理的項目  \n        → Decision: 是否還有項目? // 判斷是否繼續迴圈  \n            Yes → 回到 Decision 步驟  \n            No  → Step 10: 返回 result // 完成並輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphynrso68.py\", line 37, in <module>\n    words = ast.literal_eval(data[start:end])\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkng0ck3e.py\", line 37, in <module>\n    words = ast.literal_eval(data[start:end])\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"bat\",\"tab\",\"cat\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3nkxxfg4.py\", line 37, in <module>\n    words = ast.literal_eval(data[start:end])\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"a\",\"\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def palindromePairs(self, words):\n        # Map reversed word to its index for O(1) lookup\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            # Try every split position, including empty prefix/suffix\n            for j in range(len(word) + 1):\n                prefix, suffix = word[:j], word[j:]\n\n                # Case 1: prefix is a palindrome, look for reversed suffix\n                if prefix == prefix[::-1]:\n                    rev_suffix_idx = rev_map.get(suffix)\n                    if rev_suffix_idx is not None and rev_suffix_idx != i:\n                        res.append([i, rev_suffix_idx])\n\n                # Case 2: suffix is a palindrome (avoid duplicate when j == 0)\n                if j != 0 and suffix == suffix[::-1]:\n                    rev_prefix_idx = rev_map.get(prefix)\n                    if rev_prefix_idx is not None and rev_prefix_idx != i:\n                        res.append([rev_prefix_idx, i])\n\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire input, e.g. 'words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]'\n    data = sys.stdin.read().strip()\n    # Extract the part inside the brackets and parse it\n    if '[' in data and ']' in data:\n        start = data.index('[')\n        end = data.rindex(']')\n        words = ast.literal_eval(data[start:end])\n    else:\n        words = []\n\n    solution = Solution()\n    pairs = solution.palindromePairs(words)\n    # Output without spaces as per examples\n    print(json.dumps(pairs, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find all palindrome pairs with O(total length) runtime. We will provide virtual pseudocode with steps and explanations. Must be line-by-line with virtual arrows.\n\nWe need to design algorithm: Use hash map of reversed words to index. For each word, iterate over splits, check prefix palindrome, suffix palindrome, and handle empty string and duplicates.\n\nBut requirement O(sum length). Standard algorithm: O(n * avg length) with hashing. The complexity of building map O(total length). For each word iterate over each position O(total length). So overall O(total length). We'll output pseudocode.\n\nWe need to produce lines like:\n\nStart // ...\n→ Step 1: Build map of reversed words to index // ...\n→ Step 2: For each word ... etc.\n\nWill produce many steps, but concise. Provide explanation comments.\n\nLet's craft.\n\nWe'll have structure:\n\nStart // Program starts\n\n→ Step 1: Create hash map revMap // store reversed word -> index\n→ Step 2: For each word with index i:\n    → Decision: Check if empty string exists and i != emptyIndex ...\nBut we may produce more structured steps.\n\nGoal is to produce algorithm that returns pairs.\n\nWe'll produce steps:\n\nStart\n→ Step 1: Initialize map revMap, list result\n→ Step 2: For each index i, word in words:\n    → Step 2a: Insert reversed word into revMap\n→ Step 3: For each index i, word in words:\n    → Step 3a: If word is empty:\n        → Decision: if any other word is palindrome, add pairs ...\nBut we can combine.\n\nHowever, we need to show algorithm that is O(total length). We'll include loops over splits.\n\nLet's produce final pseudocode.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 hash map revMap 以儲存每個字串倒序與其索引 // 方便快速查找對應的索引  \n→ Step 2: 建立空列表 result 用於儲存所有符合條件的 (i, j)  \n→ Step 3: 建立變數 emptyIdx = -1，用於記錄空字串的索引（若存在）  \n→ Decision: 若 words 中存在空字串？  \n Yes → Set emptyIdx 為該空字串的索引 // 空字串可與任何回文字串配對  \n No  → emptyIdx 保持 -1  \n\n→ Step 4: 迴圈 i ← 0 … words.length-1  \n → Insert reverse(words[i]) → i into revMap // 以倒序為 key 存入對應索引  \n→ End // 完成映射建構  \n\n→ Step 5: 迴圈 i ← 0 … words.length-1  \n → current ← words[i]  \n → 迴圈 splitPos ← 0 … current.length  \n  → Decision: 若 splitPos < current.length? // 只考慮有效切割  \n   Yes → prefix ← current[0:splitPos]，suffix ← current[splitPos:]  \n    → Decision: prefix 是否為回文？  \n     Yes → revSuffixIdx ← revMap.get(reverse(suffix))  \n      Decision: revSuffixIdx 及 revSuffixIdx ≠ i?  \n       Yes → result.append((i, revSuffixIdx)) // i 前綴回文，suffix 的倒序位於 j  \n       No  → 無  \n     No  → 無  \n    → Decision: 若 splitPos > 0 且 suffix 為回文？  \n     Yes → revPrefixIdx ← revMap.get(reverse(prefix))  \n      Decision: revPrefixIdx 及 revPrefixIdx ≠ i?  \n       Yes → result.append((revPrefixIdx, i)) // suffix 為回文，prefix 的倒序位於 j  \n       No  → 無  \n     No  → 無  \n  → End迴圈 splitPos  \n → Decision: current 是否為回文且 emptyIdx ≠ -1？  \n  Yes → result.append((i, emptyIdx))，result.append((emptyIdx, i)) // 空字串與回文字串配對  \n  No  → 無  \n→ End迴圈 i  \n\n→ End // 所有字串皆已檢查完畢，result 為最終答案。"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef longest_uncommon_subsequence_length(strs):\n    \"\"\"\n    根據題目，若有字串在陣列中只出現一次，則其長度為最長的不相同子序列長度。\n    若全部字串皆重複，則不存在此類子序列，回傳 -1。\n    \"\"\"\n    # 計算每個字串的出現次數\n    freq = Counter(strs)\n\n    # 只取出現次數為 1 的字串，尋找其長度最大值\n    max_len = 0\n    for s in strs:\n        if freq[s] == 1:\n            max_len = max(max_len, len(s))\n\n    return max_len if max_len > 0 else -1\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析為字串列表，計算結果並輸出。\n    標準輸入範例：'[\"aba\",\"cdc\",\"eae\"]'\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    try:\n        # 使用 json.loads 可正確解析 JSON 格式的字串列表\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若輸入格式不符，直接退出\n        return\n\n    result = longest_uncommon_subsequence_length(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm: find longest uncommon subsequence length among array of strings. Classic Leetcode problem. Solution: if any string appears exactly once and length > others? Actually known approach: if any string not repeated, answer is its length; else -1. Because for a string to be uncommon subsequence, it must not be subsequence of any other string. If string is unique and longer than all others, it's not subsequence of shorter ones. But if duplicates exist, need longest unique string length else -1. But also need to consider when unique string's length <= others but could still be uncommon? Wait typical solution: If string is unique, it's not a subsequence of any other string unless another string contains it as subsequence. But if other strings longer, they may contain it. But we just need longest uncommon subsequence. Known solution: if there is any string that is not a subsequence of any other string, answer is its length. In Leetcode solution: if any string appears only once, answer is its length, else -1. Because if string appears once, it's not subsequence of any other identical string. But could still be subsequence of another longer string. But if it's longer than all others, cannot be subsequence of any shorter. But if there are other longer strings containing it, could be subsequence. But typical assumption: if unique string length > max length of others, then answer length. But if there are duplicates, answer -1. However problem statement typical solution: check if any string unique, return its length, else -1. Actually Leetcode 1444: Longest Uncommon Subsequence II. The solution: find if any string appears only once and if its length > any other string length? Wait algorithm: For each string, check if it is not a subsequence of any other string. But this is heavy. But known trick: If a string is unique, its length is answer, else -1. Because if a string repeats, then cannot be uncommon. But if unique, could still be subsequence of others but then there must be some other string that contains it; but if that string is longer, it may contain it. However the unique string might still be subsequence of some other longer string. But problem's official solution: check each string; if unique, answer its length. If none unique, -1. That's accepted. We'll produce virtual code accordingly.\n\nWe'll produce steps: input array, create frequency map, find maxLen. For each string, if freq==1 and len==maxLen? Actually we return max len of unique strings. So iterate over unique strings, track maxLen. If maxLen >0 return it else -1. Provide virtual code lines accordingly.\n\nLet's produce step-by-step virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq 以記錄每個字串出現次數 // 用於判斷重複與否  \n→ Step 2: 遍歷 strs  \n  → For each s:  \n     freq[s] = freq.get(s, 0) + 1 // 記錄出現頻率  \n→ Step 3: 初始化變數 maxLen = 0 // 用於儲存最長的獨特字串長度  \n→ Step 4: 再次遍歷 strs  \n  → Decision: 如果 freq[s] == 1? // s 是否唯一  \n    Yes → Decision: 如果 len(s) > maxLen? // 是否比目前已知長  \n     Yes → Step 5: maxLen = len(s) // 更新最長長度  \n     No  → Skip // 目前長度較短，維持 maxLen  \n    No → Skip // s 重複，不能成為不相同子序列  \n→ Step 6: Decision: 如果 maxLen > 0? // 是否找到了唯一字串  \n  Yes → Step 7: 回傳 maxLen // 這就是最長的不相同子序列長度  \n  No  → Step 8: 回傳 -1 // 沒有符合條件的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\nfrom typing import List, Set\n\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        \"\"\"Return all 10‑letter sequences that appear more than once in s.\"\"\"\n        seen: Set[str] = set()\n        repeated: Set[str] = set()\n        for i in range(len(s) - 9):          # 0 to len(s)-10 inclusive\n            seq = s[i:i + 10]\n            if seq in seen:\n                repeated.add(seq)           # second (or later) time -> add to result\n            else:\n                seen.add(seq)\n        return list(repeated)\n\n\ndef extract_dna_sequence(data: str) -> str:\n    \"\"\"\n    Extract the DNA sequence string from the input data.\n    Supports two formats:\n        1. s = 'DNASTRING'\n        2. DNASTRING\n    \"\"\"\n    # Try to find a quoted string first\n    match = re.search(r\"'([^']*)'\", data)\n    if match:\n        return match.group(1)\n    # Fallback: strip whitespace and quotes if present\n    return data.strip().strip(\"'\\\"\")\n\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    dna_seq = extract_dna_sequence(raw_input)\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(dna_seq)\n    # Output as a JSON array (double‑quoted strings)\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm that finds all 10-letter-long substrings that appear more than once in a DNA string. Should use steps, decisions. Not actual code. Provide explanation each line. Let's design: Start → Step: Input string s → If length <10 → End with empty list. Else: Initialize empty map (dictionary) to store counts. Initialize result set. Iterate i from 0 to len(s)-10. Extract substring of length 10. If substring in map: if count ==1: add to result. increment count. else: increment count. After loop, return list of result. End.\n\nUse virtual code syntax: \"→ Step 1: ...\" etc.\n\nWe must use arrows for decisions: Decision: length <10? Yes→ End else continue.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得 DNA 序列  \n→ Decision: 如果 s 的長度 < 10? // 需至少 10 個核苷酸才能形成 10 字母序列  \n  Yes → Step 2: 返回空集合 // 沒有足夠長度，直接結束  \n  No  → Step 3: 初始化字典 countMap 為空 // 用來統計每個 10 字母序列的出現次數"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # 复制当前排列\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交换\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 恢复\n\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # 从输入中提取列表字符串\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        list_str = match.group(0)\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.permute(nums)\n\n    # 输出格式化为无空格的 JSON\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations for generating all permutations of array of distinct integers. The virtual code uses arrows and decision etc.\n\nWe produce steps: Start, Step 1: Input array, Step 2: Define result list, Step 3: Define backtrack function, Step 4: If current path length equals n, add to result, else loop through nums, if not used, add to path, mark used, backtrack, unmark, pop path. Then initial call. End.\n\nWe need to use arrows: → and Decision:. Provide concise explanation after //.\n\nLet's produce lines.\n\nRemember to use \"虛擬碼步驟\" but no actual code. We use structure like:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 nums // 取得使用者提供的整數陣列\n→ Step 2: 建立空列表 permutations // 用來存放所有排列結果\n→ Step 3: 定義布林陣列 visited[n] 為 false // 追蹤哪些元素已經放入當前排列\n→ Step 4: 定義遞迴函式 backtrack(path) // 用於組合排列\n    → Decision: 如果 path 長度 == n? // 判斷是否已組成完整排列\n        Yes → Step 5: permutations.Add(copy of path) // 完整排列加入結果\n        No  → Step 6: 循環遍歷 nums 的每個索引 i\n            → Decision: 如果 visited[i] 為 false? // 該元素尚未使用\n                Yes → Step 7: path.Add(nums[i]) // 加入當前元素\n                        visited[i] = true // 標記已使用\n                        → Call backtrack(path) // 深度優先遞迴\n                        visited[i] = false // 回溯後解除標記\n                        path.RemoveLast() // 移除最後一個元素\n→ Step 8: 呼叫 backtrack([]) // 開始遞迴，初始 path 為空\n→ Step 9: 回傳 permutations // 返回所有排列結果\nEnd // 程式執行結束\n\nWe need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow and indentation maybe but each line separate. For nested steps, we indent? The example shows indentation of nested lines. We can keep indentation to indicate hierarchy. But each line still separate.\n\nMake sure each line has \"虛擬碼步驟\" like \"Start\" or \"→ Step 1: ...\". Provide explanation after //.\n\nWe produce in Chinese.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 nums // 取得使用者提供的整數陣列  \n→ Step 2: 建立空列表 permutations // 用來存放所有排列結果  \n→ Step 3: 建立布林陣列 visited[n] 初始化為 false // 追蹤哪些元素已經放入當前排列  \n→ Step 4: 定義遞迴函式 backtrack(path) // 用於組合排列  \n → Decision: 如果 path 長度 == n? // 判斷是否已組成完整排列  \n  Yes → Step 5: permutations.Add(copy of path) // 完整排列加入結果  \n  No  → Step 6: 循環遍歷 nums 的每個索引 i // 嘗試將每個尚未使用的元素放入 path  \n   → Decision: 如果 visited[i] 為 false? // 該元素尚未使用  \n    Yes → Step 7: path.Add(nums[i]) // 加入當前元素  \n     visited[i] = true // 標記已使用  \n     → Call backtrack(path) // 深度優先遞迴  \n     visited[i] = false // 回溯後解除標記  \n     path.RemoveLast() // 移除最後一個元素  \n→ Step 8: 呼叫 backtrack([]) // 開始遞迴，初始 path 為空  \n→ Step 9: 回傳 permutations // 返回所有排列結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        找到陣列中的重複數字。此方法不修改原陣列，且使用 O(1) 追加空間。\n        \"\"\"\n        # 第一階段：找出兩指標相遇的點\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]          # 慢指標一次走一步\n            fast = nums[nums[fast]]    # 快指標一次走兩步\n            if slow == fast:\n                break\n\n        # 第二階段：找出進入循環的入口，即重複數字\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\n\ndef main():\n    \"\"\"\n    從標準輸入讀取陣列資料，並輸出重複數字。\n    允許輸入形如 'nums = [1,3,4,2,2]' 或僅為 '[1,3,4,2,2]' 的格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出所有整數\n    numbers = [int(x) for x in re.findall(r'-?\\d+', data)]\n\n    if not numbers:\n        return\n\n    sol = Solution()\n    duplicate = sol.findDuplicate(numbers)\n    print(duplicate)\n\n\nif __name__ == \"__main__\":\n    import re\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving \"Find the duplicate number\" problem with constraints: cannot modify array, constant extra space. Standard solution: Floyd's cycle detection. Steps: first phase find intersection of two pointers; second phase find entrance to cycle. So virtual code lines: Start, Step 1: initialize two pointers; Step 2: advance until they meet; Step 3: reset pointer; Step 4: move until meet again; Step 5: output duplicate. Provide explanation each line.\n\nMake sure to include Decision nodes only if necessary. But algorithm has loops; use Decision for loop condition. Also we might want to illustrate \"While\" loops with Decision.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrows → etc.\n\nWe can produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 slow = nums[0], fast = nums[nums[0]] // 設定兩個指標開始位置\n→ Decision: while (slow != fast)? // 循環直到兩指標相遇\n    Yes → Step 2: slow = nums[slow] // slow 指標每次走一步\n    Yes → Step 3: fast = nums[nums[fast]] // fast 指標每次走兩步\n    No  → End of phase 1 // 兩指標相遇，進入下一階段\nStart phase 2\n→ Step 4: reset slow = nums[0] // 重置 slow 指標到起始點\n→ Decision: while (slow != fast)?\n    Yes → Step 5: slow = nums[slow] // slow 指標每次走一步\n    Yes → Step 6: fast = nums[fast] // fast 指標每次走一步\n    No  → Step 7: duplicate = slow // 找到重複數字\nEnd // 程式結束\n\nBut we need to keep format exactly. Use arrows accordingly. Maybe combine start of phase 2 under same \"Start\" or new \"Start\" line? Format example uses Start at top and End at bottom. We can have just one Start, but phases separate. Maybe we can use a label. But requirement not strict. Let's produce simple linear.\n\nWe'll not produce extraneous text. We'll keep each step on separate line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 slow = nums[0], fast = nums[nums[0]] // 設定慢指標與快指標的起始位置  \n→ Decision: while (slow ≠ fast)? // 兩指標是否相遇？  \n  Yes → Step 2: slow = nums[slow] // slow 指標每次前進一步  \n  Yes → Step 3: fast = nums[nums[fast]] // fast 指標每次前進兩步  \n  No  → Step 4: // 相遇，進入下一階段  \n→ Step 5: 重置 slow = nums[0] // 把 slow 指標移回起點  \n→ Decision: while (slow ≠ fast)? // 再次檢查兩指標是否相遇  \n  Yes → Step 6: slow = nums[slow] // slow 每次前進一步  \n  Yes → Step 7: fast = nums[fast] // fast 每次前進一步  \n  No  → Step 8: duplicate = slow // 兩指標相遇的位置即為重複數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[None,None,None,1.5,None,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[None, None, None, 1.5, None, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # max-heap for the lower half (store negatives)\n        self.small = []\n        # min-heap for the upper half\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 先放到小根堆（實際為大根堆）\n        heapq.heappush(self.small, -num)\n\n        # 保證所有小根堆的數都不大於大根堆的數\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩個堆的大小\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把兩個獨立的列表包成一個 tuple，方便 literal_eval 解析\n    data = '(' + data + ')'\n    ops, args = ast.literal_eval(data)\n\n    obj = None\n    output = []\n    for op, arg in zip(ops, args):\n        if op == 'MedianFinder':\n            obj = MedianFinder()\n            output.append(None)\n        elif op == 'addNum':\n            obj.addNum(arg[0])\n            output.append(None)\n        elif op == 'findMedian':\n            median = obj.findMedian()\n            output.append(median)\n\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing MedianFinder class with addNum and findMedian, using likely two heaps approach. We should provide line by line virtual code and explanations. Let's design a flow: Start, Step1: initialize two heaps: maxHeap for lower half, minHeap for upper half. Step2: addNum: if maxHeap empty or num <= maxHeap.peek, push to maxHeap else push to minHeap. Then balance: if maxHeap.size > minHeap.size+1 => move top from maxHeap to minHeap; if minHeap.size > maxHeap.size => move top from minHeap to maxHeap. Step3: findMedian: if sizes equal => median = (maxHeap.peek+minHeap.peek)/2.0 else median = maxHeap.peek. End. Also, we might mention method definitions.\n\nWe need to output each line of virtual code with comment after space. Use arrow notation.\n\nWe need to be careful to match format: each line: \"虛擬碼步驟 // 解釋\". Use Chinese explanation. Use \"Start\", \"End\" as steps.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 maxHeap（大根堆）和 minHeap（小根堆） // 建立兩個堆以保持中位數\n→ Step 2: 定義 addNum(num) // 方法：將新數字加入結構\n    → Decision: maxHeap 是否為空？ or num <= maxHeap.top ?\n        Yes → Push num 到 maxHeap // 小於等於中位數放左半部\n        No  → Push num 到 minHeap // 大於中位數放右半部\n    → Decision: maxHeap.size - minHeap.size > 1 ?\n        Yes → Move top from maxHeap 到 minHeap // 右移保持平衡\n        No  → Decision: minHeap.size - maxHeap.size > 0 ?\n            Yes → Move top from minHeap 到 maxHeap // 左移保持平衡\n            No  → // 已平衡\n→ Step 3: 定義 findMedian() // 方法：返回目前所有數的中位數\n    → Decision: maxHeap.size == minHeap.size ?\n        Yes → Return (maxHeap.top + minHeap.top) / 2.0 // 兩堆相等，取平均\n        No  → Return maxHeap.top // 左堆大，返回左堆頂\nEnd\n\nBut we must match exactly the format: \"虛擬碼步驟\" + space + \"// 解釋\". Each line should be single line. Use \"→\" etc. Use \"Decision:\" lines with indent? In example they show indentation with spaces. We'll replicate. Use proper indent of 4 spaces for nested? Let's follow example: They used \"    Yes → Step...\" etc.\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 maxHeap（大根堆）和 minHeap（小根堆） // 建立兩個堆以維持中位數\n→ Step 2: 定義 addNum(num) // 方法：將新數字加入結構\n    → Decision: maxHeap 是否為空 或 num <= maxHeap.top? // 判斷將數字放入哪個堆\n        Yes → Push num 到 maxHeap // 小於等於中位數放左半部\n        No  → Push num 到 minHeap // 大於中位數放右半部\n    → Decision: maxHeap.size - minHeap.size > 1? // 檢查左堆是否過大\n        Yes → Move top from maxHeap 到 minHeap // 右移以平衡\n        No  → Decision: minHeap.size - maxHeap.size > 0? // 檢查右堆是否過大\n            Yes → Move top from minHeap 到 maxHeap // 左移以平衡\n            No  → // 已平衡\n→ Step 3: 定義 findMedian() // 方法：返回目前所有數的中位數\n    → Decision: maxHeap.size == minHeap.size? // 判斷堆大小是否相等\n        Yes → Return (maxHeap.top + minHeap.top) / 2.0 // 兩堆相等，取平均\n        No  → Return maxHeap.top // 左堆大，返回左堆頂\nEnd // 程式執行結束\n\nMake sure each line has \" //\". Also maintain arrow lines. Provide as output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxHeap（大根堆）和 minHeap（小根堆） // 建立兩個堆以維持中位數  \n→ Step 2: 定義 addNum(num) // 方法：將新數字加入結構  \n    → Decision: maxHeap 是否為空 或 num <= maxHeap.top? // 判斷將數字放入哪個堆  \n        Yes → Push num 到 maxHeap // 小於等於中位數放左半部  \n        No  → Push num 到 minHeap // 大於中位數放右半部  \n    → Decision: maxHeap.size - minHeap.size > 1? // 檢查左堆是否過大  \n        Yes → Move top from maxHeap 到 minHeap // 右移以平衡  \n        No  → Decision: minHeap.size - maxHeap.size > 0? // 檢查右堆是否過大  \n            Yes → Move top from minHeap 到 maxHeap // 左移以平衡  \n            No  → // 已平衡  \n→ Step 3: 定義 findMedian() // 方法：返回目前所有數的中位數  \n    → Decision: maxHeap.size == minHeap.size? // 判斷堆大小是否相等  \n        Yes → Return (maxHeap.top + minHeap.top) / 2.0 // 兩堆相等，取平均  \n        No  → Return maxHeap.top // 左堆大，返回左堆頂  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvee9i50l.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpvee9i50l.py\", line 57, in main\n    intervals, new_interval = parse_input()\n                              ^^^^^^^^^^^^^\n  File \"/tmp/tmpvee9i50l.py\", line 40, in parse_input\n    intervals = ast.literal_eval(expr.strip())\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3],[6,9]], newInterval = [2,5]\n                               ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb5kb8qky.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpb5kb8qky.py\", line 57, in main\n    intervals, new_interval = parse_input()\n                              ^^^^^^^^^^^^^\n  File \"/tmp/tmpb5kb8qky.py\", line 40, in parse_input\n    intervals = ast.literal_eval(expr.strip())\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n                                                    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        result.append(newInterval)\n\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input():\n    intervals = None\n    new_interval = None\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], []\n    # 允許輸入在同一行或多行，分別包含 \"intervals =\" 與 \"newInterval =\"\n    for part in data.splitlines():\n        part = part.strip()\n        if not part:\n            continue\n        if part.startswith('intervals'):\n            _, expr = part.split('=', 1)\n            intervals = ast.literal_eval(expr.strip())\n        elif part.startswith('newInterval'):\n            _, expr = part.split('=', 1)\n            new_interval = ast.literal_eval(expr.strip())\n    # 如果整個輸入在一行，例如 \"intervals = [[1,3],[6,9]], newInterval = [2,5]\"\n    if intervals is None or new_interval is None:\n        # 直接從整個字串中提取兩個列表\n        parts = data.split('newInterval')\n        if len(parts) == 2:\n            left, right = parts\n            if 'intervals' in left:\n                _, expr = left.split('=', 1)\n                intervals = ast.literal_eval(expr.strip())\n            new_interval = ast.literal_eval(right.strip().lstrip('= ').lstrip(',').strip())\n    return intervals, new_interval\n\ndef main():\n    intervals, new_interval = parse_input()\n    sol = Solution()\n    result = sol.insert(intervals, new_interval)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with comments, describing algorithm: insert new interval into sorted non-overlapping intervals list, merging overlaps. Steps: iterate through intervals, add those ending before new interval start, merge overlapping, add remaining. Use list to accumulate. Use pseudocode lines.\n\nWe need to produce per line: virtual code step followed by comment.\n\nUse Start, Decision: with Yes →, No →.\n\nWe must not output actual code. Just pseudocode steps.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 result 為空列表 // 用來存放最終 intervals\n→ Step 2: 將 newStart, newEnd 分別存入變數 // 方便後續比較\n→ Decision: 是否存在 intervals? // 若列表為空，直接返回 newInterval\n    Yes → Step 3: 設定 idx = 0 // index for遍歷 intervals\n    No  → Step 4: 結果 = [newInterval] // 若無原 intervals，直接返回\n→ Step 5: Decision: idx < intervals 長度? // 循環遍歷\n    Yes → Decision: intervals[idx].end < newStart? // 當前 interval 完全在 newInterval 前\n        Yes → Step 6: 將 intervals[idx] 加入 result // 無交集，直接添加\n        No  → Decision: intervals[idx].start > newEnd? // 當前 interval 完全在 newInterval 後\n            Yes → Step 7: 更新 newStart = max(newStart, intervals[idx].start)? // 不需要，直接加入\n            No  → Step 8: 合併 newStart = min(newStart, intervals[idx].start) // 新 interval 與 current overlap\n            No  → Step 9: 合併 newEnd = max(newEnd, intervals[idx].end)\n            No  → Step 10: // 合併完成，跳過此 idx 但不加入結果\n    No → Step 11: // 已遍歷完所有 intervals，將合併後的 newInterval 加入 result\n→ Step 12: End // 返回結果\n\nBut we need to be careful: the algorithm is iterative: for each interval, handle. Let's produce clearer pseudocode.\n\nBetter structure:\n\nStart\n→ Step 1: Create empty list res // 存結果\n→ Step 2: Extract new_start, new_end from newInterval // 方便後續\n→ Decision: intervals 为空? // 若空直接返回 newInterval\n    Yes → Step 3: res ← [newInterval] // 將 newInterval 作為唯一 interval\n    No  → Step 4: idx ← 0 // index for intervals\n\n→ Step 5: Decision: idx < len(intervals)? // 主迴圈\n    Yes → Decision: intervals[idx].end < new_start? // 当前 interval 结束在 new_start 前\n        Yes → Step 6: Append intervals[idx] to res // 无重叠，直接加入\n        No  → Decision: intervals[idx].start > new_end? // 当前 interval 开始在 new_end 后\n            Yes → Step 7: Append [new_start, new_end] to res // 插入 newInterval 并终止后续\n            No  → Step 8: new_start ← min(new_start, intervals[idx].start) // 合并区间开始\n            No  → Step 9: new_end ← max(new_end, intervals[idx].end) // 合并区间结束\n            No  → Step 10: // 合并后不追加当前 interval，继续循环\n        // 在第一条 Yes 分支后，idx 增加\n    // In both subcases after handling, idx +=1\n    // After decision else (idx >= len(intervals)), we need to add remaining newInterval and rest intervals\n    // But we might need to append the merged newInterval after loop ends or after finishing adding newInterval.\n\nWe need to handle after loop: append merged newInterval, then any remaining intervals (those with start > new_end). Actually if newInterval merges with some intervals, after finishing loop, we must append newInterval. If some intervals after merging are still after new_end, they will be processed in loop. So algorithm: While idx < len(intervals):\n- If intervals[idx].end < new_start: res.append(intervals[idx]); idx++\n- Else if intervals[idx].start > new_end: res.append([new_start, new_end]); new_start, new_end = intervals[idx].start, intervals[idx].end; idx++? Actually we can append newInterval then append the rest intervals starting at idx. So break loop after appending newInterval, then append remaining intervals.\n\nSimplify: after while, append [new_start, new_end], then append remaining intervals from idx to end.\n\nThus pseudocode lines.\n\nLet's craft final virtual code lines step by step:\n\nStart\n→ Step 1: 初始化 res 為空列表 // 用於儲存最終結果\n→ Step 2: 取出 new_start, new_end = newInterval[0], newInterval[1] // 新區間的起止\n→ Decision: intervals 是否為空? // 若無原始區間，直接回傳\n    Yes → Step 3: 返回 [newInterval] // 單一區間\n    No  → Step 4: idx ← 0 // 迴圈索引\n\n→ Step 5: Decision: idx < len(intervals)? // 進入主迴圈\n    Yes → Decision: intervals[idx].end < new_start? // 完全在新區間前\n        Yes → Step 6: res ← res ∪ [intervals[idx]] // 加入不重疊的區間\n        No  → Decision: intervals[idx].start > new_end? // 完全在新區間後\n            Yes → Step 7: res ← res ∪ [[new_start, new_end]] // 插入新區間，結束迴圈\n            No  → Step 8: new_start ← min(new_start, intervals[idx].start) // 合併起點\n            No  → Step 9: new_end ← max(new_end, intervals[idx].end) // 合併終點\n            No  → // 合併後不將當前 interval 加入 res，直接繼續\n        // 從 idx 加 1\n    // idx += 1\n\n→ Step 10: Decision: idx < len(intervals)? // 若仍有區間未處理，返回到 Step 5\n    Yes → Step 5\n    No  → Step 11: // 迴圈結束，將合併後的 newInterval 加入\n→ Step 11: res ← res ∪ [[new_start, new_end]] // 加入最終合併區間\n→ Step 12: Decision: idx < len(intervals)? // 若有剩餘區間，加入\n    Yes → Step 13: res ← res ∪ intervals[idx:] // 加入剩餘區間\n    No  → // 無剩餘\n→ Step 14: 返回 res // 結果\n\nBut we need to maintain proper indentation and arrows. We can use \"→\" before each step. For decisions, we show \"Decision: ...\". Use \"Yes →\" and \"No →\". Also need to show arrow inside decision branches.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: res ← 空列表 // 用於儲存最終結果  \n→ Step 2: new_start ← newInterval[0] , new_end ← newInterval[1] // 取出新區間的起點與終點  \n→ Decision: intervals 是否為空? // 若沒有原始區間，直接回傳  \n    Yes → Step 3: 返回 [[new_start, new_end]] // 單一區間  \n    No  → Step 4: idx ← 0 // 設定迴圈索引  \n\n→ Step 5: Decision: idx < len(intervals)? // 主迴圈，逐個處理原始區間  \n    Yes → Decision: intervals[idx].end < new_start? // 目前區間完全在新區間前面  \n        Yes → Step 6: res ← res ∪ [intervals[idx]] // 加入不重疊的區間  \n        No  → Decision: intervals[idx].start > new_end? // 目前區間完全在新區間後面  \n            Yes → Step 7: res ← res ∪ [[new_start, new_end]] // 插入新區間，之後所有區間均在後面，直接終止迴圈  \n            No  → Step 8: new_start ← min(new_start, intervals[idx].start) // 合併區間起點  \n            No  → Step 9: new_end ← max(new_end, intervals[idx].end) // 合併區間終點  \n            No  → // 合併完成，當前區間不加入 res，繼續迴圈  \n    // 每次處理完後索引遞增  \n    idx ← idx + 1  \n    → Step 5 // 回到主迴圈判斷條件  \n\n→ Step 10: Decision: idx < len(intervals)? // 迴圈結束條件  \n    Yes → Step 5 // 若還有區間，繼續處理  \n    No  → Step 11 // 迴圈結束，處理剩餘部分  \n\n→ Step 11: res ← res ∪ [[new_start, new_end]] // 加入合併後的新區間  \n→ Decision: idx < len(intervals)? // 若有剩餘區間，直接追加  \n    Yes → Step 12: res ← res ∪ intervals[idx:] // 加入剩餘所有區間  \n    No  → // 無剩餘區間  \n\n→ Step 13: 返回 res // 程式執行結束，回傳結果  \nEnd // 程式結束執行"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_wvwdksf.py\", line 88, in <module>\n    arg_list = ast.literal_eval(lists[1])\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\n\nclass Node:\n    __slots__ = ('keys', 'prev', 'next', 'count')\n    def __init__(self):\n        self.keys = set()\n        self.prev = None\n        self.next = None\n        self.count = 0\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node()\n        node.count = count\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            target_count = node.count + 1\n            if node.next == self.tail or node.next.count > target_count:\n                target_node = self._insert_after(node, target_count)\n            else:\n                target_node = node.next\n            target_node.keys.add(key)\n            self.key_to_node[key] = target_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            if self.head.next == self.tail or self.head.next.count > 1:\n                node = self._insert_after(self.head, 1)\n            else:\n                node = self.head.next\n            node.keys.add(key)\n            self.key_to_node[key] = node\n\n    def dec(self, key):\n        node = self.key_to_node[key]\n        target_count = node.count - 1\n        node.keys.remove(key)\n        if target_count == 0:\n            del self.key_to_node[key]\n        else:\n            if node.prev == self.head or node.prev.count < target_count:\n                target_node = self._insert_after(node.prev, target_count)\n            else:\n                target_node = node.prev\n            target_node.keys.add(key)\n            self.key_to_node[key] = target_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract two list literals from input (commands and arguments)\n    lists = re.findall(r'\\[.*?\\]', data, re.S)\n    if len(lists) >= 2:\n        cmd_list = ast.literal_eval(lists[0])\n        arg_list = ast.literal_eval(lists[1])\n    else:\n        cmd_list = []\n        arg_list = []\n\n    obj = None\n    result = []\n\n    for cmd, args in zip(cmd_list, arg_list):\n        if cmd == \"AllOne\":\n            obj = AllOne()\n            result.append(None)\n        elif cmd == \"inc\":\n            obj.inc(args[0])\n            result.append(None)\n        elif cmd == \"dec\":\n            obj.dec(args[0])\n            result.append(None)\n        elif cmd == \"getMaxKey\":\n            result.append(obj.getMaxKey())\n        elif cmd == \"getMinKey\":\n            result.append(obj.getMinKey())\n        else:\n            result.append(None)\n\n    print(\"Output\\n\" + json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for implementing the AllOne data structure with O(1) operations. Provide virtual code lines with explanations, using arrows and decisions. Likely outline initialization, inc, dec, getMaxKey, getMinKey. Use double linked list of buckets, map key->node, map count->bucket. Steps per method. Let's produce lines accordingly. Use Start, End. Use decisions. Let's produce step-by-step. We'll structure inc, dec, etc. Use comments. Provide one step per line. Ensure each line ends with // explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的雙向鏈表頭尾哨兵節點 head, tail // 用於保持各計數桶的順序  \n→ Step 2: 建立空 HashMap keyNode // key → 代表此 key 所屬的 bucket 節點  \n→ Step 3: 建立空 HashMap countBucket // count → 代表該計數的 bucket 節點  \n\n// ---------- inc 方法 ----------\n→ Start inc(key) // 增加 key 的計數  \n→ Decision: keyNode 是否包含 key? // 檢查 key 是否已存在  \n    Yes → Step 4: node ← keyNode[key] // 取得 key 所在的 bucket  \n    No  → Step 5: node ← head.next // 新增計數為 1 的 bucket，若已存在則取之  \n        Decision: node.count == 1?  \n            Yes → Step 6: 插入 key 於 node.keySet  \n            No  → Step 7: 創建新 bucket newNode(count=1)  \n                → Step 8: 插入 newNode 於 head 之後  \n                → Step 9: countBucket[1] ← newNode  \n                → Step 10: 插入 key 於 newNode.keySet  \n    → Step 11: keyNode[key] ← node // 更新 key 的指向  \n→ Decision: node.count == node.next.count? // 下一 bucket 是否已是 target count+1  \n    Yes → Step 12: targetNode ← node.next  \n    No  → Step 13: targetNode ← node.next  \n            → Step 14: if node.next == tail 或 node.next.count != node.count+1 then  \n                    → Step 15: 創建新 bucket newNode(count=node.count+1)  \n                    → Step 16: 插入 newNode 於 node.next 前  \n                    → Step 17: countBucket[newNode.count] ← newNode  \n                    → Step 18: targetNode ← newNode  \n→ Step 19: 移除 key 從 node.keySet  \n→ Decision: node.keySet 為空?  \n    Yes → Step 20: 刪除 node 從雙向鏈表  \n            → Step 21: 刪除 countBucket[node.count]  \n→ Step 22: 插入 key 於 targetNode.keySet  \n→ Step 23: keyNode[key] ← targetNode // 更新 key 的指向  \nEnd // inc 執行完畢  \n\n// ---------- dec 方法 ----------\n→ Start dec(key) // 減少 key 的計數  \n→ Step 24: node ← keyNode[key] // 取得 key 所在的 bucket  \n→ Step 25: targetCount ← node.count - 1  \n→ Decision: targetCount == 0? // 是否需要刪除 key  \n    Yes → Step 26: 移除 key 從 node.keySet  \n            → Step 27: 刪除 keyNode[key] // key 從 map 移除  \n            → Decision: node.keySet 為空?  \n                Yes → Step 28: 刪除 node 從雙向鏈表  \n                    → Step 29: 刪除 countBucket[node.count]  \n                No  → Step 30: 結束 dec // 只刪除 key  \n    No → Step 31: targetNode ← node.prev // 下一個較小的計數 bucket  \n            → Decision: node.prev == head 或 node.prev.count != targetCount?  \n                Yes → Step 32: 創建新 bucket newNode(count=targetCount)  \n                    → Step 33: 插入 newNode 於 node.prev 之後  \n                    → Step 34: countBucket[newNode.count] ← newNode  \n                    → Step 35: targetNode ← newNode  \n→ Step 36: 移除 key 從 node.keySet  \n→ Decision: node.keySet 為空?  \n    Yes → Step 37: 刪除 node 從雙向鏈表  \n            → Step 38: 刪除 countBucket[node.count]  \n→ Step 39: 插入 key 於 targetNode.keySet  \n→ Step 40: keyNode[key] ← targetNode // 更新 key 的指向  \nEnd // dec 執行完畢  \n\n// ---------- getMaxKey 方法 ----------\n→ Start getMaxKey()  \n→ Decision: tail.prev == head? // 是否為空結構  \n    Yes → Step 41: Return \"\" // 沒有元素  \n    No  → Step 42: Return 任意一個 tail.prev.keySet 中的 key // 取最大計數 bucket 的 key  \nEnd // getMaxKey 完畢  \n\n// ---------- getMinKey 方法 ----------\n→ Start getMinKey()  \n→ Decision: head.next == tail? // 是否為空結構  \n    Yes → Step 43: Return \"\" // 沒有元素  \n    No  → Step 44: Return 任意一個 head.next.keySet 中的 key // 取最小計數 bucket 的 key  \nEnd // getMinKey 完畢  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef groupAnagrams(strs):\n    \"\"\"\n    組合所有字串，並以已排序字母序列為鍵，將相同字母組合的字串收集在一起。\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = ''.join(sorted(s))          # 將字串排序後作為鍵\n        anagrams[key].append(s)           # 加入相對應的分組\n    return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析 \"strs = [...]\" 這種格式，或直接只給列表\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n\n    # 用 literal_eval 解析為 Python 對象\n    try:\n        strs = ast.literal_eval(list_part)\n    except Exception:\n        strs = []\n\n    # 產生答案並以 JSON 格式輸出，確保使用雙引號\n    result = groupAnagrams(strs)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We should output steps like: Start, Step 1: 初始化哈希表, etc. Use virtual arrows, decisions. Need to use \"→\". Provide step by step, including loops over array, sorting each string, using hash map, adding to list, then output result. The algorithm: Use dictionary mapping sorted string to list of strings. Iterate through strs, sort each, add to map, after loop output map values. Use End. Provide explanation comments in Chinese after //.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: 建立空哈希表 anagramMap // 用來儲存已排序鍵對應的字串列表\n\n→ Step 2: 針對每個字串 word in strs // 遍歷輸入陣列\n\n    → Step 3: 將 word 的字元排序後存為 key // 排序後作為分組鍵\n\n    → Decision: 若 key 已存在於 anagramMap? // 檢查是否已有對應分組\n\n        Yes → Step 4: 把 word 加到 anagramMap[key] 的列表中 // 將同字母組合加入\n\n        No  → Step 5: 建立新列表 [word] 並加入到 anagramMap[key] // 創建新分組\n\nEnd // 程式結束\n\nBut need to output final list: we need Step 6: 取得 anagramMap 的所有值並返回 // 最終結果\n\nAlso need loops and decisions formatting exactly. Provide \"Decision:\" line indent.\n\nLet's produce. Ensure each line has arrow? For decisions, the arrow after Decision: is \"Decision:\". Provide indentation for Yes/No lines with spaces.\n\nAlso ensure each line ends with // explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 建立空哈希表 anagramMap // 用來儲存已排序鍵對應的字串列表\n\n→ Step 2: 針對每個字串 word in strs // 遍歷輸入陣列\n\n    → Step 3: 將 word 的字元排序後存為 key // 排序後作為分組鍵\n\n    → Decision: 若 key 已存在於 anagramMap? // 檢查是否已有對應分組\n\n        Yes → Step 4: 把 word 加到 anagramMap[key] 的列表中 // 將同字母組合加入\n\n        No  → Step 5: 建立新列表 [word] 並加入到 anagramMap[key] // 創建新分組\n\n→ Step 6: 取得 anagramMap 的所有值並返回 // 將所有分組的字串列表組成結果\n\nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import Optional\n\n# -------------------- 虛擬碼說明 --------------------\n# 1. 建立 Node 類別作為雙向鏈表節點，包含 key、value、prev、next\n# 2. LRUCache 使用 dict 將 key 映射到節點，並用雙向鏈表紀錄使用順序\n# 3. head、tail 為雙向鏈表的虛擬頭尾節點，head.next 為最近使用\n# 4. get(key) 若存在則把節點移到 head，否則回傳 -1\n# 5. put(key, value) 若存在則更新並移到 head，否則新增節點並可能踢除最舊節點\n# 6. 移除節點與插入節點的操作皆為 O(1)\n\nclass Node:\n    \"\"\"雙向鏈表節點\"\"\"\n    __slots__ = ('key', 'value', 'prev', 'next')\n    def __init__(self, key: int = 0, value: int = 0):\n        self.key = key\n        self.value = value\n        self.prev: Optional[Node] = None\n        self.next: Optional[Node] = None\n\nclass LRUCache:\n    \"\"\"LRU快取資料結構\"\"\"\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}                     # key -> Node\n        # 初始化雙向鏈表的虛擬頭尾節點\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node: Node) -> None:\n        \"\"\"把 node 從鏈表中移除\"\"\"\n        prev, nxt = node.prev, node.next\n        prev.next = nxt\n        nxt.prev = prev\n\n    def _add_to_head(self, node: Node) -> None:\n        \"\"\"把 node 插入到 head 之後（即最近使用位置）\"\"\"\n        node.next = self.head.next\n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        # 先移除再插入，更新使用順序\n        self._remove(node)\n        self._add_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # 更新值並移到最近使用\n            node = self.cache[key]\n            node.value = value\n            self._remove(node)\n            self._add_to_head(node)\n        else:\n            # 新增節點\n            node = Node(key, value)\n            self.cache[key] = node\n            self._add_to_head(node)\n            # 若超出容量，踢除最舊節點\n            if len(self.cache) > self.capacity:\n                lru = self.tail.prev  # 最舊節點\n                self._remove(lru)\n                del self.cache[lru.key]\n\n# -------------------- main 程式 --------------------\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 讀取輸入的兩個列表（使用 eval 方便解析）\n    ops, args = eval(data)\n    res = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            res.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            res.append(None)\n        elif op == \"get\":\n            res.append(cache.get(arg[0]))\n    print(res)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with comments. Provide structure for LRUCache. We need steps: initialization, get, put, eviction, maintain doubly linked list and hash map. Provide pseudo code.\n\nEnsure each line has \"虛擬碼步驟 [空格] // 解釋/說明\". Use Start, End, Decision. Use arrows →, Yes →, No →.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 LRUCache 類別 // 建立 LRUCache 類別容器\n→ Step 2: 建立 private 成員：capacity, map, head, tail // capacity：容量，map：鍵到節點的哈希表，head/tail：雙向鏈表的虛擬頭尾節點\n→ Decision: 是否需要初始化頭尾節點? // 初始化雙向鏈表的空結構\n    Yes → Step 3: head = Node(0, 0) // head 是虛擬頭節點\n    → Step 4: tail = Node(0, 0) // tail 是虛擬尾節點\n    → Step 5: head.next = tail // 連接頭尾\n    → Step 6: tail.prev = head // 連接尾頭\n→ Step 7: LRUCache(capacity) // 建構子，設定容量並初始化結構\n→ End // 初始化完成\n\nStart // get 方法\n→ Step 8: get(key) // 取得指定 key 的值\n→ Decision: key 是否在 map 中? // 檢查是否存在\n    Yes → Step 9: node = map[key] // 取得節點\n    → Step 10: removeNode(node) // 把節點從鏈表中移除\n    → Step 11: addToHead(node) // 再插入到頭部，標示為最近使用\n    → Step 12: return node.value // 回傳值\n    No  → Step 13: return -1 // key 不存在，回傳 -1\n→ End\n\nStart // put 方法\n→ Step 14: put(key, value) // 插入或更新鍵值\n→ Decision: key 是否在 map 中? // 檢查是否已存在\n    Yes → Step 15: node = map[key] // 取得節點\n    → Step 16: node.value = value // 更新值\n    → Step 17: removeNode(node) // 移除舊位置\n    → Step 18: addToHead(node) // 插入為最近使用\n    No  → Step 19: node = Node(key, value) // 新建節點\n    → Step 20: map[key] = node // 加入哈希表\n    → Step 21: addToHead(node) // 插入頭部\n    → Step 22: if size > capacity? // 檢查是否超過容量\n        Yes → Step 23: lru = tail.prev // 最舊節點\n        → Step 24: removeNode(lru) // 從鏈表移除\n        → Step 25: delete map[lru.key] // 從哈希表刪除\n        No  → // 不需要淘汰\n→ End\n\nStart // removeNode 節點移除\n→ Step 26: removeNode(node) // 將節點從鏈表中移除\n→ Step 27: prev = node.prev\n→ Step 28: next = node.next\n→ Step 29: prev.next = next\n→ Step 30: next.prev = prev\n→ End\n\nStart // addToHead 節點插入頭部\n→ Step 31: addToHead(node) // 把節點插入為最近使用\n→ Step 32: node.next = head.next\n→ Step 33: node.prev = head\n→ Step 34: head.next.prev = node\n→ Step 35: head.next = node\n→ End\n\nStart // Node 資料結構\n→ Step 36: Node(key, value) // 節點包含鍵、值、prev、next\n→ End"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpovcb7how.py\", line 39, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7whwd0fa.py\", line 39, in <module>\n    exec(data, globals())\n  File \"<string>\", line 1\n    matrix = [[-5]], k = 1\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        \"\"\"\n        找到 n x n 有序矩陣中第 k 小的元素\n        使用值範圍二分搜尋，時間 O(n log(max-min))，空間 O(1)\n        \"\"\"\n        n = len(matrix)\n        low = matrix[0][0]           # 最小值\n        high = matrix[n-1][n-1]      # 最大值\n\n        while low < high:\n            mid = (low + high) // 2\n\n            # 計算小於等於 mid 的元素數量\n            count = 0\n            for i in range(n):\n                j = n - 1\n                while j >= 0 and matrix[i][j] > mid:\n                    j -= 1\n                # 這一行左邊 j+1 個元素都 <= mid\n                count += (j + 1)\n\n            if count >= k:\n                high = mid            # 目標元素在左半區間\n            else:\n                low = mid + 1         # 目標元素在右半區間\n\n        return low\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，例如：\n    # matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 直接執行輸入，得到 matrix 與 k 兩個變數\n    exec(data, globals())\n    sol = Solution()\n    result = sol.kthSmallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode step by step for algorithm: find kth smallest in sorted matrix (n x n). Use binary search on value range or min-heap. Memory O(n). Use binary search: low = matrix[0][0], high = matrix[n-1][n-1]. While low < high: mid = (low+high)//2. Count numbers <= mid by scanning each row with binary search or moving pointer. If count >= k: high = mid else low = mid+1. Return low.\n\nProvide pseudocode lines with arrows and comments. Use Start, End, Decision. Use indentation? The example shows indentation. We'll follow.\n\nWe need to output each line with virtual code and comment. Use \"→\" for steps. Use \"Decision:\" for conditions. Provide \"Yes →\", \"No →\" with indented lines.\n\nWe'll produce lines:\n\nStart // start\n→ Step 1: 設定 n = matrix.size // get matrix size\n→ Step 2: low = matrix[0][0] // 最小值\n→ Step 3: high = matrix[n-1][n-1] // 最大值\n→ Decision: low < high? // 進入二分搜尋\n    Yes →\n        → Step 4: mid = (low + high) // 2 // 取中值\n        → Step 5: count = 0 // 统计 <= mid 的数量\n        → Step 6: for i from 0 to n-1: // 每行\n            → Step 7: j = n-1 // 从右上角开始\n            → Decision: j >= 0 and matrix[i][j] > mid? // 若大于 mid\n                Yes →\n                    → Step 8: j = j - 1 // 左移\n                No  →\n                    → Step 9: count = count + (j + 1) // 该行 <= mid 的数量\n                    → Step 10: break // 退出循环\n        → Decision: count >= k? // 判断数量是否足够\n            Yes →\n                → Step 11: high = mid // 缩小上界\n            No  →\n                → Step 12: low = mid + 1 // 缩小下界\n        → Decision: low < high? // 继续循环\n            Yes → // back to Decision: low < high\n            No →\n                → Step 13: result = low // 找到第 k 小元素\n                → End // 结束\nBut the pseudocode needs to be linear lines with arrows and comments. Use indentation maybe with spaces. Keep each line as separate line.\n\nNeed to show \"Yes →\" and \"No →\" lines with indent. Use spaces for indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n = matrix.size() // 取得矩陣的維度 n\n→ Step 2: low = matrix[0][0] // 設定搜尋區間左端為最小值\n→ Step 3: high = matrix[n-1][n-1] // 設定搜尋區間右端為最大值\n→ Decision: low < high? // 若仍有搜尋空間，進入迴圈\n    Yes →\n        → Step 4: mid = (low + high) / 2 // 計算中間值\n        → Step 5: count = 0 // 初始化小於等於 mid 的元素數量\n        → Step 6: for i = 0 to n-1 do // 遍歷每一列\n            → Step 7: j = n-1 // 從右上角開始\n            → Decision: j >= 0 and matrix[i][j] > mid? // 若右邊元素大於 mid\n                Yes →\n                    → Step 8: j = j - 1 // 左移一格\n                No  →\n                    → Step 9: count = count + (j + 1) // 本列左邊 j+1 個元素 <= mid\n                    → Step 10: break // 本列已統計完畢，跳出內層迴圈\n        → Decision: count >= k? // 取得的數量是否足以包含第 k 小\n            Yes →\n                → Step 11: high = mid // 上界縮小到 mid\n            No  →\n                → Step 12: low = mid + 1 // 下界縮小到 mid+1\n        → Decision: low < high? // 檢查是否還有更小的區間\n            Yes → // 回到最外層 Decision\n            No →\n                → Step 13: result = low // low 即為第 k 小元素\n                → End // 程式執行結束"
    },
    {
      "title": "K-diff Pairs in an Array",
      "source_file": "Leetcode/leetcode532.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4jmppt1c.py\", line 29, in <module>\n    k = int(k_str)\n        ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ', 2'"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbnlghz7e.py\", line 29, in <module>\n    k = int(k_str)\n        ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ', 1'"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp342z59fs.py\", line 29, in <module>\n    k = int(k_str)\n        ^^^^^^^^^^\nValueError: invalid literal for int() with base 10: ', 0'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        \"\"\"Return the number of unique k‑diff pairs in nums.\"\"\"\n        if k < 0:\n            return 0\n        freq = Counter(nums)\n        if k == 0:\n            # Count numbers that appear at least twice\n            return sum(v > 1 for v in freq.values())\n        # For k > 0 count each distinct number that has a partner +k\n        return sum((n + k) in freq for n in freq)\n\nif __name__ == \"__main__\":\n    # Read entire input (e.g., \"[3,1,4,1,5], 2\")\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # Find the closing bracket of the list to separate the list from k\n    close_bracket = raw.rfind(']')\n    nums_str = raw[:close_bracket + 1]          # \"[3,1,4,1,5]\"\n    k_str = raw[close_bracket + 1:].strip()    # \", 2\" → \"2\"\n\n    # Evaluate the list and convert k to integer\n    nums = eval(nums_str)\n    k = int(k_str)\n\n    # Compute and print the result\n    solution = Solution()\n    print(solution.findPairs(nums, k))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Need to cover algorithm: count unique k-diff pairs. Use hash map frequency, iterate unique numbers. If k==0, count numbers with freq>1. Else for each num, check num+k exists. Count. Output steps. Provide each line with explanation. Use arrow syntax. Start, End. Include decision structure. Let's craft.\n\nWe'll need steps:\n\nStart\n→ Step: Count frequencies of numbers in nums // Build frequency map\n→ Step: Initialize pairCount = 0 // Counter\n→ Decision: If k < 0? // Negative k not allowed, result 0\n    Yes → Step: Return 0 // Return 0 pairs\n    No  → Decision: If k == 0? // Special case\n        Yes → Step: For each (num, freq) in freqMap\n            → Decision: If freq > 1? // Duplicate exists\n                Yes → Step: pairCount += 1 // Count one pair\n                No  → Step: Continue // Skip\n        No  → Step: For each num in freqMap keys\n            → Decision: If (num + k) exists in freqMap? // Pair exists\n                Yes → Step: pairCount += 1 // Count one unique pair\n                No  → Step: Continue // Skip\n→ Step: Return pairCount // Output result\nEnd\n\nNeed to format each line with `虛擬碼步驟` + space + `// 解釋`. Use arrow arrows. Use indentation for nested decisions.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step: 建立字典 freqMap 以統計每個數字出現次數 // 準備頻率統計\n→ Step: 初始化 pairCount = 0 // 用於計算符合條件的 k-diff 對數\n→ Decision: k < 0? // k 為負值時無合法對\n    Yes → Step: Return 0 // 直接返回 0\n    No  → Decision: k == 0? // 特殊情況，差值為 0\n        Yes → Step: For 每個 (num, freq) 在 freqMap 中\n            → Decision: freq > 1? // 需要至少兩個相同數字\n                Yes → Step: pairCount += 1 // 只算一次唯一對\n                No  → Step: Continue // 無效，跳過\n        No  → Step: For 每個 num 在 freqMap keys 中\n            → Decision: (num + k) 存在於 freqMap? // 找到相差 k 的數字\n                Yes → Step: pairCount += 1 // 計入一個唯一對\n                No  → Step: Continue // 無此對，跳過\n→ Step: Return pairCount // 回傳最終計數\nEnd // 程式執行結束\n\nMake sure each line has the arrow syntax properly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立字典 freqMap 以統計每個數字出現次數 // 準備頻率統計  \n→ Step: 初始化 pairCount = 0 // 用於計算符合條件的 k‑diff 對數  \n→ Decision: k < 0? // k 為負值時無合法對  \n  Yes → Step: Return 0 // 直接返回 0  \n  No  → Decision: k == 0? // 特殊情況，差值為 0  \n   Yes → Step: For 每個 (num, freq) 在 freqMap 中  \n    → Decision: freq > 1? // 需要至少兩個相同數字  \n     Yes → Step: pairCount += 1 // 只算一次唯一對  \n     No  → Step: Continue // 無效，跳過  \n   No  → Step: For 每個 num 在 freqMap keys 中  \n    → Decision: (num + k) 存在於 freqMap? // 找到相差 k 的數字  \n     Yes → Step: pairCount += 1 // 計入一個唯一對  \n     No  → Step: Continue // 無此對，跳過  \n→ Step: Return pairCount // 回傳最終計數  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy_bnkl_q.py\", line 27, in <module>\n    main()\n  File \"/tmp/tmpy_bnkl_q.py\", line 22, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmpy_bnkl_q.py\", line 5, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'rand10'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0blc9jey.py\", line 27, in <module>\n    main()\n  File \"/tmp/tmp0blc9jey.py\", line 22, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmp0blc9jey.py\", line 5, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'rand10'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnhxomh5d.py\", line 27, in <module>\n    main()\n  File \"/tmp/tmpnhxomh5d.py\", line 22, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmpnhxomh5d.py\", line 5, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'rand10'?"
        }
      ],
      "generated_code": "# 定義 rand10()，只允許使用已知的 rand7() API\ndef rand10():\n    while True:\n        # 使用兩次 rand7() 產生 1~49 的均勻分佈\n        num = (rand7() - 1) * 7 + rand7()  # 1~49\n        # 只保留 1~40 的結果，才能均勻映射到 1~10\n        if num <= 40:\n            return 1 + (num - 1) % 10\n\ndef main():\n    import sys\n    import re\n\n    # 從標準輸入讀取 n 的值，格式為 'n = <number>'\n    data = sys.stdin.read()\n    match = re.search(r'n\\s*=\\s*(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    # 呼叫 rand10() n 次，收集結果\n    results = [rand10() for _ in range(n)]\n    # 輸出結果到標準輸出\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for generating uniform 1-10 using rand7. Classic solution: use two rand7 calls to get range 1-49. If >40 discard, else map to 1-10. Steps: Generate a = rand7(); b=rand7(); x = (a-1)*7 + b; if x > 40 → reject loop; else return (x-1)%10 +1. Also explain loop etc. Provide each line with explanation. Use Start, End, Decision.\n\nWe'll produce multiple lines: Start, Step to get a, Step to get b, Step to compute x, Decision: if x > 40? Yes: repeat; No: compute result. We'll need a loop representation. Could use Decision: while x > 40? then go to Step1. Provide arrow logic.\n\nLet's craft.\n\nUse indentation maybe but not necessary. Use arrow symbol. Use \"→\" for steps.\n\nWe must not output actual code, only virtual code with explanations. Ensure each line has explanation comment. Let's craft:\n\nStart // 程式開始\n\n→ Step 1: Call rand7() → a // 取得第一個隨機數\n\n→ Step 2: Call rand7() → b // 取得第二個隨機數\n\n→ Step 3: Compute x = (a - 1) * 7 + b // 將兩個 1-7 轉為 1-49 的均勻分佈\n\n→ Decision: 如果 x > 40? // 超過 40 的值會導致不均勻，需要重新產生\n\n    Yes → Step 1 // 回到 Step 1 重新取得 a\n\n    No  → Step 4: Return (x - 1) % 10 + 1 // 取得 1-10 的均勻結果\n\nEnd // 程式結束\n\nBut need to make sure the loop is clear: we can label Step 1 as \"Repeat\". Provide the loop representation.\n\nAlso we must not call any other API.\n\nOk. Provide virtual code accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Call rand7() → a // 取得第一個 1~7 的隨機數\n→ Step 2: Call rand7() → b // 取得第二個 1~7 的隨機數\n→ Step 3: Compute x = (a - 1) * 7 + b // 轉換為 1~49 的均勻分佈\n→ Decision: 如果 x > 40? // 40 以下才可映射為 1~10，否則重新產生\n    Yes → Step 1 // 回到 Step 1 重新呼叫 rand7() 取得 a\n    No  → Step 4: Return (x - 1) % 10 + 1 // 將 1~40 映射為 1~10 並輸出\nEnd // 程式結束執行"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # skip numbers with leading zero\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Extract the numeric string and target value using regular expressions\n    num_match = re.search(r'num\\s*=\\s*\"(\\d+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not num_match or not target_match:\n        print(\"[]\")\n        sys.exit(0)\n\n    num_str = num_match.group(1)\n    target_val = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num_str, target_val)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for algorithm that finds all expressions by inserting + - * between digits of num string so that expression evaluates to target. No leading zeros in operands. Classic LeetCode 282. Provide virtual code line by line with explanation. Must use arrow syntax. Include Start, End, Decision. We'll include recursive backtracking.\n\nWe need to output in Chinese, using Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use arrow → and Decision: If conditions.\n\nLet's produce steps.\n\nStart\n→ Step 1: 初始化結果列表 results // 用於儲存符合條件的表達式\n→ Step 2: 定義遞歸函式 DFS(位置, 表達式, 累計值, 前一項值) // 位置為已處理索引, 表達式為目前拼接的字串, 累計值為目前算式結果, 前一項值用於乘法計算\n→ Decision: 位置是否等於 num 长度? // 判斷是否已遍歷完整字串\n    Yes → Decision: 累計值等於目標? // 檢查是否符合目標\n        Yes → Step 3: 把表達式加入 results // 加入符合條件的表達式\n        No → Step 4: 返回 // 不符合，結束此路徑\n    No → Decision: 循環 i 從位置到 num長度-1 // 選取子字串作為下一個操作數\n        Yes → Step 5: 取子字串 sub = num[位置:i+1] // 取子字串\n        → Decision: sub 是否以 '0' 開頭且長度 >1? // 檢查前導零\n            Yes → Step 6: 跳過此子字串 // 無效，跳到下一個 i\n            No → Step 7: 轉換 num_val = 數值(sub) // 將子字串轉為數字\n        → Decision: 位置是否為 0? // 判斷是否為第一個操作數\n            Yes → Step 8: DFS(i+1, sub, num_val, num_val) // 直接以此為初始值\n            No → Step 9: Decision: '+'\n                Yes → Step 10: DFS(i+1, 表達式 + '+' + sub, 累計值 + num_val, num_val) // 加號\n                No → Step 11: Decision: '-'\n                    Yes → Step 12: DFS(i+1, 表達式 + '-' + sub, 累計值 - num_val, -num_val) // 減號\n                    No → Step 13: Decision: '*'\n                        Yes → Step 14: DFS(i+1, 表達式 + '*' + sub, 累計值 - 前一項值 + 前一項值 * num_val, 前一項值 * num_val) // 乘號\nEnd\n\nWe need to format each line with arrow as specified.\n\nWe need to ensure each line includes '虛擬碼步驟' plus comment.\n\nLet's produce lines.\n\nWe need to maintain indentation maybe? Use indentation like:\n\nStart // ...\n→ Step 1: ... // ...\n→ Step 2: ... // ...\n→ Decision: ... // ...\n    Yes → ...\n    No → ...\n\nBut each line should be one line. We can include indentation characters like tab? But we need to preserve clarity.\n\nWe can use spaces before each line to indicate nested decisions.\n\nThe example shows indentation for nested lines: e.g., after Decision: If, they indent Yes → lines. We'll follow same.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 results // 用於儲存符合條件的表達式\n→ Step 2: 定義遞歸函式 DFS(位置, 表達式, 累計值, 前一項值) // 位置為已處理索引, 表達式為目前拼接的字串, 累計值為目前算式結果, 前一項值用於乘法計算\n→ Decision: 位置是否等於 num 長度? // 判斷是否已遍歷完整字串\n    Yes → Decision: 累計值等於目標? // 檢查是否符合目標\n        Yes → Step 3: 把表達式加入 results // 加入符合條件的表達式\n        No  → Step 4: 返回 // 不符合，結束此路徑\n    No  → Decision: 循環 i 從位置到 num長度-1 // 選取子字串作為下一個操作數\n        Yes → Step 5: 取子字串 sub = num[位置:i+1] // 取子字串\n        → Decision: sub 是否以 '0' 開頭且長度 >1? // 檢查前導零\n            Yes → Step 6: 跳過此子字串 // 無效，跳到下一個 i\n            No  → Step 7: 轉換 num_val = 數值(sub) // 將子字串轉為數字\n        → Decision: 位置是否為 0? // 判斷是否為第一個操作數\n            Yes → Step 8: DFS(i+1, sub, num_val, num_val) // 直接以此為初始值\n            No  → Decision: '+'\n                Yes → Step 10: DFS(i+1, 表達式 + '+' + sub, 累計值 + num_val, num_val) // 加號\n                No  → Decision: '-'\n                    Yes → Step 12: DFS(i+1, 表達式 + '-' + sub, 累計值 - num_val, -num_val) // 減號\n                    No  → Decision: '*'\n                        Yes → Step 14: DFS(i+1, 表達式 + '*' + sub, 累計值 - 前一項值 + 前一項值 * num_val, 前一項值 * num_val) // 乘號\nEnd // 程式執行結束\n\nWe must also include Step 9 maybe? But we skip since we embed in No branch.\n\nWe need to ensure each line has \"虛擬碼步驟\" maybe replaced by the actual step expression. That's fine.\n\nMake sure to include \"→\" arrow before steps, \"Decision:\" lines.\n\nMake sure each line ends with comment after //.\n\nWe need to output exactly as required.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果列表 results // 用於儲存符合條件的表達式  \n→ Step 2: 定義遞歸函式 DFS(位置, 表達式, 累計值, 前一項值) // 位置為已處理索引, 表達式為目前拼接的字串, 累計值為目前算式結果, 前一項值用於乘法計算  \n→ Decision: 位置是否等於 num 長度? // 判斷是否已遍歷完整字串  \n Yes → Decision: 累計值等於目標? // 檢查是否符合目標  \n  Yes → Step 3: 把表達式加入 results // 加入符合條件的表達式  \n  No  → Step 4: 返回 // 不符合，結束此路徑  \n No  → Decision: 循環 i 從位置到 num長度-1 // 選取子字串作為下一個操作數  \n  Yes → Step 5: 取子字串 sub = num[位置:i+1] // 取子字串  \n  → Decision: sub 是否以 '0' 開頭且長度 >1? // 檢查前導零  \n   Yes → Step 6: 跳過此子字串 // 無效，跳到下一個 i  \n   No  → Step 7: 轉換 num_val = 數值(sub) // 將子字串轉為數字  \n  → Decision: 位置是否為 0? // 判斷是否為第一個操作數  \n   Yes → Step 8: DFS(i+1, sub, num_val, num_val) // 直接以此為初始值  \n   No  → Decision: '+'  \n    Yes → Step 10: DFS(i+1, 表達式 + '+' + sub, 累計值 + num_val, num_val) // 加號  \n    No  → Decision: '-'  \n     Yes → Step 12: DFS(i+1, 表達式 + '-' + sub, 累計值 - num_val, -num_val) // 減號  \n     No  → Decision: '*'  \n      Yes → Step 14: DFS(i+1, 表達式 + '*' + sub, 累計值 - 前一項值 + 前一項值 * num_val, 前一項值 * num_val) // 乘號  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef wiggle_sort(nums):\n    \"\"\"\n    Rearranges the list `nums` in place so that\n    nums[0] < nums[1] > nums[2] < nums[3] > ...\n    \"\"\"\n    n = len(nums)\n    for i in range(1, n):\n        if i % 2 == 1:          # odd index, should be greater than previous\n            if nums[i - 1] >= nums[i]:\n                nums[i - 1], nums[i] = nums[i], nums[i - 1]\n        else:                   # even index, should be less than previous\n            if nums[i - 1] <= nums[i]:\n                nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\ndef parse_input(data):\n    \"\"\"\n    Parse the input string to extract the integer list.\n    Handles inputs like:\n      - 'nums = [1,5,1,1,6,4]'\n      - '[1,5,1,1,6,4]'\n      - '1 5 1 1 6 4'\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # If the input contains a '[' and ']', extract the list slice\n    if '[' in data and ']' in data:\n        start = data.index('[')\n        end = data.rindex(']')\n        sub = data[start:end+1]\n        try:\n            return ast.literal_eval(sub)\n        except Exception:\n            pass  # fall back to space-separated parsing\n\n    # Fallback: split by whitespace and convert to int\n    return [int(x) for x in data.split()]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    wiggle_sort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for rearranging array into wiggle order: nums[0] < nums[1] > nums[2] < nums[3] ... . The typical solution is to iterate and swap when pattern violated. Use index i from 1 to n-1: if i%2==1 (odd index) and nums[i-1] >= nums[i] then swap; if i%2==0 (even) and nums[i-1] <= nums[i] then swap.\n\nWe need to produce step-by-step virtual code. Each line includes \"虛擬碼步驟\" then space then comment. Use arrows, decisions, etc. Provide Start and End.\n\nWe should include input reading, maybe assume array provided. The question: \"You may assume the input array always has a valid answer.\" So just reorder. Provide steps: read array, for loop, decision inside.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums // 從輸入取得整數序列\n→ Step 2: 取得陣列長度 n // 紀錄元素個數\n→ Step 3: 設定 i = 1 // 從第二個元素開始檢查\n→ Decision: i < n? // 是否還有元素需要檢查\n    Yes → Step 4: 判斷 i 為奇數？ // 確定當前索引為奇數或偶數\n        Yes → Decision: nums[i-1] >= nums[i]? // 奇數位置需大於前一個\n            Yes → Step 5: 交換 nums[i-1] 與 nums[i] // 若不符合，交換\n            No  → // 何不做，條件已滿\n        No  → Decision: nums[i-1] <= nums[i]? // 偶數位置需小於前一個\n            Yes → Step 6: 交換 nums[i-1] 與 nums[i] // 若不符合，交換\n            No  → // 何不做，條件已滿\n    No  → // 已完成所有檢查\n→ Step 7: 輸出已重排的 nums // 顯示最終結果\nEnd // 程式執行結束\n\nWe need to keep each line with a single step or decision. Use arrows and indentation. Provide explanation for each line. Ensure \"→\" used before steps and decisions. Use \"Decision:\" for decision nodes.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums // 從輸入取得整數序列  \n→ Step 2: 取得陣列長度 n // 紀錄元素個數  \n→ Step 3: 設定 i = 1 // 從第二個元素開始檢查  \n→ Decision: i < n? // 是否還有元素需要檢查  \n  Yes → Step 4: 判斷 i 為奇數？ // 確定當前索引是奇數或偶數  \n   Yes → Decision: nums[i-1] >= nums[i]? // 奇數位置需大於前一個  \n    Yes → Step 5: 交換 nums[i-1] 與 nums[i] // 若不符合，交換  \n    No → // 條件已滿，保持不變  \n   No → Decision: nums[i-1] <= nums[i]? // 偶數位置需小於前一個  \n    Yes → Step 6: 交換 nums[i-1] 與 nums[i] // 若不符合，交換  \n    No → // 條件已滿，保持不變  \n  No → // 已完成所有檢查  \n→ Step 7: 輸出已重排的 nums // 顯示最終結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0czqtxws.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmp0czqtxws.py\", line 38, in main\n    args = ast.literal_eval(matches[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()  # 主佇列\n        self.q2 = deque()  # 暫存佇列\n\n    def push(self, x):\n        # 把新元素塞進暫存佇列\n        self.q2.append(x)\n        # 把主佇列的所有元素搬到暫存佇列，保持 LIFO 順序\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        # 交換佇列，讓 q1 再次成為主佇列\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self):\n        # 移除並回傳最前面的元素\n        return self.q1.popleft() if self.q1 else None\n\n    def top(self):\n        # 取得最前面的元素但不移除\n        return self.q1[0] if self.q1 else None\n\n    def empty(self):\n        # 判斷是否為空\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中找出兩個列表\n    matches = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    if len(matches) >= 2:\n        ops = ast.literal_eval(matches[0])\n        args = ast.literal_eval(matches[1])\n    else:\n        ops, args = [], []\n\n    stack = MyStack()\n    result = []\n\n    for op, arg in zip(ops, args):\n        if op == 'MyStack':\n            result.append(None)\n        elif op == 'push':\n            stack.push(arg[0])\n            result.append(None)\n        elif op == 'pop':\n            result.append(stack.pop())\n        elif op == 'top':\n            result.append(stack.top())\n        elif op == 'empty':\n            result.append(stack.empty())\n\n    # 將結果轉成 LeetCode 風格的字串輸出\n    out = '['\n    for i, val in enumerate(result):\n        if val is None:\n            out += 'null'\n        elif isinstance(val, bool):\n            out += 'true' if val else 'false'\n        else:\n            out += str(val)\n        if i != len(result) - 1:\n            out += ', '\n    out += ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for implementing stack with two queues. Provide explanation. Must use Start, End, Decision, etc. Each line: 虛擬碼步驟 + space + // 解釋.\n\nWe need to detail class initialization, push, pop, top, empty. Also queue operations: enqueue to back, dequeue from front, peek front, size, isEmpty. We'll use queue1 as main queue. For push, we enqueue to q2 then move all from q1 to q2 then swap references. Or we can use single queue but requirement two queues. We'll use approach: push: enqueue to q2, then while q1 not empty, enqueue q1.front to q2, dequeue q1. then swap q1 and q2.\n\nPop: dequeue from q1.\n\nTop: peek q1.front.\n\nEmpty: check q1.isEmpty.\n\nWe must express virtual steps. Provide each function step lines.\n\nLet's structure: Start -> Initialize queues -> // etc.\n\nWe need to include decisions for conditions (empty checks). Provide pseudo.\n\nLet's produce.\n\nBe careful: We need to produce each step line, with explanation. Use arrow → etc.\n\nWe'll write:\n\nStart // 程式開始執行\n→ Class MyStack // 宣告 MyStack 類別\n→  Constructor: q1 ← new Queue // 初始化第一個佇列\n→  Constructor: q2 ← new Queue // 初始化第二個佇列\nEnd // 只做初始化\n\nBut we need separate lines for each method? The spec: \"Implement the MyStack class\" Provide steps of class implementation. Let's produce a full flow for the whole class definition, including methods.\n\nMaybe:\n\nStart // 程式開始執行\n→ Define MyStack // 宣告 MyStack 類別\n    → Member: queue1 // 第一個佇列\n    → Member: queue2 // 第二個佇列\n    → Constructor: 初始化 queue1、queue2 // 建立兩個佇列\n    → Method push(x):\n        → Enqueue x into queue2 // 把新元素塞進第二個佇列\n        → Decision: queue1 is not empty? // 檢查第一個佇列是否還有元素\n            Yes → While queue1 not empty: Enqueue front of queue1 into queue2; Dequeue from queue1 // 把 queue1 的所有元素轉移到 queue2\n            No  → // queue1 為空，直接完成\n        → Swap queue1 和 queue2 // 讓 queue1 再次成為主佇列，queue2 清空\n    → Method pop():\n        → Decision: queue1 is empty? // 檢查是否有元素可彈出\n            Yes → Return null // 或適當錯誤處理\n            No  → Dequeue from queue1 // 移除並返回最前面的元素\n    → Method top():\n        → Decision: queue1 is empty? // 檢查是否有元素\n            Yes → Return null\n            No  → Peek front of queue1 // 取得最前面的元素但不移除\n    → Method empty():\n        → Return queue1 is empty // 判斷 queue1 是否為空\n\nBut we need to follow format: each line with arrow or decision, and explanation. Use indentation? We can use indentation to represent nested structure. Use tab or spaces.\n\nWe need to maintain each line separated.\n\nLet's produce each step line. For decisions we need Yes → ... No → ... So we need two lines for each branch.\n\nWe should maintain indent using 4 spaces maybe.\n\nLet's construct:\n\nStart // 程式開始執行\n→ Define MyStack // 宣告 MyStack 類別\n    → Member: queue1 // 第一個佇列\n    → Member: queue2 // 第二個佇列\n    → Constructor: 初始化 queue1、queue2 // 建立兩個佇列\n    → Method push(x):\n        → Enqueue x into queue2 // 把新元素塞進第二個佇列\n        → Decision: queue1 is not empty? // 檢查 queue1 是否有元素\n            Yes → While queue1 not empty:\n                → Enqueue front of queue1 into queue2 // 把 queue1 的前端元素移到 queue2\n                → Dequeue from queue1 // 從 queue1 刪除該元素\n            No  → // queue1 為空，直接跳過\n        → Swap queue1 and queue2 // 讓 queue1 成為主佇列，queue2 清空\n    → Method pop():\n        → Decision: queue1 is empty? // 檢查是否有元素可彈出\n            Yes → Return null // 沒有元素可彈出\n            No  → Dequeue from queue1 // 移除並返回最前面的元素\n    → Method top():\n        → Decision: queue1 is empty? // 檢查是否有元素\n            Yes → Return null // 沒有元素可取\n            No  → Peek front of queue1 // 取得最前面的元素但不移除\n    → Method empty():\n        → Return queue1 is empty // 判斷 stack 是否為空\nEnd // 程式結束\n\nBut need each line with arrow and explanation. The above has multi-level indentation but each line uses arrow. We need to produce exactly as format: e.g., \"→ Decision: queue1 is not empty? // ...\" and for branches we need \"Yes → ...\", \"No → ...\" lines.\n\nLet's write step by step.\n\nMake sure each line ends with // explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Define MyStack // 宣告 MyStack 類別\n    → Member: queue1 // 第一個佇列\n    → Member: queue2 // 第二個佇列\n    → Constructor: 初始化 queue1、queue2 // 建立兩個佇列\n    → Method push(x):\n        → Enqueue x into queue2 // 把新元素塞進第二個佇列\n        → Decision: queue1 is not empty? // 檢查 queue1 是否有元素\n            Yes → While queue1 not empty:\n                → Enqueue front of queue1 into queue2 // 把 queue1 的前端元素移到 queue2\n                → Dequeue from queue1 // 從 queue1 刪除該元素\n            No  → // queue1 為空，直接跳過\n        → Swap queue1 and queue2 // 讓 queue1 成為主佇列，queue2 清空\n    → Method pop():\n        → Decision: queue1 is empty? // 檢查是否有元素可彈出\n            Yes → Return null // 沒有元素可彈出\n            No  → Dequeue from queue1 // 移除並返回最前面的元素\n    → Method top():\n        → Decision: queue1 is empty? // 檢查是否有元素\n            Yes → Return null // 沒有元素可取\n            No  → Peek front of queue1 // 取得最前面的元素但不移除\n    → Method empty():\n        → Return queue1 is empty // 判斷 stack 是否為空\nEnd // 程式結束\n\nBut we need to ensure each line has arrow at start except Start and End maybe. Format expects Start and End lines with no arrow? In sample, Start line had \"Start // 程式開始執行\" not arrow. So we keep same.\n\nHowever for nested lines, we can indent with spaces but maintain arrow. For example:\n\n→ Method push(x):\n    → Enqueue x into queue2 ...\n\nThus each line begins with arrow except Start and End. Good.\n\nWe need to ensure we follow \"Decision:\" lines with \"Yes →\" and \"No →\". The sample shows \"Decision: 如果數字大於 0?\" then \"Yes → Step 2: ...\" \"No → Decision: ...\".\n\nOur \"Decision: queue1 is not empty?\" should be followed by \"Yes → ...\" \"No → ...\" lines. But the \"While\" part: we used \"Yes → While queue1 not empty:\" then inside that we have two lines starting with arrow. But we need to indent properly. Use 8 spaces maybe. Let's produce.\n\nSimplify: For loop we can treat as part of Yes branch. We may just include \"Yes → While queue1 not empty:\" then lines.\n\nAlternatively, we could just describe the loop as two steps inside Yes branch. We'll show each line.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define MyStack // 宣告 MyStack 類別  \n  → Member: queue1 // 第一個佇列  \n  → Member: queue2 // 第二個佇列  \n  → Constructor: 初始化 queue1、queue2 // 建立兩個佇列  \n  → Method push(x): // 推入新元素  \n    → Enqueue x into queue2 // 把新元素塞進第二個佇列  \n    → Decision: queue1 is not empty? // 檢查 queue1 是否有元素  \n     Yes → While queue1 not empty: // 若 queue1 仍有元素  \n        → Enqueue front of queue1 into queue2 // 把 queue1 的前端元素移到 queue2  \n        → Dequeue from queue1 // 從 queue1 刪除該元素  \n     No  → // queue1 為空，直接跳過  \n    → Swap queue1 and queue2 // 讓 queue1 成為主佇列，queue2 清空  \n  → Method pop(): // 移除並回傳頂端元素  \n    → Decision: queue1 is empty? // 檢查是否有元素可彈出  \n     Yes → Return null // 沒有元素可彈出  \n     No  → Dequeue from queue1 // 移除並返回最前面的元素  \n  → Method top(): // 取得頂端元素但不移除  \n    → Decision: queue1 is empty? // 檢查是否有元素  \n     Yes → Return null // 沒有元素可取  \n     No  → Peek front of queue1 // 取得最前面的元素但不移除  \n  → Method empty(): // 判斷 stack 是否為空  \n    → Return queue1 is empty // 若 queue1 為空即 stack 為空  \nEnd // 程式結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        使用 Kahn 的拓扑排序演算法。\n        \"\"\"\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填寫前置課程關係\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 先把所有入度為 0 的節點放入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # 拓撲排序主迴圈\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若順序長度等於課程總數，代表可完成；否則回傳空清單\n        return order if len(order) == numCourses else []\n\ndef parse_input(text: str):\n    \"\"\"\n    從輸入文字中抽取 numCourses 與 prerequisites。\n    \"\"\"\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', text)\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*?\\]\\])', text, re.S)\n    if not num_match or not pre_match:\n        raise ValueError('輸入格式錯誤')\n    num_courses = int(num_match.group(1))\n    prerequisites = ast.literal_eval(pre_match.group(1))\n    return num_courses, prerequisites\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 解析輸入\n    try:\n        n, prereqs = parse_input(raw_input)\n    except Exception as e:\n        print([], end='')\n        sys.exit(0)\n\n    # 取得排課順序\n    sol = Solution()\n    result = sol.findOrder(n, prereqs)\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudo code for topological sort (Kahn's algorithm or DFS). Provide each line with // explanation. Use arrows. Provide Start, Decision, etc. Use \"Start // 程式開始執行\". Need to produce step-by-step pseudo code. We'll produce Kahn's algorithm. Steps: Build adjacency list, indegree array, queue of zero indegree, while queue not empty, pop, add to order, reduce indegree of neighbors, if indegree zero push. After loop, if order length equals numCourses return order else empty.\n\nWe'll need to show loops, decisions, etc. Provide pseudo-code lines with explanation.\n\nMake sure each line has \"虛擬碼步驟\" + \" // 解釋\". Use arrow \"→\" before step lines.\n\nOk. Let's craft.\n\nUse \"Start\". Then build adjacency list. Then indegree array. Then for each prerequisite, update adjacency and indegree. Then initialize queue with zero indegree nodes. Then while queue not empty: pop, add to order, for each neighbor: decrement indegree, if indegree zero push. After loop: Decision: order length == numCourses? Yes: return order; No: return empty array. End.\n\nMake sure to include \"Decision:\" lines for loops and if conditions. For loops we might use \"While\". Provide \"Decision: Queue 为空?\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的鄰接表 adj[0…numCourses-1] // 建立每門課的後續課程列表  \n→ Step 2: 初始化 indegree[0…numCourses-1] 為 0 // 記錄每門課前置課程的數量  \n→ Decision: 遍歷 prerequisites? // 逐一處理所有前置關係  \n    Yes → Step 3: 取出 pair [a, b] // a 需要先修 b  \n    → Step 4: adj[b].append(a) // 在 b 的鄰接表加入 a  \n    → Step 5: indegree[a] += 1 // a 的前置課程數量加一  \n    No → End of prerequisites loop  \n→ Step 6: 建立 queue 為空，order 為空列表 // queue 用於儲存 indegree 為 0 的課程  \n→ Decision: 遍歷 0…numCourses-1? // 找出所有 indegree 為 0 的課程  \n    Yes → Step 7: 如果 indegree[i] == 0  \n        → Step 8: queue.enqueue(i) // 把無前置課程的課程加入 queue  \n    No → End of courses loop  \n→ Decision: queue 非空? // 開始 Kahn 的拓撲排序  \n    Yes → Step 9: course = queue.dequeue() // 取出一門課  \n    → Step 10: order.append(course) // 加入完成順序  \n    → Decision: adj[course] 非空? // 處理所有後續課程  \n        Yes → Step 11: 對於每個 neighbour in adj[course]  \n            → Step 12: indegree[neighbour] -= 1 // 減少後續課程的前置數量  \n            → Decision: indegree[neighbour] == 0?  \n                Yes → Step 13: queue.enqueue(neighbour) // 新的零前置課程加入 queue  \n                No → 什麼也不做  \n        No → 什麼也不做  \n    → 返回到 Decision: queue 非空?  \n    No → End of while loop  \n→ Decision: order.length == numCourses? // 檢查是否所有課程都已排序  \n    Yes → Step 14: return order // 有效順序，所有課程可完成  \n    No → Step 15: return [] // 無法完成，存在循環依賴  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.19619981000049505,0.25313862306992563],[0.48975747392939273,-0.6539130720262957],[0.13782335390372816,-0.7337118515732746]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.19619981000049505, 0.25313862306992563], [0.48975747392939273, -0.6539130720262957], [0.13782335390372816, -0.7337118515732746]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport math\nimport random\n\nclass Solution:\n    \"\"\"\n    產生圓內均勻分布隨機點的類別。\n    \"\"\"\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        隨機產生一個在圓內的點。\n        透過極座標：r = R * sqrt(U)，θ = 2π * V\n        其中 U, V 為 0~1 的均勻隨機數。\n        \"\"\"\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析方法呼叫序列與參數，\n    執行對應方法，並輸出結果列表。\n    \"\"\"\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    commands = ast.literal_eval(data[0])\n    params = ast.literal_eval(data[1])\n\n    solution = None\n    results = []\n\n    for cmd, param in zip(commands, params):\n        if cmd == \"Solution\":\n            # 初始化物件\n            solution = Solution(*param)\n            results.append(None)\n        elif cmd == \"randPoint\":\n            # 呼叫 randPoint，並將結果加入\n            results.append(solution.randPoint())\n        else:\n            # 若遇到未知方法，視為 None\n            results.append(None)\n\n    # 使用 json.dumps 以便將 None 轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: generate random point inside circle uniformly. Standard approach: use polar coordinates: random angle uniform 0 to 2π, random radius sqrt(random)*R. Then compute x = x_center + r*cosθ, y = y_center + r*sinθ.\n\nImplement Solution class with constructor storing radius and center. randPoint uses rand() or random functions. Virtual code step by step.\n\nWe must output in Chinese comments, each line with // explanation. Use virtual arrows.\n\nLet's draft. Include start, class initialization, constructor, method randPoint, random generation, return array.\n\nWe need to be careful about random functions. Use Random() for Java style, but we keep generic.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義類 Solution // 建立解決方案類\n→ Step 2: 成員變數 radius, x_center, y_center // 儲存圓半徑與中心座標\n→ Decision: 是否需要初始化? // 檢查構造函式是否已呼叫\n    Yes → Step 3: Solution(radius, x_center, y_center) // 設定初始值\n    No  → End\n\nBetter to structure.\n\nActually we can design simpler: Start, define class, constructor, randPoint. Inside randPoint: generate u1, u2 random uniform [0,1). Compute r = sqrt(u1)*radius. θ = 2π*u2. Compute x = x_center + r*cosθ, y = y_center + r*sinθ. Return [x, y].\n\nLet's produce.\n\nWe need to use arrow for decision inside method? We can use decisions for random generation? Not necessary.\n\nOk produce step by step.\n\nRemember each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define Class Solution // 建立解決方案類  \n→   Declare Member Variable radius // 圓半徑  \n→   Declare Member Variable x_center // 圓心 X 座標  \n→   Declare Member Variable y_center // 圓心 Y 座標  \n\n→ Constructor Solution(radius, x_center, y_center) // 初始化物件  \n→     Set this.radius = radius // 儲存半徑  \n→     Set this.x_center = x_center // 儲存 X 座標  \n→     Set this.y_center = y_center // 儲存 Y 座標  \n\n→ Method randPoint() // 產生隨機點  \n→   Generate u1 ← Random(0, 1) // 隨機數 0~1，用於半徑  \n→   Generate u2 ← Random(0, 1) // 隨機數 0~1，用於角度  \n→   Compute r ← sqrt(u1) * this.radius // 轉換半徑，保證均勻分佈  \n→   Compute theta ← 2π * u2 // 隨機角度  \n→   Compute x ← this.x_center + r * cos(theta) // X 座標  \n→   Compute y ← this.y_center + r * sin(theta) // Y 座標  \n→   Return [x, y] // 回傳隨機點座標  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 3, 0, 4, _, _, _]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract the list of numbers\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if not nums_match:\n        nums = []\n    else:\n        nums_str = nums_match.group(1).strip()\n        nums = list(map(int, nums_str.split(','))) if nums_str else []\n\n    # Extract the value to remove\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    val = int(val_match.group(1)) if val_match else 0\n\n    original_len = len(nums)\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # Prepare the representation of the array after removal\n    arr_repr = []\n    for i in range(original_len):\n        if i < k:\n            arr_repr.append(str(nums[i]))\n        else:\n            arr_repr.append('_')\n    print(f\"{k}, nums = [{', '.join(arr_repr)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps. For this problem: remove elements in place, return new length. Use two pointers: slow and fast. We iterate fast over array, if nums[fast] != val, set nums[slow]=nums[fast], increment slow. Finally return slow. Also sort first k elements? The solution does not require sort, but judge will sort. But we just produce algorithm.\n\nLet's produce steps with Start, End, Decision. We'll describe steps: initialize slow=0, iterate fast from 0 to len-1, if nums[fast] != val then assign and increment slow. After loop, return slow.\n\nWe'll output each line with explanation. Ensure format: \"虛擬碼步驟 // 解釋\". Use arrow arrows. For loops: \"→ Step: for fast = 0 to length-1\" etc. Use Decision for condition. Provide final.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 slow = 0 // 用於指向結果陣列的寫入位置  \n→ Step 2: for fast = 0 to nums.length - 1 // 逐個檢查每個元素  \n  Decision: nums[fast] 是否不等於 val? // 判斷是否保留此元素  \n   Yes → Step 3: nums[slow] = nums[fast] // 把非 val 的元素寫入 slow 指向的位置"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列，並以 copy 方式避免被修改\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的 copy，確保不被外部改動\n        return self.original[:]\n\n    def shuffle(self):\n        # 使用 Fisher-Yates 洗牌演算法，隨機排列\n        arr = self.original[:]\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            if j != i:\n                arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援兩種格式：\n    1. 兩行：第一行為操作列表，第二行為對應參數列表\n    2. 一行：操作列表與參數列表以逗號分隔\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) == 1:\n        # 找到第一個 ']'，並在其後尋找第一個逗號，作為分隔點\n        end_ops = lines[0].find(']') + 1\n        comma = lines[0].find(',', end_ops)\n        ops_str = lines[0][:comma]\n        args_str = lines[0][comma + 1:]\n    else:\n        ops_str, args_str = lines[0], lines[1]\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])\n            results.append(None)\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n\n    # 使用 json.dumps 讓 None 轉成 null，符合範例輸出格式\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: typical Fisher-Yates shuffle. The virtual code should show Start, Step, Decision, etc. Provide each line with explanation. No actual code, just steps. Should include initialization storing original copy, reset returns original, shuffle does shuffle on a copy? Typically shuffle returns new array random each call.\n\nLet's design pseudo: \nStart\n→ Step 1: Store original array nums in self.original // preserve\n→ Step 2: Create working copy array = copy of original // for shuffling\n→ Step 3: For i from len-1 down to 1: // Fisher-Yates\n    → Step 4: Randomly choose j from 0..i // random index\n    → Decision: j != i? // if not same\n        Yes → Swap array[i] with array[j] // swap\n        No  → No action // if same skip\n→ Step 5: Return array // shuffled\n\nAlso need reset method:\n\n→ Step 6: Return copy of original // to avoid modification\n\nBut we might need to show methods separate? Virtual code may have classes and methods. We'll produce lines like:\n\nStart\n→ Step 1: Initialize class with input array // store copy\n→ Decision: None? Actually we can break into methods: reset and shuffle.\n\nWe need to produce virtual code with methods. Each method should start with \"Method: reset\" etc. Use arrow? Possibly we can denote method steps like:\n\nMethod: reset()\n→ Step: Return a copy of original array // reset\n\nMethod: shuffle()\n→ Step: Copy original array // to shuffle\n→ For loop ... etc\n\nWe need to follow format: Each line \"虛擬碼步驟 [space] // 解釋\".\n\nWe must use arrow → and decision: Yes →, No →.\n\nWe need to output step-by-step.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: Store input array nums as original // 保留原始順序\n→ Step 2: Create working array copy of original // 用於後續操作\n→ Method: reset() // 重置功能\n    → Step: Return copy of original // 回傳原始排列\n→ Method: shuffle() // 隨機洗牌\n    → Step 1: Copy original array to temp // 取得待洗牌副本\n    → Step 2: For i from len-1 down to 1 // 逐步交換\n        → Step: Generate random integer j in [0, i] // 隨機選擇\n        → Decision: j != i? // 是否需要交換\n            Yes → Step: Swap temp[i] with temp[j] // 交換\n            No  → Step: Do nothing // 跳過\n    → Step 3: Return temp // 回傳洗牌後的陣列\nEnd // 程式執行結束\n\nBut each line needs exactly \"虛擬碼步驟 // 解釋\". We should keep arrow and decision with appropriate indentation maybe. The format in example uses indentation for decisions. We'll replicate.\n\nAlso include \"Start\" and \"End\". Each line after Start we use arrow. For method start we might do \"→ Method: reset()\". But not exactly. The spec: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" So we can use \"Method:\" as step. Or we can show as separate block.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Store original array nums as self.original // 保留原始順序\n→ Store a working copy of original in self.current // 用於操作\n→ Method: reset() // 重置為原始順序\n    → Return copy of self.original // 回傳原始陣列\n→ Method: shuffle() // 隨機洗牌\n    → Copy self.original to temp // 取得待洗牌副本\n    → For i from len(temp)-1 down to 1 // 從尾部開始\n        → Generate random j between 0 and i // 隨機選取索引\n        → Decision: j != i? // 是否需要交換\n            Yes → Swap temp[i] and temp[j] // 交換元素\n            No  → // 不做任何操作\n    → Return temp // 返回洗牌結果\nEnd // 程式執行結束\n\nBut ensure each line with explanation: The line \"Method: reset()\" might have explanation: // 重置方法\n\nBetter to write as:\n\n→ Step 1: Define method reset() // 重置功能\n    → Step: Return copy of original array // 回傳原始排列\n\nBut to avoid confusion, we can keep each step line with explanation.\n\nWe should keep consistent: \"→ Step: ...\" for actions. \"Decision:\" for decisions.\n\nLet's craft final answer with lines.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store input array nums as self.original // 保留原始順序  \n→ Step 2: Store a copy of original in self.current // 用於臨時操作  \n→ Step 3: Define method reset() // 重置方法  \n    → Step 4: Return copy of self.original // 回傳原始陣列  \n→ Step 5: Define method shuffle() // 隨機洗牌方法  \n    → Step 6: Copy self.original to temp // 取得待洗牌副本  \n    → Step 7: For i from len(temp)-1 down to 1 // 由尾部開始遍歷  \n        → Step 8: Generate random integer j in [0, i] // 隨機選取索引  \n        → Decision: j != i? // 是否需要交換  \n            Yes → Step 9: Swap temp[i] with temp[j] // 交換兩個元素  \n            No  → // 若相同則不做任何交換  \n    → Step 10: Return temp // 回傳洗牌後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef subsets(nums):\n    res = []\n\n    def backtrack(start, path):\n        # 將目前子集加入結果\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            # 包含 nums[i]\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            # 退回，移除最後加入的元素\n            path.pop()\n\n    backtrack(0, [])\n    return res\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    nums = []\n\n    if data:\n        # 從輸入字串中擷取 nums 的內容\n        m = re.search(r'nums\\s*=\\s*(\\[.*\\])', data)\n        if m:\n            nums = eval(m.group(1))\n\n    result = subsets(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step for generating power set of a unique integer array. Use virtual code lines with arrow, decisions, etc. Provide short explanation. Should output line by line. The solution set must not contain duplicate subsets, return any order. Use recursion or backtracking. Provide steps: Start, Step 1: initialize result list, Step 2: call backtrack function, Step 3: backtrack with index and current subset. Decision: if index equals length, add copy to result. else include element, move forward, then exclude element. End. Provide pseudocode with arrows.\n\nAlso we need to incorporate unique elements assumption. We don't need dedup.\n\nWe need to produce virtual code with \"→ Step 1:\" etc. Should start with Start and End. Use \"Decision:\" for branching.\n\nLet's produce:\n\nStart\n→ Step 1: nums = input array, res = empty list // store all subsets\n→ Step 2: call Backtrack(0, empty subset) // start recursion\n→ End\n\nBut we need backtracking details:\n\n→ Step 3: Define Backtrack(index, current) // recursion\n→ Decision: if index == len(nums)? // base case\n    Yes → Step 4: res.append(copy of current) // add subset to result\n    No → \n        → Step 5: current.append(nums[index]) // include current element\n        → Step 6: Backtrack(index + 1, current) // explore including\n        → Step 7: current.pop() // backtrack remove element\n        → Step 8: Backtrack(index + 1, current) // explore excluding\n\nBut we need arrow lines.\n\nWe can also incorporate copying current to result. We must ensure we copy.\n\nWe need \"Yes →\" and \"No →\" branches.\n\nThus final pseudocode:\n\nStart // 程式開始執行\n→ Step 1: nums = input array of unique integers // 取得輸入陣列\n→ Step 2: res = empty list // 儲存所有子集\n→ Step 3: Define Backtrack(index, current) // 回溯函式\n→   Decision: index == len(nums)? // 檢查是否已處理完所有元素\n→     Yes → Step 4: res.append(copy(current)) // 將目前子集加入結果\n→     No → \n→       Step 5: current.append(nums[index]) // 包含該元素\n→       Step 6: Backtrack(index + 1, current) // 進一步探索包含\n→       Step 7: current.pop() // 退回，移除該元素\n→       Step 8: Backtrack(index + 1, current) // 進一步探索不包含\n→ End // 程式執行結束\n\nBut we need to follow arrow syntax: \"→\" before step lines, indentation for nested lines. Also use \"Decision:\" and \"Yes →\", \"No →\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums = input array of unique integers // 取得輸入陣列  \n→ Step 2: res = empty list // 儲存所有子集  \n→ Step 3: Define Backtrack(index, current) // 回溯函式  \n→   Decision: index == len(nums)? // 檢查是否已處理完所有元素  \n→     Yes → Step 4: res.append(copy(current)) // 將目前子集加入結果  \n→     No →  \n→       Step 5: current.append(nums[index]) // 包含該元素  \n→       Step 6: Backtrack(index + 1, current) // 進一步探索包含  \n→       Step 7: current.pop() // 退回，移除該元素  \n→       Step 8: Backtrack(index + 1, current) // 進一步探索不包含  \n→ End // 程式執行結束"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '12'"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '14'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '14'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    if not tasks:\n        return 0\n    # Count frequency of each task\n    task_counts = Counter(tasks)\n    max_freq = max(task_counts.values())\n    # Number of tasks that have the maximum frequency\n    max_count = sum(1 for cnt in task_counts.values() if cnt == max_freq)\n    # Calculate the minimum intervals needed\n    idle_slots = (max_freq - 1) * (n + 1) - (len(tasks) - max_freq * max_count)\n    # If idle slots are negative, we can fill them with remaining tasks\n    return max(len(tasks), len(tasks) + max(0, idle_slots))\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input string like:\n        'tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2'\n    Returns a tuple (tasks_list, n_value).\n    \"\"\"\n    pattern = r'tasks\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*n\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    tasks_str, n_str = match.groups()\n    tasks = ast.literal_eval(tasks_str)\n    n = int(n_str)\n    return tasks, n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    tasks, n = parse_input(raw_input)\n    result = least_interval(tasks, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for scheduling tasks with cooling period n. Classic CPU scheduling problem. We'll produce algorithm: count frequencies, find max freq, count how many tasks have that max, compute idle slots = (max-1)*(n+1) - (total tasks - max * countMax). If idle <0 then answer = total tasks else answer = idle + total tasks. But we want pseudocode lines.\n\nWe need to produce lines: Start, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's design steps:\n\nStart\n→ Step 1: 统计每个任务的出现次数 // frequency map\n→ Step 2: 找到出现次数最多的任务频率 maxFreq // max frequency\n→ Step 3: 统计具有最大频率的任务数 countMax // number of tasks with max frequency\n→ Step 4: 计算空闲槽 idleSlots = (maxFreq - 1) * (n + 1) - (totalTasks - maxFreq * countMax) // remaining slots to fill\n→ Decision: 如果 idleSlots < 0?\n    Yes → Step 5: 结果 intervals = totalTasks // 所有槽已被任务填满\n    No  → Step 6: 结果 intervals = idleSlots + totalTasks // 需要额外空闲时间\nEnd\n\nBut need to incorporate steps to compute totalTasks.\n\nWe'll also include step to sum frequencies to get total tasks.\n\nLet's produce pseudocode lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率表 freqMap // 用於存儲每個任務字母的出現次數\n→ Step 2: 遍歷 tasks 並更新 freqMap[task] += 1 // 统计每个任务出现次数\n→ Step 3: totalTasks = tasks 的长度 // 计算任务总数\n→ Step 4: maxFreq = 最大的 freqMap 值 // 找到出现次数最多的任务频率\n→ Step 5: countMax = 统计 freqMap 中等于 maxFreq 的键数量 // 有多少任务拥有最大频率\n→ Step 6: idleSlots = (maxFreq - 1) * (n + 1) - (totalTasks - maxFreq * countMax) // 计算需要的空闲间隔\n→ Decision: idleSlots < 0?\n    Yes → Step 7: intervals = totalTasks // 没有空闲间隔，直接用任务数\n    No  → Step 8: intervals = idleSlots + totalTasks // 加上空闲间隔得到总时间\nEnd // 程式執行結束\n\nEnsure each line ends with // explanation. Use arrow for decisions. For Decision we may need indentation.\n\nWe need to include arrow lines? Use \"→ Decision:\" and indent.\n\nOk produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率表 freqMap // 用於存儲每個任務字母的出現次數  \n→ Step 2: 遍歷 tasks 並更新 freqMap[task] += 1 // 统计每个任务出现次数  \n→ Step 3: totalTasks = tasks 的长度 // 计算任务总数  \n→ Step 4: maxFreq = 最大的 freqMap 值 // 找到出现次数最多的任务频率  \n→ Step 5: countMax = 统计 freqMap 中等于 maxFreq 的键数量 // 有多少任务拥有最大频率  \n→ Step 6: idleSlots = (maxFreq - 1) * (n + 1) - (totalTasks - maxFreq * countMax) // 计算需要的空闲间隔  \n→ Decision: idleSlots < 0? // 判断是否有多余的空闲槽  \n    Yes → Step 7: intervals = totalTasks // 没有空闲间隔，直接用任务数  \n    No  → Step 8: intervals = idleSlots + totalTasks // 加上空闲间隔得到总时间  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '5,nums=[1,1,2,2,3,\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      \"5, nums = [1, 1, 2, 2, 3, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7,nums=[0,0,1,1,2,3,3,_,_]'\nGot (Norm):      '7,nums=[0,0,1,1,2,3,3,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '7, nums = [0,0,1,1,2,3,3,_,_]'\nRaw Got:      \"7, nums = [0, 0, 1, 1, 2, 3, 3, '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef remove_duplicates(nums):\n    \"\"\"Remove duplicates so each element appears at most twice, in-place.\"\"\"\n    if not nums:\n        return 0\n    i = 0  # write pointer\n    for j in range(len(nums)):\n        # allow first two elements or any element different from the one two places back\n        if i < 2 or nums[j] != nums[i - 2]:\n            nums[i] = nums[j]\n            i += 1\n    return i\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Find the first '[' and the last ']' to extract the list literal\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end <= start:\n        print(\"Invalid input format\")\n        return\n    list_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"Failed to parse list\")\n        return\n    if not isinstance(nums, list):\n        print(\"Input does not contain a list\")\n        return\n\n    k = remove_duplicates(nums)\n\n    # Build the output list with '_' placeholders for the unused tail\n    output_list = []\n    for idx in range(k):\n        output_list.append(nums[idx])\n    for idx in range(k, len(nums)):\n        output_list.append('_')\n\n    print(f\"{k}, nums = {output_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to remove duplicates such that each element appears at most twice, preserving order. We produce step-by-step pseudo-code with arrow, decisions, etc. We must explain each line. Provide line numbers? Not necessary, but each line must contain virtual code step and comment.\n\nWe should produce algorithm like two pointers: write pointer i, read pointer j. For each element, count duplicates. Since sorted, we can allow first two occurrences. Approach: iterate from index 0 to n-1, maintain count of current element. Use i to write to output array. For each j, if count < 2 or element differs from previous, set nums[i] = nums[j], i++, if element same as previous, increase count else reset count.\n\nSimplify: Use i=0, for each j from 0 to n-1, if i < 2 or nums[j] != nums[i-2], then nums[i] = nums[j]; i++. This classic solution.\n\nThus virtual code:\n\nStart\n→ Initialize i = 0 // write pointer start\n→ For j = 0 to n-1 // read pointer iterate over array\n    → Decision: if i < 2? // first two positions always allowed\n        Yes → Set nums[i] = nums[j] // copy element\n        i = i + 1 // increment write pointer\n        No  → Decision: if nums[j] != nums[i-2]? // check if element differs from the one two positions before\n            Yes → Set nums[i] = nums[j] // allow copy\n            i = i + 1 // increment write pointer\n            No  → // skip duplicate beyond two times\nEnd // return i // length of result\n\nAdd explanation. Provide comments after each line. Need to keep virtual code and comment. Use arrow formatting as example.\n\nLet's produce lines accordingly. Use indentation for nested decisions.\n\nAlso we may need to include the return statement.\n\nMake sure to not include actual code, just virtual steps. Provide comments in Chinese.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 初始化寫指標 i ← 0 // 先設定寫入位置為第一個索引\n    Yes → Set i = 0 // 把寫指標設為 0\n→ For j from 0 to n-1 // 讀指標從陣列頭逐一遍歷\n    → Decision: i < 2? // 前兩個位置總是允許寫入\n        Yes → Step 1: nums[i] ← nums[j] // 直接複製元素到寫位置\n        Yes → Step 2: i ← i + 1 // 寫指標右移\n        No  → Decision: nums[j] != nums[i-2]? // 判斷此元素與前兩個位置的元素是否不同\n            Yes → Step 3: nums[i] ← nums[j] // 同樣允許寫入，因為不同\n            Yes → Step 4: i ← i + 1 // 寫指標右移\n            No  → Step 5: // 不做任何動作，跳過多餘重複\n→ End // 所有元素已處理完畢\n→ Return i // i 即為去重後陣列的有效長度\n\n---  \n說明：\n- `i` 為寫入指標，指向下一個可以放入元素的位置。  \n- `j` 為讀取指標，逐個掃描原陣列。  \n- `i < 2` 的判斷保證前兩個元素無論重複多少次都能寫入。  \n- `nums[j] != nums[i-2]` 的判斷利用已寫入的陣列，檢查目前元素是否已經在前兩個位置出現過兩次，若不是則允許寫入。  \n- 最終返回 `i` 即可得到去除多餘重複後陣列的長度，且前 `i` 個元素即為處理後的結果。"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2,0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34,-10,-14,-10,10]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        memo = {}\n\n        def ways(expr: str) -> List[int]:\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # ch == '*'\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the expression string inside quotes (single or double)\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    if not match:\n        # If no quotes, assume the entire input is the expression\n        expr = data.strip()\n    else:\n        expr = match.group(1)\n\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n    # Print list without spaces to match sample output format\n    print('[' + ','.join(str(x) for x in results) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem. The problem: Given a string expression of numbers and operators, return all possible results from computing all different ways to group numbers and operators. It's classic \"different ways to add parentheses\" problem. Need to produce algorithm.\n\nWe must output virtual code line by line with // explanation. Use Start, End, Decision, etc. Should include recursion/memoization, splitting expression by operators, evaluating subexpressions.\n\nWe need to produce steps, not actual code, but structured pseudocode. We should consider recursion function compute(i, j) returning list of results for subexpression from index i to j. Use memoization map. For each operator position, split left and right, compute recursively, combine results with operator. Base case: if subexpression is a single number, return that number.\n\nWe'll produce virtual code lines accordingly. Use arrows and decisions. Should reflect algorithm clearly.\n\nLet's craft steps:\n\nStart\n→ Input: expression string\n→ Initialize memo map\n→ Define Function compute(start, end) // recursively compute results\n→ Decision: If start == end? // subexpression single token\n    Yes → Return list containing numeric value at position start\n    No  → Initialize results list\n    → For each operator index between start+1 and end-1 step 2? But since tokens can be numbers of multiple digits, we need to parse tokens. Simplify: iterate through expression string to find operator positions (non-digit). For each operator at pos opIdx:\n        → Decision: Is char at opIdx an operator? // check if operator\n        → Yes → Compute left = compute(start, opIdx-1)\n        → Compute right = compute(opIdx+1, end)\n        → For each leftVal in left:\n            For each rightVal in right:\n                → Compute result = apply(operator, leftVal, rightVal)\n                → Add to results\n    → Store results in memo\n    → Return results\n→ Call compute(0, expression.length-1)\n→ Return final results\nEnd\n\nBut we need to use virtual code steps with arrows. Use arrow for function body.\n\nAlso we might need to parse numbers: when start==end? Not exactly; expression might be multi-digit number, but we can treat tokens separated by operators. But for simplicity, treat as we are given expression as string; when start==end we parse the whole substring into integer. Use substring.\n\nBut we can incorporate decision: if subexpression contains no operator? Use regex or check by iterating. We'll implement: Check if subexpression has any operator. If none, parse to integer.\n\nWe can use: Decision: If subexpression contains no operator? // base case\n    Yes -> Return integer value\n    No -> iterate operators.\n\nWe'll use \"Decision: 是否存在運算子\" etc.\n\nNow we need to produce virtual code lines, each line with explanation after //.\n\nLet's structure:\n\nStart // 程式開始\n→ Input expression // 取得輸入字串\n→ Initialize memoization map // 用於儲存已計算子表達式的結果\n→ Define Function Compute(subExpr) // 重新遞迴計算子表達式的所有結果\n    → Decision: 子表達式是否包含運算子? // 判斷是否為單一數字\n        Yes → Return [int(subExpr)] // 基本情況，單一數字返回本身\n        No  → Initialize empty list results // 需要分割計算\n            → For each operator index opPos in subExpr\n                → Decision: 子字元 at opPos 是否為運算子? // 確認實際運算子位置\n                    Yes →\n                        → leftResults = Compute(subExpr[0:opPos-1]) // 左子表達式\n                        → rightResults = Compute(subExpr[opPos+1:]) // 右子表達式\n                        → For each l in leftResults\n                            → For each r in rightResults\n                                → res = ApplyOperator(subExpr[opPos], l, r) // 計算\n                                → Add res to results\n            → Store results in memo for subExpr // 記錄已計算結果\n            → Return results // 返回此子表達式的所有可能結果\n→ finalResults = Compute(expression) // 計算整個表達式\n→ Return finalResults // 輸出所有可能的結果\nEnd // 程式結束\n\nBut we must output each line as \"虛擬碼步驟 [空格] // 解釋/說明\". So each line starts with step, then // explanation.\n\nAlso need to use arrow symbols: → for continuation. For decision: use Decision: If ...? Then Yes →, No →. Use indent? Provide arrow lines within decision block.\n\nWe need to ensure we obey output format: Each line \"虛擬碼步驟 [space] // 解釋/說明\". Eg: \"Start // 程式開始執行\".\n\nLet's produce full virtual code:\n\nStart // 程式開始執行\n→ Input expression // 讀取表達式字串\n→ Initialize memo = {} // 建立記憶化字典\n→ Function Compute(expr) // 重新遞迴計算子表達式\n    → Decision: expr 是否含有運算子? // 判斷是否為單一數字\n        Yes → Return [int(expr)] // 基本情況：直接回傳整數值\n        No  →\n            → results = [] // 用於儲存此子表達式的所有可能結果\n            → For each index i, char in expr\n                → Decision: char 是否為運算子? // 確認運算子位置\n                    Yes →\n                        → left = Compute(expr[0:i]) // 左子表達式\n                        → right = Compute(expr[i+1:]) // 右子表達式\n                        → For each l in left\n                            → For each r in right\n                                → res = ApplyOperator(char, l, r) // 計算\n                                → results.append(res) // 收集結果\n            → memo[expr] = results // 記錄已計算的結果\n            → Return results // 回傳所有可能結果\n→ final = Compute(expression) // 計算整個表達式\n→ Return final // 回傳所有不同的結果\nEnd // 程式結束執行\n\nBut we should avoid .append syntax, but that's fine. Use pseudo.\n\nHowever, we need to be consistent with arrow formatting: Use arrow after each step. For decision branches, indent the Yes and No lines.\n\nWe need to ensure no actual code like .append. It's okay.\n\nLet's refine.\n\nWe'll produce lines:\n\nStart // 程式開始\n→ Input expression // 取得輸入字串\n→ Initialize memo = {} // 建立記憶化字典\n→ Function Compute(expr) // 計算子表達式所有結果\n    → Decision: expr 是否包含運算子? // 判斷是否為單一數字\n        Yes → Return [int(expr)] // 基本情況，直接回傳數字\n        No  →\n            → results = [] // 用於收集所有結果\n            → For i from 0 to length(expr)-1\n                → Decision: expr[i] 是否為運算子? // 確認是否為 '+', '-', '*'\n                    Yes →\n                        → left = Compute(expr[0:i]) // 左邊子表達式\n                        → right = Compute(expr[i+1:]) // 右邊子表達式\n                        → For each l in left\n                            → For each r in right\n                                → res = ApplyOperator(expr[i], l, r) // 計算\n                                → results.append(res) // 加入結果\n            → memo[expr] = results // 先備份結果\n            → Return results // 回傳此子表達式的所有結果\n→ finalResults = Compute(expression) // 計算整個表達式\n→ Return finalResults // 輸出所有可能結果\nEnd // 程式結束\n\nBut we need to use '→' for continuation inside function. For loops, use '→' for each line.\n\nAlso we might need to use arrow for function definition line: \"→ Function Compute(expr) // ...\" But maybe \"→ Compute(expr) // ...\"? However we should indicate function name. Use \"→ Compute(expr) // 定義遞迴函式\".\n\nBetter: \"→ Function Compute(expr) // 定義遞迴函式以計算子表達式結果\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input expression // 讀取輸入的算式字串  \n→ Initialize memo = {} // 建立記憶化字典以存儲已計算子表達式的結果  \n→ Function Compute(expr) // 定義遞迴函式以計算子表達式的所有可能結果  \n    → Decision: expr 是否包含任何運算子? // 判斷是否為單一數字  \n        Yes → Return [int(expr)] // 基本情況：單一數字直接回傳本身  \n        No →  \n            → results = [] // 用於收集此子表達式的所有可能結果  \n            → For i from 0 to length(expr)-1  \n                → Decision: expr[i] 是否為 '+', '-', '*'? // 確認運算子位置  \n                    Yes →  \n                        → left = Compute(expr[0:i]) // 取得左子表達式的所有結果  \n                        → right = Compute(expr[i+1:]) // 取得右子表達式的所有結果  \n                        → For each l in left  \n                            → For each r in right  \n                                → res = ApplyOperator(expr[i], l, r) // 計算左右結果之運算  \n                                → results.append(res) // 加入到結果集合  \n            → memo[expr] = results // 將此子表達式的結果存入記憶化字典  \n            → Return results // 回傳此子表達式的所有可能結果  \n→ finalResults = Compute(expression) // 計算整個輸入表達式的所有結果  \n→ Return finalResults // 輸出所有不同的計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def crackSafe(self, n: int, k: int) -> str:\n        # Special case when n == 1: just return all digits in order\n        if n == 1:\n            return ''.join(str(i) for i in range(k))\n        seen = set()\n        res = []\n\n        def dfs(node: str):\n            for x in map(str, range(k)):\n                nxt = node + x\n                if nxt not in seen:\n                    seen.add(nxt)\n                    dfs(nxt[1:])\n                    res.append(x)\n\n        start = '0' * (n - 1)\n        dfs(start)\n        return ''.join(res) + start\n\ndef main():\n    data = sys.stdin.read()\n    # Extract all integers from the input\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    ans = Solution().crackSafe(n, k)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for generating minimal-length string that contains all possible length-n sequences over alphabet 0..k-1? Actually it's to ensure the correct password will appear as a contiguous substring of length n in the input string. But we don't know which password; we need string that guarantees unlocking for any password? Wait: The problem likely refers to constructing a string that contains all possible n-length combinations as substrings, i.e., a de Bruijn sequence of order n over alphabet size k. Minimal length string that guarantees to unlock safe regardless of password is a De Bruijn sequence length k^n + n -1. So produce steps: Build De Bruijn graph, Eulerian cycle, output path labels, etc. Provide pseudocode steps.\n\nWe produce step by step. Let's design algorithm: \n1. Start\n2. Create adjacency list for nodes of length n-1 digits.\n3. For each node, add edges for each possible digit k-1.\n4. Find Eulerian cycle using Hierholzer.\n5. Record sequence of digits along edges.\n6. Append starting node to end to get string of length k^n + n -1.\nReturn string.\n\nAdd explanation each line.\n\nWe'll produce pseudocode steps with arrow arrows.\n\nLet's craft.\n\nAlso need to handle case n=1 special? But we can keep general.\n\nLet's write:\n\nStart\n→ Step 1: 計算節點數目 = k^(n-1) // 生成所有長度 n-1 的前綴\n→ Decision: 如果 n=1? // 特殊處理\n    Yes → Step 2: 輸出所有 k 個數字並結束 // 直接列出所有數字\n    No  → Step 3: 建立鄰接表 // 建構有向圖\n\nStep 3: For each node in nodes:\n    → Step 3a: For each digit d in [0, k-1]:\n        → Step 3b: Add edge from node to suffix(node)+d // 標記每個可能的後綴\n\nStep 4: Hierholzer 初始化 stack, path\n    → Step 4a: Push start node onto stack\n    → Decision: stack 非空? \n        Yes → Step 4b: 取得 current node = stack.top()\n        → Decision: current node 還有未使用邊? \n            Yes → Step 4c: 取一條邊, 標記為使用, push dest onto stack\n            No  → Step 4d: Pop current node, add to path\n        No  → Step 4e: 跑完\n\nStep 5: 逆轉 path // 取得 Eulerian cycle\n\nStep 6: 生成密碼串\n    → Step 6a: 將第一個節點 (長度 n-1) 輸出\n    → Step 6b: 對於每個後續節點在 path (從第二個開始):\n        → Step 6b1: 輸出最後一個字符 // 獲得對應的邊標籤\n    → Step 6c: 輸出完畢\n\nReturn string.\n\nExplain each line.\n\nAlso include End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: n = 1? // 檢查是否只有單一位密碼  \n Yes → Step 1a: 輸出數字 0,1,…,k-1 並結束 // 這時長度 k 的字串即可覆蓋所有單位組合  \n No  → Step 1b: 建立節點集合 // 節點為長度 n-1 的所有組合，數量為 k^(n-1)  \n\nStep 1b → Step 2: 為每個節點建立鄰接表  \n → For each node in node_set:  \n  → For each digit d in [0, k-1]:  \n   → Step 2a: Add edge (node → suffix(node)+d) labelled d // 每個節點都出發 k 條邊，對應所有可能的後綴  \n\nStep 2a → Step 3: Hierholzer 演算法尋找 Eulerian 循環  \n → Initialize stack with start_node  \n → Decision: stack 非空?  \n  Yes → Step 3a: current = stack.top()  \n   → Decision: current 還有未使用邊?  \n    Yes → Step 3b: pop an unused edge (current → next) labelled d  \n     → Mark edge as used  \n     → Push next onto stack  \n    No → Step 3c: Pop current from stack並加入 path  \n  No → Step 3d: 完成 Eulerian 路徑  \n\nStep 3d → Step 4: 反轉 path 取得正向 Eulerian 循環  \n\nStep 4 → Step 5: 生成最短的密碼串  \n → Step 5a: result ← first node (長度 n-1 的序列)  \n → For i from 1 to len(path)-1:  \n  → Step 5b: result ← result + last_char(path[i]) // 加入對應邊的標籤  \n → Step 5c: 輸出 result // 長度為 k^n + n - 1，包含所有長度 n 的組合  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 如果其中一個是 \"0\"，直接返回 \"0\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 用一個長度為 m+n 的陣列來存儲每一位的結果\n        pos = [0] * (m + n)\n\n        # 從最低位開始計算\n        for i in range(m - 1, -1, -1):\n            digit1 = int(num1[i])\n            for j in range(n - 1, -1, -1):\n                digit2 = int(num2[j])\n                mul = digit1 * digit2\n                p1, p2 = i + j, i + j + 1\n\n                # 將乘積加到現有的位上\n                total = mul + pos[p2]\n                pos[p2] = total % 10          # 目前位的數字\n                pos[p1] += total // 10        # carry 加到前一位\n\n        # 把結果陣列轉成字串，去掉前導零\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result if result else \"0\"\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中找出兩個數字。支持多種輸入格式，\n    例如:  \"num1 = '123', num2 = '456'\" 或者 \"123 456\"。\n    \"\"\"\n    nums = re.findall(r\"\\d+\", data)\n    if len(nums) >= 2:\n        return nums[0], nums[1]\n    # 如果沒找到，直接返回空字串\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    num1, num2 = parse_input(raw_input)\n    solution = Solution()\n    result = solution.multiply(num1, num2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for string multiplication without big integer conversion. Typical algorithm: multiply digits like manual multiplication, store results in array, handle carry.\n\nWe need to produce step by step.\n\nLet's outline:\n\nStart\n→ Step 1: Obtain lengths n1, n2\n→ Step 2: Initialize result array of size n1+n2 with zeros\n→ Step 3: Loop i from n1-1 downto 0\n    → Step 4: Convert num1[i] to int digit1\n    → Step 5: Loop j from n2-1 downto 0\n        → Step 6: Convert num2[j] to int digit2\n        → Step 7: Multiply digit1 * digit2 + result[i+j+1] -> temp\n        → Step 8: Set result[i+j+1] = temp mod 10\n        → Step 9: Add temp div 10 to result[i+j]\n    → End inner loop\n→ End outer loop\n→ Step 10: Build string from result array, skip leading zeros\n→ Decision: If result string empty? set to \"0\"\n→ End\n\nNeed to use virtual code with arrows.\n\nAlso include decisions for empty string.\n\nLet's produce each line with explanation.\n\nWe'll use indentation.\n\nWe must use \"→\" arrow at each step.\n\nAlso decisions with Yes → etc.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n1 ← length(num1) // 取得 num1 的字串長度  \n→ Step 2: n2 ← length(num2) // 取得 num2 的字串長度  \n→ Step 3: result ← array of (n1 + n2) zeros // 初始化結果陣列，大小為兩個數字長度之和  \n→ Decision: 是否為空字串? // 檢查輸入是否為空  \n  Yes → Step 4: return \"0\" // 若任何輸入為空，直接返回 \"0\"  \n  No →  \n   → Step 5: for i from n1-1 down to 0 // 從 num1 的最後一位開始遍歷  \n    → Step 6: digit1 ← int(num1[i]) // 把 num1 的第 i 位字元轉為整數  \n    → Step 7: for j from n2-1 down to 0 // 從 num2 的最後一位開始遍歷  \n     → Step 8: digit2 ← int(num2[j]) // 把 num2 的第 j 位字元轉為整數  \n     → Step 9: temp ← digit1 * digit2 + result[i + j + 1] // 計算乘積並加入現有的 carry  \n     → Step 10: result[i + j + 1] ← temp mod 10 // 更新當前位的數字  \n     → Step 11: result[i + j] ← result[i + j] + temp div 10 // 把 carry 加到前一位  \n    → End inner loop // 結束 num2 的遍歷  \n   → End outer loop // 結束 num1 的遍歷  \n   → Step 12: prodStr ← \"\" // 建立空字串用於拼接結果  \n   → Step 13: for k from 0 to n1 + n2 - 1 // 逐位遍歷結果陣列  \n     → Decision: 是否為前導零? // 跳過不需要的前導零  \n       Yes → continue // 若為前導零則跳過  \n       No → prodStr ← prodStr + char(result[k] + '0') // 將數字轉為字元並附加到結果字串  \n   → End loop // 結束結果字串拼接  \n   → Decision: prodStr 為空? // 判斷是否全為零  \n     Yes → prodStr ← \"0\" // 若結果字串為空，設為 \"0\"  \n     No → // 不做任何事  \n→ End // 程式執行結束"
    }
  ]
}