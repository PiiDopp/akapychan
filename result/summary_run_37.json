{
  "run_index": 37,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 297,
  "generation_or_validation_failure_count": 37,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有標準輸入資料（此題實際上不需要使用，但依照規範需讀取）\n    _ = sys.stdin.read()\n\n    try:\n        # 使用 with 以安全方式開啟檔案，並統計行數\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        # 檔案不存在時輸出錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code with explanations, line by line, following format. The requirement: open data.txt, read content, count lines, output count. If file not found, show message. Use with and try/except.\n\nWe need to use structure: Start, End, Decision:, arrows.\n\nWe must produce lines: \"Start // 程式開始執行\" etc. The pseudo-code should reflect the logic. Each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nPseudo-code steps: Start, then Try: open file with with open('data.txt','r') as f, then read lines into list, count, output count. Decision: maybe we can use Decision to check if file opened successfully? Actually try/except handles that. So after reading, we can count lines and output.\n\nWe need to represent try/except: maybe Decision: Try? Use \"Decision: 嘗試開啟檔案?\" but that may not be necessary. Instead we can use:\n\n→ Decision: 是否成功讀取檔案? but the file reading will raise exception if not. Use try/except block:\n\nWe can represent try as: \"→ Decision: 進入 try 區塊?\" but better:\n\nUse \"→ Decision: 試圖開啟檔案?\" maybe.\n\nPseudo-code representation can use \"→ Decision: 檔案是否存在?\" but not accurate.\n\nWe can also structure:\n\nStart\n→ Decision: 嘗試開啟檔案 (try)\n    Yes → Step 1: 讀取所有行 // 讀取檔案內容\n    Yes → Step 2: 計算行數 // 獲取行數\n    Yes → Step 3: 輸出行數 // 顯示結果\n    No  → Step 4: 輸出 '找不到檔案！' // 錯誤處理\nEnd\n\nBut we need to show with and try/except.\n\nPseudo-code can show:\n\n→ Decision: 開啟檔案時是否拋出例外?\n    Yes → Step: 捕捉例外 // 處理錯誤\n    No → Step: 讀取檔案 // 讀取行\n\nAlternatively:\n\n→ Step: try\n    → Step: with open('data.txt','r') as f\n    → Step: lines = f.readlines()\n    → Step: count = len(lines)\n    → Step: print(count)\n→ Decision: except FileNotFoundError?\n    Yes → Step: print('找不到檔案！')\n\nBut need line-by-line with arrows. So each step separate line.\n\nBetter: Represent try block as a Decision with Yes path for success and No path for exception.\n\nPseudo-code:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案 'data.txt'? // 試圖進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取所有行\n    Yes → Step 3: count = len(lines) // 計算行數\n    Yes → Step 4: print(count) // 輸出行數\n    No  → Step 5: print('找不到檔案！') // 捕捉 FileNotFoundError\nEnd // 程式結束\n\nBut we need to show with try/except explicitly? They asked to use with and try/except. In pseudo-code we can mention \"try\" block and \"except\" block.\n\nSo we can structure:\n\n→ Step 1: try // 開始 try 區塊\n→ Step 2: with open('data.txt','r') as f // 使用 with 打開檔案\n→ Step 3: lines = f.readlines() // 讀取行\n→ Step 4: count = len(lines) // 計算行數\n→ Step 5: print(count) // 輸出行數\n→ Step 6: except FileNotFoundError: // 捕捉檔案未找到錯誤\n→ Step 7: print('找不到檔案！') // 顯示錯誤訊息\n\nBut we need arrow notation. Might be:\n\n→ Step 1: try // 進入 try 區塊\n    → Step 2: with open('data.txt','r') as f // 使用 with 開啟\n    → Step 3: lines = f.readlines() // 讀取內容\n    → Step 4: count = len(lines) // 計算行數\n    → Step 5: print(count) // 輸出行數\n→ Decision: except FileNotFoundError? // 捕捉檔案未找到\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n\nBut need to show arrow for each line. We could have nested indentation.\n\nWe also need to keep each line with virtual code step and explanation. So produce something like:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 以安全方式打開\n    Yes → Step 2: lines = f.readlines() // 讀取檔案所有行\n    Yes → Step 3: count = len(lines) // 計算行數\n    Yes → Step 4: print(count) // 輸出行數\n    No  → Decision: 捕捉 FileNotFoundError? // 若開啟失敗則處理錯誤\n        Yes → Step 5: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut this representation uses Decision to represent try except.\n\nWe need to output step by step. The instructions: use arrows (→, Yes →, No →) and structure (Start, End, Decision:). So we need to use them accordingly.\n\nWe can do:\n\nStart // 程式開始執行\n→ Decision: 是否進入 try? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取檔案內容\n    Yes → Step 3: count = len(lines) // 計算行數\n    Yes → Step 4: print(count) // 輸出行數\n    No  → Decision: 是否捕捉 FileNotFoundError? // 捕捉檔案不存在\n        Yes → Step 5: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nHowever, the 'No' branch of try is unnatural. We can better show try/except structure.\n\nBetter representation:\n\nStart // 程式開始執行\n→ Step 1: try // 開始 try 區塊\n→ Step 2: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n→ Step 3: lines = f.readlines() // 讀取所有行\n→ Step 4: count = len(lines) // 計算行數\n→ Step 5: print(count) // 輸出行數\n→ Decision: except FileNotFoundError? // 捕捉檔案不存在\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nWe need to keep the arrow pattern: \"→\" for normal step, \"Decision:\" for if condition, \"Yes →\", \"No →\" for branches.\n\nThus each step line should include virtual code step (like \"Start\", \"Step 1:\", etc) then space then comment explanation.\n\nWe must keep the arrow for each step: \"→ Step X: ... // ...\"\n\nYes/No branches with indentation: For example:\n\nDecision: except FileNotFoundError?\n    Yes → Step 6: print('找不到檔案！') // ...\n\nThus we output like that.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: try // 進入 try 區塊，準備捕捉檔案不存在的錯誤\n→ Step 2: with open('data.txt', 'r') as f // 使用 with 以安全方式打開檔案\n→ Step 3: lines = f.readlines() // 讀取檔案中的所有行\n→ Step 4: count = len(lines) // 計算行數\n→ Step 5: print(count) // 輸出行數結果\n→ Decision: except FileNotFoundError? // 檢查是否發生檔案未找到的例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,1,2,4,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 1, 2, 4, 5]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果列表。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有內容，並執行。這樣可以處理任何合法的 Python 代碼，例如 `print(roll_dice(5))`。\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Should not output actual code. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. Should include random module, function roll_dice(n). Simulate n times. Return list.\n\nWe need to produce a step-by-step pseudocode. Each line like:\n\nStart\n→ Step 1: Import random module\n→ Step 2: Define function roll_dice(n)\n    → Step 3: Initialize empty list results\n    → Step 4: For i from 1 to n:\n        → Step 5: Roll a die: roll = random.randint(1,6)\n        → Step 6: Append roll to results\n    → Step 7: Return results\nEnd\n\nAdd explanations. Use arrow \"→\". Use Decision if any? There's no decision except maybe check n>0? We could include Decision: if n <= 0? But spec didn't ask. We can add optional.\n\nBut keep simple. Use no actual code. Provide explanation.\n\nMake sure each line has // after virtual code.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random 模組 // 先載入 random，方便之後產生隨機數  \n→ Step 2: 定義函式 roll_dice(n) // 建立一個可重複使用的擲骰子功能  \n    → Step 3: 建立空列表 results // 用來儲存每次擲骰的結果  \n    → Step 4: 迴圈 for i 在 1 到 n:\n        → Step 5: roll = random.randint(1, 6) // 產生 1 到 6 之間的隨機整數  \n        → Step 6: results.append(roll) // 把本次擲骰結果加入列表  \n    → Step 7: return results // 回傳所有擲骰結果的列表  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 的執行時間，並回傳四捨五入到小數點 3 位的秒數。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入的所有程式碼，並在目前命名空間執行。\n    這樣可以讓輸入的程式碼自行呼叫 measure_time 並印出結果。\n    \"\"\"\n    import sys\n    code = sys.stdin.read()\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines following format. We need Start, arrow lines, decisions, etc. Provide code for measure_time(func, *args). Steps: import time, start timer, call func, stop timer, compute elapsed, round to 3 decimal places, return elapsed. Probably also return result of func? It says measure_time(func, *args) returns result (rounded time). It says \"回傳結果 (四捨五入到小數點 3 位)\". Likely return elapsed time. So we don't need to return function result. So steps: import time, define function, record start, call func with args, record end, compute elapsed, round, return. Provide explanation.\n\nWe need to format each line with \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nWe need Start, End. Might not need Decision because no branching except maybe condition? Not needed.\n\nBut we can include decision to check if func exists? Not necessary.\n\nBut we need to show function definition.\n\nLet's produce:\n\nStart\n→ Step 1: Import time module // 引入時間模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: record start_time = time.time() // 記錄開始時間\n→ Step 4: Execute result = func(*args) // 執行傳入函式並取得結果\n→ Step 5: record end_time = time.time() // 記錄結束時間\n→ Step 6: calculate elapsed = end_time - start_time // 計算耗時\n→ Step 7: round_elapsed = round(elapsed, 3) // 四捨五入到小數點3位\n→ Step 8: return round_elapsed // 回傳四捨五入後的時間\nEnd\n\nBut we also might need to return result? But spec says 回傳結果 (四捨五入到小數點 3 位). So likely just the time. Ok.\n\nAdd explanatory comment each line.\n\nAlso include \"End\".\n\nThus output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入時間模組以便計算秒數  \n→ Step 2: Define function measure_time(func, *args) // 定義一個接收函式及其參數的測時函式  \n→ Step 3: record start_time = time.time() // 取得函式執行前的時間戳  \n→ Step 4: Execute result = func(*args) // 執行傳入的函式並存儲其返回值（如果需要可使用）  \n→ Step 5: record end_time = time.time() // 取得函式執行後的時間戳  \n→ Step 6: calculate elapsed = end_time - start_time // 計算實際耗時（秒）  \n→ Step 7: round_elapsed = round(elapsed, 3) // 將耗時四捨五入到小數點 3 位  \n→ Step 8: return round_elapsed // 回傳四捨五入後的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入（若有提供），但此問題不需要使用輸入資料\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'，不會拋出錯誤\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with arrow, decision maybe none. Steps: Start, create set, add, update, remove, discard, output, End. Provide each line with comment. Use 虛擬碼步驟 and explanation.\n\nLet's produce: \nStart\n→ Step 1: 定義 fruits = {'apple', 'banana'} // 創建初始集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 同時新增 'grape' 和 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在元素，無錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd\n\nAdd comments. Use format: Step 1: ... // ... Need to include arrow arrow: \"→ Step 1: ...\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 創建初始集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不會拋出錯誤  \n→ Step 6: print(fruits) // 輸出最終集合 fruits  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate() -> str:\n    \"\"\"\n    從 exchangerate-api 取得 USD 對 TWD 的匯率，並回傳格式化字串。\n    如發生任何錯誤，回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()                      # 1xx、2xx 為成功，否則拋出異常\n        data = r.json()\n        rate = data[\"rates\"].get(\"TWD\")           # 取得 TWD 匯率\n        if rate is None:\n            return \"找不到台幣匯率\"\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef run_gui() -> None:\n    \"\"\"\n    建立 tkinter 視窗，顯示匯率並提供按鈕更新。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update() -> None:\n        label.config(text=fetch_rate())\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，內容不做實際處理，僅為符合「必須讀取」的要求\n    try:\n        sys.stdin.read()\n    except Exception:\n        pass\n\n    # 將結果直接輸出至標準輸出\n    print(fetch_rate())",
      "virtual_code": "Thinking...\nWe need to generate virtual code in Traditional Chinese, step by step, with explanation. Use structure: Start, End, Decision, etc. Use arrow notation. Provide each line: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe must not output actual code, only pseudo steps.\n\nWe need to cover: import requests, tkinter. Create main window, label to display rate, button to update. On button click, call function that fetches rate from API, parse JSON, get 'rates' 'TWD', update label.\n\nWe need to show pseudo-code steps.\n\nInclude decisions? Probably we can check response status, existence of TWD.\n\nWe need to use arrow structure. Example:\n\nStart // 程式開始執行\n→ Import: requests // 導入 HTTP 請求模組\n→ Import: tkinter // 導入 GUI 模組\n\nThen create main window:\n\n→ Step: 建立主視窗 // 建立 tkinter 視窗\n→ Step: 建立顯示匯率的標籤 // 文字顯示匯率\n→ Step: 建立更新按鈕 // 按鈕觸發匯率更新\n\nDefine function update_rate:\n\n→ Step: 取得 API URL // 設定匯率 API\n→ Step: 發送 GET 請求 // 使用 requests.get\n→ Decision: 是否成功回應 200? // 檢查回應狀態\n    Yes → Step: 解析 JSON // 轉換為字典\n    Yes → Decision: 是否含 TWD? // 檢查 key\n        Yes → Step: 取得 TWD 匯率 // 提取匯率\n        Yes → Step: 更新標籤文字 // 顯示匯率\n        No → Step: 顯示錯誤 // TWD 未找到\n    No → Step: 顯示錯誤 // 回應失敗\n→ Step: 完成更新 // 更新完成\n\nBind button to function.\n\nMain loop: Tkinter mainloop.\n\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟\" and comment. Use arrow \"→\" preceding steps. Use \"Decision:\" for if. Use \"Yes →\", \"No →\". Keep each line separate.\n\nLet's produce the pseudo-code accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: requests // 導入 HTTP 請求模組  \n→ Import: tkinter // 導入 GUI 模組  \n\n→ Step: 建立主視窗 = tkinter.Tk() // 建立 tkinter 視窗物件  \n→ Step: 主視窗.title('美元兌台幣匯率') // 設定視窗標題  \n\n→ Step: 建立顯示匯率的標籤 = tkinter.Label(主視窗, text='匯率載入中…', font=('Helvetica', 14)) // 建立顯示匯率的文字元件  \n→ Step: 標籤.pack(pady=20) // 放置標籤於視窗  \n\n→ Step: 定義函式 update_rate(): // 定義更新匯率的功能  \n→     Step: API_URL = 'https://api.exchangerate-api.com/v4/latest/USD' // 設定匯率 API URL  \n→     Step: response = requests.get(API_URL) // 發送 GET 請求  \n→     Decision: response.status_code == 200? // 檢查是否成功  \n→         Yes → Step: data = response.json() // 解析 JSON  \n→         Yes → Decision: 'TWD' in data['rates']? // 檢查是否含有 TWD 匯率  \n→             Yes → Step: rate = data['rates']['TWD'] // 取得 TWD 匯率  \n→             Yes → Step: 標籤.config(text=f'1 USD = {rate} TWD') // 更新標籤文字  \n→             No  → Step: 標籤.config(text='找不到 TWD 匯率') // 顯示錯誤訊息  \n→         No  → Step: 標籤.config(text='API 回傳失敗') // 顯示回應失敗訊息  \n→ End // 結束函式定義  \n\n→ Step: 建立更新按鈕 = tkinter.Button(主視窗, text='更新匯率', command=update_rate) // 建立按鈕並綁定函式  \n→ Step: 按鈕.pack(pady=10) // 放置按鈕  \n\n→ Step: 呼叫 update_rate() // 初始載入匯率  \n\n→ Step: 主視窗.mainloop() // 開始 tkinter 主迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpympsb0w2.py\", line 53, in main\n    arguments = json.loads(second)\n                ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 3 (char 2)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpympsb0w2.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmpympsb0w2.py\", line 56, in main\n    arguments = ast.literal_eval(second)\n                ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [], [1], [2], [2], [], [1], [2], []]\n                                       ^\nSyntaxError: unmatched ']'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into two lists: commands and arguments\n    # Handle possible spaces around the separator\n    parts = data.split('], [', 1)\n    if len(parts) == 1:  # no space in separator\n        parts = data.split('],[' , 1)\n\n    first, second = parts[0].strip(), parts[1].strip()\n    if not first.startswith('['):\n        first = '[' + first\n    if not first.endswith(']'):\n        first += ']'\n    if not second.endswith(']'):\n        second += ']'\n\n    try:\n        commands = json.loads(first)\n        arguments = json.loads(second)\n    except Exception:\n        commands = ast.literal_eval(first)\n        arguments = ast.literal_eval(second)\n\n    obj = RandomizedSet()\n    results = []\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"RandomizedSet\":\n            results.append(None)\n        elif cmd == \"insert\":\n            results.append(obj.insert(args[0]))\n        elif cmd == \"remove\":\n            results.append(obj.remove(args[0]))\n        elif cmd == \"getRandom\":\n            results.append(obj.getRandom())\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudocode for the RandomizedSet class, with methods: constructor, insert, remove, getRandom. Use a hash map and array list for O(1). Use virtual code lines with arrow syntax.\n\nWe need to use Start, End, Decision etc. Provide line by line pseudocode with explanation comment. Must not output actual code. Use structure.\n\nWe need to include all lines for class definition? Let's produce steps:\n\nStart\n→ Step 1: Initialize data structures // Hash map and array\n→ Step 2: insert(val) // if val not in map\n    Decision: val exists?\n        Yes → return false\n        No → add val to array, record index in map, return true\n→ Step 3: remove(val) // if val in map\n    Decision: val exists?\n        Yes → swap with last element, update map, pop last, remove val from map, return true\n        No → return false\n→ Step 4: getRandom() // generate random index, return element at that index\nEnd\n\nAdd comments.\n\nLet's output in format: each line \"虛擬碼步驟 // 解釋\".\n\nUse arrows: \"→\". For decision: \"Decision: ...\". Indent children with tabs or spaces.\n\nWe must be careful: Use \"Decision: if ...\". Use Yes →, No →.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 hashMap 和 list // 建立空的哈希表與動態陣列\n\n→ Step 2: insert(val) // 插入新元素\n    Decision: hashMap 包含 val? // 判斷元素是否已存在\n        Yes → 返回 false // 已存在，不插入\n        No  → list.append(val) // 將 val 加入陣列尾部\n              hashMap[val] = list.size - 1 // 記錄 val 的索引\n              返回 true // 成功插入\n\n→ Step 3: remove(val) // 刪除元素\n    Decision: hashMap 包含 val? // 判斷元素是否存在\n        Yes → lastVal = list.last // 取陣列最後一個元素\n              lastIndex = list.size - 1\n              index = hashMap[val] // 取得 val 的索引\n              list[index] = lastVal // 將最後元素移到待刪位置\n              hashMap[lastVal] = index // 更新最後元素的新索引\n              list.pop() // 刪除陣列尾部\n              hashMap.remove(val) // 從哈希表移除 val\n              返回 true // 成功刪除\n        No  → 返回 false // 元素不存在，無法刪除\n\n→ Step 4: getRandom() // 隨機取值\n    index = 隨機數(0, list.size - 1) // 產生隨機索引\n    返回 list[index] // 取出對應元素\n\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋.\n\nWe need to be consistent with \"Decision:\" lines and Yes/No.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 hashMap 和 list // 建立空的哈希表與動態陣列\n\n→ Step 2: insert(val) // 插入新元素\n    Decision: hashMap 包含 val? // 判斷元素是否已存在\n        Yes → 返回 false // 已存在，不插入\n        No  → list.append(val) // 將 val 加入陣列尾部\n              hashMap[val] = list.size - 1 // 記錄 val 的索引\n              返回 true // 成功插入\n\n→ Step 3: remove(val) // 刪除元素\n    Decision: hashMap 包含 val? // 判斷元素是否存在\n        Yes → lastVal = list.last // 取陣列最後一個元素\n              lastIndex = list.size - 1\n              index = hashMap[val] // 取得 val 的索引\n              list[index] = lastVal // 將最後元素移到待刪位置\n              hashMap[lastVal] = index // 更新最後元素的新索引\n              list.pop() // 刪除陣列尾部\n              hashMap.remove(val) // 從哈希表移除 val\n              返回 true // 成功刪除\n        No  → 返回 false // 元素不存在，無法刪除\n\n→ Step 4: getRandom() // 隨機取值\n    index = 隨機數(0, list.size - 1) // 產生隨機索引\n    返回 list[index] // 取出對應元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [2, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        \"\"\"Initialize the matrix with all zeros.\"\"\"\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining cells that are still 0\n        self.mapping = list(range(self.total))  # mapping from index to real cell\n\n    def flip(self):\n        \"\"\"Randomly pick a 0 cell, flip it to 1, and return its coordinates.\"\"\"\n        idx = random.randint(0, self.total - 1)  # 1 random call\n        real_val = self.mapping[idx]             # real flattened index\n        # Move the last available cell into this position\n        self.mapping[idx] = self.mapping[self.total - 1]\n        self.total -= 1\n        # Convert flattened index back to (row, col)\n        return [real_val // self.n, real_val % self.n]\n\n    def reset(self):\n        \"\"\"Reset all cells back to 0.\"\"\"\n        self.total = self.m * self.n\n        self.mapping = list(range(self.total))\n\ndef main():\n    # Read all input, strip whitespace\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Input format: ops, args\n    ops, args = json.loads('[' + data + ']')\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            result.append(None)          # constructor returns null\n        elif op == \"flip\":\n            result.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            result.append(None)          # reset returns null\n        else:\n            result.append(None)          # safeguard for unknown ops\n\n    # Output as JSON (null for None)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, explaining each. The problem: we need to pick a random zero cell in m x n matrix initially all zeros, flip to 1. After many flips, some zeros remain. Need to sample uniformly among remaining zeros. Must minimize random calls.\n\nStandard solution: maintain a list/array of all indices (flattened), initially mapping each index to its position in array. When flipping, pick a random integer k from 0 to remaining-1, get index = mapping[k] (or mapping[k] itself if mapping not yet assigned). Then swap mapping[k] with mapping[remaining-1] (or mapping[remaining-1] with mapping[k]?), and decrement remaining. Reset sets mapping back to identity or reinitialize.\n\nTime complexity: O(1) per flip, O(m*n) init memory. Random calls: 1 per flip. That satisfies.\n\nNow produce virtual code lines.\n\nWe need to include the class and its methods. Let's produce virtual code lines with explanation.\n\nPseudo code:\n\nStart\n\n→ Step 1: Define class Solution // 代表解法\n\n→ Step 2: Constructor(m, n) // 初始化\n    → Step 2.1: total ← m * n // 總格數\n    → Step 2.2: remaining ← total // 仍為 0 的格數\n    → Step 2.3: mapping ← array of size total // 存放映射\n    → Step 2.4: For i in 0..total-1: mapping[i] ← i // 初始映射為自己\n\n→ Step 3: flip() // 隨機挑選\n    → Step 3.1: idx ← randomInt(0, remaining-1) // 取得隨機下標\n    → Step 3.2: val ← mapping[idx] // 真正的格子編號\n    → Step 3.3: mapping[idx] ← mapping[remaining-1] // 把最後一個映射放到 idx\n    → Step 3.4: remaining ← remaining - 1 // 減少可用格數\n    → Step 3.5: i ← val / n // 轉換為行\n    → Step 3.6: j ← val % n // 轉換為列\n    → Step 3.7: return [i, j] // 回傳\n\n→ Step 4: reset()\n    → Step 4.1: remaining ← total // 全部格恢復\n    → Step 4.2: For i in 0..total-1: mapping[i] ← i // 重新映射\n\nEnd\n\nBut we need each line to be in \"虛擬碼步驟\" format, with arrow \"→\" or \"Start\", \"End\". Use \"Decision:\" maybe not needed.\n\nWe must keep each step line as a line. Each line must have \"虛擬碼步驟\" + space + comment. So for loops we can produce separate lines. For loops we need to show loop body maybe. We need to keep readability.\n\nLet's produce.\n\nStart // 程式開始執行\n\n→ Class Solution // 定義解法類別\n\n→ Constructor(m, n) // 建構子：設定矩陣尺寸\n    → total ← m * n // 計算總格數\n    → remaining ← total // 可用格數初始為全部\n    → mapping ← array of size total // 建立映射陣列\n    → For i from 0 to total-1 // 初始化映射\n        → mapping[i] ← i // 每個索引映射到自己\n\n→ Method flip() // 隨機選取一個 0 並翻轉為 1\n    → idx ← randomInt(0, remaining-1) // 產生隨機位置\n    → val ← mapping[idx] // 真實格子編號\n    → mapping[idx] ← mapping[remaining-1] // 用最後一個映射覆蓋 idx\n    → remaining ← remaining - 1 // 可用格數減 1\n    → i ← val / n // 將一維索引轉為行\n    → j ← val % n // 將一維索引轉為列\n    → return [i, j] // 回傳選中的坐標\n\n→ Method reset() // 重置矩陣為全 0\n    → remaining ← total // 恢復可用格數\n    → For i from 0 to total-1 // 重新初始化映射\n        → mapping[i] ← i // 映射回自身\n\nEnd // 程式結束\n\nBut each line should be a single line with the virtual code step. We need to include the indentation or arrow for loops. Perhaps we can represent loops as:\n\n→ For i from 0 to total-1: // 迴圈\n    → mapping[i] ← i // 映射初始化\n\nBut the instruction: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So loops lines must contain the \"虛擬碼步驟\". For loops we need to have the line \"→ For i from 0 to total-1\" then next line with mapping. But they are separate lines. But that might be ambiguous. The example didn't include loops but included decisions with indent lines. The indentation may be optional. But the requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we can have loops using arrow \"→\" and maybe comment. We can have \"→ For i in 0..total-1\" line and then inside the loop we indent or just add arrow again? The example had only decisions. But we can create lines like:\n\n→ For i from 0 to total-1 // 迴圈：初始化映射\n    → mapping[i] ← i // 把映射指向自己\n\nBut each line must contain \"虛擬碼步驟\" and comment. So we can put the indentation or not. We can use \"    →\" or \"→\" again. For readability, we can indent with spaces.\n\nWe also need to specify randomInt call. We'll write \"idx ← randomInt(0, remaining-1)\". That's one random call. Good.\n\nThe mapping array will be of size total. Good.\n\nNow produce final answer with these lines. Ensure each line has comment after space. Use // for comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義解法類別  \n\n→ Constructor(m, n) // 建構子：設定矩陣尺寸  \n&nbsp;&nbsp;→ total ← m * n // 計算總格數  \n&nbsp;&nbsp;→ remaining ← total // 可用格數初始為全部  \n&nbsp;&nbsp;→ mapping ← array of size total // 建立映射陣列  \n&nbsp;&nbsp;→ For i from 0 to total-1 // 初始化映射陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ mapping[i] ← i // 每個索引映射到自己  \n\n→ Method flip() // 隨機選取一個 0 並翻轉為 1  \n&nbsp;&nbsp;→ idx ← randomInt(0, remaining-1) // 產生隨機位置（1 次隨機呼叫）  \n&nbsp;&nbsp;→ val ← mapping[idx] // 真實格子編號  \n&nbsp;&nbsp;→ mapping[idx] ← mapping[remaining-1] // 用最後一個映射覆蓋 idx  \n&nbsp;&nbsp;→ remaining ← remaining - 1 // 可用格數減 1  \n&nbsp;&nbsp;→ i ← val / n // 一維索引轉換為行  \n&nbsp;&nbsp;→ j ← val % n // 一維索引轉換為列  \n&nbsp;&nbsp;→ return [i, j] // 回傳選中的坐標  \n\n→ Method reset() // 重置矩陣為全 0  \n&nbsp;&nbsp;→ remaining ← total // 恢復可用格數  \n&nbsp;&nbsp;→ For i from 0 to total-1 // 重新初始化映射陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ mapping[i] ← i // 映射回自身  \n\nEnd // 程式結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all possible strings after removing the minimum number of\n        invalid parentheses to make the string valid.\n        \"\"\"\n        # 1. Count how many left and right parentheses need to be removed\n        lremove, rremove = 0, 0\n        for ch in s:\n            if ch == '(':\n                lremove += 1\n            elif ch == ')':\n                if lremove == 0:\n                    rremove += 1\n                else:\n                    lremove -= 1\n\n        result = set()  # use a set to avoid duplicates\n\n        def backtrack(index: int, left: int, lrem: int, rrem: int, path: str):\n            # 2. If we have processed all characters\n            if index == len(s):\n                if lrem == 0 and rrem == 0:\n                    result.add(path)\n                return\n\n            ch = s[index]\n\n            # 3. If the current character is a left parenthesis\n            if ch == '(':\n                # 3a. Option 1: remove it\n                if lrem > 0:\n                    backtrack(index + 1, left, lrem - 1, rrem, path)\n                # 3b. Option 2: keep it\n                backtrack(index + 1, left + 1, lrem, rrem, path + ch)\n\n            # 4. If the current character is a right parenthesis\n            elif ch == ')':\n                # 4a. Option 1: remove it\n                if rrem > 0:\n                    backtrack(index + 1, left, lrem, rrem - 1, path)\n                # 4b. Option 2: keep it only if there's a matching left\n                if left > 0:\n                    backtrack(index + 1, left - 1, lrem, rrem, path + ch)\n\n            # 5. If the current character is a letter, always keep it\n            else:\n                backtrack(index + 1, left, lrem, rrem, path + ch)\n\n        # 6. Kick off the recursion\n        backtrack(0, 0, lremove, rremove, \"\")\n\n        return list(result)\n\n\nif __name__ == \"__main__\":\n    # Read input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Handle possible \"s = \\\"...\\\"\" or \"s = '...'\" format\n    if \"=\" in raw_input:\n        _, value = raw_input.split(\"=\", 1)\n        raw_input = value.strip()\n    # Remove surrounding quotes if present\n    if (raw_input.startswith('\"') and raw_input.endswith('\"')) or \\\n       (raw_input.startswith(\"'\") and raw_input.endswith(\"'\")):\n        raw_input = raw_input[1:-1]\n\n    s = raw_input\n    sol = Solution()\n    outputs = sol.removeInvalidParentheses(s)\n    print(outputs)",
      "virtual_code": "Thinking...\nThe task: we need to output virtual code steps for the algorithm that removes minimum invalid parentheses to produce all valid strings. This is classic Leetcode 301. Approach: compute left/right counts to remove, then DFS backtracking generating results with pruning. Or BFS to find all minimal solutions. Use DFS with pruning. Steps: count lremove, rremove. Then backtrack function with index, left count, lremove, rremove, path, result. Skip duplicates by using set. At end add string. Complexity. So produce virtual code lines.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision: etc.\n\nLet's write high-level pseudocode: Start, compute counts, define backtrack, call, return results, End.\n\nInside backtrack: Decision: index == len(s)? then check remaining removals: if lremove==0 && rremove==0 -> add. Else return. Decision: current char is '('? then branch: remove it -> call with lremove-1. Keep it: call with left+1. Decision: char is ')'? branch: if left>0: keep -> left-1; remove -> rremove-1. Decision: char is letter: keep -> just append.\n\nAlso maintain path string. For pruning duplicate results, use set. But we can simply add to set.\n\nWe need to produce each step line.\n\nLet's craft pseudocode.\n\nWe need to use arrow for lines: \"Start // 程式開始執行\". Then arrow lines. Use \"→\" for sequence. For decision: indent.\n\nWe'll produce maybe 30-40 lines. Let's plan:\n\nStart\n→ Step 1: 計算需移除左括號 lremove 以及右括號 rremove // 透過遍歷 s\n→ Step 2: 定義空集合 result // 存放所有有效字串\n→ Step 3: 定義遞迴函式 backtrack(index, leftCount, lremove, rremove, path) // 探索所有合法組合\n→     Decision: 如果 index == s.length?\n→         Yes → Step 4: 如果 lremove==0 且 rremove==0? // 檢查是否已移除足夠\n→             Yes → Step 5: 加入 path 至 result // 成功方案\n→             No  → Step 6: 回傳 // 未滿足條件\n→         No  → Step 7: current = s.charAt(index) // 取得目前字元\n→             Decision: 如果 current == '('?\n→                 Yes → Step 8: 如果 lremove > 0? // 移除 '(' 的選項\n→                     Yes → backtrack(index+1, leftCount, lremove-1, rremove, path) // 跳過 '('\n→                     No  → // 不做\n→                 Yes → Step 9: 保留 '(' → backtrack(index+1, leftCount+1, lremove, rremove, path+'(')\n→             Decision: 如果 current == ')'?\n→                 Yes → Step 10: 如果 leftCount > 0? // 可以保留 ')'\n→                     Yes → backtrack(index+1, leftCount-1, lremove, rremove, path+')')\n→                     No  → // 不保留\n→                 Yes → Step 11: 如果 rremove > 0? // 移除 ')' 的選項\n→                     Yes → backtrack(index+1, leftCount, lremove, rremove-1, path)\n→                     No  → // 不做\n→             Decision: 否則 (字母)\n→                 Yes → Step 12: 保留字母 → backtrack(index+1, leftCount, lremove, rremove, path+current)\n→ Step 13: 呼叫 backtrack(0,0,lremove,rremove,\"\") // 開始遞迴\n→ Step 14: 返回 result // 結果集合\nEnd\n\nAdd comments. Ensure each line includes explanation. We'll output as per format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算需移除左括號 lremove 與右括號 rremove // 透過一次遍歷 s  \n→ Step 2: 定義空集合 result // 存放所有符合條件的有效字串  \n→ Step 3: 定義遞迴函式 backtrack(index, leftCount, lremove, rremove, path) // 探索所有合法組合  \n→     Decision: 如果 index == s.length()? // 到達字串結尾  \n→         Yes → Step 4: 如果 lremove==0 且 rremove==0? // 確認已移除足夠括號  \n→             Yes → Step 5: 加入 path 至 result // 成功方案，加入結果集合  \n→             No  → Step 6: 回傳 // 尚未滿足條件，直接回傳  \n→         No  → Step 7: current = s.charAt(index) // 取得目前字元  \n→             Decision: 如果 current == '('? // 遇到左括號  \n→                 Yes → Step 8: 如果 lremove > 0? // 有移除選項  \n→                     Yes → backtrack(index+1, leftCount, lremove-1, rremove, path) // 跳過 '('  \n→                     No  → // 不做任何事  \n→                 Yes → Step 9: 保留 '(' → backtrack(index+1, leftCount+1, lremove, rremove, path+'(') // 保留左括號  \n→             Decision: 如果 current == ')'? // 遇到右括號  \n→                 Yes → Step 10: 如果 leftCount > 0? // 可以配對右括號  \n→                     Yes → backtrack(index+1, leftCount-1, lremove, rremove, path+')') // 保留右括號  \n→                     No  → // 無法配對，跳過此分支  \n→                 Yes → Step 11: 如果 rremove > 0? // 有移除選項  \n→                     Yes → backtrack(index+1, leftCount, lremove, rremove-1, path) // 跳過 ')'  \n→                     No  → // 不做任何事  \n→             Decision: 否則 (字母)  \n→                 Yes → Step 12: 保留字母 → backtrack(index+1, leftCount, lremove, rremove, path+current) // 加入字母  \n→ Step 13: 呼叫 backtrack(0,0,lremove,rremove,\"\") // 從字串起始處開始遞迴  \n→ Step 14: 返回 result // 將所有有效字串輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnqdj3znu.py\", line 39, in <module>\n    data = parse_input(sys.stdin.read().strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnqdj3znu.py\", line 36, in parse_input\n    return ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x79b833cf7a90>"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8gy9hxbc.py\", line 39, in <module>\n    data = parse_input(sys.stdin.read().strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8gy9hxbc.py\", line 36, in parse_input\n    return ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7512148f7a90>"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\nimport ast\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return 0\n\n        queue = deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        word_set.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(raw):\n    \"\"\"\n    將輸入字串轉成 dict，例如：\n    'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]'\n    會轉成 {'beginWord': 'hit', 'endWord': 'cog', 'wordList': ['hot', 'dot']}\n    \"\"\"\n    # 替換成 dict 風格\n    raw = raw.replace('beginWord =', 'beginWord:')\n    raw = raw.replace('endWord =', 'endWord:')\n    raw = raw.replace('wordList =', 'wordList:')\n    raw = '{' + raw + '}'\n    # 用 ast.literal_eval 解析安全\n    return ast.literal_eval(raw)\n\nif __name__ == \"__main__\":\n    data = parse_input(sys.stdin.read().strip())\n    begin = data['beginWord']\n    end = data['endWord']\n    lst = data['wordList']\n    result = Solution().ladderLength(begin, end, lst)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for BFS shortest transformation sequence count. Steps: start, check if endWord in list, create set for words, BFS queue with (word, level), visited, while queue not empty, pop, if word == endWord return level, for each letter position generate all possible letters a-z, if newWord in set and not visited, enqueue newWord level+1, mark visited. After loop return 0. Use decision structures. Must use virtual code format: each line: \"Step\" or \"Decision:\" etc. Use arrows. Provide explanation after //.\n\nLet's craft step by step. Use Start, End. Use Decision nodes for if endWord not in list, etc. Use BFS queue.\n\nWe'll produce lines:\n\nStart // 程式開始\n→ Decision: 若 endWord 不在 wordList? // 檢查終點是否存在\n    Yes → Step 1: 回傳 0 // 無法轉換\n    No  → Step 2: 初始化 wordsSet ← wordList, visitedSet ← {}, queue ← [(beginWord, 1)] // 建立集合與佇列\n→ Step 3: While queue 非空? // 開始 BFS\n    Yes → Step 4: (currentWord, depth) ← queue.pop_front() // 取出當前單詞與深度\n    → Decision: 若 currentWord == endWord? // 是否到達終點\n        Yes → Step 5: 回傳 depth // 找到最短路徑長度\n        No  → Step 6: For each position i in currentWord  // 逐字母生成鄰居\n            → Step 7: For each letter c in 'a'..'z'\n                → Decision: 若 newWord ≠ currentWord 且 newWord 在 wordsSet 且未訪問? // 選擇合法鄰居\n                    Yes → Step 8: queue.push_back((newWord, depth+1)) // 加入佇列\n                    Yes → visitedSet.add(newWord) // 標記已訪問\n    → No → End // BFS 結束未找到終點\nEnd // 程式結束\n\nNeed to ensure syntax with arrow, decision etc.\n\nMake sure each line has virtual code step + space + // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Decision: 若 endWord 不在 wordList? // 檢查終點是否存在於字典  \n Yes → Step 1: 回傳 0 // 無法轉換，直接結束  \n No  → Step 2: 初始化 wordsSet ← wordList, visitedSet ← {}, queue ← [(beginWord, 1)] // 建立字典集合、已訪問集合與 BFS 佇列  \n→ Step 3: While queue 非空? // 開始 BFS 迴圈  \n Yes → Step 4: (currentWord, depth) ← queue.pop_front() // 取出佇列首元素  \n  → Decision: 若 currentWord == endWord? // 是否已達終點  \n   Yes → Step 5: 回傳 depth // 找到最短轉換序列長度  \n   No  → Step 6: For each position i in currentWord // 逐字母生成鄰居單詞  \n    → Step 7: For each letter c in 'a'..'z'  \n     → Decision: 若 newWord ≠ currentWord 且 newWord 在 wordsSet 且未訪問? // 選擇合法鄰居  \n      Yes → Step 8: queue.push_back((newWord, depth+1)) // 加入佇列  \n      Yes → visitedSet.add(newWord) // 標記已訪問  \n No  → End // BFS 結束未找到終點  \nEnd // 程式結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        \"\"\"Return all unique subsets of nums, which may contain duplicates.\"\"\"\n        nums.sort()                     # 先排序，方便後續去重\n        res = [[]]                      # 初始子集集合\n        for num in nums:                # 對每個元素進行擴張\n            new_subsets = []\n            for subset in res:\n                new_subsets.append(subset + [num])\n            res += new_subsets\n        # 去除重複子集\n        seen = set()\n        unique = []\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique.append(subset)\n        return unique\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，格式預期為「nums = [1,2,2]」或直接是列表字面量\n    try:\n        _, expr = data.split('=', 1)\n    except ValueError:\n        expr = data\n    expr = expr.strip()\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = eval(expr, {})\n    sol = Solution()\n    result = sol.subsetsWithDup(nums)\n    # 產生不含空格的子集字串表示，符合範例輸出格式\n    subsets_str = []\n    for subset in result:\n        subset_str = '[' + ','.join(str(x) for x in subset) + ']'\n        subsets_str.append(subset_str)\n    output = '[' + ','.join(subsets_str) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating power set with duplicates removal. Should be iterative/backtracking? We need to output steps line by line. The format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow, decision. For duplicates, we sort and skip duplicates.\n\nLet's craft. We'll include steps: Start, sort array, define result list, define helper recursion. In recursion, add current subset to result, loop from start index to end, skip duplicates if nums[i]==nums[i-1] and i>start. Add nums[i] to subset, recurse with i+1, then pop.\n\nLet's produce lines accordingly. Ensure arrow usage: \"→ Step X: ...\" Use \"Decision:\" lines for if condition.\n\nWe need to list each line as separate. Let's count.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續跳過重複項目\n→ Step 2: 初始化 result 為空集合 // 用於儲存所有子集\n→ Step 3: 初始化空子集 current // 當前正在構造的子集\n→ Step 4: 定義遞迴函數 backtrack(start) // 用於產生子集\n    → Step 5: Add copy of current to result // 將目前子集加入結果\n    → Decision: 是否已到陣列結尾? // 檢查是否還有元素可選\n        Yes → Return // 若已結束，回到上一層\n        No  → \n            → For i from start to len(nums)-1 // 遍歷剩餘元素\n                → Decision: i>start AND nums[i]==nums[i-1]? // 檢查是否為重複項且非首位\n                    Yes → Continue // 跳過重複項\n                    No  → \n                        → Step 6: current.append(nums[i]) // 加入元素到子集\n                        → Step 7: backtrack(i+1) // 以下一個位置為起點遞迴\n                        → Step 8: current.pop() // 移除最後加入的元素，回溯\n→ Step 9: 呼叫 backtrack(0) // 從索引 0 開始遞迴\n→ Step 10: 返回 result // 回傳所有子集\n\nEnd // 程式執行結束\n\nBut we need arrow and indentation. Use \"→\" at each line. For nested lines, indent accordingly. Use \"Decision:\" line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續跳過重複項目\n→ Step 2: 初始化 result 為空集合 // 用於儲存所有子集\n→ Step 3: 初始化空子集 current // 當前正在構造的子集\n→ Step 4: 定義遞迴函數 backtrack(start) // 用於產生子集\n    → Step 5: Add copy of current to result // 將目前子集加入結果\n    → Decision: 是否已到陣列結尾? // 檢查是否還有元素可選\n        Yes → Return // 若已結束，回到上一層\n        No  →\n            → For i from start to len(nums)-1 // 遍歷剩餘元素\n                → Decision: i>start AND nums[i]==nums[i-1]? // 檢查是否為重複項且非首位\n                    Yes → Continue // 跳過重複項\n                    No  →\n                        → Step 6: current.append(nums[i]) // 加入元素到子集\n                        → Step 7: backtrack(i+1) // 以下一個位置為起點遞迴\n                        → Step 8: current.pop() // 移除最後加入的元素，回溯\n→ Step 9: 呼叫 backtrack(0) // 從索引 0 開始遞迴\n→ Step 10: 返回 result // 回傳所有子集\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出最長的不常見子序列長度\n        只要存在一個在陣列中只出現一次的字串，答案即為那個字串的長度\n        若全部字串都有重複，則不存在不常見子序列，回傳 -1\n        \"\"\"\n        if not strs:\n            return -1\n\n        freq = Counter(strs)\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1:\n                max_len = max(max_len, len(s))\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取 JSON 格式的字串陣列\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n        sys.exit()\n    try:\n        strs = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 如果輸入不是合法 JSON，視為無法處理\n        print(-1)\n        sys.exit()\n\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Let's think algorithm: longest uncommon subsequence length between array of strings.\n\nWe can recall known problem: longest uncommon subsequence II. The answer is length of the longest string that is not equal to any other string in the array. Because if a string is unique, it can't be subsequence of any other longer string? Wait: The known solution: if there is any string that is unique, answer is its length; else -1. Because if string appears at least twice, any subsequence of it appears in both; thus cannot be uncommon. And any unique string cannot be a subsequence of other longer string if it's longer than them? Actually if it's longer than others, cannot be subsequence. But if unique but shorter, it might still be subsequence of longer string. However we can pick the longest unique string: Since any longer string unique will be the longest. So answer is length of longest string that appears exactly once; if none, -1.\n\nThus algorithm: count frequencies of each string. Find max length among strings with freq 1. If none, return -1.\n\nLet's produce virtual code with steps. We'll show Start, Step 1: count frequencies; Step 2: iterate array to find max length unique; Step 3: if max==0 return -1 else max.\n\nInclude decision. Also handle empty array? Not necessary.\n\nNow produce steps with arrows. Each line with explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq 用來計數每個字串出現次數 // 準備統計字串頻率  \n→ Decision: 是否有字串需要處理?  \n Yes → Step 2: 對於每個字串 s 在 strs 中  \n     freq[s] ← freq.get(s, 0) + 1 // 更新該字串的頻率  \n     End  \n     → Step 3: 設定 maxLen ← -1 // 目前最佳不常見子序列長度  \n     → Decision: 迭代每個字串 s 在 strs 中  \n      Yes → Decision: freq[s] 等於 1? // 只考慮唯一出現的字串  \n        Yes → Decision: len(s) 大於 maxLen?  \n          Yes → maxLen ← len(s) // 更新更長的唯一字串長度  \n          No  → Step 4: 跳過 // 字串已較短  \n        No  → Step 5: 跳過 // 非唯一字串不可能是不常見子序列  \n      No → End  \n     → Decision: maxLen 為 -1? // 無唯一字串  \n       Yes → Step 6: 回傳 -1 // 不存在不常見子序列  \n       No  → Step 7: 回傳 maxLen // 回傳長度最大唯一字串  \n     No → End  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the string inside quotes after \"s = \"\n    first_quote = data.find(\"'\")\n    if first_quote == -1:\n        first_quote = data.find('\"')\n    last_quote = data.rfind(\"'\") if data.rfind(\"'\") != -1 else data.rfind('\"')\n    if first_quote == -1 or last_quote == -1 or last_quote <= first_quote:\n        s = \"\"\n    else:\n        s = data[first_quote+1:last_quote]\n    result = Solution().findRepeatedDnaSequences(s)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines step by step for problem: find all 10-letter-long substrings that appear more than once in a given string s. Classic Leetcode 187: DNA Sequencing. Approach: sliding window of length 10, use hash map to count occurrences, collect those >1. Complexity O(n). Also can optimize using bit encoding. But we just produce pseudo-code. We'll produce Start, Step: input string, Step: create dictionary counts, Step: loop over i from 0 to len(s)-10, extract substring s[i:i+10], update map, Step: after loop, collect keys with count>1, Step: return result. End.\n\nWe need arrow and decisions? We can use Decision: if count==1? But we can do simple. Provide each line with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s)-10 inclusive // 遍歷所有 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: 如果 seq 已存在於 counts?\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Decision: For each key in counts\n        Yes → Decision: 如果 counts[key] > 1 ?\n            Yes → result.append(key) // 加入結果\n→ Step 6: Return result // 回傳所有重複的 10 字元子字串\nEnd\n\nBut we need each line separately. We can indent decisions with arrow. Provide only one line per step. So we need to list each line: e.g., \"Start // 程式開始執行\". Then each line. For decisions we include the \"Decision:\" line and then indented \"Yes →\" etc. Each indented line still separate lines.\n\nWe must use the same formatting as example: \"→ Step 1: ...\" etc. So we will produce:\n\nStart // 程式開始執行\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s) - 10 // 遍歷所有可能的 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: seq 已存在於 counts? // 判斷是否已在字典中\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Decision: 是否有 key 在 counts? // 遍歷所有鍵\n        Yes → Decision: counts[key] > 1? // 判斷是否重複\n            Yes → result.append(key) // 加入結果\n→ Step 6: Return result // 回傳所有重複的 10 字元子字串\nEnd // 程式執行結束\n\nBut \"Decision: 是否有 key 在 counts?\" not necessary; we can just loop. But we can keep simple. Might better to represent loop separately: \"→ Step 5: For each key in counts\" then inside decide >1. Let's do:\n\nStart // 程式開始執行\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s)-10 // 遍歷所有可能的 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: seq 已存在於 counts? // 判斷是否已在字典中\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Step 6: For each key in counts // 遍歷所有鍵\n    → Decision: counts[key] > 1? // 判斷是否重複\n        Yes → result.append(key) // 加入結果\n→ Step 7: Return result // 回傳所有重複的 10 字元子字串\nEnd // 程式執行結束\n\nThis meets format: each line starts with \"→\" or \"Start\". Indent for decisions lines. Provide arrow and comment.\n\nMake sure to use \"Yes →\" and \"No →\" with spaces. Provide explanation after //. Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s)-10 // 遍歷所有可能的 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: seq 已存在於 counts? // 判斷是否已在字典中\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Step 6: For each key in counts // 遍歷所有鍵\n    → Decision: counts[key] > 1? // 判斷是否重複\n        Yes → result.append(key) // 加入結果\n→ Step 7: Return result // 回傳所有重複的 10 字元子字串\nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"Return all permutations of a list of distinct integers.\"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                # Found a complete permutation; add a copy to the result\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                # Swap the current index with the iterator index\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # Backtrack: restore the original order\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part from a string like \"nums = [1,2,3]\"\n    start_bracket = data.find('[')\n    end_bracket = data.rfind(']')\n    if start_bracket == -1 or end_bracket == -1 or start_bracket > end_bracket:\n        # If the input is just a list representation, use it directly\n        nums_str = data\n    else:\n        nums_str = data[start_bracket:end_bracket + 1]\n\n    # Safely evaluate the list string into a Python list\n    nums = ast.literal_eval(nums_str)\n\n    # Compute permutations using the Solution class\n    solution = Solution()\n    permutations = solution.permute(nums)\n\n    # Print the result as a Python list of lists\n    print(permutations)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all permutations of an array of distinct integers. We need to produce step-by-step with Start, End, Decision, etc.\n\nWe should give steps like: Start, read array, call recursive function permute(index). In recursion, if index == length then add copy to result. Else loop over i from index to length-1, swap arr[index] with arr[i], recurse index+1, swap back.\n\nWe should use virtual code steps like \"→ Step 1: 初始化結果清單\" etc. Provide explanation comment after //.\n\nWe must ensure each line is a step with \"→\" prefix, maybe indentation for decisions.\n\nAlso we must not output actual code, only virtual code.\n\nLet's craft.\n\nStructure:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 nums // 取得使用者提供的整數陣列\n→ Step 2: 建立空結果清單 res // 用於儲存所有排列\n→ Step 3: 呼叫遞迴函式 permute(nums, 0, res) // 從索引 0 開始生成排列\n\nDefine permute function:\n\n→ Function permute(arr, idx, res) // arr 為當前排列，idx 為固定位置，res 存放結果\n    → Decision: idx 是否等於 arr.length? // 判斷是否已固定所有元素\n        Yes → Step 4: 把 arr 的拷貝加入 res // 完整排列，加入結果\n        No  → Step 5: for i from idx to arr.length-1 // 遍歷剩餘未固定元素\n            → Step 6: 交換 arr[idx] 與 arr[i] // 將第 i 個元素放到固定位置\n            → Step 7: 呼叫 permute(arr, idx+1, res) // 進一步固定下一個位置\n            → Step 8: 交換回 arr[idx] 與 arr[i] // 回溯，恢復原始順序\n    → End // permute 函式結束\n\n→ End // 程式執行結束\n\nBut we need to maintain proper indentation and arrow usage. Possibly each step under permute should have indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 nums // 取得使用者提供的整數陣列  \n→ Step 2: 建立空結果清單 res // 用於儲存所有排列  \n→ Step 3: 呼叫遞迴函式 permute(nums, 0, res) // 從索引 0 開始生成排列  \n\nFunction permute(arr, idx, res) // arr 為當前排列，idx 為固定位置，res 存放結果  \n    → Decision: idx 是否等於 arr.length? // 判斷是否已固定所有元素  \n        Yes → Step 4: 把 arr 的拷貝加入 res // 完整排列，加入結果  \n        No  → Step 5: for i from idx to arr.length-1 // 遍歷剩餘未固定元素  \n            → Step 6: 交換 arr[idx] 與 arr[i] // 將第 i 個元素放到固定位置  \n            → Step 7: 呼叫 permute(arr, idx+1, res) // 進一步固定下一個位置  \n            → Step 8: 交換回 arr[idx] 與 arr[i] // 回溯，恢復原始順序  \n    → End // permute 函式結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表，允許重複\n        self.data = []\n        # value -> set of indices 在 data 中該值出現的位置\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        將 val 插入集合。\n        若 val 為首次插入，回傳 True；若已有，回傳 False。\n        \"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此 value 現在只有一個索引，代表首次插入\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        移除集合中一個 val（若存在）。\n        成功移除返回 True，否則返回 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取要移除的索引\n        remove_idx = self.idx_map[val].pop()\n        # 取最後一個元素\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 把最後一個元素放到要移除的位置\n        self.data[remove_idx] = last_val\n        # 更新索引映射\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 從列表中刪除最後一個元素\n        self.data.pop()\n\n        # 若此 value 不再存在，清除其映射\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回集合中的一個元素，概率與其出現頻率成正比。\n        \"\"\"\n        return random.choice(self.data)\n\ndef _format_output(res):\n    \"\"\"將結果列表轉成符合 LeetCode 輸出格式的字串。\"\"\"\n    out = []\n    for v in res:\n        if v is None:\n            out.append('null')\n        elif isinstance(v, bool):\n            out.append('true' if v else 'false')\n        else:\n            out.append(str(v))\n    return '[' + ', '.join(out) + ']'\n\ndef main():\n    # 讀取整個輸入，並把它包成一個外層列表後做 literal_eval\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    try:\n        data = ast.literal_eval('[' + raw + ']')\n    except Exception as e:\n        # 若輸入格式不符合預期，直接退出\n        return\n\n    ops, args = data[0], data[1]\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            result.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(obj.getRandom())\n    print(_format_output(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. It's like algorithm steps. We'll outline data structures: vector for values, unordered_map val->unordered_set indices. Then methods insert, remove, getRandom. Provide steps. Use virtual code syntax: Start, Step, Decision, Yes→, No→, End. Each line: virtual code step + // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 empty vector values // 存放所有元素的動態陣列\n→ Step 2: 初始化空映射 idxMap: value → set of indices // 追蹤每個值在 values 中的索引位置\n→ Step 3: 初始化隨機數生成器 rng // 用於 getRandom\n\n// ---------- insert ----------\n→ Step 4: Decision: insert(val) 是否執行？ // 進入 insert 方法\n    → Step 5: 把 val 加到 values 的尾部，記錄 index = values.size() - 1 // 新元素加入\n    → Step 6: 把 index 加入 idxMap[val] 的集合 // 更新索引映射\n    → Step 7: Decision: val 之前是否存在？ // 判斷是否為首次插入\n        Yes → Step 8: 返回 false // 已存在，回傳 false\n        No  → Step 9: 返回 true  // 第一次插入，回傳 true\n\n// ---------- remove ----------\n→ Step 10: Decision: remove(val) 是否執行？ // 進入 remove 方法\n    → Step 11: Decision: val 是否存在於 idxMap？ // 檢查是否有可移除的元素\n        Yes → Step 12: 取 idxMap[val] 中任一 indexToRemove // 隨機選擇一個待刪索引\n        No  → Step 13: 返回 false // 沒有此值，回傳 false\n\n        // 下面為 val 存在的情況\n        → Step 14: 取得 values 的最後一個元素 lastVal = values.back() // 準備交換\n        → Step 15: 取得最後一個元素的索引 lastIndex = values.size() - 1 // 為後續操作做準備\n        → Step 16: 把 lastVal 的索引集合中 lastIndex 的位置，改為 indexToRemove // 交換索引\n        → Step 17: 把 values[indexToRemove] 設為 lastVal // 交換實際值\n        → Step 18: 從 idxMap[val] 刪除 indexToRemove // 移除被刪元素的索引\n        → Step 19: Decision: indexToRemove == lastIndex? // 檢查是否刪除的是最後一個元素\n            Yes → Step 20: 從 idxMap[val] 刪除 lastIndex // 只需移除最後索引\n            No  → Step 21: 也從 idxMap[lastVal] 中刪除 lastIndex // 需要同步更新 lastVal 的索引\n        → Step 22: 從 values 刪除最後一個元素 // 真正刪除元素\n        → Step 23: Decision: idxMap[val] 是否為空？ // 若 val 已無任何索引\n            Yes → Step 24: 從 idxMap 刪除 val // 清理映射\n            No  → Step 25: 留下 idxMap[val] // 保持現有映射\n        → Step 26: 返回 true // 成功移除\n\n// ---------- getRandom ----------\n→ Step 27: Decision: getRandom() 是否執行？ // 進入 getRandom 方法\n    → Step 28: 產生隨機整數 randIdx ∈ [0, values.size() - 1] using rng // 隨機索引\n    → Step 29: 返回 values[randIdx] // 取得隨機元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1g9cxjkx.py\", line 46, in <module>\n    result = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1g9cxjkx.py\", line 11, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn4si37p2.py\", line 46, in <module>\n    result = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn4si37p2.py\", line 11, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged newInterval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(raw):\n    # Extract the part after \"intervals =\" and before \"newInterval =\"\n    parts = raw.split('newInterval =')\n    intervals_str = parts[0].replace('intervals =', '').strip()\n    new_interval_str = parts[1].strip()\n    intervals = ast.literal_eval(intervals_str)\n    new_interval = ast.literal_eval(new_interval_str)\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    intervals, new_interval = parse_input(raw_input)\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudo-code steps. Provide lines with arrow and explanation. No actual code. Steps: Start, initialize result list, iterate intervals, compare positions, add before, merge, etc. Use decision arrows. Ensure each line has virtual code and comment. Provide a step-by-step approach. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的結果陣列 result // 用來儲存最終合併後的區間\n→ Step 2: 初始化指標 i = 0 // 用於遍歷原始 intervals\n→ Decision: 是否已到達 intervals 結尾? // 檢查是否還有區間需要處理\n    No  → Decision: intervals[i].end < newInterval.start? // 當前區間完全在新區間之前\n        Yes → Step 3: result.add(intervals[i]) // 直接加入結果，因為不會覆蓋\n        No  → Decision: intervals[i].start > newInterval.end? // 當前區間完全在新區間之後\n            Yes → Step 4: result.add(newInterval) // 新區間先加入\n            No  → Step 5: newInterval.start = min(intervals[i].start, newInterval.start) // 合併區間開始點\n                    newInterval.end = max(intervals[i].end, newInterval.end) // 合併區間結束點\n    No  → Step 6: i = i + 1 // 移動到下一個區間\n    Yes → Decision: result 是否已包含 newInterval? // 判斷是否已把新區間加入結果\n        No  → Step 7: result.add(newInterval) // 若還沒加入，將新區間加入\n→ Step 8: 返回 result // 完成合併並返回結果\nEnd // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx76fkdz5.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpx76fkdz5.py\", line 49, in main\n    cache.put(*arg)\n    ^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'put'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"Least Recently Used (LRU) cache implementation.\"\"\"\n    def __init__(self, capacity: int):\n        # OrderedDict keeps the insertion order; newest items will be moved to the end.\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        \"\"\"Return the value of the key if present, otherwise -1.\n        Move the key to the end to mark it as recently used.\"\"\"\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # re-insert to end\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"Insert or update the key with the given value.\n        If capacity exceeded, evict the least recently used item.\"\"\"\n        if key in self.cache:\n            self.cache.pop(key)          # remove old entry\n        self.cache[key] = value         # insert at end (most recent)\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove LRU (first item)\n\ndef main() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Split the input into two parts: operations and arguments\n    parts = raw.split('],', 1)\n    ops_part = parts[0] + ']'        # close the first list\n    args_part = parts[1]            # already a list of lists\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    cache = None\n    results = [None]  # constructor yields null\n\n    for i in range(1, len(ops)):\n        op = ops[i]\n        arg = args[i]\n        if op == 'put':\n            cache.put(*arg)\n            results.append(None)\n        elif op == 'get':\n            val = cache.get(*arg)\n            results.append(val)\n\n    # Use json.dumps to produce 'null' for None\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanations. It's for design of LRU cache. We should outline initialization, get, put, internal data structures. Use Start, Decision, etc. Provide each line.\n\nWe need to reflect O(1) operations: using a hashmap for key->node, and a doubly linked list for usage order. We'll provide steps: create Node, doubly linked list, map, capacity. In get: check map, if not exist return -1; else move node to front, return value. In put: if key exists, update value and move to front; else create new node, add to front; add to map; if size > capacity, remove tail, delete from map.\n\nWe'll produce virtual steps. We must not output actual code, just pseudo steps.\n\nWe need to follow format: each line: `虛擬碼步驟 // 解釋`. Use arrow `→` etc.\n\nLet's produce.\n\nWe might separate the overall algorithm into phases: initialization, get, put. Each with steps.\n\nAlso include decisions like \"if key exists\" etc.\n\nLet's start: `Start // 程式開始執行`. Then initialization of class.\n\nWe can show steps:\n\n`→ Initialize LRUCache(capacity)` etc.\n\nBetter to structure: The overall program: define LRUCache class with constructor, get, put. We'll list steps within each.\n\nBut the requirement: \"逐行地產生對應的虛擬碼\" So each line is one step. We'll show steps for constructor, get, put.\n\nWe may include nested decision branches.\n\nLet's produce lines:\n\n1 Start\n2 Initialize class with capacity\n3 Create hash map: key->node\n4 Create doubly linked list with dummy head and tail\n5 Set size to 0\nEnd constructor.\n\nBut we can break.\n\nLet's create:\n\nStart // 程式開始執行\n\n→ Step: 建立 LRUCache 類別實例 // 初始化類別\n\n→ Step: 儲存 capacity // 存入容量限制\n\n→ Step: 建立 HashMap keyToNode // 用於 O(1) 取值\n\n→ Step: 建立雙向鏈表 head, tail (dummy nodes) // 方便插入/刪除\n\n→ Step: 連接 head → tail // 初始空表\n\n→ Step: size ← 0 // 記錄目前元素數量\n\nEnd // 建構完成\n\nThen get method:\n\n→ Step: Define get(key) // 方法入口\n\n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否存在\n\n    Yes → Step: node ← keyToNode[key] // 取得節點\n\n    → Step: Move node 到 head (最前) // 更新最近使用\n\n    → Step: Return node.value // 返回對應值\n\n    No  → Step: Return -1 // 鍵不存在\n\nThen put method:\n\n→ Step: Define put(key, value) // 方法入口\n\n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否已存在\n\n    Yes → Step: node ← keyToNode[key] // 取得節點\n\n    → Step: node.value ← value // 更新值\n\n    → Step: Move node 到 head // 更新最近使用\n\n    No  → Step: Create new node with key, value // 新節點\n\n        → Step: Insert node after head // 加入最前\n\n        → Step: keyToNode[key] ← node // 加入 map\n\n        → Step: size ← size + 1 // 增加計數\n\n        → Decision: 若 size > capacity? // 檢查是否超過容量\n\n            Yes → Step: tailPrev ← tail.prev // 取最舊節點\n\n            → Step: Remove tailPrev from list // 刪除節點\n\n            → Step: Remove tailPrev.key from keyToNode // 從 map 刪除\n\n            → Step: size ← size - 1 // 重新計數\n\n            No  → End // 仍在容量內\n\nEnd // 方法結束\n\nWe need to include all lines. We'll use `Start`, `End` for methods maybe.\n\nBut requirement: \"逐行輸出\" each line with `虛擬碼步驟 // 解釋`. So each line we output. Let's produce them.\n\nEnsure we use `→` arrow for steps, and `Decision:` for if statements, with nested branches Yes → ... No → ... etc.\n\nAlso we must maintain consistent formatting: no actual code.\n\nWe'll output.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立 LRUCache 類別實例 // 初始化類別  \n→ Step: 儲存 capacity 值 // 記錄容量上限  \n→ Step: 建立 HashMap keyToNode // 用於 O(1) 取得節點  \n→ Step: 建立雙向鏈表 dummy head 與 dummy tail // 方便插入與刪除  \n→ Step: 連接 head → tail // 初始空表  \n→ Step: size ← 0 // 記錄目前元素數量  \nEnd // 建構完成  \n\n// ==========================  \n// get 方法  \n// ==========================  \nStart // get 方法開始執行  \n→ Step: 定義 get(key) // 方法入口  \n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否存在  \n    Yes → Step: node ← keyToNode[key] // 取得節點  \n    → Step: Move node 至 head（最前） // 更新最近使用  \n    → Step: Return node.value // 返回對應值  \n    No  → Step: Return -1 // 鍵不存在  \nEnd // get 方法結束  \n\n// ==========================  \n// put 方法  \n// ==========================  \nStart // put 方法開始執行  \n→ Step: 定義 put(key, value) // 方法入口  \n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否已存在  \n    Yes → Step: node ← keyToNode[key] // 取得節點  \n    → Step: node.value ← value // 更新值  \n    → Step: Move node 至 head（最前） // 更新最近使用  \n    No  → Step: 創建新節點 node(key, value) // 新節點  \n        → Step: Insert node 之後 head // 加入最前  \n        → Step: keyToNode[key] ← node // 加入 map  \n        → Step: size ← size + 1 // 计数增一  \n        → Decision: 若 size > capacity? // 檢查是否超過容量  \n            Yes → Step: tailPrev ← tail.prev // 取得最舊節點  \n            → Step: Remove tailPrev 從雙向鏈表 // 刪除節點  \n            → Step: Remove tailPrev.key 從 keyToNode // 從 map 刪除  \n            → Step: size ← size - 1 // 计数减一  \n            No  → End // 仍在容量內  \n        No  → End // 仍在容量內  \nEnd // put 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4uo56vao.py\", line 38, in <module>\n    matrix = ast.literal_eval(mat_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,5,9]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjejq987h.py\", line 38, in <module>\n    matrix = ast.literal_eval(mat_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[-5]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        low = matrix[0][0]\n        high = matrix[n - 1][n - 1]\n\n        while low < high:\n            mid = low + (high - low) // 2\n            count = 0\n            i = n - 1\n            j = 0\n            # count elements <= mid\n            while i >= 0 and j < n:\n                if matrix[i][j] <= mid:\n                    count += i + 1\n                    j += 1\n                else:\n                    i -= 1\n            # decide next search interval\n            if count >= k:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\nif __name__ == \"__main__\":\n    # Read all input\n    data = sys.stdin.read().strip()\n    # Extract matrix and k using regular expressions\n    mat_match = re.search(r'matrix\\s*=\\s*(\\[.*?\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not mat_match or not k_match:\n        sys.exit(\"Invalid input format.\")\n    matrix = ast.literal_eval(mat_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.kthSmallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find kth smallest in sorted matrix. Classic solution: binary search on value range, count elements <= mid by scanning rows from bottom-left or using binary search per row. Complexity O(n log(range)). Or use min-heap O(k log n). But memory O(n). We need better than O(n^2). Provide steps.\n\nWe will produce virtual code using Start, End, Decision, Step, etc. Each line with explanation.\n\nLet's create algorithm: binary search.\n\nPseudo:\n\nStart\n→ Set low = matrix[0][0]\n→ Set high = matrix[n-1][n-1]\n→ While low < high\n    → mid = low + (high - low) // 2\n    → count = 0\n    → i = n-1; j = 0\n    → While i >= 0 and j < n\n        → If matrix[i][j] <= mid\n            → count += i+1\n            → j += 1\n        → Else\n            → i -= 1\n    → Decision: If count >= k?\n        Yes → high = mid\n        No  → low = mid + 1\n→ Step: Return low\nEnd\n\nWe must add explanation after each line.\n\nMake sure to use arrow and indentation for decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: low ← matrix[0][0] // 設定搜尋區間左端為矩陣最小值  \n→ Step: high ← matrix[n-1][n-1] // 設定搜尋區間右端為矩陣最大值  \n→ Decision: low < high? // 只要搜尋區間未縮小到單一值，就持續迴圈  \n    Yes → Step: mid ← low + (high - low) / 2 // 取搜尋區間中點作為判斷值  \n    → Step: count ← 0 // 初始化計數器，用於統計 ≤ mid 的元素數量  \n    → Step: i ← n-1 // 從最後一行開始  \n    → Step: j ← 0 // 從第一列開始  \n    → While i ≥ 0 且 j < n  \n        → Decision: matrix[i][j] ≤ mid? // 判斷當前元素是否 ≤ mid  \n            Yes → Step: count ← count + i + 1 // 所有在第 i 行左側的元素都 ≤ mid  \n            → Step: j ← j + 1 // 移到下一列  \n            No → Step: i ← i - 1 // 移到上一行  \n    → Decision: count ≥ k? // 根據計數判斷 k 號小於等於 mid  \n        Yes → Step: high ← mid // 若足夠多，縮小搜尋區間至左半邊  \n        No  → Step: low ← mid + 1 // 若不足，縮小搜尋區間至右半邊  \n→ Step: Return low // low 代表第 k 小的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppduw_bfu.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmppduw_bfu.py\", line 37, in main\n    result.append(kth_obj.add(arg))\n                  ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppduw_bfu.py\", line 13, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdqbbxlxj.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmpdqbbxlxj.py\", line 37, in main\n    result.append(kth_obj.add(arg))\n                  ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdqbbxlxj.py\", line 13, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n    # Wrap input into a tuple to parse as a Python literal\n    try:\n        data = ast.literal_eval('(' + data_str + ')')\n    except Exception:\n        # Fallback: try direct evaluation if already a tuple\n        data = ast.literal_eval(data_str)\n    ops, args = data[0], data[1]\n\n    result = []\n    kth_obj = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            kth_obj = KthLargest(arg[0], arg[1])\n            result.append(None)\n        elif op == \"add\":\n            result.append(kth_obj.add(arg))\n\n    # Format output with 'null' for None\n    output = '[' + ', '.join('null' if x is None else str(x) for x in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps. For a class that maintains kth largest using min-heap of size k. Steps: init with k and array; build heap of first k numbers; then for each remaining number > smallest, replace; add method: insert val into heap, maybe pop if size>k; return heap.peek. Provide step-by-step.\n\nWe must output each line with virtual code and comment. Use arrow notation. Provide Start, End.\n\nLet's create pseudo-code for class KthLargest with constructor and add method. Also need to maintain heap. Use steps.\n\nWe need to show initialization: Start, Step 1: Initialize k and empty min-heap, Step 2: For each number in nums: add to heap via addNumber function, but if heap size > k pop smallest. Step 3: Store heap. End of init.\n\nAdd method: Step 1: Insert val into heap, Step 2: If heap size > k, pop smallest, Step 3: Return heap.peek (kth largest). End.\n\nAlso need to define addNumber used in init.\n\nLet's produce pseudo-code with arrows. Each line should be \"虛擬碼步驟 // 解釋\". Use \"→\" to denote next step. Use \"Decision:\" for if.\n\nLet's start with Start. Then class KthLargest. But we just output pseudo-code steps, not actual class syntax? Probably show the logic.\n\nOk produce:\n\nStart // 程式開始\n→ Class KthLargest // 定義 KthLargest 類別\n    → Field: k // 儲存 k 的值\n    → Field: minHeap // 儲存最小堆，大小不超過 k\n    → Constructor(k, nums) // 初始化\n        → Step: set this.k = k // 設定 k\n        → Step: initialize this.minHeap as empty min-heap // 建立空堆\n        → Step: for each num in nums // 對初始數組進行處理\n            → Decision: if minHeap.size < k? // 堆未滿 k\n                Yes → Add num to minHeap // 直接加入堆\n                No  → Decision: if num > minHeap.peek()? // 堆已滿，檢查是否需要替換\n                    Yes → Remove minHeap.peek() // 移除最小值\n                    No  → No action // 保留現有堆\n                → Add num to minHeap // 將 num 加入堆（如果已移除）\n        → End // 完成初始化\n    → Method add(val) // 新增分數\n        → Step: if minHeap.size < k? // 堆未滿\n            Yes → Add val to minHeap // 加入\n            No  → Decision: if val > minHeap.peek()? // 堆已滿，檢查是否大於最小\n                Yes → Remove minHeap.peek() // 移除最小\n                No  → No action // 保留\n            → Add val to minHeap // 加入 val（如果已移除）\n        → Step: return minHeap.peek() // 返回第 k 大的分數\nEnd // 程式結束\n\nWe need to adhere to format: each line with \"虛擬碼步驟\" + space + \"// 解釋\". So need to write lines accordingly.\n\nUse indentation but ensure each line starts with arrow? We can use \"→\" to denote each step. For nested steps, indent with spaces. We need \"Decision:\" lines. Example: \"Decision: if minHeap.size < k?\" etc. Provide explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Class KthLargest // 定義 KthLargest 類別\n    → Field: k // 儲存 k 的值\n    → Field: minHeap // 儲存最小堆，大小不超過 k\n    → Constructor(k, nums) // 初始化\n        → Step: set this.k = k // 設定 k\n        → Step: initialize this.minHeap as empty min-heap // 建立空堆\n        → Step: for each num in nums // 逐一處理初始分數\n            → Decision: if minHeap.size < k? // 堆未滿 k 個元素\n                Yes → Add num to minHeap // 直接加入堆\n                No  → Decision: if num > minHeap.peek()? // 堆已滿，檢查是否要替換\n                    Yes → Remove minHeap.peek() // 移除最小的分數\n                    No  → No action // 保留現有堆\n                → Add num to minHeap // 若已移除最小，將 num 加入堆\n        → End // 完成初始化\n    → Method add(val) // 新增分數\n        → Decision: if minHeap.size < k? // 堆未滿 k 個元素\n            Yes → Add val to minHeap // 直接加入堆\n            No  → Decision: if val > minHeap.peek()? // 堆已滿，檢查是否比最小大\n                Yes → Remove minHeap.peek() // 移除最小的分數\n                No  → No action // 保留\n            → Add val to minHeap // 若已移除最小，將 val 加入堆\n        → Step: return minHeap.peek() // 回傳當前第 k 大的分數\nEnd // 程式結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[10]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[10]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[8,3]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[8, 3]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,8,8]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 8, 8]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        n_str = data.split('=')[-1].strip()\n    else:\n        n_str = data.strip()\n    try:\n        n = int(n_str)\n    except ValueError:\n        n = 0\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate rand10 from rand7. Classic solution: use two rand7 to generate 1-49 (7*7). Use rejection sampling: if value <= 40, map to 1-10 via mod. Else, repeat. Or can use 1-49 mapping: value%10+1. Rejection until <= 40. Or alternative use 1-42 mapping: using 1-49 but rejecting 41-49. So steps: Start, call rand7 twice, compute num = (first-1)*7 + second, if num <= 40, output num%10 +1, else repeat. Also include loop until success. That's the algorithm.\n\nWe need to output step by step virtual code, with explanation comments. Use Start, End, Decision, etc. Each line: virtual code + // explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ LoopStart // 進入重複產生直到成功\n    → Step 1: a ← rand7() // 呼叫 rand7() 產生第一個亂數\n    → Step 2: b ← rand7() // 呼叫 rand7() 產生第二個亂數\n    → Step 3: num ← (a-1)*7 + b // 將兩個亂數映射到 1~49 的整數\n    → Decision: 如果 num <= 40? // 檢查是否落在可用範圍\n        Yes → Step 4: result ← (num-1) mod 10 + 1 // 轉換到 1~10\n        Yes → Step 5: Output result // 回傳亂數\n        Yes → Step 6: Return // 結束函式\n        No  → LoopStart // 超過 40 時重新嘗試\nEnd // 程式執行結束\n\nBut we need to ensure syntax: Use Decision: if num <= 40? with Yes and No branches. Also need to indicate the loop. We might structure like:\n\nStart // 程式開始執行\n→ Decision: 需要產生 1-10? // 進入循環\n    Yes → Step 1: ... etc.\n\nBut we want to show loop using repeated steps. Virtual code can include \"Loop:\" maybe. The spec says use arrow (→) and structure Start, End, Decision:. We can represent loop by using decision with Yes leading back.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: a ← rand7() // 產生第一個 1~7 的亂數\n→ Step 2: b ← rand7() // 產生第二個 1~7 的亂數\n→ Step 3: num ← (a-1)*7 + b // 把兩個亂數映射為 1~49\n→ Decision: 如果 num <= 40? // 檢查是否在可接受的 1~40 範圍\n    Yes → Step 4: result ← (num-1) mod 10 + 1 // 將 1~40 映射到 1~10\n    Yes → Step 5: Output result // 回傳結果\n    Yes → End // 結束函式\n    No  → Step 1 // 超過 40，重新開始\n\nBut we need to avoid referencing Step 1 inside same numbering; maybe use loop label.\n\nBetter structure:\n\nStart // 程式開始執行\n→ LoopStart // 進入重複區塊\n    → Step 1: a ← rand7() // 產生第一個亂數\n    → Step 2: b ← rand7() // 產生第二個亂數\n    → Step 3: num ← (a-1)*7 + b // 合併為 1~49\n    → Decision: num <= 40? // 判斷是否在可用區間\n        Yes → Step 4: result ← (num-1) mod 10 + 1 // 轉換到 1~10\n        Yes → Step 5: Output result // 回傳\n        Yes → End // 程式結束\n        No  → LoopStart // 超過 40，重新迴圈\n\nBut we need arrow each line.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ LoopStart // 進入重複產生 1~10 的區塊  \n  → Step 1: a ← rand7() // 產生第一個 1~7 的亂數  \n  → Step 2: b ← rand7() // 產生第二個 1~7 的亂數  \n  → Step 3: num ← (a-1)*7 + b // 合併兩個亂數得到 1~49  \n  → Decision: 如果 num <= 40? // 檢查是否落在可用區間  \n    Yes → Step 4: result ← (num-1) mod 10 + 1 // 轉換 1~40 為 1~10  \n    Yes → Step 5: Output result // 回傳隨機數  \n    Yes → End // 結束函式  \n    No  → LoopStart // 超過 40，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Break II",
      "source_file": "Leetcode/leetcode140.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp04znuszy.py\", line 29, in <module>\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzc17oov6.py\", line 29, in <module>\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7907om5k.py\", line 29, in <module>\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    result = Solution().wordBreak(s, wordDict)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for word break II problem, generating all possible sentences. We should outline algorithm: use DFS with memoization. Steps: define function dfs(start). If start == len(s): return list containing empty string. If memo contains start, return. For end in range(start+1, len(s)+1): if substring in wordDict: for sub in dfs(end): add word + (' ' + sub if sub else '') to results. Memoize. Finally call dfs(0) return result list. Also initial setup: convert wordDict to set for O(1). Then produce virtual code lines accordingly. Each line must be: virtual code step + space + // explanation.\n\nWe should output \"Start\" line, then \"→\" lines. Use Decision: etc.\n\nWe must keep lines minimal but include steps.\n\nWe need to handle recursion, memoization, substring extraction, check wordDict, building results, memo storage, return. Also \"End\".\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 word_set ← wordDict 為集合 // 方便 O(1) 查找\n→ Step 2: 定義 memo ← 空字典 // 用於儲存子問題結果\n→ Step 3: 定義函式 dfs(start) // 從索引 start 開始分割\n    → Decision: 如果 start == len(s)？ // 檢查是否到達字串結尾\n        Yes → Return list containing empty string // 成功分割，返回空句子\n        No  → Decision: 如果 memo 中已有 start？ // 先前計算過\n            Yes → Return memo[start] // 直接回傳已存結果\n            No  → \n                → Step 4: 初始化 res ← 空列表 // 存放此起點的所有句子\n                → Decision: 對 end 在 range(start+1, len(s)+1) 迭代\n                    → Decision: 如果 s[start:end] 在 word_set？ // 判斷子字串是否為字典單字\n                        Yes → Step 5: 呼叫 dfs(end) 取得後續句子列表 sub_sentences\n                        → Decision: 對 sub in sub_sentences\n                            → Step 6: 如果 sub 為空字串\n                                Yes → Step 7: 組合 current_word ← s[start:end] // 只加一個單字\n                                No  → Step 8: 組合 current_word ← s[start:end] + ' ' + sub // 加單字和後續句子\n                            → Step 9: 將 current_word 加入 res // 收集此分割結果\n                        → Step 10: 進入下一個 end 值\n                → Step 11: memo[start] ← res // 缓存結果\n                → Step 12: Return res // 回傳從 start 開始的所有句子\n→ Step 13: result ← dfs(0) // 從整個字串開始遞迴\n→ Step 14: 返回 result // 輸出所有可能句子\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" plus explanation. Use arrow for steps. Need to use \"→\" before step lines. Also Decision lines with indentation. Use \"Decision:\" exactly. Provide arrow inside. Let's format.\n\nWe also might include indentation spaces for nested. For readability but maintain arrow. For example:\n\n→ Decision: 如果 start == len(s)？ // ...\n    Yes → Return ...\n    No  → Decision: ...\n\nWe must keep arrow at each step. Use \"Yes →\" and \"No →\".\n\nAlso we need to maintain consistent format: after \"→\" we add the step. Use spaces.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: word_set ← wordDict 為集合 // 方便 O(1) 查找  \n→ Step 2: memo ← 空字典 // 用於儲存子問題結果  \n→ Step 3: 定義函式 dfs(start) // 從索引 start 開始分割  \n  → Decision: 如果 start == len(s)？ // 檢查是否到達字串結尾  \n   Yes → Return list containing empty string // 成功分割，返回空句子  \n   No  → Decision: 如果 memo 中已有 start？ // 先前計算過  \n    Yes → Return memo[start] // 直接回傳已存結果  \n    No  →  \n     → Step 4: res ← 空列表 // 存放此起點的所有句子  \n     → Decision: 對 end 在 range(start+1, len(s)+1) 迭代  \n      → Decision: 如果 s[start:end] 在 word_set？ // 判斷子字串是否為字典單字  \n       Yes → Step 5: sub_sentences ← dfs(end)  // 取得後續句子列表  \n        → Decision: 對 sub 在 sub_sentences  \n         → Step 6: 如果 sub 為空字串？  \n          Yes → Step 7: current_word ← s[start:end] // 只加一個單字  \n          No  → Step 8: current_word ← s[start:end] + ' ' + sub // 加單字和後續句子  \n          → Step 9: res ← res + current_word // 收集此分割結果  \n         → Step 10: 進入下一個 sub  \n        → Step 11: 進入下一個 end  \n      → Step 12: memo[start] ← res // 缓存結果  \n      → Step 13: Return res // 回傳從 start 開始的所有句子  \n→ Step 14: result ← dfs(0) // 從整個字串開始遞迴  \n→ Step 15: 返回 result // 輸出所有可能句子  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef max_rotate_function(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    total = sum(nums)\n    # 初始 F(0)\n    cur = sum(i * num for i, num in enumerate(nums))\n    max_val = cur\n    # 迭代更新 F(k+1)\n    for i in range(n - 1):\n        cur += total - n * nums[i]\n        if cur > max_val:\n            max_val = cur\n    return max_val\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支持以下兩種格式：\n    1. nums = [1, 2, 3]\n    2. [1, 2, 3]\n    \"\"\"\n    data = data.strip()\n    if data.startswith(\"nums\"):\n        # 找到等號後的列表字串\n        _, lst_str = data.split(\"=\", 1)\n        lst_str = lst_str.strip()\n    else:\n        lst_str = data\n    # 使用 ast.literal_eval 解析為列表\n    return ast.literal_eval(lst_str)\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = max_rotate_function(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, no actual code, with explanations, step by step. Problem: given array, compute rotation function F(k) for all k and find maximum. There is known efficient solution O(n). We need to produce virtual code steps for algorithm: compute initial sum of arr[i] * i, compute total sum of array, then iteratively update F(k+1)=F(k)+totalSum - n*arr[k]. Keep max. Let's produce steps with Start, End, etc. Provide explanation per line. Must be in Traditional Chinese. Use arrow \"→\". Provide each line. Let's craft.\n\nLine 1: Start // begin\nLine 2: → Step 1: 取得輸入陣列 nums 與長度 n // get array and length\nLine 3: → Step 2: 計算總和 totalSum = sum(nums[i]) // sum of elements\nLine 4: → Step 3: 計算初始旋轉函數 F0 = Σ i * nums[i] // initial value\nLine 5: → Step 4: 設 maxF = F0 // max so far\nLine 6: → Step 5: 對 i 從 0 到 n-2 進行迴圈 // iterate remaining rotations\nLine 7: →     Decision: if i < n-1? // loop condition\nLine 8: →         Yes → Step 6: 更新 F_next = F_current + totalSum - n * nums[i] // recurrence\nLine 9: →         Yes → Step 7: 設 F_current = F_next // new current value\nLine 10: →        Yes → Step 8: 更新 maxF = max(maxF, F_current) // keep max\nLine 11: →        Yes → Step 9: 繼續下一輪迴圈 // loop continues\nLine 12: →     No → End // loop finished\nLine 13: → Step 10: 輸出 maxF // output maximum\nLine 14: End // end\n\nNeed arrow formatting; each line has \"→\" or \"    Yes →\" etc. Need to keep consistent. For Decision block, we can indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums 與長度 n // 讀取陣列與其元素數量  \n→ Step 2: 計算總和 totalSum = Σ nums[i] // 求所有元素之和  \n→ Step 3: 計算初始旋轉函數 F0 = Σ i * nums[i] // 先算 k=0 時的 F 值  \n→ Step 4: 設 maxF = F0 // 設定目前已知的最大值  \n→ Step 5: 對 i 從 0 到 n-2 進行迴圈 // 從第一個旋轉到最後一個  \n→     Decision: i < n-1? // 判斷是否還有下一輪旋轉  \n→         Yes → Step 6: 更新 F_next = F_current + totalSum - n * nums[i] // F(k+1) 的快速更新公式  \n→         Yes → Step 7: 設 F_current = F_next // 把新的 F 值設為目前值  \n→         Yes → Step 8: 更新 maxF = max(maxF, F_current) // 若更大則更新最大值  \n→         Yes → Step 9: 繼續下一輪迴圈 // 進入下一次旋轉  \n→     No → End // 迴圈結束  \n→ Step 10: 輸出 maxF // 回傳最大的旋轉函數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0:\n            return 0\n\n        # Counters for how many times we have processed s1 and how many s2 substrings we have matched\n        s1_count = 0          # number of s1 blocks processed\n        s2_count = 0          # number of s2 blocks matched as subsequence\n\n        # Current index in s2 while scanning through s1\n        s2_index = 0\n\n        # Map from current s2_index to (s1_count, s2_count) to detect cycles\n        recall = dict()\n\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[s2_index]:\n                    s2_index += 1\n                    if s2_index == len(s2):\n                        s2_index = 0\n                        s2_count += 1\n            s1_count += 1\n\n            # If we have seen this s2_index before, a cycle has been found\n            if s2_index in recall:\n                prev_s1_count, prev_s2_count = recall[s2_index]\n\n                # Number of s1 blocks before the cycle starts\n                pre_loop_s1 = prev_s1_count\n                pre_loop_s2 = prev_s2_count\n\n                # Size of the cycle in terms of s1 blocks and s2 blocks\n                cycle_s1 = s1_count - prev_s1_count\n                cycle_s2 = s2_count - prev_s2_count\n\n                # How many full cycles can we fit in the remaining s1 blocks\n                remaining_s1 = n1 - s1_count\n                full_cycles = remaining_s1 // cycle_s1\n\n                # Add the s2 blocks from the full cycles\n                s2_count += full_cycles * cycle_s2\n                s1_count += full_cycles * cycle_s1\n\n                # Process the leftover s1 blocks after the full cycles\n                rest_s1 = n1 - s1_count\n                rest_s2 = 0\n                idx = s2_index\n                for _ in range(rest_s1):\n                    for ch in s1:\n                        if ch == s2[idx]:\n                            idx += 1\n                            if idx == len(s2):\n                                idx = 0\n                                rest_s2 += 1\n                s2_count += rest_s2\n                break\n            else:\n                # Record the state for this s2_index\n                recall[s2_index] = (s1_count, s2_count)\n\n        # Each s2 block needs n2 repetitions to form one str2\n        return s2_count // n2\n\ndef main():\n    data = sys.stdin.read()\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n\n    if len(lines) == 4:\n        s1 = lines[0]\n        n1 = int(lines[1])\n        s2 = lines[2]\n        n2 = int(lines[3])\n    else:\n        # Try to parse a single line like: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n        strings = re.findall(r'\"([^\"]*)\"', data)\n        nums = re.findall(r'\\d+', data)\n        if len(strings) >= 2 and len(nums) >= 2:\n            s1 = strings[0]\n            n1 = int(nums[0])\n            s2 = strings[1]\n            n2 = int(nums[1])\n        else:\n            # Fallback: split by spaces and assume order s1 n1 s2 n2\n            parts = data.split()\n            s1 = parts[0]\n            n1 = int(parts[1])\n            s2 = parts[2]\n            n2 = int(parts[3])\n\n    solution = Solution()\n    result = solution.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solving the problem. Problem: Given s1, n1, s2, n2, str1 = s1 repeated n1 times, str2 = s2 repeated n2 times. Find maximum m such that str2 repeated m times can be obtained as a subsequence of str1. Equivalent to find how many times s2 can fit into str1 as subsequence. Standard solution uses greedy matching and cycle detection.\n\nWe need to produce virtual code steps line by line with explanations. No actual code. Use arrows etc.\n\nLet's outline algorithm:\n\n- Initialize variables: index in s1, index in s2, count of s2 occurrences, count of s1 repeats used.\n- While count of s1 repeats < n1:\n    - For each character in s1:\n        - If matches current char of s2, move index in s2 forward\n        - If index in s2 reaches length, increment s2 count, reset index to 0\n    - After finishing s1, increment s1 repeat counter\n    - Record mapping from current s1 repeat to (s2 count, s2 index)\n    - Detect cycle: if current s2 index already seen, then cycle length = current s1 repeats - previous s1 repeats\n        - cycle_s2_count = current s2 count - previous s2 count\n        - remaining s1 repeats = n1 - current s1 repeats\n        - number of cycles = remaining // cycle_length\n        - add cycle_s2_count * number_of_cycles to s2 count\n        - s1 repeats += number_of_cycles * cycle_length\n        - break\n- After loop, compute m = s2 count // n2\n- Return m\n\nSo we need virtual steps.\n\nWe must output line by line with `虛擬碼步驟 // 解釋`. Use arrows. Use Start, End. Use Decision and Yes/No.\n\nLet's produce lines like:\n\nStart // 程式開始\n→ Step 1: 初始化指標 s1_idx = 0, s2_idx = 0 // 位置於 s1 和 s2 的索引\n→ Step 2: 初始化 counter_str1 = 0, counter_s2 = 0 // 用來記錄已使用的 str1 重複數和取得的 s2 數量\n→ Decision: 是否已使用完 n1 次 str1? // 檢查是否已完成所有 str1 重複\n    Yes → End // 程式結束\n    No → Step 3: 逐字遍歷 s1 // 在每一次 str1 重複中逐字檢查\n... etc\n\nWe need cycle detection: store map from s2_idx to (counter_str1, counter_s2) at each completion of a str1.\n\nLet's write accordingly. Use arrows with indentation.\n\nWe must not output actual code; just virtual steps.\n\nLet's create step list.\n\nWe should use lines for mapping detection.\n\nWe must show use of dictionary to store mapping.\n\nUse \"Map\" as placeholder.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義 s1_idx ← 0, s2_idx ← 0 // s1 的字元索引, s2 的字元索引  \n→ Step 2: 定義 str1_used ← 0, s2_count ← 0 // 已使用的 str1 重複次數, 取得的 s2 次數  \n→ Step 3: 建立 Map 以存儲 {s2_idx: (str1_used, s2_count)} // 方便後續偵測循環  \n→ Decision: str1_used 是否已等於 n1? // 檢查是否已處理完所有 str1  \n    Yes → End // 結束程序  \n    No → Step 4: 進入內層循環, 遍歷 s1 的每個字元 c  \n→ Decision: c 是否等於 s2[s2_idx]? // 判斷字元是否匹配  \n        Yes → Step 5: s2_idx ← s2_idx + 1 // 匹配成功, 移至 s2 的下一個字元  \n        No  → Step 6: 不做任何改變 // 字元不匹配, 直接跳過  \n→ Decision: s2_idx 是否等於 s2.length? // 判斷是否已完整匹配一個 s2  \n        Yes → Step 7: s2_count ← s2_count + 1 // 完成一個 s2  \n             → Step 8: s2_idx ← 0 // 重置 s2 索引準備下一個 s2  \n        No  → No action // 仍在同一個 s2  \n→ Decision: 是否已遍歷完 s1 的全部字元? // 完成一次 str1 的使用  \n    Yes → Step 9: str1_used ← str1_used + 1 // 以 str1 完成一輪  \n         → Step 10: 檢查 Map 是否已存在 key 為 s2_idx  \n         → Decision: 是否存在?  \n            Yes → Step 11: 取得 prev_str1_used, prev_s2_count ← Map[s2_idx] // 取得上一次相同 s2_idx 的狀態  \n                  → Step 12: 計算 cycle_len ← str1_used - prev_str1_used // 循環長度  \n                  → Step 13: cycle_s2_count ← s2_count - prev_s2_count // 循環中取得的 s2 數量  \n                  → Step 14: 剩餘_str1 ← n1 - str1_used // 還剩多少 str1 可用  \n                  → Step 15: cycles ← 剩餘_str1 // cycle_len // 完整循環數  \n                  → Step 16: s2_count ← s2_count + cycles * cycle_s2_count // 加上所有完整循環的 s2  \n                  → Step 17: str1_used ← str1_used + cycles * cycle_len // 把已經完成的循環加入使用次數  \n                  → Step 18: Break 循環 // 循環計算完成後直接跳出外層  \n            No  → Step 19: Map[s2_idx] ← (str1_used, s2_count) // 記錄目前狀態  \n    No → No action // 尚未完成一次 str1 的使用，繼續內層循環  \n→ Decision: 是否已到達 n1? // 檢查是否已用完所有 str1  \n    Yes → End // 程式結束  \n    No → 回到 Step 4 // 繼續處理下一輪 str1  \n→ Step 20: 計算最大可取得的 str2 次數 m ← s2_count // n2 // 取得 m 次完整的 str2  \n→ End // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpuf3sn3pc.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpuf3sn3pc.py\", line 38, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkjy1giw5.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpkjy1giw5.py\", line 38, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmprdsf00sn.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmprdsf00sn.py\", line 38, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        # 建立圖表：每個節點相鄰節點及其比值\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        # 深度優先搜尋，計算 src 到 dst 的乘積\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor in visited:\n                    continue\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef main():\n    # 讀取整個輸入，使用 exec 將其轉成變數\n    data = sys.stdin.read()\n    # 為了安全起見，清理掉可能的行首/行尾空白\n    data = data.strip()\n    # 執行代碼，將 equations、values、queries 變成全局變數\n    exec(data, globals())\n\n    sol = Solution()\n    answers = sol.calcEquation(equations, values, queries)\n\n    # 依據題目要求輸出 5 位小數，並以字串形式列出\n    out = '[' + ','.join(f'{x:.5f}' for x in answers) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving equation evaluation problem. Should provide step-by-step approach: Build graph, perform DFS/BFS for each query, compute product of ratios. Steps: Build adjacency map with weight. For each query, if variables exist, DFS search. If path found, compute product; else -1.0.\n\nWe need to produce in lines, each line: 虛擬碼步驟 [space] // 解釋. Use arrows, Start, End, Decision: etc. Provide multiple lines.\n\nLet's design pseudo:\n\nStart\n→ Build adjacency map: For each equation Ai/Bi=val, add edge Ai->Bi with weight val, Bi->Ai with weight 1/val\n→ For each query (C,D):\n    Decision: C and D in graph? If No → add result -1.0\n    Yes → If C==D → result 1.0\n    Else:\n        Decision: Path from C to D? Perform DFS/BFS to find product.\n        If path exists → result product\n        Else → result -1.0\n→ Output results array\nEnd\n\nNeed to detail DFS steps: Use stack/recursion.\n\nLet's produce steps with decisions and arrows.\n\nRemember to include indentation with arrow lines: \"→\" before each step. Use Decision: with Yes →, No →.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildAdjacencyMap // 建立圖表，將每個方程式轉換為雙向邊  \n    → For each equation [A, B] with value v:  \n        → AddEdge A → B with weight v // Ai / Bi = v  \n        → AddEdge B → A with weight 1/v // 反向比例  \n→ PrepareResultsArray // 初始化用於存放查詢答案的結果陣列  \n→ For each query [C, D] in queries:  \n    → Decision: 是否 C 與 D 都存在於圖中?  \n        Yes → Decision: C == D?  \n            Yes → AppendResult 1.0 // 相同變量，比例為 1  \n            No  → Decision: 是否存在從 C 到 D 的路徑?  \n                Yes → BeginDFS(C, D) // 執行深度優先搜尋以求得乘積  \n                    → DFS(C, currentProduct):  \n                        → Mark C 為已訪問  \n                        → For each neighbor N of C with edge weight w:  \n                            → Decision: N 已訪問?  \n                                No → Recursively DFS(N, currentProduct * w)  \n                    → 回傳累積乘積作為答案  \n                No  → AppendResult -1.0 // 無法連通，答案未定  \n        No  → AppendResult -1.0 // 變量未定義，答案未定  \n→ OutputResultsArray // 將所有答案輸出回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 將單詞按長度升序排序，短字先處理\n        words.sort(key=len)\n        word_set = set()          # 已知可拆分的單詞集合\n        result = []               # 存放所有連接詞\n\n        for word in words:\n            if not word:\n                continue\n\n            # 動態規劃檢查 word 是否能拆分成兩個或兩個以上已知單詞\n            dp = [False] * (len(word) + 1)\n            dp[0] = True  # 空字串總是可拆分\n\n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n\n            if dp[len(word)]:\n                result.append(word)\n\n            # 把目前單詞加入已知集合，供後續單詞使用\n            word_set.add(word)\n\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    將輸入文字解析為 words 列表。\n    允許輸入類似 'words = [\"cat\",\"cats\",...]' 的格式。\n    \"\"\"\n    text = text.strip()\n    if not text:\n        return []\n\n    # 如果是 'words = [...]' 形式，取等號右側\n    if '=' in text:\n        _, rhs = text.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = text\n\n    # 使用 literal_eval 解析為 Python 物件\n    return ast.literal_eval(rhs)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    raw_input = sys.stdin.read()\n    words = parse_input(raw_input)\n\n    sol = Solution()\n    concatenated_words = sol.findAllConcatenatedWordsInADict(words)\n\n    # 輸出結果列表\n    print(concatenated_words)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines step by step for algorithm: given array of words (no duplicates), return all concatenated words in list. We need to describe algorithm: build trie or use DP. Probably use DP with set. Steps: sort words by length ascending. For each word, check if can be segmented into two or more words using DP with dictionary of previous words. Use set for known words. For each word, dynamic programming over splits; if segmentable, add to result and to set. Provide pseudo-code lines with arrow syntax.\n\nWe need to output each line: \"Start // 程式開始執行\" etc.\n\nLet's create steps:\n\nStart\n→ Step 1: Sort words by length ascending // 確保短字先處理\n→ Step 2: 初始化已知單詞集合 wordSet ← empty // 用於檢查子字串\n→ Step 3: 初始化結果列表 result ← empty // 存儲連接詞\n→ Decision: 遍歷每個 word in words // 處理每個字串\n    Yes → Step 4: 若 word 可以被拆分為至少兩個已知單詞? // 判斷是否為連接詞\n        Yes → Step 5: result.add(word) // 將連接詞加入結果\n        No  → 無\n    Yes → Step 6: wordSet.add(word) // 把所有字加入已知集合\n→ End\n\nWe need to detail the DP check function:\n\nStep 4: 需要使用動態規劃判斷. We'll break into substeps.\n\nWe can define a subroutine:\n\nDecision: 若 word 可以被拆分? \n    Yes -> add to result\n    No -> nothing\nBut we need pseudo-code inside decision to check.\n\nSimpler: \"Decision: 判斷 word 是否為連接詞 (使用 DP)\" then we can break DP steps:\n\n→ Step 4a: 建立布林陣列 dp[0..len] 初始化 dp[0]=true // dp[i] 表示前 i 個字符可拆分\n→ Step 4b: for i from 1 to len\n        for j from 0 to i-1\n            if dp[j] and substring(i,j) in wordSet\n                dp[i]=true; break\n→ Step 4c: 若 dp[len] 且 word 中至少拆分一次 (i.e., len>0?) // Actually need at least two words; we need count splits. But dp alone may accept the whole word as itself if wordSet already contains it. Since we process sorted ascending, wordSet doesn't contain current word yet. So dp[len] will only be true if constructed from previous shorter words. So that ensures at least two words. Good.\n\nSo algorithm good.\n\nNow produce pseudo-code lines accordingly. Use arrow arrow.\n\nMake sure each line ends with // explanation.\n\nAlso need to use Decision: etc. For loops, we can use Step: loop, but use arrow.\n\nLet's craft.\n\nPseudo-code lines:\n\nStart // 程式開始執行\n→ Step 1: Sort words by length ascending // 讓短字先加入集合，方便拆分\n→ Step 2: Initialize wordSet ← {} // 已知可用的字串集合\n→ Step 3: Initialize result ← [] // 儲存所有連接詞\n→ Decision: For each word in words // 逐一檢查每個字串\n    Yes → Step 4: Initialize dp[0..len(word)] ← false // dp 表示前 i 個字符是否可拆分\n        → dp[0] ← true // 空字串總是可拆分\n    → Decision: For i from 1 to len(word) // 遍歷字串長度\n        Yes → Decision: For j from 0 to i-1 // 嘗試所有分割點\n            Yes → Decision: If dp[j] AND substring(word, j, i) ∈ wordSet\n                Yes → Step 5: dp[i] ← true; Break inner loop // 找到合法拆分\n    → Decision: If dp[len(word)] = true // 整個字串可拆分為短字\n        Yes → Step 6: result.add(word) // 加入結果\n    → Step 7: wordSet.add(word) // 將目前字加入可用集合\n→ End // 程式執行結束\n\nNeed to maintain proper indentation and arrow for loops. Maybe use \"Decision:\" for loops? The example uses \"Decision:\" for if. For loops we can use \"Step:\" but it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending // 先把短字放前面，確保拆分時已知單詞已加入集合  \n→ Step 2: Initialize wordSet ← {} // 已知可用的字串集合  \n→ Step 3: Initialize result ← [] // 儲存所有連接詞  \n→ Decision: For each word in words // 逐一檢查每個字串  \n    Yes → Step 4: Initialize dp[0..len(word)] ← false // dp[i] 表示前 i 個字是否能拆分  \n        → dp[0] ← true // 空字串總是可拆分  \n    → Decision: For i from 1 to len(word) // 遍歷字串長度  \n        Yes → Decision: For j from 0 to i-1 // 嘗試所有分割點  \n            Yes → Decision: If dp[j] AND substring(word, j, i) ∈ wordSet  \n                Yes → Step 5: dp[i] ← true; Break inner loop // 找到合法拆分，結束內層循環  \n    → Decision: If dp[len(word)] = true // 整個字串可拆分成至少兩個短字  \n        Yes → Step 6: result.add(word) // 加入結果列表  \n    → Step 7: wordSet.add(word) // 將目前字加入已知集合，供後續字使用  \n→ End // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,1]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,1]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,1,2,3]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,1,2,3]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填入邊與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點作為起點\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # 拓撲排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都被加入順序，回傳結果；否則回傳空陣列\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料。支援兩種格式：\n    1. 例如: \"numCourses = 2, prerequisites = [[1,0]]\"\n    2. 兩行分別為 numCourses 與 prerequisites\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return None\n\n    # 嘗試以字典形式 eval\n    try:\n        parsed = eval('{' + data + '}')\n        return parsed['numCourses'], parsed['prerequisites']\n    except Exception:\n        pass\n\n    # 兩行分別輸入的情況\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        try:\n            num = int(lines[0].strip())\n            prereq = eval(lines[1].strip())\n            return num, prereq\n        except Exception:\n            pass\n\n    # 單行分隔的情況\n    parts = data.split()\n    if len(parts) >= 2:\n        try:\n            num = int(parts[0])\n            prereq = eval(parts[1])\n            return num, prereq\n        except Exception:\n            pass\n\n    return None\n\ndef main():\n    raw_input = sys.stdin.read()\n    parsed = parse_input(raw_input)\n    if parsed is None:\n        print(\"[]\")\n        return\n\n    numCourses, prerequisites = parsed\n    solver = Solution()\n    order = solver.findOrder(numCourses, prerequisites)\n    print(order)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for topological sort. We'll explain line by line. Use Start, Decision, etc. Should not output actual code. Just steps. Provide explanation after each line. Use virtual code syntax. Provide steps: build graph, indegree, queue, result, loop, etc. Ensure arrow lines. Use indentation for nested decisions. Provide clear explanation. Use \"→\" for each step. Provide at least those steps. Let's craft.\n\nWe need to produce a sequential algorithm. Outline:\n\nStart\n→ Step 1: 初始化圖和入度\n→ Step 2: 將每個課程添加到圖並更新入度\n→ Step 3: 將入度為0的課程加入隊列\n→ Decision: 判斷隊列是否空? No → Step 4: 從隊列取出課程，加入結果\n→ Step 5: 為每個相鄰課程減少入度，若入度變0則加入隊列\n→ End loop\n→ Decision: 判斷結果長度是否等於 numCourses? Yes → Return 結果\n→ No → Return 空陣列\n\nBut need to include \"Start\" and \"End\". Provide arrow lines with explanation.\n\nLet's craft more detailed steps: Step1: Build adjacency list and indegree array. Step2: For each pair in prerequisites: add edge, increment indegree. Step3: Initialize queue with indegree 0. Step4: While queue not empty: pop course, append to order, for each neighbor: decrement indegree, if becomes 0, enqueue. Step5: After loop, if order length = numCourses, return order else return empty.\n\nAdd explanation. Use arrow notation \"→\". Use indentation for nested loops. Also include Decision steps with Yes/No arrows.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的鄰接表 `adj` 與入度陣列 `indeg`，長度為 `numCourses` // 準備資料結構  \n→ Step 2: 遍歷 `prerequisites`  \n    → For each pair `[a, b]`:  \n        → Add `a` 到 `b` 的鄰接清單 (`adj[b] ← a`) // 建立邊  \n        → `indeg[a] ← indeg[a] + 1` // 計算入度  \n→ Step 3: 建立空的佇列 `queue`  \n    → Decision: 每個課程 `i` 的入度為 0? // 找出無前置條件的課程  \n        Yes → `queue.Enqueue(i)` // 加入佇列  \n→ Step 4: 建立空列表 `order` 用於存放課程順序  \n→ Step 5: Decision: `queue` 是否為空? // 開始拓撲排序  \n    No → Step 6: 從 `queue` 取出一個課程 `cur`  \n        → Append `cur` 到 `order` // 先完成此課程  \n        → Decision: `adj[cur]` 是否存在?  \n            Yes → For each neighbour `next` in `adj[cur]`:  \n                → `indeg[next] ← indeg[next] - 1` // 減少入度  \n                → Decision: `indeg[next]` 變為 0?  \n                    Yes → `queue.Enqueue(next)` // 現在可完成此課程  \n        → 回到 Step 5 進行下一輪  \n    Yes → End // 佇列已空，排序完成  \n→ Step 7: Decision: `order` 的長度是否等於 `numCourses`? // 檢查是否成功完成所有課程  \n    Yes → Return `order` // 有效的課程順序  \n    No → Return 空陣列 `[]` // 週期存在，無法完成課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Palindromic Subsequence",
      "source_file": "Leetcode/leetcode516.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "generated_code": "import sys\n\ndef longest_palindromic_subseq(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                if j == i + 1:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    print(longest_palindromic_subseq(s))",
      "virtual_code": "Thinking...\nWe need to output pseudocode steps to compute longest palindromic subsequence length. Use dynamic programming. Provide line by line with comments. Must use \"Start\", \"End\", \"Decision:\" etc. We should generate steps: Input string, length n, create dp matrix n x n. Initialize dp[i][i]=1. For cl from 2 to n: for i from 0 to n-cl: j=i+cl-1. If s[i]==s[j] and cl==2 then dp[i][j]=2 else if s[i]==s[j] then dp[i][j]=dp[i+1][j-1]+2 else dp[i][j]=max(dp[i+1][j],dp[i][j-1]). Finally output dp[0][n-1]. We need to present each line with arrow arrow or Yes/No decision. Use decision statements for loops? Might use Decision: if s[i]==s[j]? but loops we can express. Provide \"→\" before steps. Each line: \"虛擬碼步驟 // 解釋\". Ensure each line has arrow. Use indentation perhaps but each line separate. We might produce \"→ Step 1: 輸入字符串 s\". etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 獲取待處理的字串\n→ Step 2: 計算字串長度 n // 用於後續迴圈\n→ Step 3: 建立 n × n 的 dp 陣列 // dp[i][j] 儲存子字串 s[i..j] 的最大回文子序列長度\n→ Decision: 是否需要初始化單字母回文? // 每個單字符都是長度1的回文\n    Yes → Step 4: 對 i in 0..n-1 設定 dp[i][i] = 1 // 每個位置自我回文長度為1\n    No  → // （不會發生，因為 n≥1）\n→ Step 5: 設定 cl = 2 // 子字串長度從 2 開始\n→ Decision: cl ≤ n? // 循環遍歷所有可能的子字串長度\n    Yes → Step 6: 對 i in 0..n-cl 設定 j = i + cl - 1 // 確定子字串的起止位置\n        → Decision: s[i] == s[j]? // 比較兩端字符是否相同\n            Yes → Decision: cl == 2? // 兩字符相同時的特別處理\n                Yes → Step 7: 設定 dp[i][j] = 2 // 兩個相同字符直接形成回文\n                No  → Step 8: 設定 dp[i][j] = dp[i+1][j-1] + 2 // 內部已經是回文，外加兩字符\n            No  → Step 9: 設定 dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取不包含左或右字符的最大值\n        → Step 10: cl = cl + 1 // 進入下一個子字串長度\n    No  → // 當 cl>n 時跳出迴圈\n→ Step 11: 輸出 dp[0][n-1] // 最大回文子序列長度為整個字串\nEnd // 程式執行結束\n\nMake sure each line has arrow and comment. Use \"→\" at beginning of each line. For Decision, we indent? We can just include them as separate lines.\n\nWe must ensure no actual code, just pseudocode steps. So we can produce as above. Ensure each line ends with // 解釋. The arrows inside Decision lines too. Use \"Yes →\" etc. Good. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 獲取待處理的字串  \n→ Step 2: 計算字串長度 n // 用於後續迴圈  \n→ Step 3: 建立 n × n 的 dp 陣列 // dp[i][j] 儲存子字串 s[i..j] 的最大回文子序列長度  \n→ Decision: 是否需要初始化單字母回文? // 每個單字符都是長度1的回文  \n Yes → Step 4: 對 i in 0..n-1 設定 dp[i][i] = 1 // 每個位置自我回文長度為1  \n No  → // （不會發生，因為 n≥1）  \n→ Step 5: 設定 cl = 2 // 子字串長度從 2 開始  \n→ Decision: cl ≤ n? // 循環遍歷所有可能的子字串長度  \n Yes → Step 6: 對 i in 0..n-cl 設定 j = i + cl - 1 // 確定子字串的起止位置  \n  → Decision: s[i] == s[j]? // 比較兩端字符是否相同  \n   Yes → Decision: cl == 2? // 兩字符相同時的特別處理  \n    Yes → Step 7: 設定 dp[i][j] = 2 // 兩個相同字符直接形成回文  \n    No  → Step 8: 設定 dp[i][j] = dp[i+1][j-1] + 2 // 內部已經是回文，外加兩字符  \n   No  → Step 9: 設定 dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取不包含左或右字符的最大值  \n  → Step 10: cl = cl + 1 // 進入下一個子字串長度  \n No  → // 當 cl>n 時跳出迴圈  \n→ Step 11: 輸出 dp[0][n-1] // 最大回文子序列長度為整個字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.630835903689705,0.5840531498859491],[0.5769737488401133,0.49421223637398815],[-0.5255685815823914,-0.6783440833167521]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.630835903689705, 0.5840531498859491], [0.5769737488401133, 0.49421223637398815], [-0.5255685815823914, -0.6783440833167521]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 均勻生成半徑（使用 sqrt 保證均勻分佈）\n        r = self.radius * math.sqrt(random.random())\n        # 隨機角度 [0, 2π)\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換回直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    methods = json.loads(data[0])      # 例: [\"Solution\", \"randPoint\", ...]\n    args_list = json.loads(data[1])    # 例: [[1.0, 0.0, 0.0], [], ...]\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # 建構子不回傳任何值\n        else:\n            func = getattr(obj, method)\n            results.append(func())\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step, using the specified format. Provide lines like \"Start // 程式開始執行\" etc. The requirement: Implement the Solution class with constructor and randPoint method. Provide algorithm: generate random point inside circle uniformly: we can generate random radius r from 0 to radius with sqrt distribution: r = radius * sqrt(rand()), random angle theta uniform [0, 2π). Then x = x_center + r * cos(theta), y = y_center + r * sin(theta). Or use rejection sampling. Provide pseudocode accordingly. Need to output line by line with arrow and decision statements. Should show class definition, constructor, method, random generation steps.\n\nLet's structure:\n\nStart\n→ Step 1: Define class Solution\n→ Step 2: Constructor with radius, x_center, y_center // store values\n→ Step 3: randPoint method\n    → Step 4: Generate random angle theta uniformly in [0, 2π)\n    → Step 5: Generate random radial distance r using sqrt(random()) * radius // ensures uniform distribution\n    → Step 6: Compute x = x_center + r * cos(theta)\n    → Step 7: Compute y = y_center + r * sin(theta)\n    → Step 8: Return [x, y]\nEnd\n\nInclude Decision? Not necessary but can show maybe random. But spec says use Decision and arrow. We can incorporate decision for random generator? Not needed. Provide pseudo-code with arrow. We'll just use steps.\n\nLet's output with format lines: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立包含半徑與圓心座標的物件  \n→ Step 2: Constructor(radius, x_center, y_center) // 取得半徑與圓心座標並儲存  \n→ Step 3: 方法 randPoint() // 產生一個隨機點  \n  → Step 4: theta ← Random() * 2π // 產生均勻分布的角度 [0, 2π)  \n  → Step 5: u ← Random() // 產生均勻分布的隨機數 [0, 1)  \n  → Step 6: r ← radius * sqrt(u) // 用 sqrt 取得均勻分布的半徑  \n  → Step 7: x ← x_center + r * cos(theta) // 計算 x 座標  \n  → Step 8: y ← y_center + r * sin(theta) // 計算 y 座標  \n  → Step 9: 返回 [x, y] // 回傳隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Numbers with Unique Digits",
      "source_file": "Leetcode/leetcode357.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '811'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '811'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_unique_numbers(n: int) -> int:\n    \"\"\"\n    Return the count of all numbers with unique digits x,\n    where 0 <= x < 10^n.\n    \"\"\"\n    if n == 0:\n        return 1          # only number 0\n    n = min(n, 10)        # more than 10 digits will repeat\n    result = 1           # include 0\n    perm = 9             # first non-zero digit choices\n    for i in range(1, n + 1):\n        result += 9 * perm\n        perm *= (10 - i)\n    return result\n\ndef main() -> None:\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(count_unique_numbers(n))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. It's a problem: Count numbers with unique digits up to 10^n. This is LeetCode 357. Approach: use DP: For n=0 return 1. For n>0, count = 1 + sum_{i=1 to n} 9 * P(9,i-1). We need to generate steps: Start, input n, decision for n==0, compute result. Use loops to compute permutations. Provide steps. Must not output actual code, only virtual code. Use arrow syntax. Provide each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Input: n // 取得輸入整數 n\n→ Decision: 是否 n == 0? // 檢查是否為 0\n    Yes → Output 1 // 只有 0 這一個數\n    No  → Begin 計算\n\nNow we need to compute count. Steps: initialize result=1 for 0. Use factorial/permutation.\n\nWe can do:\n\n→ Step 1: result ← 1 // 包含數字 0\n→ Step 2: perm ← 9 // 第一個非零數字的選擇\n→ Step 3: count ← 9 // 第一位非零數字的組合數\n→ Decision: i from 2 to n? // 迴圈從 2 到 n\n    Yes → Step 4: perm ← perm × (10 - i) // 更新可選的數字數\n           → Step 5: count ← count + 9 × perm // 加上當前位數組合\n           → Go back to Decision\n    No  → Output result + count // 加總並輸出\n\nBut need to reflect DP.\n\nAlternatively: result=1; for i in 1..n: result += 9 * perm; perm *= (10-i).\n\nBut careful: For i=1: perm=9? We can set perm=9 initially? Actually for i=1: perm=9 (9 options for first digit). Then result += 9*perm? That would be 81 double. So better: Use perm=9, result=1. For i from 1 to n: result += 9*perm; perm *= (10 - i). That works: For i=1: result += 9*9 =81; perm *= 9 => 81. For i=2: result +=9*81=729; perm*=8 => 648. etc. At end result is sum.\n\nThus algorithm.\n\nLet's produce virtual code:\n\nStart\n→ Input n\n→ Decision: n == 0?\n    Yes → Output 1\n    No  → Begin\n        → result ← 1 // 包含 0\n        → perm ← 9 // 第一個非零位的選擇數\n        → i ← 1 // 目前處理的位數\n        → Decision: i <= n?\n            Yes → result ← result + 9 × perm // 加入當前位數的組合\n                → perm ← perm × (10 - i) // 更新剩餘可選數字\n                → i ← i + 1 // 進到下一位\n                → Go back to Decision\n            No  → Output result // 回傳總數\nEnd\n\nBut we need to produce arrow lines. Use \"→\" each step.\n\nLet's format:\n\nStart // 程式開始執行\n→ Input n // 取得使用者輸入的 n\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Output 1 // 只有 0 這一個數\n    No  → Begin // 開始計算\n\nNow inside begin: we need to set variables and loop. We'll produce separate lines.\n\nLet's ensure we use \"Decision:\" only once for loop. Use nested decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input n // 取得使用者輸入的 n\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Output 1 // 只有 0 這一個數\n    No  → // 開始計算\n        → result ← 1 // 包含數字 0\n        → perm ← 9 // 第一個非零數字的選擇數\n        → i ← 1 // 目前處理的位數\n        → Decision: i <= n? // 是否還有位數要處理\n            Yes → result ← result + 9 × perm // 加上當前位數的組合\n                → perm ← perm × (10 - i) // 更新剩餘可選數字\n                → i ← i + 1 // 進到下一位\n                → Go back to Decision\n            No  → Output result // 回傳總數\nEnd // 程式執行結束\n\nBut \"Go back to Decision\" is not a step; we can just show that after i++ we go back to Decision. In pseudocode, we can just loop. Let's produce lines with indentation? The specification doesn't mention indentation but we can use indentation for readability. Use spaces.\n\nWe must not output actual code, only virtual code with arrows. Use \"→\" each line. Provide explanation after //.\n\nAlso \"Decision:\" lines should be followed by Yes → and No → lines. We can use indentation.\n\nLet's craft final output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得使用者輸入的 n  \n→ Decision: n == 0? // 檢查是否為 0  \n  Yes → Output 1 // 只有 0 這一個數  \n  No  → // 開始計算  \n    → result ← 1 // 包含數字 0  \n    → perm ← 9 // 第一個非零數字的選擇數  \n    → i ← 1 // 目前處理的位數  \n    → Decision: i <= n? // 是否還有位數要處理  \n      Yes → result ← result + 9 × perm // 加上當前位數的組合  \n       → perm ← perm × (10 - i) // 更新剩餘可選數字  \n       → i ← i + 1 // 進到下一位  \n       → Go back to Decision // 重新判斷是否繼續  \n      No  → Output result // 回傳總數  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[None,[1,2,3],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[None, [1, 2, 3], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列，並建立可變副本\n        self.original = list(nums)\n        self.nums = list(nums)\n\n    def reset(self):\n        # 重新把陣列還原成原始狀態\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        # Fisher–Yates 洗牌演算法\n        shuffled = list(self.nums)\n        n = len(shuffled)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    # 讀取整個 stdin 作為輸入字串\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 將輸入包成 JSON 陣列，方便解析\n    data = json.loads('[' + raw + ']')\n    commands, args = data[0], data[1]\n\n    outputs = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'Solution':\n            # 解題輸入通常為 [[1,2,3]]，取內層作為陣列\n            nums = arg[0] if isinstance(arg, list) and len(arg) == 1 else arg\n            obj = Solution(nums)\n            outputs.append(None)\n        elif cmd == 'reset':\n            outputs.append(obj.reset())\n        elif cmd == 'shuffle':\n            outputs.append(obj.shuffle())\n        else:\n            outputs.append(None)\n\n    # 將結果以 Python list 形式輸出\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants virtual code for designing a shuffle algorithm. Must output line by line, each line with code and comment. Use arrow syntax. Need to produce solution class with constructor, reset, shuffle. Use Fisher-Yates algorithm. Represent as virtual code. Ensure each line has code + space + // explanation. Use arrows for steps. Provide Start and End. Provide decisions. So produce steps for initialization, reset, shuffle. Use array copying. Use random selection. Provide simple flow. Use Start, End.\n\nLet's produce:\n\nStart // program start\n→ Step 1: Declare class Solution // 定義 Solution 類\n→ Step 2: Declare private variable originalNums // 儲存原始陣列\n→ Step 3: Declare private variable nums // 可變陣列用於 shuffle\n→ Step 4: Constructor Solution(numsInput) // 初始化\n    → Step 5: originalNums ← Copy(numsInput) // 複製一份原始\n    → Step 6: nums ← Copy(numsInput) // 複製一份作業陣列\n→ Step 7: reset() // 重置陣列\n    → Step 8: nums ← Copy(originalNums) // 重新複製原始\n    → Step 9: return nums // 回傳重置後陣列\n→ Step 10: shuffle() // 隨機打亂\n    → Step 11: For i from length(nums)-1 down to 1\n        → Step 12: j ← Random integer between 0 and i\n        → Step 13: Swap nums[i] and nums[j] // Fisher–Yates swap\n    → Step 14: return nums // 回傳打亂後陣列\nEnd // 程式結束\n\nNeed to use arrow notation. For loops use → Step. Provide decisions? None needed. Use arrow for each. Add // comment. Ensure each line includes code plus comment. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Declare class Solution // 定義 Solution 類  \n→ Step 2: Declare private variable originalNums // 儲存原始陣列的複製  \n→ Step 3: Declare private variable nums // 供 shuffle 變動的陣列  \n→ Step 4: Constructor Solution(numsInput) // 建構子，接受輸入陣列  \n  → Step 5: originalNums ← Copy(numsInput) // 將輸入陣列複製為原始版本  \n  → Step 6: nums ← Copy(numsInput) // 再複製一次作為工作陣列  \n→ Step 7: reset() // 重置陣列至原始配置  \n  → Step 8: nums ← Copy(originalNums) // 重新複製原始陣列到工作陣列  \n  → Step 9: return nums // 回傳重置後的陣列  \n→ Step 10: shuffle() // 產生隨機排列  \n  → Step 11: For i from length(nums)-1 down to 1 // 從尾到頭遍歷  \n    → Step 12: j ← Random integer between 0 and i // 隨機選取一個索引  \n    → Step 13: Swap nums[i] and nums[j] // 交換位置（Fisher–Yates）  \n  → Step 14: return nums // 回傳已打亂的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"回傳所有子集（冪集合）\"\"\"\n        res = []\n\n        def backtrack(start, path):\n            # 目前的 path 是一個完整的子集，加入結果\n            res.append(path[:])\n            # 從 start 開始嘗試把每個元素加入子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()  # 回溯：移除剛才加入的元素\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    # 讀取整個輸入，去掉首尾空白\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期格式為 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data\n\n    # 使用安全方式解析 Python 表達式\n    try:\n        nums = ast.literal_eval(arr_str)\n    except Exception:\n        print(\"[]\")\n        return\n\n    solution = Solution()\n    result = solution.subsets(nums)\n\n    # 以 JSON 格式輸出，去除逗號後的空格\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating power set of array of unique elements. We need to produce step-by-step pseudo-code with comments in Chinese. Use arrow syntax. Each line: \"虛擬碼步驟 // 解釋\". Must start with Start, End. Use Decision nodes. We need to show algorithm: could use backtracking recursion or iterative bitmask. Provide steps: initialize result, define backtrack function, etc. Provide virtual code lines. Each line should include explanation. Use arrow lines. Use indentation for decisions. Use \"→\" arrow.\n\nWe should keep it simple. Steps:\n\nStart\n→ Step 1: Initialize result as empty list\n→ Step 2: Define recursive function backtrack(start, currentSubset)\n→ Decision: If start == length of nums?\n→ Yes → Step 3: Append copy of currentSubset to result\n→ No → Step 4: For i from start to len-1\n    → Step 5: Append nums[i] to currentSubset\n    → Step 6: Call backtrack(i+1, currentSubset)\n    → Step 7: Remove last element from currentSubset (backtrack)\n→ Step 8: Call backtrack(0, empty list)\n→ Step 9: Return result\nEnd\n\nBut we must use arrow after each step. Use indent for decision branches. Use \"Yes →\" and \"No →\".\n\nWe must ensure each line includes comment after //. Use Chinese explanation. Provide virtual code step numbers? The example uses \"Step 1:\" etc. We'll include. Provide \"Start\" line and \"End\" line. Use arrow \"→\" after Start? In example: \"Start // 程式開始執行\" then \"→ Step 1: ...\" So we follow.\n\nLet's produce. Use consistent formatting.\n\nEdge: use \"Decision:\" line with condition. Then under Yes and No indent. Use arrow after Yes. Good.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來儲存所有子集  \n→ Step 2: 定義遞迴函式 backtrack(start, currentSubset) // 回溯演算法入口  \n→ Decision: start 等於 nums 長度? // 檢查是否已遍歷完所有元素  \n Yes → Step 3: 把 currentSubset 的複本加入 result // 完整子集加入結果  \n No  → Step 4: 針對 i 從 start 到 nums 長度-1 做循環 // 嘗試把每個元素加入子集  \n  → Step 5: 把 nums[i] 加入 currentSubset // 暫時擴展子集  \n  → Step 6: 呼叫 backtrack(i+1, currentSubset) // 進入下一層回溯  \n  → Step 7: 移除 currentSubset 最後一個元素 // 回溯回原狀  \n→ Step 8: 呼叫 backtrack(0, 空列表) // 從第一個元素開始遞迴  \n→ Step 9: 回傳 result // 返回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfngqzew2.py\", line 57, in <module>\n    parts = json.loads(data)\n            ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 105 (char 104)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)     # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)   # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # ensure user follows themselves\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int):\n        # ensure user follows themselves\n        self.following[userId].add(userId)\n\n        heap = []\n        # push the most recent tweet from each followee onto the heap\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n\n        res = []\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx > 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            # user automatically follows themselves\n            self.following[followerId].add(followerId)\n            return\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # input format: [\"Twitter\", \"postTweet\", ...], [[], [1, 5], ...]\n    parts = json.loads(data)\n    commands = parts[0]\n    args_list = parts[1]\n\n    twitter = Twitter()\n    results = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Twitter\":\n            results.append(None)\n        elif cmd == \"postTweet\":\n            twitter.postTweet(*args)\n            results.append(None)\n        elif cmd == \"getNewsFeed\":\n            res = twitter.getNewsFeed(*args)\n            results.append(res)\n        elif cmd == \"follow\":\n            twitter.follow(*args)\n            results.append(None)\n        elif cmd == \"unfollow\":\n            twitter.unfollow(*args)\n            results.append(None)\n        else:\n            # unknown command\n            results.append(None)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code with explanation lines. The user wants design of simplified Twitter with given methods. We'll produce pseudo steps for each method and overall structure. Use arrow. For each method, we can include steps. Also include initialization.\n\nWe must output in Traditional Chinese. Provide line by line.\n\nLet's craft: Start, then steps for Twitter() init, then postTweet, getNewsFeed, follow, unfollow. For each method maybe sub-steps. Provide Decision structures.\n\nLet's proceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立資料結構 // 初始化所有必要的資料結構  \n  → Step 1.1: 建立字典 userTweets: userId → 列表 (儲存此使用者發佈的 tweetId，按照發佈時間先後) // 追蹤每個使用者的推文  \n  → Step 1.2: 建立字典 followees: userId → 集合 (儲存此使用者關注的使用者) // 追蹤關注關係  \n  → Step 1.3: 建立全局計數器 timestamp ← 0 // 為每則推文賦予遞增的時間戳，方便排序  \n\nEnd // 初始化完成  \n\n---  \n\n// 方法：postTweet(userId, tweetId)  \nStart // 呼叫 postTweet  \n→ Step 2: timestamp ← timestamp + 1 // 取得新推文的時間戳  \n→ Step 2.1: 若 userId 未在 userTweets 中，則建立空列表 // 新使用者首次發文時初始化  \n→ Step 2.2: 在 userTweets[userId] 前插入 (timestamp, tweetId) // 儲存推文並保持時間先後  \nEnd // postTweet 完成  \n\n---  \n\n// 方法：getNewsFeed(userId)  \nStart // 呼叫 getNewsFeed  \n→ Step 3: 取得關注清單: followList ← followees.get(userId, 空集合) ∪ {userId} // 包含自己和關注的使用者  \n→ Step 3.1: 建立空列表 candidates ← [] // 用於收集候選推文  \n→ Step 3.2: 對於 each followee 在 followList  \n  → Step 3.2.1: 取其最近的前 10 個推文 userTweets[followee][:10]  \n  → Step 3.2.2: 將這些推文加到 candidates 中  \n→ Step 4: 使用最小堆（大小不超過 10）將 candidates 按時間戳排序，取出 10 個時間戳最大的推文  \n  → Step 4.1: 對 candidates 中每個 (timestamp, tweetId)  \n    → Decision: 如果堆大小 < 10? // 堆還未滿  \n      Yes → push (timestamp, tweetId)  \n      No → 若 timestamp > 堆頂時間戳? // 新推文更新  \n       Yes → pop 堆頂，push (timestamp, tweetId)  \n       No → 省略  \n→ Step 5: 取出堆中的元素，按時間戳降序排序，取 tweetId 形成結果列表 result  \n→ Step 6: 返回 result  \nEnd // getNewsFeed 完成  \n\n---  \n\n// 方法：follow(followerId, followeeId)  \nStart // 呼叫 follow  \n→ Step 7: 若 followerId 未在 followees 中，則建立空集合 // 新使用者首次關注時初始化  \n→ Step 7.1: 向 followees[followerId] 加入 followeeId // 建立關注關係  \nEnd // follow 完成  \n\n---  \n\n// 方法：unfollow(followerId, followeeId)  \nStart // 呼叫 unfollow  \n→ Step 8: 若 followerId 在 followees 中  \n  → Step 8.1: 從 followees[followerId] 中移除 followeeId（若存在） // 解除關注關係  \nEnd // unfollow 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2xxkzwhm.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmp2xxkzwhm.py\", line 62, in main\n    ops, params = json.loads(data)\n                  ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 83 (char 82)"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}  # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key):\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef list_to_str(lst):\n    parts = []\n    for x in lst:\n        if x is None:\n            parts.append('null')\n        else:\n            parts.append(str(x))\n    return '[' + ', '.join(parts) + ']'\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, params = json.loads(data)\n    cache = None\n    results = []\n    for op, param in zip(ops, params):\n        if op == \"LFUCache\":\n            cache = LFUCache(param[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(param[0], param[1])\n            results.append(None)\n        elif op == \"get\":\n            val = cache.get(param[0])\n            results.append(val)\n    print(list_to_str(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing LFU cache. The steps should be line-by-line, each line with \"虛擬碼步驟 // 解釋\". Use arrows and structure. We should include Start, End, Decision, etc. The user wants design and implement data structure for LFU cache. Steps include initialization, get, put, maintain freq map, minFreq, etc. The virtual code should reflect logic: use hash maps for key to node, freq to linked list of keys, node has key, value, freq. On get: if key not exist return -1, else update freq, move node to freq+1 list, update minFreq if necessary. On put: if capacity 0 return; if key exists: update value, same as get for freq; else if cache at capacity: evict key with minFreq list's head; remove from key map; then insert new node with freq 1, add to freq list, set minFreq=1. Ensure O(1). Provide steps for initialization of structures. Should include decision blocks for key existence, capacity, etc.\n\nWe need to produce \"虛擬碼\" steps. Use arrow `→` and indentation. Provide short explanations. Let's structure:\n\nStart\n→ Step 1: Initialize capacity, keyMap, freqMap, minFreq // Set up main data structures\n→ Step 2: Define Node structure // Node contains key, value, freq\n\nDefine get\n→ Step 3: Check if key exists in keyMap // Determine presence\n    Yes → Step 4: Retrieve node // Get node\n        → Step 5: Increment freq // Update frequency\n        → Step 6: Move node from current freq list to freq+1 list // Re-link\n        → Step 7: If current freq list empty and freq == minFreq → Step 8: Increment minFreq // Update minFreq\n        → Step 9: Return node.value // Successful get\n    No  → Step 10: Return -1 // Key not found\n\nDefine put\n→ Step 11: If capacity == 0 → End // No storage\n→ Step 12: If key exists in keyMap\n    Yes → Step 13: Update node.value // Set new value\n        → Step 14: Perform same freq update as get // Reuse logic\n    No  → Step 15: If cache size == capacity\n        Yes → Step 16: Identify key to evict from freqMap[minFreq] head // Get LRU among min freq\n            → Step 17: Remove evicted key from keyMap // Delete mapping\n            → Step 18: Remove node from freqMap[minFreq] list // Delete from list\n        No → No action // No eviction needed\n        → Step 19: Create new node with freq=1 // New node\n            → Step 20: Add node to keyMap // Insert mapping\n            → Step 21: Add node to freqMap[1] list // Insert into freq list\n            → Step 22: Set minFreq = 1 // Reset minFreq\nEnd\n\nWe may need to include Decision blocks for various conditions. Use \"Decision:\" with \"Yes →\" \"No →\". The structure must include indentation for nested decisions.\n\nWe need to output line by line. Each line includes virtual code step, a space, then `//` comment.\n\nLet's create the output accordingly. Use proper indentation for nested decisions.\n\nThe user asked to generate \"虛擬碼\" and line-by-line explanation. So we need to produce the entire algorithm. Let's write.\n\nWe can start with:\n\nStart // 程式開始執行\n\n→ Step 1: Set capacity, minFreq, keyMap, freqMap // 初始化容量、最小頻率、鍵值對映射與頻率映射\n\nDefine Node structure maybe separate. But maybe we can skip explicit Node definition? We'll include.\n\n→ Step 2: Define Node(key, value, freq) // 資料節點包含鍵、值與頻率\n\nNow get function:\n\n→ Step 3: Define get(key) // 取得 key 的值\n\n→ Decision: key 在 keyMap 中? // 檢查 key 是否存在\n    Yes → Step 4: node = keyMap[key] // 取得節點\n        → Step 5: freq = node.freq // 讀取當前頻率\n        → Step 6: Remove node from freqMap[freq] list // 從舊頻率列表移除\n        → Step 7: node.freq = freq + 1 // 更新頻率\n        → Step 8: Add node to freqMap[freq+1] list // 加入新頻率列表\n        → Decision: freqMap[freq] 为空且 freq == minFreq? // 檢查是否需要調整最小頻率\n            Yes → Step 9: minFreq = minFreq + 1 // 更新最小頻率\n            No  → No // 保持不變\n        → Step 10: Return node.value // 回傳值\n    No  → Step 11: Return -1 // 未找到 key\n\nNow put function:\n\n→ Step 12: Define put(key, value) // 插入或更新 key\n\n→ Decision: capacity == 0? // 檢查容量是否為 0\n    Yes → End // 無法儲存\n    No  → No // 繼續\n\n→ Decision: key 在 keyMap 中? // 檢查 key 是否已存在\n    Yes → Step 13: node = keyMap[key] // 取得節點\n        → Step 14: node.value = value // 更新值\n        → Step 15: freq = node.freq // 讀取頻率\n        → Step 16: Remove node from freqMap[freq] list // 從舊頻率列表移除\n        → Step 17: node.freq = freq + 1 // 更新頻率\n        → Step 18: Add node to freqMap[freq+1] list // 加入新頻率列表\n        → Decision: freqMap[freq] 为空且 freq == minFreq? // 檢查是否需要調整最小頻率\n            Yes → Step 19: minFreq = minFreq + 1 // 更新最小頻率\n            No  → No // 保持不變\n    No  → Step 20: If keyMap.size == capacity? // 判斷是否已滿\n            Yes → Step 21: evictKey = freqMap[minFreq].head.key // 找到最舊的最小頻率鍵\n                → Step 22: Remove evictKey from keyMap // 從鍵值對映射移除\n                → Step 23: Remove evictKey node from freqMap[minFreq] list // 從頻率列表移除\n            No  → No // 不需要淘汰\n            → Step 24: Create new node(key, value, freq=1) // 新節點\n                → Step 25: Add node to keyMap // 插入鍵值對映射\n                → Step 26: Add node to freqMap[1] list // 插入頻率列表\n                → Step 27: minFreq = 1 // 重置最小頻率\n\nEnd // 程式結束\n\nBut we need to maintain indentation. Each step line uses arrow `→`. For decisions, indent inside. The structure above may need consistent indentation. Use spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set capacity, minFreq = 0, keyMap = {}, freqMap = {} // 初始化容量、最小頻率及映射表  \n→ Step 2: Define Node(key, value, freq) // 資料節點包含鍵、值與頻率  \n\n// ======== get(key) ========  \n→ Step 3: Define get(key) // 取得 key 的值  \n→ Decision: key 在 keyMap 中? // 檢查 key 是否存在  \n  Yes → Step 4: node = keyMap[key] // 取得節點  \n   → Step 5: freq = node.freq // 讀取當前頻率  \n   → Step 6: Remove node from freqMap[freq] list // 從舊頻率列表移除  \n   → Step 7: node.freq = freq + 1 // 更新頻率  \n   → Step 8: Add node to freqMap[freq+1] list // 加入新頻率列表  \n   → Decision: freqMap[freq] 为空且 freq == minFreq? // 若舊頻率表空且是最小頻率  \n    Yes → Step 9: minFreq = minFreq + 1 // 更新最小頻率  \n    No  → No // 不變  \n   → Step 10: Return node.value // 回傳值  \n  No  → Step 11: Return -1 // 未找到 key  \n\n// ======== put(key, value) ========  \n→ Step 12: Define put(key, value) // 插入或更新 key  \n→ Decision: capacity == 0? // 檢查容量是否為 0  \n  Yes → End // 無法儲存，直接結束  \n  No  → No // 繼續執行  \n→ Decision: key 在 keyMap 中? // 檢查 key 是否已存在  \n  Yes → Step 13: node = keyMap[key] // 取得節點  \n   → Step 14: node.value = value // 更新值  \n   → Step 15: freq = node.freq // 讀取頻率  \n   → Step 16: Remove node from freqMap[freq] list // 從舊頻率列表移除  \n   → Step 17: node.freq = freq + 1 // 更新頻率  \n   → Step 18: Add node to freqMap[freq+1] list // 加入新頻率列表  \n   → Decision: freqMap[freq] 为空且 freq == minFreq? // 檢查是否需調整最小頻率  \n    Yes → Step 19: minFreq = minFreq + 1 // 更新最小頻率  \n    No  → No // 保持不變  \n  No  → Step 20: If keyMap.size == capacity? // 判斷是否已滿  \n    Yes → Step 21: evictKey = freqMap[minFreq].head.key // 找到最舊的最小頻率鍵  \n     → Step 22: Remove evictKey from keyMap // 從鍵值對映射移除  \n     → Step 23: Remove evictKey node from freqMap[minFreq] list // 從頻率列表移除  \n    No  → No // 不需要淘汰  \n    → Step 24: node = Node(key, value, 1) // 新節點  \n    → Step 25: Add node to keyMap // 插入鍵值對映射  \n    → Step 26: Add node to freqMap[1] list // 插入頻率列表  \n    → Step 27: minFreq = 1 // 重置最小頻率  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    用前綴和做加權隨機挑選。\n    1. 建構時先把所有權重累積到 prefix_sum。\n    2. pickIndex 產生一個 1~total 之間的隨機整數，然後用二分搜尋\n       找到最小的 prefix_sum >= 隨機值，該索引即為結果。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []          # 前綴和\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total            # 所有權重總和\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        # bisect_left 回傳第一個大於等於 target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入為兩個列表：方法名稱和對應參數\n    # 例如： '[\"Solution\",\"pickIndex\"], [[[1]],[]]'\n    # 先將字串包在括號內，成為合法的 tuple 表達式\n    methods, args_list = ast.literal_eval('(' + raw_input + ')')\n\n    results = []          # 儲存每一次呼叫的結果\n    instance = None\n\n    for idx, method in enumerate(methods):\n        if method == \"Solution\":\n            # 第一個參數是權重列表\n            w = args_list[idx][0]\n            instance = Solution(w)\n            results.append(None)          # 建構器不回傳值，使用 None\n        else:\n            # 呼叫 pickIndex\n            res = instance.pickIndex()\n            results.append(res)\n\n    # 輸出 JSON 格式，將 None 轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The requirement: \"You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. Implement pickIndex() to randomly pick index based on weight.\" So we need to produce algorithm: preprocess cumulative weights array, total sum. In pickIndex, generate random number between 1 and sum inclusive, binary search for first cumulative >= rand. Provide step-by-step. Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Let's produce steps for initialization and pickIndex. Possibly we separate two functions: Constructor and pickIndex. Provide steps for constructor: compute cumulative array and total. Provide steps for pickIndex: generate random, binary search. Let's use decision arrow for binary search loop. Provide pseudocode. Use \"Start\" and \"End\". Provide line numbering maybe. But no numbers required. Just arrow steps.\n\nWe need to adhere to format: \"Start // 程式開始執行\" etc. Provide sequential steps. Use \"→\" for steps. Use \"Decision:\" for condition. Let's produce code. Ensure to use \"虛擬碼步驟\" meaning the step content, then space, then \"// 解釋\". Provide Chinese explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 prefix // 用於儲存累積權重  \n→ Step 2: 設定 totalWeight = 0 // 儲存所有權重總和  \n→ Step 3: For i in 0 .. w.length-1  \n    → Step 3.1: totalWeight += w[i] // 加總權重  \n    → Step 3.2: prefix[i] = totalWeight // 儲存到前綴和陣列  \n→ End // 完成建構階段  \n---  \nStart // pickIndex 呼叫開始  \n→ Step 1: randVal = RandomInt(1, totalWeight) // 產生 1 到總和之間的隨機整數  \n→ Step 2: low = 0; high = prefix.length - 1 // 設定二分搜尋區間  \n→ Decision: low <= high? // 是否還有區間可搜尋？  \n    Yes → Step 3: mid = (low + high) // 2 // 取中點  \n        Decision: randVal <= prefix[mid]? // 隨機值是否落在 mid 索引的區間內？  \n            Yes → Step 4: return mid // 找到符合條件的索引  \n            No  → Step 5: low = mid + 1 // 搜尋右半區間  \n        → Step 6: 從 Step 2 回到 Decision  \n    No  → Step 7: return -1 // 理論上不會發生，僅作安全回傳  \nEnd // pickIndex 執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,0,3]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[2,0,3]'\nRaw Got:      '[0]'"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[0]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # Binary search to count soldiers (1s) in a row\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # Build list of (soldier_count, row_index)\n        rows_info = [(count_soldiers(row), idx) for idx, row in enumerate(mat)]\n        # Sort by soldier count then by row index\n        rows_info.sort()\n        # Extract first k row indices\n        return [idx for _, idx in rows_info[:k]]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Flexible input parsing: handle \"mat = [...], k = ...\" or two lines\n    if \"k =\" in data:\n        mat_part, k_part = data.split(\"k =\", 1)\n        mat_str = mat_part.split(\"=\", 1)[1].strip()\n        k_str = k_part.strip()\n        mat = ast.literal_eval(mat_str)\n        k = int(k_str)\n    else:\n        lines = data.splitlines()\n        mat = ast.literal_eval(lines[0].strip())\n        k = int(lines[1].strip())\n\n    sol = Solution()\n    result = sol.kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The problem: given binary matrix, each row has all 1s then 0s. Find k weakest rows indices sorted by weakness. Approach: compute soldier count per row via binary search or linear. Then sort rows by count then index. Then return first k indices.\n\nWe need to produce step-by-step virtual code with arrows and decisions. Ensure each line is in format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: and arrows.\n\nWe need to cover: Input reading, count soldiers per row, store pair (count, index), sort, pick first k, output indices. Might include helper function to count soldiers via binary search. We'll produce pseudocode. Each line with arrow or indent. Use \"→\" to indicate next step. For decisions: \"Decision: condition?\" then Yes/No.\n\nWe need to ensure the steps are sequential, each line separate.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty list rowsInfo // store pairs (soldierCount, rowIndex)\n→ Step 2: For each rowIndex from 0 to m-1\n    → Decision: Count soldiers in row rowIndex? // use binary search to find first 0\n        Yes → Step 3: binarySearchFirstZero(row) → return firstZeroIdx // index of first 0\n        No → Step 4: soldierCount = firstZeroIdx // number of 1s\n    → Step 5: Append (soldierCount, rowIndex) to rowsInfo // store row data\n→ Step 6: Sort rowsInfo by (soldierCount ascending, rowIndex ascending) // order by weakness\n→ Step 7: Initialize result list weakIndices\n→ Decision: k > 0? // ensure k is positive\n    Yes → Step 8: For i from 0 to k-1\n        → Step 9: weakIndices.append(rowsInfo[i].rowIndex) // collect weakest k indices\n    No → Step 10: weakIndices remains empty\n→ Step 11: Return weakIndices // output result\nEnd\n\nBut we need to include binarySearchFirstZero function as separate step maybe. Provide details.\n\nLet's produce more detailed pseudocode with function definitions:\n\nStart\n→ Step 1: Define function countSoldiers(row)\n    → Step 1a: left = 0, right = length(row)\n    → Decision: left < right? // binary search loop\n        Yes → Step 1b: mid = (left + right) / 2\n              → Decision: row[mid] == 1? // still soldier\n                  Yes → Step 1c: left = mid + 1\n                  No  → Step 1d: right = mid\n        No  → Step 1e: Return left // number of 1s\nEnd function\n→ Step 2: Initialize empty list rowsInfo\n→ Decision: matrix is not empty? // to handle edge case\n    Yes → Step 3: For each rowIndex in 0 .. m-1\n        → Step 4: soldierCount = countSoldiers(matrix[rowIndex]) // get count\n        → Step 5: Append (soldierCount, rowIndex) to rowsInfo\n    No → Step 6: rowsInfo remains empty\n→ Step 7: Sort rowsInfo by soldierCount ascending, then rowIndex ascending\n→ Step 8: Initialize empty list weakIndices\n→ Decision: k > 0? // guard\n    Yes → Step 9: For i in 0 .. k-1\n        → Step 10: weakIndices.append(rowsInfo[i].rowIndex)\n    No → Step 11: weakIndices stays empty\n→ Step 12: Return weakIndices\nEnd\n\nBut we need to use the arrow notation and indent lines accordingly. Use \"→\" at each step. For decisions, indent Yes and No with spaces.\n\nAlso each line must be \"虛擬碼步驟 // 解釋\". We'll include comments.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define function countSoldiers(row) // 建立計算每列士兵數量的輔助函式  \n    → Step 1a: left = 0, right = length(row) // 初始化二分搜尋範圍  \n    → Decision: left < right? // 進入二分搜尋迴圈  \n        Yes → Step 1b: mid = (left + right) / 2 // 計算中間位置  \n            → Decision: row[mid] == 1? // 判斷中間是否還是士兵  \n                Yes → Step 1c: left = mid + 1 // 右半段繼續搜尋  \n                No  → Step 1d: right = mid // 左半段繼續搜尋  \n        No → Step 1e: Return left // left 為第一個 0 的索引，即士兵數量  \nEnd function // 結束函式定義  \n\n→ Step 2: Initialize empty list rowsInfo // 用來存放 (士兵數, 行號)  \n→ Decision: matrix is not empty? // 確保矩陣非空  \n    Yes → Step 3: For each rowIndex in 0 .. m-1  \n        → Step 4: soldierCount = countSoldiers(matrix[rowIndex]) // 計算該列士兵數  \n        → Step 5: Append (soldierCount, rowIndex) to rowsInfo // 儲存資料  \n    No → Step 6: rowsInfo remains empty // 空矩陣情況  \n\n→ Step 7: Sort rowsInfo by soldierCount ascending, then rowIndex ascending // 排序弱到強  \n→ Step 8: Initialize empty list weakIndices // 用來儲存最弱 k 行的索引  \n→ Decision: k > 0? // 檢查 k 是否有效  \n    Yes → Step 9: For i in 0 .. k-1  \n        → Step 10: weakIndices.append(rowsInfo[i].rowIndex) // 取出前 k 個行號  \n    No → Step 11: weakIndices stays empty // k 為 0 時直接返回空  \n\n→ Step 12: Return weakIndices // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    \"\"\"\n    Generate the shortest string that will unlock the safe.\n    It is the De Bruijn sequence B(k, n) followed by the initial (n-1)-digit prefix.\n    \"\"\"\n    # Visited set for edges represented as strings of length n\n    seen = set()\n    result = []\n\n    def dfs(node: str):\n        \"\"\"\n        Hierholzer's algorithm: traverse all edges in the De Bruijn graph.\n        `node` is a string of length n-1 (the current vertex).\n        \"\"\"\n        for digit in map(str, range(k)):\n            nxt = node + digit\n            if nxt not in seen:\n                seen.add(nxt)\n                dfs(nxt[1:])   # move to the next vertex (drop the first char)\n                result.append(digit)\n\n    start = '0' * (n - 1)\n    dfs(start)\n    # The traversal records digits in reverse order, so reverse at the end\n    return ''.join(result[::-1]) + start\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract all integers from the input; the first is n, the second is k\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        print(\"Invalid input\")\n        return\n    n, k = nums[0], nums[1]\n    answer = crack_safe(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to construct a minimal length string that guarantees unlock for any password of length n digits each digit from [0,k-1]. This is classic De Bruijn sequence generation. So steps: generate de Bruijn sequence B(k, n). Then output that string. Provide virtual code: Start, Step to create array of digits, recursive function deBruijn, append, etc. Must be line-by-line. Use arrows. Provide explanation. No actual code. Use Start, Decision, etc. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 `k` 為字元集合大小，`n` 為密碼長度 // 取得輸入參數  \n→ Step 2: 初始化空陣列 `a`，長度為 `k * n`，並將所有元素設為 0 // 用於遞迴演算法的輔助陣列  \n→ Step 3: 建立空字串變數 `sequence` 以存放最終結果 // 儲存 De Bruijn 序列  \n→ Step 4: 定義遞迴函式 `deBruijn(t, p)`  \n  → Decision: 是否 `t > n`? // 判斷遞迴結束條件  \n   Yes → If `n % p == 0` // 若 `p` 為 `n` 的除子  \n    → Step 5: 將 `a[1..p]` 之值依序追加到 `sequence` // 產生有效子序列  \n   No → End // 退出遞迴  \n   No → Set `a[t] = a[t - p]` // 重複前一個元素以構成節點  \n   → Step 6: 呼叫 `deBruijn(t + 1, p)` // 深入下一層  \n   → For `j` 從 `a[t - p] + 1` 到 `k - 1`  \n    → Step 7: 設定 `a[t] = j`  \n    → Step 8: 呼叫 `deBruijn(t + 1, t)` // 以新的分割點進行遞迴  \n→ Step 9: 呼叫 `deBruijn(1, 1)` // 從第一個位置開始遞迴生成序列  \n→ Step 10: 將 `sequence` 轉換為字串形式，並將其輸出作為答案 // 最短字串已產生  \nEnd // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 如果任一數字為 0，直接返回 \"0\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 結果長度最多為 m + n\n        pos = [0] * (m + n)\n\n        # 逐位相乘，從右往左\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = (ord(num1[i]) - 48) * (ord(num2[j]) - 48)\n                p1, p2 = i + j, i + j + 1\n                total = mul + pos[p2]\n                pos[p1] += total // 10          # 進位累加到前一位\n                pos[p2] = total % 10            # 取餘數存入當前位\n\n        # 把數組轉成字串，去除前導 0\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result or \"0\"   # 若結果為空，表示 0\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中找出所有連續的數字\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        return\n    num1, num2 = nums[0], nums[1]\n    sol = Solution()\n    print(sol.multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for string multiplication of two non-negative integers without built-in big integer or conversion. It's essentially implementing grade-school multiplication. Steps: If either is \"0\", return \"0\". Prepare result array length sum of lengths. For each digit from right to left in num1 and num2 multiply and add to result array positions. Handle carry. Then convert to string trimming leading zeros. Provide each line with explanation.\n\nWe need to output line by line: \"Start // 程式開始執行\", etc. Use virtual arrows.\n\nLet's produce.\n\nWe should include loops. Use nested loops. We can use indices i, j. Use decision for zero check.\n\nLet's write:\n\nStart // 程式開始執行\n→ Decision: 是否 num1 為 '0' 或 num2 為 '0'? // 檢查是否有零輸入\n    Yes → Step 1: 返回 '0' // 若任一為零，直接回傳\n    No  → Step 2: 初始化結果陣列 len = len(num1)+len(num2) 並設為 0 // 用於累積乘法結果\n→ For i from len(num1)-1 downto 0 // 遍歷 num1 的每位\n    → For j from len(num2)-1 downto 0 // 遍歷 num2 的每位\n        → Step 3: 計算 digit1 = num1[i] - '0' // 取得數字\n        → Step 4: 計算 digit2 = num2[j] - '0' // 取得數字\n        → Step 5: product = digit1 * digit2 + result[i+j+1] // 加上前一次累積\n        → Step 6: result[i+j+1] = product % 10 // 存入目前位\n        → Step 7: result[i+j] += product / 10 // 將進位累加至前一位\n→ Step 8: 將結果陣列轉成字串，跳過前置零 // 建立最終答案\n→ End // 程式執行結束\n\nBut we need \"virtual code\" arrow formatting: Use \"→ Step x:\" for each action, \"Decision:\" for if.\n\nAlso need to indent decision branches properly.\n\nUse the arrow and indentation as example: They used indent inside decision.\n\nWe'll produce accordingly.\n\nNeed each line separated. Provide explanation after //.\n\nAlso we must not output actual code. Just virtual steps.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 是否 num1 為 '0' 或 num2 為 '0'? // 檢查是否有零輸入\n    Yes → Step 1: 返回 '0' // 若任一為零，直接回傳\n    No  → Step 2: 初始化結果陣列 len = len(num1)+len(num2) 並設為 0 // 用於累積乘法結果\n→ For i from len(num1)-1 downto 0 // 遍歷 num1 的每位\n    → For j from len(num2)-1 downto 0 // 遍歷 num2 的每位\n        → Step 3: digit1 = num1[i] - '0' // 取得 num1 第 i 位的整數\n        → Step 4: digit2 = num2[j] - '0' // 取得 num2 第 j 位的整數\n        → Step 5: product = digit1 * digit2 + result[i+j+1] // 加上先前累積的值\n        → Step 6: result[i+j+1] = product % 10 // 設定目前位數\n        → Step 7: result[i+j] += product / 10 // 將進位加到前一位\n→ Step 8: 轉換結果陣列為字串，並跳過前置零 // 產生最終乘積字串\nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def hIndex(self, citations):\n        n = len(citations)\n        if n == 0:\n            return 0\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # At index mid, there are n - mid papers with citations >= citations[mid]\n            if citations[mid] >= n - mid:\n                # Move right to find a larger h\n                left = mid + 1\n            else:\n                right = mid - 1\n        # left is the first index where citations[left] < n - left\n        # Therefore, h-index is n - left\n        return n - left\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract a list of integers from the input string.\n    Handles inputs like:\n      - 'citations = [0,1,3,5,6]'\n      - '[1,2,100]'\n      - '0 1 3 5 6'\n    \"\"\"\n    # Try to find a list literal\n    match = re.search(r'\\[.*\\]', data, re.DOTALL)\n    if match:\n        try:\n            return ast.literal_eval(match.group(0))\n        except Exception:\n            pass\n    # Fallback: extract all integers\n    tokens = re.findall(r'-?\\d+', data)\n    return [int(tok) for tok in tokens]\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    citations = parse_input(raw)\n    solution = Solution()\n    result = solution.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. Problem: compute h-index from sorted array of citations. Need logarithmic time: binary search. Steps: find largest index i such that citations[i] >= n-i (where n length). Then h = n-i. Use binary search on indices 0..n-1. Steps: Start, compute n, low=0, high=n-1, ans=0. While low <= high: mid=(low+high)/2. If citations[mid] >= n-mid: ans=n-mid; low=mid+1; else high=mid-1. End loop, return ans. Also handle empty array return 0. Let's produce virtual code with explanations per line.\n\nWe need to use structure: Start, Decision, etc. Provide arrow. Each line: \"虛擬碼步驟 // 解釋\". Use arrow for flow. Let's produce.\n\nWe'll start with Start. Then Step: Initialize variables. Then Decision: empty? etc. Provide binary search loop. Use arrow for loops.\n\nBut we need to use arrow \"→\" and indent decision branches.\n\nWe need to show binary search logic: Use Decision: citations[mid] >= n-mid? Yes → store ans, low=mid+1 else high=mid-1.\n\nWe also need to loop. Might use while decision: while low <= high? Use Decision for loop condition.\n\nWe'll produce as:\n\nStart // 程式開始執行\n→ Step 1: Let n be length of citations // 取得陣列長度\n→ Decision: 若 n==0? // 檢查是否為空陣列\n    Yes → Step 2: 回傳 0 // 空陣列時 h-index 為 0\n    No  → Step 3: low=0, high=n-1, ans=0 // 初始化二分搜尋參數\n→ Decision: while low <= high? // 進行二分搜尋\n    Yes → Step 4: mid=(low+high)/2 // 計算中點\n    → Decision: citations[mid] >= n-mid? // 判斷此位置是否符合 h-index 條件\n        Yes → Step 5: ans=n-mid // 更新 h-index\n        → Step 6: low=mid+1 // 在右半區繼續搜尋更大的 h-index\n        No  → Step 7: high=mid-1 // 在左半區搜尋\n    No → Step 8: 回傳 ans // 搜尋結束，返回結果\nEnd // 程式執行結束\n\nNeed to maintain arrow indent: In example they used nested indents for decisions. We'll follow.\n\nAlso need to include \"→ Decision:\" lines. For loop we might use while decision. Provide Yes/No branches.\n\nMake sure to include spaces after arrow. Provide explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n be length of citations // 取得陣列長度  \n→ Decision: 若 n==0? // 檢查是否為空陣列  \n    Yes → Step 2: 回傳 0 // 空陣列時 h-index 為 0  \n    No  → Step 3: low=0, high=n-1, ans=0 // 初始化二分搜尋參數  \n→ Decision: while low <= high? // 進行二分搜尋  \n    Yes → Step 4: mid=(low+high)/2 // 計算中點  \n    → Decision: citations[mid] >= n-mid? // 判斷此位置是否符合 h-index 條件  \n        Yes → Step 5: ans=n-mid // 更新 h-index  \n        → Step 6: low=mid+1 // 在右半區繼續搜尋更大的 h-index  \n        No  → Step 7: high=mid-1 // 在左半區搜尋  \n    No → Step 8: 回傳 ans // 搜尋結束，返回結果  \nEnd // 程式執行結束"
    }
  ]
}