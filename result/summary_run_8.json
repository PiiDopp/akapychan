{
  "run_index": 8,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 293,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 先讀取 stdin，確保程式在需要時能從標準輸入取得資料\n    sys.stdin.read()\n\n    try:\n        # 用 with 語法開啟檔案，並自動關閉\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        # 輸出檔案總行數\n        print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        # 檔案不存在時顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation, no actual code. Use arrows and decision. Steps: Start, open file with with, try except, read lines, count, output count, except FileNotFoundError: output message, End. Need to use virtual code syntax.\n\nWe must not output real code, just the structure.\n\nMake sure each line is \"虛擬碼步驟 [space] // 解釋\". Use Start, →, Decision, Yes →, No →, End.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 嘗試以讀取模式打開 'data.txt' // 開啟檔案\n→ Decision: 是否成功開啟檔案? // 檢查是否發生例外\n    Yes → Step 2: 讀取所有行並儲存到 list // 讀取檔案內容\n    Yes → Step 3: 計算 list 長度並輸出 // 取得行數並顯示\n    No  → Step 4: 輸出 '找不到檔案！' // 檔案不存在時提示\nEnd // 程式執行結束\n\nBut need to represent try/except. Might include a Decision block: Decision: 是否 FileNotFoundError? No.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: 用 with 語法嘗試開啟 'data.txt' // 開啟檔案\n→ Decision: 是否成功打開? // 判斷是否觸發例外\n    Yes → Step 2: 讀取所有行到 list // 讀檔\n    Yes → Step 3: 計算行數並輸出 // 顯示行數\n    No  → Decision: 是否 FileNotFoundError? // 檢查例外類型\n        Yes → Step 4: 輸出 '找不到檔案！' // 顯示錯誤訊息\n        No  → Step 5: 重新拋出例外 // 其他錯誤\nEnd // 程式結束\n\nBut maybe simpler: Use Decision: 是否 FileNotFoundError? inside No branch.\n\nBut spec says use with syntax and try/except. So we need to show the exception handling logic. Use a Decision for FileNotFoundError.\n\nSo we need to show the try block, but virtual code representation: We can indicate Try block then Catch block.\n\nWe might do:\n\nStart\n→ Step 1: 開始 try\n→ Decision: 是否成功開啟檔案? // 進入 try 內部\n    Yes → Step 2: 讀取行數 // ...\n    Yes → Step 3: 輸出行數\n    No  → Decision: 是否 FileNotFoundError? // 進入 except\n        Yes → Step 4: 輸出 '找不到檔案！'\n        No  → Step 5: 重新拋出例外\nEnd\n\nBut we must incorporate with. Maybe:\n\nStep 1: 用 with 內部讀取檔案 // with 語法\n\nBut we can't show actual code, just structure.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 嘗試以讀取模式打開 'data.txt'，使用 with 語法 // 開啟檔案，確保檔案會自動關閉  \n→ Decision: 是否成功打開檔案? // 判斷是否觸發 FileNotFoundError  \n  Yes → Step 2: 讀取檔案所有行並儲存至 list // 取得每一行的內容  \n  Yes → Step 3: 計算 list 長度並輸出 // 顯示總行數  \n  No → Decision: 是否為 FileNotFoundError? // 判斷例外類型  \n   Yes → Step 4: 輸出 '找不到檔案！' // 檔案不存在時的提示訊息  \n   No → Step 5: 重新拋出例外 // 其他非檔案不存在的錯誤傳遞至上層  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,5,2,5,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 5, 2, 5, 6]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    \"\"\"\n    主程式：讀取標準輸入，執行其中的程式碼。\n    \"\"\"\n    # 讀取整個標準輸入\n    code = sys.stdin.read()\n    # 在全域命名空間下執行輸入的程式碼\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code lines with comments explaining each step, using the arrow style, etc.\n\nThe requirement: \"請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。\"\n\nWe need to produce virtual code steps for that requirement. Use Start, End, Decision, etc. But it's a simple function; no decisions needed. We could still show loops.\n\nThe virtual code should include:\n\nStart // 程式開始執行\n→ Step 1: Import random module // 導入 random\n→ Step 2: Define function roll_dice(n): // 定義函式\n→ Step 3: Initialize empty list results // 建立結果列表\n→ Step 4: For i from 1 to n: // 進行 n 次擲骰\n   → Step 4.1: Generate random integer 1-6 // 擲骰\n   → Step 4.2: Append to results // 存入列表\n→ Step 5: Return results // 回傳列表\nEnd // 程式執行結束\n\nAlso note that Step numbering can be linear.\n\nLet's produce virtual code lines accordingly.\n\nWe should include the arrow \"→\" before each step. For loop we can show \"Decision\" for loop condition but not necessary. We can just show \"→ Step 4: For i from 1 to n:\" but we can break into sub-steps.\n\nAlso we can show \"Decision: 是否還有剩餘次數?\" but that might be overkill. It's fine.\n\nThe output must be exactly each line with \"虛擬碼步驟\" then space then comment. For each line we put //.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import random // 導入 random 模組\n→ Define function roll_dice(n): // 定義 roll_dice 函式\n→ Initialize empty list results // 用來儲存每次擲骰結果\n→ For i in range(1, n+1): // 從 1 到 n 進行迴圈\n   → Generate random integer 1-6 using random.randint(1,6) // 模擬一次擲骰\n   → Append the generated number to results // 將結果加入列表\n→ Return results // 回傳所有擲骰結果\nEnd // 程式執行結束\n\nBut need each line separate. Also for nested lines, we indent. But spec says \"逐行輸出\" each line must include \"虛擬碼步驟\" + space + comment. So we need to maintain indentation but still each line as a separate line. We could use spaces to indicate indentation but it's okay.\n\nThus:\n\nStart // 程式開始執行\n→ Import random // 導入 random 模組\n→ Define function roll_dice(n): // 定義 roll_dice 函式\n→ Initialize empty list results // 用來儲存每次擲骰結果\n→ For i in range(1, n+1): // 從 1 到 n 進行迴圈\n    → Generate random integer 1-6 using random.randint(1,6) // 模擬一次擲骰\n    → Append the generated number to results // 將結果加入列表\n→ Return results // 回傳所有擲骰結果\nEnd // 程式執行結束\n\nWe need to ensure each line is separate. So we have 8 lines. The lines with nested steps need indentation; but we can just put a space before the arrow or 4 spaces. We'll show as \"→\" but maybe \"    →\" for nested. But spec not strict about indentation, just \"每行\" containing virtual code step and comment. We'll just use indentation for readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 導入 random 模組  \n→ Define function roll_dice(n): // 定義 roll_dice 函式  \n→ Initialize empty list results // 用來儲存每次擲骰結果  \n→ For i in range(1, n+1): // 從 1 到 n 進行迴圈  \n    → Generate random integer 1-6 using random.randint(1,6) // 模擬一次擲骰  \n    → Append the generated number to results // 將結果加入列表  \n→ Return results // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    script = sys.stdin.read()\n    exec(script, {'measure_time': measure_time})\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, using arrow, Start, End, Decision, etc. For this function. The user wants a function measure_time(func, *args) that measures execution time using time module, returns result rounded to 3 decimal places. So we will produce steps:\n\nStart\n→ Step: 載入 time 模組\n→ Step: 定義函數 measure_time(func, *args)\n→ Decision? Not needed.\n\nInside function:\n- record start time\n- call func(*args)\n- record end time\n- compute elapsed = end - start\n- round elapsed to 3 decimal places\n- return elapsed\n\nReturn value: result.\n\nThen End.\n\nWe need to output as virtual code with each line explanation. Use arrows, etc.\n\nWe need to adhere to formatting. For function, we might use \"→ Step: 定義函數 measure_time(func, *args)\" but inside we need indent? Use spaces? The format example shows indentation with spaces, no special syntax. Use arrow \"→\" for each step. Use Decision? We might not need decision.\n\nMaybe add a Decision: if needed? But not necessary.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 導入 time 模組 // 引入 time 模組以取得時間資訊\n→ Step: 定義函數 measure_time(func, *args) // 建立計時函式\n    → Step: 記錄開始時間 start = time.time() // 取得函式執行前的時間戳\n    → Step: 執行目標函式 result = func(*args) // 呼叫傳入的函式並傳遞參數\n    → Step: 記錄結束時間 end = time.time() // 取得函式執行後的時間戳\n    → Step: 計算耗時 elapsed = end - start // 計算兩者之差得到秒數\n    → Step: 四捨五入結果 rounded = round(elapsed, 3) // 取到小數點三位\n    → Step: 回傳 rounded // 傳回計算後的時間\nEnd // 程式執行結束\n\nWe should format exactly: each line ends with \"// 解釋\". We need indent for nested steps? In example, they used indentation with spaces before arrow. Use same style.\n\nSo lines:\n\nStart // 程式開始執行\n→ Step: 導入 time 模組 // 引入 time 模組以取得時間資訊\n→ Step: 定義函數 measure_time(func, *args) // 建立計時函式\n    → Step: 記錄開始時間 start = time.time() // 取得函式執行前的時間戳\n    → Step: 執行目標函式 result = func(*args) // 呼叫傳入的函式並傳遞參數\n    → Step: 記錄結束時間 end = time.time() // 取得函式執行後的時間戳\n    → Step: 計算耗時 elapsed = end - start // 計算兩者之差得到秒數\n    → Step: 四捨五入結果 rounded = round(elapsed, 3) // 取到小數點三位\n    → Step: 回傳 rounded // 傳回計算後的時間\nEnd // 程式執行結束\n\nCheck: Each line uses \"→ Step:\" etc. The nested lines have spaces before arrow. Use 4 spaces indentation? The example uses 4 spaces before arrow for nested decision. They used \"    Yes →\" etc. So we can use 4 spaces indent for nested steps.\n\nMake sure each line has explanation after //.\n\nWe must not output actual code. Only virtual code. So we should not include import time as actual code? But we can mention \"導入 time 模組\" which is conceptual. It's fine.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 導入 time 模組 // 引入 time 模組以取得時間資訊\n→ Step: 定義函數 measure_time(func, *args) // 建立計時函式\n    → Step: 記錄開始時間 start = time.time() // 取得函式執行前的時間戳\n    → Step: 執行目標函式 result = func(*args) // 呼叫傳入的函式並傳遞參數\n    → Step: 記錄結束時間 end = time.time() // 取得函式執行後的時間戳\n    → Step: 計算耗時 elapsed = end - start // 計算兩者之差得到秒數\n    → Step: 四捨五入結果 rounded = round(elapsed, 3) // 取到小數點三位\n    → Step: 回傳 rounded // 傳回計算後的時間\nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"apple\",\"melon\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'apple', 'melon', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入但此題不需要實際使用，僅為符合「從 stdin 讀取」的要求\n    _ = sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除 'pineapple'（不存在不拋錯）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments explaining each line. Use structure Start, Step, Decision, End. The steps: define set, add, update, remove, discard, print. Need to show each line.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增橘子\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增葡萄和哈密瓜\n→ Step 4: fruits.remove('banana') // 移除香蕉\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的奇異果，不會拋錯\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式結束\n\nNeed to adhere to format: each line must have virtual code step and comment. Use → arrow. Use step numbering. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 初始化集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'（不存在不拋錯）  \n→ Step 6: print(fruits) // 輸出最終集合 fruits  \nEnd // 程式結束執行"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.82TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.82 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\nfrom tkinter import messagebox\n\ndef fetch_rate():\n    \"\"\"\n    從 exchangerate-api 取得 USD → TWD 的匯率。\n    若成功返回 float，失敗則回傳 None。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()          # 若 HTTP 狀態碼不是 200 就拋例外\n        data = response.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return float(rate)\n    except Exception:\n        return None\n\n# ---------------- GUI 相關 ----------------\ndef start_gui():\n    \"\"\"\n    建立 tkinter GUI，包含標籤顯示匯率與更新按鈕。\n    \"\"\"\n    def update_label():\n        rate = fetch_rate()\n        if rate is not None:\n            lbl_rate.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            lbl_rate.config(text=\"更新失敗，請檢查網路連線\")\n\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    lbl_rate = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    lbl_rate.pack(pady=10)\n\n    btn_update = tk.Button(win, text=\"更新匯率\", command=update_label)\n    btn_update.pack(pady=5)\n\n    win.mainloop()\n\n# ---------------- 主程式 ----------------\ndef main():\n    \"\"\"\n    1. 若 stdin 為 tty（使用者在互動式執行），啟動 GUI。\n    2. 若 stdin 不是 tty（被傳入資料），則以 console 模式處理。\n    \"\"\"\n    if sys.stdin.isatty():\n        # 互動式執行，啟動 GUI\n        start_gui()\n    else:\n        # 讀取 stdin 的所有輸入\n        command = sys.stdin.read().strip()\n        if command == \"按下「更新匯率」按鈕\":\n            rate = fetch_rate()\n            if rate is not None:\n                print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n            else:\n                print(\"更新失敗，請檢查網路連線\")\n        else:\n            # 其餘指令可自行處理，這裡簡單回傳錯誤訊息\n            print(\"無效指令\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with each line containing \"虛擬碼步驟 // 解釋\" after a space. Use arrows → and Decision: and Start/End.\n\nWe need to produce steps for a Python script using requests to call the API, get USD to TWD rate, display in tkinter, with button to refresh. Must be in Traditional Chinese.\n\nWe must not output actual code, only virtual code steps. So we need to use generic steps like \"Start\", \"→ Import requests and tkinter\", etc.\n\nThe user wants virtual code in the format: \"Start // 程式開始執行\" etc.\n\nWe must obey the formatting guidelines: each line has \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows (→, Yes →, No →) and structure Start/End/Decision.\n\nWe need to produce a sequence that includes: import, create tkinter root window, create label to show rate, create button that triggers refresh function, define refresh function that makes API call, parse JSON, update label, start main loop.\n\nWe should include decisions? For error handling: if request fails or rate missing. Decision: \"如果 API 呼叫成功?\" -> Yes -> parse and update; No -> show error message.\n\nAlso maybe Decision: \"是否取得 TWD 兜換率?\" -> Yes -> update label; No -> show default.\n\nOk.\n\nLet's produce lines.\n\nRemember each line must have virtual code step, then space, then // explanation.\n\nWe can use \"Start\" then \"→ Import necessary modules\" etc.\n\nUse arrow for each step.\n\nWe need to use virtual code with arrow \"→\". We might also use \"Decision:\".\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Import requests and tkinter modules // 匯入所需的函式庫\n→ Define function fetch_rate() // 定義取得匯率的函式\n    → Make GET request to https://api.exchangerate-api.com/v4/latest/USD // 呼叫匯率 API\n    → Decision: 如果回應成功? // 檢查 HTTP 狀態碼是否 200\n        Yes → Parse JSON response // 解析回傳的 JSON 資料\n        No  → Return error message // 回傳錯誤訊息\n    → Decision: 是否包含 TWD 匯率? // 檢查 JSON 中是否有 TWD 鍵\n        Yes → Extract rate value // 取得 TWD 匯率值\n        No  → Return None // 沒有該匯率時回傳 None\n→ Create tkinter root window // 建立主視窗\n→ Create label widget to display rate // 建立顯示匯率的標籤\n→ Create button widget with command to refresh rate // 建立更新按鈕並綁定刷新函式\n→ Define function update_rate() // 定義按鈕觸發的刷新功能\n    → Call fetch_rate() // 取得最新匯率\n    → Decision: 若取得到匯率? // 檢查是否成功取得\n        Yes → Update label text with rate // 更新標籤內容為最新匯率\n        No  → Update label text with '取得失敗' // 顯示錯誤訊息\n→ 初始化顯示匯率 // 初始時更新一次顯示\n→ 進入 tkinter 主迴圈 // 啟動 GUI 事件循環\nEnd // 程式執行結束\n\nBut we need each line separated with newlines. We must ensure formatting: start line with \"Start\", each subsequent line starting with \"→\" or \"Decision:\" etc. For nested lines, we might indent? The example didn't indent but had nested within arrow. They used spaces indentation. We can indent with 4 spaces or a tab? Use spaces to indicate nesting.\n\nBetter to use indent with 4 spaces for inner steps. Provide lines accordingly.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests and tkinter modules // 匯入 requests 與 tkinter 函式庫  \n→ Define function fetch_rate() // 定義取得匯率的函式  \n → Make GET request to https://api.exchangerate-api.com/v4/latest/USD // 呼叫匯率 API  \n → Decision: 如果回應成功? // 檢查 HTTP 狀態碼是否為 200  \n  Yes → Parse JSON response // 解析回傳的 JSON 資料  \n  No  → Return error message // 回傳錯誤訊息  \n → Decision: 是否包含 TWD 匯率? // 檢查 JSON 中是否有 TWD 鍵  \n  Yes → Extract rate value // 取得 TWD 匯率值  \n  No  → Return None // 沒有該匯率時回傳 None  \n→ Create tkinter root window // 建立主視窗  \n→ Create label widget to display rate // 建立顯示匯率的標籤  \n→ Create button widget with command to refresh rate // 建立更新按鈕並綁定刷新函式  \n→ Define function update_rate() // 定義按鈕觸發的刷新功能  \n → Call fetch_rate() // 取得最新匯率  \n → Decision: 若取得到匯率? // 檢查是否成功取得  \n  Yes → Update label text with rate // 更新標籤內容為最新匯率  \n  No  → Update label text with '取得失敗' // 顯示錯誤訊息  \n→ 初始化顯示匯率 // 初始時更新一次顯示  \n→ 進入 tkinter 主迴圈 // 啟動 GUI 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[None,[2,0],[0,0],[1,0],None,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[None, [2, 0], [0, 0], [1, 0], None, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split the two lists: operations and parameters\n    data = data.replace('],', ']|', 1)\n    ops_str, params_str = data.split('|', 1)\n    ops = ast.literal_eval(ops_str)\n    params = ast.literal_eval(params_str)\n\n    res = []\n    obj = None\n    for op, param in zip(ops, params):\n        if op == \"Solution\":\n            obj = Solution(param[0], param[1])\n            res.append(None)\n        elif op == \"flip\":\n            res.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            res.append(None)\n        else:\n            res.append(None)\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the solution class with flip and reset, using random minimal calls. This is a known Leetcode 503 solution: Use reservoir sampling? Actually typical solution: Keep mapping from integer index to another. Represent matrix as flattened list of size m*n. Keep list of available indices. Initially all 0..m*n-1. When flip, pick random k from 0..size-1; index = avail[k]; then set avail[k] = avail[size-1]; size--; return index in 2D. Reset: clear mapping; size = m*n.\n\nWe need to produce virtual code with steps and explanation. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrow syntax. Let's outline:\n\nStart\n→ Step 1: Initialize m, n, total = m*n // store dimensions\n→ Step 2: Create mapping dict // map index to replacement\n→ Step 3: Set remaining = total // number of available zeros\nEnd? Actually we need to include methods.\n\nDefine class Solution:\n    Step: Initialize constructor\n    → Step: Set self.m = m\n    → Step: Set self.n = n\n    → Step: Set self.total = m * n\n    → Step: Set self.rem = self.total\n    → Step: Create empty map dict // mapping for swapped indices\n    → Step: Return\n\nMethod flip():\n    → Step: Generate random integer r in [0, self.rem-1] // pick random available index\n    → Step: If r in mapping: val = mapping[r] else val = r // get actual index\n    → Step: If self.rem-1 in mapping: last = mapping[self.rem-1] else last = self.rem-1 // get last available index\n    → Step: mapping[r] = last // replace r with last\n    → Step: Decrement self.rem\n    → Step: Compute row = val // self.n, col = val % self.n\n    → Step: Return [row, col]\n\nMethod reset():\n    → Step: Clear mapping // empty dict\n    → Step: Set self.rem = self.total // reset remaining count\n\nThis is minimal random calls: one per flip. Complexity: O(1) time, O(k) space where k is number of flips.\n\nWe need to format each line with \"虛擬碼步驟 // 解釋\". Use arrows \"→\". Use structure.\n\nMake sure each line has virtual code and explanation. No actual code. Use step numbers? We can just present each line.\n\nLet's produce pseudocode like:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→ Constructor: Solution(m, n) // 初始化\n    → Step 1: self.m ← m // 儲存行數\n    → Step 2: self.n ← n // 儲存列數\n    → Step 3: self.total ← m × n // 總格數\n    → Step 4: self.rem ← self.total // 仍可翻轉的格數\n    → Step 5: self.map ← EmptyMap() // 用於映射已使用索引\n    → End // 結束建構\n→ Method: int[] flip() // 隨機翻轉\n    → Step 1: r ← RandomInteger(0, self.rem-1) // 選取隨機位置\n    → Step 2: val ← If r in self.map Then self.map[r] Else r // 取得實際索引\n    → Step 3: lastIdx ← If (self.rem-1) in self.map Then self.map[self.rem-1] Else self.rem-1 // 取得最後一個可用索引\n    → Step 4: self.map[r] ← lastIdx // 替換 r 為 lastIdx\n    → Step 5: self.rem ← self.rem - 1 // 可用格數減一\n    → Step 6: row ← val ÷ self.n // 計算行\n    → Step 7: col ← val mod self.n // 計算列\n    → Step 8: Return [row, col] // 返回並翻轉成功\n→ Method: void reset() // 重置\n    → Step 1: self.map ← EmptyMap() // 清空映射\n    → Step 2: self.rem ← self.total // 重置可用格數\n    → End // 結束\nEnd // 程式執行結束\n\nAdd arrow for Decision? None needed. Ensure each line with virtual code and comment. We'll output each line. Use Chinese explanation. Provide the lines as per format. Ensure each line ends with // 解釋. Use \"Step\" numbering maybe optional but fine.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義 Solution 類別  \n\n→ Constructor: Solution(m, n) // 建構子初始化矩陣尺寸  \n  → Step 1: self.m ← m // 儲存行數  \n  → Step 2: self.n ← n // 儲存列數  \n  → Step 3: self.total ← m × n // 計算總格數  \n  → Step 4: self.rem ← self.total // 記錄剩餘可翻轉的格數  \n  → Step 5: self.map ← EmptyMap() // 用於映射已使用的索引  \n  → End // 結束建構  \n\n→ Method: int[] flip() // 隨機選取一個值為 0 的格並翻轉為 1  \n  → Step 1: r ← RandomInteger(0, self.rem-1) // 在剩餘格中隨機取一個索引  \n  → Step 2: val ← If r in self.map Then self.map[r] Else r // 取得實際的平面索引  \n  → Step 3: lastIdx ← If (self.rem-1) in self.map Then self.map[self.rem-1] Else self.rem-1 // 取得最後一個可用索引  \n  → Step 4: self.map[r] ← lastIdx // 把被選中索引替換為最後一個索引  \n  → Step 5: self.rem ← self.rem - 1 // 減少剩餘可翻轉的格數  \n  → Step 6: row ← val ÷ self.n // 計算行座標  \n  → Step 7: col ← val mod self.n // 計算列座標  \n  → Step 8: Return [row, col] // 回傳並完成翻轉  \n\n→ Method: void reset() // 將所有格重置為 0  \n  → Step 1: self.map ← EmptyMap() // 清空映射表  \n  → Step 2: self.rem ← self.total // 將剩餘格數重設為總格數  \n  → End // 結束重置  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['()()()', '(())()']\""
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        }
      ],
      "generated_code": "import sys\nfrom typing import List, Set\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # 先算出最小需要刪除的左括號和右括號數量\n        left_rem, right_rem = 0, 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem > 0:\n                    left_rem -= 1\n                else:\n                    right_rem += 1\n\n        res: Set[str] = set()\n\n        def dfs(idx: int, path: str, left_rem: int, right_rem: int, open_bracket: int) -> None:\n            \"\"\"回溯搜索所有合法字串\"\"\"\n            if idx == len(s):\n                if left_rem == 0 and right_rem == 0 and open_bracket == 0:\n                    res.add(path)\n                return\n\n            ch = s[idx]\n\n            if ch == '(':\n                # 1. 刪除這個 '('\n                if left_rem > 0:\n                    dfs(idx + 1, path, left_rem - 1, right_rem, open_bracket)\n                # 2. 保留這個 '('，同時打開一個括號\n                dfs(idx + 1, path + ch, left_rem, right_rem, open_bracket + 1)\n\n            elif ch == ')':\n                # 1. 刪除這個 ')'\n                if right_rem > 0:\n                    dfs(idx + 1, path, left_rem, right_rem - 1, open_bracket)\n                # 2. 保留這個 ')'，必須有未匹配的 '('\n                if open_bracket > 0:\n                    dfs(idx + 1, path + ch, left_rem, right_rem, open_bracket - 1)\n\n            else:\n                # 普通字母，直接加入\n                dfs(idx + 1, path + ch, left_rem, right_rem, open_bracket)\n\n        dfs(0, \"\", left_rem, right_rem, 0)\n        return list(res)\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    解析輸入資料，支援兩種格式：\n    1. 直接給字串：()())()\n    2. 包含前綴 s = 的形式：s = \"()())()\"\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, val = raw.split('=', 1)\n        val = val.strip()\n        # 移除可能存在的引號\n        if val.startswith((\"'\", '\"')) and val.endswith((\"'\", '\"')):\n            val = val[1:-1]\n        return val\n    return raw\n\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    s = parse_input(raw_data)\n    solution = Solution()\n    output = solution.removeInvalidParentheses(s)\n    print(output)",
      "virtual_code": "Thinking...\nThe task: produce virtual code steps line by line with explanations for removing minimum number of invalid parentheses to generate all unique valid strings. Should describe algorithm: compute left and right removals needed, BFS or DFS backtracking. Probably typical solution: count mismatches, use DFS backtracking to remove parentheses, use set to avoid duplicates. Steps:\n\nStart\n→ compute left_removal, right_removal counts\n→ Define recursive function dfs(index, path, left_rem, right_rem, open)\n    // etc\n→ Use DFS to generate valid strings; store in result set\n→ After recursion, output result list\nEnd\n\nNeed to format each line: virtual step + comment.\n\nAlso need arrow formatting for decisions.\n\nWe must not output actual code. Just pseudo steps.\n\nLet's produce line by line. Use Start, End. Each step lines. Use arrow -> for step, Decision: with Yes → and No →. Provide explanation. Use typical pseudocode steps.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left_removal ← 0, right_removal ← 0 // 用來計算需要刪除的左、右括號數  \n→ Decision: 是否遍歷整個字串 s? // 判斷是否已完成遍歷  \n    Yes → Step 2: 對每個字符 c 進行  \n        Decision: c 為 '('? // 判斷是否為左括號  \n            Yes → left_removal ← left_removal + 1 // 需要將此左括號視為多餘  \n            No → Decision: c 為 ')'？ // 判斷是否為右括號  \n                Yes → Decision: left_removal > 0? // 是否還有未匹配的左括號  \n                    Yes → left_removal ← left_removal - 1 // 匹配成功，減少左括號計數  \n                    No  → right_removal ← right_removal + 1 // 沒有可匹配的左括號，右括號視為多餘  \n                No  → // 字母直接忽略  \n    No  → // 整個字串遍歷完成，left_removal、right_removal 已得到最小刪除數  \n\n→ Step 3: 建立結果集合 result ← {} // 用來儲存所有唯一的合法字串  \n→ Step 4: 定義遞迴函式 dfs(index, path, left_rem, right_rem, open) // 參數說明：index 目前處理位置，path 已構造的字串，left_rem、right_rem 剩餘需刪除的左、右括號，open 為已打開的左括號數  \n\n    Decision: index == length(s)? // 已到達字串末尾  \n        Yes → Decision: left_rem == 0 and right_rem == 0 and open == 0? // 是否已符合合法條件  \n            Yes → result.add(path) // 將合法字串加入集合  \n            No  → // 不是合法結果，返回  \n        No  → Step 5: 取得當前字符 c ← s[index]  \n\n    Decision: c 為 '('? // 處理左括號  \n        Yes → Decision: left_rem > 0? // 可以選擇刪除此左括號  \n            Yes → dfs(index+1, path, left_rem-1, right_rem, open) // 刪除後繼續遞迴  \n            No → // 不刪除，進入下一步  \n            Decision: open+1 ≤ max_possible? // 確保不會打開太多左括號  \n                Yes → dfs(index+1, path+'(', left_rem, right_rem, open+1) // 添加左括號並遞迴  \n                No  → // 超過合法開口數，返回  \n\n    Decision: c 為 ')'？ // 處理右括號  \n        Yes → Decision: right_rem > 0? // 可以選擇刪除此右括號  \n            Yes → dfs(index+1, path, left_rem, right_rem-1, open) // 刪除後繼續遞迴  \n            No → // 不刪除，進入下一步  \n            Decision: open > 0? // 必須有未匹配的左括號才能添加右括號  \n                Yes → dfs(index+1, path+')', left_rem, right_rem, open-1) // 添加右括號並遞迴  \n                No  → // 沒有可匹配左括號，返回  \n\n    Decision: c 為字母？ // 直接加入字串  \n        Yes → dfs(index+1, path+c, left_rem, right_rem, open) // 字母不影響括號數量，遞迴  \n\n→ Step 6: 呼叫 dfs(0, \"\", left_removal, right_removal, 0) // 從頭開始遞迴搜尋  \n→ Step 7: 輸出結果 list(result) // 將集合轉為列表返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Find K Pairs with Smallest Sums",
      "source_file": "Leetcode/leetcode373.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbbk8rwix.py\", line 55, in <module>\n    nums1, nums2, k = parse_input(input_line)\n                      ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbbk8rwix.py\", line 43, in parse_input\n    nums2_part = parts[1].split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmploegzibu.py\", line 55, in <module>\n    nums1, nums2, k = parse_input(input_line)\n                      ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmploegzibu.py\", line 43, in parse_input\n    nums2_part = parts[1].split('=', 1)[1].strip()\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport heapq\nfrom typing import List, Tuple, Set\n\nclass Solution:\n    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n        # 若任一陣列為空，直接返回空清單\n        if not nums1 or not nums2 or k <= 0:\n            return []\n\n        heap: List[Tuple[int, int, int]] = []  # 儲存 (sum, index_in_nums1, index_in_nums2)\n        visited: Set[Tuple[int, int]] = set()\n        res: List[List[int]] = []\n\n        # 初始把第一個最小對 (0,0) 加入堆\n        heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))\n        visited.add((0, 0))\n\n        # 主循環：取得 k 個最小和對\n        while heap and len(res) < k:\n            total, i, j = heapq.heappop(heap)\n            res.append([nums1[i], nums2[j]])\n\n            # 將 (i+1, j) 加入堆（往 nums1 方向走）\n            if i + 1 < len(nums1) and (i + 1, j) not in visited:\n                heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n                visited.add((i + 1, j))\n\n            # 將 (i, j+1) 加入堆（往 nums2 方向走）\n            if j + 1 < len(nums2) and (i, j + 1) not in visited:\n                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n                visited.add((i, j + 1))\n\n        return res\n\ndef parse_input(line: str) -> Tuple[List[int], List[int], int]:\n    \"\"\"\n    將形如 'nums1 = [1,7,11], nums2 = [2,4,6], k = 3' 的字串轉成\n    (nums1, nums2, k) 三元組。\n    \"\"\"\n    parts = line.split(',')\n    nums1_part = parts[0].split('=', 1)[1].strip()\n    nums2_part = parts[1].split('=', 1)[1].strip()\n    k_part = parts[2].split('=', 1)[1].strip()\n\n    nums1 = eval(nums1_part, {\"__builtins__\": None}, {})\n    nums2 = eval(nums2_part, {\"__builtins__\": None}, {})\n    k = int(k_part)\n    return nums1, nums2, k\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取一行資料\n    input_line = sys.stdin.read().strip()\n    if input_line:\n        nums1, nums2, k = parse_input(input_line)\n        solution = Solution()\n        result = solution.kSmallestPairs(nums1, nums2, k)\n        print(result)\n    else:\n        print([])",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code to find k smallest sum pairs from two sorted arrays. Use typical algorithm: min-heap with pairs of indices. Steps: Initialize heap with (nums1[0]+nums2[0], 0,0). While result size < k and heap not empty: pop min, add to result, push next pair in same row: (i+1, j) and next column: (i, j+1) but to avoid duplicates we only push (i+1, j) when not visited and maybe we push both? Actually typical approach: push (i+1, j) and (i, j+1). But to avoid duplicates we use visited set.\n\nWe'll produce pseudocode.\n\nWe must output each line: \"虛擬碼步驟 // 解釋\". Use arrow and decision etc.\n\nWe need to use start and end. Provide step by step lines.\n\nLet's design:\n\nStart\n→ Step 1: Initialize result list // store k pairs\n→ Step 2: If k==0 or arrays empty -> return result // trivial case\n→ Step 3: Initialize min-heap // priority queue ordered by sum\n→ Step 4: Initialize visited set // to avoid duplicate pairs\n→ Step 5: Push (nums1[0]+nums2[0], 0, 0) into heap, mark visited\n→ Decision: While result.size < k AND heap not empty? // main loop\n    Yes → Step 6: Pop min from heap, let (sum, i, j) // get pair\n    → Step 7: Append (nums1[i], nums2[j]) to result // add to answer\n    → Decision: If i+1 < nums1.length AND (i+1, j) not visited? // push next in nums1\n        Yes → Step 8: Push (nums1[i+1]+nums2[j], i+1, j) into heap, mark visited\n    → Decision: If j+1 < nums2.length AND (i, j+1) not visited? // push next in nums2\n        Yes → Step 9: Push (nums1[i]+nums2[j+1], i, j+1) into heap, mark visited\n    No → ...\n    No → ...\n→ End // output result\n\nBut we also need to handle decision formatting with arrows.\n\nLet's format properly: Each line has \"虛擬碼步驟 // 解釋\". Use arrows and decisions accordingly.\n\nWe'll produce each line accordingly. Ensure we maintain indentation for decision branches maybe but we can just use lines like \"Decision: ...\" and then lines starting with \"    Yes → ...\".\n\nMake sure each line is separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空清單 // 用於存放找到的 k 個最小和對\n→ Step 2: 若 k = 0 或 nums1 或 nums2 為空則返回 result // 特殊情況快速結束\n→ Step 3: 建立最小堆 heap，按 sum 排序 // 儲存候選對的索引與和\n→ Step 4: 建立 visited 集合，用來避免重複加入相同索引組合\n→ Step 5: 將 (nums1[0] + nums2[0], 0, 0) 推入 heap，並將 (0,0) 加入 visited // 初始最小對\n→ Decision: while result.size < k AND heap 不是空的? // 主循環：不斷取最小對\n    Yes →\n        Step 6: 從 heap 中彈出最小元素 (sum, i, j) // 取得目前最小和對的索引\n        → Step 7: 將 (nums1[i], nums2[j]) 加入 result // 收集答案\n        → Decision: i + 1 < nums1.length AND (i+1, j) 未在 visited? // 是否能往下推到下一個 nums1\n            Yes → Step 8: 將 (nums1[i+1] + nums2[j], i+1, j) 推入 heap，並把 (i+1, j) 加入 visited\n            No →\n        → Decision: j + 1 < nums2.length AND (i, j+1) 未在 visited? // 是否能往右推到下一個 nums2\n            Yes → Step 9: 將 (nums1[i] + nums2[j+1], i, j+1) 推入 heap，並把 (i, j+1) 加入 visited\n            No →\n    No → // 當 result 已滿 k 或 heap 空時退出循環\nEnd // 程式執行結束，result 為 k 個最小和對的列表"
    },
    {
      "title": "Min Stack",
      "source_file": "Leetcode/leetcode155.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,-3,null,0,-2]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,-3,null,0,-2]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys, json\n\nclass MinStack:\n    ...",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for MinStack class with push, pop, top, getMin O(1). Use two stacks: main stack and min stack. Provide steps: Start, initialize stacks, push: push val onto main, if min empty or val <= min.top push to min; pop: pop main, if popped equals min.top pop min; top: return main.top; getMin: return min.top. End. Ensure each line is virtual code with arrow and comment.\n\nUse arrow for flow. Need to show structure: Start, Decision, Yes, No. Provide stepwise instructions. Format: \"Start // 程式開始執行\". Then arrow lines. Should include all lines of algorithm, not actual code. Use comments in Chinese. Provide each step. Ensure \"虛擬碼步驟\" and comment separated by space. Use arrow as \"→\". For decisions use \"Decision: ...\". Provide sub-indented lines with spaces.\n\nLet's write.\n\nStart\n→ Step 1: 初始化主堆疊 S ← 空 // 建立主堆疊\n→ Step 2: 初始化最小堆疊 M ← 空 // 建立存最小值堆疊\n\nThen push: need a method; inside push, step.\n\n→ Step 3: push(val) // 進入 push 函式\n    → Step 4: S.push(val) // 把值加入主堆疊\n    → Decision: M 是否空? // 檢查最小堆疊是否為空\n        Yes → M.push(val) // 若空，直接加入\n        No  → Step 5: M.top() ≤ val? // 若非空，比較當前最小\n            Yes → M.push(val) // 小於等於時，加入\n            No  → // 不做任何操作\n\npop:\n\n→ Step 6: pop() // 進入 pop 函式\n    → Decision: S 是否空? // 檢查主堆疊是否為空\n        Yes → // 空時不操作\n        No  → Step 7: temp ← S.pop() // 移除主堆疊頂\n            → Decision: temp == M.top()? // 若移除值為最小值\n                Yes → M.pop() // 同時移除最小堆疊頂\n                No  → // 不做任何操作\n\ntop:\n\n→ Step 8: top() // 進入 top 函式\n    → Decision: S 是否空? // 檢查主堆疊是否為空\n        Yes → return null // 或錯誤\n        No  → return S.top() // 回傳主堆疊頂\n\ngetMin:\n\n→ Step 9: getMin() // 進入 getMin 函式\n    → Decision: M 是否空? // 檢查最小堆疊是否為空\n        Yes → return null // 或錯誤\n        No  → return M.top() // 回傳最小值\n\nEnd.\n\nMake sure each line uses \"→\" only once per line. For decisions, indent sub-lines with spaces. Also note each line should contain only the virtual code step and comment. Use Chinese comments. Provide full structure.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: S ← 空 // 初始化主堆疊  \n→ Step 2: M ← 空 // 初始化最小堆疊  \n\n→ Step 3: push(val) // 進入 push 函式  \n    → Step 4: S.push(val) // 把值加入主堆疊  \n    → Decision: M 是否空? // 檢查最小堆疊是否為空  \n        Yes → M.push(val) // 若空，直接加入  \n        No  → Step 5: M.top() ≤ val? // 若非空，比較當前最小值  \n            Yes → M.push(val) // 小於等於時，加入最小堆疊  \n            No  → // 不做任何操作  \n\n→ Step 6: pop() // 進入 pop 函式  \n    → Decision: S 是否空? // 檢查主堆疊是否為空  \n        Yes → // 空時不操作  \n        No  → Step 7: temp ← S.pop() // 移除主堆疊頂  \n            → Decision: temp == M.top()? // 若移除值為最小值  \n                Yes → M.pop() // 同時移除最小堆疊頂  \n                No  → // 不做任何操作  \n\n→ Step 8: top() // 進入 top 函式  \n    → Decision: S 是否空? // 檢查主堆疊是否為空  \n        Yes → return null // 或拋出錯誤  \n        No  → return S.top() // 回傳主堆疊頂  \n\n→ Step 9: getMin() // 進入 getMin 函式  \n    → Decision: M 是否空? // 檢查最小堆疊是否為空  \n        Yes → return null // 或拋出錯誤  \n        No  → return M.top() // 回傳最小值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Words",
      "source_file": "Leetcode/leetcode692.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp99tckcc4.py\", line 28, in main\n    words, k = ast.literal_eval(expr)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    (words= [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k= 2)\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp99tckcc4.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp99tckcc4.py\", line 33, in main\n    k_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd5zqrj2q.py\", line 28, in main\n    words, k = ast.literal_eval(expr)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    (words= [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k= 4)\n     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpd5zqrj2q.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpd5zqrj2q.py\", line 33, in main\n    k_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\nimport ast\n\ndef top_k_frequent(words, k):\n    \"\"\"Return the k most frequent words sorted by frequency desc and lexicographically.\"\"\"\n    if not words or k <= 0:\n        return []\n    # Count frequencies\n    count = Counter(words)\n    # Sort by (-frequency, word)\n    sorted_words = sorted(count.items(), key=lambda x: (-x[1], x[0]))\n    # Extract words and take first k\n    return [word for word, freq in sorted_words[:k]]\n\ndef main():\n    # Read entire input from stdin\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Convert the input string into a tuple (words, k)\n    # Example input: 'words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2'\n    # Make it a Python expression by removing spaces after '=' and wrapping in parentheses\n    expr = raw.replace('words =', 'words=').replace('k =', 'k=').replace('k=', 'k=')\n    expr = f\"({expr})\"\n    try:\n        words, k = ast.literal_eval(expr)\n    except Exception:\n        # Fallback: try splitting by comma\n        parts = raw.split(',')\n        words_part = parts[0].split('=')[1].strip()\n        k_part = parts[1].split('=')[1].strip()\n        words = ast.literal_eval(words_part)\n        k = int(k_part)\n    result = top_k_frequent(words, k)\n    # Print result as JSON array\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Each line: \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow, decision, etc. Should not output actual code. Should describe algorithm. Steps: start, count frequencies, build list, sort by freq desc then lex asc, take first k. Use dictionary etc. Provide step-by-step pseudocode.\n\nLet's craft.\n\nStart\n\n→ Step 1: 接收輸入 words 與 k // 取得字串陣列和需要的頻次數量\n\n→ Step 2: 初始化空頻率表 freqMap // 用於儲存每個字串的出現次數\n\n→ Decision: 若 words 為空? // 檢查輸入是否有效\n    Yes → Step 3: 回傳空陣列 // 沒有字串直接結束\n    No  → 下一步\n\n→ Step 4: 迭代 words，對每個 word 在 freqMap 中累加計數 // 統計頻率\n\n→ Step 5: 將 freqMap 轉換為一個 (word, count) 的清單 wordCountList // 方便排序\n\n→ Step 6: 設定排序規則：先按 count 降序，再按字串升序 // 定義排序依據\n\n→ Decision: 是否有多餘的字串? // 檢查 list 長度是否大於 k\n    Yes → Step 7: 取前 k 個元素 // 只保留需要的個數\n    No  → Step 8: 使用全部元素 // 所有字串都足夠\n\n→ Step 9: 建立結果陣列 result，從 wordCountList 取出 word 部分 // 準備回傳\n\n→ End // 回傳結果並結束\n\nWe need to follow formatting: each line includes \"虛擬碼步驟\" then space then \"// 解釋\". The arrow syntax: \"→\" for steps, \"Decision:\" for decisions, with indentation.\n\nAlso we need to include \"Start\" and \"End\".\n\nLet's produce with proper indentation:\n\nStart // 程式開始執行\n\n→ Step 1: Receive words array and integer k // 取得輸入\n\n→ Step 2: Initialize empty frequency map freqMap // 用於統計字串頻率\n\n→ Decision: If words is empty? // 檢查輸入是否有效\n    Yes → Step 3: Return empty list // 沒有字串直接回傳\n    No  → // 進一步處理\n\n→ Step 4: For each word in words, increment freqMap[word] // 統計頻率\n\n→ Step 5: Convert freqMap into list of (word, count) pairs wordCountList // 方便排序\n\n→ Step 6: Sort wordCountList by: primary key count descending, secondary key word ascending // 排序規則\n\n→ Decision: If wordCountList length > k? // 需要裁剪\n    Yes → Step 7: Truncate list to first k elements // 只保留最頻繁的 k 個\n    No  → // 使用完整列表\n\n→ Step 8: Extract words from sorted (and possibly truncated) list into result array // 準備回傳\n\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" phrase. The example uses \"Step 1: ...\". So we should use \"Step X:\" lines.\n\nAlso we need to show decision indent with arrow after each decision branch. Use indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入 words 陣列與整數 k // 接收字串列表與需要的頻次數量  \n→ Step 2: 初始化空頻率表 freqMap // 用於統計每個字串的出現次數  \n→ Decision: 若 words 為空? // 檢查輸入是否有效  \n  Yes → Step 3: 回傳空陣列 // 沒有字串直接結束  \n  No  → // 進一步處理  \n→ Step 4: 迭代 words，對每個 word 在 freqMap 中累加計數 // 統計頻率  \n→ Step 5: 將 freqMap 轉換為一個 (word, count) 的清單 wordCountList // 方便排序  \n→ Step 6: 設定排序規則：先按 count 降序，再按字串升序 // 定義排序依據  \n→ Decision: wordCountList 長度是否大於 k? // 是否需要裁剪  \n  Yes → Step 7: 取前 k 個元素 // 只保留需要的個數  \n  No  → // 使用完整列表  \n→ Step 8: 建立結果陣列 result，從 wordCountList 取出 word 部分 // 準備回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '\"12\"'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '\"457\"'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '\"1\"'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 找出所有數字，忽略其它文字\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n        sol = Solution()\n        result = sol.addStrings(num1, num2)\n        # 輸出時加上雙引號，符合範例要求\n        print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nWe need to generate virtual code for adding two numbers given as strings, without using big integer library, and not converting to integers directly. We need line by line pseudocode, each line with a short comment. Use arrows and decision. Provide steps like: Start, input strings, initialize carry, i pointer from end of strings, loop while i>=0 or j>=0 or carry, etc.\n\nWe need to produce virtual code lines. Should be clear but no real code. Use \"→\" arrow.\n\nLet's create steps:\n\nStart\n\n→ Input num1, num2 // get strings\n\n→ Initialize i = len(num1)-1, j = len(num2)-1, carry = 0, result = empty string // set indices and carry\n\n→ Decision: while i>=0 or j>=0 or carry > 0? // loop condition\n\n    Yes → Step: digit1 = if i>=0 then num1[i]-'0' else 0 // get digit from num1\n\n    → Step: digit2 = if j>=0 then num2[j]-'0' else 0 // get digit from num2\n\n    → Step: sum = digit1 + digit2 + carry // compute sum\n\n    → Step: carry = sum / 10 // new carry\n\n    → Step: result = (sum % 10) + result // prepend digit to result\n\n    → Step: i = i - 1\n\n    → Step: j = j - 1\n\n    No → End loop\n\n→ Output result // return sum as string\n\nEnd\n\nBut we need to use arrow style:\n\nStart // 程式開始執行\n\n→ Input num1, num2 // 取得兩個字串表示的非負整數\n\n→ Decision: i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // 初始化指標、進位、結果\n\n→ Decision: i >= 0 or j >= 0 or carry > 0? // 判斷是否還有數位或進位需要處理\n\n    Yes → Step: digit1 = i >= 0 ? num1[i] - '0' : 0 // 取得 num1 的對應數位，若已經越界則取 0\n\n    → Step: digit2 = j >= 0 ? num2[j] - '0' : 0 // 取得 num2 的對應數位，若已經越界則取 0\n\n    → Step: sum = digit1 + digit2 + carry // 兩個數位與進位相加\n\n    → Step: carry = sum / 10 // 計算新的進位\n\n    → Step: result = (sum % 10) + result // 把計算出的位數前置到結果字串\n\n    → Step: i = i - 1 // 移動到 num1 的上一位\n\n    → Step: j = j - 1 // 移動到 num2 的上一位\n\n    No → End // 迴圈結束\n\n→ Output result // 回傳相加後的字串\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋. Use arrow arrow lines, include Start, End.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input num1, num2 // 取得兩個字串表示的非負整數  \n→ Decision: i = len(num1)-1, j = len(num2)-1, carry = 0, result = \"\" // 初始化索引、進位與結果字串  \n→ Decision: i >= 0 or j >= 0 or carry > 0? // 判斷是否還有數位或進位需要處理  \n    Yes → Step: digit1 = i >= 0 ? num1[i] - '0' : 0 // 取得 num1 的對應數位，若已越界則取 0  \n    → Step: digit2 = j >= 0 ? num2[j] - '0' : 0 // 取得 num2 的對應數位，若已越界則取 0  \n    → Step: sum = digit1 + digit2 + carry // 兩個數位與進位相加  \n    → Step: carry = sum / 10 // 計算新的進位  \n    → Step: result = (sum % 10) + result // 把計算出的位數前置到結果字串  \n    → Step: i = i - 1 // 移動到 num1 的上一位  \n    → Step: j = j - 1 // 移動到 num2 的上一位  \n    No → End // 迴圈結束  \n→ Output result // 回傳相加後的字串  \nEnd // 程式結束"
    },
    {
      "title": "K-th Smallest in Lexicographical Order",
      "source_file": "Leetcode/leetcode440.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa93kyj6x.py\", line 47, in <module>\n    solve()\n  File \"/tmp/tmpa93kyj6x.py\", line 39, in solve\n    nums = list(map(int, data))\n           ^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp_890f_e.py\", line 47, in <module>\n    solve()\n  File \"/tmp/tmpp_890f_e.py\", line 39, in solve\n    nums = list(map(int, data))\n           ^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \"\"\"\n        找到 [1, n] 範圍內第 k 個字典序數字。\n        使用「前綴計數」技巧，從前綴 1 開始，逐步決定是否跳過整個前綴子樹或進入下一層。\n        \"\"\"\n        def count_prefix(prefix: int, n: int) -> int:\n            \"\"\"\n            計算以 prefix 為前綴的數字在 [1, n] 內的個數。\n            \"\"\"\n            cur, nxt = prefix, prefix + 1\n            cnt = 0\n            while cur <= n:\n                cnt += min(n + 1, nxt) - cur\n                cur *= 10\n                nxt *= 10\n            return cnt\n\n        curr = 1\n        k -= 1          # 先把起始數字 1 算進已排好的序列\n        while k > 0:\n            cnt = count_prefix(curr, n)\n            if k >= cnt:\n                # 整個前綴子樹都在第 k 個之前，跳過它\n                k -= cnt\n                curr += 1\n            else:\n                # 進入前綴子樹的下一層\n                k -= 1\n                curr *= 10\n        return curr\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    nums = list(map(int, data))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    solution = Solution()\n    print(solution.findKthNumber(n, k))\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve: given n, k, find kth lexicographically smallest integer in [1, n]. This is like find kth number in lexicographical order 1..n. We need to produce steps line by line with explanations. Use Start, Decision, etc. We need to outline algorithm.\n\nWe can implement method using counting numbers under prefix. Approach: start with prefix=1, rank=1. While rank < k, compute count of numbers under current prefix: count = countNumbersInRange(prefix, prefix+1, n). If rank + count <= k, then move to next prefix: prefix++ ; rank++? Wait typical algorithm: we maintain current prefix, and accumulate steps.\n\nBut we need to produce pseudo steps. We can outline algorithm:\n\nStart\n→ Input n, k\n→ Initialize prefix=1, rank=1\n→ While rank < k:\n    → Compute count = countInRange(prefix, prefix+1, n)\n    → If rank + count <= k:\n        → rank += count\n        → prefix += 1\n      Else:\n        → prefix *= 10\n        → rank += 1\n→ Return prefix\n\nAdditionally, we need to define function countInRange(low, high, n): counts numbers starting with prefix between low and high-1 inclusive within [1, n]. Implementation: while low <= n: count += min(n+1, high) - low ; low*=10; high*=10.\n\nBut we need to express in virtual code steps. Provide decision points: If rank + count <= k? etc.\n\nOk produce pseudo lines:\n\nStart // 程式開始\n→ Input n, k // 讀入範圍上限與目標順位\n→ Step 1: prefix = 1 // 初始化前綴為 1\n→ Step 2: rank = 1 // 目前已排好首位的數字個數\n→ Decision: while rank < k? // 是否還需要繼續搜尋？\n    Yes → Step 3: count = Count(prefix, prefix+1, n) // 計算以 current prefix 開頭的數字總數\n    → Decision: rank + count <= k? // 是否跳過整個子樹？\n        Yes → Step 4: rank += count // 跳過子樹後更新已排數量\n            → Step 5: prefix += 1 // 前進到同層的下一個前綴\n            → Go back to while\n        No  → Step 6: prefix *= 10 // 進入下一層子節點\n            → Step 7: rank += 1 // 進入子節點後，將當前數字算作已排\n            → Go back to while\n    No → End loop // rank 已達 k 或超過\n→ Return prefix // 第 k 個字典序數字\nEnd // 程式結束\n\nBut we need to include function Count maybe separate block.\n\nDefine subroutine Count(low, high, n) lines. Use Start sub. But we can embed.\n\nBetter: Use Step 3: count = 0 ; l = prefix ; h = prefix+1 ; while l <= n: count += min(n+1, h) - l ; l *= 10 ; h *= 10 ; return count\n\nBut we can show steps: Step 3.1: count = 0 ; l = prefix ; h = prefix+1 ; Step 3.2: while l <= n: count += min(n+1, h) - l ; l *= 10 ; h *= 10 ; Step 3.3: return count\n\nWe can show this as separate subroutine. But keep simple.\n\nOk produce final output with each line: \"虛擬碼步驟 // 解釋\" with arrow or decision.\n\nNeed to maintain structure: Start, End, Decision:, Yes→, No→. Also arrows for steps: → Step.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n, k // 讀取上限 n 與欲取第 k 個字典序數字  \n→ Step 1: prefix = 1 // 初始化前綴為 1  \n→ Step 2: rank = 1 // 目前已排好前綴為 1 的數字數量  \n\nDecision: rank < k? // 是否還需要繼續搜尋直到第 k 個？  \n&nbsp;&nbsp;Yes → Step 3: count = 0 ; l = prefix ; h = prefix + 1 // 計算以 current prefix 開頭的數字總數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: l ≤ n? // 進入循環計算子樹大小  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: count += min(n + 1, h) - l // 加入本層可用數字數量  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: l *= 10 ; h *= 10 // 進一步往下一層  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → End Decision // 子樹已計算完畢  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: // count 已完成  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decision: rank + count ≤ k? // 能否跳過整個子樹？  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: rank += count // 跳過子樹後更新已排數量  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: prefix += 1 // 同層前綴往後移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Go back to Decision rank < k?  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 9: prefix *= 10 // 進入下一層子節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 10: rank += 1 // 進入子節點後計算當前數字  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Go back to Decision rank < k?  \n\nNo → Step 11: result = prefix // rank 已達到或超過 k，取得答案  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Word Break",
      "source_file": "Leetcode/leetcode139.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'true'\nGot (Norm):      'false'\n--- (Raw) ---\nRaw Expected: 'true'\nRaw Got:      'false'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        \"\"\"DP 方案：dp[i] 表示前 i 個字母能否被切分成字典單詞\"\"\"\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True  # 空字串可被切分\n\n        for i in range(1, len(s) + 1):\n            # 從 0 到 i-1 的起點，嘗試切分\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break  # 找到一個合法切分即可\n\n        return dp[len(s)]\n\ndef main():\n    # 從標準輸入讀取整個輸入，並使用 exec 解析變量\n    input_data = sys.stdin.read()\n    local_vars = {}\n    try:\n        exec(input_data, {}, local_vars)\n    except Exception as e:\n        # 若 exec 失敗，直接返回 False\n        print(\"false\")\n        return\n\n    s = local_vars.get('s')\n    wordDict = local_vars.get('wordDict')\n    if s is None or wordDict is None:\n        print(\"false\")\n        return\n\n    solution = Solution()\n    result = solution.wordBreak(s, wordDict)\n    # 以小寫字串輸出結果\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for Word Break problem. Use DP or DFS with memo. Let's produce DP approach: boolean array dp of length n+1, dp[0]=true. For i 1..n: for each word in wordDict: if i>=len(word) and dp[i-len(word)] and s.substring(i-len(word), i) == word: dp[i]=true break. Finally return dp[n].\n\nWe'll present virtual steps: Start, Decision, loops. Use arrows. Provide explanation per line.\n\nWe should adhere to format: Each line: virtual code step, space, // explanation. Use arrow lines for loops.\n\nWe must be careful: Use Step labels.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: n ← length of s // 計算字串長度\n→ Step 2: dp[0..n] ← false // 初始化 DP 陣列\n→ Step 3: dp[0] ← true // 空字串可以被切分\n→ Decision: 是否需要處理更多索引? // 判斷是否已到結尾\n    Yes → Step 4: i ← 1 // 設定目前索引\n    No  → End // 完成\n→ Decision: i <= n? // 循環遍歷字串位置\n    Yes → Decision: 是否已經找到合法切分? // 若 dp[i] 已 true 則跳過\n        Yes → Step 5: i ← i + 1 // 前往下一個位置\n        No  → Step 6: For each word in wordDict // 逐個檢查字典單字\n            → Decision: i >= len(word) AND dp[i - len(word)]? // 檢查前段是否可切分且長度匹配\n                Yes → Decision: s.substring(i - len(word), i) == word? // 確認子字串是否等於單字\n                    Yes → Step 7: dp[i] ← true // 設定可切分\n                    Yes → Step 8: Break // 跳出內部迴圈\n                No → // 继续下一個單字\n        → Step 9: i ← i + 1 // 前往下一個位置\n    No  → Step 10: return dp[n] // 返回最終結果\nEnd // 程式結束\n\nBut we need to ensure each line is proper. Provide step numbering.\n\nWe might restructure to avoid complex nested decisions. Use loops indicated by arrow with Decision lines. Use indentation to show nested. Let's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(s) // 取得字串 s 的長度  \n→ Step 2: dp[0..n] ← false // 初始化布林陣列 dp，長度 n+1  \n→ Step 3: dp[0] ← true // 空字串可以被視為已切分  \n→ Decision: i ≤ n? // 是否還有位置需要檢查  \n    Yes → Step 4: i ← 1 // 從第一個位置開始  \n    No  → End // 所有位置已檢查完畢  \n→ Decision: i ≤ n? // 迴圈：遍歷所有索引 i  \n    Yes → Decision: dp[i] = true? // 若已知可切分，直接跳過  \n        Yes → Step 5: i ← i + 1 // 前往下一個索引  \n        No  → Step 6: For each word ∈ wordDict // 逐個檢查字典單字  \n            → Decision: i ≥ length(word) AND dp[i - length(word)]? // 前段已可切分且長度匹配？  \n                Yes → Decision: s.substring(i - length(word), i) = word? // 子字串是否等於單字？  \n                    Yes → Step 7: dp[i] ← true // 設定 dp[i] 為 true，表示此位置可切分  \n                    Yes → Step 8: Break // 跳出 For 迴圈，因已找到合法切分  \n                    No  → // 仍檢查下一個字典單字  \n                No  → // 仍檢查下一個字典單字  \n            → Step 9: i ← i + 1 // 前往下一個索引  \n    No  → Step 10: return dp[n] // 所有索引已檢查完，回傳最後一個位置是否可切分  \nEnd // 程式結束執行"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"Return the string sorted by decreasing character frequency.\"\"\"\n        # Count occurrences of each character\n        freq = Counter(s)\n        # most_common returns a list of (char, count) sorted by count descending\n        # Build the result by repeating each character its counted times\n        return ''.join(char * count for char, count in freq.most_common())\n\ndef extract_string(raw_input: str) -> str:\n    \"\"\"\n    Extract the first quoted string from the input.\n    If no quotes are found, return the trimmed input as-is.\n    \"\"\"\n    match = re.search(r'\"(.*?)\"', raw_input)\n    return match.group(1) if match else raw_input.strip()\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_data = sys.stdin.read()\n    # Extract the string to process\n    s = extract_string(raw_data)\n    # Compute the frequency-sorted string\n    solution = Solution()\n    result = solution.frequencySort(s)\n    # Output the result to stdout\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line by line steps, each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision:. We need to handle the algorithm: count frequencies, sort by freq desc, produce string. Steps: Start, Step1: input s. Step2: count frequency map. Step3: create list of (char, freq). Step4: sort list by freq descending. Step5: build result string by repeating char freq times. Step6: output result. End.\n\nNeed to show decisions? There's a sorting decision. Could include Decision: If freq equal? but not necessary. But can show sorting step with decision.\n\nWe'll produce each step line by line.\n\nMake sure to use 虛擬碼 arrows and indentation. We'll write:\n\nStart // 程式開始\n\n→ Step 1: 輸入字串 s // 取得待排序的字串\n\n→ Step 2: 建立空字典 freq_map // 用於計算每個字元的出現次數\n\n→ Decision: 是否需要遍歷字串? // 進行字元計數\n\n    Yes → Step 3: 對 s 中每個字元 c 做 freq_map[c]++ // 更新計數\n\n→ Step 4: 將 freq_map 轉成列表 freq_list = [(char, count)] // 方便排序\n\n→ Step 5: 依 count 降序排序 freq_list // 以頻率排序\n\n→ Step 6: 建立空字串 result // 存放結果\n\n→ Decision: 是否還有項目在 freq_list? // 逐項處理\n\n    Yes → Step 7: 對於 (char, count) 在 freq_list 做 result += char * count // 重複加入\n\n    No  → Step 8: 結束循環\n\n→ Step 9: 輸出 result // 回傳排序後的字串\n\nEnd // 程式結束\n\nWe need to keep each line separate and include arrow. Use \"→\" preceding each step. For decisions use \"Decision:\" line then indent sub-branches.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待排序的字串  \n→ Step 2: 建立空字典 freq_map // 用於計算每個字元的出現次數  \n→ Decision: 是否需要遍歷字串? // 進行字元計數  \n    Yes → Step 3: 對 s 中每個字元 c 做 freq_map[c]++ // 更新計數  \n→ Step 4: 將 freq_map 轉成列表 freq_list = [(char, count)] // 方便排序  \n→ Step 5: 依 count 降序排序 freq_list // 以頻率排序  \n→ Step 6: 建立空字串 result // 存放結果  \n→ Decision: 是否還有項目在 freq_list? // 逐項處理  \n    Yes → Step 7: 對於 (char, count) 在 freq_list 做 result += char * count // 重複加入  \n    No  → Step 8: 結束循環  \n→ Step 9: 輸出 result // 回傳排序後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def lexicalOrder(self, n: int):\n        \"\"\"\n        Return all integers from 1 to n sorted lexicographically.\n        Uses O(n) time and O(1) extra space (besides the output list).\n        \"\"\"\n        result = []\n        current = 1\n        while current <= n:\n            result.append(current)          # record the current number\n\n            # Try to go deeper into the current subtree (current*10)\n            if current * 10 <= n:\n                current *= 10\n            # If we cannot go deeper, try to go to the next sibling\n            elif current % 10 != 9 and current + 1 <= n:\n                current += 1\n            # Otherwise we need to climb up until we can increment\n            else:\n                while (current // 10) % 10 == 9 or current + 1 > n:\n                    current //= 10\n                current += 1\n        return result\n\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n\n    # Extract the first integer found in the input\n    match = re.search(r\"(\\d+)\", data)\n    n = int(match.group(1)) if match else 0\n\n    # Compute and output the lexicographical order list\n    sol = Solution()\n    print(sol.lexicalOrder(n))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that given n returns numbers 1..n sorted lexicographically, O(n) time, O(1) space. Typical lexicographic order algorithm uses DFS over digits: start at 1, output, then if curr*10 <= n, go deeper (curr*10). Else, if curr%10 !=9 and curr+1 <= n, increment. Else, while curr/10 %10 ==9 or curr+1 > n, curr/=10; then curr++.\n\nWe need to write steps line by line with explanations. Use Start, End, Decision. Provide virtual code steps.\n\nWe must not output actual code, just steps.\n\nWe'll produce:\n\nStart\n→ Step 1: Initialize current = 1 // starting number\n→ Step 2: Initialize result list empty // store output\n→ Decision: While current <= n? // iterate over all numbers\n    Yes →\n        → Step 3: Append current to result // add to output\n        → Decision: Can we go deeper (current*10 <= n)? // try next lexicographically\n            Yes → Step 4: current = current*10 // move to next child\n            No →\n                → Decision: Is current%10 !=9 and current+1 <= n? // can increment\n                    Yes → Step 5: current = current + 1 // increment\n                    No →\n                        → Step 6: While (current/10)%10 ==9 or current+1 > n:\n                            → Step 7: current = current/10 // climb up until we can increment\n                        → Step 8: current = current + 1 // move to next sibling\n    No → End\n\nBut must ensure O(1) extra space. Use result list considered output only.\n\nNeed to produce each line with arrow. Use formatting: `→ Step ...` etc.\n\nMake sure to include comments after `//`.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 current = 1 // 設定起始數字為 1  \n→ Step 2: 初始化 result = [] // 建立結果儲存區  \n→ Decision: 是否 current ≤ n? // 判斷是否還有數字需要處理  \n    Yes →  \n        → Step 3: 將 current 加入 result // 將當前數字加入輸出序列  \n        → Decision: 是否 current × 10 ≤ n? // 檢查能否往更深的子節點遞進  \n            Yes →  \n                → Step 4: current = current × 10 // 進入下一層（以 0 結尾）  \n            No →  \n                → Decision: current % 10 ≠ 9 且 current + 1 ≤ n? // 能否直接遞增？  \n                    Yes →  \n                        → Step 5: current = current + 1 // 直接遞增到下一個兄弟節點  \n                    No →  \n                        → Step 6: While (current / 10) % 10 == 9 或 current + 1 > n: // 從目前節點往上移動直到能遞增  \n                            → Step 7: current = current / 10 // 把 current 除以 10，回到父節點  \n                        → Step 8: current = current + 1 // 進行遞增，跳到下一個可行的數字  \n    No → End // 所有數字已處理完畢，程式結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出字串陣列中「最長不通用子序列」的長度。\n        若不存在，回傳 -1。\n        \"\"\"\n        if not strs:\n            return -1\n\n        # 先統計每個字串的出現頻率\n        freq = Counter(strs)\n\n        # 找出所有唯一字串（頻率為 1）的長度，取最大值\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1:\n                max_len = max(max_len, len(s))\n\n        return max_len\n\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，解析成 Python list\n    data = sys.stdin.read().strip()\n    try:\n        strs = json.loads(data)\n    except json.JSONDecodeError:\n        # 若輸入格式不合法，直接回傳 -1\n        print(-1)\n        sys.exit(0)\n\n    # 建立 Solution 物件並計算結果\n    sol = Solution()\n    result = sol.findLUSlength(strs)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudo-code steps line by line with explanation. Need to produce solution for longest uncommon subsequence length. Problem known LeetCode 521. Approach: For each string, if it's unique among array, answer is its length. Else -1. Because if string appears at least twice, can't be uncommon. The longest uncommon subsequence is the longest unique string. So algorithm: count frequencies, find max length among strings with freq==1, else -1.\n\nWe need to produce virtual code step by step. Use Start, End, Decision, arrow, etc. Provide explanation comments after //.\n\nEnsure no actual code, only virtual steps. Must adhere to format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow symbol for steps, decisions.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化字典 freq // 用於計數每個字串出現次數\n→ Step 2: 對於每個 str in strs, freq[str] += 1 // 逐個統計\n→ Step 3: 初始化 maxLen = -1 // 預設最長不通用子序列長度\n→ Decision: 是否存在任何 freq[str] == 1? // 檢查是否有唯一字串\n    Yes → Step 4: 遍歷 strs\n        → Decision: 如果 freq[str] == 1?\n            Yes → Decision: 是否 str.length > maxLen?\n                Yes → Step 5: maxLen = str.length // 更新最長唯一字串長度\n                No  → (無操作)\n        (跳出迴圈)\n    No  → (無操作)\n→ Step 6: 回傳 maxLen // 回傳結果，若仍為 -1 則表示不存在\nEnd\n\nNeed to include arrow for each line. Use \"→\" before each step/decision. Provide explanation after //.\n\nAlso for decisions, indent lines? Use indentation as example shows indentation for inner steps. Use tab or space? In example they used 4 spaces before nested lines. We can replicate.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字典 freq // 用於統計每個字串在陣列中出現的次數  \n→ Step 2: 對於每個 str in strs，freq[str] += 1 // 逐一累加頻率  \n→ Step 3: 初始化變數 maxLen 為 -1 // 用於保存目前找到的最長唯一字串長度  \n→ Decision: 是否存在至少一個字串的頻率為 1？ // 檢查是否有唯一字串可作為不通用子序列  \n  Yes → Step 4: 遍歷 strs  \n    → Decision: 如果 freq[str] == 1？ // 只考慮唯一字串  \n     Yes → Decision: str.length > maxLen？ // 判斷是否比目前最大長度更長  \n      Yes → Step 5: maxLen = str.length // 更新最大長度  \n      No  → (無需更動)  \n    (No → (跳過此字串))  \n  (No → (不做任何事))  \n→ Step 6: 回傳 maxLen // 結果為最長唯一字串長度，若為 -1 表示不存在不通用子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    data = sys.stdin.read()\n    # Extract the DNA sequence enclosed in single quotes, e.g., s = 'ACGT...'\n    match = re.search(r\"'([^']*)'\", data)\n    if not match:\n        # If no quotes found, assume the entire input is the sequence\n        s = data.strip()\n    else:\n        s = match.group(1)\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: find all 10-letter-long substrings that occur more than once in a string s. This is a known problem: Leetcode 187. Approach: sliding window, hash set seen, result set.\n\nWe need to produce step-by-step virtual code with arrows and comments.\n\nWe need to use Start, End, Decision: etc.\n\nWe produce code lines like:\n\nStart\n→ Step 1: Initialize empty set seen and result\n→ Decision: If length(s) < 10? etc.\n\nWe need to follow format: each line: `虛擬碼步驟 // 解釋`\n\nAlso use arrow `→`. Indent for nested decisions? Should maintain structure.\n\nWe need to produce all steps; no actual code.\n\nWe need to ensure each line has explanation after `//`.\n\nOk.\n\nLet's draft.\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 seen 用於儲存已出現的 10 字元子字串 // 初始化已看到的子字串集合\n→ Step 2: 建立空集合 result 用於儲存重複出現的 10 字元子字串 // 初始化結果集合\n→ Decision: s 的長度 < 10? // 判斷是否足夠長\n    Yes → Step 3: 回傳空集合 result // 長度不足，無重複子字串\n    No  → Continue\n→ Step 4: 從 i=0 到 i <= len(s)-10 // 迭代所有可能的 10 字元起始位置\n    → Step 5: 取得子字串 sub = s[i:i+10] // 取出當前 10 字元子字串\n    → Decision: sub 是否已存在於 seen? // 判斷子字串是否已被看到\n        Yes → Decision: sub 是否已存在於 result? // 判斷是否已經加入結果\n            Yes → Step 6: 不執行任何操作 // 已經記錄過，無需再次加入\n            No  → Step 7: 將 sub 加入 result // 新增重複子字串至結果\n        No  → Step 8: 將 sub 加入 seen // 第一次看到此子字串，加入已看到集合\n→ Step 9: 回傳 result // 將所有重複的 10 字元子字串回傳\nEnd // 程式執行結束\n\nWe must ensure each line with arrow? In sample they used arrow for step lines, and indent for nested decisions. Use same style.\n\nWe also need \"Decision:\" lines with indent.\n\nOk. Ensure all lines include explanation after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 seen 用於儲存已出現的 10 字元子字串 // 初始化已看到的子字串集合  \n→ Step 2: 建立空集合 result 用於儲存重複出現的 10 字元子字串 // 初始化結果集合  \n→ Decision: s 的長度 < 10? // 判斷是否足夠長  \n    Yes → Step 3: 回傳空集合 result // 長度不足，無重複子字串  \n    No  → Continue  \n→ Step 4: 從 i=0 到 i <= len(s)-10 迭代所有可能的 10 字元起始位置 // 走訪每個起始點  \n    → Step 5: 取得子字串 sub = s[i:i+10] // 取出當前 10 字元子字串  \n    → Decision: sub 是否已存在於 seen? // 判斷子字串是否已被看到  \n        Yes → Decision: sub 是否已存在於 result? // 判斷是否已經加入結果  \n            Yes → Step 6: 不執行任何操作 // 已經記錄過，無需再次加入  \n            No  → Step 7: 將 sub 加入 result // 新增重複子字串至結果  \n        No  → Step 8: 將 sub 加入 seen // 第一次看到此子字串，加入已看到集合  \n→ Step 9: 回傳 result // 將所有重複的 10 字元子字串回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        生成 nums 的所有排列\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 如果已經固定完所有位置，加入結果\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            # 嘗試將每個元素放到 start 位置\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]   # 交換\n                backtrack(start + 1)                         # 進一步排列\n                nums[start], nums[i] = nums[i], nums[start]   # 回朔\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    # 尋找首尾中括號，抽取列表部分\n    l = raw.find('[')\n    r = raw.rfind(']')\n    if l == -1 or r == -1:\n        nums = []\n    else:\n        nums = ast.literal_eval(raw[l:r+1])  # 安全解析列表\n\n    solution = Solution()\n    result = solution.permute(nums)\n    # 以 JSON 格式輸出，避免空格問題\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step for generating all permutations of an array of distinct integers. Provide each line with virtual code and comment. Use Start, End, Decision, arrows. Provide \"→\" arrows. The algorithm: backtracking. Steps: Start, assign result list, define helper function permute(start). At each call, if start == length, append copy. Else for i from start to n-1: swap, recurse, swap back. Provide comments. Each line includes the step label: e.g., \"Start\", \"→ Step 1: Initialize result list // ...\", etc.\n\nLet's structure:\n\nStart\n→ Step 1: Input array nums // 取得輸入\n→ Step 2: Initialize empty list result // 儲存所有排列\n→ Step 3: Define recursive function backtrack(start) // 從索引 start 開始\n→ Step 4: If start == nums.length → add copy of nums to result // 完成一個排列\n→ Step 5: For i from start to nums.length-1 // 嘗試每個位置\n    → Decision: If i >= start? but just loop.\n    → Step 6: Swap nums[start] and nums[i] // 交換\n    → Step 7: backtrack(start + 1) // 進一步生成\n    → Step 8: Swap back nums[start] and nums[i] // 回朔\n→ Step 9: Call backtrack(0) // 開始\n→ Step 10: Return result // 結果\nEnd\n\nAdd comments. Need to ensure each line has \"虛擬碼步驟\" plus comment. Use arrows and indent properly. Provide indentation for loops maybe using 4 spaces indent? But example shows indentation of Decision. Use same.\n\nLet's craft.\n\nAlso use \"Decision:\" for if conditions. For loop use \"→ Step\". Indentation: within Decision, lines indented by 4 spaces? In example, they indent 4 spaces for inner lines. Use same.\n\nWe need to not output actual code. So we avoid parentheses. Just pseudo steps.\n\nWe need to follow format exactly: each line: `<虛擬碼步驟> // <解釋>`.\n\nThus each line string.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 輸入陣列 nums // 取得使用者提供的數字列表\n→ Step 2: 初始化空列表 result // 用於儲存所有排列\n→ Step 3: 定義遞迴函式 backtrack(start) // 從索引 start 開始排列\n→ Step 4: Decision: 如果 start 等於 nums.length? // 判斷是否已經生成完整排列\n    Yes → Step 5: 將 nums 的拷貝加入 result // 完整排列加入結果\n    No  → Step 6: 迭代 i 從 start 到 nums.length-1 // 嘗試把每個元素放在 start 位置\n        → Step 7: 交換 nums[start] 與 nums[i] // 暫時固定元素\n        → Step 8: backtrack(start + 1) // 生成後續排列\n        → Step 9: 交換 nums[start] 與 nums[i] // 回復原狀，進行下一個嘗試\n→ Step 10: 呼叫 backtrack(0) // 從第一個位置開始遞迴\n→ Step 11: 回傳 result // 返回所有排列\nEnd // 程式執行結束\n\nMake sure each line includes only one step and comment.\n\nCheck that Decision lines include Yes and No options.\n\nLine 4: \"Decision: 如果 start 等於 nums.length?\" then lines 5 and 6 indented.\n\nBut need to match example's indentation: 4 spaces before inner lines. So we do that.\n\nAlso step 6 is for loop: \"迭代 i 從 start 到 nums.length-1\". Not a decision but a loop. We can represent as Step. That's fine.\n\nWe need to maintain each line separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 nums // 取得使用者提供的數字列表  \n→ Step 2: 初始化空列表 result // 用於儲存所有排列  \n→ Step 3: 定義遞迴函式 backtrack(start) // 從索引 start 開始排列  \n→ Step 4: Decision: 如果 start 等於 nums.length? // 判斷是否已經生成完整排列  \n    Yes → Step 5: 將 nums 的拷貝加入 result // 完整排列加入結果  \n    No  → Step 6: 迭代 i 從 start 到 nums.length-1 // 嘗試把每個元素放在 start 位置  \n        → Step 7: 交換 nums[start] 與 nums[i] // 暫時固定元素  \n        → Step 8: backtrack(start + 1) // 生成後續排列  \n        → Step 9: 交換 nums[start] 與 nums[i] // 回復原狀，進行下一個嘗試  \n→ Step 10: 呼叫 backtrack(0) // 從第一個位置開始遞迴  \n→ Step 11: 回傳 result // 返回所有排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        1. 找到相遇點\n        2. 從起始點與相遇點重新開始，逐步前進直到相遇，即為重複數字\n        \"\"\"\n        # 第一階段：尋找兩個指針相遇的位置\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # 第二階段：尋找入環點（重複數）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整行資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 取得陣列字串\n    # 若輸入形式為 'nums = [1,3,4,2,2]'，則去掉前綴\n    if data.startswith(\"nums\"):\n        start = data.find(\"[\")\n        if start != -1:\n            data = data[start:]\n    # 使用 ast.literal_eval 解析為 Python 物件\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # 如果解析失敗，直接結束\n        sys.exit(1)\n\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding duplicate number without modifying array, constant space. Classic Floyd's Tortoise and Hare algorithm. Steps: start pointers at nums[0] maybe? Actually we use value as index. Implementation: slow = nums[0], fast = nums[nums[0]]; then loop while slow != fast; then find entrance: slow = nums[0]; while slow != fast: slow = nums[slow]; fast = nums[fast]; return slow.\n\nWe'll produce virtual code lines with explanation.\n\nWe must produce each line with \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\" for steps.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: slow ← nums[0] // 初始化慢指針\n\n→ Step 2: fast ← nums[ nums[0] ] // 初始化快指針\n\n→ Decision: slow ≠ fast? // 進入循環尋找交叉點\n\n    Yes → Step 3: slow ← nums[ slow ] // 慢指針移動一步\n\n    Yes → Step 4: fast ← nums[ nums[ fast ] ] // 快指針移動兩步\n\n    Yes → 回到 Decision // 繼續循環\n\n    No  → Step 5: entrance ← nums[0] // 交叉點找到，重置入口指針\n\n→ Decision: entrance ≠ fast? // 尋找入口位置\n\n    Yes → Step 6: entrance ← nums[ entrance ] // 入口指針移動一步\n\n    Yes → Step 7: fast ← nums[ fast ] // 快指針移動一步\n\n    Yes → 回到 Decision // 繼續循環\n\n    No  → Step 8: return entrance // 入口即為重複數\n\nEnd // 程式結束\n\nBut need to include arrow for decision. Let's structure exactly as example: Decision: If condition? and then Yes → etc. We need each line as separate line. Use \"→ Decision:\" line.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: slow ← nums[0] // 初始化慢指針為第一個元素\n\n→ Step 2: fast ← nums[ nums[0] ] // 初始化快指針為以第一個元素為索引的值\n\n→ Decision: slow ≠ fast? // 檢查慢指針和快指針是否相遇\n\n    Yes → Step 3: slow ← nums[ slow ] // 慢指針向前移動一步\n\n    Yes → Step 4: fast ← nums[ nums[ fast ] ] // 快指針向前移動兩步\n\n    Yes → 回到 Decision // 重複相遇判斷\n\n    No  → Step 5: entrance ← nums[0] // 相遇後重置入口指針為起始位置\n\n→ Decision: entrance ≠ fast? // 檢查入口指針和快指針是否相遇\n\n    Yes → Step 6: entrance ← nums[ entrance ] // 入口指針向前移動一步\n\n    Yes → Step 7: fast ← nums[ fast ] // 快指針向前移動一步\n\n    Yes → 回到 Decision // 重複相遇判斷\n\n    No  → Step 8: return entrance // 相遇點即為重複數\n\nEnd // 程式結束\n\nBut we need arrow for \"回到 Decision\"? In example they use \"Yes →\" and \"No →\" under decision. They didn't use \"回到 Decision\". Instead we can simply repeat Decision line after steps. But we can keep as separate step? In example they don't include loop step. For clarity we can produce:\n\nStart\n\n→ Step 1: slow ← nums[0]\n\n→ Step 2: fast ← nums[ nums[0] ]\n\n→ Decision: slow ≠ fast? \n\n    Yes → Step 3: slow ← nums[ slow ]\n\n    Yes → Step 4: fast ← nums[ nums[ fast ] ]\n\n    Yes → 回到 Decision\n\n    No  → Step 5: entrance ← nums[0]\n\n→ Decision: entrance ≠ fast? \n\n    Yes → Step 6: entrance ← nums[ entrance ]\n\n    Yes → Step 7: fast ← nums[ fast ]\n\n    Yes → 回到 Decision\n\n    No  → Step 8: return entrance\n\nEnd\n\nBut we might not need \"回到 Decision\" but keep it. Example didn't have loops but maybe okay. They used \"Yes → Step 2\" etc. For loops, we can express using decision repeated.\n\nWe should ensure each line is separate. We can include \"回到 Decision\" as a line.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: slow ← nums[0] // 初始化慢指針為陣列第一個元素\n→ Step 2: fast ← nums[ nums[0] ] // 初始化快指針為以第一個元素為索引的值\n→ Decision: slow ≠ fast? // 檢查慢指針和快指針是否已相遇\n    Yes → Step 3: slow ← nums[ slow ] // 慢指針前進一步\n    Yes → Step 4: fast ← nums[ nums[ fast ] ] // 快指針前進兩步\n    Yes → 回到 Decision // 重新檢查相遇條件\n    No  → Step 5: entrance ← nums[0] // 相遇後將入口指針重置到起始位置\n→ Decision: entrance ≠ fast? // 從入口位置開始尋找真正的重複數\n    Yes → Step 6: entrance ← nums[ entrance ] // 入口指針前進一步\n    Yes → Step 7: fast ← nums[ fast ] // 快指針前進一步\n    Yes → 回到 Decision // 重新檢查相遇條件\n    No  → Step 8: return entrance // 入口與快指針相遇，即為重複數\nEnd // 程式結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '-1'"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list) -> int:\n        # 若目標基因不在基因庫中，直接無法完成\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            # 產生所有可能的鄰居基因\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入字串轉成 dict，例如:\n    # startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\n    # 先包裹成大括號，再用 literal_eval 解析\n    try:\n        data_dict = ast.literal_eval('{' + data + '}')\n    except Exception as e:\n        print(-1)\n        return\n\n    start_gene = data_dict.get('startGene')\n    end_gene = data_dict.get('endGene')\n    bank = data_dict.get('bank', [])\n\n    result = Solution().minMutation(start_gene, end_gene, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations, for the problem of minimum mutation steps from startGene to endGene, with bank list of valid genes. This is classic BFS on graph of genes. Steps: use BFS queue, visited set, for each gene generate neighbors by changing each position to A/C/G/T except same. If neighbor in bank and not visited, enqueue with distance+1. If endGene found return distance. If BFS ends return -1. Need virtual code lines with arrow and decision. Use Start, End, Decision. Use proper format.\n\nWe should include initialization, check endGene in bank maybe not needed because if not reachable BFS returns -1. But we can check early. We'll produce steps: Start, load bank into set, visited set with startGene, queue with startGene and 0, Decision: queue empty? If Yes → End with -1. No → Dequeue current gene and dist. Decision: current == endGene? Yes → End return dist. No → generate neighbors: for each index, for each char in 'ACGT', if newChar != currentChar, newGene = ... Decision: newGene in bank AND not visited? Yes → add visited, enqueue newGene with dist+1. After for loops, go back to queue empty decision. End.\n\nNeed to show steps as virtual code lines with arrows.\n\nLet's produce.\n\nAlso note that we may have a decision inside loops but we can express loops as steps. But we need each line as virtual code, with arrow.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 bankSet ← set(bank) // 將 gene bank 轉成集合以便 O(1) 查詢\n→ Step 2: 初始化 visitedSet ← {startGene} // 記錄已訪問的基因\n→ Step 3: 初始化 queue ← [(startGene, 0)] // BFS 隊列，儲存 (基因, 步數)\n→ Decision: queue 為空? // 檢查是否有可處理的節點\n    Yes → End -1 // 沒有可處理節點，返回 -1\n    No  → Continue // 進行 BFS\n\nAnd then loop. But we must represent loop as repeating until queue empty. We can model as Decision: queue 為空? Yes -> End -1; No -> Process. After processing, go back to Decision.\n\nLet's produce a simple loop representation:\n\n→ Decision: queue 為空? // 判斷是否完成 BFS\n    Yes → End -1\n    No  → Step 4: 取出 (currentGene, steps) ← queue.pop() // 取得下一個節點\n    → Decision: currentGene == endGene? // 檢查是否到達目標\n        Yes → End steps // 找到最短步數，結束\n        No  → Step 5: 為每個位置 i in 0..7\n            → For each char in 'ACGT'\n                → Decision: char != currentGene[i]? // 確保變化\n                    Yes → newGene ← currentGene[0:i] + char + currentGene[i+1:]\n                    → Decision: newGene in bankSet AND newGene not in visitedSet? // 檢查合法且未訪問\n                        Yes → visitedSet.add(newGene)\n                        → queue.append((newGene, steps+1)) // 加入隊列\n                        No  → Continue\n                    No  → Continue\n        → Go back to Decision: queue 為空? // 循環\n\nBut we need to represent nested loops with indentation? They didn't specify indentation but we can indent decisions. Use \"Decision:\" and \"Yes →\" \"No →\" lines.\n\nBetter: show each step explicitly.\n\nWe'll produce a set of lines. Must include \"Start\" and \"End\". Must include arrow.\n\nLet's craft final answer.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: bankSet ← Set(bank) // 將基因庫轉成集合，便於 O(1) 查詢\n→ Step 2: visitedSet ← {startGene} // 記錄已經走過的基因，避免重複\n→ Step 3: queue ← [(startGene, 0)] // BFS 隊列，儲存 (基因, 已經走的步數)\n→ Decision: queue 為空? // 判斷是否已無可處理節點\n    Yes → End -1 // 若空，表示無法到達 endGene，返回 -1\n    No  → 進行 BFS\n\n→ Step 4: (currentGene, steps) ← queue.pop() // 取出下一個節點\n→ Decision: currentGene == endGene? // 是否已達目標\n    Yes → End steps // 找到最短步數，結束\n    No  → 產生鄰居基因\n\n→ Step 5: for i in 0 .. 7 // 每個位置\n    → for char in ['A', 'C', 'G', 'T'] // 每個可能的字母\n        → Decision: char != currentGene[i]? // 必須改變字符\n            Yes → newGene ← currentGene[:i] + char + currentGene[i+1:] // 生成新基因\n            → Decision: newGene in bankSet AND newGene not in visitedSet? // 檢查合法且未訪問\n                Yes → visitedSet.add(newGene) // 標記已訪問\n                → queue.append((newGene, steps+1)) // 加入隊列\n                No  → // 新基因已訪問或不在庫，跳過\n            No  → // 位置字符未改變，跳過\n        → // 內層循環結束\n    → // 外層循環結束\n\n→ Go back to Decision: queue 為空? // 重複 BFS 主迴圈\n```"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆存儲較大的半部分\n        self.large = []\n        # 大根堆（使用負數）存儲較小的半部分\n        self.small = []\n\n    def addNum(self, num: int) -> None:\n        # 將新數加入小根堆\n        heapq.heappush(self.large, num)\n\n        # 保持兩堆之間的大小關係：大根堆不應該小於小根堆\n        if self.large and self.small and self.large[0] < -self.small[0]:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n        # 調整大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return float(-self.small[0])\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    # 讀取所有輸入行\n    lines = [line.strip() for line in sys.stdin.read().splitlines() if line.strip()]\n    if len(lines) < 2:\n        return\n\n    commands = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    result = []\n    finder = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MedianFinder\":\n            finder = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            finder.addNum(args[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            result.append(finder.findMedian())\n\n    # 輸出結果，使用 JSON 格式以得到 null 代替 None\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for implementing MedianFinder. Use two heaps approach. Provide steps: Start, initialize two heaps, addNum: push into appropriate heap then balance sizes, findMedian: compute median based on sizes. Use Decision structure. Provide explanation. Each line with \"→\" etc. Also need to show End. Use Start and End. Let's produce lines.\n\nWe will include logic: Use max-heap for lower half, min-heap for upper half. addNum: if maxHeap empty or num <= maxHeap.top then push to maxHeap else push to minHeap. Balance: if size difference >1, move one from larger to smaller. findMedian: if sizes equal, median = (max.top + min.top)/2. else median = top of larger heap.\n\nWe'll output each step line by line. Use decision arrows. Let's write.\n\nStart // ...\n→ Step 1: 初始化 MaxHeap lowerHalf // ...\n→ Step 2: 初始化 MinHeap upperHalf // ...\n→ Step 3: 定義 addNum(num) 方法 // ...\n    → Step 3.1: 如果 lowerHalf 為空 或 num ≤ lowerHalf.top? // ...\n        Yes → Step 3.2: lowerHalf.push(num) // 把數字放進 lowerHalf\n        No  → Step 3.3: upperHalf.push(num) // 把數字放進 upperHalf\n    → Step 3.4: 平衡兩堆大小 // ...\n        → Decision: lowerHalf.size() > upperHalf.size() + 1? // ...\n            Yes → Step 3.5: upperHalf.push(lowerHalf.top()); lowerHalf.pop(); // 將較大堆頂移到另一堆\n            No  → Decision: upperHalf.size() > lowerHalf.size() + 1? // ...\n                Yes → Step 3.6: lowerHalf.push(upperHalf.top()); upperHalf.pop(); // 將較小堆頂移到另一堆\n                No  → // 已平衡\n    → Step 3.7: 返回 void // ...\n→ Step 4: 定義 findMedian() 方法 // ...\n    → Decision: lowerHalf.size() == upperHalf.size()? // ...\n        Yes → Step 4.1: median = (lowerHalf.top() + upperHalf.top()) / 2.0 // 計算平均\n        No  → Decision: lowerHalf.size() > upperHalf.size()? // ...\n            Yes → Step 4.2: median = lowerHalf.top() // 最大值\n            No  → Step 4.3: median = upperHalf.top() // 最小值\n    → Step 4.4: 返回 median // ...\nEnd // 程式結束\n\nNeed to use proper syntax: \"Step 1:\" etc. Provide explanation after //.\n\nEnsure each line has \"虛擬碼步驟\" and explanation. Use \"→\" for flow lines. Provide indentation maybe with tabs or spaces. Use arrow for decisions: \"Yes →\" \"No →\". For each decision, include explanation. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 MaxHeap lowerHalf // 建立一個大根堆，用於儲存較小的一半數值  \n→ Step 2: 初始化 MinHeap upperHalf // 建立一個小根堆，用於儲存較大的一半數值  \n→ Step 3: 定義 addNum(num) 方法 // 開始實作加入新數字的功能  \n  → Step 3.1: 如果 lowerHalf 為空 或 num ≤ lowerHalf.top()? // 判斷新數字應放進哪一堆  \n    Yes → Step 3.2: lowerHalf.push(num) // 新數字比 lowerHalf 的最大值還小或等，放入 lowerHalf  \n    No  → Step 3.3: upperHalf.push(num) // 新數字比 lowerHalf 的最大值還大，放入 upperHalf  \n  → Step 3.4: 平衡兩堆大小 // 之後需要確保兩堆大小差不超過 1  \n    → Decision: lowerHalf.size() > upperHalf.size() + 1? // lowerHalf 是否過大？  \n     Yes → Step 3.5: upperHalf.push(lowerHalf.top()); lowerHalf.pop(); // 將 lowerHalf 的最大值移到 upperHalf  \n     No  → Decision: upperHalf.size() > lowerHalf.size() + 1? // upperHalf 是否過大？  \n      Yes → Step 3.6: lowerHalf.push(upperHalf.top()); upperHalf.pop(); // 將 upperHalf 的最小值移到 lowerHalf  \n      No  → // 兩堆已平衡，無需操作  \n  → Step 3.7: 返回 void // addNum 完成  \n→ Step 4: 定義 findMedian() 方法 // 開始實作找中位數的功能  \n  → Decision: lowerHalf.size() == upperHalf.size()? // 兩堆大小是否相等？  \n    Yes → Step 4.1: median = (lowerHalf.top() + upperHalf.top()) / 2.0 // 兩堆大小相等時，中位數是兩個堆頂平均值  \n    No  → Decision: lowerHalf.size() > upperHalf.size()? // lowerHalf 是否較大？  \n     Yes → Step 4.2: median = lowerHalf.top() // lowerHalf 多一個元素時，中位數是其最大值  \n     No  → Step 4.3: median = upperHalf.top() // upperHalf 多一個元素時，中位數是其最小值  \n  → Step 4.4: 返回 median // 返回計算得到的中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgr86elu1.py\", line 96, in <module>\n    main()\n  File \"/tmp/tmpgr86elu1.py\", line 88, in main\n    intervals, new_interval = parse_intervals_and_new(data)\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgr86elu1.py\", line 33, in parse_intervals_and_new\n    raise ValueError(\"Cannot find the second '[' in the input.\")\nValueError: Cannot find the second '[' in the input."
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiwan87n6.py\", line 96, in <module>\n    main()\n  File \"/tmp/tmpiwan87n6.py\", line 88, in main\n    intervals, new_interval = parse_intervals_and_new(data)\n                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpiwan87n6.py\", line 33, in parse_intervals_and_new\n    raise ValueError(\"Cannot find the second '[' in the input.\")\nValueError: Cannot find the second '[' in the input."
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef parse_intervals_and_new(data: str):\n    \"\"\"\n    從輸入字串中擷取 intervals 與 newInterval 兩個列表。\n    這個解析器不依賴空格，能處理類似 'intervals = [[1,3],[6,9]], newInterval = [2,5]' 的格式。\n    \"\"\"\n    i, n = 0, len(data)\n    # 找第一個 '['\n    while i < n and data[i] != '[':\n        i += 1\n    if i == n:\n        raise ValueError(\"Cannot find the first '[' in the input.\")\n    start = i\n    depth = 0\n    while i < n:\n        if data[i] == '[':\n            depth += 1\n        elif data[i] == ']':\n            depth -= 1\n            if depth == 0:\n                i += 1\n                break\n        i += 1\n    first = data[start:i]\n\n    # 跳過任何空白和逗號，找到第二個 '['\n    while i < n and (data[i].isspace() or data[i] == ','):\n        i += 1\n    if i == n or data[i] != '[':\n        raise ValueError(\"Cannot find the second '[' in the input.\")\n    start = i\n    depth = 0\n    while i < n:\n        if data[i] == '[':\n            depth += 1\n        elif data[i] == ']':\n            depth -= 1\n            if depth == 0:\n                i += 1\n                break\n        i += 1\n    second = data[start:i]\n\n    intervals = ast.literal_eval(first)\n    new_interval = ast.literal_eval(second)\n    return intervals, new_interval\n\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        將 newInterval 插入到已排序且互不重疊的 intervals 中，\n        並合併任何重疊區間。返回合併後的新區間列表。\n        \"\"\"\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 1. 將所有不在 newInterval 之前的區間直接加入結果\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 2. 合併所有與 newInterval 重疊的區間\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 3. 將合併後的 newInterval 加入結果\n        result.append(newInterval)\n\n        # 4. 將所有剩餘的區間加入結果\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    intervals, new_interval = parse_intervals_and_new(data)\n    solution = Solution()\n    merged = solution.insert(intervals, new_interval)\n    # 使用 json.dumps 以避免在輸出中出現空格\n    print(json.dumps(merged))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode in virtual code steps. Should explain each line. Should be line by line. We need to process array of intervals sorted non-overlapping. Insert new interval and merge if overlapping. Return resulting array.\n\nWe produce steps: Start, input intervals array, newInterval. Initialize result list. Iterate intervals. For each interval, if interval ends before new starts -> add to result. Else if interval starts after new ends -> add new (if not yet added) then add interval. Else merge: update new interval's start to min(start, interval[0]), end to max(end, interval[1]). After loop, if new not added, add new. End.\n\nMake sure to use decision structure. Use arrow arrows. Each line with explanation. Ensure no code output. Only virtual code with comments.\n\nLet's produce. Ensure \"Start // 程式開始執行\" etc. Use steps like \"→ Step 1: 定義 result 為空陣列 // 用來存放合併後的區間\". Use Decision: \"Decision: newInterval 已加入 result?\" etc. Use Yes → etc.\n\nWe should use variable names like intervals, newInterval, result, i, merged. We'll use pseudocode steps.\n\nLet's craft. We'll number or just use Step X. Provide explanation.\n\nAlso note \"虛擬碼步驟\" can be \"Step 1:\" etc.\n\nLet's produce lines:\n\nStart\n→ Step 1: result = [] // 建立空結果陣列\n→ Step 2: newAdded = False // 標記新區間是否已加入\n→ Step 3: for each interval in intervals // 逐一檢查每個已有區間\n    → Decision: interval.end < newInterval.start? // 新區間在此之前，無重疊\n        Yes → Step 4: result.append(interval) // 直接加入結果\n        No → Decision: interval.start > newInterval.end? // 新區間在此之後，無重疊\n            Yes → Decision: newAdded? // 是否已將新區間加入\n                Yes → Step 5: result.append(interval) // 新區間已加，直接加入\n                No  → Step 6: result.append(newInterval) // 先加入新區間\n                No  → Step 7: result.append(interval) // 再加入當前區間\n                No  → Step 8: newAdded = True // 標記新區間已加\n            No  → Step 9: // 重疊，合併區間\n                newInterval.start = min(newInterval.start, interval.start) // 更新開始\n                newInterval.end   = max(newInterval.end, interval.end)   // 更新結束\n→ Decision: newAdded? // 迴圈結束後判斷新區間是否已加入\n    Yes → End // 已加入，結果完成\n    No  → Step 10: result.append(newInterval) // 若尚未加入，追加\nEnd\n\nNeed to be careful about indentation. Use spaces or arrow? Use indentation with spaces for readability. Ensure each line ends with comment. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = [] // 建立空結果陣列，用於儲存最終合併後的區間  \n→ Step 2: newAdded = False // 標記 newInterval 是否已加入結果陣列  \n→ Step 3: for each interval in intervals // 逐一檢查每個已有區間  \n  → Decision: interval.end < newInterval.start? // 新區間完全在此區間之前，無重疊  \n   Yes → Step 4: result.append(interval) // 直接把此區間加入結果  \n   No → Decision: interval.start > newInterval.end? // 新區間完全在此區間之後，無重疊  \n    Yes → Decision: newAdded? // 判斷新區間是否已經加入結果  \n     Yes → Step 5: result.append(interval) // 新區間已加，直接把此區間加入結果  \n     No  → Step 6: result.append(newInterval) // 先把新區間加入結果  \n     No  → Step 7: result.append(interval) // 再把此區間加入結果  \n     No  → Step 8: newAdded = True // 標記新區間已加入  \n    No → Step 9: // 新區間與此區間重疊，需要合併  \n     newInterval.start = min(newInterval.start, interval.start) // 更新合併後的開始位置  \n     newInterval.end   = max(newInterval.end, interval.end)   // 更新合併後的結束位置  \n→ Decision: newAdded? // 迴圈結束後判斷新區間是否已加入結果  \n  Yes → End // 新區間已加入，結果完成  \n  No  → Step 10: result.append(newInterval) // 若尚未加入，追加新區間到結果  \nEnd // 程式執行結束，返回 result 陣列"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef group_anagrams(strs):\n    \"\"\"\n    將字串陣列按字母排序後，使用 sorted 字串作為 key，將相同 key 的字串歸為同一組。\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))          # 例如 \"eat\" -> ('a', 'e', 't')\n        anagrams[key].append(s)\n    return list(anagrams.values())\n\ndef main():\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 取得第一個 '[' 後的內容（即字串列表字面值）\n    start = raw_input.find('[')\n    if start == -1:\n        raise ValueError(\"輸入格式錯誤，找不到 '['\")\n    list_literal = raw_input[start:]\n\n    # 用 ast.literal_eval 解析成 Python list\n    try:\n        strs = ast.literal_eval(list_literal)\n    except Exception as e:\n        raise ValueError(f\"無法解析字串列表: {e}\")\n\n    # 分組同字母異序的字串\n    result = group_anagrams(strs)\n\n    # 用 json.dumps 輸出，得到雙引號格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for grouping anagrams. Should be line by line with comments. Use Start, End, Decision, arrows. Provide explanation after space. The code is pseudo. Each line like \"Start // 程式開始執行\". Then steps.\n\nWe need to consider algorithm: iterate over strings, compute sorted key or count vector, store in map, collect groups.\n\nPseudo code steps: Start, Step 1: initialize hashmap key->list, Step 2: for each string in strs: compute sorted string key, add string to hashmap list, Step 3: initialize result list, Step 4: iterate over hashmap values, add to result, End.\n\nUse Decision if needed? Not necessary but can include a Decision: if strs is empty? But we can show.\n\nLet's produce. Use arrow for steps. Each line: \"→ Step X: ...\" plus comment.\n\nLet's produce.\n\nAlso mention that key is sorted string. Use \"Decision: 如果 strs 為空?\" etc. Provide explanation.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的字典 groups // 用來儲存以排序字串為 key 的 anagram 群組  \n→ Decision: 如果 strs 為空? // 檢查輸入是否為空  \n  Yes → Step 2: 回傳空陣列 // 空輸入直接回傳空結果  \n  No → Step 3: 進入迴圈處理每個字串 // 開始對每個字串進行處理  \n→ Step 4: 對 strs 內的每個字串 s 進行迴圈  \n  → Step 4.1: 將 s 轉成字元陣列，排序，合併成 sortedKey // 以排序後的字元為 key  \n  → Step 4.2: 若 groups 沒有 sortedKey, 則建立空陣列作為值 // 初始化群組  \n  → Step 4.3: 將 s 加入 groups[sortedKey] // 把字串放進對應的 anagram 群組  \n→ Step 5: 建立結果 result 為空陣列 // 用來收集所有群組  \n→ Decision: 如果 groups 為空? // 檢查是否有任何 anagram 群組  \n  Yes → Step 6: 回傳 result // 若沒有輸入字串，直接回傳空結果  \n  No → Step 7: 迭代 groups 的每個值 list  \n   → Step 7.1: 將 list 加入 result // 將群組加入最終結果  \n→ End // 程式執行結束，返回 result 其中包含所有 anagram 群組"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"Convert a Roman numeral string to an integer.\"\"\"\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0\n        prev_value = 0\n        # Process characters from right to left\n        for char in reversed(s):\n            value = roman_map[char]\n            if value < prev_value:\n                total -= value\n            else:\n                total += value\n            prev_value = value\n        return total\n\ndef main():\n    # Read entire stdin input\n    data = sys.stdin.read()\n    # Extract Roman numeral letters (I,V,X,L,C,D,M)\n    match = re.search(r'[IVXLCDM]+', data.upper())\n    if not match:\n        return\n    roman_str = match.group(0)\n    sol = Solution()\n    result = sol.romanToInt(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to convert Roman numeral string to integer. Provide steps line by line, with explanation. We must not output actual code. So produce a flowchart style pseudocode. Steps: Start, input string, initialize total=0, mapping dict, iterate over string index, if current symbol value < next symbol value then subtract else add. End, output total. Provide explanation after each line. Use arrows and Decision. Provide in Traditional Chinese.\n\nWe need to produce each line with '虛擬碼步驟' and then explanation. Example format: `Start // 程式開始執行`. Use '→ Step 1: ... // explanation' etc.\n\nMake sure to include arrow lines. For decisions use 'Decision:'.\n\nLet's draft. We'll need mapping dictionary: Map Roman symbol to value. Steps:\n\n1. Start.\n2. Input roman string S.\n3. Initialize total = 0.\n4. Initialize i = 0.\n5. Decision: i < len(S)?\n   Yes → Step: cur = value of S[i] // get value\n   No → End → output total.\n6. Decision: i+1 < len(S) AND cur < value of S[i+1]?\n   Yes → Step: total = total + (value of S[i+1] - cur); i = i+2\n   No → Step: total = total + cur; i = i+1\n7. Go back to Decision: i < len(S)?\n\nAlternatively using loop.\n\nWill produce steps accordingly.\n\nLet's format: each line starts with arrow or step.\n\nWe must keep step numbers or names. Use Step 1 etc.\n\nLet's produce.\n\nUse \"Start\" then \"→ Step 1: ...\" etc.\n\nEnsure each line includes explanation.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input Roman numeral string S // 取得使用者輸入的羅馬數字  \n→ Step 2: Initialize total ← 0 // 儲存最終整數結果  \n→ Step 3: Initialize i ← 0 // 位置指標，從字串起始處開始  \n→ Decision: i < len(S) ? // 檢查是否還有未處理的字符  \n  Yes → Step 4: cur ← value_of(S[i]) // 取得當前字符的數值  \n  No  → Step 7: Output total // 所有字符處理完畢，輸出結果  \n→ Decision: i+1 < len(S) AND cur < value_of(S[i+1]) ? // 判斷是否為減法組合  \n  Yes → Step 5: total ← total + (value_of(S[i+1]) - cur) // 計算減法結果  \n    → Step 6: i ← i + 2 // 跳過已處理的兩個字符  \n  No  → Step 5: total ← total + cur // 直接累加當前數值  \n    → Step 6: i ← i + 1 // 移動到下一個字符  \n→ Step 6: Go back to Decision: i < len(S) // 迴圈至下一個字符  \n→ Step 7: End // 程式執行結束（已在 Decision 的 No 分支輸出結果）"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxvo3hje2.py\", line 43, in <module>\n    matrix = ast.literal_eval(matrix_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,5,9]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpee8jl3zx.py\", line 43, in <module>\n    matrix = ast.literal_eval(matrix_str)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[-5]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low = matrix[0][0]\n    high = matrix[-1][-1]\n    while low < high:\n        mid = (low + high) // 2\n        # Count elements <= mid\n        count = 0\n        row, col = 0, n - 1\n        while row < n and col >= 0:\n            if matrix[row][col] <= mid:\n                count += col + 1\n                row += 1\n            else:\n                col -= 1\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract matrix part\n    matrix_match = re.search(r'matrix\\s*=\\s*(\\[[^\\]]+\\])', data)\n    if not matrix_match:\n        raise ValueError(\"Matrix not found in input\")\n    matrix_str = matrix_match.group(1)\n\n    # Extract k part\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        raise ValueError(\"k not found in input\")\n    k = int(k_match.group(1))\n\n    matrix = ast.literal_eval(matrix_str)\n    result = kth_smallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. Problem: find kth smallest in sorted matrix. Classic solution: binary search over value range, counting <= mid. Complexity O(n^2 log(max-min)). Memory O(1). Provide pseudocode with start, decision, loops, etc. Use virtual code with arrows.\n\nWe need to follow format: each line: \"虛擬碼步驟 // 解釋\". Use \"→\" arrows and \"Decision:\" etc. Provide step-by-step.\n\nWe need to start with Start, then steps: input matrix, k, compute low, high. While low<high: mid, count number <= mid. If count >= k then high=mid else low=mid+1. End. Return low.\n\nWe should use pseudocode, not actual code. Use \"Step 1: 取得矩陣大小 n\" etc.\n\nNeed to be precise but simple. Let's craft:\n\nStart\n→ Step 1: 定義 n 為矩陣維度 // 取得矩陣大小\n→ Step 2: 設定 low 為 matrix[0][0] // 最小值\n→ Step 3: 設定 high 為 matrix[n-1][n-1] // 最大值\n→ Decision: low < high? // 確定是否還需要繼續搜尋\n    Yes → Step 4: 計算 mid = (low + high) // 2 // 中值\n    → Step 5: 計算 count = 0 // 初始化計數\n    → Step 6: for i = 0 to n-1: // 逐行遍歷\n        → Step 7: j = n-1 // 從最右邊開始\n        → Decision: j >= 0? // 是否還有列可檢查\n            Yes → Decision: matrix[i][j] <= mid? // 值是否小於等於 mid\n                Yes → Step 8: count = count + 1 // 計數加一\n                No → Step 9: j = j - 1 // 向左移動\n            No → Step 10: i = i + 1 // 進到下一行\n    → Decision: count >= k? // 是否足夠多數值小於等於 mid\n        Yes → Step 11: high = mid // 將上限縮小\n        No  → Step 12: low = mid + 1 // 將下限調高\n    → Decision: low < high? // 再次判斷是否結束迴圈\n        Yes → jump to Step 4\n        No  → Step 13: return low // 最終答案\nEnd\n\nBut we need to use arrow syntax properly. We also need to indicate loops and decisions.\n\nBut the format demands: \"→ Step ...\" etc. For decisions, use \"Decision: ...\" and indent for branches.\n\nWe need to ensure indentation: we can indent each branch lines by some spaces or maybe with tabs. We can just use spaces.\n\nAlso we need to avoid actual code. Use pseudocode words.\n\nWe should avoid \"jump to\" but we can use recursion? Actually we can just loop with while. Use \"while low < high:\" but in pseudocode.\n\nBut format uses \"Decision:\" and \"Yes →\" and \"No →\". So maybe:\n\n→ Decision: low < high? // 循環判斷\n    Yes → Step 4: mid = (low + high) // 2 // 計算中值\n    ...\n\nBut the loop may be represented by decision then branches, but we need to return to decision after finishing counting. But we can just show \"→ Decision: low < high? // 是否還需搜尋\" then \"Yes →\" etc. Inside yes branch we can include all steps and then at the end, go back to decision. Maybe we can represent loop by \"→ Decision: low < high? // 循環條件\" and \"Yes → ...\" and \"No → End\" etc.\n\nHowever we need \"End\" at the end. Actually we need to output \"End // 程式執行結束\".\n\nSo maybe we have a structure like:\n\nStart\n→ Step 1...\n→ Step 2...\n→ Step 3...\n→ Decision: low < high? // 判斷是否還有迴圈\n    Yes → Step 4...\n    … (all steps inside loop)\n    → Decision: low < high? // 再次判斷\n        Yes → (repeat)\n        No → Step 13...\nEnd\n\nBut to avoid confusion, we can show loop as:\n\n→ Decision: low < high? // 循環條件\n    Yes → Step 4: mid = ...\n        … \n        → Decision: low < high? // 再次判斷\n            Yes → ... (go back to Step 4)\n            No → Step 13: return low\n    No  → End\n\nBut we want to keep pseudocode linear; we can do:\n\n→ Step 4: mid = ...\n→ Step 5: count = 0\n→ Step 6: for i = 0 to n-1\n    ... counting\n→ Decision: count >= k? ...\n→ Step 11/12: adjust low/high\n→ Decision: low < high? ...\n    Yes → go back to Step 4\n    No → Step 13: return low\n\nBut \"go back\" not allowed? We can just show that the loop repeats. But maybe easier to present as while loop:\n\n→ Step 4: while low < high: // 迴圈開始\n    ... steps inside\n→ Step 13: return low\nEnd\n\nBut format demands Decision and arrow, not while. But maybe \"Decision:\" is acceptable. They didn't specify we can't use while. But they want \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we need to use these.\n\nSo we can have:\n\n→ Decision: low < high? // 判斷是否還需搜尋\n    Yes → Step 4: mid = (low + high) // 2 // 計算中值\n        → Step 5: count = 0 // 初始化計數\n        → Step 6: for i = 0 to n-1 // 逐行\n            → Step 7: j = n-1 // 從最右邊\n            → Decision: j >= 0? \n                Yes → Decision: matrix[i][j] <= mid? \n                    Yes → Step 8: count = count + 1 // 計數加一\n                    No  → Step 9: j = j - 1 // 向左移動\n                No  → Step 10: i = i + 1 // 進到下一行\n        → Decision: count >= k? \n            Yes → Step 11: high = mid // 上限調整\n            No  → Step 12: low = mid + 1 // 下限調整\n        → Decision: low < high? // 回到外層判斷\n            Yes → (回到 Step 4) // 這裡表示迴圈再次執行\n            No  → Step 13: return low // 結果\n    No  → End // 迴圈結束，返回結果\nEnd\n\nBut we need to avoid \"return low\" outside? We can put Step 13 inside No branch.\n\nHowever we also need End at final. We can have \"End\" after the entire structure.\n\nBut the \"return low\" should be executed before End. So maybe:\n\n→ Decision: low < high? // 判斷是否還需搜尋\n    Yes → ... // loop body\n    No  → Step 13: result = low // 記錄答案\n→ End // 程式結束\n\nBut they might want End at very end after returning.\n\nSimplify: We'll create a structure:\n\nStart\n→ Step 1: n = matrix size\n→ Step 2: low = matrix[0][0]\n→ Step 3: high = matrix[n-1][n-1]\n→ Decision: low < high? // 需要搜尋\n    Yes → Step 4: mid = (low + high) // 2\n        → Step 5: count = 0\n        → Step 6: i = 0\n        → Decision: i < n? \n            Yes → Step 7: j = n-1\n                → Decision: j >= 0? \n                    Yes → Decision: matrix[i][j] <= mid? \n                        Yes → Step 8: count = count + 1\n                        No  → Step 9: j = j - 1\n                    No  → Step 10: i = i + 1\n                // Actually we need to loop j and i; we can use nested loops but we need to show them with decisions\n            No  → Step 11: Decision: count >= k? \n                Yes → Step 12: high = mid\n                No  → Step 13: low = mid + 1\n                → Decision: low < high? \n                    Yes → (go back to Step 4)\n                    No  → Step 14: return low\n    No  → Step 15: return low\nEnd\n\nBut this is messy.\n\nMaybe easier: use a function: while low < high, compute mid, count. But still need to show loops.\n\nCould show pseudocode as:\n\nStart\n→ Step 1: n = len(matrix)\n→ Step 2: low = matrix[0][0]\n→ Step 3: high = matrix[n-1][n-1]\n→ Decision: low < high? // 循環條件\n    Yes → Step 4: mid = (low + high) // 2\n        → Step 5: count = 0\n        → Step 6: for i = 0 to n-1\n            → Step 7: j = n-1\n            → Decision: j >= 0? \n                Yes → Decision: matrix[i][j] <= mid?\n                    Yes → Step 8: count = count + 1\n                    No  → Step 9: j = j - 1\n                No  → Step 10: i = i + 1\n        → Decision: count >= k? \n            Yes → Step 11: high = mid\n            No  → Step 12: low = mid + 1\n        → Decision: low < high? // 迴圈判斷\n            Yes → (回到 Step 4) // 循環\n            No  → Step 13: return low\n    No  → Step 13: return low\nEnd\n\nBut we need to incorporate \"End\" at last. The \"return low\" should happen before End.\n\nMaybe we can simplify: use binary search with loop, but still show decisions.\n\nBetter: Represent loop as:\n\n→ Decision: low < high? // 迴圈條件\n    Yes → \n        → Step 4: mid = (low + high) // 2\n        → Step 5: count = 0\n        → Step 6: i = 0\n        → Decision: i < n? \n            Yes → \n                → Step 7: j = n-1\n                → Decision: j >= 0? \n                    Yes → \n                        → Decision: matrix[i][j] <= mid? \n                            Yes → Step 8: count = count + 1\n                            No  → Step 9: j = j - 1\n                    No  → Step 10: i = i + 1\n            No  → \n                → Decision: count >= k? \n                    Yes → Step 11: high = mid\n                    No  → Step 12: low = mid + 1\n                → Decision: low < high? \n                    Yes → (回到 Step 4)\n                    No  → Step 13: return low\n    No → Step 13: return low\nEnd\n\nBut the nested decisions get complicated.\n\nMaybe we can cheat: Use \"while\" pseudo but still use \"Decision:\".\n\nWe can write:\n\n→ Step 4: while low < high: // 迴圈\n    ... body\n\nBut they didn't restrict \"while\". They said to use \"Decision:\" etc. But we can still show \"while\".\n\nMaybe easiest: Show algorithm in high-level pseudocode with steps and decisions.\n\nLet's produce:\n\nStart\n→ Step 1: n = matrix size // 獲取矩陣維度\n→ Step 2: low = matrix[0][0] // 最小元素\n→ Step 3: high = matrix[n-1][n-1] // 最大元素\n→ Decision: low < high? // 是否還需要繼續搜尋\n    Yes → Step 4: mid = (low + high) // 2 // 計算中值\n        → Step 5: count = 0 // 初始化計數\n        → Step 6: i = 0 // 初始化行指標\n        → Decision: i < n? // 是否還有行\n            Yes → Step 7: j = n-1 // 從右端開始\n                → Decision: j >= 0? // 是否還有列\n                    Yes → Decision: matrix[i][j] <= mid? // 與 mid 比較\n                        Yes → Step 8: count = count + 1 // 計數 +1\n                        No  → Step 9: j = j - 1 // 向左移動\n                    No  → Step 10: i = i + 1 // 行指標+1\n            No → Decision: count >= k? // 判斷是否足夠\n                Yes → Step 11: high = mid // 收縮上限\n                No  → Step 12: low = mid + 1 // 調整下限\n                → Decision: low < high? // 迴圈結束條件\n                    Yes → (回到 Step 4) // 重新進入搜尋\n                    No  → Step 13: result = low // 記錄答案\n    No → Step 13: result = low // 若初始條件不滿足，直接結果\n→ End // 程式結束\n\nBut we need to ensure \"End\" after return. This is okay.\n\nHowever the nested loops and decisions are still a bit messy. But it's fine as long as each line has \"虛擬碼步驟 // 解釋\". We have to ensure each line is one statement.\n\nLet's craft final answer accordingly. Ensure each line begins with \"→\" except Start and End. Use \"Decision:\" for decisions. Use \"Yes →\" and \"No →\". Indentation maybe with spaces. Provide explanation after \"//\". Use traditional Chinese.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n = matrix size // 取得矩陣維度 n\n→ Step 2: low = matrix[0][0] // 設定最小可能值\n→ Step 3: high = matrix[n-1][n-1] // 設定最大可能值\n→ Decision: low < high? // 判斷是否需要進一步搜尋\n    Yes → Step 4: mid = (low + high) // 2 // 計算中值\n        → Step 5: count = 0 // 初始化小於等於 mid 的元素數量\n        → Step 6: i = 0 // 初始化行索引\n        → Decision: i < n? // 檢查是否還有行\n            Yes → Step 7: j = n-1 // 從最右側開始\n                → Decision: j >= 0? // 檢查是否還有列\n                    Yes → Decision: matrix[i][j] <= mid? // 與中值比較\n                        Yes → Step 8: count = count + 1 // 數量加一\n                        No  → Step 9: j = j - 1 // 向左移動\n                    No  → Step 10: i = i + 1 // 行指標向下\n            No → Decision: count >= k? // 判斷是否已經找足夠數量\n                Yes → Step 11: high = mid // 上限調整為 mid\n                No  → Step 12: low = mid + 1 // 下限調整為 mid+1\n                → Decision: low < high? // 重新檢查迴圈條件\n                    Yes → (回到 Step 4) // 繼續搜尋\n                    No  → Step 13: result = low // 找到第 k 小的元素\n    No → Step 13: result = low // 初始條件已滿足，直接返回\nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0+-2i'\nGot (Norm):      '0-2i'\n--- (Raw) ---\nRaw Expected: '\"0+-2i\"'\nRaw Got:      '0-2i'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef parse_complex(s: str):\n    \"\"\"\n    解析形如 \"real+imaginaryi\" 或 \"real-imaginaryi\" 的複數字串。\n    支援實部為負、虛部為負，以及實部後接 '+-' 的情形。\n    \"\"\"\n    # 找到實部與虛部的分隔符號，必須排除可能出現在實部前面的符號\n    split_index = None\n    for i in range(1, len(s) - 1):\n        if s[i] == '+' or s[i] == '-':\n            split_index = i\n            break\n    if split_index is None:\n        raise ValueError(f\"無法解析複數字串 {s}\")\n\n    real_str = s[:split_index]\n    imag_str = s[split_index:-1]  # 去掉最後的 'i'\n\n    # 處理形如 \"+-1\" 的情形：去掉前面的 '+'\n    if imag_str and imag_str[0] == '+':\n        imag_str = imag_str[1:]\n\n    real = int(real_str)\n    imag = int(imag_str)\n    return real, imag\n\ndef format_complex(real: int, imag: int) -> str:\n    \"\"\"\n    將實部、虛部轉成字串形式，例如 (0, -2) -> \"0-2i\"\n    \"\"\"\n    if imag >= 0:\n        return f\"{real}+{imag}i\"\n    else:\n        return f\"{real}{imag}i\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先用正則式抓取引號內的內容\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        num1, num2 = parts[0], parts[1]\n    else:\n        # 如果沒有引號，直接以逗號分割\n        parts = [p.strip().strip('\"') for p in data.split(',')]\n        num1, num2 = parts[0], parts[1]\n\n    a, b = parse_complex(num1)\n    c, d = parse_complex(num2)\n\n    real_part = a * c - b * d\n    imag_part = a * d + b * c\n\n    result = format_complex(real_part, imag_part)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that parses two complex numbers strings, multiplies them, and returns string. Need step by step.\n\nWe should include Start, End, Decision, etc. Each line: virtual code step + \" // explanation\".\n\nWe need to be careful to represent string parsing, splitting by '+', handling signs, etc.\n\nLet's design algorithm:\n\n- Input: two strings num1, num2.\n\n- Parse function: parseComplex(string s):\n\n   - Find index of '+' or '-' after real part (but careful with negative real part). Could split by '+' or '-'. But since imaginary part is always followed by 'i', we can find the position of 'i', then the imaginary part substring before 'i', and the real part substring before the start of imaginary part.\n\n   - Approach: Find position of 'i' (last char). Real part is substring from start to the index of '+' or '-' before the imaginary part. Actually string pattern: real+imaginaryi or real-imaginaryi. real can be negative; imaginary can be negative. So we can locate the last '+' or '-' before the 'i', but ensure we don't take the sign of real part.\n\n   - Let's find index of '+' or '-' that splits real and imaginary: search for '+' or '-' after the first character. Example: \"-3-4i\" -> real \"-3\", imaginary \"-4\". So we can find first occurrence of '+' or '-' after index 1.\n\n   - So:\n\n       splitIndex = s.find('+',1) if not found then s.find('-',1)\n\n   - realPart = s[0:splitIndex], real = int(realPart)\n\n   - imagPart = s[splitIndex:-1] (exclude 'i'), imag = int(imagPart)\n\nReturn (real, imag)\n\n- Multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i\n\n- Compose result string: f\"{realPart}+{imagPart}i\" but need handle sign of imaginary part: if imaginaryPart negative, use '-' automatically by str conversion. For example 5-6i -> \"5-6i\". So we can use sign string: if imag >=0: imag_str = f\"+{imag}\", else imag_str = f\"{imag}\". Then result = f\"{real}{imag_str}i\".\n\nEdge cases: real part zero: \"0+0i\" etc. No special formatting needed.\n\nNow produce virtual code line by line.\n\nWe need Start, then step reading inputs, parse each, multiplication, result building, output, End.\n\nAlso may include helper functions parseComplex and formatComplex.\n\nUse virtual code:\n\nStart\n→ Step 1: Input num1, num2 // 取得兩個複數字串\n\n→ Step 2: Call parseComplex(num1) → (a, b) // 解析第一個複數\n\n→ Step 3: Call parseComplex(num2) → (c, d) // 解析第二個複數\n\n→ Step 4: Compute realPart = a*c - b*d // 真實部乘法公式\n\n→ Step 5: Compute imagPart = a*d + b*c // 虛部乘法公式\n\n→ Step 6: Call formatComplex(realPart, imagPart) → resultStr // 轉成字串格式\n\n→ Step 7: Output resultStr // 回傳結果\n\nEnd\n\nNow define parseComplex as subroutine:\n\n→ Start parseComplex(s) // 解析複數字串\n\n→ Decision: 找到 '+' 或 '-' 後於第一個字元? // 確定分隔符位置\n\n   Yes → splitIndex = index of '+' after position 1; No → splitIndex = index of '-' after position 1\n\n→ Step 8: realStr = s[0:splitIndex] // 真實部字串\n\n→ Step 9: imagStr = s[splitIndex:-1] // 虛部字串（去掉最後的 'i'）\n\n→ Step 10: real = int(realStr) // 轉為整數\n\n→ Step 11: imag = int(imagStr) // 轉為整數\n\n→ End // 回傳 (real, imag)\n\nBut we need to produce lines inside parseComplex subroutine. Use indentation maybe not necessary but can use arrow. Use \"parseComplex\" as a step.\n\nSimilarly formatComplex:\n\n→ Start formatComplex(real, imag) // 建立字串表示\n\n→ Decision: imag >= 0? // 處理正負符號\n\n   Yes → imagStr = \"+\" + str(imag)\n\n   No  → imagStr = str(imag) // 直接負號\n\n→ Step 12: result = str(real) + imagStr + \"i\" // 組合字串\n\n→ End // 回傳 result\n\nNeed to ensure each line includes explanation. Use \"→\" arrow.\n\nWe also need to include \"Start\" and \"End\" for main routine, and also subroutines. Use indentation? Not necessary. Just separate lines.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input num1, num2 // 取得兩個複數字串\n→ Step 2: Call parseComplex(num1) → (a, b) // 解析第一個複數字串為 (實部, 虛部)\n→ Step 3: Call parseComplex(num2) → (c, d) // 解析第二個複數字串為 (實部, 虛部)\n→ Step 4: Compute realPart = a*c - b*d // 真實部乘法公式：ac - bd\n→ Step 5: Compute imagPart = a*d + b*c // 虛部乘法公式：ad + bc\n→ Step 6: Call formatComplex(realPart, imagPart) → resultStr // 轉成字串格式\n→ Step 7: Output resultStr // 回傳結果\nEnd // 程式執行結束\n\n// ---------- parseComplex 子程式 ----------\nStart parseComplex(s) // 開始解析複數字串\n→ Decision: s 中是否含 '+' 後於第一個字元? // 找到實部與虛部的分隔符\n    Yes → splitIndex = s.find('+', 1) // 找到 '+' 的位置\n    No  → splitIndex = s.find('-', 1) // 找到 '-' 的位置（負虛部）\n→ Step 8: realStr = s[0:splitIndex] // 取實部字串\n→ Step 9: imagStr = s[splitIndex:-1] // 取虛部字串（去除最後的 'i'）\n→ Step 10: real = int(realStr) // 轉為整數實部\n→ Step 11: imag = int(imagStr) // 轉為整數虛部\nEnd // 回傳 (real, imag)\n\n// ---------- formatComplex 子程式 ----------\nStart formatComplex(real, imag) // 開始組合字串\n→ Decision: imag >= 0? // 處理正負符號\n    Yes → imagStr = \"+\" + str(imag) // 正數前加 '+'\n    No  → imagStr = str(imag) // 負數直接保留負號\n→ Step 12: result = str(real) + imagStr + \"i\" // 組合成 \"real+imagi\" 或 \"real-imagi\"\nEnd // 回傳結果字串"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[1]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[1]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[2,4]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[2, 4]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[2,8,9]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[2, 8, 9]'"
        }
      ],
      "generated_code": "import sys\nimport secrets\n\ndef rand7() -> int:\n    \"\"\"Return a uniform random integer from 1 to 7 inclusive.\"\"\"\n    return secrets.randbelow(7) + 1\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        Generate a uniform random integer from 1 to 10 using only rand7().\n        Uses the classic 49‑to‑40 rejection sampling technique.\n        \"\"\"\n        while True:\n            # Produce a number in the range 1..49\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # accept only 1..40\n                return 1 + (num - 1) % 10     # map to 1..10\n\ndef main() -> None:\n    \"\"\"\n    Main entry point:\n    - Reads input from stdin. Expected format: 'n = X' or just 'X'.\n    - Generates X random numbers using Solution.rand10().\n    - Prints the list of results.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the integer n from the input\n    try:\n        if '=' in data:\n            n_str = data.split('=')[-1].strip()\n        else:\n            n_str = data\n        n = int(n_str)\n    except ValueError:\n        # If parsing fails, exit silently\n        return\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating rand10() using rand7() only, typical algorithm: use two rand7 calls to produce 49 outcomes, reject if > 40, map 1-40 to 1-10 via modulo. Or other efficient approach. Provide step-by-step pseudocode with arrows, decision blocks, etc. Each line: \"虛擬碼步驟 // 解釋\". We need to output only the virtual code lines, no real code.\n\nSo produce:\n\nStart\n→ Step 1: Call rand7() -> a\n→ Step 2: Call rand7() -> b\n→ Step 3: Compute num = (a-1)*7 + b // combine to 1..49\n→ Decision: if num > 40? // reject range 41-49\n    Yes → Step 4: Repeat from Step 1 // retry\n    No  → Step 5: result = (num-1) mod 10 + 1 // map 1..40 to 1..10\n→ Step 6: Return result\nEnd\n\nBut we need to incorporate looping and recursion perhaps. Use 'Loop' structure. Provide virtual pseudocode lines. Ensure each line has '虛擬碼步驟' and comment.\n\nWe must keep each line separate. Use arrows. Provide 'Start', 'End'.\n\nAdd indentation for decisions. Provide '→' before each step. Provide 'Decision:' lines. Provide 'Yes →', 'No →'.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 呼叫 rand7() 並將結果存至 a // 取得第一個 1~7 的隨機數  \n→ Step 2: 呼叫 rand7() 並將結果存至 b // 取得第二個 1~7 的隨機數  \n→ Step 3: 計算 num = (a - 1) * 7 + b // 把兩個 7 面結果映射為 1~49 的整數  \n→ Decision: 若 num > 40? // 檢查是否在可接受的 1~40 範圍內  \n    Yes → Step 4: 重新執行 Step 1-3 // 失敗時重試，產生新的 num  \n    No  → Step 5: 計算 result = ((num - 1) mod 10) + 1 // 把 1~40 轉換為 1~10  \n→ Step 6: 回傳 result // 結束並返回 1~10 的隨機數  \nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0tdr_u17.py\", line 44, in <module>\n    target = int(target_match.group('target'))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: no such group"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfhr8r3td.py\", line 44, in <module>\n    target = int(target_match.group('target'))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: no such group"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe84_8ic9.py\", line 44, in <module>\n    target = int(target_match.group('target'))\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIndexError: no such group"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for end in range(index + 1, len(num) + 1):\n                temp = num[index:end]\n                # Skip numbers with leading zeros\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n\n                if index == 0:\n                    # First number, no operator before it\n                    backtrack(end, temp, curr, curr)\n                else:\n                    # Try multiplication first to match sample order\n                    backtrack(end, path + '*' + temp, value - last + last * curr, last * curr)\n                    backtrack(end, path + '+' + temp, value + curr, curr)\n                    backtrack(end, path + '-' + temp, value - curr, -curr)\n\n        backtrack(0, \"\", 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    num_match = re.search(r'num\\s*=\\s*\"(?P<num>\\d+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not num_match or not target_match:\n        print(\"[]\")\n        sys.exit(0)\n\n    num = num_match.group('num')\n    target = int(target_match.group('target'))\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: add operators between digits to reach target. Use recursive DFS. Steps: Start, Input num, target. Decision? Use recursion: generate expressions. Handle leading zeros. Evaluate with precedence: multiplication before addition/subtraction, can use current result and last operand. Pseudocode typical.\n\nWe output each line as \"虛擬碼步驟 // 解釋\" with arrow etc.\n\nLet's craft steps:\n\nStart\n→ Step 1: 定義結果列表 res // 用於儲存符合目標的表達式\n→ Step 2: 定義遞歸函式 dfs(index, path, evaluated, last) // index: 當前處理位置, path: 當前表達式字符串, evaluated: 當前表達式評估值, last: 最後一個操作數（用於乘法）\n→ Step 3: 判斷 index 是否等於 len(num) // 若已走完所有位\n    Yes → 判斷 evaluated 是否等於 target // 檢查是否達到目標\n        Yes → 將 path 加入 res // 儲存符合的表達式\n        No  → 直接返回 // 不符合\n    No  → 進行迴圈\n→ Step 4: 從 index 開始到 len(num)-1 迭代 end // 形成下一個操作數\n    → Step 5: 取子串 curr_str = num[index:end+1] // 從 index 到 end 的子串\n    → Step 6: 判斷 curr_str 是否以 '0' 開頭且長度>1 // 檢查前導零\n        Yes → 跳過此迴圈 // 前導零不允許\n        No  → 轉為整數 curr = int(curr_str)\n    → Step 7: 如果 index == 0 // 第一個數字\n        → Decision: 直接加入 path\n            Yes → dfs(end+1, curr_str, curr, curr) // 第一個數字，eval=curr, last=curr\n    → Step 8: 否則 // 之後的數字，嘗試 '+', '-', '*'\n        → Decision: 加號\n            Yes → dfs(end+1, path + '+' + curr_str, evaluated + curr, curr)\n        → Decision: 減號\n            Yes → dfs(end+1, path + '-' + curr_str, evaluated - curr, -curr)\n        → Decision: 乘號\n            Yes → dfs(end+1, path + '*' + curr_str, evaluated - last + last * curr, last * curr)\n→ Step 9: 結束遞歸\n→ Step 10: 呼叫 dfs(0, \"\", 0, 0) // 開始遞歸\n→ End // 回傳結果 res\n\nWe need to format each line with arrow and explanation. We must maintain proper indentation for decisions. Use arrow like \"→\". For nested decisions, indent? The example uses indent.\n\nWe should produce each step as a line: \"虛擬碼步驟 // 解釋\". Each decision and branches should be on separate lines, maybe with indentation for branches.\n\nLet's craft.\n\nImportant: Provide each line with appropriate arrow.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果列表 res // 用於儲存符合目標的表達式  \n→ Step 2: 定義遞歸函式 dfs(index, path, evaluated, last) // index: 當前處理位置, path: 當前表達式字串, evaluated: 當前表達式評估值, last: 最後一個操作數（用於乘法）  \n→ Step 3: 判斷 index 是否等於 len(num) // 若已走完所有位  \n  Yes → 判斷 evaluated 是否等於 target // 檢查是否達到目標  \n    Yes → 將 path 加入 res // 儲存符合的表達式  \n    No  → 直接返回 // 不符合  \n  No  → 進行迴圈  \n→ Step 4: 從 index 開始到 len(num)-1 迭代 end // 形成下一個操作數  \n  → Step 5: 取子串 curr_str = num[index:end+1] // 取得從 index 到 end 的子串  \n  → Step 6: 判斷 curr_str 是否以 '0' 開頭且長度>1 // 檢查前導零  \n    Yes → 跳過此迴圈 // 前導零不允許  \n    No  → 轉為整數 curr = int(curr_str)  \n  → Step 7: 如果 index == 0 // 第一個數字  \n    Decision: 直接加入 path  \n     Yes → dfs(end+1, curr_str, curr, curr) // 第一個數字，eval=curr, last=curr  \n  → Step 8: 否則 // 之後的數字，嘗試 '+', '-', '*'\n    Decision: 加號  \n     Yes → dfs(end+1, path + '+' + curr_str, evaluated + curr, curr)  \n    Decision: 減號  \n     Yes → dfs(end+1, path + '-' + curr_str, evaluated - curr, -curr)  \n    Decision: 乘號  \n     Yes → dfs(end+1, path + '*' + curr_str, evaluated - last + last * curr, last * curr)  \n→ Step 9: 結束遞歸  \n→ Step 10: 呼叫 dfs(0, \"\", 0, 0) // 開始遞歸  \nEnd // 程式執行結束，回傳結果列表 res"
    },
    {
      "title": "Super Pow",
      "source_file": "Leetcode/leetcode372.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptid717sw.py\", line 34, in <module>\n    a, b = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptid717sw.py\", line 27, in parse_input\n    b = ast.literal_eval(val)\n        ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpl_sq3qyu.py\", line 34, in <module>\n    a, b = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpl_sq3qyu.py\", line 27, in parse_input\n    b = ast.literal_eval(val)\n        ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nMOD = 1337\n\ndef super_pow(a, b):\n    \"\"\"計算 a^b mod 1337，b 為數位陣列。\"\"\"\n    result = 1\n    for digit in b:\n        result = pow(result, 10, MOD) * pow(a, digit, MOD) % MOD\n    return result\n\ndef parse_input(text):\n    \"\"\"從輸入文字中解析 a 與 b。\"\"\"\n    parts = [p.strip() for p in text.split(',')]\n    a = None\n    b = None\n    for part in parts:\n        if '=' not in part:\n            continue\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        if key == 'a':\n            a = int(val)\n        elif key == 'b':\n            b = ast.literal_eval(val)\n    return a, b\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    a, b = parse_input(data)\n    if a is None or b is None:\n        raise ValueError(\"Invalid input format.\")\n    result = super_pow(a, b)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations for computing a^b mod 1337 where b is big as array of digits. Use modular exponentiation with exponentiation by squaring but handle large exponent via repeated squaring with exponent digits. Use method: convert exponent array to base 10^k? Actually standard approach: treat exponent as array of digits; process from most significant digit: compute result = (result^10 * a^digit) mod 1337. Because exponent given in decimal digits array. So algorithm:\n\nInput a, bDigits array.\n\nresult = 1.\n\nfor each digit d in bDigits:\n    result = powMod(result, 10, 1337) * powMod(a, d, 1337) % 1337\n\nReturn result.\n\nAlso need powMod(x, exp, mod) efficient.\n\nProvide virtual code accordingly.\n\nNeed lines with arrows and decision. No actual code, just virtual steps. Provide explanation after space. We'll create:\n\nStart\n→ Step 1: 讀取 a, bDigits // 取得底數及指數位陣列\n→ Step 2: 設 result = 1 // 初始結果\n→ ForEach d in bDigits: // 處理每一位數\n    → Step 3: result = powMod(result, 10, 1337) * powMod(a, d, 1337) mod 1337 // 更新結果\n→ End // 回傳 result\n\nAlso need to define powMod subroutine steps.\n\nDefine subroutine powMod(base, exp, mod):\n\nStart\n→ Step 4: 設 temp = 1, pow = base mod mod\n→ While exp > 0:\n    → Decision: exp mod 2 == 1?\n        Yes → temp = (temp * pow) mod mod\n        No →\n    → pow = (pow * pow) mod mod\n    → exp = exp // 2\n→ End // 回傳 temp\n\nBut need to produce steps in order.\n\nWe'll embed subroutine call inside main loop.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 a, bDigits // 取得底數及指數的數位陣列\n→ Step 2: 設 result = 1 // 初始結果\n→ Decision: bDigits 是否為空?\n    Yes → End // 若指數為空，直接回傳 1\n    No →\n→ ForEach d in bDigits: // 逐位處理指數\n    → Step 3: temp1 = powMod(result, 10, 1337) // 計算 result^10 mod 1337\n    → Step 4: temp2 = powMod(a, d, 1337) // 計算 a^d mod 1337\n    → Step 5: result = (temp1 * temp2) mod 1337 // 合併結果\n→ End // 程式執行結束，返回 result\n\nThen subroutine powMod(base, exp, mod):\n\nStart // powMod 開始\n→ Step 6: 設 temp = 1\n→ Step 7: pow = base mod mod\n→ Decision: exp > 0?\n    Yes →\n        → While exp > 0:\n            → Decision: exp mod 2 == 1?\n                Yes → temp = (temp * pow) mod mod\n                No →\n            → pow = (pow * pow) mod mod\n            → exp = exp // 2\n        → End While\n        → Return temp\n    No → Return 1\n→ End // powMod 結束\n\nBut we need to present each line sequentially. For loops and while loops need arrow representation.\n\nWe can express loops with → for each line inside.\n\nWe should not output actual code, but virtual steps. Use arrows for each step.\n\nWe need to maintain the formatting. Each line: virtual code step [space] // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 a, bDigits // 取得底數 a 及指數的數位陣列  \n→ Step 2: 設 result = 1 // 初始化結果為 1  \n→ Decision: bDigits 是否為空? // 檢查指數陣列是否為空  \n  Yes → End // 若空則直接回傳 1，程式結束  \n  No →  \n→ ForEach d in bDigits: // 逐位處理指數陣列  \n  → Step 3: temp1 = powMod(result, 10, 1337) // 計算 result^10 (模 1337)  \n  → Step 4: temp2 = powMod(a, d, 1337) // 計算 a^d (模 1337)  \n  → Step 5: result = (temp1 * temp2) mod 1337 // 合併兩部分得到新的結果  \n→ End // 程式執行結束，最終結果為 result  \n\n// ---------------------------- powMod 子程式 ----------------------------\n\nStart // powMod 開始  \n→ Step 6: 設 temp = 1 // 初始乘積  \n→ Step 7: pow = base mod mod // 取餘數後的底數  \n→ Decision: exp > 0? // 若指數為零直接回傳 1  \n  Yes →  \n   → While exp > 0: // 迴圈直到指數為零  \n     → Decision: exp mod 2 == 1? // 判斷目前位是否為 1  \n       Yes → temp = (temp * pow) mod mod // 若為 1，累乘  \n       No →  \n      → pow = (pow * pow) mod mod // 底數平方  \n      → exp = exp // 2 // 指數右移一位  \n    → End While  \n    → Return temp // 返回計算結果  \n  No → Return 1 // 若初始指數為 0，返回 1  \n→ End // powMod 結束\n\nEnd // 整體程式結束，回傳 a^b mod 1337 的結果"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0:\n            return 0\n\n        s1_count = 0   # 已經處理完的 s1 次數\n        s2_count = 0   # 已經匹配到的 s2 次數\n        index = 0      # s2 中目前需要匹配的字元位置\n        recall = dict()  # 記錄每次 index 所對應的 (s1_count, s2_count)\n\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[index]:\n                    index += 1\n                    if index == len(s2):\n                        index = 0\n                        s2_count += 1\n            s1_count += 1\n\n            if index in recall:\n                # 发现循环\n                s1_count_prev, s2_count_prev = recall[index]\n                pre_loop_s1 = s1_count_prev\n                pre_loop_s2 = s2_count_prev\n                loop_s1 = s1_count - s1_count_prev\n                loop_s2 = s2_count - s2_count_prev\n                break\n            else:\n                recall[index] = (s1_count, s2_count)\n        else:\n            # 没有发现循环，直接计算\n            return s2_count // n2\n\n        # 计算前置部分\n        total_s2 = pre_loop_s2\n\n        # 计算可以完整出现的循环次数\n        remaining_s1 = n1 - pre_loop_s1\n        loops = remaining_s1 // loop_s1\n        total_s2 += loops * loop_s2\n\n        # 计算剩余部分\n        rest_s1 = remaining_s1 % loop_s1\n        rest_index = index\n        rest_s2 = 0\n        for _ in range(rest_s1):\n            for ch in s1:\n                if ch == s2[rest_index]:\n                    rest_index += 1\n                    if rest_index == len(s2):\n                        rest_index = 0\n                        rest_s2 += 1\n        total_s2 += rest_s2\n\n        return total_s2 // n2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 提取字串和數字\n    str_vals = re.findall(r'\"([^\"]*)\"', data)\n    num_vals = [int(x) for x in re.findall(r'(\\d+)', data)]\n\n    if len(str_vals) < 2 or len(num_vals) < 2:\n        print(0)\n    else:\n        s1, s2 = str_vals[0], str_vals[1]\n        n1, n2 = num_vals[0], num_vals[1]\n        solution = Solution()\n        result = solution.getMaxRepetitions(s1, n1, s2, n2)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm. Problem is classic Leetcode 466: Maximum Repetitions. Need to produce virtual code step-by-step with explanations. Must be in Traditional Chinese.\n\nWe output each line with virtual code then // explanation. Use Start, End, Decision, arrow. Provide algorithm: precompute mapping of positions to repeats, use cycle detection. Should be generic.\n\nLet's design: Step 1: Input s1, n1, s2, n2. Step 2: compute counts.\n\nPseudo algorithm:\n- If n1==0 or s1==\"\" then return 0.\n- Use two pointers i1 in s1, i2 in s2, counts: s1Count, s2Count.\n- For each iteration, increment s1Count. For each char in s1: if matches s2[i2] then i2++.\n- If i2==len(s2): i2=0; s2Count++.\n- Track seen states of i2: record at which s1Count we saw it, and corresponding s2Count.\n- When a repeated state occurs, we have a loop. Use loop info to compute total s2Count after n1 s1 repeats: prefix before loop, loop part, remaining after loop.\n- Return s2Count // n2.\n\nLet's produce virtual code lines.\n\nWe need to produce each line with arrow etc. Use indentation? Use spaces. Provide arrow for steps.\n\nWe'll structure:\n\nStart\n→ Step 1: 初始化變數 s1, n1, s2, n2, 以及 length變數 L1, L2\n→ Step 2: 若 n1 為 0 或 s1 為空，回傳 0\n→ Step 3: 初始化 i1 = 0, i2 = 0, s1Count = 0, s2Count = 0\n→ Step 4: 建立空字典 record\n→ Decision: 若 s1Count < n1? etc\n\nBut better to use while loop. Let's produce pseudo:\n\n→ While s1Count < n1\n    → For each char in s1\n        → 如果 char == s2[i2] 则 i2++ \n        → 如果 i2 == L2\n            → i2 = 0\n            → s2Count++ \n    → s1Count++ \n    → Decision: 若 record 存在 i2?\n        → Yes → ... handle cycle \n        → No → record[i2] = (s1Count, s2Count)\n\nThen compute result after loop.\n\nWe must produce a single linear virtual code with decisions etc. Use arrow for each step.\n\nLet's craft.\n\nAlso we must output in Traditional Chinese explanations.\n\nLet's produce.\n\nAlso we must output each line exactly with virtual code then // explanation.\n\nWe'll use syntax like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入 s1, n1, s2, n2 // 讀取使用者輸入\n→ Step 2: 計算 L1 = s1.length, L2 = s2.length // 字串長度\n→ Decision: 若 n1 == 0 或 L1 == 0? // 檢查是否有可重複的字串\n    Yes → Return 0 // 直接回傳 0\n    No  → // 繼續\n\nBut we must use return? But we just produce pseudo. We'll produce comment.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 取得輸入 s1, n1, s2, n2 // 讀取使用者輸入\n→ Step 2: 計算 L1 = s1.length, L2 = s2.length // 取得兩個字串的長度\n→ Decision: 若 n1 == 0 或 L1 == 0? // 若無可重複的字串\n    Yes → Step 3a: 回傳 0 // 最大可取得的 m 為 0\n    No  → // 繼續執行後續步驟\n→ Step 3b: 初始化 i1 = 0, i2 = 0, s1Count = 0, s2Count = 0 // 索引與計數器\n→ Step 4: 建立空字典 record // 用於偵測重複的 i2 狀態\n→ Decision: 是否已完成 n1 次 s1 的迭代? // 循環條件\n    No  → // 進入主迴圈\n        → Step 5: s1Count++ // 進行一次 s1 的完整迭代\n        → For i1 取 0 到 L1-1  // 遍歷 s1 的每個字元\n            → Step 5a: 若 s1[i1] == s2[i2]? // 檢查是否能匹配 s2 的當前位置\n                Yes → i2++ // 匹配成功，移至 s2 的下一個字元\n                No  → // 不匹配，繼續檢查下一個字元\n            → Decision: i2 == L2? // 是否已完整匹配一個 s2\n                Yes → i2 = 0, s2Count++ // 完成一次 s2，重置 i2 並計數\n                No  → // 繼續迴圈\n        → Decision: record 包含 i2? // 檢查是否遇到重複的 i2 狀態\n            Yes → // 偵測到循環，進行快速計算\n                → Step 6: 取得前一個 s1Count 和 s2Count (prevCount, prevS2)\n                → Step 7: 計算 loopSize = s1Count - prevCount // 循環長度\n                → Step 8: 計算 loopScore = s2Count - prevS2 // 循環中 s2 的數量\n                → Step 9: 計算 remaining = n1 - s1Count // 還剩多少次 s1 需要迭代\n                → Step 10: 加上前面已完成的 s2Count // 從 prevS2 加回\n                → Step 11: 取得完整循環數目 loops = remaining / loopSize\n                → Step 12: s2Count += loops * loopScore // 每個循環對 s2 的貢獻\n                → Step 13: 剩餘部分 rem = remaining % loopSize\n                → Step 14: 重新執行 s1Count 從 0 到 rem 次\n                    → For each remaining i1 在 0 到 L1-1\n                        → 同步 Step 5a 的匹配邏輯\n                    → 每次完成 s1 後 s1Count++\n                → Step 15: 迴圈結束，跳出主迴圈\n            No  → record[i2] = (s1Count, s2Count) // 記錄當前狀態以供後續偵測\n    Yes → // 已完成所有 n1 次 s1 的迭代，結束主迴圈\n→ Step 16: 計算 m = s2Count / n2 // 取整得到可完整重複的 s2 數量\n→ Step 17: 回傳 m // 結果輸出\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpefukl7tw.py\", line 102, in <module>\n    main()\n  File \"/tmp/tmpefukl7tw.py\", line 75, in main\n    commands, arguments = parse_input(data.strip())\n                          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpefukl7tw.py\", line 67, in parse_input\n    args = ast.literal_eval(f'[{args_raw}]')\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\nfrom collections import deque\nimport ast\n\nclass MyStack:\n    \"\"\"\n    使用兩個 queue (deque) 實作 LIFO stack。\n    \"\"\"\n    def __init__(self):\n        # q1 為主隊列，q2 為輔助隊列\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        把元素 x 放入堆疊頂部。\n        將元素加入主隊列後，將除了新進元素之外的所有元素\n        轉移到輔助隊列，最後再把輔助隊列的內容回傳給主隊列。\n        \"\"\"\n        self.q1.append(x)                # 先把新元素加到主隊列\n        # 把主隊列中除了新元素之外的元素，依順序移到輔助隊列\n        for _ in range(len(self.q1) - 1):\n            self.q2.append(self.q1.popleft())\n        # 再把輔助隊列的內容搬回主隊列，完成 push\n        while self.q2:\n            self.q1.append(self.q2.popleft())\n\n    def pop(self) -> int:\n        \"\"\"\n        移除並回傳堆疊頂部元素。\n        \"\"\"\n        return self.q1.popleft()\n\n    def top(self) -> int:\n        \"\"\"\n        回傳堆疊頂部元素，但不移除。\n        \"\"\"\n        # 直接從主隊列的左端讀取\n        return self.q1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        判斷堆疊是否為空。\n        \"\"\"\n        return len(self.q1) == 0\n\n\ndef parse_input(input_text: str):\n    \"\"\"\n    解析形如\n        [\"MyStack\", \"push\", ...], [[], [1], ...]\n    的輸入字串，回傳兩個 list。\n    \"\"\"\n    # 去除可能的前置文字\n    if input_text.startswith(\"Input\"):\n        input_text = input_text[len(\"Input\"):].strip()\n    # 找到兩個 list 的分隔\n    pattern = re.compile(r'\\[(.*?)\\],\\s*\\[(.*?)\\]', re.DOTALL)\n    m = pattern.search(input_text)\n    if not m:\n        raise ValueError(\"Invalid input format\")\n    cmds_raw, args_raw = m.group(1), m.group(2)\n    # 將 raw 文字包回中括號後使用 literal_eval 轉成 list\n    cmds = ast.literal_eval(f'[{cmds_raw}]')\n    args = ast.literal_eval(f'[{args_raw}]')\n    return cmds, args\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    commands, arguments = parse_input(data.strip())\n\n    stack = None\n    outputs = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MyStack\":\n            stack = MyStack()\n            outputs.append(None)   # 只為了保持輸出長度一致\n        elif cmd == \"push\":\n            stack.push(arg[0])\n            outputs.append(None)\n        elif cmd == \"pop\":\n            outputs.append(stack.pop())\n        elif cmd == \"top\":\n            outputs.append(stack.top())\n        elif cmd == \"empty\":\n            outputs.append(stack.empty())\n        else:\n            # 若有未知指令，忽略\n            outputs.append(None)\n\n    # 使用 json.dumps 讓 None -> null，True/False -> true/false\n    print(json.dumps(outputs))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step. The requirement: implement a stack using two queues. Provide virtual code for class MyStack with methods push, pop, top, empty. Use queue operations only. We should produce pseudo-code with Start/End etc. Provide explanation after each line.\n\nWe need to use virtual code syntax: Start, →, Decision, etc. Each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow and structure. Should be line-by-line.\n\nLet's design algorithm: Use two queues q1, q2. For push: push to q1. For pop: while q1 size > 1, pop from q1 and enqueue to q2; then pop last element from q1 (the top). Swap q1 and q2. For top: similar but instead of removing, just peek and re-enqueue. Or we can maintain top value but that's not allowed? We'll use same as pop but not remove: transfer all but last, peek last, enqueue to q2, swap. For empty: check q1 is empty. We'll produce pseudocode.\n\nWe need to produce virtual code lines. Possibly structure: Start, → Step: define MyStack class, create q1 and q2. Then methods.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 MyStack 類別 // 定義 MyStack\n    → Step 2: 建立兩個空隊列 q1, q2 // 用來模擬堆疊\nEnd // 初始化結束\n\nBut we need separate methods. We'll structure each method with decision points.\n\nLet's produce full pseudocode:\n\nStart // 程式開始\n→ Step 1: 定義類別 MyStack // 創建堆疊類別\n    → Step 2: 宣告兩個 queue 變數 q1, q2 // 用於存放元素\nEnd // 類別結構完成\n\nThen define push:\n\n→ Method: push(x) // 將 x 推入堆疊\n    → Step 3: q1.enqueue(x) // 將元素加入 q1\nEnd\n\nPop:\n\n→ Method: pop() // 移除並返回堆疊頂部元素\n    → Decision: q1.isEmpty()? // 判斷是否有元素\n        Yes → Return null // 或拋例外\n        No  → Step 4: While q1.size() > 1\n                → Step 5: temp = q1.dequeue() // 取出前端\n                → Step 6: q2.enqueue(temp) // 放入 q2\n        → Step 7: topElement = q1.dequeue() // 最後一個即頂部\n        → Step 8: Swap q1 and q2 // 讓 q1 成為新的主隊列\n        → Return topElement\nEnd\n\nTop: similar but don't discard last:\n\n→ Method: top() // 回傳堆疊頂部元素\n    → Decision: q1.isEmpty()?\n        Yes → Return null\n        No  → Step 9: While q1.size() > 1\n                → Step 10: temp = q1.dequeue()\n                → Step 11: q2.enqueue(temp)\n        → Step 12: topElement = q1.dequeue()\n        → Step 13: q2.enqueue(topElement) // 重新放回\n        → Step 14: Swap q1 and q2\n        → Return topElement\nEnd\n\nEmpty:\n\n→ Method: empty() // 檢查是否為空\n    → Decision: q1.isEmpty()?\n        Yes → Return true\n        No  → Return false\nEnd\n\nFinally End of program.\n\nBut we need each line separate, with arrow and explanation.\n\nAlso include decision lines with Yes → / No →.\n\nWe should ensure format: each line: virtual code step + space + // explanation.\n\nWe can use indentation for nested steps: we can indent lines after Decision: but not necessary.\n\nBut we need to produce a clear structure.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義 MyStack 類別 // 創建堆疊類別\n    → Step 2: 宣告兩個 queue 變數 q1, q2 // 用於模擬堆疊\nEnd // 類別初始化結束\n\nThen methods.\n\nBut we need to show each method as separate Start? Actually each method can be separate block. Use \"Method: push(x)\" etc.\n\nLet's produce:\n\n→ Method: push(x) // 將 x 推入堆疊\n    → Step 3: q1.enqueue(x) // 將元素加入 q1\nEnd\n\nSimilar.\n\nLet's produce all.\n\nLet's ensure we use proper arrow characters.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 定義 MyStack 類別 // 創建堆疊類別\n    → Step 2: 宣告兩個 queue 變數 q1, q2 // 用於模擬堆疊\n\nEnd // MyStack 類別結束\n\n→ Method: push(x) // 將 x 推入堆疊\n    → Step 3: q1.enqueue(x) // 把元素放入主隊列\nEnd\n\n→ Method: pop() // 移除並返回堆疊頂部元素\n    → Decision: q1.isEmpty()? // 判斷堆疊是否為空\n        Yes → Return null // 空時回傳 null（或拋例外）\n        No  → Step 4: While q1.size() > 1 // 移動除最後一個以外的所有元素\n                → Step 5: temp = q1.dequeue() // 取出隊列前端\n                → Step 6: q2.enqueue(temp) // 放入輔助隊列\n        → Step 7: topElement = q1.dequeue() // 取出最後一個即為頂部\n        → Step 8: Swap q1 and q2 // 讓 q1 成為新的主隊列\n        → Return topElement // 回傳被移除的頂部元素\nEnd\n\n→ Method: top() // 回傳堆疊頂部元素（不移除）\n    → Decision: q1.isEmpty()?\n        Yes → Return null // 空時回傳 null（或拋例外）\n        No  → Step 9: While q1.size() > 1 // 移動除最後一個以外的所有元素\n                → Step 10: temp = q1.dequeue()\n                → Step 11: q2.enqueue(temp)\n        → Step 12: topElement = q1.dequeue() // 取得頂部元素\n        → Step 13: q2.enqueue(topElement) // 再放回輔助隊列\n        → Step 14: Swap q1 and q2 // 讓 q1 成為新的主隊列\n        → Return topElement // 回傳頂部元素\nEnd\n\n→ Method: empty() // 檢查堆疊是否為空\n    → Decision: q1.isEmpty()?\n        Yes → Return true // 堆疊空\n        No  → Return false // 堆疊非空\nEnd\n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites: list[list[int]]) -> list[int]:\n        \"\"\"使用 Kahn 演算法進行拓樸排序\"\"\"\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 先把所有入度為 0 的節點加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若有循環，無法完成所有課程\n        return order if len(order) == numCourses else []\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        return\n\n    # 取得 numCourses\n    m_num = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(m_num.group(1)) if m_num else 0\n\n    # 取得 prerequisites，若不存在則視為空列表\n    m_pre = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data)\n    prerequisites = eval(m_pre.group(1)) if m_pre else []\n\n    result = Solution().findOrder(numCourses, prerequisites)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for algorithm: topological sort (Kahn's algorithm or DFS). Provide steps line by line with explanations. Use Start, Decision, End. Use arrow →. Ensure each line: \"虛擬碼步驟 // 解釋\". Provide the algorithm. Use lines for building graph, indegree, queue, etc. Provide multiple steps. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立圖 adjacency list 與 indegree 陣列，size = numCourses // 為每門課建立鄰接表與入度計數器  \n→ Step 2: 對每個 pair (a, b) in prerequisites  \n  → Step 2a: adjacency[b].append(a) // b 為前置課，a 需要先修  \n  → Step 2b: indegree[a] += 1 // a 的入度增加  \n→ Step 3: 建立 queue 及 results list // 用於 Kahn 演算法  \n  → Step 3a: 對 i in 0..numCourses-1  \n    → Decision: 如果 indegree[i] == 0? // 無前置課  \n      Yes → queue.append(i) // 將 i 加入可修課程  \n      No → 不做任何事  \n→ Step 4: 進行拓樸排序  \n  → Decision: 如果 queue 為空? // 無可修課程  \n    No → End // 所有課已處理完畢  \n    Yes → Step 4a: course = queue.pop_front() // 取出可修課程  \n      → results.append(course) // 加入順序  \n      → 對 neighbour in adjacency[course]  \n       → indegree[neighbour] -= 1 // 解除前置課的依賴  \n        → Decision: 如果 indegree[neighbour] == 0? // 現在無前置課  \n          Yes → queue.append(neighbour) // 可以修 neighbour  \n          No → 不做任何事  \n      → 回到 Step 4  \n→ Step 5: Decision: 如果 len(results) == numCourses? // 所有課都已排好順序  \n   Yes → Return results // 成功得到課程順序  \n   No → Return [] // 存在循環，無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Integer to English Words",
      "source_file": "Leetcode/leetcode273.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'TwelveThousandThreeHundredFortyFive'\nGot (Norm):      'OneMillionTwoThousandThreeHundredFortyFive'\n--- (Raw) ---\nRaw Expected: '\"Twelve Thousand Three Hundred Forty Five\"'\nRaw Got:      '\"One Million Two Thousand Three Hundred Forty Five\"'"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'OneMillionTwoHundredThirtyFourThousandFiveHundredSixtySeven'\nGot (Norm):      'OneHundredTwentyThreeMillionFourThousandFiveHundredSixtySeven'\n--- (Raw) ---\nRaw Expected: '\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"'\nRaw Got:      '\"One Hundred Twenty Three Million Four Thousand Five Hundred Sixty Seven\"'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            switcher = [\"\", \"One\", \"Two\", \"Three\", \"Four\",\n                        \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n            return switcher[n]\n\n        def two_less_20(n: int) -> str:\n            switcher = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\",\n                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return switcher[n - 10]\n\n        def ten(n: int) -> str:\n            switcher = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\",\n                        \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return switcher[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            elif n < 10:\n                return one(n)\n            elif n < 20:\n                return two_less_20(n)\n            else:\n                t = n // 10\n                r = n % 10\n                return ten(t) + (\" \" + one(r) if r != 0 else \"\")\n\n        def three(n: int) -> str:\n            h = n // 100\n            r = n % 100\n            if h != 0 and r != 0:\n                return one(h) + \" Hundred \" + two(r)\n            elif h == 0 and r != 0:\n                return two(r)\n            elif h != 0 and r == 0:\n                return one(h) + \" Hundred\"\n            else:\n                return \"\"\n\n        billion = num // 1_000_000_000\n        million = (num - billion * 1_000_000_000) // 1_000_0\n        thousand = (num - billion * 1_000_000_000 - million * 1_000_0) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion != 0:\n            parts.append(three(billion) + \" Billion\")\n        if million != 0:\n            parts.append(three(million) + \" Million\")\n        if thousand != 0:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest != 0:\n            parts.append(three(rest))\n\n        return \" \".join(parts)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r\"-?\\d+\", data)\n    num = int(match.group()) if match else 0\n    sol = Solution()\n    result = sol.numberToWords(num)\n    # Output with surrounding double quotes as per examples\n    print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining converting integer to English words. Steps: handle zero, arrays of ones, tens, thousands, loop dividing by 1000, process each chunk. Provide steps and explanations. Use Start, End, Decision, etc. Each line format: \"虛擬碼步驟 // 解釋\". Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 num 為 0? // 檢查輸入是否為 0  \n  Yes → Step 1: 輸出 'Zero' // 直接輸出 \"Zero\"  \n  No → Step 2: 定義詞典 // 建立單字、十位、百位及千級詞典  \n    // words_1: 1-19, words_10: 20,30,...,90, thousands: Thousand, Million, Billion  \n→ Step 3: 初始化 result 為空串 // 用於累積最終英文表達  \n→ Step 4: 設定 index = 0 // 用於追蹤千級詞的位置  \n→ Decision: while num > 0? // 只要還有數字未處理  \n  Yes → Step 5: segment = num mod 1000 // 取得最低三位數  \n    → Decision: 如果 segment 為 0? // 若此段為 0，直接跳過  \n      Yes → Step 6: num = num / 1000 // 移除已處理的三位數  \n      No → Step 7: segment_words = ConvertSegment(segment) // 將三位數轉成英文  \n        // ConvertSegment 內部會處理百位、十位、單位  \n        → Step 8: 如果 result 為空串? // 判斷是否為第一段  \n         Yes → result = segment_words // 直接設置結果  \n         No → result = segment_words + ' ' + thousands[index] + ' ' + result // 加上千級詞並拼接  \n       → Step 9: num = num / 1000 // 移除已處理的三位數  \n       → Step 10: index = index + 1 // 進入下一千級  \n  No → Step 11: 清除多餘空格 // 確保結果格式正確  \n→ Step 12: 輸出 result // 顯示最終英文表達  \nEnd // 程式執行結束  \n\n// ConvertSegment 虛擬碼（單獨說明）  \n→ Step A1: 定義 segResult 為空串  \n→ Step A2: 如果 segment >= 100? // 處理百位  \n  Yes → segResult = words_1[segment / 100] + ' Hundred'  \n  No → segResult = ''  \n→ Step A3: segment = segment mod 100 // 取剩餘兩位  \n→ Step A4: 如果 segment >= 20? // 處理十位以上  \n  Yes → segResult += ' ' + words_10[(segment / 10) * 10]  \n    segment = segment mod 10 // 取單位  \n  No → If segment > 0? // 直接使用 1-19 的詞典  \n    Yes → segResult += ' ' + words_1[segment]  \n    No → segResult += ''  \n→ Step A5: 返回 segResult.trim() // 去除前後空格并返回\n\n（以上虛擬碼列出了主要流程與每一步的簡短說明。）"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS: find the shortest distance and build parent links\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        # DFS to build all shortest paths\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    assignments = {}\n    # Parse assignments like: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]\n    try:\n        module = ast.parse(data)\n        for node in module.body:\n            if isinstance(node, ast.Assign) and len(node.targets) == 1:\n                var = node.targets[0].id\n                assignments[var] = ast.literal_eval(node.value)\n    except Exception:\n        # Fallback: treat the entire input as a single Python expression\n        try:\n            assignments = eval(data, {})\n        except Exception:\n            assignments = {}\n\n    beginWord = assignments.get('beginWord', '')\n    endWord = assignments.get('endWord', '')\n    wordList = assignments.get('wordList', [])\n\n    solution = Solution()\n    output = solution.findLadders(beginWord, endWord, wordList)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving word ladder II: find all shortest transformation sequences. Need to output virtual code steps line by line with comments.\n\nWe need to produce a high-level algorithm: BFS to find shortest path lengths, then DFS/backtracking to construct all paths. Steps: build adjacency using generic forms, BFS from beginWord to endWord building distance map and adjacency map. Then DFS to build paths using adjacency, only following edges that go to next level. Output list of lists.\n\nWe need to follow format: \"虛擬碼步驟 // 解釋\" each line.\n\nUse arrows and Decision, Start, End.\n\nLet's create step by step:\n\nStart // 程式開始執行\n→ Decision: 如果 endWord 不在 wordList? // 檢查是否能達成\n    Yes → Step: 返回空列表 // 無法達成\n    No  → Step: 建立 wordSet 包含 wordList 和 beginWord // 建立字典集合\n→ Step: 建立 map genericWord -> words 列表 // 生成通用字典\n→ Step: 建立空距離 dict distance // 用於 BFS\n→ Step: 初始化 queue, distance[beginWord]=0 // BFS 開始\n→ Decision: queue 不是空? // BFS 循環\n    Yes → Step: Dequeue current\n    → Step: For每一個位置 i in current\n        → Step: 生成通用字 generic\n        → Step: For每個候選 word 在 map[generic]\n            → Decision: distance 未設定? // 未訪問\n                Yes → Step: 設置 distance[word] = distance[current] +1\n                → Step: Enqueue word\n                → Decision: word == endWord? // 到達終點\n                    Yes → Step: 設置 found=true // 找到最短層\n    → Decision: found? // 找到最短層後停止 BFS\n        Yes → Step: 跳出 BFS 迴圈\n        No  → Continue\n→ Step: 建立 adjacency dict adj for words in distance // 還是建立 edges from word to next level\n→ Decision: distance 包含 endWord? // 仍有路徑\n    Yes → Step: 建立結果列表 results\n    → Step: 定義遞迴 DFS(current, path)\n        → Decision: current == endWord? // 完成路徑\n            Yes → Step: 把 path 加到 results\n            No  → Step: For每個 next 在 adj[current]\n                → Step: DFS(next, path + [next])\n→ Step: 調用 DFS(beginWord, [beginWord])\n→ Step: 返回 results\nEnd // 程式結束\n\nBut we need to use arrows: \"→\" for step, \"Decision:\" lines.\n\nLet's produce more formal lines:\n\nWe need each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce like:\n\nStart // 程式開始執行\n\n→ Decision: endWord 是否在 wordList? // 確認是否能到達\n\n    Yes → Step: 返回 [] // 沒有路徑\n\n    No  → Step: wordSet ← wordList ∪ {beginWord} // 包含開始字\n\n→ Step: genericMap ← 空映射 // 建立通用字典\n\n→ Decision: 遍歷 wordSet 的每個單字 word // 生成通用字\n\n    → Step: 生成所有通用字 generic（用 '*' 取代一個字母） // 例如 'h*t'\n\n    → Decision: genericMap 內無 generic? // 初始\n        Yes → Step: genericMap[generic] ← [word]\n        No  → Step: genericMap[generic].append(word)\n\n→ Step: distance ← 空字典 // 記錄每個字到 beginWord 的距離\n\n→ Step: queue ← [beginWord] // BFS 緩衝\n\n→ Step: distance[beginWord] ← 0 // 起始距離\n\n→ Step: found ← False // 是否找到 endWord\n\n→ Decision: queue 不為空? // BFS 主循環\n\n    Yes → Step: current ← queue.pop(0)\n\n    → Step: For i in 0..len(current)-1\n\n        → Step: generic ← current with '*' 替換第 i 位\n\n        → Decision: genericMap 內有 generic? // 有候選字\n\n            Yes → Step: For each neighbor in genericMap[generic]\n\n                → Decision: neighbor not in distance? // 未訪問\n\n                    Yes → Step: distance[neighbor] ← distance[current] + 1\n\n                    → Step: queue.append(neighbor)\n\n                    → Decision: neighbor == endWord? // 到達終點\n\n                        Yes → Step: found ← True\n\n    → Decision: found? // 找到最短層後停止\n\n        Yes → Step: 跳出 BFS\n\n        No  → Continue\n\n→ Decision: endWord 是否在 distance? // 仍有路徑\n\n    Yes → Step: adj ← 空字典 // 邊集合\n\n    → Decision: distance.keys() 循環 word\n\n        → Step: For i in 0..len(word)-1\n\n            → Step: generic ← word 替換第 i 位 '*'\n\n            → Decision: genericMap 有 generic? // 產生鄰居\n\n                Yes → Step: For each neighbor in genericMap[generic]\n\n                    → Decision: distance.get(neighbor) == distance[word]+1? // 下一層\n\n                        Yes → Step: adj[word].append(neighbor)\n\n    → Step: results ← []\n\n    → Step: 定義 DFS(current, path)\n\n        → Decision: current == endWord? // 完成路徑\n\n            Yes → Step: results.append(path) // 將路徑加入結果\n\n            No  → Step: For each next in adj[current]\n\n                → Step: DFS(next, path + [next])\n\n    → Step: DFS(beginWord, [beginWord])\n\n    → Step: 返回 results\n\n    → End // 完成\n\n    No → Step: 返回 [] // 無路徑\n\nEnd // 程式結束\n\nWe need to make sure each line ends with // 解釋. The above has some lines with multiple commands; maybe need to split into separate lines. Also maintain indentation? It's okay.\n\nWe need to follow the format exactly: each line \"虛擬碼步驟 // 解釋\". Use arrows and decisions.\n\nLet's craft final answer accordingly. Ensure each line starts with \"Start\" or \"→\" or \"Decision:\" or \"End\". For decisions, we need indent lines? The format example shows indented lines with Yes → ... etc. So we can replicate similar structure.\n\nWe'll produce something like:\n\n```\nStart // 程式開始執行\n→ Decision: endWord 是否在 wordList? // 確認是否能到達\n    Yes → Step: 返回 [] // 沒有路徑\n    No  → Step: wordSet ← wordList ∪ {beginWord} // 包含開始字\n→ Step: genericMap ← 空映射 // 建立通用字典\n→ Decision: 遍歷 wordSet 的每個單字 word // 生成通用字\n    → Step: 生成所有通用字 generic（用 '*' 取代一個字母） // 例如 'h*t'\n    → Decision: genericMap 內無 generic? // 初始\n        Yes → Step: genericMap[generic] ← [word]\n        No  → Step: genericMap[generic].append(word)\n...\n```\n\nBut maybe it's too detailed. We'll keep to main steps; still need clarity.\n\nThe instruction says \"逐行產生對應的虛擬碼\" but we can group logical lines; but must keep each step separate.\n\nLet's craft final answer with enough detail but not too granular. Let's produce around 40-50 lines. Ensure format.\n\nProceed to final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: endWord 是否在 wordList? // 確認是否能到達  \n Yes → Step: 返回 [] // 無法到達，直接結束  \n No  → Step: wordSet ← wordList ∪ {beginWord} // 建立字典集合，包含起始字  \n\n→ Step: genericMap ← 空映射 // 用於存放通用形式與單字對應關係  \n\n→ Decision: 遍歷 wordSet 的每個單字 word // 為每個單字生成通用形式  \n → Step: 生成所有通用字 generic（用 '*' 取代單字的每個位置）  \n → Decision: genericMap 內無 generic? // 是否首次遇到此通用形式  \n  Yes → Step: genericMap[generic] ← [word] // 建立新列表  \n  No  → Step: genericMap[generic].append(word) // 加入現有列表  \n\n→ Step: distance ← 空字典 // 記錄每個單字到 beginWord 的最短距離  \n\n→ Step: queue ← [beginWord] // BFS 待處理隊列  \n\n→ Step: distance[beginWord] ← 0 // 起始距離為 0  \n\n→ Step: found ← False // 標記是否已找到 endWord  \n\n→ Decision: queue 不為空? // BFS 主循環  \n Yes → Step: current ← queue.pop(0) // 取出隊首元素  \n  → Step: For i in 0 .. len(current)-1  \n   → Step: generic ← current 的第 i 個字母替換為 '*'  \n   → Decision: genericMap 內有 generic? // 是否存在候選字  \n    Yes → Step: For each neighbor in genericMap[generic]  \n     → Decision: neighbor 未在 distance? // 未訪問過  \n      Yes → Step: distance[neighbor] ← distance[current] + 1 // 設置距離  \n       → Step: queue.append(neighbor) // 加入隊列  \n       → Decision: neighbor == endWord? // 到達終點  \n        Yes → Step: found ← True // 標記已找到最短層  \n        No → Step: 省略  \n     → 省略  \n  → 省略  \n → Decision: found? // 找到最短層後停止 BFS  \n  Yes → Step: 跳出 BFS 循環  \n  No  → 省略  \n\n→ Decision: endWord 是否在 distance? // 是否存在可達路徑  \n Yes → Step: adj ← 空映射 // 建立鄰接表，只包含走向下一層的邊  \n  → Decision: distance.keys() 遍歷每個 word  \n   → Step: For i in 0 .. len(word)-1  \n    → Step: generic ← word 的第 i 個字母替換為 '*'  \n    → Decision: genericMap 有 generic?  \n     Yes → Step: For each neighbor in genericMap[generic]  \n      → Decision: distance.get(neighbor) == distance[word] + 1? // 下一層  \n       Yes → Step: adj[word].append(neighbor) // 加入鄰接表  \n       No  → Step: 省略  \n     → 省略  \n    → 省略  \n → Step: results ← [] // 儲存所有最短路徑  \n → Step: 定義 DFS(current, path) // 回溯尋找所有路徑  \n  → Decision: current == endWord? // 完成一條路徑  \n   Yes → Step: results.append(path) // 加入結果  \n   No  → Step: For each next in adj[current]  \n    → Step: DFS(next, path + [next]) // 繼續遞迴  \n → Step: DFS(beginWord, [beginWord]) // 開始回溯  \n → Step: 返回 results // 回傳所有最短轉換序列  \n\n No → Step: 返回 [] // 無可達路徑  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.11454500248412157,-0.9608390116854163],[-0.7327005108632211,0.6166809974044489],[-0.4775369457089236,0.8711598164502341]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.11454500248412157, -0.9608390116854163], [-0.7327005108632211, 0.6166809974044489], [-0.4775369457089236, 0.8711598164502341]]'"
        }
      ],
      "generated_code": "import sys, json, random, math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    ops = json.loads(data[0])\n    args = json.loads(data[1]) if len(data) > 1 else []\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            result.append(None)\n        elif op == \"randPoint\":\n            result.append(obj.randPoint())\n        else:\n            # ignore unknown\n            result.append(None)\n    sys.stdout.write(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating uniform random point inside circle. Must be line by line, with arrow etc. No actual code, just pseudo. Provide explanation. Use Start, End, Decision, etc. We'll design steps:\n\nStart\n→ Step 1: 初始化半徑radius、x_center、y_center // store values\n→ Step 2: 生成均勻隨機角θ (0,2π) // random angle\n→ Step 3: 生成均勻隨機半徑r' = sqrt(rand())*radius // to ensure uniform distribution in circle\n→ Step 4: 計算點座標x = x_center + r' * cos(θ) // x coordinate\n→ Step 5: 計算點座標y = y_center + r' * sin(θ) // y coordinate\n→ Step 6: 返回 [x, y] // output array\n\nWe also need Decision? The function does not have decisions, just generate random. But we can include a decision for random? Not needed. But can show step for generating random and checking if within circle? Since using sqrt ensures uniform.\n\nWe should include the constructor and method. Represent as:\n\n→ Step 1: 定義類別 Solution // define class\n→ Step 2: Start Constructor: Solution(radius, x_center, y_center) // store\n→ Step 3: End Constructor // finish init\n→ Step 4: Start Method randPoint() // define method\n→ Step 5: 隨機產生θ // random angle\n→ Step 6: 隨機產生u ∈ [0,1] // uniform\n→ Step 7: 計算 r = sqrt(u) * radius // scale radius\n→ Step 8: 計算 x = x_center + r * cosθ // compute x\n→ Step 9: 計算 y = y_center + r * sinθ // compute y\n→ Step 10: 返回 [x, y] // output\n→ End Method // finish\nEnd // finished.\n\nAdd explanation comments.\n\nNeed arrow: \"→\" between steps.\n\nWe need to use \"Start\" \"End\" \"Decision:\" but no decision needed. Could still show no decision.\n\nWe'll format each line as \"虛擬碼步驟 // 解釋\".\n\nExample: \"Start // 程式開始執行\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 宣告要實作的類別  \n→ Step 2: Start Constructor: Solution(radius, x_center, y_center) // 建構子開始  \n→ Step 3: 變數 radius ← radius // 儲存半徑  \n→ Step 4: 變數 x_center ← x_center // 儲存中心 x 座標  \n→ Step 5: 變數 y_center ← y_center // 儲存中心 y 座標  \n→ Step 6: End Constructor // 建構子結束，物件已初始化  \n→ Step 7: Start Method randPoint() // 定義生成隨機點的方法  \n→ Step 8: 生成隨機角 θ ∈ [0, 2π) // 使用均勻分布得到角度  \n→ Step 9: 生成隨機數 u ∈ [0, 1) // 均勻分布的隨機數  \n→ Step 10: 計算 r ← √u * radius // 透過平方根調整半徑以確保均勻分布  \n→ Step 11: 計算 x ← x_center + r * cos(θ) // 轉換為 Cartesian 坐標  \n→ Step 12: 計算 y ← y_center + r * sin(θ) // 轉換為 Cartesian 坐標  \n→ Step 13: 返回 [x, y] // 產生的隨機點作為陣列輸出  \n→ End Method // randPoint 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，並返回非 val 元素的個數 k。\n        原地修改 nums，將前 k 個位置設為非 val 元素，後續元素不重要。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    \"\"\"\n    讀取 stdin 內容，格式類似：\n        nums = [3,2,2,3], val = 3\n    解析 nums 與 val，執行 removeElement，並輸出結果：\n        k, nums = [<k 個有效元素>, _, _, ...]\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 解析 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    # 解析 val 整數\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not val_match:\n        return\n\n    # 使用 eval 解析列表，安全性依賴於輸入格式\n    nums = eval(nums_match.group(1))\n    val = int(val_match.group(1))\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 產生輸出：前 k 個元素實際值，後續以 '_' 占位\n    output_elements = [str(x) for x in nums[:k]] + ['_'] * (len(nums) - k)\n    print(f\"{k}, nums = [{','.join(output_elements)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem remove element from array in-place, returning k. Provide line by line with explanation. Must follow format with Start, →, Decision etc. Must use arrow symbols. Provide each line with // explanation. Use virtual code steps: Start, set two pointers? Usually algorithm: i=0, iterate j over array, if nums[j] != val, set nums[i]=nums[j]; i++; return i. So produce virtual code. Use \"→\" lines, decisions. Keep each step. Use Decision: if element equals val? Actually we need to copy when not equal. Provide explanation.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize pointer i to 0 // i will track position of next non-val element\n→ Step 2: For each index j from 0 to length-1 // iterate through array\n    → Decision: If nums[j] equals val? // check if current element should be removed\n        Yes → Step 3: Continue // skip this element\n        No  → Step 4: nums[i] ← nums[j] // store non-val element at i\n              → Step 5: i ← i + 1 // move i forward\n→ End // return i as count of non-val elements\n\nBut we need to use arrow notation for loop? Could do: → Step 2: For j in 0 to nums.length-1 // iterate indices\n\nWe need to show step within loop maybe use indentation. Provide proper syntax.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化指標 i 為 0 // i 用來記錄下個非 val 元素應該寫入的位置  \n→ Step 2: 循環遍歷 j 從 0 到 nums.length-1 // j 用來檢查每個元素  \n    → Decision: 如果 nums[j] 等於 val? // 判斷此元素是否需要被移除  \n        Yes → Step 3: 直接跳過該元素 // val 的值不複製，保持 i 不變  \n        No  → Step 4: 將 nums[j] 複製到 nums[i] // 把非 val 元素放到前面  \n              → Step 5: i ← i + 1 // 移動寫入指標到下一個位置  \n→ End // 回傳 i，表示前 i 個元素都是非 val，且 i 為移除後的長度  \n\n這樣即可完成「移除指定值並返回新長度」的虛擬程式流程。"
    },
    {
      "title": "Target Sum",
      "source_file": "Leetcode/leetcode494.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxth8khy3.py\", line 26, in <module>\n    target_part = parts[1].split('=', 1)[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums, target):\n        dp = defaultdict(int)\n        dp[0] = 1\n\n        for num in nums:\n            next_dp = defaultdict(int)\n            for s in dp:\n                next_dp[s + num] += dp[s]\n                next_dp[s - num] += dp[s]\n            dp = next_dp\n\n        return dp[target]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expected format: \"nums = [1,1,1], target = 3\"\n    parts = [p.strip() for p in data.split(',')]\n    nums_part = parts[0].split('=', 1)[1].strip()\n    target_part = parts[1].split('=', 1)[1].strip()\n    nums = ast.literal_eval(nums_part)\n    target = int(target_part)\n\n    solution = Solution()\n    result = solution.findTargetSumWays(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code lines, step by step. Problem: count expressions using + or - before each number in array such that sum equals target. It's classic target sum DP or recursion. We'll produce virtual steps: start, input array, target, DP initialization, iterate numbers, for each number update counts for sums, use decision to add + or -, final result return count for target. Provide explanation after each line.\n\nNeed to use arrows, Start, End. Use \"Step X: ...\". Ensure each line has virtual code + space + // explanation. Provide decision nodes? Could incorporate DP update loops. Might not need decision arrow, but can use.\n\nWe'll output lines:\n\nStart // start program\n→ Step 1: Input nums, target // get inputs\n→ Step 2: Initialize dp map with dp[0] = 1 // base case: zero sum before any number\n→ Decision: If nums is empty? // check empty array\n    Yes → Step 3: Return dp[target] if target==0 else 0 // if no numbers, only zero sum possible\n    No → Step 4: For each num in nums // iterate numbers\n        → Step 5: Initialize new map next as empty // temporary for current iteration\n        → Step 6: For each (sum, count) in dp // existing sums\n            → Step 7: Add sum + num to next with count // positive sign\n            → Step 8: Add sum - num to next with count // negative sign\n        → Step 9: dp = next // update dp for next number\n→ Step 10: Return dp[target] // final answer\n\nAdd explanation. Use arrow style: Indentation can be shown as space. Use \"Decision:\" etc. Should reflect each line. Ensure each line ends with // explanation. Use proper arrow.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 nums, target // 取得數字陣列與目標值  \n→ Step 2: 初始化 dp 為 {0: 1} // 基本情況，尚未處理任何數字時和為 0 的方式只有一種  \n→ Decision: nums 是否為空? // 檢查陣列是否沒有元素  \n  Yes → Step 3: 回傳 (target == 0 ? dp[0] : 0) // 若陣列為空，只有和為 0 時才可達成目標  \n  No  → Step 4: 對每個 num 在 nums 中循環 // 逐個處理數字  \n    → Step 5: 建立 temp 為空字典 // 用於儲存本輪計算的所有可能和  \n    → Step 6: 對 dp 中每個 (sum, count) 進行迭代 // 取出前一輪所有可能的和與計數  \n      → Step 7: temp[sum + num] += count // 加上正號的方式  \n      → Step 8: temp[sum - num] += count // 加上負號的方式  \n    → Step 9: dp = temp // 更新 dp 為本輪結果，準備處理下一個數字  \n→ Step 10: 回傳 dp[target] // 回傳所有能達到目標值的表達式數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[3,2,1],[1,2,3],[1,3,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [3, 2, 1], [1, 2, 3], [1, 3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        \"\"\"保存原始陣列並初始化當前陣列\"\"\"\n        self.original = list(nums)\n        self.current = list(nums)\n\n    def reset(self):\n        \"\"\"重置為原始配置並回傳\"\"\"\n        self.current = list(self.original)\n        return list(self.current)\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 洗牌演算法隨機排列陣列並回傳\"\"\"\n        self.current = list(self.original)\n        n = len(self.current)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            self.current[i], self.current[j] = self.current[j], self.current[i]\n        return list(self.current)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成 tuple 方便 literal_eval\n    try:\n        ops, args = ast.literal_eval('(' + data + ')')\n    except Exception as e:\n        raise ValueError(f\"輸入格式錯誤: {e}\")\n\n    result = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            obj = Solution(args[i][0])\n            result.append(None)\n        elif op == \"reset\":\n            result.append(obj.reset())\n        elif op == \"shuffle\":\n            result.append(obj.shuffle())\n        else:\n            raise ValueError(f\"未知操作: {op}\")\n\n    # 輸出符合 JSON 的格式，None 會顯示為 null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo code lines step by step. Need to follow format: \"虛擬碼步驟 // 解釋\". Use arrows. Need to cover class Solution with constructor, reset, shuffle. Use internal state original array and current array. For shuffle, use Fisher-Yates. Provide decisions for random index. Show loop. Use decision steps. Let's create Start, then steps.\n\nUse \"Start\" for program, maybe not necessary, but fine. The code structure: Start, → Step 1: Define class Solution // etc.\n\nWe need to output lines. Each line contains \"虛擬碼步驟\" + space + \"// explanation\". Need arrows for decision and loops.\n\nWe need to describe the constructor: store original array copy, and current array copy.\n\nReset: set current array to copy of original, return current.\n\nShuffle: copy original to current, loop i from last index down to 1: generate random j between 0 and i, swap current[i], current[j]; after loop return current.\n\nWe can illustrate decisions: \"Decision: j ≤ i?\" but that's implicit. Use \"Decision: random j selection\".\n\nUse \"For i from n-1 downto 1\" as loop. Provide arrow.\n\nLet's write.\n\nWe need to maintain structure:\n\nStart // 程式開始執行\n\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n\n→ Step 2: 定義建構子 Solution(nums) // 建構子接收陣列 nums\n\n    → Step 3: original ← copy(nums) // 保存原始陣列\n\n    → Step 4: current ← copy(nums) // 初始化當前陣列\n\n→ Step 5: 定義方法 reset() // 重置方法\n\n    → Step 6: current ← copy(original) // 將 current 重新設為原始\n\n    → Step 7: return current // 回傳重置後的陣列\n\n→ Step 8: 定義方法 shuffle() // 隨機洗牌方法\n\n    → Step 9: current ← copy(original) // 先複製原始陣列到 current\n\n    → Step 10: n ← length(current) // 獲取陣列長度\n\n    → Step 11: For i from n-1 downto 1 // 依次遍歷陣列\n\n        → Step 12: j ← random integer in [0, i] // 隨機選取索引\n\n        → Step 13: swap current[i] and current[j] // 交換元素\n\n    → Step 14: return current // 回傳洗牌後的陣列\n\nEnd // 程式執行結束\n\nBut need to format arrows and decisions. For the loop we can use arrow: \"For i from n-1 downto 1 →\".\n\nMaybe use Decision: if i > 0? but loop handles.\n\nWe can incorporate decision for random selection: \"Decision: generate j in [0,i]\".\n\nUse arrow with \"→\". Eg:\n\n→ Step 12: j ← random integer in [0, i] // 產生隨機索引\n\nBut to include decision: \"Decision: j ≤ i?\" but not necessary.\n\nLet's produce final answer with each line accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 宣告 Solution 類別  \n→ Step 2: 定義建構子 Solution(nums) // 建構子接收整數陣列 nums  \n  → Step 3: original ← copy(nums) // 將 nums 複製並存為原始陣列  \n  → Step 4: current ← copy(nums) // 初始化 current 為 nums 的複本  \n→ Step 5: 定義方法 reset() // 重置陣列並回傳  \n  → Step 6: current ← copy(original) // 將 current 重新設為原始陣列  \n  → Step 7: return current // 回傳重置後的陣列  \n→ Step 8: 定義方法 shuffle() // 隨機洗牌並回傳  \n  → Step 9: current ← copy(original) // 先複製原始陣列到 current  \n  → Step 10: n ← length(current) // 取得陣列長度  \n  → Step 11: For i from n-1 downto 1 → // 逐個元素進行交換  \n    → Step 12: j ← random integer in [0, i] // 產生隨機索引 j  \n    → Step 13: swap current[i] and current[j] // 交換元素以實現洗牌  \n  → Step 14: return current // 回傳已洗牌的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"\n        回傳 nums 的所有子集（冪集）。\n        \"\"\"\n        res = []\n\n        def backtrack(start, path):\n            # 把目前的子集加入結果\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])        # 包含 nums[i]\n                backtrack(i + 1, path)     # 進一步遞迴\n                path.pop()                 # 回溯，移除已加入的元素\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入成列表\n    try:\n        # 若輸入為 \"nums = [1,2,3]\" 等格式，抓取 '[' 到 ']' 的內容\n        start = data.find('[')\n        end = data.rfind(']') + 1\n        if start != -1 and end != -1:\n            list_str = data[start:end]\n        else:\n            # 直接把整個輸入當作列表\n            list_str = data\n        nums = ast.literal_eval(list_str)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets (power set) of an array of unique integers. Steps: Start, define recursion or iterative approach. We will produce steps with decisions, using virtual arrows. Ensure each line has the pattern: virtual step + space + // explanation. Include Start and End. Use arrow \"→\" for flow, \"Decision:\" for if. Provide indentation? In example they used indentation but with arrow after. We'll replicate style.\n\nSo steps: Start, Step 1: 初始化結果集合 res = [] and current subset cur = [] . Step 2: 定義遞迴函式 backtrack(index). Step 3: decision: index == len(nums)? yes: add cur copy to res. No: decision: include current element? We'll push, backtrack(index+1), pop. Then backtrack(index+1) for excluding. Or we can do loop for each index. Let's produce simple recursion.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 nums, res = [], cur = [] // 初始化輸入陣列與結果與目前子集\n→ Step 2: 定義遞迴函式 backtrack(i) // 用來產生子集\n→ Decision: i == len(nums) // 判斷是否已處理完所有元素\n    Yes → Step 3: res.append(cur.copy()) // 把目前子集加入結果\n    No  → Step 4: cur.append(nums[i]) // 包含當前元素\n    → Step 5: backtrack(i+1) // 進行包含後的遞迴\n    → Step 6: cur.pop() // 移除已加入的元素\n    → Step 7: backtrack(i+1) // 進行不包含當前元素的遞迴\n→ Step 8: backtrack(0) // 從第一個元素開始遞迴\n→ Step 9: return res // 回傳所有子集\nEnd // 程式執行結束\n\nCheck each line has \"虛擬碼步驟\" then space then comment. Use \"→\" arrow after each step? In example they used \"→ Step 1:\" after Start. So for Step lines use \"→ Step X:\" with arrow. For decisions use \"Decision:\". Use indentation with spaces maybe.\n\nWe should ensure each line ends with comment. Let's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 nums, res = [], cur = [] // 初始化輸入陣列與結果與目前子集  \n→ Step 2: 定義遞迴函式 backtrack(i) // 用來產生子集  \n→ Decision: i == len(nums) // 判斷是否已處理完所有元素  \n Yes → Step 3: res.append(cur.copy()) // 把目前子集加入結果  \n No → Step 4: cur.append(nums[i]) // 包含當前元素  \n  → Step 5: backtrack(i+1) // 進行包含後的遞迴  \n  → Step 6: cur.pop() // 移除已加入的元素  \n  → Step 7: backtrack(i+1) // 進行不包含當前元素的遞迴  \n→ Step 8: backtrack(0) // 從第一個元素開始遞迴  \n→ Step 9: return res // 回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2,0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34,-10,-14,-10,10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef diffWaysToCompute(expression: str):\n    memo = {}\n\n    def ways(expr: str):\n        if expr in memo:\n            return memo[expr]\n\n        res = []\n        for i, ch in enumerate(expr):\n            if ch in '+-*':\n                left = ways(expr[:i])\n                right = ways(expr[i + 1:])\n                for l in left:\n                    for r in right:\n                        if ch == '+':\n                            res.append(l + r)\n                        elif ch == '-':\n                            res.append(l - r)\n                        else:  # '*'\n                            res.append(l * r)\n\n        if not res:\n            res.append(int(expr))\n        memo[expr] = res\n        return res\n\n    return ways(expression)\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to extract expression inside quotes\n    match = re.search(r'expression\\s*=\\s*\"([^\"]+)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # Fallback: expression without quotes\n        match = re.search(r'expression\\s*=\\s*([^\\s]+)', data)\n        expr = match.group(1) if match else data\n\n    expr = expr.replace(' ', '')\n    results = diffWaysToCompute(expr)\n    print('[' + ','.join(str(x) for x in results) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: evaluate all possible results from different parenthesizations of an expression string of numbers and operators. We need step-by-step algorithm: parse string, divide into numbers and operators, use recursion/memoization to compute results for subexpressions.\n\nWe'll produce virtual code in lines with arrows and decision etc. Use virtual code constructs: Start, End, Decision, Step.\n\nWe must not output actual code, just virtual steps. Provide explanations after each line. Let's write.\n\nOutline:\n\nStart\n→ Step 1: Input expression string // get the string\n→ Step 2: Parse into tokens list (numbers, operators) // split digits into numbers, operators separate\n→ Decision: if tokens length == 1? // single number\n    Yes → Step 3: Return list containing that number // base case\n    No  → Step 4: Create memo map // for caching subexpression results\n→ Step 5: Define recursive function compute(l, r) // compute all results for subexpression tokens[l..r]\n    Inside compute:\n    → Decision: if l == r? // single number\n        Yes → Step 6: Return list with that number\n        No  → Step 7: If memo has key l,r? // caching\n            Yes → Step 8: Return memoized results\n            No  → Step 9: Initialize empty result list\n            → Loop i from l+1 to r-1 step 2? // operators positions\n                → Step 10: leftResults = compute(l, i-1)\n                → Step 11: rightResults = compute(i+1, r)\n                → Step 12: For each a in leftResults, b in rightResults\n                    → Step 13: op = tokens[i] // operator\n                    → Step 14: res = apply op to a and b // compute\n                    → Step 15: Append res to result list\n            → Step 16: memoize l,r with result list\n            → Step 17: Return result list\n    End compute function\n→ Step 18: Call compute(0, len(tokens)-1) // compute all results\n→ Step 19: Return the list // final output\nEnd\n\nWe need to format each line with virtual code arrow etc. Use \"→\" for normal steps, \"Decision:\" with Yes→, No→.\n\nMake sure each line is a virtual code step. For function definition, we can write \"→ Step 5: 定義遞歸函式 compute(l, r) // 計算子陣列 l 到 r 的所有結果\".\n\nAlso need to use Start and End. We'll indent decisions properly maybe with indentation. Provide explanation after //.\n\nLet's produce. Ensure no actual code, just virtual steps. Use Chinese comments. Provide line numbers? Not required but could help. We'll just produce sequential lines.\n\nAlso ensure we cover apply operator step: define apply operation virtual.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 expression // 取得原始算式  \n\n→ Step 2: 解析 expression 為 tokens 列表 // 依照數字與運算符切分，tokens 例: [2, '+', 3, '*', 4]  \n\n→ Decision: tokens 長度是否為 1? // 判斷是否只有單一數字  \n Yes → Step 3: 回傳 [tokens[0]] // 單個數字的唯一結果  \n No → Step 4: 初始化 memo map // 用於記錄子表達式的計算結果  \n\n→ Step 5: 定義遞歸函式 compute(l, r) // 計算 tokens[l..r] 的所有結果  \n\n → Decision: l == r? // 子表達式是否只有一個數字  \n  Yes → Step 6: 回傳 [tokens[l]] // 基本情況  \n  No → Step 7: 若 memo 已有 key (l, r)? // 檢查是否已計算  \n   Yes → Step 8: 回傳 memo[(l, r)] // 直接取記錄  \n   No → Step 9: 初始化 empty results list // 用於收集所有可能結果  \n\n   → Loop i from l+1 to r-1 step 2 // i 為運算符位置  \n    → Step 10: leftResults = compute(l, i-1) // 計算左子表達式  \n    → Step 11: rightResults = compute(i+1, r) // 計算右子表達式  \n\n    → Loop a in leftResults  \n     → Loop b in rightResults  \n      → Step 12: op = tokens[i] // 取得運算符  \n      → Step 13: res = apply op on a 與 b // 執行運算（+、-、*）  \n      → Step 14: 將 res 加入 results  \n\n   → Step 15: memo[(l, r)] = results // 記錄本次子表達式的結果  \n   → Step 16: 回傳 results // 將結果返回給呼叫者  \n\n→ Step 17: finalResults = compute(0, len(tokens)-1) // 計算整個表達式的所有可能結果  \n→ Step 18: 回傳 finalResults // 將結果作為輸出  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,0,0]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null,0,1,1,0,0]'"
        }
      ],
      "generated_code": "import random\nimport bisect\nimport json\nimport sys\n\nclass Solution:\n    def __init__(self, w):\n        # 前綴和\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機生成 1~total 的整數\n        target = random.randint(1, self.total)\n        # 二分搜尋得到第一個 prefix_sum >= target 的位置\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 分離方法名與參數\n    first_close = raw_input.find(']')\n    methods_str = raw_input[:first_close + 1]\n    args_str = raw_input[first_close + 2:].strip()\n    methods = json.loads(methods_str)\n    args = json.loads(args_str)\n\n    results = []\n    instance = None\n    for method, params in zip(methods, args):\n        if method == \"Solution\":\n            instance = Solution(*params)\n            results.append(None)            # 構造函數返回 None\n        else:\n            results.append(getattr(instance, method)(*params))\n\n    # 輸出結果，使用無空格的 JSON 風格\n    print(json.dumps(results, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step. It's a typical weighted random selection: preprocess prefix sums; then in pickIndex generate random number r in [0, total) and binary search to find index.\n\nWe'll produce virtual code lines with steps and comments. Ensure using arrow etc. Format: each line \"虛擬碼步驟 // 解釋\". Use \"Start\" \"End\". Decision arrows. Use \"→\". For loops: \"For each weight\" etc. Provide lines like:\n\nStart\n→ Step 1: 初始化 prefixSum array // 建立累積和\n→ For i = 0 to w.length-1: ...\nBut we can write step: \"計算 prefix sums\" etc. Provide steps.\n\nWe also need pickIndex function.\n\nWe can structure like:\n\nStart\n→ Step 1: Build prefix sum array // 前缀和\n→ Step 2: 計算 totalWeight // 總重量\n→ Step 3: 定義 pickIndex()\n   → Step 3.1: 生成隨機數 r ∈ [0, totalWeight)\n   → Decision: binary search on prefix sum to find index where prefixSum[i] > r\n       Yes? etc\n→ End\n\nWe must follow output format strictly: each line \"虛擬碼步驟 // 解釋\" with arrow.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 建立 prefixSum 數組 // 用於儲存累積和\n→ Step 2: totalWeight = 0 // 初始化總重量\n→ Decision: 遍歷 w 的每個元素\n    Yes → Step 3: totalWeight += w[i] // 累加總重量\n    No  → Step 4: prefixSum[i] = totalWeight // 記錄累積和\n→ Step 5: 定義函數 pickIndex() // 生成隨機索引\n    → Step 5.1: 隨機生成 r ∈ [0, totalWeight) // 隨機數\n    → Decision: 在 prefixSum 中找到第一個大於 r 的位置\n        Yes → Step 5.2: 返回對應索引 // 返回選中的索引\n        No  → Step 5.3: (binary search logic) // 迭代搜尋\n→ End // 程式結束\n\nBut need to use arrow inside decisions. Use \"Decision:\" and \"Yes →\", \"No →\".\n\nMake sure each line separate. Use \"Start\" line. Provide steps.\n\nLet's craft more precise.\n\nWe'll also include binary search loop lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 prefixSum 數組長度為 w.length // 用於儲存前綴和\n→ Step 2: totalWeight ← 0 // 總重量初始值\n→ Step 3: For i = 0 to w.length-1\n    → Step 3.1: totalWeight ← totalWeight + w[i] // 累加重量\n    → Step 3.2: prefixSum[i] ← totalWeight // 記錄前綴和\n→ Step 4: 定義函數 pickIndex()\n    → Step 4.1: r ← 隨機數 0 ≤ r < totalWeight // 產生隨機數\n    → Decision: binarySearch(prefixSum, r)\n        Yes → Step 4.2: return index // 找到對應索引\n        No  → Step 4.3: （遞迴或迴圈實現） // binary search 失敗不應該發生\n→ End // 程式結束\n\nBut we need explicit binary search loop. Let's write:\n\nDecision: binarySearch loop start\n    Yes → Step 4.2: mid ← (left + right) // 計算中點\n    Yes → Step 4.3: If prefixSum[mid] > r → right ← mid-1; else → left ← mid+1\n    Yes → Step 4.4: Loop until left > right\n    Yes → Step 4.5: return left // 左指針即為索引\n\nBut using decision may be confusing. Maybe better to just describe steps without decision.\n\nGiven instruction, we can use \"Decision:\" for loops and conditions. Let's keep simple: For each element build prefix sums. For pickIndex, generate random, then binary search. Use decision for binary search condition: while left <= right? Use \"Decision:\".\n\nWe'll produce lines accordingly.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 prefixSum 數組長度為 w.length // 用於儲存前綴和  \n→ Step 2: totalWeight ← 0 // 總重量初始值  \n→ Step 3: For i = 0 to w.length-1  \n    → Step 3.1: totalWeight ← totalWeight + w[i] // 累加重量  \n    → Step 3.2: prefixSum[i] ← totalWeight // 記錄前綴和  \n→ Step 4: 定義函數 pickIndex() // 生成隨機索引  \n    → Step 4.1: r ← 隨機數 0 ≤ r < totalWeight // 產生隨機數  \n    → Step 4.2: left ← 0, right ← w.length-1 // 設定 binary search 範圍  \n    → Decision: while left ≤ right? // 進行 binary search  \n        Yes → Step 4.3: mid ← (left + right) / 2 // 計算中點  \n        Yes → Step 4.4: If prefixSum[mid] > r Then  \n            Yes → Step 4.5: right ← mid - 1 // 向左搜尋  \n            No  → Step 4.6: left ← mid + 1 // 向右搜尋  \n    → Step 4.7: return left // left 為符合條件的索引  \n→ End // 程式結束"
    }
  ]
}