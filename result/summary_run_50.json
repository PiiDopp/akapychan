{
  "run_index": 50,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 291,
  "generation_or_validation_failure_count": 43,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin（雖然本題不需要，但依照規範必須執行）\n    _ = sys.stdin.read()\n\n    try:\n        # 嘗試以 read 模式開啟 data.txt\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        # 輸出總行數\n        print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        # 檔案不存在時輸出錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code with explanations line by line. We must use Start, End, Decision: etc. Use with, try/except. We should output each step as a line: \"Start // ...\", \"→ Step 1: ...\" etc. Provide the arrow syntax. For decision we use Decision: if file exists? Actually we try opening file. Try open with with open... except FileNotFoundError: print not found. So we can structure: Start, try block with with open... Step 1: initialize counter, Step 2: read lines, Step 3: count lines, Step 4: print count. Then except: print message. End.\n\nWe need to follow arrow arrow. Use \"→\" for step. For try block, we can label as \"→ Decision: try open file?\" But easier: Use \"→ Step 1: 嘗試以 read 模式開啟 data.txt 使用 with 語法\". Then inside \"→ Decision: 是否成功打開檔案?\" but we can incorporate try/except. Maybe:\n\nStart\n→ Step 1: 嘗試以讀取模式開啟 'data.txt' 並使用 with 語法 // 準備打開檔案\n→ Decision: 是否打開成功? // 由 try / except 判斷\n    Yes → Step 2: 初始化行數計數器 // 計數變數\n    → Step 3: 逐行讀取檔案並累計 // 讀取每行並加一\n    → Step 4: 輸出總行數 // 顯示結果\n    No  → Step 5: 輸出 '找不到檔案！' // 檔案不存在時的訊息\nEnd\n\nBut we need to incorporate try/except. Use Step 1: try block? Maybe:\n\n→ Step 1: 嘗試以 read 模式開啟 'data.txt' 並使用 with 語法 // 進入 try\n→ Step 2: 初始化計數器 // 計數 0\n→ Step 3: 逐行讀取並累計 // for line in file: count +=1\n→ Step 4: 輸出總行數 // print count\n→ Decision: 是否拋出 FileNotFoundError? // if exception\n    Yes → Step 5: 輸出 '找不到檔案！'\n    No  → // nothing\nEnd\n\nBut we should reflect the try/except structure. Perhaps use \"→ Decision: 觸發異常?\" after try block. But in code, we would have try: ... except FileNotFoundError: ... else: ...\n\nSo the structure: Start, Step 1: try, Step 2: with open..., Step 3: count lines, Step 4: print, Step 5: except, Step 6: print error, End. But we need arrow for each line. Use \"→\" at start of each step. But the example shows \"→ Decision:\" with indent and then Yes / No lines. But we can use nested arrow for steps.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 嘗試使用 try 語句打開 'data.txt' 並使用 with 語法 // 開始嘗試\n→ Step 2: 使用 with open('data.txt', 'r') as file: // 開啟檔案\n    → Step 3: 初始化計數器 count = 0 // 計數變數\n    → Step 4: 逐行讀取 file 進行累加\n        → Step 5: count += 1\n    → Step 6: 輸出 count // 顯示行數\n→ Decision: 是否捕捉到 FileNotFoundError? // 檢查是否發生例外\n    Yes → Step 7: 輸出 '找不到檔案！' // 顯示錯誤訊息\n    No  → // 成功執行，已在 Step 6 輸出\nEnd // 程式結束\n\nBut we need to be careful with formatting: Each line ends with // explanation. The arrows must be consistent. For indentation, we can indent with spaces. Use \"→\" for each step. For Decision, we need Yes → and No → lines. The example shows that inside Decision block we indent. Let's replicate.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 嘗試使用 try 語句打開 'data.txt' 並使用 with 語法 // 開始嘗試  \n→ Decision: 是否能成功執行 try 區塊? // 檢查是否拋出 FileNotFoundError  \n Yes → Step 2: 以讀取模式開啟檔案並使用 with open('data.txt', 'r') as file: // 打開檔案  \n  → Step 3: 初始化計數器 count = 0 // 設定行數變數  \n  → Step 4: 逐行讀取檔案並累加 count  \n   → Step 5: count += 1 // 每讀到一行加一  \n  → Step 6: 輸出 count // 顯示總行數  \n No  → Step 7: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "Thinking...\nWe need to produce Python code that satisfies conditions. They want a function roll_dice(n) using random module. main block reads from stdin all data. They want to process the input string 'print(roll_dice(5))' and output result. So basically we need to execute arbitrary input as Python code? They give example where stdin contains 'print(roll_dice(5))' and output should be result of executing that code. So we need to read the input from stdin, which will be a line like \"print(roll_dice(5))\" (could be any code that uses roll_dice). So we need to evaluate that code safely? The problem statement: \"從標準輸入 (stdin) 讀取解決問題所需的所有數據（例如，使用 `input()` 或 `sys.stdin.read()`). 處理這些數據. 將最終答案打印 (print) 到標準輸出 (stdout).\" They want a generic main that reads the input string, then executes it. That means we can use exec. We should first define roll_dice function, then read the entire stdin (like sys.stdin.read()), then exec it. This will run the input code.\n\nWe need to import random. Use if __name__ == \"__main__\": block. In main: import sys, read all lines via sys.stdin.read(), strip maybe. Then exec that string.\n\nWe must not hardcode examples. So just exec whatever read. That should produce output. Ensure exec environment has roll_dice defined.\n\nPotential issues: If input contains newline etc. Use sys.stdin.read().\n\nLet's produce final code block.\n\nAlso we must not output any other text. So just code.\n\nLet's craft:\n\n```python\nimport random\nimport sys\n\nCA9:-0/&$ED(5,A+5>$(?.A/47+)<()205F'86-32:6.\"+>%;.E+06(+,?&:70#8BD;(/<=?D#>;=<-\"3/6&$C2@C/)<=#%23*77#AF$C?>B(*?7/4(36#=0?;.&)#B(>'/$E0E><C7#(.95@D>(13A((2F*&&DA#?/E<<3-2($'A@5A#)/=&?2'6=4F4/;A530'(-B7\"7?89.=&((/3*-7D<F+B2E,F.E<,4;&AE-*7(<&D/',F2,D8*+:=DA=+?7;8@&.&$9+:EA<A3+'#>1@2-+.9/1#,E./%8@-;==7\"-4FD15F5$*=$(4'&63%)70.;B&-9'A567B>BDA96A??D,:-4../F)4B4@*7?D<941"
        }
      ],
      "generated_code": null,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following the format: each line: \"虛擬碼步驟 [space] // 解釋\". Must use arrow \"→\", \"Yes →\", \"No →\". Use Start, End, Decision. Also no actual code. Just virtual steps.\n\nWe need function roll_dice(n) simulate n times six-sided die and return list of results.\n\nSo steps:\n\nStart\n\n→ Define function roll_dice(n): // start function definition\n\n→ Initialize empty list results // create list to hold rolls\n\n→ Decision: If n <= 0? // check for non-positive\n\n    Yes → Return empty list // if zero or negative, return empty\n\n    No  → Step 2: Set counter i = 1 // start counter\n\n→ Loop while i <= n: // repeat n times\n\n    → Step 3: Generate random number r between 1 and 6 // simulate dice\n\n    → Step 4: Append r to results // add to list\n\n    → Step 5: Increment i // move to next roll\n\n→ Return results // return list of all rolls\n\nEnd\n\nBut we must format each line with virtual code and comment. Need to use \"→\" at start of each step. For decision we show \"Decision:\" lines. Indentation maybe implied by arrow.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義函數 roll_dice(n) // 開始函數定義\n→ Step 2: 初始化空串列 results // 用於儲存擲骰結果\n→ Decision: n 是否小於等於 0? // 檢查擲骰次數是否合法\n    Yes → Step 3: 回傳空串列 results // 若次數非正數，直接回傳空結果\n    No  → Step 4: 設定計數器 i = 1 // 初始化計數器\n→ Decision: i 是否小於等於 n? // 判斷是否已完成所有擲骰\n    Yes → Step 5: 產生隨機數 r 在 1~6 之間 // 模擬一次擲骰\n    → Step 6: 將 r 加入 results // 儲存結果\n    → Step 7: i 增加 1 // 計數器自增\n    No  → Step 8: 回傳 results // 擲骰完成後回傳結果\nEnd // 程式結束\n\nBut we need arrow after each step. Use \"→\". For decisions we might indent with spaces? But guidelines show:\n\n```\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step ...\n    No  → Decision ...\n```\n\nSo we can use indentation spaces for nested branches.\n\nWe should produce virtual code lines with arrows. Use 'Step X:' for actions.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 roll_dice(n) // 開始函式D>=2DE,5:9.1-(.2A:#4&AB<.@E-E;9.;36;&-F+0A23:D)2)3189)82,?FA;-:'6#1&1@A+48-6951%':'3:.F=7F8%DE,6.E8=35>45?:#D=B8<'\"2F9\"6$(:-@=?:A($0#?1?/30E%#3/)@5)7-2$/39C=;,'+#3##>C'C>)03;9\"$0FC0\">\">.C;B9>F/<;+3@?28=D'2%6,*=<D*/=&1/4'40(''6&<A+=,:1,.*>218,)>:(4C&$@'?%E%3BE*7@.:2A?(#/-/D0*2?>:/91,1CF.%08'11,=*>D>DBB/77C:/7B04$1)+4:359E12';C33-7'8@2+,11*C+&16##5.?#()5),>*,4>23,9083$:?5(/#3-19B+>755F536F3?D1?DC:;A8-(E1@5\"-B-;:38>F19D?@.#AA\"9E+2>84:\"1.#'A*>\"9,0@@3$),*,0':2;,DB/>?FF=/$@@0#92A#=E%)"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間，回傳秒數 (四捨五入到小數點 3 位)。\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    code = sys.stdin.read()\n    # 只在執行環境中注入 measure_time\n    exec_globals = {\"measure_time\": measure_time, \"__name__\": \"__main__\"}\n    exec(code, exec_globals)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines. Use Start, End, Decision, etc. The function measure_time(func, *args) that uses time module. It should measure time before and after, compute duration, round to 3 decimals, return that. So we need steps: import time, define function, record start time, call func(*args), record end time, compute elapsed, round, return. So we produce virtual code line by line. Use arrow arrows. Provide brief explanation after each line. Also include a comment line for import. Use \"→\" for steps. The virtual code lines must include the arrow and step, then space, then comment with // explanation. We need to follow format.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: import time module // 引入時間模組\n→ Step 2: Define function measure_time(func, *args) // 建立測時函式\n→ Step 3: start = time.time() // 記錄起始時間\n→ Step 4: result = func(*args) // 執行傳入函式並取得結果\n→ Step 5: end = time.time() // 記錄結束時間\n→ Step 6: elapsed = round(end - start, 3) // 計算秒數並四捨五入到三位小數\n→ Step 7: return elapsed, result // 回傳經過時間與函式結果\nEnd // 程式結束\n\nBut maybe we want to return both result and elapsed? The requirement: \"回傳結果 (四捨五入到小數點 3 位)\". It might mean return the elapsed seconds, not the function result. But typical measure_time returns time. However the requirement might mean \"return the time\" only. Let's interpret: measure_time(func, *args) returns time elapsed. But some implementations return both. However specification: \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。\" So the \"結果\" refers to the time measurement, not the function's return value. So we should only return the elapsed time, not result. But we might also want to execute func and ignore its result. Ok.\n\nSo modify Step 4 to call func(*args) maybe but we don't need result. But still need to call function. So we can ignore result. So Step 4: func(*args) // 執行傳入函式\nThen Step 6: elapsed = round(end - start, 3) // ...\nStep 7: return elapsed // 回傳時間\n\nOk.\n\nThus final virtual code lines.\n\nNeed to adhere to \"每行虛擬"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"melon\",\"grape\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'melon', 'grape', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取並忽略任何輸入，確保程式可以從 stdin 接收資料\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step. Use Start, End, Decision if needed. For each line: \"虛擬碼步驟 // 解釋\". Use arrow arrows.\n\nWe don't output actual code. Just structure.\n\nWe'll produce Start, then Step 1: Create set, Step 2: add, Step 3: update, Step 4: remove, Step 5: discard, Step 6: output. End. Use appropriate arrows. No decision needed.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'，若不存在會出錯  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'，不存在則不做任何事  \n→ Step 6: 輸出 fruits // 顯示集合中剩餘的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> float | None:\n    \"\"\"從匯率 API 取得 USD 對 TWD 的匯率。\"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        return data['rates']['TWD']\n    except Exception:\n        return None\n\ndef update_label() -> None:\n    \"\"\"將最新匯率顯示在 tkinter 的 label 上。\"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f'目前美元匯率：約 {rate} TWD')\n    else:\n        label.config(text='更新失敗，請檢查網路連線')\n\ndef print_rate() -> None:\n    \"\"\"從 stdin 讀取指令，並把匯率結果輸出到 stdout。\"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        print(f'目前美元匯率：約 {rate} TWD')\n    else:\n        print('更新失敗，請檢查網路連線')\n\n# --------------------- GUI 設定 ---------------------\nwin = tk.Tk()\nwin.title('匯率查詢')\n\nlabel = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\nlabel.pack(pady=10)\n\ntk.Button(win, text='更新匯率', command=update_label).pack(pady=5)\n\n# --------------------- main 區塊 ---------------------\nif __name__ == \"__main__\":\n    # 從標準輸入讀取指令\n    line = sys.stdin.readline().strip()\n    if line == '按下「更新匯率」按鈕':\n        print_rate()\n    # 啟動 tkinter 主循環\n    win.mainloop()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines following format: each line: virtual code step + space + // explanation. Use Start, End, Decision, arrows. The request: use requests module to call API to get USD to TWD rate, display in Tkinter window, button to refresh.\n\nWe need to produce a structured algorithm: Import modules, define fetch_rate function, create Tkinter window, label to display rate, button to trigger refresh, main loop.\n\nWe need to maintain \"逐行\" output. Each line includes \"虛擬碼步驟\" plus comment.\n\nWe can use pseudo-code style: \"Start\", \"→ Step 1: 載入 requests, tkinter // import modules\" etc.\n\nMake sure we don't output actual code but pseudo-code lines. Use arrow \"→\" before each step. For decisions use \"Decision:\" lines.\n\nLet's structure:\n\nStart\n→ Step 1: 匯入 requests, tkinter\n→ Step 2: 定義 fetch_rate() // 連線 API 取得 USD->TWD 匯率\n→ Decision: 如果請求成功? // 檢查 HTTP 回應\n    Yes → Step 3: 解析 JSON，取 rates.TWD // 提取匯率\n    No  → Step 4: 回傳 'Error' // 失敗回傳錯誤訊息\n→ Step 5: 建立 Tkinter 視窗 // 初始化 GUI\n→ Step 6: 建立 Label 以顯示匯率 // 用於顯示\n→ Step 7: 建立 Button 以更新匯率 // 按鈕點擊觸發\n→ Step 8: Button 連接 fetch_rate() 並更新 Label // 事件綁定\n→ Decision: 是否已完成設定? // 檢查所有元件是否已配置\n    Yes → Step 9: 啟動主循環 mainloop // 進入 GUI 循環\n    No  → Step 10: 繼續設定其他元件 // 這裡假設已完成\nEnd\n\nBut we need to be careful: we need each line with \"→\" or \"Decision:\" etc. Let's make each line consistent: use \"Start\" line, then \"→ Step X\" lines, \"Decision:\" lines with indentation. Use \"Yes →\" and \"No →\" lines. Each line must contain a comment after //.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests, tkinter // 導入 HTTP 與 GUI 模組  \n→ Step 2: 定義 fetch_rate() // 建立函式來取得匯率  \n→   Decision: 若請求成功? // 檢查 HTTP 回應狀態  \n  Yes → Step 3: 解析 JSON，取 rates.TWD // 取得美元兌台幣匯率  \n  No  → Step 4: 回傳 'Error' // 請求失敗時回傳錯誤訊息  \n→ Step 5: 建立 Tkinter 視窗 root // 初始化主視窗  \n→ Step 6: 建立 Label rate_label，初始文字 '匯率載入中...' // 顯示匯率的文字元件  \n→ Step 7: 建立 Button update_btn，文字 '更新匯率' // 按鈕觸發更新動作  \n→ Step 8: 綁定 update_btn 的 click 事件到 lambda: rate_label['text'] = fetch_rate() // 點擊更新時顯示最新匯率  \n→ Step 9: 放置 rate_label、update_btn 至 root 視窗 // 把元件放到 GUI 上  \n→   Decision: 是否已配置完所有元件? // 確認 GUI 元件已安置  \n  Yes → Step 10: 啟動 root.mainloop() // 進入 Tkinter 主循環，等待使用者操作  \n  No  → Step 11: 繼續配置其他元件 // 若有遺漏，持續添加  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass RandomizedSet:\n    def __init__(self):\n        # 用字典存儲元素到索引的映射，列表存儲元素\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        # 如果已存在，插入失敗\n        if val in self.val_to_index:\n            return False\n        # 將新值追加到列表尾部\n        self.values.append(val)\n        # 更新映射，指向新元素的索引\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        # 如果不存在，刪除失敗\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素在列表中的索引\n        idx = self.val_to_index[val]\n        # 取得列表最後一個元素\n        last_val = self.values[-1]\n        # 把最後一個元素搬到要刪除的位置\n        self.values[idx] = last_val\n        # 更新映射，指向新位置\n        self.val_to_index[last_val] = idx\n        # 真正移除列表最後一個元素\n        self.values.pop()\n        # 刪除映射中的目標元素\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        # 隨機選擇一個索引並返回對應值\n        return random.choice(self.values)\n\ndef parse_input(raw):\n    \"\"\"\n    將 stdin 的內容解析為兩個列表：ops 與 args\n    \"\"\"\n    raw = raw.strip().replace('\\n', ' ')\n    # 找到第一個 '],' 以分離兩個列表\n    split_idx = raw.find('],')\n    if split_idx != -1:\n        ops_str = raw[:split_idx + 1]\n        args_str = raw[split_idx + 2:].strip()\n    else:\n        # 可能是兩行分開\n        parts = raw.split()\n        ops_str = parts[0] if parts else '[]'\n        args_str = parts[1] if len(parts) > 1 else '[]'\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        return\n    ops, args = parse_input(raw_input)\n\n    result = []\n    rset = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            rset = RandomizedSet()\n            result.append(None)\n        elif op == \"insert\":\n            # arg 為單元素列表\n            val = arg[0] if isinstance(arg, list) else arg\n            result.append(rset.insert(val))\n        elif op == \"remove\":\n            val = arg[0] if isinstance(arg, list) else arg\n            result.append(rset.remove(val))\n        elif op == \"getRandom\":\n            result.append(rset.getRandom())\n        else:\n            # 未知操作，視情況處理\n            result.append(None)\n\n    # 輸出 JSON 格式，符合 LeetCode 的輸出要求\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing RandomizedSet class with methods insert, remove, getRandom, each O(1). The user wants line-by-line pseudocode steps, with explanation comment after each line. Format: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision, Yes/No.\n\nWe need to describe the class and its internal data structures: an array/list for values and a hash map from value to index.\n\nWe'll output step by step algorithm: initialization, insert, remove, getRandom. Possibly show decision steps.\n\nLet's produce Start, Step for initialization, etc.\n\nWe'll use lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化空的列表 values // 用於隨機存取元素\n→ Step 2: 初始化空的映射 valToIndex // 用於 O(1) 查找索引\n\nThen for insert:\n\n→ Step 3: 定義 insert(val) // 插入新值\n→ Decision: 是否已存在 val 在 valToIndex? // 檢查集合中是否已有該值\n    Yes → Step 4: 返回 false // 已存在，插入失敗\n    No → Step 5: 將 val 加入 values 列表尾部 // 追加新元素\n        → Step 6: 設置 valToIndex[val] = values.length - 1 // 更新索引映射\n        → Step 7: 返回 true // 成功插入\n\nFor remove:\n\n→ Step 8: 定義 remove(val) // 刪除值\n→ Decision: val 是否存在於 valToIndex? // 判斷是否需要刪除\n    Yes → Step 9: 取得 idx = valToIndex[val] // 找到該值在列表中的索引\n        → Step 10: 取得 last = values.last() // 取得列表最後一個元素\n        → Step 11: 將 last 放到 idx 位置 // 替換待刪元素\n            → Step 12: 更新 valToIndex[last] = idx // 更新映射\n        → Step 13: 移除 values 最後一個元素 // 真正刪除\n        → Step 14: 刪除 valToIndex[val] // 移除映射\n        → Step 15: 返回 true // 刪除成功\n    No → Step 16: 返回 false // 值不存在，刪除失敗\n\nFor getRandom:\n\n→ Step 17: 定義 getRandom() // 隨機取值\n→ Step 18: 生成隨機索引 r = random(0, values.length-1) // 隨機數\n→ Step 19: 返回 values[r] // 返回隨機元素\n\nEnd.\n\nWe need to ensure each line ends with comment.\n\nLet's format precisely. Use \"→\" arrow each line after Start and before End.\n\nWe must use \"Decision:\" lines and indent? In example they indent lines under Decision: Yes → ... etc. We should mimic that.\n\nUse \"Yes →\" \"No →\" lines. For nested decisions we indent further.\n\nBe careful with Chinese characters in comments: // 解釋.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空的列表 values // 用於隨機存取元素\n→ Step 2: 初始化空的映射 valToIndex // 用於 O(1) 查找索引\n\n→ Step 3: 定義 insert(val) // 插入新值\n→ Decision: 是否已存在 val 在 valToIndex? // 檢查集合中是否已有該值\n    Yes → Step 4: 返回 false // 已存在，插入失敗\n    No  → Step 5: 將 val 加入 values 列表尾部 // 追加新元素\n        → Step 6: 設置 valToIndex[val] = values.length - 1 // 更新索引映射\n        → Step 7: 返回 true // 成功插入\n\n→ Step 8: 定義 remove(val) // 刪除值\n→ Decision: val 是否存在於 valToIndex? // 判斷是否需要刪除\n    Yes → Step 9: 取得 idx = valToIndex[val] // 找到該值在列表中的索引\n        → Step 10: 取得 last = values.last() // 取得列表最後一個元素\n        → Step 11: 將 last 放到 idx 位置 // 替換待刪元素\n            → Step 12: 更新 valToIndex[last] = idx // 更新映射\n        → Step 13: 移除 values 最後一個元素 // 真正刪除\n        → Step 14: 刪除 valToIndex[val] // 移除映射\n        → Step 15: 返回 true // 刪除成功\n    No  → Step 16: 返回 false // 值不存在，刪除失敗\n\n→ Step 17: 定義 getRandom() // 隨機取值\n→ Step 18: 生成隨機索引 r = random(0, values.length-1) // 隨機數\n→ Step 19: 返回 values[r] // 返回隨機元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[2,0],[0,0],[1,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [2, 0], [0, 0], [1, 0], null, [2, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n          # 仍可翻轉的 0 的總數\n        self.flipped = {}           # 只記錄已被翻轉的索引對應關係\n\n    def flip(self):\n        # 隨機挑選一個仍為 0 的索引\n        r = random.randint(0, self.total - 1)\n        # 若 r 已被記錄，代表其實際值是映射中的對應值\n        x = self.flipped.get(r, r)\n        # 把這個位置從可用列表中移除\n        self.total -= 1\n        # 更新映射：把最後一個可用索引放到 r 所在的位置\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # 將線性索引轉成 (row, col)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將兩個列表包裝成 JSON 陣列，方便解析\n    try:\n        # 如果輸入是多行，先合併成一行\n        raw_input = raw_input.replace('\\n', ' ')\n        data = json.loads('[' + raw_input + ']')\n    except Exception:\n        # 若 JSON 解析失敗，嘗試使用 ast.literal_eval\n        data = ast.literal_eval('[' + raw_input + ']')\n\n    method_names = data[0]\n    args_list = data[1]\n\n    res = []\n    obj = None\n\n    for name, args in zip(method_names, args_list):\n        if name == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)          # 建構子回傳 null\n        elif name == \"flip\":\n            res.append(obj.flip())\n        elif name == \"reset\":\n            obj.reset()\n            res.append(None)          # reset 回傳 null\n\n    # 輸出結果，使用 JSON 以得到 `null` 形式\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. We must not produce real code. The problem: pick random zero in m*n matrix, flip to 1. Need algorithm that minimizes random calls and time/space.\n\nCommon solution: treat matrix flattened indices 0..m*n-1. Maintain list of available indices: initially all. When flip, choose random index k in [0, remaining-1], map to real index via array mapping (swap). Keep array of size m*n storing mapping from position to actual index. On reset, reinitialize mapping to identity.\n\nThis uses O(m*n) space but can be optimized with hash map only for used indices.\n\nWe produce virtual code step by step: start class, constructor, init variables: m, n, total, availableIndices array (size m*n), remaining. For flip: if remaining==0 maybe error. Random randIndex = random(0, remaining-1). realIndex = availableIndices[randIndex]. swap availableIndices[randIndex] with availableIndices[remaining-1]. remaining--. convert realIndex to (i,j). return [i,j].\n\nReset: set remaining = total; for i from 0 to total-1: availableIndices[i] = i.\n\nWe need minimal random calls: only one per flip. So algorithm uses one random call.\n\nWe output virtual code lines: start class, etc. Use arrows for flow. Provide explanation after //.\n\nWe need to include Start, End. Also decisions.\n\nLet's write virtual code. We'll use pseudocode.\n\nLines:\n\nStart // 程式開始\n→ Step 1: 定義類別 Solution // 建立類別\n→ Step 2: 定義屬性 m, n, total, remaining, mapping // 保存矩陣尺寸、總數、剩餘可選索引、映射數組\n→ Step 3: 生成建構子 Solution(m, n) // 初始化\n\nWithin constructor:\n→ Step 4: m ← m, n ← n // 設置尺寸\n→ Step 5: total ← m × n // 計算總元素\n→ Step 6: remaining ← total // 所有索引均可用\n→ Step 7: mapping ← 新建陣列 size total // 建立映射陣列\n→ Decision: 是否需要初始化 mapping？ // 確認\n    Yes → Step 8: For i from 0 to total-1: mapping[i] ← i // 初始化映射為 identity\n\nDefine flip():\n→ Step 9: If remaining = 0, 返回 error // 無可用零\n→ Step 10: randIdx ← random(0, remaining-1) // 隨機選擇剩餘索引\n→ Step 11: realIdx ← mapping[randIdx] // 取得實際索引\n→ Step 12: mapping[randIdx] ← mapping[remaining-1] // 把最後一個可用索引搬到被選的位置\n→ Step 13: remaining ← remaining - 1 // 可用索引數減一\n→ Step 14: row ← realIdx ÷ n // 計算行\n→ Step 15: col ← realIdx mod n // 計算列\n→ Step 16: return [row, col] // 返回選中的坐標\n\nDefine reset():\n→ Step 17: remaining ← total // 重置可用索引數\n→ Decision: 是否需要重建 mapping？ // 確認\n    Yes → Step 18: For i from 0 to total-1: mapping[i] ← i // 重新初始化映射\n\nEnd // 程式結束\n\nBut we need arrow style: Start, → etc. We might structure with steps inside functions but keep arrow for control flow. Provide explanation after //.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立解題類別  \n→ Step 2: 定義屬性 m, n, total, remaining, mapping // 保存矩陣尺寸、總數、剩餘可選索引、映射陣列  \n→ Step 3: 生成建構子 Solution(m, n) // 初始化物件  \n\n→   Step 4: m ← m, n ← n // 設定行列數  \n→   Step 5: total ← m × n // 計算矩陣總元素數  \n→   Step 6: remaining ← total // 所有索引一開始都是可用  \n→   Step 7: mapping ← 新建陣列 size total // 建立映射陣列，初始為 identity  \n→   Decision: 是否需要初始化 mapping？  \n  Yes → Step 8: For i from 0 to total-1: mapping[i] ← i // 將 mapping[i] 初始化為 i  \n\n→ Step 9: 定義函式 flip() // 隨機選取一個 0 並翻轉為 1  \n  → Decision: remaining == 0? // 檢查是否還有未翻轉的元素  \n   Yes → Step 10: Return error 或特殊值 // 沒有可用索引  \n   No  → Step 11: randIdx ← random(0, remaining-1) // 只呼叫一次隨機，選擇剩餘索引  \n    → Step 12: realIdx ← mapping[randIdx] // 取得實際的行列索引  \n    → Step 13: mapping[randIdx] ← mapping[remaining-1] // 把最後一個可用索引移到 randIdx 位置  \n    → Step 14: remaining ← remaining - 1 // 可用索引數減一  \n    → Step 15: row ← realIdx ÷ n // 計算行  \n    → Step 16: col ← realIdx mod n // 計算列  \n    → Step 17: Return [row, col] // 回傳選中的座標  \n\n→ Step 18: 定義函式 reset() // 將所有元素重設為 0  \n  → Step 19: remaining ← total // 重置可用索引數  \n  → Decision: 是否需要重新初始化 mapping？  \n   Yes → Step 20: For i from 0 to total-1: mapping[i] ← i // 重建映射陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Restore IP Addresses",
      "source_file": "Leetcode/leetcode93.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpidbwofgp.py\", line 31, in <module>\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9nzsg6o_.py\", line 31, in <module>\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnb4c553_.py\", line 31, in <module>\n    data = sys.stdin.read()\n           ^^^\nNameError: name 'sys' is not defined. Did you forget to import 'sys'?"
        }
      ],
      "generated_code": "import json\nimport re\n\nclass Solution:\n    def restoreIpAddresses(self, s: str):\n        res = []\n\n        def backtrack(start: int, path: list):\n            # 已完成 4 段且已走完所有字元\n            if start == len(s) and len(path) == 4:\n                res.append('.'.join(path))\n                return\n            # 片段數量已超過 4\n            if len(path) >= 4:\n                return\n            # 嘗試長度 1~3\n            for length in range(1, 4):\n                if start + length > len(s):\n                    break\n                part = s[start:start + length]\n                # 前導零且長度 >1 或超過 255\n                if (part.startswith('0') and len(part) > 1) or int(part) > 255:\n                    continue\n                backtrack(start + length, path + [part])\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入，提取其中的數字作為字串\n    data = sys.stdin.read()\n    s = ''.join(re.findall(r'\\d', data))\n    solution = Solution()\n    output = solution.restoreIpAddresses(s)\n    # 使用 json.dumps 輸出符合題目示例的格式\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that given string of digits, returns all possible valid IP addresses by inserting dots. We must not output actual code but virtual code with explanations. Each line includes virtual step and comment. Use arrows and decisions.\n\nWe need to cover algorithm: iterate over positions for first, second, third dot; check each part valid length 1-3, numeric value <=255, no leading zero except zero itself; if all four parts valid, combine. Then output list.\n\nAlso could use recursion/backtracking but easier with nested loops.\n\nWe'll produce Start, nested loops, decisions.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty result list // list of IP addresses\n\n→ Decision: if length of s < 4 or >12? // Because 4 to 12 digits required\n    Yes → End // impossible, return empty\n\nWe can do loops: for i from 1 to 3 (first segment length)\n    for j from i+1 to i+3 (second segment length)\n        for k from j+1 to j+3 (third segment length)\n            segment4 start = k+1, ensure <=12\n\nCheck each segment validity function valid(segment):\n\n-> if segment starts with '0' and length >1 -> false\n-> parse integer; if >255 -> false\n-> else true\n\nThen if all four valid, combine s[0:i] + '.' + s[i:j] + '.' + s[j:k] + '.' + s[k:]\n\nAdd to result.\n\nThen End.\n\nBut we need virtual code line by line. Use arrow for loop? They didn't specify loops, but we can use \"→ Loop: i from 1 to 3\" etc. Use indentation to represent nested loops. Use decisions inside.\n\nLet's craft.\n\nExample lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 result 為空陣列 // 用於儲存符合條件的 IP\n→ Decision: 如果 s 的長度 <4 或 >12? // 必要長度檢查\n    Yes → End // 長度不合法，直接結束\n→ Loop i = 1 to 3 // 第一段長度\n    → Decision: 如果 i > len(s)-3? // 剩餘至少三段每段至少1長\n        Yes → No more i // 跳過\n    → Loop j = i+1 to i+3 // 第二段長度\n        → Decision: 如果 j > len(s)-2? // 至少兩段剩餘\n            Yes → No more j\n        → Loop k = j+1 to j+3 // 第三段長度\n            → Decision: 如果 k > len(s)-1? // 至少一段剩餘\n                Yes → No more k\n            → Step 2: 計算 segment1 = s[0:i] // 第一段\n            → Step 3: 計算 segment2 = s[i:j] // 第二段\n            → Step 4: 計算 segment3 = s[j:k] // 第三段\n            → Step 5: 計算 segment4 = s[k:len(s)] // 第四段\n            → Decision: 是否 segment1, segment2, segment3, segment4 都有效? // 檢查每段合法性\n                Yes → Step 6: 組合成 ip = segment1+'.'+segment2+'.'+segment3+'.'+segment4 // 完整 IP\n                → Step 7: 加入 ip 至 result // 存入結果\n                No → // 任何段不合法，忽略\n→ End // 程式執行結束\n\nBut we need to define function valid(segment) inline: we could create Decision: 是否 valid(segment1)? etc. Use nested decisions.\n\nWe can break into Decision: If segment1 有效 else skip.\n\nSimpler: Decision: 若 segment1 有效且 segment2 有效且 segment3 有效且 segment4 有效? yes.\n\nBut we need to describe validity check: No leading zeros unless segment == \"0\", numeric <=255.\n\nWe can write a sub-Decision: Check segment validity:\n\n→ Decision: 檢查 segment1 是否有效? // 先檢查第一段\n    Yes → ...\n    No → skip\n\nBut for brevity, we can create a helper.\n\nWe can define:\n\n→ Function: isValid(seg) // returns true/false // 檢查段合法性\n\nBut virtual code: maybe define function.\n\nWe can include:\n\n→ Step X: 定義 isValid(seg) // 檢查是否符合 0-255 且不含前導零\n   // 虛擬步驟: if seg starts with '0' and length >1 return false\n   // if int(seg) >255 return false\n   // else return true\n\nBut we must adhere to format: each line must be a step and comment. We can use arrow, but function definition maybe separate.\n\nLet's produce final answer with lines.\n\nMake sure to include start and end.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 result 為空陣列 // 用於儲存符合條件的 IP  \n→ Decision: 如果 s 的長度 <4 或 >12? // 必要長度檢查  \n    Yes → End // 長度不合法，直接結束  \n→ Function isValid(seg) // 檢查單段是否合法  \n    → Decision: 如果 seg 長度 >1 且 seg[0] == '0'? // 前導零不允許  \n        Yes → Return false // 不合法  \n        No  → Decision: 如果 int(seg) > 255?  \n            Yes → Return false // 數值超過 255  \n            No  → Return true // 合法  \n→ Loop i = 1 to 3 // 第一段長度  \n    → Decision: 如果 i > len(s)-3? // 剩餘至少三段每段至少 1 個字元  \n        Yes → Continue // 跳過此 i，進行下一個 i  \n    → Loop j = i+1 to i+3 // 第二段長度  \n        → Decision: 如果 j > len(s)-2? // 至少兩段剩餘  \n            Yes → Continue // 跳過此 j，進行下一個 j  \n        → Loop k = j+1 to j+3 // 第三段長度  \n            → Decision: 如果 k > len(s)-1? // 至少一段剩餘  \n                Yes → Continue // 跳過此 k，進行下一個 k  \n            → Step 2: segment1 = s[0:i] // 第一段  \n            → Step 3: segment2 = s[i:j] // 第二段  \n            → Step 4: segment3 = s[j:k] // 第三段  \n            → Step 5: segment4 = s[k:len(s)] // 第四段  \n            → Decision: 是否 isValid(segment1) 且 isValid(segment2) 且 isValid(segment3) 且 isValid(segment4)? // 檢查四段合法性  \n                Yes → Step 6: ip = segment1 + '.' + segment2 + '.' + segment3 + '.' + segment4 // 組合完整 IP  \n                → Step 7: result.append(ip) // 加入結果陣列  \n                No → // 任一段不合法，忽略此組合  \n→ End // 程式執行結束"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzl8k3vw1.py\", line 24, in <module>\n    data = list(map(int, sys.stdin.read().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'k'"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvslm4b8v.py\", line 24, in <module>\n    data = list(map(int, sys.stdin.read().split()))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'k'"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def findMaximizedCapital(self, k, W, Profits, Capital):\n        # 將專案按啟動資本排序\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []      # 儲存可啟動專案的利潤（使用最大堆）\n        i = 0\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有目前可啟動的專案加入最大堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])  # 負號實現最大堆\n                i += 1\n            if not max_heap:\n                break  # 沒有可選專案，提前結束\n            # 取利潤最高的專案\n            W += -heapq.heappop(max_heap)\n        return W\n\nif __name__ == \"__main__\":\n    data = list(map(int, sys.stdin.read().split()))\n    if not data:\n        sys.exit()\n    k, w = data[0], data[1]\n    rest = data[2:]\n    n = len(rest) // 2\n    profits = rest[:n]\n    capital = rest[n:]\n    solution = Solution()\n    result = solution.findMaximizedCapital(k, w, profits, capital)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for algorithm to maximize capital with k projects: typical solution: use min-heap sorted by capital, max-heap sorted by profit. Steps: sort projects by capital ascending. Use index i to push all with capital <= current capital into max-heap (profits). Then pick max profit up to k times. Return capital. Need to output in specified format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, Yes →, No → etc.\n\nWe need to produce lines. Let's draft.\n\nStart // 程式開始執行\n→ Step 1: 將所有項目對 (capital, profit) 依 capital 升序排序 // 方便後續挑選可行項目\n→ Step 2: 初始化 maxHeap 為空 // 用來存已可啟動項目的利潤\n→ Step 3: 初始化 i = 0 // 指向排序後項目陣列的索引\n→ Step 4: 針對 t = 1 到 k 迴圈 // 進行最多 k 次選擇\n    → Decision: 是否還有項目可選? // 判斷是否已經選完 k 個\n        No  → End // 若已達 k，結束\n        Yes → Step 5: 將所有 capital[i] <= currentCapital 的項目 push profit 到 maxHeap, 並遞增 i // 把目前可啟動的項目加入最大堆\n        → Decision: maxHeap 是否非空? // 是否有可選的項目\n            No  → Break // 若無可啟動項目，跳出循環\n            Yes → Step 6: pop 最大利潤 from maxHeap，並加到 currentCapital // 執行最利潤項目\n→ Step 7: 回傳 currentCapital // 返回最終資本\nEnd // 程式結束\n\nBut we need to use arrow syntax like \"→ Decision:\" and sub-indentation. Provide consistent format.\n\nLet's structure as:\n\nStart // 程式開始執行\n→ Step 1: Sort projects by capital ascending // 以利後續挑選\n→ Step 2: maxProfitHeap ← Empty // 儲存已可啟動項目的利潤\n→ Step 3: i ← 0 // 指向排序後的項目\n→ Step 4: t ← 1 // 迴圈變數，表示已選擇的項目數\n→ Decision: t ≤ k? // 檢查是否還能選\n    Yes → Step 5: While i < n and projects[i].capital ≤ capital do\n                → maxProfitHeap.push(projects[i].profit) // 加入可啟動項目\n                → i ← i + 1\n            End While // 將所有可啟動項目加入堆\n    No  → End // 已達 k，結束\n\nBut we need each line after '→' is separate line. We need to embed loops and decisions properly.\n\nLet's design pseudo code with indent levels. Use \"→\" for each line after Start, but nested lines should start with \"→\" too. We can show indentation via spaces.\n\nWe need to follow the format: each line \"虛擬碼步驟 [space] // 解釋\". Use \"→\" before step lines? In example, they used \"→ Step 1: ...\". For nested, they used indentation spaces before \"Yes →\" etc. We'll replicate.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: projects ← (capital, profit) pairs // 取得所有項目資料\n→ Step 2: sort projects by capital ascending // 方便後續判斷可啟動條件\n→ Step 3: maxHeap ← empty // 儲存已可啟動項目的利潤，取最大值\n→ Step 4: i ← 0 // 指向 projects 陣列的下標\n→ Step 5: currentCapital ← w // 初始資本\n→ Step 6: for count from 1 to k do // 進行最多 k 次選擇\n    → Decision: 是否已完成 k 次選擇? // 檢查迴圈條件\n        No  → Step 6.1: while i < n and projects[i].capital ≤ currentCapital do // 將所有可啟動項目加入堆\n                → maxHeap.push(projects[i].profit) // 加入利潤\n                → i ← i + 1\n            End While // 所有可啟動項目已加入\n        Yes → No operation? // Actually loop handles\n    → Decision: maxHeap 是否為空? // 檢查是否有可選項目\n        No  → Step 6.2: profit ← maxHeap.pop() // 取最大利潤\n        Yes → Break // 若無可選項目，跳出循環\n    → Step 6.3: currentCapital ← currentCapital + profit // 取得利潤，更新資本\n→ Step 7: return currentCapital // 回傳最終資本\nEnd // 程式結束\n\nBut the indentation and arrow formatting may be wrong. We need to match example: They use:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n\nSo nested indentation: lines indented by one space before \"Yes →\". For loops, we might do \"→ Step 6: for count from 1 to k do // 進行最多 k 次選擇\" then indent inside the for block? But the format not strict about loops; we can treat as nested Decision with Yes/No. But loops might be represented as repeated Steps within loop? We can simplify: use while loop as Decision block.\n\nSimplify: Use a while loop: While count <= k and maxHeap not empty.\n\nWe can do:\n\n→ Step 4: count ← 0 // 已選擇項目數\n\n→ Decision: count < k? // 是否還能選\n    Yes → Step 5: while i < n and projects[i].capital ≤ currentCapital do\n            → maxHeap.push(projects[i].profit) // 加入可啟動項目\n            → i ← i + 1\n        End While\n        → Decision: maxHeap 非空?\n            Yes → Step 6: profit ← maxHeap.pop() // 取最大利潤\n                → currentCapital ← currentCapital + profit\n                → count ← count + 1\n                → Repeat Decision: count < k? // 重新判斷\n            No  → Break // 無可選項目，結束\n    No  → End // 迴圈結束\n\nBut this seems complex.\n\nSimpler: Represent algorithm as sequential steps with Decision loops:\n\nStart\n→ Step 1: sort projects by capital\n→ Step 2: maxHeap ← empty\n→ Step 3: i ← 0\n→ Step 4: currentCapital ← w\n→ Step 5: count ← 0\n→ Decision: count < k? // 是否還可以選\n    No → End // 若已選 k 個，結束\n    Yes → Step 6: while i < n and projects[i].capital ≤ currentCapital do\n                → maxHeap.push(projects[i].profit) // 加入可啟動項目\n                → i ← i + 1\n            End While\n        → Decision: maxHeap 非空?\n            No  → Break // 無可啟動項目，結束\n            Yes → Step 7: profit ← maxHeap.pop() // 取最大利潤\n                → currentCapital ← currentCapital + profit\n                → count ← count + 1\n                → Repeat Decision: count < k? // 重新判斷\n→ Step 8: return currentCapital\nEnd\n\nBut we need to keep each line separate. The 'Repeat Decision' may be ambiguous.\n\nWe can avoid recursion: Use while loop outer: while count < k and maxHeap not empty. Steps inside loop.\n\nBetter: Use pseudo:\n\nStart\n→ Step 1: sort projects by capital ascending\n→ Step 2: maxHeap ← empty\n→ Step 3: i ← 0\n→ Step 4: currentCapital ← w\n→ Step 5: count ← 0\n→ Decision: count < k? // 是否還能選\n    No → End\n    Yes → Step 6: while i < n and projects[i].capital ≤ currentCapital do\n            → maxHeap.push(projects[i].profit)\n            → i ← i + 1\n          End While\n          → Decision: maxHeap is empty?\n              No → Step 7: profit ← maxHeap.pop()\n                  → currentCapital ← currentCapital + profit\n                  → count ← count + 1\n                  → Repeat Decision: count < k? // 重新判斷\n              Yes → Break\n→ Step 8: return currentCapital\nEnd\n\nBut this uses nested decisions and loops. The format may not require perfect syntax, but to show logic.\n\nMaybe we can do simpler representation:\n\nStart\n→ Step 1: sort projects by capital ascending\n→ Step 2: initialize maxHeap empty\n→ Step 3: i = 0, capital = w, chosen = 0\n→ Decision: chosen < k? // 仍有選擇空間\n    Yes → Step 4: while i < n and projects[i].capital ≤ capital do\n            → maxHeap.push(projects[i].profit) // 可啟動項目放入堆\n            → i = i + 1\n          End While\n          → Decision: maxHeap empty? // 有可選項目嗎\n              No → Step 5: capital = capital + maxHeap.pop() // 取最大利潤\n                  → chosen = chosen + 1\n                  → Repeat Decision: chosen < k? // 重新檢查\n              Yes → Break // 無可選項目，結束\n    No → End // 已選 k 個，結束\n→ Step 6: return capital\nEnd\n\nWe need to ensure each line includes \"虛擬碼步驟 // 解釋\". We need to write in Chinese, short explanation.\n\nWe need to ensure we have '→' preceding each line after start. For nested lines, indent with a space before 'Yes →' or 'No →', but still have '→' after indent? In example, they used:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nThey had 'Yes →' and 'No  →' with spaces before arrow. So we should replicate. So for outer Decision we have:\n\n→ Decision: chosen < k? // 仍有選擇空間\n    Yes → Step 4: while i < n and projects[i].capital ≤ capital do\n            → maxHeap.push(projects[i].profit) // ...\n            → i = i + 1\n          End While\n          → Decision: maxHeap empty? // ...\n              No → Break\n              Yes → Step 5: capital = capital + maxHeap.pop()\n                    → chosen = chosen + 1\n                    → Repeat Decision: chosen < k? // loop back\nBut formatting is getting messy.\n\nAlternatively, we could avoid nested loops and use repeated decision until no more options or k reached. Represent as:\n\nStart\n→ Step 1: sort projects by capital ascending\n→ Step 2: maxHeap ← empty\n→ Step 3: i ← 0\n→ Step 4: currentCapital ← w\n→ Step 5: chosen ← 0\n→ Decision: chosen < k and maxHeap non-empty? // 有可選項目且未達 k\n    No  → End // 結束\n    Yes → Step 6: while i < n and projects[i].capital ≤ currentCapital do\n            → maxHeap.push(projects[i].profit)\n            → i ← i + 1\n          End While\n          → Decision: maxHeap non-empty? // 是否有可選項目\n              No  → End // 無可選項目，結束\n              Yes → Step 7: profit ← maxHeap.pop()\n                    → currentCapital ← currentCapital + profit\n                    → chosen ← chosen + 1\n                    → Repeat Decision: chosen < k and maxHeap non-empty? // 回到判斷\n→ Step 8: return currentCapital\nEnd\n\nWe still have repeated Decision loops. It's okay.\n\nBut we need each line individually. Provide lines for each step. Ensure that after \"End While\" we still have a line.\n\nBut each line after Start should include \"→\" or indent lines with \"    \" before \"Yes →\" etc.\n\nLet's produce final answer.\n\nMake sure to use Chinese and short explanation.\n\nLet's construct final list:\n\n1. Start // 程式開始執行\n2. → Step 1: projects ← (capital, profit) pairs // 取得所有項目資料\n3. → Step 2: sort projects by capital ascending // 方便後續判斷可啟動條件\n4. → Step 3: maxHeap ← empty // 儲存已可啟動項目的利潤\n5. → Step 4: i ← 0 // 指向排序後的項目\n6. → Step 5: currentCapital ← w // 初始資本\n7. → Step 6: chosen ← 0 // 已選擇項目數\n8. → Decision: chosen < k? // 是否還能選\n   9. No  → End // 已選 k 個，結束\n   10. Yes → Step 7: while i < n and projects[i].capital ≤ currentCapital do\n           → maxHeap.push(projects[i].profit) // 加入可啟動項目\n           → i ← i + 1\n         End While\n         → Decision: maxHeap 非空? // 是否有可選項目\n             No  → End // 無可選項目，結束\n             Yes → Step 8: profit ← maxHeap.pop() // 取最大利潤\n                 → currentCapital ← currentCapital + profit // 更新資本\n                 → chosen ← chosen + 1 // 更新已選項目數\n                 → Repeat Decision: chosen < k? // 重新判斷\n11. → Step 9: return currentCapital // 回傳最終資本\n12. End // 程式結束\n\nWe need each line with \"虛擬碼步驟 // 解釋\". For lines 10 and 11 we have nested lines. We must keep them as separate lines, each starting with \"→\" or indent with \"    \" for nested.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: projects ← (capital, profit) pairs // 取得所有項目資料\n→ Step 2: sort projects by capital ascending // 方便後續判斷可啟動條件\n→ Step 3: maxHeap ← empty // 儲存已可啟動項目的利潤\n→ Step 4: i ← 0 // 指向排序後的項目\n→ Step 5: currentCapital ← w // 初始資本\n→ Step 6: chosen ← 0 // 已選擇項目數\n→ Decision: chosen < k? // 是否還能選\n    No  → End // 已選 k 個，結束\n    Yes → Step 7: while i < n and projects[i].capital ≤ currentCapital do\n            → maxHeap.push(projects[i].profit) // 加入可啟動項目\n            → i ← i + 1\n          End While\n          → Decision: maxHeap 非空? // 是否有可選項目\n              No  → End // 無可選項目，結束\n              Yes → Step 8: profit ← maxHeap.pop() // 取最大利潤\n                  → currentCapital ← currentCapital + profit // 更新資本\n                  → chosen ← chosen + 1 // 更新已選項目數\n                  → Repeat Decision: chosen < k? // 重新判斷\n→ Step 9: return currentCapital // 回傳最終資本\nEnd // 程式結束\n\nBut we still have \"Repeat Decision\" which is not standard. Might be better to simply loop back to Decision line. But it's okay.\n\nLet's provide this as final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: projects ← (capital, profit) pairs // 取得所有項目資料  \n→ Step 2: sort projects by capital ascending // 方便後續判斷可啟動條件  \n→ Step 3: maxHeap ← empty // 儲存已可啟動項目的利潤  \n→ Step 4: i ← 0 // 指向排序後的項目  \n→ Step 5: currentCapital ← w // 初始資本  \n→ Step 6: chosen ← 0 // 已選擇項目數  \n→ Decision: chosen < k? // 是否還能選  \n    No  → End // 已選 k 個，結束  \n    Yes → Step 7: while i < n and projects[i].capital ≤ currentCapital do  \n            → maxHeap.push(projects[i].profit) // 加入可啟動項目  \n            → i ← i + 1  \n          End While  \n          → Decision: maxHeap 非空? // 是否有可選項目  \n              No  → End // 無可選項目，結束  \n              Yes → Step 8: profit ← maxHeap.pop() // 取最大利潤  \n                  → currentCapital ← currentCapital + profit // 更新資本  \n                  → chosen ← chosen + 1 // 更新已選項目數  \n                  → Repeat Decision: chosen < k? // 重新判斷  \n→ Step 9: return currentCapital // 回傳最終資本  \nEnd // 程式結束"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfuce8g_l.py\", line 44, in parse_input\n    return ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpfuce8g_l.py\", line 51, in <module>\n    params = parse_input(raw_input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfuce8g_l.py\", line 46, in parse_input\n    raise ValueError(f\"無法解析輸入: {raw}\") from e\nValueError: 無法解析輸入: {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnp6dphtz.py\", line 44, in parse_input\n    return ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpnp6dphtz.py\", line 51, in <module>\n    params = parse_input(raw_input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnp6dphtz.py\", line 46, in parse_input\n    raise ValueError(f\"無法解析輸入: {raw}\") from e\nValueError: 無法解析輸入: {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\ndef ladder_length(begin_word: str, end_word: str, word_list):\n    \"\"\"\n    找出從 begin_word 到 end_word 的最短轉換步數。\n    每一步只能改變一個字母，且中間所有單字必須在 word_list 裡。\n    若無法轉換則回傳 0。\n    \"\"\"\n    word_set = set(word_list)\n    if end_word not in word_set:\n        return 0\n\n    queue = deque([(begin_word, 1)])   # (目前單字, 路徑長度)\n    visited = {begin_word}\n\n    while queue:\n        word, length = queue.popleft()\n        if word == end_word:\n            return length\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c == word[i]:\n                    continue\n                new_word = word[:i] + c + word[i+1:]\n                if new_word in word_set and new_word not in visited:\n                    visited.add(new_word)\n                    queue.append((new_word, length + 1))\n    return 0\n\ndef parse_input(raw):\n    \"\"\"\n    將輸入字串轉成字典，例如：\n    'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]'\n    會被轉成 {'beginWord': 'hit', 'endWord': 'cog', 'wordList': ['hot', 'dot']}\n    \"\"\"\n    if not raw:\n        return {}\n    # 將鍵值對包裝成 dict 格式，並用 literal_eval 解析\n    raw = raw.strip()\n    raw = '{' + raw + '}'\n    try:\n        return ast.literal_eval(raw)\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {raw}\") from e\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input_data = sys.stdin.read()\n    params = parse_input(raw_input_data)\n\n    begin = params.get('beginWord')\n    end = params.get('endWord')\n    word_list = params.get('wordList', [])\n\n    # 檢查必填參數是否完整\n    if begin is None or end is None or not isinstance(word_list, list):\n        print(0)\n    else:\n        result = ladder_length(begin, end, word_list)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for shortest transformation sequence length. Essentially BFS. Steps: check endWord in list. Use set for wordList. Use queue of (word, depth). visited set. While queue, pop. If word==endWord return depth. For each letter position generate neighbors by replacing each letter a-z, if neighbor in wordList and not visited, add to queue with depth+1, mark visited. If finished return 0.\n\nWe'll produce lines starting with Start. Use arrow lines. Indentation for Decision branches. Ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow. Let's craft.\n\nMake sure to not include actual code, just virtual.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 endWord 是否在 wordList 內 // 若不存在則無法轉換  \n→ Decision: endWord 在 wordList?  \n  Yes → Step 2: 建立 wordSet 為 wordList 的集合 // 方便 O(1) 查詢  \n  No  → End // 直接結束並回傳 0  \n→ Step 3: 建立 visited 集合並加入 beginWord // 避免重複訪問  \n→ Step 4: 建立 queue 並將 (beginWord, 1) 入列 // 1 表示第一個單詞  \n→ Decision: queue 是否為空?  \n  Yes → End // queue 為空，無法到達 endWord，回傳 0  \n  No  → Loop  \n    → Step 5: 取出 queue 前端的 (currentWord, currentLen)  \n    → Decision: currentWord 是否等於 endWord?  \n      Yes → End // 找到最短路徑，回傳 currentLen  \n      No  → Step 6: 為 currentWord 的每個字母位置 i  \n       → Step 7: 對每個字母 'a' 到 'z'  \n        → Decision: 替換後的新字母是否不同於原字母?  \n          Yes → Step 8: 生成 newWord  \n          → Decision: newWord 在 wordSet 且未被 visited?  \n            Yes → Step 9: 加入 visited，將 (newWord, currentLen+1) 入列  \n            No  → Continue // 忽略已訪問或不在字典的單詞  \n            No → Continue  \n        No → Continue  \n      → End Loop  \n→ End // 所有可能已嘗試完畢，無法到達 endWord，回傳 0"
    },
    {
      "title": "K-th Smallest in Lexicographical Order",
      "source_file": "Leetcode/leetcode440.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp449zg9ry.py\", line 40, in <module>\n    n, k = map(int, data[:2])\n    ^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7676y9ub.py\", line 40, in <module>\n    n, k = map(int, data[:2])\n    ^^^^\nValueError: invalid literal for int() with base 10: 'n'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \"\"\"\n        找到 1~n 之間按字典序排列後第 k 個數字。\n        \"\"\"\n        def count_prefix(prefix: int, n: int) -> int:\n            \"\"\"\n            計算所有以 prefix 為前綴且不超過 n 的整數數量。\n            \"\"\"\n            cur = prefix\n            nxt = prefix + 1\n            cnt = 0\n            while cur <= n:\n                cnt += min(n + 1, nxt) - cur\n                cur *= 10\n                nxt *= 10\n            return cnt\n\n        curr = 1          # 從 1 開始\n        k -= 1            # 轉成 0‑based\n        while k > 0:\n            cnt = count_prefix(curr, n)\n            if k >= cnt:\n                # 跳過整棵子樹\n                k -= cnt\n                curr += 1\n            else:\n                # 進入子樹\n                k -= 1\n                curr *= 10\n        return curr\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().split()\n    if not data:\n        sys.exit()\n    # 只取前兩個整數作為 n 和 k\n    n, k = map(int, data[:2])\n    ans = Solution().findKthNumber(n, k)\n    print(ans)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for: given n and k, return kth lexicographically smallest integer in [1, n]. This is classic lexicographic order counting: use DFS, count nodes.\n\nWe need step-by-step logic. Steps: define function countPrefix(prefix, n): returns number of integers starting with prefix up to n. Use formula. Then iterate from 1 to 10? Actually algorithm: start with curr=1, steps=1? Let's outline typical solution:\n\n1. Initialize current=1, rank=1\n2. While rank < k:\n   - Compute steps = countSteps(current, current+1, n)\n   - If rank + steps <= k:\n       current +=1\n       rank += steps\n     else:\n       current *=10\n       rank +=1\n3. Return current\n\nBut we need lexicographic kth. Implementation details: countSteps(current, next, n):\n steps=0\n while current <= n:\n    steps += min(n+1, next) - current\n    current *=10\n    next *=10\n return steps\n\nBut we must produce virtual code step by step, with explanations. Let's produce:\n\nStart\n→ Step 1: Input n and k\n→ Step 2: Define function countSteps(prefix, next, limit)\n    → Step 3: Initialize steps=0\n    → Step 4: While prefix <= limit:\n        → Step 5: steps += min(limit+1, next) - prefix\n        → Step 6: prefix *=10\n        → Step 7: next *=10\n    → Step 8: Return steps\n→ Step 9: Set current=1, rank=1\n→ Decision: 是否已經到達第k個? (rank == k)\n    Yes → Step 10: Return current\n    No → Step 11: Compute steps = countSteps(current, current+1, n)\n→ Decision: rank + steps <= k ?\n    Yes → Step 12: current +=1\n           Step 13: rank += steps\n           → Go back to Decision rank==k\n    No → Step 14: current *=10\n           Step 15: rank +=1\n           → Go back to Decision rank==k\nEnd\n\nBut we need to ensure we handle rank==k? Actually rank starts at 1. At each iteration we check if rank == k. If so return. But after updating rank, we might check again. Implementation wise, loop until rank == k. So we can use while rank < k: compute steps etc. So simpler:\n\n→ Decision: rank < k ?\n    Yes → ...\n    No → Step 16: Return current\n\nLet's craft accordingly. Provide each line with arrow or indentation. Use indentation for decision branches.\n\nWe should output lines exactly with \"虛擬碼步驟\" plus explanation. Use `→` arrow. Provide step numbers optional? But example uses \"Step 1:\". We'll follow same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input integers n 和 k // 取得搜尋範圍上限與目標順位\n→ Step 2: Define function countSteps(prefix, next, limit) // 計算以 prefix 為前綴且不超過 limit 的數字總數\n    → Step 3: Initialize steps = 0 // 步驟計數器\n    → Step 4: While prefix ≤ limit:\n        → Step 5: steps += min(limit + 1, next) - prefix // 加入本層級可取的數量\n        → Step 6: prefix *= 10 // 進入下一個十倍級\n        → Step 7: next   *= 10 // 更新下一個前綴上限\n    → Step 8: Return steps // 回傳本前綴下可取的總數\n→ Step 9: Set current = 1, rank = 1 // 從第一個數字開始，排名已知為1\n→ Decision: rank < k? // 尚未到達第 k 個\n    Yes → Step 10: steps = countSteps(current, current + 1, n) // 計算以 current 為前綴的整個子樹大小\n    → Decision: rank + steps ≤ k? // 能否直接跳過整棵子樹\n        Yes → Step 11: current += 1 // 跳到下一個兄弟節點\n               Step 12: rank += steps // 排名更新為子樹末尾之後的位置\n        No  → Step 13: current *= 10 // 進入子樹，前綴加一個0\n               Step 14: rank += 1 // 進入子樹時的排名加1（即走進第一個子節點）\n    → Go back to Decision: rank < k? // 重複判斷\n    No  → Step 15: Return current // 已達到第 k 個，輸出結果\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立一個字典，把每個數值對應到其所有索引的列表\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 從對應索引列表中隨機挑選一個\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入：分離方法列表和參數列表\n    if '\\n' in data:\n        parts = data.splitlines()\n    else:\n        idx = data.find('],')\n        if idx != -1:\n            parts = [data[:idx + 1], data[idx + 2:]]\n        else:\n            parts = [data]\n\n    methods = ast.literal_eval(parts[0])\n    args_list = ast.literal_eval(parts[1]) if len(parts) > 1 else []\n\n    # 執行方法並收集結果\n    result = []\n    obj = None\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(args[0])  # 初始化\n            result.append(None)\n        else:\n            result.append(getattr(obj, method)(*args))\n\n    # 以 JSON 格式輸出，None 會轉成 null\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Need to generate algorithm: store mapping from number to list of indices during constructor. Then pick picks random index from list. Use random function. So we need to produce steps in pseudo code style with arrows etc. Provide line by line.\n\nThe virtual code format: Each line: \"虛擬碼步驟 // 解釋\". Must use arrows like →, Yes →, No →, Decision: etc. Provide Start and End.\n\nWe can structure:\n\nStart\n→ Step 1: 初始化空字典 mapping // map number to list of indices\n→ Decision: 是否已經處理完陣列? No ... etc.\n\nBut easier: just simple linear pseudocode: Start -> Step 1: Create empty map -> For each index i in nums -> Append i to map[nums[i]] -> End.\n\nThen pick method: Start -> Retrieve list = mapping[target] -> RandomIndex = random choice from list -> Return RandomIndex -> End.\n\nBut need to use arrows for steps: \"→ Step 1: 初始化映射\" etc.\n\nLet's produce step lines.\n\nAlso need to mention randomness: \"Random\" maybe a function.\n\nLet's produce:\n\nStart\n→ Step 1: Create empty dictionary mapping // 建立一個空字典存放數值到其索引的映射\n→ Step 2: For i from 0 to length(nums)-1 // 遍歷整個陣列\n    → Decision: 如果 mapping 已包含 nums[i]? // 判斷該數值是否已在字典\n        Yes → Step 3a: mapping[nums[i]].append(i) // 已存在，將索引追加到現有列表\n        No  → Step 3b: mapping[nums[i]] = [i] // 不存在，創建新列表並加入索引\n→ End // 完成建構\n\nDefine pick method:\n\n→ Step 4: Retrieve list indices = mapping[target] // 取得目標值對應的索引列表\n→ Step 5: RandomIndex = random.choice(indices) // 隨機從列表中挑選一個索引\n→ Step 6: Return RandomIndex // 回傳隨機選取的索引\n\nBut we need to maintain \"虛擬碼步驟\" each line. For each line we need to include arrow, step, // explanation.\n\nWe can combine multiple nested steps in a single line? Usually each line is separate. But we can include nested decision as separate lines. Example earlier.\n\nWe will produce multiple lines for each decision.\n\nWe must ensure arrow usage. Use \"→\" for steps, \"Decision:\" for decisions, \"Yes →\", \"No →\".\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: mapping = {} // 建立空字典\n→ For i in range(len(nums)) // 逐一遍歷陣列\n    → Decision: 是否已經存在 mapping[nums[i]]? // 檢查是否已有該數值的索引列表\n        Yes → mapping[nums[i]].append(i) // 已存在，加入索引\n        No  → mapping[nums[i]] = [i] // 不存在，創建新列表\n→ End // 完成初始化\n\nDefine pick:\n\n→ Step 2: indices = mapping[target] // 取得所有對應索引\n→ Step 3: idx = random.choice(indices) // 隨機選一個\n→ Return idx // 回傳結果\n\nBut we need to indicate that these steps are inside class methods. We can add comments accordingly.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: mapping = {} // 建立一個空字典，用來存放每個數值對應的索引列表  \n→ For i in range(len(nums)) // 逐一遍歷陣列 nums  \n  → Decision: mapping 已存在 nums[i] 的鍵? // 判斷這個數值是否已經在字典中  \n   Yes → mapping[nums[i]].append(i) // 已存在，將目前索引 i 加入對應的列表  \n   No  → mapping[nums[i]] = [i] // 不存在，建立新列表並加入索引 i  \n→ End // 完成物件初始化，已把所有索引映射好  \n\n//---------------------------  \nStart // pick 方法開始執行  \n→ Step 2: indices = mapping[target] // 取得 target 所對應的所有索引列表  \n→ Step 3: idx = random.choice(indices) // 隨機從列表中挑選一個索引  \n→ Return idx // 回傳隨機選到的索引  \nEnd // pick 方法執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    Sort characters in `s` by decreasing frequency.\n    \"\"\"\n    # Count each character's frequency\n    counter = Counter(s)\n    # Build the result using most_common which returns (char, freq) sorted by freq desc\n    return ''.join(char * freq for char, freq in counter.most_common())\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # The input may be of the form: s = \"tree\"\n    # Extract the string value between the first pair of double quotes.\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = raw_input[first_quote + 1 : last_quote]\n    else:\n        # If no quotes are present, assume the whole input is the string\n        s = raw_input\n\n    # Compute the frequency‑sorted string\n    result = frequency_sort(s)\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: given string s, sort it by decreasing frequency. We need steps: start, input string, count frequencies, create list of (char, count), sort descending by count, build result string. Need virtual code lines. Use Start, Decision, Step, etc. Each line with arrow and explanation. Use simple structure.\n\nWe'll produce steps:\n\nStart\n\n→ Step 1: Receive input string s\n\n→ Step 2: Initialize frequency map freq\n\n→ Step 3: For each character c in s: increment freq[c]\n\n→ Step 4: Create list chars from keys of freq\n\n→ Step 5: Sort chars by freq descending\n\n→ Step 6: Initialize result string res\n\n→ Step 7: For each character c in sorted chars: repeat c freq[c] times and append to res\n\n→ End // return res\n\nBut we also need explanation for each line. Use \"虛擬碼步驟\" + space + \"// 解釋\". So each line will have code like \"Start // 程式開始執行\". Use arrow \"→\". Provide decision? There are no decisions except maybe sorting but that's algorithmic.\n\nWe need to follow output format: each line start with Start or arrow then step.\n\nMake sure to include explanation in Chinese.\n\nAlso we can include decision: if s empty? maybe handle but not necessary.\n\nI'll produce maybe a Decision: if s empty? But not required.\n\nWe just produce straightforward algorithm.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得待排序的字串  \n→ Step 2: 初始化頻率字典 freq ← {} // 用於計算每個字元出現次數  \n→ Step 3: For each 字元 c in s: freq[c] ← freq.get(c, 0) + 1 // 統計字元頻率  \n→ Step 4: 建立字元列表 chars ← list(freq.keys()) // 取得所有不同字元  \n→ Step 5: Sort chars 依 freq[字元] 降序 // 依頻率從高到低排序  \n→ Step 6: 初始化結果字串 res ← \"\" // 用於累積排序後的字元  \n→ Step 7: For each 字元 c in chars:  \n  → Append c repeated freq[c] 次到 res // 依頻率重複字元並加入結果  \n→ End // 回傳 res，完成頻率降序排序的字串"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        # 建立字串逆序到索引的對應表\n        rev_index = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        def is_palindrome(s: str) -> bool:\n            return s == s[::-1]\n\n        # 遍歷每個字串\n        for i, word in enumerate(words):\n            n = len(word)\n            # split 從 0 到 n（包含 n）\n            for j in range(n + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 若 prefix 為回文，則查找 suffix 的逆序\n                if is_palindrome(prefix):\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_index:\n                        idx = rev_index[rev_suffix]\n                        if idx != i:\n                            res.append([idx, i])\n\n                # 若 suffix 為回文且不是空字串，則查找 prefix 的逆序\n                if j != n and is_palindrome(suffix):\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_index:\n                        idx = rev_index[rev_prefix]\n                        if idx != i:\n                            res.append([i, idx])\n\n        return res\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含 \"words = \"，則去除等號前的部分\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n\n    # 安全解析字串為 Python 物件\n    try:\n        words = ast.literal_eval(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    if not isinstance(words, list):\n        print(\"Input must be a list of strings.\", file=sys.stderr)\n        return\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce pseudocode steps with explanations. Algorithm: For each word, reverse it, map reversed to index. For each word, for each split (including empty), check prefix palindrome etc. Need to output steps. We need to use the format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows.\n\nWe need to outline algorithm: Build hash map of reversed words to index. Then for each word, iterate splits from 0 to len, check if prefix is palindrome then if suffix reversed exists and index != current. Similarly for suffix palindrome. Also handle whole word reversed equal case.\n\nWe need O(total length). So loops linear.\n\nLet's produce steps:\n\nStart\n\n→ Build map reversed_word_to_index\n\n→ For each word with index i in words:\n\n    → For each split position j from 0 to len(word):\n\n        → Let prefix = word[0:j], suffix = word[j:]\n\n        → If prefix is palindrome:\n\n            → reversed_suffix = reverse(suffix)\n\n            → If reversed_suffix exists in map and map[reversed_suffix] != i:\n\n                → Add pair (map[reversed_suffix], i)\n\n        → If suffix is palindrome AND j != len(word):\n\n            → reversed_prefix = reverse(prefix)\n\n            → If reversed_prefix exists and != i:\n\n                → Add pair (i, map[reversed_prefix])\n\nEnd\n\nNeed to mention return result.\n\nWe must include each step line.\n\nLet's produce.\n\nNote: Use decision arrow.\n\nWe should use indent for nested steps? The format example uses indentation for decisions.\n\nWe'll produce lines accordingly.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 hash map `revIndex`，將每個字串 `words[k]` 的逆序 `reverse(words[k])` 作為 key，`k` 作為 value // 建立逆序到索引的對應表  \n→ Decision: `revIndex` 建好? // 檢查映射表是否建立完成  \n    Yes → Step 2: 初始化空陣列 `result` 用於存放所有符合條件的 (i, j) // 準備儲存結果  \n→ Step 3: 遍歷每個單字 `word` 及其索引 `i` in words // 為每個字串做處理  \n    → Decision: 對於 `word`，從 split 位置 `j = 0` 到 `j = len(word)` // 逐位分割字串  \n        Yes → Step 4: 計算 `prefix = word[0:j]` 與 `suffix = word[j:]` // 取得前後兩段  \n        → Decision: `prefix` 是否為回文? // 檢查前半段是否為回文  \n            Yes → Step 5: 計算 `revSuffix = reverse(suffix)` // 取後半段逆序  \n            → Decision: `revSuffix` 是否存在於 `revIndex` 且索引 ≠ `i`? // 檢查是否有對應的逆序字串  \n                Yes → Step 6: 將 `(revIndex[revSuffix], i)` 加入 `result` // 找到符合條件的對  \n                No → Step 7: 跳過此分割 // 沒有對應逆序字串  \n        No → Step 8: 跳過前半段檢查 // 前半段不是回文，忽略此分割  \n        → Decision: `suffix` 是否為回文且 `j != len(word)`? // 檢查後半段是否為回文，且不為整個字串  \n            Yes → Step 9: 計算 `revPrefix = reverse(prefix)` // 取前半段逆序  \n            → Decision: `revPrefix` 是否存在於 `revIndex` 且索引 ≠ `i`? // 檢查是否有對應的逆序字串  \n                Yes → Step 10: 將 `(i, revIndex[revPrefix])` 加入 `result` // 找到符合條件的對  \n                No → Step 11: 跳過此分割 // 沒有對應逆序字串  \n            No → Step 12: 跳過後半段檢查 // 後半段不是回文或是整個字串  \n→ Step 13: 回傳 `result` // 回傳所有找到的回文對  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef find_lus_length(strs):\n    \"\"\"返回最長不常見子序列的長度，若不存在則返回 -1。\"\"\"\n    # 計算每個字串出現的次數\n    freq = Counter(strs)\n\n    max_len = -1\n    for s in strs:\n        # 只考慮出現次數為 1 的字串\n        if freq[s] == 1:\n            if len(s) > max_len:\n                max_len = len(s)\n\n    return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 若輸入為空，直接輸出 -1\n        print(-1)\n    else:\n        try:\n            # 解析 JSON 格式的字串陣列\n            strs = json.loads(raw_input)\n        except json.JSONDecodeError:\n            # 若解析失敗，視為無效輸入\n            print(-1)\n        else:\n            # 計算並輸出答案\n            result = find_lus_length(strs)\n            print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We need to consider the problem: longest uncommon subsequence among strings in array. Standard known solution: If there is any string that appears exactly once, answer is its length; else -1. Explanation: If duplicate strings, they cannot be uncommon. So algorithm: count frequencies. For each string, if its freq == 1, candidate length = its length, keep max. After loop, if max >0 return max else -1.\n\nEdge: All duplicates -> -1. All unique -> max length.\n\nWe need to produce step-by-step pseudocode with arrows. Should include Start, End, Decision etc.\n\nLet's produce lines:\n\nStart // begin\n→ Step 1: Initialize frequency map // count occurrences of each string\n→ Step 2: For each string s in strs: increment map[s] // counting\n→ Step 3: Initialize maxLen = -1 // store best uncommon length\n→ Step 4: For each string s in strs:\n   → Decision: Is map[s] == 1? // check uniqueness\n        Yes → Step 5: If length(s) > maxLen then maxLen = length(s) // update\n        No → Step 6: Continue // skip duplicates\n→ Step 7: Return maxLen // output result\nEnd // finish\n\nBut we need to maintain the format: each line with virtual code step, space, // explanation. Use arrow and indentation. For nested steps, we can indent.\n\nLet's format: \"Start // 程式開始執行\". Then \"→ Step 1: 初始化頻率字典 freqMap // 用於記錄每個字串出現次數\". Then \"→ Step 2: 對於陣列 strs 中每個字串 s: freqMap[s]++ // 進行計數\". Then \"→ Step 3: 設置變數 maxLen = -1 // 預設為 -1 表示尚未找到不常見子序列\". Then \"→ Step 4: 對於陣列 strs 中每個字串 s:\" (indent). Then \"    → Decision: 若 freqMap[s] == 1? // 判斷字串是否唯一\" Then \"        Yes → Step 5: 若 len(s) > maxLen 則 maxLen = len(s) // 更新最大長度\". Then \"        No → Step 6: 繼續下一個字串 // 跳過重複字串\". Then \"→ Step 7: 返回 maxLen // 輸出結果\" Then \"End // 程式執行結束\".\n\nWe need to keep every line's \"虛擬碼步驟 + 空格 + // 解釋/說明\". Also include arrow and decision.\n\nMake sure to show indentation with spaces. Use \"→\" for steps, \"Decision:\" for decisions, \"Yes →\", \"No →\". Use \"Step X:\" for steps.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率字典 freqMap // 用於記錄每個字串出現次數  \n→ Step 2: 對於陣列 strs 中每個字串 s: freqMap[s]++ // 進行計數  \n→ Step 3: 設置變數 maxLen = -1 // 預設為 -1 表示尚未找到不常見子序列  \n→ Step 4: 對於陣列 strs 中每個字串 s:  \n    → Decision: 若 freqMap[s] == 1? // 判斷字串是否唯一  \n        Yes → Step 5: 若 len(s) > maxLen 則 maxLen = len(s) // 更新最大長度  \n        No → Step 6: 繼續下一個字串 // 跳過重複字串  \n→ Step 7: 返回 maxLen // 輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        找出 DNA 序列中所有重複出現的 10 字母長子字串。\n        \"\"\"\n        seen = set()      # 已經遇到過的子字串\n        repeated = set()  # 重複出現的子字串\n\n        for i in range(len(s) - 9):          # 只考慮能取到 10 個字母的起點\n            seq = s[i:i+10]                   # 取得 10 字母子字串\n            if seq in seen:\n                repeated.add(seq)            # 第二次出現就加入結果\n            else:\n                seen.add(seq)                # 第一次出現\n        return list(repeated)\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取 DNA 序列，輸出所有重複的 10 字母長子字串。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中提取字串：嘗試從單引號中取值，若無則直接使用整行\n    match = re.search(r\"'(.*?)'\", data)\n    if match:\n        dna_sequence = match.group(1)\n    else:\n        dna_sequence = data\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(dna_sequence)\n\n    # 以 JSON 格式輸出結果，符合範例要求\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: given string s, find all 10-letter substrings that occur more than once. Use dictionary to count, iterate. Complexity O(n). Need to output virtual code lines.\n\nWe will produce steps: Start, Step 1: initialize set, etc. Use decision points. Provide comments. Ensure each line: virtual code + space + // explanation. Use arrows.\n\nLet's produce steps:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 從使用者或函式取得 DNA 序列\n→ Decision: 是否 s 長度小於 10? // 檢查是否有足夠長度產生子字串\n    Yes → Step 2: 返回空集合 // 若不足 10 個字母，無重複子字串\n    No  → Step 3: 初始化 map counter ← 空字典 // 用於計數子字串出現次數\n→ Step 4: 初始化結果集合 results ← 空集合 // 用於儲存重複子字串\n→ Decision: 設定 i ← 0, n ← 長度(s) // 變數 i 為迴圈索引\n    Yes → Step 5: 迴圈條件 i ≤ n - 10 // 只考慮能取到 10 字母的起點\n        Yes → Step 6: sub ← s.substring(i, i+10) // 取得 10 字母子字串\n        → Step 7: counter[sub] ← counter.getOrDefault(sub,0)+1 // 計數\n        → Decision: counter[sub] == 2? // 判斷是否剛好第二次出現\n            Yes → Step 8: results.add(sub) // 將子字串加入結果\n            No  → Step 9: // 不做任何事，已經在結果中或尚未重複\n        → Step 10: i ← i+1 // 移動到下一個起點\n    No  → // 迴圈結束\n→ Step 11: 返回 results // 結果回傳\nEnd // 程式執行結束\n\nNeed to use arrow structure and decisions. Use \"Decision:\" lines with Yes → and No → lines. Make sure each line has virtual code and explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者或函式取得 DNA 序列  \n→ Decision: 是否 s 長度小於 10? // 檢查是否有足夠長度產生子字串  \n  Yes → Step 2: 返回空集合 // 若不足 10 個字母，無重複子字串  \n  No  → Step 3: 初始化 map counter ← 空字典 // 用於計數子字串出現次數  \n→ Step 4: 初始化結果集合 results ← 空集合 // 用於儲存重複子字串  \n→ Decision: 設定 i ← 0, n ← 長度(s) // 變數 i 為迴圈索引  \n  Yes → Step 5: 迴圈條件 i ≤ n - 10 // 只考慮能取到 10 字母的起點  \n    Yes → Step 6: sub ← s.substring(i, i+10) // 取得 10 字母子字串  \n    → Step 7: counter[sub] ← counter.getOrDefault(sub,0)+1 // 計數  \n    → Decision: counter[sub] == 2? // 判斷是否剛好第二次出現  \n      Yes → Step 8: results.add(sub) // 將子字串加入結果  \n      No  → Step 9: // 不做任何事，已經在結果中或尚未重複  \n    → Step 10: i ← i+1 // 移動到下一個起點  \n    No  → // 迴圈結束  \n→ Step 11: 返回 results // 結果回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入像是 \"nums = [1,2,3]\"，先去掉前綴\n    if data.startswith(\"nums\"):\n        parts = data.split(\"=\", 1)\n        if len(parts) == 2:\n            data = parts[1].strip()\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        # 如果 literal_eval 失敗，改用 eval（在安全環境下）\n        nums = eval(data, {\"__builtins__\": None}, {})\n    if not isinstance(nums, list):\n        nums = [nums]\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (like pseudocode) for generating all permutations of an array of distinct integers, with each line annotated. Use the specified format. Use arrows →, Decision, Start, End. Provide explanation after each line with //.\n\nWe should include steps: start, input array, call recursion, generate permutations by swapping, backtracking. Use typical algorithm: backtrack starting from index i, for j from i to n-1, swap, backtrack(i+1), swap back.\n\nSo produce lines:\n\nStart // program start\n→ Step 1: 獲取輸入陣列 nums // Get input array\n→ Step 2: 定義結果列表 result // Initialize result list\n→ Step 3: 定義遞迴函數 backtrack(startIndex) // Define recursive function\n→ Decision: 是否到達 startIndex 等於陣列長度? // Check if at end\n   Yes → Step 4: 複製當前陣列並加入 result // Add permutation\n   No  → Step 5: 循環 i 從 startIndex 到 nums.length-1 // Loop over positions\n           → Step 6: 交換 nums[startIndex] 與 nums[i] // Swap to generate new order\n           → Step 7: 呼叫 backtrack(startIndex+1) // Recurse deeper\n           → Step 8: 交換回原位 // Undo swap\n→ Step 9: 呼叫 backtrack(0) // Start recursion\n→ Step 10: 返回結果 result // Return result\nEnd // 程式結束\n\nWe need each line separated, each with virtual code + // explanation. Use arrow formatting.\n\nEnsure using arrow \"→\" before each step. Use indentation? We can indent inside Decision block.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取輸入陣列 nums // 從使用者或呼叫方取得整數陣列  \n→ Step 2: 定義結果列表 result // 用於存放所有排列  \n→ Step 3: 定義遞迴函數 backtrack(startIndex) // 生成排列的核心遞迴程式  \n→ Decision: startIndex 是否等於 nums.length? // 判斷是否已經排列完所有位置  \n    Yes → Step 4: 複製 nums 並加入 result // 完整排列時將當前順序加入結果  \n    No  → Step 5: 循環 i 從 startIndex 到 nums.length-1 // 在剩餘位置進行交換  \n        → Step 6: 交換 nums[startIndex] 與 nums[i] // 產生新的排列方向  \n        → Step 7: 呼叫 backtrack(startIndex + 1) // 進一步遞迴處理後續位置  \n        → Step 8: 交換回原位 // 回溯，恢復原始順序以備下一次迭代  \n→ Step 9: 呼叫 backtrack(0) // 從第一個位置開始遞迴  \n→ Step 10: 返回結果 result // 完成所有排列後輸出結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        在不修改陣列、且只使用常數額外空間的情況下找出重複的數字。\n        \"\"\"\n        # 第一階段：尋找慢指標與快指標的相遇點\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        # 第二階段：尋找入環點，即重複數字\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取原始資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入：找出等號右邊的列表文字\n    if \"=\" in raw_input:\n        _, list_str = raw_input.split(\"=\", 1)\n    else:\n        list_str = raw_input\n\n    list_str = list_str.strip()\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception as e:\n        # 如果解析失敗，直接結束\n        sys.exit()\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudo code with steps, using arrow, decision etc. Problem: Find duplicate in array without modifying array, constant extra space. Classic Floyd's Tortoise and Hare cycle detection. Steps: treat array as linked list where value is next pointer index. Find intersection. Then find start of cycle (duplicate). Provide pseudo code line by line with explanations. Use Start, End, Decision. Should be in Traditional Chinese. Provide steps like: Start, → Step 1: initialize slow=nums[0], fast=nums[0], etc. Let's produce lines. Ensure each line has \"虛擬碼步驟 // 解釋\". We'll maintain clarity.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指標，指向第一個元素  \n→ Step 2: fast ← nums[0] // 初始化快指標，同樣指向第一個元素  \n→ Decision: 循環開始? // 檢查是否進入循環  \n    Yes → Step 3: slow ← nums[slow] // 慢指標走一步  \n    → Step 4: fast ← nums[nums[fast]] // 快指標走兩步  \n    → Decision: slow = fast? // 判斷是否相遇  \n        Yes → Step 5: entry ← nums[0] // 從頭開始尋找入口  \n        → Step 6: fast ← nums[fast] // fast 也走一步，準備尋找相遇點  \n        → Decision: entry = fast? // 判斷是否找到入口  \n            Yes → Step 7: return entry // entry 為重複數字，返回結果  \n            No  → Step 6 // 若未相等，繼續往前走，回到決策 Step 6  \n        No  → Step 4 // 若 slow 未與 fast 相遇，繼續快慢指標移動，回到決策 Step 4  \n    No  → Step 3 // 若未進入循環，則不發生重複，結束（此情況不會出現）  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\nimport random\nimport collections\nimport ast\nimport json\n\nclass RandomizedCollection:\n    \"\"\"\n    這個類別實作一個可存放重複元素的資料結構，並支援 O(1) 平均時間的插入、刪除及隨機取值。\n    \"\"\"\n    def __init__(self):\n        # 用 list 儲存所有元素，能快速取得隨機位置\n        self.data = []\n        # 用 dict 以元素為鍵，值為其在 data 中所有索引的集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        插入 val。若 val 原本不存在於集合，回傳 True，否則回傳 False。\n        \"\"\"\n        # 把 val 加入 data\n        self.data.append(val)\n        # 把新索引加入對應的集合\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此時索引集合大小為 1，代表原本不存在\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        刪除一個 val（如果存在）。若成功刪除回傳 True，否則回傳 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            # val 不存在\n            return False\n\n        # 取一個索引位置\n        remove_idx = self.idx_map[val].pop()\n        # 取 data 的最後一個元素\n        last_val = self.data[-1]\n        # 把最後一個元素搬到要刪除的位置\n        self.data[remove_idx] = last_val\n\n        # 更新 last_val 的索引集合\n        self.idx_map[last_val].add(remove_idx)\n        # 刪除舊索引（最後一個位置）\n        self.idx_map[last_val].discard(len(self.data) - 1)\n\n        # 刪除 data 的最後一個元素\n        self.data.pop()\n\n        # 若 val 的索引集合已空，移除字典中的鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        以等機率回傳 data 中的任一元素。\n        \"\"\"\n        return random.choice(self.data)\n\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，格式為兩個列表：\n    1. 方法名稱列表\n    2. 參數列表\n    執行所有操作，並以 JSON 格式輸出結果。\n    \"\"\"\n    # 讀取全部輸入資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將兩個列表包裝成 tuple，方便 ast.literal_eval 解析\n    try:\n        ops, args = ast.literal_eval('(' + raw_input + ')')\n    except Exception as e:\n        raise ValueError(f\"無法解析輸入: {e}\")\n\n    # 建立 RandomizedCollection 物件\n    rc = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            rc = RandomizedCollection()\n            results.append(None)  # 以 null 表示初始化\n        elif op == \"insert\":\n            results.append(rc.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(rc.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(rc.getRandom())\n        else:\n            raise ValueError(f\"未知操作: {op}\")\n\n    # 輸出結果，使用 JSON 以符合範例輸出格式\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the design of RandomizedCollection with O(1) average operations. Use vector and hashmap of val to set of indices. Provide pseudo steps for constructor, insert, remove, getRandom. Each line with arrow and explanation. Use structure: Start, End, Decision. Provide step by step algorithm.\n\nWe should create steps: Initialize data structures. Insert: add to vector, update map. Remove: check map, get an index, swap last element, update map. getRandom: pick random index.\n\nLet's produce step by step lines with arrows. Use Start // start. Then Step 1: initialize array, map. Then Step 2: insert procedure. Then Step 3: remove procedure. Then Step 4: getRandom.\n\nBut we must output sequential lines of virtual code, not grouping functions. Possibly we can represent each method as separate blocks. But we might show pseudo code with method labels.\n\nWe should structure as:\n\nStart // start program\n→ Step 1: 初始化 empty vector arr // ...\n→ Step 2: 初始化 empty hashmap idx_map // ...\n→ Function: insert(val) // ...\n    → Decision: 检查 val 是否已存在于 idx_map? // ...\n    → Step: 在 arr 末尾添加 val // ...\n    → Step: 将新索引加入 idx_map[val] // ...\n    → Step: 返回 false if val existed, true otherwise // ...\n→ Function: remove(val) // ...\n    → Decision: 是否存在 val in idx_map? // ...\n        Yes → Step: 取 idx_map[val] 中任一索引 idx // ...\n        → Step: 取 arr 末尾元素 last_val // ...\n        → Step: 将 arr[idx] 设为 last_val // ...\n        → Step: 更新 idx_map[last_val] 移除末尾索引并加入 idx // ...\n        → Step: 从 arr 删除最后一个元素 // ...\n        → Step: 从 idx_map[val] 移除 idx // ...\n        → Decision: 若 idx_map[val] 为空，则删除键 val // ...\n        → Step: 返回 true // ...\n        No → Step: 返回 false // ...\n→ Function: getRandom() // ...\n    → Step: 随机生成 index 0 到 arr.size-1 // ...\n    → Step: 返回 arr[index] // ...\nEnd // program end\n\nNeed each line with arrow and explanation.\n\nAlso we need to maintain O(1) average.\n\nWe might use set or unordered_set for indices. For simplicity we can mention as \"unordered_set\".\n\nLet's produce. Use \"→\" arrow. For Decision we show indentation.\n\nLet's ensure every line includes code step and explanation comment.\n\nLet's produce the answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 vector<int> arr // 用於儲存所有元素，支持 O(1) 隨機存取\n→ Step 2: 初始化 unordered_map<int, unordered_set<int>> idx_map // 鍵為值，值為該值在 arr 中所有索引的集合\n→ Function: insert(val) // 插入元素 val\n    → Decision: 是否存在 idx_map[val]? // 檢查 val 是否已經在集合中\n        Yes → Step 3: 在 arr 末尾添加 val // 把新元素放到 vector 的尾部\n        No  → Step 3: 在 arr 末尾添加 val // 同樣把新元素放到 vector 的尾部\n        // 兩種情況都把元素放進 arr，保持插入 O(1)\n    → Step 4: 取得新元素的索引 idx = arr.size() - 1\n    → Step 5: idx_map[val].insert(idx) // 把新索引加入對應值的索引集合\n    → Step 6: Return !idx_map[val].size() - 1 // 若原先不存在，返回 true；否則返回 false\n→ Function: remove(val) // 刪除一個 val\n    → Decision: 是否存在 idx_map[val]? // 檢查 val 是否在集合中\n        Yes → Step 7: 取 idx_map[val] 中任一索引 idx // 取得要刪除元素在 arr 中的位置\n        No  → Step 8: Return false // 若不存在，直接返回 false\n        // 只要存在就進行以下刪除流程\n        → Step 9: 取 arr 末尾元素 last_val // 準備與要刪除元素交換\n        → Step 10: arr[idx] = last_val // 把末尾元素覆蓋到 idx 位置\n        → Decision: last_val 是否等於 val?\n            Yes → Step 11: idx_map[val].erase(idx) // 只需刪除自己的索引\n            No  → Step 11: idx_map[last_val].erase(arr.size() - 1) // 刪除末尾索引\n                  → Step 12: idx_map[last_val].insert(idx) // 把新位置索引加入集合\n        → Step 13: arr.pop_back() // 移除最後一個元素\n        → Step 14: idx_map[val].erase(idx) // 刪除 val 的索引\n        → Decision: idx_map[val] 是否空?\n            Yes → Step 15: idx_map.erase(val) // 若沒有剩餘索引，移除鍵\n            No  → No step // 留下集合\n        → Step 16: Return true // 刪除成功\n→ Function: getRandom() // 隨機取得一個元素\n    → Step 17: 隨機生成整數 r 在 [0, arr.size() - 1] // 產生合法索引\n    → Step 18: Return arr[r] // 直接返回對應元素\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\nimport ast\n\nclass MedianFinder:\n    \"\"\"維持兩個堆：maxHeap 存放較小的一半，minHeap 存放較大的一半。\"\"\"\n    def __init__(self):\n        self.max_heap = []  # 最大堆，實作為負值的最小堆\n        self.min_heap = []  # 最小堆\n\n    def addNum(self, num: int):\n        \"\"\"加入新數字並平衡兩堆。\"\"\"\n        # 如果 max_heap 為空或 num 小於等於 max_heap 的頂部，則放入 max_heap\n        if not self.max_heap or num <= -self.max_heap[0]:\n            heapq.heappush(self.max_heap, -num)\n        else:\n            heapq.heappush(self.min_heap, num)\n\n        # 平衡：確保兩堆大小相差不超 1\n        if len(self.max_heap) > len(self.min_heap) + 1:\n            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))\n        elif len(self.min_heap) > len(self.max_heap) + 1:\n            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))\n\n    def findMedian(self) -> float:\n        \"\"\"返回目前所有數字的中位數。\"\"\"\n        if len(self.max_heap) == len(self.min_heap):\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0\n        elif len(self.max_heap) > len(self.min_heap):\n            return -self.max_heap[0]\n        else:\n            return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入的兩個列表\n    try:\n        # 將輸入分成兩部分，第一部分是命令列表，第二部分是參數列表\n        parts = data.split('],', 1)\n        cmd_list_str = parts[0] + ']'\n        args_list_str = parts[1].strip()\n        cmd_list = ast.literal_eval(cmd_list_str)\n        args_list = ast.literal_eval(args_list_str)\n    except Exception:\n        # 如果解析失敗，直接輸出空列表\n        print('[]')\n        return\n\n    results = []\n    mf = None\n    for cmd, args in zip(cmd_list, args_list):\n        if cmd == 'MedianFinder':\n            mf = MedianFinder()\n            results.append(None)\n        elif cmd == 'addNum':\n            mf.addNum(args[0])\n            results.append(None)\n        elif cmd == 'findMedian':\n            results.append(mf.findMedian())\n        else:\n            # 未知命令，視為無返回值\n            results.append(None)\n\n    # 將 None 轉換成 null，使用 json.dumps 可以直接得到正確格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for implementing MedianFinder class with addNum and findMedian, using two heaps (max heap for lower half, min heap for upper half). Use virtual code steps.\n\nWe need to output line by line: each line has \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision etc.\n\nWe need to incorporate class structure: Start, Step 1: Define class MedianFinder // class definition\nStep 2: Initialize two heaps // lower and upper\nMethod: addNum\nMethod: findMedian\n\nWe must keep it pseudo-code.\n\nMake sure to include decisions: balancing heaps.\n\nPseudo-code lines:\n\nStart\n→ Step 1: Define class MedianFinder // class definition\n→ Step 2: Declare maxHeap // stores lower half\n→ Step 3: Declare minHeap // stores upper half\n→ Step 4: Constructor MedianFinder() // 初始化\n    → Step 5: Initialize maxHeap as empty max-heap\n    → Step 6: Initialize minHeap as empty min-heap\n→ Step 7: Method addNum(num) // 插入新數字\n    → Decision: If maxHeap is empty or num <= maxHeap.top?\n        Yes → Step 8: Insert num into maxHeap\n        No  → Step 9: Insert num into minHeap\n    → Decision: If maxHeap.size > minHeap.size + 1?\n        Yes → Step 10: Move maxHeap.top to minHeap\n        No  →\n    → Decision: If minHeap.size > maxHeap.size + 1?\n        Yes → Step 11: Move minHeap.top to maxHeap\n        No  →\n→ Step 12: Method findMedian() // 計算中位數\n    → Decision: If maxHeap.size == minHeap.size?\n        Yes → Step 13: median = (maxHeap.top + minHeap.top) / 2.0\n        No  →\n            Decision: If maxHeap.size > minHeap.size?\n                Yes → Step 14: median = maxHeap.top\n                No  → Step 15: median = minHeap.top\n    → Step 16: Return median\nEnd\n\nMake sure each line ends with // 解釋.\n\nLet's craft accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MedianFinder // 建立 MedianFinder 物件  \n→ Step 2: 宣告 maxHeap // 用於存放較小的一半（最大堆）  \n→ Step 3: 宣告 minHeap // 用於存放較大的一半（最小堆）  \n\n→ Step 4: Constructor MedianFinder() // 初始化  \n    → Step 5: maxHeap 初始化為空最大堆 // 低位數字集合  \n    → Step 6: minHeap 初始化為空最小堆 // 高位數字集合  \n\n→ Step 7: 方法 addNum(num) // 插入新數字  \n    → Decision: 如果 maxHeap 為空 或 num ≤ maxHeap.top? // 判斷將數字放哪個堆  \n        Yes → Step 8: 把 num 插入 maxHeap // 放進較小的一半  \n        No  → Step 9: 把 num 插入 minHeap // 放進較大的一半  \n    → Decision: 如果 maxHeap.size > minHeap.size + 1? // 檢查兩堆大小差  \n        Yes → Step 10: 把 maxHeap.top 移到 minHeap // 重新平衡，維持差不超 1  \n        No  →  \n    → Decision: 如果 minHeap.size > maxHeap.size + 1? // 檢查另一邊是否過大  \n        Yes → Step 11: 把 minHeap.top 移到 maxHeap // 重新平衡  \n        No  →  \n\n→ Step 12: 方法 findMedian() // 計算目前中位數  \n    → Decision: 如果 maxHeap.size == minHeap.size? // 堆大小相等，取平均  \n        Yes → Step 13: median = (maxHeap.top + minHeap.top) / 2.0 // 兩個中位數平均  \n        No  →  \n            Decision: 如果 maxHeap.size > minHeap.size? // 低位堆較多  \n                Yes → Step 14: median = maxHeap.top // 直接取較小堆頂  \n                No  → Step 15: median = minHeap.top // 直接取較大堆頂  \n    → Step 16: 返回 median // 回傳計算得到的中位數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\ndef group_anagrams(strs):\n    \"\"\"\n    將輸入的字串陣列按字母排序後分組，同字母排序相同的字串放在同一子陣列中。\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))          # 以排序後的字元組作為鍵\n        anagrams[key].append(s)         # 將原字串加入對應鍵的列表\n    return list(anagrams.values())\n\ndef parse_input(data):\n    \"\"\"\n    解析輸入字串，將 'strs = [...]' 轉成真正的 Python list。\n    \"\"\"\n    if '=' in data:\n        _, rhs = data.split('=', 1)    # 取得等號右側的部分\n        rhs = rhs.strip()\n    else:\n        rhs = data.strip()\n    return ast.literal_eval(rhs)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        strs = []\n    else:\n        strs = parse_input(raw_input)\n\n    result = group_anagrams(strs)\n\n    # 用 json.dumps 並去除空格，符合範例輸出格式\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for grouping anagrams. Provide step by step: start, iterate, sort each string, use hashmap, etc. Provide explanation each line. Use arrow. Format as example. Must use Traditional Chinese. Use 虛擬碼步驟. Must include \"→\" arrow for steps, decisions. Use \"Decision:\" with Yes →, No →. Provide End. Ensure each line has code + space + // explanation. The code is virtual, not real. Use pseudocode. For grouping anagrams: For each string, sort characters, use as key, add to dictionary. Finally return list of values. Provide stepwise. Ensure each line is separate. Provide proper indentation? We can use indentation by spaces. Use arrow for sub-steps. Let's craft.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 建立空字典 anagram_map // 用於將排序後的字串作為鍵對應到原始字串列表\nLine3: → Step 2: 對每個字串 str 於 strs 進行迴圈 // 逐一處理輸入陣列\nLine4:     → Step 2.1: key ← 對 str 進行字元排序並連接成字串 // 排序後的字串作為鍵\nLine5:     → Decision: 是否存在 key? // 判斷字典中是否已有該鍵\nLine6:         Yes → Step 2.2: 將 str 追加到 anagram_map[key] 列表 // 已有鍵，加入列表\nLine7:         No  → Step 2.3: anagram_map[key] ← [str] // 無鍵，建立新列表\nLine8: → Step 3: 回傳 anagram_map 的所有值作為結果 // 取得分組好的列表\nLine9: End // 程式執行結束\n\nWe need to ensure each line includes 虛擬碼步驟 + space + // explanation. For sub-steps we indent. Use arrow. Provide Decision lines. This should meet. Use Traditional Chinese. Provide final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 anagram_map // 用於將排序後的字串作為鍵對應到原始字串列表  \n→ Step 2: 對每個字串 str 於 strs 進行迴圈 // 逐一處理輸入陣列  \n  → Step 2.1: key ← 對 str 進行字元排序並連接成字串 // 排序後的字串作為鍵  \n  → Decision: 是否存在 key? // 判斷字典中是否已有該鍵  \n   Yes → Step 2.2: 將 str 追加到 anagram_map[key] 列表 // 已有鍵，加入列表  \n   No  → Step 2.3: anagram_map[key] ← [str] // 無鍵，建立新列表  \n→ Step 3: 回傳 anagram_map 的所有值作為結果 // 取得分組好的列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字字串轉換為整數。\"\"\"\n    roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n                 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    # 逆序遍歷，處理加減\n    for char in reversed(s):\n        value = roman_map[char]\n        if value < prev_value:\n            total -= value\n        else:\n            total += value\n        prev_value = value\n    return total\n\ndef main() -> None:\n    # 從標準輸入讀取原始資料\n    data = sys.stdin.read()\n    # 以正則式擷取羅馬數字字串\n    match = re.search(r'([IVXLCDM]+)', data)\n    if not match:\n        return\n    roman_str = match.group(1)\n    # 計算並輸出結果\n    result = roman_to_int(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting Roman numeral to integer. Provide step-by-step pseudocode with explanations. Use Start, Decision, arrows. Ensure no actual code. Use Chinese. Provide each line with virtual code step and explanation. We'll outline algorithm: parse string left to right, map characters to values, if current value < next value then subtract else add. Alternatively iterate from rightmost. Provide steps: read string, initialize total=0, prev=0, loop each char from right to left: val=map[char]; if val<prev then total-=val else total+=val; prev=val. End. We'll produce virtual code accordingly. Use arrows. Provide lines accordingly.\n\nLet's craft lines:\n\nStart\n→ Step 1: Read input Roman numeral string // 取得使用者輸入的羅馬數字\n→ Step 2: Initialize total = 0, prev_value = 0 // 設定累計和與前一個符號的數值\n→ Step 3: For each character c in the string from rightmost to leftmost // 逆序遍歷字符\n    → Step 4: Retrieve numeric value v for c from Roman mapping // 根據對應表取得數值\n    → Decision: 如果 v < prev_value? // 判斷是否需要減法\n        Yes → Step 5: total = total - v // 小於前值，執行減法\n        No  → Step 6: total = total + v // 大於等於前值，執行加法\n    → Step 7: prev_value = v // 更新前值為目前數值\n→ Step 8: 輸出 total // 顯示最終的整數結果\nEnd\n\nNeed to include arrow indentation for nested steps. Ensure proper formatting. Use \"Yes →\" and \"No →\". Use indentation for nested blocks. Provide each line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read input Roman numeral string // 取得使用者輸入的羅馬數字  \n→ Step 2: Initialize total = 0, prev_value = 0 // 設定累計和與前一個符號的數值  \n→ Step 3: For each character c in the string from rightmost to leftmost // 逆序遍歷字符  \n  → Step 4: Retrieve numeric value v for c from Roman mapping // 根據對應表取得數值  \n  → Decision: 如果 v < prev_value? // 判斷是否需要減法  \n    Yes → Step 5: total = total - v // 小於前值，執行減法  \n    No  → Step 6: total = total + v // 大於等於前值，執行加法  \n  → Step 7: prev_value = v // 更新前值為目前數值  \n→ Step 8: 輸出 total // 顯示最終的整數結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Size Subarray Sum",
      "source_file": "Leetcode/leetcode209.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjcx9mk0o.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpjcx9mk0o.py\", line 32, in main\n    target, nums = parse_input(data)\n                   ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjcx9mk0o.py\", line 25, in parse_input\n    nums = eval(part.split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplarhn5i_.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmplarhn5i_.py\", line 32, in main\n    target, nums = parse_input(data)\n                   ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmplarhn5i_.py\", line 25, in parse_input\n    nums = eval(part.split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbqv1jf39.py\", line 37, in <module>\n    main()\n  File \"/tmp/tmpbqv1jf39.py\", line 32, in main\n    target, nums = parse_input(data)\n                   ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpbqv1jf39.py\", line 25, in parse_input\n    nums = eval(part.split('=')[1].strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\ndef min_subarray_len(target, nums):\n    left = 0\n    total = 0\n    min_len = float('inf')\n    for right in range(len(nums)):\n        total += nums[right]\n        while total >= target:\n            min_len = min(min_len, right - left + 1)\n            total -= nums[left]\n            left += 1\n    return 0 if min_len == float('inf') else min_len\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form: 'target = 7, nums = [2,3,1,2,4,3]'\"\"\"\n    target = None\n    nums = None\n    for part in data.split(','):\n        part = part.strip()\n        if part.startswith('target'):\n            target = int(part.split('=')[1].strip())\n        elif part.startswith('nums'):\n            # Use eval safely for list literal\n            nums = eval(part.split('=')[1].strip())\n    return target, nums\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    target, nums = parse_input(data)\n    result = min_subarray_len(target, nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code with line-by-line steps. Requirements: use Start, End, Decision:, arrows →, Yes →, No →. For each line: \"虛擬碼步驟 [space] // 解釋/說明\". Use Traditional Chinese. Provide algorithm: sliding window, minimal length. Steps: Start, initialize left, right, sum, minLen. While right < n: add nums[right], increment right, while sum >= target: update minLen, subtract nums[left], increment left. After loop, if minLen==∞ return 0 else minLen. End.\n\nMake sure to include Decision lines for condition checks. Use \"Decision: sum >= target?\" etc.\n\nProvide each line as separate line.\n\nLet's craft.\n\nStart // 程式開始執行\n\n→ Step 1: 設定 n = nums.Length // 取得陣列長度\n\n→ Step 2: 初始化 left = 0, right = 0, sum = 0, minLen = Infinity // 兩指標與累加器\n\n→ Decision: right < n? // 是否還有元素未遍歷\n\n    Yes → Step 3: sum = sum + nums[right] // 加入右指標元素\n\n    Yes → Step 4: right = right + 1 // 右指標右移\n\n    Yes → Decision: sum >= target? // 子陣列是否已達目標和\n\n        Yes → Step 5: minLen = min(minLen, right - left) // 更新最短長度\n\n        Yes → Step 6: sum = sum - nums[left] // 從左端移除元素\n\n        Yes → Step 7: left = left + 1 // 左指標右移\n\n        No  → Step 8: // 跳回上一步，繼續擴大右指標\n\n    No  → Step 9: // 跳回上一步，繼續擴大右指標\n\nEnd // 程式執行結束\n\nBut need to output in proper format. We must include \"Start\" and \"End\". Use arrow for each step.\n\nBetter format:\n\nStart // 程式開始執行\n\n→ Step 1: n ← nums.Length // 取得陣列長度\n\n→ Step 2: left ← 0; right ← 0; sum ← 0; minLen ← Infinity // 初始化指標與變數\n\n→ Decision: right < n? // 檢查右指標是否越過陣列\n\n    Yes → Step 3: sum ← sum + nums[right] // 加入右指標元素至累加和\n\n    Yes → Step 4: right ← right + 1 // 右指標右移一位\n\n    Yes → Decision: sum >= target? // 是否達到目標和\n\n        Yes → Step 5: minLen ← min(minLen, right - left) // 更新最短長度\n\n        Yes → Step 6: sum ← sum - nums[left] // 從左端移除元素\n\n        Yes → Step 7: left ← left + 1 // 左指標右移\n\n        No  → Step 8: // 仍未達目標，繼續擴大右指標\n\n    No  → Step 9: // 仍未達目標，繼續擴大右指標\n\nEnd // 程式執行結束\n\nHowever we need to ensure proper arrow usage: each line begins with \"→\" except Start and End? In example, Start line not preceded by arrow. So we follow example: Start, then each step line begins with \"→\". Decision lines with indent.\n\nAlso after Step 4 we still need Decision. But we may restructure as while loop: While right < n: ... We'll produce pseudocode lines accordingly.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: n ← nums.Length // 取得陣列長度\n\n→ Step 2: left ← 0; right ← 0; sum ← 0; minLen ← Infinity // 初始化變數\n\n→ Decision: right < n? // 右指標是否還在陣列內\n\n    Yes → Step 3: sum ← sum + nums[right] // 加入右指標元素\n\n    Yes → Step 4: right ← right + 1 // 右指標右移\n\n    Yes → Decision: sum >= target? // 是否已達目標和\n\n        Yes → Step 5: minLen ← min(minLen, right - left) // 更新最短長度\n\n        Yes → Step 6: sum ← sum - nums[left] // 從左端移除元素\n\n        Yes → Step 7: left ← left + 1 // 左指標右移\n\n        No  → Step 8: // 仍未達目標，繼續擴大右指標\n\n    No  → Step 9: // 仍未達目標，繼續擴大右指標\n\nEnd // 程式執行結束\n\nBut we need to return 0 if minLen is Infinity. That step not shown. We need a decision after loop to output result. Add after End? We can add step before End: Decision: minLen == Infinity? etc. But we need to output result. Let's add steps after Decision: but we need to output result. Since we are generating virtual code, maybe we just include decision that if minLen==Infinity return 0 else minLen.\n\nAdd after while loop:\n\n→ Decision: minLen == Infinity? // 是否還沒有符合條件的子陣列\n\n    Yes → Step 10: return 0 // 沒有符合的子陣列\n\n    No  → Step 11: return minLen // 回傳最短長度\n\nBut we need to place before End. Also need to incorporate loop. Our representation didn't show loop explicitly. We used Decision: right < n? repeatedly. That's fine.\n\nLet's incorporate Step 10 and 11 before End.\n\nAlso we need to ensure indentation and arrow formatting: For Decision, use \"Decision:\". For sub-steps, use \"Yes →\" and \"No →\".\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← nums.Length // 取得陣列長度\n→ Step 2: left ← 0; right ← 0; sum ← 0; minLen ← Infinity // 初始化指標與變數\n→ Decision: right < n? // 右指標是否還在陣列內\n    Yes → Step 3: sum ← sum + nums[right] // 加入右指標元素\n    Yes → Step 4: right ← right + 1 // 右指標右移\n    Yes → Decision: sum >= target? // 是否已達目標和\n        Yes → Step 5: minLen ← min(minLen, right - left) // 更新最短長度\n        Yes → Step 6: sum ← sum - nums[left] // 從左端移除元素\n        Yes → Step 7: left ← left + 1 // 左指標右移\n        No  → Step 8: // 仍未達目標，繼續擴大右指標\n    No  → Step 9: // 仍未達目標，繼續擴大右指標\n→ Decision: minLen == Infinity? // 是否還沒有符合條件的子陣列\n    Yes → Step 10: return 0 // 沒有符合的子陣列\n    No  → Step 11: return minLen // 回傳最短長度\nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpt6mii9gh.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpt6mii9gh.py\", line 40, in main\n    results.append(kth.add(arg))\n                   ^^^^^^^^^^^^\n  File \"/tmp/tmpt6mii9gh.py\", line 14, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0gud6g7x.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp0gud6g7x.py\", line 40, in main\n    results.append(kth.add(arg))\n                   ^^^^^^^^^^^^\n  File \"/tmp/tmp0gud6g7x.py\", line 14, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Try to split into two lines (operations and arguments)\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) == 2:\n        ops = ast.literal_eval(lines[0])\n        args = ast.literal_eval(lines[1])\n    else:\n        # Fallback: treat the whole input as a tuple/list of two lists\n        parsed = ast.literal_eval(data)\n        ops, args = parsed[0], parsed[1]\n\n    results = []\n    kth = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            kth = KthLargest(arg[0], arg[1])\n            results.append(None)  # null in JSON\n        elif op == \"add\" and kth is not None:\n            results.append(kth.add(arg))\n        else:\n            # In case of unexpected operation, append None\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Provide steps for class KthLargest: constructor takes k and nums, maintain min-heap of size k. add pushes val and pops if size > k. Return heap root. Provide explanation per line.\n\nWe need to output step-by-step virtual code with arrows, decision etc. For initialization, we should loop through nums and add each. Also ensure heap size k. Use data structure priority queue (min-heap). Use methods: Insert, Pop.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 KthLargest // 建立類別\n→ Step 2: 成員變數 k, heap // 存儲 k 值與最小堆\n→ Step 3: Constructor KthLargest(k, nums) // 初始化\n    → Decision: nums 為空? // 檢查是否有初始數據\n        Yes → End Constructor // 無數據則直接返回\n        No → \n            → Step 4: 將 k 儲存至成員變數 // 保存 k\n            → Step 5: 建立空 min-heap // 初始化堆\n            → Step 6: For each num in nums:\n                → Step 7: Call add(num) // 將初始分數加入堆\n→ Step 8: add(val) // 新增分數並回傳 kth 大\n    → Step 9: Insert val 至 min-heap // 加入新分數\n    → Decision: min-heap 大小 > k? // 檢查是否超過 k\n        Yes → Step 10: Pop 最小元素 // 移除最小，保持大小 k\n        No → No operation\n    → Step 11: Return min-heap 根元素 // kth 大的分數\nEnd // 程式結束\n\nNeed to follow output format: each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows. Use Start, End. Also include indentation for decision branches.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 KthLargest // 建立類別  \n→ Step 2: 成員變數 k, heap // 存儲 k 值與最小堆  \n→ Step 3: Constructor KthLargest(k, nums) // 初始化  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: nums 為空? // 檢查是否有初始數據  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → End Constructor // 無數據則直接返回  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 4: 將 k 儲存至成員變數 // 保存 k  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 5: 建立空 min-heap // 初始化堆  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 6: For each num in nums: // 遍歷初始分數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Step 7: Call add(num) // 將初始分數加入堆  \n→ Step 8: add(val) // 新增分數並回傳 kth 大  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 9: Insert val 至 min-heap // 加入新分數  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: min-heap 大小 > k? // 檢查是否超過 k  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 10: Pop 最小元素 // 移除最小，保持大小 k  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → No operation // 大小已正好  \n&nbsp;&nbsp;&nbsp;&nbsp;Step 11: Return min-heap 根元素 // kth 大的分數  \nEnd // 程式結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb_x_8baf.py\", line 54, in <module>\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # 分割成兩個列表\n    # 找到第一個 '],' 位置作為分割點\n    split_index = raw.find('],')\n    if split_index == -1:\n        # 若格式不符，直接嘗試解析整個字串\n        ops, args = [], []\n    else:\n        ops_part = raw[:split_index + 1]  # 包含第一個 ']'\n        args_part = raw[split_index + 1:].strip()  # 後面剩下\n        # 解析兩個部分\n        ops = ast.literal_eval(ops_part)\n        args = ast.literal_eval(args_part)\n\n    results = []\n    trie = None\n\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif op == 'insert':\n            trie.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            res = trie.search(arg[0])\n            results.append(res)\n        elif op == 'startsWith':\n            res = trie.startsWith(arg[0])\n            results.append(res)\n        else:\n            # 忽略未知指令\n            results.append(None)\n\n    print(results)",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step for Trie class with methods. Each line: virtual code step + // explanation. Use arrow syntax. Provide steps like Start, define node structure, init root, insert, search, startsWith. No actual code. Let's produce structure: Start, define Node with children map and isEnd. Then class Trie with root. Methods. Use Decision for search? Implementation: search: traverse, return true if node exists and isEnd. startsWith: traverse, return true if node exists. Insert: traverse, create nodes, mark end. Use arrows and indent. Provide explanation per line. Ensure each line ends with // explanation. Provide the virtual code in lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Definition: Node // 定義 Trie 節點結構  \n→     children: Map<Character, Node> // 子節點字典，鍵為字母，值為子節點  \n→     isEnd: Boolean // 是否為單字結束標記  \n\n→ Class: Trie // 定義 Trie 類別  \n→     root: Node // 根節點，初始時空節點  \n\n→ Method: Trie() // 建構子，初始化 Trie  \n→     root ← new Node() // 建立根節點，children 為空，isEnd 為 false  \n\n→ Method: insert(word: String) // 插入單字  \n→     current ← root // 從根節點開始  \n→     for each char in word // 遍歷單字中的每個字母  \n→         if current.children does not contain char // 若不存在對應子節點  \n→             current.children[char] ← new Node() // 創建新節點  \n→         current ← current.children[char] // 移動到子節點  \n→     current.isEnd ← true // 標記單字結束  \n\n→ Method: search(word: String) → Boolean // 查詢單字是否存在  \n→     current ← root // 從根節點開始  \n→     for each char in word // 遍歷單字  \n→         if current.children does not contain char // 若找不到字母  \n→             return false // 該單字不在 Trie  \n→         current ← current.children[char] // 移動到子節點  \n→     return current.isEnd // 若到達節點且為單字結束則為 true，否則 false  \n\n→ Method: startsWith(prefix: String) → Boolean // 判斷是否有單字以 prefix 開頭  \n→     current ← root // 從根節點開始  \n→     for each char in prefix // 遍歷前綴字母  \n→         if current.children does not contain char // 若找不到字母  \n→             return false // 沒有以此前綴的單字  \n→         current ← current.children[char] // 移動到子節點  \n→     return true // 前綴存在，無需檢查 isEnd  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp529qwk62.py\", line 28, in <module>\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp529qwk62.py\", line 14, in rand10\n    a = rand7()          # 取得第一個隨機數\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph7vxtgui.py\", line 28, in <module>\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmph7vxtgui.py\", line 14, in rand10\n    a = rand7()          # 取得第一個隨機數\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk0ozhn_3.py\", line 28, in <module>\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk0ozhn_3.py\", line 14, in rand10\n    a = rand7()          # 取得第一個隨機數\n        ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 假設外部已提供 rand7() 函式\n# 這裡不再重新實作，以免使用內建隨機 API\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        透過兩次呼叫 rand7() 產生 1~49 的均勻分佈，\n        將 1~40 對應到 1~10，若超過 40 則重試。\n        \"\"\"\n        while True:\n            a = rand7()          # 取得第一個隨機數\n            b = rand7()          # 取得第二個隨機數\n            num = (a - 1) * 7 + b  # 轉換成 1~49\n            if num <= 40:        # 只接受 1~40\n                return 1 + (num - 1) % 10  # 對應到 1~10\n\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取 n 的值，例如 \"n = 3\"\n    input_data = sys.stdin.read()\n    match = re.search(r'\\d+', input_data)\n    n = int(match.group()) if match else 0\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n\n    # 將結果輸出為列表形式\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate rand10 using rand7. Classic approach: generate 49 outcomes using two rand7 calls, map 1-40 to 1-10, reject 41-49. Or use rejection sampling with 7*7=49 combos. Steps: start, call rand7 twice to get a,b, compute num = (a-1)*7 + b => 1-49. If num <= 40: output (num-1)%10 +1. Else repeat. Provide virtual code lines with explanations.\n\nWe need to output in Chinese. Use arrow formatting. Provide each line with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 呼叫 rand7() 並存入變數 a // 取得第一個隨機數  \n→ Step 2: 呼叫 rand7() 並存入變數 b // 取得第二個隨機數  \n→ Step 3: 計算 num = (a - 1) * 7 + b // 將兩個數合併成 1-49 的唯一編號  \n→ Decision: 如果 num <= 40? // 檢查編號是否在可用範圍內  \n    Yes → Step 4: 計算 result = ((num - 1) % 10) + 1 // 將 1-40 重新映射為 1-10  \n        → Step 5: 回傳 result // 完成 rand10() 的輸出  \n        → End // 程式執行結束  \n    No  → Step 6: 轉至 Step 1 重新嘗試 // 若 num 在 41-49，重複整個流程以確保均勻分佈"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':  # 避免前導零\n                    continue\n                curr = int(temp)\n                if index == 0:  # 第一個數字不需要加操作符\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    # 乘法時需先把上一次加/減的數值從 value 中扣除，再加上乘積\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：num = \"123\", target = 6 之類的格式\n    pattern = r'num\\s*=\\s*\"(?P<num>[^\"]*)\"\\s*,\\s*target\\s*=\\s*(?P<target>-?\\d+)'\n    m = re.search(pattern, data)\n    if m:\n        num = m.group('num')\n        target = int(m.group('target'))\n    else:\n        # 若輸入格式不包含引號，可嘗試直接分隔\n        parts = data.split(',')\n        num_part = parts[0].split('=')[1].strip()\n        target_part = parts[1].split('=')[1].strip()\n        num = num_part.strip('\"')\n        target = int(target_part)\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: \"add operators to get target\". Classic LeetCode 282. The virtual code steps. We must output line by line, with arrow, start, end, decisions.\n\nWe need to describe algorithm: recursive DFS/backtracking. Use variables: path string, pos index, cumulative value, previous multiplication value. For each position, choose number from pos to i, avoid leading zeros. Recursively call.\n\nSo we produce pseudocode with decisions and steps. Ensure to use arrow '→'. Provide comments after each line.\n\nLet's craft.\n\nWe need Start, End. Use decisions.\n\nWe also need to ensure each line includes arrow, step, comment.\n\nLet's produce. We'll need recursion function, base case. Use list results. We'll treat target variable.\n\nWe need to mention that leading zero check. We'll mention multiplication effect.\n\nLet's output.\n\nWe also need to mention we will use a stack or recursion.\n\nAlright.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 results // 用來儲存符合目標值的所有表達式  \n→ Step 2: 呼叫 DFS(start=0, path=\"\", curr=0, prev=0) // 從字串開頭開始遞迴搜尋  \n\n→ Function DFS(start, path, curr, prev) // start: 當前索引；path: 已建構的表達式；curr: 目前整體值；prev: 前一個數字（用於乘法）  \n    → Decision: 是否已到達字串結尾? // 判斷是否所有位都已處理  \n        Yes → Decision: curr 是否等於 target? // 檢查是否達到目標  \n            Yes → Step 3: 加入 path 至 results // 成功的表達式加入結果集合  \n            No → Step 4: Return // 若不等於目標則回溯  \n        No  → Step 5: for i從start到len(num)-1  \n            → Step 6: substring num[start:i+1] 作為 currentStr // 取出從 start 到 i 的子字串  \n            → Decision: currentStr 是否以 '0' 開頭且長度>1? // 防止前導零  \n                Yes → Step 7: 跳過此迴圈迭代 // 跳過包含前導零的數字  \n                No  → Step 8: 轉換 currentStr 為數字 currentNum // 取得數值  \n                → Decision: start 是否為 0? // 是否是第一個數字（不需要操作符）  \n                    Yes → Step 9: DFS(i+1, currentStr, currentNum, currentNum) // 第一個數字直接作為 curr 和 prev  \n                    No  →  \n                        → Step 10: DFS(i+1, path + \"+\" + currentStr, curr + currentNum, currentNum) // 加法情形  \n                        → Step 11: DFS(i+1, path + \"-\" + currentStr, curr - currentNum, -currentNum) // 減法情形  \n                        → Step 12: DFS(i+1, path + \"*\" + currentStr, curr - prev + (prev * currentNum), prev * currentNum) // 乘法情形（需調整 curr）  \n\nEnd // 程式執行結束，results 中即為所有符合目標的表達式集合"
    },
    {
      "title": "Number of Islands",
      "source_file": "Leetcode/leetcode200.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if grid[i][j] == '0' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    count += 1\n        return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n    else:\n        # 將輸入字串轉換為 Python 資料結構\n        try:\n            grid = ast.literal_eval(data)\n        except Exception:\n            grid = []\n        solution = Solution()\n        result = solution.numIslands(grid)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting islands. Should be BFS/DFS approach. Use visited set. Iterate all cells. For each '1' not visited, increment count, start DFS marking visited. Use stack or recursion. Provide steps. Format: \"虛擬碼步驟 // 解釋\". Use arrows. We'll produce lines. Use \"Start\". Let's generate:\n\nStart // start program\n→ For i in 0 to m-1 // 遍歷行\n    → For j in 0 to n-1 // 遍歷列\n        → Decision: 如果 grid[i][j] == '1' 且 未訪問? // 找到未標記的陸地\n            Yes → Step: count += 1 // 島嶼數加一\n            → Call DFS(i, j) // 從該點深度優先搜索並標記所有連通陸地\n            No → Continue // 不是陸地或已訪問，跳過\n→ End // 程式結束\n\nNow define DFS:\n\nDFS(row, col):\n    → Decision: 判斷 row 或 col 是否越界? // 邊界檢查\n        Yes → End DFS // 超出範圍，返回\n        No  → Decision: 如果 grid[row][col] == '0' 或 已訪問? // 水或已標記\n            Yes → End DFS // 不處理\n            No  → Step: 標記 visited[row][col] = True // 標記為已訪問\n            → Step: For each (dr, dc) in {(1,0),(-1,0),(0,1),(0,-1)} // 四個方向\n                → Call DFS(row+dr, col+dc) // 續行\n    End DFS\n\nWe need to format each line with arrow, indent. Ensure we use \"→\" and \"Decision:\" lines.\n\nLet's produce.\n\nAlso we need to maintain visited matrix.\n\nStart: set count=0, visited = [[False]*n for _ in range(m)] // 初始化\n\nThen loops.\n\nAdd lines.\n\nWe'll produce the final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: m ← 取得 grid 行數 // 獲取行數  \n→ Step: n ← 取得 grid 列數 // 獲取列數  \n→ Step: count ← 0 // 島嶼計數初始化  \n→ Step: visited ← 二維布林陣列 (m × n) 全為 False // 標記訪問狀態  \n\n→ Decision: 如果 m == 0 或 n == 0? // 空格網格檢查  \n    Yes → End // 若無格子則直接結束  \n    No  → Continue // 有格子則進行遍歷  \n\n→ For i from 0 to m-1 // 遍歷每一行  \n    → For j from 0 to n-1 // 遍歷每一列  \n        → Decision: 如果 grid[i][j] == '1' 且 visited[i][j] == False? // 找到未訪問的陸地  \n            Yes → Step: count ← count + 1 // 新島嶼，計數加一  \n            → Call DFS(i, j) // 從此點進行 DFS 標記整個島嶼  \n            No  → Continue // 不是陸地或已訪問，跳過  \n\nEnd // 程式執行結束  \n\n// ---------- DFS 定義 ----------  \n\nDFS(row, col): // 開始 DFS  \n→ Decision: 判斷 row 或 col 是否越界? // 边界检查  \n    Yes → Return // 超出範圍，直接返回  \n    No  → Continue  \n\n→ Decision: 如果 grid[row][col] == '0' 或 visited[row][col] == True? // 水或已標記  \n    Yes → Return // 不進行處理  \n    No  → Step: visited[row][col] ← True // 標記此格已訪問  \n\n→ Step: directions ← {(1,0), (-1,0), (0,1), (0,-1)} // 四個相鄰方向  \n→ For each (dr, dc) in directions // 遍歷方向  \n    → Call DFS(row + dr, col + dc) // 递归搜索相邻格子  \n\nReturn // DFS 完成返回  \nEnd DFS // DFS 定義結束"
    },
    {
      "title": "Kth Largest Element in an Array",
      "source_file": "Leetcode/leetcode215.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp277arrcw.py\", line 39, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp277arrcw.py\", line 28, in parse_input\n    nums = eval(nums_str)            # 轉成 list\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu6mfu2h7.py\", line 39, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu6mfu2h7.py\", line 28, in parse_input\n    nums = eval(nums_str)            # 轉成 list\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums, k):\n        # 使用大小為 k 的最小堆，堆中始終保留 k 個最大元素\n        heap = nums[:k]\n        heapq.heapify(heap)          # 把前 k 個元素調整為最小堆\n        for num in nums[k:]:\n            # 若目前元素比堆頂小，則不可能是 k 大元素，直接跳過\n            if num > heap[0]:\n                heapq.heappop(heap)  # 移除最小元素\n                heapq.heappush(heap, num)  # 加入新的候選元素\n        return heap[0]  # 堆頂即為第 k 大元素\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援以下兩種格式：\n    1. 一行：'nums = [3,2,1,5,6,4], k = 2'\n    2. 多行：第一行為 nums 列表，第二行為 k 整數\n    \"\"\"\n    data = data.strip().replace('\\r', ' ').replace('\\n', ' ')\n    # 去掉前綴文字\n    data = data.replace('nums =', '').replace('k =', '').strip()\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) >= 2:\n        nums_str, k_str = parts[0], parts[1]\n        nums = eval(nums_str)            # 轉成 list\n        k = int(k_str)                   # 轉成 int\n    else:\n        # 假設多行輸入\n        lines = [p.strip() for p in data.splitlines() if p.strip()]\n        nums = eval(lines[0])\n        k = int(lines[1])\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    result = Solution().findKthLargest(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps, line by line, for algorithm: find kth largest element in array without sorting. We can use min-heap of size k, or quickselect. We'll pick min-heap approach. Outline: initialize min-heap, iterate nums, push element, if size > k pop min. After iteration, top of heap is kth largest. So produce virtual code with Start, End, Decision, etc.\n\nAlso, we should produce steps: Input, initialize heap, for each element: push, maybe pop, after loop: result. Let's structure.\n\nWe'll use pseudo:\n\nStart\n→ Step 1: Receive nums array and integer k // input\n→ Step 2: Initialize empty min-heap // min-heap for k largest\n→ Step 3: For each num in nums // iterate\n    → Step 3.1: Insert num into heap // add element\n    → Decision: If heap size > k? // maintain size\n        Yes → Step 3.2: Remove smallest element from heap // pop\n        No  → (none)\n→ Step 4: The smallest element in heap is kth largest // retrieve\n→ End\n\nAdd explanation comments.\n\nOk. Ensure format: each line \"虛擬碼步驟 // 解釋\" with arrow or decision lines. We'll produce multi-line with indentation. Use \"Decision:\" lines. Need to maintain formatting like sample. For nested steps, indent appropriately.\n\nLet's craft.\n\nAlso need to mention we are not sorting.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Receive nums array and integer k // 取得輸入資料  \n→ Step 2: Initialize empty min-heap H // 建立最小堆，長度最多 k  \n→ Step 3: For each num in nums // 遍歷陣列  \n  → Step 3.1: Insert num into H // 將元素加入堆  \n  → Decision: 如果 H 的大小 > k? // 保持堆長度不超過 k  \n    Yes → Step 3.2: Remove the smallest element from H // 刪除堆頂，確保只保留 k 個最大值  \n    No → (不做任何事)  \n→ Step 4: H 的堆頂元素即為第 k 大元素 // 最小堆頂是第 k 大值  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,2,2,false]'\nGot (Norm):      '[null,null,2,2,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 2, 2, false]'\nRaw Got:      '[null, null, 2, 2, false]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        self.q1.append(x)\n\n    def pop(self):\n        # Move all but the last element to q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        # Swap the queues\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self):\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        self.q2.append(res)\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self):\n        return not self.q1\n\ndef parse_input(raw: str):\n    raw = raw.strip()\n    if raw.startswith(\"Input \"):\n        raw = raw[6:].strip()\n    # Find the split between the two lists\n    split_index = raw.find('],')\n    if split_index == -1:\n        raise ValueError(\"Input format error\")\n    list1_str = raw[:split_index + 1]\n    list2_str = raw[split_index + 2:].strip()\n    ops = ast.literal_eval(list1_str)\n    args = ast.literal_eval(list2_str)\n    return ops, args\n\ndef format_output(results):\n    formatted = '[' + ', '.join(\n        'null' if v is None else\n        ('true' if v is True else ('false' if v is False else str(v)))\n        for v in results\n    ) + ']'\n    return formatted\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    stack = MyStack()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            continue\n        if op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n        else:\n            # Ignore unknown operations\n            pass\n\n    print(format_output(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for implementing a stack using two queues. We need to follow format: each line: 虛擬碼步驟 + space + // 解釋. Use Start, End, Decision:, arrows. Provide step-by-step for class methods.\n\nWe need to describe algorithm: use two queues q1 and q2. For push: enqueue to q1. For pop: move all elements except last from q1 to q2, then dequeue last from q1 as popped, then swap q1 and q2. For top: similar but keep last in q1, record value, move others to q2, then swap. empty: check q1 empty.\n\nWe need to provide steps in a flow-like pseudo code. Use decision points. Also we need to include Start/End. Provide each operation as a separate section? Probably we give overall structure then functions.\n\nLet's create high-level Start, then declare two queues, then methods. Each method start and end. Use Decision to check emptiness, etc.\n\nWe must output \"虛擬碼步驟\" (like \"Start\", \"→ Step 1: ...\") etc.\n\nLet's produce:\n\nStart // 程式開始\n→ Declare q1, q2 as empty queues // 初始化兩個空隊列\n→ Define push(x) // 推送 x\n    → q1.Enqueue(x) // 把 x 加到 q1\n→ End push\n→ Define pop() // 取出並返回頂部元素\n    → Decision: q1.isEmpty()? // 檢查是否有元素\n        Yes → Return null/throw // 為空時返回\n        No  → Step 1: size = q1.size() // 獲取大小\n        → For i = 1 to size-1:\n            → temp = q1.Dequeue() // 從前端取出\n            → q2.Enqueue(temp) // 放入 q2\n        → topElement = q1.Dequeue() // 最後一個元素即頂部\n        → Swap q1 and q2 // 交換兩個隊列\n        → Return topElement // 返回\n→ End pop\n→ Define top() // 取得頂部元素但不移除\n    → Decision: q1.isEmpty()?\n        Yes → Return null\n        No  → Step 1: size = q1.size()\n        → For i = 1 to size-1:\n            → temp = q1.Dequeue()\n            → q2.Enqueue(temp)\n        → topElement = q1.Dequeue()\n        → q2.Enqueue(topElement) // 把頂部放回 q2\n        → Swap q1 and q2\n        → Return topElement\n→ End top\n→ Define empty() // 判斷是否空\n    → Return q1.isEmpty() // 若 q1 空則整體空\n→ End empty\nEnd // 程式結束\n\nBut we must include decision branches within loops? Provide loops as \"For\". The format requires arrow, but loops can be indicated as steps.\n\nWe should use arrows: \"→\" preceding each step. Use \"Decision:\" with \"Yes →\" \"No →\" etc.\n\nLet's craft final answer accordingly.\n\n...done thinking.\n\nStart // 程式開始  \n→ Declare q1, q2 as empty queues // 初始化兩個空隊列  \n\n→ Define push(x) // 推送 x 到堆疊  \n    → q1.Enqueue(x) // 把 x 加到 q1  \n→ End push  \n\n→ Define pop() // 取出並返回頂部元素  \n    → Decision: q1.isEmpty()? // 檢查是否有元素  \n        Yes → Return null // 若空，直接回傳空值  \n        No  → Step 1: size = q1.size() // 獲取 q1 的大小  \n        → For i = 1 to size-1: // 移動除最後一個以外的所有元素  \n            → temp = q1.Dequeue() // 從前端取出  \n            → q2.Enqueue(temp) // 放入 q2  \n        → topElement = q1.Dequeue() // 最後一個元素即堆疊頂部  \n        → Swap q1 and q2 // 交換兩個隊列，保持 q1 為主隊列  \n        → Return topElement // 返回頂部元素  \n→ End pop  \n\n→ Define top() // 取得堆疊頂部元素但不移除  \n    → Decision: q1.isEmpty()?  \n        Yes → Return null // 空時回傳空值  \n        No  → Step 1: size = q1.size()  \n        → For i = 1 to size-1:  \n            → temp = q1.Dequeue()  \n            → q2.Enqueue(temp)  \n        → topElement = q1.Dequeue() // 取出頂部元素  \n        → q2.Enqueue(topElement) // 把頂部元素重新放回 q2  \n        → Swap q1 and q2 // 交換隊列  \n        → Return topElement // 回傳頂部元素  \n→ End top  \n\n→ Define empty() // 判斷堆疊是否為空  \n    → Return q1.isEmpty() // q1 為主隊列，若其空則堆疊為空  \n→ End empty  \n\nEnd // 程式結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    # Extract numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    numCourses = int(num_match.group(1)) if num_match else 0\n    # Extract prerequisites list\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*\\]\\])', data, re.S)\n    prerequisites = eval(pre_match.group(1)) if pre_match else []\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    numCourses, prerequisites = parse_input()\n    sol = Solution()\n    result = sol.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for topological sort problem. Use BFS Kahn's algorithm. Provide steps line by line with explanation.\n\nWe must not output actual code, only virtual steps. Use arrows, Decision etc.\n\nNeed to follow format: each line \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide steps: read inputs, build graph adjacency list, indegree array, queue initial nodes, while queue not empty, pop, add to order, decrease indegree of neighbors, enqueue if zero. After loop, if order length == numCourses return order else return empty.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 numCourses, prerequisites // 取得課程總數與先修關係  \n→ Step 2: 初始化 adjacencyList[numCourses] 為空陣列 // 建立每門課的鄰接清單  \n→ Step 3: 初始化 indegree[numCourses] 為 0 // 記錄每門課的前置課程數量  \n→ Decision: 是否有先修條目?  \n    Yes → Step 4: 針對每個 [a, b]  \n        → adjacencyList[b].append(a) // b 為前置，a 為後置  \n        → indegree[a] += 1 // a 的前置數量增加  \n    No → // 若無先修條目，跳過此步驟  \n→ Step 5: 初始化 queue 為空容器  \n→ Decision: 遍歷所有課程 i  \n    Yes → 如果 indegree[i] == 0  \n        → queue.enqueue(i) // 無前置課程，先加入隊列  \n    No  → // 有前置課程，跳過  \n→ Step 6: 初始化 order 為空陣列 // 儲存課程完成順序  \n→ Step 7: While queue 非空  \n    → Step 7a: current = queue.dequeue() // 取出首個課程  \n    → Step 7b: order.append(current) // 加入完成順序  \n    → Decision: 是否有後置課程於 adjacencyList[current]?  \n        Yes → Step 7c: 遍歷每個 neighbour in adjacencyList[current]  \n            → indegree[neighbour] -= 1 // 減少前置數量  \n            → Decision: indegree[neighbour] == 0?  \n                Yes → queue.enqueue(neighbour) // 前置全滿，加入隊列  \n                No  → // 還有前置課程，保持等待  \n        No  → // 無後置課程，跳過  \n→ Step 8: Decision: order.length == numCourses?  \n    Yes → Return order // 成功取得有效順序  \n    No  → Return [] // 無法完成所有課程，回傳空陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Super Ugly Number",
      "source_file": "Leetcode/leetcode313.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfe_252oz.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmpfe_252oz.py\", line 64, in main\n    n, primes = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfe_252oz.py\", line 46, in parse_input\n    primes = ast.literal_eval(val)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4386wd2h.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmp4386wd2h.py\", line 64, in main\n    n, primes = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4386wd2h.py\", line 46, in parse_input\n    primes = ast.literal_eval(val)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nthSuperUglyNumber(self, n, primes):\n        # ugly[0] = 1, indices for each prime\n        ugly = [1]\n        indices = [0] * len(primes)\n        vals = list(primes)\n\n        for _ in range(1, n):\n            next_ugly = min(vals)          # 取所有候選值的最小者\n            ugly.append(next_ugly)         # 存入超醜數序列\n\n            for i in range(len(primes)):\n                if vals[i] == next_ugly:\n                    indices[i] += 1          # 指標往後移\n                    vals[i] = ugly[indices[i]] * primes[i]\n\n        return ugly[-1]\n\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 n 與 primes。\n    支援兩種格式：\n    1. 'n = 12, primes = [2,7,13,19]'\n    2. 第一行為 n，第二行為 primes 列表\n    \"\"\"\n    data = data.strip()\n    if not data:\n        raise ValueError(\"空輸入\")\n\n    # 嘗試格式 1\n    if ',' in data:\n        parts = [p.strip() for p in data.split(',')]\n        n = None\n        primes = None\n        for part in parts:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            if key == 'n':\n                n = int(val)\n            elif key == 'primes':\n                primes = ast.literal_eval(val)\n        if n is None or primes is None:\n            raise ValueError(\"無法解析輸入\")\n        return n, primes\n\n    # 格式 2：兩行輸入\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        n = int(lines[0].strip())\n        primes = ast.literal_eval(lines[1].strip())\n        return n, primes\n\n    # 其他情況直接拋錯\n    raise ValueError(\"不支援的輸入格式\")\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    n, primes = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.nthSuperUglyNumber(n, primes)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find nth super ugly number. This is classic problem: use multiple pointers. Steps: Start array ugly[1..n] initialize ugly[1]=1. Maintain indices for each prime, pointer[i]=1. Next ugly number is min(prime[i]*ugly[pointer[i]]) for all i. Then assign to ugly[nextIndex]. For each i where that product equals new ugly, increment pointer[i]. Continue until n. Return ugly[n].\n\nWe need to output step-by-step virtual code lines, each line with // explanation. Use Start, End, Decision. Use arrows →. Must be line by line. Let's craft.\n\nLine1: Start // 開始\nLine2: → Step 1: 初始化 ugly[1] = 1 // 設定第一個超醜數\nLine3: → Step 2: 初始化 pointer[0..k-1] = 1 // 每個素數對應的指標\nLine4: → Step 3: 設定 idx = 1 // 當前已生成的超醜數數量\nLine5: → Decision: idx < n? // 是否已生成到第 n 個\nLine6:     Yes → Step 4: 計算 next = min(primes[i] * ugly[pointer[i]]) for all i // 找出下一個最小的候選值\nLine7:     Yes → Step 5: ugly[idx+1] = next // 存入新生成的超醜數\nLine8:     Yes → Step 6: 對於每個 i, 若 primes[i] * ugly[pointer[i]] == next，則 pointer[i]++ // 更新指標\nLine9:     Yes → Step 7: idx++ // 生成數量增加\nLine10:    Yes → Step 8: 返回到 Decision: idx < n? // 重新檢查\nLine11:    No → Step 9: 返回 ugly[n] // 完成，輸出第 n 個\nLine12: End // 程式結束\n\nBut need each line with arrow and explanation. Use consistent formatting. Also we might include for loop for i inside steps, but we can just describe generically.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 ugly[1] = 1 // 第一個超醜數為 1  \n→ Step 2: 初始化 pointer[0..k-1] = 1 // 每個素數對應的指標均指向 ugly 的第一個元素  \n→ Step 3: 設定 idx = 1 // 已生成的超醜數個數  \n→ Decision: idx < n? // 是否還需要生成更多  \n  Yes → Step 4: 計算 next = min( primes[i] * ugly[pointer[i]] ) for all i // 找出所有候選值中的最小者  \n  Yes → Step 5: ugly[idx+1] = next // 把這個最小值存入超醜數序列  \n  Yes → Step 6: 對每個 i, 若 primes[i] * ugly[pointer[i]] == next，則 pointer[i]++ // 更新所有相等候選者的指標  \n  Yes → Step 7: idx++ // 生成的超醜數個數增加  \n  Yes → Step 8: 返回到 Decision: idx < n? // 再次檢查是否已達第 n 個  \n  No → Step 9: 返回 ugly[n] // 第 n 個超醜數已生成，作為結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    try:\n        parsed = eval(\"{\" + data + \"}\", {}, {})\n    except Exception:\n        parsed = {}\n    beginWord = parsed.get('beginWord')\n    endWord = parsed.get('endWord')\n    wordList = parsed.get('wordList', [])\n    sol = Solution()\n    result = sol.findLadders(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm to find all shortest transformation sequences between beginWord and endWord given wordList. That's classic Word Ladder II problem. Approach: BFS to build graph and track levels, then DFS/DFS/backtracking to generate all paths.\n\nWe need step-by-step pseudocode line by line, each line ending with // explanation. Use Start, End, Decision, etc. We need to output in Chinese (繁體). Each line: \"虛擬碼步驟 // 解釋\".\n\nWe should show logic: Initialize sets, queue, adjacency map, BFS loop, build neighbors. Then backtracking.\n\nWe'll produce pseudocode lines:\n\nStart // 程式開始\n→ Step 1: 初始化 wordSet 為 wordList 的集合 // 將字典轉成集合便於查找\n→ Decision: 如果 endWord 不在 wordSet? // 確認終點是否可達\n    Yes → Return [] // 沒有結果\n    No → ...\n\nThen BFS:\n\n→ Step 2: 建立 queue 為 [[beginWord, [beginWord]]] // 以單詞和目前路徑\n→ Step 3: 建立 visited 集合為 {beginWord}\n→ Step 4: 建立 results 集合為空 // 存儲最短路徑\n\n→ Decision: 如果 queue 為空? // BFS 結束\n    Yes → Return results\n    No → …\n\nLoop: While queue not empty:\n\nWe need level-wise BFS: track level size, visited this level. We'll use levelVisited.\n\nSimplify pseudocode: use level variable.\n\nLet's produce:\n\n→ Step 5: 開始 BFS 迴圈\n    While queue 不是空:\n        size ← queue.length\n        levelVisited ← {}\n        for i in 0..size-1:\n            word, path ← queue.pop()\n            for each neighbor in generateNeighbors(word):\n                if neighbor == endWord:\n                    results.append(path + [neighbor])\n                    foundEnd ← True\n                if neighbor not in visited and neighbor not in levelVisited:\n                    levelVisited.add(neighbor)\n                    queue.append([neighbor, path + [neighbor]])\n        if foundEnd:\n            break\n        visited.update(levelVisited)\n\nAfter BFS, results contains all shortest sequences.\n\nThen output results.\n\nWe need to show generateNeighbors: For each position replace letter with a-z.\n\n→ Step 6: 定義 generateNeighbors(word):\n    neighbors ← []\n    for i in 0..len(word)-1:\n        for c in 'a'..'z':\n            if c != word[i]:\n                newWord ← word[0:i] + c + word[i+1:]\n                if newWord in wordSet:\n                    neighbors.append(newWord)\n    return neighbors\n\nFinally:\n\n→ Step 7: Return results\n\nWe need to produce line-by-line pseudocode with explanations, using arrows and decisions. Also ensure each line is separate.\n\nLet's structure:\n\nStart // 程式開始\n→ Step 1: wordSet ← Set(wordList) // 轉成集合\n→ Decision: 如果 endWord 不在 wordSet? // 檢查是否可達\n    Yes → Return [] // 沒結果\n    No  → …\n\nDefine generateNeighbors function.\n\nBut we need to keep it line-by-line.\n\nBetter: Provide pseudocode lines with function definitions separate.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: wordSet ← Set(wordList) // 將字典轉為集合\n→ Decision: 如果 endWord 不在 wordSet? // 確認終點存在\n    Yes → Return [] // 無路徑\n    No  → ...\n\n→ Step 2: queue ← [[beginWord, [beginWord]]] // BFS佇列，元素為 [單詞, 路徑]\n→ Step 3: visited ← {beginWord} // 已訪問集合\n→ Step 4: results ← [] // 儲存所有最短路徑\n→ Step 5: foundEnd ← False // 是否已找到終點\n→ Step 6: While queue 不是空: // BFS 循環\n    → Decision: 如果 foundEnd? // 若已找到最短層則停止\n        Yes → Break\n        No  →\n            size ← len(queue) // 本層節點數\n            levelVisited ← {} // 本層新訪問\n            for i in 0..size-1:\n                word, path ← queue.pop(0) // 取隊首\n                for neighbor in generateNeighbors(word):\n                    if neighbor == endWord:\n                        results.append(path + [neighbor]) // 加入結果\n                        foundEnd ← True\n                    if neighbor not in visited and neighbor not in levelVisited:\n                        levelVisited.add(neighbor)\n                        queue.append([neighbor, path + [neighbor]])\n            visited.update(levelVisited) // 更新全局已訪問\n\n→ Function: generateNeighbors(word)\n    ← Step 7: neighbors ← [] // 儲存相鄰單詞\n    ← for i in 0..len(word)-1:\n        ← for c in 'a'..'z':\n            ← if c != word[i]:\n                ← newWord ← word[:i] + c + word[i+1:]\n                ← if newWord in wordSet:\n                    ← neighbors.append(newWord)\n    ← Return neighbors\n\n→ Step 8: Return results // 回傳所有最短序列\n\nWe need to produce each line with virtual code and explanation. The lines within for loops must also be separate lines. But the instruction: \"逐行地產生對應的虛擬碼\" Each line of virtual code followed by explanation. So we need to include each line of pseudocode as a separate line. We should not include code blocks? They said just output lines. So each line as \"虛擬碼步驟 // 解釋\".\n\nUse arrow \"→\" or \"Start\" etc.\n\nLet's craft final output. Use \"Start\", \"End\". Provide decisions with Yes → and No →.\n\nLet's do it.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: wordSet ← Set(wordList) // 把字典轉成集合，方便 O(1) 查找\n\n→ Decision: 如果 endWord 不在 wordSet? // 確認終點是否存在於字典\n    Yes → Return [] // 結果為空，直接結束\n    No  → // 繼續執行\n\n→ Step 2: queue ← [[beginWord, [beginWord]]] // BFS 佇列，每項為 [當前單詞, 已走路徑]\n→ Step 3: visited ← {beginWord} // 記錄已被訪問的單詞，避免重複\n→ Step 4: results ← [] // 存放所有最短轉換序列\n→ Step 5: foundEnd ← False // 標記是否已在此層找到 endWord\n\n→ Decision: queue 為空? // 若佇列已空，結束\n    Yes → Return results // 直接回傳結果\n    No  → // 進入 BFS 迴圈\n\n→ While queue 不是空: // 開始層級 BFS\n    → Decision: foundEnd? // 若已找到最短層，則終止\n        Yes → Break\n        No  →\n            size ← len(queue) // 本層節點數\n            levelVisited ← {} // 本層新增訪問集合\n            → for i in 0..size-1:\n                → word, path ← queue.pop(0) // 取隊首元素\n                → for neighbor in generateNeighbors(word): // 產生相鄰單詞\n                    → Decision: neighbor == endWord? // 是否到達終點\n                        Yes →\n                            results.append(path + [neighbor]) // 加入一條完整路徑\n                            foundEnd ← True // 標記已找到\n                        No  →\n                            → Decision: neighbor 不在 visited 且不在 levelVisited? // 確保此層未重複訪問\n                                Yes →\n                                    levelVisited.add(neighbor) // 標記為本層已訪問\n                                    queue.append([neighbor, path + [neighbor]]) // 加入佇列以備後續層處理\n                                No  → // 已訪問，略過\n            → visited.update(levelVisited) // 把本層已訪問的單詞加入全局已訪問集合\n\n→ Function: generateNeighbors(word)\n    ← Step 7: neighbors ← [] // 儲存所有合法相鄰單詞\n    ← for i in 0..len(word)-1:\n        ← for c in 'a'..'z':\n            ← Decision: c != word[i]? // 只替換不同字母\n                Yes →\n                    ← newWord ← word[:i] + c + word[i+1:] // 產生新單詞\n                    ← Decision: newWord in wordSet? // 是否在字典中\n                        Yes → neighbors.append(newWord) // 合法相鄰\n                        No  → // 當前字母不合法，略過\n    ← Return neighbors\n\n→ Step 8: Return results // 回傳所有最短轉換序列\n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.26583096992824057,-0.3479723033801796],[0.09659437966733345,0.7345095266659335],[0.12508292658094175,0.45633842562872234]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.26583096992824057, -0.3479723033801796], [0.09659437966733345, 0.7345095266659335], [0.12508292658094175, 0.45633842562872234]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 使用極座標隨機生成點\n        r = self.radius * math.sqrt(random.random())  # sqrt 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    lines = data.splitlines()\n    if len(lines) < 2:\n        return\n    methods = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(obj, method)\n            results.append(func(*args))\n\n    print(json.dumps(results, ensure_ascii=False))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The code: start, initialization, store radius and center, randPoint: generate random r and theta, convert to Cartesian, return. Use random uniform. Steps. Ensure proper steps.\n\nWe must include Start, End, Decision, arrows. No actual code. Just pseudocode steps.\n\nLet's craft lines:\n\nStart\n→ Step 1: Store radius, center coordinates in object properties // 初始化物件屬性\n→ Step 2: Define randPoint function // 產生隨機點\n    → Step 3: Generate random number u in [0,1] // 隨機長度比例\n    → Step 4: Compute radius r = sqrt(u) * radius // 轉換為均勻分布的半徑\n    → Step 5: Generate random angle theta in [0,2π] // 隨機角度\n    → Step 6: Compute x = x_center + r * cos(theta) // 將極座標轉為直角座標\n    → Step 7: Compute y = y_center + r * sin(theta) // 同上\n    → Step 8: Return [x, y] // 回傳隨機點\nEnd\n\nNeed to include arrow formatting. Use \"→\" between steps. Decision not needed except maybe to decide? Not required. So just sequential steps.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Store radius, x_center, y_center in object properties // 初始化物件屬性  \n→ Step 2: Define function randPoint() // 產生隨機點的主函式  \n  → Step 3: Generate random number u ∈ [0,1] // 隨機長度比例，確保均勻分佈  \n  → Step 4: Compute r = sqrt(u) * radius // 將比例轉為半徑，使用平方根以得到均勻點  \n  → Step 5: Generate random angle theta ∈ [0, 2π] // 隨機角度，覆蓋整個圓周  \n  → Step 6: Compute x = x_center + r * cos(theta) // 從極座標轉為直角座標（x）  \n  → Step 7: Compute y = y_center + r * sin(theta) // 同上（y）  \n  → Step 8: Return [x, y] // 回傳隨機點，包含圓周上的點  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeElement(self, nums, val):\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list of numbers and the value to remove\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if not nums_match or not val_match:\n        return\n\n    nums_str = nums_match.group(1)\n    val_str = val_match.group(1)\n\n    nums = ast.literal_eval(nums_str)\n    val = int(val_str)\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # Prepare the display of the array: keep first k elements, underscore for the rest\n    display = [str(nums[i]) if i < k else '_' for i in range(len(nums))]\n    print(f\"{k}, nums = [{','.join(display)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The algorithm: two-pointer technique. Use write pointer to keep index for non-val elements. Iterate read pointer over array. If nums[i] != val, assign nums[write] = nums[i] and increment write. After loop, return write. Need to produce virtual code step by step. Use Start, End, Decision. We'll produce:\n\nStart\n→ Step 1: initialize write = 0 // pointer for placing next non-val element\n→ Step 2: for read from 0 to length-1 // iterate over all elements\n    → Decision: if nums[read] != val? // check if current element should stay\n        Yes → Step 3: nums[write] = nums[read] // place element at write position\n        Yes → Step 4: write = write + 1 // move write pointer\n    No → // do nothing (skip val)\n→ Step 5: return write // number of retained elements\n\nBut need to format each line with virtual code step and comment. Use arrow arrow. Use Decision. Should be each line as \"虛擬碼步驟 // 解釋\". Use Start and End. Let's produce lines:\n\nStart // 程式開始\n→ Step 1: write = 0 // 初始化寫指標，指向下一個可放置元素的位置\n→ Step 2: for read = 0 to nums.length - 1 // 逐個讀取陣列元素\n    → Decision: if nums[read] ≠ val? // 判斷此元素是否要保留\n        Yes → Step 3: nums[write] = nums[read] // 把非 val 元素寫入 write 所在位置\n        Yes → Step 4: write = write + 1 // 移動寫指標\n        No  → // 直接跳過 val 元素，不做任何操作\n→ Step 5: return write // write 即為保留元素的個數 k\nEnd // 程式結束\n\nNeed to ensure formatting: each line \"→ Step ...\" etc. We need to indent for nested lines? Not necessary but can show with spaces. Use \"→ Decision:\" line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: write = 0 // 初始化寫指標，指向下一個可放置元素的位置\n→ Step 2: for read = 0 to nums.length - 1 // 逐個讀取陣列元素\n    → Decision: if nums[read] ≠ val? // 判斷此元素是否要保留\n        Yes → Step 3: nums[write] = nums[read] // 把非 val 元素寫入 write 所在位置\n        Yes → Step 4: write = write + 1 // 移動寫指標\n        No  → // 跳過 val 元素，直接繼續下一輪\n→ Step 5: return write // write 即為保留元素的個數 k\nEnd // 程式結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取 strs、m、n。\n    期望輸入類似：\n        strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    \"\"\"\n    # 抽取所有雙引號內的字串\n    strs = re.findall(r'\"([^\"]*)\"', data)\n    # 把所有數字取出，第一個為 m，第二個為 n\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        return [], 0, 0\n    m, n = int(nums[0]), int(nums[1])\n    return strs, m, n\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read().strip()\n    if not raw_data:\n        sys.exit(0)\n    strs, m, n = parse_input(raw_data)\n    solution = Solution()\n    result = solution.findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the classic problem \"Ones and Zeros\" from LeetCode. Use dynamic programming: dp[i][j] largest subset size with i zeros and j ones. Iterate over each string compute zeros, ones. Update dp from m down to zeros and n down to ones.\n\nWe need to output step-by-step virtual code lines, each with explanation. Use arrows and Decision etc. Provide a clear algorithm.\n\nWe need to include Start, End, Decision, Steps. Use pseudo-code.\n\nWe should produce step-by-step. Each line: \"Start // 程式開始執行\" etc.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize 2D array dp of size (m+1) x (n+1) with 0 // dp[i][j] stores largest subset size with i zeros and j ones\n→ Step 2: For each string s in strs: // iterate over all strings\n    → Step 2.1: Count zeros z and ones o in s // compute counts\n    → Step 2.2: For i from m down to z: // iterate capacity downwards\n        → Step 2.2.1: For j from n down to o: // iterate capacity downwards\n            → Decision: If dp[i-z][j-o] + 1 > dp[i][j]? // check if adding current string improves subset size\n                Yes → Step 2.2.1.1: dp[i][j] = dp[i-z][j-o] + 1 // update dp\n                No → Step 2.2.1.2: // do nothing\n→ Step 3: Return dp[m][n] // maximum subset size\n\nWe need to format exactly: each line has virtual code step, space, comment. Use arrow. Use indentation? The sample shows indentation with tabs. Use indentation to reflect nested decisions.\n\nLet's produce.\n\nUse Start, End. Use Step numbers? They can be step labels.\n\nWe need to use \"Decision:\" lines for if. Provide \"Yes →\" and \"No →\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Initialize 2D array dp[m+1][n+1] with zeros // 建立 dp 表，用來存最大子集合大小\n→ Step 2: For each string s in strs: // 逐一處理每個二進位字串\n    → Step 2.1: Count zeros z and ones o in s // 計算該字串中 0 與 1 的數量\n    → Step 2.2: For i from m down to z: // 從容量上限向下遍歷，避免重複使用同一字串\n        → Step 2.2.1: For j from n down到 o: // 同理處理 1 的容量\n            → Decision: dp[i-z][j-o] + 1 > dp[i][j]? // 判斷加入該字串是否能提高子集合大小\n                Yes → Step 2.2.1.1: dp[i][j] = dp[i-z][j-o] + 1 // 更新 dp 值\n                No → // 不更新\n→ Step 3: Return dp[m][n] // 最終答案為 dp 表右下角的值\nEnd // 程式結束\n\nCheck formatting: Each line has step, space, comment. Indentation for nested levels; use tabs or spaces? Use indentation with 4 spaces.\n\nNeed to include arrows '→' at start of each step line. For Decision lines, indent accordingly.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize 2D array dp[m+1][n+1] with zeros // 建立 dp 表，用來存最大子集合大小\n→ Step 2: For each string s in strs: // 逐一處理每個二進位字串\n    → Step 2.1: Count zeros z and ones o in s // 計算該字串中 0 與 1 的數量\n    → Step 2.2: For i from m down to z: // 從容量上限向下遍歷，避免重複使用同一字串\n        → Step 2.2.1: For j from n down to o: // 同理處理 1 的容量\n            → Decision: dp[i-z][j-o] + 1 > dp[i][j]? // 判斷加入該字串是否能提高子集合大小\n                Yes → Step 2.2.1.1: dp[i][j] = dp[i-z][j-o] + 1 // 更新 dp 值\n                No  → // 不更新\n→ Step 3: Return dp[m][n] // 最終答案為 dp 表右下角的值\nEnd // 程式結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport ast\nimport json\n\nclass Solution:\n    \"\"\"用於陣列隨機洗牌與重置的類別\"\"\"\n\n    def __init__(self, nums):\n        \"\"\"初始化，保存原始陣列\"\"\"\n        self.nums = list(nums)  # 深拷貝，避免外部修改\n\n    def reset(self):\n        \"\"\"重置為原始順序並回傳\"\"\"\n        return self.nums\n\n    def shuffle(self):\n        \"\"\"使用 Fisher‑Yates 演算法隨機洗牌並回傳新陣列\"\"\"\n        arr = list(self.nums)  # 不改動原陣列\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)  # 隨機選取 [i, n-1]\n            arr[i], arr[j] = arr[j], arr[i]  # 交換元素\n        return arr\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 將兩個列表拆分\n    split_index = data.index('],')\n    commands_str = data[:split_index + 1]\n    args_str = data[split_index + 2:].strip()\n\n    # 轉成 Python 物件\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    output = []\n    sol = None\n\n    # 執行各個指令\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            sol = Solution(arg[0])  # arg[0] 是原始陣列\n            output.append(None)     # 建構子不回傳值，使用 null\n        elif cmd == \"reset\":\n            output.append(sol.reset())\n        elif cmd == \"shuffle\":\n            output.append(sol.shuffle())\n\n    # 輸出結果，使用 JSON 以符合題目格式\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: constructor stores original copy, reset returns original, shuffle uses Fisher-Yates. Use the specified format. Each line: Virtual code step + space + // explanation. Use arrows. Ensure start, decision etc.\n\nWe must produce step-by-step, with decisions? The algorithm doesn't need decisions besides maybe loop.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // ...\n→ Step 2: 複製陣列到原始陣列 orig // ...\n→ End // 初始化結束\n\nBut we need a class definition. Might use Step 1: 定義類別 Solution // ...\n\nWe'll produce virtual steps for each method: Constructor, reset, shuffle.\n\nAlso include internal helper: FisherYates. Use loop.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類\n→ Step 2: 定義成員變數 nums, orig // 儲存陣列與原始副本\n→ Step 3: 定義建構子 (int[] nums) // 初始化\n    → Step 4: 複製傳入陣列到 this.nums // 以便修改\n    → Step 5: 創建 this.orig 為 this.nums 的深拷貝 // 保存原始順序\n→ Step 6: 定義 reset() 方法 // 重置陣列\n    → Step 7: 將 this.nums 設為 this.orig 的深拷貝 // 還原\n    → Step 8: 回傳 this.nums // 返回重置後陣列\n→ Step 9: 定義 shuffle() 方法 // 隨機打亂陣列\n    → Step 10: 產生隨機數生成器 rng // 用於隨機數\n    → Step 11: 進行 Fisher-Yates 演算法\n        → Decision: 迴圈從 i = this.nums.length-1 到 1 // 檢查索引\n            Yes → Step 12: 隨機產生 j in [0, i] // 取得隨機位置\n            → Step 13: 交換 this.nums[i] 與 this.nums[j] // 交換元素\n            → Step 14: i = i-1 // 更新索引\n        → End // 迴圈結束\n    → Step 15: 回傳 this.nums // 返回打亂後陣列\nEnd // 程式結束\n\nWe need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow as shown: \"→ Step 1: ...\".\n\nAlso need Decision lines: \"Decision: ...\".\n\nWe need indentation? They show indent for nested steps. We can indent with spaces.\n\nWe'll produce each line exactly following.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類  \n→ Step 2: 定義成員變數 nums, orig // 儲存陣列與原始副本  \n→ Step 3: 定義建構子 (int[] nums) // 初始化物件  \n → Step 4: 複製傳入陣列到 this.nums // 以便於隨機打亂  \n → Step 5: 創建 this.orig 為 this.nums 的深拷貝 // 保留原始順序  \n→ Step 6: 定義 reset() 方法 // 重置陣列  \n → Step 7: 將 this.nums 設為 this.orig 的深拷貝 // 還原到原始配置  \n → Step 8: 回傳 this.nums // 回傳重置後陣列  \n→ Step 9: 定義 shuffle() 方法 // 隨機打亂陣列  \n → Step 10: 產生隨機數生成器 rng // 用於產生隨機索引  \n → Step 11: 進行 Fisher-Yates 演算法  \n  → Decision: 從 i = this.nums.length-1 到 1 迴圈? // 檢查是否還有未處理元素  \n   Yes → Step 12: 隨機產生 j in [0, i] // 取得隨機位置  \n   → Step 13: 交換 this.nums[i] 與 this.nums[j] // 交換元素以打亂順序  \n   → Step 14: i = i-1 // 移動到下一個索引  \n  → End // 迴圈結束  \n → Step 15: 回傳 this.nums // 返回打亂後陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\ndef subsets(nums):\n    \"\"\"Return all subsets of the list `nums`.\"\"\"\n    result = []\n\n    def backtrack(start, path):\n        # 當前子集完成，加入結果\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])          # 包含 nums[i]\n            backtrack(i + 1, path)        # 進一步遞迴\n            path.pop()                    # 回溯：移除最後加入的元素\n\n    backtrack(0, [])\n    return result\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取原始資料\n    data = sys.stdin.read().strip()\n\n    # 找到第一個 '[' 與最後一個 ']' 之間的字串並解析為 Python list\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group(0)\n    else:\n        nums_str = data  # 如果輸入本身就是 list 字串\n\n    # 使用 literal_eval 安全地解析字串為 list\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        nums = []\n\n    # 計算子集並輸出\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to generate all subsets of a unique integer array, using backtracking. Each line: virtual code step + space + comment.\n\nWe must use Start, End, Decision: etc. Should be line-by-line.\n\nLet's produce:\n\nStart\n→ Step 1: sort array? Not necessary but might keep order. But can just use original array.\n\nBut we can assume input array \"nums\". We will use backtracking.\n\nDefine function backtrack(index, currentSubset)\n- if index == len(nums): add currentSubset copy to result\n- else:\n    - Decision: Include current element?\n        Yes → add nums[index] to currentSubset → backtrack(index+1, currentSubset)\n        No  → backtrack(index+1, currentSubset)\n- After recursion, remove element if included.\n\nWe need to output solution list.\n\nWe'll produce steps accordingly.\n\nLet's craft. Each line includes virtual code step.\n\nLet's produce steps:\n\nStart // 程式開始執行\n→ Step 1: Initialize result list ← [] // 用於儲存所有子集\n→ Step 2: Call backtrack(0, []) // 從索引0開始回溯\n→ Function backtrack(index, subset) // 定義回溯函式\n    → Decision: if index == length(nums)? // 判斷是否已處理完所有元素\n        Yes → Step 3: Append copy of subset to result // 完整子集加入結果\n        No  → Step 4: Decision: Include nums[index] in subset? // 決定是否加入當前元素\n            Yes → Step 5: Append nums[index] to subset // 將元素加入子集\n            → Step 6: backtrack(index+1, subset) // 進一步回溯\n            → Step 7: Remove last element from subset // 回溯結束後移除元素\n            No  → Step 8: backtrack(index+1, subset) // 直接跳過當前元素\n→ End // 程式執行結束\n→ Step 9: Return result // 傳回所有子集\n\nBut we need to align each line with arrow and comment. Also we need to include decision branches.\n\nBetter format:\n\nStart // 程式開始執行\n→ Step 1: Initialize result ← [] // 建立儲存子集的列表\n→ Step 2: Call backtrack(0, []) // 從第一個元素開始回溯\n→ Function backtrack(index, subset) // 回溯函式\n    → Decision: if index == len(nums)? // 判斷是否已遍歷完所有元素\n        Yes → Step 3: Append copy(subset) to result // 加入完整子集到結果\n        No  → Step 4: Decision: Include nums[index]? // 選擇是否加入目前元素\n            Yes → Step 5: Append nums[index] to subset // 加入元素\n            → Step 6: backtrack(index+1, subset) // 進一步處理下一個元素\n            → Step 7: Remove last element from subset // 回溯，移除元素\n            No  → Step 8: backtrack(index+1, subset) // 直接跳過當前元素\n→ End // 程式執行結束\n→ Step 9: Return result // 回傳所有子集\n\nMake sure to include \"→\" at start of each line except Start? They used Start without arrow in example. We'll follow same: Start //, End //, Step lines start with arrow.\n\nAlso we should include arrows inside decision branches: \"Yes →\", \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result ← [] // 建立儲存子集的空列表  \n→ Step 2: 呼叫 backtrack(0, []) // 從第一個元素開始回溯  \n→ Function backtrack(index, subset) // 定義回溯函式  \n  → Decision: index == len(nums) ? // 判斷是否已遍歷完所有元素  \n   Yes → Step 3: result.append(copy(subset)) // 加入完整子集到結果  \n   No  → Step 4: Decision: 是否包含 nums[index] ? // 選擇是否加入目前元素  \n    Yes → Step 5: subset.append(nums[index]) // 加入元素  \n     → Step 6: backtrack(index+1, subset) // 進一步處理下一個元素  \n     → Step 7: subset.pop() // 回溯，移除剛加入的元素  \n    No  → Step 8: backtrack(index+1, subset) // 直接跳過當前元素  \n→ End // 程式執行結束  \n→ Step 9: 回傳 result // 傳回所有子集列表"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef originalDigits(s: str) -> str:\n    \"\"\"給定一串字母，還原其中出現的數字並按升序輸出。\"\"\"\n    count = Counter(s)\n\n    # 先用唯一字母確定對應的數字\n    out = {}\n    out['0'] = count['z']   # zero\n    out['2'] = count['w']   # two\n    out['4'] = count['u']   # four\n    out['6'] = count['x']   # six\n    out['8'] = count['g']   # eight\n\n    # 再用剩餘字母確定其他數字\n    out['3'] = count['h'] - out['8']   # three\n    out['5'] = count['f'] - out['4']   # five\n    out['7'] = count['s'] - out['6']   # seven\n\n    # 1, 9 需要結合多個字母消除\n    out['1'] = count['o'] - out['0'] - out['2'] - out['4']   # one\n    out['9'] = count['i'] - out['5'] - out['6'] - out['8']   # nine\n\n    # 依照升序組成最終字串\n    res = [k * out[k] for k in sorted(out.keys())]\n    return ''.join(res)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，移除所有非字母字符（以適應「s = ...」之類格式）\n    raw_input = sys.stdin.read()\n    s = ''.join(re.findall(r'[a-zA-Z]', raw_input))\n    print(originalDigits(s))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving: given string s with letters forming English words for digits 0-9 but out of order, return digits in ascending order.\n\nWe need to produce step-by-step pseudocode with arrow notation.\n\nWe should handle mapping, counting letters, unique letters to identify digits.\n\nWe should produce a general algorithm.\n\nNeed to produce virtual code with step lines.\n\nWe need to ensure each line ends with // explanation.\n\nWe need to use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's design steps:\n\nStart\n→ Step 1: Count frequency of each letter in s // Build letter count map\n→ Step 2: Initialize digit_counts array of size 10 to zero // To store count of each digit\n→ Step 3: For each unique identifying letter for digits:\n   - For digits that have unique letters in the spelled-out word: e.g., 'z' for zero, 'w' for two, 'u' for four, 'x' for six, 'g' for eight\n→ For each such letter, compute count = frequency[letter]\n   - Set digit_counts[digit] = count\n   - For each letter in that digit's word, decrement frequency by count * number of times letter appears\n   - // Explanation\n→ Step 4: Continue with remaining digits that can be identified after removal:\n   - 'o' for one (after zero, two, four removed)\n   - 'h' for three (after eight removed)\n   - 'f' for five (after four removed)\n   - 's' for seven (after six removed)\n   - 'i' for nine (after five, six, eight removed)\n→ Step 5: For each of these letters, compute count, update digit_counts and reduce frequency\n→ Step 6: Construct result string by appending digit repeated digit_counts times in ascending order\n→ End\n\nBut need to show each step line by line. Let's produce detailed pseudo lines. For loops we might need to represent as \"For each\" lines.\n\nWe need to produce each line with arrow symbol '→' or 'Start' 'End'.\n\nWe should also represent decision steps if any.\n\nWe can incorporate decisions when computing counts? But not necessary.\n\nBut they might want to see loops. We'll express loops as separate lines.\n\nMake sure to use \"→\" before each line after start, and indent decisions etc.\n\nWe should ensure each line ends with // explanation.\n\nLet's produce. Use \"→ Step X:\" style.\n\nWe'll keep steps enumerated for readability.\n\nLet's generate.\n\nWe also might want to show a mapping dictionary.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: letter_count ← map of character frequencies from s // 建立字母頻率表\n→ Step 2: digit_counts ← array[10] of zeros // 以存放各位數字出現次數\n\nNow unique letter identification:\n\n→ Step 3: For each (letter, digit, word) in [('z',0,'zero'),('w',2,'two'),('u',4,'four'),('x',6,'six'),('g',8,'eight')]:\n    // 依照唯一字母確定對應數字\n\nWe need to express loop properly: maybe:\n\n→ Step 3: For each unique mapping (letter, digit, word) in list:\n    → Step 3.1: count ← letter_count[letter] // 獲取該唯一字母的出現次數\n    → Step 3.2: digit_counts[digit] ← count // 記錄該數字出現次數\n    → Step 3.3: For each ch in word:\n        → Step 3.3.1: letter_count[ch] ← letter_count[ch] - count // 減去已使用的字母\n        // ... explanation\n\nThen proceed to other digits:\n\n→ Step 4: For each (letter, digit, word) in [('o',1,'one'),('h',3,'three'),('f',5,'five'),('s',7,'seven'),('i',9,'nine')]:\n    // 依照剩餘字母確定其他數字\n    → Step 4.1: count ← letter_count[letter]\n    → Step 4.2: digit_counts[digit] ← count\n    → Step 4.3: For each ch in word:\n        → Step 4.3.1: letter_count[ch] ← letter_count[ch] - count\n\nThen build result:\n\n→ Step 5: result ← empty string // 用於儲存最終數字字串\n→ Step 6: For d from 0 to 9:\n    → Step 6.1: result ← result + repeat(d, digit_counts[d]) // 將每個數字重複對應次數追加\n\n→ End // 程式執行結束\n\nWe may need to show \"repeat\" pseudo. Good.\n\nMake sure each line includes // explanation. Provide short intuitive explanation.\n\nAlso ensure that inside loops, we maintain arrow and explanation.\n\nWe may need to represent nested loops with indentation but still arrow. We can just prefix with arrow each sub-step.\n\nAlso we need to show decisions? Not needed.\n\nBut might include \"Decision\" if we had to check something, but not needed.\n\nLet's produce final output accordingly. Ensure each line is separate.\n\nWe need to format with \"Start\" line, \"End\" line. Use arrow for each subsequent line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: letter_count ← count frequencies of each character in s // 建立字母頻率表  \n→ Step 2: digit_counts ← array[10] of zeros // 用於記錄每個數字出現次數  \n\n→ Step 3: For each (letter, digit, word) in [('z',0,'zero'),('w',2,'two'),('u',4,'four'),('x',6,'six'),('g',8,'eight')]: // 先處理擁有唯一字母的數字  \n → Step 3.1: count ← letter_count[letter] // 取得唯一字母的出現次數  \n → Step 3.2: digit_counts[digit] ← count // 記錄該數字的數量  \n → Step 3.3: For each ch in word: // 把已使用的字母從頻率表中減去  \n  → Step 3.3.1: letter_count[ch] ← letter_count[ch] - count // 更新頻率  \n\n→ Step 4: For each (letter, digit, word) in [('o',1,'one'),('h',3,'three'),('f',5,'five'),('s',7,'seven'),('i',9,'nine')]: // 處理剩餘數字  \n → Step 4.1: count ← letter_count[letter] // 取得剩餘字母的出現次數  \n → Step 4.2: digit_counts[digit] ← count // 記錄該數字的數量  \n → Step 4.3: For each ch in word: // 逐字減去已使用字母  \n  → Step 4.3.1: letter_count[ch] ← letter_count[ch] - count // 更新頻率  \n\n→ Step 5: result ← \"\" // 用於儲存最終數字字串  \n→ Step 6: For d from 0 to 9: // 按升序組裝結果  \n → Step 6.1: result ← result + repeat(d, digit_counts[d]) // 將每個數字重複對應次數追加到結果  \n\nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa1gk8gws.py\", line 57, in <module>\n    ops = ast.literal_eval(ops_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"LFUCache\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int) -> None:\n        \"\"\"Increment frequency of an existing key.\"\"\"\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key (and least recently used among them)\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key with frequency 1\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Parse input like: '[\"LFUCache\", \"put\", ...], [[2], [1, 1], ...]'\n    ops_str, args_str = data.split(',', 1)\n    ops = ast.literal_eval(ops_str)\n    args_list = ast.literal_eval(args_str)\n    results = []\n    cache = None\n    for op, args in zip(ops, args_list):\n        if op == \"LFUCache\":\n            cache = LFUCache(*args)\n            results.append(None)\n        elif op == \"put\":\n            cache.put(*args)\n            results.append(None)\n        elif op == \"get\":\n            res = cache.get(*args)\n            results.append(res)\n    # Convert None to null for output format\n    output = []\n    for r in results:\n        if r is None:\n            output.append(\"null\")\n        else:\n            output.append(str(r))\n    print(\"[\" + \", \".join(output) + \"]\")",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for implementing LFUCache. Must be in Traditional Chinese. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Should be line-by-line explanation of algorithm. Since requirement: implement LFUCache with O(1). We can use min frequency list, key to node map, freq to doubly linked list. Provide steps for constructor, get, put.\n\nWe'll output step by step. Let's craft steps:\n\nStart\n→ Initialize capacity, minFreq, maps: keyNodeMap, freqListMap\n→ Constructor details\n→ get steps\n→ Decision if key exists\n→ If exists: update freq\n→ update minFreq maybe\n→ return value\n→ else return -1\n→ put steps\n→ If capacity 0 return\n→ Decision if key exists\n→ If exists: update value, update freq\n→ else: check capacity full\n→ Decision if full\n→ If full: evict least frequently used (minFreq list head)\n→ Remove key from maps\n→ Add new node freq=1\n→ Update freqListMap, minFreq=1\n→ End\n\nAlso include helper functions: incrementFrequency(node). Provide explanation.\n\nLet's produce each line with comment. Use \"Step\" labels.\n\nEnsure each line: \"Step: ... // ...\"\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 capacity, minFreq = 0, keyNodeMap = 空字典, freqListMap = 空字典 // 建立主資料結構\n\n→ Step 2: 定義 Node 類別 { key, value, freq, prev, next } // 每個鍵值對存儲頻率及鏈表指針\n\n→ Step 3: 定義 DoublyLinkedList 類別 { head, tail, size, addNode(node), removeNode(node), removeHead() } // 便於 O(1) 插入與刪除\n\n→ Step 4: 定義 incFrequency(node) // 升級節點頻率的輔助函式\n    → Step 5: 從 freqListMap[node.freq] 中移除 node // 刪除舊頻率鏈表\n    → Step 6: node.freq += 1 // 令頻率加 1\n    → Step 7: 如果 freqListMap[node.freq] 不存在，建立新鏈表 // 準備新頻率層\n    → Step 8: 在 freqListMap[node.freq] 中加入 node // 插入新頻率層\n    → Step 9: 如果舊頻率鏈表空且 minFreq == node.freq - 1，minFreq += 1 // 更新 minFreq\n\n→ Decision: get(key) // 取得指定鍵\n    Yes → Step 10: 如果 keyNodeMap 中不存在 key，返回 -1 // 不存在直接返回\n    No  → Step 11: node = keyNodeMap[key] // 取得節點\n    → Step 12: incFrequency(node) // 更新頻率\n    → Step 13: 返回 node.value // 回傳值\n\n→ Decision: put(key, value) // 插入或更新鍵\n    Yes → Step 14: 如果 capacity == 0，直接返回 // 空容量不進行任何操作\n    No  → Step 15: 如果 keyNodeMap 中存在 key\n        Yes → Step 16: node = keyNodeMap[key] // 取得節點\n        → Step 17: node.value = value // 更新值\n        → Step 18: incFrequency(node) // 更新頻率\n        No  → Step 19: 如果 keyNodeMap.size == capacity // 檢查是否已滿\n            Yes → Step 20: list = freqListMap[minFreq] // 找到最小頻率鏈表\n            → Step 21: nodeToRemove = list.removeHead() // 取出最舊節點（最近最少使用）\n            → Step 22: 移除 keyNodeMap[nodeToRemove.key] // 從鍵值映射中刪除\n            No  → （不做任何事，因為空間足夠）\n        → Step 23: 新建 node = Node(key, value, freq=1) // 新節點，頻率為 1\n        → Step 24: 如果 freqListMap[1] 不存在，建立新鏈表\n        → Step 25: freqListMap[1].addNode(node) // 加入頻率 1 鏈表\n        → Step 26: keyNodeMap[key] = node // 更新鍵值映射\n        → Step 27: minFreq = 1 // 新插入的最小頻率為 1\n\nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List, Dict\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str) -> List[int]:\n        memo: Dict[str, List[int]] = {}\n\n        def ways(expr: str) -> List[int]:\n            if expr in memo:\n                return memo[expr]\n\n            res: List[int] = []\n            for i, ch in enumerate(expr):\n                if ch in \"+-*\":\n                    left = ways(expr[:i])\n                    right = ways(expr[i + 1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n\n            if not res:  # no operator found, single number\n                res.append(int(expr))\n\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # 尋找格式 expression = \"...\"\n    match = re.search(r'expression\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # 若輸入直接是表達式，使用整行文字\n        expr = data.strip()\n\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: given expression string with numbers and operators + - *. Need to compute all possible results by different parentheses grouping. Standard problem: LeetCode 241. Approach: recursive divide and conquer with memoization. We parse expression, recursively split at operators, compute left and right results, combine with operator.\n\nWe need to output each step line with explanation. Use Start, End, Decision etc.\n\nWe should output a step-by-step algorithm in virtual code.\n\nWe must produce line-by-line virtual code with explanation.\n\nWe'll design algorithm:\n\nStart\n→ Step 1: Define function diffWays(expression) // Main function\n→ Decision: if expression contains no operator? // base case\n    Yes → Step 2: return list containing integer parsed from expression // single number\n    No  → Step 3: Initialize result list // store all results\n→ Step 4: For each index i in expression\n        If character at i is operator\n            → Step 5: leftExpr = substring 0..i-1\n            → Step 6: rightExpr = substring i+1..end\n            → Step 7: leftResults = diffWays(leftExpr) // recursive\n            → Step 8: rightResults = diffWays(rightExpr)\n            → Step 9: For each l in leftResults\n                    For each r in rightResults\n                        → Step 10: compute val = applyOperator(l, r, operator)\n                        → Step 11: Append val to result list\n→ Step 12: return result list\n\nAlso memoization: Use map cache. Add Decision: if expression in cache? etc.\n\nAdd caching:\n\n→ Step 13: Initialize cache map before function call.\n\nBut we can incorporate caching inside function: if cache contains expression, return cached result.\n\nAdd Decision: if cache[expression] exists? // use cached\n\nOk. Provide virtual code lines with explanation.\n\nWe need to avoid actual code; use placeholders like \"function diffWays(expression)\". Use arrow for flow.\n\nLet's produce.\n\nAlso include Start and End lines.\n\nLet's produce 25-30 lines.\n\nEnsure each line includes virtual code step and comment.\n\nLet's generate.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 定義 cache 為空映射 // 用來記錄已計算的子表達式結果\n\n→ Step 2: 定義函式 diffWays(expression) // 計算表達式所有可能結果的主函式\n\n→ Decision: cache 是否已包含 expression? // 檢查是否有先前計算過\n    Yes → Step 3: 返回 cache[expression] // 若已存在則直接回傳快取值\n    No  → Step 4: 進入函式體執行後續步驟\n\n→ Step 5: 如果 expression 中不含 '+', '-', '*'? // 基本情況：單一數字\n    Yes → Step 6: 解析 expression 為整數，並返回單元素列表 // 直接回傳數字\n    No  → Step 7: 初始化 result 為空列表 // 存儲此表達式所有可能結果\n\n→ Step 8: 遍歷 expression 中每個字符 i\n    → Decision: expression[i] 是否為運算符? // 判斷是否可以分割\n        Yes →\n            → Step 9: leftExpr = substring 0..i-1 // 左子表達式\n            → Step 10: rightExpr = substring i+1..end // 右子表達式\n            → Step 11: leftResults = diffWays(leftExpr) // 重新遞迴計算左部\n            → Step 12: rightResults = diffWays(rightExpr) // 重新遞迴計算右部\n            → Step 13: 對每個 l 在 leftResults\n                → Step 14: 對每個 r 在 rightResults\n                    → Step 15: val = applyOperator(l, r, expression[i]) // 執行對應算術運算\n                    → Step 16: 把 val 加到 result 列表中\n        No → 繼續到下一個字符\n\n→ Step 17: 把 result 存入 cache[expression] // 以便下次直接取用\n→ Step 18: 返回 result // 結束函式執行\n\n→ Step 19: 呼叫 diffWays(輸入表達式) // 開始計算\n→ Step 20: 把回傳的結果輸出或返回給上層 // 將所有可能結果呈現\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\nimport ast\n\n#----------------------------------------------------\n# Weighted Random Picker\n#----------------------------------------------------\nclass Solution:\n    def __init__(self, w):\n        \"\"\"\n        建構子：接收一個正整數權重列表 w\n        先計算前綴和 prefix_sum，方便之後做二分搜尋\n        \"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"\n        隨機挑選一個索引\n        1. 產生 1 到總權重之間的隨機整數 target\n        2. 用 bisect 找出第一個 prefix_sum[i] >= target\n        3. 回傳對應索引 i\n        \"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\n#----------------------------------------------------\n# 主程式：解析輸入，執行指令並輸出結果\n#----------------------------------------------------\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 把輸入包裝成 tuple，方便用 ast 解析\n    try:\n        data = ast.literal_eval(f'({raw_input})')\n    except Exception as e:\n        print(f\"解析失敗: {e}\", file=sys.stderr)\n        return\n\n    commands, args_list = data\n    results = []\n    instance = None\n\n    for cmd, arg in zip(commands, args_list):\n        if cmd == 'Solution':\n            # arg[0] 是權重列表\n            instance = Solution(arg[0])\n            results.append(None)  # 建構子回傳 null\n        else:\n            method = getattr(instance, cmd)\n            if arg:\n                # 若有參數，解包並呼叫\n                res = method(*arg[0])\n            else:\n                # 無參數直接呼叫\n                res = method()\n            results.append(res)\n\n    # 將結果以 JSON 格式輸出，None 會自動轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The requirement: Virtual Code algorithm for weighted random selection. Steps: Build prefix sum array, total sum. In pickIndex, generate random number between 1 and total, binary search. Provide explanation each line. Use Start End etc. Use arrows. Should be in Traditional Chinese. Let's craft.\n\nLine 1: Start // Program starts\n\nLine 2: → Step 1: 初始化 w // Input weights\n\nBut the algorithm requires precomputation: build prefix sums. So:\n\n→ Step 1: 计算 prefixSum array // 构建前缀和\n\n→ Step 2: 计算 totalWeight = prefixSum[last] // total weight\n\nMaybe include data structure: array prefixSum.\n\nThen pickIndex: random number r = random(1, totalWeight). Use binary search over prefixSum.\n\nDecision: r <= prefixSum[mid]? etc.\n\nReturn index.\n\nEnd.\n\nNeed to include Explanation comments. Use Chinese.\n\nLet's produce lines. Need arrow lines.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 以 w 為輸入，初始化空的 prefixSum 陣列 // 接收權重資料\n→ Step 2: 從左到右遍歷 w，將每個 w[i] 累加到前一個 prefixSum，並存入 prefixSum[i] // 建立前綴和\n→ Step 3: 計算 totalWeight = prefixSum[w.length-1] // 取得總重量\n→ Step 4: 進入 pickIndex() 時，產生一個介於 1 到 totalWeight 的隨機整數 r // 隨機選擇點\n→ Decision: 找出第一個 prefixSum[i] ≥ r 的索引 // 找到對應權重區間\n    → Binary Search: \n        → Step 5: 左指標 low = 0, 右指標 high = w.length-1 // 初始搜尋範圍\n        → Step 6: 重複直到 low > high\n            → Step 7: 計算 mid = low + (high - low) / 2 // 中點\n            → Decision: 如果 prefixSum[mid] < r?\n                Yes → low = mid + 1 // r 在右半邊\n                No  → high = mid - 1 // r 在左半邊\n        → Step 8: 回傳 low // low 為第一個滿足條件的索引\n→ End // 程式執行結束\n\nBut need each line in format: \"虛擬碼步驟 // 解釋\". Also use arrow symbol. For decision lines, use Yes → and No →. For binary search, may be nested but we can flatten.\n\nBetter structure:\n\nStart // 程式開始執行\n→ Step 1: 初始化 prefixSum 陣列為空 // 用於存儲前綴和\n→ Step 2: totalWeight = 0 // 用於累計總重量\n→ Step 3: 對於 i 從 0 到 w.length-1 做\n    → Step 4: totalWeight += w[i] // 累加當前權重\n    → Step 5: prefixSum[i] = totalWeight // 存入前綴和\n→ Step 6: pickIndex() 定義\n    → Step 7: r = 隨機整數(1, totalWeight) // 隨機選擇點\n    → Step 8: low = 0, high = w.length-1 // 二分搜尋範圍\n    → Step 9: 當 low ≤ high 時\n        → Step 10: mid = low + (high - low) / 2 // 計算中點\n        → Decision: prefixSum[mid] < r?\n            Yes → low = mid + 1 // r 在右邊\n            No  → high = mid - 1 // r 在左邊\n    → Step 11: 回傳 low // low 為選取的索引\nEnd // 程式結束\n\nYes that's good. Ensure each line has arrow. For lines inside decision, we need indent but still each line separate. Use '→' for each line; inside decision lines use 'Yes →' and 'No →'.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 prefixSum 陣列為空 // 用於存儲前綴和\n→ Step 2: totalWeight = 0 // 用於累計總重量\n→ Step 3: 對於 i 從 0 到 w.length-1 做\n    → Step 4: totalWeight += w[i] // 累加當前權重\n    → Step 5: prefixSum[i] = totalWeight // 存入前綴和\n→ Step 6: 定義 pickIndex() 函式\n    → Step 7: r = 隨機整數(1, totalWeight) // 隨機選擇點\n    → Step 8: low = 0, high = w.length-1 // 二分搜尋範圍\n    → Step 9: 當 low ≤ high 時\n        → Step 10: mid = low + (high - low) / 2 // 計算中點\n        → Decision: prefixSum[mid] < r?\n            Yes → low = mid + 1 // r 在右邊\n            No  → high = mid - 1 // r 在左邊\n    → Step 11: 回傳 low // low 為選取的索引\nEnd // 程式結束\n```"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        \"\"\"\n        Multiply two non-negative integer strings without using built-in big integers.\n        \"\"\"\n        # Handle trivial zero cases, including inputs like \"000\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # Temporary array to hold intermediate results\n        pos = [0] * (m + n)\n\n        # Perform multiplication like in elementary school\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n\n                pos[p1] += sum_ // 10      # carry to the higher position\n                pos[p2] = sum_ % 10       # keep current digit\n\n        # Convert the result array to a string, removing leading zeros\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result if result else \"0\"\n\ndef main() -> None:\n    \"\"\"\n    Reads two numbers from standard input, multiplies them,\n    and prints the product as a string.\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract all sequences of digits; works for formats like:\n    # num1 = '123', num2 = '456'  or simply 123 456\n    nums = re.findall(r\"\\d+\", data)\n    if len(nums) < 2:\n        return  # insufficient input\n\n    num1, num2 = nums[0], nums[1]\n    solution = Solution()\n    print(solution.multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode that multiplies two large numbers represented as strings, without using built-in BigInteger or converting to integers. The pseudocode should be line-by-line with explanations. Use Start, End, Decision, arrow.\n\nWe need to handle multiplication via school algorithm: each digit multiply and sum. Steps: initialize result array of length len1+len2. For i from len1-1 downto 0, for j from len2-1 downto 0, multiply digits, add to result[i+j+1], manage carry. Then convert to string, skip leading zeros. Return.\n\nWe also need to handle empty string or \"0\". Provide steps.\n\nLet's craft pseudocode lines.\n\nWe can use variables: len1, len2, n1, n2, result array. Use indices.\n\nNeed explanation after each line.\n\nLet's produce pseudocode.\n\nWe'll include \"Start\" line.\n\nWe'll use \"→\" to denote next steps.\n\nMake sure to indent decisions.\n\nAlso we may have a helper function to convert char to int digit.\n\nPseudo lines:\n\nStart\n→ Step 1: n1 ← num1; n2 ← num2 // store input strings\n→ Decision: If n1 = \"0\" or n2 = \"0\"? // check trivial zero case\n    Yes → Step 2: Return \"0\" // zero product\n    No  → Step 3: len1 ← length(n1); len2 ← length(n2) // lengths\n→ Step 4: result ← array of zeros with size len1 + len2 // storage for intermediate sums\n→ Step 5: For i from len1-1 downto 0 // iterate digits of first number\n    → Step 6: digit1 ← integer value of n1[i] // convert char to digit\n    → Step 7: carry ← 0\n    → Step 8: For j from len2-1 downto 0 // iterate digits of second number\n        → Step 9: digit2 ← integer value of n2[j]\n        → Step 10: product ← digit1 * digit2 + result[i+j+1] + carry // multiply and add carry\n        → Step 11: result[i+j+1] ← product mod 10 // store least significant digit\n        → Step 12: carry ← product div 10 // compute carry\n    → Step 13: result[i] ← result[i] + carry // add remaining carry to higher position\n→ Step 14: Convert result array to string skipping leading zeros\n    → Step 15: index ← 0\n    → Step 16: While index < len(result) and result[index] = 0\n        → Step 17: index ← index + 1 // skip zero\n    → Step 18: If index = len(result) // all zeros\n        → Step 19: Return \"0\"\n        → Step 20: Else\n            → Step 21: output ← empty string\n            → Step 22: For k from index to len(result)-1\n                → Step 23: output ← output concatenated with string(result[k]) // build result\n            → Step 24: Return output\nEnd\n\nWe need to ensure each line has explanation after space. For decisions, indent.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: n1 ← num1; n2 ← num2 // 取得輸入的字串\n→ Decision: 若 n1 = \"0\" 或 n2 = \"0\"? // 檢查是否有零輸入\n    Yes → Step 2: Return \"0\" // 若任一數為 0，直接回傳 \"0\"\n    No  → Step 3: len1 ← length(n1); len2 ← length(n2) // 取得兩個字串長度\n→ Step 4: result ← array of zeros with size len1 + len2 // 建立長度足夠的暫存陣列\n→ Step 5: For i from len1-1 downto 0 // 從 num1 的最低位開始迭代\n    → Step 6: digit1 ← integer value of n1[i] // 將字元轉成數字\n    → Step 7: carry ← 0 // 初始化進位\n    → Step 8: For j from len2-1 downto 0 // 從 num2 的最低位開始迭代\n        → Step 9: digit2 ← integer value of n2[j] // 將字元轉成數字\n        → Step 10: product ← digit1 * digit2 + result[i+j+1] + carry // 計算乘積並加上已存值與進位\n        → Step 11: result[i+j+1] ← product mod 10 // 儲存單一位數\n        → Step 12: carry ← product div 10 // 計算新的進位\n    → Step 13: result[i] ← result[i] + carry // 把剩餘進位加回更高位\n→ Step 14: Convert result array to string while跳過前導零 // 將暫存陣列轉成字串\n    → Step 15: index ← 0 // 設定起始索引\n    → Step 16: While index < len(result) and result[index] = 0\n        → Step 17: index ← index + 1 // 跳過前導零\n    → Step 18: If index = len(result) // 全為零時\n        → Step 19: Return \"0\" // 回傳 \"0\"\n        → Step 20: Else\n            → Step 21: output ← empty string // 準備拼接結果\n            → Step 22: For k from index to len(result)-1\n                → Step 23: output ← output concatenated with string(result[k]) // 加入每一位\n            → Step 24: Return output // 回傳最終乘積字串\nEnd // 程式執行結束\n```"
    }
  ]
}