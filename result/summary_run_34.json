{
  "run_index": 34,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 298,
  "generation_or_validation_failure_count": 36,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef count_lines_in_file() -> None:\n    \"\"\"\n    開啟 data.txt，統計行數並輸出結果。\n    若檔案不存在則輸出錯誤訊息。\n    \"\"\"\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            # 用生成器逐行計數，避免一次性載入大量資料\n            line_count = sum(1 for _ in f)\n        print(f'檔案共有 {line_count} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\ndef main() -> None:\n    \"\"\"\n    1. 讀取標準輸入的全部內容。\n    2. 若有內容，寫入（或覆寫）data.txt。\n    3. 呼叫 count_lines_in_file 進行統計並輸出。\n    \"\"\"\n    # 讀取 stdin 所有內容\n    input_data = sys.stdin.read()\n\n    # 若有輸入，寫入 data.txt\n    if input_data:\n        with open('data.txt', 'w', encoding='utf-8') as f:\n            f.write(input_data)\n\n    # 執行行數統計\n    count_lines_in_file()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode. Each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use arrows and Decision. Use Start End. Use with, try/except, file reading, count lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 檔案是否存在? // 檢查 data.txt 是否可開啟  \n Yes → Step 1: 以讀取模式開啟檔案 (with open('data.txt','r') as file) // 使用 with 語法安全打開檔案  \n  → Step 2: 初始化行計數器 count = 0 // 用於累計行數  \n  → Step 3: 逐行迭代 file 讀取每行 // 逐行處理檔案內容  \n   → Step 4: 對每行執行 count += 1 // 逐行遞增計數器  \n  → Step 5: 輸出 '總共有 {count} 行文字' // 顯示總行數  \n  End // 完成檔案處理  \n No → Step 6: 輸出 '找不到檔案！' // 檔案不存在時的錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[6,4,6,1,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[6, 4, 6, 1, 2]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取全部標準輸入\n    code = sys.stdin.read()\n    # 若輸入非空，執行之（允許直接呼叫 roll_dice 或其他表達式）\n    if code.strip():\n        eval(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with a brief comment. Format: line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrow. Provide steps to define function, import random, loop, etc.\n\nWe need to output only virtual code, no real code. So use generic steps: \"Start // 程式開始執行\", \"→ Import 模組 random // 引入 random 模組\", etc. Then \"→ Function roll_dice(n): // 定義函式 roll_dice\" then body. The loop: \"→ For i 1 to n: // 迴圈擲骰 n 次\". Inside, \"→ Step: 產生 隨機 數字 1~6 // 擲骰子\". Append to results list. Finally return list.\n\nNeed arrow lines. Use \"→\" arrow for normal steps. For decision maybe not needed. But could show that random.randint returns between 1 and 6. No decision. End.\n\nLet's produce.\n\nEnsure each line ends with comment. Let's list:\n\nStart // 程式開始執行\n→ Import 模組 random // 引入 random 模組以生成隨機數\n→ Function roll_dice(n): // 定義函式 roll_dice，參數 n 表示擲骰次數\n    → Initialize results list // 建立空列表以儲存每次擲骰的結果\n    → For i 1 to n: // 迴圈執行 n 次擲骰\n        → Step: 產生 隨機 數字 1~6 // 使用 random.randint(1,6) 擲骰\n        → Append 數字 到 results // 把擲出的數字加入 results 列表\n    → Return results // 回傳所有擲骰結果\nEnd // 程式執行結束\n\nBut must keep each line individually with arrow. Need indent but arrow includes arrow inside maybe. According to format, we can include indentation as spaces. They didn't specify indentation but example shows indent for nested steps.\n\nUse \"→\" arrow for each step. For nested inside function we can indent with two spaces before arrow. Eg: \"  → Step\". Let's follow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Import 模組 random // 引入 random 模組以生成隨機數\n→ Function roll_dice(n): // 定義函式 roll_dice，參數 n 為擲骰次數\n  → Initialize results list // 建立空列表以儲存每次擲骰結果\n  → For i 1 to n: // 迴圈執行 n 次擲骰\n    → Step: 產生 隨機 數字 1~6 // 使用 random.randint(1,6) 擲骰\n    → Append 數字 到 results // 把擲出的數字加入 results 列表\n  → Return results // 回傳所有擲骰結果\nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    start = time.perf_counter()\n    func(*args)\n    end = time.perf_counter()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for a function measure_time(func, *args) that uses time module to measure execution time and returns result rounded to 3 decimal places.\n\nWe must produce step-by-step with explanations, no actual code. Must follow the format: each line: \"虛擬碼步驟 // 解釋\". Use arrow →, Yes →, No →, Decision:. Must include Start and End. Also need to mention import time.\n\nThus we produce:\n\nStart // 程式開始\n→ Step 1: Import time module // 導入 time 模組\n→ Step 2: 定義函數 measure_time(func, *args) // 定義函式\n→ Step 3: 在函式內部記錄 start = time.perf_counter() // 取得開始時間\n→ Step 4: 執行 func(*args) 並將結果存入 result // 執行目標函式並取得回傳值\n→ Step 5: 記錄 end = time.perf_counter() // 取得結束時間\n→ Step 6: 計算 elapsed = end - start // 計算經過時間\n→ Step 7: 四捨五入 elapsed 至 3 位小數並存入 rounded_time = round(elapsed, 3) // 四捨五入\n→ Step 8: 回傳 (result, rounded_time) // 回傳結果和時間\nEnd // 程式執行結束\n\nBut need to use arrows properly: maybe each step as \"→ Step X: ...\". We can include comments. Use arrow arrow and decisions maybe not needed. But requirement: Use arrow (→, Yes →, No →) and Decision. Might need no decision here. But we can show a decision if needed: maybe check if function returns something? Not necessary.\n\nJust produce simple steps. Ensure each line ends with \"// 解釋\".\n\nLet's craft.\n\nAlso include arrow from Start to Step 1 etc. Use indentation for nested steps if needed. Not necessary.\n\nWill produce:\n\nStart // 程式開始執行\n→ Step 1: 導入 time 模組 // 使用 time 模組測量時間\n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量函式\n→ Step 3: 在函式內部記錄開始時間 start = time.perf_counter() // 取得高精度起始時間\n→ Step 4: 執行目標函式並取得結果 result = func(*args) // 執行傳入的函式\n→ Step 5: 記錄結束時間 end = time.perf_counter() // 取得高精度結束時間\n→ Step 6: 計算經過時間 elapsed = end - start // 計算耗時\n→ Step 7: 將 elapsed 四捨五入到小數點 3 位 rounded_time = round(elapsed, 3) // 取三位小數\n→ Step 8: 回傳結果和耗時 (result, rounded_time) // 返回執行結果與時間\nEnd // 程式執行結束\n\nThis is straightforward. Provide as virtual code. Ensure each line ends with //.\n\nWe could also include Decision: maybe decide if func is None? Not required.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 導入 time 模組 // 使用 time 模組測量時間  \n→ Step 2: 定義函數 measure_time(func, *args) // 建立測量函式  \n→ Step 3: 在函式內部記錄開始時間 start = time.perf_counter() // 取得高精度起始時間  \n→ Step 4: 執行目標函式並取得結果 result = func(*args) // 執行傳入的函式  \n→ Step 5: 記錄結束時間 end = time.perf_counter() // 取得高精度結束時間  \n→ Step 6: 計算經過時間 elapsed = end - start // 計算耗時  \n→ Step 7: 將 elapsed 四捨五入到小數點 3 位 rounded_time = round(elapsed, 3) // 取三位小數  \n→ Step 8: 回傳結果和耗時 (result, rounded_time) // 返回執行結果與時間  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"grape\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'grape', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取（若有）任何輸入，雖然本題不需要，但依照要求加入\n    sys.stdin.read()\n\n    # 建立集合並進行所需操作\n    fruits = {'apple', 'banana'}\n    fruits.add('orange')\n    fruits.update(['grape', 'melon'])\n    fruits.remove('banana')\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code in the format described. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Include Start, End. Use Decision if needed? Not needed. We need to show steps for creating set, adding, updating, removing, discarding, printing. Use the syntax: → Step 1: Create set fruits = {'apple', 'banana'} // Initialize set.\n\nWe might include variable names.\n\nWe should produce lines accordingly. Use \"Start\" and \"End\". Use arrows for steps. Format: \"Start // 程式開始執行\" then arrow. For each step.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Initialize set fruits = {'apple', 'banana'} // 建立集合並加入兩個水果\n→ Step 2: Call fruits.add('orange') // 新增一個元素 'orange'\n→ Step 3: Call fruits.update({'grape', 'melon'}) // 同時加入多個元素\n→ Step 4: Call fruits.remove('banana') // 移除 'banana'，若不存在會拋錯\n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'，不會拋錯\n→ Step 6: Output fruits // 顯示最終集合內容\nEnd // 程式執行結束\n\nBut need to use arrow: \"→\" before each step. Provide explanation after //.\n\nCheck format: \"虛擬碼步驟 [空格] // 解釋/說明\". So \"→ Step 1: Initialize set fruits = {'apple', 'banana'} // 建立集合並加入兩個水果\" is fine.\n\nAlso \"Start // 程式開始執行\" no arrow. \"End // 程式執行結束\". Good.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize set fruits = {'apple', 'banana'} // 建立集合並加入兩個水果  \n→ Step 2: Call fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: Call fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: Call fruits.remove('banana') // 使用 remove() 移除 'banana'，若不存在會拋錯  \n→ Step 5: Call fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不會拋錯  \n→ Step 6: Output fruits // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> float | None:\n    \"\"\"\n    取得 USD → TWD 的匯率。\n    成功回傳浮點數，失敗回傳 None。\n    \"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef gui_app() -> None:\n    \"\"\"\n    建立 tkinter GUI，顯示並可更新匯率。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update() -> None:\n        rate = fetch_rate()\n        if rate is not None:\n            label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            label.config(text=\"更新失敗，請檢查網路連線\")\n\n    button = tk.Button(win, text=\"更新匯率\", command=update)\n    button.pack(pady=5)\n\n    # 初始載入一次\n    update()\n    win.mainloop()\n\ndef main() -> None:\n    \"\"\"\n    主要執行入口。\n    若 stdin 有輸入，則以 CLI 模式回傳匯率；否則啟動 GUI。\n    \"\"\"\n    # 讀取整個 stdin\n    stdin_data = sys.stdin.read()\n    if stdin_data.strip():\n        # CLI 模式：忽略輸入內容，只是觸發更新\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 無輸入時啟動 GUI\n        gui_app()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, following format. Steps: import, create Tk, label, button, function to fetch via requests, update label. Use decision structure? Possibly not. Just flow. But maybe decision: if request success? We'll show. Provide arrow. Use Start, End. Use Yes/No decision for HTTP status. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests 與 tkinter 模組 // 引入網路請求與 GUI 所需套件  \n→ Step 2: 建立 Tk 視窗實例 root // 初始化主視窗  \n→ Step 3: 設定視窗標題 \"USD ↔ TWD 匯率查詢\" // 顯示視窗標題  \n→ Step 4: 建立 Label 控制項 lbl_rate，初始文字為 \"匯率載入中...\" // 顯示匯率結果的地方  \n→ Step 5: 設置 Label 在網格行 0 列 0，填充寬度並居中 // 佈局 Label  \n→ Step 6: 定義函式 fetch_rate() // 取得並更新匯率的主要流程  \n    → Step 7: 送出 GET 請求至 \"https://api.exchangerate-api.com/v4/latest/USD\" // 取得最新匯率資料  \n    → Decision: 回傳狀態碼是否為 200? // 判斷是否成功取得資料  \n        Yes → Step 8: 解析回傳 JSON，取得 rates[\"TWD\"] // 取出台幣匯率  \n        Yes → Step 9: 更新 lbl_rate 文字為 \"1 USD = {rate} TWD\" // 顯示匯率  \n        No  → Step 10: 更新 lbl_rate 文字為 \"請求失敗，請稍後再試\" // 顯示錯誤訊息  \n→ Step 11: 建立 Button 控制項 btn_update，文字為 \"更新匯率\"，並綁定 fetch_rate() // 按鈕觸發更新  \n→ Step 12: 設置 Button 在網格行 1 列 0，填充寬度並居中 // 佈局 Button  \n→ Step 13: 在程式啟動時即呼叫 fetch_rate() 取得初始匯率 // 首次載入匯率  \n→ Step 14: 呼叫 root.mainloop() // 進入 tkinter 事件迴圈，等待使用者互動  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        # 用字典映射值到其在 values 列表中的索引\n        self.val_to_index = {}\n        # 用列表儲存所有值，方便隨機存取\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        # 新元素直接放到列表尾端\n        self.values.append(val)\n        # 記錄該元素的索引\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素在列表中的索引\n        idx = self.val_to_index[val]\n        # 取得列表最後一個元素\n        last_val = self.values[-1]\n        # 把最後一個元素搬到 idx 的位置\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素（原本的要刪除元素已被覆蓋）\n        self.values.pop()\n        # 移除字典中對應鍵\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選擇索引並返回對應值\n        return random.choice(self.values)\n\ndef parse_input():\n    data = sys.stdin.read().strip()\n    if not data:\n        return [], []\n    # 若輸入為單行且包含兩個列表，將其包裝成一個列表再解析\n    if data.startswith('[') and ',' in data:\n        try:\n            parsed = ast.literal_eval('[' + data + ']')\n            if isinstance(parsed, (list, tuple)) and len(parsed) == 2:\n                return parsed[0], parsed[1]\n        except Exception:\n            pass\n    # 其餘情況：多行輸入\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return ast.literal_eval(lines[0]), ast.literal_eval(lines[1])\n    return [], []\n\ndef to_json(val):\n    if val is None:\n        return 'null'\n    if isinstance(val, bool):\n        return 'true' if val else 'false'\n    return str(val)\n\nif __name__ == \"__main__\":\n    commands, args_list = parse_input()\n    rs = RandomizedSet()\n    results = [None]  # constructor returns null\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == 'insert':\n            results.append(rs.insert(*args))\n        elif cmd == 'remove':\n            results.append(rs.remove(*args))\n        elif cmd == 'getRandom':\n            results.append(rs.getRandom())\n        else:  # 'RandomizedSet' or unknown\n            results.append(None)\n\n    output = '[' + ', '.join(to_json(v) for v in results) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations, following format. For each step, we need to show virtual code and explanation. The user wants implementation of RandomizedSet class with insert, remove, getRandom. Provide algorithm steps: using hash map for val to index, and array/list for values. We'll produce pseudocode describing the operations.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Use arrow arrows. Must start with Start and End.\n\nThe algorithm:\n\nStart\n→ Initialize array A and map M\nInsert(val):\n→ Check if val in M\n→ If yes → return false\n→ Else append val to A, set M[val] = last index\n→ return true\nRemove(val):\n→ Check if val in M\n→ If no → return false\n→ Get index = M[val]\n→ Get last element = A[-1]\n→ Swap A[index] and A[-1]\n→ Update M[last] = index\n→ Remove last element from A\n→ Delete M[val]\n→ return true\nGetRandom:\n→ Choose random index between 0 and len(A)-1\n→ Return A[index]\n\nNeed to structure with Decision, Yes→, No→. Provide explanation each line. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Declare array A ← [] // 用來存放集合中的元素，方便隨機存取\n→ Declare map M ← {} // 鍵為元素值，值為其在 A 中的索引，支援 O(1) 查找\n\n// ------------------ Insert 操作 ------------------\n→ Step: insert(val) // 接收要插入的值\n    Decision: 是否已存在於 M? // 檢查元素是否已在集合中\n        Yes → Return false // 已存在，無需插入，回傳失敗\n        No  → Append val 至 A // 新元素加到陣列尾端\n             → 設定 M[val] ← len(A)-1 // 記錄其索引\n             → Return true // 插入成功\n\n// ------------------ Remove 操作 ------------------\n→ Step: remove(val) // 接收要刪除的值\n    Decision: 是否存在於 M? // 檢查元素是否在集合中\n        Yes → \n            → index ← M[val] // 取得該元素在 A 的索引\n            → last ← A[-1] // 取得陣列最後一個元素\n            → Swap A[index] 與 A[-1] // 交換位置，保持陣列連續\n            → M[last] ← index // 更新最後一個元素的新索引\n            → Remove A[-1] // 刪除陣列最後一個位置（原本的待刪元素）\n            → Delete M[val] // 從映射中移除該元素\n            → Return true // 刪除成功\n        No  → Return false // 元素不存在，無法刪除\n\n// ------------------ getRandom 操作 ------------------\n→ Step: getRandom() // 回傳隨機元素\n    → randIndex ← RandomInt(0, len(A)-1) // 隨機產生合法索引\n    → Return A[randIndex] // 以相同機率回傳該元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [1, 0], [2, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"\n    使用「映射+抽樣」的技巧，將 m*n 個格子映射到一維索引，\n    只用一次隨機數產生並且 O(1) 的時間與空間複雜度。\n    \"\"\"\n    def __init__(self, m: int, n: int):\n        # 行列數\n        self.rows = m\n        self.cols = n\n        # 剩餘未翻轉的格子數\n        self.total = m * n\n        # 映射表：從抽樣索引到實際格子索引\n        self.mapping = {}\n\n    def flip(self) -> list[int]:\n        \"\"\"\n        隨機挑選一個還是 0 的格子並把它翻轉成 1。\n        回傳對應的 [i, j]。\n        \"\"\"\n        # 隨機抽樣\n        rand_idx = random.randint(0, self.total - 1)\n        # 取得實際格子索引\n        real_idx = self.mapping.get(rand_idx, rand_idx)\n\n        # 將此格子標記為已翻轉\n        self.total -= 1\n        # 把最後一個可用格子映射到抽到的位置\n        # 若 total 仍 > 0，則將 mapping[rand_idx] 指向 mapping[total] 或 total 本身\n        if self.total > 0:\n            self.mapping[rand_idx] = self.mapping.get(self.total, self.total)\n\n        # 轉回 2 維座標\n        i = real_idx // self.cols\n        j = real_idx % self.cols\n        return [i, j]\n\n    def reset(self) -> None:\n        \"\"\"\n        重設所有格子為 0。\n        \"\"\"\n        self.total = self.rows * self.cols\n        self.mapping.clear()\n\n\ndef main() -> None:\n    \"\"\"\n    主程式：從 stdin 讀取操作列表與參數，執行並輸出結果。\n    輸入格式示例：\n        [\"Solution\",\"flip\",\"flip\",\"reset\"],\n        [[2,3],[],[],[]]\n    輸出格式示例：\n        [null,[1,0],[0,1],null]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分成兩個頂層列表\n    sep_idx = data.find('],')\n    ops_str = data[:sep_idx + 1]\n    params_str = data[sep_idx + 2:]\n\n    ops = json.loads(ops_str)\n    params = json.loads(params_str)\n\n    obj = None\n    output = []\n\n    for op, param in zip(ops, params):\n        if op == \"Solution\":\n            obj = Solution(param[0], param[1])\n            output.append(None)          # null\n        elif op == \"flip\":\n            output.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            output.append(None)\n        else:\n            # 不支援的操作，直接忽略\n            output.append(None)\n\n    # 使用 json.dumps 讓 None 轉成 null\n    print(json.dumps(output))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm. Use structure. The algorithm: use reservoir sampling like mapping of indices to values. We can flatten matrix indices 0..m*n-1. Maintain dictionary mapping from chosen index to original index to support removal. On flip: choose random integer from [0, remaining-1], map to actual index via mapping, then swap mapping: map[idx] = last. Decrement remaining. Reset: clear map, remaining=m*n.\n\nImplement solution class.\n\nWe need to output step-by-step virtual code for initialization, flip, reset.\n\nWe should include lines with 'Start', 'End', 'Decision', '→' arrows. Use simple steps. Provide explanation after each line.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 Solution(m, n) // 建立物件並設定行列數\n    → Step 1.1: 設定 total = m * n // 總格子數\n    → Step 1.2: 設定 remaining = total // 仍為 0 的格子數\n    → Step 1.3: 建立空的字典 mapping = {} // 用於映射隨機索引到實際格子\n→ End // 初始化完成\n\nStart // flip() 方法開始執行\n→ Step 2: 隨機選取 idx ∈ [0, remaining-1] // 取得一個剩餘格子中的隨機位置\n    → Step 2.1: 若 mapping 包含 idx, 取 mapping[idx] 為 realIdx 否則 realIdx = idx // 取得實際格子編號\n→ Step 3: 減少 remaining by 1 // 已被翻轉的格子不再可用\n→ Step 4: 若 remaining > 0，將 mapping[idx] 指向 mapping.get(remaining, remaining) // 把最後一個可用格子移到此位置\n    → Step 4.1: 讓 mapping[remaining] = remaining 或 mapping[remaining] 的原值 // 更新映射\n→ Step 5: 取得 i = realIdx // m + 1 // 行號\n→ Step 6: 取得 j = realIdx % n // 列號\n→ Step 7: 回傳 [i, j] // 返回隨機翻轉的位置\n→ End // flip() 執行結束\n\nStart // reset() 方法開始執行\n→ Step 8: 設定 remaining = total // 重新可用格子數\n→ Step 9: 清空 mapping = {} // 移除所有映射\n→ End // reset() 執行結束\n\nEnd // 程式結束執行"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        # Helper to check validity of a string\n        def is_valid(st: str) -> bool:\n            count = 0\n            for ch in st:\n                if ch == '(':\n                    count += 1\n                elif ch == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        level = {s}\n        while level:\n            # 找到所有合法的字串\n            valid = [x for x in level if is_valid(x)]\n            if valid:\n                return valid\n            # 生成下一層\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        nxt = item[:i] + item[i+1:]\n                        next_level.add(nxt)\n            level = next_level\n        return []\n\n\ndef parse_input(text: str) -> str:\n    \"\"\"\n    從輸入文字中擷取真正的字串。\n    支援:\n        - s = \"abc\"\n        - s = 'abc'\n        - s = abc\n        - abc\n    \"\"\"\n    # 先搜尋單引號或雙引號包起來的內容\n    m = re.search(r'[\"\\'](.*?)[\"\\']', text)\n    if m:\n        return m.group(1)\n    # 若沒有引號，嘗試移除等號\n    if '=' in text:\n        _, val = text.split('=', 1)\n        return val.strip()\n    return text.strip()\n\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read()\n    s = parse_input(raw)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    # 輸出符合範例的格式，例如 [\"(())()\",\"()()()\"]\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm to remove minimal invalid parentheses and return all unique valid strings.\n\nWe need to produce virtual code with arrow notation.\n\nThe algorithm: BFS/DFS to remove parentheses. Classic solution: Use BFS to find all valid strings with minimal removals; use set to avoid duplicates.\n\nPseudo steps:\n\n- Count left removals needed and right removals needed.\n- Use DFS recursion with pruning; but we can also use BFS: start from original string, generate all possible strings by removing one parenthesis at a time; check if valid; first level where any valid found: return all found at that level.\n\nSimpler: BFS.\n\nPseudo:\n\nStart\n→ Step 1: Define function isValid(s) // checks parentheses balance\n→ Step 2: Initialize queue with original string\n→ Step 3: Initialize visited set\n→ Step 4: Initialize result list\n→ Step 5: Initialize found flag false\n→ Decision: while queue not empty\n    → Step 6: Pop current string cur\n    → Decision: if isValid(cur)\n        → Yes → Add cur to result list\n        → Yes → Set found true\n    → Decision: if found\n        → Yes → Continue to next iteration (skip generating neighbors) // because we only want minimal removals\n        → No → Generate neighbors\n            → For each index i in cur\n                → Decision: if cur[i] is '(' or ')'\n                    → Yes → newStr = cur with char i removed\n                    → Decision: if newStr not in visited\n                        → Yes → Add newStr to queue\n                        → Yes → Mark visited\nEnd\n→ Decision: If result list empty\n    → Yes → Add empty string to result // because all parentheses removed?\n    → No → Nothing\n→ Return result\n\nWe must output virtual code lines. Use \"Start\", \"End\", \"Decision:\" and arrows.\n\nWe need to produce lines with comments in Chinese.\n\nWe need to ensure each line ends with `// 解釋/說明`.\n\nLet's produce step-by-step.\n\nWe must maintain indentation? In sample, indentation not necessary; but we should reflect decisions.\n\nLet's generate.\n\nStart\n\n→ Step 1: 定義 isValid(s) 檢查字串是否有效 // 用堆疊或計數器判斷括號配對\n\nBut we need virtual code line with arrow? Use \"Step 1: 定義 isValid(s)\" then comment.\n\nBut we need arrow? The sample shows \"→ Step 1: 輸入使用者數字\". So each step line starts with arrow then Step number.\n\nAlso we need \"Decision:\" lines for branching.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isValid(s) 檢查字串是否合法 // 逐字符計算左括號平衡\n→ Decision: 如果字串 s 為空\n    Yes → Step 2: 回傳 true // 空字串自然有效\n    No  → Step 3: 初始化 counter 為 0\n→ Step 4: 從左到右遍歷 s\n    → Decision: 如果字符是 '('\n        Yes → Step 5: counter += 1 // 右移\n        No → Decision: 如果字符是 ')'\n            Yes → Step 6: counter -= 1 // 左移\n            No → Step 7: 繼續\n    → Decision: 如果 counter < 0\n        Yes → Step 8: 回傳 false // 多個右括號\n→ Decision: 循環結束後\n    Yes → Step 9: 回傳 counter == 0 // 所有左括號匹配\n\nBut we can keep isValid as subfunction; we might just note \"Step 1: 定義 isValid(s)\" and skip internal details? The instructions ask for virtual code step-by-step. We can treat isValid as a black box.\n\nBetter: Step 1: 定義函式 isValid(s) // 用於判斷字串是否合法\nWe might not detail inside; but still could add steps for isValid. However we can keep simple.\n\nLet's decide: We'll include isValid as a helper, not expand inside.\n\nProceed.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isValid(s) 檢查括號平衡 // 內部使用計數器或堆疊\n→ Step 2: 初始化佇列 queue，加入原始字串 s\n→ Step 3: 初始化集合 visited，加入 s\n→ Step 4: 初始化結果列表 result，空\n→ Step 5: 初始化標誌 found 為 false\n\n→ Decision: 佇列非空\n    Yes → Step 6: 取出佇列前端字串 cur\n    → Decision: 如果 isValid(cur)\n        Yes → Step 7: 將 cur 加入 result\n        Yes → Step 8: 設置 found 為 true\n    → Decision: 如果 found 為真\n        Yes → Step 9: 繼續下一次循環（跳過生成子節點） // 只保留最少移除層\n        No  → Step 10: 生成子節點\n            → For i 在 0 到 len(cur)-1\n                → Decision: 如果 cur[i] 為 '(' 或 ')'\n                    Yes → Step 11: newStr = cur 去除索引 i 的字元\n                    → Decision: 如果 newStr 未在 visited\n                        Yes → Step 12: 加入 newStr 到 queue\n                        Yes → Step 13: 加入 newStr 到 visited\n→ Decision: result 非空\n    Yes → Step 14: 回傳 result\n    No  → Step 15: 回傳 [\"\" ] // 若無合法字串，回傳空字串\nEnd // 程式執行結束\n\nWe need to format with arrow for each step. The indentation inside decisions may be indicated by spaces. In sample, indentation for nested lines is with spaces. For our answer, we can mimic.\n\nLet's produce each line with arrow or Decision and comment.\n\nMake sure each line ends with comment // 解釋/說明.\n\nLet's craft:\n\n```\nStart // 程式開始執行\n→ Step 1: 定義函式 isValid(s) 檢查括號平衡 // 內部使用計數器判斷是否合法\n→ Step 2: 初始化佇列 queue，加入原始字串 s // 用於 BFS\n→ Step 3: 初始化集合 visited，加入 s // 避免重複處理\n→ Step 4: 初始化結果列表 result，空 // 存放最少移除後的合法字串\n→ Step 5: 初始化標誌 found 為 false // 代表是否已找到合法字串\n→ Decision: 佇列非空\n    Yes → Step 6: 取出佇列前端字串 cur // 進行處理\n    → Decision: 如果 isValid(cur)\n        Yes → Step 7: 將 cur 加入 result // 收集合法字串\n        Yes → Step 8: 設置 found 為 true // 已找到合法字串\n    → Decision: 如果 found 為真\n        Yes → Step 9: 繼續下一次循環（跳過生成子節點） // 只保留最少移除層\n        No  → Step 10: 生成子節點\n            → For i 在 0 到 len(cur)-1\n                → Decision: 如果 cur[i] 為 '(' 或 ')'\n                    Yes → Step 11: newStr = cur 去除索引 i 的字元\n                    → Decision: 如果 newStr 未在 visited\n                        Yes → Step 12: 加入 newStr 到 queue\n                        Yes → Step 13: 加入 newStr 到 visited\n→ Decision: result 非空\n    Yes → Step 14: 回傳 result // 完成\n    No  → Step 15: 回傳 [\"\"] // 若無合法字串，回傳空字串\nEnd // 程式執行結束\n```\n\nWe need to ensure each line ends with `// 解釋/說明`. Let's check each.\n\nLine \"Start // 程式開始執行\" ok.\n\n\"→ Step 1: 定義函式 isValid(s) 檢查括號平衡 // 內部使用計數器判斷是否合法\" ok.\n\n\"→ Step 2: 初始化佇列 queue，加入原始字串 s // 用於 BFS\" ok.\n\n\"→ Step 3: 初始化集合 visited，加入 s // 避免重複處理\" ok.\n\n\"→ Step 4: 初始化結果列表 result，空 // 存放最少移除後的合法字串\" ok.\n\n\"→ Step 5: 初始化標誌 found 為 false // 代表是否已找到合法字串\" ok.\n\n\"→ Decision: 佇列非空\" comment? It has no comment after but we need // explanation. The sample shows Decision lines include comment. Let's add comment: // 佇列中還有字串可處理\n\nAdd comment.\n\nSame for nested decisions.\n\nAlso each inner line should include comment.\n\nLet's adjust.\n\nLine: \"→ Decision: 佇列非空 // 佇列中還有字串可處理\"\n\nThen \"Yes → Step 6: 取出佇列前端字串 cur // 進行處理\" good.\n\n\"→ Decision: 如果 isValid(cur) // 檢查目前字串是否合法\"\n\nAdd comment.\n\n\"Yes → Step 7: 將 cur 加入 result // 收集合法字串\"\n\n\"Yes → Step 8: 設置 found 為 true // 已找到合法字串\"\n\n\"→ Decision: 如果 found 為真 // 已找到合法字串，避免多餘移除\"\n\n\"Yes → Step 9: 繼續下一次循環（跳過生成子節點） // 只保留最少移除層\"\n\n\"No  → Step 10: 生成子節點 // 產生下一層所有可能的字串\"\n\n\"→ For i 在 0 到 len(cur)-1 // 遍歷每個字符\"\n\n\"    → Decision: 如果 cur[i] 為 '(' 或 ')' // 只對括號進行刪除\"\n\n\"        Yes → Step 11: newStr = cur 去除索引 i 的字元 // 生成新字串\"\n\n\"        → Decision: 如果 newStr 未在 visited // 避免重複\"\n\n\"            Yes → Step 12: 加入 newStr 到 queue // 放入佇列\"\n\n\"            Yes → Step 13: 加入 newStr 到 visited // 記錄已處理\"\n\n\"→ Decision: result 非空 // 有合法字串可回傳\"\n\n\"    Yes → Step 14: 回傳 result // 完成\"\n\n\"    No  → Step 15: 回傳 [''] // 若無合法字串，回傳空字串\"\n\nFinally End.\n\nWe need to make sure indentation uses spaces to indicate nested.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isValid(s) 檢查括號平衡 // 內部使用計數器判斷是否合法\n→ Step 2: 初始化佇列 queue，加入原始字串 s // 用於 BFS\n→ Step 3: 初始化集合 visited，加入 s // 避免重複處理\n→ Step 4: 初始化結果列表 result，空 // 存放最少移除後的合法字串\n→ Step 5: 初始化標誌 found 為 false // 代表是否已找到合法字串\n→ Decision: 佇列非空 // 佇列中還有字串可處理\n    Yes → Step 6: 取出佇列前端字串 cur // 進行處理\n    → Decision: 如果 isValid(cur) // 檢查目前字串是否合法\n        Yes → Step 7: 將 cur 加入 result // 收集合法字串\n        Yes → Step 8: 設置 found 為 true // 已找到合法字串\n    → Decision: 如果 found 為真 // 已找到合法字串，避免多餘移除\n        Yes → Step 9: 繼續下一次循環（跳過生成子節點） // 只保留最少移除層\n        No  → Step 10: 生成子節點 // 產生下一層所有可能的字串\n            → For i 在 0 到 len(cur)-1 // 遍歷每個字符\n                → Decision: 如果 cur[i] 為 '(' 或 ')' // 只對括號進行刪除\n                    Yes → Step 11: newStr = cur 去除索引 i 的字元 // 生成新字串\n                    → Decision: 如果 newStr 未在 visited // 避免重複\n                        Yes → Step 12: 加入 newStr 到 queue // 放入佇列\n                        Yes → Step 13: 加入 newStr 到 visited // 記錄已處理\n→ Decision: result 非空 // 有合法字串可回傳\n    Yes → Step 14: 回傳 result // 完成\n    No  → Step 15: 回傳 [''] // 若無合法字串，回傳空字串\nEnd // 程式執行結束"
    },
    {
      "title": "Bulls and Cows",
      "source_file": "Leetcode/leetcode299.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A3B'\nGot (Norm):      '0A0B'\n--- (Raw) ---\nRaw Expected: '\"1A3B\"'\nRaw Got:      '0A0B'"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1A1B'\nGot (Norm):      '0A0B'\n--- (Raw) ---\nRaw Expected: '\"1A1B\"'\nRaw Got:      '0A0B'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        \"\"\"Return the Bulls and Cows hint for a single guess.\"\"\"\n        bulls = 0\n        # Count frequencies of unmatched digits\n        secret_unmatched = Counter()\n        guess_unmatched = Counter()\n\n        for s, g in zip(secret, guess):\n            if s == g:\n                bulls += 1\n            else:\n                secret_unmatched[s] += 1\n                guess_unmatched[g] += 1\n\n        # Cows are the minimum matches of each digit in the unmatched parts\n        cows = sum(min(secret_unmatched[d], guess_unmatched[d]) for d in secret_unmatched)\n        return f\"{bulls}A{cows}B\"\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the raw stdin data to extract the secret and guess strings.\n    Supports formats like:\n        secret = \"1807\", guess = \"7810\"\n    or simply two space/newline separated tokens.\n    \"\"\"\n    # Remove quotes, equal signs, commas and split by whitespace\n    cleaned = data.replace('\"', '').replace(\"'\", '').replace('=', ' ').replace(',', ' ')\n    tokens = cleaned.split()\n    if len(tokens) < 2:\n        raise ValueError(\"Input must contain both secret and guess.\")\n    return tokens[0], tokens[1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    secret_str, guess_str = parse_input(raw_input)\n    solution = Solution()\n    hint = solution.getHint(secret_str, guess_str)\n    print(hint)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation comments. Provide the algorithm: iterate over digits, count bulls, track counts of remaining digits in secret and guess. Then compute cows by min of counts. Output string.\n\nWe need to use virtual code syntax: Start, → Step 1, → Decision: etc. Provide arrow lines. Must include \"[space]\" between code and comment. Use // comment.\n\nWe must not output actual code, just virtual steps. Each line must have code + space + // comment.\n\nOk produce lines:\n\nStart // start program\n→ Step 1: 初始化 bulls = 0, cows = 0 // 設定計數器\n→ Step 2: 初始化兩個大小為10的計數器 secretCount[0..9], guessCount[0..9] 為0 // 用於統計非牛的數字\n→ Decision: 迭代索引 i 從 0 到 length(secret)-1? // 遍歷所有位\n    Yes → Decision: secret[i] 等於 guess[i]? // 判斷是否為牛\n        Yes → Step 3: bulls++ // 位於正確位置\n        No  → Step 4: secretCount[secret[i]]++ // 非牛，統計秘密數字\n             → Step 5: guessCount[guess[i]]++ // 非牛，統計猜測數字\nEnd of loop // 迴圈結束\n→ Step 6: For each digit d 從 0 到 9\n    → Step 7: cows += min(secretCount[d], guessCount[d]) // 計算奶牛\n→ Step 8: 返回 字符串 bulls + \"A\" + cows + \"B\" // 結果格式\n\nNeed to ensure each line is separate.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 bulls = 0, cows = 0 // 設定牛與奶牛的計數器  \n→ Step 2: 初始化 secretCount[0..9] = 0, guessCount[0..9] = 0 // 用於統計非牛的數字頻率  \n→ Decision: 迭代索引 i 從 0 到 secret.length-1? // 逐位比對  \n    Yes → Decision: secret[i] 等於 guess[i]? // 判斷是否為牛  \n        Yes → Step 3: bulls++ // 位置正確，牛數增加  \n        No  → Step 4: secretCount[ secret[i] ]++ // 非牛，統計秘密數字頻率  \n             → Step 5: guessCount[ guess[i] ]++ // 非牛，統計猜測數字頻率  \nEnd // 迭代結束  \n→ Step 6: For d 從 0 到 9  \n    → Step 7: cows += min( secretCount[d], guessCount[d] ) // 計算奶牛數量  \n→ Step 8: 返回 字符串 bulls + \"A\" + cows + \"B\" // 結果格式化並輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp27hcik3n.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp27hcik3n.py\", line 30, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 使用字典將每個數字映射到它的所有索引\n        self.index_map = defaultdict(list)\n        for idx, num in enumerate(nums):\n            self.index_map[num].append(idx)\n\n    def pick(self, target):\n        # 隨機選擇一個等於 target 的索引\n        return random.choice(self.index_map[target])\n\ndef main():\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將輸入拆分為操作名列表和對應的參數列表\n    # 例：'[\"Solution\", \"pick\", \"pick\"], [[[1, 2]], [3], [1]]'\n    parts = raw_input.split('],', 1)\n    ops_str = parts[0] + ']'          # 完成第一個列表的閉合\n    args_str = '[' + parts[1].strip()  # 為第二部分包裝一層方括號\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = []\n    instance = None\n\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            instance = Solution(arg[0])\n            res.append(None)           # 以 null 表示\n        else:\n            method = getattr(instance, op)\n            res.append(method(*arg))\n\n    # 以 JSON 風格輸出結果\n    import json\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines, step-by-step, for a class Solution that stores an array, and pick returns random index of target. Implementation: store mapping from target to list of indices or pick on the fly. Virtual code: Start, init, store mapping, pick, loop over array, count, reservoir sampling. Use Reservoir sampling: count occurrences, when find target, generate random number between 0 and count-1, if 0 choose index.\n\nWe'll produce virtual code lines:\n\nStart\n→ Step 1: 定義類別 Solution // Class definition\n→ Step 2: 定義屬性 nums // store array\n→ Step 3: 定義構造函式 Solution(nums) // constructor\n    → Step 4: 設定 this.nums = nums // assign\nEnd\n\nPick function:\n\n→ Step 1: 定義方法 pick(target) // method\n    → Step 2: 初始化 count = 0 // number of target seen\n    → Step 3: 初始化 result = -1 // placeholder\n    → Step 4: 循環 i from 0 to nums.length-1\n        → Decision: 如果 nums[i] == target?\n            Yes → Step 5: count += 1 // increment count\n            Yes → Step 6: 生成隨機數 r 在 [0, count-1]\n            Yes → Decision: 如果 r == 0?\n                Yes → Step 7: result = i // 選擇此索引\n    → Step 8: 返回 result // 返回隨機索引\n\nWe need to include comments.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立 Solution 類別  \n→ Step 2: 定義屬性 nums // 用於存儲輸入陣列  \n→ Step 3: 定義構造函式 Solution(nums) // 初始化物件  \n  → Step 4: 設定 this.nums = nums // 把傳入的陣列存進物件屬性  \nEnd // 結束初始化  \n\nStart // 開始 pick 方法的流程  \n→ Step 1: 定義方法 pick(target) // 定義選取目標值的函式  \n  → Step 2: 初始化 count = 0 // 追蹤已見到的目標數量  \n  → Step 3: 初始化 result = -1 // 暫存被選中的索引  \n  → Step 4: 循環 i 由 0 到 this.nums.length - 1 // 遍歷整個陣列  \n    → Decision: 如果 this.nums[i] == target? // 檢查當前元素是否為目標  \n     Yes → Step 5: count += 1 // 找到目標後計數加一  \n     Yes → Step 6: 生成隨機數 r 在 [0, count-1] // 隨機選擇候選索引  \n     Yes → Decision: 如果 r == 0? // 機率 1/count  \n      Yes → Step 7: result = i // 把此索引存入結果  \n  → Step 8: 返回 result // 回傳隨機挑選的目標索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    依字元頻率降冪排序字符串\n    \"\"\"\n    # 計算每個字符的出現頻率\n    freq = Counter(s)\n    # most_common() 會按頻率降冪排序\n    # 直接把每個字符重複對應次數拼接起來\n    return ''.join(char * count for char, count in freq.most_common())\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    # 若輸入類似 s = \"tree\"，則擷取引號內的內容\n    if '\"' in raw_input:\n        start = raw_input.find('\"')\n        end = raw_input.rfind('\"')\n        if start != -1 and end != -1 and end > start:\n            s = raw_input[start + 1:end]\n        else:\n            s = raw_input\n    else:\n        s = raw_input\n\n    result = frequency_sort(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step explaining sorting characters by frequency descending. Use Start, Decision, etc. Not actual code. Provide lines like:\n\nStart // start\n→ Step 1: Initialize empty map frequencyMap // record counts\n→ Step 2: For each char in s, increment frequencyMap[char] // count\n→ Step 3: Convert map entries to list of (char, count) // pair list\n→ Decision: Is list empty? ...\nBut we don't need to check empty. Just proceed.\n\nThen sort list by count descending.\n\n→ Step 4: Sort list by count descending // ordering\n→ Step 5: Build result string: For each pair, append char repeated count times // output\n→ Step 6: Return result string // final\n\nAlso mention handling multiple answers any.\n\nUse arrow syntax and explanation.\n\nOk produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率字典 frequencyMap // 用於記錄每個字符的出現次數  \n→ Step 2: 對字串 s 的每個字符 c 執行 frequencyMap[c] += 1 // 逐個累加頻率  \n→ Step 3: 將 frequencyMap 轉換為頻率列表 freqList，元素為 (字符, 次數) // 方便排序  \n→ Decision: freqList 是否為空? // 檢查是否有任何字符  \n  Yes → End // 若字串為空，直接結束並返回空字串  \n  No  → Step 4: 對 freqList 依據次數降序排序 // 最高頻率排前面  \n→ Step 5: 初始化空字串 result // 用於儲存最終結果  \n→ Step 6: 對 freqList 中的每個 (char, count) 執行  \n  → result += char 重複 count 次 // 依頻率拼接字符  \n→ Step 7: 返回 result // 完成排序後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # Build a map from reversed word to its index\n        rev_dict = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            n = len(word)\n            # Iterate over all possible splits: prefix = word[:j], suffix = word[j:]\n            for j in range(n + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # Case 1: prefix is a palindrome\n                if prefix == prefix[::-1]:\n                    rev = suffix[::-1]\n                    if rev in rev_dict and rev_dict[rev] != i:\n                        res.append([rev_dict[rev], i])\n\n                # Case 2: suffix is a palindrome (avoid double counting when j == n)\n                if j != n and suffix == suffix[::-1]:\n                    rev = prefix[::-1]\n                    if rev in rev_dict and rev_dict[rev] != i:\n                        res.append([i, rev_dict[rev]])\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list of words from the input\n    # The input may be like: 'words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]'\n    # or simply: '[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        words = []\n    else:\n        words_str = data[start:end+1]\n        try:\n            words = ast.literal_eval(words_str)\n        except Exception:\n            words = []\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find all palindrome pairs with linear time relative to total characters. This known problem: we can use trie of reversed words, mapping indices. For each word, we iterate splits and check palindrome prefix/suffix. We'll produce pseudocode steps.\n\nWe need to output line by line, each with \"虛擬碼步驟 // 解釋\". Use arrow markers: Start, End, Decision, Yes→, No→. The virtual code should reflect logic but not actual code. Provide step-by-step.\n\nWe'll start with building a trie of reversed words with indices. Then for each word, iterate splits, check palindrome property, look up matches.\n\nWe must maintain O(total length). So building trie O(total length). Searching each word also O(len(word)). So overall O(total).\n\nWe produce pseudocode steps: Start, Step 1: Build trie, Step 2: For each word i, check splits, etc.\n\nWe need to reflect decisions for palindrome checks.\n\nLet's draft.\n\nUse arrow lines with spaces.\n\nWe need to include comments after each step. Should be clear.\n\nLet's produce:\n\nStart\n→ Step 1: 建立 Trie，將每個字串 reverse 後插入，並將其索引存於節點終端 // 建構 Trie 以便快速查詢後綴\n\nThen for each word index i:\n→ Step 2: 對於每個單字 words[i]，進行以下處理 // 逐一檢查字串\n\nInside loop, we need to check splits.\n\nWe might do:\n\n→ Step 3: 對於從 0 到 words[i].length 的每個分割點 k，分為前綴 words[i][0:k] 與後綴 words[i][k: ] // 檢查所有可能分割\n\nDecision: 前綴是否為 palindrome? // 如果是，則在 Trie 中尋找匹配的後綴 (reverse of 前綴) 的索引 j != i\n\n    Yes → Step 4: 在 Trie 中搜尋 reverse(前綴) 的索引 j // 若找到且 j != i\n\n        → Decision: j 是否存在且不等於 i? // 需要確保不同索引\n\n            Yes → Step 5: 若後綴為空，則 words[i] + words[j] 為 palindrome，加入結果 // 前綴 palindrome 且後綴為空\n\n            No  → Step 6: words[i] + words[j] 為 palindrome，加入結果 // 即使後綴不空，前綴 palindrome 且後綴在 Trie 匹配\n\n        No → Step 7: 無匹配，跳過\n\nDecision: 後綴是否為 palindrome? // 同理處理反向\n\n    Yes → Step 8: 在 Trie 中搜尋 reverse(後綴) 的索引 j // 若找到且 j != i\n\n        → Decision: j 是否存在且不等於 i?\n\n            Yes → Step 9: 若前綴為空，則 words[j] + words[i] 為 palindrome，加入結果\n\n            No  → Step 10: words[j] + words[i] 為 palindrome，加入結果\n\n        No → Step 11: 無匹配，跳過\n\nWe also need to handle when whole word itself palindrome? That will be covered by splits where k = len(word) and k = 0.\n\nBetter: We'll also handle when k == len(word), then prefix is whole word, suffix empty. If prefix palindrome then we need find word j where reversed whole word exists. That's handled.\n\nSimilarly k==0, prefix empty, suffix whole word, check suffix palindrome etc.\n\nNeed to store results: list pairs.\n\nAfter loop, End.\n\nBut we must present virtual code lines sequentially, with arrows and decisions.\n\nBetter to structure:\n\nStart\n→ Step 1: 建立 Trie，將 words[i] 以 reverse 形式插入，並在終端節點存索引 i // 建立搜尋資料結構\n→ Step 2: 初始化答案 list // 儲存 (i,j) 對\n→ Decision: 是否所有 words 已插入? // 確認 Trie 完整\n    Yes → Step 3: 對於每個索引 i 進行以下步驟\n        → Step 3a: 取得 words[i] 的長度 n\n        → Step 3b: 對於 k 從 0 到 n\n            → Step 3b1: 定義前綴 = words[i][0:k], 後綴 = words[i][k:]\n            → Decision: 前綴是否為 palindrome?\n                Yes → Step 3b1a: 在 Trie 搜尋 reverse(前綴)，取得索引 j\n                    → Decision: j 存在且 j != i?\n                        Yes → Step 3b1a1: 若後綴為空，則 words[i]+words[j] 為 palindrome，加入答案\n                        No  → Step 3b1a2: words[i]+words[j] 為 palindrome，加入答案\n                No  → Step 3b1b: 跳過\n            → Decision: 後綴是否為 palindrome?\n                Yes → Step 3b1c: 在 Trie 搜尋 reverse(後綴)，取得索引 j\n                    → Decision: j 存在且 j != i?\n                        Yes → Step 3b1c1: 若前綴為空，則 words[j]+words[i] 為 palindrome，加入答案\n                        No  → Step 3b1c2: words[j]+words[i] 為 palindrome，加入答案\n                No  → Step 3b1d: 跳過\n    No → End\n\nBut we need to include \"End\".\n\nAlso, we need to ensure each line uses arrow or decision. Provide explanation.\n\nLet's produce final output with correct indentation.\n\nWe must ensure each line is one step.\n\nLet's format like:\n\nStart // 程式開始執行\n→ Step 1: 建立 Trie，將每個 words[i] 以 reverse 形式插入，並在終端節點存索引 i // 建構 Trie 以便快速查詢\n→ Step 2: 初始化答案 list // 用於儲存所有 palindrome pair\n→ Decision: Trie 已建構完成? // 確保 Trie 已就緒\n    Yes → Step 3: 對於每個索引 i 從 0 到 words.length-1 執行以下\n        → Step 3a: 取得 words[i] 的長度 n // 方便分割\n        → Step 3b: 對於 k 從 0 到 n\n            → Step 3b1: 設定 prefix = words[i][0:k], suffix = words[i][k:] // 分割字串\n            → Decision: prefix 是否為 palindrome? // 前半部是否為回文\n                Yes → Step 3b1a: 在 Trie 中搜尋 reverse(prefix)，取得索引 j // 找到對應後綴\n                    → Decision: j 存在且 j ≠ i? // 確保不同索引\n                        Yes → Step 3b1a1: 若 suffix 為空，則 words[i]+words[j] 為 palindrome，加入答案 // 前半部為回文且後半部空\n                        No  → Step 3b1a2: words[i]+words[j] 為 palindrome，加入答案 // 前半部為回文且後半部不空，但仍成回文\n                No  → Step 3b1b: 跳過\n            → Decision: suffix 是否為 palindrome? // 後半部是否為回文\n                Yes → Step 3b1c: 在 Trie 中搜尋 reverse(suffix)，取得索引 j // 找到對應前綴\n                    → Decision: j 存在且 j ≠ i? // 確保不同索引\n                        Yes → Step 3b1c1: 若 prefix 為空，則 words[j]+words[i] 為 palindrome，加入答案 // 後半部為回文且前半部空\n                        No  → Step 3b1c2: words[j]+words[i] 為 palindrome，加入答案 // 後半部為回文且前半部不空\n                No  → Step 3b1d: 跳過\n→ End // 程式執行結束\n\nBut the \"Decision: Trie 已建構完成?\" is trivial, but we can keep.\n\nNeed to ensure each line uses arrow or Decision: lines. For decisions we use \"Decision:\" with Yes→ and No→.\n\nWe need to produce lines each with arrow or decision.\n\nLet's rewrite properly.\n\nWe need to ensure proper indentation. Use arrow \"→\" at each step. For decisions we use \"Decision: ...?\" then indent Yes→ and No→ lines.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Trie，將每個 words[i] 以 reverse 形式插入，並在終端節點存索引 i // 建構 Trie 以便快速查詢  \n→ Step 2: 初始化答案 list // 用於儲存所有 palindrome pair  \n→ Decision: Trie 已建構完成? // 確保 Trie 已就緒  \n Yes → Step 3: 對於每個索引 i 從 0 到 words.length-1 執行以下  \n  → Step 3a: 取得 words[i] 的長度 n // 方便分割  \n  → Step 3b: 對於 k 從 0 到 n  \n   → Step 3b1: 設定 prefix = words[i][0:k], suffix = words[i][k:] // 分割字串  \n   → Decision: prefix 是否為 palindrome? // 前半部是否為回文  \n    Yes → Step 3b1a: 在 Trie 中搜尋 reverse(prefix)，取得索引 j // 找到對應後綴  \n     → Decision: j 存在且 j ≠ i? // 確保不同索引  \n      Yes → Step 3b1a1: 若 suffix 為空，則 words[i]+words[j] 為 palindrome，加入答案 // 前半部為回文且後半部空  \n      No  → Step 3b1a2: words[i]+words[j] 為 palindrome，加入答案 // 前半部為回文且後半部不空  \n     No  → Step 3b1b: 跳過  \n   → Decision: suffix 是否為 palindrome? // 後半部是否為回文  \n    Yes → Step 3b1c: 在 Trie 中搜尋 reverse(suffix)，取得索引 j // 找到對應前綴  \n     → Decision: j 存在且 j ≠ i? // 確保不同索引  \n      Yes → Step 3b1c1: 若 prefix 為空，則 words[j]+words[i] 為 palindrome，加入答案 // 後半部為回文且前半部空  \n      No  → Step 3b1c2: words[j]+words[i] 為 palindrome，加入答案 // 後半部為回文且前半部不空  \n    No  → Step 3b1d: 跳過  \n→ End // 程式執行結束"
    },
    {
      "title": "Implement Queue using Stacks",
      "source_file": "Leetcode/leetcode232.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,1,false]'\nGot (Norm):      '[null,null,1,1,false]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, 1, false]'\nRaw Got:      '[null, null, 1, 1, false]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\nif __name__ == \"__main__\":\n    lines = [line.strip() for line in sys.stdin.read().splitlines() if line.strip() != \"\"]\n    # Skip a possible 'Input' line\n    if lines and lines[0].lower() == \"input\":\n        lines = lines[1:]\n    if len(lines) < 2:\n        print(\"[]\")\n        sys.exit(0)\n    methods = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1])\n\n    obj = MyQueue()\n    results = []\n    for method, arg in zip(methods, args):\n        if method == \"push\":\n            obj.push(arg[0] if arg else None)\n            results.append(None)\n        elif method == \"pop\":\n            results.append(obj.pop())\n        elif method == \"peek\":\n            results.append(obj.peek())\n        elif method == \"empty\":\n            results.append(obj.empty())\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps line by line. Each line: virtual code step + space + // explanation. Use arrows and structure: Start, End, Decision: etc.\n\nWe need to implement a FIFO queue using two stacks. So the algorithm: use two stacks, inStack and outStack. push: push onto inStack. pop: if outStack empty, move all from inStack to outStack, then pop outStack. peek similar. empty: both empty.\n\nWe must produce pseudo code steps: start, variable init, operations, decisions. Should be stepwise.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize Stack inStack // stack for incoming elements\n→ Step 2: Initialize Stack outStack // stack for outgoing elements\n→ Step 3: Define Method push(x) // push element to queue\n    → Step 3.1: inStack.push(x) // add to top of inStack\n→ Step 4: Define Method pop() // remove front element\n    → Decision: outStack.isEmpty() ?\n        Yes → Step 4.1: while !inStack.isEmpty() // transfer\n                 → Step 4.1.1: outStack.push(inStack.pop()) // move each\n        No → skip\n    → Step 4.2: return outStack.pop() // pop front element\n→ Step 5: Define Method peek() // get front element without removing\n    → Decision: outStack.isEmpty() ?\n        Yes → Step 5.1: while !inStack.isEmpty()\n                 → Step 5.1.1: outStack.push(inStack.pop())\n        No → skip\n    → Step 5.2: return outStack.peek() // top of outStack is front\n→ Step 6: Define Method empty() // check if queue empty\n    → Decision: inStack.isEmpty() && outStack.isEmpty() ?\n        Yes → Step 6.1: return true\n        No  → Step 6.2: return false\nEnd\n\nMake sure each line with arrow, and comment after //.\n\nNeed to ensure each line ends with // explanation. Use arrow formatting consistent.\n\nWe also need to indicate \"→\" arrow, \"Decision:\" lines.\n\nLet's produce each line carefully.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 Stack inStack // 用於儲存入隊元素\n→ Step 2: 初始化 Stack outStack // 用於儲存出隊元素\n→ Step 3: 定義 方法 push(x) // 將元素加入隊尾\n    → Step 3.1: inStack.push(x) // 直接推入 inStack\n→ Step 4: 定義 方法 pop() // 取得並移除隊首元素\n    → Decision: outStack.isEmpty() ? // 判斷出隊堆疊是否為空\n        Yes → Step 4.1: while !inStack.isEmpty() // 若空，將所有 inStack 移至 outStack\n            → Step 4.1.1: outStack.push(inStack.pop()) // 逐一移動\n        No  → // outStack 已有元素，無需搬移\n    → Step 4.2: return outStack.pop() // 從 outStack 取出最前面元素\n→ Step 5: 定義 方法 peek() // 取得隊首元素但不移除\n    → Decision: outStack.isEmpty() ?\n        Yes → Step 5.1: while !inStack.isEmpty()\n            → Step 5.1.1: outStack.push(inStack.pop())\n        No  → // outStack 已有元素\n    → Step 5.2: return outStack.peek() // 返回 outStack 的頂部元素\n→ Step 6: 定義 方法 empty() // 判斷隊列是否為空\n    → Decision: inStack.isEmpty() && outStack.isEmpty() ?\n        Yes → Step 6.1: return true\n        No  → Step 6.2: return false\nEnd // 程式執行結束\n\nMake sure each line has arrow or indentation. For Decision lines we need the arrow maybe \"Decision:\" preceded by arrow. In example, they used \"Decision:\" after an indentation, no arrow. They also used \"Yes →\" lines inside. So keep consistent: indent inside Decision block.\n\nWe must keep consistent spacing. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 Stack inStack // 用於儲存入隊元素\n→ Step 2: 初始化 Stack outStack // 用於儲存出隊元素\n→ Step 3: 定義 方法 push(x) // 將元素加入隊尾\n    → Step 3.1: inStack.push(x) // 直接推入 inStack\n→ Step 4: 定義 方法 pop() // 取得並移除隊首元素\n    → Decision: outStack.isEmpty() ? // 判斷出隊堆疊是否為空\n        Yes → Step 4.1: while !inStack.isEmpty() // 若空，將所有 inStack 移至 outStack\n            → Step 4.1.1: outStack.push(inStack.pop()) // 逐一移動\n        No  → // outStack 已有元素，無需搬移\n    → Step 4.2: return outStack.pop() // 從 outStack 取出最前面元素\n→ Step 5: 定義 方法 peek() // 取得隊首元素但不移除\n    → Decision: outStack.isEmpty() ?\n        Yes → Step 5.1: while !inStack.isEmpty()\n            → Step 5.1.1: outStack.push(inStack.pop())\n        No  → // outStack 已有元素\n    → Step 5.2: return outStack.peek() // 返回 outStack 的頂部元素\n→ Step 6: 定義 方法 empty() // 判斷隊列是否為空\n    → Decision: inStack.isEmpty() && outStack.isEmpty() ?\n        Yes → Step 6.1: return true\n        No  → Step 6.2: return false\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\ndef findLUSlength(strs):\n    \"\"\"Return length of the longest uncommon subsequence among the given strings.\"\"\"\n    freq = Counter(strs)          # Count occurrences of each string\n    max_len = 0                   # Max length among unique strings\n\n    for s in strs:\n        if freq[s] == 1 and len(s) > max_len:\n            max_len = len(s)\n\n    return max_len if max_len > 0 else -1\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Parse the input list of strings (e.g., '[\"aba\",\"cdc\",\"eae\"]')\n    strs = json.loads(data)\n    result = findLUSlength(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given array of strings strs, return length of longest uncommon subsequence between them or -1. This is LeetCode 688. Known solution: if any string appears only once, answer is its length; else if all strings identical, -1; else the longest length among strings (since if duplicates, need unique). Actually algorithm: if all strings are same, return -1. Else for each string s, if count of s in array == 1, return len(s). Else continue. After loop, return -1? Wait, but if no unique string, then maybe longest string is not uncommon? Actually if all strings are unique, the longest string length is answer. But if duplicates exist, we can't use duplicates. But algorithm above works: iterate all s, if count(s)==1, return len(s). After loop, return -1? Let's confirm: example [\"aba\",\"cdc\",\"eae\"] all unique, answer 3. Count(s)==1 for each, so we return first len 3. Good. Example [\"aaa\",\"aaa\",\"aa\"], we have duplicate \"aaa\" but unique \"aa\", answer 2. Good. Example [\"a\",\"a\"], no unique, return -1. Also case [\"abcd\",\"abc\"] where duplicates none, answer 4. Good. So algorithm stands: find any unique string; return its length. If none, return -1.\n\nThus pseudocode: count frequency map, loop. Complexity O(n). Use dictionary.\n\nWe'll produce step-by-step pseudocode lines.\n\nLet's craft:\n\nStart // Program starts\n→ Step 1: 初始化頻率表 counts // 用來計算每個字串出現次數\n→ Step 2: 對每個字串 s in strs: // 遍歷所有字串\n    → Step 3: counts[s] += 1 // 更新頻率\n→ Decision: 是否存在頻率為1的字串? // 檢查是否有唯一字串\n    Yes → Step 4: 找到第一個 counts[s]==1 的字串 s_unique // 找到唯一字串\n    → Step 5: 回傳 len(s_unique) // 回傳該字串長度\n    No  → Step 6: 回傳 -1 // 若不存在唯一字串，返回 -1\nEnd // 程式結束\n\nBut need to handle that we need to find the longest unique. Since we iterate order maybe not longest; but we can track max length among unique. So better: iterate all strings, if counts[s]==1 and len(s)>maxLen, update maxLen. After loop, if maxLen>0 return maxLen else -1. Or easier: loop again over strings to find any unique; but we need longest unique, but all unique have unique, but we want longest among them. But if we return first unique, not necessarily longest. Example [\"a\",\"abc\"] -> unique both; first unique \"a\" len1, but answer should be 3. So need to track max length among unique strings. So we should compute max unique length.\n\nThus pseudocode:\n\nStart\n→ Step 1: 計算每個字串出現次數 counts\n→ Step 2: maxLen ← 0 // 初始化最大長度\n→ Step 3: 對每個字串 s in strs:\n    → Decision: 如果 counts[s]==1? // 是否唯一\n        Yes → Step 4: 如果 len(s) > maxLen: maxLen ← len(s) // 更新最大長度\n        No  → 跳過\n→ Decision: maxLen>0? // 是否有唯一字串\n    Yes → Step 5: 回傳 maxLen // 回傳最大長度\n    No  → Step 6: 回傳 -1 // 否則不存在\nEnd\n\nYes.\n\nNow produce lines with \"虛擬碼步驟\" and comments.\n\nMake sure each line has '虛擬碼步驟 // 解釋'. Use arrows and decisions.\n\nAlso Start and End lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 counts // 用於統計每個字串出現次數  \n→ Step 2: 初始化變數 maxLen ← 0 // 用來記錄唯一字串的最大長度  \n→ Step 3: 對陣列 strs 中的每個字串 s 執行  \n    → Decision: 若 counts[s] 尚未存在? // 檢查字典中是否已有此字串\n        Yes → Step 4: 設置 counts[s] ← 1 // 第一次見到此字串，計數為 1\n        No  → Step 5: counts[s] ← counts[s] + 1 // 不是第一次見，計數加 1  \n→ Step 6: 再次遍歷 strs 中的每個字串 s  \n    → Decision: 若 counts[s] == 1? // 判斷此字串是否唯一\n        Yes → Decision: 若 len(s) > maxLen? // 是否比目前最大長度更長\n            Yes → Step 7: maxLen ← len(s) // 更新最大長度\n            No  → 跳過  \n        No  → 跳過  \n→ Decision: maxLen > 0? // 是否存在唯一字串\n    Yes → Step 8: 回傳 maxLen // 回傳最長唯一字串的長度\n    No  → Step 9: 回傳 -1 // 沒有唯一字串，返回 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"\n        找出 DNA 序列中長度為 10 的子字串，且出現次數超過一次的所有子字串。\n        \"\"\"\n        if len(s) < 10:\n            return []\n\n        seen = set()\n        repeated = set()\n        window = 10\n        for i in range(len(s) - window + 1):\n            seq = s[i:i + window]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從 stdin 讀入的字串中提取 DNA 序列。\n    支援類似 \"s = 'ACGT'\" 或直接的 DNA 字串輸入。\n    \"\"\"\n    raw = raw.strip()\n    # 先嘗試找出第一個單引號或雙引號包起來的內容\n    match = re.search(r\"['\\\"]([^'\\\"]*)['\\\"]\", raw)\n    if match:\n        return match.group(1)\n    # 若沒有引號，直接回傳整個字串\n    return raw\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    s = parse_input(data)\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n    # 以 JSON 格式輸出，符合範例中的「[\"...\"]」形式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step. The algorithm: given string s, find all 10-letter substrings that appear more than once. Use sliding window of length 10, count using hash map. Collect those with count >1.\n\nWe'll produce steps: Start, input string, if length<10 return empty, create map, set result list, loop i from 0 to len-10, extract substring s[i:i+10], increment count, if count becomes 2 add to result, end loop, output result. End. Also handle decision: length < 10? etc.\n\nWe must output in specified format: each line with \"虛擬碼步驟 // 解釋/說明\". Use arrows, Decision: etc.\n\nLet's craft lines.\n\n1. Start // 程式開始執行\n2. → Input: s // 取得 DNA 序列\n3. → Decision: s.length < 10? // 檢查序列長度是否足夠 10\n    Yes → Step: Return empty list // 若不足 10，無法有 10 字母子序列\n    No  → Step: 初始化\n4. → Step: Initialize map counts = {} // 記錄每個 10 字母子序列出現次數\n5. → Step: Initialize result = [] // 存放重複出現的子序列\n6. → Step: Set windowSize = 10\n7. → Step: For i from 0 to s.length - windowSize // 滑動窗口遍歷所有 10 字母子序列\n    → Step: sub = s.substring(i, i + windowSize) // 取得當前子序列\n    → Step: counts[sub] = (counts[sub] ?? 0) + 1 // 更新計數\n    → Decision: counts[sub] == 2? // 第一次超過一次時加入結果\n        Yes → Step: result.append(sub) // 加入結果\n        No  → Step: do nothing // 其餘次數不重複加入\n8. → Step: Return result // 回傳所有重複的 10 字母子序列\nEnd // 程式執行結束\n\nWe need each line as separate line. Use proper indentation for decisions maybe with tabs. Format as in example: use indentation spaces. Provide each line with arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s // 取得 DNA 序列  \n→ Decision: s.length < 10? // 檢查序列長度是否足夠 10  \n  Yes → Step: Return empty list // 若不足 10，無法有 10 字母子序列  \n  No  → Step: 初始化  \n→ Step: Initialize map counts = {} // 記錄每個 10 字母子序列出現次數  \n→ Step: Initialize result = [] // 存放重複出現的子序列  \n→ Step: Set windowSize = 10  \n→ Step: For i from 0 to s.length - windowSize // 滑動窗口遍歷所有 10 字母子序列  \n  → Step: sub = s.substring(i, i + windowSize) // 取得當前子序列  \n  → Step: counts[sub] = (counts[sub] ?? 0) + 1 // 更新計數  \n  → Decision: counts[sub] == 2? // 第一次超過一次時加入結果  \n    Yes → Step: result.append(sub) // 加入結果  \n    No  → Step: do nothing // 其餘次數不重複加入  \n→ Step: Return result // 回傳所有重複的 10 字母子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef permute(nums):\n    \"\"\"Return all permutations of a list of distinct integers.\"\"\"\n    res = []\n\n    def backtrack(start):\n        if start == len(nums):\n            res.append(nums[:])  # append a copy of the current permutation\n            return\n        for i in range(start, len(nums)):\n            # swap the current element with the element at index i\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            # backtrack: restore the original order\n            nums[start], nums[i] = nums[i], nums[start]\n\n    backtrack(0)\n    return res\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract the list part after '=' if present\n    if '=' in data:\n        list_part = data.split('=', 1)[1].strip()\n    else:\n        list_part = data\n\n    # Safely evaluate the list expression\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = []\n\n    # Compute permutations and print the result\n    result = permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nThe user asks: \"使用者需求: Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. 請根據輸出格式要求產生虛擬碼和逐行解釋:\" So we need to output virtual code steps to generate permutations. Should not output actual code, just virtual steps with arrows and decisions. Let's produce a start, input array, recursion to generate permutations, maybe using backtracking.\n\nWe need to include the start, steps, decisions, end. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 讀取給定的整數陣列\n→ Step 2: 初始化空列表 result 用於儲存所有排列 // 建立結果儲存容器\n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // 設計遞迴方法\n    → Step 4: Decision: 如果 remaining 為空? // 判斷是否所有元素已使用\n        Yes → Step 5: 把 current 加入 result // 將完整排列加入結果\n        No  → Decision: 迭代每個元素 in remaining\n            → Step 6: 選擇元素 e 作為下一個位置 // 選取一個未使用的元素\n            → Step 7: 呼叫 backtrack(current + [e], remaining - {e}) // 進行遞迴\n            → Step 8: 回溯 // 返回上一層\n→ Step 9: 呼叫 backtrack([], nums) // 開始遞迴\n→ Step 10: 回傳 result // 回傳所有排列\nEnd // 程式執行結束\n\nBut we need to format each line with arrow and include \"Decision:\" lines. For decisions, we must indent accordingly. Use indentation: For Decision: If, then Yes → etc. Use 'Yes →' 'No →'.\n\nWe need to maintain virtual code style. Let's produce.\n\nAlso mention \"使用者輸入\" etc.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums // 從使用者或呼叫方取得整數陣列  \n→ Step 2: 初始化空列表 result 用於儲存所有排列 // 建立結果容器  \n→ Step 3: 定義遞迴函式 backtrack(current, remaining) // 設計回溯演算法  \n  Decision: 如果 remaining 為空? // 判斷是否已使用完所有元素  \n   Yes → Step 4: 把 current 加入 result // 把完整排列加入結果  \n   No  → Decision: 迭代 remaining 中每個元素 e  \n    Yes → Step 5: 選擇元素 e 作為下一個位置 // 把 e 加入 current  \n     → Step 6: 呼叫 backtrack(current + [e], remaining - {e}) // 進一步遞迴  \n     → Step 7: 回溯 // 回到上一層，準備選取下一個元素  \n→ Step 8: 呼叫 backtrack([], nums) // 從空序列開始遞迴  \n→ Step 9: 回傳 result // 將所有排列返回  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # 使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        \n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        \n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        \n        return slow\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入中擷取列表部分\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        print(\"Invalid input\")\n        sys.exit(1)\n\n    nums_str = data[start:end+1]\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception:\n        print(\"Invalid input\")\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the problem: find the repeated number in array of length n+1 with values 1..n, with only one duplicate, no modification, constant space.\n\nThis is the classic Floyd's Tortoise and Hare (linked list cycle detection). Steps: first phase find intersection, second phase find entrance.\n\nWe'll produce virtual code lines accordingly.\n\nWe need to use structure: Start, → Step, Decision: ... Yes → ... No → ...\n\nWe need to be careful to not output actual code, just virtual steps. Provide brief explanation per line.\n\nLet's draft:\n\nStart // 程式開始執行\n\n→ Step 1: 定義 slow = nums[0] // 初始化慢指針\n\n→ Step 2: 定義 fast = nums[0] // 初始化快指針\n\n→ Decision: 迴圈開始? // 進入第一次尋找交點的迴圈\n\n    Yes → Step 3: slow = nums[slow] // 移動慢指針一步\n\n    → Step 4: fast = nums[nums[fast]] // 移動快指針兩步\n\n    → Decision: slow == fast? // 檢查是否相遇\n\n        Yes → Decision: 交點已找到? // 結束第一次迴圈\n\n        No  → Yes → Step 5: 迴圈繼續 // 回到迴圈開始\n\nAfter loop, we found intersection.\n\n→ Step 6: 重置 slow = nums[0] // 把慢指針重設到起點\n\n→ Decision: 迴圈開始? // 進入尋找入口的迴圈\n\n    Yes → Step 7: slow = nums[slow] // 慢指針移一步\n\n    → Step 8: fast = nums[fast] // 快指針也移一步\n\n    → Decision: slow == fast? // 檢查是否相遇\n\n        Yes → Step 9: 重複數 = slow // 找到重複的數字\n\n        No  → Yes → Step 10: 迴圈繼續 // 回到迴圈開始\n\n→ Step 11: 輸出 重複數 // 返回結果\n\nEnd // 程式結束\n\nBut we need to ensure using constant extra space: only variables slow, fast, result. So it's fine.\n\nBut we need to produce virtual code with arrow notation. Use \"Decision:\" for conditions, \"Yes →\" for branch. Provide each line with explanation comment.\n\nWe also need to include the loop structure. Since it's virtual, we can represent loops via decisions: \"Decision: 是否已相遇?\" with Yes/No branches, and the No branch points back to Step 3 (loop). But in our representation, we cannot use goto, but we can show the loop via repetition in the lines? Example: Show \"Decision: slow == fast?\" with Yes and No; the No branch leads to \"→ Step 3\" again. In example, they didn't use loops; they just used nested Decision to show repeated iteration? Let's follow pattern: Use Decision and Yes/No arrow. For loop, we can show \"Decision: 迴圈是否結束?\" with Yes to exit, No to continue.\n\nBut to keep simple, we can describe loop in a single Decision with two branches: Yes → exit, No → back to start of loop. But we cannot show arrow back. But we can mimic by referencing step numbers. Since this is pseudocode, we can simply show iterative steps in a block with indentation. But requirement: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:).\" So we need to use arrows and decisions. In example, they didn't have loops; they had nested decisions.\n\nSo we need to use Decision: for each loop, we can show \"Decision: 是否已相遇?\" Yes to exit loop, No to continue (but we need to indicate next step). We can refer to step numbers or just show as \"Yes → Exit Loop\" but maybe we can just show: \"Decision: slow == fast?\" with Yes → \"離開循環\" and No → \"繼續循環\" (point to Step 3). In the example, they didn't show loops. But we can still do. Let's produce:\n\nStart\n\n→ Step 1: slow = nums[0] // 初始化慢指針\n\n→ Step 2: fast = nums[0] // 初始化快指針\n\n→ Decision: 找到交點? // 開始尋找交點\n\n    Yes → End of phase 1 // 交點已找到\n\n    No  → Step 3: slow = nums[slow] // 慢指針移動\n\n          → Step 4: fast = nums[nums[fast]] // 快指針移動兩步\n\n          → Decision: 找到交點? // 檢查是否相遇\n\n             Yes → Exit phase 1\n\n             No  → Back to Step 3\n\nBut need to reflect loops: maybe we can denote as \"Decision: slow == fast?\" with Yes -> \"交點找到\" else -> \"繼續循環\".\n\nWe might also break into two separate loops: first intersection loop, second entrance loop.\n\nLet's produce virtual code lines:\n\nStart // 程式開始\n\n→ Step 1: slow ← nums[0] // 設定慢指針起點\n\n→ Step 2: fast ← nums[0] // 設定快指針起點\n\n→ Decision: 已經相遇? // 判斷是否已在同一節點\n\n    Yes → Step 3: 交點已確定 // 交點找到，進入下一階段\n\n    No  → Step 4: slow ← nums[slow] // 慢指針前進一格\n\n          → Step 5: fast ← nums[nums[fast]] // 快指針前進兩格\n\n          → Decision: 已經相遇? // 檢查是否相遇\n\n             Yes → Step 6: 交點已確定\n\n             No  → 回到 Step 4 // 重複上述過程\n\nAfter loop ends, we have intersection.\n\n→ Step 7: slow ← nums[0] // 把慢指針重設到起點\n\n→ Decision: 已經相遇? // 判斷是否到入口\n\n    Yes → Step 8: 重複數 ← slow // 找到重複數\n\n    No  → Step 9: slow ← nums[slow] // 慢指針前進一格\n\n          → Step 10: fast ← nums[fast] // 快指針也前進一格\n\n          → Decision: 已經相遇? // 檢查相遇\n\n             Yes → Step 11: 重複數 ← slow // 找到重複數\n\n             No  → 回到 Step 9 // 重複\n\n→ Step 12: 輸出 重複數 // 回傳結果\n\nEnd // 程式結束\n\nBut we need each line as \"虛擬碼步驟 [space] // 解釋\". We should ensure that each line contains only one step, not multiple. In example, each line is a separate step. So we need to split Step 4-5 etc. We need to avoid grouping. Also we need to handle loop back references maybe with \"→\" arrow pointing to previous line? But it's okay.\n\nSimplify: Represent loops as while loops using Decision: \"Decision: slow != fast?\" then inside block.\n\nBut the example didn't use while loops; they used nested Decision but no loops. But it's acceptable to use Decision and arrows to show flow.\n\nWe can use this pattern:\n\nStart\n\n→ Step 1: slow ← nums[0] // 初始化慢指針\n\n→ Step 2: fast ← nums[0] // 初始化快指針\n\n→ Decision: slow != fast? // 判斷是否已相遇\n\n    Yes → Step 3: slow ← nums[slow] // 慢指針移動\n\n          → Step 4: fast ← nums[nums[fast]] // 快指針移動兩格\n\n          → Decision: slow != fast? // 再次檢查\n\n             Yes → 回到 Step 3 // 繼續迴圈\n\n             No  → 交點已找到 // 交點確定\n\nAfter loop:\n\n→ Step 5: slow ← nums[0] // 把慢指針重設到起點\n\n→ Decision: slow != fast? // 判斷是否到入口\n\n    Yes → Step 6: slow ← nums[slow] // 慢指針移動\n\n          → Step 7: fast ← nums[fast] // 快指針移動\n\n          → Decision: slow != fast? // 檢查\n\n             Yes → 回到 Step 6 // 繼續迴圈\n\n             No  → 重複數 ← slow // 找到重複數\n\nAfter loop:\n\n→ Step 8: 輸出 重複數 // 回傳結果\n\nEnd\n\nBut we need to have each step on a separate line. We need to manage indentation or grouping.\n\nBut the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". The \"虛擬碼步驟\" can be like \"Start\", \"→ Step 1: ...\", \"→ Decision: ...\", \"Yes → ...\", \"No → ...\".\n\nWe need to produce each line accordingly.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: slow ← nums[0] // 初始化慢指針\n\n→ Step 2: fast ← nums[0] // 初始化快指針\n\n→ Decision: slow != fast? // 迴圈條件：還未相遇\n\n    Yes → Step 3: slow ← nums[slow] // 慢指針前進一步\n\n    → Step 4: fast ← nums[nums[fast]] // 快指針前進兩步\n\n    → Decision: slow != fast? // 再次檢查是否相遇\n\n        Yes → 回到 Step 3 // 仍未相遇，繼續迴圈\n\n        No  → // 交點已找到，結束第一階段\n\n// 交點確定，開始尋找入口\n\n→ Step 5: slow ← nums[0] // 把慢指針重設至起點\n\n→ Decision: slow != fast? // 判斷是否到入口\n\n    Yes → Step 6: slow ← nums[slow] // 慢指針前進一步\n\n    → Step 7: fast ← nums[fast] // 快指針前進一步\n\n    → Decision: slow != fast? // 檢查是否相遇\n\n        Yes → 回到 Step 6 // 繼續搜尋入口\n\n        No  → 重複數 ← slow // 找到重複數，退出\n\n→ Step 8: 輸出 重複數 // 回傳結果\n\nEnd // 程式結束\n\nBut we need each line as \"虛擬碼步驟 [space] // 解釋\". The lines with decisions contain \"→ Decision:\" then indent and then \"Yes → ...\". In example, they did indent.\n\nWe must ensure each line is separate. So lines with Yes/No branch should start with indentation and \"Yes →\" or \"No →\". That's fine.\n\nAlso, we need to indicate \"回到 Step 3\" maybe not necessary; we can just say \"循環回到前面\" but to keep constant space, we can indicate that the No branch goes back to the top of the loop.\n\nLet's produce final answer accordingly.\n\nWe must output in Traditional Chinese. Provide only virtual code lines.\n\nLet's craft final.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 將慢指針指向陣列起點  \n→ Step 2: fast ← nums[0] // 將快指針指向陣列起點  \n→ Decision: slow ≠ fast? // 判斷兩指針是否已相遇（第一階段尋找交點）  \n    Yes → Step 3: slow ← nums[slow] // 慢指針移動一步  \n    → Step 4: fast ← nums[nums[fast]] // 快指針移動兩步  \n    → Decision: slow ≠ fast? // 再次檢查是否相遇  \n        Yes → 回到 Step 3 // 若未相遇，重複此迴圈  \n        No  → // 交點已找到，結束第一階段  \n\n→ Step 5: slow ← nums[0] // 把慢指針重設至陣列起點，準備尋找入口  \n→ Decision: slow ≠ fast? // 判斷兩指針是否已相遇（第二階段尋找入口）  \n    Yes → Step 6: slow ← nums[slow] // 慢指針移動一步  \n    → Step 7: fast ← nums[fast] // 快指針也移動一步  \n    → Decision: slow ≠ fast? // 檢查是否相遇  \n        Yes → 回到 Step 6 // 若未相遇，繼續尋找入口  \n        No  → 重複數 ← slow // 找到重複的數字，退出迴圈  \n\n→ Step 8: 輸出 重複數 // 將重複數字返回給呼叫者  \nEnd // 程式結束執行"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,2,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 2, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素\n        self.data = []\n        # 值 -> 所有索引集合\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，返回是否首次插入\"\"\"\n        self.data.append(val)\n        idx = len(self.data) - 1\n        self.idx_map[val].add(idx)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"移除一個 val，返回是否成功移除\"\"\"\n        if not self.idx_map[val]:\n            return False\n        # 取出一個待刪除索引\n        remove_idx = self.idx_map[val].pop()\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n        # 把最後一個元素移到要刪除的位置\n        self.data[remove_idx] = last_val\n        if remove_idx != last_idx:\n            # 更新最後一個元素的索引集合\n            self.idx_map[last_val].discard(last_idx)\n            self.idx_map[last_val].add(remove_idx)\n        # 刪除最後一個元素\n        self.data.pop()\n        # 若 val 的索引集合已空，刪除鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.data)\n\ndef parse_input(input_str: str):\n    \"\"\"將輸入字串轉為 ops 與 args\"\"\"\n    # 為了讓 JSON 解析成功，將兩個 list 包裝在外層列表中\n    wrapped = '[' + input_str.strip() + ']'\n    ops_and_args = json.loads(wrapped)\n    return ops_and_args[0], ops_and_args[1]\n\ndef format_output(results):\n    \"\"\"將結果轉為 LeetCode 風格字串\"\"\"\n    out_parts = []\n    for val in results:\n        if val is None:\n            out_parts.append('null')\n        elif isinstance(val, bool):\n            out_parts.append('true' if val else 'false')\n        else:\n            out_parts.append(str(val))\n    return '[' + ', '.join(out_parts) + ']'\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    ops, args = parse_input(raw_input)\n\n    collection = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedCollection':\n            collection = RandomizedCollection()\n            results.append(None)\n        elif op == 'insert':\n            results.append(collection.insert(arg[0]))\n        elif op == 'remove':\n            results.append(collection.remove(arg[0]))\n        elif op == 'getRandom':\n            results.append(collection.getRandom())\n\n    print(format_output(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this RandomizedCollection implementation. Should include steps for init, insert, remove, getRandom. Each line with arrow and explanation. We'll describe algorithm: use vector for values, unordered_map val -> unordered_set of indices. Insert: push_back val to vector, add index to map set. Return true if set size==1 (i.e., was not present). Remove: check if map[val] non-empty. Get any index from set (e.g., iterator). Remove that index: swap with last element in vector, update map for swapped value. Erase last element. Remove index from map[val]. If set empty, erase map entry. Return true. getRandom: generate random index [0, vec.size()-1], return vec[idx]. We'll produce step-by-step pseudocode with decisions.\n\nWe'll output lines like:\nStart\n→ Step: 初始化數據結構 // vector & map\n→ Step: insert(val)\n...\n\nBut need to produce algorithm for class and methods. Let's produce high-level pseudo with lines representing each logical step. Ensure \"Decision:\" lines for conditions.\n\nLet's write:\n\nStart // 初始化 RandomizedCollection\n→ Step 1: 建立空 vector nums\n→ Step 2: 建立空 map valToIndices（鍵為 int，值為 set<int>）\n\nInsert(val):\n→ Decision: if val不在 valToIndices? // 判斷是否首次插入\n    Yes → Step: 返回 true\n    No  → Step: 返回 false\n→ Step: nums.push_back(val) // 將值加入末尾\n→ Step: idx = nums.size()-1 // 獲取新元素索引\n→ Step: valToIndices[val].insert(idx) // 將索引加入集合\n\nRemove(val):\n→ Decision: 如果 val 在 valToIndices? // 判斷是否存在\n    No → Step: 返回 false\n→ Step: idx = 任意 valToIndices[val] 中的索引 // 取出一個索引\n→ Step: lastIdx = nums.size()-1\n→ Step: lastVal = nums[lastIdx]\n→ Step: nums[idx] = lastVal // 用最後一個元素覆蓋待刪除位置\n→ Decision: 如果 idx != lastIdx? // 是否需要更新\n    Yes → Step: valToIndices[lastVal].erase(lastIdx)\n            Step: valToIndices[lastVal].insert(idx)\n→ Step: nums.pop_back() // 刪除最後元素\n→ Step: valToIndices[val].erase(idx) // 移除舊索引\n→ Decision: 如果 valToIndices[val] 為空? // 清除空集合\n    Yes → Step: valToIndices.erase(val)\n→ Step: 返回 true\n\ngetRandom():\n→ Step: randomIdx = 隨機數 [0, nums.size()-1]\n→ Step: return nums[randomIdx]\n\nEnd\n\nWe need to use arrow \"→\" at each line. For decision branches, indent maybe but include arrows and decisions.\n\nEnsure each line has the format: \"→ Step: ... // 說明\" or \"→ Decision: ...\".\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空 vector nums // 用來存放所有元素  \n→ Step 2: 建立空 map valToIndices（鍵 int，值 set<int>） // 將每個值映射到其所有索引  \n\n// ====================== insert ======================\n→ Decision: 如果 val 不在 valToIndices? // 判斷是否首次插入  \n  Yes → Step: 返回 true // 首次插入返回 true  \n  No  → Step: 返回 false // 已存在則返回 false  \n→ Step: nums.push_back(val) // 把 val 加入向量尾部  \n→ Step: idx = nums.size() - 1 // 取得新元素的索引  \n→ Step: valToIndices[val].insert(idx) // 將索引加入對應集合  \n\n// ====================== remove ======================\n→ Decision: 如果 val 不在 valToIndices? // 判斷是否存在  \n  No → Step: 返回 false // 不存在則返回 false  \n→ Step: idx = 任意 valToIndices[val] 中的索引 // 取出一個要刪除的索引  \n→ Step: lastIdx = nums.size() - 1 // 取得最後一個元素的索引  \n→ Step: lastVal = nums[lastIdx] // 取得最後一個元素的值  \n→ Step: nums[idx] = lastVal // 用最後一個元素覆蓋要刪除的位置  \n→ Decision: 如果 idx != lastIdx? // 是否需要更新索引映射  \n  Yes → Step: valToIndices[lastVal].erase(lastIdx) // 移除舊索引  \n    Step: valToIndices[lastVal].insert(idx) // 插入新索引  \n→ Step: nums.pop_back() // 刪除向量最後一個元素  \n→ Step: valToIndices[val].erase(idx) // 移除對應集合中的舊索引  \n→ Decision: 如果 valToIndices[val] 為空? // 檢查是否需要清除鍵  \n  Yes → Step: valToIndices.erase(val) // 刪除空集合的鍵  \n→ Step: 返回 true // 成功刪除一個元素  \n\n// ====================== getRandom ======================\n→ Step: randomIdx = 隨機數 [0, nums.size() - 1] // 產生隨機索引  \n→ Step: return nums[randomIdx] // 回傳隨機選出的元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Minimum Genetic Mutation",
      "source_file": "Leetcode/leetcode433.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu898wmp7.py\", line 50, in parse_input\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {startGene \"\":,\"AACCGGTT\", endGene \"\":,\"AACCGGTA\", bank \"\":,[\"AACCGGTA\"] }\n               ^^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpu898wmp7.py\", line 60, in <module>\n    start, end, bank = parse_input(raw_input)\n                       ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu898wmp7.py\", line 53, in parse_input\n    data = eval(dict_str, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {startGene \"\":,\"AACCGGTT\", endGene \"\":,\"AACCGGTA\", bank \"\":,[\"AACCGGTA\"] }\n               ^^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8_6wpkg3.py\", line 50, in parse_input\n    data = ast.literal_eval(dict_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {startGene \"\":,\"AACCGGTT\", endGene \"\":,\"AAACGGTA\", bank \"\":,[\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"] }\n               ^^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp8_6wpkg3.py\", line 60, in <module>\n    start, end, bank = parse_input(raw_input)\n                       ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8_6wpkg3.py\", line 53, in parse_input\n    data = eval(dict_str, {})\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {startGene \"\":,\"AACCGGTT\", endGene \"\":,\"AAACGGTA\", bank \"\":,[\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"] }\n               ^^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start: str, end: str, bank: list) -> int:\n        \"\"\"返回從 start 變異到 end 所需的最少步數，若無法完成則回傳 -1。\"\"\"\n        # 若終點不在基因庫，無法完成\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = {start}\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n\n            for i in range(len(current)):\n                for g in genes:\n                    if g == current[i]:\n                        continue\n                    mutation = current[:i] + g + current[i+1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef parse_input(text: str):\n    \"\"\"\n    將類似 'startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]'\n    的字串轉換成 dict，並回傳 start, end, bank。\n    \"\"\"\n    # 把變數名變成鍵\n    transformed = ''\n    for token in text.replace('\\n', ' ').split():\n        if '=' in token:\n            key, val = token.split('=', 1)\n            transformed += f'\"{key.strip()}\":{val.strip()},'\n        else:\n            transformed += token + ' '\n    if transformed.endswith(','):\n        transformed = transformed[:-1]\n    # 包裹成 dict 字串\n    dict_str = '{' + transformed + '}'\n    try:\n        data = ast.literal_eval(dict_str)\n    except Exception:\n        # 若解析失敗，嘗試直接 eval\n        data = eval(dict_str, {})\n    return data.get('startGene'), data.get('endGene'), data.get('bank', [])\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    start, end, bank = parse_input(raw_input)\n    sol = Solution()\n    result = sol.minMutation(start, end, bank)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for finding minimum mutations using BFS. Provide virtual code line by line with explanations. Ensure use of arrow, decision, Start, End. Use the sample format. We'll do BFS over 8-char strings, bank set. Steps: convert bank to set. If endGene not in bank, return -1. Queue start with startGene and depth 0. Visited set. While queue not empty: pop. If current equals endGene, return depth. Generate neighbors: for each position, change to other nucleotides. If new in bank and not visited, add to queue depth+1. After loop, return -1.\n\nLet's format each step with \"→ Step X:\" and arrow. Provide explanation after //. Use Decision: with Yes →, No → as required.\n\nWe'll number steps maybe not needed but keep.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: bankSet ← 轉換 bank 為集合 // 方便 O(1) 成員檢查  \n→ Decision: endGene 是否在 bankSet? // 確認終點是否有效  \n    Yes → Step 2: 初始化 queue ← [(startGene, 0)] // (基因, 目前步數)  \n           visited ← {startGene} // 已探索的基因  \n    No  → Step 3: 返回 -1 // 終點不在可行基因庫，無法完成變異  \n\n→ Step 4: while queue 不是空的 // BFS 逐層搜尋  \n        → Step 5: (current, steps) ← queue 去頭 // 取出第一個基因與步數  \n        → Decision: current == endGene? // 是否已達終點  \n            Yes → Step 6: 返回 steps // 最短變異數目  \n            No  → Step 7: 為 i in 0..7 // 逐位嘗試變異  \n                    → Step 8: for nucleotide in ['A','C','G','T']  \n                        → Decision: nucleotide != current[i]? // 只變異一次  \n                            Yes → newGene ← current 替換第 i 位為 nucleotide // 產生新基因  \n                                   → Decision: newGene 在 bankSet 且 not in visited? // 必須在庫且未訪問  \n                                       Yes → visited ← visited ∪ {newGene}  \n                                              queue ← queue 加 (newGene, steps+1) // 加入 BFS 隊列  \n                                       No  → Step 9: // 不符合條件，忽略  \n                            No  → Step 10: // 與原字相同，跳過  \n→ Step 11: 返回 -1 // BFS 結束仍未找到終點，無可行路徑  \nEnd // 程式執行結束"
    },
    {
      "title": "Best Time to Buy and Sell Stock III",
      "source_file": "Leetcode/leetcode123.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys, ast\n\ndef max_profit(prices):\n    if not prices:\n        return 0\n    # 初始化四個狀態：第一筆買入、第一筆賣出、第二筆買入、第二筆賣出\n    buy1 = -prices[0]\n    sell1 = 0\n    buy2 = -prices[0]\n    sell2 = 0\n    for price in prices[1:]:\n        # 第一筆買入：盡量用更低的價格買入\n        if -price < buy1:\n            buy1 = -price\n        # 第一筆賣出：盡量獲得更高利潤\n        if price + buy1 > sell1:\n            sell1 = price + buy1\n        # 第二筆買入：用第一筆賣出的利潤作為初始資金，盡量低買入\n        if -price + sell1 < buy2:\n            buy2 = -price + sell1\n        # 第二筆賣出：盡量獲得更高利潤\n        if price + buy2 > sell2:\n            sell2 = price + buy2\n    return sell2\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，例如：prices = [3,3,5,0,0,3,1,4]\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        prices = []\n    else:\n        try:\n            prices = ast.literal_eval(data[start:end+1])\n        except Exception:\n            prices = []\n    result = max_profit(prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: maximum profit with at most two transactions, stock prices array. Standard DP: keep track of four states: buy1, sell1, buy2, sell2. Or use min cost and profit. We'll create steps: initialize variables, iterate over prices, update states. Use virtual code with arrows.\n\nWe need to output line by line. Let's produce:\n\nStart // 程式開始\n→ Step 1: 初始化 buy1, sell1, buy2, sell2 // 設定第一筆買賣的最佳利潤與成本\n    - buy1 = -∞? Actually we set to -prices[0] maybe.\nBut simpler: set buy1 = -prices[0]; sell1=0; buy2=-prices[0]; sell2=0; then iterate.\n\nAlternatively, we can compute min cost and max profit.\n\nWe produce pseudo algorithm:\n\nStart // 開始\n→ Step 1: 取得數列長度 n // 計算天數\n→ Decision: 如果 n < 2? // 若天數不足兩天，無法交易\n    Yes → Step 2: 輸出 0 // 無利潤\n    No  → Step 3: 初始化\n        → Step 3.1: buy1 = -prices[0] // 第一筆買入成本\n        → Step 3.2: sell1 = 0\n        → Step 3.3: buy2 = -prices[0] // 第二筆買入成本\n        → Step 3.4: sell2 = 0\n    → Step 4: 從第 2 天開始遍歷\n        → For each price in prices[1:]:\n            → Decision: price > buy1? // 更新第一筆買入\n                Yes → buy1 = min(buy1, -price) // 以最低價格買入\n                No  → No action\n            → Decision: price - buy1 > sell1? // 更新第一筆賣出\n                Yes → sell1 = price - buy1\n                No  → No action\n            → Decision: price > buy2? // 更新第二筆買入\n                Yes → buy2 = min(buy2, -price + sell1) // 用第一筆賣出的利潤作為成本\n                No  → No action\n            → Decision: price - buy2 > sell2? // 更新第二筆賣出\n                Yes → sell2 = price - buy2\n                No  → No action\n    → Step 5: 輸出 sell2 // 最終最大利潤\nEnd // 結束\n\nBut maybe use simpler DP: keep maxProfit1 and maxProfit2. However pseudo fine.\n\nLet's output each step line by line. Ensure each line ends with // explanation. Use arrows as indicated.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 取得價格陣列長度 n // 先知道有幾天的股價\n→ Decision: 如果 n < 2? // 少於兩天就無法完成任何交易\n    Yes → Step 2: 輸出 0 // 回傳零利潤\n    No  → Step 3: 初始化交易狀態\n        → Step 3.1: buy1 = -prices[0] // 第一筆買進的最佳成本（負值表示支出）\n        → Step 3.2: sell1 = 0 // 第一筆賣出的最大利潤\n        → Step 3.3: buy2 = -prices[0] // 第二筆買進的最佳成本，初始時與第一筆相同\n        → Step 3.4: sell2 = 0 // 第二筆賣出的最大利潤\n→ Step 4: 從第 2 天（索引 1）開始迭代所有股價\n    → For price in prices[1:]:\n        → Decision: price < -buy1? // 若今天的價格低於目前已記錄的最低買入成本\n            Yes → buy1 = -price // 更新第一筆買進的最低成本\n            No  → No action\n        → Decision: price + buy1 > sell1? // 若今天以第一筆買進成本賣出能得到更高利潤\n            Yes → sell1 = price + buy1 // 更新第一筆賣出的最大利潤\n            No  → No action\n        → Decision: price < -buy2 + sell1? // 若今天的價格低於 (第二筆買進成本 = -buy2 + sell1)\n            Yes → buy2 = -price + sell1 // 更新第二筆買進成本（使用第一筆賣出的利潤作為初始資金）\n            No  → No action\n        → Decision: price + buy2 > sell2? // 若今天以第二筆買進成本賣出能得到更高利潤\n            Yes → sell2 = price + buy2 // 更新第二筆賣出的最大利潤\n            No  → No action\n→ Step 5: 輸出 sell2 // sell2 即為最多兩筆交易可取得的最大總利潤\nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef groupAnagrams(strs):\n    \"\"\"\n    組合所有字母排列相同的字串。\n    以排序後的字串作為鍵，將原字串存入對應的列表。\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))            # 把字串排序成元組作為鍵\n        anagrams[key].append(s)           # 將原字串加入對應鍵的列表\n    return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 若輸入為 'strs = [...]' 的形式，先取等號右邊\n    if raw_input.startswith('strs'):\n        raw_input = raw_input.split('=', 1)[1].strip()\n\n    # 解析成 Python 列表\n    try:\n        strs = ast.literal_eval(raw_input)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit(1)\n\n    # 執行分組\n    result = groupAnagrams(strs)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for grouping anagrams. Output in Traditional Chinese. Each line: 虛擬碼步驟 + space + // explanation. Use Start, End, Decision: with arrows. So produce step-by-step. Probably: Start → Step 1: 建立哈希表 (key: sorted string) → Iterate each string → Sort string → Check hash → Append to list → End.\n\nWe need to be granular: start, iterate, sort, map. Provide arrow notation. Use 'Yes' and 'No' where applicable. Not actual code. Provide simple steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 groups // 用於儲存已排序字串對應的字串列表\n→ Step 2: 迭代輸入陣列 strs // 處理每個字串\n    → Step 3: 將當前字串 s 轉換為字符陣列並排序 → 得到 key // 用排序後的字串作為鍵\n    → Decision: groups 是否已包含 key? // 檢查是否已有此鍵\n        Yes → Step 4: 在 groups[key] 的列表中追加 s // 已有，將字串加入對應列表\n        No  → Step 5: 在 groups 建立新列表並加入 s // 沒有，創建新鍵並加入字串\n→ Step 6: 將 groups 的所有值取出為列表列表 // 轉換為最終結果\nEnd // 程式執行結束\n\nAdd explanations. Ensure each line ends with // 說明. Use arrow format properly. Provide 'Yes →' and 'No →' lines indented. Ensure format: \"Step 3: ...\" etc. Provide Chinese explanations.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 groups // 用於儲存已排序字串對應的字串列表  \n→ Step 2: 迭代輸入陣列 strs // 處理每個字串  \n → Step 3: 將當前字串 s 轉換為字符陣列並排序 → 得到 key // 用排序後的字串作為鍵  \n → Decision: groups 是否已包含 key? // 檢查是否已有此鍵  \n  Yes → Step 4: 在 groups[key] 的列表中追加 s // 已有，將字串加入對應列表  \n  No  → Step 5: 在 groups 建立新列表並加入 s // 沒有，創建新鍵並加入字串  \n→ Step 6: 將 groups 的所有值取出為列表列表 // 轉換為最終結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,null,false,true,true,true]'\nGot (Norm):      '[null,null,null,false,true,true,true]'\n--- (Raw) ---\nRaw Expected: '[null,null,null,null,false,true,true,true]'\nRaw Got:      '[null, null, null, false, true, true, true]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    def addWord(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i+1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], i+1)\n        return dfs(self.root, 0)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args = ast.literal_eval('(' + data + ')')\n    wd = WordDictionary()\n    res = []\n    for op, arg in zip(ops, args):\n        if op == 'addWord':\n            wd.addWord(arg[0] if isinstance(arg, (list, tuple)) else arg)\n            res.append(None)\n        elif op == 'search':\n            res.append(wd.search(arg[0] if isinstance(arg, (list, tuple)) else arg))\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation, following format. The requirement: design a data structure that supports adding words and searching with '.' wildcards. We need to produce virtual code for WordDictionary class with addWord and search methods. It's basically a Trie with DFS for search. Provide steps. Use Start, End, Decision. Each line must have '虛擬碼步驟' space '//' explanation.\n\nWe need to break into logical steps: initialization, addWord, search. For search with wildcard: DFS recursion. Provide pseudo steps.\n\nWe need to ensure we produce multiple lines. We'll produce:\n\nStart // program start\n→ Step: Create TrieNode class // define node\n→ Step: WordDictionary constructor // initialize root\n→ Step: addWord(word) // iterate letters\n→ Step: search(word) // call helper\n→ Step: helper(node, word, index) // recursive DFS\nDecision: char is '.'? // wildcard\n    Yes → iterate children\n    No → move to child with char\nDecision: reached end? // end of word\n    Yes → return node.isWord\n    No → continue recursion\nEnd // program end\n\nBut we need to reflect more detail. We'll produce a more comprehensive virtual code.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Format: Start, →, Decision, Yes→, No→.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Class TrieNode: // 定義 Trie 節點\n    → isWord: Boolean = False // 標記是否為完整單字\n    → children: Map<Character, TrieNode> = {} // 儲存子節點\n→ Class WordDictionary: // 主資料結構\n    → root: TrieNode = TrieNode() // 初始化根節點\n→ Method addWord(word): // 新增單字\n    → node ← root // 從根開始\n    → For each ch in word:\n        → If ch not in node.children:\n            → node.children[ch] ← TrieNode()\n        → node ← node.children[ch]\n    → node.isWord ← True // 標記結尾\n→ Method search(word): // 搜尋字串\n    → Return dfs(word, 0, root) // 開始遞迴\n→ Function dfs(word, idx, node): // 以 DFS 進行匹配\n    → If idx == length(word): // 到字串末尾\n        → Return node.isWord\n    → ch ← word[idx]\n    → Decision: ch == '.'? // 是否為通配符\n        Yes → For each childNode in node.children.values():\n            → If dfs(word, idx+1, childNode): // 任何子節點匹配成功\n                → Return True\n        → Return False // 無子節點匹配\n        No  → Decision: ch in node.children? // 字母是否存在\n            Yes → Return dfs(word, idx+1, node.children[ch]) // 繼續往下\n            No  → Return False // 字母不匹配\nEnd // 程式結束\n\nWe must ensure the formatting: Each line \"虛擬碼步驟 // 解釋\". The virtual code lines include arrows etc. But we need to output line by line. Each line must have a space after the step? The sample shows \"Start // 程式開始執行\" no arrow after. Then \"→ Step 1: 輸入使用者數字 // ...\" So we use arrow '→' at beginning of step lines. For nested, we can indent by adding spaces. But keep same format: \"→ Step: ...\" For decision, we write \"Decision: ...\" and nested \"Yes →\" \"No →\". We should maintain formatting.\n\nLet's write lines:\n\nStart // 程式開始執行\n→ Class TrieNode: // 定義 Trie 節點\n    → isWord: Boolean = False // 標記是否為完整單字\n    → children: Map<Character, TrieNode> = {} // 儲存子節點\n→ Class WordDictionary: // 主資料結構\n    → root: TrieNode = TrieNode() // 初始化根節點\n→ Method addWord(word): // 新增單字\n    → node ← root // 從根節點開始\n    → For each ch in word:\n        → If ch not in node.children:\n            → node.children[ch] ← TrieNode()\n        → node ← node.children[ch]\n    → node.isWord ← True // 標記單字結尾\n→ Method search(word): // 搜尋字串\n    → Return dfs(word, 0, root) // 開始遞迴搜尋\n→ Function dfs(word, idx, node): // 以 DFS 進行匹配\n    → If idx == length(word): // 到字串末尾\n        → Return node.isWord\n    → ch ← word[idx]\n    → Decision: ch == '.'? // 是否為通配符\n        Yes → For each childNode in node.children.values():\n            → If dfs(word, idx+1, childNode): // 子節點匹配成功\n                → Return True\n        → Return False // 無子節點匹配\n        No  → Decision: ch in node.children? // 字母是否存在\n            Yes → Return dfs(word, idx+1, node.children[ch]) // 繼續往下\n            No  → Return False // 字母不匹配\nEnd // 程式結束\n\nNeed to ensure each line has a space between step and comment. In sample, they use \"→ Step 1: ... // ...\" So we do same: \"→ Class TrieNode: // ...\" etc. For nested we might indent but still arrow. Use proper spacing.\n\nAlso note \"Decision:\" lines should have space after colon? \"Decision: ch == '.'?\" Good. \"Yes →\" etc. Provide explanation after comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Class TrieNode: // 定義 Trie 節點\n    → isWord: Boolean = False // 標記是否為完整單字\n    → children: Map<Character, TrieNode> = {} // 儲存子節點\n→ Class WordDictionary: // 主資料結構\n    → root: TrieNode = TrieNode() // 初始化根節點\n→ Method addWord(word): // 新增單字\n    → node ← root // 從根節點開始\n    → For each ch in word:\n        → If ch not in node.children:\n            → node.children[ch] ← TrieNode()\n        → node ← node.children[ch]\n    → node.isWord ← True // 標記單字結尾\n→ Method search(word): // 搜尋字串\n    → Return dfs(word, 0, root) // 開始遞迴搜尋\n→ Function dfs(word, idx, node): // 以 DFS 進行匹配\n    → If idx == length(word): // 到字串末尾\n        → Return node.isWord\n    → ch ← word[idx]\n    → Decision: ch == '.'? // 是否為通配符\n        Yes → For each childNode in node.children.values():\n            → If dfs(word, idx+1, childNode): // 子節點匹配成功\n                → Return True\n        → Return False // 無子節點匹配\n        No  → Decision: ch in node.children? // 字母是否存在\n            Yes → Return dfs(word, idx+1, node.children[ch]) // 繼續往下\n            No  → Return False // 字母不匹配\nEnd // 程式結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppd9mxn0y.py\", line 39, in <module>\n    result = solution.complexNumberMultiply(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppd9mxn0y.py\", line 21, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmppd9mxn0y.py\", line 18, in parse\n    imag_part = int(s[sep_index:])\n                ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        def parse(s: str):\n            # 去掉末尾的 i\n            if s.endswith('i'):\n                s = s[:-1]\n            # 找到實部和虛部的分隔符，從第二個字符開始尋找\n            sep_index = None\n            for i in range(1, len(s)):\n                if s[i] == '+' or s[i] == '-':\n                    sep_index = i\n                    break\n            if sep_index is None:\n                raise ValueError(\"Invalid complex number format\")\n            real_part = int(s[:sep_index])\n            imag_part = int(s[sep_index:])\n            return real_part, imag_part\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        # (a+bi)(c+di) = (ac - bd) + (ad + bc)i\n        real = a_real * b_real - a_imag * b_imag\n        imag = a_real * b_imag + a_imag * b_real\n\n        return f\"{real}+{imag}i\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 解析輸入，預期形如：\"1+1i\", \"1+1i\"\n    parts = [p.strip().strip('\"').strip(\"'\") for p in data.split(',')]\n    if len(parts) != 2:\n        raise ValueError(\"Input must contain two complex numbers separated by a comma.\")\n    num1, num2 = parts[0], parts[1]\n\n    solution = Solution()\n    result = solution.complexNumberMultiply(num1, num2)\n\n    # 根據範例輸出，結果需要加上雙引號\n    print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode lines with comments, describing algorithm to multiply complex numbers represented as strings like \"a+bi\". Must parse integers, compute product. Edge cases: negative numbers. Input strings maybe \"a+bi\" or \"a-bi\" depending sign. We need to parse into real1, imag1, real2, imag2. Then compute product: (a+bi)(c+di) = (ac - bd) + (ad + bc)i. Then output string in same form: real + sign + imag + \"i\". Real and imag are integers within range maybe. We output \"real+imag i\" or \"real-imag i\" if imag negative? But typical representation: if imag negative, it's \"real-abs(imag)i\". So we handle.\n\nVirtual code: start, input, parse first number, parse second number, compute product, format output, end.\n\nParsing steps: find index of 'i' maybe last char. Find index of '+' or '-' for the separator between real and imaginary, but careful that real part could be negative, so first sign may be '-' at start. Approach: Remove trailing 'i', then find last '+' or '-' that splits into real and imag. Could find last occurrence of '+' or '-' after first char. Use find. Then substring accordingly. Convert to int. We'll just describe.\n\nOk produce pseudocode lines.\n\nUse Start, End, Decision, Step lines. Also need arrow notation. Provide comments.\n\nWe'll output sequential lines. Let's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Step 1: 讀取字串 num1, num2 // 取得兩個複數字串輸入\nLine 3: → Step 2: 解析字串 num1 為 real1, imag1 // 從字串拆分實部與虛部\nLine 4: →   Decision: 是否含 '-' 作為分隔? // 判斷分隔符位置\nLine 5: →     Yes → Step 2a: 取出 real1 為 substring 前至分隔符 // 取得實部\nLine 6: →     Yes → Step 2b: 取出 imag1 為 substring 從分隔符至 'i' // 取得虛部\nLine 7: →     No  → Step 2c: 取出 real1 為 substring 前至分隔符 // 同上\nLine 8: →   End Decision\nBut we might simplify: just parse with regex. But need pseudo lines. Maybe we can combine.\n\nBut the format demands each line includes 虛擬碼步驟 + // explanation. So we must write each step with explanation.\n\nBetter to do:\n\nStep 2: 解析 num1 // 使用分隔符 + 或 - 找到實部與虛部\n\nBut we need to explain parse.\n\nWe'll produce step by step:\n\n- Step 2: 去除尾部 'i' // 移除虛部字母\n- Step 3: 在剩餘字串中找到最後一個 '+' 或 '-' // 確定分隔符\n- Step 4: 取分隔符前 substring 為 realPartStr // 得到實部字串\n- Step 5: 取分隔符後 substring 為 imagPartStr // 得到虛部字串\n- Step 6: 將 realPartStr, imagPartStr 轉成整數 real1, imag1 // 轉型\n\nSimilarly for num2.\n\nThen compute product.\n\n- Step 7: 計算 newReal = real1 * real2 - imag1 * imag2 // 實部計算\n- Step 8: 計算 newImag = real1 * imag2 + imag1 * real2 // 虛部計算\n- Step 9: 轉成字串 newImagStr = abs(newImag) // 取得絕對值字串\n- Step 10: 轉成最終結果字串 result = f\"{newReal}{'+' if newImag>=0 else '-'}{newImagStr}i\" // 產生輸出字串\n- End.\n\nWe need arrow notation: '→' before each line. Use Step 1 etc.\n\nWe need Decision lines maybe not needed but we can include simple decisions.\n\nWe must maintain formatting: each line like \"→ Step X: ...\" then space then \"// explanation\".\n\nLet's craft final answer. Use Chinese comments.\n\nWe'll produce about 15 lines. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取兩個複數字串 num1, num2 // 取得輸入  \n→ Step 2: 去除字串 num1 末尾的 'i' // 移除虛部字母  \n→ Step 3: 在剩餘字串中尋找最後一次出現的 '+' 或 '-' // 確定實部與虛部的分隔位置  \n→ Step 4: 取分隔符前的子字串為 real1Str // 取得 num1 的實部字串  \n→ Step 5: 取分隔符後（不含分隔符）的子字串為 imag1Str // 取得 num1 的虛部字串  \n→ Step 6: 把 real1Str 與 imag1Str 轉為整數 real1, imag1 // 轉型  \n→ Step 7: 重複步驟 2~6 處理 num2，得到 real2, imag2 // 解析第二個複數  \n→ Step 8: 計算實部 newReal = real1 * real2 - imag1 * imag2 // 乘法公式中的實部  \n→ Step 9: 計算虛部 newImag = real1 * imag2 + imag1 * real2 // 乘法公式中的虛部  \n→ Step 10: 取 newImag 的絕對值 imagAbsStr // 為輸出做準備  \n→ Step 11: 產生輸出字串 result = newReal + ('+' if newImag>=0 else '-') + imagAbsStr + 'i' // 組成最終複數字串  \n→ Step 12: 輸出 result // 回傳結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnosp3ift.py\", line 96, in <module>\n    main()\n  File \"/tmp/tmpnosp3ift.py\", line 76, in main\n    ops, args_list = parse_input(raw)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnosp3ift.py\", line 52, in parse_input\n    ops = ast.literal_eval(left)\n          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef parse_input(data: str):\n    \"\"\"Parse the input format used in the examples.\"\"\"\n    data = data.strip()\n    # Split the two top-level lists\n    try:\n        left, right = data.split('], [', 1)\n    except ValueError:\n        raise ValueError(\"Input format is incorrect.\")\n    # Clean trailing and leading brackets\n    if left.endswith(']'):\n        left = left[:-1]\n    if right.startswith('['):\n        right = right[1:]\n    if right.endswith(']'):\n        right = right[:-1]\n    ops = ast.literal_eval(left)\n    args = ast.literal_eval(right)\n    return ops, args\n\ndef format_output(lst):\n    out = '['\n    for i, val in enumerate(lst):\n        if i:\n            out += ', '\n        if val is None:\n            out += 'null'\n        elif val is True:\n            out += 'true'\n        elif val is False:\n            out += 'false'\n        else:\n            out += str(val)\n    out += ']'\n    return out\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    ops, args_list = parse_input(raw)\n    results = []\n    trie_obj = None\n    for op, arg in zip(ops, args_list):\n        if op == 'Trie':\n            trie_obj = Trie()\n            results.append(None)\n        elif op == 'insert':\n            trie_obj.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie_obj.search(arg[0]))\n        elif op == 'startsWith':\n            results.append(trie_obj.startsWith(arg[0]))\n        else:\n            # Unknown operation, append None\n            results.append(None)\n    print(format_output(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing Trie class with methods: constructor, insert, search, startsWith. Should be step-by-step algorithmic pseudocode. Should use virtual code arrows and decisions.\n\nWe need to produce line-by-line, each line: virtual code step + space + // explanation. Format: \"Start // 程式開始執行\" etc. Use \"→\" for steps, \"Decision:\" etc. Let's produce a clear algorithm.\n\nWe'll break into overall class definition and each method. We can show pseudo code for constructor, insert, search, startsWith. For insert: iterate chars, create node if missing, move to child, after loop mark end-of-word. For search: iterate, if missing return false, after loop return node.endFlag. For startsWith: iterate, if missing return false, after loop return true.\n\nWe can include struct Node: children map char->Node, isEnd bool. Represent with arrow.\n\nWe should produce code lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義節點結構 Node // 定義 Trie 節點\n\nBut the requirement is to produce virtual code steps for the implementation. It's not necessary to include code for all lines? But we need to provide algorithm steps, not actual code.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類別，包含 children 映射與 isEnd 標誌 // 建立 Trie 節點結構\n→ Step 2: 定義 Trie 類別，擁有 root Node // 初始化 Trie\n→ Step 3: Trie() → root ← new Node() // 建構子，創建根節點\n→ Step 4: insert(word) → node ← root // 進入根節點\n→ Step 5: → For each char c in word:\n        Decision: 是否存在 node.children[c]?\n            Yes → node ← node.children[c] // 走到現有子節點\n            No  → newNode ← new Node(); node.children[c] ← newNode; node ← newNode // 創建新節點\n        // 逐字建立或遍歷 Trie\n→ Step 6: node.isEnd ← true // 標記單詞結尾\n→ Step 7: search(word) → node ← root // 進入根節點\n→ Step 8: → For each char c in word:\n        Decision: 是否存在 node.children[c]?\n            Yes → node ← node.children[c] // 移動至子節點\n            No  → Return false // 找不到字符，單詞不存在\n        // 逐字查找\n→ Step 9: Return node.isEnd // 若到達終點且標記為結尾，則單詞存在\n→ Step 10: startsWith(prefix) → node ← root // 進入根節點\n→ Step 11: → For each char c in prefix:\n        Decision: 是否存在 node.children[c]?\n            Yes → node ← node.children[c] // 移動至子節點\n            No  → Return false // 前綴不在 Trie 中\n        // 逐字檢查前綴\n→ Step 12: Return true // 已遍歷完整前綴，代表存在前綴\nEnd // 程式執行結束\n\nWe must format each line with virtual code step followed by space then // explanation. Use arrow for steps. For loops, use \"→\" to indicate each step. Use \"Decision:\" accordingly. Ensure each line is separate.\n\nLet's produce that.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類別，包含 children 映射與 isEnd 標誌 // 建立 Trie 節點結構  \n→ Step 2: 定義 Trie 類別，擁有 root Node // 初始化 Trie  \n→ Step 3: Trie() → root ← new Node() // 建構子，創建根節點  \n→ Step 4: insert(word) → node ← root // 進入根節點  \n→ Step 5: → For each char c in word:  \n    → Decision: 是否存在 node.children[c]?  \n        Yes → node ← node.children[c] // 走到現有子節點  \n        No  → newNode ← new Node(); node.children[c] ← newNode; node ← newNode // 創建新節點  \n    // 逐字建立或遍歷 Trie  \n→ Step 6: node.isEnd ← true // 標記單詞結尾  \n→ Step 7: search(word) → node ← root // 進入根節點  \n→ Step 8: → For each char c in word:  \n    → Decision: 是否存在 node.children[c]?  \n        Yes → node ← node.children[c] // 移動至子節點  \n        No  → Return false // 找不到字符，單詞不存在  \n    // 逐字查找  \n→ Step 9: Return node.isEnd // 若到達終點且標記為結尾，則單詞存在  \n→ Step 10: startsWith(prefix) → node ← root // 進入根節點  \n→ Step 11: → For each char c in prefix:  \n    → Decision: 是否存在 node.children[c]?  \n        Yes → node ← node.children[c] // 移動至子節點  \n        No  → Return false // 前綴不在 Trie 中  \n    // 逐字檢查前綴  \n→ Step 12: Return true // 已遍歷完整前綴，代表存在前綴  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[6,6]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[6, 6]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[9,6,3]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[9, 6, 3]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7():\n    return random.randint(1,7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            num = (rand7() - 1) * 7 + rand7()  # 1-49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate rand10() using rand7(). Classic method: use two calls to get 1-49 range: (rand7()-1)*7 + rand7() gives 1-49. Accept if <= 40, then map to 1-10 via mod 10. If >40, reject and retry. Or use 2-digit method.\n\nWe must produce step-by-step pseudo-code with arrow lines, including decisions. No actual code.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Repeat\n→ Step 2: Generate x = rand7()\n→ Step 3: Generate y = rand7()\n→ Step 4: Compute num = (x-1)*7 + y // 1-49\n→ Decision: if num <= 40? \n    Yes → Step 5: Return ((num-1) mod 10) + 1\n    No  → Step 6: Repeat\n\nThen End.\n\nWe need to adhere to format: each line: virtual code step + space + // explanation.\n\nWe'll incorporate loops using Decision: while True? We can structure with a loop using Decision: 是否需要重試? maybe use a Decision at end to loop.\n\nWe need to show \"Start\", \"End\". Use arrows for steps. Also use Yes/No arrows for decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 重複下列流程直到產生有效結果 // 迴圈重試\n→ Step 2: rand1 ← rand7() // 取得 1~7 的隨機數\n→ Step 3: rand2 ← rand7() // 再取得一次 1~7 的隨機數\n→ Step 4: num ← (rand1 - 1) * 7 + rand2 // 組合成 1~49 的隨機數\n→ Decision: 是否 num ≤ 40? // 只接受 1~40 的範圍\n    Yes → Step 5: 返回 ((num - 1) mod 10) + 1 // 轉換為 1~10 的均勻數\n    No  → Step 6: 重複 Step 2~5 // 超過 40，重試\nEnd // 程式執行結束\n\nWe must maintain arrow for each step. For loop we might use Decision: 是否需要重試? but simpler as above.\n\nMake sure each line has space before //.\n\nWe also need to follow arrow formatting: \"→ Step X:\" etc. For decision, \"Decision:\" and indent children lines with tab or spaces. Provide \"Yes →\" and \"No →\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 重複下列流程直到產生有效結果 // 迴圈重試  \n→ Step 2: rand1 ← rand7() // 取得 1~7 的隨機數  \n→ Step 3: rand2 ← rand7() // 再取得一次 1~7 的隨機數  \n→ Step 4: num ← (rand1 - 1) * 7 + rand2 // 組合成 1~49 的隨機數  \n→ Decision: 是否 num ≤ 40? // 只接受 1~40 的範圍  \n  Yes → Step 5: 返回 ((num - 1) mod 10) + 1 // 轉換為 1~10 的均勻數  \n  No  → Step 6: 重複 Step 2~5 // 超過 40，重試  \nEnd // 程式執行結束"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6j31ew5a.py\", line 21, in <module>\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpest5cqjy.py\", line 21, in <module>\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4o21po2f.py\", line 21, in <module>\n    nums = eval(nums_str)\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\ndef search_insert(nums, target):\n    left, right = 0, len(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    parts = data.split(',')\n    nums_part = parts[0].strip()\n    target_part = parts[1].strip()\n    nums_str = nums_part.split('=')[1].strip()\n    nums = eval(nums_str)\n    target = int(target_part.split('=')[1].strip())\n    result = search_insert(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode with explanations, following the format. It's a binary search insertion index problem.\n\nWe should produce:\n\nStart\n→ Step 1: Initialize left = 0, right = length-1\n→ Step 2: While left <= right: compute mid, compare arr[mid] to target\n→ Decision: arr[mid] == target? Yes -> Step 3 output mid, End\n→ Decision: arr[mid] < target? Yes -> left = mid + 1\n→ No -> right = mid - 1\nAfter loop: return left (the insertion index)\nEnd\n\nNeed to incorporate explanation for each line. Use arrow \"→\" before step statements. Use Decision statements with Yes → etc.\n\nAlso need to ensure each line ends with // explanation. Each line preceded by \"Start\" or \"End\".\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = array.length - 1 // 設定搜尋區間\n→ Decision: left <= right? // 檢查是否仍有區間可搜尋\n    Yes → Step 2: 計算 mid = left + (right - left) // 防止溢位\n    Yes → Step 3: 若 array[mid] == target → Step 4: 輸出 mid // 找到目標\n    No  → Step 5: 若 array[mid] < target → Step 6: left = mid + 1 // 目標在右半\n    No  → Step 7: 若 array[mid] > target → Step 8: right = mid - 1 // 目標在左半\nAfter loop: Step 9: 輸出 left // 左指標即為插入位置\nEnd // 程式結束\n\nBut need to follow format: each line \"虛擬碼步驟 [space] // 解釋\". So we must not combine multiple steps on one line. We need separate lines for each step. Also Decision lines should indent? The example uses indentation. Use spaces for indentation.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = array.length - 1 // 設定搜尋區間\n→ Decision: left <= right? // 檢查是否仍有可搜尋區間\n    Yes → Step 2: 計算 mid = left + (right - left) // 防止溢位\n    Yes → Decision: array[mid] == target? // 判斷是否找到目標\n        Yes → Step 3: 輸出 mid // 找到目標，返回索引\n        No  → Decision: array[mid] < target? // 目標在右邊\n            Yes → Step 4: left = mid + 1 // 更新左邊界\n            No  → Step 5: right = mid - 1 // 更新右邊界\nAfter loop: Step 6: 輸出 left // left 為插入位置\nEnd // 程式結束\n\nCheck each line ends with // explanation. Also include the arrow for Decision and Yes→ etc. The arrow should be before the step line. In example they use:\n\n→ Decision: ...\n    Yes → Step...\n    No  → ...\n\nSo we will follow that.\n\nNeed to ensure each line is separate and each explanation concise.\n\nAlso note that \"After loop:\" is not a virtual code step but we can include a step for after loop: Step 6: return left.\n\nLet's refine:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = array.length - 1 // 設定搜尋區間\n→ Decision: left <= right? // 檢查是否仍有可搜尋區間\n    Yes → Step 2: 計算 mid = left + (right - left) // 防止溢位\n    Yes → Decision: array[mid] == target? // 判斷是否找到目標\n        Yes → Step 3: 輸出 mid // 找到目標，返回索引\n        No  → Decision: array[mid] < target? // 目標在右邊\n            Yes → Step 4: left = mid + 1 // 更新左邊界\n            No  → Step 5: right = mid - 1 // 更新右邊界\n→ Decision: left <= right? // 迴圈結束條件再次檢查\n    No  → Step 6: 輸出 left // left 為插入位置\nEnd // 程式結束\n\nBut we need to use \"End\" after step 6. The Decision lines should be part of loop. The loop repeated until left > right. We could model loop with while. But example uses Decision and recursion of Yes.\n\nBetter structure:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = array.length - 1 // 設定搜尋區間\n→ Decision: left <= right? // 檢查是否仍有可搜尋區間\n    Yes → Step 2: 計算 mid = left + (right - left) // 防止溢位\n    Yes → Decision: array[mid] == target? // 判斷是否找到目標\n        Yes → Step 3: 輸出 mid // 找到目標，返回索引\n        No  → Decision: array[mid] < target? // 目標在右邊\n            Yes → Step 4: left = mid + 1 // 更新左邊界\n            No  → Step 5: right = mid - 1 // 更新右邊界\n    No  → Step 6: 輸出 left // left 為插入位置\nEnd // 程式結束\n\nBut step 6 is after loop; we need to ensure step 6 executes only after left > right. That fits with Decision: left <= right? No → Step 6.\n\nHowever the loop should be repeated. The decision should be part of the loop. In this format, each time we go back to the decision after step 5 or 4. We can illustrate recursion by indenting again.\n\nBetter to use explicit \"While left <= right:\" but the required format uses Decision and arrows. So we can show:\n\nStart\n→ Step 1: 左 = 0, 右 = n-1\n→ Decision: 左 <= 右? // 仍有搜尋區間\n    Yes → Step 2: mid = 左 + (右 - 左) // 計算中點\n    Yes → Decision: arr[mid] == target? // 找到目標?\n        Yes → Step 3: 輸出 mid // 返回索引\n        No  → Decision: arr[mid] < target? // 目標在右邊\n            Yes → Step 4: 左 = mid + 1 // 更新左邊界\n            No  → Step 5: 右 = mid - 1 // 更新右邊界\n    No  → Step 6: 輸出 左 // 插入位置\nEnd\n\nBut we must keep consistent indentation: Each step preceded by \"→\". The Decision lines include indent for nested steps: \"Yes →\" and \"No →\" lines at same indent level as Step inside decision.\n\nWe need to ensure every line ends with \"// 解釋/說明\".\n\nLet's write final answer accordingly. Use Traditional Chinese. Ensure each line has one step.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = array.length - 1 // 設定搜尋區間\n→ Decision: left <= right? // 判斷是否還有區間可搜尋\n    Yes → Step 2: mid = left + (right - left) // 計算中點，避免溢位\n    Yes → Decision: array[mid] == target? // 檢查是否找到目標\n        Yes → Step 3: 輸出 mid // 找到目標，返回索引\n        No  → Decision: array[mid] < target? // 目標在右半邊\n            Yes → Step 4: left = mid + 1 // 更新左邊界，繼續搜尋右側\n            No  → Step 5: right = mid - 1 // 更新右邊界，繼續搜尋左側\n    No  → Step 6: 輸出 left // left 為插入位置\nEnd // 程式結束\n\nCheck format: each line has \"→\" or \"Start\"/\"End\" lines. Yes.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0, right = array.length - 1 // 設定搜尋區間  \n→ Decision: left <= right? // 判斷是否還有區間可搜尋  \n  Yes → Step 2: mid = left + (right - left) // 計算中點，避免溢位  \n  Yes → Decision: array[mid] == target? // 檢查是否找到目標  \n    Yes → Step 3: 輸出 mid // 找到目標，返回索引  \n    No → Decision: array[mid] < target? // 目標在右半邊  \n     Yes → Step 4: left = mid + 1 // 更新左邊界，繼續搜尋右側  \n     No → Step 5: right = mid - 1 // 更新右邊界，繼續搜尋左側  \n  No → Step 6: 輸出 left // left 為插入位置  \nEnd // 程式結束"
    },
    {
      "title": "Word Break II",
      "source_file": "Leetcode/leetcode140.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptyyy56si.py\", line 35, in main\n    vars_dict = eval(\"{\" + data + \"}\")\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']}\n     ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmptyyy56si.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmptyyy56si.py\", line 41, in main\n    word_list = eval(word_part)\n                ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    ['cat'\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvl4tigzb.py\", line 35, in main\n    vars_dict = eval(\"{\" + data + \"}\")\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']}\n     ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpvl4tigzb.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpvl4tigzb.py\", line 41, in main\n    word_list = eval(word_part)\n                ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    ['apple'\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaprbw7hq.py\", line 35, in main\n    vars_dict = eval(\"{\" + data + \"}\")\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    {s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']}\n     ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpaprbw7hq.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpaprbw7hq.py\", line 41, in main\n    word_list = eval(word_part)\n                ^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    ['cats'\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start: int) -> List[str]:\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入字串轉成 dict，例如 \"s = 'catsanddog', wordDict = ['cat','cats']\" -> {\"s\":\"catsanddog\",\"wordDict\":[\"cat\",\"cats\"]}\n    try:\n        vars_dict = eval(\"{\" + data + \"}\")\n    except Exception:\n        # 若 eval 失敗，嘗試更簡單的分割解析\n        parts = data.split(',')\n        s_part = parts[0].split('=')[1].strip().strip(\"'\\\"\")\n        word_part = parts[1].split('=')[1].strip()\n        word_list = eval(word_part)\n        vars_dict = {'s': s_part, 'wordDict': word_list}\n\n    s = vars_dict['s']\n    wordDict = vars_dict['wordDict']\n    solution = Solution()\n    result = solution.wordBreak(s, wordDict)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for word break II problem. Steps: start, preprocess dictionary to set, recursion with memo, backtrack building sentences, return list. Each line: virtual code step, comment. Use arrows. Let's produce a linear representation.\n\nWe need to produce code steps line by line, not actual code. Should include Decision, Start, End. Provide explanation after //.\n\nWe can write:\n\nStart\n→ Step 1: Convert wordDict to set // speed up lookup\n→ Step 2: Initialize memo map // cache substring to sentences\n→ Step 3: Define recursive function dfs(startIndex) // returns list of sentences from start\n    → Decision: If startIndex equals len(s)? // reached end\n        Yes → Step 4: Return list containing empty string // base case\n    → Decision: If memo contains startIndex? // reuse\n        Yes → Step 5: Return memo[startIndex]\n    → Step 6: Initialize list results // temporary storage\n    → Decision: For end in range(startIndex+1, len(s)+1)? // iterate end positions\n        → Decision: If substring s[startIndex:end] in dict? // word match\n            Yes → Step 7: Call dfs(end) // get sentences for remainder\n            → Decision: For each sub in dfs(end)? // iterate sub sentences\n                → Step 8: If sub is empty? // no remaining words\n                    Yes → Step 9: Append s[startIndex:end] to results // single word\n                    No  → Step 10: Append s[startIndex:end] + ' ' + sub to results // join with space\n    → Step 11: memo[startIndex] = results // cache\n    → Step 12: Return results\n→ Step 13: Call dfs(0) // start recursion from beginning\n→ Step 14: Return list of sentences // final output\nEnd\n\nMake sure to format each line with arrow. Use appropriate indentation for nested decisions. We need to keep format consistent. The lines inside for loops etc. Use arrow and indent? The sample uses indentation after decision lines. We'll mimic.\n\nLet's produce.\n\nAlso include explanation after //. Use simple Chinese.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 wordDict 轉成 set(dictSet) // 方便快速查找  \n→ Step 2: 建立 memo 映射表 // 用於記錄已計算過的子串結果  \n→ Step 3: 定義遞迴函式 dfs(start) // 回傳從 index 開始的所有合法句子  \n    → Decision: 如果 start == s.length? // 是否已走到字串結尾  \n        Yes → Step 4: 回傳 [''] // 基本情況：空字串代表結束  \n    → Decision: 如果 memo.containsKey(start)? // 先前已計算  \n        Yes → Step 5: 回傳 memo[start] // 直接取快取結果  \n    → Step 6: 建立空陣列 results // 暫存本層的所有句子  \n    → Decision: 針對 end 從 start+1 到 s.length? // 嘗試所有切分位置  \n        → Decision: 如果 s.substring(start, end) 在 dictSet? // 目前子字串是否為字典詞  \n            Yes → Step 7: 子句子列表 = dfs(end) // 取得剩餘字串的所有句子  \n            → Decision: 針對 sub 在 子句子列表? // 為每個後續句子建立完整句子  \n                → Step 8: 如果 sub.isEmpty()? // 無後續詞  \n                    Yes → Step 9: results.add( s.substring(start, end) ) // 直接加入單字  \n                    No  → Step 10: results.add( s.substring(start, end) + ' ' + sub ) // 加空格連接  \n    → Step 11: memo[start] = results // 存進快取  \n    → Step 12: 回傳 results // 回傳本層結果  \n→ Step 13: 最終答案 = dfs(0) // 從字串開始處進行分詞  \n→ Step 14: 回傳 最終答案 // 所有可能的合法句子  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx_kmhvso.py\", line 51, in <module>\n    answer = solver.calcEquation(equations, values, queries)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx_kmhvso.py\", line 9, in calcEquation\n    graph[a][b] = val\n    ~~~~~^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr2g91aq3.py\", line 51, in <module>\n    answer = solver.calcEquation(equations, values, queries)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr2g91aq3.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpev1xrphr.py\", line 51, in <module>\n    answer = solver.calcEquation(equations, values, queries)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpev1xrphr.py\", line 8, in calcEquation\n    for (a, b), val in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef parse_input(data: str):\n    # Find indices of the three keys\n    eq_idx = data.find('equations')\n    val_idx = data.find('values')\n    qu_idx = data.find('queries')\n    # Extract the string representations of the lists\n    eq_str = data[eq_idx + len('equations ='):val_idx].strip()\n    val_str = data[val_idx + len('values ='):qu_idx].strip()\n    qu_str = data[qu_idx + len('queries ='):].strip()\n    # Safely evaluate the lists\n    equations = ast.literal_eval(eq_str)\n    values = ast.literal_eval(val_str)\n    queries = ast.literal_eval(qu_str)\n    return equations, values, queries\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    equations, values, queries = parse_input(raw_input)\n    solver = Solution()\n    answer = solver.calcEquation(equations, values, queries)\n    # Format each result to 5 decimal places\n    formatted = '[' + ','.join(f\"{x:.5f}\" for x in answer) + ']'\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving division queries from equations. This is typical \"evaluate division\" problem. Approach: Build graph with variable nodes, edges weighted by ratio. For each query, perform DFS or BFS to find ratio from C to D. If path exists, multiply ratios. If either variable not in graph, return -1.0.\n\nNeed to output step by step pseudo code lines, each with explanation. Use arrow syntax and decisions.\n\nSo produce:\n\nStart\n\n→ Step 1: Build adjacency list graph from equations and values // create mapping variable to neighbors with weight\n\nFor each equation i:\n\n→ Step 2: For pair (A,B) with value v\n\n→   Add edge A→B weight v // A/B = v\n\n→   Add edge B→A weight 1/v // B/A = 1/v\n\nThen compute answers for queries.\n\n→ Step 3: Initialize result list\n\nFor each query (C,D):\n\n→ Step 4: If C or D not in graph\n\n→   Add -1.0 to result\n\n→   Continue to next query\n\n→ Step 5: Use DFS to find ratio from C to D\n\n→   Define function DFS(current, target, accumulated)\n\n→     If current == target return accumulated\n\n→     Mark current visited\n\n→     For each neighbor in graph[current]:\n\n→       If neighbor not visited:\n\n→         Result = DFS(neighbor, target, accumulated * weight)\n\n→         If result != -1.0 return result\n\n→     Return -1.0\n\n→ Step 6: Call DFS(C,D,1.0) and add to result list\n\nEnd\n\nReturn result\n\nNow format each line with comment. Use \"→\" arrow. Decision blocks for if conditions.\n\nNeed each line \"虛擬碼步驟\" + space + \"// 解釋\". Use line numbers? Not needed.\n\nEnsure each line includes virtual code step. Example: \"Start // 程式開始執行\".\n\nAlso use \"Decision:\" for if.\n\nLet's craft lines:\n\nStart // 程式開始執行\n\n→ Step 1: Initialize empty graph G // 建立圖表\n\n→ Step 1.1: For each equation i in equations: // 迭代方程\n\n    → Step 1.1.1: Let A = equations[i][0], B = equations[i][1], v = values[i] // 取得變數與比例\n\n    → Step 1.1.2: Add edge A → B with weight v to G // 建立 A/B = v\n\n    → Step 1.1.3: Add edge B → A with weight 1/v to G // 建立 B/A = 1/v\n\nDecision: For each query (C,D) in queries? // 進行查詢\n\n    Yes → Step 2: Initialize result list res // 儲存答案\n\n    → Step 2.1: For each query (C,D):\n\n        Decision: If C not in G or D not in G? // 變數是否存在\n\n            Yes → res.append(-1.0) // 無法確定，加入 -1.0\n\n            No → Step 3: Compute ratio using DFS // 尋找路徑\n\n                → Step 3.1: Define function DFS(node, target, acc):\n\n                    Decision: If node == target? // 到達目標\n\n                        Yes → return acc // 成功，返回累積比例\n\n                        No → Step 3.1.1: Mark node visited // 避免循環\n\n                        → Step 3.1.2: For each neighbor w of node in G[node]:\n\n                            Decision: If w not visited? // 仍未訪問\n\n                                Yes → temp = DFS(w, target, acc * G[node][w]) // 深入遞迴\n\n                                Decision: If temp != -1.0? // 找到路徑\n\n                                    Yes → return temp // 返回比例\n\n                    → Step 3.1.3: return -1.0 // 未找到路徑\n\n                → Step 3.2: ratio = DFS(C, D, 1.0) // 從 C 開始\n\n                → Step 3.3: res.append(ratio) // 加入答案\n\nEnd // 程式執行結束\n\nReturn res // 回傳所有查詢結果\n\nBut we need each line separate, no nested indentation maybe? We can embed indentation with spaces to indicate structure, but each line must be separate.\n\nLet's produce lines exactly. Use arrow for each step. Use Decision: for if.\n\nWill produce something like:\n\nStart // 程式開始執行\n→ Step 1: Initialize empty graph G // 建立圖表\n→ Step 1.1: For each equation in equations: // 迭代所有方程\n    → Step 1.1.1: Let A = equation[0], B = equation[1], v = corresponding value // 取得變數及比例\n    → Step 1.1.2: Add edge A → B with weight v to G // 建立 A/B = v\n    → Step 1.1.3: Add edge B → A with weight 1/v to G // 建立 B/A = 1/v\nDecision: For each query (C,D) in queries? // 進行查詢\n    Yes → Step 2: Initialize result list res // 儲存答案\n    → Step 2.1: For each query (C,D):\n        Decision: If C not in G or D not in G? // 變數是否存在\n            Yes → res.append(-1.0) // 無法確定，加入 -1.0\n            No → Step 3: Compute ratio via DFS // 尋找路徑\n                → Step 3.1: Define DFS(node, target, acc):\n                    Decision: If node == target? // 到達目標\n                        Yes → return acc // 返回累積比例\n                        No → Step 3.1.1: Mark node visited // 避免循環\n                        → Step 3.1.2: For each neighbor w of node:\n                            Decision: If w not visited? // 還未訪問\n                                Yes → temp = DFS(w, target, acc * G[node][w]) // 深入遞迴\n                                Decision: If temp != -1.0? // 找到路徑\n                                    Yes → return temp // 返回比例\n                    → Step 3.1.3: return -1.0 // 未找到路徑\n                → Step 3.2: ratio = DFS(C, D, 1.0) // 從 C 開始\n                → Step 3.3: res.append(ratio) // 加入答案\nEnd // 程式執行結束\nReturn res // 回傳所有查詢結果\n\nBut each line must be a separate line. We need to ensure no indentation maybe? We can keep indentation with spaces for readability but each line must be one line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize empty graph G // 建立圖表  \n→ Step 1.1: For each equation in equations: // 迭代所有方程  \n    → Step 1.1.1: Let A = equation[0], B = equation[1], v = corresponding value // 取得變數及比例  \n    → Step 1.1.2: Add edge A → B with weight v to G // 建立 A/B = v  \n    → Step 1.1.3: Add edge B → A with weight 1/v to G // 建立 B/A = 1/v  \nDecision: For each query (C,D) in queries? // 進行查詢  \n    Yes → Step 2: Initialize result list res // 儲存答案  \n    → Step 2.1: For each query (C,D):  \n        Decision: If C not in G or D not in G? // 變數是否存在  \n            Yes → res.append(-1.0) // 無法確定，加入 -1.0  \n            No → Step 3: Compute ratio via DFS // 尋找路徑  \n                → Step 3.1: Define DFS(node, target, acc):  \n                    Decision: If node == target? // 到達目標  \n                        Yes → return acc // 返回累積比例  \n                        No → Step 3.1.1: Mark node visited // 避免循環  \n                        → Step 3.1.2: For each neighbor w of node:  \n                            Decision: If w not visited? // 還未訪問  \n                                Yes → temp = DFS(w, target, acc * G[node][w]) // 深入遞迴  \n                                Decision: If temp != -1.0? // 找到路徑  \n                                    Yes → return temp // 返回比例  \n                    → Step 3.1.3: return -1.0 // 未找到路徑  \n                → Step 3.2: ratio = DFS(C, D, 1.0) // 從 C 開始  \n                → Step 3.3: res.append(ratio) // 加入答案  \nEnd // 程式執行結束  \nReturn res // 回傳所有查詢結果"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 以入度為 0 的課程初始化隊列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法做拓樸排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都被排完，返回順序，否則返回空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input(content: str):\n    \"\"\"從輸入字串中解析出 numCourses 與 prerequisites。\"\"\"\n    # 解析 numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', content)\n    numCourses = int(num_match.group(1)) if num_match else 0\n\n    # 解析 prerequisites，使用 ast.literal_eval 以安全方式轉為列表\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', content)\n    if pre_match:\n        prereqs_str = pre_match.group(1)\n        prerequisites = ast.literal_eval(prereqs_str)\n    else:\n        prerequisites = []\n\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        sys.exit(0)\n\n    numCourses, prerequisites = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for topological sorting algorithm for course schedule problem. Provide lines with arrows and decisions. Should not produce actual code, just virtual steps. Let's craft a step-by-step algorithm:\n\nStart\n→ Build adjacency list for courses from prerequisites\n→ Compute indegree array\n→ Initialize queue with zero indegree courses\n→ Initialize result list\n→ While queue not empty\n    → Dequeue course\n    → Append to result\n    → For each neighbor in adjacency[course]\n        → Decrease indegree[neighbor]\n        → If indegree[neighbor] == 0 → enqueue neighbor\n→ Decision: result length == numCourses?\n    Yes → Return result\n    No  → Return empty array\nEnd\n\nAlso we might need to handle cycle detection.\n\nWe must use arrow syntax as requested: \"→\" preceding each step. Decision blocks with indentation. Provide explanation after //.\n\nWe must include start, end.\n\nAlso we need to include decisions: e.g., \"If indegree == 0?\" etc.\n\nLet's produce the virtual code accordingly.\n\nMake sure each line is one step. We can have nested decisions.\n\nWe need to ensure the explanation is brief, intuitive.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立圖形 adj[0…numCourses-1] 為空列表 // 為每門課建立相鄰課表  \n→ Step 2: 建立 indegree[0…numCourses-1] 為 0 // 計算各課前置課的數量  \n→ Step 3: 對於每個 pair [a,b] in prerequisites  \n  → adj[b].append(a) // 以 b 為起點指向 a  \n  → indegree[a] += 1 // a 的前置課數增加  \n→ Step 4: 初始化 queue 為空隊列 // 用於儲存 indegree 為 0 的課程  \n→ Step 5: 對於每門課 i  \n  → Decision: 如果 indegree[i] == 0?  \n   Yes → queue.enqueue(i) // 沒有前置課，先加入隊列  \n   No  →  // 仍保留 indegree[i] 供後續使用  \n→ Step 6: 初始化 result 為空列表 // 存儲最終修課順序  \n→ Step 7: Decision: 如果 queue 為空?  \n  Yes → Decision: 如果 result.length == numCourses?  \n   Yes → Return result // 所有課程都已排完  \n   No  → Return [] // 存在循環，無法完成所有課程  \n  No →  // queue 非空，繼續處理  \n   → Loop: While queue 非空  \n    → Step 8: course = queue.dequeue() // 取出一門課  \n    → Step 9: result.append(course) // 加入結果  \n    → Step 10: 對於每個 neighbor in adj[course]  \n      → indegree[neighbor] -= 1 // 失去一個前置課  \n      → Decision: 如果 indegree[neighbor] == 0?  \n       Yes → queue.enqueue(neighbor) // 前置課全滿，加入隊列  \n       No  →  // 還有未完成的前置課  \n    → End Loop  \n→ Decision: result.length == numCourses?  \n  Yes → Return result // 成功得到一個可行順序  \n  No  → Return [] // 循環偵測失敗  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[[\"hit\", \"hot\", \"dot\", \"dog\", \"cog\"]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        parents = defaultdict(list)\n        layer = {beginWord: 0}\n        queue = deque([beginWord])\n        found = False\n\n        while queue and not found:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n                        if new_word == endWord:\n                            found = True\n\n        if endWord not in parents:\n            return []\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return res\n\ndef parse_input(text: str):\n    # Extract beginWord\n    bw_match = re.search(r'beginWord\\s*=\\s*\"([^\"]*)\"', text)\n    beginWord = bw_match.group(1) if bw_match else \"\"\n\n    # Extract endWord\n    ew_match = re.search(r'endWord\\s*=\\s*\"([^\"]*)\"', text)\n    endWord = ew_match.group(1) if ew_match else \"\"\n\n    # Extract wordList\n    wl_match = re.search(r'wordList\\s*=\\s*\\[([^\\]]*)\\]', text)\n    wordList = []\n    if wl_match:\n        inside = wl_match.group(1)\n        wordList = re.findall(r'\"([^\"]*)\"', inside)\n    return beginWord, endWord, wordList\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    beginWord, endWord, wordList = parse_input(raw)\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nThe user wants virtual code for the problem: Word Ladder II. They want pseudo-code with explanations. Need to follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to produce step-by-step virtual code: start, BFS to find distances, then DFS/backtracking to build sequences. Use dictionary set, adjacency building, etc. We'll produce lines accordingly.\n\nMake sure to use arrows → and Decision: etc. Let's produce a fairly detailed pseudo-code.\n\nWe can start:\n\nStart\n→ 初始化 wordSet ← set(wordList)\n→ 若 endWord not in wordSet: Return []\n\n→ 初始化距離 dict: distance[word] = INF; distance[beginWord] = 0\n→ 初始化 queue ← [beginWord]\n→ Decision: queue not empty? Yes → BFS to compute shortest distance to each word\n...\nThen after BFS, if endWord not reachable: Return []\n\n→ 初始化 result list\n→ DFS(current=beginWord, path=[beginWord])\n    if current == endWord: add path copy to result\n    else: for each neighbor nextWord in generateNeighbors(current) where distance[nextWord] == distance[current]+1:\n           path.append(nextWord)\n           DFS(nextWord, path)\n           path.pop()\n\nReturn result.\n\nNeed to include neighbor generation: For each character position, replace with 'a'-'z', check in wordSet.\n\nAlso need to use decision for BFS step.\n\nLet's produce the pseudocode with arrows.\n\nWe'll maintain that each line has comment //.\n\nWe need to keep indentation? We can show arrow and indentation by spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ 將 wordList 轉成 hash set wordSet // 提供 O(1) 查詢\n→ 若 endWord 不在 wordSet: 返回空列表 // 無法到達\n→ 建立距離映射 distance，初始為無限 // 记录最短层级\n→ distance[beginWord] = 0\n→ 初始化 BFS 隊列 queue ← [beginWord]\n→ Decision: queue 非空? Yes → BFS 搜尋最短距離\n    → 取出 queue 佇列首元素 current\n    → Decision: 是否已到達 endWord? No → 生成所有鄰居 next\n        → For 每個字母變更後的 word newWord\n            → Decision: newWord 在 wordSet? Yes\n                → Decision: distance[newWord] 未設定? Yes\n                    → distance[newWord] = distance[current] + 1\n                    → queue 進入 newWord\n                → Decision: distance[newWord] > distance[current] + 1? Yes\n                    → distance[newWord] = distance[current] + 1\n    → 將 current 從 queue 移除\n    → 回到 Decision: queue 非空? // 迴圈結束\n→ Decision: endWord 是否有 distance? No → 返回空列表 // 無路徑\n→ 初始化結果列表 result ← []\n→ 定義 DFS(current, path)\n    → Decision: current == endWord? Yes\n        → result 加入 path 複製 // 收集完整路徑\n        → 返回\n    → 否則\n        → For 每個鄰居 next 在 generateNeighbors(current)\n            → Decision: distance[next] == distance[current] + 1? Yes\n                → path 加入 next\n                → DFS(next, path)\n                → path 移除 last\n→ DFS(beginWord, [beginWord]) // 開始遞迴\n→ 返回 result // 所有最短路徑\n\nBut must use arrow and Decision lines correctly. Use Yes → and No → lines. Provide each step.\n\nLet's produce final output with the correct format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Use Decision block with indentation.\n\nWe'll keep each line as separate line, no extra lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ wordSet ← Set(wordList) // 將字典轉成 hash 集合，O(1) 查詢  \n→ Decision: endWord 不在 wordSet? Yes → Return [] // 若目標字未在字典，無路徑  \n→ distance ← Map() // 記錄每個字到 beginWord 的最短層級  \n→ distance[beginWord] ← 0 // 起點層級為 0  \n→ queue ← [beginWord] // BFS 隊列  \n→ Decision: queue 非空? Yes → BFS 取得距離  \n  → current ← queue.popFront() // 取出隊首字  \n  → Decision: current == endWord? No → 生成鄰居  \n    → For pos 0..len(current)-1  \n     → For c in 'a'..'z'  \n      → newWord ← current[:pos] + c + current[pos+1:] // 位置 pos 的字改成 c  \n      → Decision: newWord 在 wordSet? Yes  \n       → Decision: newWord 未在 distance? Yes  \n         → distance[newWord] ← distance[current] + 1  \n         → queue.append(newWord) // 新字加入 BFS  \n       → Decision: distance[newWord] > distance[current] + 1? Yes  \n          → distance[newWord] ← distance[current] + 1 // 找到更短路徑時更新  \n           → queue.append(newWord) // 更新層級後仍需探索  \n  → queue.removeFront() // 完成 current 的處理  \n  → 回到 Decision: queue 非空? // 迴圈繼續  \n→ Decision: endWord 不在 distance? Yes → Return [] // 無法到達 endWord  \n→ result ← [] // 儲存所有最短路徑  \n→ DFS(current, path) // 定義遞迴搜尋  \n  → Decision: current == endWord? Yes  \n    → result.append(path.copy()) // 收集完整路徑  \n    → Return  \n  → 否則  \n    → For next in generateNeighbors(current) // 產生所有鄰居  \n     → Decision: distance[next] == distance[current] + 1? Yes  \n      → path.append(next) // 加入路徑  \n      → DFS(next, path) // 深度優先搜尋  \n      → path.pop() // 回溯  \n→ DFS(beginWord, [beginWord]) // 開始遞迴搜尋  \n→ Return result // 所有最短變換序列\n\n（備註：generateNeighbors 以字典 wordSet 為基準，對每個位置替換 26 個字母，若生成的新字在 wordSet 中即為鄰居。）"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.66679,-0.09389],[0.53211,0.52964],[-0.4019,-0.87431]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.66679, -0.09389], [0.53211, 0.52964], [-0.4019, -0.87431]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻分布的半徑與角度\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        # 將結果四捨五入到小數點後 5 位，符合題目輸出格式\n        return [round(x, 5), round(y, 5)]\n\ndef main():\n    # 從 stdin 讀取兩行輸入\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    # 解析指令列和對應的參數\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    output = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構物件，對應返回 null\n            obj = Solution(*args)\n            output.append(None)\n        elif cmd == \"randPoint\":\n            # 產生隨機點\n            point = obj.randPoint()\n            output.append(point)\n        else:\n            # 其它指令直接忽略或拋錯\n            output.append(None)\n\n    # 輸出結果，None 會被轉成 JSON 的 null\n    print(json.dumps(output, ensure_ascii=False))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. Must use Start, End, Decision, etc. Steps: initialize radius, center; randPoint should generate random polar coordinates uniformly. Approach: generate random radius sqrt(r)*R? Actually uniform distribution: choose radius sqrt(u)*R where u uniform [0,1], angle uniform [0, 2π). Then convert to x,y. Provide steps accordingly. Need to implement in virtual code. We'll produce pseudo-steps: Start, initialize variables; then function randPoint: generate random u, sqrt, angle, compute x, y, return [x, y]. Provide explanation for each line. Use arrow. Ok. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 radius, x_center, y_center // 以輸入值儲存圓半徑及中心座標  \n→ Decision: 若 radius > 0? // 確保圓半徑合法  \n    Yes → Step 2: 允許物件建立 // 進行初始化  \n    No  → Step 3: 抛出錯誤 // 半徑無效時停止  \n\nEnd // 程式結束  \n\n---  \n\nStart // 呼叫 randPoint 時執行  \n→ Step 4: 產生隨機數 u ∈ [0, 1] // 用於決定半徑分布  \n→ Step 5: 計算 r = radius * sqrt(u) // 取得符合均勻分布的半徑  \n→ Step 6: 產生隨機角度 theta ∈ [0, 2π) // 角度均勻  \n→ Step 7: 計算 x = x_center + r * cos(theta) // 轉換到座標系  \n→ Step 8: 計算 y = y_center + r * sin(theta) // 轉換到座標系  \n→ Step 9: 回傳 [x, y] // 返回隨機點座標  \nEnd // randPoint 執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef remove_element(nums, val):\n    \"\"\"\n    移除 nums 中所有等於 val 的元素，並返回新的長度。\n    使用雙指針法：快指針 fast 遍歷整個陣列，慢指針 slow\n    指向下一個應該寫入的位置。\n    \"\"\"\n    slow = 0\n    for fast in range(len(nums)):\n        if nums[fast] != val:\n            nums[slow] = nums[fast]\n            slow += 1\n    return slow\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取完整輸入\n    data = sys.stdin.read().strip()\n\n    # 使用正則表達式提取 nums 列表和 val 整數\n    nums_pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])'\n    val_pattern = r'val\\s*=\\s*(-?\\d+)'\n\n    nums_match = re.search(nums_pattern, data)\n    val_match = re.search(val_pattern, data)\n\n    nums = ast.literal_eval(nums_match.group(1)) if nums_match else []\n    val = int(val_match.group(1)) if val_match else 0\n\n    # 執行移除操作\n    k = remove_element(nums, val)\n\n    # 產生輸出字串，未使用的位元以 '_' 顯示\n    output_parts = []\n    for i in range(len(nums)):\n        if i < k:\n            output_parts.append(str(nums[i]))\n        else:\n            output_parts.append('_')\n    output_str = f\"{k}, nums = [{','.join(output_parts)}]\"\n\n    print(output_str)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanations. The task: remove all occurrences of val in-place and return new length k. Classic algorithm: two pointers. We'll produce steps: Start, initialize write pointer i = 0, iterate read pointer j over array, if nums[j] != val, assign nums[i] = nums[j]; i++; end. Return i. Provide explanations.\n\nNeed to use arrow notation: Start, →, Decision, Yes →, No →, End.\n\nMake sure each line is a step, with explanation. Provide in Chinese Traditional.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化寫入指標 i 為 0 // 準備將非 val 的元素寫回陣列\n→ Step 2: 從 0 到 nums.length-1 迭代讀取指標 j // 遍歷整個陣列\n    → Decision: nums[j] 是否等於 val? // 判斷當前元素是否為要移除的值\n        Yes → Step 3: 跳過此元素 // 若為 val，直接不執行寫入\n        No  → Step 4: nums[i] = nums[j] // 將非 val 元素寫到寫入指標位置\n                → Step 5: i++ // 移動寫入指標至下一位置\nEnd // 所有元素已處理完成\n→ Step 6: 回傳 i // i 為新的有效長度 k\n\nMake sure each line includes arrow and explanation. Use '→' for sequential steps, and 'Decision:' for decisions. Provide lines accordingly. Use Chinese. Provide step numbers as in example: Step 1, Step 2, etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化寫入指標 i 為 0 // 準備將非 val 的元素寫回陣列  \n→ Step 2: 從 0 到 nums.length-1 迭代讀取指標 j // 遍歷整個陣列  \n  → Decision: nums[j] 是否等於 val? // 判斷當前元素是否為要移除的值  \n   Yes → Step 3: 跳過此元素 // 若為 val，直接不執行寫入  \n   No  → Step 4: nums[i] = nums[j] // 將非 val 元素寫到寫入指標位置  \n    → Step 5: i++ // 移動寫入指標至下一位置  \nEnd // 所有元素已處理完成  \n→ Step 6: 回傳 i // i 為新的有效長度 k"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\ndef subsets(nums):\n    res = []\n    def backtrack(start, path):\n        # 把目前子集的拷貝加入結果\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])          # 暫時加入元素\n            backtrack(i + 1, path)        # 深入下一層\n            path.pop()                    # 回溯\n    backtrack(0, [])\n    return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入字串中擷取 list 表示\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1:\n        nums = []\n    else:\n        list_str = data[left:right+1]\n        nums = ast.literal_eval(list_str)\n    result = subsets(nums)\n    # 用 json.dumps 產生無空格的輸出格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of unique elements array. Must produce line by line with // explanation. Use Start, End, Decision, etc.\n\nThe algorithm: typical backtracking. Steps: initialize result, call backtrack(index, path). For each element, add to path, rec backtrack(i+1, path), then backtrack without element.\n\nBut need to write in virtual steps.\n\nWe need to produce a structured flow: Start → initialize result → call function → recursion.\n\nBut as virtual code line by line, each line includes virtual step plus explanation.\n\nWe can structure as:\n\nStart\n→ Step 1: Initialize empty result list // create container for subsets\n→ Step 2: Define recursive function backtrack(startIndex, currentSubset) // helper\n    → Decision: 是否已遍歷完整? // check if startIndex == length\n        Yes → Step 3: Add copy of currentSubset to result // store subset\n        No → Step 4: 添加 currentSubset 到 result // store\n        → Step 5: For each element i from startIndex to end // iterate\n            → Step 6: Append nums[i] to currentSubset // include element\n            → Step 7: Call backtrack(i+1, currentSubset) // recursion\n            → Step 8: Remove last element from currentSubset // backtrack\n→ Step 9: Call backtrack(0, empty list) // start recursion\n→ Step 10: Return result // output\n\nBut we need to use virtual arrows: Start, →, Decision:, Yes →, No → etc.\n\nWe need to produce each step line.\n\nWe need to incorporate the recursion logic in lines.\n\nMaybe we use nested decision blocks.\n\nLet's craft step-by-step:\n\n1. Start // 程式開始執行\n2. → Step 1: 初始化 result 為空清單 // 建立子集存放容器\n3. → Step 2: 定義遞迴函式 backtrack(startIdx, path) // 助手函式\n    4. → Decision: startIdx 是否等於 nums 長度? // 判斷是否已處理完所有元素\n        5. Yes → Step 3: 將 path 的拷貝加入 result // 存入子集\n        6. No  → Step 4: 將 path 的拷貝加入 result // 每一次呼叫都存一次\n        7. → Step 5: 從 startIdx 到 nums.length-1 迭代 i // 遍歷剩餘元素\n            8. → Step 6: 把 nums[i] 加入 path // 暫時加入\n            9. → Step 7: 呼叫 backtrack(i+1, path) // 深入下一層\n            10. → Step 8: 從 path 移除最後一個元素 // 回溯\n7. → Step 9: 呼叫 backtrack(0, 空清單) // 從第一個元素開始\n8. → Step 10: 回傳 result // 回傳所有子集\n9. End // 程式結束\n\nBut we must ensure each line uses correct syntax: \"→ Step 1:\" etc. Also the Decision block uses indentation? The example shows indentation with tab? They show:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n\nSo we can replicate same style.\n\nThus lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空清單 // 建立子集存放容器\n→ Step 2: 定義遞迴函式 backtrack(startIdx, path) // 助手函式\n    → Decision: startIdx 是否等於 nums.length? // 判斷是否已處理完所有元素\n        Yes → Step 3: 將 path 的拷貝加入 result // 存入子集\n        No  → Step 4: 將 path 的拷貝加入 result // 存入子集\n        → Step 5: 從 startIdx 到 nums.length-1 迭代 i // 遍歷剩餘元素\n            → Step 6: 把 nums[i] 加入 path // 暫時加入\n            → Step 7: 呼叫 backtrack(i+1, path) // 深入下一層\n            → Step 8: 從 path 移除最後一個元素 // 回溯\n→ Step 9: 呼叫 backtrack(0, 空清單) // 從第一個元素開始\n→ Step 10: 回傳 result // 回傳所有子集\nEnd // 程式結束\n\nBut we need to keep \"→\" before each step. And decision indentation.\n\nAlso step 3 and step 4 might be same? We can have Step 3 for storing each call, Step 4 for final condition? But it's fine.\n\nBut we need to make sure to not duplicate steps.\n\nBetter: In recursion, at each call we always add a copy of current path to result (for each subset). Then iterate over elements to include.\n\nThus we can combine: Step 3 for adding path; Step 5 for loop; Step 6-8 for recursion.\n\nThus we don't need separate Yes/No for startIdx condition: We don't need to differentiate. Actually we always add path regardless; no need for decision. But we may decide to include decision for clarity: When startIdx equals length, we stop recursion. But we can still add path and then stop.\n\nSimplify: Decision: startIdx == nums.length? // base case\n    Yes → Step 3: 將 path 的拷貝加入 result // 存入子集\n    No  → Step 4: 將 path 的拷貝加入 result // 存入子集\n         → Step 5: 從 startIdx 到 nums.length-1 迭代 i\n             → Step 6: 把 nums[i] 加入 path\n             → Step 7: 呼叫 backtrack(i+1, path)\n             → Step 8: 從 path 移除最後一個元素\n\nThis duplicates adding path twice? Actually we add path in both Yes and No? But we only want to add once per call. So we can structure: Step 3: 將 path 的拷貝加入 result // always add subset\nDecision: startIdx == nums.length? // check if reached end\n    Yes → Step 4: Return // stop recursion\n    No  → Step 5: 從 startIdx 到 nums.length-1 迭代 i\n        → Step 6: 把 nums[i] 加入 path\n        → Step 7: 呼叫 backtrack(i+1, path)\n        → Step 8: 從 path 移除最後一個元素\n\nYes that's better.\n\nThus produce steps accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空清單 // 建立子集存放容器  \n→ Step 2: 定義遞迴函式 backtrack(startIdx, path) // 助手函式  \n  → Step 3: 將 path 的拷貝加入 result // 每次呼叫都存一次子集  \n  → Decision: startIdx 是否等於 nums.length? // 判斷是否已處理完所有元素  \n   Yes → Step 4: Return // 若已到結尾，結束遞迴  \n   No  → Step 5: 從 startIdx 到 nums.length-1 迭代 i // 遍歷剩餘元素  \n    → Step 6: 把 nums[i] 加入 path // 暫時加入當前元素  \n    → Step 7: 呼叫 backtrack(i+1, path) // 深入下一層遞迴  \n    → Step 8: 從 path 移除最後一個元素 // 回溯至上一層  \n→ Step 9: 呼叫 backtrack(0, 空清單) // 從第一個元素開始遞迴  \n→ Step 10: 回傳 result // 回傳所有子集  \nEnd // 程式結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n\n            if not res:  # no operator found, expr is a number\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin，並從中抽取引號內的表達式\n    data = sys.stdin.read()\n    match = re.search(r'\"([^\"]*)\"', data)\n    if not match:\n        # 若找不到引號，嘗試直接使用整行作為表達式\n        expression = data.strip()\n    else:\n        expression = match.group(1)\n\n    sol = Solution()\n    result = sol.diffWaysToCompute(expression)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to compute all possible results by adding parentheses to a binary expression. Classic Leetcode \"Different Ways to Add Parentheses\". Use recursion + memoization. Input string expression containing digits and operators +,-,*. Output list of results. Steps: parse string, define function compute(start,end). If memo contains return. Else iterate over positions to split on operator, recursively compute left and right, combine results. If no operator found -> return numeric value. End.\n\nWe need to output each line with virtual code step and comment. Use Start, End, Decision. Provide all steps line by line. Use arrow '→'. Provide decision for if operator found? But simpler: Use recursion with memoization. Provide steps: Start, parse expression to list tokens maybe. Then compute function. Use memoization dict. Recursion base case: if start==end -> return [number]. else loop through tokens positions: if token is operator, compute left/right and combine. If no operator => number. At end return memo[start][end].\n\nAlso need to mention function call. Steps for main function: parse expression, call compute(0, len(tokens)-1), return results. Then End.\n\nNeed to include details for memoization dictionary. Provide step for initialize memo. Provide decision: if memo has key -> return memo. Provide step for iteration over tokens.\n\nMake sure to use virtual code syntax: Start, → Step n: .... ; Decision: if condition? ; Yes→ ... No→ ...; End.\n\nLet's write steps:\n\nStart // 程式開始執行\n→ Step 1: Tokenize expression into list of numbers and operators // 先把字串拆成數字與運算子\n→ Step 2: Initialize memoization map memo = {} // 用來記錄子表達式的結果\n→ Step 3: Define function compute(l, r) // 計算子表達式從 l 到 r 的所有結果\n    → Decision: 是否已在 memo 中? // 檢查是否已計算過\n        Yes → Return memo[(l,r)] // 直接回傳緩存結果\n        No  →\n            → Step 4: If l == r, token 是數字 // 子表達式只有一個項目\n                → Step 5: memo[(l,r)] = [int(tokens[l])] // 儲存並回傳\n                → Step 6: Return memo[(l,r)]\n            → Decision: 有可分割的運算子? // 從 l 到 r 找尋運算子\n                Yes →\n                    → Step 7: For each index i from l+1 to r-1, step 2 // 只檢查運算子位置\n                        → Decision: tokens[i] 是運算子? // 判斷是否為 '+', '-', '*'\n                            Yes →\n                                → Step 8: left = compute(l, i-1) // 左邊子表達式\n                                → Step 9: right = compute(i+1, r) // 右邊子表達式\n                                → Step 10: For each a in left:\n                                    → Step 11: For each b in right:\n                                        → Decision: tokens[i] 是 '+'? // 根據運算子計算\n                                            Yes → result = a + b\n                                            No →\n                                                Decision: tokens[i] 是 '-'? // \n                                                    Yes → result = a - b\n                                                    No → result = a * b\n                                        → Step 12: Append result to memo[(l,r)] // 收集結果\n                            No → Continue loop // 不是運算子跳過\n                    → Step 13: Return memo[(l,r)] // 所有拆分完畢後回傳\n                No → // 這種情況在 l==r 已處理，其他不會發生\n                    → Step 14: memo[(l,r)] = [] // 但保持一致\n                    → Step 15: Return memo[(l,r)]\n→ Step 16: Call compute(0, len(tokens)-1) // 求整個表達式的所有結果\n→ Step 17: Return result list // 回傳最終結果\nEnd // 程式執行結束\n\nNeed to keep each line with arrow and comment. But inside functions we might indent? But not necessary; we can use arrow to denote nested lines. Use the structure:\n\nStart // ...\n→ Step 1: ...\n→ Step 2: ...\n→ Step 3: Define function compute(l, r) // ...\n    → Decision: ...\n        Yes → ...\n        No → ...\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Tokenize the input expression into a list of numbers and operators // 先把字串拆成數字與運算子  \n→ Step 2: Initialize memoization map `memo = {}` // 用來記錄子表達式的結果  \n→ Step 3: Define function `compute(l, r)` // 計算子表達式從 l 到 r 的所有結果  \n  → Decision: `(l, r)` 已存在於 `memo`? // 檢查是否已計算過  \n   Yes → Return `memo[(l, r)]` // 直接回傳緩存結果  \n   No →  \n    → Step 4: If `l == r` (子表達式只有一個項目)  \n     → Step 5: `memo[(l, r)] = [int(tokens[l])]` // 儲存並回傳單一數字  \n     → Step 6: Return `memo[(l, r)]`  \n    → Decision: 在 `l` 到 `r` 之間有可分割的運算子?  \n     Yes →  \n      → Step 7: For each index `i` from `l+1` to `r-1` stepping by 2 (運算子位置)  \n       → Decision: `tokens[i]` 是運算子? (`+`, `-`, `*`)  \n        Yes →  \n         → Step 8: `left = compute(l, i-1)` // 計算左邊子表達式  \n         → Step 9: `right = compute(i+1, r)` // 計算右邊子表達式  \n         → Step 10: For each `a` in `left`:  \n          → Step 11: For each `b` in `right`:  \n            → Decision: `tokens[i]` 為 `+`?  \n             Yes → `result = a + b`  \n             No →  \n              → Decision: `tokens[i]` 為 `-`?  \n               Yes → `result = a - b`  \n               No → `result = a * b`  \n             → Step 12: Append `result` to `memo[(l, r)]` // 收集結果  \n            → Step 13: End inner loops  \n            → Step 14: End for-loop over `i`  \n            → Step 15: Return `memo[(l, r)]` // 所有拆分完畢後回傳  \n            → Step 16: End Decision block for operator  \n            → Step 17: End Decision block for splitable?  \n            → Step 18: End function `compute`  \n→ Step 19: Call `compute(0, len(tokens)-1)` to obtain all results for the whole expression // 求整個表達式的所有結果  \n→ Step 20: Return the resulting list // 回傳最終結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,0,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 0, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和列表，用於快速定位索引\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 1 ~ total 之間的隨機整數，使用 bisect 找到對應索引\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    # 讀取整個輸入字串\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 將輸入轉換成 (methods, args) 形式\n    # 由於輸入已經是兩個列表，用逗號分隔，將整個字串包在括號後再解析\n    data = ast.literal_eval('(' + raw_input + ')')\n    methods, args = data\n\n    results = []\n    instance = None\n\n    for method, arg in zip(methods, args):\n        if method == 'Solution':\n            # 建構子，arg 是權重列表\n            instance = Solution(arg[0] if isinstance(arg, list) else arg)\n            results.append(None)\n        else:\n            # 其他方法直接呼叫\n            res = getattr(instance, method)(*arg)\n            results.append(res)\n\n    # 將結果輸出成 JSON 格式，None 會轉成 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing pickIndex using weighted random selection. Steps: preprocess to build cumulative sums. Then pickIndex uses random number between 0 and sum, binary search to find index. Provide virtual code lines with explanation.\n\nStructure: Start, building prefix sum in constructor. Then pickIndex step. Need use Decision and arrows. Provide line numbers? Not necessary. Just lines sequentially. Use \"Start\", \"End\".\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空列表 prefixSum // 用於儲存前綴和，幫助快速定位索引\n→ Step 2: 設置 totalWeight = 0 // 計算總權重\n→ Step 3: For i from 0 to w.length - 1: // 遍歷所有權重\n    → Step 4: totalWeight += w[i] // 累加權重\n    → Step 5: prefixSum.append(totalWeight) // 將累加值存入前綴和列表\n→ Step 6: store totalWeight // 方便 pickIndex 直接使用\nEnd // 建構完成，準備使用 pickIndex\n\nStart // pickIndex 進入\n→ Step 1: rand = random() * totalWeight // 產生 [0, totalWeight) 的隨機數\n→ Decision: 在 prefixSum 中尋找第一個大於等於 rand 的索引 // 二分搜尋確保 O(log n)\n    Yes → Step 2: return found_index // 回傳對應的索引\n    No → Step 3: 這種情況不應發生，返回 0 // 防止邊界錯誤\nEnd // pickIndex 執行結束"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpx8di7d8k.py\", line 36, in <module>\n    mat, k = parse_input(data)\n             ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpx8di7d8k.py\", line 29, in parse_input\n    mat = eval(mat_str)  # 將字串轉為列表\n          ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1eqrar6g.py\", line 36, in <module>\n    mat, k = parse_input(data)\n             ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1eqrar6g.py\", line 29, in parse_input\n    mat = eval(mat_str)  # 將字串轉為列表\n          ^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,0,0,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # 二分搜尋求每一行 1 的個數\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()                      # 先按士兵數，後按行號\n        return [i for _, i in soldiers[:k]]  # 取前 k 個行號\n\ndef parse_input(text: str):\n    \"\"\"從輸入字串中抽取 mat 與 k。\"\"\"\n    mat_match = re.search(r'mat\\s*=\\s*(\\[.*?\\])', text, re.S)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', text)\n    if not mat_match or not k_match:\n        raise ValueError(\"輸入格式錯誤\")\n    mat_str = mat_match.group(1)\n    k = int(k_match.group(1))\n    mat = eval(mat_str)  # 將字串轉為列表\n    return mat, k\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    mat, k = parse_input(data)\n    sol = Solution()\n    result = sol.kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with step-by-step. The user wants solution for k weakest rows problem. Provide pseudocode lines with explanation. Let's produce algorithm: For each row, count soldiers using binary search or simple loop since rows sorted. Use pair of (count, index). Sort by count then index. Take first k indices.\n\nAlso can use priority queue. But simpler: iterate, count, push to list, sort. Complexity O(mn log m). Provide steps.\n\nWe need to output line-by-line with \"Start\", \"End\". Use arrow \"→\". Provide comments in Chinese.\n\nLet's craft.\n\nWe'll have Start. Step 1: Initialize empty list rowsInfo. Step 2: For each row i from 0 to m-1: count soldiers. Use binary search: find first 0 or length. Add tuple. Step 3: Sort rowsInfo by count ascending, then index ascending. Step 4: Extract first k indices into result. Step 5: Return result.\n\nWe need to indicate decisions? Not many decisions except maybe binary search. We can include Decision for binary search loop? But better just include a step to count using binary search. We can break down: Decision: while low < high? But it's okay.\n\nLet's produce.\n\nWe'll use \"Decision:\" lines for binary search.\n\nImplement binary search: low=0, high=n. while low<high: mid=(low+high)//2; if mat[i][mid]==1: low=mid+1 else high=mid. After loop, count=low. Add.\n\nSo we will produce lines accordingly.\n\nMake sure each line has \"虛擬碼步驟\" then space then comment.\n\nLet's write.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Initialize rowsInfo ← empty list // 用於存儲每一行的(士兵數量, 行號)  \n→ Step 2: For i ← 0 to m-1 // 遍歷每一行  \n    → Step 2.1: low ← 0, high ← n // 二分搜尋的左右指標  \n    → Decision: 是否還有可比較的區間? (low < high)  \n        Yes → Step 2.1.1: mid ← (low + high) // 2 // 取中點  \n            → Decision: mat[i][mid] 是否為 1?  \n                Yes → Step 2.1.1.1: low ← mid + 1 // 仍在士兵區域，向右移動  \n                No  → Step 2.1.1.2: high ← mid // 進入平民區域，向左縮小範圍  \n        No  → Step 2.1.2: count ← low // binary search 結束，low 即為 1 的數量  \n    → Step 2.2: Append (count, i) to rowsInfo // 存儲此行資訊  \n→ Step 3: Sort rowsInfo by count ascending, then index ascending // 先按士兵數，後按行號  \n→ Step 4: result ← empty list // 儲存最弱的 k 行號  \n→ Step 5: For j ← 0 to k-1  \n    → Step 5.1: Append rowsInfo[j].index to result // 取前 k 個行號  \n→ Step 6: Return result // 輸出最弱 k 行的索引  \nEnd // 程式執行結束"
    }
  ]
}