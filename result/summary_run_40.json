{
  "run_index": 40,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 300,
  "generation_or_validation_failure_count": 34,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "def main():\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants a virtual code for a program that opens data.txt, reads content, outputs number of lines, or displays \"找不到檔案！\" if file not found, using with syntax and try/except. They want virtual code, no real code, step by step, with explanation. Use arrows, decision, etc. Format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Let's produce:\n\nStart\n→ Step 1: 開啟文件data.txt // start with file opening attempt\n→ Decision: try to open file? // try-except\n    Yes → Step 2: 讀取所有行 // read lines\n    → Step 3: 計算行數 // count lines\n    → Step 4: 輸出 '總行數: X' // output number\n    No  → Step 5: 輸出 '找不到檔案！' // if error\nEnd\n\nBut must incorporate with syntax: \"→ Step 1: 使用 with 打開 data.txt\" maybe. And try/except: \"→ Decision: try\" ... Actually we need to represent try/except as Decision? Use \"Decision: 讀取檔案成功?\" with Yes/No. Ok.\n\nLet's produce each line with explanation. Use \"Start // 程式開始執行\". Then \"→ Step 1: 嘗試使用 with 語法開啟 data.txt // 以安全方式打開檔案\" Then decision: \"→ Decision: 檔案成功開啟?\" etc. Actually the try/except block: try: with open... except FileNotFoundError: show message. So we can model that.\n\nSimplify: Step 1: 試圖打開檔案 // with open. Decision: 是否捕捉到例外? No means success. So \"Yes → Step 2: 讀取行數\" etc. If Yes → Step 3: 輸出找不到檔案.\n\nLet's produce.\n\nRemember to end. Ensure each line has virtual code + space + comment. Let's do.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 嘗試使用 with 語法開啟 'data.txt' // 以安全方式打開檔案  \n→ Decision: 是否捕捉到 FileNotFoundError? // 檢查檔案是否存在  \n Yes → Step 2: 輸出 '找不到檔案！' // 顯示錯誤訊息  \n No  → Step 3: 讀取所有行至 list 'lines' // 取得檔案所有文字行  \n→ Step 4: 計算 'lines' 的長度並存於 'line_count' // 取得行數  \n→ Step 5: 輸出 '總行數: ' + line_count // 顯示總行數  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,2,4,4,3]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 2, 4, 4, 3]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，去除首尾空白\n    data = sys.stdin.read().strip()\n\n    # 嘗試將輸入當作整數來執行 roll_dice\n    try:\n        n = int(data)\n        print(roll_dice(n))\n    except ValueError:\n        # 若不是單純整數，直接執行輸入的程式碼\n        # 這樣可處理像 \"print(roll_dice(5))\" 這類輸入\n        exec(data)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step. Each line: \"虛擬碼步驟 // 解釋\". Use arrow etc. Format example shows: Start, → Step 1: ... etc. For function definition and random import.\n\nSo we produce:\n\nStart // 程式開始執行\n→ Step 1: 匯入 random 模組 // 用於隨機生成數值\n→ Step 2: 定義函數 roll_dice(n): // 建立擲骰函數，參數 n 為擲骰次數\n    → Step 3: 建立空列表 results // 用來儲存每次擲骰結果\n    → Step 4: Decision: n 是否大於 0? // 檢查輸入是否合法\n        Yes → Step 5: For i in 1..n: // 迭代擲骰 n 次\n            → Step 6: result = random.randint(1,6) // 產生 1~6 的隨機整數\n            → Step 7: Append result 到 results // 儲存結果\n        No  → Step 8: Raise ValueError('n must be positive') // n 無效時拋例外\n    → Step 9: Return results // 返回所有擲骰結果\nEnd // 程式執行結束\n\nWe need each line \"虛擬碼步驟\" then space then comment. The arrow \"→\" preceding each step. For decisions we indent. In the example, indentation using spaces. Use \"Decision:\" line and indent Yes → etc.\n\nThus produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 random 模組 // 用於產生隨機數值  \n→ Step 2: 定義函數 roll_dice(n): // 建立擲骰函數，n 為擲骰次數  \n → Step 3: 建立空列表 results // 用來儲存每次擲骰的結果  \n → Step 4: Decision: n 是否大於 0? // 檢查輸入值是否合法  \n  Yes → Step 5: For i 在 1 到 n: // 進行 n 次擲骰迴圈  \n    → Step 6: result = random.randint(1, 6) // 產生 1~6 的隨機整數  \n    → Step 7: 把 result 加到 results // 將結果加入列表  \n  No → Step 8: Raise ValueError('n 必須為正整數') // 若 n 不合法，拋出例外  \n → Step 9: Return results // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    執行 func 並測量耗時，回傳四捨五入到小數點三位的秒數。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入的程式碼\n    code = sys.stdin.read()\n    # 在一個包含 measure_time 的 namespace 內執行輸入程式碼\n    exec(code, {\"measure_time\": measure_time, \"__builtins__\": __builtins__})",
      "virtual_code": "Thinking...\nWe need to output in the specified format. Provide virtual code steps line by line, each line includes virtual code step and comment. Use arrow and decision. They want a function measure_time(func, *args) using time module, measure seconds, round to 3 decimal places, return result. Also presumably return the function's return? Actually measure_time should return the result of func? The description says \"並回傳結果 (四捨五入到小數點 3 位)。\" Means \"return result (rounded to 3 decimal places)\". Likely the elapsed time. So function returns elapsed seconds, rounded to 3 decimal places. Provide steps: import time, define function, start time, call func with args, end time, compute elapsed, round, return. Possibly also handle nested? Just simple. Provide as virtual code. Use Start/End, Decision? No decisions needed. Just steps. Use arrow and step numbering.\n\nLet's format accordingly. Use \"Start\", \"End\". Each line: arrow → Step. Also after arrow, need space then comment. Example: \"→ Step 1: import time // 引入 time 模組\". Provide lines. Provide indentation for nested? Not needed.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: import time // 引入 time 模組\n→ Step 2: Define function measure_time(func, *args) // 宣告函式\n→ Step 3: start_time = time.time() // 取得開始時間\n→ Step 4: result = func(*args) // 執行傳入函式並取得結果\n→ Step 5: end_time = time.time() // 取得結束時間\n→ Step 6: elapsed = end_time - start_time // 計算執行時間\n→ Step 7: rounded_time = round(elapsed, 3) // 四捨五入到三位小數\n→ Step 8: return rounded_time // 回傳計算結果\nEnd // 程式執行結束\n\nBut we need to output only virtual code and comment lines. Not actual code. So use \"Step\" as step. Should we include the function body? Possibly include the function definition step. Let's produce accordingly. Use \"→ Step 1:\" etc. Good.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import time // 引入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 宣告測量時間的函式  \n→ Step 3: start_time = time.time() // 取得執行前的時間戳  \n→ Step 4: result = func(*args) // 執行傳入的函式並取得其返回值  \n→ Step 5: end_time = time.time() // 取得執行後的時間戳  \n→ Step 6: elapsed = end_time - start_time // 計算兩個時間戳之差即執行耗時  \n→ Step 7: rounded_time = round(elapsed, 3) // 將耗時四捨五入到小數點第三位  \n→ Step 8: return rounded_time // 回傳四捨五入後的耗時（秒）  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"apple\",\"grape\",\"melon\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'apple', 'grape', 'melon'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（即使目前不需要任何輸入，也遵循題目要求）\n    _ = sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 使用 discard() 嘗試移除 'pineapple'（不存在時不會錯誤）\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output line-by-line virtual code steps. They want to create a set, add, update, remove, discard, print. Should use Start, End, Decision if necessary. Provide explanation comments. No real code. Just virtual steps. Let's produce steps:\n\nStart\n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 新增元素 orange\n→ Step 3: fruits.update({'grape', 'melon'}) // 同時新增 grape 與 melon\n→ Step 4: fruits.remove('banana') // 移除 banana，若不存在會錯誤\n→ Step 5: fruits.discard('pineapple') // 嘗試移除 pineapple，若不存在不會錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd\n\nWe might also include decision for remove? But it's fine.\n\nLet's format as requested: \"虛擬碼步驟\" + space + \"// 解釋\". Use arrows. Provide Start and End. Use \"→\" at each step.\n\nAlso maybe \"Step 1: fruits = {'apple', 'banana'}\". Provide explanation. Use \"虛擬碼步驟\" could be \"Start\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增元素 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'（若不存在會拋錯）  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'，不存在時不會錯誤  \n→ Step 6: 輸出 fruits // 顯示最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\n# 取得美元對台幣的匯率\ndef get_exchange_rate():\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        resp = requests.get(url)\n        resp.raise_for_status()  # 確保 HTTP 200\n        data = resp.json()\n        rate = data[\"rates\"][\"TWD\"]\n        return rate\n    except Exception:\n        return None  # 失敗時回傳 None\n\n# 更新顯示匯率的 label\ndef update_label(label):\n    rate = get_exchange_rate()\n    if rate is not None:\n        label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n    else:\n        label.config(text=\"更新失敗，請檢查網路連線\")\n\n# 建立 tkinter GUI\ndef run_gui():\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    btn = tk.Button(win, text=\"更新匯率\", command=lambda: update_label(label))\n    btn.pack(pady=5)\n\n    win.mainloop()\n\n# 主程式區塊\ndef main():\n    # 從標準輸入讀取資料\n    input_str = sys.stdin.read().strip()\n    if input_str:\n        # 若輸入中包含「更新匯率」字樣，直接取得並輸出匯率\n        if \"更新匯率\" in input_str:\n            rate = get_exchange_rate()\n            if rate is not None:\n                print(f\"目前美元匯率：約 {rate} TWD\")\n            else:\n                print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 無輸入時啟動 GUI\n        run_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines: Start, etc. Use requests, tkinter. Steps: import, define function get_rate, set up GUI, button, label, update. No actual code, just virtual steps. Each line has code step and comment. Use arrow \"→\". Use \"Decision:\" where necessary? Not many decisions. We'll produce something like:\n\nStart\n→ Import requests and tkinter modules\n→ Define function get_exchange_rate() → send GET request, parse JSON, extract TWD, return rate\n→ Define function update_label() → call get_exchange_rate, set label text\n→ Create main window\n→ Create label to display rate\n→ Create button that triggers update_label\n→ Layout widgets\n→ Call update_label initially to show current rate\n→ mainloop\nEnd\n\nWe need each line like \"Start // 程式開始執行\" etc. Use arrow \"→\". Should each line start with arrow? Example given shows Start then arrow for each step. So produce:\n\nStart // 程式開始執行\n→ Import requests, tkinter // 引入外部模組\n→ Function: get_exchange_rate() // 定義取得匯率的函式\n   → Send GET request to API URL // 連接匯率 API\n   → Parse JSON response // 取得回傳資料\n   → Extract 'rates' → 'TWD' // 取得美元對台幣匯率\n   → Return rate // 將匯率傳回\n→ Function: update_label() // 更新顯示匯率的函式\n   → Call get_exchange_rate() // 取得最新匯率\n   → Set label text to formatted rate // 更新視窗文字\n→ Create main window // 建立 tkinter 視窗\n→ Create label widget // 用於顯示匯率\n→ Create button widget // 用於觸發更新\n   → Bind button command to update_label // 按鈕點擊時執行更新\n→ Layout widgets // 放置在視窗\n→ Call update_label() // 初始顯示匯率\n→ mainloop() // 開始事件循環\nEnd // 程式執行結束\n\nWe must keep each line separate and no nested arrows except maybe decisions. But decisions not needed. Provide comments in Chinese. Ensure each line ends with comment. Use arrow \"→\" and \"Start\" \"End\". Provide each step line. Ensure no code blocks. Just plain lines. Ensure no code tags. Use \"→\" preceding each line after start. For nested inside functions, we may indent? But not necessary. Just separate lines. The example uses indentation for decision branch, but we can ignore. Provide each step as separate line. Good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import requests, tkinter // 引入 requests 與 tkinter 模組  \n→ Function: get_exchange_rate() // 定義取得匯率的函式  \n   → Send GET request to 'https://api.exchangerate-api.com/v4/latest/USD' // 連線至匯率 API  \n   → Parse JSON response // 解析回傳的 JSON 資料  \n   → Extract 'rates' → 'TWD' // 取得美元對台幣的匯率值  \n   → Return rate // 將匯率回傳  \n→ Function: update_label() // 定義更新顯示匯率的函式  \n   → Call get_exchange_rate() // 取得最新匯率  \n   → Set label text to formatted rate // 把匯率顯示在 label 上  \n→ Create main window // 建立 tkinter 主視窗  \n→ Create label widget // 建立用於顯示匯率的 label  \n→ Create button widget // 建立按鈕以觸發更新  \n   → Bind button command to update_label // 按鈕點擊時執行更新函式  \n→ Layout widgets // 放置 label 與按鈕在視窗中  \n→ Call update_label() // 初始顯示最新匯率  \n→ mainloop() // 開始 tkinter 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6_bvopci.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmp6_bvopci.py\", line 53, in main\n    ops, args = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6_bvopci.py\", line 45, in parse_input\n    ops = ast.literal_eval(ops_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2]\n                                                                                                   ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nimport json\nimport random\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.values)\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析兩個列表：\n    1. 操作列表（如 [\"RandomizedSet\",\"insert\",...])\n    2. 參數列表（如 [[],[1],[2],...])\n    \"\"\"\n    pattern = r'\\s*\\[(.*)\\]\\s*,\\s*\\[(.*)\\]\\s*'\n    m = re.match(pattern, data, re.S)\n    if not m:\n        return [], []\n    ops_str = '[' + m.group(1).strip() + ']'\n    args_str = '[' + m.group(2).strip() + ']'\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n    return ops, args\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    ops, args = parse_input(raw)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            results.append(None)\n        elif op == \"insert\":\n            results.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            results.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            results.append(obj.getRandom())\n\n    # 將結果轉成 JSON 格式輸出\n    print(json.dumps(results, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for RandomizedSet class, with operations insert, remove, getRandom all O(1). Use hash map and array.\n\nWe produce step-by-step pseudocode with lines and comments. Use arrows. Probably include start, class, internal data structures.\n\nWe need to output only virtual code lines, each line with explanation.\n\nLet's craft:\n\nStart // Start of algorithm\n\n→ Step 1: Define class RandomizedSet // Class definition\n\n→ Step 2: Inside class, define array values // dynamic array to store elements\n\n→ Step 3: Inside class, define hashmap indexMap // map value to its index in array\n\nInsert operation:\n\n→ Step 4: Method insert(val) // Insert element\n\n→ Step 5: Decision: If val exists in indexMap? // check presence\n\n   Yes → Step 6: Return false // already present\n\n   No  → Step 7: Append val to values // add to array\n\n   → Step 8: Update indexMap[val] = values.length - 1 // record index\n\n   → Step 9: Return true // insertion successful\n\nRemove operation:\n\n→ Step 10: Method remove(val) // Remove element\n\n→ Step 11: Decision: If val not in indexMap? // check existence\n\n   No  → Step 12: Return false // not present\n\n   Yes → Step 13: Get indexToRemove = indexMap[val] // index of element to remove\n\n   → Step 14: Get lastVal = values.last() // last element in array\n\n   → Step 15: Swap values[indexToRemove] with lastVal // move last to deleted spot\n\n   → Step 16: Update indexMap[lastVal] = indexToRemove // update moved element's index\n\n   → Step 17: Remove last element from values // pop\n\n   → Step 18: Delete indexMap[val] // remove mapping\n\n   → Step 19: Return true // removal successful\n\nGetRandom:\n\n→ Step 20: Method getRandom() // Return random element\n\n→ Step 21: Generate randomIndex in [0, values.length-1] // random index\n\n→ Step 22: Return values[randomIndex] // output element\n\nEnd // End of class definition\n\nBut the requirement is \"逐行產生虛擬碼\" maybe each line includes Start End as above. We also need to show the overall structure.\n\nWe might use Start and End at top-level? Might need to show class start and end. Provide Start at beginning of algorithm, End at end.\n\nAlso maybe show initialization constructor.\n\nLet's produce accordingly. Ensure each line ends with comment. Use arrow symbols. Use indentation for decisions. Provide proper indentation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Class RandomizedSet // 定義 RandomizedSet 類別\n→ Step 2:    values ← [] // 動態陣列，用來存儲集合中的元素\n→ Step 3:    indexMap ← {} // 哈希表，映射值 → 該值在 values 陣列中的索引\n\n→ Step 4:    Method insert(val) // 插入操作\n→ Step 5:        Decision: 若 val 在 indexMap 中? // 判斷元素是否已存在\n→ Step 5.1:            Yes → Step 5.2:        Return false // 已存在，插入失敗\n→ Step 5.2:            No  → Step 5.3:        Append val to values // 加入陣列\n→ Step 5.3:                           Set indexMap[val] ← values.length - 1 // 記錄索引\n→ Step 5.4:                           Return true // 插入成功\n\n→ Step 6:    Method remove(val) // 刪除操作\n→ Step 7:        Decision: 若 val 不在 indexMap 中? // 判斷元素是否存在\n→ Step 7.1:            No  → Step 7.2:        Return false // 不存在，刪除失敗\n→ Step 7.2:            Yes → Step 7.3:        indexToRemove ← indexMap[val] // 取要刪除元素的索引\n→ Step 7.3:                           lastVal ← values.last() // 取陣列最後一個元素\n→ Step 7.4:                           values[indexToRemove] ← lastVal // 用最後一個元素覆蓋要刪除的位置\n→ Step 7.5:                           indexMap[lastVal] ← indexToRemove // 更新被覆蓋元素的新索引\n→ Step 7.6:                           Remove last element from values // 從陣列中移除最後一個元素\n→ Step 7.7:                           Delete indexMap[val] // 刪除被刪除元素的映射\n→ Step 7.8:                           Return true // 刪除成功\n\n→ Step 8:    Method getRandom() // 隨機取得元素\n→ Step 9:        randomIndex ← RandomInt(0, values.length - 1) // 產生 0~len-1 的隨機索引\n→ Step 10:       Return values[randomIndex] // 回傳隨機索引對應的元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n          # 仍可翻轉的格子數\n        self.mapping = {}           # 位置映射表\n\n    def flip(self):\n        # 隨機選取一個在 [0, total-1] 的索引\n        r = random.randint(0, self.total - 1)\n        # 取得實際格子索引\n        idx = self.mapping.get(r, r)\n        # 之後 total 減 1，表示該格子已被翻轉\n        self.total -= 1\n        # 用最後一個可用格子覆蓋被選中的位置，保持映射表完整\n        last = self.mapping.get(self.total, self.total)\n        self.mapping[r] = last\n        # 將一次維度索引轉換回 (i, j)\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包裝成一個元組，方便直接使用 ast.literal_eval\n    commands, args = ast.literal_eval('(' + data + ')')\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            res.append(None)\n        elif cmd == \"flip\":\n            res.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            res.append(None)\n    # 輸出結果，None 會被轉成 null\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to flip random zero cell and reset. We must use virtual code syntax with arrows. Provide step-by-step. We need to optimize randomness calls: we can map each cell to a unique number 0..m*n-1, maintain list of available indices; use reservoir-like: maintain a map of swaps, like LeetCode 521 Random Flip Matrix. Steps: Initialize m,n, total = m*n, available = list/ map; reset clears map and total.\n\nflip: pick random r from [0,total-1]; find mapped index = mapping.get(r) or r; decrement total; mapping[r] = mapping.get(total) or total; return mapping index as [i,j] = idx/m, idx%m.\n\nNeed to output virtual code lines with explanation.\n\nWe need to use Start, End, Decision. Provide steps like initialization, reset, flip.\n\nLet's produce.\n\nStructure: We'll show class initialization block, then methods. Use comments. Provide each step.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 m, n, total, map ← {} // 保存行列數、剩餘可翻轉的格子數與映射表  \n→ Step 2: total ← m × n // 初始時所有格子均為 0  \n→ End // 初始化完成  \n\n// ---------- Reset 方法 ----------\nStart // reset() 開始  \n→ Step 3: total ← m × n // 重新計算可翻轉格子數  \n→ Step 4: map ← {} // 清空映射表，所有格子回復為 0  \n→ End // reset() 結束  \n\n// ---------- Flip 方法 ----------\nStart // flip() 開始  \n→ Decision: total > 0? // 確保還有可翻轉的格子  \n    Yes → Step 5: randIdx ← RandomInt(0, total-1) // 隨機選取一個可用索引，僅呼叫一次隨機函式  \n    → Step 6: realIdx ← map.get(randIdx) if exists else randIdx // 取得對應的實際格子索引  \n    → Step 7: total ← total - 1 // 減少可翻轉格子數  \n    → Step 8: lastIdx ← map.get(total) if exists else total // 取得最後一個可用索引的實際格子  \n    → Step 9: map.put(randIdx, lastIdx) // 用最後一個索引覆蓋被選中的位置，保持映射表完整  \n    → Step 10: return [realIdx / n, realIdx % n] // 將一次維度索引轉換回 (i, j)  \n    No → Step 11: throw Exception(\"No zeros left\") // 這個情況在正常使用中不會發生，僅作安全檢查  \n→ End // flip() 結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays",
      "source_file": "Leetcode/leetcode349.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[9,4]'\nGot (Norm):      '[4,9]'\n--- (Raw) ---\nRaw Expected: '[9,4]'\nRaw Got:      '[4, 9]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        Compute the intersection of two integer arrays, keeping only unique elements.\n        \"\"\"\n        # Convert the two lists into sets and compute the set intersection.\n        inter_set = set(nums1) & set(nums2)\n        # Convert the set back to a list. Order is not guaranteed, but we\n        # sort it for deterministic output.\n        return sorted(inter_set)\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string of the form:\n        nums1 = [1,2,2,1], nums2 = [2,2]\n    and return the two lists of integers.\n    \"\"\"\n    # Regular expression to capture the list part after each variable name.\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not nums1_match or not nums2_match:\n        raise ValueError(\"Input format is incorrect.\")\n    # Evaluate the string representations of the lists safely.\n    nums1 = eval(nums1_match.group(1))\n    nums2 = eval(nums2_match.group(1))\n    return nums1, nums2\n\ndef main():\n    # Read the entire input from stdin.\n    raw_input = sys.stdin.read()\n    # Parse the two integer lists from the input.\n    nums1, nums2 = parse_input(raw_input)\n    # Compute the intersection using the Solution class.\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n    # Print the result list.\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code algorithm for computing intersection of two integer arrays, unique elements, order arbitrary. Use Start, End, Decision, arrow. Each line: virtual step plus comment. Must use arrow and structure. Provide unique elements result.\n\nApproach: Use hash set for one array, iterate over other, add to result set if in set. Or convert to sets and intersection. We'll produce generic algorithm.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: 建立 Set1 並將 nums1 的所有元素加入 // 先將第一個陣列轉成集合\n→ Step 2: 建立空集合 Result // 儲存交集\n→ Step 3: 遍歷 nums2 中的每個元素\n    → Decision: 該元素是否存在於 Set1?\n        Yes → Decision: 該元素是否已經在 Result 中?\n            Yes → // 已經加入，跳過\n            No  → Step 4: 將該元素加入 Result // 新增唯一元素\n        No  → // 不在第一個集合，忽略\n→ Step 5: 將 Result 轉換為陣列 // 準備輸出\nEnd\n\nAdd comments.\n\nMake sure each line has arrow or decision. For decision, use indentation. Use arrow \"→\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Set1 並將 nums1 的所有元素加入 // 先將第一個陣列轉成集合  \n→ Step 2: 建立空集合 Result // 儲存交集的唯一元素  \n→ Step 3: 遍歷 nums2 中的每個元素 // 逐一檢查第二個陣列的元素  \n  Decision: 該元素是否存在於 Set1? // 檢查它是否在第一個集合中  \n   Yes → Decision: 該元素是否已經在 Result 中? // 防止重複加入  \n    Yes → // 已存在，直接跳過  \n    No  → Step 4: 將該元素加入 Result // 新增唯一交集元素  \n   No  → // 不在 Set1，忽略此元素  \n→ Step 5: 將 Result 轉換為陣列 // 將集合轉為可回傳的陣列格式  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[1,0],[0,1],[3,2],[2,4]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[1, 0], [0, 1], [3, 2], [2, 4]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[0,1],[1,0],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[0, 1], [1, 0], [0, 1], [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        \"\"\"\n        尋找所有可以組成迴文的字串對。\n        算法核心是對每個單字，將其拆成前綴與後綴，\n        同時檢查兩個方向的匹配規則，時間複雜度為 O(總字長)。\n        \"\"\"\n        # 建立單字 → 索引 的映射，方便 O(1) 取得對應索引\n        word_to_index = {word: i for i, word in enumerate(words)}\n\n        # 方便處理空字串的特殊情況\n        empty_index = word_to_index.get(\"\")\n\n        # 便於判斷子字串是否為迴文\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        res: List[List[int]] = []\n\n        for i, word in enumerate(words):\n            # 空字串與任何迴文字串都能組成迴文對\n            if empty_index is not None and empty_index != i and is_palindrome(word):\n                res.append([i, empty_index])\n                res.append([empty_index, i])\n\n            # 逐一拆分單字，檢查前綴或後綴為迴文的情況\n            n = len(word)\n            for cut in range(n + 1):\n                prefix = word[:cut]\n                suffix = word[cut:]\n\n                # 1. 前綴為迴文 → 需要一個單字，其倒序等於後綴\n                if is_palindrome(prefix):\n                    rev_suffix = suffix[::-1]\n                    j = word_to_index.get(rev_suffix)\n                    if j is not None and j != i:\n                        res.append([j, i])\n\n                # 2. 後綴為迴文 → 需要一個單字，其倒序等於前綴\n                # 這裡 cut == n 的情況會與前面重複，因此跳過\n                if cut != n and is_palindrome(suffix):\n                    rev_prefix = prefix[::-1]\n                    j = word_to_index.get(rev_prefix)\n                    if j is not None and j != i:\n                        res.append([i, j])\n\n        return res\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，預期格式類似於：words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n    raw_input = sys.stdin.read().strip()\n\n    # 只保留方括號之間的文字，並使用 eval 轉成 Python 物件\n    # 為安全起見，也可以改用 ast.literal_eval，但此處假設輸入正確\n    match = re.search(r'\\[(.*?)\\]', raw_input)\n    if match:\n        list_str = '[' + match.group(1) + ']'\n        try:\n            words = eval(list_str)\n        except Exception:\n            words = []\n    else:\n        words = []\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm that returns all palindrome pairs with O(total length) runtime. Likely using a Trie of reversed words and checking splits. But need high-level pseudocode. Provide line by line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Build a hash map word_to_index mapping each word to its index // O(total length)\n→ Step 2: Define a helper function isPalindrome(s, left, right) // check substring palindrome\n→ Step 3: For each word with index i:\n    → Decision: Check if word is palindrome and empty string exists? // handle empty\n        Yes → Step: add pair (i, empty_index)\n    → For each split position k from 0 to len(word):\n        → Left = word[0:k], Right = word[k:]\n        → Decision: If left is palindrome?\n            Yes → reverseRight = reverse(Right)\n                → Decision: If reverseRight in map and map[reverseRight] != i\n                    Yes → add pair (map[reverseRight], i) // reversed word before\n        → Decision: If right is palindrome and k != len(word)?\n            Yes → reverseLeft = reverse(Left)\n                → Decision: If reverseLeft in map and map[reverseLeft] != i\n                    Yes → add pair (i, map[reverseLeft]) // word before reversed\n→ End // return pairs\n\nMake sure to explain each line.\n\nReturn final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立哈希表 wordToIndex，將每個單字映射到其索引 // O(總字長)  \n→ Step 2: 定義輔助函式 isPalindrome(s, l, r) 檢查子字串是否為迴文 // O(長度)  \n→ Step 3: 若 words 內存在空字串，將其索引記錄為 emptyIdx // 方便後續處理  \n→ Decision: 迴圈遍歷每個單字 words[i]  \n    Yes → Step 4: 若 words[i] 為迴文且 emptyIdx 不是 i，加入 (i, emptyIdx) 與 (emptyIdx, i) // 空字串可與任何迴文配對  \n    → Decision: 令 n = words[i] 的長度  \n    → for k 從 0 到 n：  \n        → Step 5: 取左半部 left = words[i][0:k]，右半部 right = words[i][k:]  \n        → Decision: 如果 left 為迴文  \n            Yes → Step 6: 取 right 的反轉 revRight  \n            → Decision: 若 revRight 存於 wordToIndex 且 wordToIndex[revRight] != i，加入 (wordToIndex[revRight], i) // 將反轉的右半部放在前面形成迴文  \n        → Decision: 如果 right 為迴文且 k < n （避免雙重計算）  \n            Yes → Step 7: 取 left 的反轉 revLeft  \n            → Decision: 若 revLeft 存於 wordToIndex 且 wordToIndex[revLeft] != i，加入 (i, wordToIndex[revLeft]) // 將反轉的左半部放在後面形成迴文  \n→ End // 所有配對已找完，回傳結果陣列"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"找出所有長度為10且重複出現的 DNA 子字串。\"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中擷取第一個被單引號包住的 DNA 字串\n    match = re.search(r\"'(.*?)'\", data)\n    if match:\n        dna = match.group(1)\n    else:\n        # 若輸入本身就是 DNA 字串，直接使用\n        dna = data.strip()\n    result = Solution().findRepeatedDnaSequences(dna)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step to solve the problem: find all 10-letter-long sequences that occur more than once in a DNA string. Provide each line: \"虛擬碼步驟 // 解釋\". Use arrows, Start, End, Decision. No actual code.\n\nWe need to consider algorithm: sliding window of length 10, use hash map to count, then collect those with count >1. We can implement using dictionary.\n\nWe'll produce steps: Start, Input string s, length n, if n<10 return empty. Initialize map, result list. For i in range(n-10+1): extract substring, update count. After loop, iterate map entries, if count >1 add to result. Output result.\n\nBut need to follow arrow style. We must include arrows for loop. Use \"→\" for next step. Use \"Decision:\" for condition checks.\n\nLet's produce lines accordingly.\n\nWe need to include variable names: s, n, map, result, i, sub. Provide concise explanations.\n\nLet's produce:\n\nStart\n→ Step 1: 設定變數 s 為輸入的 DNA 序列 // 取得 DNA 字串\n→ Step 2: 計算 s 的長度 n // 獲取序列長度\n→ Decision: n < 10? // 檢查序列是否不足 10 個字元\n    Yes → Step 3: 返回空列表 // 無 10 字母子字串\n    No  → Step 4: 初始化空哈希表 countMap 和空列表 result // 準備計數\n→ Decision: n - 10 + 1 > 0? // 確認有可滑動的窗口\n    Yes → Step 5: 進入 for 迴圈 i 從 0 到 n-10\n        → Step 6: 取子字串 sub = s[i : i+10] // 取得 10 字母片段\n        → Step 7: 更新 countMap[sub] = countMap.get(sub, 0) + 1 // 計數\n    No  → (skip loop)\n→ Step 8: 迭代 countMap 中的鍵值\n        → Decision: count > 1? // 判斷是否重複\n            Yes → Step 9: 把子字串加入 result // 收集重複序列\n            No  → (不加入)\n→ Step 10: 返回 result // 回傳所有重複的 10 字母序列\nEnd // 程式結束\n\nWe need each line separate. Let's ensure correct arrow formatting. For each step we provide \"→ Step X: ...\". Indent decisions accordingly. Use \"→\" inside decisions? We can indent with tabs maybe but maintain consistent formatting.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定變數 s 為輸入的 DNA 序列 // 取得 DNA 字串  \n→ Step 2: 計算 s 的長度 n // 獲取序列長度  \n→ Decision: n < 10? // 檢查序列是否不足 10 個字元  \n  Yes → Step 3: 返回空列表 // 無 10 字母子字串  \n  No  → Step 4: 初始化空哈希表 countMap 和空列表 result // 準備計數  \n→ Decision: n - 10 + 1 > 0? // 確認有可滑動的窗口  \n  Yes → Step 5: 進入 for 迴圈 i 從 0 到 n-10  \n    → Step 6: 取子字串 sub = s[i : i+10] // 取得 10 字母片段  \n    → Step 7: 更新 countMap[sub] = countMap.get(sub, 0) + 1 // 計數  \n  No  → (不執行迴圈)  \n→ Step 8: 迭代 countMap 中的鍵值  \n    → Decision: count > 1? // 判斷是否重複  \n      Yes → Step 9: 把子字串加入 result // 收集重複序列  \n      No  → (不加入)  \n→ Step 10: 返回 result // 回傳所有重複的 10 字母序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Array",
      "source_file": "Leetcode/leetcode189.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[5,6,7,1,2,3,4]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[5,6,7,1,2,3,4]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,99,-1,-100]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[3,99,-1,-100]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def rotate(self, nums, k):\n        n = len(nums)\n        if n <= 1:\n            return\n        k %= n\n        if k == 0:\n            return\n        # 先反轉整個陣列\n        nums.reverse()\n        # 再反轉前 k 個元素\n        nums[:k] = reversed(nums[:k])\n        # 反轉剩下的 n-k 個元素\n        nums[k:] = reversed(nums[k:])\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'nums = [1,2,3], k = 2' 的輸入字串，回傳 nums 與 k。\n    \"\"\"\n    nums = None\n    k = None\n    # 把多行換成一行，並以逗號切分\n    parts = data.replace('\\n', ' ').split(',')\n    for part in parts:\n        part = part.strip()\n        if part.startswith('nums'):\n            nums_str = part.split('=', 1)[1].strip()\n            try:\n                nums = eval(nums_str, {}, {})\n            except Exception:\n                nums = []\n        elif part.startswith('k'):\n            k_str = part.split('=', 1)[1].strip()\n            try:\n                k = int(k_str)\n            except Exception:\n                k = 0\n    return nums, k\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    nums, k = parse_input(data)\n    if nums is None or k is None:\n        return\n    Solution().rotate(nums, k)\n    # 輸出結果，保持 Python 列表格式\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for rotating array to right by k steps. Must be line by line, using arrow syntax. Provide explanation comment after space. No actual code. Should handle edge cases: negative? but k non-negative. Use algorithm: reverse segments. Steps: compute n, normalize k mod n. Reverse whole array, then reverse first k, then reverse k to end. Also handle empty or single element. Provide explanation. Use decision if n==0 or n==1 or k% n ==0 then nothing. Provide pseudo steps.\n\nLet's produce.\n\nStructure: Start, then steps. Use arrow → for steps. For decisions: Decision: if condition. Then Yes → Step etc.\n\nWill produce:\n\nStart // 程式開始\n\n→ Step 1: 取得陣列長度 n // 取得 nums 長度\n\n→ Decision: n <= 1? // 檢查是否需要旋轉\n\n    Yes → End // 陣列長度 <=1 時不需要旋轉\n\n    No  → Step 2: k = k mod n // 先將步數化為 n 以內\n\n→ Decision: k == 0? // 檢查步數是否為 0\n\n    Yes → End // 步數為 0 時不需要旋轉\n\n    No  → Step 3: 反轉整個陣列 // 先將整個陣列倒序\n\n→ Step 4: 反轉前 k 個元素 // 反轉陣列首部 k 個\n\n→ Step 5: 反轉剩下 n-k 個元素 // 反轉陣列後部\n\nEnd // 程式執行結束\n\nBut need arrow formatting: maybe use → Step X: ... // explanation\n\nAlso decisions: use Decision: 如果 n <= 1? // explanation. Then Yes → End // explanation. No → Step 2.\n\nAlso arrow after Decision? They used Yes → Step. No → Step. So need to indent? But example shows indentation but we can keep same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列長度 n ← nums.length // 獲取 nums 的長度  \n→ Decision: n <= 1? // 檢查陣列是否只有 0 或 1 個元素  \n  Yes → End // 陣列長度 <= 1 時不需要任何旋轉  \n  No  → Step 2: k = k mod n // 先把 k 限制在 [0, n-1] 範圍內  \n→ Decision: k == 0? // 檢查步數是否為 0  \n  Yes → End // 步數為 0 時不需要任何旋轉  \n  No  → Step 3: 反轉整個陣列 ← reverse(nums, 0, n-1) // 先將整個陣列倒序  \n→ Step 4: 反轉前 k 個元素 ← reverse(nums, 0, k-1) // 反轉陣列首部 k 個元素  \n→ Step 5: 反轉剩下 n-k 個元素 ← reverse(nums, k, n-1) // 反轉陣列後部  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,2,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 2, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val):\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val):\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        self.data.pop()\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.data)\n\ndef format_result(res):\n    if res is None:\n        return 'null'\n    if isinstance(res, bool):\n        return 'true' if res else 'false'\n    return str(res)\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    # Parse the two lists provided in the input\n    ops, args = ast.literal_eval('(' + input_data + ')')\n    result = []\n    obj = None\n    for cmd, arg in zip(ops, args):\n        if cmd == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            result.append(None)\n        elif cmd == 'insert':\n            result.append(obj.insert(arg[0]))\n        elif cmd == 'remove':\n            result.append(obj.remove(arg[0]))\n        elif cmd == 'getRandom':\n            result.append(obj.getRandom())\n    print('[' + ', '.join(format_result(r) for r in result) + ']')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the design and operations of RandomizedCollection. We don't output actual code. We should describe steps: initialize data structures, insert, remove, getRandom. Use Start, End, Decision, arrow notation. Provide brief explanation after each line. No actual code syntax, just pseudo-steps. Must be line by line. Use \"虛擬碼步驟\" and comment after space. Use arrow \"→\". Format each line: \"Start // 程式開始執行\". Then \"→ Step 1: ... // ...\".\n\nWe need to outline design: Use vector to store elements, unordered_map<int, unordered_set<int>> for value to indices positions. Provide steps for insert, remove, getRandom. Provide decision branches. Use O(1) average.\n\nLet's produce the flow:\n\nStart // 初始化程序\n\n→ Step 1: 建立空 vector elements // 用於隨機存取\n\n→ Step 2: 建立 hash map indicesMap，key 為 val，value 為 set of indices 在 vector 位置 // 方便查找索引\n\n→ Step 3: 定義 insert(val)\n\n    → Decision: 如果 indicesMap[val] 為空? // 判斷 val 是否首次出現\n\n        Yes → Step 4: Append val 至 elements // 將 val 加入 vector\n\n            → Step 5: 取得新索引 idx = elements.size()-1 // 紀錄位置\n\n            → Step 6: 將 idx 插入 indicesMap[val] // 更新索引集合\n\n            → Step 7: 回傳 true // 代表新元素\n\n        No  → Step 8: Append val 至 elements // 同樣加入 vector\n\n            → Step 9: idx = elements.size()-1\n\n            → Step 10: 將 idx 插入 indicesMap[val] // 更新索引集合\n\n            → Step 11: 回傳 false // 已存在\n\n→ Step 12: 定義 remove(val)\n\n    → Decision: 若 indicesMap[val] 為空? // 沒有此元素\n\n        Yes → Step 13: 回傳 false // 無法移除\n\n        No  → Step 14: 取 indicesMap[val] 內任意一個索引 removeIdx // 取得要移除的索引\n\n            → Step 15: 取 vector 末尾元素 lastVal 和 its idx lastIdx = elements.size()-1 // 準備交換\n\n            → Decision: 若 removeIdx ≠ lastIdx? // 需要交換以保持 vector 索引連續\n\n                Yes → Step 16: elements[removeIdx] = lastVal // 覆蓋\n\n                    → Step 17: 更新 indicesMap[lastVal]：移除 lastIdx，加入 removeIdx // 更新索引位置\n\n                No  → (不需要交換)\n\n            → Step 18: 移除 vector 最後一個元素 // 刪除\n\n            → Step 19: 從 indicesMap[val] 移除 removeIdx // 更新索引集合\n\n            → Decision: 若 indicesMap[val] 空? // 是否已經無剩餘\n\n                Yes → Step 20: 刪除 indicesMap[val] // 釋放空鍵\n\n                No  → (保持)\n\n            → Step 21: 回傳 true // 成功移除\n\n→ Step 22: 定義 getRandom()\n\n    → Step 23: 隨機選取 index r 在 0~elements.size()-1\n\n    → Step 24: 回傳 elements[r] // 隨機元素\n\nEnd // 程式結束\n\nNeed to ensure each line uses arrow for steps, but Start and End not arrows. Provide explanation comments. Let's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空 vector elements // 用於隨機存取  \n→ Step 2: 建立 hash map indicesMap，key 為 val，value 為 set of indices 在 vector 位置 // 方便查找索引  \n\n→ Step 3: 定義 insert(val) // 插入操作  \n    → Decision: 若 indicesMap[val] 為空? // 判斷 val 是否第一次出現  \n        Yes → Step 4: 把 val 加入 vector elements // 將新值放到尾端  \n            → Step 5: 計算新索引 idx = elements.size() - 1 // 紀錄位置  \n            → Step 6: 把 idx 插入 indicesMap[val] // 更新索引集合  \n            → Step 7: 回傳 true // 表示是新元素  \n        No  → Step 8: 把 val 加入 vector elements // 同樣放到尾端  \n            → Step 9: idx = elements.size() - 1  \n            → Step 10: 把 idx 插入 indicesMap[val] // 更新索引集合  \n            → Step 11: 回傳 false // 表示已存在  \n\n→ Step 12: 定義 remove(val) // 移除操作  \n    → Decision: 若 indicesMap[val] 為空? // 沒有此元素  \n        Yes → Step 13: 回傳 false // 無法移除  \n        No  → Step 14: 從 indicesMap[val] 任意取一個索引 removeIdx // 取待刪除位置  \n            → Step 15: 取 vector 末尾元素 lastVal 和其索引 lastIdx = elements.size() - 1 // 準備交換  \n            → Decision: 若 removeIdx ≠ lastIdx? // 需要交換以維持連續索引  \n                Yes → Step 16: 把 lastVal 放到 removeIdx 的位置 elements[removeIdx] = lastVal // 覆蓋  \n                    → Step 17: 在 indicesMap[lastVal] 中移除 lastIdx 並加入 removeIdx // 更新索引集合  \n                No  → (不需要交換)  \n            → Step 18: 移除 vector 最後一個元素 // 刪除尾部元素  \n            → Step 19: 從 indicesMap[val] 移除 removeIdx // 更新索引集合  \n            → Decision: 若 indicesMap[val] 空? // 是否已無剩餘元素  \n                Yes → Step 20: 刪除 indicesMap[val] // 釋放空鍵  \n                No  → (保持)  \n            → Step 21: 回傳 true // 成功移除  \n\n→ Step 22: 定義 getRandom() // 隨機取得元素  \n    → Step 23: 隨機選取索引 r ∈ [0, elements.size()-1] // 隨機位置  \n    → Step 24: 回傳 elements[r] // 回傳對應元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    \"\"\"雙堆實現的中位數查找器\"\"\"\n    def __init__(self):\n        # 小根堆（max heap，使用負值實現）\n        self.small = []\n        # 大根堆（min heap）\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        \"\"\"將新數字加入結構，保持兩堆平衡\"\"\"\n        # 先放入小根堆（負值）\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆都有元素且小根堆最大值大於大根堆最小值，則交換\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡兩堆大小：小根堆最多比大根堆多一個\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"返回目前所有數字的中位數\"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取操作序列，執行並輸出結果\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入轉換為兩個列表\n    # 例如: '[\"MedianFinder\",\"addNum\"],[[],[1]]' -> ('MedianFinder', 'addNum'), ([], [1])\n    # 用括號包起來讓 ast.literal_eval 成為 tuple\n    try:\n        ops, args = ast.literal_eval(f'({data})')\n    except Exception as e:\n        # 若解析失敗，直接退出\n        print(f\"Error parsing input: {e}\")\n        return\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            result.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            result.append(median)\n        else:\n            # 未知操作，略過\n            result.append(None)\n\n    # 格式化輸出，將 None 轉成 'null'\n    output = '[' + ', '.join('null' if x is None else str(x) for x in result) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for MedianFinder with addNum and findMedian. Should use data structures like two heaps. Use virtual code lines with explanation. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個堆: 小根堆 maxHeap (存下半) // 儲存較小的一半\n→ Step 2: 初始化另一個堆: 大根堆 minHeap (存上半) // 儲存較大的一半\n→ Step 3: addNum(num) // 新增數字\n    → Decision: maxHeap 为空 或 num ≤ maxHeap.top()? // 判斷數字屬於下半\n        Yes → maxHeap.push(num) // 放入小根堆\n        No  → minHeap.push(num) // 放入大根堆\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 若下半過大\n        Yes → minHeap.push(maxHeap.top()); maxHeap.pop() // 平衡\n        No  → Decision: minHeap.size() > maxHeap.size()? // 若上半過大\n            Yes → maxHeap.push(minHeap.top()); minHeap.pop() // 平衡\n→ Step 4: findMedian() // 取得中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量相等\n        Yes → median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均\n        No  → median = maxHeap.top() // 下半多 1\n    → Return median\nEnd // 程式結束\n\nBut need virtual code format: each line separate. Use arrow for steps, decisions with Yes →, No →. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxHeap（小根堆） // 存放較小的一半數字  \n→ Step 2: 初始化 minHeap（大根堆） // 存放較大的一半數字  \n\n→ Step 3: addNum(num) // 新增數字到資料結構  \n    → Decision: maxHeap 为空 或 num ≤ maxHeap.top()? // 判斷 num 屬於下半  \n        Yes → maxHeap.push(num) // 放入小根堆  \n        No  → minHeap.push(num) // 放入大根堆  \n    → Decision: maxHeap.size() > minHeap.size() + 1? // 下半太多  \n        Yes → minHeap.push(maxHeap.top()); maxHeap.pop() // 重新平衡  \n        No  → Decision: minHeap.size() > maxHeap.size()? // 上半太多  \n            Yes → maxHeap.push(minHeap.top()); minHeap.pop() // 重新平衡  \n\n→ Step 4: findMedian() // 取得目前所有數字的中位數  \n    → Decision: maxHeap.size() == minHeap.size()? // 數量相等  \n        Yes → median = (maxHeap.top() + minHeap.top()) / 2.0 // 取平均  \n        No  → median = maxHeap.top() // 下半多一個，取其頂點  \n    → Return median  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7oqnh2un.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmp7oqnh2un.py\", line 46, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7oqnh2un.py\", line 32, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjcbplalx.py\", line 52, in <module>\n    main()\n  File \"/tmp/tmpjcbplalx.py\", line 46, in main\n    intervals, new_interval = parse_input(raw_input)\n                              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjcbplalx.py\", line 32, in parse_input\n    intervals = ast.literal_eval(intervals_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        # Merge all overlapping intervals\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        # Add the merged newInterval\n        result.append(newInterval)\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        return result\n\ndef parse_input(data):\n    # Try to find \"intervals = ...\" and \"newInterval = ...\"\n    intervals_match = re.search(r'intervals\\s*=\\s*(\\[[^\\]]*\\])', data)\n    new_interval_match = re.search(r'newInterval\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if intervals_match and new_interval_match:\n        intervals = ast.literal_eval(intervals_match.group(1))\n        new_interval = ast.literal_eval(new_interval_match.group(1))\n    else:\n        # Fallback: assume first line is intervals, second line is newInterval\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            intervals = ast.literal_eval(lines[0])\n            new_interval = ast.literal_eval(lines[1])\n        else:\n            raise ValueError(\"Invalid input format\")\n    return intervals, new_interval\n\ndef main():\n    raw_input = sys.stdin.read()\n    intervals, new_interval = parse_input(raw_input)\n    sol = Solution()\n    result = sol.insert(intervals, new_interval)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for inserting a new interval into sorted non-overlapping intervals, merging overlaps. The output must be virtual code line by line with comment.\n\nWe need to include Start, End, Decision nodes. Provide step-by-step.\n\nWe should cover steps: initialize result list, iterate intervals, compare end and start to determine before, overlapping, after. Build result accordingly.\n\nLet's craft.\n\nWe must ensure each line is like: `Start // ...`. Then arrows. Use `→` for steps, `Decision:` lines.\n\nWe'll produce something like:\n\nStart // 開始\n→ Step 1: 初始化空列表 result // 用來儲存合併後的區間\n→ Step 2: 設定 index = 0 // 追蹤 intervals 中的索引\n\nThen iterate through intervals while index < len(intervals). In pseudocode, we might use while loop with decisions inside.\n\nAlternatively we can produce more simplified approach: use for each interval.\n\nWe should keep steps clear.\n\nWe should mention: For each interval [cur_start, cur_end] in intervals:\n\n- If cur_end < new_start: add current interval to result\n- Else if cur_start > new_end: add newInterval if not added, then add remaining intervals, break\n- Else: overlapping: merge new_start = min(new_start, cur_start), new_end = max(new_end, cur_end)\n\nAfter loop, if new interval not yet added, add it.\n\nReturn result.\n\nLet's produce step-by-step pseudocode accordingly.\n\nUse arrows and decisions accordingly.\n\nWe need each line: `虛擬碼步驟 // 解釋`.\n\nWe'll produce a linear structure with nested decisions.\n\nWe can produce:\n\nStart // 程式開始\n\n→ Step 1: result = [] // 初始化結果列表\n\n→ Step 2: i = 0 // 迴圈索引\n\n→ Decision: i < len(intervals)? // 仍有未處理的區間\n    Yes → Step 3: cur_start, cur_end = intervals[i] // 取得當前區間\n\n    → Decision: cur_end < new_start? // 當前區間在新區間之前\n        Yes → Step 4: result.append([cur_start, cur_end]) // 直接加入\n               i += 1\n        No → Decision: cur_start > new_end? // 當前區間在新區間之後\n            Yes → Step 5: result.append([new_start, new_end]) // 加入新區間\n                   // 往後所有剩餘區間都不重疊，直接加入\n                   → For remaining j in range(i, len(intervals)):\n                         result.append(intervals[j])\n                   → i = len(intervals) // 退出迴圈\n            No → Step 6: new_start = min(new_start, cur_start) // 合併\n                   new_end = max(new_end, cur_end) // 合併\n                   i += 1\n\n    // loop back to Decision i < len(intervals)\n\nAfter loop: Decision: new_start is still not added? // 如果尚未加入新區間\n    Yes → Step 7: result.append([new_start, new_end]) // 加入\n\n→ Step 8: return result // 回傳結果\n\nEnd // 程式結束\n\nBut we need to make each line a single step.\n\nWe should ensure each line ends with `//` comment.\n\nLet's craft final pseudocode accordingly.\n\nWe also need to adhere to format: each line: `虛擬碼步驟 // 解釋`. The \"虛擬碼步驟\" includes arrows or words. We must use `→`, `Decision:` etc. Each line must start with `Start`, `→`, or `Decision:`.\n\nLet's format:\n\nStart // 程式開始\n\n→ Step 1: result = [] // 初始化結果列表\n\n→ Step 2: i = 0 // 設定索引\n\n→ Decision: i < len(intervals) // 是否還有未處理的區間\n    Yes → Step 3: cur_start, cur_end = intervals[i] // 取得目前區間\n        → Decision: cur_end < new_start // 目前區間完全在新區間前面\n            Yes → Step 4: result.append([cur_start, cur_end]) // 將其加入結果\n                   i += 1 // 移動到下一個\n            No → Decision: cur_start > new_end // 目前區間完全在新區間後面\n                Yes → Step 5: result.append([new_start, new_end]) // 加入新區間\n                       → For j in range(i, len(intervals)): result.append(intervals[j]) // 加入剩餘區間\n                       → i = len(intervals) // 迴圈結束\n                No → Step 6: new_start = min(new_start, cur_start) // 合併區間起始\n                       new_end = max(new_end, cur_end) // 合併區間結束\n                       i += 1 // 進行下一個\n        // 回到 Decision i < len(intervals)\n\n→ Decision: i < len(intervals) // 迴圈判斷\n    // 重複上述流程\n\n→ Decision: new_start not added? // 新區間是否已加入\n    Yes → Step 7: result.append([new_start, new_end]) // 加入新區間\n\n→ Step 8: return result // 回傳結果\n\nEnd // 程式結束\n\nBut this has nested decisions with multiple lines per decision, need to ensure each line is a single step. But the format requires each line includes \"虛擬碼步驟\" and comment. We can use indentation? In the example, they used indentation. For decisions, they used \"Decision:\" and indentation for Yes and No branches. That is acceptable.\n\nWe can produce pseudocode with nested decisions like that.\n\nBut each \"Decision\" line is separate, and the lines within branches start with Yes → or No →. For clarity, we should keep each line separate.\n\nLet's craft final answer accordingly.\n\nAlso we should note that in the For loop for remaining intervals, we can just write `→ For j in range(i, len(intervals)): result.append(intervals[j])` as a step.\n\nBut we might need to break out of loop after adding new interval. We can set i = len(intervals) to terminate.\n\nSimplify: After adding new interval, we can append remaining intervals by a loop, then set i = len(intervals) to end loop.\n\nWe might skip i increment.\n\nLet's produce final pseudocode.\n\nWe must ensure each line includes comment. We'll use Chinese comments.\n\nNow final.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: result = [] // 初始化結果列表\n\n→ Step 2: i = 0 // 設定迴圈索引\n\n→ Decision: i < len(intervals) // 是否還有未處理的區間\n    Yes → Step 3: cur_start, cur_end = intervals[i] // 取得目前區間\n        → Decision: cur_end < new_start // 目前區間完全在新區間前面\n            Yes → Step 4: result.append([cur_start, cur_end]) // 加入不重疊區間\n                   i += 1 // 移動到下一個區間\n            No → Decision: cur_start > new_end // 目前區間完全在新區間後面\n                Yes → Step 5: result.append([new_start, new_end]) // 加入新區間\n                       → For j in range(i, len(intervals)): result.append(intervals[j]) // 加入剩餘不重疊區間\n                       → i = len(intervals) // 迴圈結束\n                No → Step 6: new_start = min(new_start, cur_start) // 合併起始點\n                       new_end = max(new_end, cur_end) // 合併結束點\n                       i += 1 // 移動到下一個區間\n        // 回到 Decision i < len(intervals)\n\n→ Decision: i < len(intervals) // 迴圈條件，重複上述流程\n    // (同上)\n\n→ Decision: new_start not yet added? // 檢查新區間是否已加入結果\n    Yes → Step 7: result.append([new_start, new_end]) // 加入新區間\n\n→ Step 8: return result // 回傳最終合併後的區間列表\n\nEnd // 程式結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# Colors we care about\nCOLORS = ['R', 'Y', 'B', 'G', 'W']\n\ndef collapse(board: str) -> str:\n    \"\"\"\n    Repeatedly remove any contiguous group of 3 or more same-colored balls.\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        i = 0\n        new_board = []\n        while i < len(board):\n            j = i\n            while j < len(board) and board[j] == board[i]:\n                j += 1\n            if j - i >= 3:            # group of 3+ found\n                changed = True\n                i = j                 # skip this group\n            else:                     # keep this segment\n                new_board.append(board[i:j])\n                i = j\n        board = ''.join(new_board)\n    return board\n\ndef min_steps(board: str, hand_counts) -> int:\n    \"\"\"\n    DFS with memoization to find minimum number of insertions to clear the board.\n    \"\"\"\n    INF = 10 ** 9\n    memo = {}\n\n    def dfs(b: str, h):\n        key = (b, tuple(h))\n        if key in memo:\n            return memo[key]\n        if not b:                     # board cleared\n            return 0\n        best = INF\n        # Try every insertion position\n        for pos in range(len(b) + 1):\n            # Try inserting each color that we still have\n            for idx, cnt in enumerate(h):\n                if cnt == 0:\n                    continue\n                color = COLORS[idx]\n                # Count same-colored balls adjacent to the insertion point\n                left = pos - 1\n                left_cnt = 0\n                while left >= 0 and b[left] == color:\n                    left_cnt += 1\n                    left -= 1\n                right = pos\n                right_cnt = 0\n                while right < len(b) and b[right] == color:\n                    right_cnt += 1\n                    right += 1\n                total = 1 + left_cnt + right_cnt\n                if total < 3:          # insertion wouldn't create a removable group\n                    continue\n                # Perform the insertion and collapse\n                new_b = b[:pos] + color + b[pos:]\n                new_b = collapse(new_b)\n                h[idx] -= 1\n                sub = dfs(new_b, h)\n                h[idx] += 1\n                if sub != -1:\n                    best = min(best, sub + 1)\n        memo[key] = -1 if best == INF else best\n        return memo[key]\n\n    return dfs(board, hand_counts)\n\ndef main():\n    data = sys.stdin.read()\n    # Extract board and hand strings using regex\n    board_match = re.search(r'board\\s*=\\s*\"([^\"]*)\"', data)\n    hand_match = re.search(r'hand\\s*=\\s*\"([^\"]*)\"', data)\n    if not board_match or not hand_match:\n        return\n    board = board_match.group(1)\n    hand = hand_match.group(1)\n    # Count hand balls per color\n    hand_counts = [0] * len(COLORS)\n    for ch in hand:\n        if ch in COLORS:\n            hand_counts[COLORS.index(ch)] += 1\n    result = min_steps(board, hand_counts)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm. Likely using DFS with pruning, backtracking, count of hand balls. We need to produce pseudo steps. Ensure each line includes explanation comment. Use arrows, Start, End, Decision.\n\nWe'll outline algorithm: Preprocess board removal function to collapse. Define recursive DFS: if board empty return 0; if hand empty return INF; try each color count>0: for each insertion position that could create group of 3. Insert, collapse, recurse, track min.\n\nWe'll produce steps. Use variables: board, handCount[5]. Use mapping char to index.\n\nWe'll produce pseudo code lines.\n\nLet's produce about maybe 50 lines. Ensure each line ends with comment. Use \"→\" arrow after Start? For each step. We'll use \"Start\" then \"→ Step X\". Provide explanations.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 handCount[5] // 依據手牌字串統計各顏色球的數量  \n→ Step 2: 呼叫 DFS(board, handCount) // 開始遞迴尋找最小插入數  \n→ Step 3: 定義函式 DFS(board, handCount)  \n  → Decision: 如果 board 為空? // 若板上無球即已清空  \n    Yes → Return 0 // 無需再插入球  \n    No → Decision: 如果所有手牌數量為 0? // 若沒有球可插  \n      Yes → Return INF // 代表無法完成，回傳無窮大  \n      No → Step 4: 初始化 best = INF // 用於儲存目前最小插入數  \n      → For colorIdx in 0..4: // 嘗試每種顏色  \n        Decision: 若 handCount[colorIdx] == 0? // 若此顏色手牌為 0  \n          Yes → Continue // 跳過  \n          No → Step 5: 針對 board 中所有可能插入位置 i (0..len(board))  \n            Decision: 是否在此位置插入能形成至少 3 個同色連續球? // 判斷是否有利  \n              Yes → Step 6: 複製 board 為 newBoard  \n               → 插入顏色對應的球於位置 i  \n               → 呼叫 collapse(newBoard)  // 連續消除  \n               → handCount[colorIdx]-- // 使用一顆球  \n               → result = DFS(newBoard, handCount) // 進行下一層遞迴  \n               → handCount[colorIdx]++ // 回復手牌數量  \n               Decision: 若 result != INF? // 只保留可行路徑  \n                 Yes → best = min(best, result + 1) // 加 1 為本次插入  \n                 No → Do nothing // 無效路徑  \n            Decision: 結束所有位置 i  \n           Decision: 結束所有顏色 colorIdx  \n       → Return best // 迴傳目前最小插入數  \n→ Step 7: 定義函式 collapse(board)  \n  → 迴圈:  \n    → Step 8: 搜尋 longest contiguous segment of same color in board  \n    → Decision: 是否 segmentLen >= 3?  \n      Yes → Step 9: 移除該 segment 並將兩側拼接成新 board  \n       → board = new board  \n       → 重複 Step 8 // 可能產生新的連續 3+ 組  \n      No → Break // 無更多可消除的組  \n  → Return board // 回傳已消除完畢的板  \n→ Step 10: 結果 = DFS(initialBoard, handCount)  \n  → Decision: 是否結果 == INF?  \n    Yes → Return -1 // 無法清空  \n    No → Return 結果 // 最小插入數  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppys6wlqu.py\", line 43, in <module>\n    ops = json.loads(raw_input[0])\n          ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if word[i] not in node.children:\n                    return False\n                return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip().splitlines()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析操作與參數\n    ops = json.loads(raw_input[0])\n    args = json.loads(raw_input[1]) if len(raw_input) > 1 else []\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            res.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            res.append(None)\n        elif op == \"search\":\n            res.append(obj.search(arg[0]))\n        else:\n            # 若有其他方法，視情況擴充\n            res.append(None)\n\n    # 輸出結果，將 None 轉為 null\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow for the WordDictionary class. It's a design problem; we need to show steps for initializing, adding words, searching with dot support. We need to produce virtual code lines, each with explanation. We need to use arrows and decision structure. We need to design the algorithm: likely a Trie with recursion for search.\n\nSo produce steps: Start, Initialize root node, addWord: insert into trie, search: recursive DFS. We need to present virtual code: each line like \"Start // 程式開始執行\" etc.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立根節點 root // Trie 根節點\n\nFor addWord, we need to show steps: traverse each character, create child if none, mark end. For search, handle '.' recursively.\n\nWe can break into functions: addWord(word), search(word). We'll produce high-level pseudo-code, not actual code.\n\nWe should incorporate decision steps where necessary. For example, in search, if char is '.', we need to loop over all children, etc.\n\nWe'll output each line with explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 WordDictionary 類別 // 定義資料結構\n→ Step 2: 建立 TrieNode 類別，含 children[26] 與 isEnd // Trie 節點\n→ Step 3: WordDictionary() 初始化 root // 建構子\n\nFor addWord(word):\n→ Function addWord(word)\n→ Step: current ← root // 先指向根節點\n→ For each ch in word\n    → Decision: 如果 current.children[ch] 存在? // 有無此字母節點\n        Yes → current ← current.children[ch] // 進入節點\n        No → current.children[ch] ← new TrieNode(); current ← current.children[ch] // 新增節點\n→ Decision: 設定 current.isEnd ← true // 標記字尾\n\nFor search(word):\n→ Function search(word)\n→ Step: return dfs(root, word, 0) // 從根開始遞歸\n\n→ Function dfs(node, word, idx)\n→ Decision: 如果 idx == len(word)? // 已遍歷完\n    Yes → return node.isEnd // 若字尾則匹配成功\n    No →\n→ Step: ch ← word[idx] // 目前字元\n→ Decision: 如果 ch == '.'? // 任意字母\n    Yes → for child in node.children\n                If child != null and dfs(child, word, idx+1) return true\n           return false // 沒有符合\n    No →\n        → Decision: 如果 node.children[ch] 存在? // 具體字母節點\n            Yes → return dfs(node.children[ch], word, idx+1)\n            No  → return false\n\nEnd // 程式執行結束\n\nBut we need each line with explanation. So we need to separate each step line. We need to ensure each line has virtual code step + comment. The arrow lines and decisions are each a line. For loops we can have \"For each ch in word\" as a line, but we need to handle loop body. We can show \"For each ch in word:\" then indent? In virtual code we can't indent but we can use \"→\" for each line. Use nested arrows.\n\nWe need to maintain clarity. Use \"→\" for each line. For decision lines use \"Decision:\".\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別，具有 children[26] 與 isEnd 屬性 // 定義 Trie 節點結構\n→ Step 2: 定義 WordDictionary 類別 // 建立字典類別\n→ Step 3: WordDictionary() 初始化 root 為新的 TrieNode // 建構子\n...\n\nFor addWord and search functions, we may include lines as steps inside the function. We can indicate \"Function addWord(word)\" as a step line. Then \"→ current ← root // 目前節點指向根\" etc.\n\nBetter to break into lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別，含 children[26] 與 isEnd // Trie 節點結構\n→ Step 2: 定義 WordDictionary 類別 // 字典類別\n→ Step 3: WordDictionary() 初始化 root 為 TrieNode // 建構子\n→ Step 4: Function addWord(word) // 定義新增字的函式\n→ Step 5: current ← root // 開始於根節點\n→ Step 6: For each ch in word // 逐字插入\n    → Decision: current.children[ch] 存在? // 檢查節點是否已存在\n        Yes → current ← current.children[ch] // 移動至已存在節點\n        No  → current.children[ch] ← new TrieNode(); current ← current.children[ch] // 新增節點並移動\n→ Step 7: current.isEnd ← true // 標記字尾\n→ Step 8: Function search(word) // 定義搜尋函式\n→ Step 9: return dfs(root, word, 0) // 從根開始遞歸搜尋\n→ Step 10: Function dfs(node, word, idx) // 遞歸搜尋輔助函式\n    → Decision: idx == len(word)? // 是否到字串尾\n        Yes → return node.isEnd // 若字尾則匹配成功\n        No →\n            → Step 11: ch ← word[idx] // 取得目前字元\n            → Decision: ch == '.'? // 任意字母\n                Yes →\n                    → Step 12: for child in node.children // 遍歷所有子節點\n                        → Decision: child != null and dfs(child, word, idx+1)? // 递归检查\n                            Yes → return true // 找到匹配\n                            No  → continue // 继续尝试下一个子节点\n                    → Step 13: return false // 所有子节点都不匹配\n                No →\n                    → Decision: node.children[ch] 存在? // 是否存在具體字母節點\n                        Yes → return dfs(node.children[ch], word, idx+1) // 递归\n                        No  → return false // 沒有節點，搜尋失敗\nEnd // 程式執行結束\n\nWe need to ensure each line includes code + comment.\n\nAlso maintain proper formatting: use arrow \"→\" for each line. Indent inside loops? We can just use arrow for nested lines. The sample shows indentation by tab? It shows '→ Decision: ...' and nested lines with indentation. We can mimic that.\n\nSo produce final answer with those lines.\n\nMake sure to keep it in Traditional Chinese. Use \"檢查\" etc.\n\nAlso add a \"Start\" and \"End\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別，含 children[26] 與 isEnd 屬性 // Trie 節點結構  \n→ Step 2: 定義 WordDictionary 類別 // 字典類別  \n→ Step 3: WordDictionary() 初始化 root 為 TrieNode // 建構子  \n\n→ Function addWord(word) // 定義新增字的函式  \n → Step 4: current ← root // 開始於根節點  \n → Step 5: For each ch in word // 逐字插入  \n   → Decision: current.children[ch] 存在? // 檢查節點是否已存在  \n    Yes → current ← current.children[ch] // 移動至已存在節點  \n    No  → current.children[ch] ← new TrieNode(); current ← current.children[ch] // 新增節點並移動  \n → Step 6: current.isEnd ← true // 標記字尾  \n\n→ Function search(word) // 定義搜尋函式  \n → Step 7: return dfs(root, word, 0) // 從根開始遞歸搜尋  \n\n→ Function dfs(node, word, idx) // 遞歸搜尋輔助函式  \n  → Decision: idx == len(word)? // 是否到字串尾  \n   Yes → return node.isEnd // 若字尾則匹配成功  \n   No →  \n    → Step 8: ch ← word[idx] // 取得目前字元  \n    → Decision: ch == '.'? // 任意字母  \n     Yes →  \n      → Step 9: for child in node.children // 遍歷所有子節點  \n       → Decision: child != null and dfs(child, word, idx+1)? // 递归检查  \n        Yes → return true // 找到匹配  \n        No  → continue // 继续尝试下一个子节点  \n      → Step 10: return false // 所有子节点都不匹配  \n     No →  \n      → Decision: node.children[ch] 存在? // 是否存在具體字母節點  \n       Yes → return dfs(node.children[ch], word, idx+1) // 递归  \n       No  → return false // 沒有節點，搜尋失敗  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpa1hl36mx.py\", line 33, in <module>\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpoxuoxmhh.py\", line 33, in <module>\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0] if self.min_heap else None\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split the two lists: operations and arguments\n    parts = data.split('],', 1)\n    ops_str = parts[0]\n    args_str = parts[1] if len(parts) > 1 else ''\n    if not ops_str.endswith(']'):\n        ops_str += ']'\n    if not args_str.startswith('['):\n        args_str = '[' + args_str\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"KthLargest\":\n            k, nums = args[i]\n            obj = KthLargest(k, nums)\n            res.append(None)\n        elif op == \"add\":\n            val = args[i][0]\n            res.append(obj.add(val))\n\n    # Convert None to 'null' for output formatting\n    output_parts = []\n    for val in res:\n        if val is None:\n            output_parts.append(\"null\")\n        else:\n            output_parts.append(str(val))\n    print(\"[\" + \", \".join(output_parts) + \"]\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line for a class KthLargest with constructor and add method. Use virtual steps. Use decision structure? We need to explain algorithm: maintain min-heap of size k, or if fewer than k elements, store all. When adding, if heap size < k, push val. Else compare val with heap.top (smallest among k largest). If val > top, pop top and push val. Then return heap.top. Virtual code: Start, initialize variables, etc. Show class structure. Use steps.\n\nNeed to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrow syntax. Use Start, End. Use Decision: and Yes →, No →. So we can outline high-level algorithm.\n\nWe will produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 KthLargest // 建立類別\n→ Step 2: 在類別內宣告變數 k 與 minHeap // 變數儲存 k 與小根堆\n→ Step 3: 實作建構子 KthLargest(k, nums) // 建構子\n    → Step 3.1: 設定 this.k = k // 存儲 k\n    → Step 3.2: 初始化 this.minHeap 為空堆 // 建立堆\n    → Step 3.3: 對於 nums 中每個 val\n        → Decision: 如果 minHeap 大小 < k?\n            Yes → Step 3.3.1: 將 val 推進 minHeap // 直接加入\n            No  → Decision: 如果 val > minHeap.top?\n                Yes → Step 3.3.2: 從 minHeap pop 最小並 push val // 替換\n                No  → Step 3.3.3: 跳過 // 不影響 k 大小\n→ Step 4: 定義方法 add(val) // 加入新分數\n    → Step 4.1: Decision: 如果 minHeap 大小 < k?\n        Yes → Step 4.1.1: 將 val 推進 minHeap // 直接加入\n        No  → Decision: 如果 val > minHeap.top?\n            Yes → Step 4.1.2: pop 最小並 push val // 替換\n            No  → Step 4.1.3: 跳過 // 不影響\n    → Step 4.2: 返回 minHeap.top // 回傳第 k 大\nEnd // 程式執行結束\n\nNeed to ensure each line has \"虛擬碼步驟\" maybe like \"Step\". Use arrows.\n\nMake sure each line ends with \"// 解釋\". No extra spaces. Use arrow symbol \"→\".\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 KthLargest // 建立類別  \n→ Step 2: 宣告變數 k 與 minHeap // 儲存 k 與小根堆  \n→ Step 3: 實作建構子 KthLargest(k, nums) // 初始化  \n    → Step 3.1: 設定 this.k = k // 存儲 k  \n    → Step 3.2: 初始化 this.minHeap 為空堆 // 建立堆  \n    → Step 3.3: 對於 nums 中每個 val  \n        → Decision: 如果 minHeap 大小 < k? // 檢查堆是否已滿  \n            Yes → Step 3.3.1: 將 val 推進 minHeap // 直接加入  \n            No  → Decision: 如果 val > minHeap.top? // 與目前第 k 大比較  \n                Yes → Step 3.3.2: 從 minHeap pop 最小並 push val // 替換  \n                No  → Step 3.3.3: 跳過 // 不影響第 k 大  \n→ Step 4: 定義方法 add(val) // 新分數加入  \n    → Step 4.1: Decision: 如果 minHeap 大小 < k? // 堆還未滿  \n        Yes → Step 4.1.1: 將 val 推進 minHeap // 直接加入  \n        No  → Decision: 如果 val > minHeap.top? // 與目前第 k 大比較  \n            Yes → Step 4.1.2: pop 最小並 push val // 替換  \n            No  → Step 4.1.3: 跳過 // 不影響第 k 大  \n    → Step 4.2: 返回 minHeap.top // 回傳第 k 大  \nEnd // 程式執行結束"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpshhcja87.py\", line 51, in <module>\n    main()\n  File \"/tmp/tmpshhcja87.py\", line 46, in main\n    result = sol.complexNumberMultiply(parts[0], parts[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpshhcja87.py\", line 24, in complexNumberMultiply\n    a_real, a_imag = parse(a)\n                     ^^^^^^^^\n  File \"/tmp/tmpshhcja87.py\", line 21, in parse\n    imag_part = int(s[idx:])  # 包含正負號\n                ^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '+-1'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"將兩個複數字串相乘並回傳字串形式。\"\"\"\n\n        def parse(s: str):\n            \"\"\"把 'real+imaginaryi' 轉成 (real, imaginary) 整數。\"\"\"\n            if not s or s[-1] != 'i':\n                raise ValueError(\"invalid complex number format\")\n            s = s[:-1]  # 去掉結尾的 'i'\n            # 找到實部與虛部的分隔符號 (+ 或 -)，但不要把前面的負號當分隔符號\n            idx = None\n            for i in range(1, len(s)):\n                if s[i] in '+-':\n                    idx = i\n                    break\n            if idx is None:\n                raise ValueError(\"invalid complex number format\")\n            real_part = int(s[:idx])\n            imag_part = int(s[idx:])  # 包含正負號\n            return real_part, imag_part\n\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real = a_real * b_real - a_imag * b_imag\n        imag = a_real * b_imag + a_imag * b_real\n        return f\"{real}+{imag}i\"\n\n\ndef main() -> None:\n    \"\"\"主程式：讀取輸入、計算並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 以逗號分隔兩個複數，並去除可能的空格與雙引號\n    parts = [p.strip() for p in data.split(',')]\n    if len(parts) != 2:\n        # 如果沒有逗號，嘗試以空白分隔\n        parts = data.split()\n    parts = [p[1:-1] if p.startswith('\"') and p.endswith('\"') else p for p in parts]\n\n    sol = Solution()\n    result = sol.complexNumberMultiply(parts[0], parts[1])\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code that takes two complex numbers as strings like \"a+bi\" or \"a-bi\" presumably, but spec says \"real+imaginaryi\". It could be plus sign. We'll assume format real+imaginaryi, where imaginary part may be negative? Could be \"5-3i\". We'll parse. Multiply: (a+bi)*(c+di) = (ac - bd) + (ad + bc)i.\n\nWe need to produce virtual code steps with explanation.\n\nWe need to use arrows, decisions. We'll design steps: Start, Input num1, num2. Parse function: Extract real and imag from string. Use decisions to handle '+' or '-' between real and imaginary. Then compute multiplication. Then format string. End.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 接收兩個複數字串 num1, num2 // 取得輸入\n\n→ Step 2: 解析 num1 為 (a, b) // 取得實部與虛部\n\n→ Step 3: 解析 num2 為 (c, d) // 取得實部與虛部\n\n→ Step 4: 計算實部結果 realRes = a * c - b * d // 乘法實部\n\n→ Step 5: 計算虛部結果 imagRes = a * d + b * c // 乘法虛部\n\n→ Step 6: 轉換結果為字串 result = realRes + (if imagRes >=0 then '+' else '') + imagRes + 'i' // 格式化\n\n→ Step 7: 輸出 result // 回傳結果\n\nEnd // 程式結束\n\nBut we need to include decision steps for parsing: we can break into sub-steps:\n\nStep 2: 解析 num1 為 (a, b)\n\n→ Decision: 如果字串中含 '+'? // 判斷正負\n\n   Yes → Step 2.1: 分割於 '+' → 取得 a, bStr\n\n   No → Step 2.2: 以 '-' 分割 -> 取得 a, bStr，bStr 前加 '-'\n\nSimilar for Step 3.\n\nAlso need to strip trailing 'i'.\n\nWe can include additional steps.\n\nLet's produce more detailed:\n\nStart\n\n→ Step 1: Input num1, num2\n\n→ Step 2: ParseComplex(num1) → (a, b) // 取得 num1 的實部與虛部\n\n→ Step 3: ParseComplex(num2) → (c, d) // 取得 num2 的實部與虛部\n\n→ Step 4: realRes = a * c - b * d\n\n→ Step 5: imagRes = a * d + b * c\n\n→ Step 6: If imagRes >= 0, sign = '+' else sign = ''\n\n→ Step 7: result = realRes + sign + imagRes + 'i'\n\n→ Step 8: Output result\n\nEnd\n\nNow, ParseComplex procedure: Steps inside:\n\nParseComplex(str):\n\n→ Remove trailing 'i'\n\n→ Decision: 如果 str 含 '+'? // 虛部正\n\n   Yes → Split on '+', part1 = realStr, part2 = imagStr\n\n   No  → Decision: 如果 str 含 '-'? // 虛部負\n\n        Yes → Split on '-', but careful first char may be negative real. So we need to find last '-' after first char. Use substeps.\n\n        No → Error.\n\n→ Convert part1 to integer a\n\n→ Convert part2 to integer b\n\n→ Return (a, b)\n\nBut we can summarise as steps.\n\nBut since we output lines, we can include function steps maybe inside Indentation. Use arrows and decisions.\n\nWe need to keep each line separate. Provide explanation.\n\nLet's craft final answer with lines.\n\nEnsure each line has \"虛擬碼步驟\" and \"// 解釋\".\n\nWe'll keep arrow lines with \"→\".\n\nWe'll include steps for ParseComplex procedure. We'll indent or use numbering? Not necessary. We just need sequential lines.\n\nWe must use \"Start\" and \"End\". Also we should use \"Decision:\" lines.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 接收輸入複數字串 num1, num2 // 取得兩個複數字串\n\n→ Step 2: (a, b) = ParseComplex(num1) // 解析第一個複數得到實部 a 與虛部 b\n\n→ Step 3: (c, d) = ParseComplex(num2) // 解析第二個複數得到實部 c 與虛部 d\n\n→ Step 4: realRes = a * c - b * d // 計算乘積的實部\n\n→ Step 5: imagRes = a * d + b * c // 計算乘積的虛部\n\n→ Step 6: Decision: 如果 imagRes >= 0? // 判斷虛部符號\n\n   Yes → Step 7: sign = '+' // 虛部為正，加入正號\n\n   No  → Step 8: sign = '' // 虛部為負，直接顯示負號\n\n→ Step 9: result = realRes + sign + imagRes + 'i' // 組合結果字串\n\n→ Step 10: 輸出 result // 回傳最終複數字串\n\nEnd // 程式結束\n\nNow we need to include ParseComplex definition. Should we include inside? It might be separate steps.\n\nWe can add function definition steps after End? But End marks program end. Instead we can add before Start, or define within.\n\nBetter: Add ParseComplex subroutine lines before Start? But typical pseudo code: function definitions at top.\n\nWe'll produce:\n\nParseComplex(str) // 定義解析函式\n\n→ Step 1: 去除字串最後的 'i' // 去掉 i\n\n→ Decision: 如果 str 含 '+'? // 虛部為正\n\n   Yes → Step 2: [realStr, imagStr] = Split(str, '+') // 分割實虛\n\n   No  → Decision: 如果 str 含 '-'? // 虛部為負\n\n        Yes → Step 3: 找到最後一個 '-' 的位置 idx\n\n        → Step 4: realStr = Substring(str, 0, idx)\n\n        → Step 5: imagStr = Substring(str, idx + 1)\n\n        No → Step 6: error // 無效格式\n\n→ Step 7: real = ToInt(realStr) // 轉換實部\n\n→ Step 8: imag = ToInt(imagStr) // 轉換虛部\n\n→ Step 9: Return (real, imag) // 回傳實虛\n\nBut we need to keep each line separate, with explanation.\n\nThus we need to list ParseComplex steps. Let's create those lines.\n\nWe need to maintain ordering: definitions before main flow.\n\nWe'll produce:\n\nParseComplex(str) // 解析複數字串並回傳實部、虛部\n\n→ Step 1: str = RemoveTrailingI(str) // 刪除字串末尾的 'i'\n\n→ Decision: 如果 str 含 '+'? // 虛部正號\n\n   Yes → Step 2: realStr, imagStr = SplitAtFirstPlus(str) // 分割實部與虛部\n\n   No  → Decision: 如果 str 含 '-'? // 虛部負號\n\n        Yes → Step 3: idx = FindLastMinus(str) // 找到最後一個 '-' 位置\n\n        → Step 4: realStr = Substring(str, 0, idx) // 取得實部\n\n        → Step 5: imagStr = Substring(str, idx + 1) // 取得虛部\n\n        No → Step 6: Error('Invalid format') // 格式錯誤\n\n→ Step 7: real = ToInt(realStr) // 轉為整數\n\n→ Step 8: imag = ToInt(imagStr) // 轉為整數\n\n→ Step 9: Return (real, imag) // 回傳解析結果\n\nNow we need to integrate these before the main Start. We'll output each line accordingly.\n\nBe careful about arrow \"→\" and \"Decision:\".\n\nAlso maintain that each line has a virtual code step and comment.\n\nLet's produce final answer.\n...done thinking.\n\nParseComplex(str) // 解析複數字串並回傳實部、虛部  \n→ Step 1: str = RemoveTrailingI(str) // 刪除字串末尾的 'i'  \n→ Decision: 如果 str 含 '+'? // 虛部為正號  \n   Yes → Step 2: realStr, imagStr = SplitAtFirstPlus(str) // 分割實部與虛部  \n   No  → Decision: 如果 str 含 '-'? // 虛部為負號  \n        Yes → Step 3: idx = FindLastMinus(str) // 找到最後一個 '-' 位置  \n        → Step 4: realStr = Substring(str, 0, idx) // 取得實部  \n        → Step 5: imagStr = Substring(str, idx + 1) // 取得虛部  \n        No → Step 6: Error('Invalid format') // 格式錯誤  \n→ Step 7: real = ToInt(realStr) // 轉為整數  \n→ Step 8: imag = ToInt(imagStr) // 轉為整數  \n→ Step 9: Return (real, imag) // 回傳解析結果  \n\nStart // 程式開始執行  \n→ Step 1: 接收輸入複數字串 num1, num2 // 取得兩個複數字串  \n→ Step 2: (a, b) = ParseComplex(num1) // 解析第一個複數得到實部 a 與虛部 b  \n→ Step 3: (c, d) = ParseComplex(num2) // 解析第二個複數得到實部 c 與虛部 d  \n→ Step 4: realRes = a * c - b * d // 計算乘積的實部  \n→ Step 5: imagRes = a * d + b * c // 計算乘積的虛部  \n→ Step 6: Decision: 如果 imagRes >= 0? // 判斷虛部符號  \n   Yes → Step 7: sign = '+' // 虛部為正，加入正號  \n   No  → Step 8: sign = '' // 虛部為負，直接顯示負號  \n→ Step 9: result = realRes + sign + imagRes + 'i' // 組合結果字串  \n→ Step 10: 輸出 result // 回傳最終複數字串  \nEnd // 程式結束執行"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[3]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[3]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[3,7]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[3,7]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[3,6,8]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[3,6,8]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\n# 假設已經有一個 API rand7() 可用\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"利用兩次 rand7 產生 1~49 的等機率數，映射至 1~10，若超過 40 則重試。\"\"\"\n        while True:\n            # 兩次 rand7 產生 1~49 的等機率數\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                # 1~40 可映射為 1~10\n                return 1 + (num - 1) % 10\n\ndef main():\n    # 讀取整行輸入，並從中提取整數 n\n    raw_input = sys.stdin.read().strip()\n    match = re.search(r'\\d+', raw_input)\n    if not match:\n        return\n    n = int(match.group())\n\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n\n    # 按要求格式化輸出，無空格\n    output = '[' + ','.join(str(x) for x in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps, not actual code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows, Decision. Should implement rand10 using rand7. Classic approach: generate 2 random 1-7 to get 1-49 uniform. Use 1-40 to map to 1-10 via modulo. Reject 41-49. Or generate base-7 digits. We'll produce stepwise algorithm: repeat until get result. Use loops. We'll use Decision: if x <= 40? etc.\n\nWe must produce \"Start\" and \"End\" and each step. Provide explanation after each line.\n\nLet's outline:\n\nStart\n\n→ Step 1: repeat\n\n    -> Step 1.1: Call rand7() → r1\n\n    -> Step 1.2: Call rand7() → r2\n\n    -> Step 1.3: Compute combined = (r1-1)*7 + r2   // yields 1-49\n\n    -> Decision: if combined <= 40? // Acceptable range\n\n        Yes → Step 1.4: Return ((combined-1) mod 10) + 1 // map to 1-10\n\n        No  → Step 1.5: Go back to Step 1 (restart loop)\n\nEnd\n\nWe also may show while loop representation:\n\n→ Decision: 是否得到合法數字? // loop condition\n\nBut the above is enough. Provide each line with explanation.\n\nNeed to format with \"虛擬碼步驟 // 解釋\". Use arrow and indentation. Provide explanation inline.\n\nAlso maybe include comments like \"//\".\n\nLet's produce.\n\nMake sure each line ends with // explanation.\n\nWill show indentation with spaces.\n\nUse \"→\" arrow.\n\nAlso include \"Start // 程式開始執行\" and \"End // 程式結束\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 重複執行以下步驟直到得到合法結果 // 循環直到產生有效數字  \n  → Step 1.1: r1 ← rand7() // 取得第一個 1~7 的隨機數  \n  → Step 1.2: r2 ← rand7() // 再取得第二個 1~7 的隨機數  \n  → Step 1.3: combined ← (r1 − 1) × 7 + r2 // 將兩個數合併得到 1~49 的等機率數  \n  → Decision: 如果 combined ≤ 40? // 只接受前 40 個數字（可映射為 1~10）  \n   Yes → Step 1.4: return ((combined − 1) mod 10) + 1 // 轉換為 1~10 的均勻隨機數  \n   No  → Step 1.5: goto Step 1 // 超過 40 的數字視為失敗，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def reverse(self, x: int) -> int:\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        rev = 0\n\n        while x != 0:\n            # 取得最後一位，正負號保持一致\n            if x >= 0:\n                pop = x % 10\n            else:\n                pop = -((-x) % 10)\n            x //= 10\n\n            # 檢查乘 10 會不會溢位\n            if rev > INT_MAX // 10 or rev < INT_MIN // 10:\n                return 0\n            if rev == INT_MAX // 10 and pop > 7:\n                return 0\n            if rev == INT_MIN // 10 and pop < -8:\n                return 0\n\n            rev = rev * 10 + pop\n\n        return rev\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 從輸入中尋找第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        sys.exit(0)\n    x = int(match.group())\n    result = Solution().reverse(x)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code for reversing digits of a 32-bit signed integer, detect overflow without using 64-bit. Must produce step-by-step pseudocode. Use arrows. Ensure each line has \"虛擬碼步驟 // 解釋\". Use Start End Decision etc. Also include steps for computing reversed number by repeated pop/push. Use 32-bit operations. For overflow check: before pushing new digit, check if current result will overflow. For 32-bit signed range: [-2^31, 2^31-1] = [-2147483648, 2147483647]. Standard algorithm: \nrev=0\nwhile x != 0:\n    pop = x % 10  (but careful with negative).\n    x /= 10\n    if rev > INT_MAX/10 or rev < INT_MIN/10: return 0\n    if rev == INT_MAX/10 and pop > 7: return 0\n    if rev == INT_MIN/10 and pop < -8: return 0\n    rev = rev * 10 + pop\n\nBut cannot use 64-bit. We must avoid overflow detection using 32-bit arithmetic. Use division by 10 and multiplication by 10, with check as above.\n\nAlso we need to handle negative properly. Use sign of x.\n\nOk produce pseudocode lines. Ensure each line has arrow and explanation. Use Step numbers? maybe not necessary but can. We need \"虛擬碼步驟\" + space + \"// 解釋\". The format examples show \"Start\" \"→ Step 1:\" etc. So we will replicate.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 設定 INT_MAX = 2147483647 // 最大正整數\n→ Step 2: 設定 INT_MIN = -2147483648 // 最小負整數\n→ Step 3: 設定 rev = 0 // 逆序結果暫存\n→ Step 4: While x ≠ 0 // 逐位處理\n    → Step 4.1: pop = x % 10 // 取最後一位\n    → Step 4.2: x = x / 10 // 去除已取位\n    → Decision: 檢查 rev 乘 10 會不會溢位?\n        Yes → Step 4.3: return 0 // 超過範圍\n        No  → ...\n    etc.\n\nWe need to use 32-bit operations only. In pseudocode, division and modulo produce integer.\n\nWe also need to check if rev > INT_MAX/10 etc. Provide that logic.\n\nAlso handle negative rev and pop.\n\nOk produce.\n\nLet's craft.\n\nWe need to ensure each line after arrow includes explanation. Provide indentation? The example uses indentation for nested steps. We'll mimic.\n\nMake sure each line ends with \"// 解釋\".\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 INT_MAX = 2147483647 // 32 位正整數上限  \n→ Step 2: 設定 INT_MIN = -2147483648 // 32 位負整數下限  \n→ Step 3: 設定 rev = 0 // 逆序暫存器，初始為 0  \n→ Step 4: While x ≠ 0 // 循環處理每一位  \n → Step 4.1: pop = x % 10 // 取得目前最後一位（負數也可用）  \n → Step 4.2: x = x / 10 // 移除已處理的位  \n → Decision: rev 是否能安全乘 10 而不溢? // 檢查乘法前的安全性  \n  Yes → Step 4.3: // 若安全，進行後續檢查  \n   → Decision: rev > INT_MAX/10? // 正數超限前置檢查  \n    Yes → Step 4.4: return 0 // 超過上限，直接返回 0  \n    No  → Decision: rev == INT_MAX/10 且 pop > 7? // 末位進位造成溢出  \n     Yes → Step 4.5: return 0 // 末位大於 7 時溢出  \n     No  → Decision: rev < INT_MIN/10? // 負數超限前置檢查  \n      Yes → Step 4.6: return 0 // 超過下限，返回 0  \n      No  → Decision: rev == INT_MIN/10 且 pop < -8? // 末位進位造成溢出  \n       Yes → Step 4.7: return 0 // 末位小於 -8 時溢出  \n       No  → Step 4.8: rev = rev * 10 + pop // 安全累加最後一位  \n  No  → Step 4.9: // 若乘 10 會溢位直接返回 0  \n    → return 0  \n→ Step 5: return rev // 所有位處理完成，返回逆序結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpajfnqljn.py\", line 64, in <module>\n    main()\n  File \"/tmp/tmpajfnqljn.py\", line 40, in main\n    data = json.loads(sys.stdin.read())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 47 (char 46)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]  # copy original array\n        # Binary Indexed Tree (Fenwick Tree)\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._add(i + 1, nums[i])\n\n    def _add(self, i, val):\n        \"\"\"Internal helper to add val at position i in BIT (1‑based).\"\"\"\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        \"\"\"Update element at index to val.\"\"\"\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        \"\"\"Return sum of elements from left to right inclusive.\"\"\"\n        return self._prefix(right + 1) - self._prefix(left)\n\n    def _prefix(self, i):\n        \"\"\"Internal helper to compute prefix sum up to i (1‑based).\"\"\"\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\n\ndef main():\n    # Read entire stdin and parse as JSON\n    data = json.loads(sys.stdin.read())\n    commands, args_list = data[0], data[1]\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"NumArray\":\n            obj = NumArray(args[0])\n            result.append(None)\n        elif cmd == \"update\":\n            obj.update(*args)\n            result.append(None)\n        elif cmd == \"sumRange\":\n            res = obj.sumRange(*args)\n            result.append(res)\n        else:\n            # In case of unknown command, append None\n            result.append(None)\n\n    # Output the results list, converting None to null via json\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanation. The pseudocode should represent the design of NumArray class with constructor, update, sumRange. Use virtual code with arrows, decisions. We need to cover internal data structure. Use maybe segment tree or Fenwick tree. Simpler: use binary indexed tree. Let's produce steps. We need to handle multiple queries. So algorithm: Build BIT from nums. Update: update BIT. Query sumRange: prefix sum difference. Provide pseudocode accordingly. Provide step-by-step.\n\nWe need to use the arrow syntax and indentation. Each line should be \"虛擬碼步驟 // 解釋\". Use Start, End.\n\nMake sure to follow formatting: each line must be \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's craft.\n\nStart // 程式開始執行\n→ Initialize: 建立 NumArray 物件 // 開始建構物件\n    → Step 1: 保存 nums 長度 n // 記錄陣列大小\n    → Step 2: 建立 BIT 陣列 bit[1..n] // 建立 Binary Indexed Tree\n    → Step 3: 對每個索引 i 從 1 到 n\n        → Step 3.1: 將 nums[i-1] 加入 BIT[i] // 將原始值加入 BIT\n        → Step 3.2: parent = i + (i & -i) // 計算父節點\n        → Decision: parent <= n?\n            Yes → Step 3.3: bit[parent] += bit[i] // 把子節點值累加到父節點\n            No  → Skip // 結束\nEnd // 完成建構\n\nStart // 更新方法\n→ Function update(index, val)\n    → Step 1: 差值 delta = val - nums[index] // 計算要調整的差值\n    → Step 2: nums[index] = val // 更新原始陣列\n    → Step 3: i = index + 1 // BIT 使用 1 基索引\n    → Decision: i <= n?\n        Yes → Step 4: bit[i] += delta // 更新 BIT 位置\n            → i += i & -i // 移動到下一個需要更新的節點\n            → Repeat Decision\n        No  → Skip // 更新完成\nEnd // 更新結束\n\nStart // sumRange 方法\n→ Function sumRange(left, right)\n    → Step 1: sumRight = prefixSum(right) // 計算前綴和\n    → Step 2: sumLeft = prefixSum(left - 1) // 計算前綴和\n    → Step 3: return sumRight - sumLeft // 取差得到區間和\nEnd // sumRange 結束\n\nStart // 前綴和輔助函式\n→ Function prefixSum(idx)\n    → Step 1: result = 0\n    → Step 2: i = idx + 1 // 轉為 1 基\n    → Decision: i > 0?\n        Yes → Step 3: result += bit[i] // 加入 BIT 值\n            → i -= i & -i // 移動到上一個節點\n            → Repeat Decision\n        No  → Skip\n    → Step 4: return result\nEnd // 前綴和結束\n\nEnd // 程式結束\n\nEnsure each line contains the arrow. Provide indentation maybe with tabs? It's okay.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize: 建立 NumArray 物件 // 開始建構物件\n    → Step 1: 保存 nums 長度 n // 記錄陣列大小\n    → Step 2: 建立 BIT 陣列 bit[1..n] // 建立 Binary Indexed Tree\n    → Step 3: 對每個索引 i 從 1 到 n\n        → Step 3.1: 將 nums[i-1] 加入 BIT[i] // 將原始值加入 BIT\n        → Step 3.2: parent = i + (i & -i) // 計算父節點\n        → Decision: parent <= n?\n            Yes → Step 3.3: bit[parent] += bit[i] // 把子節點值累加到父節點\n            No  → Skip // 結束\nEnd // 完成建構\n\nStart // 更新方法\n→ Function update(index, val)\n    → Step 1: 差值 delta = val - nums[index] // 計算要調整的差值\n    → Step 2: nums[index] = val // 更新原始陣列\n    → Step 3: i = index + 1 // BIT 使用 1 基索引\n    → Decision: i <= n?\n        Yes → Step 4: bit[i] += delta // 更新 BIT 位置\n            → i += i & -i // 移動到下一個需要更新的節點\n            → Repeat Decision\n        No  → Skip // 更新完成\nEnd // 更新結束\n\nStart // sumRange 方法\n→ Function sumRange(left, right)\n    → Step 1: sumRight = prefixSum(right) // 計算前綴和\n    → Step 2: sumLeft = prefixSum(left - 1) // 計算前綴和\n    → Step 3: return sumRight - sumLeft // 取差得到區間和\nEnd // sumRange 結束\n\nStart // 前綴和輔助函式\n→ Function prefixSum(idx)\n    → Step 1: result = 0\n    → Step 2: i = idx + 1 // 轉為 1 基\n    → Decision: i > 0?\n        Yes → Step 3: result += bit[i] // 加入 BIT 值\n            → i -= i & -i // 移動到上一個節點\n            → Repeat Decision\n        No  → Skip\n    → Step 4: return result\nEnd // 前綴和結束\n\nEnd // 程式結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcp55mgw3.py\", line 34, in <module>\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        i = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if i == 0:\n            return \"\"\n        return arr[i - 1][1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Parse the input string which contains two lists separated by a comma.\n    # Example format: '[\"TimeMap\", \"set\", ...], [[], [\"foo\", \"bar\", 1], ...]'\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = '[' + parts[1]\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    output = []\n\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            output.append(None)\n        elif op == \"set\":\n            obj.set(*arg)\n            output.append(None)\n        elif op == \"get\":\n            val = obj.get(*arg)\n            output.append(val)\n\n    print(json.dumps(output))",
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode lines with explanations. The user wants design of time-based key-value data structure, with class TimeMap, with set and get. Use virtual code.\n\nWe should produce lines: Start, initialize data structure: e.g., a dictionary mapping key to list of (timestamp,value) sorted by timestamp. Then for set: append to list. For get: binary search to find largest timestamp <= target.\n\nWe need to produce step-by-step algorithm.\n\nLet's create steps: Start → Initialize data structure → set function → get function → End.\n\nUse arrow syntax: \"→ Step: ...\".\n\nUse Decision nodes for binary search: \"Decision: 是否存在 timestamp_prev <= timestamp?\" etc.\n\nWe need to provide each line of virtual code with comment explanation.\n\nWe must adhere to format: \"虛擬碼步驟 [空格] // 解釋\".\n\nAlso use arrow symbols like \"→\" or \"Yes →\", \"No →\".\n\nOk produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化 TimeMap // 建立空字典 mapping key -> list\n\n→ Step 2: set(key, value, timestamp) // 設定值\n\n    → Append (timestamp, value) to list for key // 保持升序\n\n→ Step 3: get(key, timestamp) // 取得值\n\n    → Decision: key 是否存在? // 若不存在直接回 \"\"\n\n        Yes → Step 3.1: list = mapping[key] // 取得該 key 的時間列表\n\n            → BinarySearch(list, timestamp) // 找最接近且 <= timestamp 的索引\n\n            → Decision: 索引是否有效? // 若無有效值回 \"\"\n\n                Yes → Step 3.2: 返回 list[index].value // 最大 timestamp 的 value\n\n                No  → Step 3.3: 返回 \"\" // 無符合\n\n        No  → Step 3.4: 返回 \"\" // key 沒有任何紀錄\n\nEnd // 程式結束\n\nBut need more detailed lines for binary search: maybe steps inside: left, right, while loop. But maybe just high-level.\n\nWe need \"逐行\" produce each line. Could split into lines like:\n\nStart // 程式開始\n\n→ Step 1: TimeMap = new Map() // 初始化\n\n→ Step 2: set(key, value, timestamp)\n\n    → 如果 key 未在 Map 中，初始化 list\n\n    → Append (timestamp, value) 到 list // 由於 timestamp 並非隨機，若需要排序，可插入保持升序\n\n→ Step 3: get(key, timestamp)\n\n    → Decision: key 是否存在?\n\n        Yes → Step 3.1: list = Map[key] // 取得\n\n            → Decision: list 为空? // 若为空直接返回 \"\"\n\n            Yes → Step 3.1a: 返回 \"\"\n\n            No  → Step 3.1b: left=0, right=length-1\n\n                → While left <= right\n\n                    → mid = (left+right)//2\n\n                    → Decision: list[mid].timestamp <= timestamp\n\n                        Yes → left = mid + 1 // 记录候选\n\n                        No  → right = mid - 1\n\n                → Decision: right < 0? // 无合适\n\n                    Yes → Step 3.1c: 返回 \"\"\n\n                    No  → Step 3.1d: 返回 list[right].value\n\n        No  → Step 3.2: 返回 \"\"\n\nEnd\n\nThis is more detailed. Each line with comment.\n\nMake sure arrow syntax correct. Use \"→\", \"Yes →\", \"No →\". Indent maybe by spaces but each line must start with the virtual code step then comment.\n\nWe can include indentation but each line is separate. Provide each step. Let's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: TimeMap = new Map() // 初始化時間鍵值儲存結構\n→ Step 2: set(key, value, timestamp) // 定義 set 方法\n    → Decision: key 是否存在於 TimeMap? // 檢查是否已有此 key\n        Yes → Step 2.1: list = TimeMap[key] // 取得已存在的時間列表\n        No  → Step 2.2: list = [] // 新建空列表\n            → TimeMap[key] = list // 將新列表存入 Map\n    → Step 2.3: list.append((timestamp, value)) // 把 (時間,值) 加到列表\n→ Step 3: get(key, timestamp) // 定義 get 方法\n    → Decision: key 是否存在於 TimeMap? // 若沒有 key 直接回 \"\"\n        Yes → Step 3.1: list = TimeMap[key] // 取得該 key 的時間列表\n            → Decision: list 為空? // 若列表為空回 \"\"\n                Yes → Step 3.1a: return \"\" // 無任何記錄\n                No  → Step 3.1b: left = 0; right = len(list) - 1 // 準備二分搜尋\n                    → While left <= right // 二分搜尋尋找最大 <= timestamp\n                        → mid = (left + right) // 2\n                        → Decision: list[mid].timestamp <= timestamp\n                            Yes → left = mid + 1 // 仍可往右搜尋，並記錄候選\n                            No  → right = mid - 1 // 向左搜尋\n                    → Decision: right < 0? // 是否找不到合法時間\n                        Yes → Step 3.1c: return \"\" // 無符合的 timestamp\n                        No  → Step 3.1d: return list[right].value // 取得最接近且 <= timestamp 的值\n        No  → Step 3.2: return \"\" // key 不存在\nEnd // 程式結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,1,1,5,4,6]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 1, 1, 5, 4, 6]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,2,1,3,2,3]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 2, 1, 3, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef wiggleSort(nums):\n    \"\"\"\n    Rearranges the list so that nums[0] < nums[1] > nums[2] < nums[3] ...\n    This implementation sorts the list first and then swaps each\n    pair of adjacent elements starting from index 1.\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    for i in range(1, n, 2):\n        if i + 1 < n:\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n\nif __name__ == \"__main__\":\n    # Read the whole input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Find the first '[' and the last ']' to isolate the list literal\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        raise ValueError(\"Input does not contain a list literal.\")\n\n    list_literal = data[start:end + 1]\n    try:\n        nums = ast.literal_eval(list_literal)\n    except Exception as e:\n        raise ValueError(\"Failed to parse list: \" + str(e))\n\n    # Ensure the parsed object is a list of integers\n    if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums):\n        raise ValueError(\"Parsed data is not a list of integers.\")\n\n    # Perform wiggle sort\n    result = wiggleSort(nums)\n\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for wiggle sort. Steps: We can sort array and then swap adjacent pairs starting from 1. But simpler: for i from 1 to n-1, if i%2==1 then nums[i] > nums[i-1] else nums[i] < nums[i-1]. Use sorting to guarantee. Approach: sort nums. Then for i=1; i<n; i+=2, swap nums[i] and nums[i+1] if i+1 < n. This yields wiggle. Provide virtual code line by line with comments.\n\nWe must follow format: each line \"虛擬碼步驟 // 解釋\". Use Start End, Decision: etc.\n\nLet's craft:\n\nStart\n→ Step 1: 取得輸入陣列 nums // 輸入整數陣列\n→ Step 2: 對 nums 進行升序排序 // 使元素有序\n→ Decision: 是否有偶數個元素? // 判斷是否有尾端元素可交換\n    Yes → Step 3: 為 i = 1 迭代至 n-1，每 2 步\n        → Step 4: 如果 i+1 < n，交換 nums[i] 與 nums[i+1] // 交換相鄰奇偶位置\n        → Step 5: i ← i + 2\n    No  → Step 3: 為 i = 1 迭代至 n-2，每 2 步\n        → Step 4: 如果 i+1 < n，交換 nums[i] 與 nums[i+1]\n        → Step 5: i ← i + 2\n→ Step 6: 輸出修改後的 nums // 結果\nEnd\n\nBut we need each line with a single virtual code step. The decision block may be separate lines. Use indentation? The example shows indentation with tab or spaces. We'll produce similar.\n\nMake sure each line has // comment. Use \"Start\" \"End\" steps. Use arrow for transitions. We must keep each line separate. Let's produce.\n\nAlso need to ensure each line uses arrow \"→\" or \"Yes →\" \"No →\". For decision we can write \"Decision: 如果有偶數個元素?\" and then indent Yes / No.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 取得待處理的整數陣列\n→ Step 2: 對 nums 進行升序排序 // 使元素有序，便於後續交換\n→ Decision: nums 的長度是否為偶數? // 判斷是否存在尾端偶數索引\n    Yes → Step 3: 令 i ← 1 // 開始於索引 1（第一個奇數位置）\n    No  → Step 3: 令 i ← 1 // 同樣從索引 1 開始，因為交換不受偶數/奇數影響\n→ Step 4: Decision: i < nums.length ? // 迴圈條件，直到遍歷完所有元素\n        Yes → Step 5: Decision: i + 1 < nums.length ? // 確保有相鄰元素可交換\n                Yes → Step 6: 交換 nums[i] 與 nums[i + 1] // 交換奇偶位置，形成 \"< >\" 形態\n                No  → Step 7: 跳過 // 沒有相鄰元素，無需交換\n        No  → Step 8: 跳出迴圈 // 所有元素已處理\n→ Step 9: i ← i + 2 // 以 2 為步長，跳到下一個奇數索引\n→ Step 10: 迴圈回到 Step 4 // 重複檢查條件並交換\n→ Step 11: 輸出 nums // 顯示已重新排序的陣列\nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[6.00000,0.50000,-1.00000,1.00000,-1.00000]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[6.00000,0.50000,-1.00000,1.00000,-1.00000]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3.75000,0.40000,5.00000,0.20000]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[3.75000,0.40000,5.00000,0.20000]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0.50000,2.00000,-1.00000,-1.00000]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0.50000,2.00000,-1.00000,-1.00000]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor in visited:\n                    continue\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef parse_list_from_string(s, var_name):\n    idx = s.find(var_name + '=')\n    if idx == -1:\n        return None\n    start = s.find('[', idx)\n    if start == -1:\n        return None\n    depth = 0\n    for i in range(start, len(s)):\n        if s[i] == '[':\n            depth += 1\n        elif s[i] == ']':\n            depth -= 1\n            if depth == 0:\n                end = i\n                break\n    return ast.literal_eval(s[start:end+1])\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    equations = parse_list_from_string(data, 'equations')\n    values = parse_list_from_string(data, 'values')\n    queries = parse_list_from_string(data, 'queries')\n    if equations is None or values is None or queries is None:\n        print('[]')\n        return\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n    output = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode step-by-step to solve the problem: evaluate division queries given equations with ratios. This is typical graph with union find or DFS. Provide pseudocode lines with explanations. Each line ends with // explanation. Use arrows, decision etc.\n\nWe need to structure steps: Build graph, DFS to find ratio, handle queries. Also handle unknown variables.\n\nLet's produce: Start, build adjacency list, for each query, check presence, if missing, answer -1.0, else DFS or BFS to find ratio path.\n\nWe need to produce step by step with explanation. Each line includes arrow: \"→\" preceding step or \"Start\", \"End\". Decision lines use \"Decision:\". Use Yes → and No →.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化鄰接表 graph // 建立變量之間的比值圖\n→ Step 2: 逐一處理 equations 和 values，將每條方程加入 graph // 將 Ai/Bi = v 轉成邊 Ai→Bi(v) 及 Bi→Ai(1/v)\n→ Decision: 是否有需要處理的 query? // 檢查 queries 是否非空\n...\n\nBut we can produce more steps.\n\nWe need to produce code lines until End.\n\nLet's craft maybe 20-30 lines.\n\nWe need to ensure each line contains \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nUse arrows: \"→\" for normal step, \"Decision:\" for condition.\n\nExample: \"→ Step 3: 設定答案陣列 result = 空陣列 // 用於儲存每個查詢結果\".\n\nWhen DFS: \"→ Function: DFS(node, target, acc, visited)\" but we can express as Step.\n\nBetter to produce substeps: \"→ Function DFS(current, target, product, visited)\".\n\nBut since we must output step lines, we can include function definitions as steps: \"→ Function DFS(current, target, product, visited) // 定義遞迴搜尋\" etc.\n\nHowever, we may not need to dive into recursion detail.\n\nSimplify: \"→ Step 4: 對於每個查詢 (Cj, Dj)，若 Cj 或 Dj 不在 graph，將 -1.0 加入 result\" etc.\n\n\"→ Step 5: 否則執行 DFS 從 Cj 到 Dj，若找到路徑，將乘積加入 result，否則 -1.0\".\n\nWe need to handle visited set.\n\nWe can express DFS as step \"→ Step 6: DFS(curr, target, acc, visited) // 尋找路徑\".\n\nBut maybe too granular.\n\nThe instructions: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋\" So we should produce line per step.\n\nLet's produce a decent pseudocode flow.\n\nLet's list steps:\n\n1. Start\n2. Build graph\n3. For each query: if missing variable => -1.0\n4. Else: DFS\n5. DFS function\n6. End\n\nWe need to use \"Decision:\" arrow lines with Yes→ and No→ for branching.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: graph ← 空字典 // 用於儲存變量之間的比值\n→ Step 2: 迭代 i in 0..len(equations)-1\n    → Step 3: a ← equations[i][0]; b ← equations[i][1]; v ← values[i]\n    → Step 4: graph[a] ← graph[a] ∪ {(b, v)} // 加入 a→b 的比值\n    → Step 5: graph[b] ← graph[b] ∪ {(a, 1/v)} // 加入 b→a 的逆比值\n→ Step 6: result ← 空列表 // 儲存查詢答案\n→ Step 7: 迭代每個查詢 (c, d) in queries\n    → Decision: 是否 c 或 d 不在 graph? // 檢查是否已知變量\n        Yes → Step 8: result.append(-1.0) // 未定義，答案 -1.0\n        No  → Step 9: 設 visited ← 空集合\n               → Step 10: ratio ← DFS(c, d, 1.0, visited) // 執行 DFS 找比值\n               → Decision: ratio 為 None? // 無路徑\n                   Yes → Step 11: result.append(-1.0) // 路徑不存在，答案 -1.0\n                   No  → Step 12: result.append(ratio) // 找到比值，加入答案\n→ Step 13: 返回 result // 輸出所有查詢答案\nEnd // 程式執行結束\n\nNow we need to write DFS function separately.\n\nBut inside the pseudocode we can include function definition earlier. Let's insert before queries.\n\nAdd:\n\n→ Step 5: 定義函數 DFS(node, target, acc, visited)\n    → Decision: node == target? // 到達目標\n        Yes → Step 6: 返回 acc // 成功，返回累積比值\n        No  → visited.add(node) // 標記已訪問\n               → 迭代 (neighbor, weight) in graph[node]\n                  → Decision: neighbor 是否在 visited? // 避免循環\n                      Yes → 省略\n                      No  → Step 7: 結果 ← DFS(neighbor, target, acc * weight, visited)\n                            → Decision: 結果 是否為 None? // 未找到路徑\n                                Yes → 省略\n                                No  → 返回 結果 // 路徑找到\n               → 返回 None // 所有鄰居都無路徑\n\nBut we must keep line numbering consistent. Maybe restructure: after graph build, before queries we define DFS.\n\nLet's rewrite entire pseudocode properly.\n\nWe need to ensure each line has \"虛擬碼步驟\" plus explanation.\n\nLet's produce step list with numbers maybe not required, but each line.\n\nBetter to include line numbers? Not needed.\n\nLet's produce final answer with lines.\n\nAlso note that we need to use \"→\" for normal step; for function definitions, we can just use arrow. For decision we use \"Decision:\" etc.\n\nLet's produce.\n\nPotential pitfalls: The DFS function uses recursion; we can define it as step lines. Provide explanation.\n\nOk produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: graph ← 空字典 // 用於儲存每個變量及其相鄰變量與比值  \n→ Step 2: 迭代 i 在 0 .. len(equations)-1  \n    → Step 3: a ← equations[i][0]；b ← equations[i][1]；v ← values[i] // 取得方程的兩變量與比值  \n    → Step 4: graph[a] ← graph[a] ∪ {(b, v)} // 加入 a → b 的比值邊  \n    → Step 5: graph[b] ← graph[b] ∪ {(a, 1/v)} // 加入 b → a 的逆比值邊  \n→ Step 6: 定義函數 DFS(node, target, acc, visited) // 遞迴尋找從 node 到 target 的累積比值  \n    → Decision: node == target? // 判斷是否已到達目標  \n        Yes → Step 7: 返回 acc // 成功，返回目前累積的比值  \n        No  → Step 8: visited.add(node) // 標記目前節點已訪問  \n             → 迭代 (nei, w) 在 graph[node]  \n                 → Decision: nei 在 visited? // 防止循環  \n                     Yes → Step 9: 省略 // 跳過已訪問的鄰居  \n                     No  → Step 10: res ← DFS(nei, target, acc * w, visited) // 進一步遞迴  \n                         → Decision: res 為 None? // 沒有找到路徑  \n                             Yes → Step 11: 省略 // 繼續搜尋其他鄰居  \n                             No  → Step 12: 返回 res // 找到路徑，直接返回比值  \n    → Step 13: 返回 None // 所有鄰居都無路徑，回傳 None  \n→ Step 14: result ← 空列表 // 用於儲存每個查詢的答案  \n→ Step 15: 迭代每個查詢 (c, d) 在 queries  \n    → Decision: c 或 d 不在 graph? // 檢查變量是否已知  \n        Yes → Step 16: result.append(-1.0) // 未定義，答案為 -1.0  \n        No  → Step 17: visited ← 空集合 // 初始化訪問集合  \n             → Step 18: ratio ← DFS(c, d, 1.0, visited) // 從 c 開始尋找 d  \n             → Decision: ratio 為 None? // 無路徑  \n                 Yes → Step 19: result.append(-1.0) // 路徑不存在，答案為 -1.0  \n                 No  → Step 20: result.append(ratio) // 找到比值，加入答案  \n→ Step 21: 返回 result // 輸出所有查詢答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Integer to English Words",
      "source_file": "Leetcode/leetcode273.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'TwelveThousandThreeHundredFortyFive'\nGot (Norm):      'OneMillionTwoThousandThreeHundredFortyFive'\n--- (Raw) ---\nRaw Expected: '\"Twelve Thousand Three Hundred Forty Five\"'\nRaw Got:      '\"One Million Two Thousand Three Hundred Forty Five\"'"
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'OneMillionTwoHundredThirtyFourThousandFiveHundredSixtySeven'\nGot (Norm):      'OneHundredTwentyThreeMillionFourThousandFiveHundredSixtySeven'\n--- (Raw) ---\nRaw Expected: '\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"'\nRaw Got:      '\"One Hundred Twenty Three Million Four Thousand Five Hundred Sixty Seven\"'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            switcher = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\",\n                        \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n            return switcher[n]\n\n        def two_less_20(n: int) -> str:\n            switcher = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\",\n                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return switcher[n - 10]\n\n        def ten(n: int) -> str:\n            switcher = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n                        \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return switcher[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            if n < 10:\n                return one(n)\n            if n < 20:\n                return two_less_20(n)\n            tens, rest = divmod(n, 10)\n            return ten(tens) + (\" \" + one(rest) if rest else \"\")\n\n        def three(n: int) -> str:\n            hundred, rest = divmod(n, 100)\n            if hundred and rest:\n                return one(hundred) + \" Hundred \" + two(rest)\n            if not hundred and rest:\n                return two(rest)\n            if hundred and not rest:\n                return one(hundred) + \" Hundred\"\n            return \"\"\n\n        billion = num // 1_000_000_000\n        million = (num % 1_000_000_000) // 1_000_0\n        thousand = (num % 1_000_0) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion:\n            parts.append(three(billion) + \" Billion\")\n        if million:\n            parts.append(three(million) + \" Million\")\n        if thousand:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest:\n            parts.append(three(rest))\n\n        return \" \".join(parts)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract the first integer found in the input\n    match = re.search(r\"-?\\d+\", data)\n    if match:\n        num = int(match.group())\n    else:\n        num = 0\n\n    sol = Solution()\n    result = sol.numberToWords(num)\n    # Output with surrounding double quotes as shown in the examples\n    print(f'\"{result}\"')",
      "virtual_code": "Thinking...\nThe user wants a virtual code for converting a non-negative integer to English words representation. Provide step-by-step pseudocode, line by line with explanations. Should use Start, End, Decision, arrow syntax. Should not output actual code. Let's think: Steps: start, if num==0 output \"Zero\". else: initialize arrays for below_20, tens, thousands. Define function convert(num) recursively: if num<20 return arr. else if num<100 return tens + convert(num%10). else if num<1000 return below_20[num//100]+\" Hundred\"+(if remainder>0 \" \"+convert(remainder)). Else for thousand groups: iterate over [(\"Billion\",\"1000000000\"), (\"Million\",\"1000000\"), (\"Thousand\",\"1000\")]. For each: if num>=value: result += convert(num//value)+\" \"+name + (if remainder>0 \" \"). Then remainder num%=value. After loop, if remainder>0 result += convert(remainder). Return result.strip(). At top: result=convert(num); print(result). End.\n\nWe must express each line as virtual code step. We need to break into steps like:\n\nStart // program starts\n→ Step 1: Define arrays for below_20, tens, thousands // mapping numbers to words\n\nBut we can keep simpler: Step 1: if num==0 output \"Zero\" // handle zero\n\nThen function convert. But we can break into steps:\n\n→ Step 2: Define function Convert(num) // recursive helper\n\nThen inside that we have decisions. We'll write lines inside function with indentation maybe but just separate lines. Use arrow for decisions.\n\nWe need to produce a line per action. Let's produce about maybe 25-30 lines. Use 'Step' numbering or just descriptive.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入整數 num // 從使用者取得非負整數\n→ Decision: 是否 num 等於 0? // 檢查是否為 0\n    Yes → Step 2: 輸出 'Zero' // 回傳 \"Zero\"\n    No  → Step 3: 呼叫 Convert(num) 並將結果存入 result // 進行轉換\n→ Step 4: 輸出 result // 顯示英文文字\nEnd // 程式結束\n\nBut we also need to define Convert.\n\nWe can embed function definition lines after Step 3 but before Step 4? We might need to include function definition steps in sequence before use. We can just describe it as a step.\n\nLet's produce:\n\nStart\n→ Step 1: 定義陣列 below_20 = [...], tens = [...], thousands = [\"Thousand\",\"Million\",\"Billion\"] // 基本單位\n→ Step 2: 定義函式 Convert(num) // 轉換子函式\n    → Decision: 如果 num < 20? // 小於20直接回傳對應字串\n        Yes → Step 3: 回傳 below_20[num] // 回傳單詞\n        No  → Decision: 如果 num < 100? // 兩位數\n            Yes → Step 4: 若 num % 10 == 0? // 切除零尾數\n                Yes → Step 5: 回傳 tens[num//10] // 只回傳十位\n                No  → Step 6: 回傳 tens[num//10] + \" \" + Convert(num%10) // 加上單位\n            No  → Decision: 如果 num < 1000? // 三位數\n                Yes → Step 7: 若 num % 100 == 0? // 沒尾數\n                    Yes → Step 8: 回傳 below_20[num//100] + \" Hundred\" // 百位\n                    No  → Step 9: 回傳 below_20[num//100] + \" Hundred \" + Convert(num%100) // 加上剩餘\n                No  → Decision: 對於千級以上\n                    Yes → Step 10: 初始化 result = \"\"\n                    No  → Step 11: // 這裡不會發生\n                → Step 12: For each (name, value) in [(\"Billion\",1000000000), (\"Million\",1000000), (\"Thousand\",1000)]\n                    → Decision: 如果 num >= value?\n                        Yes → Step 13: result += Convert(num//value) + \" \" + name\n                        No  → Step 14: // 跳過\n                    → Step 15: num = num % value // 更新剩餘\n                → Decision: 如果 num > 0?\n                    Yes → Step 16: result += \" \" + Convert(num) // 加上剩餘部分\n                    No  → Step 17: // 無需額外文字\n                → Step 18: 回傳 result.strip() // 去除首尾空格\n\n→ Step 19: 如果 num 等於 0? // 再次檢查\n    Yes → Step 20: result = \"Zero\"\n    No  → Step 21: result = Convert(num) // 呼叫轉換函式\n\n→ Step 22: 輸出 result // 顯示最終字串\nEnd\n\nBut we have duplicates. Maybe better to just define function and then call.\n\nBut we need to keep each line as a separate step. So we might include the function definition as multiple lines: Step 2: 定義函式 Convert(num) // 轉換子函式.\n\nBut we also need to handle decisions inside. Each decision branch lines.\n\nLet's produce a clear step-by-step pseudocode. Provide lines for each step, with explanation.\n\nAlso ensure we use the arrow arrow style.\n\nLet's generate final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入整數 num // 從使用者取得非負整數  \n\n→ Decision: 是否 num 等於 0? // 檢查是否為 0  \n  Yes → Step 2: result = \"Zero\" // 直接回傳 \"Zero\"  \n  No  → Step 3: result = Convert(num) // 呼叫轉換子函式  \n\n→ Step 4: 輸出 result // 顯示英文文字  \n\nEnd // 程式結束  \n\n---  \n\nStep 5: 定義陣列 below_20 = [\"\", \"One\", \"Two\", ..., \"Nineteen\"] // 0-19 對應字串  \n→ Step 6: 定義陣列 tens = [\"\", \"\", \"Twenty\", \"Thirty\", ..., \"Ninety\"] // 十位數字  \n→ Step 7: 定義函式 Convert(num) // 轉換子函式  \n\n  Decision: 如果 num < 20? // 小於20直接回傳  \n   Yes → Step 8: 回傳 below_20[num] // 回傳單一單詞  \n   No  → Decision: 如果 num < 100? // 兩位數  \n    Yes → Decision: 如果 num % 10 == 0? // 十位整數  \n     Yes → Step 9: 回傳 tens[num // 10] // 只回傳十位單詞  \n     No  → Step 10: 回傳 tens[num // 10] + \" \" + Convert(num % 10) // 加上個位單詞  \n    No  → Decision: 如果 num < 1000? // 三位數  \n     Yes → Decision: 如果 num % 100 == 0? // 百位整數  \n      Yes → Step 11: 回傳 below_20[num // 100] + \" Hundred\" // 百位單詞  \n      No  → Step 12: 回傳 below_20[num // 100] + \" Hundred \" + Convert(num % 100) // 加上剩餘兩位  \n    No → Step 13: // 處理千級以上  \n     → Step 14: 初始化 result = \"\" // 用於累積字串  \n     → Step 15: 定義數組 scale = [(\"Billion\", 1000000000), (\"Million\", 1000000), (\"Thousand\", 1000)]  \n     → 迭代 (name, value) 在 scale  \n      Decision: 如果 num >= value? // 是否包含此千級  \n       Yes → Step 16: result += Convert(num // value) + \" \" + name // 加上該級別單詞  \n       No  → Step 17: // 跳過此級別  \n      → Step 18: num = num % value // 取餘數繼續下一級  \n     → Decision: 如果 num > 0? // 是否還有剩餘數字  \n      Yes → Step 19: result += \" \" + Convert(num) // 加上剩餘部分  \n      No  → Step 20: // 無剩餘  \n     → Step 21: 回傳 result.strip() // 去除首尾空格  \n\nStep 22: // Convert 函式結束  \nEnd // 程式結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.7996625226507603,-0.30492353059268784],[-0.4671280515608436,0.4422106072513118],[-0.260724644297698,-0.4558844141708018]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.7996625226507603, -0.30492353059268784], [-0.4671280515608436, 0.4422106072513118], [-0.260724644297698, -0.4558844141708018]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機半徑: sqrt(rnd) 保證均勻分佈\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取兩行：方法列表與參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        sys.exit()\n    methods = json.loads(data[0])\n    args_list = json.loads(data[1])\n\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構物件\n            obj = Solution(*args)\n            results.append(None)  # 物件建構不回傳值\n        else:\n            # 呼叫對應方法\n            func = getattr(obj, method)\n            results.append(func(*args))\n\n    # 將結果輸出為 JSON 格式（None 會變成 null）\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode. For each line, include \"虛擬碼步驟\" + \" // 解釋/說明\". Use arrows and Decision etc. Should cover initialization and randPoint generation.\n\nSteps: Start, assign radius and center, then randPoint method. In randPoint: generate random angle theta uniformly 0 to 2π, random radius sqrt(rnd)*R. Then compute x = x_center + radius * cos(theta), y = y_center + radius * sin(theta). Return [x, y].\n\nAlso maybe include decision to generate. But pseudocode can be linear.\n\nEnsure \"→\" for steps. Use \"Decision:\" for condition if any.\n\nWe need to produce \"逐行\" lines. Might have multiple lines inside randPoint. Use indentation with arrows? The sample shows arrows for steps, then decisions with indented Yes/No.\n\nWe can simply list lines: Start, → Step 1: assign radius, etc. Then in randPoint: Step.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告變數 radius, x_center, y_center // 存放圓半徑與中心座標  \n→ Step 2: 建立類別 Solution(radius, x_center, y_center) // 初始化物件時設定這三個參數  \n\nStart // 進入 randPoint 方法  \n→ Step 3: 產生隨機角度 theta 介於 0 與 2π 之間 // 均勻分佈在圓周上  \n→ Step 4: 產生隨機半徑 r' 介於 0 與 radius 的平方根 // 以 r' = sqrt(rand()) * radius 取得均勻分佈在圓內  \n→ Step 5: 計算點的 x 坐標 x = x_center + r' * cos(theta) // 把隨機半徑和角度轉換回直角座標  \n→ Step 6: 計算點的 y 坐標 y = y_center + r' * sin(theta) // 同理取得 y 坐標  \n→ Step 7: 回傳陣列 [x, y] // 返回隨機生成的點  \nEnd // randPoint 方法執行結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpualg4opw.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpualg4opw.py\", line 30, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgj6ahkrb.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpgj6ahkrb.py\", line 30, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\ndef main():\n    # 從 stdin 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入被單引號包住，先移除它\n    if data.startswith(\"'\") and data.endswith(\"'\"):\n        data = data[1:-1]\n\n    # 執行輸入字串以得到變數 strs, m, n\n    # 這裡使用 exec 是為了簡化解析；在正式環境請確保輸入安全\n    local_vars = {}\n    exec(data, {}, local_vars)\n\n    strs = local_vars.get('strs', [])\n    m = local_vars.get('m', 0)\n    n = local_vars.get('n', 0)\n\n    sol = Solution()\n    result = sol.findMaxForm(strs, m, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The problem: maximum subset of binary strings limited by m zeros and n ones. It's classic DP problem. We will generate steps: Start, read input array, define DP table 2D size (m+1)*(n+1). Initialize zero. Iterate strings, count zeros and ones. For each string, iterate j from m down to zeros, k from n down to ones, dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones] + 1). Finally result dp[m][n]. End. Provide line by line.\n\nNeed to use virtual code arrows and decisions. No real code.\n\nLet's write steps.\n\nStart\n\n→ Step 1: 定義 dp 為 (m+1) x (n+1) 二維表，初始值 0 // 建立 DP 表\n\n→ Step 2: 對於每個字符串 s in strs // 逐一處理每個字串\n\n    → Step 2.1: 計算 zeros = s.count('0')，ones = s.count('1') // 取得 0 與 1 的數量\n\n    → Decision: 是否 zeros <= m 且 ones <= n? // 確認字串是否能放進限制\n\n        Yes → Step 2.2: 從 j = m 到 zeros，k = n 到 ones 反向迭代 // 遞迴更新 dp\n\n            → Step 2.2.1: dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones] + 1) // 更新子問題解\n\n        No  → Step 2.3: 跳過該字串 // 字串過大，不能加入\n\n→ Step 3: 回傳 dp[m][n] // 取得最大子集大小\n\nEnd\n\nNeed to make sure each line has virtual code and comment. Also use arrow and decisions.\n\nLet's write line by line. Also include indentation. Ensure each line ends with // explanation.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 dp 為 (m+1) x (n+1) 二維表，初始值 0 // 建立 DP 表，用於存儲不同 0 與 1 配額下可選字串的最大數量\n→ Step 2: 對於每個字符串 s in strs // 逐一處理每個輸入字串\n    → Step 2.1: 計算 zeros = s.count('0')，ones = s.count('1') // 取得當前字串中的 0 與 1 的個數\n    → Decision: 是否 zeros <= m 且 ones <= n? // 檢查字串是否在可接受的配額範圍內\n        Yes → Step 2.2: 從 j = m 到 zeros，k = n 到 ones 反向迭代 // 逆序更新 dp，避免重複使用同一字串\n            → Step 2.2.1: dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones] + 1) // 若加入此字串能獲得更大的子集，則更新 dp\n        No  → Step 2.3: 跳過該字串 // 字串超出配額限制，直接忽略\n→ Step 3: 回傳 dp[m][n] // dp[m][n] 儲存的即為在 m 個 0 與 n 個 1 的限制下能選取的最大字串數\nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[3,2,1],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [3, 2, 1], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"實作 Fisher‑Yates 洗牌與重設功能的類別\"\"\"\n\n    def __init__(self, nums):\n        \"\"\"\n        初始化時儲存原始陣列並建立可操作的副本。\n        \"\"\"\n        self._original = list(nums)   # 原始順序\n        self.nums = list(nums)        # 可變動的陣列\n\n    def reset(self):\n        \"\"\"\n        將陣列還原為原始順序並回傳。\n        \"\"\"\n        self.nums = list(self._original)\n        return self.nums\n\n    def shuffle(self):\n        \"\"\"\n        隨機洗牌（Fisher‑Yates 演算法），並回傳洗牌後的陣列。\n        \"\"\"\n        n = len(self.nums)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\n\ndef main():\n    \"\"\"\n    讀取輸入並執行 LeetCode 樣式的測試流程。\n    輸入格式示例：\n        [\"Solution\",\"shuffle\",\"reset\",\"shuffle\"], [[[1,2,3]], [], [], []]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析兩個 JSON 陣列\n    first_bracket = data.find(']')\n    ops = json.loads(data[:first_bracket + 1])\n    args = json.loads(data[first_bracket + 1:].lstrip(',').strip())\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # 建構子只接收第一個元素（原始陣列）\n            obj = Solution(arg[0])\n            results.append(None)          # 以 None 代表 null\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若遇到未知指令，加入 None\n            results.append(None)\n\n    # 輸出結果，使用 json.dumps 以產生 null 而非 None\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for a class Solution with constructor, reset, shuffle. Provide each step line with arrow and explanation. Use decision arrow etc. Probably no real code. Use Start, End. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立主類別\n→ Step 2: 宣告變數原始陣列原始 = 空 // 用於儲存初始化時的原始資料\n→ Step 3: 宣告變數目前陣列 = 空 // 用於儲存目前的陣列狀態\n→ Decision: 進入建構子? // 檢查是否呼叫建構子\n    Yes → Step 4: 建構子接受參數 nums // 初始化時傳入的整數陣列\n        → Step 5: 原始陣列原始 = 複製 nums // 儲存原始順序\n        → Step 6: 目前陣列 = 複製 nums // 初始時亦為原始順序\n    No → End // 無建構子調用，結束\n→ Decision: 進入 reset()? // 檢查是否呼叫 reset 方法\n    Yes → Step 7: 目前陣列 = 複製 原始陣列原始 // 將陣列恢復為原始順序\n        → Step 8: 回傳 目前陣列 // 回傳重設後的陣列\n    No → End // 若不呼叫 reset，結束此流程\n→ Decision: 進入 shuffle()? // 檢查是否呼叫 shuffle 方法\n    Yes → Step 9: 取得長度 n = 目前陣列長度 // 為隨機排列做準備\n        → Step 10: 從 i = n-1 到 1 進行迴圈 // 遞減迴圈\n            → Step 11: 產生隨機索引 j，範圍 0 ~ i // 隨機選取\n            → Step 12: 交換 目前陣列[i] 與 目前陣列[j] // 交換位置\n        → Step 13: 回傳 目前陣列 // 回傳隨機排列\n    No → End // 若不呼叫 shuffle，結束此流程\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\n\ndef subsets(nums):\n    res = []\n\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return res\n\ndef parse_input(data: str):\n    data = data.strip()\n    if not data:\n        return []\n\n    if '=' in data:\n        _, right = data.split('=', 1)\n        right = right.strip()\n    else:\n        right = data\n\n    try:\n        nums = eval(right, {}, {})\n    except Exception:\n        import re\n        nums = list(map(int, re.findall(r'-?\\d+', right)))\n    return nums\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = subsets(nums)\n\n    def subset_to_str(subset):\n        return '[' + ','.join(map(str, subset)) + ']'\n\n    output = '[' + ','.join(subset_to_str(subset) for subset in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for generating all subsets of a unique integer array, returning power set. Provide each line with arrow or start end and explanations.\n\nWe need to include logic. Use recursion or iterative method. We should produce pseudo-code lines. We'll show:\n\nStart\n→ Step: Sort array (optional)\n→ Step: Initialize result list with empty subset\n→ Step: For each number in nums\n→ Decision: Add number to each existing subset\n→ For each subset in current result\n→ Step: Append subset + number\n→ Add new subsets to result\nEnd\n\nOr recursion:\n\nStart\n→ Step: Define function dfs(index, current)\n→ Step: Add current to result\n→ Decision: If index==len(nums)? End recursion\n→ Step: dfs(index+1, current) // skip current element\n→ Step: dfs(index+1, current + [nums[index]]) // include current element\nEnd\n\nPick one. Provide virtual code lines.\n\nWe should include each line with explanation.\n\nLet's craft a concise pseudo-code:\n\nStart\n→ Step 1: Input array nums // obtain unique elements\n→ Step 2: Initialize result = [[]] // start with empty subset\n→ Step 3: For each num in nums // iterate over elements\n→ Decision: 是否將 num 加入目前結果? // decide to create new subsets\n    Yes → Step 4: For each subset in result // for each existing subset\n           → Step 5: Append subset + [num] to new_subsets // create new subset with num\n    No  → (no action)\n→ Step 6: Append new_subsets to result // add all new subsets\nEnd\n\nBut we need arrow format: Use arrow arrow. Use \"→\" before each step, \"Decision:\" line with Yes/No branches.\n\nBetter: Use recursion pseudo-code as it's simpler.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義變數 result = [] // 用於存放所有子集\n→ Step 2: 定義函式 dfs(idx, current) // idx為目前索引，current為已選元素集合\n→ Step 3: 將 current 加入 result // 每次遞迴都記錄一個子集\n→ Decision: idx 是否等於 nums.length? // 判斷是否已遍歷完所有元素\n    Yes → End // 若已完結，回傳結果\n    No  → Step 4: dfs(idx+1, current) // 不選擇 nums[idx] 的遞迴\n→ Step 5: dfs(idx+1, current + [nums[idx]]) // 選擇 nums[idx] 的遞迴\nEnd // 程式結束\n\nBut we need arrow lines with decision and branches. Let's align formatting.\n\nWe need to produce \"Start\", \"→\", \"Decision:\" etc.\n\nProbably:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result = [] // 存放所有子集\n→ Step 2: 定義函式 dfs(idx, current) // idx 為當前索引，current 為已選元素集合\n→ Step 3: result.append(current) // 把目前的子集加入結果\n→ Decision: idx 是否等於 nums.length? // 判斷是否已遍歷完所有元素\n    Yes → End // 遞迴結束\n    No  → Step 4: dfs(idx+1, current) // 不選擇 nums[idx] 的遞迴\n→ Step 5: dfs(idx+1, current + [nums[idx]]) // 選擇 nums[idx] 的遞迴\n→ Step 6: dfs(0, []) // 初始呼叫\nEnd // 程式結束\n\nBut we need to maintain order: we should call dfs after defining. So we can put Step 6 before Step 2? Wait, we need to call after definition. The order:\n\nStart\n→ Step 1: result = []\n→ Step 2: define dfs\n→ Step 3: dfs(0, [])\n→ Decision: ???\n\nBut decision inside dfs. So we need to nest decision lines inside dfs. Let's produce pseudo-code with indentation maybe? But we must keep arrow lines.\n\nLet's produce pseudo-code with each line separate. Use \"→\" before each. For nested levels we can indent with some spaces.\n\nBut the format might not require indentation. Provide all lines linear with arrow, using \"Decision:\" lines with \"Yes →\" and \"No →\" sublines.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: result = [] // 用於存放所有子集\n→ Step 2: 定義函式 dfs(idx, current) // idx 為目前索引，current 為已選元素集合\n→ Step 3: result.append(current) // 把目前的子集加入結果\n→ Decision: idx 是否等於 nums.length? // 判斷是否已遍歷完所有元素\n    Yes → End // 遞迴結束\n    No  → Step 4: dfs(idx+1, current) // 不選擇 nums[idx] 的遞迴\n→ Step 5: dfs(idx+1, current + [nums[idx]]) // 選擇 nums[idx] 的遞迴\n→ Step 6: dfs(0, []) // 初始呼叫\nEnd // 程式結束\n\nBut we need to maintain the order: Step 6 should be before Step 4? Actually Step 4 and 5 are inside dfs, they come after decision. The structure of pseudo-code should reflect that. But we can keep them linear.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: result = [] // 用於存放所有子集\n→ Step 2: 定義函式 dfs(idx, current) // idx 為目前索引，current 為已選元素集合\n→ Step 3: result.append(current) // 把目前的子集加入結果\n→ Decision: idx 是否等於 nums.length? // 判斷是否已遍歷完所有元素\n    Yes → End // 遞迴結束\n    No  → Step 4: dfs(idx+1, current) // 不選擇 nums[idx] 的遞迴\n→ Step 5: dfs(idx+1, current + [nums[idx]]) // 選擇 nums[idx] 的遞迴\n→ Step 6: dfs(0, []) // 初始呼叫\nEnd // 程式結束\n\nBut this seems wrong: Step 5 should be inside the \"No\" branch as well. However, we can just present them sequentially because the pseudo-code will still be interpreted correctly.\n\nAlternatively, we can use iterative approach:\n\nStart\n→ Step 1: result = [[]] // start with empty subset\n→ Step 2: For each num in nums\n→ Step 3: new_subsets = []\n→ Step 4: For each subset in result\n→ Step 5: new_subsets.append(subset + [num]) // create new subset\n→ Step 6: result.extend(new_subsets) // add new subsets\nEnd\n\nBut this is simpler. Provide pseudo-code.\n\nI'll produce iterative version:\n\nStart // 程式開始執行\n→ Step 1: result = [[]] // 初始化結果，包含空子集\n→ Step 2: For each num in nums // 逐個遍歷輸入數列\n→ Decision: 是否開始為此 num 生成新子集? // 進入內部迴圈\n    Yes → Step 3: new_subsets = [] // 用於暫存本次 num 的新子集\n    Yes → Step 4: For each subset in result // 遍歷目前已有的子集\n    Yes → Step 5: new_subsets.append(subset + [num]) // 將 num 加到子集中\n    Yes → Step 6: result.extend(new_subsets) // 把所有新子集加入結果\nEnd // 程式結束\n\nBut we need each line separated. Let's write:\n\nStart // 程式開始執行\n→ Step 1: result = [[]] // 初始化結果，包含空子集\n→ Step 2: For each num in nums // 逐個遍歷輸入數列\n→ Decision: num 已處理? // 檢查是否需要為此 num 生成新子集\n    Yes → Step 3: new_subsets = [] // 用於暫存本次 num 的新子集\n    Yes → Step 4: For each subset in result // 遍歷目前已有的子集\n    Yes → Step 5: new_subsets.append(subset + [num]) // 將 num 加到子集中\n    Yes → Step 6: result.extend(new_subsets) // 把所有新子集加入結果\nEnd // 程式結束\n\nBut we also need to handle for loop. Might be simpler: Provide each step for iteration.\n\nGiven the requirement, it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result = [[]] // 初始化結果，先放一個空子集  \n→ Step 2: For each num in nums // 逐一取出陣列中的每個元素  \n→ Decision: 是否為目前的 num 產生新子集? // 進入生成階段  \n  Yes → Step 3: new_subsets = [] // 用來暫存本輪產生的子集  \n  Yes → Step 4: For each subset in result // 遍歷目前已有的所有子集  \n    → Step 5: new_subsets.append(subset + [num]) // 把 num 加到子集中  \n  Yes → Step 6: result.extend(new_subsets) // 把新子集加入總結果  \nEnd // 程式結束，result 即為所有子集（冪集）"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '12'"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '14'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '14'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def leastInterval(self, tasks, n):\n        \"\"\"\n        計算最少需要的 CPU 週期數。\n        \"\"\"\n        # 1. 計算每個任務的出現次數\n        task_counts = Counter(tasks)\n        if not task_counts:  # 沒有任務\n            return 0\n\n        # 2. 找出最高頻率以及擁有此頻率的任務數量\n        max_freq = max(task_counts.values())\n        max_count = sum(1 for cnt in task_counts.values() if cnt == max_freq)\n\n        # 3. 計算理論上的空間槽\n        empty_slots = (max_freq - 1) * (n + 1)\n        # 4. 用其他任務填補空間槽\n        remaining_tasks = len(tasks) - max_freq * max_count\n        empty_slots -= remaining_tasks\n        idle_time = max(0, empty_slots)\n\n        # 5. 最終結果是任務數 + 必要的閒置時間\n        return len(tasks) + idle_time\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，返回 (tasks, n)。\n    輸入範例：\n        tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\n    \"\"\"\n    # 找出 tasks = [...] 的部分\n    tasks_match = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not tasks_match:\n        raise ValueError(\"Cannot find tasks list in input.\")\n    tasks_str = tasks_match.group(1)\n    tasks = ast.literal_eval(tasks_str)\n\n    # 找出 n = 數值的部分\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n    if not n_match:\n        raise ValueError(\"Cannot find n value in input.\")\n    n = int(n_match.group(1))\n    return tasks, n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    try:\n        tasks, n = parse_input(raw_input)\n    except Exception as e:\n        # 若解析失敗，直接退出\n        print(f\"Error parsing input: {e}\")\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.leastInterval(tasks, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solution to \"LeetCode 621. Task Scheduler\". Outline algorithm: count frequencies, find max freq, count how many tasks have max freq. Then compute idle slots: (maxFreq-1)*(n+1) - sum(min(freq, maxFreq-1)). Actually formula: maxIdle = (maxFreq-1)*(n+1) - (totalTasks - maxFreqCount). result = max(totalTasks, totalTasks + maxIdle?). Wait correct: let maxFreq = max count. let maxCount = number of tasks with count == maxFreq. Compute emptySlots = (maxFreq-1)*(n+1). remainingTasks = totalTasks - maxFreq*maxCount. emptySlots -= remainingTasks. idleTime = max(0, emptySlots). result = totalTasks + idleTime.\n\nWe'll produce virtual code steps.\n\nUse pseudo structure: Start, Input tasks array, n. Count frequencies. Find maxFreq, maxCount. Compute emptySlots, remainingTasks, idleTime, result. Output result. End.\n\nMake each line with explanation. Use arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 freq 用於計算每個任務字母出現次數 // 以字母為鍵，計數為值  \n→ Step 2: 逐個遍歷 tasks，更新 freq[字母] = freq.get(字母, 0) + 1 // 取得每個任務的頻率  \n→ Decision: 若 tasks 為空? // 檢查是否有任務可執行  \n  Yes → Step 3: 回傳 0 // 無任務時不需要任何時間  \n  No → Step 4: 取得總任務數 totalTasks = len(tasks) // 紀錄任務總數  \n→ Step 5: 找出最大頻率 maxFreq = max(freq.values()) // 最高重複次數  \n→ Step 6: 計算具有最大頻率的任務數 maxCount = 0  \n  → Step 6.1: 逐個頻率值，如果 value == maxFreq，maxCount += 1 // 計算重複最多的任務數  \n→ Step 7: 計算理論上的空間槽 emptySlots = (maxFreq - 1) * (n + 1) // 每組最大頻率任務之間需留的間隔  \n→ Step 8: 計算剩餘任務 remainingTasks = totalTasks - maxFreq * maxCount // 需要填補空間槽的其他任務數  \n→ Step 9: 更新空間槽 emptySlots = emptySlots - remainingTasks // 用剩餘任務填滿空間  \n→ Decision: 若 emptySlots < 0? // 空間槽可能為負值，表示不需要額外閒置時間  \n  Yes → Step 10: idleTime = 0 // 無閒置時間  \n  No → Step 11: idleTime = emptySlots // 必須的閒置時間  \n→ Step 12: 計算總時間 result = totalTasks + idleTime // 任務數 + 必要閒置時間  \n→ Step 13: 回傳 result // 傳回最小 CPU 時間  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdtvflkkq.py\", line 52, in <module>\n    args = ast.literal_eval(args_part)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0  # global timestamp\n        self.tweets = []  # list of tuples: (timestamp, tweetId, userId)\n        self.following = defaultdict(set)  # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        \"\"\"Compose a new tweet.\"\"\"\n        self.time += 1\n        self.tweets.append((self.time, tweetId, userId))\n\n    def getNewsFeed(self, userId: int) -> list:\n        \"\"\"Retrieve the 10 most recent tweet IDs in the news feed.\"\"\"\n        res = []\n        # Users whose tweets should appear in the feed: followed + self\n        followees = self.following.get(userId, set()).copy()\n        followees.add(userId)\n        # Scan tweets from newest to oldest\n        for _, tid, uid in reversed(self.tweets):\n            if uid in followees:\n                res.append(tid)\n                if len(res) == 10:\n                    break\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        \"\"\"Make followerId follow followeeId.\"\"\"\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        \"\"\"Make followerId unfollow followeeId.\"\"\"\n        self.following[followerId].discard(followeeId)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Remove surrounding quotes if present\n    if data[0] in (\"'\", '\"') and data[-1] == data[0]:\n        data = data[1:-1]\n\n    # Split into operations and arguments\n    parts = data.split('],', 1)\n    ops_part = parts[0] + ']'\n    args_part = '[' + parts[1].strip()\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    twitter = Twitter()\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Twitter\":\n            # Constructor already called\n            results.append(None)\n        elif op == \"postTweet\":\n            twitter.postTweet(arg[0], arg[1])\n            results.append(None)\n        elif op == \"getNewsFeed\":\n            results.append(twitter.getNewsFeed(arg[0]))\n        elif op == \"follow\":\n            twitter.follow(arg[0], arg[1])\n            results.append(None)\n        elif op == \"unfollow\":\n            twitter.unfollow(arg[0], arg[1])\n            results.append(None)\n        else:\n            # Unknown operation; ignore\n            results.append(None)\n\n    # Format output: replace None with 'null', others with their string representation\n    output_parts = []\n    for res in results:\n        if res is None:\n            output_parts.append('null')\n        else:\n            output_parts.append(str(res))\n    print('[' + ', '.join(output_parts) + ']')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. We need to design a simplified Twitter class with methods: constructor, postTweet, getNewsFeed, follow, unfollow. Need to show logic: data structures: for each user: set of followees; list of tweets (global? or per user?). We'll need a global tweet list with timestamps. For getNewsFeed, we need to merge tweets from followed users + self, pick top 10 by timestamp. We can use priority queue or simply iterate.\n\nWe produce virtual code steps: Start, define class Twitter, constructor, data structures: followMap, tweetList, timestamp counter.\n\nThen methods: postTweet: increment timestamp, add to tweetList (append), maybe store tweet with userId and timestamp. For getNewsFeed: gather all tweets from user and followees, sort by timestamp descending, take first 10.\n\nFollow: add followee to follower's set.\n\nUnfollow: remove.\n\nWe need to produce code steps with arrows and decisions. Provide line numbers? Not necessary, just each line with arrow.\n\nWe should structure like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Twitter // 建立 Twitter 類別\n→ Step 2: 定義成員變數 followMap, tweetList, timestamp // 追蹤關係、所有推文、時間戳\n→ Step 3: 定義 Constructor Twitter() // 初始化資料\n    → Step 4: 初始化 followMap 為空映射 // ...\n    → Step 5: 初始化 tweetList 為空列表 // ...\n    → Step 6: timestamp 設為 0 // ...\n→ Step 7: 定義方法 postTweet(userId, tweetId) // 發佈推文\n    → Step 8: timestamp += 1 // 新增時間戳\n    → Step 9: tweetList.add( (userId, tweetId, timestamp) ) // 儲存推文\n→ Step 10: 定義方法 getNewsFeed(userId) // 取得新聞摘要\n    → Step 11: 建立候選列表 candidates // ...\n    → Step 12: 如果 userId 在 followMap 中，則將所有 followee 加入候選集 // ...\n    → Step 13: 將 userId 自己加入候選集 // ...\n    → Step 14: 迭代 tweetList 從最後開始，若 tweet.userId 在候選集中，加入 feed，直到 10 個 // ...\n    → Step 15: 針對 feed 只保留 tweetId 並返回 // ...\n→ Step 16: 定義方法 follow(followerId, followeeId) // 追蹤\n    → Step 17: 若 followerId 不在 followMap，初始化空集合 // ...\n    → Step 18: add followeeId 到 followerId 的集合 // ...\n→ Step 19: 定義方法 unfollow(followerId, followeeId) // 取消追蹤\n    → Step 20: 若 followerId 在 followMap，且包含 followeeId，則移除 // ...\nEnd // 程式結束\n\nNeed to include decision blocks? For getNewsFeed we have decisions: if tweet.userId in candidates? Also need decision on if follower has followee map. Provide Decision: if followerId in followMap? Yes -> add followee.\n\nOk produce final output with each line arrow. Ensure each line ends with // 解釋.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Twitter // 建立 Twitter 類別  \n→ Step 2: 定義成員變數 followMap, tweetList, timestamp // 追蹤關係、所有推文、時間戳  \n\n→ Step 3: 定義 Constructor Twitter() // 初始化資料  \n  → Step 4: 初始化 followMap 為空映射 // 用於存放每個使用者的追蹤集合  \n  → Step 5: 初始化 tweetList 為空列表 // 用於存放所有推文（userId, tweetId, timestamp）  \n  → Step 6: timestamp 設為 0 // 時間戳從 0 開始  \n\n→ Step 7: 定義方法 postTweet(userId, tweetId) // 發佈推文  \n  → Step 8: timestamp += 1 // 為此推文產生新的時間戳  \n  → Step 9: tweetList.add( (userId, tweetId, timestamp) ) // 將推文加入全局列表  \n\n→ Step 10: 定義方法 getNewsFeed(userId) // 取得新聞摘要  \n  → Step 11: 建立候選集 candidates 為空集合 // 追蹤的使用者及自己  \n  → Decision: 若 userId 在 followMap 中? // 檢查是否已有追蹤關係  \n  →  Yes → Step 12: 將 followMap[userId] 中的所有 followee 加入 candidates // 加入追蹤者  \n  →  No  → Step 12: 跳過 // 若沒有追蹤關係，候選集保持空  \n  → Step 13: 將 userId 自己加入 candidates // 自己的推文也要顯示  \n  → Step 14: 建立空列表 feed // 用於暫存前 10 個推文  \n  → Step 15: 迭代 tweetList 從最後開始（最舊到最新）  \n  →  Decision: 若 tweet.userId 在 candidates 中? // 判斷是否屬於候選使用者  \n  →  Yes → Step 16: feed.add(tweet.tweetId) // 將推文加入 feed  \n  →  No  → Step 16: 跳過 // 不屬於候選人，忽略  \n  → Step 17: 若 feed.size() 已達 10，則停止迭代 // 只取最近 10 個  \n  → Step 18: 返回 feed // 結果即為新聞摘要  \n\n→ Step 19: 定義方法 follow(followerId, followeeId) // 追蹤另一使用者  \n  → Decision: 若 followerId 不在 followMap?  \n  →  Yes → Step 20: 初始化 followMap[followerId] 為空集合 // 新使用者  \n  →  No  → Step 20: 跳過 // 已存在集合  \n  → Step 21: followMap[followerId].add(followeeId) // 加入追蹤關係  \n\n→ Step 22: 定義方法 unfollow(followerId, followeeId) // 取消追蹤  \n  → Decision: 若 followerId 在 followMap 且 followeeId 存在於其集合?  \n  →  Yes → Step 23: followMap[followerId].remove(followeeId) // 移除追蹤關係  \n  →  No  → Step 23: 跳過 // 若不存在則不處理  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwhuxlv9_.py\", line 3, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9qlabrxy.py\", line 3, in <module>\n    from sortedcontainers import SortedList\nModuleNotFoundError: No module named 'sortedcontainers'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom sortedcontainers import SortedList\n\ndef containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff):\n    if indexDiff <= 0 or valueDiff < 0:\n        return False\n    window = SortedList()\n    for i, num in enumerate(nums):\n        pos = window.bisect_left(num - valueDiff)\n        if pos < len(window) and abs(window[pos] - num) <= valueDiff:\n            return True\n        window.add(num)\n        if len(window) > indexDiff:\n            window.remove(nums[i - indexDiff])\n    return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    nums_match = re.search(r'nums\\s*=\\s*\\[(.*?)\\]', data)\n    if not nums_match:\n        return\n    nums_str = nums_match.group(1)\n    nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', data)\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', data)\n    if not index_match or not value_match:\n        return\n    indexDiff = int(index_match.group(1))\n    valueDiff = int(value_match.group(1))\n    result = containsNearbyAlmostDuplicate(nums, indexDiff, valueDiff)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. The algorithm: two nested loops, check constraints, break. Or use sliding window with balanced BST or set to maintain window of size indexDiff, and for each element check if any within valueDiff. Use multiset (balanced BST) or sorted list. But we can just provide a simple O(n^2) algorithm for clarity. But maybe better to show efficient algorithm: use sliding window and a balanced BST for values. Complexity O(n log indexDiff). Provide steps.\n\nWe must output only virtual code lines with comments. Use arrows and decisions.\n\nLet's produce:\n\nStart // start\n→ Step 1: Initialize an empty balanced BST `window` // to store values in current window\n→ Step 2: For each index `i` from 0 to n-1 // iterate over array\n→ Decision: If i > indexDiff // window too large\n    Yes → Step 3: Remove nums[i - indexDiff - 1] from `window` // maintain window size\n    No  →\n→ Decision: Find in `window` any value `v` such that abs(v - nums[i]) <= valueDiff // using BST search\n    Yes → Step 4: Return true // found valid pair\n    No  → Step 5: Insert nums[i] into `window` // add current element to window\n→ Step 6: After loop ends, Return false // no pair found\nEnd // end\n\nBut we need arrow indentation. Use arrow and indentation for decision branches. Also include the condition in decision. Provide explanation after //. For find in window, we can note we need to check lower_bound(nums[i]-valueDiff) and if <= nums[i]+valueDiff. Represent as decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的平衡 BST `window` // 用於保存當前滑動窗口內的數值  \n→ Step 2: 從 i = 0 到 nums.length - 1 迴圈 // 遍歷每個索引  \n→ Decision: 若 i > indexDiff? // 確保窗口大小不超過 indexDiff  \n Yes → Step 3: 從 `window` 刪除 nums[i - indexDiff - 1] // 移除最舊的元素以維持窗口長度  \n No  →  \n→ Decision: 在 `window` 中是否存在值 v 使得 |v - nums[i]| ≤ valueDiff? // 透過 BST 的 lower_bound 查詢  \n Yes → Step 4: 回傳 true // 找到符合條件的索引對  \n No  → Step 5: 將 nums[i] 插入 `window` // 加入當前元素進入滑動窗口  \n→ Step 6: 迴圈結束後回傳 false // 未找到任何符合條件的索引對  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null,1,0,0,1,1]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"初始化，建立前綴和陣列以供二分搜尋\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"隨機選取索引，根據前綴和及權重比例\"\"\"\n        # 產生 1 到 total 的隨機整數（包含兩端）\n        target = random.randint(1, self.total)\n        # 找到第一個大於 target 的前綴和對應的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，格式為 (operations, arguments)\n    # 例：'[\"Solution\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]'\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    ops, args = eval(data)\n\n    obj = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg[0] 是 w 列表\n            obj = Solution(arg[0])\n            results.append(None)  # 在 LeetCode 中對象創建不返回值\n        elif op == \"pickIndex\":\n            res = obj.pickIndex()\n            results.append(res)\n        else:\n            # 若有其他方法，直接呼叫\n            res = getattr(obj, op)(*arg)\n            results.append(res)\n\n    # 轉換為 LeetCode 輸出格式：null 代表 None\n    output = ['null' if r is None else str(r) for r in results]\n    print('[' + ','.join(output) + ']')",
      "virtual_code": "Thinking...\nWe need to produce pseudocode with arrows etc. Steps: Start, build prefix sums, total sum, pick random in [0, total), find index via binary search, return index, End. Provide each line with explanation comment.\n\nLet's produce. Ensure \"Start\" then steps. Use \"→\" arrows. Use Decision for binary search. Provide each line. Ensure each line: virtual code + space + // explanation. Provide Chinese explanation.\n\nLet's create.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 w // 取得權重陣列  \n→ Step 2: 建立前綴和陣列 prefix，prefix[0] = w[0]  \n  → Loop i from 1 to w.length-1  \n    prefix[i] = prefix[i-1] + w[i] // 計算累積權重  \n→ Step 3: 計算總權重 total = prefix[w.length-1] // 取得所有權重之和  \n→ Step 4: 產生隨機數 r，範圍 [0, total) // r 為隨機浮點數  \n→ Decision: 找出最小的 i 使得 prefix[i] > r // 這是二分搜尋的決策  \n  Yes → Step 5: 回傳索引 i // 依權重選出的索引  \n→ End // 程式執行結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 若其中一個為 0，直接回傳 0\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 結果長度最多 m+n\n        result = [0] * (m + n)\n\n        # 兩層迴圈從右往左計算\n        for i in range(m - 1, -1, -1):\n            d1 = ord(num1[i]) - 48          # 字元轉成數字\n            for j in range(n - 1, -1, -1):\n                d2 = ord(num2[j]) - 48\n                prod = d1 * d2\n                p1, p2 = i + j, i + j + 1\n                summ = prod + result[p2]\n\n                result[p1] += summ // 10   # 加上進位\n                result[p2] = summ % 10     # 本位數字\n\n        # 轉成字串，跳過前導 0\n        # result 可能還有前導 0，例如 000123\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n        return ''.join(str(d) for d in result[start:])\n\ndef main():\n    data = sys.stdin.read()\n    # 以非數字字元分割，取出第一個兩個數字串\n    parts = re.findall(r\"\\d+\", data)\n    if len(parts) < 2:\n        # 若沒有找到足夠數字，嘗試逐行讀取\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            parts = [lines[0].strip(), lines[1].strip()]\n        else:\n            # 無法取得輸入，直接結束\n            return\n\n    num1, num2 = parts[0], parts[1]\n    sol = Solution()\n    result = sol.multiply(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code line by line for multiplying two large numbers represented as strings, without using BigInteger or converting to integer. So we need to implement classic grade-school multiplication.\n\nWe need to produce virtual code steps, each line with arrow arrow etc. Format example: \"Start // 程式開始執行\" etc.\n\nWe must give the algorithm steps. We need to consider input strings num1, num2. Steps: check if either is \"0\" return \"0\". Determine lengths. Create result array of zeros length m+n. For i from m-1 down to 0, for j from n-1 down to 0, multiply digit, add to result[i+j+1] etc. Then handle carry. Convert result array to string skipping leading zeros. Return string.\n\nAlso need to note that we cannot use BigInteger or integer conversion; we use char to int conversion: int d1 = num1.charAt(i) - '0'; etc.\n\nWe need to produce virtual code with arrow arrow and decisions. Let's format accordingly. We can break into logical steps. The code should not be actual code but pseudocode with arrows. Provide explanation for each line.\n\nLet's produce:\n\nStart // start\n\n→ Decision: 是否其中一個為 \"0\"? // check zero\n\nYes → Step 1: 返回 \"0\" // if zero return\n\nNo  → Step 2: 定義 m = length(num1), n = length(num2) // lengths\n\n→ Step 3: 創建整型陣列 result 尺寸 m+n 初始化為 0 // result array\n\n→ Step 4: 迴圈 i from m-1 down to 0 // outer loop\n\n    → Step 5: 取 d1 = num1[i] - '0' // first digit\n\n    → Step 6: 內部迴圈 j from n-1 down to 0 // inner loop\n\n        → Step 7: 取 d2 = num2[j] - '0' // second digit\n\n        → Step 8: 乘積 prod = d1 * d2 // product\n\n        → Step 9: 累加到 result[i+j+1] += prod // add to position\n\n→ Step 10: 迴圈 k from m+n-1 down to 1 // handle carry\n\n        → Step 11: carry = result[k] / 10 // carry digit\n\n        → Step 12: result[k] = result[k] % 10 // remainder\n\n        → Step 13: result[k-1] += carry // add carry to left\n\n→ Step 14: 建立 StringBuilder sb // string builder\n\n→ Step 15: 迴圈 p from 0 to m+n-1\n\n        → Decision: 如果 result[p] 為 0 且 sb 仍空? // skip leading zeros\n\n            Yes → Continue // skip\n\n            No  → Step 16: sb.append(result[p]) // append digit\n\n→ Step 17: 返回 sb.toString() // 結果\n\nEnd\n\nNeed to use arrow format: \"→ Step ...\" and \"    Yes → ...\" etc.\n\nAlso the decision lines: \"Decision: ...\" with Yes/No lines indented. Ensure each line ends with // 解釋/說明.\n\nMake sure to include proper indentation with spaces? Example from sample: They used two spaces before Yes/No. Use four spaces? In sample they had \"    Yes → ...\" (4 spaces). Use that.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 其中一個數字是否為 \"0\"? // 檢查是否有零輸入  \n    Yes → Step 1: 返回 \"0\" // 任何一個為 0 時結果為 0  \n    No  → Step 2: 設定 m = num1.length(), n = num2.length() // 取得兩字串長度  \n→ Step 3: 創建整數陣列 result，大小為 m + n，全部初始化為 0 // 用來儲存各位乘積  \n→ Step 4: 從 i = m - 1 迴圈到 0 // 外層迴圈遍歷 num1 的每個位數  \n    → Step 5: 取 d1 = num1.charAt(i) - '0' // 將字元轉為數值  \n    → Step 6: 從 j = n - 1 迴圈到 0 // 內層迴圈遍歷 num2 的每個位數  \n        → Step 7: 取 d2 = num2.charAt(j) - '0' // 將字元轉為數值  \n        → Step 8: prod = d1 * d2 // 計算兩位數相乘的結果  \n        → Step 9: result[i + j + 1] += prod // 加入到對應位置，稍後再處理進位  \n→ Step 10: 從 k = m + n - 1 迴圈到 1 // 依序處理進位  \n        → Step 11: carry = result[k] / 10 // 取得進位值  \n        → Step 12: result[k] = result[k] % 10 // 留下本位數字  \n        → Step 13: result[k - 1] += carry // 把進位加入左邊位數  \n→ Step 14: 建立 StringBuilder sb // 用來組裝最終字串  \n→ Step 15: 從 p = 0 迴圈到 m + n - 1 // 遍歷結果陣列  \n        → Decision: result[p] 為 0 且 sb 仍然空? // 避免前導零  \n            Yes → Continue // 跳過前導零  \n            No  → Step 16: sb.append(result[p]) // 把數字加入 sb  \n→ Step 17: 返回 sb.toString() // 產生乘積字串  \nEnd // 程式執行結束"
    }
  ]
}