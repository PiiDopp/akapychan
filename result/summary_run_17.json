{
  "run_index": 17,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 294,
  "generation_or_validation_failure_count": 40,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,2,6,4,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 2, 6, 4, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入內容（可多行）\n    code = sys.stdin.read()\n    # 在同一個命名空間下執行輸入的程式碼，這樣就能呼叫 roll_dice\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Format: \"虛擬碼步驟 // 解釋\". Use arrows, decisions. Need to implement random module, function roll_dice(n) simulate n dice rolls, return list.\n\nWe'll have Start, maybe import random, define function, loop, append random int between 1-6, return list, End.\n\nLet's craft. Each line: \"Start // 程式開始執行\". Next: \"→ Step 1: 導入 random 模組 // 需要隨機數\". Then \"→ Step 2: 定義函數 roll_dice(n) // 以 n 為參數\". Inside function: \"→ Step 3: 初始化空列表 results = [] // 用來存結果\". \"→ Step 4: 循環 i 從 1 到 n // 擲 n 次\". \"→ Step 5: 在循環內生成 random.randint(1,6) 並 append 到 results // 擲骰子\". \"→ Step 6: 循環結束後返回 results // 結果回傳\". Then End. Might need indent arrow for inside loop? We can use indentation via arrow and spaces. But format requires just each line. Use maybe \"→ Decision:\"? Not necessary. But we can show loop using arrow. Ok.\n\nMake sure no actual code. Use descriptive. We'll produce lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 載入 random 模組 // 讓程式能夠產生隨機數  \n→ Step 2: 定義函式 roll_dice(n) // 以 n 為參數，表示擲骰子的次數  \n→ Step 3: 初始化空列表 results = [] // 用來儲存每一次擲骰子的結果  \n→ Step 4: 進入 for 循環 i 從 1 到 n // 迭代 n 次以模擬 n 次擲骰子  \n    → Step 5: 在循環內部執行 random.randint(1, 6) 並將結果 append 到 results // 產生 1~6 的隨機整數並存入列表  \n→ Step 6: 循環結束後回傳 results // 將所有擲骰結果以列表形式回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "學生資料類別設計",
      "source_file": "1100.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Alice的分數是90\\nBob的分數是80'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: 'Alice 的分數是 90\\nBob 的分數是 80'\nRaw Got:      ''"
        }
      ],
      "generated_code": "class Student:\n    def __init__(self, name, score):\n        \"\"\"初始化學生的姓名與分數\"\"\"\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        \"\"\"輸出『姓名 的分數是 分數』\"\"\"\n        print(f'{self.name} 的分數是 {self.score}')\n\n\ndef main():\n    import sys\n\n    # 讀取所有非空行，若沒有輸入則使用預設資料\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n\n    # 若無任何輸入，直接建立兩個預設學生並顯示資訊\n    if not lines:\n        s1 = Student('Alice', 90)\n        s2 = Student('Bob', 80)\n        s1.show_info()\n        s2.show_info()\n        return\n\n    # 若有輸入，預期每行格式為「姓名 分數」\n    students = []\n    for line in lines:\n        parts = line.split()\n        if len(parts) >= 2:\n            name = parts[0]\n            try:\n                score = int(parts[1])\n            except ValueError:\n                continue  # 若分數不是數字則忽略此行\n            students.append(Student(name, score))\n\n    # 逐一顯示每位學生的資訊\n    for student in students:\n        student.show_info()\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line, each line: virtual code step + space + // explanation. Use arrow syntax: Start, →, Decision etc. No actual code. Should represent class definition, init, method, instantiation, calling method. Use arrows for flow.\n\nLet's craft:\n\nStart\n→ Class Student // 定義 Student 類別\n→ Step 1: 定義 __init__(self, name, score) // 初始化 name 與 score\n→ Step 2: self.name = name // 存儲姓名\n→ Step 3: self.score = score // 存儲分數\n→ Step 4: 定義 show_info(self) // 方法宣告\n→ Step 5: print(f'{self.name} 的分數是 {self.score}') // 輸出訊息\n→ End // 類別定義結束\n→ Step 6: 建立 obj1 = Student('Alice', 90) // 第一個物件\n→ Step 7: 建立 obj2 = Student('Bob', 75) // 第二個物件\n→ Step 8: 呼叫 obj1.show_info() // 輸出 Alice 的分數\n→ Step 9: 呼叫 obj2.show_info() // 輸出 Bob 的分數\nEnd // 程式結束\n\nBut we need arrow for decision? Not needed. Use \"→\" preceding each step. Format: \"Start // 程式開始執行\". Let's produce.\n\nBut the requirement: Use 虛擬碼的箭頭 (→, Yes →, No →) and 結構 (Start, End, Decision:). So we can start with Start.\n\nSo output lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 Class Student // 建立 Student 類別\n→ Step 2: 定義 __init__(self, name, score) // 建構子\n→ Step 3: self.name = name // 儲存姓名\n→ Step 4: self.score = score // 儲存分數\n→ Step 5: 定義 show_info(self) // 定義顯示方法\n→ Step 6: print(f'{self.name} 的分數是 {self.score}') // 輸出訊息\n→ Step 7: End // 結束類別定義\n→ Step 8: 建立 obj1 = Student('Alice', 90) // 第一個物件\n→ Step 9: 建立 obj2 = Student('Bob', 75) // 第二個物件\n→ Step 10: 呼叫 obj1.show_info() // 顯示 Alice 分數\n→ Step 11: 呼叫 obj2.show_info() // 顯示 Bob 分數\nEnd // 程式結束\n\nBut need to use \"End\" at the end of class definition? We can use \"End // 結束類別定義\" maybe but \"End\" might conflict with main End. Better to just use \"End\" only at program end. So after step 6, we don't need another End. So we keep it simple.\n\nThus final.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Class Student // 建立 Student 類別  \n→ Step 2: 定義 __init__(self, name, score) // 建構子，用來初始化屬性  \n→ Step 3: self.name = name // 儲存姓名屬性  \n→ Step 4: self.score = score // 儲存分數屬性  \n→ Step 5: 定義 show_info(self) // 定義顯示資訊的方法  \n→ Step 6: print(f'{self.name} 的分數是 {self.score}') // 輸出『姓名 的分數是 分數』  \n→ Step 7: 建立 obj1 = Student('Alice', 90) // 創建第一個 Student 物件  \n→ Step 8: 建立 obj2 = Student('Bob', 75) // 創建第二個 Student 物件  \n→ Step 9: 呼叫 obj1.show_info() // 顯示 Alice 的分數  \n→ Step 10: 呼叫 obj2.show_info() // 顯示 Bob 的分數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"apple\",\"orange\",\"melon\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'apple', 'orange', 'melon', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    處理程式邏輯，將水果集合做增刪改操作並輸出結果。\n    \"\"\"\n    # 讀取所有輸入（即使此程序不使用任何輸入）\n    sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 新增 'orange'\n    fruits.add('orange')\n\n    # 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 移除 'banana'\n    fruits.remove('banana')\n\n    # 嘗試移除不存在的 'pineapple'，不會拋錯\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation comments. Format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows etc. Need Start, End, decisions? Not necessary, but can use. We'll produce linear steps. Include Start, End. Provide each line with arrow. Use virtual code: \"→ Step 1: ...\" etc. Provide explanations.\n\nLet's do:\n\nStart\n→ Step 1: 初始化 fruits = {'apple', 'banana'} // 創建集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在的 'pineapple'\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd\n\nMake sure each line has arrow maybe but not necessary all lines. Provide explanation after //.\n\nLet's format exactly as required: each line: \"虛擬碼步驟 // 解釋\". Use spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 fruits = {'apple', 'banana'} // 創建一個包含 'apple' 與 'banana' 的集合\n→ Step 2: fruits.add('orange') // 使用 add() 將 'orange' 新增到 fruits\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'，若不存在會拋出錯誤\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'，不存在時不會出錯\n→ Step 6: 輸出 fruits // 顯示最終的 fruits 集合\nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.66TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.66 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\nimport tkinter as tk\n\ndef get_rate():\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        rate = data['rates']['TWD']\n        return rate\n    except Exception as e:\n        return None\n\ndef print_rate():\n    rate = get_rate()\n    if rate is not None:\n        print(f'目前美元匯率：約 {rate} TWD')\n    else:\n        print('更新失敗，請檢查網路連線')\n\n# GUI part\ndef run_gui():\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def on_update():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=on_update).pack(pady=5)\n\n    win.mainloop()\n\nif __name__ == '__main__':\n    # read entire stdin\n    try:\n        user_input = sys.stdin.read().strip()\n    except Exception:\n        user_input = ''\n\n    # if input indicates update, output rate\n    if '更新匯率' in user_input or '按下' in user_input:\n        print_rate()\n    else:\n        # no input or not recognized, run GUI\n        run_gui()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for the requirement. Use virtual code with arrows. Must include Start, End, Decision. Use virtual steps. No real code. Steps: import requests, tkinter. Create main window. Label to show rate. Button to fetch. Function to fetch: call API, parse JSON, get TWD rate, update label. Bind button. Then main loop. Ensure each line: Virtual code step + // explanation. Use arrows. Use Decision for error handling maybe. Use Yes/No branches for success/failure. Provide sequential. Also include Start and End. Ensure no actual code. Let's create steps:\n\nStart\n→ Step 1: Import requests module // Load HTTP client library\n→ Step 2: Import tkinter module // Load GUI toolkit\n→ Step 3: Define function fetch_rate() // Function to get exchange rate\n    → Step 3.1: Make GET request to API URL // Retrieve latest rates\n    → Decision: If request successful? // Check status\n        Yes → Step 3.2: Parse JSON response // Convert to data structure\n            → Step 3.3: Extract TWD rate // Get specific currency value\n            → Step 3.4: Update label text with rate // Display in GUI\n        No  → Step 3.5: Update label text with error message // Inform failure\n→ Step 4: Create main Tk window // Initialize GUI\n→ Step 5: Create Label widget to show rate // Placeholder text\n→ Step 6: Create Button widget labeled \"更新匯率\" // Button to trigger fetch\n    → Step 6.1: Assign command fetch_rate to button // Bind action\n→ Step 7: Arrange widgets using pack/grid // Layout\n→ Step 8: Call fetch_rate() once to display initial rate // Initial data\n→ Step 9: Start Tk main loop // Run GUI event loop\nEnd\n\nNeed arrow syntax: → Step X. For decisions: Decision: ... Yes → ... No → ... Indent.\n\nMake sure each line ends with // explanation. Provide proper spacing. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests module // 載入 HTTP 客戶端庫  \n→ Step 2: Import tkinter module // 載入圖形界面工具  \n→ Step 3: Define function fetch_rate() // 定義獲取匯率的函式  \n → Step 3.1: Make GET request to API URL // 送出 GET 請求取得最新匯率資料  \n → Decision: 如果請求成功? // 判斷 HTTP 狀態碼是否為 200  \n  Yes → Step 3.2: Parse JSON response // 將回傳資料轉成字典  \n   → Step 3.3: Extract TWD rate // 取得「TWD」欄位的匯率值  \n   → Step 3.4: Update label text with rate // 將匯率顯示在 GUI 標籤  \n  No  → Step 3.5: Update label text with error message // 顯示錯誤提示  \n→ Step 4: Create main Tk window // 初始化主視窗  \n→ Step 5: Create Label widget to show rate // 佈建顯示匯率的標籤  \n→ Step 6: Create Button widget labeled \"更新匯率\" // 佈建更新按鈕  \n → Step 6.1: Assign command fetch_rate to button // 把按鈕與函式綁定  \n→ Step 7: Arrange widgets using pack/grid // 設定元件排版  \n→ Step 8: Call fetch_rate() once to display initial rate // 初始載入匯率  \n→ Step 9: Start Tk main loop // 啟動 GUI 事件迴圈  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,null,true,false,true,2,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, null, true, false, true, 2, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        index = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Wrap the two lists into an outer list to make it a valid Python literal\n    data = '[' + data + ']'\n    ops, args = ast.literal_eval(data)\n\n    result = [None]  # first operation is the constructor -> null\n    instance = None\n\n    for op, arg in zip(ops, args):\n        if op == 'RandomizedSet':\n            instance = RandomizedSet()\n            result.append(None)\n        elif op == 'insert':\n            result.append(instance.insert(arg[0]))\n        elif op == 'remove':\n            result.append(instance.remove(arg[0]))\n        elif op == 'getRandom':\n            result.append(instance.getRandom())\n        else:\n            # Unknown operation, append None\n            result.append(None)\n\n    # Print the result in JSON format to match expected output\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for RandomizedSet. We must outline structure: Start, use a hash map for val to index in array, array list to store values. For insert: if val exists, return false; else append to array, set map. For remove: if val not exists, return false; else swap last element to index, update map, pop. Return true. getRandom: random index from array. End. Provide each line with explanation.\n\nWe must produce step lines with arrows, decisions. So produce like:\n\nStart // start\n→ Step 1: Initialize empty map and array // data structures\n→ Step 2: Define insert(val)\n    → Decision: if val in map?\n        Yes → Step 3: Return false // already present\n        No  → Step 4: Append val to array; map[val] = last index; Return true\n→ Step 5: Define remove(val)\n    → Decision: if val not in map?\n        Yes → Step 6: Return false\n        No  → Step 7: index = map[val]; lastVal = array[-1];\n            → Decision: if index != last index?\n                Yes → Step 8: array[index] = lastVal; map[lastVal] = index; // swap\n                No  → // no swap needed\n            → Step 9: Remove last element from array; delete map[val]; Return true\n→ Step 10: Define getRandom()\n    → Step 11: idx = random integer between 0 and len(array)-1; Return array[idx]\nEnd\n\nAdd explanations after //. Ensure format: \"虛擬碼步驟 // 解釋\". Each line separate.\n\nWe need use virtual code arrows. Use \"→\" to indent steps. We can also use \"Decision:\" lines. Provide comments.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的哈希表 map 和動態陣列 arr // 用於 O(1) 存取與隨機索引  \n→ Step 2: 定義 insert(val) // 插入操作  \n  Decision: 若 val 已存在於 map? // 檢查重複  \n   Yes → Step 3: 回傳 false // 已存在，不插入  \n   No  → Step 4: 將 val 加入 arr 的尾部 // 存入資料  \n    → Step 5: map[val] = arr.size() - 1 // 記錄其索引  \n    → Step 6: 回傳 true // 成功插入  \n→ Step 7: 定義 remove(val) // 刪除操作  \n  Decision: 若 val 不在 map? // 無此元素  \n   Yes → Step 8: 回傳 false // 刪除失敗  \n   No  → Step 9: index = map[val] // 取得要刪除的索引  \n     lastVal = arr.back() // 取陣列最後一個值  \n     Decision: 若 index ≠ arr.size() - 1? // 需要交換  \n      Yes → Step 10: arr[index] = lastVal // 把最後一個放到要刪除的位置  \n       → Step 11: map[lastVal] = index // 更新索引  \n      No  → // 如果已是最後一個，無需交換  \n     → Step 12: arr.pop_back() // 刪除陣列最後一個元素  \n     → Step 13: map.erase(val) // 從哈希表移除鍵  \n     → Step 14: 回傳 true // 成功刪除  \n→ Step 15: 定義 getRandom() // 取得隨機元素  \n  Step 16: idx = randInt(0, arr.size() - 1) // 產生隨機索引  \n   → Step 17: 回傳 arr[idx] // 等機率返回元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp23vimhsk.py\", line 82, in <module>\n    main()\n  File \"/tmp/tmp23vimhsk.py\", line 59, in main\n    commands = json.loads(data[0])            # e.g. [\"Solution\", \"flip\", \"reset\"]\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 54 (char 53)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    \"\"\"隨機翻轉矩陣中0的位置，確保所有0位置等機率被選中。\"\"\"\n\n    def __init__(self, m: int, n: int):\n        \"\"\"\n        建構子：初始化矩陣尺寸、剩餘可翻轉格子數量，以及映射表。\n        mapping[i] 代表在當前隨機池中的第 i 個可用格子實際對應的線性索引。\n        \"\"\"\n        self.m = m\n        self.n = n\n        self.total = m * n            # 總格子數\n        self.remaining = self.total   # 仍可翻轉的格子數\n        self.mapping = list(range(self.total))  # 初始映射 0..total-1\n\n    def flip(self):\n        \"\"\"\n        隨機選取一個尚未被翻轉的格子，將其翻轉為1。\n        這裡使用類似 Fisher‑Yates 洗牌的技巧，避免重複選取。\n        \"\"\"\n        if self.remaining == 0:\n            return None  # 若已無空位，返回 None\n\n        # 隨機選取 0 .. remaining-1 之間的一個索引\n        r = random.randint(0, self.remaining - 1)\n\n        # 取得真正的格子索引\n        idx = self.mapping[r]\n\n        # 將選中的索引移至「已使用」區域（即 remaining-1 位置）\n        self.mapping[r], self.mapping[self.remaining - 1] = (\n            self.mapping[self.remaining - 1],\n            self.mapping[r],\n        )\n\n        # 更新剩餘可翻轉格子數\n        self.remaining -= 1\n\n        # 把線性索引轉回 (row, col)\n        return [idx // self.n, idx % self.n]\n\n    def reset(self):\n        \"\"\"\n        將矩陣重設為全0，並重置映射表和剩餘數量。\n        \"\"\"\n        self.remaining = self.total\n        self.mapping = list(range(self.total))\n\n\ndef main():\n    # 讀取 stdin：兩行，第一行為指令列表，第二行為參數列表\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    commands = json.loads(data[0])            # e.g. [\"Solution\", \"flip\", \"reset\"]\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    obj = None\n    outputs = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)  # args: [m, n]\n            outputs.append(None)   # Constructor返回 null\n        elif cmd == \"flip\":\n            outputs.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            outputs.append(None)   # reset返回 null\n        else:\n            outputs.append(None)   # 不支援的指令，視情況處理\n\n    # 輸出符合 LeetCode 風格的結果，使用 json.dumps 以得到 null 等格式\n    print(json.dumps(outputs))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for algorithm. Use virtual code lines with explanations. The problem: random flip of zeros in m*n binary matrix. Approach: use reservoir? Actually standard solution: maintain list of available indices mapping from index to coordinates. Use Fisher-Yates like method: maintain array of size m*n of indices 0..m*n-1. At each flip, pick random r from 0 to k-1 (k remaining), swap arr[r] with arr[k-1], decrement k. Convert arr[k] to coordinates. Reset clears arr to identity and resets k. Complexity O(1) time per flip, O(m*n) space.\n\nWe need to write virtual code for class, constructor, flip, reset.\n\nNeed to include Start, End, Decision, etc.\n\nProvide step-by-step. For each line, explanation. Use arrow and indentation for decisions.\n\nLet's produce.\n\nWe need to consider that we have variables:\n\n- total = m*n\n- mapping = array of size total\n- remaining = total\n\nInitialize mapping[i] = i for all.\n\nFlip: if remaining ==0 maybe error but assume called only when zeros exist.\n\n- r = randomInt(0, remaining-1)\n- index = mapping[r]\n- mapping[r] = mapping[remaining-1]\n- mapping[remaining-1] = index? Actually we need to swap r with remaining-1. So mapping[r], mapping[remaining-1] = mapping[remaining-1], mapping[r]\n- remaining--\n- return [index/m, index%n]\n\nReset:\n\n- for i in 0..total-1 mapping[i]=i\n- remaining=total\n\nNow produce virtual code line by line with explanation.\n\nWill start with class definition:\n\nStart // 初始化Solution物件\n\nWe will show the steps inside constructor, flip, reset.\n\nLet's output:\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 Solution(m, n) // 建構子，接收行列數\n    → Step 1.1: 設定 this.total = m * n // 總格數\n    → Step 1.2: 建立陣列 this.map[0..total-1] // 儲存可用索引\n    → Step 1.3: for i 0 .. total-1: this.map[i] = i // 初始化映射\n    → Step 1.4: 設定 this.remaining = total // 剩餘可翻轉格子數\n→ End // 完成建構\n...\n```\n\nThen flip function. Provide lines.\n\nNeed to use Decision: if remaining==0? But not necessary.\n\nWe'll include:\n\n```\n→ Step 2: 定義 flip() // 取得隨機零並翻轉\n    → Decision: 是否還有剩餘格子? // 確認 remaining > 0\n        Yes → Step 2.1: r = randomInt(0, remaining-1) // 隨機索引\n        → Step 2.2: idx = this.map[r] // 取得實際格子索引\n        → Step 2.3: this.map[r] = this.map[remaining-1] // 交換\n        → Step 2.4: this.map[remaining-1] = idx\n        → Step 2.5: this.remaining-- // 更新剩餘數\n        → Step 2.6: return [idx / n, idx % n] // 轉回座標\n        No → Step 2.7: return null // 或錯誤處理\n→ End\n```\n\nReset function:\n\n```\n→ Step 3: 定義 reset() // 重設矩陣\n    → Step 3.1: for i 0 .. total-1: this.map[i] = i // 重新映射\n    → Step 3.2: this.remaining = total // 重置剩餘數\n→ End\n```\n\nAnd End main. Provide End.\n\nLet's craft final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 Solution(m, n) // 建構子，接收行列數\n    → Step 1.1: 設定 this.total = m * n // 總格數\n    → Step 1.2: 建立陣列 this.map[0..total-1] // 儲存可用索引\n    → Step 1.3: for i 0 .. total-1: this.map[i] = i // 初始化映射\n    → Step 1.4: 設定 this.remaining = total // 剩餘可翻轉格子數\n→ End // 完成建構\n\n→ Step 2: 定義 flip() // 取得隨機零並翻轉\n    → Decision: 是否還有剩餘格子? // 確認 remaining > 0\n        Yes → Step 2.1: r = randomInt(0, remaining-1) // 隨機索引\n        → Step 2.2: idx = this.map[r] // 取得實際格子索引\n        → Step 2.3: this.map[r] = this.map[remaining-1] // 交換\n        → Step 2.4: this.map[remaining-1] = idx\n        → Step 2.5: this.remaining-- // 更新剩餘數\n        → Step 2.6: return [idx / n, idx % n] // 轉回座標\n        No → Step 2.7: return null // 或錯誤處理\n→ End\n\n→ Step 3: 定義 reset() // 重設矩陣\n    → Step 3.1: for i 0 .. total-1: this.map[i] = i // 重新映射\n    → Step 3.2: this.remaining = total // 重置剩餘數\n→ End\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findSubstringInWraproundString(self, s: str) -> int:\n        # dp[i] 表示以字母 chr(i + ord('a')) 結尾的最大子串長度\n        dp = [0] * 26\n        k = 0  # 目前連續子串長度\n\n        for i, ch in enumerate(s):\n            if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n                k += 1\n            else:\n                k = 1\n            idx = ord(ch) - ord('a')\n            if k > dp[idx]:\n                dp[idx] = k\n\n        return sum(dp)\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中提取所有小寫英文字母，拼接成字符串\n    s = ''.join(re.findall('[a-z]', data))\n    solution = Solution()\n    result = solution.findSubstringInWraproundString(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps. The problem: count unique non-empty substrings of s that appear in infinite wraparound string base, which is repeated alphabet with wrap-around adjacency.\n\nThis is known LeetCode 467 \"Unique Substrings in Wraparound String\". Approach: For each character, track the longest contiguous substring ending at that character that follows wrap-around rule. Then the number of unique substrings is sum of lengths of longest substrings ending at each letter. Because each distinct substring is determined by its ending letter and length. So we maintain an array of 26, maxLen[char] = maximum length of substring ending with that char that satisfies consecutive rule. Iterate over s, keep currentLen, if s[i] follows s[i-1] (i.e., (s[i]-s[i-1]+26)%26==1) then currentLen++ else currentLen=1. Update maxLen[char] = max(maxLen[char], currentLen). Finally sum all maxLen. Return sum.\n\nWe need virtual code line by line with explanation.\n\nStart, then initialize array, etc. We'll follow format.\n\nMake sure each line ends with \"// 解釋/說明\". Use arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 maxLen[26] 初始化為 0 // 儲存每個字母結尾時可形成的最大合法子串長度\n→ Step 2: currentLen ← 0 // 當前連續合法子串長度\n→ Decision: 是否 s 為空? // 檢查輸入字串是否為空\n    Yes → Step 3: Return 0 // 空字串無合法子串\n    No  → Continue\n→ Step 4: For i 從 0 到 len(s)-1 迴圈 // 逐個遍歷 s 的字符\n    → Step 5: 如果 i > 0 且 (s[i] - s[i-1] + 26) % 26 == 1\n        → Step 6: currentLen ← currentLen + 1 // 繼續符合環繞規則的連續子串\n        No  → Step 7: currentLen ← 1 // 重新開始新的子串\n    → Step 8: idx ← s[i] - 'a' // 轉換字符為索引\n    → Step 9: maxLen[idx] ← max(maxLen[idx], currentLen) // 更新以此字符結尾的最大長度\n→ Step 10: sum ← 0 // 儲存所有字母的最大長度總和\n→ Step 11: For each val in maxLen\n    → Step 12: sum ← sum + val // 累加\n→ Step 13: Return sum // 總數即為唯一合法子串數\nEnd // 程式執行結束\n\nMake sure each line uses arrow appropriately. For Step 4 the for loop we need arrow to next steps? Use arrow to step 5, etc.\n\nNeed each line: \"虛擬碼步驟 // 解釋/說明\"\n\nMake sure arrows are correct: Use \"→\" for normal steps. For decision: \"Decision:\" with Yes→ etc.\n\nI'll format accordingly.\n\nAlso step 4 \"For i 從 0 到 len(s)-1 迴圈\" then within loop we need steps. We can indent? But in this format we just write sequentially; maybe use arrow to indicate inside loop.\n\nSimplify: use \"→ Step 4: For i ← 0 to len(s)-1 // 迴圈遍歷 s\" then \"→ Step 5: If i > 0 且 (s[i]-s[i-1]+26)%26==1 // 判斷是否連續\" then \"→ Step 6: currentLen ← currentLen + 1\" else \"→ Step 7: currentLen ← 1\". Then \"→ Step 8: idx ← s[i] - 'a' // 字符轉索引\" etc.\n\nBetter to keep decision nested.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義 maxLen[26] 初始化為 0 // 儲存每個字母結尾時可形成的最大合法子串長度\n→ Step 2: currentLen ← 0 // 當前連續合法子串長度\n→ Decision: 是否 s 為空? // 檢查輸入字串是否為空\n    Yes → Step 3: Return 0 // 空字串無合法子串\n    No  → Continue\n→ Step 4: For i ← 0 to len(s)-1 迴圈 // 逐個遍歷 s 的字符\n    → Decision: i > 0 且 (s[i]-s[i-1]+26)%26 == 1? // 判斷當前字符是否與前一字符連續\n        Yes → Step 5: currentLen ← currentLen + 1 // 繼續符合環繞規則的連續子串\n        No  → Step 6: currentLen ← 1 // 重新開始新的子串\n    → Step 7: idx ← s[i] - 'a' // 轉換字符為索引\n    → Step 8: maxLen[idx] ← max(maxLen[idx], currentLen) // 更新以此字符結尾的最大長度\n→ Step 9: sum ← 0 // 儲存所有字母的最大長度總和\n→ Step 10: For each val in maxLen\n    → Step 11: sum ← sum + val // 累加\n→ Step 12: Return sum // 總數即為唯一合法子串數\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        # 先排序，方便統一處理重複元素\n        nums.sort()\n        res = [[]]  # 初始只包含空集合\n        for num in nums:\n            # 對目前所有子集再加一個 num，產生新的子集\n            new_subsets = [subset + [num] for subset in res]\n            res += new_subsets\n        # 移除重複的子集，使用 tuple 做為可哈希鍵\n        unique_res = []\n        seen = set()\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n        return unique_res\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 允許輸入為 'nums = [...]' 或僅為列表字面量\n    if data.startswith('nums'):\n        # 分離等號後面的列表字面量\n        _, expr = data.split('=', 1)\n        nums = eval(expr.strip())\n    else:\n        nums = eval(data)\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of an array with possible duplicates, ensuring no duplicate subsets. That's the classic subset problem with duplicates: sort array, then backtrack including or excluding, but skip duplicates when start>prev.\n\nWe need to output line by line: Start, steps, decisions etc. Provide comments.\n\nWe need to not output actual code but virtual code with arrows. Each line: \"虛擬碼步驟 // 解釋\". Use arrows →, Yes→, No→, Decision:.\n\nWe should outline steps: input array, sort, backtrack function with parameters (index, current subset). At each step: add current subset to result. Decision: if index < length? Yes → recursively include element at index, then skip duplicates: while next element same as current, increment index to skip duplicates when excluding. Actually typical algorithm: For i from index to n-1: if i>index && nums[i]==nums[i-1] continue; add nums[i] to subset; backtrack(i+1,...); remove.\n\nBut we can produce a simplified virtual pseudocode with decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input nums // 取得輸入數列\n→ Sort nums ascending // 方便處理重複元素\n→ Initialize result as empty list // 存放所有子集\n→ Define RecursiveBacktrack(current, start) // 產生子集的遞迴函式\n    → Add copy of current to result // 每個遞迴呼叫都把當前子集加入結果\n    → Decision: 如果 start < length(nums)? // 是否還有元素可以考慮加入\n        Yes → For i from start to length(nums)-1 // 遍歷可選元素\n            → Decision: 如果 i > start 且 nums[i] == nums[i-1]? // 跳過重複的選擇\n                Yes → Continue // 跳過此重複元素\n                No  → \n                    → Append nums[i] to current // 選擇該元素\n                    → RecursiveBacktrack(current, i+1) // 進一步遞迴\n                    → Remove last element from current // 回溯\n        No → End // 走到這裡說明沒有更多元素可選\nEnd // 程式結束\n\nBut we need to output line by line with virtual code lines. We can break each step into separate lines: Start, Input, Sort, etc.\n\nMake sure each line has the virtual code step and comment.\n\nWe might need to indent substeps. We can use indentation to show nested. But it's not required. Use arrow \"→\".\n\nWe need to include decisions and Yes→/No→.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input nums // 取得輸入整數陣列  \n→ Sort nums ascending // 先排序以便處理重複元素  \n→ Initialize result as empty list // 用來儲存所有子集  \n→ Define RecursiveBacktrack(current, start) // 定義遞迴產生子集的函式  \n    → Add copy of current to result // 把目前子集加入結果  \n    → Decision: start < length(nums)? // 還有可以選擇的元素嗎？  \n        Yes → For i from start to length(nums)-1 // 逐一嘗試每個候選元素  \n            → Decision: i > start AND nums[i] == nums[i-1]? // 重複元素需跳過  \n                Yes → Continue // 跳過此重複元素  \n                No  →  \n                    → Append nums[i] to current // 選擇此元素  \n                    → RecursiveBacktrack(current, i+1) // 進一步遞迴  \n                    → Remove last element from current // 回溯到上一層  \n        No  → End // 沒有更多元素可選，結束遞迴  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,3,0,2]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 3, 0, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立字典，將每個數字映射到所有索引的位置\n        self.index_map = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.index_map[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選 target 的任一個索引\n        return random.choice(self.index_map[target])\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入分成兩部分：commands 與對應的參數\n    # 假設第一個 ']' 為命令列表結束的位置\n    end_cmd_idx = data.find(']')\n    commands_str = data[:end_cmd_idx + 1]\n    args_str = data[end_cmd_idx + 2:].strip()  # 跳過 '],'\n\n    # 轉換成 Python 資料結構\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    # 執行操作並收集結果\n    outputs = []\n    instance = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            instance = Solution(arg[0])\n            outputs.append(None)\n        elif cmd == \"pick\":\n            result = instance.pick(arg[0])\n            outputs.append(result)\n        else:\n            # 如果有其他命令，直接拋出錯誤\n            raise ValueError(f\"Unknown command: {cmd}\")\n\n    # 輸出結果列表\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step: initialize, pick random with reservoir sampling? Since we need equal probability among indices that equal target. Approach: During initialization, store mapping from target to list of indices. Then pick random index from that list.\n\nAlternatively, reservoir sampling in pick: iterate through array, count matches, for each match, with probability 1/c choose index.\n\nWe need to output virtual code lines with comments.\n\nSo produce:\n\nStart\n→ Step 1: Initialize class with nums array // store array\n→ Step 2: Build dictionary mapping number to list of indices // for quick lookup\n→ End\n\nThen pick method:\n\nStart // pick method\n→ Step 1: Retrieve list of indices for target // from map\n→ Decision: If list is empty? // should not happen\n    No → Step 2: Generate random integer between 0 and list.size()-1\n    Yes → Step 3: Return -1 // error\n→ Step 3: Return list[randomIndex] // random index\nEnd\n\nBut need reservoir? The dictionary approach is simple and ensures equal probability if choose random index from list. That's acceptable.\n\nLet's produce virtual code lines:\n\nStart // 程式開始\n→ Step 1: Store nums into member variable // Keep original array\n→ Step 2: Initialize empty map<number, list<int>> // mapping target to indices\n→ Step 3: For i from 0 to nums.length-1 // iterate array\n    → Step 4: val = nums[i]\n    → Step 5: If map does not contain val then create new list\n    → Step 6: Add i to map[val] // record index\n→ End // 初始結束\n\nThen pick:\n\nStart // pick 方法開始\n→ Step 1: indices = map[target] // get list of positions\n→ Decision: indices is null or empty? // should not happen\n    No → Step 2: randomIndex = Random(0, indices.size-1) // pick random within list\n    Yes → Step 3: Return -1 // error fallback\n→ Step 4: Return indices[randomIndex] // output random index\nEnd // pick 方法結束\n\nBut need to format exactly with arrow, etc.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: Store nums array in member variable // 保存原始陣列\n→ Step 2: Create empty map <int, list<int>> indexMap // 建立目標值到索引的對應表\n→ Step 3: For i from 0 to nums.length-1\n    → Step 4: val = nums[i] // 取得當前元素\n    → Step 5: If indexMap does not contain key val\n        → Step 6: indexMap[val] = new list // 初始化列表\n    → Step 7: indexMap[val].add(i) // 將索引加入列表\nEnd // 初始結束\n\nStart // pick 方法開始\n→ Step 1: indices = indexMap[target] // 取得目標值所有索引\n→ Decision: indices is null or indices.isEmpty()?\n    No → Step 2: randIdx = RandomInt(0, indices.size-1) // 隨機選取位置\n    Yes → Step 3: Return -1 // 出錯情況\n→ Step 4: Return indices[randIdx] // 返回隨機索引\nEnd // pick 方法結束\n\nEnsure each line ends with comment. Provide all lines sequentially. Ensure arrow indentation correct.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: Store nums array in member variable // 保存原始陣列\n→ Step 2: Create empty map <int, list<int>> indexMap // 建立目標值到索引的對應表\n→ Step 3: For i from 0 to nums.length-1\n    → Step 4: val = nums[i] // 取得當前元素\n    → Step 5: If indexMap does not contain key val\n        → Step 6: indexMap[val] = new list // 初始化列表\n    → Step 7: indexMap[val].add(i) // 將索引加入列表\nEnd // 初始結束\n\nStart // pick 方法開始\n→ Step 1: indices = indexMap[target] // 取得目標值所有索引\n→ Decision: indices is null or indices.isEmpty()?\n    No → Step 2: randIdx = RandomInt(0, indices.size-1) // 隨機選取位置\n    Yes → Step 3: Return -1 // 出錯情況\n→ Step 4: Return indices[randIdx] // 返回隨機索引\nEnd // pick 方法結束"
    },
    {
      "title": "Word Break",
      "source_file": "Leetcode/leetcode139.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8_6qz1rh.py\", line 42, in <module>\n    s, word_dict = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8_6qz1rh.py\", line 35, in parse_input\n    word_dict = ast.literal_eval(word_value)  # 轉成 list\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"leet\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpttv4pmr1.py\", line 42, in <module>\n    s, word_dict = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpttv4pmr1.py\", line 35, in parse_input\n    word_dict = ast.literal_eval(word_value)  # 轉成 list\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"apple\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpavil31rn.py\", line 42, in <module>\n    s, word_dict = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpavil31rn.py\", line 35, in parse_input\n    word_dict = ast.literal_eval(word_value)  # 轉成 list\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"cats\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n        # 將字典轉成集合，O(1) 進行查詢\n        word_set = set(wordDict)\n        # dp[i] 表示 s[:i] 能否被合法分割\n        dp = [False] * (len(s) + 1)\n        dp[0] = True  # 空字串可以被分割\n\n        # 外層遍歷每個可能的結尾位置\n        for i in range(1, len(s) + 1):\n            # 內層尋找可行的分割點 j\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break  # 找到合法分割即可\n        return dp[len(s)]\n\n\ndef parse_input(raw: str) -> tuple[str, list[str]]:\n    \"\"\"\n    將形如 's = \"leetcode\", wordDict = [\"leet\",\"code\"]' 的輸入轉為 (s, wordDict)。\n    \"\"\"\n    parts = raw.split(',')\n    # 解析 s\n    s_part = parts[0].strip()\n    s_value = s_part.split('=')[1].strip()\n    s = ast.literal_eval(s_value)  # 允許單雙引號\n\n    # 解析 wordDict\n    word_part = parts[1].strip()\n    word_value = word_part.split('=')[1].strip()\n    word_dict = ast.literal_eval(word_value)  # 轉成 list\n\n    return s, word_dict\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    s, word_dict = parse_input(raw_input)\n    result = Solution().wordBreak(s, word_dict)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for word break problem. Provide line-by-line. Use virtual code with arrows, decisions. Use Chinese comments. Should output only virtual code and comments. No real code. Provide steps: Start, input s and wordDict, DP array, loop over positions, inner loop over words or length, decision if substring in dict, set dp, etc. Provide End. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp[0] = true // dp[i] 表示前 i 個字可以被劃分  \n→ Step 2: 取得字串長度 n 和字典長度 m // 用於迴圈條件  \n→ Decision: n 是否為 0? // 檢查輸入字串是否為空  \n    Yes → Step 3: 輸出 true // 空字串可視為有效分割  \n    No → Step 4: 建立 dp[0..n] 且全部設為 false // 初始不合法  \n→ Decision: wordDict 是否為空? // 若字典為空則無法分割  \n    Yes → Step 5: 輸出 false  \n    No →  \n        → Decision: 是否要將每個單字加入字典集? // 準備查詢  \n            Yes → Step 6: 將 wordDict 轉成集合 setWords // 提升查詢速度  \n            No → Step 6: 直接使用 wordDict // 省略轉換  \n→ Step 7: 外層迴圈 for i from 1 to n // 每個可能的結尾位置  \n    → Decision: dp[i-1] 為 true? // 前一段已可分割  \n        Yes →  \n            → Step 8: 內層迴圈 for j from 0 to i-1 // 從前面找分割點  \n                → Decision: s[j:i] 是否在 setWords? // 檢查子字串是否為字典詞  \n                    Yes → Step 9: 設 dp[i] = true // 找到合法分割，結束內層迴圈  \n                            → End // 跳出內層迴圈，進入下一 i  \n                    No → 進行下一個 j  \n            → Decision: 是否已將 dp[i] 設為 true? // 內層結束後檢查  \n                Yes → 進行下一個 i  \n                No → 進行下一個 i  \n        No → 進行下一個 i  \n→ Step 10: 回傳 dp[n] // 是否整個字串可分割  \nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        Sort characters in decreasing order of frequency.\n        If frequencies tie, any order is acceptable.\n        \"\"\"\n        # Count frequency of each character\n        freq = Counter(s)\n        # most_common returns list sorted by frequency descending\n        # Build result string by repeating each character freq times\n        return ''.join(char * cnt for char, cnt in freq.most_common())\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    Extract the string value from a line like:\n        s = \"tree\"\n    Returns the substring inside the double quotes.\n    If no double quotes are found, returns the stripped line.\n    \"\"\"\n    line = line.strip()\n    first_quote = line.find('\"')\n    last_quote = line.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        return line[first_quote + 1:last_quote]\n    # Fallback: return the whole line stripped of whitespace\n    return line\n\nif __name__ == \"__main__\":\n    # Read the entire stdin as a single string (handles single-line input)\n    raw_input = sys.stdin.read()\n    # In case of multiple lines, take the first non-empty line\n    for raw_line in raw_input.splitlines():\n        if raw_line.strip():\n            input_line = raw_line\n            break\n    else:\n        input_line = ''\n    # Parse the input to get the string `s`\n    s = parse_input(input_line)\n    # Solve\n    solution = Solution()\n    result = solution.frequencySort(s)\n    # Output the result\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, with explanations. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows and structure. Must not output actual code. Should reflect algorithm: count frequencies, sort by freq descending, reconstruct string.\n\nLet's write steps:\n\nStart // program start\n→ Step 1: 初始化頻率映射 // 建立字元頻率表\n→ Step 2: 遍歷 s 為每個字元增加計數 // 填充頻率表\n→ Decision: s 是否為空? // 檢查是否有輸入\n    Yes → Step 3: 回傳空字串 // 空輸入直接回傳\n    No  → Step 4: 將頻率映射轉為字元-頻率列表 // 為排序做準備\n→ Step 5: 按頻率遞減排序列表 // 使高頻字元排前\n→ Step 6: 初始化結果字符串 builder // 準備拼接結果\n→ Step 7: 對於每個 (字元, 頻率) 在排序後的列表\n    → Step 7.1: 重複字元頻率次數加入 builder // 加入該字元\n→ Step 8: 回傳 builder 的字串 // 結果\nEnd // 程式結束\n\nWe need to use arrow formatting exactly: \"→ Step X: ...\". Provide decision with Yes →, No → lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率映射 // 建立一個字典用來記錄每個字元的出現次數  \n→ Step 2: 遍歷 s 為每個字元增加計數 // 逐字逐位更新頻率表  \n→ Decision: s 是否為空? // 檢查輸入是否為空字串  \n    Yes → Step 3: 回傳空字串 // 空輸入直接返回空結果  \n    No  → Step 4: 將頻率映射轉為字元-頻率列表 // 方便後續排序  \n→ Step 5: 按頻率遞減排序列表 // 使出現次數多的字元排在前面  \n→ Step 6: 初始化結果字符串 builder // 準備拼接最終字串  \n→ Step 7: 對於每個 (字元, 頻率) 在排序後的列表  \n    → Step 7.1: 重複字元頻率次數加入 builder // 把同一字元連續加進結果  \n→ Step 8: 回傳 builder 的字串 // 完成後輸出排序好的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[2,3]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[2,3]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1,0],[0,1],[0,1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立字典: 把每個單字的倒序映射到原始索引\n        rev_to_idx = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 處理空字串的特例: 空字串可與任何回文字串配對\n        if \"\" in rev_to_idx:\n            empty_idx = rev_to_idx[\"\"]\n            for i, w in enumerate(words):\n                if i != empty_idx and w == w[::-1]:\n                    res.append([empty_idx, i])\n                    res.append([i, empty_idx])\n\n        # 主循環: 逐個字串檢查所有切割位置\n        for i, word in enumerate(words):\n            length = len(word)\n            # 遍歷所有切割點, 包括 0 與 len(word)\n            for j in range(length + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n\n                # 1. 前半部為回文, 後半部的倒序存在於字典\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_to_idx:\n                        idx = rev_to_idx[rev_suffix]\n                        if idx != i:\n                            res.append([i, idx])\n\n                # 2. 後半部為回文, 前半部的倒序存在於字典\n                # 避免重複計算 j==0 的情況, 因為此時 suffix==word, 前半部已處理\n                if j != 0 and suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_to_idx:\n                        idx = rev_to_idx[rev_prefix]\n                        if idx != i:\n                            res.append([idx, i])\n\n        return res\n\ndef main():\n    # 讀取完整輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 找出 '=' 後面的字串並解析成 Python 資料結構\n    try:\n        _, list_str = raw_input.split('=', 1)\n    except ValueError:\n        list_str = raw_input  # 直接為列表字串\n    words = ast.literal_eval(list_str.strip())\n\n    # 計算結果並輸出\n    sol = Solution()\n    pairs = sol.palindromePairs(words)\n    # 用 json.dumps 並指定 separators 以去除空格，符合範例輸出格式\n    print(json.dumps(pairs, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find palindrome pairs with O(total length). The classic approach: iterate over each word, for each prefix/suffix check reversed word exists. Need hash map of word to index. For each word, check all splits. For each split, if prefix is palindrome then need reversed suffix exists. And if suffix is palindrome then reversed prefix exists, but ensure not same index and handle duplicates. Also handle empty string case.\n\nWe need to produce pseudo code lines with steps and explanations. Let's produce concise steps: Build map, iterate words, for each word, iterate split positions 0..len. For each split, check prefix palindrome, suffix palindrome. Provide checks. Use Decision nodes. Keep result list. Complexity O(total length). Let's structure.\n\nWe can use Start, End. Use arrows.\n\nLet's produce lines:\n\nStart\n→ Step 1: Build hash map wordToIndex mapping each word to its index // O(total length)\n→ Step 2: Initialize empty list result // store pairs\n→ Step 3: For each index i from 0 to words.length-1: // main loop\n    → Decision: Check if word[i] is empty string? // special case\n        Yes → Step 4: For each index j != i: // pair with all others\n            → Decision: words[j] is palindrome? // if so, add pair (i,j)\n                Yes → Step 5: Add pair (i,j) to result\n            No → End sub\n        No → End sub\n    → Decision: For split position s from 0 to len(word[i]) // inclusive at len\n        Yes → Step 6: Let prefix = word[i][0:s], suffix = word[i][s:len] // split\n        → Decision: prefix is palindrome? // if true\n            Yes → Step 7: revSuffix = reverse(suffix)\n            → Decision: revSuffix exists in map and map[revSuffix] != i? // find match\n                Yes → Step 8: Add pair (map[revSuffix], i) to result\n                No → End sub\n            No → End sub\n        → Decision: suffix is palindrome? // second condition\n            Yes → Step 9: revPrefix = reverse(prefix)\n            → Decision: revPrefix exists in map and map[revPrefix] != i? // find match\n                Yes → Step 10: Add pair (i, map[revPrefix]) to result\n                No → End sub\n            No → End sub\n→ End // return result\n\nNeed to ensure splits at 0 and len produce empty prefix/suffix handled.\n\nWe also need to avoid duplicate pairs. This algorithm will add duplicates for splits that produce same pair? We should ensure we only add when i != j and if prefix palindrome and revSuffix != i etc. For empty splits, we must avoid double counting. Might need to add check if s != 0 for second condition? But we can handle in explanation.\n\nLet's produce final virtual code with each line. Use arrows accordingly.\n\nWe should use indentation for decision blocks. Use spaces for arrow: →.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 wordToIndex，將 words 中每個字串映射到其索引 // O(total length)  \n→ Step 2: 初始化空列表 result 來儲存所有 (i, j) 組合 //  \n→ Step 3: 對於每個索引 i 從 0 到 words.length-1 進行遍歷 // 主循環  \n  → Decision: words[i] 是否為空字串？ // 特殊處理空字串  \n   Yes → Step 4: 對於每個索引 j ≠ i：  \n     → Decision: words[j] 是否為回文？ // 空字串可與任何回文字串配對  \n       Yes → Step 5: 將 (i, j) 加入 result //  \n       No → End //  \n      End //  \n   No → End //  \n  → Decision: 對 words[i] 的每個分割點 s 從 0 到 words[i].length 進行迴圈 // 包含兩端空子字串  \n    Yes → Step 6: 計算 prefix = words[i][0:s], suffix = words[i][s:] // 分割  \n     → Decision: prefix 是否為回文？ // 可能前面可配對反向後綴  \n      Yes → Step 7: revSuffix = reverse(suffix) // 取 suffix 的倒序  \n       → Decision: revSuffix 是否在 wordToIndex 且 index ≠ i？ // 找到配對  \n         Yes → Step 8: 將 (wordToIndex[revSuffix], i) 加入 result //  \n         No → End //  \n      No → End //"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"回傳最長不常見子序列的長度，若不存在則回傳 -1\"\"\"\n        # 計算每個字串出現的次數\n        freq = {}\n        for s in strs:\n            freq[s] = freq.get(s, 0) + 1\n\n        max_len = -1\n        # 只要字串是唯一的，長度就是候選值\n        for s in strs:\n            if freq[s] == 1:\n                max_len = max(max_len, len(s))\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整段文字\n    data = sys.stdin.read().strip()\n    if not data:\n        # 沒有輸入時直接輸出 -1\n        print(-1)\n        sys.exit(0)\n\n    try:\n        # 解析 JSON/Python 列表字串\n        strs = ast.literal_eval(data)\n        if not isinstance(strs, list):\n            raise ValueError\n    except Exception:\n        # 解析失敗也回傳 -1\n        print(-1)\n        sys.exit(0)\n\n    solution = Solution()\n    print(solution.findLUSlength(strs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The task: Given array of strings, find length of longest uncommon subsequence. Classic Leetcode problem 524. The algorithm: If all strings same, return -1. Otherwise, for each string, if it's not present elsewhere, answer is its length. Return max length. So produce virtual code. Ensure each line has \"虛擬碼步驟 // 解釋\". Use Start, Decision, End. Use arrow for steps.\n\nLet's outline steps:\n\nStart\n→ Step 1: Initialize result = -1 // set default\n→ Step 2: For each string s in strs: // iterate all strings\n→ Decision: Count occurrences of s in strs? // check duplicates\n    Yes → Continue // skip if duplicate (i.e., appears more than once)\n    No  → Step 3: Update result = max(result, length of s) // candidate\nAfter loop, return result\nEnd\n\nBut we need to check duplicates more explicitly: For each s, if s occurs only once, update result. We can use a map to count. But simpler: For each s, check if it's unique. Could do Decision: if any other string equals s? Then No.\n\nBut we can just compute frequency map before loop.\n\nLet's produce virtual code accordingly.\n\nMake sure each line has arrow arrow etc. Provide short explanation. Use Yes/No decisions.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算 strs 中每個字串的出現頻率 // 用於判斷是否唯一\n→ Step 2: 初始化 result 為 -1 // 預設長度，若無特殊子序列則返回 -1\n→ Step 3: 遍歷每個字串 s 在 strs 中 // 為每個字串檢查是否為唯一\n→ Decision: s 的頻率是否等於 1? // 是否唯一\n    Yes → Step 4: 計算 s 的長度 L // 準備更新結果\n    Yes → Step 5: result = max(result, L) // 取最大長度\n    No  → Step 6: 跳過此字串 // 重複字串不可作為不常見子序列\n→ Step 7: 回傳 result // 返回最長不常見子序列長度\nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str) -> list[str]:\n        \"\"\"\n        找出所有長度為 10 的 DNA 子序列，並回傳出現超過一次的子序列列表。\n        \"\"\"\n        if len(s) < 10:\n            return []\n\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef parse_input(data: str) -> str:\n    \"\"\"\n    從輸入字串中抽取 DNA 序列。預期輸入格式類似：\n        s = 'ACGTACGTAC'\n    若找不到單引號包住的字串，則直接將整行視為 DNA 序列。\n    \"\"\"\n    match = re.search(r\"'([^']*)'\", data)\n    if match:\n        return match.group(1)\n    # 直接使用整行輸入，去除可能的空白\n    return data.strip()\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    dna_sequence = parse_input(raw_input)\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(dna_sequence)\n    # 使用 JSON 方式輸出，符合範例格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code to find all 10-letter-long substrings that occur more than once in a DNA string. We must use the format: each line: \"虛擬碼步驟 // 解釋\" with arrow etc. Use Start, End, Decision, etc. So produce a linear algorithm: Use dictionary to count occurrences of each 10-letter substring. Then iterate over string from 0 to len(s)-10, get substring s[i:i+10], increment count. After loop, collect those with count > 1. Return result. Or we can do set for first seen and result set.\n\nWe produce lines with virtual code steps, not actual code, but pseudo steps. Use arrow \"→\". Use Decision blocks. Provide explanation after //.\n\nLet's produce.\n\nMake sure to include Start and End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 CountMap // 用來記錄每個 10 字符長子串的出現次數\n→ Step 2: 取得輸入字串長度 N // 用於迴圈終止條件\n→ Decision: N 是否小於 10? // 若字串太短則無 10 字符長子串\n    Yes → Step 3: 回傳空列表 // 沒有足夠長度，直接返回\n    No  → Step 4: 設定索引 i = 0 // 開始從頭遍歷子串\n→ While i ≤ N-10: // 迴圈遍歷所有可能的 10 字符長子串\n    → Step 5: 取子串 Sub = s[i:i+10] // 取得當前 10 字符長子串\n    → Decision: Sub 是否已在 CountMap? // 檢查子串是否已出現\n        Yes → Step 6: Increment CountMap[Sub] by 1 // 已存在，次數加一\n        No  → Step 7: 設定 CountMap[Sub] = 1 // 第一次出現，次數設為 1\n    → Step 8: i = i + 1 // 移動到下一個起始位置\n→ Step 9: 初始化空列表 Result // 用於存放重複出現的子串\n→ Step 10: 遍歷 CountMap 的鍵 K\n    → Decision: CountMap[K] > 1? // 檢查是否出現超過一次\n        Yes → Step 11: 將 K 加入 Result // 這個子串重複出現，加入結果\n        No  → Step 12: 跳過 // 不重複的子串不加入\n→ Step 13: 回傳 Result // 返回所有重複 10 字符長子串的列表\nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        \"\"\"返回 nums 的所有排列\"\"\"\n        res: List[List[int]] = []\n\n        def backtrack(start: int) -> None:\n            # 當 start 到達 nums 長度時，已經形成一個完整排列\n            if start == len(nums):\n                res.append(nums[:])   # 加入結果副本\n                return\n            # 從 start 開始遍歷所有可能的位置\n            for i in range(start, len(nums)):\n                # 交換 nums[start] 與 nums[i]，把 nums[i] 放到當前位置\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)   # 進一步深度搜尋\n                # 回溯：恢復原始順序\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，例如 'nums = [1,2,3]'\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析 nums 列表\n    if '=' in raw_input:\n        _, list_str = raw_input.split('=', 1)\n        nums = eval(list_str.strip())\n    else:\n        # 若直接給出列表\n        nums = eval(raw_input)\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of an array of distinct integers. Provide step-by-step algorithm: start, input array, recursive backtracking function. Use steps like: Start, Step 1: input array, Step 2: initialize result list, Step 3: call backtrack with empty path and used set, Step 4: backtrack recursion: if path length equals n, add to result, else iterate over nums, if not used, add to path, mark used, recurse, unmark, remove. End. Provide explanations after each line. Use arrows. Must not output actual code. So produce a structured textual algorithm. Ensure each line has the format: 虛擬碼步驟 // 解釋. Use Start and End. Use Decision. Use arrows. Also show nested lines indented.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 獲取輸入陣列 nums // 取得使用者提供的整數陣列\n→ Step 2: 初始化結果列表 results 為空 // 用於儲存所有排列\n→ Step 3: 定義遞迴函式 backtrack(已選取的 path, 已使用的標記 set) // 用於回溯搜尋排列\n    → Decision: 如果 path 長度等於 nums 長度? // 判斷是否已組成完整排列\n        Yes → Step 4: 將 path 複製並加入 results // 完整排列加入結果\n        No  → Step 5: 針對 nums 中每個數字 num 進行迭代 // 嘗試將每個尚未使用的數字加入排列\n            → Decision: 若 num 已在 set 中? // 檢查是否已使用\n                Yes → No action // 已使用則跳過\n                No  → Step 6: 將 num 加入 path 並加入 set // 新增數字至當前排列\n                        → Step 7: 呼叫 backtrack(更新後的 path, set) // 繼續深層搜尋\n                        → Step 8: 移除 path 中的 num 並從 set 中移除 // 回溯，恢復狀態\n→ Step 9: 呼叫 backtrack([], 空集合) // 從空排列開始回溯\n→ Step 10: 回傳 results // 回傳所有生成的排列\nEnd // 程式執行結束\n\nNeed to maintain arrows and indentation. Use appropriate arrow characters. The sample uses \"→\" arrow, indent inside decision. Use \"Decision:\" label. Provide each line as separate. For each line we can add indentation spaces for clarity. Provide virtual code and explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取輸入陣列 nums // 取得使用者提供的整數陣列  \n→ Step 2: 初始化結果列表 results 為空 // 用於儲存所有排列  \n→ Step 3: 定義遞迴函式 backtrack(已選取的 path, 已使用的標記 set) // 用於回溯搜尋排列  \n → Decision: 如果 path 長度等於 nums 長度? // 判斷是否已組成完整排列  \n  Yes → Step 4: 將 path 複製並加入 results // 完整排列加入結果  \n  No  → Step 5: 針對 nums 中每個數字 num 進行迭代 // 嘗試將每個尚未使用的數字加入排列  \n   → Decision: 若 num 已在 set 中? // 檢查是否已使用  \n    Yes → No action // 已使用則跳過  \n    No  → Step 6: 將 num 加入 path 並加入 set // 新增數字至當前排列  \n      → Step 7: 呼叫 backtrack(更新後的 path, set) // 繼續深層搜尋  \n      → Step 8: 移除 path 中的 num 並從 set 中移除 // 回溯，恢復狀態  \n→ Step 9: 呼叫 backtrack([], 空集合) // 從空排列開始回溯  \n→ Step 10: 回傳 results // 回傳所有生成的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # 使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：可能是 'nums = [1,3,4,2,2]'\n    try:\n        if '=' in data:\n            _, list_str = data.split('=', 1)\n            list_str = list_str.strip()\n        else:\n            list_str = data\n        nums = ast.literal_eval(list_str)\n    except Exception as e:\n        # 若解析失敗，直接輸出錯誤\n        print(f\"Error parsing input: {e}\")\n        return\n    solution = Solution()\n    result = solution.findDuplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code for Floyd's Tortoise and Hare algorithm. Use array access only. Steps: start, define slow, fast = nums[0], loop, move slow = nums[slow], fast = nums[nums[fast]] until equal. Then find entrance: start pointer, etc. End.\n\nWe need each line: virtual code step plus comment. Use Start, End, Decision. Let's produce line by line. Ensure each line contains \"虛擬碼步驟\" and comment. Use arrow \"→\" to indicate next. For decision we use \"Decision:\" with Yes/No. Provide simple comments.\n\nLet's produce.\n\nWe may break into steps:\n\nStart\n→ Step 1: 初始化慢指針 slow = nums[0] // 設置慢指針起點\n→ Step 2: 初始化快指針 fast = nums[0] // 設置快指針起點\n→ Decision: 需要進入循環直到慢指針等於快指針? // 判斷是否相遇\n    Yes → Step 3: slow = nums[slow] // 慢指針移動一步\n    Yes → Step 4: fast = nums[nums[fast]] // 快指針移動兩步\n    No  → Step 5: // 循環結束，已相遇\n→ Step 6: 初始化 ptr1 = nums[0] // 第一個入口指針\n→ Step 7: 初始化 ptr2 = slow // 第二個入口指針\n→ Decision: 需要進入循環直到 ptr1 等於 ptr2? // 找入口\n    Yes → Step 8: ptr1 = nums[ptr1] // ptr1 移動一步\n    Yes → Step 9: ptr2 = nums[ptr2] // ptr2 移動一步\n    No  → Step 10: 返回 ptr1 // ptr1 即重複數字\nEnd\n\nNeed ensure syntax. Use \"→\" only for normal steps. For decision, indent Yes/No lines. Provide comment.\n\nLet's format.\n\nAlso include \"Start\" and \"End\". Provide only virtual code, no real code. Ensure each line is separate.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化慢指針 slow = nums[0] // 設置慢指針起點\n→ Step 2: 初始化快指針 fast = nums[0] // 設置快指針起點\n→ Decision: 需要進入循環直到慢指針等於快指針? // 判斷是否相遇\n    Yes → Step 3: slow = nums[slow] // 慢指針移動一步\n    Yes → Step 4: fast = nums[nums[fast]] // 快指針移動兩步\n    No  → Step 5: // 循環結束，已相遇\n→ Step 6: 初始化 ptr1 = nums[0] // 第一個入口指針\n→ Step 7: 初始化 ptr2 = slow // 第二個入口指針\n→ Decision: 需要進入循環直到 ptr1 等於 ptr2? // 找入口\n    Yes → Step 8: ptr1 = nums[ptr1] // ptr1 移動一步\n    Yes → Step 9: ptr2 = nums[ptr2] // ptr2 移動一步\n    No  → Step 10: 返回 ptr1 // ptr1 即重複數字\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport collections\nimport random\n\nclass RandomizedCollection:\n    \"\"\"多重集合，支持 O(1) 的插入、刪除及隨機取樣。\"\"\"\n\n    def __init__(self):\n        # 存放所有元素，方便隨機取樣\n        self.data = []\n        # 每個值對應其在 data 中的索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入 val，若是第一次插入返回 True，否則返回 False。\"\"\"\n        first_time = len(self.idx_map[val]) == 0\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return first_time\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若存在，移除一個 val，返回 True；否則返回 False。\"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取要移除的索引\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 若要移除的位置不是最後一個，則把最後一個元素搬到這裡\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n\n        # 刪除最後一個元素\n        self.data.pop()\n\n        # 若 val 已經沒有剩餘索引，清除映射\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素。\"\"\"\n        return random.choice(self.data)\n\n\ndef main() -> None:\n    \"\"\"主函式：讀取 LeetCode 風格輸入，執行操作並輸出結果。\"\"\"\n    input_str = sys.stdin.read().strip()\n    if not input_str:\n        return\n\n    # 將輸入解析成兩個列表：commands 與 args\n    commands, args = ast.literal_eval(f'({input_str})')\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)                # null 對應 None\n        elif cmd == \"insert\":\n            val = arg[0] if isinstance(arg, list) else arg\n            results.append(obj.insert(val))\n        elif cmd == \"remove\":\n            val = arg[0] if isinstance(arg, list) else arg\n            results.append(obj.remove(val))\n        elif cmd == \"getRandom\":\n            results.append(obj.getRandom())\n\n    # 將結果轉成 LeetCode 風格輸出\n    out_parts = []\n    for v in results:\n        if v is None:\n            out_parts.append(\"null\")\n        elif isinstance(v, bool):\n            out_parts.append(\"true\" if v else \"false\")\n        else:\n            out_parts.append(str(v))\n    print(f\"[{', '.join(out_parts)}]\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for the described class. Use Start, End, Decision, etc. Need to explain each line. Provide pseudo steps. Should cover initialization, insert, remove, getRandom. Use appropriate data structures: list for values, dict mapping value to set of indices. Outline algorithm. Provide step-by-step. Let's write:\n\nStart\n→ Step: Define class RandomizedCollection\n→ Step: Constructor: create empty list and dict\n→ Insert: Add val to list, record index in dict set. Return true if first time\n→ Remove: Check if val exists. If not return false. Otherwise get an index to remove from list, get last element and its index, swap, update dict sets, pop from list. Return true\n→ getRandom: return random choice from list\nEnd\n\nBut need each line with arrow and comment. Use arrow to indicate flow. Use Decision for checks. Let's structure:\n\nStart // 程式開始執行\n→ Step 1: Define RandomizedCollection class // 定義資料結構\n→ Step 2: Constructor: init empty list 'vals' and map 'idxMap' from value to set of indices // 初始化儲存陣列與索引集合\n→ Decision: 在構造函式內 // 處理初始化\n\nWe can incorporate into pseudocode lines. We'll produce more explicit lines:\n\nStart // 程式開始\n→ Step: class RandomizedCollection // 定義類別\n→ Step:    // 建構子\n→ Step:        vals ← empty list // 存放所有元素\n→ Step:        idxMap ← empty map from int to set // 每個值對應其在 vals 的索引集合\n→ End // 完成初始化\n\nThen functions:\n\n→ Function insert(val)\n→ Step:    if val not in idxMap: exists ← false else exists ← true\n→ Step:    append val to vals // 把新值加入末尾\n→ Step:    add index len(vals)-1 to idxMap[val] // 記錄其索引\n→ Decision: 若不存在則 return true else return false\n\nSimilarly remove.\n\nNeed careful steps.\n\nAlso random: choose random index from 0 to len(vals)-1 and return vals[idx].\n\nMake sure to use arrow indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class RandomizedCollection // 建立 RandomizedCollection 類別  \n→ Step 2: Constructor: init empty list `vals` // 用來存所有元素，支援 O(1) 隨機存取  \n→ Step 3: Constructor: init empty map `idxMap` from int to set // 每個值對應其在 `vals` 中的索引集合  \n→ End // 初始化結束  \n\n→ Function insert(val) // 插入元素的步驟  \n→ Decision: 如果 val 在 idxMap 中? // 判斷這是第一次插入  \n  Yes → Step 4a: exists ← false // 初次插入，返回 true  \n  No  → Step 4b: exists ← true // 已存在，返回 false  \n→ Step 5: Append val to vals // 把新值放到 list 末尾，O(1)  \n→ Step 6: Add index len(vals)-1 to idxMap[val] // 更新索引集合  \n→ Step 7: Return exists // 回傳是否首次出現  \n\n→ Function remove(val) // 移除元素的步驟  \n→ Decision: 是否有 idxMap[val]? // 確認 val 是否存在  \n  No → Step 8: Return false // 沒有可移除，直接回傳 false  \n  Yes → Step 9: Choose any idx from idxMap[val] // 取出一個該值的索引  \n→ Step 10: lastVal ← vals[-1] // 取 list 最後一個元素  \n→ Step 11: lastIdx ← len(vals)-1 // 最後一個元素的索引  \n→ Decision: idx ≠ lastIdx? // 檢查被移除元素是否是最後一個  \n  Yes → Step 12: vals[idx] ← lastVal // 用最後一個元素覆蓋要移除的位置  \n     Step 13: Update idxMap[lastVal]: remove lastIdx, add idx // 更新索引集合  \n  No  → Step 14: // idx 是最後一個，無需覆蓋  \n→ Step 15: Remove idx from idxMap[val] // 從索引集合刪除該位置  \n→ Decision: idxMap[val] 為空?  \n  Yes → Step 16: Delete idxMap[val] // 若無剩餘索引，刪除映射  \n→ Step 17: Pop vals[-1] // 刪除 list 最後一個元素，O(1)  \n→ Step 18: Return true // 成功移除，回傳 true  \n\n→ Function getRandom() // 隨機取值的步驟  \n→ Step 19: randIdx ← random integer between 0 and len(vals)-1 // 隨機索引  \n→ Step 20: Return vals[randIdx] // 回傳隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (store negatives)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        heapq.heappush(self.small, -num)\n        # balance values between heaps\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # keep size property: |len(small) - len(large)| <= 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將輸入轉成兩個列表: ops 與 args\n    try:\n        ops, args = ast.literal_eval('(' + raw_input + ')')\n    except Exception:\n        ops, args = ast.literal_eval(raw_input)\n\n    results = []\n    mf = None\n    for op, arg in zip(ops, args):\n        if op == 'MedianFinder':\n            mf = MedianFinder()\n            results.append(None)\n        elif op == 'addNum':\n            # arg 可能是 [num] 或直接 num\n            if isinstance(arg, list):\n                num = arg[0]\n            else:\n                num = arg\n            mf.addNum(num)\n            results.append(None)\n        elif op == 'findMedian':\n            median = mf.findMedian()\n            results.append(median)\n\n    # 使用 json.dumps 以符合「null」的輸出格式\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing a MedianFinder class with addNum and findMedian. Should include explanation. Use virtual code style with arrows and decision. Should produce steps. Not actual code. Let's design algorithm: use two heaps: max heap for lower half, min heap for upper half. Balanced sizes difference at most one. Steps: addNum: if lower empty or num <= max of lower -> push to lower else push to upper. Rebalance if size difference >1. findMedian: if sizes equal, return (max lower + min upper)/2 else return top of larger heap. Provide start, steps, decision points, end.\n\nWe produce line by line virtual code. Use \"Start\", \"→\" for next step, \"Decision:\" etc. Each line: virtual code step + \" // explanation\".\n\nWe need to include maybe initialization of two heaps. So start, init heaps, then addNum function steps, then findMedian function steps.\n\nLet's produce.\n\nNote: we should not output actual code, just virtual code. Provide each step with comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個優先佇列 // maxHeap 用於存放較小的一半，minHeap 用於存放較大的一半  \n→ Step 2: 定義 addNum(int num) 方法 // 將新數字加入資料結構  \n→ Decision: 如果 maxHeap 為空 或 num ≤ maxHeap.top? // 判斷新數字是否屬於較小的一半  \n  Yes → Step 3: 將 num 插入 maxHeap // 加入較小的一半  \n  No  → Step 4: 將 num 插入 minHeap // 加入較大的一半  \n→ Step 5: 重平衡兩個佇列大小 // 兩個佇列大小差不超過 1  \n  Decision: 如果 maxHeap.size() > minHeap.size() + 1? // maxHeap 過大  \n   Yes → Step 6: 從 maxHeap 取出頂部元素，插入 minHeap // 移動一個元素  \n   No  → Decision: 如果 minHeap.size() > maxHeap.size() + 1? // minHeap 過大  \n    Yes → Step 7: 從 minHeap 取出頂部元素，插入 maxHeap // 移動一個元素  \n    No → Step 8: // 兩個佇列已平衡  \n→ Step 9: 定義 findMedian() 方法 // 回傳目前所有元素的中位數  \n→ Decision: 如果 maxHeap.size() == minHeap.size()? // 兩個佇列大小相等  \n  Yes → Step 10: 返回 (maxHeap.top() + minHeap.top()) / 2.0 // 取兩個中間值的平均  \n  No  → Decision: 如果 maxHeap.size() > minHeap.size()? // maxHeap 較大  \n   Yes → Step 11: 返回 maxHeap.top() // maxHeap 顶部為中位數  \n   No  → Step 12: 返回 minHeap.top() // minHeap 顶部為中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict\n\ndef groupAnagrams(strs):\n    \"\"\"\n    組合相同字母組成的字串，回傳一個字串組的列表。\n    \"\"\"\n    anagrams = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))            # 把字串排序得到鍵\n        anagrams[key].append(s)           # 加入對應的字串\n    return list(anagrams.values())\n\ndef main():\n    \"\"\"\n    從標準輸入讀取格式為 `strs = [...]` 的字串，解析後執行\n    anagram 分組並將結果以 JSON 格式輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 只取 '=' 之後的部分，若沒有 '=' 則直接使用整行\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n\n    # 用 eval 解析為 Python 物件，限制 builtins 為 None 以避免安全風險\n    try:\n        strs = eval(expr, {\"__builtins__\": None}, {})\n    except Exception:\n        strs = []\n\n    result = groupAnagrams(strs)\n    # 使用 json.dumps 讓輸出為雙引號風格，符合範例\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step with explanation. Use Start, End, Decision. For grouping anagrams: iterate each string, compute sorted key or char frequency. Use hash map. For each string, compute key, append to map. Then output map values. So pseudocode lines.\n\nWe must not output real code. Just steps. Use arrows, etc.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Use Decision. Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty dictionary groups // Create container for anagram groups\n→ Step 2: For each string s in input array strs // Iterate through all strings\n    → Step 3: Compute key = sorted characters of s // Sort letters to form group key\n    → Decision: If key exists in groups? // Check if group already created\n        Yes → Step 4: Append s to groups[key] // Add string to existing group\n        No  → Step 5: Create new list [s] and assign to groups[key] // New group\n→ Step 6: Initialize result list // Prepare output\n→ Decision: For each key, list in groups // Iterate over all groups\n    Yes → Step 7: Append list to result // Add group to output\n→ End\n\nBut maybe need to use arrow properly.\n\nBetter structure: After Step 2, nested actions. Use indentation? The example uses indentation with Decision and Yes/No arrows.\n\nWe need to use \"Decision:\" for each branch.\n\nAlso each line must end with \"// 解釋/說明\". So produce lines accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空字典 groups // 建立用於儲存同位異字組的映射  \n→ Step 2: 對輸入陣列 strs 中每個字串 s 做迭代 // 遍歷所有字串  \n    → Step 3: 計算 key = s 的字母排序後的字串 // 排序得到組別鍵  \n    → Decision: key 是否已存在於 groups? // 判斷該鍵是否已有對應列表  \n        Yes → Step 4: groups[key] ← groups[key] 加上 s // 已有組別，加入字串  \n        No  → Step 5: groups[key] ← [s] // 新組別，建立列表並加入字串  \n→ Step 6: 初始化結果列表 result = [] // 準備儲存所有同位異字組  \n→ Decision: 遍歷 groups 中每個 key, list // 逐一處理所有組別  \n    Yes → Step 7: result 加上 list // 把整個同位異字列表加入結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef roman_to_int(s: str) -> int:\n    \"\"\"將羅馬數字字串轉換為整數。\"\"\"\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    total = 0          # 最終結果\n    prev = 0           # 前一個字符的數值，用於判斷減法\n    # 逆序遍歷，便於比較前後兩個字符\n    for ch in reversed(s):\n        value = roman_map[ch]\n        if value < prev:     # 表示是減法情況\n            total -= value\n        else:                # 加法\n            total += value\n        prev = value\n    return total\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    raw_input = sys.stdin.read().strip()\n\n    # 儘量抽取引號內的羅馬數字\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        roman_str = match.group(1)\n    else:\n        # 若沒有引號，嘗試移除可能的前綴\n        roman_str = raw_input.split('=', 1)[-1].strip()\n\n    # 轉換並輸出結果\n    result = roman_to_int(roman_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting Roman numeral to integer. Provide each line with explanation comment.\n\nWe need to use Start, End, Decision, arrows. Steps: initialize mapping, iterate over string, compare current and next value, add or subtract. Provide line-by-line.\n\nEnsure each line has \"虛擬碼步驟\" followed by space then comment. Use arrows. Use \"→\" for flow. Use \"Decision:\" etc. Use Start and End. Provide maybe a function name: Step 1: 定義符號值對應表 // mapping. Step 2: 初始化 total = 0. Step 3: 迴圈 i = 0 to len-1. Inside: Decision: 是否存在下一個字符且當前值 < 下一值? If Yes, total += (next - current), i += 2. Else, total += current, i++.\n\nAfter loop End.\n\nWe should keep each line separate. Use \"Start // 程式開始執行\" line. Then \"→ Step 1: 定義符號到數值的映射表\" etc.\n\nNeed to use virtual code arrow lines. Provide explanation after space. Use \"Decision:\" lines with indentation maybe.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義符號到數值的映射表 // 建立 I→1, V→5, X→10, L→50, C→100, D→500, M→1000 的字典  \n→ Step 2: 初始化 total ← 0 // 儲存最終的整數結果  \n→ Step 3: 初始化指標 i ← 0 // 用於遍歷羅馬數字字串  \n→ Step 4: 初始化字串長度 n ← len(roman) // 方便迴圈條件  \n→ Step 5: Decision: i < n? // 判斷是否還有未處理的字符  \n  Yes → Step 6: 取得 current_value ← value_map[roman[i]] // 目前字符的數值  \n  Yes → Step 7: Decision: i+1 < n AND current_value < value_map[roman[i+1]]? // 檢查是否為減法情況  \n    Yes → Step 8: 取得 next_value ← value_map[roman[i+1]] // 下一個字符的數值  \n    Yes → Step 9: total ← total + (next_value - current_value) // 加入減法結果  \n    Yes → Step 10: i ← i + 2 // 跳過兩個字符  \n    No  → Step 11: total ← total + current_value // 直接加上目前值  \n    No  → Step 12: i ← i + 1 // 只移動一個字符  \n  No  → End // 迴圈結束，total 已完成計算  \nEnd // 程式執行結束，返回 total（已在程式內部計算完成）"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnjnos427.py\", line 36, in <module>\n    matrix, k = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnjnos427.py\", line 29, in parse_input\n    raise ValueError(\"輸入格式錯誤\")\nValueError: 輸入格式錯誤"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptv3mqm8t.py\", line 36, in <module>\n    matrix, k = parse_input(raw)\n                ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptv3mqm8t.py\", line 29, in parse_input\n    raise ValueError(\"輸入格式錯誤\")\nValueError: 輸入格式錯誤"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\ndef kth_smallest(matrix, k):\n    n = len(matrix)\n    low, high = matrix[0][0], matrix[-1][-1]\n    while low < high:\n        mid = (low + high) // 2\n        count = 0\n        i, j = n - 1, 0\n        while i >= 0 and j < n:\n            if matrix[i][j] <= mid:\n                count += i + 1\n                j += 1\n            else:\n                i -= 1\n        if count >= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\n\ndef parse_input(data):\n    # 尋找 matrix 與 k 的字串，並安全解析\n    mat_match = re.search(r'matrix\\s*=\\s*(\\[[\\s\\[\\],-]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not mat_match or not k_match:\n        raise ValueError(\"輸入格式錯誤\")\n    matrix = ast.literal_eval(mat_match.group(1))\n    k = int(k_match.group(1))\n    return matrix, k\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    matrix, k = parse_input(raw)\n    result = kth_smallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation, no actual code, using Start, End, Decision, arrows, etc. We must solve the problem: Given an n x n matrix sorted rows and columns ascending, find kth smallest element. Must use memory better than O(n^2). The usual solution: binary search on value range + count less than or equal to mid by scanning from bottom-left. Complexity O(n log(max-min)). Memory O(1). So we need to produce steps for that algorithm. Provide pseudo steps.\n\nWe should produce lines like:\n\nStart // Program start\n→ Step 1: 確定矩陣尺寸 n\n→ Step 2: 設定 low = matrix[0][0], high = matrix[n-1][n-1] // 最小最大值\n→ Decision: while low < high? // Binary search loop\n    → Step 3: mid = (low + high) // 2 // 中值\n    → Step 4: count = 0\n    → Step 5: i = n-1, j = 0 // 由左下角開始\n    → Decision: while i >= 0 and j < n? // Count elements <= mid\n        → Decision: if matrix[i][j] <= mid?\n            Yes → count += i+1 // 所有行上方元素都 <= mid\n            No  → i-- // Move up\n        → j++ // Move right\n    → Decision: if count >= k? // Check if mid is too high\n        Yes → high = mid // 尋找更小的值\n        No  → low = mid + 1 // 需要更大的值\n→ Step 6: return low // kth smallest\n\nBut we need to produce per line: \"虛擬碼步驟\" + space + \"// 解釋\". Must use arrow notation: Start, End, Decision. Use arrows: →. For decisions use \"Decision:\".\n\nLet's design lines:\n\n1. Start // 程式開始執行\n2. → Step 1: n ← matrix size // 取得矩陣大小 n\n3. → Step 2: low ← matrix[0][0] // 設定最小可能值\n4. → Step 3: high ← matrix[n-1][n-1] // 設定最大可能值\n5. → Decision: while low < high? // Binary search 迴圈\n6.     → Step 4: mid ← (low + high) // 2 // 計算中間值\n7.     → Step 5: count ← 0 // 初始化小於等於 mid 的元素數量\n8.     → Step 6: i ← n-1 // 從最後一行開始\n9.     → Step 7: j ← 0 // 從第一列開始\n10.    → Decision: while i ≥ 0 and j < n? // 迴圈計算 count\n11.        → Decision: if matrix[i][j] ≤ mid? // 判斷當前元素是否小於等於 mid\n12.            Yes → count ← count + i + 1 // 所有在第 i 行左側（包含）元素均 ≤ mid\n13.            No  → i ← i - 1 // 若大於 mid，向上一行\n14.        → j ← j + 1 // 無論大小都向右移動\n15.    → Decision: if count ≥ k? // 判斷 mid 是否足夠大\n16.        Yes → high ← mid // 將上界移至 mid，尋找更小值\n17.        No  → low ← mid + 1 // 下界移至 mid+1，尋找更大值\n18. → Step 8: return low // low 為第 k 小的元素\n19. End // 程式結束\n\nBut we need to ensure arrow formatting. Use \"→\" before each step. Indentation may be represented by spaces before arrow? Example from format: they used \"→ Decision:\" inside indent. Let's replicate.\n\nWe'll format as:\n\nStart // 程式開始執行\n→ Step 1: n ← matrix.size() // 取得矩陣大小\n→ Step 2: low ← matrix[0][0] // 設定最小值\n→ Step 3: high ← matrix[n-1][n-1] // 設定最大值\n→ Decision: while low < high? // 進行二分搜尋\n    → Step 4: mid ← (low + high) // 2 // 計算中點\n    → Step 5: count ← 0 // 初始化計數\n    → Step 6: i ← n-1 // 從最後一行開始\n    → Step 7: j ← 0 // 從第一列開始\n    → Decision: while i ≥ 0 and j < n? // 遍歷矩陣計數\n        → Decision: if matrix[i][j] ≤ mid? // 判斷元素大小\n            Yes → count ← count + i + 1 // 该列左侧全部小于等于mid\n            No  → i ← i - 1 // 向上移動\n        → j ← j + 1 // 向右移動\n    → Decision: if count ≥ k? // 判斷是否足夠多\n        Yes → high ← mid // 設置更小的上界\n        No  → low ← mid + 1 // 設置更大的下界\n→ Step 8: return low // low 為第 k 小元素\nEnd // 程式結束\n\nNeed to ensure no actual code syntax like matrix.size(), but we can just keep as pseudo variable.\n\nOk produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← matrix size // 取得矩陣大小 n  \n→ Step 2: low ← matrix[0][0] // 設定最小可能值  \n→ Step 3: high ← matrix[n-1][n-1] // 設定最大可能值  \n→ Decision: while low < high? // 二分搜尋迴圈  \n    → Step 4: mid ← (low + high) // 2 // 計算中點  \n    → Step 5: count ← 0 // 初始化小於等於 mid 的元素數量  \n    → Step 6: i ← n-1 // 從最後一行開始  \n    → Step 7: j ← 0 // 從第一列開始  \n    → Decision: while i ≥ 0 and j < n? // 迴圈計算 count  \n        → Decision: if matrix[i][j] ≤ mid? // 判斷當前元素是否小於等於 mid  \n            Yes → count ← count + i + 1 // 所有在第 i 行左側（包含）元素均 ≤ mid  \n            No  → i ← i - 1 // 若大於 mid，向上一行  \n        → j ← j + 1 // 無論大小都向右移動  \n    → Decision: if count ≥ k? // 判斷 mid 是否足夠大  \n        Yes → high ← mid // 將上界移至 mid，尋找更小值  \n        No  → low ← mid + 1 // 下界移至 mid+1，尋找更大值  \n→ Step 8: return low // low 為第 k 小的元素  \nEnd // 程式結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpps6bmyz1.py\", line 39, in <module>\n    nums1 = parse_list(matches[0])\n            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpps6bmyz1.py\", line 31, in parse_list\n    return [int(x.strip()) for x in list_str.split(\",\") if x.strip()]\n            ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp77p3ub1y.py\", line 39, in <module>\n    nums1 = parse_list(matches[0])\n            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp77p3ub1y.py\", line 31, in parse_list\n    return [int(x.strip()) for x in list_str.split(\",\") if x.strip()]\n            ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '[4'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        找出兩個列表中相同元素的交集，重複出現的次數取兩者中最小值。\n        \"\"\"\n        # 以 Counter 建立兩個頻率表\n        counter1 = Counter(nums1)\n        counter2 = Counter(nums2)\n        result = []\n        # 迭代較小的頻率表以減少不必要的檢查\n        if len(counter1) > len(counter2):\n            counter1, counter2 = counter2, counter1\n        for num in counter1:\n            if num in counter2:\n                # 取兩個 Counter 中該元素出現次數的較小值\n                result.extend([num] * min(counter1[num], counter2[num]))\n        return result\n\ndef parse_list(list_str):\n    \"\"\"\n    將字串 '[1, 2, 2, 1]' 轉成 Python list [1, 2, 2, 1]。\n    \"\"\"\n    list_str = list_str.strip()\n    if list_str == \"[]\":\n        return []\n    # 以逗號分隔，並移除空格後轉為 int\n    return [int(x.strip()) for x in list_str.split(\",\") if x.strip()]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 找出所有以 [ ] 包住的子字串（即兩個列表）\n    matches = re.findall(r'\\[.*?\\]', data)\n    if len(matches) >= 2:\n        nums1 = parse_list(matches[0])\n        nums2 = parse_list(matches[1])\n    else:\n        # 若輸入格式不符，則直接退出\n        nums1, nums2 = [], []\n\n    sol = Solution()\n    output = sol.intersect(nums1, nums2)\n    # 印出結果，符合題目要求的列表格式\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation, using arrow, Start, Decision, etc. The algorithm: intersection with duplicates. Approach: build frequency map of nums1, iterate nums2, if element present in map and count >0, add to result, decrement. Or vice versa. Provide pseudocode accordingly. Output each line as \"虛擬碼步驟 // 解釋\". Use Chinese comments. Must include Start, End. Use arrows and Decision. Ensure each line is separate. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化空字典 freq 以存儲 nums1 中每個元素的出現次數 // 用於快速查找\n→ Step 2: 初始化空列表 result 以儲存最終交集 // 結果容器\n→ Decision: 是否遍歷 nums1 以填充 freq? // 準備頻率表\n    Yes → Step 3: 對於每個 num 在 nums1 中\n        → Step 4: 若 num 在 freq 中，freq[num] += 1\n        → Step 5: 否則 freq[num] = 1\n    No → // 這一步永遠執行，無需處理\n→ Decision: 是否遍歷 nums2 以找出交集? // 比對另一陣列\n    Yes → Step 6: 對於每個 num 在 nums2 中\n        → Step 7: 如果 num 在 freq 且 freq[num] > 0\n            → Step 8: 將 num 添加到 result\n            → Step 9: freq[num] -= 1\n        → Step 10: 否則不做任何事\n    No → // 這一步永遠執行，無需處理\n→ Step 11: 返回 result // 結果返回\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjgwowrcf.py\", line 26, in <module>\n    main()\n  File \"/tmp/tmpjgwowrcf.py\", line 22, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpjgwowrcf.py\", line 7, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5tby0p69.py\", line 26, in <module>\n    main()\n  File \"/tmp/tmp5tby0p69.py\", line 22, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmp5tby0p69.py\", line 7, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn8j7kvc7.py\", line 26, in <module>\n    main()\n  File \"/tmp/tmpn8j7kvc7.py\", line 22, in main\n    result = [sol.rand10() for _ in range(n)]\n              ^^^^^^^^^^^^\n  File \"/tmp/tmpn8j7kvc7.py\", line 7, in rand10\n    num = (rand7() - 1) * 7 + rand7()  # 1~49\n           ^^^^^\nNameError: name 'rand7' is not defined. Did you mean: 'range'?"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def rand10(self):\n        while True:\n            # 兩次呼叫 rand7 產生 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:                     # 只使用 1~40\n                return 1 + (num - 1) % 10     # 轉換到 1~10\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，例如 'n = 3' 或 '3'\n    if '=' in data:\n        _, val = data.split('=', 1)\n        n = int(val.strip())\n    else:\n        n = int(data.strip())\n    sol = Solution()\n    result = [sol.rand10() for _ in range(n)]\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating rand10 from rand7. Classic solution: use 2 rand7 to generate 49 outcomes, discard >40, map 1-40 to 1-10 by modulo. So steps: call rand7 twice, compute num = (a-1)*7 + b (0-48) +1? Actually produce 1-49. If >40 discard and repeat. Then return (num-1)%10 +1.\n\nWe need step-by-step pseudo-code with explanation after each line.\n\nWe must obey format: each line with \"虛擬碼步驟 // 解釋\".\n\nUse arrows and Decision.\n\nLet's structure:\n\nStart\n→ Step: 呼叫 rand7() 取得 a // 第一個隨機數\n→ Step: 呼叫 rand7() 取得 b // 第二個隨機數\n→ Step: 計算 num = (a - 1) * 7 + b // 產生 1~49\n→ Decision: 若 num > 40? // 只保留 1~40\n    Yes → Go back to Step 1 // 重新產生\n    No  → Step: 產生 rand10 = (num - 1) mod 10 + 1 // 轉換為 1~10\n→ Step: 回傳 rand10 // 回傳結果\nEnd\n\nBut we need arrow syntax: \"→ Step 1: ...\". Use numbers. For decisions we need indentation. The sample shows \"Decision: 如果數字大於 0? // 檢查數值是否為正\" then Yes→ etc. We should use similar style.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: a ← rand7() // 取得第一個隨機數\n→ Step 2: b ← rand7() // 取得第二個隨機數\n→ Step 3: num ← (a - 1) * 7 + b // 將兩個 1~7 映射到 1~49\n→ Decision: num > 40? // 只使用 1~40 的結果\n    Yes → Step 1 // 若超過 40，重新開始\n    No  → Step 4: result ← ((num - 1) mod 10) + 1 // 轉換到 1~10\n→ Step 5: return result // 回傳隨機整數\nEnd // 程式執行結束\n\nCheck formatting: Use spaces before //.\n\nAlso need to include \"→\" before each step. Indentation for decisions.\n\nWe need to ensure \"Step 1\" reused in loop. Might use \"→ Step 1\" in Yes branch to loop back. It's okay.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: a ← rand7() // 取得第一個隨機數  \n→ Step 2: b ← rand7() // 取得第二個隨機數  \n→ Step 3: num ← (a - 1) * 7 + b // 將兩個 1~7 映射到 1~49  \n→ Decision: num > 40? // 只使用 1~40 的結果  \n  Yes → Step 1 // 若超過 40，重新開始  \n  No  → Step 4: result ← ((num - 1) mod 10) + 1 // 轉換到 1~10  \n→ Step 5: return result // 回傳隨機整數  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpl4n_4zcb.py\", line 81, in <module>\n    main()\n  File \"/tmp/tmpl4n_4zcb.py\", line 58, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 47 (char 46)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    \"\"\"使用 Binary Indexed Tree (Fenwick Tree) 的實作，支援 O(log n) 的更新與區間和查詢。\"\"\"\n\n    def __init__(self, nums):\n        \"\"\"\n        建構子：把 nums 的長度與元素複製一份，並以 1 為起點建構 BIT。\n        \"\"\"\n        self.n = len(nums)\n        self.nums = nums[:]          # 保留原始陣列以便計算差值\n        self.tree = [0] * (self.n + 1)  # BIT 的索引從 1 開始\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])  # 初始值放進 BIT\n\n    def _update_tree(self, i, val):\n        \"\"\"將 val 加到 BIT 的索引 i 及其父節點上。\"\"\"\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        \"\"\"\n        更新 nums[index] 為 val，並把差值同步更新到 BIT。\n        \"\"\"\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        \"\"\"\n        取得左至右（含）區間的和。透過前綴和差值實現。\n        \"\"\"\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        \"\"\"計算 BIT 前綴和，返回 1 .. i 的總和。\"\"\"\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\n\ndef main():\n    \"\"\"\n    讀取輸入、執行操作並輸出結果。輸入格式為 JSON 兩個陣列：\n    ops = ['NumArray', 'sumRange', ...]\n    args = [[[1,3,5]], [0,2], ...]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        print('[]')\n        return\n\n    # 解析輸入為兩個列表\n    ops, args = json.loads(data)\n    results = []\n\n    obj = None  # 存放 NumArray 的實例\n    for op, arg in zip(ops, args):\n        if op == 'NumArray':\n            obj = NumArray(arg[0])  # arg 是一個列表包裹的陣列\n            results.append(None)\n        elif op == 'update':\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif op == 'sumRange':\n            res = obj.sumRange(arg[0], arg[1])\n            results.append(res)\n        else:\n            # 若出現未知操作，可忽略或拋例外\n            results.append(None)\n\n    # 使用 json.dumps 以符合範例輸出的 null 形式\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the implementation of the described NumArray class. The output should be step-by-step pseudo-code with explanations. Use arrows, decisions etc. We need to describe initialization, update, sumRange. Use virtual code structure.\n\nWe need to follow format: \"虛擬碼步驟 // 解釋/說明\". Each line includes a virtual step and comment. We should include Start, End, etc.\n\nThe virtual code might look like:\n\nStart // 程式開始執行\n→ Step 1: 建立節點結構 Node // 建立樹節點用於區段樹\n→ Step 2: 建立區段樹 build(nums, node, l, r) // 建立區段樹\n... etc.\n\nWe need to be thorough but not too verbose. Should include recursion.\n\nWe can choose to use Segment Tree. The steps: build tree, update, query sum.\n\nMake sure to include decisions like base case.\n\nLet's craft lines.\n\nWe'll need:\n\n- Start\n- Step: Initialize array size N\n- Step: Build segment tree\n\nWithin build, use recursion: if l==r, set node.value=nums[l]; else build left, right, sum.\n\nUpdate: recursively traverse, if index==l==r, set value; else go left/right, then update node.value.\n\nQuery: recursively sum.\n\nWe should keep each line separate. Use arrow lines for decisions.\n\nWe can use \"Decision:\" for base case.\n\nUse \"Yes →\" \"No →\" etc.\n\nOk. We'll produce virtual code.\n\nWe also need to mention Node structure. Maybe include Node array representation.\n\nLet's craft:\n\nStart\n→ Step 1: Define class NumArray\n→ Step 2: Private members: int[] tree, int n // segment tree array and size\n→ Step 3: Constructor NumArray(nums) // initialize\n    → Step 3.1: n = nums.length\n    → Step 3.2: tree = new int[4*n] // allocate enough space\n    → Step 3.3: build(0, 0, n-1, nums) // build tree\n→ Step 4: void update(index, val)\n    → Step 4.1: update(0, 0, n-1, index, val)\n→ Step 5: int sumRange(left, right)\n    → Step 5.1: return query(0, 0, n-1, left, right)\n→ End\n\nNow define functions:\n\n→ Function build(node, l, r, nums)\n    → Decision: l==r? // leaf\n        Yes → tree[node] = nums[l] // set leaf value\n        No → Decision: (mid) // compute mid\n            → mid = (l+r)/2\n            → build(node*2+1, l, mid, nums)\n            → build(node*2+2, mid+1, r, nums)\n            → tree[node] = tree[node*2+1] + tree[node*2+2]\n\nSimilarly for update and query.\n\nWe'll need to separate each line.\n\nWe can use arrows for recursion calls.\n\nLet's produce each line. Ensure each line has \" // 解釋\".\n\nLet's begin.\n\nStart // 程式開始執行\n\nWe'll produce.\n\nMake sure each line has virtual code step and explanation. Use arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 NumArray // 建立主類別  \n→ Step 2: 私有變數 int[] tree, int n // 以陣列存儲區段樹，n 為原始陣列長度  \n→ Step 3: Constructor NumArray(int[] nums) // 初始化區段樹  \n    → Step 3.1: n = nums.length // 記錄原始陣列長度  \n    → Step 3.2: tree = new int[4 * n] // 為區段樹分配足夠空間  \n    → Step 3.3: build(0, 0, n - 1, nums) // 建立區段樹  \n→ Step 4: void update(int index, int val) // 更新元素值  \n    → Step 4.1: update(0, 0, n - 1, index, val) // 進入遞迴更新  \n→ Step 5: int sumRange(int left, int right) // 查詢區間和  \n    → Step 5.1: return query(0, 0, n - 1, left, right) // 進入遞迴查詢  \nEnd // 程式執行結束  \n\n→ Function build(int node, int l, int r, int[] nums) // 建立區段樹的遞迴函式  \n    → Decision: l == r ? // 判斷是否為葉節點  \n        Yes → tree[node] = nums[l] // 葉節點儲存對應元素值  \n        No → Step 6: int mid = (l + r) / 2 // 計算中點  \n            → build(node * 2 + 1, l, mid, nums) // 建立左子樹  \n            → build(node * 2 + 2, mid + 1, r, nums) // 建立右子樹  \n            → tree[node] = tree[node * 2 + 1] + tree[node * 2 + 2] // 計算並存儲區間和  \n\n→ Function update(int node, int l, int r, int index, int val) // 更新區段樹的遞迴函式  \n    → Decision: l == r ? // 到達目標葉節點  \n        Yes → tree[node] = val // 更新值  \n        No → Step 7: int mid = (l + r) / 2 // 計算中點  \n            → Decision: index <= mid ? // 判斷更新在哪個子區間  \n                Yes → update(node * 2 + 1, l, mid, index, val) // 更新左子樹  \n                No → update(node * 2 + 2, mid + 1, r, index, val) // 更新右子樹  \n            → tree[node] = tree[node * 2 + 1] + tree[node * 2 + 2] // 更新父節點的區間和  \n\n→ Function query(int node, int l, int r, int ql, int qr) // 查詢區間和的遞迴函式  \n    → Decision: ql <= l && r <= qr ? // 當節點覆蓋完全在查詢區間內  \n        Yes → return tree[node] // 直接返回區間和  \n        No → Step 8: int mid = (l + r) / 2 // 計算中點  \n            → Decision: qr <= mid ? // 完全在左子樹  \n                Yes → return query(node * 2 + 1, l, mid, ql, qr) // 只查詢左子樹  \n                No → Decision: ql > mid ? // 完全在右子樹  \n                    Yes → return query(node * 2 + 2, mid + 1, r, ql, qr) // 只查詢右子樹  \n                    No → // 区间跨越左右子樹  \n                        → int leftSum = query(node * 2 + 1, l, mid, ql, mid) // 左子樹部分和  \n                        → int rightSum = query(node * 2 + 2, mid + 1, r, mid + 1, qr) // 右子樹部分和  \n                        → return leftSum + rightSum // 合併兩部分得到總和"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index, path, value, last):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit(0)\n\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]+)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if num_match and target_match:\n        num = num_match.group(1)\n        target = int(target_match.group(1))\n    else:\n        # Fallback: assume first line is num string, second line is target integer\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            num = lines[0].strip()\n            target = int(lines[1].strip())\n        else:\n            num = lines[0].strip()\n            target = int(lines[1].strip()) if len(lines) > 1 else 0\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for generating all expressions by inserting operators, evaluating to target. Standard LeetCode 282 problem. Need to produce step-by-step pseudo-code with comments. Should use Start, Decision, End. Provide each step with explanation.\n\nThe steps include:\n\n- Start\n- Initialize result list\n- Define recursive DFS function: parameters: path string, index, eval current value, prev operand\n- At each recursive call, if index == len(num), if eval == target, add path to result\n- Else loop from i=index to len(num)-1: substr = num[index:i+1]\n- If substr has leading zeros and length>1 skip\n- Convert cur = int(substr)\n- If index==0: call DFS with path=substr, eval=cur, prev=cur\n- Else: for each op: '+', '-', '*'\n   For '+': new_eval = eval + cur; prev = cur\n   For '-': new_eval = eval - cur; prev = -cur\n   For '*': new_eval = eval - prev + prev * cur; prev = prev * cur\n- Continue\n\nBut need to produce pseudo-code lines with arrows and explanations.\n\nLet's format each line with `→` arrow or `Decision:`. Use Start and End. For recursive function we can define separate steps.\n\nWe should produce something like:\n\nStart // Start\n→ Step 1: Define function dfs(index, path, eval, prev) // DFS parameters\n...\n\nBut each line is a step; for recursive function we can treat each block as a step? Might need to produce lines for logic inside DFS. For readability, we can include lines for function definition and body.\n\nWe need to ensure each line has a comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Set result list to empty // 存儲符合條件的表達式\n→ Step 2: Call DFS(0, \"\", 0, 0) // 開始遞迴\n→ Step 3: Return result // 結束並返回所有表達式\nEnd // 程式執行結束\n\nBut we also need the DFS logic. We'll include steps inside DFS with indentation.\n\nUse structure:\n\n→ Function dfs(index, path, eval, prev):\n    → Decision: index == len(num)? // 是否已經處理完所有位\n        Yes → Decision: eval == target? // 檢查計算結果是否符合目標\n            Yes → Step: Add path to result // 把完整表達式加入結果\n            No  → Step: Return // 結束此分支\n        No  → Step: For i from index to len(num)-1 // 遍歷剩餘子字串\n            → Step: substring = num[index:i+1] // 取子字串\n            → Decision: substring has leading zero and length>1? // 檢查前導零\n                Yes → Continue // 跳過不合法子字串\n                No  → Step: cur = int(substring) // 轉換為數字\n            → Decision: index == 0? // 第一個數字不用加操作符\n                Yes → Step: dfs(i+1, substring, cur, cur) // 直接遞迴\n                No  → Step: For op in ['+','-','*'] // 遍歷操作符\n                    → Decision: op == '+'? // 加號\n                        Yes → Step: dfs(i+1, path + \"+\" + substring, eval + cur, cur)\n                    → Decision: op == '-'? // 減號\n                        Yes → Step: dfs(i+1, path + \"-\" + substring, eval - cur, -cur)\n                    → Decision: op == '*'? // 乘號\n                        Yes → Step: newEval = eval - prev + prev * cur // 調整乘法先算\n                               Step: newPrev = prev * cur\n                               Step: dfs(i+1, path + \"*\" + substring, newEval, newPrev)\n\nBut each line must be single step. We can split the * case into separate lines.\n\nWe should maintain the arrows. For nested decisions, we might indent or separate lines. The format requires each line with arrow. We'll produce lines like:\n\n→ Decision: index == len(num)? // ...\n    Yes → Decision: eval == target? ...\n        Yes → Step: Add path to result // ...\n        No  → Step: Return // ...\n    No  → Step: For i from index to len(num)-1 // ...\n\nBut indent is not specified, but we can show indentation by spaces. We'll keep it simple.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 result 為空列表 // 用來存放符合目標的所有表達式\n→ Step 2: 呼叫 dfs(0, \"\", 0, 0) // 開始遞迴，起始索引為 0，路徑、目前值、上一個操作數均為 0\n→ Step 3: 回傳 result // 所有遞迴完成後，返回結果列表\nEnd // 程式執行結束\n\nFunction dfs(index, path, eval, prev) // index: 當前處理到的位置；path: 已組成的表達式；eval: 整個表達式目前的算值；prev: 最近一次乘法的前驅值\n    → Decision: index == len(num) ? // 是否已經把整個字串消耗完\n        Yes → Decision: eval == target ? // 目前算值是否等於目標\n            Yes → Step: result.append(path) // 加入符合條件的表達式\n            No  → Step: return // 不符合，直接返回\n        No  → Step: for i in range(index, len(num)) // 從現在位置往後逐個切出子字串\n            → Step: substring = num[index : i+1] // 取出子字串\n            → Decision: substring has leading zero AND len(substring) > 1 ? // 檢查前導零\n                Yes → Step: continue // 跳過不合法的子字串\n                No  → Step: cur = int(substring) // 將子字串轉成數字\n            → Decision: index == 0 ? // 第一個數字不需要前置符號\n                Yes → Step: dfs(i+1, substring, cur, cur) // 直接遞迴\n                No  → Step: for op in ['+', '-', '*'] // 遍歷所有可能的操作符\n                    → Decision: op == '+' ?\n                        Yes → Step: dfs(i+1, path + \"+\" + substring, eval + cur, cur) // 加號情況\n                    → Decision: op == '-' ?\n                        Yes → Step: dfs(i+1, path + \"-\" + substring, eval - cur, -cur) // 減號情況\n                    → Decision: op == '*' ?\n                        Yes → Step: newEval = eval - prev + prev * cur // 調整乘法優先計算\n                        → Step: newPrev = prev * cur // 更新最近乘法的前驅值\n                        → Step: dfs(i+1, path + \"*\" + substring, newEval, newPrev) // 乘號情況\n```"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[5,1,1,1,6,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[5, 1, 1, 1, 6, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[3,1,2,2,3,1]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[3, 1, 2, 2, 3, 1]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"Reorder nums into nums[0] < nums[1] > nums[2] < nums[3] ...\"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            if i % 2 == 1:  # i is odd, we need nums[i-1] > nums[i]\n                if nums[i - 1] < nums[i]:\n                    nums[i - 1], nums[i] = nums[i], nums[i - 1]\n            else:          # i is even, we need nums[i-1] < nums[i]\n                if nums[i - 1] > nums[i]:\n                    nums[i - 1], nums[i] = nums[i], nums[i - 1]\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    # Extract the list part, e.g. \"[1,5,1,1,6,4]\"\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums = ast.literal_eval(match.group())\n    else:\n        nums = []\n\n    sol = Solution()\n    sol.wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with comments explaining. The problem: reorder array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] ... typical solution: iterate i from 1 to n-1, if i is odd then require nums[i-1] > nums[i], if not, swap. For even indices require nums[i-1] < nums[i], else swap. That's common. Let's produce lines:\n\nStart\n→ Step 1: Read array nums // input array\n→ Step 2: For i from 1 to length(nums)-1 // iterate\n    → Decision: If i is odd? // check index parity\n        Yes → Decision: If nums[i-1] < nums[i]? // need descending at odd\n            Yes → No action // already correct\n            No  → Step 3: Swap nums[i-1] and nums[i] // swap to satisfy\n        No  → Decision: If nums[i-1] > nums[i]? // need ascending at even\n            Yes → No action\n            No  → Step 3: Swap nums[i-1] and nums[i]\n→ End // finished\n\nBut we need each line. The pseudocode with arrows and indentations. Ensure each line ends with // explanation.\n\nLet's write line by line.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: Read array nums // 讀取輸入的整數陣列\n\nLine 3: → Step 2: For i from 1 to length(nums)-1 // 從第二個元素開始遍歷\n\nLine 4:     → Decision: If i is odd? // 判斷索引是奇數\n\nLine 5:         Yes → Decision: If nums[i-1] < nums[i]? // 奇數位置需為下降\n\nLine 6:             Yes → No action // 已符合條件，不需交換\n\nLine 7:             No  → Step 3: Swap nums[i-1] and nums[i] // 交換以滿足條件\n\nLine 8:         No  → Decision: If nums[i-1] > nums[i]? // 偶數位置需為上升\n\nLine 9:             Yes → No action // 已符合條件\n\nLine 10:            No  → Step 3: Swap nums[i-1] and nums[i] // 交換以滿足條件\n\nLine 11: End // 程式執行結束\n\nMake sure indentation: maybe use 4 spaces. Also maintain arrow format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read array nums // 讀取輸入的整數陣列  \n→ Step 2: For i from 1 to length(nums)-1 // 從第二個元素開始遍歷  \n  → Decision: If i is odd? // 判斷索引是奇數  \n   Yes → Decision: If nums[i-1] < nums[i]? // 奇數位置需為下降  \n    Yes → No action // 已符合條件，不需交換  \n    No  → Step 3: Swap nums[i-1] and nums[i] // 交換以滿足條件  \n  No  → Decision: If nums[i-1] > nums[i]? // 偶數位置需為上升  \n   Yes → No action // 已符合條件  \n   No  → Step 3: Swap nums[i-1] and nums[i] // 交換以滿足條件  \nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites):\n        \"\"\"\n        使用 Kahn 演算法進行拓樸排序\n        \"\"\"\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填充鄰接表與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 將所有入度為 0 的節點加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # 逐步處理佇列中的節點\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程皆已排入順序，則返回順序；否則返回空列表\n        return order if len(order) == numCourses else []\n\ndef main():\n    \"\"\"\n    從標準輸入讀取資料，解析後輸出課程排序結果\n    輸入範例：\n        numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得 numCourses 數值\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    if not num_match:\n        raise ValueError(\"輸入中缺少 numCourses\")\n    numCourses = int(num_match.group(1))\n\n    # 取得 prerequisites 字串並解析成 Python 物件\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data, re.DOTALL)\n    if not pre_match:\n        raise ValueError(\"輸入中缺少 prerequisites\")\n    prereq_str = pre_match.group(1)\n    prerequisites = ast.literal_eval(prereq_str)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n    print(order)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for topological sort algorithm to find order of courses or empty array if cycle. Use BFS Kahn algorithm or DFS. Provide steps line by line with explanation. Use Start, Decision, etc. Let's produce a clear flow. We'll include building adjacency list, indegree, queue, loop, etc. Let's produce maybe 25-30 lines. Ensure each line ends with // explanation. Use \"Start\" and \"End\". Use \"Decision:\" lines with Yes and No branches. Use \"→\" arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 graph 為空字典 // 建立課程與其後續課程的鄰接表  \n→ Step 2: 初始化 indegree 為長度為 numCourses 的全 0 陣列 // 代表每門課的前置課程數  \n→ Step 3: For each pair [a, b] in prerequisites  \n  → Add a 到 graph[b] 的鄰接清單 // b 是 a 的前置課程  \n  → indegree[a]++ // a 的前置課程數量增加  \n→ Step 4: 初始化 queue 為空列表 // 用於存放 indegree 為 0 的課程  \n→ Step 5: For i from 0 to numCourses-1  \n  → Decision: 如果 indegree[i] == 0? // 無前置課程可立即修  \n    Yes → Append i 到 queue // 可加入修課序列  \n    No → Do nothing // 需要等待前置課程完成  \n→ Step 6: 初始化 result 為空列表 // 存放最終課程修習順序  \n→ Step 7: While queue 非空  \n   → Step 7a: Pop 首項 cur 於 queue // 取一門可修課程  \n   → Append cur 到 result // 加入修習順序  \n   → For each neighbour next 在 graph[cur]  \n    → indegree[next]-- // 移除已修課程的依賴  \n    → Decision: 如果 indegree[next] == 0? // 此課程現在無依賴  \n      Yes → Append next 到 queue // 可以加入 queue 修習  \n      No → Do nothing  \n→ Step 8: Decision: 如果 len(result) == numCourses? // 所有課程都已安排  \n   Yes → Return result // 有效順序，返回修習順序  \n   No  → Return empty list // 產生循環，無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.002314538263295969,0.27592131512028245],[0.6305347767999133,0.3589708571684611],[-0.8112299337411658,0.5330721650474111]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.002314538263295969, 0.27592131512028245], [0.6305347767999133, 0.3589708571684611], [-0.8112299337411658, 0.5330721650474111]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    \"\"\"\n    產生圓內均勻分佈的隨機點\n    \"\"\"\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        使用極座標產生均勻分布的隨機點\n        \"\"\"\n        # 隨機半徑，採用 sqrt 保證均勻分佈\n        r = self.radius * math.sqrt(random.random())\n        # 隨機角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 計算座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\n\nif __name__ == \"__main__\":\n    # 讀取 stdin 的兩行輸入\n    raw = sys.stdin.read().strip().splitlines()\n    if not raw:\n        sys.exit()\n\n    # 解析指令與對應的參數\n    commands = json.loads(raw[0])\n    args_list = json.loads(raw[1])\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # 物件建立後回傳 null\n        elif cmd == \"randPoint\":\n            results.append(obj.randPoint())\n        else:\n            # 如有其他指令，預設回傳 None\n            results.append(None)\n\n    # 以 JSON 格式輸出結果，Python 的 None 會被轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: given radius, center, generate uniform random point inside circle. Classic method: generate random angle theta in [0,2π) and random radius r with distribution sqrt(u)*R. So steps: generate u in [0,1), set r = sqrt(u)*radius. Generate angle theta uniform [0,2π). Compute x = x_center + r * cos(theta); y = y_center + r * sin(theta). Return [x, y]. Also initialization stores radius, center. Provide virtual code lines with explanations. Use Start, End, Decision? There's no decision needed except maybe none. Provide arrow lines. We'll produce step-by-step.\n\nUse 'Solution: 初始化' for constructor. Use 'randPoint: generate random point' etc.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n\nUse arrow '→'.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution，帶有屬性 radius、x_center、y_center // 用來儲存圓的半徑與中心座標\n→ Step 2: Solution(double radius, double x_center, double y_center) { // 建構子，初始化屬性\n→     this.radius = radius // 設定半徑\n→     this.x_center = x_center // 設定 X 軸中心\n→     this.y_center = y_center // 設定 Y 軸中心\n→ } // 建構子結束\n→ Step 3: randPoint() { // 產生隨機點的函式\n→     // 產生一個 0~1 之間的隨機數，用於計算半徑\n→     u ← Random() // 隨機數器，返回 0~1\n→     // 將隨機數平方根後乘以半徑，以確保點在圓內均勻分布\n→     r ← sqrt(u) * this.radius // 隨機半徑\n→     // 產生一個 0~2π 的隨機角度\n→     theta ← Random() * 2π // 隨機角度\n→     // 計算點的 X、Y 坐標\n→     x ← this.x_center + r * cos(theta) // X 座標\n→     y ← this.y_center + r * sin(theta) // Y 座標\n→     // 回傳結果\n→     return [x, y] // 隨機點的座標陣列\n→ } // randPoint 函式結束\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 3, 0, 4, _, _, _]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\ndef removeElement(nums, val):\n    \"\"\"移除 nums 中所有值為 val 的元素，原地操作，返回新長度 k。\"\"\"\n    write_idx = 0\n    for num in nums:\n        if num != val:\n            nums[write_idx] = num\n            write_idx += 1\n    return write_idx\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入中的 nums 與 val\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    val_match = re.search(r'val\\s*=\\s*([-\\d]+)', data)\n    if not nums_match or not val_match:\n        return\n\n    nums = ast.literal_eval(nums_match.group(1))\n    val = int(val_match.group(1))\n\n    # 執行移除\n    k = removeElement(nums, val)\n\n    # 產生輸出格式\n    output_items = []\n    for i in range(k):\n        output_items.append(str(nums[i]))\n    for _ in range(len(nums) - k):\n        output_items.append('_')\n    print(f\"{k}, nums = [{', '.join(output_items)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation comments. The user wants solution for problem: remove element from array in-place. They want virtual code steps. Use Start, End, Decision, arrows, etc. We must not output actual code but pseudo steps.\n\nWe should produce step-by-step algorithm: Use two-pointer approach: i for reading, j for writing. Iterate over nums, if nums[i] != val, set nums[j] = nums[i]; j++. Finally return j. That's the simplest.\n\nWe need to produce each step on separate line with the pattern: `虛擬碼步驟 // 解釋`. Use arrow →. Provide decision branches as needed. For this algorithm, there is no explicit decision with arrows except in loop. We can include Decision for \"元素是否等於 val?\" and Yes/No branches.\n\nAlso may include Start and End. Provide steps like: Start, → Step: 設定寫入指標 j 為 0, → Step: 循環 i 從 0 到 nums.length-1, → Decision: 如果 nums[i] 等於 val? → No → Step: 把 nums[i] 放到 nums[j]， j++ ; → Yes → Step: 跳過; End loop; → Step: 回傳 j; End.\n\nLet's produce lines accordingly.\n\nMake sure each line ends with comment // explanation. Use spaces after code. Use arrow.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化寫入指標 writeIdx 為 0 // 用於標記下一個要寫入的位置  \n→ Step: 初始化讀取指標 readIdx 為 0 // 用於遍歷整個陣列  \n→ Decision: readIdx 是否小於 nums.length? // 判斷是否還有元素可讀  \n    Yes → Step: 如果 nums[readIdx] ≠ val? // 檢查當前元素是否要保留  \n        Yes → Step: 把 nums[readIdx] 存回 nums[writeIdx] // 將保留元素寫入前面  \n        → Step: writeIdx ← writeIdx + 1 // 更新寫入指標  \n        No  → Step: // 當元素等於 val 時不做任何寫入，直接跳過  \n    No  → Step: // 讀取完成，所有非 val 元素已在前面  \n→ Step: readIdx ← readIdx + 1 // 前進到下一個元素  \n← // 回到 Decision 以判斷是否還有元素  \nEnd // 程式執行結束  \n→ Step: 回傳 writeIdx // writeIdx 即為 k，表示非 val 元素的個數與新陣列的有效長度。"
    },
    {
      "title": "First Missing Positive",
      "source_file": "Leetcode/leetcode41.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7x09lwm2.py\", line 36, in <module>\n    nums = parse_input(lines[0]) if lines else []\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7x09lwm2.py\", line 26, in parse_input\n    return ast.literal_eval(line[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1,2,0\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5minj8md.py\", line 36, in <module>\n    nums = parse_input(lines[0]) if lines else []\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5minj8md.py\", line 26, in parse_input\n    return ast.literal_eval(line[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3,4,-1,1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpw7d1otyk.py\", line 36, in <module>\n    nums = parse_input(lines[0]) if lines else []\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpw7d1otyk.py\", line 26, in parse_input\n    return ast.literal_eval(line[start:end])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [7,8,9,11,12\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        n = len(nums)\n        for i in range(n):\n            # 將 nums[i] 放到正確的位置 nums[nums[i]-1]\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                # 交換\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1\n\ndef parse_input(line):\n    \"\"\"\n    從輸入文字中抽取列表，例如 'nums = [1,2,0]' → [1, 2, 0]\n    \"\"\"\n    start = line.find('[')\n    end = line.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    return ast.literal_eval(line[start:end])\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，允許多行輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 只處理第一行（或多行合併），根據題目範例格式\n    lines = data.splitlines()\n    nums = parse_input(lines[0]) if lines else []\n\n    solution = Solution()\n    result = solution.firstMissingPositive(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Problem: given unsorted integer array, find smallest missing positive integer. Need O(n) time, O(1) space. Standard algorithm: use index-based placement: for each number in 1..n, put number x at index x-1 if x in range. Then scan for first index where arr[i]!=i+1. That is answer i+1, else n+1. Use in-place.\n\nWe must produce virtual code step by step. Format: Each line \"虛擬碼步驟 // 解釋\". Must use arrows: Start, End, Decision, etc. Let's craft:\n\nStart\n→ Step 1: N ← length of nums // get size\n→ Step 2: for i from 0 to N-1 do // iterate array\n    → Decision: If nums[i] <= 0 or nums[i] > N? // ignore out-of-range numbers\n        Yes → Skip // do nothing\n        No  → Step 3: while nums[i] != i+1 and nums[i] <= N and nums[nums[i]-1] != nums[i] do // swap to correct position\n            → Step 4: temp ← nums[i]\n            → Step 5: nums[i] ← nums[temp-1]\n            → Step 6: nums[temp-1] ← temp\n            → End while\n→ Step 7: for i from 0 to N-1 do // find first missing\n    → Decision: If nums[i] != i+1? // mismatch indicates missing\n        Yes → Return i+1 // found smallest missing positive\n        No  → Continue\n→ Step 8: Return N+1 // all positions filled, so next missing\nEnd\n\nBut need arrow notation. For loops, we can show \"→ Step 2: for i in 0..N-1\" etc.\n\nAlso use Decision indentation.\n\nLet's craft final answer with each line. Ensure each line ends with \"// 解釋\". Use Chinese. Provide all steps.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: N ← length of nums // 取得陣列長度  \n→ Step 2: for i from 0 to N-1 do // 逐一檢查每個元素  \n  → Decision: nums[i] ≤ 0 or nums[i] > N? // 是否為無效正整數  \n   Yes → Skip // 無效數值不處理  \n   No  → Step 3: while nums[i] ≠ i+1 and nums[i] ≤ N and nums[nums[i]-1] ≠ nums[i] do // 把正整數放到正確位置  \n    → Step 4: temp ← nums[i] // 暫存當前值  \n    → Step 5: nums[i] ← nums[temp-1] // 把目標位置的值移到當前  \n    → Step 6: nums[temp-1] ← temp // 把暫存值放到目標位置  \n    → End while // 位置正確或無法交換時結束循環  \n→ Step 7: for i from 0 to N-1 do // 再次遍歷陣列找缺失值  \n  → Decision: nums[i] ≠ i+1? // 檢查索引是否對應正整數  \n   Yes → Return i+1 // 找到第一個缺失的正整數即為答案  \n   No  → Continue // 繼續檢查下一個索引  \n→ Step 8: Return N+1 // 所有位置皆正確，缺失值為 N+1  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[1,3,2],[1,3,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [1, 3, 2], [1, 3, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)          # 儲存原始陣列\n        self.arr = list(nums)               # 用於 shuffle 的工作陣列\n\n    def reset(self):\n        self.arr = list(self.original)      # 重設工作陣列為原始陣列\n        return self.arr\n\n    def shuffle(self):\n        n = len(self.arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)    # 隨機選擇索引\n            self.arr[i], self.arr[j] = self.arr[j], self.arr[i]  # 交換\n        return self.arr\n\ndef main():\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 將輸入分成兩部分：操作名稱列表與參數列表\n    split_idx = raw_input.find('],')\n    ops_str = raw_input[:split_idx + 1]\n    args_str = raw_input[split_idx + 2:]\n\n    ops = json.loads(ops_str)\n    args = json.loads(args_str)\n\n    result = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])          # arg[0] 為 nums\n            result.append(None)             # 按照 LeetCode 風格返回 null\n        elif op == \"reset\":\n            res = obj.reset()\n            result.append(res)\n        elif op == \"shuffle\":\n            res = obj.shuffle()\n            result.append(res)\n        else:\n            # 若有其他未知方法，可自行處理\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以得到符合範例的格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines step by step, no actual code. We need to follow the requested format.\n\nUser: requirement: design algorithm to shuffle array, all permutations equally likely. Implement class with constructor, reset, shuffle.\n\nSo produce virtual code.\n\nWe need to produce each line: \"虛擬碼步驟 // 解釋\".\n\nWe can incorporate the steps of class definition, storing original array, making copy, implementing shuffle using Fisher-Yates.\n\nWe should use virtual code arrows and structure.\n\nLet's design:\n\nStart\n→ Step: Define class Solution // Declare class\n→ Step: Store original array reference // keep original\n→ Step: Make copy for shuffle // internal array\n\nConstructor:\n→ Step: Solution(nums) // initialize with nums\n→ Step: original ← nums // store reference\n→ Step: array ← copy of nums // copy for manipulation\n\nreset():\n→ Step: reset() // return original config\n→ Step: array ← copy of original // reset\n→ Step: return array // output\n\nshuffle():\n→ Step: shuffle() // random permutation\n→ Step: n ← length of array // size\n→ Step: for i from 0 to n-1\n    → Step: j ← random int [i, n-1] // pick random index\n    → Step: swap array[i] and array[j] // swap\n→ Step: return array // shuffled\n\nEnd.\n\nWe need to use virtual code style: Start, Decision, etc. But simple steps can be Step.\n\nWe need to use arrow →.\n\nWe need to include comments after //.\n\nWe must output each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 定義類別 Solution // 宣告 Solution 類別\n→ Step: 定義原始陣列原始數據 // 儲存輸入的原始陣列\n→ Step: 定義工作陣列工作數據 // 用於隨機化的複本\n→ Step: Solution(nums) // 建構子：接收 nums\n    → Step: 原始數組 ← nums // 直接引用原始陣列\n    → Step: 工作數組 ← 複製原始數組 // 創建可修改的副本\n→ Step: reset() // 重設方法：返回原始排列\n    → Step: 工作數組 ← 複製原始數組 // 將工作陣列恢復為原始\n    → Step: 返回 工作數組 // 回傳重設後的陣列\n→ Step: shuffle() // 隨機化方法：返回隨機排列\n    → Step: n ← 長度(工作數組) // 取得陣列長度\n    → Step: for i = 0 到 n-1\n        → Step: j ← 隨機整數範圍(i, n-1) // 隨機挑選索引\n        → Step: 交換 工作數組[i] 與 工作數組[j] // 交換元素\n    → Step: 返回 工作數組 // 回傳隨機排列\nEnd // 程式執行結束\n\nWe need to ensure each line is separate, no blank lines? We can keep line breaks.\n\nMake sure we follow the formatting: \"虛擬碼步驟 [space] // 解釋\".\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 定義類別 Solution // 宣告 Solution 類別  \n→ Step: 定義原始陣列 originalNums // 儲存輸入的原始陣列  \n→ Step: 定義工作陣列 shuffledNums // 用於隨機化的可修改副本  \n→ Step: Solution(nums) // 建構子：接收 nums  \n → Step: originalNums ← nums // 直接引用原始陣列  \n → Step: shuffledNums ← 複製(originalNums) // 創建可修改的副本  \n→ Step: reset() // 重設方法：返回原始排列  \n → Step: shuffledNums ← 複製(originalNums) // 將工作陣列恢復為原始  \n → Step: 返回 shuffledNums // 回傳重設後的陣列  \n→ Step: shuffle() // 隨機化方法：返回隨機排列  \n → Step: n ← 長度(shuffledNums) // 取得陣列長度  \n → Step: for i = 0 到 n-1  \n   → Step: j ← 隨機整數範圍(i, n-1) // 隨機挑選索引  \n   → Step: 交換 shuffledNums[i] 與 shuffledNums[j] // 交換元素  \n → Step: 返回 shuffledNums // 回傳隨機排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = []\n    else:\n        nums_str = data[start:end+1]\n        try:\n            nums = eval(nums_str, {\"__builtins__\": None}, {})\n        except Exception:\n            nums = []\n    solution = Solution()\n    result = solution.subsets(nums)\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of a unique integer array. Need to output step by step with explanation, in traditional Chinese. Use arrows. So we design algorithm: backtracking or bitmask. Use recursion or iteration. We'll produce a typical backtracking approach: function backtrack(index, currentSubset). Start from index 0. For each element, choose to include or exclude. Add subset when index reaches length. Return all subsets. Provide steps.\n\nWe need to use Start, End, Decision: and arrows. Provide each line with // explanation.\n\nAlso use \"Yes →\" and \"No →\" for decisions. Provide step numbering.\n\nLet's produce code steps:\n\nStart // 程式開始\n→ Step 1: 定義函式 generateSubsets(nums) // 準備輸出\n→ Step 2: 初始化結果列表 subsets = [] // 存儲所有子集\n→ Step 3: 呼叫 backtrack(0, []) // 從索引0開始遞迴\n→ Step 4: 定義 backtrack(index, current) // 遞迴函式\n→ Decision: index == nums.length? // 檢查是否已遍歷完所有元素\n    Yes → Step 5: 將 current 複製並加入 subsets // 將子集加入結果\n    No  → Decision: 是否包含 nums[index]? // 決定是否把當前元素加入子集\n        Yes → Step 6: current.append(nums[index]) // 加入元素\n        → Step 7: backtrack(index + 1, current) // 進一步遞迴\n        → Step 8: current.pop() // 回溯，移除已加入元素\n        No  → Step 9: backtrack(index + 1, current) // 直接跳過當前元素\n→ Step 10: 返回 subsets // 結束\n→ End // 程式結束\n\nNeed to incorporate arrow directions for decisions. Use indentation for steps within decisions. Should be lines.\n\nMake sure to add arrow '→' before steps. For decisions, use 'Decision:' line. For branches, use 'Yes →' and 'No →' lines. Use step numbering.\n\nAlso ensure we don't output actual code. Use virtual steps.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 generateSubsets(nums) // 準備接收輸入陣列  \n→ Step 2: 初始化結果列表 subsets = [] // 用來儲存所有子集  \n→ Step 3: 呼叫 backtrack(0, []) // 從索引 0 開始遞迴探索  \n→ Step 4: 定義 backtrack(index, current) // 遞迴函式：index 為目前考慮的位置，current 為目前已選的子集  \n→ Decision: index == nums.length? // 判斷是否已處理完所有元素  \n  Yes → Step 5: 將 current 的副本加入 subsets // 完整子集加入結果  \n  No  → Decision: 是否包含 nums[index]? // 決定是否將當前元素納入子集  \n    Yes → Step 6: current.append(nums[index]) // 加入當前元素  \n     → Step 7: backtrack(index + 1, current) // 進一步遞迴到下一個位置  \n     → Step 8: current.pop() // 回溯，移除剛加入的元素  \n    No  → Step 9: backtrack(index + 1, current) // 直接跳過當前元素繼續遞迴  \n→ Step 10: 返回 subsets // 完成後回傳所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpaph_qj2b.py\", line 21, in <module>\n    operations, arguments = json.loads(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 49 (char 48)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析成兩個列表：操作名稱與對應參數\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 使用 json.loads 解析，因為輸入格式符合 JSON\n    operations, arguments = json.loads(raw_input)\n\n    result = []\n    obj = None\n    for op, arg in zip(operations, arguments):\n        if op == \"NumArray\":\n            # arg 是一個只包含一次陣列的列表，例如 [[-2, 0, 3, ...]]\n            obj = NumArray(arg[0])\n            result.append(None)  # LeetCode 期望輸出 null\n        else:\n            # 對於 sumRange，arg 是 [left, right]\n            res = getattr(obj, op)(*arg)\n            result.append(res)\n\n    # 將結果輸出為 JSON 格式，None 會自動轉成 null\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: implement NumArray with constructor and sumRange queries. Use segment tree or prefix sum? Usually prefix sum. Virtual code should show steps. The user only wants virtual code steps, not actual code. So we need to produce line by line steps. Use \"Start\", \"End\", \"Decision\", arrow etc. Provide explanation after space.\n\nWe'll produce steps for initialization: compute prefix sum array of length n+1. Then sumRange returns prefix[right+1]-prefix[left]. Provide decisions? Maybe handle bounds. Could include decision if left or right out of range. But typical implementation just assume valid indices. We'll include check.\n\nLet's create steps:\n\nStart\n→ Step 1: Input nums array // receive input array\n→ Step 2: n = length(nums) // store length\n→ Step 3: prefix[0] = 0 // initialize prefix sum array\n→ Decision: For i from 1 to n? // iterate through array\n    → Step 4: prefix[i] = prefix[i-1] + nums[i-1] // compute cumulative sum\nEnd // finished initialization\n\nThen sumRange method:\nStart\n→ Step 1: Input left, right // indices\n→ Decision: Validate left <= right? // check\n    Yes → Step 2: result = prefix[right+1] - prefix[left] // compute sum\n    No  → Step 3: result = 0 // or error handling\n→ Step 4: return result // return sum\nEnd\n\nBut need to incorporate into class. Could produce virtual code for class:\n\nStart // NumArray constructor\n...\nEnd\n\nThen another Start for sumRange.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input nums array // 接收使用者提供的整數陣列  \n→ Step 2: n = length(nums) // 記錄陣列長度  \n→ Step 3: prefix[0] = 0 // 初始化前綴和陣列  \n→ Decision: 迴圈 i 從 1 到 n? // 循環計算前綴和  \n  Yes → Step 4: prefix[i] = prefix[i‑1] + nums[i‑1] // 計算累積和  \nEnd // 建構子結束，已經產生 prefix 陣列  \n\nStart // sumRange 方法開始  \n→ Step 1: Input left, right // 取得查詢區間索引  \n→ Decision: left ≤ right? // 檢查索引是否合法  \n  Yes → Step 2: result = prefix[right+1] - prefix[left] // 計算區間總和  \n  No → Step 3: result = 0 // 或者拋出錯誤，這裡簡化為返回 0  \n→ Step 4: return result // 將結果回傳給呼叫者  \nEnd // sumRange 方法結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    # 從輸入中提取被雙引號包住的表達式\n    match = re.search(r'\"(.*?)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        expr = \"\"\n\n    # 計算所有可能的結果\n    result = Solution().diffWaysToCompute(expr)\n\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the problem: given a string expression of numbers and operators, return all possible results from computing all different ways to group numbers and operators. This is the \"Different Ways to Add Parentheses\" problem (Leetcode 241). We need to produce virtual code steps, not actual code.\n\nWe should output line by line virtual code: Start, Step: parse expression, Decision: is it a single number? If yes, return number; else for each operator, split expression into left and right substrings, recursively compute results for left and right, combine results via operator, accumulate. Finally return results. Also need to consider memoization to avoid recomputing.\n\nWe need to produce explanation after each line with //.\n\nLet's craft virtual code:\n\nStart // 開始執行\n\n→ Step 1: 定義函數 diffWays(expr) // 定義遞迴函數計算結果\n\n→ Decision: expr 是否為單一數字? // 檢查是否已無運算符\n\n    Yes → Step 2: 轉換 expr 為整數並返回 [整數] // 直接回傳結果列表\n\n    No → Step 3: 初始化 empty results 列表 // 用於儲存所有可能結果\n\n    → For 迴圈: 遍歷 expr 中每個字符 idx\n\n        → Decision: idx 是否為運算符? // 找到運算符位置\n\n            Yes → Step 4: leftSub = expr[0:idx] // 左子表達式\n\n            Step 5: rightSub = expr[idx+1:] // 右子表達式\n\n            → Step 6: leftResults = diffWays(leftSub) // 递归求左子结果\n\n            Step 7: rightResults = diffWays(rightSub) // 递归求右子结果\n\n            → For 迴圈: left in leftResults\n\n                → For 迴圈: right in rightResults\n\n                    → Step 8: result = applyOperator(left, right, expr[idx]) // 计算两结果\n\n                    Step 9: results.append(result) // 加入結果列表\n\n    → Step 10: memoize(expr, results) // 将结果存入缓存\n\n→ End // 返回\n\nBut we need to produce each line in order. The steps include decisions with Yes and No branches.\n\nWe must use virtual code arrow and structure. The format: \"虛擬碼步驟 // 解釋\". Each line must contain virtual code step plus explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: 定義遞迴函數 diffWays(expr) // 定義計算所有結果的遞迴函式\n\n→ Decision: expr 是否為純數字? // 判斷是否已無運算符可拆分\n\n    Yes → Step 2: 轉換 expr 為整數並回傳 [整數] // 單個數字直接作為唯一結果\n\n    No → Step 3: 初始化空列表 results // 用於收集所有可能的計算結果\n\n→ For idx in 0..len(expr)-1 // 遍歷表達式中的每個字符\n\n    → Decision: expr[idx] 是否為 '+', '-', '*'? // 判斷是否為運算符\n\n        Yes → Step 4: leftExpr = expr[0:idx] // 取運算符左側子表達式\n\n        Step 5: rightExpr = expr[idx+1:] // 取運算符右側子表達式\n\n        Step 6: leftResults = diffWays(leftExpr) // 遞迴計算左子結果\n\n        Step 7: rightResults = diffWays(rightExpr) // 遞迴計算右子結果\n\n        → For left in leftResults // 結合左子結果\n\n            → For right in rightResults // 結合右子結果\n\n                → Step 8: res = applyOperator(left, right, expr[idx]) // 根據運算符計算\n\n                Step 9: results.append(res) // 加入結果列表\n\n→ Step 10: memoize(expr, results) // 將 expr 的結果緩存，避免重複計算\n\n→ Step 11: return results // 回傳所有可能結果\n\nEnd // 程式結束\n\nBut we need to embed decisions with Yes → and No → structure properly. For decisions, we must indent the branches.\n\nAlso we need to reflect memoization optional. For clarity, we can add Step 0: 初始化 memoization cache // global.\n\nLet's produce final virtual code.\n\nWe should format each line with \"虛擬碼步驟 // 解釋\". Ensure no actual code. Use arrows and decision blocks.\n\nLet's craft:\n\nStart // 程式開始執行\n\n→ Step 0: 初始化全局字典 memo = {} // 用於快取子表達式的結果\n\n→ Step 1: 定義遞迴函數 diffWays(expr) // 計算 expr 的所有可能結果\n\n→ Decision: expr 是否為純數字? // 判斷是否無運算符可拆分\n\n    Yes → Step 2: return [int(expr)] // 直接回傳單個數字\n\n    No → Step 3: 若 memo 中已存在 expr, 回傳 memo[expr] // 取得已快取結果\n\n→ Step 4: results = [] // 用於收集本次 expr 的所有結果\n\n→ For idx in 0..len(expr)-1 // 遍歷 expr 每個位置\n\n    → Decision: expr[idx] 是否為 '+', '-', '*'? // 判斷是否為運算符\n\n        Yes → Step 5: leftExpr = expr[0:idx] // 左子表達式\n\n        Step 6: rightExpr = expr[idx+1:] // 右子表達式\n\n        Step 7: leftVals = diffWays(leftExpr) // 取得左子結果\n\n        Step 8: rightVals = diffWays(rightExpr) // 取得右子結果\n\n        → For left in leftVals // 結合左子結果\n\n            → For right in rightVals // 結合右子結果\n\n                → Step 9: result = applyOperator(left, right, expr[idx]) // 執行運算\n\n                Step 10: results.append(result) // 加入到結果列表\n\n→ Step 11: memo[expr] = results // 存入快取\n\n→ Step 12: return results // 回傳所有可能結果\n\n→ End // 程式執行結束\n\nBut we have to make sure each line is a virtual code step with explanation. Each line we have \"虛擬碼步驟 // 解釋\". The decision lines may need indentation. For decisions, we write:\n\n→ Decision: expr 是否為純數字? // 判斷是否無運算符可拆分\n\n    Yes → Step 2: return [int(expr)] // 直接回傳單個數字\n\n    No → Step 3: 若 memo 中已存在 expr, 回傳 memo[expr] // 取得已快取結果\n\nSimilarly for operator detection.\n\nLet's format accordingly:\n\nStart // 程式開始執行\n\n→ Step 0: 初始化全局字典 memo = {} // 用於快取子表達式的結果\n\n→ Step 1: 定義遞迴函數 diffWays(expr) // 計算 expr 的所有可能結果\n\n→ Decision: expr 是否為純數字? // 判斷是否無運算符可拆分\n\n    Yes → Step 2: return [int(expr)] // 直接回傳單個數字\n\n    No → Step 3: 若 memo 中已存在 expr, 回傳 memo[expr] // 取得已快取結果\n\n→ Step 4: results = [] // 用於收集本次 expr 的所有結果\n\n→ For idx in 0..len(expr)-1 // 遍歷 expr 每個位置\n\n    → Decision: expr[idx] 是否為 '+', '-', '*'? // 判斷是否為運算符\n\n        Yes → Step 5: leftExpr = expr[0:idx] // 左子表達式\n\n        Step 6: rightExpr = expr[idx+1:] // 右子表達式\n\n        Step 7: leftVals = diffWays(leftExpr) // 取得左子結果\n\n        Step 8: rightVals = diffWays(rightExpr) // 取得右子結果\n\n        → For left in leftVals // 結合左子結果\n\n            → For right in rightVals // 結合右子結果\n\n                → Step 9: result = applyOperator(left, right, expr[idx]) // 執行運算\n\n                Step 10: results.append(result) // 加入到結果列表\n\n→ Step 11: memo[expr] = results // 存入快取\n\n→ Step 12: return results // 回傳所有可能結果\n\n→ End // 程式執行結束\n\nWe must ensure each line is a single line, no line breaks within the code part. Also the \"Decision:\" block has two branches.\n\nNow let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 初始化全局字典 memo = {} // 用於快取子表達式的結果  \n→ Step 1: 定義遞迴函數 diffWays(expr) // 計算 expr 的所有可能結果  \n→ Decision: expr 是否為純數字? // 判斷是否無運算符可拆分  \n Yes → Step 2: return [int(expr)] // 直接回傳單個數字  \n No → Step 3: 若 memo 中已存在 expr, 回傳 memo[expr] // 取得已快取結果  \n→ Step 4: results = [] // 用於收集本次 expr 的所有結果  \n→ For idx in 0..len(expr)-1 // 遍歷 expr 每個位置  \n → Decision: expr[idx] 是否為 '+', '-', '*'? // 判斷是否為運算符  \n  Yes → Step 5: leftExpr = expr[0:idx] // 左子表達式  \n   Step 6: rightExpr = expr[idx+1:] // 右子表達式  \n   Step 7: leftVals = diffWays(leftExpr) // 取得左子結果  \n   Step 8: rightVals = diffWays(rightExpr) // 取得右子結果  \n   → For left in leftVals // 結合左子結果  \n    → For right in rightVals // 結合右子結果  \n     → Step 9: result = applyOperator(left, right, expr[idx]) // 執行運算  \n     Step 10: results.append(result) // 加入到結果列表  \n→ Step 11: memo[expr] = results // 存入快取  \n→ Step 12: return results // 回傳所有可能結果  \n→ End // 程式執行結束"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeipus465.py\", line 76, in <module>\n    result = sol.calculate(expr)\n             ^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpeipus465.py\", line 43, in calculate\n    apply_operator()\n  File \"/tmp/tmpeipus465.py\", line 18, in apply_operator\n    left = values.pop()\n           ^^^^^^^^^^^^\nIndexError: pop from empty list"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        # 移除空白字符，方便處理\n        s = s.replace(' ', '')\n        values = []   # 儲存數值的棧\n        ops = []      # 儲存運算符號的棧\n        num = 0       # 當前正在解析的數字\n\n        def precedence(op: str) -> int:\n            return 1 if op in '+-' else 2\n\n        def apply_operator():\n            \"\"\"從堆疊中取出兩個數字和運算符，計算結果並推回 values 棧。\"\"\"\n            right = values.pop()\n            left = values.pop()\n            op = ops.pop()\n            if op == '+':\n                values.append(left + right)\n            elif op == '-':\n                values.append(left - right)\n            elif op == '*':\n                values.append(left * right)\n            elif op == '/':\n                # 整數除法，向 0 截斷\n                values.append(int(left / right))\n\n        i = 0\n        n = len(s)\n        while i < n:\n            c = s[i]\n            if c.isdigit():\n                num = num * 10 + int(c)\n                i += 1\n                continue\n            if c == '(':\n                ops.append(c)\n            elif c == ')':\n                # 計算直到遇到左括號\n                while ops and ops[-1] != '(':\n                    apply_operator()\n                ops.pop()  # 移除 '('\n            else:  # '+', '-', '*', '/'\n                # 先把前面的數字推進棧\n                values.append(num)\n                num = 0\n                # 處理優先級\n                while ops and ops[-1] != '(' and precedence(ops[-1]) >= precedence(c):\n                    apply_operator()\n                ops.append(c)\n            i += 1\n\n        # 最後把剩餘數字推進棧\n        if num != 0 or not values:\n            values.append(num)\n\n        # 依次處理剩餘運算符\n        while ops:\n            apply_operator()\n\n        return values[-1]\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中提取第一個被雙引號或單引號包裹的字串\n    match = re.search(r'[\"\\'](.*?)[\"\\']', data, re.DOTALL)\n    if match:\n        expr = match.group(1)\n    else:\n        expr = data.strip()\n\n    sol = Solution()\n    result = sol.calculate(expr)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for evaluating a string expression, no eval. Basic calculator: supports +, -, *, / and parentheses. Probably integer arithmetic, but unclear. Use stack for signs and precedence. Classic solution: iterate over string, maintain current number, sign, stack of multipliers. When encountering operator or end, perform previous operator. Use stack to handle parentheses: push current result and sign onto stack, reset.\n\nWe need virtual code line by line. Provide explanation after //.\n\nLet's craft algorithm:\n\nStart\n→ Initialize result=0, currentNumber=0, currentSign=1 (1 for +, -1 for -)\n→ Initialize stack empty\n→ For each character c in string s:\n    If digit: accumulate currentNumber = currentNumber*10 + int(c)\n    Else if c is '+': result += currentSign * currentNumber; currentNumber=0; currentSign=1\n    Else if c is '-': result += currentSign * currentNumber; currentNumber=0; currentSign=-1\n    Else if c is '(':\n        Push result onto stack\n        Push currentSign onto stack\n        Reset result=0, currentSign=1\n    Else if c is ')':\n        result += currentSign * currentNumber\n        currentNumber=0\n        prevSign = stack.pop()\n        prevResult = stack.pop()\n        result = prevResult + prevSign * result\n    Else if c is '*': store pending multiplication? Approach: use currentSign for plus/minus only, handle * / by using a variable lastValue. Alternative simpler: use stack to store numbers and signs, push currentNumber*sign onto stack when encountering + or -. But for *,/ need to handle precedence.\n\nLet's use stack of numbers: when encountering + or -, push currentNumber*sign onto stack, set sign accordingly. For *,/ push currentNumber onto stack but multiply last element. Actually algorithm: Use stack of ints. sign=1 for '+', -1 for '-'. num=0. When see digit accumulate. When see operator or end: if op == '+': push sign*num; sign=1. If '-': push sign*num; sign=-1. If '*': temp = stack.pop() * num; push temp. If '/': temp = int(stack.pop() / num); push temp. Then reset num=0. For '(': push current stack and sign onto stack, reset.\n\nBut we can use simpler method: Two stacks: one for numbers and one for operators? Let's just implement simple algorithm: Use stack for numbers, sign variable for current sign, currentNumber. When encounter digit accumulate. When encounter operator or end or ')': perform previous operator stored in variable prevOp? But we don't have precedence. So we need to handle * and / with precedence. Use stack for numbers and last operator for current operation. Classic method: maintain lastSign variable for previous operator. For * and /, we compute using stack top.\n\nImplement: lastSign='+' initially. num=0. For each char:\nif digit: num = num*10 + int\nif char in '+-*/' or char==')' or at end:\n    if lastSign=='+': stack.append(num)\n    elif lastSign=='-': stack.append(-num)\n    elif lastSign=='*': stack.append(stack.pop() * num)\n    elif lastSign=='/': stack.append(int(stack.pop() / num)) # integer division truncate towards zero\n    lastSign=char\n    num=0\nif char=='(':\n    push current stack and lastSign onto stack? Actually we can use recursion, but easier: use stack for numbers and a separate stack for signs. But given time, produce virtual code accordingly.\n\nSimplify: use two stacks: values and ops. Use precedence. But we want virtual code, not actual implementation. Provide steps.\n\nLet's craft pseudocode:\n\nStart\n→ Set values stack = empty\n→ Set ops stack = empty\n→ Set num = 0\n→ For each char c in s:\n    If c is digit: num = num*10 + int(c)\n    Else if c is '(': push current values and ops? Actually push markers: push values stack? Use ops stack push '('\n    Else if c is ')' : compute until '('\n    Else if c in '+-*/': process operator precedence: while ops not empty and precedence(ops.top) >= precedence(c): compute\n    After loop push c onto ops\n    Reset num=0\n→ After loop, if num != 0: push num to values\n→ While ops not empty: compute\n→ result = values.top\nReturn result\nCompute function: pop two values, pop operator, push result.\n\nProvide virtual code lines accordingly. Explanation.\n\nLet's produce step-by-step virtual code.\n\nNeed to use virtual arrows and decisions. Use Start, End.\n\nLet's draft:\n\nStart\n→ Initialize values stack // 儲存數值\n→ Initialize ops stack // 儲存運算子\n→ Initialize num = 0 // 當前累積數字\n→ For each character c in string s: // 逐字符處理\n    → Decision: 如果 c 是數字? // 檢查是否為數字\n        Yes → num = num * 10 + int(c) // 累積數字\n        No → Decision: c 是否為 '('? // 處理左括號\n            Yes → ops push '(' // 把左括號推入運算子棧\n            No → Decision: c 是否為 ')' ? // 處理右括號\n                Yes → Decision: ops 非空且頂部不是 '('? // 計算直到左括號\n                    Yes → While ops.top != '(': \n                            → Call Compute // 取兩數、算術\n                            → ops pop\n                        EndWhile\n                    No → // 找到左括號\n                No → Decision: c 是否為 '+','-','*','/'? // 處理算術符號\n                    Yes → Decision: ops 非空且 precedence(ops.top) >= precedence(c)? // 先計算高優先順序\n                        Yes → While ops 非空且 precedence(ops.top) >= precedence(c):\n                                → Call Compute\n                                → ops pop\n                            EndWhile\n                        No →\n                    → ops push c // 把新算子推入棧\n                    → num = 0 // 重置累積數字\n                No → // 其他字符忽略\n→ Decision: num != 0? // 末尾還有數字\n    Yes → values push num\n→ While ops 非空: // 計算剩餘算子\n    → Call Compute\n    → ops pop\n→ Result = values.top // 最終結果\n→ End\n\nDefine Compute subroutine:\nCall Compute // 子程序計算\n    → Operand2 = values pop // 第二個操作數\n    → Operand1 = values pop // 第一個操作數\n    → Operator = ops pop // 取出運算子\n    → Decision: Operator 為 '+'\n        Yes → values push Operand1 + Operand2\n        No → Decision: Operator 為 '-'\n            Yes → values push Operand1 - Operand2\n            No → Decision: Operator 為 '*'\n                Yes → values push Operand1 * Operand2\n                No → // 必須為 '/'\n                    → values push int(Operand1 / Operand2) // 整數除法\nEnd\n\nBut need to use virtual code lines with arrows and decisions. Format must have one line per step.\n\nWe'll produce multiple lines; each line: \"→ Step: ...\" with explanation. Use indentation for nested decisions.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize values stack // 建立儲存數值的棧\n→ Initialize ops stack // 建立儲存運算子/括號的棧\n→ Initialize num = 0 // 初始化目前累積的數字\n→ For each character c in string s: // 逐字元處理輸入字串\n    → Decision: 如果 c 是數字? // 檢查是否為數字字符\n        Yes → num = num * 10 + int(c) // 將數字累加進 num\n        No → Decision: c 是否為 '('? // 判斷是否為左括號\n            Yes → ops push '(' // 把左括號推入運算子棧\n            No → Decision: c 是否為 ')'? // 判斷是否為右括號\n                Yes → Decision: ops 非空且 ops.top != '('? // 先計算直至遇到左括號\n                    Yes → While ops.top != '(':\n                            → Call Compute // 執行一次計算\n                            → ops pop // 移除已處理的運算子\n                        EndWhile\n                    No → // 找到左括號，等待後續處理\n                No → Decision: c 是否為 '+', '-', '*', '/'? // 判斷是否為算術符號\n                    Yes → Decision: ops 非空且 precedence(ops.top) >= precedence(c)? // 高優先順序的運算子先計算\n                        Yes → While ops 非空且 precedence(ops.top) >= precedence(c):\n                                → Call Compute // 執行一次計算\n                                → ops pop // 移除已處理的運算子\n                            EndWhile\n                        No →\n                    → ops push c // 把新運算子推入棧\n                    → num = 0 // 重設 num 為 0，準備累積下一個數字\n                No → // 其他字符（如空格）忽略\n→ Decision: num != 0? // 若最後還有未推入的數字\n    Yes → values push num // 把剩餘的數字推入數值棧\n→ While ops 非空: // 處理剩餘的運算子\n    → Call Compute // 執行一次計算\n    → ops pop // 移除已處理的運算子\n→ Result = values.top // 取得最終結果\n→ End // 程式執行結束\n\n// 子程序：Compute（執行一次算術計算）\nCall Compute // 子程序開始\n    → Operand2 = values pop // 取出第二個操作數\n    → Operand1 = values pop // 取出第一個操作數\n    → Operator = ops pop // 取出運算子\n    → Decision: Operator 為 '+'? // 判斷運算符號\n        Yes → values push Operand1 + Operand2 // 推入加法結果\n        No → Decision: Operator 為 '-'? // 判斷減法\n            Yes → values push Operand1 - Operand2 // 推入減法結果\n            No → Decision: Operator 為 '*'? // 判斷乘法\n                Yes → values push Operand1 * Operand2 // 推入乘法結果\n                No → // 必須為除法\n                    → values push int(Operand1 / Operand2) // 推入整數除法結果（截斷）\nEnd // 子程序結束"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7tcda39g.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmp7tcda39g.py\", line 61, in main\n    candidates, target = parse_input(raw_data)\n                         ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7tcda39g.py\", line 36, in parse_input\n    candidates = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9qmdkyz6.py\", line 66, in <module>\n    main()\n  File \"/tmp/tmp9qmdkyz6.py\", line 61, in main\n    candidates, target = parse_input(raw_data)\n                         ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9qmdkyz6.py\", line 36, in parse_input\n    candidates = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\ndef combination_sum(candidates, target):\n    \"\"\"Return all unique combinations that sum to target using unlimited repeats.\"\"\"\n    res = []\n\n    def backtrack(start, path, total):\n        if total == target:\n            res.append(list(path))\n            return\n        if total > target:\n            return\n        for i in range(start, len(candidates)):\n            path.append(candidates[i])\n            backtrack(i, path, total + candidates[i])\n            path.pop()\n\n    backtrack(0, [], 0)\n    return res\n\ndef parse_input(data: str):\n    \"\"\"Parse input that may be like 'candidates = [2,3,6,7], target = 7'\n    or separate lines: first line list, second line integer.\"\"\"\n    candidates = None\n    target = None\n\n    # Try to parse key=value pairs\n    parts = [p.strip() for p in data.split(',')]\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            key, val = key.strip(), val.strip()\n            if key == 'candidates':\n                candidates = ast.literal_eval(val)\n            elif key == 'target':\n                target = int(val)\n\n    if candidates is not None and target is not None:\n        return candidates, target\n\n    # Fallback: assume first line is list, second line is target\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        candidates = ast.literal_eval(lines[0])\n        target = int(lines[1])\n        return candidates, target\n\n    raise ValueError(\"Input format not recognized\")\n\ndef format_output(combos):\n    \"\"\"Return a string representation without spaces, e.g. [[2,2,3],[7]].\"\"\"\n    inner = ','.join('[' + ','.join(map(str, comb)) + ']' for comb in combos)\n    return '[' + inner + ']'\n\ndef main():\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        return\n    candidates, target = parse_input(raw_data)\n    result = combination_sum(candidates, target)\n    print(format_output(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving combination sum problem. We need to output line by line with virtual code steps and explanation. Use Start, End, Decision, arrows. We need to illustrate algorithm: backtracking.\n\nWe'll produce steps: Start, read input array and target, sort candidates for optimization, define recursive function to backtrack. Then at each recursion, if remaining target==0, record combination. If remaining target<0, backtrack. For each candidate starting from index to avoid duplicates. Add candidate to combination, call backtrack with same index (allow unlimited). After recursion, remove candidate.\n\nWe'll produce virtual code lines accordingly.\n\nMake sure each line has virtual code step and comment.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 載入 candidates 陣列與 target // 取得輸入\n→ Step 2: Sort candidates // 方便後續剪枝\n→ Step 3: 初始化 result 為空 list // 存放所有組合\n→ Step 4: 初始化 temp 為空 list // 暫存目前組合\n\n→ Step 5: 定義遞迴函式 backtrack(startIndex, remaining) // 從 startIndex 開始選取\n\n    → Decision: 若 remaining == 0? // 檢查是否已達目標\n        Yes → Step 5.1: result 加上 temp 的拷貝 // 記錄組合\n        No → Step 5.2: Decision: 若 remaining < 0? // 檢查是否超過\n            Yes → Step 5.3: Return // 超過目標，返回\n            No → Step 5.4: 循環 i 從 startIndex 到 candidates.length-1\n                → Step 5.4.1: temp 加上 candidates[i] // 加入候選\n                → Step 5.4.2: backtrack(i, remaining - candidates[i]) // 允許重複\n                → Step 5.4.3: temp 從尾端移除 // 回溯\n\n→ Step 6: 呼叫 backtrack(0, target) // 從第一個候選開始\n→ Step 7: 回傳 result // 回傳所有組合\n\nEnd // 程式結束\n\nNeed to use arrow and indentation? Use indent by spaces? Format shows arrows. We'll match sample: \"→ Decision:\" etc. Use indent inside decisions. For loops we can show as \"→ Step 5.4: for i = startIndex to candidates.length-1\" then indent sub-steps.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 載入 candidates 陣列與 target // 取得輸入\n→ Step 2: Sort candidates // 方便後續剪枝\n→ Step 3: 初始化 result 為空 list // 存放所有組合\n→ Step 4: 初始化 temp 為空 list // 暫存目前組合\n\n→ Step 5: 定義遞迴函式 backtrack(startIndex, remaining) // 從 startIndex 開始選取\n    → Decision: 若 remaining == 0? // 檢查是否已達目標\n        Yes → Step 5.1: result 加上 temp 的拷貝 // 記錄組合\n        No  → Decision: 若 remaining < 0? // 檢查是否超過\n            Yes → Step 5.3: Return // 超過目標，返回\n            No  → Step 5.4: for i = startIndex to candidates.length - 1\n                → Step 5.4.1: temp 加上 candidates[i] // 加入候選\n                → Step 5.4.2: backtrack(i, remaining - candidates[i]) // 允許重複\n                → Step 5.4.3: temp 從尾端移除 // 回溯\n\n→ Step 6: 呼叫 backtrack(0, target) // 從第一個候選開始\n→ Step 7: 回傳 result // 回傳所有組合\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu_o713e_.py\", line 70, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu_o713e_.py\", line 43, in parse_input\n    prerequisites = ast.literal_eval(m.group(2))\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9jp49hdu.py\", line 70, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9jp49hdu.py\", line 43, in parse_input\n    prerequisites = ast.literal_eval(m.group(2))\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites) -> bool:\n        # 建立圖與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點進行 BFS（拓撲排序）\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析多種可能的輸入格式。\n    支援：\n    1. 'numCourses = 2, prerequisites = [[1,0]]'\n    2. 第一行是 numCourses，第二行是 prerequisites 列表\n    3. 直接兩個值分隔\n    \"\"\"\n    data = data.strip()\n    # 先嘗試匹配「numCourses = X, prerequisites = Y」形式\n    pattern = r'numCourses\\s*=\\s*(\\d+)\\s*,\\s*prerequisites\\s*=\\s*(\\[[^\\]]*\\])'\n    m = re.search(pattern, data)\n    if m:\n        numCourses = int(m.group(1))\n        prerequisites = ast.literal_eval(m.group(2))\n        return numCourses, prerequisites\n\n    # 逐行解析\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        try:\n            numCourses = int(lines[0].strip())\n            prerequisites = ast.literal_eval(lines[1].strip())\n            return numCourses, prerequisites\n        except Exception:\n            pass\n\n    # 直接以空白或逗號分隔\n    parts = re.split(r'[\\s,]+', data)\n    try:\n        numCourses = int(parts[0])\n        # 把剩餘部分重新拼成列表字串\n        list_str = ' '.join(parts[1:])\n        prerequisites = ast.literal_eval(list_str)\n        return numCourses, prerequisites\n    except Exception as e:\n        raise ValueError(\"無法解析輸入\") from e\n\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    numCourses, prerequisites = parse_input(raw_input)\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    print(\"true\" if result else \"false\")",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving course schedule feasibility. Use DFS cycle detection or Kahn's algorithm. We'll produce pseudocode lines with explanations. Provide each line with arrow and comment. Use \"Start\" \"End\" and \"Decision:\".\n\nLet's outline algorithm:\n\nStart\n→ Input numCourses, prerequisites\n→ Build adjacency list graph: For each pair [a,b], add edge b->a? Wait we need prerequisites. Usually edge b->a meaning b must be before a. But we can also store edges from a to b. For cycle detection, we need directed edges from a to b? Actually if we want to detect cycle, we can treat graph as directed from course to prerequisite. Usually for DFS cycle detection, we use edges from a to b (a depends on b). We'll choose that.\n\n→ Initialize visited array 0 unvisited, 1 visiting, 2 visited.\n→ For each course from 0 to numCourses-1:\n    → Decision: if visited[course]==0? // not visited\n        Yes → Step: DFS(course) // perform DFS\n        If DFS returns false → return false\n→ Return true\n\nDFS(course):\n    → Step: mark visited[course]=1\n    → For each neighbor in graph[course]: // prerequisites\n        → Decision: if visited[neighbor]==1? // cycle detected\n            Yes → Step: return false\n            No → Decision: if visited[neighbor]==0? // not visited\n                Yes → Step: if DFS(neighbor)==false → return false\n    → Step: mark visited[course]=2\n    → Step: return true\n\nEnd\n\nBut we need pseudocode step-by-step.\n\nWe can produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 接收 numCourses 與 prerequisites // 讀入課程數與先修關係\n→ Step 2: 初始化圖 adjacencyList // 建立鄰接表\n    → For each pair [a,b] in prerequisites:\n        → Step: adjacencyList[a].append(b) // a 需要先修 b\n→ Step 3: 建立 visited 陣列大小 numCourses, 全為 0 // 0=未訪問\n→ Step 4: 建立函式 DFS(course) // 定義深度優先搜尋\n    → Step 5: visited[course] = 1 // 標記為「正在訪問」\n    → Step 6: For each pre in adjacencyList[course]:\n        → Decision: visited[pre] == 1? // 是否已在路徑上\n            Yes → Step: return False // 找到循環\n            No → Decision: visited[pre] == 0? // 未訪問\n                Yes → Step: if DFS(pre) == False → return False\n    → Step 7: visited[course] = 2 // 標記為「已完成」\n    → Step 8: return True\n→ Step 9: For each course i from 0 to numCourses-1:\n    → Decision: visited[i] == 0? // 未訪問\n        Yes → Step: if DFS(i) == False → return False // 無法完成\n→ Step 10: return True // 所有課程可完成\nEnd // 程式結束\n\nBut we need to maintain arrow format: Use \"→\" preceding each step after Start? The sample had \"→ Step 1: ...\" etc. We also need \"Decision:\" lines with indentation and Yes/No arrow. Use indentation for decisions.\n\nWe should produce each line as a single line. We can nest decisions within lines? Example sample: \"Decision: 如果數字大於 0?\" then \"Yes → Step 2: ...\", \"No → Decision: ...\". So we must maintain indentation using spaces? Use four spaces indentation? They used two spaces? Example: In sample they had:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n        Yes → Step 3: 輸出 '零' // 數字是零，顯示該訊息\n        No  → Step 4: 輸出 '負數' // 否則數值是負數\n\nThus indentation of four spaces for nested decisions? They used 4 spaces for the lines after Decision. We can replicate.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 接收 numCourses 與 prerequisites // 讀入課程數與先修關係\n→ Step 2: 初始化 adjacencyList 為 list of lists // 建立鄰接表\n    → For each pair [a,b] in prerequisites:\n        → Step: adjacencyList[a].append(b) // a 需要先修 b\n→ Step 3: 初始化 visited 陣列長度 numCourses, 值皆 0 // 0=未訪問\n→ Step 4: 定義函式 DFS(course) // 進行深度優先搜尋\n    → Step 5: visited[course] = 1 // 標記為「正在訪問」\n    → Step 6: For each pre in adjacencyList[course]:\n        → Decision: visited[pre] == 1? // 在同一路徑上，形成循環？\n            Yes → Step: return False // 找到循環，無法完成\n            No  → Decision: visited[pre] == 0? // 未訪問\n                Yes → Step: if DFS(pre) == False → return False // 递归检查\n    → Step 7: visited[course] = 2 // 標記為「已完成」\n    → Step 8: return True // 目前節點無循環\n→ Step 9: For i from 0 to numCourses-1:\n    → Decision: visited[i] == 0? // 尚未探索\n        Yes → Step: if DFS(i) == False → return False // 任何節點無法完成\n→ Step 10: return True // 所有課程都能完成\nEnd // 程式執行結束\n\nBut we need to keep consistent arrow syntax. For \"For\" loops maybe use \"Step:\" as well. Provide \"Step 9:\" etc.\n\nWe must not output actual code. Just pseudocode with arrows. Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 numCourses 與 prerequisites // 讀入課程數與先修關係  \n→ Step 2: 初始化 adjacencyList 為 list of lists // 建立鄰接表  \n    → For each pair [a,b] in prerequisites:  \n        → Step: adjacencyList[a].append(b) // a 需要先修 b  \n→ Step 3: 初始化 visited 陣列長度 numCourses，初值皆 0 // 0=未訪問  \n→ Step 4: 定義函式 DFS(course) // 進行深度優先搜尋  \n    → Step 5: visited[course] = 1 // 標記為「正在訪問」  \n    → Step 6: For each pre in adjacencyList[course]:  \n        → Decision: visited[pre] == 1? // 在同一路徑上，形成循環？  \n            Yes → Step: return False // 找到循環，無法完成  \n            No  → Decision: visited[pre] == 0? // 未訪問  \n                Yes → Step: if DFS(pre) == False → return False // 递归检查  \n    → Step 7: visited[course] = 2 // 標記為「已完成」  \n    → Step 8: return True // 目前節點無循環  \n→ Step 9: For i from 0 to numCourses-1:  \n    → Decision: visited[i] == 0? // 尚未探索  \n        Yes → Step: if DFS(i) == False → return False // 任何節點無法完成  \n→ Step 10: return True // 所有課程都能完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和陣列與總重量\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機產生 1~total 的整數\n        target = random.randint(1, self.total)\n        # 用 bisect 找出第一個 prefix_sum >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 轉換成合法的 JSON 兩層陣列格式\n    json_input = f'[{raw_input}]'\n    ops, args = json.loads(json_input)\n\n    outputs = []\n    # 先處理建構子\n    # args[0] 會是 [[w1, w2, ...]]\n    solution = Solution(args[0][0])\n    outputs.append(None)\n\n    # 後續呼叫方法\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == \"pickIndex\":\n            result = solution.pickIndex()\n            outputs.append(result)\n        else:\n            # 若有其他方法可在此處加入\n            outputs.append(None)\n\n    # 輸出結果，null 對應 Python 的 None\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm to pick index weighted by weights array. We should describe steps: preprocess prefix sums, total sum, random number generation, binary search, return index. Also explain each line. Use Start, End, Decision etc. Provide each line with \"虛擬碼步驟\" and comment. Use arrow notation. Should produce structured pseudocode. Provide steps: Initialize prefix sum array; compute total weight; pick random number in [1, total]; binary search to find first prefix >= rand; return index.\n\nWe should keep each line as a single instruction, with explanation.\n\nLet's produce.\n\nMake sure to use arrow \"→\" before each step.\n\nUse \"Decision:\" for conditions. Use \"Yes →\" \"No →\" appropriately.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的前綴和陣列 prefix // 用來儲存累積重量  \n→ Step 2: 初始化變數 totalWeight ← 0 // 代表所有重量的總和  \n→ Step 3: 針對每個重量 w[i] 做迴圈  \n  → 內部步驟: totalWeight ← totalWeight + w[i] // 累加重量  \n  → 內部步驟: prefix[i] ← totalWeight // 記錄到目前為止的累積值  \n→ Step 4: 將 randomNumber ← 1 + RandomInteger(0, totalWeight - 1) // 產生 1~totalWeight 的隨機數  \n→ Decision: 是否需要使用二分搜尋找到第一個 prefix ≥ randomNumber? // 確定使用更快的方法  \n  Yes → Step 5: 初始化 left ← 0, right ← w.length - 1  \n  → 內部循環:  \n    → Decision: left ≤ right?  \n     Yes → Step 6: mid ← left + (right - left) / 2  \n      → Decision: prefix[mid] < randomNumber?  \n       Yes → left ← mid + 1 // 仍在右半區  \n       No  → right ← mid - 1 // 可能是答案，往左搜尋"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdwy_9r_7.py\", line 30, in main\n    obj = eval(data, {})\n          ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"mat\": [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], \"k\": 3\n         ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpdwy_9r_7.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpdwy_9r_7.py\", line 34, in main\n    mat = eval(parts[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"mat\": [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], \"k\": 3\n         ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmeeeumlz.py\", line 30, in main\n    obj = eval(data, {})\n          ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"mat\": [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], \"k\": 2\n         ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpmeeeumlz.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpmeeeumlz.py\", line 34, in main\n    mat = eval(parts[0].strip())\n          ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    \"mat\": [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], \"k\": 2\n         ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        soldiers.sort()\n        return [i for _, i in soldiers[:k]]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入字串中的「mat =」與「k =」替換成 JSON 風格的 key，方便 eval\n    data = re.sub(r'\\bmat\\s*=\\s*', '\"mat\": ', data)\n    data = re.sub(r'\\bk\\s*=\\s*', '\"k\": ', data)\n\n    try:\n        obj = eval(data, {})\n    except Exception:\n        # 如果 eval 失敗，假設輸入為兩行：第一行為矩陣，第二行為 k\n        parts = data.splitlines()\n        mat = eval(parts[0].strip())\n        k = int(parts[1].strip())\n        obj = {\"mat\": mat, \"k\": k}\n\n    mat = obj[\"mat\"]\n    k = int(obj[\"k\"])\n\n    result = Solution().kWeakestRows(mat, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo-code with explanations, no actual code. The requirement: For user request: \"You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row. A row i is weaker than a row j if one of the following is true: The number of soldiers in row i is less than the number of soldiers in row j. Both rows have the same number of soldiers and i < j. Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.\"\n\nWe need to produce pseudo-code line by line, each with explanation. Use Start, End, Decision. Use arrows. Provide explanation after a space. Each line: \"虛擬碼步驟 // 解釋\" The example uses \"→\" arrow. They used \"Step 1: ...\". For decision: \"Decision:\" and then \"Yes →\" \"No →\". Also can use \"Start\", \"End\".\n\nWe should cover entire algorithm: count soldiers per row (since binary matrix with soldiers left). Use binary search to find first 0. Count. Store pair (count, index). Then sort pairs by count ascending, index ascending. Then take first k indices. Output array.\n\nPseudo-code steps: 1. Start. 2. Initialize list pairs. 3. For each row i: compute soldiers using binary search. 4. Add pair. 5. Sort list by count then index. 6. Select first k indices into result. 7. Return result. 8. End.\n\nNeed to ensure decision for binary search: if mid value is 1, move left? Actually we find last 1. Use binary search: low=0, high=n-1, while low <= high: mid=(low+high)//2. If mat[i][mid]==1: low=mid+1 else: high=mid-1. At end, number of soldiers = high+1. That's typical. Provide step-by-step.\n\nLet's craft pseudo-code lines:\n\nStart // 程式開始執行\n→ Step 1: Input mat, k // 取得矩陣與欲取出的弱行數量\n→ Step 2: m ← number of rows in mat // 取得行數\n→ Step 3: n ← number of columns in mat // 取得列數\n→ Step 4: pairs ← empty list // 用於儲存 (soldiers, rowIndex) 的對\n→ Step 5: For i from 0 to m-1 // 逐行處理\n    → Decision: 是否已處理完所有行? // 檢查迴圈結束條件\n        No → Step 6: low ← 0, high ← n-1 // 初始化二分搜尋範圍\n        → Step 7: While low ≤ high // 找到最後一個 1 的位置\n            → Decision: low ≤ high? // 判斷是否還有搜尋範圍\n                Yes → Step 8: mid ← (low + high) // 2 // 計算中點\n                → Decision: mat[i][mid] == 1? // 中點為 1 還是 0\n                    Yes → Step 9: low ← mid + 1 // 繼續搜尋右半區\n                    No  → Step 10: high ← mid - 1 // 繼續搜尋左半區\n                No → Step 11: soldiers ← high + 1 // 高指向最後一個 1\n                → Step 12: Append (soldiers, i) to pairs // 儲存結果\n                → Step 13: Increment i // 前往下一行\n→ Step 14: Sort pairs by (soldiers ascending, rowIndex ascending) // 排序\n→ Step 15: result ← empty list // 儲存最弱行索引\n→ Step 16: For j from 0 to k-1 // 取前 k 個\n    → Step 17: Append pairs[j].rowIndex to result // 取得行索引\n→ Step 18: Return result // 回傳結果\nEnd // 程式執行結束\n\nBut must maintain the arrow formatting exactly: \"→\" arrow before each step. For decisions: \"Decision: ...\". And \"Yes →\", \"No →\". For the outer loop, we might not need Decision for for loop. But we can express loop like \"→ Step 5: For i = 0 to m-1:\". Then inside the loop we have binary search. That's fine.\n\nNeed to keep consistent indentation or not? Example shows indentation for nested decisions. We can indent with spaces. Provide line by line.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Input mat, k // 取得矩陣與欲取出的弱行數量\n→ Step 2: m ← number of rows in mat // 取得行數\n→ Step 3: n ← number of columns in mat // 取得列數\n→ Step 4: pairs ← empty list // 用於儲存 (soldiers, rowIndex) 的對\n→ Step 5: For i = 0 to m-1 // 逐行處理\n    → Step 6: low ← 0, high ← n-1 // 初始化二分搜尋範圍\n    → Step 7: While low ≤ high // 找到最後一個 1 的位置\n        → Decision: low ≤ high? // 判斷是否還有搜尋範圍\n            Yes → Step 8: mid ← (low + high) // 2 // 計算中點\n            → Decision: mat[i][mid] == 1? // 中點為 1 還是 0\n                Yes → Step 9: low ← mid + 1 // 繼續搜尋右半區\n                No  → Step 10: high ← mid - 1 // 繼續搜尋左半區\n        No  → Step 11: soldiers ← high + 1 // 高指向最後一個 1\n            → Step 12: Append (soldiers, i) to pairs // 儲存結果\n→ Step 13: Sort pairs by (soldiers ascending, rowIndex ascending) // 排序\n→ Step 14: result ← empty list // 儲存最弱行索引\n→ Step 15: For j = 0 to k-1 // 取前 k 個\n    → Step 16: Append pairs[j].rowIndex to result // 取得行索引\n→ Step 17: Return result // 回傳結果\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # If any number is zero, the product is zero\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # Result can be at most m + n digits long\n        pos = [0] * (m + n)\n\n        # Multiply each digit of num1 by each digit of num2\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                sum_ = mul + pos[p2]\n\n                pos[p1] += sum_ // 10      # carry to the left\n                pos[p2] = sum_ % 10        # remainder stays at current position\n\n        # Convert digit list to string, removing any leading zeros\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result if result else \"0\"\n\n\ndef main():\n    # Read all input from stdin\n    data = sys.stdin.read()\n\n    # Extract all sequences of digits (handles formats like \"num1 = '123', num2 = '456'\")\n    nums = re.findall(r'\\d+', data)\n\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # Fallback: split by whitespace\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            # Not enough data provided\n            return\n\n    solution = Solution()\n    product = solution.multiply(num1, num2)\n    print(product)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Task: multiply two big numbers represented as strings, output product string. No built-in BigInteger, no convert to integer directly. Use manual multiplication algorithm: like long multiplication or digit arrays.\n\nWe'll produce steps:\n\nStart\n→ Step: Determine lengths of strings\n→ Step: Initialize result array of size len1+len2 with zeros\n→ Step: Loop over num1 from end to start (i)\n    → Loop over num2 from end to start (j)\n        → Multiply digit1 * digit2\n        → Add to result[i+j+1] current\n        → Carry = result[i+j+1] // 10\n        → result[i+j+1] = result[i+j+1] % 10\n        → result[i+j] += carry\n→ Step: Convert result array to string, skipping leading zeros\n→ End\n\nAlso handle empty string etc.\n\nWe need to produce virtual code lines with explanations. Use arrows. Format: each line \"Step X: ... // explanation\". Use Decision if needed? There's no condition except skipping leading zeros. We can use Decision to skip leading zeros.\n\nLet's produce lines. Use Start, End.\n\nWe'll include Decision: skip leading zeros.\n\nWe need to adhere to format. Let's produce.\n\nAlso use Yes/No arrow maybe for the loop? Not necessary but we can use Decision. We might use Decision for skipping leading zeros: if result[i]==0 and not first non-zero? But we can just build string and then trim. Use Decision.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: len1 ← length of num1 // 取得第一個數字長度\n→ Step 2: len2 ← length of num2 // 取得第二個數字長度\n→ Step 3: result ← array of zeros with size len1+len2 // 用來存放各位相乘後的中間結果\n→ Step 4: for i from len1-1 down to 0 // 逐位處理 num1 的每個數字\n    → Step 5: digit1 ← integer value of num1[i] // 把字元轉成數字\n    → Step 6: for j from len2-1 down to 0 // 逐位處理 num2 的每個數字\n        → Step 7: digit2 ← integer value of num2[j] // 把字元轉成數字\n        → Step 8: product ← digit1 * digit2 // 計算兩位相乘的結果\n        → Step 9: temp ← result[i+j+1] + product // 加上前面累積的值\n        → Step 10: result[i+j+1] ← temp % 10 // 取餘數放回相位\n        → Step 11: result[i+j] ← result[i+j] + temp // 取整數部分作為進位累加到前一位\n→ Step 12: idx ← 0 // 用來尋找第一個非零位\n→ Decision: result[idx] == 0? // 是否還是 0，需要跳過？\n    Yes → Step 13: idx ← idx + 1 // 跳過前導 0\n    No  → Step 14: // 進入下一步\n→ Step 15: if idx == len(result) then // 全部為 0 的情況\n    → Step 16: return \"0\" // 乘積為 0\n→ Step 17: productStr ← \"\" // 初始化結果字串\n→ Step 18: for k from idx to len(result)-1\n    → Step 19: productStr ← productStr + string(result[k]) // 逐位拼接為字串\n→ End // 程式執行結束\n\nNeed to keep format: \"Step X: ... // explanation\". We used Step 4 etc. But the Decision block: \"Decision: result[idx] == 0?\" with Yes→ etc. That's okay. However after the Decision block we have Step 15 etc. We need to ensure proper indentation maybe but not necessary.\n\nMake sure we include arrow in each line: \"→ Step X:\" etc. For Decision we use \"Decision: ...\" with Yes→ and No→.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: len1 ← length of num1 // 取得第一個數字長度\n→ Step 2: len2 ← length of num2 // 取得第二個數字長度\n→ Step 3: result ← array of zeros with size len1+len2 // 用來存放各位相乘後的中間結果\n→ Step 4: for i from len1-1 down to 0 // 逐位處理 num1 的每個數字\n    → Step 5: digit1 ← integer value of num1[i] // 把字元轉成數字\n    → Step 6: for j from len2-1 down to 0 // 逐位處理 num2 的每個數字\n        → Step 7: digit2 ← integer value of num2[j] // 把字元轉成數字\n        → Step 8: product ← digit1 * digit2 // 計算兩位相乘的結果\n        → Step 9: temp ← result[i+j+1] + product // 加上前面累積的值\n        → Step 10: result[i+j+1] ← temp % 10 // 取餘數放回相位\n        → Step 11: result[i+j] ← result[i+j] + temp // 取整數部分作為進位累加到前一位\n→ Step 12: idx ← 0 // 用來尋找第一個非零位\n→ Decision: result[idx] == 0? // 是否還是 0，需要跳過？\n    Yes → Step 13: idx ← idx + 1 // 跳過前導 0\n    No  → // 進入下一步\n→ Step 15: if idx == len(result) then // 全部為 0 的情況\n    → Step 16: return \"0\" // 乘積為 0\n→ Step 17: productStr ← \"\" // 初始化結果字串\n→ Step 18: for k from idx to len(result)-1\n    → Step 19: productStr ← productStr + string(result[k]) // 逐位拼接為字串\n→ End // 程式執行結束"
    }
  ]
}