{
  "run_index": 14,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 293,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef count_lines_in_file() -> None:\n    \"\"\"\n    讀取名為 data.txt 的檔案並輸出行數。\n    若檔案不存在，輸出錯誤訊息。\n    \"\"\"\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的資料（此題目不需要實際輸入，僅符合需求說明）\n    sys.stdin.read()\n    # 執行主功能\n    count_lines_in_file()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with arrow or decision etc. Provide explanations. Should follow example format. Must start with Start, End. Use with, try/except. Steps: Start, try block, open file with with open('data.txt') as f:, read lines, count, print count, except FileNotFoundError: print '找不到檔案！', End. Use decision? Maybe Decision: If file opened? But try/except covers. We can use Decision to indicate error handling. Let's produce. Each line: \"Start // 程式開始執行\". Then \"→ Step 1: 執行 try 區塊 // 嘗試執行以下程式碼\" etc. Then inside try: \"→ Step 2: with open('data.txt', 'r') as f: // 開啟檔案\" Then reading lines: \"→ Step 3: lines = f.readlines() // 讀取所有行\" Then count: \"→ Step 4: line_count = len(lines) // 計算行數\" Then print: \"→ Step 5: print('總共有', line_count, '行文字') // 輸出行數\". Then except: \"→ Decision: 如果發生 FileNotFoundError? // 檢查是否檔案不存在\". Then Yes branch: \"    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\". End. Need to indent decisions. Provide the explanation.\n\nLet's write. Ensure each line uses the format: \"虛擬碼步驟 [space] // 解釋\". Use arrow → for steps. For Decision: \"Decision:\" then indent Yes→ etc. Provide indentation with 4 spaces? Example shows 4 spaces before Yes →. Let's mimic.\n\nAlso include End. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 執行 try 區塊 // 嘗試執行以下程式碼  \n    → Step 2: with open('data.txt', 'r') as f: // 使用 with 語法開啟檔案  \n        → Step 3: lines = f.readlines() // 讀取檔案中的所有行  \n        → Step 4: line_count = len(lines) // 計算行數  \n        → Step 5: print('總共有', line_count, '行文字') // 輸出行數資訊  \n→ Decision: 如果發生 FileNotFoundError? // 檢查是否檔案不存在  \n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,6,2,6,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 6, 2, 6, 6]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"\n    模擬擲 n 次六面骰，返回所有結果的串列。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        # 產生 1~6 的隨機整數\n        results.append(random.randint(1, 6))\n    return results\n\ndef main():\n    # 讀取整個標準輸入，預期是可執行的程式碼\n    code = sys.stdin.read()\n    # 在本模組的全域命名空間中執行輸入的程式碼\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation, following format: start, steps, decisions if any, end. The requirement: use random module, function roll_dice(n) that simulates rolling n times a six-sided die and returns a list of results. So steps: Start, define function roll_dice(n), initialize empty list results, loop i from 1 to n, generate random int 1-6, append to list, after loop return list, End. No decisions. Should include \"→\" arrow.\n\nUse virtual code lines with explanation after \"//\". Ensure each line is a separate line. Format: \"Start // 程式開始執行\" etc.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Function: roll_dice(n) // 定義函式 roll_dice，接受參數 n  \n→ Step 1: results ← [] // 初始化空串列來存放擲骰結果  \n→ Step 2: for i in range(1, n+1): // 循環擲 n 次  \n  → Step 2.1: outcome ← random.randint(1, 6) // 產生 1 到 6 之間的隨機整數  \n  → Step 2.2: results.append(outcome) // 將擲到的數字加入結果串列  \n→ Step 3: return results // 回傳所有擲骰結果的串列  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需的秒數，並回傳四捨五入到小數點第三位的值。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整段程式碼並執行\n    code = sys.stdin.read()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with explanation after space. Format: \"虛擬碼步驟 // 解釋\". Use arrows. Include Start, End. Steps: import time, define function measure_time(func,*args), record start time, call func(*args) to get result, record end time, compute elapsed seconds, round to 3 decimals, return result and elapsed? The prompt says \"並回傳結果 (四捨五入到小數點 3 位)\". It might mean return elapsed time? Actually \"測量函數 func 執行所需的秒數，並回傳結果\" could mean return the elapsed time. But ambiguous: maybe return elapsed time only. We'll assume return elapsed seconds rounded to 3 decimals. Provide pseudo code accordingly. Provide each line. We'll use \"Start\" and \"End\". Use \"→\" arrow for flow. Use Decision? Not needed. We'll use Step numbering. Provide explanatory comments in Chinese. Ensure each line has \"虛擬碼步驟 // 解釋\". Use \"Start // 程式開始執行\". Provide arrow indentation. Use no actual code. Use pseudo.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 time 模組 // 需要用來取得時間戳  \n→ Step 2: 定義函式 measure_time(func, *args) // 接收要測量的函式及其參數  \n→     Step 2.1: 記錄 start_time ← time.time() // 函式呼叫前的時間  \n→     Step 2.2: 執行 result ← func(*args) // 執行傳入的函式並取得結果  \n→     Step 2.3: 記錄 end_time ← time.time() // 函式呼叫後的時間  \n→     Step 2.4: 計算 elapsed ← end_time - start_time // 取得執行秒數  \n→     Step 2.5: 四捨五入 elapsed 取 3 位小數 // 保留到小數點第三位  \n→     Step 2.6: 回傳 elapsed // 回傳測量到的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（即使此題不需要實際輸入，仍須遵循題目規範）\n    sys.stdin.read()\n\n    # 1. 建立集合 fruits = {'apple', 'banana'}\n    fruits = {'apple', 'banana'}\n\n    # 2. 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 3. 使用 update() 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 4. 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 5. 使用 discard() 嘗試移除 'pineapple'（此元素不存在）\n    fruits.discard('pineapple')\n\n    # 6. 輸出集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code with step lines. Start, End. Steps: create set, add, update, remove, discard, print. Use decision? Not needed. Provide each line with explanation comment. Use virtual arrows. Use \"→\". Each line like \"Start // 程式開始執行\". Next line \"→ Step 1: 建立集合 fruits = {'apple', 'banana'} // 初始化集合\" etc.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立集合 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不會拋錯  \n→ Step 6: 輸出 fruits // 顯示集合的最終內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate():\n    \"\"\"從 API 取得 USD 對 TWD 的匯率，失敗時回傳 None。\"\"\"\n    url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n    try:\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef update_label(label):\n    \"\"\"更新 tkinter 視窗中的 Label。\"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f\"目前美元匯率：約 {rate:.1f} TWD\")\n    else:\n        label.config(text=\"更新失敗，請檢查網路連線\")\n\nif __name__ == \"__main__\":\n    # 1. 從標準輸入讀取資料\n    input_data = sys.stdin.read().strip()\n\n    # 2. 處理輸入，若包含「更新」字樣則執行匯率查詢\n    if input_data and (\"更新\" in input_data or \"按下\" in input_data):\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.1f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n\n    # 3. 建立 tkinter 視窗\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    btn = tk.Button(win, text=\"更新匯率\", command=lambda: update_label(label))\n    btn.pack(pady=5)\n\n    win.mainloop()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each with \"虛擬碼步驟\" and comment after //, using arrows and decisions etc. No actual code, just pseudo. They want steps for using requests to fetch from API, then show result in tkinter window with button to update.\n\nWe should outline: import modules, define function fetch_rate, build tkinter window, label to show rate, button to call update, mainloop. Provide arrow for decision maybe: check if request success. Provide logic.\n\nLet's craft.\n\nWe need to use Start, End, Decision.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 載入 requests 及 tkinter 模組 // 導入所需模組\n\n→ Step 2: 設定 API 端點 URL 為 https://api.exchangerate-api.com/v4/latest/USD // 定義 API URL\n\n→ Step 3: 定義函式 fetch_rate() // 建立獲取匯率的函式\n\n   → Step 4: 使用 requests.get(URL) 並解析 JSON // 發送 GET 請求並轉成字典\n\n   → Decision: 如果回傳狀態碼 200? // 檢查是否成功\n\n        Yes → Step 5: 從 JSON 取出 rates.TWD 并返回 // 取得 TWD 匯率\n\n        No  → Step 6: 回傳 None // 失敗時回傳空\n\n→ Step 7: 建立 tkinter 視窗 root = tkinter.Tk() // 初始化 GUI\n\n→ Step 8: 創建 Label 以顯示匯率結果 // 用於展示\n\n→ Step 9: 創建 Button 觸發更新匯率 // 更新按鈕\n\n   → Step 10: 按鈕點擊事件 on_update() // 定義按鈕回調\n\n       → Step 11: rate = fetch_rate() // 取得最新匯率\n\n       → Decision: 如果 rate 存在? // 判斷是否成功\n\n            Yes → Step 12: label.config(text=f\"USD/TWD: {rate}\") // 更新顯示\n\n            No  → Step 13: label.config(text=\"取得匯率失敗\") // 顯示錯誤\n\n→ Step 14: 在窗口中放置 Label 與 Button // 布局\n\n→ Step 15: 調用 on_update() 初始化顯示 // 初始載入\n\n→ Step 16: root.mainloop() // 開始事件循環\n\nEnd // 程式執行結束\n\nNeed to use arrow formatting exactly. Let's follow format: \"虛擬碼步驟\" + space + \"// 解釋\".\n\nMake sure each line has only one step? For nested steps we can indent or maybe use sub steps. The example shows indentation with spaces: \"→ Decision:\" etc. So we should follow similar style.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 載入 requests 及 tkinter 模組 // 導入所需模組\n→ Step 2: 設定 API 端點 URL 為 https://api.exchangerate-api.com/v4/latest/USD // 定義 API URL\n→ Step 3: 定義函式 fetch_rate() // 建立獲取匯率的函式\n    → Step 4: 使用 requests.get(URL) 並解析 JSON // 發送 GET 請求並轉成字典\n    → Decision: 如果回傳狀態碼 200? // 檢查是否成功\n        Yes → Step 5: 從 JSON 取出 rates.TWD 并返回 // 取得 TWD 匯率\n        No  → Step 6: 回傳 None // 失敗時回傳空\n→ Step 7: 建立 tkinter 視窗 root = tkinter.Tk() // 初始化 GUI\n→ Step 8: 創建 Label 以顯示匯率結果 // 用於展示\n→ Step 9: 創建 Button 觸發更新匯率 // 更新按鈕\n    → Step 10: 按鈕點擊事件 on_update() // 定義按鈕回調\n        → Step 11: rate = fetch_rate() // 取得最新匯率\n        → Decision: 如果 rate 存在? // 判斷是否成功\n            Yes → Step 12: label.config(text=f\"USD/TWD: {rate}\") // 更新顯示\n            No  → Step 13: label.config(text=\"取得匯率失敗\") // 顯示錯誤\n→ Step 14: 在窗口中放置 Label 與 Button // 布局\n→ Step 15: 調用 on_update() 初始化顯示 // 初始載入\n→ Step 16: root.mainloop() // 開始事件循環\nEnd // 程式執行結束\n\nYes. Ensure each line has \"虛擬碼步驟\" text. Use the arrow symbol.\n\nMake sure indentation consistent: use two spaces before inner steps maybe.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 載入 requests 及 tkinter 模組 // 導入所需模組\n→ Step 2: 設定 API 端點 URL 為 https://api.exchangerate-api.com/v4/latest/USD // 定義 API URL\n→ Step 3: 定義函式 fetch_rate() // 建立獲取匯率的函式\n    → Step 4: 使用 requests.get(URL) 並解析 JSON // 發送 GET 請求並轉成字典\n    → Decision: 如果回傳狀態碼 200? // 檢查是否成功\n        Yes → Step 5: 從 JSON 取出 rates.TWD 并返回 // 取得 TWD 匯率\n        No  → Step 6: 回傳 None // 失敗時回傳空\n→ Step 7: 建立 tkinter 視窗 root = tkinter.Tk() // 初始化 GUI\n→ Step 8: 創建 Label 以顯示匯率結果 // 用於展示\n→ Step 9: 創建 Button 觸發更新匯率 // 更新按鈕\n    → Step 10: 按鈕點擊事件 on_update() // 定義按鈕回調\n        → Step 11: rate = fetch_rate() // 取得最新匯率\n        → Decision: 如果 rate 存在? // 判斷是否成功\n            Yes → Step 12: label.config(text=f\"USD/TWD: {rate}\") // 更新顯示\n            No  → Step 13: label.config(text=\"取得匯率失敗\") // 顯示錯誤\n→ Step 14: 在窗口中放置 Label 與 Button // 布局\n→ Step 15: 調用 on_update() 初始化顯示 // 初始載入\n→ Step 16: root.mainloop() // 開始事件循環\nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Elements",
      "source_file": "Leetcode/leetcode347.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpahsvmjul.py\", line 41, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpahsvmjul.py\", line 32, in parse_input\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpu_thkkvz.py\", line 41, in <module>\n    nums, k = parse_input(raw_input)\n              ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpu_thkkvz.py\", line 32, in parse_input\n    nums = ast.literal_eval(nums_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\nfrom collections import Counter\nimport ast\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        # 計算每個元素的頻率\n        freq = Counter(nums)\n        # 取出頻率最高的 k 個元素\n        # heapq.nlargest 會依照給定 key 取得最大的項目\n        topk = heapq.nlargest(k, freq.items(), key=lambda x: x[1])\n        # 只取元素值而非頻率\n        return [item for item, _ in topk]\n\ndef parse_input(input_str):\n    \"\"\"\n    解析輸入字串，格式類似：\n    'nums = [1,1,1,2,2,3], k = 2'\n    會回傳 (nums, k)\n    \"\"\"\n    # 移除所有空白及換行\n    cleaned = input_str.replace(\"\\n\", \"\").replace(\"\\r\", \"\").strip()\n    # 分割成兩段\n    try:\n        nums_part, k_part = cleaned.split(\",\", 1)\n    except ValueError:\n        # 如果沒有逗號，直接返回空列表或錯誤\n        return [], 0\n    # 取得 nums 列表\n    nums_str = nums_part.split(\"=\", 1)[1].strip()\n    nums = ast.literal_eval(nums_str)\n    # 取得 k 整數\n    k_str = k_part.split(\"=\", 1)[1].strip()\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取全部輸入\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    solution = Solution()\n    result = solution.topKFrequent(nums, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line. So algorithm: frequency map, heap of size k, etc. Provide each step. Use arrow. We must not output actual code. Just steps. Let's craft.\n\nWe need to include Start, End, Decision. For each step, explanation.\n\nLet's produce steps:\n\nStart\n→ Step 1: 建立頻率字典 // 统计每个元素出现次数\n→ Step 2: 迭代 nums，更新字典 // 计数\n→ Decision: 字典为空? // 处理空数组\n    Yes → Step 3: 返回空数组 // 无元素\n    No → Continue\n→ Step 4: 建立最小堆 // 用于保存前k个高频元素\n→ Step 5: 遍历字典键值对\n    → Decision: 堆大小 < k? // 堆未满\n        Yes → Step 6: 将 (key, freq) 插入堆 // 直接加入\n        No → Step 7: 若 freq > 堆根频率? // 需要替换\n            Yes → Step 8: 移除堆根并插入 (key, freq) // 更新堆\n            No → Step 9: 跳过 // 当前元素频率不高\n→ Step 10: 提取堆中所有键 // 得到k个最频繁元素\n→ End // 返回结果\n\nWe need to include explanation comments in Chinese after space. Use correct arrow syntax. Indent decisions. Use arrow \"Yes →\" \"No →\".\n\nEnsure each line ends with // explanation. Provide steps. Ensure each step uses virtual code. The \"Start\" line must end with // 程式開始執行. And \"End\" line with // 程式執行結束.\n\nAlso need to reflect that steps may include comments inside. We must include line after arrow for each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空頻率字典 freqMap // 用於記錄每個數字的出現次數  \n→ Step 2: 逐一遍歷 nums，對每個 num 更新 freqMap[num]++ // 統計頻率  \n→ Decision: freqMap 為空? // 檢查是否有輸入元素  \n    Yes → Step 3: 返回空列表 // 沒有元素可處理  \n    No  → Continue // 進一步處理  \n→ Step 4: 建立一個最小堆 minHeap，元素為 (元素, 次數) // 用於保留前 k 個高頻元素  \n→ Step 5: 遍歷 freqMap 的每個 (key, value)  \n    → Decision: minHeap 大小 < k? // 堆還未滿 k 個  \n        Yes → Step 6: 插入 (key, value) 至 minHeap // 直接加入堆中  \n        No → Step 7: 若 value > minHeap 根的次數? // 是否需要替換堆頂  \n            Yes → Step 8: 移除 minHeap 根，再插入 (key, value) // 更新堆  \n            No  → Step 9: 跳過 // 目前元素頻率不高於堆頂  \n→ Step 10: 從 minHeap 提取所有元素的 key，存入 result 列表 // 得到 k 個最頻繁元素  \n→ End // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpntya2b4t.py\", line 77, in <module>\n    main()\n  File \"/tmp/tmpntya2b4t.py\", line 59, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [, [[], [1], [2], [2], [], [1], [2], []]\n     ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        # 映射值到其在 values 列表中的索引\n        self.val_to_index = {}\n        # 存放所有元素的列表\n        self.values = []\n\n    def insert(self, val):\n        \"\"\"若 val 不在集合中則插入，返回 True；否則返回 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        \"\"\"若 val 在集合中則刪除，返回 True；否則返回 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取出要刪除元素的位置\n        idx = self.val_to_index[val]\n        # 取最後一個元素\n        last_val = self.values[-1]\n        # 用最後一個元素覆蓋待刪除的位置\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素\n        self.values.pop()\n        # 移除映射\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        \"\"\"隨機返回集合中一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得兩個列表：操作序列和對應參數\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) < 2:\n        # 如果輸入在同一行，嘗試用分隔符拆開\n        parts = data.split(']', 1)\n        ops_str = parts[0] + ']'\n        args_str = parts[1].strip()\n        if not args_str.startswith('['):\n            args_str = '[' + args_str\n    else:\n        ops_str, args_str = lines[0], lines[1]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    output = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            output.append(None)          # 构造函数返回 null\n        elif op == \"insert\":\n            output.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            output.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            output.append(obj.getRandom())\n    # 使用 json.dumps 以得到符合要求的 null/true/false 表示\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for implementing RandomizedSet with O(1) operations. Use array (list) and hashmap. Outline steps. Provide step-by-step algorithm with decisions. Use Start, End, Decision, etc. Provide for each function.\n\nWe must provide sequential lines but maybe break into functions. Could do:\n\nStart\n→ Step: Define class RandomizedSet // declare structure\n→ Step: Initialize list data and dict indices // array and map\n\nThen Insert:\n→ Step: if val in indices: return False\n→ Step: append val to data\n→ Step: set indices[val] = len(data)-1\n→ Step: return True\n\nRemove:\n→ Decision: if val not in indices? No → return False\n→ Step: get index of val\n→ Step: get last element\n→ Step: replace data[index] = last\n→ Step: update indices[last] = index\n→ Step: pop last\n→ Step: delete indices[val]\n→ Step: return True\n\nGetRandom:\n→ Step: return random element from data // using random index\n\nMake each line with explanation. Should maintain arrow indentation? Use arrow \"→\" for steps, \"Decision:\" for decisions, \"Yes →\" \"No →\". Use Start End. Provide simple.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step: 定義 RandomizedSet 類別 // 建立類別結構\n→ Step: 建立空陣列 data 以及空字典 indices // 用於存放元素與索引對應\n\n// ---------- insert 方法 ----------\n→ Step: insert(val) // 呼叫 insert 方法\n→ Decision: 是否已存在 indices[val]? // 判斷 val 是否已在集合中\n    No → Step: data.append(val) // 把 val 加到陣列末尾\n    No → Step: indices[val] = len(data) - 1 // 記錄 val 在陣列中的索引\n    No → Step: return True // 插入成功\n    Yes → Step: return False // 插入失敗，val 已存在\n\n// ---------- remove 方法 ----------\n→ Step: remove(val) // 呼叫 remove 方法\n→ Decision: 是否存在 indices[val]? // 判斷 val 是否在集合中\n    Yes → Step: idx = indices[val] // 取得 val 的索引\n    Yes → Step: last = data[-1] // 取得陣列最後一個元素\n    Yes → Step: data[idx] = last // 用最後一個元素覆蓋要刪除的位置\n    Yes → Step: indices[last] = idx // 更新 last 的索引為 idx\n    Yes → Step: data.pop() // 刪除陣列最後一個元素\n    Yes → Step: del indices[val] // 移除 val 的索引記錄\n    Yes → Step: return True // 刪除成功\n    No  → Step: return False // 刪除失敗，val 不在集合\n\n// ---------- getRandom 方法 ----------\n→ Step: getRandom() // 呼叫 getRandom 方法\n→ Step: return 隨機選取 data 中的一個元素 // 每個元素機率相同\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, m, n):\n        # 初始化矩陣大小與剩餘可翻轉的 0 數量\n        self.rows = m\n        self.cols = n\n        self.total = m * n          # 剩餘可翻轉的 0\n        self.flipped = {}           # 映射表：已翻轉位置的映射\n\n    def flip(self):\n        # 隨機挑選一個仍為 0 的索引\n        r = random.randint(0, self.total - 1)\n        # 若 r 已被映射，取映射值；否則取自身\n        x = self.flipped.get(r, r)\n        # 把已使用的索引映射到最後一個剩餘位置\n        self.flipped[r] = self.flipped.get(self.total - 1, self.total - 1)\n        self.total -= 1\n        # 轉換為行列座標\n        return [x // self.cols, x % self.cols]\n\n    def reset(self):\n        # 重設為全 0\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整字串\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 分離命令列表與參數列表\n    close_bracket = data.find(']')\n    commands = ast.literal_eval(data[:close_bracket + 1])\n    args = ast.literal_eval(data[close_bracket + 2:])\n\n    result = []\n    sol = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            sol = Solution(*arg)\n            result.append(None)          # 建構器返回 null\n        elif cmd == \"flip\":\n            res = sol.flip()\n            result.append(res)\n        elif cmd == \"reset\":\n            sol.reset()\n            result.append(None)          # reset 返回 null\n\n    # 輸出結果，使用 json 以產生 null 的格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Need algorithm: use reservoir? Actually typical solution: treat matrix as flattened array size m*n, maintain mapping from available indices to used ones. Initially all indices available. Use random index among remaining; swap with last unused index. Keep count of remaining cells. On flip: pick random r in [0, remaining-1], get index at mapping[r] or r itself. Set mapping[r] = mapping[remaining-1] or remaining-1. Decrease remaining. Return row, col from chosen flat index. Reset: clear mapping and reset remaining. Complexity: O(1) per flip, O(m*n) space for mapping. Minimize random calls: one per flip. Provide virtual code accordingly. Provide steps.\n\nWe output lines with virtual code arrows etc. Each line: step description plus comment.\n\nLet's design:\n\nStart\n→ Init: Set m, n, total = m*n, remaining = total, map = empty hash map\n→ End Init // initialization\n\nflip() function:\nStart flip // start flip\n→ If remaining == 0 → throw error or return null // no zeros\n→ randIdx = RandomInt(0, remaining-1) // pick random\n→ actualIdx = map.get(randIdx, randIdx) // get mapped index\n→ mappedLast = map.get(remaining-1, remaining-1)\n→ map.put(randIdx, mappedLast) // replace used spot\n→ remaining-- // one less zero\n→ row = actualIdx / n\n→ col = actualIdx % n\n→ Return [row, col] // return flipped index\nEnd flip\n\nreset():\nStart reset\n→ remaining = total\n→ map.clear()\nEnd reset\n\nNeed to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrow →. Use Decision for condition. Use Start End.\n\nLet's produce.\n\nRemember to not output actual code. Use virtual pseudocode with arrow and comments.\n\nLet's produce lines.\n\nWe should include the constructor, flip, reset.\n\nLet's write.\n\nStart // Program start\n\n→ Constructor: Set m, n, total = m * n, remaining = total, map = {} // initialize variables\n\nEnd // Constructor done\n\nNow function flip:\n\nStart // flip function\n→ Decision: 如果 remaining == 0? // 檢查是否還有 0\n    Yes → Return null // 沒有可翻轉的 0，直接返回\n    No  → Continue\n→ randIdx = RandomInt(0, remaining-1) // 取得隨機索引\n→ actualIdx = map.get(randIdx, randIdx) // 若映射存在則取映射值，否則取自身\n→ mappedLast = map.get(remaining-1, remaining-1) // 取得最後一個可用索引的映射\n→ map.put(randIdx, mappedLast) // 把被使用的索引映射到最後一個可用索引\n→ remaining = remaining - 1 // 減少剩餘可用 0 的數量\n→ row = actualIdx / n // 轉換為行\n→ col = actualIdx % n // 轉換為列\n→ Return [row, col] // 返回被翻轉的座標\nEnd // flip function end\n\nNow reset:\n\nStart // reset function\n→ remaining = total // 將剩餘計數重置為全部\n→ map.clear() // 清空映射\nEnd // reset function end\n\nEnd // program\n\nMake sure each line ends with // explanation. Use Chinese.\n\nLet's format exactly as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Constructor: m, n, total = m * n, remaining = total, map = {} // 初始化矩陣大小、剩餘可翻轉數量與映射表  \nEnd // 建構完成  \n\nStart // flip 函式開始  \n→ Decision: 如果 remaining == 0? // 檢查是否還有 0 可翻  \n  Yes → Return null // 無可翻轉位置，直接回傳空值  \n  No  → Continue  \n→ randIdx = RandomInt(0, remaining-1) // 產生隨機索引，範圍在剩餘可用位置  \n→ actualIdx = map.get(randIdx, randIdx) // 若 randIdx 已映射，取得映射值；否則使用自身索引  \n→ mappedLast = map.get(remaining-1, remaining-1) // 取得最後一個剩餘位置的映射值  \n→ map.put(randIdx, mappedLast) // 將被使用的索引映射到最後一個剩餘位置，保持映射有效  \n→ remaining = remaining - 1 // 減少剩餘可翻轉的 0 的數量  \n→ row = actualIdx / n // 計算行號  \n→ col = actualIdx % n // 計算列號  \n→ Return [row, col] // 返回被翻轉的座標  \nEnd // flip 函式結束  \n\nStart // reset 函式開始  \n→ remaining = total // 將剩餘數量重設為全部  \n→ map.clear() // 清空映射表，恢復所有位置為 0  \nEnd // reset 函式結束  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      '[\"(a)()()\", \"(a())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\ndef is_valid(string: str) -> bool:\n    \"\"\"判斷字串括號是否平衡。\"\"\"\n    count = 0\n    for ch in string:\n        if ch == '(':\n            count += 1\n        elif ch == ')':\n            count -= 1\n            if count < 0:          # 右括號多於左括號\n                return False\n    return count == 0            # 左右括號數相等\n\ndef remove_invalid_parentheses(s: str):\n    \"\"\"回傳最少刪除後所有合法字串的列表。\"\"\"\n    level = {s}                 # 目前層級的所有字串\n    while level:\n        # 先過濾出合法字串\n        valid = [x for x in level if is_valid(x)]\n        if valid:\n            return valid\n        # 若沒有合法字串，產生下一層級\n        next_level = set()\n        for item in level:\n            for i, ch in enumerate(item):\n                if ch in ('(', ')'):           # 只移除括號\n                    next_item = item[:i] + item[i+1:]\n                    next_level.add(next_item)\n        level = next_level\n    return []\n\ndef main():\n    \"\"\"主程式，從 stdin 讀取輸入並輸出結果。\"\"\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # 解析字串，例如:  s = \"()())()\"\n    match = re.search(r'[\"\\'](.*?)[\"\\']', raw_input)\n    s = match.group(1) if match else raw_input\n    result = remove_invalid_parentheses(s)\n    # 輸出符合範例的 JSON 格式\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The problem: remove minimum parentheses to get all valid strings. Classic solution: BFS to find all minimal removals, or DFS with pruning. Since we need pseudocode, we can use BFS approach: starting string, if valid return list, else generate neighbors by removing one parenthesis at each position. Use set to avoid duplicates. Continue level by level until found. Return all valid strings at that level.\n\nWe need to produce step-by-step pseudocode with arrows and decision branches.\n\nLet's produce:\n\nStart\n\n→ Step 1: Define function isValid(str) -> bool // checks if parentheses balanced\n\n→ Step 2: Initialize queue with input string s // BFS queue\n\n→ Step 3: Initialize visited set with s // avoid repeats\n\n→ Step 4: Initialize result list = empty\n\n→ Step 5: Initialize found = False // flag for minimal level\n\n→ Step 6: While queue not empty\n\n   → Step 6.1: Pop current string cur\n\n   → Decision: If isValid(cur)? // check validity\n\n        Yes → Add cur to result; set found = True\n\n        No → If not found\n\n             → Decision: For each index i in cur\n\n                    If cur[i] is '(' or ')'\n\n                        → Generate next = cur with char i removed\n\n                        → Decision: If next not in visited?\n\n                              Yes → Add next to queue and visited\n\nAfter loop, return result.\n\nExplain each line.\n\nAlso note we should stop generating neighbors once found at first valid level, to ensure minimal removal.\n\nNeed to include End.\n\nAlso may include initial comment for overall algorithm.\n\nLet's output as per format: each line with \"虛擬碼步驟\" then // 解釋.\n\nWe need to use \"→\" and \"Decision:\" and \"Yes →\", \"No →\".\n\nWe need \"Start\" and \"End\".\n\nLet's produce.\n\nAlso incorporate BFS.\n\nPotential lines:\n\nStart\n\n→ Step 1: Define function isValid(str) -> bool // check balanced parentheses\n\n→ Step 2: Initialize queue with s // BFS start\n\n→ Step 3: Initialize visited set with s // avoid duplicates\n\n→ Step 4: Initialize result list = [] // store valid strings\n\n→ Step 5: Initialize found = False // flag to stop after minimal level\n\n→ Decision: While queue not empty? // BFS loop\n\n    Yes →\n\n        → Step 6: Dequeue current string cur // get next string\n\n        → Decision: isValid(cur)? // check if current string valid\n\n            Yes →\n\n                → Step 7: Append cur to result // record valid string\n\n                → Step 8: Set found = True // minimal level reached\n\n            No →\n\n                → Decision: If found is False? // only generate neighbors if not found\n\n                    Yes →\n\n                        → For i from 0 to length(cur)-1\n\n                            → Decision: If cur[i] is '(' or ')'? // only remove parentheses\n\n                                Yes →\n\n                                    → Step 9: next = cur with char i removed // generate neighbor\n\n                                    → Decision: If next not in visited? // avoid repeats\n\n                                        Yes →\n\n                                            → Step 10: Add next to queue // enqueue neighbor\n\n                                            → Step 11: Add next to visited // mark visited\n\nEnd\n\nAdd some explanation lines.\n\nEnsure each line includes arrow etc.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define function isValid(str) → bool // 檢查字串括號是否平衡  \n→ Step 2: Initialize queue ← [s] // BFS 從輸入字串開始  \n→ Step 3: Initialize visited ← {s} // 追蹤已處理的字串，避免重複  \n→ Step 4: Initialize result ← [] // 存放所有最少刪除後合法字串  \n→ Step 5: Initialize found ← False // 標記是否已找到合法字串，確保最少刪除  \nDecision: While queue not empty? // BFS 主迴圈  \n    Yes →  \n        → Step 6: cur ← queue.pop() // 取出下一個字串進行檢查  \n        → Decision: isValid(cur)? // 判斷當前字串是否已合法  \n            Yes →  \n                → Step 7: result.append(cur) // 收集合法字串  \n                → Step 8: found ← True // 之後不再產生子節點，保證最少刪除  \n            No →  \n                → Decision: found is False? // 只有在尚未找到合法字串時才繼續生成子節點  \n                    Yes →  \n                        → For i in 0 .. len(cur)-1  \n                            → Decision: cur[i] == '(' or cur[i] == ')' ? // 只移除括號  \n                                Yes →  \n                                    → Step 9: next ← cur with character i removed // 產生鄰居字串  \n                                    → Decision: next not in visited? // 避免重複處理  \n                                        Yes →  \n                                            → Step 10: queue.append(next) // 加入待處理隊列  \n                                            → Step 11: visited.add(next) // 標記已處理  \nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Word Ladder",
      "source_file": "Leetcode/leetcode127.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        \"\"\"返回最短變換序列長度，若無路徑則回傳 0。\"\"\"\n        wordSet = set(wordList)          # 轉成集合以 O(1) 檢查\n        if endWord not in wordSet:        # 目標字若不在字典中直接失敗\n            return 0\n\n        queue = deque([(beginWord, 1)])   # (目前單字, 路徑長度)\n\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:           # 找到目標\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:   # 只考慮字典中的合法字\n                        wordSet.remove(new_word)  # 避免重複\n                        queue.append((new_word, length + 1))\n        return 0  # 沒有任何有效路徑\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取資料並輸出結果。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 假設輸入形式為：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\", ...]\n    # 用 exec 解析成變數\n    local_vars = {}\n    try:\n        exec(data, {}, local_vars)\n    except Exception:\n        # 若輸入格式不符，直接終止\n        print(0)\n        return\n\n    beginWord = local_vars.get(\"beginWord\", \"\")\n    endWord = local_vars.get(\"endWord\", \"\")\n    wordList = local_vars.get(\"wordList\", [])\n\n    solution = Solution()\n    result = solution.ladderLength(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe task: produce virtual code steps with explanation, no real code, for the algorithm: shortest transformation sequence length (like Word Ladder). Should output step by step using arrows, decisions, etc. Must be in Traditional Chinese. Provide virtual code lines, each with explanation.\n\nWe should outline algorithm: BFS from beginWord, using queue, visited set, wordList set, etc. Steps: Start, Check endWord in list, build adjacency? BFS.\n\nLet's craft.\n\nWe need to include decisions: if endWord not in wordList → 0. BFS loop: while queue not empty: pop word, level; for each position generate all 26 possible words, if new word equals endWord → return level+1; if in wordList and not visited → add to queue, remove from wordList to avoid revisit.\n\nAlso, we might maintain distance count. Use level variable.\n\nUse pseudo steps.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 wordSet = set(wordList) // 將字典轉成集合方便 O(1) 檢查\n→ Decision: 如果 endWord 不在 wordSet? // 檢查目標字是否可達\n    Yes → Step 2: 回傳 0 // 無法完成轉換，直接結束\n    No  → Step 3: 建立 queue = [beginWord] // 初始化 BFS 隊列，先放入起始字\n        → Step 4: 建立 visited = {beginWord} // 記錄已訪問的字，避免重複\n        → Step 5: 建立 level = 1 // 初始距離為 1（含 beginWord）\n→ Decision: queue 是否為空? // 檢查是否還有字可處理\n    Yes → Step 6: 回傳 0 // queue 為空表示無路徑，結束\n    No  → Step 7: 取出 current = queue.pop(0) // 取得隊列首字\n        → Step 8: 對 current 的每個位置 i 從 0 到 len(current)-1\n            → Step 9: 對每個字母 c 從 'a' 到 'z'\n                → Step 10: 生成 nextWord = current 的第 i 位替換為 c // 嘗試所有單字母變化\n                → Decision: nextWord 是否等於 endWord? // 檢查是否達到目標\n                    Yes → Step 11: 回傳 level + 1 // 找到最短路徑，返回距離\n                    No  → Decision: nextWord 是否在 wordSet 且未被訪問? // 可用且未處理\n                        Yes → Step 12: queue.append(nextWord) // 加入隊列\n                            → Step 13: visited.add(nextWord) // 標記已訪問\n                            → Step 14: wordSet.remove(nextWord) // 從字典中移除，避免重複\n                        No  → // 跳過此變化\n        → Step 15: level += 1 // 進入下一層距離\n        → Decision: queue 是否為空? // 再次檢查隊列\n            Yes → Step 16: 回傳 0 // 所有可能已處理但未找到目標\n            No  → 回到 Step 7 // 繼續 BFS\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[None,4,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[None, 4, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立從數值到其所有索引的映射\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選擇 target 的任一索引\n        return random.choice(self.indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，使用 eval 解析成兩個列表\n    data = eval(sys.stdin.read())\n    ops, args = data\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            # arg 形如 [[1,2,3,3,3]]，取第一個元素作為 nums\n            obj = Solution(arg[0])\n            outputs.append(None)\n        else:\n            # 其餘方法均以 *arg 形式傳遞參數\n            result = getattr(obj, op)(*arg)\n            outputs.append(result)\n\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Must not output actual code, only steps with virtual arrows, start, end, decisions. We need to handle initialization and pick. Use reservoir sampling or map? Since target always exists. Use array indices mapping: store positions for each value. But we need virtual steps. Let's propose:\n\nStart\n→ Step: Initialize hash map positions: map from number to list of indices. // Build mapping\n→ End of init.\n\nFor pick:\n→ Step: Retrieve list of indices for target from map. // Get positions\n→ Decision: If list size == 1? // If only one occurrence\n    Yes → Return that index // deterministic\n    No → Step: Randomly select index from list using uniform selection. // Random choice\n→ End\n\nWe need to output in virtual code lines. Use arrows. Provide explanation after each.\n\nLet's write:\n\nStart\n→ Step 1: 建立字典 positions，key 為數值，value 為該數值在 nums 的所有索引列表 // 建構索引映射\n→ Decision: 檢查 nums 是否為空? // 若空則直接終止\n    No → Step 2: 迭代 nums，對於每個 index i, nums[i] → 將 i 加入 positions[nums[i]] 的列表 // 將索引存入對應列表\n    Yes → End // 空陣列直接結束\n→ End // 初始化完成\n\nNow pick:\nStart\n→ Step 3: 取得 target 對應的索引列表 idxList ← positions[target] // 從字典取列表\n→ Decision: idxList 长度是否為 1? // 判斷是否唯一\n    Yes → Step 4: 回傳 idxList[0] // 唯一索引\n    No → Step 5: 產生隨機整數 r ∈ [0, len(idxList)-1] // 隨機選擇\n    → Step 6: 回傳 idxList[r] // 回傳隨機索引\n→ End // pick 完成\n\nMake sure each line includes arrow. Use \"Decision:\" for condition. \"Yes →\" \"No →\" indent. Provide comments after //.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立字典 positions，key 為數值，value 為該數值在 nums 的所有索引列表 // 建構索引映射\n\n→ Decision: 檢查 nums 是否為空? // 判斷是否有資料\n    Yes → End // 空陣列直接結束\n    No  → Step 2: 迭代 nums，對於每個 index i, nums[i] → 將 i 加入 positions[nums[i]] 的列表 // 將索引存入對應列表\n\nEnd // 初始化完成\n\nStart // pick 函式開始\n\n→ Step 3: 取得 target 對應的索引列表 idxList ← positions[target] // 從字典取列表\n\n→ Decision: idxList 長度是否為 1? // 判斷是否唯一\n    Yes → Step 4: 回傳 idxList[0] // 唯一索引直接回傳\n    No  → Step 5: 產生隨機整數 r ∈ [0, len(idxList)-1] // 隨機選擇索引\n         → Step 6: 回傳 idxList[r] // 回傳隨機索引\n\nEnd // pick 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        # Count frequency of each character\n        freq = Counter(s)\n        # Build result string by sorting characters by decreasing frequency\n        sorted_chars = sorted(freq.items(), key=lambda x: -x[1])\n        return ''.join(char * count for char, count in sorted_chars)\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    # Extract the string value after 's = \"...\"'\n    match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: assume the whole input is the string\n        s = data\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: frequency sort string. So algorithm: count freq, sort characters by freq descending, build output string. Also we can skip duplicates.\n\nVirtual code steps line by line. Use Start, End, Decision, etc. Provide explanation after //.\n\nLet's produce steps:\n\nStart // start program\n→ Step 1: initialize frequency map // create dictionary\n→ Step 2: for each char in s, increment freq // count occurrences\n→ Step 3: convert map entries to list of (char, freq) // prepare sorting\n→ Decision: need sorting by freq descending? // always yes\n    Yes → Step 4: sort list by freq descending // order by freq\n→ Step 5: initialize result string // build result\n→ Step 6: for each (char, freq) in sorted list\n    → Step 6a: append char repeated freq times to result // build output\n→ Step 7: return result // output\nEnd // finish\n\nWe need arrow for each line. Provide each line with virtual code step and comment. Should show decision with Yes arrow.\n\nMake sure each line is separate.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率表 // 建立一個字典用於統計各字符出現次數  \n→ Step 2: 逐個字符遍歷 s，對每個字符在頻率表中累加計數 // 計算每個字符的出現頻率  \n→ Step 3: 將頻率表轉換為 (字符, 次數) 列表 // 準備進行排序  \n→ Decision: 是否需要按頻率降序排序? // 我們始終需要排序  \n  Yes → Step 4: 對列表按次數降序排序 // 將頻率高的字符排在前面  \n→ Step 5: 初始化結果字符串 result // 用於拼接最終輸出  \n→ Step 6: 遍歷排序後的列表  \n  → Step 6a: 將字符重複次數次後追加到 result // 根據頻率拼接字符  \n→ Step 7: 返回 result // 輸出排序後的字符串  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7aelmtb6.py\", line 46, in <module>\n    solve()\n  File \"/tmp/tmp7aelmtb6.py\", line 34, in solve\n    words = eval(data)\n            ^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptlossmdo.py\", line 46, in <module>\n    solve()\n  File \"/tmp/tmptlossmdo.py\", line 34, in solve\n    words = eval(data)\n            ^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"bat\",\"tab\",\"cat\"]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo750acr0.py\", line 46, in <module>\n    solve()\n  File \"/tmp/tmpo750acr0.py\", line 34, in solve\n    words = eval(data)\n            ^^^^^^^^^^\n  File \"<string>\", line 1\n    words = [\"a\",\"\"]\n          ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\n\ndef palindrome_pairs(words):\n    \"\"\"\n    Return all index pairs (i, j) with i != j such that\n    words[i] + words[j] is a palindrome.\n    \"\"\"\n    result = []\n    n = len(words)\n\n    for i in range(n):\n        wi = words[i]\n        for j in range(n):\n            if i == j:\n                continue\n            candidate = wi + words[j]\n            if candidate == candidate[::-1]:          # palindrome test\n                result.append([i, j])\n\n    return result\n\n\ndef solve() -> None:\n    \"\"\"\n    Reads a list of words from stdin and prints all palindrome pairs.\n    The input format is a single line containing a Python‑style list\n    of strings, e.g.  [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"].\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Safely evaluate the list literal\n    words = eval(data)\n\n    pairs = palindrome_pairs(words)\n\n    # Print as a list of lists, one pair per line (any order is accepted)\n    print(\"[\")\n    for k, pair in enumerate(pairs):\n        comma = \",\" if k + 1 < len(pairs) else \"\"\n        print(f\"  {pair}{comma}\")\n    print(\"]\")\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with arrow and explanation. The algorithm for palindrome pairs: use a hash map from reversed word to index, and check splits. Complexity O(total length). We need to produce step by step virtual code lines. Each line: \"虛擬碼步驟 // 解釋\". Use Start, Decision, Yes→, No→. Must be line by line. Provide algorithm in pseudo code but not actual code. We'll produce steps: Start, build map, iterate words, for each word iterate splits, check palindrome substring, etc.\n\nWe need to structure with arrow and decision nodes. Provide explanation after each. Let's craft. Use '→' arrow after each step. Provide indentation for decisions.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立哈希表 reverseMap，鍵為 words[i] 的反轉字串，值為 i // 方便快速查找反向匹配  \n→ Decision: 是否已完成哈希表建立?  \n    Yes → Step 2: 初始化空列表 result // 用來儲存所有 (i, j) 組合  \n→ Step 3: 逐一遍歷每個單詞 words[i] // i 為目前索引  \n  → Decision: 取出 words[i] 的長度 len // 為後續切割使用  \n   Yes → Step 4: 對每個切割點 k 從 0 到 len 進行迴圈 // 包含整個字串的情況  \n    → Decision: 將 words[i] 切成前後兩段 left = words[i][0:k], right = words[i][k:] 是否為回文?  \n     Yes → Step 5: 如果 left 為回文，查找 reverseMap[right]，若存在且索引不等於 i  \n      → Step 6: 把 (reverseMap[right], i) 加入 result // 反向字串 + 當前字串為回文  \n      No → Step 5b: 如果 right 為回文，查找 reverseMap[left]，若存在且索引不等於 i  \n       → Step 7: 把 (i, reverseMap[left]) 加入 result // 當前字串 + 反向字串為回文  \n      No → Step 5c: 不做任何事 // 切割點不產生合法回文組合  \n    No → Step 4b: 跳過此切割點 // 前後兩段都不是回文，無法形成對稱組合  \n→ Step 8: 完成所有單詞的遍歷  \n→ End // 程式執行結束，result 為所有回文對的列表"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\ndef find_repeated_dna_sequences(s: str):\n    \"\"\"找出所有重複出現的 10 字符 DNA 子序列。\"\"\"\n    seen = set()\n    repeated = set()\n    # 遍歷所有長度為 10 的子串\n    for i in range(len(s) - 9):\n        seq = s[i:i+10]\n        if seq in seen:\n            repeated.add(seq)   # 已經見過，加入結果\n        else:\n            seen.add(seq)       # 第一次見到，加入 seen\n    return list(repeated)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從標準輸入讀取的字串中提取 DNA 序列。\n    支援「s = '...'}」或僅為字串本身。\n    \"\"\"\n    raw = raw.strip()\n    # 先嘗試尋找單引號之間的內容\n    start = raw.find(\"'\")\n    end = raw.rfind(\"'\")\n    if start != -1 and end != -1 and end > start:\n        return raw[start+1:end]\n    # 如果找不到引號，去掉可能的變量名\n    if raw.startswith(\"s\"):\n        raw = raw.replace(\"s =\", \"\", 1).strip()\n    # 移除兩側的引號（如果存在）\n    return raw.strip(\"'\\\"\")\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read()\n    if not raw_input:\n        sys.exit()\n    dna_seq = parse_input(raw_input)\n    result = find_repeated_dna_sequences(dna_seq)\n    # 使用 JSON 形式輸出，符合範例中的雙引號風格\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find all 10-letter-long substrings that appear more than once in a given string s. It's a classic LeetCode problem. We need to output pseudocode, line by line, with explanation. Must use the format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow, Start, End, Decision. Should not output actual code. So we produce steps: start, input string, initialize set seen, set result, iterate i from 0 to len(s)-10, extract substring, if substring in seen -> add to result, else add to seen. After loop, return result. We also consider edge case: length < 10 return empty. Use decisions for that. We must include decisions.\n\nLet's craft lines:\n\nStart\n→ Step 1: 取得輸入字串 s // 獲取 DNA 序列\n→ Decision: s 長度 < 10? // 判斷是否足夠長\n    Yes → Step 2: 回傳空集合 // 若不足 10 個字元，無重複子序列\n    No  → \n→ Step 3: 初始化 seen 為空集合 // 用於記錄已見過的 10 字符子串\n→ Step 4: 初始化 result 為空集合 // 儲存重複出現的子串\n→ Step 5: for i 從 0 到 len(s)-10 進行迴圈 // 遍歷所有可能的 10 字符子串\n    → Step 5a: substring ← s[i:i+10] // 取出當前 10 字符子串\n    → Decision: substring 在 seen 中? // 判斷是否已見過\n        Yes → Step 5b: 加入 substring 至 result // 若已見過，加入結果\n        No  → Step 5c: 加入 substring 至 seen // 否則加入 seen\n→ End // 完成\n\nWe need each line to have the \"虛擬碼步驟\" plus \"// 解釋\". Each line maybe multiple levels; we need to indent maybe. Use arrow lines. Provide each line separately.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 獲取 DNA 序列  \n→ Decision: s 長度 < 10? // 判斷是否足夠長  \n  Yes → Step 2: 回傳空集合 // 若不足 10 個字元，無重複子序列  \n  No  →  \n→ Step 3: 初始化 seen 為空集合 // 用於記錄已見過的 10 字符子串  \n→ Step 4: 初始化 result 為空集合 // 儲存重複出現的子串  \n→ Step 5: for i 從 0 到 len(s)-10 進行迴圈 // 遍歷所有可能的 10 字符子串  \n  → Step 5a: substring ← s[i:i+10] // 取出當前 10 字符子串  \n  → Decision: substring 在 seen 中? // 判斷是否已見過  \n    Yes → Step 5b: 加入 substring 至 result // 若已見過，加入結果  \n    No  → Step 5c: 加入 substring 至 seen // 否則加入 seen  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of a list of distinct integers.\n        :param nums: List[int]\n        :return: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # If the current position reaches the end, record the permutation\n            if start == len(nums):\n                res.append(nums[:])  # make a copy\n                return\n            # Try swapping each element into the current position\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # swap\n                backtrack(start + 1)                          # recurse\n                nums[start], nums[i] = nums[i], nums[start]  # backtrack (swap back)\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Extract the list expression after 'nums ='\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # Safely evaluate the list expression\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = []\n\n    # Compute permutations and print the result\n    solution = Solution()\n    permutations = solution.permute(nums)\n    print(permutations)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for generating all permutations of distinct integers array. Each line with \"虛擬碼步驟 // 解釋\".\n\nUse virtual code style with Start, End, Decision, etc.\n\nLet's produce step-by-step algorithm: using backtracking.\n\nOutline:\n\nStart\n→ Step 1: Initialize result list\n→ Step 2: Define recursive function backtrack(current permutation, used set)\n   → Decision: If length of current == length of nums?\n       Yes → Step: Append copy of current to result\n       No → For each num in nums:\n             Decision: If num not in used?\n                Yes → Add num to current, mark used\n                → Recursively call backtrack\n                → After return: remove num from current, unmark used\n→ After recursion completes, return result\nEnd\n\nAdd explanatory comments.\n\nMake sure each line ends with // comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來存放所有排列  \n→ Step 2: 定義函式 backtrack(current, used) // current 是目前已經選取的數列，used 是已使用的數字集合  \n  Decision: 如果 current 的長度等於 nums 的長度? // 檢查是否已經選完所有數字  \n   Yes → Step 3: 把 current 的複本加入 result // 完整排列，加入結果列表  \n   No  → For each num in nums: // 嘗試將每個數字加入排列  \n     Decision: 如果 num 已在 used? // 判斷數字是否已被使用  \n      Yes → No operation // 已使用，跳過  \n      No  → Step 4: 將 num 加入 current 並標記為 used // 選擇此數字  \n       → 呼叫 backtrack(current, used) // 進一步深度遞迴  \n       → Step 5: 從 current 移除 num 並取消 used 標記 // 回溯，恢復狀態  \n→ Step 6: 呼叫 backtrack([], set()) // 從空排列開始遞迴  \n→ Step 7: 回傳 result // 返回所有排列結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        \n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        \n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        \n        return slow\n\ndef main():\n    # 從 stdin 讀取輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串，取得 nums 列表\n    l = data.find('[')\n    r = data.rfind(']')\n    if l != -1 and r != -1:\n        nums_str = data[l:r+1]\n    else:\n        nums_str = data\n    nums = ast.literal_eval(nums_str)\n\n    # 計算重複的數字\n    sol = Solution()\n    duplicate = sol.findDuplicate(nums)\n\n    # 將結果輸出到 stdout\n    print(duplicate)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving this problem: find duplicate in array with constraints: array length n+1, values in [1,n], only one duplicate, cannot modify array, constant extra space. Classic Floyd's Tortoise and Hare cycle detection. Steps: treat array as linked list where next of index i is nums[i]. Find intersection by moving tortoise and hare. Then find entrance by moving one pointer from start. Return value at intersection.\n\nWe need to produce line-by-line virtual code with arrows. Use Start, End, Decision: etc.\n\nLet's outline:\n\nStart\n→ Initialize slow = nums[0], fast = nums[0] // set pointers at start\n→ Decision: While loop condition? We need while true loop until slow==fast. Use Decision: slow != fast? Then move pointers. But virtual code we can write steps inside loop.\n\nWe need to reflect that we cannot modify array.\n\nVirtual code:\n\nStart\n→ Step 1: Set slow = nums[0] // initialize tortoise\n→ Step 2: Set fast = nums[0] // initialize hare\n→ Step 3: While slow ≠ fast:\n    → Step 3.1: slow = nums[slow] // move one step\n    → Step 3.2: fast = nums[nums[fast]] // move two steps\n→ Step 4: // At this point slow == fast, intersection found\n→ Step 5: Set finder = nums[0] // reset pointer to start\n→ Step 6: While finder ≠ slow:\n    → Step 6.1: finder = nums[finder] // move one step\n    → Step 6.2: slow = nums[slow] // move one step\n→ Step 7: Return slow // duplicate number found\nEnd\n\nBut need to use Decision structure.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化緩慢指標\n→ Step 2: fast ← nums[0] // 初始化快速指標\n→ Decision: slow ≠ fast? // 判斷是否已相遇\n    Yes → Step 3: slow ← nums[slow] // 緩慢指標走一步\n          → Step 4: fast ← nums[nums[fast]] // 快速指標走兩步\n          → Go back to Decision\n    No  → // slow == fast，跳出循環\n→ Step 5: finder ← nums[0] // 將另一指標回到起點\n→ Decision: finder ≠ slow? // 判斷是否找到重複數字\n    Yes → Step 6: finder ← nums[finder] // 走一步\n          → Step 7: slow ← nums[slow] // 走一步\n          → Go back to Decision\n    No  → // finder == slow，找到重複數字\n→ Step 8: Return slow // 回傳重複的數字\nEnd // 程式執行結束\n\nWe need arrow syntax: \"→\" etc. Provide short explanation after \"//\".\n\nLet's incorporate arrow usage properly.\n\nUse indent maybe: but we need each line separate with arrow. For nested decision, maybe use indentation.\n\nWe can produce as:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化緩慢指標\n→ Step 2: fast ← nums[0] // 初始化快速指標\n→ Decision: slow ≠ fast? // 判斷是否相遇\n    Yes → Step 3: slow ← nums[slow] // 緩慢指標走一步\n          → Step 4: fast ← nums[nums[fast]] // 快速指標走兩步\n          → Go back to Decision\n    No  → // 相遇，進入下一步\n→ Step 5: finder ← nums[0] // 將另一指標回到起點\n→ Decision: finder ≠ slow? // 判斷是否找到入口\n    Yes → Step 6: finder ← nums[finder] // 走一步\n          → Step 7: slow ← nums[slow] // 走一步\n          → Go back to Decision\n    No  → // 相遇，找到重複數字\n→ Step 8: Return slow // 回傳重複的數字\nEnd // 程式執行結束\n\nBut \"Go back to Decision\" might not be standard. We could simply write \"→\" back to the Decision line? Could express as \"→ Decision: slow ≠ fast?\" again. But maybe it's okay.\n\nWe need to ensure each line has \"虛擬碼步驟\" followed by space then comment. The arrow at the beginning of line.\n\nMake sure no actual code.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化緩慢指標\n→ Step 2: fast ← nums[0] // 初始化快速指標\n→ Decision: slow ≠ fast? // 判斷兩指標是否相遇\n    Yes → Step 3: slow ← nums[slow] // 緩慢指標走一步\n          → Step 4: fast ← nums[nums[fast]] // 快速指標走兩步\n          → Decision: slow ≠ fast? // 重新檢查相遇條件\n    No  → // 已相遇，進入尋找入口\n→ Step 5: finder ← nums[0] // 將尋找入口的指標回到起點\n→ Decision: finder ≠ slow? // 判斷是否到達入口\n    Yes → Step 6: finder ← nums[finder] // 走一步\n          → Step 7: slow ← nums[slow] // 走一步\n          → Decision: finder ≠ slow? // 重新檢查\n    No  → // 相遇，入口即重複數字\n→ Step 8: Return slow // 回傳重複的數字\nEnd // 程式執行結束\n\nThis seems good. Ensure no actual code like \"nums[0]\" might be considered code. But it's pseudocode style.\n\nWe can keep it.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化緩慢指標  \n→ Step 2: fast ← nums[0] // 初始化快速指標  \n→ Decision: slow ≠ fast? // 判斷兩指標是否相遇  \n  Yes → Step 3: slow ← nums[slow] // 緩慢指標走一步  \n    → Step 4: fast ← nums[nums[fast]] // 快速指標走兩步  \n    → Decision: slow ≠ fast? // 重新檢查相遇條件  \n  No  → // 已相遇，進入尋找入口  \n→ Step 5: finder ← nums[0] // 將尋找入口的指標回到起點  \n→ Decision: finder ≠ slow? // 判斷是否到達入口  \n  Yes → Step 6: finder ← nums[finder] // 走一步  \n    → Step 7: slow ← nums[slow] // 走一步  \n    → Decision: finder ≠ slow? // 重新檢查  \n  No  → // 相遇，入口即為重複數字  \n→ Step 8: Return slow // 回傳重複的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport json\nimport ast\n\nclass MedianFinder:\n    \"\"\"\n    使用兩個堆來保持資料的中位數。\n    小堆（max-heap）存放較小的一半元素，實際存的是負值。\n    大堆（min-heap）存放較大的一半元素。\n    \"\"\"\n    def __init__(self):\n        # 小堆，存放負值以實現最大堆\n        self.small = []\n        # 大堆，最小堆\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        \"\"\"\n        將新數字加入資料結構，並保持兩堆的平衡。\n        \"\"\"\n        # 把新數放進小堆（作為最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 如果兩堆有交叉（小堆最大值 > 大堆最小值）\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡堆大小，兩堆大小差不超過 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"\n        回傳目前所有數字的中位數。\n        \"\"\"\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支援兩種格式：\n    1. 兩行，第一行為命令列表，第二行為參數列表\n    2. 單行，兩個列表以 ',' 分隔\n    \"\"\"\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) == 1:\n        # 單行，嘗試以 '],[' 或 '], ' 分隔\n        idx = lines[0].find('],')\n        if idx != -1:\n            left = lines[0][:idx + 1]\n            right = lines[0][idx + 2:]\n        else:\n            parts = lines[0].split(',', 1)\n            left, right = parts[0], parts[1]\n        cmds = ast.literal_eval(left)\n        args = ast.literal_eval(right)\n    else:\n        cmds = ast.literal_eval(lines[0])\n        args = ast.literal_eval(lines[1])\n    return cmds, args\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    commands, arguments = parse_input(data)\n\n    result = []\n    mf = None\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"MedianFinder\":\n            mf = MedianFinder()\n            result.append(None)  # 代表 null\n        elif cmd == \"addNum\":\n            mf.addNum(arg[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            median = mf.findMedian()\n            result.append(median)\n\n    # 輸出與題目範例一致的 JSON 格式\n    print(json.dumps(result))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. The problem: implement MedianFinder class with addNum and findMedian, maintaining two heaps: max-heap for lower half, min-heap for upper half. The algorithm: on addNum, insert into appropriate heap; rebalance sizes; findMedian returns top of heaps average if even else top.\n\nWe produce virtual code lines: Start, Step: define class, constructors, data members (maxHeap, minHeap). AddNum steps: if maxHeap empty or num <= maxHeap.top, insert into maxHeap else into minHeap. Rebalance: if size difference >1 then move top from larger heap to smaller heap. findMedian: if sizes equal, average of tops; else return top of larger heap.\n\nWe must output step by step with comments. Use arrow formatting. Provide each line with virtual code step and comment.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class MedianFinder // 建立 MedianFinder 類別  \n→   Data member: maxHeap // 儲存較小半部，為最大堆  \n→   Data member: minHeap // 儲存較大半部，為最小堆  \n\n→ Method: MedianFinder() // 建構子，初始化兩個堆  \n→     Initialize maxHeap as empty max-heap  \n→     Initialize minHeap as empty min-heap  \n\n→ Method: addNum(int num) // 新增數字到資料結構  \n→     Decision: 如果 maxHeap 為空 或 num ≤ maxHeap.top? // 判斷將數字放入哪個堆  \n→         Yes → Insert num into maxHeap // 放入較小半部  \n→         No  → Insert num into minHeap // 放入較大半部  \n\n→ 重新平衡堆大小 // 確保兩堆大小差不超過 1  \n→     Decision: maxHeap.size() > minHeap.size() + 1? // maxHeap 過大  \n→         Yes → Move maxHeap.top() 到 minHeap  \n→         No  → Decision: minHeap.size() > maxHeap.size() + 1? // minHeap 過大  \n→                 Yes → Move minHeap.top() 到 maxHeap  \n\n→ Method: findMedian() // 取得目前所有數字的中位數  \n→     Decision: maxHeap.size() == minHeap.size()? // 整體數量為偶數  \n→         Yes → Return (maxHeap.top() + minHeap.top()) / 2.0 // 兩中位數平均  \n→         No  → Decision: maxHeap.size() > minHeap.size()? // maxHeap 多一個  \n→                 Yes → Return maxHeap.top() // 回傳較小半部的最大值  \n→                 No  → Return minHeap.top() // 回傳較大半部的最小值  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))  # 將字串排序後作為 key\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        strs = []\n    else:\n        # 假設輸入格式為 \"strs = [...]\"，或直接給出列表字面值\n        if '=' in data:\n            _, rhs = data.split('=', 1)\n            rhs = rhs.strip()\n        else:\n            rhs = data\n        try:\n            strs = ast.literal_eval(rhs)\n        except Exception:\n            # 若解析失敗，視為單一字串\n            strs = [rhs]\n    sol = Solution()\n    result = sol.groupAnagrams(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with comments in Chinese, as per format. It's the classic group anagrams problem. We need to outline algorithm: use dictionary mapping sorted string to list, iterate array, sort each string, add to bucket, then output values. Each line: virtual code step + comment. Use arrows, decision etc.\n\nWe must follow format: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision. No actual code. Use step numbers maybe. Provide step by step.\n\nLet's produce:\n\nStart\n→ Step 1: 建立空字典 groups // 用來存儲以排序後字串為鍵的分組\n→ Decision: 若輸入陣列 strs 為空? // 檢查是否有資料\n    Yes → Step 2: 回傳空陣列 // 沒有字串，直接回傳\n    No  → Step 3: 針對陣列中每個字串 s 進行循環 // 開始處理每個字串\n        → Step 4: 取得 s 的字元並排序，稱為 key // 為了找出字母相同的分組\n        → Step 5: 若 key 尚未在 groups 中，則新增 key -> 空清單 // 初始化分組\n        → Step 6: 將 s 加入 groups[key] 的清單 // 把原字串放進對應分組\n→ Step 7: 取得 groups 的所有清單作為結果 // 收集所有分組\nEnd\n\nWe should ensure we use the arrow indentation for decisions. Use the pattern \"Decision:\" with Yes →, No →. For nested decisions, indent accordingly.\n\nMake sure to include \"Start\" and \"End\" at top and bottom. Use \"→\" lines for steps.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 groups // 用來存儲以排序後字串為鍵的分組  \n→ Decision: 若輸入陣列 strs 為空? // 檢查是否有資料  \n  Yes → Step 2: 回傳空陣列 // 沒有字串，直接回傳  \n  No  → Step 3: 針對陣列中每個字串 s 進行循環 // 開始處理每個字串  \n    → Step 4: 取得 s 的字元並排序，稱為 key // 為了找出字母相同的分組  \n    → Step 5: 若 key 尚未在 groups 中，則新增 key -> 空清單 // 初始化分組  \n    → Step 6: 將 s 加入 groups[key] 的清單 // 把原字串放進對應分組  \n→ Step 7: 取得 groups 的所有清單作為結果 // 收集所有分組  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"將羅馬數字字串轉換為整數。\"\"\"\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0\n        prev_value = 0\n        # 從右到左遍歷，以便比較前後數值\n        for char in reversed(s):\n            value = roman_map[char]\n            if value < prev_value:\n                total -= value   # 前面較小，執行減法\n            else:\n                total += value   # 前面較大或相等，執行加法\n            prev_value = value\n        return total\n\ndef extract_roman_input(data: str) -> str:\n    \"\"\"\n    從輸入字串中提取羅馬數字。支持：\n    - s = \"XXX\"\n    - Input: s = \"XXX\"\n    - 直接輸入 XXX\n    \"\"\"\n    # 先嘗試找到第一對引號中的內容\n    match = re.search(r'[\"\\']([^\"\\']+)[\"\\']', data)\n    if match:\n        return match.group(1).strip()\n    # 若沒有引號，試著從等號後面提取\n    parts = data.split('=')\n    if len(parts) > 1:\n        return parts[1].strip()\n    # 最後回退：直接去除空白\n    return data.strip()\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    roman_str = extract_roman_input(raw_input)\n    solution = Solution()\n    result = solution.romanToInt(roman_str)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines with explanations. Steps: Start, initialize sum=0, iterate characters from rightmost to leftmost, use lastValue to compare. Or use mapping and subtract or add. We'll write decision steps. Ensure each line has 虛擬碼 + space + // explanation.\n\nLet's craft.\n\nStart // 程式開始\n→ Step 1: 定義映射表: {I:1, V:5, X:10, L:50, C:100, D:500, M:1000} // 建立符號對應數值\n→ Step 2: 初始化變數 total = 0, prev = 0 // 用於累加結果與比較前一個數值\n→ Step 3: 從輸入字串最後一個字符到第一個字符遍歷 // 逆向遍歷方便比較\n    → Decision: 符號對應值 current > prev? // 判斷是否需要減法\n        Yes → Step 4: total = total - current // 前面較小，執行減法\n        No  → Step 5: total = total + current // 前面較大或相等，執行加法\n    → Step 6: prev = current // 更新 prev 為當前數值\n→ Step 7: 輸出 total // 回傳整數結果\nEnd // 程式結束\n\nMake sure each line ends with // explanation.\n\nAlso include Start and End lines. Use arrow arrow for decision lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義映射表: {I:1, V:5, X:10, L:50, C:100, D:500, M:1000} // 建立符號對應數值  \n→ Step 2: 初始化變數 total = 0, prev = 0 // 用於累加結果與比較前一個數值  \n→ Step 3: 從輸入字串最後一個字符到第一個字符遍歷 // 逆向遍歷方便比較  \n  → Decision: current > prev? // 判斷是否需要執行減法  \n   Yes → Step 4: total = total - current // 前面較小，執行減法  \n   No  → Step 5: total = total + current // 前面較大或相等，執行加法  \n  → Step 6: prev = current // 更新 prev 為當前數值  \n→ Step 7: 輸出 total // 回傳整數結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzfzzwmb5.py\", line 85, in <module>\n    main()\n  File \"/tmp/tmpzfzzwmb5.py\", line 56, in main\n    ops, params = parse_input(raw_input)\n                  ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzfzzwmb5.py\", line 50, in parse_input\n    ops = ast.literal_eval(ops_line.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"WordDictionary\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef parse_input(data: str):\n    \"\"\"Parse the LeetCode style input into ops and params lists.\"\"\"\n    data = data.strip()\n    if not data:\n        return [], []\n    # If input spans two lines, split accordingly\n    if '\\n' in data:\n        lines = data.splitlines()\n        ops_line, params_line = lines[0], lines[1]\n    else:\n        # Single line: wrap in parentheses to make a tuple\n        ops_line, params_line = data.split(',', 1)\n    # Use ast.literal_eval to safely evaluate the lists\n    ops = ast.literal_eval(ops_line.strip())\n    params = ast.literal_eval(params_line.strip())\n    return ops, params\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, params = parse_input(raw_input)\n\n    results = []\n    obj = None\n    for op, param in zip(ops, params):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            obj.addWord(param[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(obj.search(param[0]))\n\n    # Convert results to LeetCode style output\n    out_parts = []\n    for r in results:\n        if r is None:\n            out_parts.append(\"null\")\n        elif r is True:\n            out_parts.append(\"true\")\n        elif r is False:\n            out_parts.append(\"false\")\n        else:\n            out_parts.append(str(r))\n    output = \"[\" + \",\".join(out_parts) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. Should not produce real code. It's a typical LeetCode problem 211 Word Dictionary with wildcard search. Data structure: Trie. Virtual code lines: Start, initialize root node. addWord uses recursion. search uses recursion for '.' wildcard. Should show decisions. Provide step by step with arrows.\n\nWe need to produce lines of virtual code. Use `→` arrow. Each line ends with `//` explanation. Must follow format.\n\nOk, produce:\n\nStart // init\n\n→ Step 1: Create root node // root of trie\n\n→ Step 2: addWord(word) // function definition\n\n    → For each char c in word // iterate chars\n\n        → If child node for c doesn't exist // missing node\n\n            → Create new TrieNode // add node\n\n        → Move to child node // continue\n\n    → Mark current node as word end // word stored\n\n→ Step 3: search(word) // function definition\n\n    → Call helper function searchHelper(word, index, node)\n\n→ Step 4: searchHelper(word, i, node) // recursive search\n\n    → If i equals word length\n\n        → Return node.isEnd // if reached end\n\n    → Let ch = word[i] // current character\n\n    → If ch is not '.'\n\n        → If node.children[ch] exists\n\n            → Return searchHelper(word, i+1, node.children[ch]) // continue\n\n        → Else return False // char mismatch\n\n    → Else (ch == '.')\n\n        → For each child in node.children\n\n            → If searchHelper(word, i+1, child) returns True\n\n                → Return True // found match\n\n        → Return False // no match found\n\nEnd // finish\n\nWe need each line with arrow arrow? Provide nested indent with arrow? According to example, indent uses spaces then arrow? We can just indent with spaces. Use arrows for steps.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Trie 的根節點 // 初始化字典的根節點  \n→ Step 2: 定義函式 addWord(word) // 用於加入新單字  \n    → For 每個字元 ch 在 word 中  \n        → Decision: 根節點的子節點中是否已有 ch? // 檢查是否已有該字母節點  \n            Yes → Step 2.1: 取該子節點 // 直接使用已存在節點  \n            No  → Step 2.2: 新增一個 TrieNode 並指派給 ch // 新建缺失節點  \n        → Step 2.3: 移動到 ch 的節點 // 准備處理下一個字元  \n    → Decision: 已處理完所有字元? // 判斷是否到達單字尾部  \n        Yes → Step 2.4: 標記目前節點為單字結束 // 表示這條路徑代表一個完整單字  \n→ Step 3: 定義函式 search(word) // 用於查找是否存在匹配單字  \n    → Step 3.1: 呼叫 helper(word, 0, root) // 從根節點開始遞迴搜尋  \n→ Step 4: 定義遞迴 helper(word, idx, node) // 具體搜尋實作  \n    → Decision: idx 等於 word 長度? // 是否已檢查完所有字元  \n        Yes → Return node.isEnd // 若結束節點是單字結束，則為真  \n        No  → Step 4.1: 取 word[idx] 為 ch // 取得目前要比對的字元  \n            → Decision: ch 是否為 '.'? // 處理通配符  \n                Yes → Step 4.2: 對 node 所有子節點進行遞迴  \n                    → For 每個子節點 child  \n                        → If helper(word, idx+1, child) 為真  \n                            → Return true // 找到符合的路徑  \n                    → Return false // 所有子節點皆不匹配  \n                No  → Step 4.3: Decision: node.children 是否含 ch?  \n                    Yes → Return helper(word, idx+1, node.children[ch]) // 直接往下遞迴  \n                    No  → Return false // 字元不匹配  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,true,false,true,null,true]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[null, null, true, false, true, null, true]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for ch in prefix:\n            if ch not in node.children:\n                return False\n            node = node.children[ch]\n        return True\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Split into two lists: operations and arguments\n    try:\n        parts = data.split('],', 1)\n        ops_part = parts[0] + ']'\n        args_part = '[' + parts[1]\n        ops = ast.literal_eval(ops_part)\n        args = ast.literal_eval(args_part)\n    except Exception as e:\n        # If parsing fails, just exit\n        print(\"[]\")\n        return\n\n    results = []\n    trie = None\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif op == 'insert':\n            trie.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie.search(arg[0]))\n        elif op == 'startsWith':\n            results.append(trie.startsWith(arg[0]))\n        else:\n            # Unsupported operation; ignore or append None\n            results.append(None)\n\n    # Output in JSON format to match expected null/true/false\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps, line by line, with explanation. For Trie class, typical operations: node structure, root, insert, search, startsWith. Should use arrow syntax: Start, End, Decision, Yes/No.\n\nWe'll create high-level structure: Start // program start\n→ Step: Define TrieNode class // node with children and isEnd flag\n→ Step: Define Trie class // root node\n→ Step: Insert method\n→ Step: Search method\n→ Step: startsWith method\nEnd.\n\nBut they want each line of virtual code with explanation. So we need each step line as \"Step ... // explanation\". Use arrow. For decisions, show Yes → etc. For loops maybe use For.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Define TrieNode class with child map and isEnd flag // 建立節點結構\n→ Step 2: Define Trie class with root node // 建立 Trie 物件\n→ Step 3: Trie() constructor: root = new TrieNode() // 初始化根節點\n→ Step 4: insert(String word): node = root // 從根節點開始\n→ Decision: 迭代每個字元 c in word? // 逐字元處理\n    Yes → Step 5: 如果 node.children 沒有 c，則新增 TrieNode() // 建立新節點\n    Yes → Step 6: node = node.children[c] // 移至該子節點\n→ Step 7: node.isEnd = true // 標記單詞結束\n→ Step 8: search(String word): node = root // 從根節點開始\n→ Decision: 迭代每個字元 c in word? // 逐字元處理\n    Yes → Step 9: 如果 node.children 沒有 c，則返回 false // 沒有此路徑\n    Yes → Step 10: node = node.children[c] // 移至子節點\n→ Step 11: return node.isEnd // 若結尾標記則存在\n→ Step 12: startsWith(String prefix): node = root // 從根節點開始\n→ Decision: 迭代每個字元 c in prefix? // 逐字元處理\n    Yes → Step 13: 如果 node.children 沒有 c，則返回 false // 無前綴\n    Yes → Step 14: node = node.children[c] // 移至子節點\n→ Step 15: return true // 前綴存在\nEnd // 程式執行結束\n\nNeed to ensure arrow formatting consistent: \"→ Step X:\" lines, decisions with Yes/No.\n\nAlso maybe use For loops: \"→ For each char c in word:\" but use arrow.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類，包含 children 映射與 isEnd 標誌 // 建立節點結構  \n→ Step 2: 定義 Trie 類，內部持有 root 節點 // 建立 Trie 物件  \n→ Step 3: Trie() 構造函式：root ← 新 TrieNode() // 初始化根節點  \n\n→ Step 4: insert(String word)：node ← root // 從根節點開始  \n→ Decision: 迭代 word 中每個字元 c？ // 逐字元處理  \n    Yes → Step 5: 若 node.children 缺少 c，則 node.children[c] ← 新 TrieNode() // 新增節點  \n    Yes → Step 6: node ← node.children[c] // 移動至子節點  \n→ Step 7: node.isEnd ← true // 標記單詞結束  \n\n→ Step 8: search(String word)：node ← root // 從根節點開始  \n→ Decision: 迭代 word 中每個字元 c？ // 逐字元處理  \n    Yes → Step 9: 若 node.children 缺少 c，則 返回 false // 路徑不存在  \n    Yes → Step 10: node ← node.children[c] // 移動至子節點  \n→ Step 11: 返回 node.isEnd // 若結尾標記為 true，表示已插入該單詞  \n\n→ Step 12: startsWith(String prefix)：node ← root // 從根節點開始  \n→ Decision: 迭代 prefix 中每個字元 c？ // 逐字元處理  \n    Yes → Step 13: 若 node.children 缺少 c，則 返回 false // 無此前綴  \n    Yes → Step 14: node ← node.children[c] // 移動至子節點  \n→ Step 15: 返回 true // 所有字元皆存在，前綴成立  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[4]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[4]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[1,6]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[1, 6]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,9,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 9, 5]'"
        }
      ],
      "generated_code": "import random\nimport sys\nimport re\n\n# ---------------------------------------------------------\n# 隨機生成 1~7 的 API，僅供測試使用\ndef rand7() -> int:\n    \"\"\"返回 1 到 7 的均勻隨機整數\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        使用 rand7() 生成 1~10 的均勻隨機整數。\n        方式：將兩次 rand7() 組合成 1~49，若超過 40 則重新生成。\n        \"\"\"\n        while True:\n            # 兩次 rand7() 組合成 1~49 的整數\n            num = (rand7() - 1) * 7 + rand7() + 1   # +1 使結果在 1~49\n            if num <= 40:                           # 只保留 1~40 的部分\n                return 1 + (num - 1) % 10           # 映射到 1~10\n            # num > 40 時，重複迴圈，重新產生\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    1. 從標準輸入讀取 'n = X' 的格式，提取 X 為 n。\n    2. 呼叫 rand10() n 次，收集結果。\n    3. 將結果列印成列表格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group(0))\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo code for implementing rand10() using rand7(). Classic solution: generate 49 possibilities using two calls of rand7() as base-7 digits: (x-1)*7 + (y-1) +1 gives 1-49. Accept if <=40. Map to 1-10 by modulo. Use rejection sampling.\n\nNeed to produce step-by-step pseudocode with explanations. Use arrows. Provide each line. Let's design:\n\nStart\n→ Step 1: Call rand7() → obtain a // first random number 1-7\n→ Step 2: Call rand7() → obtain b // second random number 1-7\n→ Step 3: Compute num = (a-1)*7 + (b-1) + 1 // convert to 1-49\n→ Decision: If num > 40? // if out of accepted range\n    Yes → Step 4: Repeat rand10() call // recursively call or loop\n    No  → Step 5: Compute result = ((num-1) mod 10) + 1 // map to 1-10\n→ Step 6: Return result\nEnd\n\nNeed to include loop; could use recursion or while loop.\n\nAlso note we need to not call other APIs.\n\nWe should show that if num > 40, we repeat.\n\nWe might structure with while true loop: generate until accepted.\n\nBut they want step-by-step. We can use Decision: If num <= 40? Yes else repeat.\n\nWe'll produce pseudocode accordingly.\n\nAdd explanation comments after each line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Call rand7() → obtain a // 取得第一個 1~7 的隨機數\n→ Step 2: Call rand7() → obtain b // 取得第二個 1~7 的隨機數\n→ Step 3: Compute num = (a-1) * 7 + (b-1) + 1 // 將兩個數組成 1~49 的整數\n→ Decision: 是否 num > 40? // 檢查是否落在可接受的 1~40 範圍\n    Yes → Step 4: 重複步驟 1–3 // 若超出 40，重新產生一組數字\n    No  → Step 5: result = ((num-1) mod 10) + 1 // 將 1~40 映射到 1~10\n→ Step 6: Return result // 傳回均勻分佈的 1~10 整數\nEnd // 程式執行結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2**31 - 1\nINT_MIN = -2**31\n\ndef reverse(x: int) -> int:\n    rev = 0\n    while x != 0:\n        pop = x % 10\n        x //= 10\n        # check overflow\n        if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and pop > 7):\n            return 0\n        if rev < INT_MIN // 10 or (rev == INT_MIN // 10 and pop < -8):\n            return 0\n        rev = rev * 10 + pop\n    return rev\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        x = int(match.group())\n        print(reverse(x))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanations, for reversing digits of 32-bit signed int without using 64-bit integers. We need to avoid overflow: if reversed value outside 32-bit range, return 0.\n\nApproach: We'll use long? but disallowed. So we need to detect overflow before it occurs. Typical algorithm: while x != 0, pop = x % 10; x /= 10; check if rev > (INT_MAX - pop)/10 or rev < (INT_MIN - pop)/10; if overflow, return 0; else rev = rev*10 + pop. Use 32-bit signed operations only. But we must not use 64-bit. We can use int rev=0; int pop; while(x!=0){pop=x%10; x/=10; if (rev>INT_MAX/10 || (rev==INT_MAX/10 && pop>7)) return 0; if (rev<INT_MIN/10 || (rev==INT_MIN/10 && pop<-8)) return 0; rev=rev*10+pop;} return rev;\n\nWe need to produce virtual code lines with decision and arrow. Also we need Start, End. Provide comments.\n\nLet's produce. Ensure each line includes explanation. Use arrow and decision. Provide each line. We'll use 'Decision' for overflow check. We'll use variable names: rev, pop, x. Use constants INT_MAX=2147483647, INT_MIN=-2147483648. Represent them maybe as 2147483647, -2147483648. But we need to compare. Use integer division.\n\nAlso need to mention \"Assume environment no 64-bit integer\" - we just do 32-bit.\n\nOk produce.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use '→' arrow after each step. Start and End.\n\nLet's create.\n\nPotential steps:\n\nStart\n→ Step 1: Define rev = 0 // Initialize reversed result\n→ Step 2: While x != 0 // Process each digit\n    → Decision: Compute pop = x % 10 // Extract last digit\n    → Step 3: x = x / 10 // Remove last digit from original\n    → Decision: If rev > INT_MAX/10 OR (rev == INT_MAX/10 AND pop > 7) OR rev < INT_MIN/10 OR (rev == INT_MIN/10 AND pop < -8) // Check for overflow\n        Yes → Step 4: Return 0 // Overflow would occur\n        No → Step 5: rev = rev * 10 + pop // Append digit\n→ Step 6: Return rev // Return reversed integer\n\nBut we need to follow arrow structure. Use nested decisions. Also need to be careful about indent.\n\nLet's produce with correct formatting. Use tabs maybe? But each line we produce.\n\nUse Start // start.\n\nThen \"→ Step 1:\" etc.\n\nWhen while loop: \"→ While x != 0:\" maybe not allowed but we can use \"→ Decision: x != 0?\" with Yes and No.\n\nBut typical structure: Decision: x != 0? Yes → do inside. So we might use:\n\n→ Decision: x != 0? // check if there are digits left\n    Yes → ... // loop body\n    No → Step 6: Return rev\n\nBut we also need to incorporate loop inside the Yes branch.\n\nLet's design:\n\nStart\n→ Step 1: Set rev = 0 // initialize reversed result\n→ Decision: x != 0? // check if input has digits\n    Yes → Step 2: pop = x % 10 // get last digit\n    Yes → Step 3: x = x / 10 // remove last digit\n    Yes → Decision: rev > INT_MAX/10 OR (rev == INT_MAX/10 AND pop > 7) OR rev < INT_MIN/10 OR (rev == INT_MIN/10 AND pop < -8)? // overflow check\n        Yes → Step 4: Return 0 // overflow detected\n        No → Step 5: rev = rev * 10 + pop // append digit\n    Yes → Decision: x != 0? // repeat loop\n        Yes → (go back to Step 2) // but we need loop, we can use goto? But we can just repeat the structure by recursion? Instead we can embed within the loop, but we need to produce a representation.\n\nSimpler: Use a while loop representation as decision with recursion.\n\nBut we can structure like:\n\nStart\n→ Step 1: Set rev = 0\n→ Decision: x != 0? // while condition\n    Yes → \n        → Step 2: pop = x % 10\n        → Step 3: x = x / 10\n        → Decision: overflow condition? \n            Yes → Step 4: Return 0\n            No  → Step 5: rev = rev * 10 + pop\n        → Decision: x != 0? // loop again\n            Yes → (go back to Step 2) // but we cannot reference previous step? Could use \"Yes → go back\" but it's fine.\n            No → Step 6: Return rev\n    No → Step 6: Return rev\n\nBut the instructions: \"使用虛擬碼的箭頭 (→, Yes →, No →) 和結構 (Start, End, Decision:)\" So we need to use arrow notation exactly. We can use indentation to show nested decisions.\n\nLet's produce final answer.\n\nAlso ensure each line has explanation after //.\n\nLet's produce 12-14 lines.\n\nWe must not output actual code but pseudocode lines. Use \"Step\" naming.\n\nLet's craft:\n\n```\nStart // 程式開始執行\n→ Step 1: rev = 0 // 初始化反轉結果\n→ Decision: x != 0? // 檢查是否還有數位要處理\n    Yes → Step 2: pop = x % 10 // 取得原數字最後一位\n    Yes → Step 3: x = x / 10 // 去掉最後一位\n    Yes → Decision: rev > INT_MAX/10 OR (rev == INT_MAX/10 AND pop > 7) OR rev < INT_MIN/10 OR (rev == INT_MIN/10 AND pop < -8)? // 事先判斷是否會溢位\n        Yes → Step 4: Return 0 // 溢位，直接回傳 0\n        No  → Step 5: rev = rev * 10 + pop // 把新位數加入反轉結果\n    Yes → Decision: x != 0? // 若還有位數，繼續循環\n        Yes → (回到 Step 2) // 重新處理下一個位數\n        No  → Step 6: Return rev // 所有位數已處理完畢，回傳結果\n    No  → Step 6: Return rev // 初始 x 為 0，直接回傳 0\nEnd // 程式執行結束\n```\n\nBut we need each line as one line of virtual code. The above block has multiple lines per indentation. We can produce each line separately with line number. The requirement: \"逐行輸出\" - each line separate. Each line must contain \"虛擬碼步驟\" + space + \"// 解釋\". So we must not combine multiple steps on one line.\n\nSo we need to split each step into a single line. The nested decisions have multiple lines: Decision lines and Yes/No lines. For each \"Yes →\" we need a line. The \"回到 Step 2\" is ambiguous but can be just \"Yes → (repeat loop)\" or \"Yes → go back to Step 2\". Let's do \"Yes → Step 2: repeat loop\". But it's still a line.\n\nBut maybe simpler: Use \"Decision: x != 0?\" with Yes branch including all steps; but each branch lines inside need to be separate lines. So we can use \"Yes →\" line for each step inside. The indentation is optional. But we can produce like:\n\nStart // 程式開始執行\n→ Step 1: rev = 0 // 初始化反轉結果\n→ Decision: x != 0? // 檢查是否還有數位要處理\n    Yes → Step 2: pop = x % 10 // 取得原數字最後一位\n    Yes → Step 3: x = x / 10 // 去掉最後一位\n    Yes → Decision: rev > INT_MAX/10 OR (rev == INT_MAX/10 AND pop > 7) OR rev < INT_MIN/10 OR (rev == INT_MIN/10 AND pop < -8)? // 溢位檢查\n        Yes → Step 4: Return 0 // 溢位，直接回傳 0\n        No  → Step 5: rev = rev * 10 + pop // 把新位數加入反轉結果\n    Yes → Decision: x != 0? // 仍有位數則循環\n        Yes → (repeat loop) // 回到 Step 2 處理下一位\n        No  → Step 6: Return rev // 所有位數處理完畢，回傳結果\n    No  → Step 6: Return rev // 初始 x 為 0，直接回傳 0\nEnd // 程式執行結束\n\nBut lines include indentation but each line is separate. But we need each line to include the step plus explanation. The above includes indentation lines. Each line includes \"→\" arrow. For \"Yes → (repeat loop)\" maybe we need a step. But we might just use \"Yes → go back to Step 2\" but still a line. This is acceptable.\n\nLet's produce final answer in Chinese with step lines. Use \"Start\" and \"End\".\n\nEnsure each line uses arrow arrow: '→', 'Yes →', 'No →' as appropriate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: rev = 0 // 初始化反轉結果\n→ Decision: x != 0? // 檢查是否還有數位要處理\n    Yes → Step 2: pop = x % 10 // 取得原數字最後一位\n    Yes → Step 3: x = x / 10 // 去掉最後一位\n    Yes → Decision: rev > INT_MAX/10 OR (rev == INT_MAX/10 AND pop > 7) OR rev < INT_MIN/10 OR (rev == INT_MIN/10 AND pop < -8)? // 檢查是否即將溢位\n        Yes → Step 4: Return 0 // 溢位，直接回傳 0\n        No  → Step 5: rev = rev * 10 + pop // 把新位數加入反轉結果\n    Yes → Decision: x != 0? // 若還有位數，繼續循環\n        Yes → (repeat loop) // 回到 Step 2 處理下一位\n        No  → Step 6: Return rev // 所有位數已處理完畢，回傳結果\n    No  → Step 6: Return rev // 初始 x 為 0，直接回傳 0\nEnd // 程式執行結束"
    },
    {
      "title": "ZigZag Conversion",
      "source_file": "Leetcode/leetcode6.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'PAHNAPLSIIGYIR'\nGot (Norm):      'PAYPALISHIRING'\n--- (Raw) ---\nRaw Expected: \"'PAHNAPLSIIGYIR'\"\nRaw Got:      'PAYPALISHIRING'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"將字串轉換成 zigzag 形，然後按行讀取。\"\"\"\n    def convert(self, s: str, numRows: int) -> str:\n        # 如果只用一行或行數不小於字串長度，直接回傳原字串\n        if numRows == 1 or numRows >= len(s):\n            return s\n        # 每一行用一個字串積累\n        rows = [''] * numRows\n        index, step = 0, 1  # 目前所在行、以及往下或往上的方向\n        for c in s:\n            rows[index] += c  # 加到對應行\n            # 到頂或底時改變方向\n            if index == 0:\n                step = 1\n            elif index == numRows - 1:\n                step = -1\n            index += step\n        # 把所有行連接起來就是結果\n        return ''.join(rows)\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取字串與行數，輸出轉換後的結果。\n    支援兩種輸入格式：\n    1. 兩行：第一行是字串，第二行是行數。\n    2. 一行，格式為 `s = '文字', numRows = 3` 或類似的 key=value。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試正則解析 key=value 的寫法\n    pattern = re.compile(r\"(s|numRows)\\s*=\\s*(['\\\"]?)(.*?)\\2\")\n    matches = pattern.findall(data)\n    if matches:\n        values = {}\n        for key, _, val in matches:\n            if key == 's':\n                values['s'] = val\n            else:\n                try:\n                    values['numRows'] = int(val)\n                except ValueError:\n                    values['numRows'] = 1\n        s = values.get('s', '')\n        numRows = values.get('numRows', 1)\n    else:\n        # 若沒有 key=value，則視為兩行輸入\n        parts = data.splitlines()\n        if len(parts) >= 2:\n            s = parts[0].strip('\"\\'' )  # 去除可能的引號\n            try:\n                numRows = int(parts[1].strip())\n            except ValueError:\n                numRows = 1\n        else:\n            # 只有一行，假設是字串，行數預設為 1\n            s = data.strip('\"\\'' )\n            numRows = 1\n\n    result = Solution().convert(s, numRows)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting string to zigzag pattern and read line by line. Essentially the LeetCode problem 6: ZIGZAG CONVERSION. So steps: input string s, number of rows nRows. If nRows==1 or nRows>=len(s) return s. Determine cycleLen = 2*nRows-2. Create array of string builder for each row. Iterate over s characters with index i, compute posInCycle = i % cycleLen. row = posInCycle < nRows ? posInCycle : cycleLen - posInCycle. Append char to row string. After loop, concatenate all rows. Output result. So we produce virtual code steps line by line.\n\nWe need to format each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrow syntax: Start, Step 1, Decision, Yes, No, etc.\n\nWe need to produce in Traditional Chinese.\n\nLet's produce steps:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s 和行數 numRows // 獲取要轉換的字串和行數\n→ Decision: 如果 numRows <= 1 或 numRows >= s.Length? // 檢查是否需要直接返回\n    Yes → Step 2: 輸出 s // 直接回傳原字串\n    No  → Step 3: 計算 cycleLen = 2 * numRows - 2 // 計算一個完整往返的週期長度\n→ Step 4: 建立 rows 陣列，長度 numRows，內部為空字串 // 用於儲存各行內容\n→ Step 5: 迴圈 i 從 0 到 s.Length-1\n    → Step 6: 計算 pos = i % cycleLen // 找出當前字元在週期中的位置\n    → Decision: 如果 pos < numRows? // 判斷是往下走還是往上走\n        Yes → Step 7: rowIndex = pos // 往下走，行號就是 pos\n        No  → Step 8: rowIndex = cycleLen - pos // 往上走，行號取倒數\n    → Step 9: 將 s[i] 加到 rows[rowIndex] // 把字元加入對應行\n→ Step 10: 初始化 result 為空字串 // 用於累加所有行的內容\n→ Step 11: 迴圈 row 從 0 到 numRows-1\n    → Step 12: result = result + rows[row] // 依序合併行字串\n→ Step 13: 輸出 result // 回傳最終的 zigzag 讀字串\nEnd // 程式結束\n\nAlso maybe add final output step.\n\nEnsure arrow notation: Use \"→\" for steps.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s 和行數 numRows // 獲取要轉換的字串和行數  \n→ Decision: 如果 numRows <= 1 或 numRows >= s.Length? // 判斷是否不需要轉換  \n Yes → Step 2: 輸出 s // 直接回傳原字串  \n No  → Step 3: 計算 cycleLen = 2 * numRows - 2 // 計算完整往返的週期長度  \n→ Step 4: 建立 rows 陣列，長度 numRows，內部為空字串 // 用於儲存各行內容  \n→ Step 5: 迴圈 i 從 0 到 s.Length-1  \n → Step 6: 計算 pos = i % cycleLen // 找出當前字元在週期中的位置  \n → Decision: 如果 pos < numRows? // 判斷是往下走還是往上走  \n  Yes → Step 7: rowIndex = pos // 往下走，行號就是 pos  \n  No  → Step 8: rowIndex = cycleLen - pos // 往上走，行號取倒數  \n → Step 9: 將 s[i] 加到 rows[rowIndex] // 把字元加入對應行  \n→ Step 10: 初始化 result 為空字串 // 用於累加所有行的內容  \n→ Step 11: 迴圈 row 從 0 到 numRows-1  \n → Step 12: result = result + rows[row] // 依序合併行字串  \n→ Step 13: 輸出 result // 回傳最終的 zigzag 讀字串  \nEnd // 程式結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6fb8n5o8.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmp6fb8n5o8.py\", line 37, in main\n    ops = ast.literal_eval(ops_part.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"NumArray\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]          # 保存原始值以便計算差值\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops_part, args_part = data.split(',', 1)\n    ops = ast.literal_eval(ops_part.strip())\n    args = ast.literal_eval(args_part.strip())\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            obj = NumArray(arg[0])   # arg[0] 是 nums 列表\n            results.append(None)\n        elif op == \"update\":\n            obj.update(arg[0], arg[1])\n            results.append(None)\n        elif op == \"sumRange\":\n            results.append(obj.sumRange(arg[0], arg[1]))\n\n    output = '[' + ', '.join('null' if v is None else str(v) for v in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbols →, Decision etc. We need to describe a solution: using segment tree or binary indexed tree. Provide steps for initialization, update, sumRange. The code structure: Start, Step 1: Initialize BIT array, etc. Should include decision points maybe for handling index bounds. Provide explanation after each line. We must not output actual code. Use virtual code. Let's produce a step-by-step algorithm. We'll create a class NumArray with a binary indexed tree (Fenwick tree). Steps: build tree, update, query prefix sum, sumRange. Include decision: if left>right? Not needed. Provide loops for building, etc. Provide explanation.\n\nWe need to output with arrows. Let's produce:\n\nStart\n→ Step 1: Create internal array tree of size n+1 // 1-indexed Fenwick tree\n→ Step 2: For i from 0 to n-1: updateTree(i, nums[i]) // Build tree by inserting each value\n→ Decision: When initializing, do we need to copy original array? yes // store nums\n→ Step 3: Store original nums for future updates // keep original values for difference calculation\n\nThen update:\n→ Function update(index, val):\n→ Step 4: Compute delta = val - nums[index] // difference\n→ Step 5: nums[index] = val // update stored value\n→ Step 6: UpdateFenwick(index, delta) // apply delta to tree\n\nFenwick update function:\n→ Step 7: While idx <= n: tree[idx] += delta; idx += idx & -idx // propagate\n\nsumRange:\n→ Function sumRange(left, right):\n→ Step 8: prefixRight = prefixSum(right) // sum 0..right\n→ Step 9: prefixLeftMinus1 = prefixSum(left-1) // sum 0..left-1\n→ Step 10: return prefixRight - prefixLeftMinus1 // desired sum\n\nprefixSum:\n→ Step 11: sum = 0; idx = idx+1; while idx>0: sum += tree[idx]; idx -= idx & -idx // accumulate\n→ Step 12: return sum\n\nEnd\n\nNeed each line with explanation. Use arrow or decision. Provide Start and End lines.\n\nLet's craft each line accordingly. Use \"→\" for steps, \"Decision:\" for decision. Provide explanation after //.\n\nEnsure no actual code, just description.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立大小為 n+1 的樹陣列 tree 以及儲存原始陣列 nums // 使用 1‑index 的 Fenwick 樹以便更新和查詢\n\n→ Step 2: 從索引 0 到 n-1 逐一呼叫 UpdateFenwick(i, nums[i]) 以建構樹 // 逐個插入原始值，完成樹的初始化\n\nDecision: 是否需要保留原始值以便未來更新？ // 需要，才能計算差值\n\n→ Step 3: 將原始陣列 nums 複製至內部變數 self.nums // 方便後續取得舊值進行差值計算\n\n→ Function update(index, val): // 定義更新方法\n\n→ Step 4: 計算 delta = val - self.nums[index] // 取得要加到樹上的差值\n\n→ Step 5: self.nums[index] = val // 更新內部陣列的值\n\n→ Step 6: 呼叫 UpdateFenwick(index, delta) // 將差值更新至 Fenwick 樹\n\n→ Function UpdateFenwick(idx, delta): // Fenwick 樹的更新邏輯\n\n→ Step 7: idx ← idx + 1 // 轉換至 1‑index\n\n→ Decision: idx <= n? // 是否還在樹的範圍內\n\n    Yes → Step 8: tree[idx] ← tree[idx] + delta // 加上差值\n\n    Yes → Step 9: idx ← idx + (idx & -idx) // 移動至下一個節點\n\n    No  → End of UpdateFenwick // 更新完成\n\n→ Function sumRange(left, right): // 定義區間求和方法\n\n→ Step 10: prefixRight ← PrefixSum(right) // 取得 0..right 的前綴和\n\n→ Step 11: prefixLeft ← PrefixSum(left - 1) // 取得 0..left-1 的前綴和\n\n→ Step 12: return prefixRight - prefixLeft // 差值即為區間和\n\n→ Function PrefixSum(idx): // 計算 0..idx 的前綴和\n\n→ Step 13: sum ← 0; idx ← idx + 1 // 轉換至 1‑index\n\n→ Decision: idx > 0? // 是否還有節點可累加\n\n    Yes → Step 14: sum ← sum + tree[idx] // 累加節點值\n\n    Yes → Step 15: idx ← idx - (idx & -idx) // 移動至上一個節點\n\n    No  → End of PrefixSum // 前綴和完成\n\n→ Step 16: return sum // 回傳累計結果\n\nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      '[\"1+2+3\", \"1*2*3\"]'"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      '[\"2+3*2\", \"2*3+2\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Parse the input assuming format: num = \"123\", target = 6\n    match = re.search(r'num\\s*=\\s*\"([^\"]+)\"\\s*,\\s*target\\s*=\\s*(-?\\d+)', data)\n    if not match:\n        # If parsing fails, try to split by commas and spaces\n        parts = [p.strip() for p in data.replace(',', ' ').split()]\n        num = None\n        target = None\n        for i, part in enumerate(parts):\n            if part == 'num':\n                if i + 1 < len(parts):\n                    num = parts[i + 1].strip('\"')\n            elif part == 'target':\n                if i + 1 < len(parts):\n                    target = int(parts[i + 1])\n        if num is None or target is None:\n            raise ValueError(\"Input format is incorrect.\")\n    else:\n        num, target = match.group(1), int(match.group(2))\n\n    solver = Solution()\n    result = solver.addOperators(num, target)\n    # Output in JSON format to match the examples\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nThe task: produce virtual code steps for generating all expressions by inserting operators + - * such that expression evaluates to target. Input: string num of digits, integer target. Output: list of strings of expressions, with no leading zeros in operands. Must produce step-by-step pseudocode with explanations, following the output format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows and structure.\n\nWe need to produce algorithm: recursion/backtracking building expression and evaluating as we go. Use DFS with parameters: position, current expression string, evaluated value, last operand (for multiplication). Need to avoid leading zeros: if segment starts with '0' and length>1 skip.\n\nWe produce stepwise pseudocode: Start, Step 1: input. Step 2: call recursive function. Inside recursion: decision: if position == len(num) -> if eval == target -> add expression to result. Else: iterate i from pos to len(num)-1, pick substring num[pos:i+1], convert to long. If pos==0: first number, no operator. Else: for each operator: '+', '-', '*', compute new eval accordingly: for '+' and '-' just add/subtract; for '*', need to adjust by subtracting lastOperand and adding lastOperand*curr. Then recursive call with updated position i+1, expression appended with op+num, updated eval, updated lastOperand. Also skip if substring starts with '0' and length>1.\n\nAlso at end End. Provide explanation for each line.\n\nLet's craft lines:\n\nStart\n→ Step 1: 取得輸入字串 num 與目標值 target\n→ Step 2: 建立結果列表 results\n→ Step 3: 呼叫遞迴函式 DFS 於起始位置 0，空字串，值 0，上一操作數 0\n    → Function DFS(pos, expr, eval, last)\n        → Decision: 若 pos 等於長度 num? // 完整處理完所有數字\n            Yes → Decision: 若 eval 等於 target? // 檢查是否符合目標\n                Yes → Step: 把 expr 加入 results\n                No → Step: 回溯\n            No → Step: 循環選取子字串\n                → Loop i 從 pos 到 len(num)-1\n                    → Step: 取子字串 curStr = num[pos:i+1]\n                    → Decision: 若 curStr 開頭為 '0' 且長度 > 1? // 避免前導零\n                        Yes → Step: 跳過此子字串\n                        No → Step: 轉為數字 curNum\n                    → Decision: 若 pos==0? // 第一個數字\n                        Yes → Step: DFS(i+1, curStr, curNum, curNum) // 無運算子\n                        No → Step: For each op in ['+','-','*']\n                                → Decision: op == '+'\n                                    Yes → Step: DFS(i+1, expr+'+'+curStr, eval+curNum, curNum)\n                                → Decision: op == '-'\n                                    Yes → Step: DFS(i+1, expr+'-'+curStr, eval-curNum, -curNum)\n                                → Decision: op == '*'\n                                    Yes → Step: DFS(i+1, expr+'*'+curStr, eval-last+last*curNum, last*curNum)\nEnd\n\nBut we must ensure each line ends with explanation. Provide arrow for recursion lines. Use \"Decision:\" and \"Yes →\", \"No →\" with indentation. Use \"Step:\" lines for actions. Each line must follow format: \"虛擬碼步驟 // 解釋\".\n\nMake sure each line includes arrow symbol when appropriate. Example: \"→ Decision: 若 pos 等於長度 num?\" etc. For loops and decisions, use indentation as example given: they used indented lines after Decision.\n\nWe must produce final answer only with lines, not other commentary. Each line separate. Provide indent for nested lines? The example uses indentation for nested lines: \"    Yes → Step 2: ...\" So we should mimic. Use four spaces indent.\n\nLet's craft lines. Ensure consistent syntax.\n\nWe'll use simplified wording: \"Step:\" for actions. Provide short explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 num 與目標值 target // 讀取參數\n→ Step 2: 建立空列表 results // 用來儲存符合條件的表達式\n→ Step 3: 呼叫遞迴函式 DFS(0, \"\", 0, 0) // 從第一個位元開始搜尋\n\n    Function DFS(pos, expr, eval, last) // pos: 目前處理位置，expr: 當前表達式，eval: 表達式目前值，last: 上一操作數（用於乘法調整）\n        → Decision: 若 pos 等於 len(num) ? // 所有數字都已處理\n            Yes → Decision: 若 eval 等於 target ? // 檢查是否達到目標\n                Yes → Step: 把 expr 加入 results // 符合條件，加入結果\n                No → Step: 回溯 // 不是目標值，返回上一層\n            No → Step: 循環選取子字串\n                → Loop i 從 pos 到 len(num)-1\n                    → Step: 取子字串 curStr = num[pos:i+1] // 目前考慮的數字片段\n                    → Decision: 若 curStr 開頭為 '0' 且長度 > 1 ? // 防止前導零\n                        Yes → Step: 跳過此子字串 // 無效片段\n                        No → Step: 把 curStr 轉為數字 curNum // 轉成整數\n                    → Decision: 若 pos == 0 ? // 第一個數字\n                        Yes → Step: DFS(i+1, curStr, curNum, curNum) // 無運算子，直接進入下一層\n                        No → Step: 為每個運算子嘗試\n                            → Decision: op == '+' ?\n                                Yes → Step: DFS(i+1, expr+'+'+curStr, eval+curNum, curNum) // 加法\n                            → Decision: op == '-' ?\n                                Yes → Step: DFS(i+1, expr+'-'+curStr, eval-curNum, -curNum) // 減法\n                            → Decision: op == '*' ?\n                                Yes → Step: DFS(i+1, expr+'*'+curStr, eval-last+last*curNum, last*curNum) // 乘法，調整前一次計算\nEnd // 程式結束\n\nBut need to match output format exactly: each line should contain \"虛擬碼步驟 // 解釋\". Indentation within nested lines should be with spaces. Use arrow for each step. Use \"Decision:\" lines.\n\nAlso need \"→\" arrow at start of each line. The example uses arrow at start of each step, but not at start of \"Start\". It uses \"Start // 程式開始執行\" without arrow. \"→\" for each step. \"Decision:\" lines start with arrow then \"Decision:\".\n\nWe can replicate.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 num 與目標值 target // 讀取參數\n→ Step 2: 建立空列表 results // 用來儲存符合條件的表達式\n→ Step 3: 呼叫遞迴函式 DFS(0, \"\", 0, 0) // 從第一個位元開始搜尋\n    → Function DFS(pos, expr, eval, last) // pos: 當前位置，expr: 目前表達式，eval: 目前計算值，last: 前一操作數\n        → Decision: 若 pos 等於 len(num) ? // 所有數字已處理\n            Yes → Decision: 若 eval 等於 target ? // 檢查是否符合目標\n                Yes → Step: 把 expr 加入 results // 成功加入結果\n                No  → Step: 回溯 // 不是目標值，返回上一層\n            No  → Step: 循環選取子字串\n                → Loop i 從 pos 到 len(num)-1\n                    → Step: 取子字串 curStr = num[pos:i+1] // 目前考慮的數字片段\n                    → Decision: 若 curStr 開頭為 '0' 且長度 > 1 ? // 防止前導零\n                        Yes → Step: 跳過此子字串 // 無效片段\n                        No  → Step: 把 curStr 轉為數字 curNum // 轉成整數\n                    → Decision: 若 pos == 0 ? // 第一個數字\n                        Yes → Step: DFS(i+1, curStr, curNum, curNum) // 無運算子，直接進入下一層\n                        No  → Step: 為每個運算子嘗試\n                            → Decision: op == '+' ?\n                                Yes → Step: DFS(i+1, expr+'+'+curStr, eval+curNum, curNum) // 加法\n                            → Decision: op == '-' ?\n                                Yes → Step: DFS(i+1, expr+'-'+curStr, eval-curNum, -curNum) // 減法\n                            → Decision: op == '*' ?\n                                Yes → Step: DFS(i+1, expr+'*'+curStr, eval-last+last*curNum, last*curNum) // 乘法調整\nEnd // 程式結束\n\nMake sure arrow lines start with \"→\". Indent lines inside Decision: with two spaces or four spaces? Example uses four spaces indent for nested lines. We'll keep four spaces indent after arrow? They used \"    Yes →\" inside decision. That means four spaces before \"Yes →\". So we can use four spaces indent before \"Yes →\". For \"Decision:\" line, no indent? It starts at level of function. So we need indent for nested lines inside Decision.\n\nLet's format exactly:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 num 與目標值 target // 讀取參數\n→ Step 2: 建立空列表 results // 用來儲存符合條件的表達式\n→ Step 3: 呼叫遞迴函式 DFS(0, \"\", 0, 0) // 從第一個位元開始搜尋\n    → Function DFS(pos, expr, eval, last) // pos: 當前位置，expr: 目前表達式，eval: 目前計算值，last: 前一操作數\n        → Decision: 若 pos 等於 len(num) ? // 所有數字已處理\n            Yes → Decision: 若 eval 等於 target ? // 檢查是否符合目標\n                Yes → Step: 把 expr 加入 results // 成功加入結果\n                No  → Step: 回溯 // 不是目標值，返回上一層\n            No  → Step: 循環選取子字串\n                → Loop i 從 pos 到 len(num)-1\n                    → Step: 取子字串 curStr = num[pos:i+1] // 目前考慮的數字片段\n                    → Decision: 若 curStr 開頭為 '0' 且長度 > 1 ? // 防止前導零\n                        Yes → Step: 跳過此子字串 // 無效片段\n                        No  → Step: 把 curStr 轉為數字 curNum // 轉成整數\n                    → Decision: 若 pos == 0 ? // 第一個數字\n                        Yes → Step: DFS(i+1, curStr, curNum, curNum) // 無運算子，直接進入下一層\n                        No  → Step: 為每個運算子嘗試\n                            → Decision: op == '+' ?\n                                Yes → Step: DFS(i+1, expr+'+'+curStr, eval+curNum, curNum) // 加法\n                            → Decision: op == '-' ?\n                                Yes → Step: DFS(i+1, expr+'-'+curStr, eval-curNum, -curNum) // 減法\n                            → Decision: op == '*' ?\n                                Yes → Step: DFS(i+1, expr+'*'+curStr, eval-last+last*curNum, last*curNum) // 乘法調整\nEnd // 程式結束\n\nWe should ensure no extraneous spaces before arrow. Also each line includes the arrow and explanation.\n\nCheck \"Decision: 若 pos 等於 len(num) ?\" line: we need to maintain arrow before \"Decision:\"? Example uses \"→ Decision:\" at start of line. So we should have \"→ Decision:\" lines, not \"    → Decision:\"? Wait the example had:\n\n→ Decision: 如果數字大於 0? // ...\n    Yes → Step 2: ...\n\nThus we use \"→ Decision:\" lines at same indent level as other steps inside function. For nested inside decision, indent with 4 spaces then \"Yes →\". Good.\n\nThus inside function, we start with \"→ Decision:\" etc.\n\nNow we need to include indent for function header: \"→ Function DFS...\" inside Step 3. In example they did \"→ Step 1: ...\". For function, maybe we treat as \"→ Function DFS(...)\" as a step? But maybe we can just include \"→ Function DFS(...)\" as a step. In explanation, we can say it's a function definition. Ok.\n\nThus final answer. Ensure each line ends with // 解釋.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 num 與目標值 target // 讀取參數\n→ Step 2: 建立空列表 results // 用來儲存符合條件的表達式\n→ Step 3: 呼叫遞迴函式 DFS(0, \"\", 0, 0) // 從第一個位元開始搜尋\n    → Function DFS(pos, expr, eval, last) // pos: 當前位置，expr: 目前表達式，eval: 目前計算值，last: 前一操作數\n        → Decision: 若 pos 等於 len(num) ? // 所有數字已處理\n            Yes → Decision: 若 eval 等於 target ? // 檢查是否符合目標\n                Yes → Step: 把 expr 加入 results // 成功加入結果\n                No  → Step: 回溯 // 不是目標值，返回上一層\n            No  → Step: 循環選取子字串\n                → Loop i 從 pos 到 len(num)-1\n                    → Step: 取子字串 curStr = num[pos:i+1] // 目前考慮的數字片段\n                    → Decision: 若 curStr 開頭為 '0' 且長度 > 1 ? // 防止前導零\n                        Yes → Step: 跳過此子字串 // 無效片段\n                        No  → Step: 把 curStr 轉為數字 curNum // 轉成整數\n                    → Decision: 若 pos == 0 ? // 第一個數字\n                        Yes → Step: DFS(i+1, curStr, curNum, curNum) // 無運算子，直接進入下一層\n                        No  → Step: 為每個運算子嘗試\n                            → Decision: op == '+' ?\n                                Yes → Step: DFS(i+1, expr+'+'+curStr, eval+curNum, curNum) // 加法\n                            → Decision: op == '-' ?\n                                Yes → Step: DFS(i+1, expr+'-'+curStr, eval-curNum, -curNum) // 減法\n                            → Decision: op == '*' ?\n                                Yes → Step: DFS(i+1, expr+'*'+curStr, eval-last+last*curNum, last*curNum) // 乘法調整\nEnd // 程式結束"
    },
    {
      "title": "Time Based Key-Value Store",
      "source_file": "Leetcode/leetcode981.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]'\nGot (Norm):      '[None,None,\"bar\",\"bar\",None,\"bar2\",\"bar2\"]'\n--- (Raw) ---\nRaw Expected: '[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]'\nRaw Got:      \"[None, None, 'bar', 'bar', None, 'bar2', 'bar2']\""
        }
      ],
      "generated_code": "import sys\nimport json\nimport bisect\nfrom collections import defaultdict\n\nclass TimeMap:\n    def __init__(self):\n        # 每個 key 對應一個時間戳和值的有序列表\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        # 直接把 (timestamp, value) 加到對應 key 的列表中\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 會回傳第一個 > (timestamp, chr(127)) 的索引\n        # chr(127) 為 ASCII 中的最高可打印字符，確保不被任何值截斷\n        idx = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if idx == 0:\n            return \"\"\n        return arr[idx - 1][1]\n\ndef main() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # 將輸入包裝成一個 JSON 陣列：[[ops], [args]]\n    data = json.loads('[' + raw + ']')\n    ops, args_list = data[0], data[1]\n\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"TimeMap\":\n            obj = TimeMap()\n            res.append(None)          # 代表 null\n        elif op == \"set\":\n            obj.set(*args)\n            res.append(None)\n        elif op == \"get\":\n            res.append(obj.get(*args))\n        else:\n            res.append(None)\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described TimeMap data structure.\n\nWe need to output line by line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows: Start, →, Decision, End.\n\nWe must not output actual code. Just steps.\n\nGoal: design data structure, initialization, set, get with binary search.\n\nSteps: initialize a map from key to list of (timestamp, value). For set, append. For get, if key not exist return \"\". Else binary search list to find rightmost timestamp <= given. Return value if found else \"\".\n\nLet's produce pseudocode:\n\nStart\n\n→ Step 1: Initialize an empty dictionary KeyMap // 存儲每個 key 對應的時間戳和值列表\n\n→ Step 2: Define Class TimeMap // 定義 TimeMap 類\n\n   → Step 3: Define Constructor: TimeMap() // 構造函數\n       → Step 4: Set KeyMap = empty dictionary // 初始化字典\n\n   → Step 5: Define Method set(key, value, timestamp) // 存儲 key-value\n       → Step 6: If key not in KeyMap then KeyMap[key] = empty list // 創建列表\n       → Step 7: Append (timestamp, value) to KeyMap[key] // 添加新時間戳和值\n\n   → Step 8: Define Method get(key, timestamp) // 取得值\n       → Step 9: If key not in KeyMap then Return \"\" // 若 key 不存在\n       → Step 10: Let records = KeyMap[key] // 取得該 key 的列表\n       → Step 11: If records empty then Return \"\" // 安全檢查\n       → Step 12: Perform binary search on records for largest index with timestamp <= given\n           → Step 13: If found then Return records[index].value else Return \"\" // 根據搜尋結果\n\n→ End\n\nBut need to use Decision and arrows. Also each line with explanation.\n\nLet's craft each step with proper format.\n\nUse \"Start\" line, \"End\". Use \"Decision:\" lines with Yes →, No →.\n\nWe need to break down binary search into decisions.\n\nExample:\n\n→ Decision: Is timestamp <= records[mid].timestamp? // 判斷二分搜索條件\n\nWe can outline binary search steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize empty dictionary KeyMap // 建立一個空字典來存放 key 與其時間戳和值的列表  \n→ Step 2: Define Class TimeMap // 定義 TimeMap 類別  \n    → Step 3: Constructor TimeMap() // 建構子，用來初始化資料結構  \n        → Step 4: Set KeyMap = empty dictionary // 將 KeyMap 置為空字典  \n    → Step 5: Method set(key, value, timestamp) // 設定 key 的值及時間戳  \n        → Step 6: Decision: key 存於 KeyMap? // 檢查 key 是否已存在  \n            Yes → Step 7: No action // 已存在，直接跳至添加  \n            No  → Step 8: KeyMap[key] = empty list // 新建列表以存放時間戳與值  \n        → Step 9: Append (timestamp, value) to KeyMap[key] // 將新時間戳和值追加到列表  \n    → Step 10: Method get(key, timestamp) // 取得指定時間戳之前的最新值  \n        → Step 11: Decision: key 存於 KeyMap? // 檢查 key 是否存在  \n            No  → Step 12: Return \"\" // 若不存在直接回傳空字串  \n            Yes → Step 13: Let records = KeyMap[key] // 取得該 key 的列表  \n        → Step 14: Decision: records 為空? // 檢查列表是否有資料  \n            Yes → Step 15: Return \"\" // 若空，回傳空字串  \n            No  → Step 16: Perform binary search on records for largest timestamp <= query  \n                → Step 17: Set low = 0, high = length(records) - 1, resultIndex = -1 // 初始化二分搜尋變數  \n                → Step 18: While low <= high  \n                    → Step 19: mid = (low + high) // 2 // 計算中點  \n                    → Step 20: Decision: records[mid].timestamp <= timestamp? // 判斷是否可以往右移  \n                        Yes → Step 21: resultIndex = mid // 更新最近符合的索引  \n                        → Step 22: low = mid + 1 // 向右搜尋更大的時間戳  \n                        No  → Step 23: high = mid - 1 // 向左搜尋更小的時間戳  \n                → Step 24: Decision: resultIndex == -1? // 是否找到符合的時間戳  \n                    Yes → Step 25: Return \"\" // 沒找到符合，回傳空字串  \n                    No  → Step 26: Return records[resultIndex].value // 回傳找到的值  \nEnd // 程式執行結束"
    },
    {
      "title": "Count The Repetitions",
      "source_file": "Leetcode/leetcode466.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr7l7bvcw.py\", line 78, in <module>\n    s1, n1, s2, n2 = parse_input(raw)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpr7l7bvcw.py\", line 71, in parse_input\n    n1 = int(tokens[1])\n         ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqfp89wg0.py\", line 78, in <module>\n    s1, n1, s2, n2 = parse_input(raw)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqfp89wg0.py\", line 71, in parse_input\n    n1 = int(tokens[1])\n         ^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '='"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\ndef get_max_repetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    \"\"\"Return the maximum integer m such that [s2, m] is a subsequence of [s1, n1].\"\"\"\n    if n1 == 0:\n        return 0\n\n    # Record state after each full s1 consumption: {s2_index: (count_s1, count_s2)}\n    recall = {}\n    s1_count = s2_count = 0\n    s2_index = 0  # current position in s2\n\n    while s1_count < n1:\n        # consume one whole s1\n        for ch in s1:\n            if ch == s2[s2_index]:\n                s2_index += 1\n                if s2_index == len(s2):\n                    s2_index = 0\n                    s2_count += 1\n        s1_count += 1\n\n        # If we have seen this s2_index before, a cycle is found\n        if s2_index in recall:\n            prev_s1, prev_s2 = recall[s2_index]\n            # Numbers before the cycle starts\n            pre_loop_s1, pre_loop_s2 = prev_s1, prev_s2\n            # Numbers inside one cycle\n            cycle_s1 = s1_count - prev_s1\n            cycle_s2 = s2_count - prev_s2\n            break\n        else:\n            recall[s2_index] = (s1_count, s2_count)\n    else:\n        # No cycle detected – all s1 blocks were processed\n        return s2_count // n2\n\n    # Use the cycle to jump ahead\n    result = pre_loop_s2\n    remaining_s1 = n1 - pre_loop_s1\n    cycles = remaining_s1 // cycle_s1\n    result += cycles * cycle_s2\n    s1_count = pre_loop_s1 + cycles * cycle_s1\n\n    # Process the remaining s1 blocks after the cycles\n    for _ in range(n1 - s1_count):\n        for ch in s1:\n            if ch == s2[s2_index]:\n                s2_index += 1\n                if s2_index == len(s2):\n                    s2_index = 0\n                    result += 1\n\n    return result // n2\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form:\n       s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n    \"\"\"\n    strings = re.findall(r'\"([^\"]+)\"', data)\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(strings) == 2 and len(numbers) == 2:\n        s1, s2 = strings\n        n1, n2 = numbers\n        return s1, n1, s2, n2\n    # Fallback: assume order s1 s2 n1 n2\n    tokens = data.strip().split()\n    s1 = tokens[0]\n    n1 = int(tokens[1])\n    s2 = tokens[2]\n    n2 = int(tokens[3])\n    return s1, n1, s2, n2\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s1, n1, s2, n2 = parse_input(raw)\n    ans = get_max_repetitions(s1, n1, s2, n2)\n    print(ans)",
      "virtual_code": "Thinking...\nWe need produce pseudocode steps. We should design algorithm: find maximum m such that str2 repeated m times can be subsequence of str1 repeated n1 times. Classic Leetcode 466? Actually problem 466? Wait 466 is count of subsequence? This is \"Maximum Number of Repetitions\" Leetcode 466? Actually it's 466? Let's recall. Problem: maximum number of repetitions of t2 within t1 repeated n1 times. The algorithm uses mapping of indices after consuming one s2. Use cycle detection.\n\nWe need produce virtual code steps line by line with comments.\n\nLet's design steps:\n\nStart\n→ Input s1, n1, s2, n2\n→ Initialize idx1 = 0, idx2 = 0, count = 0, record = {} // map idx2 to [idx1, count]\n→ While idx1 < n1:\n    → For each character c in s1:\n        → If c == s2[idx2]: idx2 +=1\n            → If idx2 == n2: count +=1; idx2 = 0\n    → idx1 +=1\n    → If idx2 in record:\n        → (prevIdx1, prevCount) = record[idx2]\n        → cycleLen = idx1 - prevIdx1\n        → cycleCount = count - prevCount\n        → remaining = n1 - idx1\n        → numCycles = remaining // cycleLen\n        → count += numCycles * cycleCount\n        → idx1 += numCycles * cycleLen\n    → Else:\n        → record[idx2] = [idx1, count]\n→ Return count // max m\n\nBut we need maximum integer m such that str2 repeated m times can be obtained from str1. The algorithm returns count.\n\nWe need to produce pseudocode with steps and comments. Also use arrow structure.\n\nLet's produce as per format:\n\nStart // start program\n→ Input s1, n1, s2, n2 // 取得輸入值\n→ Set i = 0, j = 0, result = 0 // i 追蹤 str1 的重複次數, j 追蹤 s2 的索引, result 為已完成的 str2 次數\n→ Create empty map visited // 用於記錄 j 位置與當前 i, result 的對應\n→ While i < n1: // 只處理 str1 重複次數\n    → For each char c in s1: // 遍歷 s1 的每個字符\n        → If c == s2[j]: // 匹配成功\n            → j += 1\n            → If j == n2: // 完成一個 s2\n                → result += 1\n                → j = 0\n    → i += 1\n    → If j in visited: // 循環檢測\n        → (prevI, prevResult) = visited[j]\n        → cycleI = i - prevI\n        → cycleRes = result - prevResult\n        → remainingI = n1 - i\n        → cycles = remainingI // cycleI\n        → result += cycles * cycleRes\n        → i += cycles * cycleI\n    → Else:\n        → visited[j] = (i, result)\n→ Return result // 最終最大 m\n\nMake sure arrow indentation and formatting as required: Each line \"虛擬碼步驟 // 解釋\". Use arrows. Use indentation for nested decisions. Ensure we follow format: Start, → Step, Decision: etc.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input s1, n1, s2, n2 // 取得輸入值\n→ Set i = 0, j = 0, result = 0 // i 為已處理的 str1 次數，j 為 s2 中的索引，result 為完成的 str2 次數\n→ Create empty map visited // 用於記錄每個 j 位置所對應的 (i, result)\n→ While i < n1: // 只在 str1 的重複次數內迴圈\n    → For each char c in s1: // 逐個檢查 s1 的字符\n        → If c == s2[j]: // 若字符匹配\n            → j += 1 // 移至 s2 的下一個索引\n            → If j == n2: // 完成一次 s2\n                → result += 1 // 記錄一次完成\n                → j = 0 // 重置為 s2 開頭\n    → i += 1 // 結束本次 str1 的一個重複\n    → Decision: 如果 j 在 visited 中? // 檢測是否出現循環\n        Yes → (prevI, prevResult) = visited[j]\n            → cycleI = i - prevI // 循環的 i 長度\n            → cycleRes = result - prevResult // 循環內增加的 result 數量\n            → remainingI = n1 - i // 尚未處理的 str1 次數\n            → cycles = remainingI // cycleI // 可以跳過的循環數\n            → result += cycles * cycleRes // 直接加上所有循環的結果\n            → i += cycles * cycleI // 跳過這些循環的 i\n        No  → visited[j] = (i, result) // 記錄當前 j 的狀態\n→ Return result // 最大 m，表示可以從 str1 取得 [str2, m] 的次數\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzma7ep20.py\", line 80, in <module>\n    main()\n  File \"/tmp/tmpzma7ep20.py\", line 53, in main\n    commands = ast.literal_eval(commands_str)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Subscript object at 0x756ee3d0d010>"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented using two queues.\"\"\"\n    def __init__(self):\n        self.q1 = deque()   # primary queue\n        self.q2 = deque()   # secondary queue\n\n    def push(self, x):\n        \"\"\"Push element x onto stack.\"\"\"\n        self.q1.append(x)\n\n    def pop(self):\n        \"\"\"Remove the element on top of the stack and return it.\"\"\"\n        # Move all elements except the last one to q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # The last element is the top of the stack\n        top_elem = self.q1.popleft()\n        # Swap queues to restore state\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def top(self):\n        \"\"\"Get the top element of the stack.\"\"\"\n        # Move all elements except the last one to q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        # Peek at the last element\n        top_elem = self.q1.popleft()\n        # Put it back into q2\n        self.q2.append(top_elem)\n        # Swap queues to restore state\n        self.q1, self.q2 = self.q2, self.q1\n        return top_elem\n\n    def empty(self):\n        \"\"\"Return True if stack is empty, False otherwise.\"\"\"\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into two lists: commands and arguments\n    idx = data.find('],')\n    commands_str = data[:idx+1]\n    args_str = data[idx+2:].strip()\n    commands = ast.literal_eval(commands_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    stack = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"MyStack\":\n            stack = MyStack()\n            results.append(None)          # constructor has no return value\n        elif cmd == \"push\":\n            stack.push(arg[0])\n            results.append(None)          # push returns nothing\n        elif cmd == \"pop\":\n            results.append(stack.pop())\n        elif cmd == \"top\":\n            results.append(stack.top())\n        elif cmd == \"empty\":\n            results.append(stack.empty())\n        else:\n            # Unsupported command; append None\n            results.append(None)\n\n    # Output results in JSON format (null, true, false)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. The requirement: LIFO stack using two queues. Provide steps for MyStack class with methods push, pop, top, empty. Use two queues: q1 and q2. Approach: for push, enqueue to q1. For pop/top, need to move all except last element from q1 to q2, then pop/peek that last element, then swap q1 and q2. Could also optimize push to O(1) by pushing to q2 and then moving all from q1 to q2. But typical approach: push O(n). We'll choose simpler: push to q1, pop/top move elements.\n\nWe need virtual code: Start, Step: push, etc. Should be line by line with explanation.\n\nWe'll produce a pseudocode for class MyStack with methods. Use decision structure. Provide virtual code with arrow. Each line has explanation. We'll format like example.\n\nLet's produce:\n\nStart // 開始初始化\n→ Step 1: 建立兩個空佇列 q1, q2 // 初始化兩個佇列\nEnd // 結束初始化\n\nBut need separate for class. Maybe start of class. But the requirement is to output virtual code for the implementation. Provide all steps. We'll produce as code block.\n\nMake sure each line includes: 虛擬碼步驟 + space + // 解釋.\n\nUse arrows: Start, End, Decision, etc.\n\nWe'll produce code:\n\nStart // 開始定義 MyStack\n→ Step 1: Declare queue q1, q2 // 初始化兩個佇列\n→ Decision: 當調用 push(x) 時? // 處理 push\n    Yes → Step 2: q1.enqueue(x) // 將 x 加到 q1 的尾部\n→ Decision: 當調用 pop() 時? // 處理 pop\n    Yes → Step 3: While q1.size() > 1: q2.enqueue(q1.dequeue()) // 移動除最後一個以外的所有元素\n    → Step 4: topElement = q1.dequeue() // 移除並取得頂部元素\n    → Step 5: Swap(q1, q2) // 交換兩個佇列，恢復為原始狀態\n    → Step 6: Return topElement // 回傳彈出的元素\n→ Decision: 當調用 top() 時? // 處理 top\n    Yes → Step 7: While q1.size() > 1: q2.enqueue(q1.dequeue()) // 移動除最後一個以外的所有元素\n    → Step 8: topElement = q1.dequeue() // 取出頂部元素但不移除\n    → Step 9: q2.enqueue(topElement) // 把頂部元素重新放回 q2\n    → Step 10: Swap(q1, q2) // 交換兩個佇列，恢復為原始狀態\n    → Step 11: Return topElement // 回傳頂部元素\n→ Decision: 當調用 empty() 時? // 處理 empty\n    Yes → Step 12: Return q1.isEmpty() // 判斷 q1 是否空\nEnd // 結束 MyStack\n\nBut we need to ensure each line has virtual code with arrow and explanation. We must include \"Start\" and \"End\". We also need to incorporate Decision: lines. Let's format each line carefully.\n\nAlso we need to show \"→\" arrow at start of step lines.\n\nLet's produce as code block. Ensure each line has explanation after //.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 開始定義 MyStack\n→ Step 1: Declare queue q1, q2 // 初始化兩個佇列\n→ Decision: 如果調用 push(x) 時? // 判斷是否要執行 push\n    Yes → Step 2: q1.enqueue(x) // 將 x 加入 q1 的尾部\n→ Decision: 如果調用 pop() 時? // 判斷是否要執行 pop\n    Yes → Step 3: While q1.size() > 1: q2.enqueue(q1.dequeue()) // 把除最後一個以外的所有元素移到 q2\n    → Step 4: topElement = q1.dequeue() // 取出並移除 q1 的最後一個元素（即堆疊頂部）\n    → Step 5: Swap(q1, q2) // 交換兩個佇列，恢復為原始狀態\n    → Step 6: Return topElement // 回傳彈出的元素\n→ Decision: 如果調用 top() 時? // 判斷是否要執行 top\n    Yes → Step 7: While q1.size() > 1: q2.enqueue(q1.dequeue()) // 把除最後一個以外的所有元素移到 q2\n    → Step 8: topElement = q1.dequeue() // 取出 q1 的最後一個元素（即堆疊頂部）\n    → Step 9: q2.enqueue(topElement) // 把頂部元素重新放回 q2，保持堆疊不變\n    → Step 10: Swap(q1, q2) // 交換兩個佇列，恢復為原始狀態\n    → Step 11: Return topElement // 回傳頂部元素\n→ Decision: 如果調用 empty() 時? // 判斷是否要執行 empty\n    Yes → Step 12: Return q1.isEmpty() // 判斷 q1 是否空（整個堆疊是否空）\nEnd // 結束 MyStack\n```"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表和入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填充圖和入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 以入度為 0 的節點開始排程\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 如果所有課程都已排完，回傳順序；否則回傳空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 numCourses 與 prerequisites。\n    支援兩種常見格式：\n    1. 'numCourses = 2, prerequisites = [[1,0]]'\n    2. 兩行分開：第一行是數字，第二行是列表。\n    \"\"\"\n    data = data.strip()\n    # 嘗試使用正則表達式抽取\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    prereq_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data, re.S)\n\n    if num_match and prereq_match:\n        numCourses = int(num_match.group(1))\n        prerequisites = eval(prereq_match.group(1))\n        return numCourses, prerequisites\n\n    # 若第一種方式失敗，嘗試兩行分開的格式\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        try:\n            numCourses = int(lines[0])\n            prerequisites = eval(lines[1])\n            return numCourses, prerequisites\n        except Exception:\n            pass\n\n    # 如果仍然無法解析，拋出錯誤\n    raise ValueError(\"無法解析輸入格式\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        numCourses, prerequisites = parse_input(raw_input)\n    except Exception:\n        # 直接嘗試 eval 整個輸入\n        try:\n            data = eval(raw_input.strip())\n            numCourses, prerequisites = data[0], data[1]\n        except Exception:\n            print(\"[]\")\n            sys.exit(0)\n\n    sol = Solution()\n    result = sol.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for topological sorting Kahn's algorithm. Provide line by line with explanation. Use Start, End, Decision. Use arrow notation. Provide steps: build graph adjacency list, indegree array, queue of zero indegree, result list. While queue not empty: pop, add to result, for each neighbor reduce indegree, if becomes zero add to queue. After loop, if result length equals numCourses return result else empty.\n\nWe must use simplified pseudocode. Each line: \"Start // ...\" etc. Provide lines. Use indentation? In sample they didn't indent further lines under decisions; just indent with spaces maybe. Provide decisions as \"Decision: ...\" lines.\n\nWe need to ensure each line has arrow \"→\" before the step, except Start and End. Provide each step with explanation. We'll produce about maybe 20 lines.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的鄰接表 graph[0..numCourses-1] // 用來記錄每門課程的後續課程  \n→ Step 2: 建立 indegree[0..numCourses-1] 初始化為 0 // 记录每门课的前置课程数量  \n→ Step 3: 遍歷 prerequisites  \n  → Step 3.1: 取 (a, b) // a 需要先修的 b  \n  → Step 3.2: graph[b].add(a) // 在 b 的鄰接表加入 a  \n  → Step 3.3: indegree[a] += 1 // a 的前置課程數量加一  \n→ Step 4: 建立空佇列 queue  \n→ Step 5: 遍歷 0..numCourses-1  \n  → Decision: indegree[i] 為 0? // 是否沒有前置課程  \n   Yes → Step 5.1: queue.enqueue(i) // 可以立刻修的課程加入佇列  \n   No → Step 5.2: // 跳過  \n→ Step 6: 建立空列表 result // 存放課程修習順序  \n→ Decision: queue 非空? // 仍有可修的課程  \n  Yes → Step 6.1: course = queue.dequeue() // 取一門課程  \n   → Step 6.2: result.append(course) // 加入修習順序  \n   → Step 6.3: 遍歷 graph[course] 中的每個 neighbour  \n     → Step 6.3.1: indegree[neighbour] -= 1 // 前置課程數量減一  \n      → Decision: indegree[neighbour] 為 0? // 是否剩下的課程可修  \n       Yes → Step 6.3.2: queue.enqueue(neighbour) // 加入佇列  \n       No → Step 6.3.3: // 跳過  \n    → Step 6.4: Decision: queue 非空? // 重新檢查佇列  \n     Yes → Step 6.5: 跳回 Step 6.1  \n     No → Step 6.6: // 佇列已空，結束循環  \n  No → Step 6.7: // 佇列一開始就空，直接跳過循環  \n→ Decision: result.length == numCourses? // 是否所有課程都已安排  \n  Yes → Step 7: return result // 回傳一個有效的修習順序  \n  No → Step 7.1: return [] // 形成循環，無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[[\"hit\",\"hit\",\"hot\",\"dot\",\"dog\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      \"[['hit', 'hit', 'hot', 'dot', 'dog']]\""
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS 以找到最短距離，並紀錄每個單詞的前驅節點\n        layer = {beginWord: 0}\n        parents = defaultdict(set)\n\n        queue = deque([beginWord])\n        found_end = False\n        while queue and not found_end:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].add(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].add(word)\n                        if new_word == endWord:\n                            found_end = True\n\n        if not found_end:\n            return []\n\n        # DFS 從 endWord 回溯至 beginWord，構造所有最短路徑\n        res = []\n\n        def dfs(curr, path):\n            if curr == beginWord:\n                res.append([beginWord] + path[::-1])\n                return\n            for prev in parents[curr]:\n                dfs(prev, path + [prev])\n\n        dfs(endWord, [])\n        return res\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串解析 beginWord, endWord, wordList。\"\"\"\n    begin_match = re.search(r'beginWord\\s*=\\s*\"([^\"]+)\"', data)\n    end_match = re.search(r'endWord\\s*=\\s*\"([^\"]+)\"', data)\n    list_match = re.search(r'wordList\\s*=\\s*(\\[.*\\])', data, re.S)\n\n    if not begin_match or not end_match or not list_match:\n        raise ValueError(\"輸入格式不正確\")\n\n    beginWord = begin_match.group(1)\n    endWord = end_match.group(1)\n    wordList = ast.literal_eval(list_match.group(1))\n    return beginWord, endWord, wordList\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    beginWord, endWord, wordList = parse_input(raw)\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code for finding all shortest transformation sequences. Use BFS to build levels, then DFS/backtracking or BFS path reconstruction. The output virtual code should be step-by-step with explanation. Must be in Traditional Chinese. Use arrow syntax: →, Yes →, No →. Use Start, End, Decision: etc. Each line: virtual code step + space + // explanation. Let's design algorithm:\n\nStart\n→ Step 1: Initialize adjacency dictionary by grouping words by intermediate patterns (like replace each letter with '*') // Build pattern map for quick neighbor lookup\n→ Step 2: Initialize queue with beginWord // BFS queue\n→ Step 3: Initialize visited set with beginWord // Mark visited at level\n→ Step 4: Initialize distance map with beginWord -> 0 // Level tracking\n→ Step 5: Initialize parents map (word -> set of previous words) // For path reconstruction\n→ Decision: while queue not empty? // BFS loop\n    Yes →\n        → Step 6: Pop current word from queue\n        → Step 7: For each letter position i in current word\n            → Step 8: Create intermediate pattern by replacing i with '*'\n            → Step 9: For each neighbor in pattern map[pattern]\n                → Decision: neighbor not visited? // first encounter at this level\n                    Yes →\n                        → Step 10: Set distance[neighbor] = distance[current] + 1\n                        → Step 11: Add neighbor to parents[neighbor] as current\n                        → Step 12: Add neighbor to queue\n                        → Step 13: Add neighbor to visited set\n                    No →\n                        → Decision: distance[neighbor] == distance[current] + 1? // same level\n                            Yes →\n                                → Step 14: Add current to parents[neighbor] // another parent\n                            No →\n                                → Step 15: Skip // deeper level\n        → Decision: current == endWord? // found target\n            Yes →\n                → Step 16: Mark foundEnd = true // to stop after this level\n            No →\n                → Step 17: Continue // keep BFS\n    No →\n        → Step 18: End BFS\n\nAfter BFS, if not foundEnd return empty\n\nElse reconstruct all paths via DFS from endWord to beginWord using parents map\n\n→ Step 19: Initialize result list // store all sequences\n→ Step 20: Define recursive function dfs(word, path)\n    → Decision: word == beginWord?\n        Yes →\n            → Step 21: Append reverse of path + beginWord to result // build sequence\n        No →\n            → Step 22: For each parent in parents[word]\n                → Step 23: Call dfs(parent, path + [word]) // prepend path\n\n→ Step 24: Call dfs(endWord, [])\n→ End // done\n\nNeed to format each line with virtual code and explanation. Use arrow '→' for actions. Use 'Decision:' lines with Yes/No. Must include space between virtual code and // explanation. Each line separate.\n\nLet's craft.\n\nNeed to start with Start // 程式開始執行\n\nThen each step as described.\n\nEnsure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化模式字典（patternMap）用於快速查找相鄰單詞 // 建立字典，鍵為中間模式，值為對應單詞集合  \n→ Step 2: 初始化 BFS 隊列 queue，加入 beginWord // 從起始單詞開始廣度優先搜索  \n→ Step 3: 初始化已訪問集合 visited，加入 beginWord // 標記已處理的單詞  \n→ Step 4: 初始化距離字典 dist，設定 beginWord -> 0 // 記錄每個單詞的最短距離  \n→ Step 5: 初始化父親映射 parents，為每個單詞設定空集合 // 用於後續路徑回溯  \n→ Decision: queue 是否非空? // 進入 BFS 主循環  \n    Yes →  \n        → Step 6: 從 queue 取出當前單詞 current // 取出待處理單詞  \n        → Step 7: 對 current 的每個字母位置 i  \n            → Step 8: 建立中間模式 pattern = current[0:i] + '*' + current[i+1:] // 替換第 i 個字母為 *  \n            → Step 9: 對 patternMap[pattern] 中的每個相鄰單詞 neighbor  \n                → Decision: neighbor 是否未訪問?  \n                    Yes →  \n                        → Step 10: 設定 dist[neighbor] = dist[current] + 1 // 記錄距離  \n                        → Step 11: parents[neighbor].add(current) // 設定父親  \n                        → Step 12: 將 neighbor 加入 queue // 排入下一層  \n                        → Step 13: 將 neighbor 加入 visited // 標記已訪問  \n                    No →  \n                        → Decision: dist[neighbor] == dist[current] + 1?  \n                            Yes →  \n                                → Step 14: parents[neighbor].add(current) // 同層又找到父親  \n                            No →  \n                                → Step 15: 跳過 // 已在更深層，忽略  \n        → Decision: current == endWord? // 找到目標單詞  \n            Yes →  \n                → Step 16: 設定 foundEnd = True // 標記已完成所有最短層  \n            No →  \n                → Step 17: 繼續 BFS // 仍有單詞待處理  \n    No →  \n        → Step 18: BFS 結束 // 所有層已處理  \n→ Decision: foundEnd 為 True? // 是否存在至少一條路徑  \n    Yes →  \n        → Step 19: 初始化結果列表 result = [] // 用於存儲所有最短路徑  \n        → Step 20: 定義遞迴函式 dfs(word, path)  \n            → Decision: word == beginWord?  \n                Yes →  \n                    → Step 21: result.append([beginWord] + path[::-1]) // 逆序拼接得到完整路徑  \n                No →  \n                    → Step 22: 對 parents[word] 中的每個 parent  \n                        → Step 23: dfs(parent, path + [word]) // 深度優先回溯  \n        → Step 24: dfs(endWord, []) // 從結尾單詞開始回溯  \n        → Step 25: 返回 result // 傳回所有最短變換序列  \n    No →  \n        → Step 26: 返回 [] // 無任何可達路徑  \nEnd // 程式執行結束"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '98'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '98'"
        }
      ],
      "generated_code": "class Solution:\n    def singleNumber(self, nums):\n        \"\"\"\n        找到只出現一次的元素。使用兩個位掩碼 ones 與 twos\n        來追蹤每一位出現 1 次或 2 次的狀態。當某一位同時\n        出現在 ones 與 twos 時，代表已經出現三次，會被清除。\n        \"\"\"\n        ones, twos = 0, 0\n        for num in nums:\n            # 更新兩次出現的位\n            twos |= ones & num\n            # 更新一次出現的位\n            ones ^= num\n            # 清除出現三次的位\n            ones &= ~twos\n        return ones\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    data = sys.stdin.read().strip()\n    nums = []\n\n    if data:\n        # 只取第一個 '[' 之後到第一個 ']' 的內容\n        l = data.find('[')\n        r = data.find(']', l)\n        if l != -1 and r != -1:\n            inside = data[l + 1 : r]\n            if inside.strip():\n                # 以逗號分割，並轉為整數\n                nums = [int(x.strip()) for x in inside.split(',')]\n\n    solution = Solution()\n    result = solution.singleNumber(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with steps. Use bit manipulation: count bits mod 3. Pseudocode: use two variables ones, twos. For each num: twos |= ones & num; ones ^= num; ones &= ~twos; End. Return ones. Explain each. Also include Start, End. Use Decision? Not needed. But maybe we can add decision for each iteration? Keep simple. Provide line per operation. We must use \"→\" arrow. Let's produce:\n\nStart\n→ Step 1: 初始化 ones = 0, twos = 0 // 两个位掩码\n→ Step 2: 遍历 nums 中每个 num // 逐个处理\n    → Step 2.1: twos = twos OR (ones AND num) // 更新出现两次的位\n    → Step 2.2: ones = ones XOR num // 更新出现一次的位\n    → Step 2.3: ones = ones AND NOT twos // 清除出现三次的位\n→ Step 3: 返回 ones // ones 即为唯一出现的元素\nEnd\n\nBut we need to use \"Decision:\" maybe optional. We can include Decision for end? not necessary. But ensure formatting. Provide one line per step. Use indent for sub-steps? Format example uses indentation. We'll follow. Use \"→\" arrow and indentation. Provide explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ones ← 0, twos ← 0 // 建立兩個位掩碼，分別記錄出現一次和兩次的位  \n→ Step 2: For each num in nums // 逐個遍歷陣列  \n    → Step 2.1: twos ← twos OR (ones AND num) // 先將已出現一次且現在再次出現的位加入 twos  \n    → Step 2.2: ones ← ones XOR num // 更新 ones，將 num 的位翻轉（若已在 ones，則消除）  \n    → Step 2.3: ones ← ones AND NOT twos // 清除已在 twos 中的位，確保三次出現的位被移除  \n→ Step 3: Return ones // ones 中剩下的位即為只出現一次的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.6100488095710334,0.39145816139613504],[0.7579935503568103,-0.37289444162719376],[-0.8975493133467657,0.22628735832240052]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.6100488095710334, 0.39145816139613504], [0.7579935503568103, -0.37289444162719376], [-0.8975493133467657, 0.22628735832240052]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 用極座標生成均勻隨機點\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    results = []\n    obj = None\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            obj = Solution(*args[i])\n            results.append(None)          # constructor returns null\n        else:\n            method = getattr(obj, op)\n            result = method()\n            results.append(result)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step with comments, following format.\n\nWe need to implement a solution that generates uniform random point inside circle. The standard approach: sample r = sqrt(random()) * radius, theta = random()*2π, then x = x_center + r*cos(theta), y = y_center + r*sin(theta). So we will produce virtual code.\n\nWe must produce lines: Start, then constructor, etc. Virtual code lines like: \"Solution(double radius, double x_center, double y_center) // ...\" etc.\n\nWe need to show decision? But maybe not necessary. Just algorithm steps.\n\nWe will produce:\n\nStart // program start\n→ Step 1: Store radius, x_center, y_center // init object\n→ Step 2: Generate u1=random() in [0,1) // random\n→ Step 3: Generate u2=random() in [0,1) // random\n→ Step 4: Compute r = sqrt(u1) * radius // radius scaled to uniform\n→ Step 5: Compute theta = 2π * u2 // angle uniform\n→ Step 6: Compute x = x_center + r * cos(theta) // coordinate\n→ Step 7: Compute y = y_center + r * sin(theta) // coordinate\n→ Step 8: Return [x, y] // result\n\nWe need to show within class. Use Decision? Not necessary.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→ Constructor Solution(radius, x_center, y_center) // 初始化圓的半徑與中心\n→ End of Constructor // 建構完成\n→ Function randPoint() // 隨機產生點\n→ Decision: 產生兩個 0~1 的隨機數? // 需要兩個隨機數\n→ Step: u1 = random() // 第一個隨機數\n→ Step: u2 = random() // 第二個隨機數\n→ Step: r = sqrt(u1) * radius // 均勻分佈的半徑\n→ Step: theta = 2 * PI * u2 // 均勻分佈的角度\n→ Step: x = x_center + r * cos(theta) // 計算 x 座標\n→ Step: y = y_center + r * sin(theta) // 計算 y 座標\n→ Step: return [x, y] // 回傳點\nEnd // 程式結束\n\nWe should maintain format with \"虛擬碼步驟 [空格] // 解釋/說明\". Use Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義 Solution 類別  \n→ Constructor Solution(radius, x_center, y_center) // 初始化圓半徑與中心座標  \n→ End Constructor // 建構完成  \n→ Function randPoint() // 隨機產生圓內點  \n→ Decision: 需要兩個 0~1 的隨機數? // 用於生成半徑與角度  \n→ Step: u1 = random() // 第一個隨機數，範圍 [0,1)  \n→ Step: u2 = random() // 第二個隨機數，範圍 [0,1)  \n→ Step: r = sqrt(u1) * radius // 均勻分佈的半徑（轉換方式）  \n→ Step: theta = 2 * PI * u2 // 均勻分佈的角度  \n→ Step: x = x_center + r * cos(theta) // 計算 x 座標  \n→ Step: y = y_center + r * sin(theta) // 計算 y 座標  \n→ Step: return [x, y] // 回傳隨機點  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        Remove all occurrences of val from nums in-place.\n        Return the number of elements that are not equal to val.\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 抓取 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    # 抓取 val 整數\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not val_match:\n        return\n\n    nums_str = nums_match.group(1)\n    val = int(val_match.group(1))\n\n    # 直接 eval 讀取列表，限制執行環境\n    nums = eval(nums_str, {\"__builtins__\": None}, {})\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 準備輸出，前 k 個元素保持原樣，後面用 \"_\" 表示未使用位置\n    output_parts = [str(nums[i]) for i in range(k)]\n    output_parts += ['_' for _ in range(len(nums) - k)]\n\n    print(f\"{k}, nums = [{','.join(output_parts)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem. We must output step-by-step pseudocode lines, each with explanation comment. Must follow format exactly: each line has virtual code step + space + // explanation. Use arrows, Start, End, Decision: etc. Need to not output actual code. Should include Start, End. Steps: we need to remove all val in-place and return k.\n\nWe will use two pointers: left = 0; for right in range(len(nums)): if nums[right] != val: nums[left] = nums[right]; left += 1. After loop, k = left. Return k.\n\nLet's produce virtual steps line by line. Use Start, →, Decision:, Yes →, No →, End. Should not output actual code; just pseudocode steps. Let's write something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0 // 左指標指向下一個可接受位置\n→ Step 2: 從 i = 0 到 nums.length-1 迴圈遍歷 // 遍歷所有元素\n    → Decision: 如果 nums[i] 不等於 val? // 檢查元素是否要保留\n        Yes → Step 3: nums[left] = nums[i] // 將保留元素放到左指標位置\n              → Step 4: left = left + 1 // 移動左指標\n        No  → Step 5: 不執行任何操作 // 直接跳過該元素\n→ Step 6: k = left // k 為保留元素數量\n→ Step 7: 返回 k // 結束並返回結果\nEnd // 程式執行結束\n\nBut we need to follow arrow format exactly: For loops we might express as \"→ Step 2: For i in 0..len(nums)-1: ...\" But in pseudocode we need to show arrow then Step number etc. The example uses arrow before \"Step 1\". So for loops, maybe we use \"→ Step 2: For i from 0 to length(nums)-1 do\" then inside decision etc. Use indentation maybe.\n\nWe must maintain \"Decision:\" with Yes → and No → lines. Also we must use \"Start\" and \"End\".\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 left = 0 // 左指標指向下一個可接受位置  \n→ Step 2: For i from 0 to nums.length-1 do // 遍歷所有元素  \n  Decision: 如果 nums[i] 不等於 val? // 檢查元素是否要保留  \n   Yes → Step 3: nums[left] = nums[i] // 將保留元素放到左指標位置  \n    → Step 4: left = left + 1 // 移動左指標  \n   No  → Step 5: 直接跳過該元素 // 不做任何處理  \n→ Step 6: k = left // k 為保留元素數量  \n→ Step 7: 返回 k // 結束並返回結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,1,3],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 1, 3], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 保存原始陣列的複製，便於重置\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列的複製，確保不會被外部改動\n        return list(self.original)\n\n    def shuffle(self):\n        # 使用 Fisher‑Yates 洗牌演算法隨機打亂\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，格式為 (ops, args) 的兩個列表\n    ops, args = ast.literal_eval(data)\n    results = []\n    obj = None\n\n    for i, op in enumerate(ops):\n        if op == \"Solution\":\n            # args[i] 為包含原始陣列的一個列表\n            nums = args[i][0] if args[i] else []\n            obj = Solution(nums)\n            results.append(None)  # Solution 建構時返回 null\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem: design algorithm to randomly shuffle array, with reset. We need to output line by line: \"Start // 程式開始執行\" etc. Use arrows, Decision: etc. Provide each line with explanation. We'll produce a flow for initialization, reset, shuffle.\n\nWe need to include methods: constructor, reset, shuffle. The virtual code should illustrate logic: store original array, copy for shuffling, use Fisher-Yates.\n\nLet's produce lines.\n\nStart\n→ Step 1: 初始化 Solution 類別，存儲原始陣列 nums 的複製 // 將原始陣列備份以便重置\n→ Step 2: 建立內部陣列 currentArr 作為可變動的拷貝 // 供 shuffle 時使用\n→ Decision: 是否呼叫 reset? // 需要在 reset 時恢復原始陣列\n    Yes → Step 3: reset() // 回傳原始陣列的複製 // 重置\n    No → Decision: 是否呼叫 shuffle? // 隨機打亂\n        Yes → Step 4: shuffle() // Fisher–Yates 演算法\n            → Step 4a: 對 currentArr 執行 Fisher–Yates 迴圈 // 隨機交換每個元素\n            → Step 4b: 返回 currentArr // 回傳隨機排列\n        No → End // 若無操作則結束\n\nBut we need to show algorithm details: For shuffle, loop i from len-1 downto 1, pick random j between 0..i, swap arr[i] and arr[j].\n\nAlso reset returns original. So in Step 3: reset() // 生成原始陣列的複製\n\nLet's produce a more detailed virtual code:\n\nStart // 程式開始執行\n→ Step 1: Constructor Solution(nums)\n    → Save original = copy(nums) // 保留原始順序\n    → current = copy(nums) // 初始可變陣列\n→ Step 2: Method reset()\n    → Return copy(original) // 回傳原始陣列的複製\n→ Step 3: Method shuffle()\n    → For i from len-1 downto 1\n        → j = random(0, i) // 隨機索引\n        → Swap current[i] with current[j] // 交換\n    → Return copy(current) // 回傳隨機排列\n\nAlso include decision arrows for usage? Might not need decision but we can show process of shuffle.\n\nWe must produce each line with arrow and explanation.\n\nLet's craft.\n\nWe need to output the virtual code with each line having \"虛擬碼步驟 [空格] // 解釋\". Use \"Start\", \"End\" etc. Let's produce. We'll use arrows. Use \"→\" for next step. Use \"Decision:\" for conditions. Use \"Yes →\" \"No →\" accordingly.\n\nOk. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立解決方案的容器\n→ Step 2: Constructor Solution(nums)\n    → 保存原始陣列 original = copy(nums) // 用於重置\n    → 初始化 current = copy(nums) // 用於 shuffle\n→ Step 3: 定義方法 reset()\n    → 回傳 copy(original) // 產生原始陣列的複製\n→ Step 4: 定義方法 shuffle()\n    → Decision: 若 current 為空? // 確保陣列存在\n        Yes → current = copy(original) // 重新載入原始\n        No  → // 跳過\n    → For i from len(current)-1 down to 1\n        → j = random(0, i) // 隨機索引\n        → Swap current[i] 和 current[j] // 交換元素\n    → Return copy(current) // 回傳隨機排列\nEnd // 程式執行結束\n\nBut we need to show each step as separate lines. Also use \"→\" for flow. Need each line individually, not nested in block? The example shows indentation but each line separate with arrows. We can indent with spaces. Provide lines.\n\nWe need to maintain the requirement: Each line must contain \"虛擬碼步驟 [space] // 解釋\".\n\nThus each line is like \"Start // 程式開始執行\".\n\nFor steps with substeps, we might indent but keep separate lines. Use \"→\" at start for sub-steps. So:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立解決方案的容器\n→ Step 2: Constructor Solution(nums)\n→  → 保存原始陣列 original = copy(nums) // 用於重置\n→  → 初始化 current = copy(nums) // 用於 shuffle\n→ Step 3: 方法 reset()\n→  → 回傳 copy(original) // 產生原始陣列的複製\n→ Step 4: 方法 shuffle()\n→  → Decision: 若 current 為空? // 確保陣列存在\n→  →  Yes → current = copy(original) // 重新載入原始\n→  →  No  → // 跳過\n→  → For i from len(current)-1 down to 1\n→   →  j = random(0, i) // 隨機索引\n→   →  Swap current[i] 與 current[j] // 交換元素\n→  → Return copy(current) // 回傳隨機排列\nEnd // 程式執行結束\n\nBut maybe simpler: No need to check empty.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立解決方案的容器\n→ Step 2: Constructor Solution(nums)\n→  → 原始陣列 original = copy(nums) // 用於重置時還原順序\n→  → 可變陣列 current = copy(nums) // 用於 shuffle 時交換元素\n→ Step 3: 方法 reset()\n→  → 回傳 copy(original) // 產生原始陣列的複製並回傳\n→ Step 4: 方法 shuffle()\n→  → For i = len(current)-1 downto 1\n→   → 隨機 j = random(0, i) // 取得 0~i 的隨機索引\n→   → 交換 current[i] 與 current[j] // 交換兩個元素\n→  → Return copy(current) // 回傳隨機排列的複製\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Reconstruct Original Digits from English",
      "source_file": "Leetcode/leetcode423.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '012'\nGot (Norm):      '0127'\n--- (Raw) ---\nRaw Expected: '\"012\"'\nRaw Got:      '0127'"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '45'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"45\"'\nRaw Got:      '457'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        count = Counter(s)\n        out = {}\n        out['0'] = count['z']\n        out['2'] = count['w']\n        out['4'] = count['u']\n        out['6'] = count['x']\n        out['8'] = count['g']\n        out['3'] = count['h'] - out['8']\n        out['5'] = count['f'] - out['4']\n        out['7'] = count['s'] - out['6']\n        out['1'] = count['o'] - out['0'] - out['2'] - out['4']\n        out['9'] = count['i'] - out['5'] - out['6'] - out['8']\n        res = [k * out[k] for k in sorted(out.keys())]\n        return ''.join(res)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract only alphabetic characters from the input\n    s = ''.join(re.findall('[a-zA-Z]', data))\n    solution = Solution()\n    result = solution.originalDigits(s.lower())\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.\n\nWe must produce step by step pseudocode lines with explanations. Use Start, End, Decision. Each line has \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nWe must not output actual code, just pseudocode steps.\n\nNeed to cover typical solution: Count letters, unique letter mapping to digits.\n\nWe'll produce steps: Start, Step1: initialize frequency map, Step2: count letters, Step3: determine digits in order using unique letters (z->0, w->2, etc). We can list decisions mapping unique letters.\n\nSimplify: Use list of digit names and unique letters.\n\nWill produce steps: For each unique letter in order, count frequency, append digit accordingly, reduce frequencies. After all digits, sort digits ascending or directly output sorted.\n\nLet's produce.\n\nEnsure each line has arrow symbol. Use \"→\" after Start.\n\nWe'll include indentation for decisions.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化字母頻率表 // 建立每個字母的出現次數\n→ Step 2: 迭代輸入字串 s，累計每個字母的頻次 // 逐字母統計\n→ Step 3: 建立空結果列表 digits // 用於存放找出的數字\n→ Decision: 檢查是否存在字母 'z'（代表 0）? // 'z' 唯一出現在 \"zero\"\n    Yes → Step 4: 取得 count = freq['z'] // 0 的數量\n        → Step 5: 重複追加 '0' 到 digits count 次 // 加入 0\n        → Step 6: 對每個字母 in \"zero\" 減少 freq[letter] by count // 移除已處理字母\n        → Decision: 是否還有字母 'w'（代表 2）?\n            Yes → Step 7: count = freq['w'] // 2 的數量\n                → Step 8: 追加 '2' count 次\n                → Step 9: 對每個字母 in \"two\" 減少 freq[letter] by count\n                → Decision: 是否還有字母 'u'（代表 4）?\n                    Yes → Step10: count = freq['u']\n                        → Step11: 追加 '4' count 次\n                        → Step12: 減少 freq of \"four\"\n                        → Decision: 是否還有字母 'x'（代表 6）?\n                            Yes → Step13: count = freq['x']\n                                → Step14: 追加 '6' count 次\n                                → Step15: 減少 freq of \"six\"\n                                → Decision: 是否還有字母 'g'（代表 8）?\n                                    Yes → Step16: count = freq['g']\n                                        → Step17: 追加 '8' count 次\n                                        → Step18: 減少 freq of \"eight\"\n                                        → Decision: 是否還有字母 'h'（代表 3）?\n                                            Yes → Step19: count = freq['h']\n                                                → Step20: 追加 '3' count 次\n                                                → Step21: 減少 freq of \"three\"\n                                                → Decision: 是否還有字母 'f'（代表 5）?\n                                                    Yes → Step22: count = freq['f']\n                                                        → Step23: 追加 '5' count 次\n                                                        → Step24: 減少 freq of \"five\"\n                                                        → Decision: 是否還有字母 'v'（代表 7）?\n                                                            Yes → Step25: count = freq['v']\n                                                                → Step26: 追加 '7' count 次\n                                                                → Step27: 減少 freq of \"seven\"\n                                                                → Decision: 是否還有字母 'o'（代表 1）?\n                                                                    Yes → Step28: count = freq['o']\n                                                                        → Step29: 追加 '1' count 次\n                                                                        → Step30: 減少 freq of \"one\"\n                                                                        → Decision: 是否還有字母 'n'（代表 9）?\n                                                                            Yes → Step31: count = freq['n']\n                                                                                → Step32: 追加 '9' count 次\n                                                                                → Step33: 減少 freq of \"nine\"\n                                                                                → End // 所有數字已處理完畢\n                                                                            No  → End // 無剩餘 9\n                                                                    No  → End // 無剩餘 1\n                                                            No  → End // 無剩餘 7\n                                                    No  → End // 無剩餘 5\n                                            No  → End // 無剩餘 3\n                                    No  → End // 無剩餘 8\n                            No  → End // 無剩餘 6\n                    No  → End // 無剩餘 4\n            No  → End // 無剩餘 2\n    No  → End // 無剩餘 0\n→ Step 34: 將 digits 按升序排序 // 取得最終升序結果\n→ Step 35: 將排序後的數字列表轉為字串輸出 // 形成輸出格式\nEnd // 程式執行結束\n\nBut we might need more concise. We need each line as single line. Indentation with spaces but keep arrow lines. The above uses nested indentation but each line remains single. That is okay.\n\nWe must use \"Decision:\" lines, but we have many. We can streamline: Use Decision lines and branches. But might exceed typical length.\n\nBetter to use more concise: Use decisions for each unique letter step. We can collapse branches into linear steps: e.g., Step 4: process 0, Step 5: process 2, etc. Since unique letters guarantee order.\n\nBut the requirement wants \"逐行\" but doesn't demand decision branches. But can include decision for clarity.\n\nSimplify: Steps:\n\nStart\n→ Step1: build freq map\n→ Step2: initialize empty string result\n→ Step3: process digits in order using unique letters: 0,2,4,6,8,3,5,7,1,9\nfor each:\n    count = freq[unique_letter]\n    append digit count times to result\n    subtract count from each letter of digit word\n→ StepN: sort result ascending // result is already sorted because we processed in ascending order? Actually we processed in unique letter order which is not ascending; we need to sort after.\n\nBetter: we could collect counts into array digits[10] and then output ascending.\n\nLet's produce steps with Decision for each unique letter? Could use simplified approach.\n\nGiven requirement, we can just present algorithm steps: Build freq, process each unique letter mapping to digit, subtract, then output sorted.\n\nWe don't need to show decision logic. So we produce simpler steps.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 初始化字母頻率表 freq // 記錄每個字母出現次數\n→ Step 2: 讀取輸入字串 s，對每個字母累加至 freq // 統計頻率\n→ Step 3: 建立整數陣列 digitCount[10] 初值為 0 // 用於記錄每個數字出現的個數\n→ Decision: 是否包含字母 'z'（代表 0）?\n    Yes → Step 4: digitCount[0] = freq['z'] // 0 的數量\n        → Step 5: 對字母 \"zero\" 的每個字母減少 freq[letter] 乘以 digitCount[0] // 移除已處理字母\n→ Decision: 是否包含字母 'w'（代表 2）?\n    Yes → Step 6: digitCount[2] = freq['w']\n        → Step 7: 對 \"two\" 減少對應字母\n... (similar for 4,6,8,3,5,7,1,9)\n→ Step 10: 將 digitCount 轉成升序字串 // 0-9 依序輸出相應次數\n→ End // 程式結束\n\nBut we need each line with arrow. Let's craft final answer with explicit lines.\n\nI'll provide each step line, with decision lines for each digit. Use indentation spaces.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字母頻率表 freq（Map[char] → int） // 記錄每個字母的出現次數  \n→ Step 2: 逐字元迭代輸入字串 s，將 freq[字母] 加 1 // 進行統計  \n→ Step 3: 建立整數陣列 digitCount[10]，所有元素初值為 0 // 用於存放每個數字的個數  \n→ Decision: 是否存在字母 'z'（代表 0）? // 'z' 只出現在 \"zero\"  \n  Yes → Step 4: digitCount[0] = freq['z'] // 0 的數量  \n   → Step 5: 對字母 \"zero\" 中的每個字母減少 freq[letter] 乘以 digitCount[0] // 移除已處理字母  \n  No  → Step 4: digitCount[0] = 0  \n→ Decision: 是否存在字母 'w'（代表 2）?  \n  Yes → Step 6: digitCount[2] = freq['w']  \n   → Step 7: 對字母 \"two\" 減少 freq[letter] 乘以 digitCount[2]  \n  No  → Step 6: digitCount[2] = 0  \n→ Decision: 是否存在字母 'u'（代表 4）?  \n  Yes → Step 8: digitCount[4] = freq['u']  \n   → Step 9: 對字母 \"four\" 減少 freq[letter] 乘以 digitCount[4]  \n  No  → Step 8: digitCount[4] = 0  \n→ Decision: 是否存在字母 'x'（代表 6）?  \n  Yes → Step 10: digitCount[6] = freq['x']  \n   → Step 11: 對字母 \"six\" 減少 freq[letter] 乘以 digitCount[6]  \n  No  → Step 10: digitCount[6] = 0  \n→ Decision: 是否存在字母 'g'（代表 8）?  \n  Yes → Step 12: digitCount[8] = freq['g']  \n   → Step 13: 對字母 \"eight\" 減少 freq[letter] 乘以 digitCount[8]  \n  No  → Step 12: digitCount[8] = 0  \n→ Decision: 是否存在字母 'h'（代表 3）?  \n  Yes → Step 14: digitCount[3] = freq['h']  \n   → Step 15: 對字母 \"three\" 減少 freq[letter] 乘以 digitCount[3]  \n  No  → Step 14: digitCount[3] = 0  \n→ Decision: 是否存在字母 'f'（代表 5）?  \n  Yes → Step 16: digitCount[5] = freq['f']  \n   → Step 17: 對字母 \"five\" 減少 freq[letter] 乘以 digitCount[5]  \n  No  → Step 16: digitCount[5] = 0  \n→ Decision: 是否存在字母 'v'（代表 7）?  \n  Yes → Step 18: digitCount[7] = freq['v']  \n   → Step 19: 對字母 \"seven\" 減少 freq[letter] 乘以 digitCount[7]  \n  No  → Step 18: digitCount[7] = 0  \n→ Decision: 是否存在字母 'o'（代表 1）?  \n  Yes → Step 20: digitCount[1] = freq['o']  \n   → Step 21: 對字母 \"one\" 減少 freq[letter] 乘以 digitCount[1]  \n  No  → Step 20: digitCount[1] = 0  \n→ Decision: 是否存在字母 'n'（代表 9）?  \n  Yes → Step 22: digitCount[9] = freq['n']  \n   → Step 23: 對字母 \"nine\" 減少 freq[letter] 乘以 digitCount[9]  \n  No  → Step 22: digitCount[9] = 0  \n→ Step 24: 建立結果字串 result // 用於儲存升序輸出  \n  → For i 從 0 到 9  \n    → 追加字符 '0'+i 至 result，重複 digitCount[i] 次 // 按數字升序添加  \n→ End // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7,nums=[0,0,1,1,2,3,3,_,_]'\nGot (Norm):      '7,nums=[0,0,1,1,2,3,3,__]'\n--- (Raw) ---\nRaw Expected: '7, nums = [0,0,1,1,2,3,3,_,_]'\nRaw Got:      '7, nums = [0,0,1,1,2,3,3,__]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Remove duplicates in-place so that each element appears at most twice.\n        Return the new length k.\n        \"\"\"\n        if not nums:\n            return 0\n\n        k = 0  # write position\n        for i in range(len(nums)):\n            if k < 2 or nums[k - 2] != nums[i]:\n                nums[k] = nums[i]\n                k += 1\n        return k\n\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract the list representation using regex\n    m = re.search(r'\\[.*\\]', data)\n    if m:\n        nums = ast.literal_eval(m.group())\n    else:\n        nums = []\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # Build the output string with underscores for unused slots\n    result_parts = [str(nums[i]) for i in range(k)]\n    if len(nums) > k:\n        result_parts.append('_' * (len(nums) - k))\n    result_str = '[' + ','.join(result_parts) + ']'\n\n    print(f\"{k}, nums = {result_str}\")",
      "virtual_code": "Thinking...\nWe need to produce virtual code for removing duplicates up to twice in sorted array. Use two pointers: write pointer index and iterate. For each element, if it's the first or second occurrence of current value, write it. Approach: use counter to track count of current number. Or simpler: if write pointer < 2 then always copy; else if nums[write-2] != nums[i] then copy.\n\nLet's produce line-by-line. Use Start, End, Decision. Provide explanation comment. Use virtual code style.\n\nLet's craft:\n\nStart\n→ Initialize write = 0 // write index for result\n→ For i from 0 to length-1: // iterate through array\n    → Decision: if write < 2? // first two positions always kept\n        Yes → nums[write] = nums[i] // copy element\n        write = write + 1\n        No → Decision: if nums[write-2] != nums[i]? // check if current differs from two positions back\n            Yes → nums[write] = nums[i]\n            write = write + 1\n            No → // skip duplicate beyond twice\n→ End // return write as k\n\nNeed to include explanation after each line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 write = 0 // write 指標，指向下個可寫位置  \n→ Step 2: 針對 i 從 0 到 nums.length - 1 進行迴圈 // 逐一檢查每個元素  \n  Decision: write 是否小於 2？ // 前兩個位置始終可寫，直接保留  \n   Yes → nums[write] = nums[i] // 將元素寫入 write 位置  \n    write = write + 1 // 移動 write 到下一個位置  \n   No → Decision: nums[write - 2] 與 nums[i] 是否不同？ // 與兩個位置前的元素比較，確定是否已出現超過兩次  \n    Yes → nums[write] = nums[i] // 仍允許寫入，因為出現次數 ≤ 2  \n     write = write + 1 // 更新 write  \n    No → // 超過兩次重複，跳過此元素，不做寫入  \n→ End // 程式執行結束，write 即為保留元素個數 k\n\n此虛擬碼遵循「原地」且「O(1) 內存」的限制，並確保每個唯一元素最多保留兩個。"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression):\n        memo = {}\n\n        def ways(expr):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        _, expr_part = data.split('=', 1)\n        expr_part = expr_part.strip()\n        if (expr_part.startswith('\"') and expr_part.endswith('\"')) or \\\n           (expr_part.startswith(\"'\") and expr_part.endswith(\"'\")):\n            expr = expr_part[1:-1]\n        else:\n            expr = expr_part\n    else:\n        expr = data\n\n    sol = Solution()\n    result = sol.diffWaysToCompute(expr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code for solving this problem: given string expression of numbers and operators, compute all possible results by different parenthesizations. Classic Leetcode 241. Approach: recursion with memoization, parse numbers and operators. Use divide and conquer: for each operator index, split left and right, recursively compute all left results and right results, combine. Also handle base case: if no operator, parse number.\n\nWe need to produce virtual code line-by-line with explanations. The format: \"虛擬碼步驟 // 解釋/說明\".\n\nWe should use Start, End, Decision: etc. Use arrows. Provide step-by-step.\n\nLet's craft.\n\nWe'll need helper function compute(expression, l, r). Use memo map for substring key. Use recursion. We'll produce pseudo code.\n\nWe can write top-level function diffWaysToCompute(expression). Steps: initialize memo map. Call helper. Return results.\n\nThe helper: if substring is number only, convert to integer list.\n\nWe can parse operators indices.\n\nWe'll produce code:\n\nStart\n→ Step 1: 定義 diffWaysToCompute(expression) // 主函數\n    → Step 2: 初始化 memo = {} // 用於儲存子表達式結果\n    → Step 3: 回傳 helper(expression, 0, len(expression)-1, memo) // 計算整個表達式\nEnd\n\nDefine helper:\n\nStart\n→ Step 1: 定義 helper(expr, left, right, memo) // 計算子表達式\n    → Step 2: key = left + \",\" + right // 子問題的唯一標識\n    → Decision: 如果 key 在 memo 中?\n        Yes → Step 3: 回傳 memo[key] // 直接回傳已計算結果\n        No  → Step 4: 初始化 results = [] // 暫存所有可能結果\n    → Step 5: 迭代 i from left to right\n        → Decision: 如果 expr[i] 為運算子?\n            Yes → Step 6: leftRes = helper(expr, left, i-1, memo) // 左子表達式結果\n                → Step 7: rightRes = helper(expr, i+1, right, memo) // 右子表達式結果\n                → Step 8: 迭代 l in leftRes\n                    → Step 9: 迭代 r in rightRes\n                        → Step 10: 結果 = apply(expr[i], l, r) // 執行運算\n                        → Step 11: 把結果加入 results\n            No  // 跳過數字位置\n    → Decision: 如果 results 為空? // 表示子表達式沒有運算子，純數字\n        Yes → Step 12: num = int(expr[left:right+1]) // 轉成整數\n            → Step 13: results = [num]\n        No\n    → Step 14: memo[key] = results // 記錄子問題結果\n    → Step 15: 回傳 results\nEnd\n\nNeed to define apply function: maybe inline.\n\nWe also need to convert char to number.\n\nWe'll produce final answer.\n\nMake sure each line ends with comment.\n\nLet's craft final output with proper indentation maybe not necessary but maintain structure.\n\nAlso use arrows and decisions properly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 diffWaysToCompute(expression) // 主函數，輸入整個字串  \n→ Step 2: 初始化 memo = {} // 用來記錄已計算的子表達式結果  \n→ Step 3: 回傳 helper(expression, 0, len(expression)-1, memo) // 開始遞迴計算整個表達式  \nEnd // 程式結束  \n\nStart // helper 函式，計算 [left, right] 範圍內的所有結果  \n→ Step 1: 定義 helper(expr, left, right, memo)  \n→ Step 2: key = left + \",\" + right // 子問題唯一標識  \n→ Decision: 如果 key 在 memo 中?  \n Yes → Step 3: 回傳 memo[key] // 已計算直接回傳  \n No  → Step 4: 初始化 results = [] // 暫存所有可能結果  \n→ Step 5: 迭代 i 從 left 到 right  \n → Decision: 如果 expr[i] 是運算子 ('+', '-', '*')?  \n  Yes → Step 6: leftRes = helper(expr, left, i-1, memo) // 左子表達式所有結果  \n   → Step 7: rightRes = helper(expr, i+1, right, memo) // 右子表達式所有結果  \n   → Step 8: 迭代 l in leftRes  \n    → Step 9: 迭代 r in rightRes  \n     → Step 10: result = apply(expr[i], l, r) // 執行對應運算  \n      → Step 11: 把 result 加入 results  \n  No  // 若不是運算子，直接跳過數字字符  \n→ Decision: 如果 results 為空? // 代表沒有任何運算子，純數字  \n Yes → Step 12: num = int(expr[left:right+1]) // 將子字串轉成整數  \n   → Step 13: results = [num]  \n No  \n→ Step 14: memo[key] = results // 記錄子問題結果  \n→ Step 15: 回傳 results  \nEnd // helper 結束  \n\n// apply 函式，根據運算子執行計算  \nStart  \n→ Step 1: 定義 apply(op, a, b)  \n → Decision: 如果 op == '+'?  \n  Yes → Step 2: 回傳 a + b  \n  No → Decision: 如果 op == '-'?  \n   Yes → Step 3: 回傳 a - b  \n   No → Decision: 如果 op == '*'?  \n    Yes → Step 4: 回傳 a * b  \n    No → Step 5: 回傳 0 // 不可能出現其他運算子  \nEnd\n\n// End of 虛擬碼生成，整體流程已完成  \nEnd"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '23'\nGot (Norm):      '14'\n--- (Raw) ---\nRaw Expected: '23'\nRaw Got:      '14'"
        }
      ],
      "generated_code": "import sys\n\ndef evaluate(expr, idx=0):\n    \"\"\"解析 expr 從 idx 開始的子字串，返回 (結果, 新索引)\"\"\"\n    stack, num, sign = [], 0, '+'\n    while idx < len(expr):\n        ch = expr[idx]\n        if ch.isdigit():\n            num = num * 10 + int(ch)\n        elif ch == '(':\n            # 解析子表達式\n            sub_val, idx = evaluate(expr, idx + 1)\n            num = sub_val\n        elif ch in '+-*/' or ch == ')':\n            # 根據前一個 sign 處理 num\n            if sign == '+':\n                stack.append(num)\n            elif sign == '-':\n                stack.append(-num)\n            elif sign == '*':\n                stack.append(stack.pop() * num)\n            elif sign == '/':\n                stack.append(int(stack.pop() / num))\n            sign = ch\n            num = 0\n        # 移動到下一個字符\n        idx += 1\n        # 若遇到右括號，結束本層解析\n        if ch == ')':\n            break\n    # 處理最後一個數字\n    if sign == '+':\n        stack.append(num)\n    elif sign == '-':\n        stack.append(-num)\n    elif sign == '*':\n        stack.append(stack.pop() * num)\n    elif sign == '/':\n        stack.append(int(stack.pop() / num))\n    return sum(stack), idx\n\ndef calculate(s):\n    return evaluate(s)[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 提取字串內容\n    if '=' in data:\n        s = data.split('=', 1)[1].strip()\n    else:\n        s = data\n    # 去除可能存在的引號\n    if s and s[0] in ('\"', \"'\") and s[-1] == s[0]:\n        s = s[1:-1]\n    # 評估表達式\n    result = calculate(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. The task: implement basic calculator to evaluate string expression without eval. So typical algorithm: use stack to handle + - * /. But we can assume only + - * / and parentheses? The description says valid expression. Probably includes + - * / and parentheses. We need to output virtual code in lines with arrows and decisions. Use typical stack approach: parse characters, maintain current number, sign, and stack for previous results. Also handle parentheses by recursion or stack. Let's produce a simplified algorithm:\n\n- Initialize stack, current_num = 0, sign = '+'\n- Iterate over each char with index i\n- If digit, build current_num\n- If char is '(' -> push current_num and sign onto stack, reset current_num=0, sign='+'\n- If char is operator or ')' or end: compute based on sign: if '+': push current_num; if '-': push -current_num; if '*': pop, multiply by current_num, push result; if '/': pop, divide current_num by popped? Actually push pop / current_num. But need integer division? Assume integer result? We'll implement as integer division truncating toward zero.\n- If char is ')': after processing, compute sum of stack; but stack may contain previous stack from '('? Use separate stack: we can push a marker like '(' to know when to stop? Another method: push sign and number onto stack, and when encountering ')', pop until marker? But simpler: when encountering '(', push current_num and sign onto stack and also push a marker; reset current_num and sign. When encountering ')', pop until marker? Actually algorithm: use stack to store numbers. When encountering '(', push current_num and sign onto stack, push a marker like '(' or 0? Many solutions: use stack for numbers and signs. Let's produce a simpler approach: use stack for numbers only, treat parentheses via recursion: function eval(i) returns result and new index. But virtual code may use recursion as Decision.\n\nLet's produce pseudocode:\n\n- Function evaluate(s, i): // i current index\n  - Initialize stack, num=0, sign='+'\n  - while i < len(s):\n      - ch = s[i]\n      - if ch is digit: build num\n      - else if ch is '(': \n          - call evaluate(s, i+1) -> sub, i = new index after ')'\n          - num = sub\n      - if ch in '+-*/' or ch==')' or i==len(s)-1:\n          - process sign: if '+': push num; if '-': push -num; if '*': temp=stack.pop(); push temp*num; if '/': temp=stack.pop(); push int(temp/num)\n          - sign = ch\n          - num=0\n      - if ch==')': break\n      - i+=1\n  - sum stack\n  - return sum, i\n\nThen main function: result, _ = evaluate(s, 0); return result.\n\nLet's generate virtual code lines accordingly. Use arrows and decisions. Include Start, End. Let's craft:\n\nStart // 程式開始\n→ Step 1: 定義函式 Evaluate(s, idx) // 解析子字串並返回結果與新索引\n→ Decision: idx 是否超過字串長度? // 檢查是否已經處理完字串\n    Yes → Step 2: 回傳 0, idx // 空子表達式返回 0\n    No  → Step 3: 初始化 stack, num=0, sign='+' // 設定計算環境\n→ Loop: 遍歷 s 從 idx 開始\n    → Decision: s[idx] 是數字? // 檢查字符類型\n        Yes → Step 4: num = num*10 + int(s[idx]) // 連續數字組合\n        No  → Decision: s[idx] 是 '('? // 進入子表達式\n            Yes → Step 5: sub, idx = Evaluate(s, idx+1) // 解析子表達式\n                 → Step 6: num = sub // 使用子表達式結果\n            No  → Decision: s[idx] 是運算符或 ')'? // 統一處理符號\n                Yes → Step 7: 根據前一個 sign 處理 num 並推入 stack\n                         → Decision: sign 是 '+'? // 加法\n                             Yes → stack.push(num)\n                             No → Decision: sign 是 '-'? // 減法\n                                 Yes → stack.push(-num)\n                                 No → Decision: sign 是 '*'? // 乘法\n                                     Yes → temp = stack.pop(); stack.push(temp*num)\n                                     No → Decision: sign 是 '/'? // 除法\n                                         Yes → temp = stack.pop(); stack.push(int(temp/num))\n                No → Step 8: 更新 sign 為 s[idx] // 記錄目前運算符\n                No → Decision: s[idx] 是 ')'？ // 子表達式結束\n                    Yes → Step 9: 斷開循環並返回 sum(stack), idx\n                    No  → Step 10: idx += 1 // 移動至下一個字符\n→ Decision: 循環結束 (idx 到達字串末尾) ?\n    Yes → Step 11: 返 sum(stack), idx // 主調用結束\n→ End // 程式結束\n\nBut we need to use arrow for decisions: Yes →, No → etc.\n\nWe must include \"→\" before each step. Also need to include \"Decision:\" lines. Also include indentation for decisions. Use consistent style.\n\nLet's produce final output.\n\nMake sure each line has \"虛擬碼步驟\" + space + comment. We need to keep lines as in example.\n\nWe should write Start // 程式開始\n\nThen arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義函式 Evaluate(s, idx) // 解析子字串並返回結果與新索引\n→ Decision: idx 是否超過字串長度? // 檢查是否已經處理完字串\n    Yes → Step 2: 回傳 0, idx // 空子表達式返回 0\n    No  → Step 3: 初始化 stack, num=0, sign='+' // 設定計算環境\n→ Loop: 遍歷 s 從 idx 開始\n    → Decision: s[idx] 是數字? // 檢查字符類型\n        Yes → Step 4: num = num*10 + int(s[idx]) // 連續數字組合\n        No  → Decision: s[idx] 是 '('? // 進入子表達式\n            Yes → Step 5: sub, idx = Evaluate(s, idx+1) // 解析子表達式\n                 → Step 6: num = sub // 使用子表達式結果\n            No  → Decision: s[idx] 是運算符或 ')'？ // 統一處理符號\n                Yes → Step 7: 根據前一個 sign 處理 num 並推入 stack\n                        → Decision: sign 是 '+'? // 加法\n                            Yes → stack.push(num)\n                            No  → Decision: sign 是 '-'? // 減法\n                                Yes → stack.push(-num)\n                                No  → Decision: sign 是 '*'? // 乘法\n                                    Yes → temp = stack.pop(); stack.push(temp*num)\n                                    No  → Decision: sign 是 '/'? // 除法\n                                        Yes → temp = stack.pop(); stack.push(int(temp/num))\n                No  → Step 8: 更新 sign 為 s[idx] // 記錄目前運算符\n                No  → Decision: s[idx] 是 ')'？ // 子表達式結束\n                    Yes → Step 9: 斷開循環並返回 sum(stack), idx\n                    No  → Step 10: idx += 1 // 移動至下一個字符\n→ Decision: 循環結束 (idx 到達字串末尾) ?\n    Yes → Step 11: 返 sum(stack), idx // 主調用結束\n→ End // 程式結束"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp2d_os2m.py\", line 42, in <module>\n    prerequisites = ast.literal_eval(prereq_part)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2jbpt23x.py\", line 42, in <module>\n    prerequisites = ast.literal_eval(prereq_part)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canFinish(self, numCourses, prerequisites):\n        # 建立鄰接表\n        adj = [[] for _ in range(numCourses)]\n        for a, b in prerequisites:\n            adj[b].append(a)\n\n        visited = [False] * numCourses\n        rec_stack = [False] * numCourses\n\n        def dfs(course):\n            visited[course] = True\n            rec_stack[course] = True\n            for neigh in adj[course]:\n                if not visited[neigh]:\n                    if dfs(neigh):\n                        return True\n                elif rec_stack[neigh]:\n                    return True\n            rec_stack[course] = False\n            return False\n\n        for i in range(numCourses):\n            if not visited[i]:\n                if dfs(i):\n                    return False\n        return True\n\nif __name__ == \"__main__\":\n    # 讀取輸入，例如: numCourses = 2, prerequisites = [[1,0]]\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入\n    parts = [p.strip() for p in raw_input.split(',')]\n    num_courses = int(parts[0].split('=')[1].strip())\n    prereq_part = parts[1].split('=')[1].strip()\n    prerequisites = ast.literal_eval(prereq_part)\n\n    # 計算並輸出結果\n    solution = Solution()\n    result = solution.canFinish(num_courses, prerequisites)\n    print('true' if result else 'false')",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for detecting if all courses can be finished given prerequisites: essentially check if directed graph has cycle. Use DFS or Kahn. Provide step-by-step. Use Start, End, Decision, arrows.\n\nNeed each line: virtual code step + space + // explanation. Use arrows.\n\nLet's produce algorithm: Use adjacency list, visited array, recursion stack. DFS each node.\n\nPseudo lines:\n\nStart\n→ Build adjacency list from prerequisites\n→ Initialize visited array with False\n→ Initialize recursion stack array with False\n→ For each course i from 0 to numCourses-1\n    Decision: If course i already visited? // skip if done\n        Yes → Continue // skip\n        No  → Step: if DFS(i) returns true (cycle detected) then return false\n→ End // No cycles found, return true\n\nDefine DFS(course):\n    Mark visited[course] = True\n    Mark stack[course] = True\n    For each neighbor in adj[course]\n        Decision: if visited[neighbor] == False\n            Yes → if DFS(neighbor) == True then return True // cycle\n        Decision: else if stack[neighbor] == True\n            Yes → return True // cycle\n    Mark stack[course] = False\n    return False\n\nAt top-level, if any DFS returns True then cycle.\n\nReturn false if cycle else true.\n\nNeed to include returning values.\n\nLet's produce step-by-step.\n\nUse lines like:\n\n→ Step 1: Initialize adjacency list // Build graph\n\nNeed to include decisions and returns.\n\nAlso include Step: Return false // cannot finish\n\nReturn true at end.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 創建空的鄰接表 adj // 用來存放課程之間的依賴關係\n→ Step 2: 針對 prerequisites 中的每一對 [a, b]，將 b 加入 adj[a] // 表示要先修課程 b 才能修課程 a\n→ Step 3: 建立 visited 陣列，長度為 numCourses，全部設為 False // 用來標記課程是否已被訪問過\n→ Step 4: 建立 recursionStack 陣列，長度為 numCourses，全部設為 False // 用來標記 DFS 路徑上目前在考慮的節點\n→ Decision: 對於每個課程 i 從 0 到 numCourses-1\n    Yes → Decision: 如果 visited[i] 為 True\n        Yes → Continue // 已經處理過此課程，跳過\n        No  → Step 5: 如果 DFS(i) 返回 True（偵測到循環）\n            Yes → Step 6: Return False // 不能完成所有課程\n→ Step 7: Return True // 所有課程都能完成\nEnd // 程式執行結束\n\n// ----------------- DFS 函式定義 -----------------\n\n→ Function DFS(course) // 回傳 True 表示偵測到循環\n    → Step 1: visited[course] ← True // 標記此課程已被訪問\n    → Step 2: recursionStack[course] ← True // 將此課程加入當前 DFS 路徑\n    → Decision: 對於 adj[course] 中的每個 neighbour\n        Yes → Decision: 如果 visited[neighbour] 為 False\n            Yes → Step 3: 如果 DFS(neighbour) 返回 True\n                Yes → Return True // 循環被傳遞回來，結束 DFS\n            No  → Continue // 繼續遍歷其他相鄰課程\n        Yes → Decision: 否則如果 recursionStack[neighbour] 為 True\n            Yes → Return True // 找到回到自身的路徑，形成循環\n        No  → Continue\n    → Step 4: recursionStack[course] ← False // 從 DFS 路徑中移除此課程\n    → Return False // 未偵測到循環，正常結束 DFS\nEnd Function // DFS 函式結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,0,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 0, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    Weighted random picker.\n\n    Preprocess the weights into a prefix sum array so that\n    a random integer in [1, total] can be mapped to an index\n    in O(log n) time using binary search.\n    \"\"\"\n    def __init__(self, w):\n        # Build prefix sums\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # Random target in [1, total]\n        target = random.randint(1, self.total)\n        # Find the first index where prefix_sum[i] >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # Read the whole input. The input consists of two JSON arrays\n    # separated by a comma, e.g. '[\"Solution\",\"pickIndex\"], [[[1]],[]]'.\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # Wrap the input in an outer list so json.loads can parse it\n    wrapped = '[' + raw + ']'\n    functions, arguments = json.loads(wrapped)\n\n    # Execute the sequence of operations\n    results = []\n    instance = None\n    for func, args in zip(functions, arguments):\n        if func == \"Solution\":\n            instance = Solution(*args)\n            results.append(None)  # constructor returns null\n        else:\n            method = getattr(instance, func)\n            results.append(method(*args))\n\n    # Output the results in JSON format\n    # json.dumps will convert None to 'null', which matches expected output\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, with explanation. It's a typical weighted random selection: preprocess prefix sums, then in pickIndex generate random number between 1 and total sum, then binary search. Provide steps for constructor and pickIndex. Use virtual code with Start, Decision, etc.\n\nLet's craft.\n\nLine 1: Start // program start\nLine 2: → Step 1: Input array w // read array\nBut we need to show algorithm: Constructor: store w, build prefix sum array ps where ps[i] = sum up to i. And store total sum.\n\nThen pickIndex: generate random integer r between 1 and total sum inclusive. Then find first index where ps[i] >= r. Return i.\n\nImplement binary search.\n\nLet's produce steps.\n\nWe should include decision loops.\n\nUse arrow \"→\" to denote next step. Use Decision to represent binary search.\n\nAlso include End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 w // 取得權重陣列  \n→ Step 2: 初始化 prefixSum[0] = w[0] // 建立前綴和陣列第一項  \n→ Decision: 若 w.length > 1? // 檢查陣列長度是否大於 1  \n  Yes → Step 3: 從 i = 1 開始，對於每個 i: prefixSum[i] = prefixSum[i-1] + w[i] // 計算前綴和  \n  No  → End // 若陣列只有一個元素，直接結束建構  \n→ Step 4: total = prefixSum[w.length-1] // 記錄總權重  \nEnd // 建構完成  \n\nStart // 呼叫 pickIndex 時執行  \n→ Step 5: r = 1 + RandomInt(total) // 產生 1~total 之間的隨機整數  \n→ Step 6: low = 0, high = w.length - 1 // 初始化二分搜尋範圍  \n→ Decision: low <= high? // 開始二分搜尋  \n  Yes → Step 7: mid = (low + high) // 2 // 計算中點  \n    Decision: prefixSum[mid] >= r? // 判斷 r 是否落在 mid 位置的區間  \n     Yes → Step 8: return mid // 找到對應索引  \n     No  → Step 9: low = mid + 1 // r 在右半區間，更新 low  \n       → 回到 Decision: low <= high?  \n  No  → End // 理論上不會到此，因 r 保證在 1~total 之間  \nEnd // pickIndex 執行結束"
    }
  ]
}