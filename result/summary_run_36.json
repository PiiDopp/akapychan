{
  "run_index": 36,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 301,
  "generation_or_validation_failure_count": 33,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin 以符合題目規範（實際不使用這些輸入）\n    sys.stdin.read()\n\n    file_name = 'data.txt'\n    line_count = 0\n\n    try:\n        # 使用 with 語法安全開啟檔案並逐行計數\n        with open(file_name, 'r', encoding='utf-8') as f:\n            for _ in f:\n                line_count += 1\n        # 成功讀取後輸出總行數\n        print('檔案共有', line_count, '行')\n    except FileNotFoundError:\n        # 檔案不存在時顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code lines with explanations. Use structure with Start, End, Decision. Must include with, try/except. Should open file \"data.txt\", count lines, output count, if file not found, output error message. So code lines:\n\nStart\n→ Step 1: 將檔名設定為 'data.txt' // define file name\n→ Step 2: 將行數計數器初始化為 0 // init counter\n→ Step 3: 開始 try 块 // attempt file operations\n    → Decision: 嘗試打開檔案並讀取? // attempt file open\n        Yes → Step 4: 使用 with open(file, 'r') as f: // open file safely\n            → Step 5: 對於每行 in f: // iterate lines\n                → Step 6: 行數計數器 += 1 // count\n        No → Decision: 是否發生 FileNotFoundError? // catch error\n            Yes → Step 7: 輸出 '找不到檔案！' // show message\n            No → Step 8: 重新拋出錯誤 // rethrow unexpected\n→ Step 9: 如果沒有例外, 輸出 '總行數: ' + 行數 // output count\nEnd\n\nBut we need \"with\" inside try. And use except. Represent try/except as Decision? Might use Decision: 如果 try 成功? but try is flow. Let's structure:\n\nStart\n→ Step 1: Set file_name = 'data.txt' // 設定檔案名稱\n→ Step 2: Initialize line_count = 0 // 初始化行數\n→ Decision: 嘗試開啟檔案? // 進入 try\n    Yes → Step 3: with open(file_name, 'r') as f: // 打開檔案\n        → Step 4: 對每一行 in f: // 逐行\n            → Step 5: line_count += 1 // 計數\n    No → Decision: 是否為 FileNotFoundError? // 例外處理\n        Yes → Step 6: 輸出 '找不到檔案！' // 顯示錯誤\n        No → Step 7: 重新拋出 // 未處理的例外\n→ Decision: 是否成功讀取? // 進一步決定輸出\n    Yes → Step 8: 輸出 '總行數: ' + line_count // 顯示結果\n    No → Step 9: 不輸出 // 可能不需要\nEnd\n\nBut need to show try/except. Might be clearer: \n\nStart\n→ Step 1: file_name = 'data.txt' // 設定檔名\n→ Step 2: line_count = 0 // 初始化計數\n→ Decision: 開始 try? // 進入 try 區塊\n    Yes → Step 3: 將 try 內部開始\n        → Step 4: with open(file_name, 'r') as f: // open file\n            → Step 5: for line in f: // iterate\n                → Step 6: line_count += 1 // count\n    No → Decision: 是否發生 FileNotFoundError? // exception branch\n        Yes → Step 7: 輸出 '找不到檔案！' // error message\n        No → Step 8: 重新拋出 // unknown error\n→ Decision: 是否成功? // after try-except\n    Yes → Step 9: 輸出 '總行數: ' + line_count // output count\n    No → Step 10: 無需其他操作\nEnd\n\nBut need to reflect try/except. Could show as:\n\nStart\n→ Step 1: file_name = 'data.txt' // 設定檔名\n→ Step 2: line_count = 0 // 初始化計數\n→ Decision: 進入 try? // 嘗試執行\n    Yes → Step 3: try\n        → Step 4: with open(file_name, 'r') as f: // 開啟檔案\n            → Step 5: for line in f: // 逐行\n                → Step 6: line_count += 1 // 計數\n        → Step 7: except FileNotFoundError:\n            → Step 8: 輸出 '找不到檔案！' // 錯誤訊息\n→ Decision: 是否成功? // 判斷是否有錯誤\n    Yes → Step 9: 輸出 '總行數: ' + line_count // 顯示結果\n    No → Step 10: 無需執行 // 例外已處理\nEnd\n\nWe need to use arrows etc. Let's format each line as \"虛擬碼步驟 // 解釋\". Use indentation? Should indent under Decision? Not required but we can show indentation. Use spaces before arrows for indentation. Use \"Decision:\" lines with indented Yes/No. Provide simple explanations. Ensure each line includes a space after code and before comment.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: file_name = 'data.txt' // 設定檔名為 data.txt\n→ Step 2: line_count = 0 // 初始化行數計數器為 0\n→ Decision: 嘗試執行檔案開啟? // 進入 try 區塊\n    Yes → Step 3: try\n        → Step 4: with open(file_name, 'r') as f: // 使用 with 語法安全開啟檔案\n            → Step 5: for line in f: // 逐行迭代檔案內容\n                → Step 6: line_count += 1 // 將行數計數器加 1\n        → Step 7: except FileNotFoundError:\n            → Step 8: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息\n→ Decision: 是否成功讀取? // 判斷是否發生錯誤\n    Yes → Step 9: 輸出 '總行數: ' + line_count // 成功時輸出行數\n    No  → Step 10: 無需進一步操作 // 例外已處理完畢\nEnd // 程式執行結束\n\nBut note that Step 3 \"try\" not necessary; maybe skip. But keep.\n\nCheck each line includes space between code and comment.\n\nYes.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: file_name = 'data.txt' // 設定檔名為 data.txt  \n→ Step 2: line_count = 0 // 初始化行數計數器為 0  \n→ Decision: 嘗試執行檔案開啟? // 進入 try 區塊  \n&nbsp;&nbsp;Yes → Step 3: try  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: with open(file_name, 'r') as f: // 使用 with 語法安全開啟檔案  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: for line in f: // 逐行迭代檔案內容  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: line_count += 1 // 將行數計數器加 1  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: except FileNotFoundError:  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息  \n→ Decision: 是否成功讀取? // 判斷是否發生錯誤  \n&nbsp;&nbsp;Yes → Step 9: 輸出 '總行數: ' + line_count // 成功時輸出行數  \n&nbsp;&nbsp;No  → Step 10: 無需進一步操作 // 例外已處理完畢  \nEnd // 程式執行結束"
    },
    {
      "title": "平均分配",
      "source_file": "300.json",
      "problem_index_in_file": 1,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "Thinking...\nWe need to output Python code only. The code must implement described behavior. Let's produce:\n\n```\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    if m == 0:\n        print('錯誤: 小朋友人數不能為 0')\n        return\n    per = n // m\n    left = n % m\n    print(f\"每人={per} 剩下={left}\")\nif __name__ == \"__main__\":\n    main()\n```\n\nCheck format: Output format: \"每人=3 剩下=2\" with spaces? Example: '每人=3 剩下=2' no spaces between each? In example output: '每人=3 剩下=2' yes a space between the two parts. Our f-string prints with space: f\"每人={per} 剩下={left}\" yields exactly \"每人=3 剩下=2\". Good.\n\nEdge case: reading input maybe newline. Use sys.stdin.read() ensures both ints. Good.\n\nWe need to not output extra text.\n\nLet's produce final code.\n...done thinking.\n\n```python\ndef main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    if m == 0:\n        print(\"錯誤: 小朋友人數不能為 0\")\n        return\n    per = n // m\n    left = n % m\n    print(f\"每人={per}"
        }
      ],
      "generated_code": null,
      "virtual_code": "Thinking...\nWe need to output step-by-step pseudocode with explanation. Use format with \"虛擬碼步驟\" then space then comment. Use Start, End, Decision. So steps: input n, input m, compute quotient = n / m (integer division), remainder = n % m, output quotient and remainder. Should use decision to avoid division by zero maybe. So we can check if m > 0 else error. Let's produce lines. Ensure each line has arrow '→'. Format like Start, then arrow steps. Use 'Decision: 如果 m>0?' etc. Use Yes → ... No → Step. At end End.\n\nLet's produce output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n  // 讀入糖果總數  \n→ Step 2: 輸入 m  // 讀入小朋友人數  \n→ Decision: 如果 m>0? // 檢查小朋友人數是否有效  \n  Yes → Step 3: 計算 quotient = n ÷ m // 每人分到的糖果數（整數除法）  \n   → Step 4: 計算 remainder = n mod m // 剩餘未分配的糖果數  \n   → Step 5: 輸出 quotient // 顯示每人得到的糖果數  \n   → Step 6: 輸出 remainder // 顯示剩餘糖果數  \n  No  → Step 7: 輸出 '錯誤: 小朋友人數不能為 0' // 處理除以零的情況  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,5,2,6,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 5, 2, 6, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳所有結果的串列。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取完整輸入\n    input_code = sys.stdin.read()\n    # 執行使用者輸入的程式碼，並讓 roll_dice 可用於該程式碼\n    exec(input_code, {\"roll_dice\": roll_dice})",
      "virtual_code": "Thinking...\nThe user wants virtual code for a function roll_dice(n) that uses random module, simulates rolling a six-sided die n times, and returns list of results. Must output line by line with arrow etc. Use Start, End, Decision, etc. No actual code. Use virtual code style: \"Step\" lines. Let's craft:\n\nStart // start program\n→ Step 1: 定義函式 roll_dice(n) // 定義函式\n→ Step 2: 建立空串列 results // 用於儲存結果\n→ Step 3: 循環 i 從 1 到 n // 進行 n 次擲骰\n    → Decision: 檢查 i 是否小於等於 n? // 確認循環條件\n        Yes → Step 4: 使用 random.randint(1,6) 產生一個 1-6 隨機數 // 擲骰\n        → Step 5: 將隨機數加入 results // 存入結果串列\n        No  → Step 6: 迴圈結束 // 超過 n，結束循環\n→ Step 7: 回傳 results // 返回所有結果\nEnd // 程式結束\n\nBut need correct structure: Use Decision for loop condition maybe. Or use Step with for. Might show \"Decision: 迴圈條件\" with Yes → Step 4. Then after loop, Step 7.\n\nMake sure each line ends with // explanation. Provide arrow lines.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 roll_dice(n) // 建立擲骰函式\n→ Step 2: 建立空列表 results // 用於儲存擲骰結果\n→ Step 3: 循環計數器 i 從 1 到 n // 執行 n 次擲骰\n    → Decision: i 小於等於 n? // 判斷是否還有擲骰\n        Yes → Step 4: result ← random.randint(1,6) // 產生 1-6 隨機數\n        → Step 5: results.append(result) // 加入結果列表\n        No  → Step 6: 迴圈結束 // 超過 n，結束擲骰\n→ Step 7: 回傳 results // 返回所有擲骰結果\nEnd // 程式執行結束\n\nBut arrow style: \"→\" before Step lines"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "# -*- coding: utf-8 -*-\n\"\"\"\n此程式碼定義了一個 measure_time(func, *args) 函式，用來測量 func 執行所需的秒數，\n並將測量結果四捨五入到小數點 3 位。主程式從標準輸入讀取一段 Python 程式碼，\n將其執行，並讓使用者自行在程式碼中呼叫 measure_time。\n\"\"\"\n\nimport time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行時間（秒），並回傳四捨五入至 3 位小數的結果。\n    \"\"\"\n    start = time.time()          # 記錄開始時間\n    func(*args)                  # 執行目標函式\n    end = time.time()            # 記錄結束時間\n    elapsed = end - start        # 計算耗時\n    return round(elapsed, 3)     # 回傳四捨五入後的秒數\n\ndef main():\n    \"\"\"\n    主程式：從標準輸入讀取完整的 Python 程式碼，將 measure_time\n    這個函式加入執行環境後，直接執行輸入程式碼。\n    \"\"\"\n    # 讀取整個輸入\n    code = sys.stdin.read()\n\n    # 建立執行環境，預先注入 measure_time，並保留全域字典\n    exec_env = globals().copy()\n    exec_env['measure_time'] = measure_time\n\n    # 執行使用者輸入的程式碼\n    exec(code, exec_env)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. Should include Start, End, Decision, etc. The function measure_time(func,*args) uses time module. Steps: import time, define function, start timer, call func(*args), end timer, compute elapsed, round to 3 decimal, return elapsed, return result? Wait requirement: measure_time(func,*args) to measure function execution time and return result. Should return the elapsed seconds, round to 3 decimals. Probably also return result? The spec says: 用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。Interpretation: \"回傳結果\" refers to the time measurement. So return elapsed time. Provide steps: import time; define function; start time; result=func(*args); end time; elapsed=end-start; rounded=round(elapsed,3); return rounded. Also might need to handle optional args. Provide steps.\n\nWe must output"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"orange\",\"grape\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'orange', 'grape', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取並忽略所有輸入（若有輸入）\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 使用 add() 新增 'orange'\n    fruits.add('orange')\n\n    # 使用 update() 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 使用 remove() 移除 'banana'\n    fruits.remove('banana')\n\n    # 使用 discard() 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user requests a step-by-step virtual code that performs set operations in Python, but we should output only virtual steps, not actual code. We need to follow the format: each line with \"虛擬碼步驟\" + space + \"// 解釋\". Use arrow →, Start, End, Decision if needed. No actual code. We need to produce virtual steps for:\n\n1. Start\n2. Create set fruits = {'apple', 'banana'}\n3. Add 'orange'\n4. Update with 'grape', 'melon'\n5. Remove 'banana'\n6. Discard 'pineapple'\n7. Output the set\n8. End\n\nWe should show each step as a line. Let's include comments. The steps could be:\n\nStart // 程式開始執行\n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立初始集合\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'\n→ Step 6: 輸出 fruits // 顯示最終集合內容\nEnd // 程式執行結束\n\nWe must keep the format. Use arrow for each step. No code. Let's comply.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化集合 fruits = {'apple', 'banana'} // 建立初始集合  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'（不會拋錯）  \n→ Step 6: 輸出 fruits // 顯示最終集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\nAPI_URL = 'https://api.exchangerate-api.com/v4/latest/USD'\n\ndef get_rate():\n    \"\"\"Fetch the USD to TWD exchange rate from the API.\"\"\"\n    try:\n        response = requests.get(API_URL, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        return data['rates'].get('TWD')\n    except Exception:\n        return None\n\ndef create_gui():\n    \"\"\"Create the Tkinter GUI window.\"\"\"\n    win = tk.Tk()\n    win.title('匯率查詢')\n\n    label = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\n    label.pack(pady=10)\n\n    def update_rate():\n        rate = get_rate()\n        if rate is not None:\n            label.config(text=f'目前美元匯率：約 {rate} TWD')\n        else:\n            label.config(text='更新失敗，請檢查網路連線')\n\n    tk.Button(win, text='更新匯率', command=update_rate).pack(pady=5)\n\n    win.mainloop()\n\ndef main():\n    # 讀取標準輸入\n    _ = sys.stdin.read().strip()\n\n    # 取得匯率並印出\n    rate = get_rate()\n    if rate is not None:\n        print(f'目前美元匯率：約 {rate} TWD')\n    else:\n        print('更新失敗，請檢查網路連線')\n\n    # 啟動 GUI\n    create_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps following format. Need to describe steps using virtual code arrows, Start, End, Decision, etc. Need to include requests module, tk, fetch API, parse JSON, get TWD rate, display in window, button triggers update. Should not output real code, only virtual steps. Provide each line with comment. Use arrow → and indentation. Ensure each line has \"虛擬碼步驟 [空格] // 解釋\". Use Start, End. Also Decision for error checking maybe. Provide steps line by line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Import Modules: requests, tkinter as tk // 導入網路請求與 GUI 模組\n→ Create Main Window: root = tk.Tk() // 建立主視窗\n→ Set Window Title: root.title('USD to TWD 匯率查詢') // 設定視窗標題\n→ Define Label Widget: rate_label = tk.Label(root, text='匯率將於此顯示') // 用於顯示匯率\n→ Place Label: rate_label.pack(pady=20) // 放置標籤並添加垂直間距\n→ Define Update Function: def fetch_rate(): // 定義更新匯率的函式\n    → Send GET Request: response = requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 連接匯率 API\n    → Decision: 如果 response.status_code 為 200? // 檢查回應是否成功\n        Yes → Parse JSON: data = response.json() // 將回傳資料轉為 JSON\n        → Decision: 如果 'TWD' 在 data['rates']? // 檢查是否存在台幣匯率\n            Yes → Extract Rate: rate = data['rates']['TWD'] // 取得 TWD 匯率\n            → Update Label: rate_label.config(text=f'1 USD = {rate} TWD') // 更新標籤文字\n            No → Update Label: rate_label.config(text='錯誤：缺少 TWD 匯率資料') // 處理缺失資料\n        No  → Update Label: rate_label.config(text='錯誤：無效的回應資料') // 處理回應資料錯誤\n    No  → Update Label: rate_label.config(text='網路錯誤：無法取得匯率') // 處理 HTTP 錯誤\n→ End Function // 函式結束\n→ Define Button Widget: update_btn = tk.Button(root, text='更新匯率', command=fetch_rate) // 建立按鈕並綁定函式\n→ Place Button: update_btn.pack(pady=10) // 放置按鈕並添加垂直間距\n→ 初始呼叫更新：fetch_rate() // 程式啟動時先取得一次匯率\n→ Start Main Loop: root.mainloop() // 啟動 tkinter 事件循環\nEnd // 程式執行結束\n\nMake sure each line ends with comment. Indentation: We use indentation for nested steps? In example, they used 4 spaces or indentation. Use proper indentation for steps inside function. But we should keep each line separate, not combine multiple steps on same line. For nested lines we can indent.\n\nEnsure no actual code. Use only description. Provide each line. Provide arrow arrow? In sample they used \"→ Step 1: ...\" etc. For nested we can indent with spaces or use 4 spaces. Use \"→\" at start of each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import Modules: requests, tkinter as tk // 導入網路請求與 GUI 模組  \n→ Create Main Window: root = tk.Tk() // 建立主視窗  \n→ Set Window Title: root.title('USD to TWD 匯率查詢') // 設定視窗標題  \n→ Define Label Widget: rate_label = tk.Label(root, text='匯率將於此顯示') // 用於顯示匯率  \n→ Place Label: rate_label.pack(pady=20) // 放置標籤並添加垂直間距  \n→ Define Update Function: def fetch_rate(): // 定義更新匯率的函式  \n  → Send GET Request: response = requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 連接匯率 API  \n  → Decision: 如果 response.status_code 為 200? // 檢查回應是否成功  \n    Yes → Parse JSON: data = response.json() // 將回傳資料轉為 JSON  \n    → Decision: 如果 'TWD' 在 data['rates']? // 檢查是否存在台幣匯率  \n      Yes → Extract Rate: rate = data['rates']['TWD'] // 取得 TWD 匯率  \n      → Update Label: rate_label.config(text=f'1 USD = {rate} TWD') // 更新標籤文字  \n      No → Update Label: rate_label.config(text='錯誤：缺少 TWD 匯率資料') // 處理缺失資料  \n    No  → Update Label: rate_label.config(text='錯誤：無效的回應資料') // 處理回應資料錯誤  \n  No  → Update Label: rate_label.config(text='網路錯誤：無法取得匯率') // 處理 HTTP 錯誤  \n→ End Function // 函式結束  \n→ Define Button Widget: update_btn = tk.Button(root, text='更新匯率', command=fetch_rate) // 建立按鈕並綁定函式  \n→ Place Button: update_btn.pack(pady=10) // 放置按鈕並添加垂直間距  \n→ 初始呼叫更新：fetch_rate() // 程式啟動時先取得一次匯率  \n→ Start Main Loop: root.mainloop() // 啟動 tkinter 事件循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    \"\"\"實作可隨機取值、插入、刪除的集合。\"\"\"\n\n    def __init__(self):\n        self.val_to_index = {}   # 值 -> 索引\n        self.values = []         # 存放值的列表\n\n    def insert(self, val: int) -> bool:\n        \"\"\"若 val 未存在則插入並回傳 True，否則回傳 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若 val 存在則刪除並回傳 True，否則回傳 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # 交換要刪除的元素與最後一個元素\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機回傳集合中一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    res = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)                     # 代表 null\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            res.append(None)\n\n    # 轉換結果為 LeetCode 輸出格式\n    out_parts = []\n    for item in res:\n        if item is None:\n            out_parts.append(\"null\")\n        elif isinstance(item, bool):\n            out_parts.append(\"true\" if item else \"false\")\n        else:\n            out_parts.append(str(item))\n    print(f\"[{', '.join(out_parts)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines for a solution to RandomizedSet problem, with explanation after each line. We should not output real code. Provide steps: using hash map for value to index, list for values. Provide methods insert, remove, getRandom. Provide class skeleton. Use arrow and decision.\n\nWe need to ensure each line includes \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe must use Start, End, Decision.\n\nWe should not output real code, but pseudo-code steps.\n\nWe should show each step. For example:\n\nStart // 程式開始執行\n→ Step 1: Define class RandomizedSet // 定義類別\n→ Step 2: Define list values = [] // 動態陣列儲存元素\n→ Step 3: Define map valToIndex = {} // 值到索引的映射\n→ Step 4: Constructor // 初始化\n    → Step 4.1: Set values = [] // ...\n... etc.\n\nWe need to incorporate decision for insert: if val in map.\n\nFor remove: if val not in map.\n\nGetRandom: pick random index between 0 and len(values)-1.\n\nAll operations O(1).\n\nWe need to produce each line with explanation.\n\nMake sure to use arrow and decision structure.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define class RandomizedSet // 定義 RandomizedSet 類別  \n→ Step 2: Define list values = [] // 用於存放所有元素的動態陣列  \n→ Step 3: Define map valToIndex = {} // 用於快速查找元素所在索引的字典  \n→ Step 4: Constructor // 初始化方法  \n    → Step 4.1: values = [] // 初始化空陣列  \n    → Step 4.2: valToIndex = {} // 初始化空字典  \n→ Step 5: Method insert(val) // 插入元素  \n    → Decision: 如果 val 在 valToIndex? // 檢查元素是否已存在  \n        Yes → Step 5.1: Return false // 已存在，返回失敗  \n        No  → Step 5.2: Append val 到 values // 加入陣列尾部  \n            → Step 5.3: valToIndex[val] = len(values)-1 // 記錄索引  \n            → Step 5.4: Return true // 成功插入  \n→ Step 6: Method remove(val) // 刪除元素  \n    → Decision: 如果 val 在 valToIndex? // 檢查元素是否存在  \n        No  → Step 6.1: Return false // 不存在，返回失敗  \n        Yes → Step 6.2: idx = valToIndex[val] // 取得要刪除的索引  \n            → Step 6.3: lastVal = values[-1] // 取得最後一個元素  \n            → Step 6.4: Swap values[idx] 與 lastVal // 將最後一個元素移到要刪除位置  \n            → Step 6.5: values[idx] = lastVal  \n            → Step 6.6: values.pop() // 刪除最後一個元素（已被移到 idx）  \n            → Step 6.7: valToIndex[lastVal] = idx // 更新被移動元素的索引  \n            → Step 6.8: Delete valToIndex[val] // 移除被刪除元素的映射  \n            → Step 6.9: Return true // 成功刪除  \n→ Step 7: Method getRandom() // 隨機取一個元素  \n    → Step 7.1: n = len(values) // 取得元素數量  \n    → Step 7.2: randIdx = RandomInt(0, n-1) // 產生隨機索引  \n    → Step 7.3: Return values[randIdx] // 回傳隨機元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[1,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0, 0], [2, 0], [1, 0], null, [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n        self.total = m * n\n        self.flipped = {}\n\n    def flip(self):\n        r = random.randint(0, self.total - 1)\n        x = self.flipped.get(r, r)\n        self.total -= 1\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        return [x // self.n, x % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並解析成兩個列表：commands 與對應參數\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    commands, args = ast.literal_eval(raw_input)\n\n    instance = None\n    results = []\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"Solution\":\n            instance = Solution(*arg)\n            results.append(None)            # Constructor對應null\n        elif cmd == \"flip\":\n            results.append(instance.flip())\n        elif cmd == \"reset\":\n            instance.reset()\n            results.append(None)            # reset對應null\n\n    # 使用 json.dumps 將結果轉成符合題目輸出格式的字串\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: We need algorithm to randomly pick zero in matrix, flip it to one. Optimize random calls and time/space.\n\nCommon solution: treat matrix as 1D array size m*n. Keep list of available indices. Initially all indices from 0..m*n-1. On flip, pick random index in range [0, remaining-1], return mapping of that index. Use mapping dictionary to handle swapped indices to avoid O(n) removal. After picking index, swap mapping: if mapping contains selected index, get mapped value; else use selected index. Similarly for last index. Then update mapping for selected. Decrease remaining count. Reset: clear mapping and set remaining = m*n.\n\nAlso can use reservoir. But mapping approach.\n\nWe need virtual code lines. Provide explanation after each line.\n\nWe'll create class Solution with m,n, remaining, map. Methods: init, flip, reset.\n\nWe need to use virtual code arrow and structure.\n\nLet's produce steps:\n\nStart\n→ Initialize: m, n, remaining = m*n, map = {} // store mapping from virtual index to real index\n→ Method flip\n    → If remaining == 0 // all ones\n        Yes → return error or null // but in problem not needed\n    → Random idx = randomInt(0, remaining-1) // pick random index within remaining\n    → Get realIdx = map.get(idx) if exists else idx // actual index to flip\n    → Swap with last: lastIdx = remaining-1\n    → realLast = map.get(lastIdx) if exists else lastIdx\n    → map[idx] = realLast // update mapping for swapped index\n    → Remove mapping for lastIdx if exists // because it's used\n    → remaining--\n    → Convert realIdx to (i, j): i = realIdx / n, j = realIdx % n\n    → Return [i, j]\n→ Method reset\n    → remaining = m*n\n    → map.clear()\nEnd\n\nWe need to output line by line with comments.\n\nUse virtual code with arrows. Use Decision for conditional.\n\nLet's write step by step.\n\nWe also need to include 'Start' and 'End' lines.\n\nWe may separate methods. For each method, we can start with 'Start' of method? The requirement: each line has \"虛擬碼步驟\" and comment. Use arrows. Should show decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Class Solution: // 定義 Solution 類\n    → Constructor: m, n // 初始化矩陣尺寸\n        → Set this.m = m, this.n = n // 存儲尺寸\n        → Set this.remaining = m * n // 剩餘可翻轉位置數\n        → Initialize this.map = {} // 建立映射字典\n→ Method flip // 隨機翻轉一個 0 為 1\n    → Decision: 如果 this.remaining == 0? // 檢查是否還有 0 可翻\n        Yes → Return null // 或拋出錯誤\n        No  → Continue\n    → Random idx = randomInt(0, this.remaining - 1) // 取得隨機位置\n    → Decision: 如果 this.map 包含 idx? // 是否已被映射\n        Yes → realIdx = this.map[idx] // 取得實際索引\n        No  → realIdx = idx // 使用原始索引\n    → Set lastIdx = this.remaining - 1 // 最後一個未使用索引\n    → Decision: 如果 this.map 包含 lastIdx? // 檢查最後索引是否已映射\n        Yes → realLast = this.map[lastIdx] // 取得實際最後索引\n        No  → realLast = lastIdx // 使用原始最後索引\n    → Update this.map[idx] = realLast // 把選中的位置映射到最後位置\n    → Decision: 如果 this.map 包含 lastIdx? // 刪除最後位置的映射\n        Yes → Delete this.map[lastIdx] // 移除\n        No  → No action\n    → Decrement this.remaining-- // 已翻轉一個\n    → Compute i = floor(realIdx / this.n) // 行號\n    → Compute j = realIdx % this.n // 列號\n    → Return [i, j] // 返回索引\n→ Method reset // 重置矩陣\n    → Set this.remaining = this.m * this.n // 重新設為全尺寸\n    → Clear this.map // 清空映射\nEnd // 程式執行結束\n\nNeed to maintain indentation? Not required. But we can indent for readability.\n\nEnsure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Class Solution: // 定義 Solution 類\n    → Constructor: m, n // 初始化矩陣尺寸\n        → Set this.m = m, this.n = n // 存儲尺寸\n        → Set this.remaining = m * n // 剩餘可翻轉位置數\n        → Initialize this.map = {} // 建立映射字典\n→ Method flip // 隨機翻轉一個 0 為 1\n    → Decision: 如果 this.remaining == 0? // 檢查是否還有 0 可翻\n        Yes → Return null // 無法翻轉，直接返回\n        No  → Continue\n    → Random idx = randomInt(0, this.remaining - 1) // 取得隨機位置\n    → Decision: 如果 this.map 包含 idx? // 是否已被映射\n        Yes → realIdx = this.map[idx] // 取得實際索引\n        No  → realIdx = idx // 使用原始索引\n    → Set lastIdx = this.remaining - 1 // 最後一個未使用索引\n    → Decision: 如果 this.map 包含 lastIdx? // 檢查最後索引是否已映射\n        Yes → realLast = this.map[lastIdx] // 取得實際最後索引\n        No  → realLast = lastIdx // 使用原始最後索引\n    → Update this.map[idx] = realLast // 把選中的位置映射到最後位置\n    → Decision: 如果 this.map 包含 lastIdx? // 刪除最後位置的映射\n        Yes → Delete this.map[lastIdx] // 移除映射\n        No  → No action\n    → Decrement this.remaining // 已翻轉一個\n    → Compute i = floor(realIdx / this.n) // 行號\n    → Compute j = realIdx % this.n // 列號\n    → Return [i, j] // 返回索引\n→ Method reset // 重置矩陣\n    → Set this.remaining = this.m * this.n // 重新設為全尺寸\n    → Clear this.map // 清空映射\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_unique_substrings_in_wraparound(s: str) -> int:\n    \"\"\"Return the number of unique non‑empty substrings of `s`\n    that appear in the infinite wraparound string of the alphabet.\"\"\"\n    # dp[i] stores the maximum length of a valid substring ending with chr(i + 'a')\n    dp = [0] * 26\n    cur_len = 0  # length of current consecutive sequence\n\n    for i, ch in enumerate(s):\n        # Check if current character continues the wraparound sequence\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            cur_len += 1\n        else:\n            cur_len = 1\n\n        idx = ord(ch) - ord('a')\n        dp[idx] = max(dp[idx], cur_len)\n\n    return sum(dp)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the alphabetic string from raw input, handling optional prefixes\n    like 's = ' and surrounding quotes.\"\"\"\n    # Remove everything except lowercase letters\n    return re.sub(r'[^a-z]', '', raw)\n\ndef main() -> None:\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    result = count_unique_substrings_in_wraparound(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps explaining algorithm to count unique non-empty substrings of s that appear in the infinite wraparound string of alphabet (circular). Known problem: Leetcode 467. Solution: track longest valid substring ending at each letter. For each char in s, update current length; if s[i] consecutive previous, curLen++ else curLen=1. For each char, update maxLen[char] = max(maxLen[char], curLen). Sum over all chars gives count. Provide steps with virtual code.\n\nWe need to output in required format: each line \"虛擬碼步驟 // 解釋\". Use arrow notation.\n\nStructure: Start, Step, Decision, End.\n\nWe need to produce step-by-step explanation of algorithm, not code. Let's craft.\n\nStart // Begin algorithm\n→ Step 1: Initialize an array maxLen[26] to zeros // store longest substring length ending with each letter\n→ Step 2: Set currentLen = 0 // length of current consecutive sequence\n→ Step 3: Iterate over each character ch in input string s // traverse string\n    → Decision: Is ch consecutive to previous character? // check wraparound adjacency\n        Yes → currentLen = currentLen + 1 // extend current consecutive run\n        No  → currentLen = 1 // reset run to length 1\n    → Step 4: idx = position of ch in alphabet // 0-25\n    → Step 5: maxLen[idx] = max(maxLen[idx], currentLen) // update max length for this ending char\n→ Step 6: Sum all values in maxLen // total number of unique substrings\n→ Step 7: Return the sum // result\nEnd // Algorithm finished\n\nWe also might need to explain how wraparound adjacency is determined: (ch - prev + 26) % 26 == 1.\n\nAdd comment.\n\nLet's output lines accordingly. Ensure each line ends with // explanation. Use appropriate arrow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化長度為 26 的陣列 maxLen，全部設為 0 // 用於記錄每個字母結尾的最大連續子字串長度  \n→ Step 2: 設定 currentLen = 0 // 目前連續序列長度  \n→ Step 3: 遍歷輸入字串 s 的每個字元 ch // 循環處理每個字符  \n  → Decision: ch 是否為前一個字符的下一個字母（含 wraparound）? // 檢查連續性  \n   Yes → currentLen = currentLen + 1 // 連續序列可延長  \n   No  → currentLen = 1 // 連續序列重新開始  \n  → Step 4: idx = 字母表索引(ch) // 取得 ch 在 'a'~'z' 的索引 (0-25)  \n  → Step 5: maxLen[idx] = max(maxLen[idx], currentLen) // 更新以 ch 結尾的最大長度  \n→ Step 6: total = sum(maxLen[0..25]) // 所有字母結尾的最大長度相加即為唯一子字串數量  \n→ Step 7: 返回 total // 結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    # Extract all digit sequences (handles formats like num1 = \"11\", num2 = \"123\" or plain numbers)\n    numbers = re.findall(r'\\d+', raw_input)\n    if len(numbers) < 2:\n        print(\"0\")  # Default fallback if input is insufficient\n    else:\n        num1, num2 = numbers[0], numbers[1]\n        solution = Solution()\n        result = solution.addStrings(num1, num2)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Each line with \"虛擬碼步驟 // 解釋\". Use arrows. No actual code. Just algorithm outline. Must be line-by-line. Need to handle adding two numeric strings without built-in big integers.\n\nAlgorithm: reverse strings, iterate digits, keep carry, build result string, then reverse. Ensure handling different lengths.\n\nWe need to output each step line by line. Use virtual code arrows. Use \"Start\" \"End\". Decision nodes. Use Yes/No arrows.\n\nWe can produce steps:\n\nStart // begin\n→ Step 1: 初始化變數 carry=0, result=\"\" // start\n→ Step 2: 取得兩個字符串 num1, num2 // input\n→ Decision: 是否 num1 反轉比 num2 反轉長? // compare lengths\n    Yes → Step 3: 交換 num1, num2 // ensure num1 is longer\n    No  → Step 3: // do nothing\n→ Step 4: 反轉 num1, num2 // reverse strings for easier addition\n→ Step 5: 將兩個反轉字符串轉成字符陣列 // to iterate\n→ Step 6: 設定 i=0, j=0 // indices\n→ Decision: i < len(num1) 或 j < len(num2) 或 carry>0? // loop condition\n    Yes → Step 7: 若 i < len(num1) 則 d1 = int(num1[i]) 否則 d1=0 // get digit\n    → Step 8: 若 j < len(num2) 則 d2 = int(num2[j]) 否則 d2=0 // get digit\n    → Step 9: sum = d1 + d2 + carry // sum of digits\n    → Step 10: carry = sum // 10 // new carry\n    → Step 11: result += char((sum % 10) + '0') // append digit\n    → Step 12: i++ // increment\n    → Step 13: j++ // increment\n    → Go back to Decision\n    No → Step 14: 反轉 result // reverse result string\n    → Step 15: 返回 result // output\nEnd\n\nNeed to use arrow notation. Use \"Yes →\" etc. Should be each line separate. For decisions, indent subsequent lines? In example, they used indentation but we can just put each line on new line, using arrow and spaces.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 carry = 0, result = \"\" // 設定進位與結果字串  \n→ Step 2: 讀取輸入字串 num1 與 num2 // 取得兩個數字字串  \n→ Decision: 是否 num1 反轉後長度 < num2 反轉後長度? // 確保 num1 為較長字串  \n  Yes → Step 3: 交換 num1 與 num2 // 交換兩字串以便後續處理  \n  No  → Step 3: // 無須交換  \n→ Step 4: 反轉 num1 與 num2 // 方便從最低位開始相加  \n→ Step 5: 將兩個反轉後的字串轉為字符陣列 // 方便逐位存取  \n→ Step 6: 設定指標 i = 0, j = 0 // 索引指向最低位  \n→ Decision: i < len(num1) 或 j < len(num2) 或 carry > 0? // 是否還有位數需處理  \n  Yes → Step 7: 若 i < len(num1) 則 d1 = int(num1[i]) 否則 d1 = 0 // 取得 num1 的位數  \n  → Step 8: 若 j < len(num2) 則 d2 = int(num2[j]) 否則 d2 = 0 // 取得 num2 的位數  \n  → Step 9: sum = d1 + d2 + carry // 當前位總和  \n  → Step 10: carry = sum / 10 // 計算新的進位  \n  → Step 11: result += char((sum % 10) + '0') // 把本位數字加入結果  \n  → Step 12: i++ // 移到下一位  \n  → Step 13: j++ // 移到下一位  \n  → 返回 Decision // 重新檢查條件  \n  No  → Step 14: 反轉 result // 把結果從高位排列  \n  → Step 15: 返回 result // 輸出最終字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,2,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 2, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"隨機選取目標數字所在的索引。\"\"\"\n    def __init__(self, nums):\n        # 建立每個數值對應的索引列表\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機選取對應列表中的一個索引\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析成兩個列表：方法名稱與對應的參數列表\n    methods, args_list = eval(data)\n\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構物件\n            obj = Solution(*args)\n            results.append(None)  # 代表 null\n        else:\n            # 呼叫對應的方法並收集回傳值\n            func = getattr(obj, method)\n            results.append(func(*args))\n\n    # 以 JSON 格式輸出，讓 None 變成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line with explanation, not actual code. Should represent structure: Start, End, Decision. Steps: Constructor: store array. For pick: iterate over array, collect indices that match target, then pick random from list. Alternative using reservoir sampling. Use reservoir sampling to avoid storing all indices. Let's produce pseudocode.\n\nOutline:\n\nStart\n→ Step 1: Initialize Solution with nums\n   - store nums in instance variable\n\n→ Step 2: pick(target)\n   - initialize count=0, resultIndex = -1\n   - for each i from 0 to nums.length-1\n       if nums[i]==target\n           count++\n           if random(1..count)==1\n               resultIndex = i\n   - return resultIndex\n\nEnd\n\nAdd Decision for checking nums[i]==target, random selection.\n\nLet's produce line by line pseudocode with explanations.\n\nWe'll include arrows. Use \"Decision:\" for condition. Example:\n\nStart // program begins\n→ Step 1: Constructor(Solution) // 接收陣列 nums\n→ Decision: Store nums? // store the array\n\nBut we can more concise.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: Constructor(nums) // 將 nums 存於物件屬性\n→ Decision: None // (just store)\n→ Step 2: pick(target) // 針對目標值回傳隨機索引\n    → Step 2.1: count = 0 // 目前已見到的目標數量\n    → Step 2.2: result = -1 // 儲存候選索引\n    → For i in 0 .. nums.length-1 // 遍歷陣列\n        → Decision: if nums[i] == target? // 是否為目標值\n            Yes → Step 2.3: count = count + 1 // 增加計數\n            Yes → Step 2.4: if randomInt(1, count) == 1? // 隨機選取\n                Yes → Step 2.5: result = i // 設定為目前索引\n            No // 跳過\n        No // 跳過\n    → Step 2.6: return result // 回傳隨機索引\nEnd // 程式結束\n\nBut we need \"→\" arrow for each step. For loops, we can use \"→ For i = 0 to n-1\" and indent inside.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Constructor(nums) // 接收陣列並存於物件屬性  \n→ Step 2: pick(target) // 針對目標值回傳隨機索引  \n&nbsp;&nbsp;→ Step 2.1: count = 0 // 已見到的目標數量  \n&nbsp;&nbsp;→ Step 2.2: result = -1 // 儲存隨機選中的索引  \n&nbsp;&nbsp;→ For i = 0 to nums.length - 1 // 逐個遍歷陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: nums[i] == target? // 判斷當前元素是否為目標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.3: count = count + 1 // 增加計數  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.4: if randomInt(1, count) == 1? // 隨機選取機制  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2.5: result = i // 若被選中，更新索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 不被選中，保持現有索引  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 當前元素不是目標，直接跳過  \n&nbsp;&nbsp;→ Step 2.6: return result // 回傳隨機選中的索引  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立「單詞反轉」->索引 的映射\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 找出空字串索引，若存在\n        empty_idx = -1\n        for i, w in enumerate(words):\n            if w == \"\":\n                empty_idx = i\n                break\n\n        # 主循環：處理每個單詞\n        for i, word in enumerate(words):\n            # 完全翻轉匹配\n            if word[::-1] in rev_map:\n                j = rev_map[word[::-1]]\n                if j != i:\n                    res.append([i, j])\n\n            # 空字串特殊處理：空字串可與任何回文配對\n            if empty_idx != -1 and word != \"\" and word == word[::-1]:\n                res.append([empty_idx, i])\n                res.append([i, empty_idx])\n\n            # 逐個切分點檢查前綴/後綴是否為回文\n            for cut in range(1, len(word)):\n                prefix, suffix = word[:cut], word[cut:]\n\n                # 前綴為回文，後綴反轉可放在前面\n                if prefix == prefix[::-1]:\n                    rev_suffix = suffix[::-1]\n                    if rev_suffix in rev_map:\n                        j = rev_map[rev_suffix]\n                        if j != i:\n                            res.append([j, i])\n\n                # 後綴為回文，前綴反轉可放在後面\n                if suffix == suffix[::-1]:\n                    rev_prefix = prefix[::-1]\n                    if rev_prefix in rev_map:\n                        j = rev_map[rev_prefix]\n                        if j != i:\n                            res.append([i, j])\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit(0)\n\n    # 解析輸入：允許 \"words = [...]\" 或僅輸入列表字串\n    if data.lower().startswith(\"words\"):\n        _, arr_str = data.split(\"=\", 1)\n        arr_str = arr_str.strip()\n        words = ast.literal_eval(arr_str)\n    else:\n        words = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find all palindrome pairs with O(total length) complexity. Approach: For each word, insert reversed word into hash map with index. For each word, for each split position, check prefix/suffix palindrome. Complexity O(total length^2)? But we want O(total length). Standard solution: Build a map from reversed word to index. Then for each word, for each prefix that is palindrome, check if reversed suffix exists. Also handle full word reversed exists. Complexity: O(total length^2) worst-case? Actually standard solution is O(total length * average word length). The requirement O(sum of words[i].length). That's typical solution. We'll produce pseudocode accordingly.\n\nWe need to produce virtual code lines with explanation. Each step: Start, building map, loop over words, splits, decisions, etc. We need to ensure steps are logically correct. We'll not output actual code.\n\nWe need to mention hash map, isPalindrome function. We should outline algorithm. Provide steps.\n\nWe'll produce something like:\n\nStart\n→ Step 1: 建立空 hash map reverseMap // key: reversed word, value: index\n→ Step 2: 逐個遍歷 words，將 reversed(word) 存入 reverseMap // 建立反向查找表\n→ Step 3: 逐個遍歷 words，對每個單詞進行處理 // 主循環\n    → Step 4: 取得 currentWord, currentIndex\n    → Step 5: 若 currentWord 反向在 reverseMap 且不等於自身索引，則輸出 (currentIndex, reverseIndex) // 完全翻轉匹配\n    → Step 6: 針對 currentWord 進行所有可能的分割\n        → Decision: 將 currentWord 分割為 prefix, suffix // 迭代所有切點\n            Yes → Step 7: 若 prefix 為回文，查找 reversed(suffix) 在 reverseMap // suffix 的反向匹配\n                → Decision: 如果存在且索引不同\n                    Yes → Step 8: 輸出 (reverseIndex, currentIndex) // suffix + currentWord 成回文\n            No → (continue)\n            Yes → Step 9: 若 suffix 為回文，查找 reversed(prefix) 在 reverseMap // prefix 的反向匹配\n                → Decision: 如果存在且索引不同\n                    Yes → Step 10: 輸出 (currentIndex, reverseIndex) // currentWord + prefix 成回文\nEnd\n\nAlso handle empty string special case: if empty string present, pair with any palindrome word.\n\nAdd steps for that.\n\nWe'll produce final output accordingly. Ensure each line follows format.\n\nLet's produce lines.\n\nWe'll include comments. Ensure each line has virtual code step + space + // explanation.\n\nWe'll use arrows \"→\" to indicate flow. We'll nest decisions with indentation maybe.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空 hash map reverseMap // key: words[i] 的反轉字串，value: 該字串索引  \n→ Step 2: 逐個遍歷 words，將每個 words[i] 反轉後存入 reverseMap  \n  → Decision: words[i] 已存在於 reverseMap? // 防止重複鍵，雖不必要但示範  \n   Yes → Skip // 若已存在則略過  \n   No  → reverseMap[reverse(words[i])] = i // 存入映射  \n→ Step 3: 檢查空字串是否存在於 words，若存在則將其索引存入 emptyIndex  \n  → Decision: 0 in words?  \n   Yes → emptyIndex = index_of_empty_string  \n   No  → emptyIndex = -1 // 表示不存在  \n→ Step 4: 逐個遍歷 words，處理每個字串 currentWord  \n  → Step 4a: 取得 currentIndex = i, currentWord = words[i]  \n  → Decision: currentWord 反轉後存在於 reverseMap 且 reverseIndex ≠ currentIndex? // 完全翻轉匹配  \n   Yes → Step 4b: 輸出 (currentIndex, reverseIndex) // currentWord + reverseWord 形成回文  \n   No  → (不執行)  \n  → Decision: emptyIndex ≠ -1 且 currentWord 本身為回文? // 空字串可與任何回文配對  \n   Yes → Step 4c: 輸出 (emptyIndex, currentIndex)  \n   No  → (不執行)  \n  → Step 4d: 針對 currentWord 的所有可能分割點 j (0..len(currentWord))  \n   → Decision: j == 0? // 特殊分割，前綴為空  \n    Yes → 前綴空不需檢查  \n    No  → Step 4d1: prefix = currentWord[0:j], suffix = currentWord[j:]  \n    → Decision: prefix 為回文? // 若前綴回文，則 suffix 反轉可以放在前面  \n     Yes → Step 4d2: reversedSuffix = reverse(suffix)  \n      → Decision: reversedSuffix 在 reverseMap 且 reverseIndex ≠ currentIndex?  \n       Yes → Step 4d3: 輸出 (reverseIndex, currentIndex) // reversedSuffix + currentWord 成回文  \n       No  → (不執行)  \n     No  → (不執行)  \n    → Decision: suffix 為回文? // 若後綴回文，則 prefix 反轉可以放在後面  \n     Yes → Step 4d4: reversedPrefix = reverse(prefix)  \n      → Decision: reversedPrefix 在 reverseMap 且 reverseIndex ≠ currentIndex?  \n       Yes → Step 4d5: 輸出 (currentIndex, reverseIndex) // currentWord + reversedPrefix 成回文  \n       No  → (不執行)  \n     No  → (不執行)  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):          # 0 ~ len(s)-10 inclusive\n            seq = s[i:i + 10]                # 10‑letter substring\n            if seq in seen:\n                repeated.add(seq)           # 第一次重複才加入\n            else:\n                seen.add(seq)               # 首次遇到就記錄\n        return list(repeated)\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從字串中抽出引號內的 DNA 序列\n    match = re.search(r\"(['\\\"])(.*?)\\1\", data, re.DOTALL)\n    if match:\n        dna_seq = match.group(2)\n    else:\n        dna_seq = data  # 直接使用整段輸入\n\n    sol = Solution()\n    result = sol.findRepeatedDnaSequences(dna_seq)\n\n    # 以 Python list 的文字表示輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. This is like LeetCode problem \"Repeated DNA Sequences\". We should produce steps: Input string s; use hash map to count substrings of length 10; iterate, add to map, track repeated; output list. The virtual code must be line by line with arrow notation. Let's design:\n\nStart\n→ Step 1: Initialize hash map counts // map substring -> count\n→ Step 2: Initialize result list // list of repeated sequences\n→ Decision: If length(s) < 10? // too short to have any 10-length substring\n    Yes → End // no sequences\n    No  →\n→ Step 3: For i from 0 to len(s)-10 // iterate over all 10-length substrings\n    → Step 4: substring = s.substring(i, i+10) // extract 10-letter substring\n    → Decision: If substring exists in counts? // check if seen before\n        Yes →\n            → Step 5: If counts[substring] == 1? // first time it's repeated\n                Yes →\n                    → Step 6: Add substring to result list // add to result\n                No →\n                    → // already added, do nothing\n            → Step 7: Increment counts[substring] // increase count\n        No →\n            → Step 8: counts[substring] = 1 // first occurrence\n→ Step 9: Return result list // output all repeated sequences\nEnd\n\nWe need arrow indenting. Also each line must have code step and comment.\n\nWe must be careful to use \"Decision:\" for conditional branches. For loops we can denote as \"Loop: ...\". But examples show \"→ Step 1:\" etc. We can use \"→ Decision:\" etc.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Provide line by line.\n\nWe can use \"Loop:\" or just \"→ Step 3:\" but inside maybe \"→ For i in range(0, len(s)-9) // iterate\". Good.\n\nWe need to use \"Yes →\" and \"No →\".\n\nAlso we need to include \"Start\" and \"End\".\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: Initialize hash map counts // 建立雜湊表存儲子字串及其出現次數\n→ Step 2: Initialize result list // 存放重複出現的 10 字母子字串\n→ Decision: s.length < 10? // 檢查輸入長度是否足以形成 10 字母子字串\n    Yes → End // 長度不足，直接結束\n    No  →\n→ Step 3: For i from 0 to s.length - 10 // 遍歷所有可能的 10 字母子字串位置\n    → Step 4: substring = s.substring(i, i + 10) // 取得目前位置的 10 字母子字串\n    → Decision: counts.containsKey(substring)? // 子字串是否已出現\n        Yes →\n            → Step 5: If counts[substring] == 1? // 第一次重複出現\n                Yes →\n                    → Step 6: result.add(substring) // 加入結果清單\n                No →\n                    → // 已經加入，無需再次加入\n            → Step 7: counts[substring] += 1 // 更新計數\n        No →\n            → Step 8: counts[substring] = 1 // 初次出現，計數設為 1\n→ Step 9: Return result // 回傳所有重複的 10 字母子字串\nEnd // 程式執行結束\n```\n\nNeed to ensure each line ends with //.\n\nAlso use arrow for each line? In example, they used \"→ Step 1:\" etc. We'll maintain that.\n\nAlso for decisions inside loops, we need indentation maybe with spaces? Example uses indent for nested decisions. We'll just indent.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize hash map counts // 建立雜湊表存儲子字串及其出現次數  \n→ Step 2: Initialize result list // 存放重複出現的 10 字母子字串  \n→ Decision: s.length < 10? // 檢查輸入長度是否足以形成 10 字母子字串  \n Yes → End // 長度不足，直接結束  \n No →  \n→ Step 3: For i from 0 to s.length - 10 // 遍歷所有可能的 10 字母子字串位置  \n → Step 4: substring = s.substring(i, i + 10) // 取得目前位置的 10 字母子字串  \n → Decision: counts.containsKey(substring)? // 子字串是否已出現  \n  Yes →  \n   → Step 5: If counts[substring] == 1? // 第一次重複出現  \n    Yes →  \n     → Step 6: result.add(substring) // 加入結果清單  \n    No →  \n     → // 已經加入，無需再次加入  \n    → Step 7: counts[substring] += 1 // 更新計數  \n  No →  \n   → Step 8: counts[substring] = 1 // 初次出現，計數設為 1  \n→ Step 9: Return result // 回傳所有重複的 10 字母子字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        Generate all permutations of a list of distinct integers.\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 若已經選到最後一個位置，將目前排列加入結果\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            # 嘗試將每個可能的元素放到目前位置\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入，例如 \"nums = [1,2,3]\"\n    if '=' in raw_input:\n        _, expr = raw_input.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = raw_input\n\n    # 安全地將字串轉為 Python 對象\n    nums = ast.literal_eval(expr)\n\n    # 計算排列並輸出\n    solution = Solution()\n    permutations = solution.permute(nums)\n    print(permutations)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of distinct integers. Must follow format: each line \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, arrows. Should be line by line.\n\nWe need to think of algorithm: backtracking: function permute(nums): call backtrack(current, remaining). Use recursion or iterative. Steps: Start, Step 1: define result list. Step 2: call backtrack with empty path and copy of nums. Step 3: inside backtrack, Decision: if remaining empty? Yes → add path to result; No → iterate over remaining: for each i: choose nums[i], remove from remaining, add to path, call backtrack, backtrack: remove last from path, restore remaining.\n\nNeed to produce step lines. Might need to specify recursion.\n\nWe'll produce high-level pseudocode lines. Use arrows \"→\". Decision lines. Use indentation to indicate branches. Provide explanation after //.\n\nLet's write.\n\nStart // 程式開始執行\n→ Step 1: 定義結果列表 result ← 空列表 // 用於儲存所有排列\n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current: 已選取的元素序列; remaining: 剩餘待選的元素\n→ Step 3: 呼叫 backtrack([], nums) // 開始遞迴，初始時已選取為空，剩餘為整個陣列\n→ Step 4: 回傳 result // 返回所有排列\n\nNow inside backtrack definition:\n\n→ Decision: 若 remaining 為空? // 判斷是否已選完所有元素\n    Yes → Step 5: 將 current 複製並加入 result // 完整排列完成，加入結果\n    No → Step 6: 對 remaining 中每個元素 i 迭代 // 將每個可選元素作為下一步\n        → Step 7: current ← current ∪ [i] // 將 i 加入已選序列\n        → Step 8: remaining ← remaining \\ {i} // 移除 i 從剩餘\n        → Step 9: 呼叫 backtrack(current, remaining) // 進一步遞迴\n        → Step 10: current ← current \\ [i] // 回溯，移除最後加入的元素\n        → Step 11: remaining ← remaining ∪ {i} // 將 i 恢復回剩餘\n\nBut we need to indicate that backtrack definition is inside earlier step lines. Use indentation or explicit. But each line is separate with arrow. Provide explanation.\n\nLet's craft final output lines.\n\nMake sure each line includes \"→\" for steps or decision. Indentation lines might have additional spaces before arrow for readability but not required. Should reflect structure.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果列表 result ← 空列表 // 用於儲存所有排列  \n→ Step 2: 定義遞迴函式 backtrack(current, remaining) // current: 已選取的元素序列; remaining: 剩餘待選的元素  \n→ Step 3: 呼叫 backtrack([], nums) // 開始遞迴，初始時已選取為空，剩餘為整個陣列  \n→ Step 4: 回傳 result // 返回所有排列  \n\n→ Decision: 若 remaining 為空? // 判斷是否已選完所有元素  \n    Yes → Step 5: 將 current 複製並加入 result // 完整排列完成，加入結果  \n    No  → Step 6: 對 remaining 中每個元素 i 迭代 // 將每個可選元素作為下一步  \n        → Step 7: current ← current ∪ [i] // 將 i 加入已選序列  \n        → Step 8: remaining ← remaining \\ {i} // 移除 i 從剩餘  \n        → Step 9: 呼叫 backtrack(current, remaining) // 進一步遞迴  \n        → Step 10: current ← current \\ [i] // 回溯，移除最後加入的元素  \n        → Step 11: remaining ← remaining ∪ {i} // 將 i 恢復回剩餘  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe4tijkdt.py\", line 72, in <module>\n    main()\n  File \"/tmp/tmpe4tijkdt.py\", line 51, in main\n    ops, args = parse_input()\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmpe4tijkdt.py\", line 40, in parse_input\n    ops = json.loads(ops_str)\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 24 (char 23)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.data)\n\ndef parse_input():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return [], []\n    lines = raw.splitlines()\n    if len(lines) == 1:\n        # Maybe the two lists are on the same line separated by comma\n        line = lines[0].strip()\n        if ',' in line:\n            ops_str, args_str = line.split(',', 1)\n            ops = json.loads(ops_str)\n            args = json.loads(args_str)\n        else:\n            ops = json.loads(line)\n            args = json.loads(sys.stdin.read())\n    else:\n        ops = json.loads(lines[0])\n        args = json.loads(lines[1])\n    return ops, args\n\ndef main():\n    ops, args = parse_input()\n    obj = None\n    res = []\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            res.append(None)\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n    # Format output to match LeetCode style\n    out = '[' + ', '.join(\n        'null' if v is None else ('true' if v is True else 'false' if v is False else str(v))\n        for v in res\n    ) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode line by line with explanations. Need to cover class, data structures, insert, remove, getRandom, all O(1) average. We'll design using vector (list) to store values, and hash map from val to set of indices (maybe list). We'll produce steps: initialization: array, dict.\n\nWe'll produce pseudocode for class methods. Use Start, End for overall? We may show pseudocode for each method. Format: \"Start // 程式開始執行\" but for class we might use \"Start // RandomizedCollection 初始化\" etc.\n\nBut requirement: Output must be line-by-line with virtual code and explanation. We should provide steps for all functions. We'll structure each method's algorithm. We'll include decision statements. Let's produce pseudocode.\n\nWe'll start with class definition. Use 'Class RandomizedCollection // 定義資料結構' as first line? But format expects Start. Maybe we can treat overall algorithm. But might be okay.\n\nBetter: Provide pseudocode for the whole structure, then each method. We'll separate blocks with blank lines? Not allowed? Only each line. But we can include 'Class RandomizedCollection // 定義類別' as a line. We'll not use Start/End for entire, but for methods. We could use Start for each method.\n\nLet's produce:\n\nLine1: Class RandomizedCollection // 定義類別\nLine2: → data: Array<int> nums // 存儲所有元素\nLine3: → map: Dictionary<int, Set<int>> idx // 每個值對應其在 nums 的索引集合\n\nThen methods.\n\nInsert method:\n\nStart // 插入元素\n→ Step 1: Append val to nums // 把 val 加到陣列尾部\n→ Step 2: Record index = nums.length - 1 // 新增的索引\n→ Step 3: If idx[val] not exists: Create empty set // 初始化集合\n→ Step 4: Add index to idx[val] // 索引加入集合\n→ Step 5: If idx[val] size was 1 after insertion: return true // 之前不存在\n→ Step 6: Else return false // 之前已存在\n\nRemove method:\n\nStart // 刪除元素\n→ Decision: 如果 idx[val] 為空? // 檢查是否存在\n    No  → Return false // 沒有該元素\n    Yes → Proceed\n→ Step 1: Get an arbitrary index from idx[val] // 取一個索引\n→ Step 2: Remove that index from idx[val] // 從集合刪除\n→ Step 3: If idx[val] is empty: Delete idx[val] // 清除空集合\n→ Step 4: Get lastIndex = nums.length - 1 // 最後一個索引\n→ Step 5: If index != lastIndex: // 被刪除的不是最後一個\n        Step 5.1: Move lastVal = nums[lastIndex] // 取最後一個值\n        Step 5.2: Set nums[index] = lastVal // 覆蓋\n        Step 5.3: Update idx[lastVal]: remove lastIndex; add index // 更新索引集合\n→ Step 6: Remove last element from nums // 物理刪除\n→ Step 7: Return true // 刪除成功\n\ngetRandom method:\n\nStart // 隨機取值\n→ Step 1: Generate random integer r in [0, nums.length-1] // 隨機索引\n→ Step 2: Return nums[r] // 返回對應值\n\nEnd of class.\n\nBut we must use arrow syntax: \"→\" for steps. Decision with indentation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nClass RandomizedCollection // 定義隨機集合類別\n→ nums : Array<int> // 存放所有元素，支持隨機索引\n→ idx : Dictionary<int, Set<int>> // 每個值對應其在 nums 中的索引集合\n\n// =====================  insert 方法 =====================\nStart // 插入元素\n→ Step 1: Append val to nums // 把 val 加到陣列尾部\n→ Step 2: newIndex := nums.length - 1 // 記錄新元素的索引\n→ Decision: idx[val] 是否存在?\n    Yes → Step 3: Add newIndex to idx[val] // 已存在則直接加入集合\n    No  → Step 3: idx[val] := New Set // 初始化集合\n          → Step 4: Add newIndex to idx[val] // 新增索引\n→ Decision: idx[val] 的大小是否為 1?\n    Yes → Return true // 之前該值未出現\n    No  → Return false // 之前已存在\n\n// =====================  remove 方法 =====================\nStart // 刪除元素\n→ Decision: idx[val] 是否為空?\n    No  → Step 1: targetIndex := Arbitrary element from idx[val] // 取一個索引\n          → Step 2: Remove targetIndex from idx[val] // 從集合移除\n          → Decision: idx[val] 是否為空?\n                Yes → Delete idx[val] // 清除空集合\n          → Step 3: lastIndex := nums.length - 1 // 最後一個元素的索引\n          → Decision: targetIndex != lastIndex?\n                Yes → Step 4: lastVal := nums[lastIndex] // 取最後一個值\n                      → Step 5: nums[targetIndex] := lastVal // 覆蓋目標位置\n                      → Step 6: Remove lastIndex from idx[lastVal] // 移除舊索引\n                      → Step 7: Add targetIndex to idx[lastVal] // 加入新索引\n                No  → // 被刪除的是最後一個，無需搬移\n          → Step 8: Remove last element from nums // 物理刪除\n          → Return true // 刪除成功\n    Yes → Return false // 該值不存在\n\n// =====================  getRandom 方法 =====================\nStart // 隨機取值\n→ Step 1: r := RandomInteger(0, nums.length - 1) // 產生隨機索引\n→ Step 2: Return nums[r] // 返回隨機元素\n\nEnd // RandomizedCollection 類別結束\n```"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpess04ve3.py\", line 68, in <module>\n    main()\n  File \"/tmp/tmpess04ve3.py\", line 48, in main\n    ops, args = json.loads(data)\n                ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 75 (char 74)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    \"\"\"用兩個堆（最大堆與最小堆）實現動態中位數查詢。\"\"\"\n\n    def __init__(self):\n        # small 儲存較小一半的數字，使用負值實現最大堆\n        self.small = []\n        # large 儲存較大一半的數字，最小堆\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        \"\"\"將新數字加入資料結構。\"\"\"\n        # 把新數字先塞進 small（最大堆）\n        heapq.heappush(self.small, -num)\n\n        # 保持兩堆有序：small 的最大值不應大於 large 的最小值\n        if self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 重新平衡兩堆大小，允許的差值最多為 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        \"\"\"回傳目前所有元素的中位數。\"\"\"\n        if len(self.small) > len(self.large):\n            # 小堆多一個，直接回傳最大值\n            return -self.small[0]\n        else:\n            # 大小相等，回傳兩個堆頂平均值\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 以 JSON 方式解析輸入，輸入形式為兩個列表\n    ops, args = json.loads(data)\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            results.append(obj.findMedian())\n\n    # 將結果轉成 JSON 字串，None 會被轉成 null\n    print(json.dumps(results))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for implementing MedianFinder class with addNum and findMedian. Use virtual code with arrows, decisions. Must be line by line. Provide each line with explanation.\n\nWe need to outline algorithm: use two heaps: max heap for lower half, min heap for upper half. Add number: push to appropriate heap; rebalance sizes; findMedian: if equal sizes, return average; else return top of larger heap. Need initialization. Provide steps for class, constructor, methods, heap operations.\n\nWe should structure: Start, Step: Initialize two heaps, etc. For each method, use decision flows.\n\nLet's produce pseudo-code.\n\nRemember to not output actual code, just steps. Use arrow →, Decision: etc. Each line with comment.\n\nLet's produce lines. Use indent? Just arrow. Use Start and End at top level? Maybe at each method start. Provide class-level start and end? But instructions: each line must contain virtual code step + comment. They gave example with Start/End overall. We'll produce top-level: Start, → Step: Define class MedianFinder, etc.\n\nOk. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MedianFinder // 建立一個類別來儲存資料結構  \n→ Step 2: 建立 maxHeap: 儲存較小一半的數字（最大堆） // 方便取得中位數左側最大值  \n→ Step 3: 建立 minHeap: 儲存較大一半的數字（最小堆） // 方便取得中位數右側最小值  \n\n→ Step 4: 定義 Constructor MedianFinder() // 初始化物件  \n→     → Step 5: maxHeap ← 空堆 // 初始時兩堆皆為空  \n→     → Step 6: minHeap ← 空堆  \n\n→ Step 7: 定義 方法 addNum(num: 整數) // 將新數字加入資料結構  \n→     → Decision: 如果 maxHeap 為空 或 num ≤ maxHeap.top()? // 判斷將數字放入哪一堆  \n→         Yes → Step 8: maxHeap.insert(num) // 小於等於左側最大值，放入 maxHeap  \n→         No  → Step 9: minHeap.insert(num) // 大於左側最大值，放入 minHeap  \n\n→     → Step 10: Decision: maxHeap.size() - minHeap.size() > 1? // 檢查左堆是否過大  \n→         Yes → Step 11: minHeap.insert(maxHeap.extractMax()) // 將 maxHeap 最高值移到 minHeap  \n→     → Decision: minHeap.size() - maxHeap.size() > 1? // 檢查右堆是否過大  \n→         Yes → Step 12: maxHeap.insert(minHeap.extractMin()) // 將 minHeap 最小值移到 maxHeap  \n\n→ Step 13: 定義 方法 findMedian() → double // 取得目前所有數字的中位數  \n→     → Decision: maxHeap.size() == minHeap.size()? // 堆大小相等，數字個數為偶數  \n→         Yes → Step 14: return (maxHeap.top() + minHeap.top()) / 2.0 // 取兩堆頂部平均  \n→         No  → Decision: maxHeap.size() > minHeap.size()? // 左堆較大  \n→             Yes → Step 15: return maxHeap.top() // 左堆頂部即中位數  \n→             No  → Step 16: return minHeap.top() // 右堆頂部即中位數  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '-1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '-1'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef collapse(s: str) -> str:\n    \"\"\"\n    Repeatedly remove groups of 3 or more consecutive identical characters.\n    \"\"\"\n    while True:\n        n = len(s)\n        i = 0\n        new_s = []\n        changed = False\n        while i < n:\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            if j - i >= 3:\n                changed = True\n                # skip this group\n                i = j\n            else:\n                new_s.append(s[i:j])\n                i = j\n        s = \"\".join(new_s)\n        if not changed:\n            break\n    return s\n\ndef find_min_step(board: str, hand: str) -> int:\n    hand_count = Counter(hand)\n    memo = {}\n    INF = 10 ** 9\n\n    def dfs(cur_board: str) -> int:\n        if not cur_board:\n            return 0\n        key = (cur_board, tuple(sorted(hand_count.items())))\n        if key in memo:\n            return memo[key]\n\n        best = INF\n        n = len(cur_board)\n        # Try inserting each ball from hand at every possible position\n        for pos in range(n + 1):\n            for color, cnt in list(hand_count.items()):\n                if cnt == 0:\n                    continue\n                # Insert the ball\n                new_board = cur_board[:pos] + color + cur_board[pos:]\n                # Collapse the board\n                collapsed = collapse(new_board)\n                hand_count[color] -= 1\n                sub = dfs(collapsed)\n                if sub != INF:\n                    best = min(best, sub + 1)\n                hand_count[color] += 1\n\n        memo[key] = best\n        return best\n\n    ans = dfs(board)\n    return -1 if ans == INF else ans\n\ndef parse_input(data: str):\n    board_match = re.search(r'board\\s*=\\s*[\"\\']?([^\"\\']+?)[\"\\']?', data)\n    hand_match = re.search(r'hand\\s*=\\s*[\"\\']?([^\"\\']+?)[\"\\']?', data)\n    board = board_match.group(1) if board_match else \"\"\n    hand = hand_match.group(1) if hand_match else \"\"\n    return board, hand\n\ndef main():\n    data = sys.stdin.read()\n    board, hand = parse_input(data)\n    result = find_min_step(board, hand)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code that solves the Zuma problem. Need to output line-by-line steps with comments. This is a standard BFS / DFS with state as board string and hand counts. Use recursion with memoization to find min insertions. We produce algorithm description steps. Not actual code. Just steps. Use arrow and decision. Provide comments. Let's design algorithm:\n\nStart\n\n→ Build hand count map from hand string\n\n→ Define recursive function dfs(board, handCount) returns min steps\n\n→ Base: if board empty return 0\n\n→ If hand empty return INF\n\n→ For each position i from 0 to board length:\n\n   - For each color c in handCount >0:\n\n      * Try insert at position i: newBoard = insert board at i with c\n\n      * While true: find contiguous segment of same color around inserted index, if length>=3 remove, update board, else break\n\n      * Reduce handCount[c] by 1\n\n      * Recursively compute dfs(newBoard, handCount) +1\n\n      * Keep min\n\n→ Memoize result for board+handCount key\n\nReturn min else INF.\n\nEdge: insert between identical groups may lead to removal.\n\nSimplify: iterate over board indices where board[i]==board[i+1] or at ends.\n\nBut we just produce high-level pseudocode.\n\nLet's produce steps:\n\nStart\n\n→ Step 1: Convert hand string into count map\n\n→ Step 2: Define DFS function with memoization\n\n    → Decision: board empty? // if board empty return 0\n\n    → Decision: hand empty? // if hand empty return INF\n\n    → Initialize result to INF\n\n    → For each index i from 0 to board length:\n\n        → For each color c with count>0:\n\n            → Step: create new board by inserting c at position i\n\n            → Step: While true: find consecutive same color group around insertion point\n\n                 Decision: group length >=3? // if yes remove group and collapse, continue loop\n\n                 else break\n\n            → Step: decrement hand count for c\n\n            → Step: compute temp = 1 + dfs(newBoard, handCount)\n\n            → Step: result = min(result, temp)\n\n            → Step: restore hand count for c\n\n    → Step: memoize result for state\n\n    → Return result\n\n→ Step 3: Call dfs(board, handCount)\n\n→ Decision: result >= INF? // if impossible return -1 else result\n\nEnd\n\nAdd comments each line.\n\nLet's format with arrows. Use `→` for steps, `Decision:` for decisions.\n\nBe careful to maintain consistent formatting. Each line: `虛擬碼步驟 // 解釋/說明`\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 轉換 hand 字串為顏色計數表 // 方便快速取得每種顏色剩餘數量  \n→ Step 2: 建立 memo 物件用於存儲已計算狀態 // 避免重複計算  \n→ Step 3: 定義遞迴函式 dfs(board, handCount) // 主要邏輯，返回最小插入次數  \n\n    → Decision: 若 board 為空? // 直接成功  \n        Yes → Step 4: 回傳 0 // 需要的插入次數為零  \n        No →  \n\n    → Decision: 若 handCount 全為 0? // 沒有球可插  \n        Yes → Step 5: 回傳 INF // 表示此路徑不可行  \n        No →  \n\n    → Step 6: 初始化 minStep 為 INF // 用於記錄最小插入次數  \n\n    → For i 在 0 到 board.length  \n        → For 每顏色 c 其 handCount[c] > 0  \n            → Step 7: 新建新板 newBoard = board 在位置 i 插入 顏色 c // 模擬插入  \n            → Step 8: 讓 newBoard 進行消除迴圈  \n                → While true  \n                    → Step 9: 在 newBoard 找到插入點附近連續相同顏色的區塊 (左邊界 L, 右邊界 R) // 透過指針掃描  \n                    → Decision: (R - L + 1) >= 3? // 區塊長度是否足以消除  \n                        Yes → Step 10: 移除區塊並把左邊和右邊合併成 newBoard // 繼續檢查可能的連鎖  \n                        No → Break // 無法再消除，結束迴圈  \n                → End While  \n            → Step 11: 減少 handCount[c] 1，並呼叫 dfs(newBoard, handCount)  \n                → Step 12: temp = 1 + dfs(newBoard, handCount) // 這一次插入加上後續最小步數  \n            → Step 13: minStep = min(minStep, temp) // 更新全局最小值  \n            → Step 14: 回復 handCount[c] 加 1 // 恢復狀態以供下一個顏色嘗試  \n        → End For  \n    → End For  \n    → Step 15: 在 memo 中記錄此 (board, handCount) 的結果為 minStep  \n    → Step 16: 回傳 minStep  \n\n→ Step 17: 計算 ans = dfs(initialBoard, handCount) // 呼叫主函式  \n→ Decision: ans >= INF? // 判斷是否可行  \n    Yes → Step 18: 回傳 -1 // 無法清除全部球  \n    No  → Step 19: 回傳 ans // 最小插入數量  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum IV",
      "source_file": "Leetcode/leetcode377.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwmnsfaz5.py\", line 36, in <module>\n    main()\n  File \"/tmp/tmpwmnsfaz5.py\", line 19, in main\n    data[key] = ast.literal_eval(val)\n                ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef main():\n    # 讀取整個標準輸入，去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 解析輸入，假設格式類似: 'nums = [1,2,3], target = 4'\n    parts = raw_input.split(',')\n    data = {}\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            # 用 ast.literal_eval 解析值，安全地處理 list 與 int\n            data[key] = ast.literal_eval(val)\n\n    nums = data.get('nums', [])\n    target = data.get('target', 0)\n\n    # DP 解法：計算所有排列組合的數量\n    dp = [0] * (target + 1)\n    dp[0] = 1  # 只有一種方式達到 0：不選任何數字\n\n    for i in range(1, target + 1):\n        for num in nums:\n            if i - num >= 0:\n                dp[i] += dp[i - num]\n\n    print(dp[target])\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: Given array distinct integers nums, target, return number of combinations that sum to target. This is similar to \"Combination Sum IV\" (Leetcode 377). Need DP counting order matters. Use DP array dp[0..target], dp[0]=1; for i from 1..target, for each num in nums if num <= i: dp[i] += dp[i-num]. Output dp[target].\n\nWe must produce virtual code line by line with explanations. Format: \"虛擬碼步驟 // 解釋\".\n\nAlso use arrows. We'll produce steps: Start, Step 1: Initialize dp array, Step 2: Iterate i from 1 to target, Step 3: Inner loop over nums, Decision: if num <= i? Yes -> update dp[i], else skip. End. Return dp[target]. Use arrow notation. Let's craft. Ensure each line ends with // explanation. Use Chinese. Let's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度為 target + 1 並全部設為 0 // 初始化 dp，dp[i] 代表達到目標 i 的組合數\n→ Step 2: 設定 dp[0] 為 1 // 只有一種方式達到 0：不取任何數字\n→ Step 3: 迭代 i 從 1 到 target // 逐步計算每個子目標的組合數\n    → Decision: 若 i < 1? // 確保 i 為有效子目標\n        Yes → Skip // i 為 0 時已處理，直接跳過\n        No  → 進入內部循環\n            → Step 4: 迭代每個 num 在 nums 中 // 嘗試以每個數字作為最後一個加數\n                → Decision: 若 num > i? // 如果數字大於目前子目標，不能使用\n                    Yes → Skip // 跳過此 num\n                    No  → Step 5: 更新 dp[i] ← dp[i] + dp[i - num] // 加上以此 num 結尾的組合數\n→ Step 6: 回傳 dp[target] // 結果即為達到目標的總組合數\nEnd // 程式執行結束"
    },
    {
      "title": "K-diff Pairs in an Array",
      "source_file": "Leetcode/leetcode532.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpphz4e2td.py\", line 31, in <module>\n    main()\n  File \"/tmp/tmpphz4e2td.py\", line 25, in main\n    nums = ast.literal_eval(arr_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2datqrc_.py\", line 31, in <module>\n    main()\n  File \"/tmp/tmp2datqrc_.py\", line 25, in main\n    nums = ast.literal_eval(arr_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2wj5uad8.py\", line 31, in <module>\n    main()\n  File \"/tmp/tmp2wj5uad8.py\", line 25, in main\n    nums = ast.literal_eval(arr_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\ndef findPairs(nums, k):\n    \"\"\"\n    Count unique k-diff pairs in the list `nums`.\n    A pair (i, j) is unique if nums[i] != nums[j] and |nums[i] - nums[j]| == k.\n    \"\"\"\n    if k < 0:               # absolute difference cannot be negative\n        return 0\n    freq = Counter(nums)\n    if k == 0:\n        # For k==0 we need numbers that appear at least twice\n        return sum(v > 1 for v in freq.values())\n    # For k>0 count each number that has a counterpart n+k\n    return sum((n + k) in freq for n in freq)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Input format: \"[3,1,4,1,5], 2\"\n    arr_part, k_part = data.split(',', 1)\n    nums = ast.literal_eval(arr_part.strip())\n    k = int(k_part.strip())\n    result = findPairs(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find number of unique k-diff pairs. Approach: use set for numbers, count unique pairs. If k==0, need count of numbers with freq>1. Else, for each num in set, check if num+k in set, count. Complexity O(n). We'll produce steps with Start, Decision, End. Need to include array input, k. Provide line by line.\n\nLet's write:\n\nStart // start\n→ Step 1: Read nums array and k // get inputs\n→ Step 2: Create freq map from nums // count occurrences\n→ Step 3: Initialize result = 0 // pair count\n→ Decision: If k < 0? // negative k invalid\n    No → proceed\n    Yes → Step 4: Return result // no pairs\n→ Decision: If k == 0? // special case\n    Yes → Step 5: For each (num, count) in freq\n            If count > 1\n                result += 1\n        Step 6: Return result\n    No → Step 7: Create set of unique numbers from freq keys // for fast lookup\n    Step 8: For each num in set\n            If num + k in set\n                result += 1\n    Step 9: Return result\nEnd\n\nNeed to format each line with arrow and comment. For loops we can show arrow with indentation? Use → Step... For decisions we need nested arrows: Yes → ... No → ... but we might not need both in same line. Use indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取陣列 nums 與整數 k // 從使用者取得輸入  \n→ Step 2: 建立頻率地圖 freq = {} // 計算每個數字出現的次數  \n→ Step 3: 設定 result = 0 // 用來儲存唯一 k‑diff 對的數量  \n→ Decision: k 是否小於 0? // k 為負時無合法對  \n    No → // k ≥ 0，繼續  \n    Yes → Step 4: 回傳 result // 沒有合法對，直接結束  \n→ Decision: k 是否等於 0? // 特殊情況  \n    Yes → Step 5: 對每個 (num, count) 在 freq 中  \n            → Decision: count 是否大於 1? // 需要至少兩個相同數字  \n                Yes → result += 1 // 計入一對相同數字的對  \n                No  → // 只有一個，無對  \n        Step 6: 回傳 result // 結束特殊情況  \n    No → Step 7: 建立 uniqueSet = set(freq.keys()) // 取得所有不重複的數字  \n    → Step 8: 對每個 num 在 uniqueSet 中  \n            → Decision: (num + k) 是否存在於 uniqueSet? // 檢查是否形成合法對  \n                Yes → result += 1 // 成功形成一對  \n                No  → // 無對，忽略  \n    Step 9: 回傳 result // 所有情況處理完畢  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbofqzk31.py\", line 38, in <module>\n    res = obj.add(arg)\n          ^^^^^^^^^^^^\n  File \"/tmp/tmpbofqzk31.py\", line 14, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgs35xjb6.py\", line 38, in <module>\n    res = obj.add(arg)\n          ^^^^^^^^^^^^\n  File \"/tmp/tmpgs35xjb6.py\", line 14, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Split into two parts: commands list and arguments list\n    first_close = data.find(']')\n    commands_str = data[:first_close + 1]\n    args_str = data[first_close + 2:].strip()\n    commands = ast.literal_eval(commands_str)\n    args_list = ast.literal_eval(args_str)\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args_list):\n        if cmd == \"KthLargest\":\n            k, nums = arg\n            obj = KthLargest(k, nums)\n            result.append(None)\n        elif cmd == \"add\":\n            res = obj.add(arg)\n            result.append(res)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, describing logic of KthLargest class. Use start, decision, arrows, no actual code. Provide each line with \"虛擬碼步驟 // 解釋\". Must be in Traditional Chinese. The code will be conceptual: maintain a min-heap of size k. For each add, push, if size>k pop. Return heap root. Also constructor: initialize heap with first nums, maintain size k by adding each number. Provide steps. Let's output each step as per format.\n\nWe need to produce a flowchart-like pseudocode, step-by-step. Might need multiple lines: Start, initialize min-heap, add initial numbers, etc. Each line uses arrow →.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: 初始化空的最小堆 // 建立一個容量可動態增減的最小堆\n→ Step 2: 儲存 k // 將 k 存入成員變數\n→ Step 3: For 每個 num in nums // 處理初始陣列\n    → Decision: If 堆大小 < k? // 若堆還未滿k\n        Yes → Step 4: 插入 num 至堆 // 把數值加入堆中\n        No → Step 5: 如果 num > 堆最小值? // 堆已滿k，檢查是否比最小值大\n            Yes → Step 6: 替換堆最小值為 num // 移除最小值並加入 num\n            No → Step 7: 跳過 // num 不足以成為 k 大的\n→ Step 8: End of constructor // 構造完成\n→ Function add(val) // 定義 add 方法\n    → Step 9: 插入 val 至堆 // 無論堆大小\n    → Decision: 如果堆大小 > k? // 檢查是否超過 k\n        Yes → Step 10: 移除堆最小值 // 將最小值踢出以維持大小\n        No → No change\n    → Step 11: 回傳 堆最小值 // 堆根即為 kth 大\n→ End // 程式結束\n\nWe might need to break decision branches properly with arrows. Use indentation. Use \"Decision:\" lines with arrow. Format: `Decision: 如果 ...?` with Yes→/No→.\n\nMake sure each line includes \"// 解釋\". Provide in Traditional Chinese.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的最小堆 // 建立一個能動態增減元素的最小堆，用來保存目前 k 大的數值  \n→ Step 2: 儲存 k // 把 k 存入物件屬性，供後續判斷使用  \n→ Step 3: For 每個 num in nums // 處理傳入的初始分數陣列  \n  Decision: 堆大小 < k? // 判斷堆還沒滿 k 個元素  \n   Yes → Step 4: 插入 num 至堆 // 把分數加入堆中，因為還沒達到 k 個  \n   No → Decision: num > 堆最小值? // 堆已滿，檢查新分數是否比目前 k 大中最小值還大  \n    Yes → Step 5: 替換堆最小值為 num // 移除最小值並加入新分數，保持堆中保存 k 大的數  \n    No → Step 6: 跳過 // 新分數不夠大，直接忽略  \n→ Step 7: End of constructor // 完成初始堆構造，物件準備就緒  \n→ Function add(val) // 定義 add 方法  \n  Step 8: 插入 val 至堆 // 把新分數先加入堆中  \n  Decision: 堆大小 > k? // 判斷是否超過 k 個元素  \n   Yes → Step 9: 移除堆最小值 // 把最小的那個移除，維持堆大小為 k  \n   No → No change // 不需要移除，堆大小已在 k 或更少  \n  Step 10: 回傳 堆最小值 // 堆頂即為目前所有分數中的第 k 大  \n→ End // 程式執行結束"
    },
    {
      "title": "Implement Trie (Prefix Tree)",
      "source_file": "Leetcode/leetcode208.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmplyd37fg8.py\", line 88, in <module>\n    main()\n  File \"/tmp/tmplyd37fg8.py\", line 65, in main\n    commands = ast.literal_eval(left)\n               ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    ['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app']\n                                                                              ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入字串解析為兩個列表：commands 與 args_list\n    pattern = r'\\[(.*)\\],\\s*\\[(.*)\\]'\n    m = re.match(pattern, data, re.DOTALL)\n    if m:\n        left = '[' + m.group(1) + ']'\n        right = '[' + m.group(2) + ']'\n    else:\n        # 若格式不符合預期，嘗試以第一個逗號分隔\n        parts = data.split(',', 1)\n        if len(parts) < 2:\n            return\n        left, right = parts[0].strip(), parts[1].strip()\n        if not left.startswith('['):\n            left = '[' + left\n        if not left.endswith(']'):\n            left += ']'\n        if not right.startswith('['):\n            right = '[' + right\n        if not right.endswith(']'):\n            right += ']'\n\n    commands = ast.literal_eval(left)\n    args_list = ast.literal_eval(right)\n\n    results = []\n    trie = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif cmd == 'insert':\n            trie.insert(args[0])\n            results.append(None)\n        elif cmd == 'search':\n            results.append(trie.search(args[0]))\n        elif cmd == 'startsWith':\n            results.append(trie.startsWith(args[0]))\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output a virtual code description step by step, each line with virtual code and comment. The user wants a Trie class with methods. So we will produce pseudo-code for the Trie class: initialization, node structure, insert, search, startsWith. We need to produce a step-by-step algorithm, but likely the user expects a pseudo code that outlines the methods. We'll produce each method with steps, using the specified format: \"虛擬碼步驟 // 解釋\".\n\nWe must not output actual code, only the structure with arrows, Start, End, Decision, etc. The output should be line by line.\n\nWe can produce a top-level structure for the Trie class, then inside each method a Start... End. Let's think:\n\nWe can define Node structure: char? children map? Let's outline the pseudocode:\n\nStart // 程式開始執行\n→ Step 1: 定義 TrieNode 類別 // 節點結構，包含 children 與 isEnd 標誌\n    → Step 1.1: Node.children ← 空 map // 儲存子節點\n    → Step 1.2: Node.isEnd ← false // 是否為單詞結束\n→ Step 2: 定義 Trie 類別 // 主類別\n    → Step 2.1: Trie.root ← new TrieNode() // 根節點\n→ End\n\nThen methods:\n\nInsert:\n→ Start // 插入單詞\n→ Step 1: current ← Trie.root // 從根節點開始\n→ For each char c in word\n    → Decision: current.children 是否包含 c ?\n        Yes → current ← current.children[c] // 跳到已存在子節點\n        No → current.children[c] ← new TrieNode() // 新增子節點\n            → current ← current.children[c] // 移動到新節點\n→ Step 2: current.isEnd ← true // 標記為單詞結束\n→ End\n\nSearch:\n→ Start // 搜尋單詞\n→ Step 1: current ← Trie.root\n→ For each char c in word\n    → Decision: current.children 是否包含 c ?\n        Yes → current ← current.children[c]\n        No  → Return false // 沒有該字元子節點，單詞不存在\n→ Step 2: Return current.isEnd // 若為單詞結束則存在\n→ End\n\nstartsWith:\n→ Start // 檢查前綴\n→ Step 1: current ← Trie.root\n→ For each char c in prefix\n    → Decision: current.children 是否包含 c ?\n        Yes → current ← current.children[c]\n        No  → Return false // 前綴不存在\n→ Step 2: Return true // 所有字元匹配成功\n→ End\n\nMake sure each line is separate, with arrow \"→\". For decisions we need to indent? The example shows indenting for nested. We'll mimic that.\n\nWe need to output the steps in Chinese. Also each line ends with \"// 解釋\". Let's produce.\n\nAlso we might include \"Decision:\" lines.\n\nWe need to separate each logical block. Provide Start, End for entire program, maybe also Start/End inside methods.\n\nLet's produce the output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 TrieNode 類別 // 節點結構，包含子節點集合與是否為單詞結束的標誌  \n    → Step 1.1: Node.children ← 空 map // 儲存各字元對應的子節點  \n    → Step 1.2: Node.isEnd ← false // 預設不是單詞結束點  \n→ Step 2: 定義 Trie 類別 // 主資料結構  \n    → Step 2.1: Trie.root ← new TrieNode() // 建立根節點  \nEnd // 程式結束\n\nStart // Trie 類別方法定義  \n→ Method: insert(word) // 插入單詞  \n    → Step 1: current ← Trie.root // 從根節點開始  \n    → For each 字元 c in word  \n        → Decision: current.children 是否包含 c? // 檢查子節點是否存在  \n            Yes → current ← current.children[c] // 已有子節點，直接移動  \n            No  → current.children[c] ← new TrieNode() // 新增子節點  \n                → current ← current.children[c] // 移動到新建立的節點  \n    → Step 2: current.isEnd ← true // 標記為單詞結束點  \nEnd // insert 方法結束\n\n→ Method: search(word) // 搜尋單詞是否存在  \n    → Step 1: current ← Trie.root // 從根節點開始  \n    → For each 字元 c in word  \n        → Decision: current.children 是否包含 c? // 檢查子節點是否存在  \n            Yes → current ← current.children[c] // 移動到子節點  \n            No  → Return false // 該字元不存在，單詞不在 trie  \n    → Step 2: Return current.isEnd // 若至此仍在節點，根據 isEnd 判斷是否為完整單詞  \nEnd // search 方法結束\n\n→ Method: startsWith(prefix) // 判斷是否有單詞以 prefix 為前綴  \n    → Step 1: current ← Trie.root // 從根節點開始  \n    → For each 字元 c in prefix  \n        → Decision: current.children 是否包含 c? // 檢查子節點是否存在  \n            Yes → current ← current.children[c] // 移動到子節點  \n            No  → Return false // 前綴不存在  \n    → Step 2: Return true // 所有字元匹配，前綴存在  \nEnd // startsWith 方法結束  \nEnd // 程式結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz2j30a3b.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpz2j30a3b.py\", line 29, in main\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpz2j30a3b.py\", line 16, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^^^\n  File \"/tmp/tmpz2j30a3b.py\", line 6, in rand7\n    raise NotImplementedError(\"rand7() 必須由執行環境提供\")\nNotImplementedError: rand7() 必須由執行環境提供"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzvqu58_o.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpzvqu58_o.py\", line 29, in main\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpzvqu58_o.py\", line 16, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^^^\n  File \"/tmp/tmpzvqu58_o.py\", line 6, in rand7\n    raise NotImplementedError(\"rand7() 必須由執行環境提供\")\nNotImplementedError: rand7() 必須由執行環境提供"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd2802cuo.py\", line 33, in <module>\n    main()\n  File \"/tmp/tmpd2802cuo.py\", line 29, in main\n    results = [solution.rand10() for _ in range(n)]\n               ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpd2802cuo.py\", line 16, in rand10\n    num = (rand7() - 1) * 7 + rand7()\n           ^^^^^^^\n  File \"/tmp/tmpd2802cuo.py\", line 6, in rand7\n    raise NotImplementedError(\"rand7() 必須由執行環境提供\")\nNotImplementedError: rand7() 必須由執行環境提供"
        }
      ],
      "generated_code": "import sys\nimport re\n\n# 假設環境會提供 rand7() API\ndef rand7():\n    raise NotImplementedError(\"rand7() 必須由執行環境提供\")\n\nclass Solution:\n    def rand10(self) -> int:\n        \"\"\"\n        生成 1~10 的均勻隨機整數。\n        透過兩次 rand7() 產生 1~49 的整數，若不在 1~40 內則重試。\n        \"\"\"\n        while True:\n            # 兩次 rand7() 產生 1~49 的隨機數\n            num = (rand7() - 1) * 7 + rand7()\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef parse_n(input_str: str) -> int:\n    \"\"\"從輸入字串中提取第一個整數作為 n。\"\"\"\n    match = re.search(r'\\d+', input_str)\n    return int(match.group()) if match else 0\n\ndef main() -> None:\n    data = sys.stdin.read()\n    n = parse_n(data)\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with \"虛擬碼步驟\" and \"// 解釋\". Use arrows. Should not output real code. Provide a virtual algorithm for rand10() using rand7(). Classic solution: generate 49 values (7*7) via two calls, map to 1-10, reject if >40 or >? Standard: 49 values; we need 1-10 uniform: 49/10=4 remainder 9. Use 40 as usable; remainder 9 discarded. Or use 2*7=14, 14>10, can map 1-10, reject 11-14? But that would bias? Actually 14 not multiple of 10; using rejection: generate 2 randoms => (x-1)*7 + y gives 1-49. Use 40 as accepted. Then map to 1-10 via mod: (num-1)%10+1. Return that.\n\nVirtual steps:\n\nStart\n→ Step 1: Generate r1 = rand7()\n→ Step 2: Generate r2 = rand7()\n→ Step 3: num = (r1-1)*7 + r2 // 1-49\n→ Decision: 如果 num <= 40? // Acceptable range\n    Yes → Step 4: result = (num-1) % 10 + 1 // Map to 1-10\n    No  → Step 5: Go back to Step 1 // Retry\n\nEnd\n\nBut need loop structure. Use while loop: while True, generate r1 r2; compute num; if num<=40 return mapped value; else continue.\n\nBut need to show virtual code line by line. Use arrows, decision. Provide explanation.\n\nLet's write:\n\nStart // 程式開始執行\n→ Decision: 需要產生 rand10() // 開始過程\n    Yes → Step 1: r1 ← rand7() // 取得第一個隨機數\n    No  → End\n\nBut better:\n\nStart // 程式開始執行\n→ Step 1: 重複直到產生合法值 // 循環邏輯\n    → Step 2: r1 ← rand7() // 產生第一個隨機數\n    → Step 3: r2 ← rand7() // 產生第二個隨機數\n    → Step 4: num ← (r1-1)*7 + r2 // 轉換為 1-49\n    → Decision: 如果 num <= 40? // 判斷是否落在可用範圍\n        Yes → Step 5: result ← (num-1) % 10 + 1 // 映射到 1-10\n        No  → Step 6: Go back to Step 2 // 重新嘗試\n    → Decision: 是否返回 result? // 若已得到合法值\n        Yes → Step 7: 返回 result // 結束函式\n        No  → Step 8: 循環到 Step 2\n\nBut the virtual code format requires arrow lines. Use \"→\" to indicate flow.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 設定 loop 迴圈 // 開始重複嘗試\n    → Step 2: r1 ← rand7() // 產生第一個隨機數\n    → Step 3: r2 ← rand7() // 產生第二個隨機數\n    → Step 4: num ← (r1-1)*7 + r2 // 將兩個 1-7 合併成 1-49\n    → Decision: 如果 num <= 40? // 可用的 40 個數\n        Yes → Step 5: result ← (num-1) % 10 + 1 // 轉為 1-10\n        No  → Step 6: Go back to Step 2 // 超過 40，重新嘗試\n    → Decision: 是否有 result? // 判斷是否已取得合法值\n        Yes → Step 7: 返回 result // 結束函式\n        No  → Step 8: 循環到 Step 2\nEnd // 程式結束\n\nBut we need each line as separate output lines.\n\nAlso note that the \"Decision\" lines must have Yes → ... and No → ... inside. The \"Go back to Step 2\" can be just loop.\n\nBetter to represent loop explicitly: \"→ Step 1: 開始 while True 循環\" then inside. Use Decision and loops. Use \"→ Decision\" for conditions, then \"Yes →\" and \"No →\" lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Begin while True 循環 // 進入重複流程\n    → Step 2: r1 ← rand7() // 取得第一個隨機數\n    → Step 3: r2 ← rand7() // 取得第二個隨機數\n    → Step 4: num ← (r1-1)*7 + r2 // 生成 1-49\n    → Decision: 如果 num <= 40? // 判斷是否在可接受範圍\n        Yes → Step 5: result ← (num-1) % 10 + 1 // 映射到 1-10\n        No  → Step 6: 繼續 // 超過 40，返回循環\n    → Decision: 是否已得到 result? // 判斷是否完成\n        Yes → Step 7: return result // 返回最終值\n        No  → Step 8: 繼續 // 循環回 Step 2\nEnd // 程式結束\n\nBut the Decision lines inside loop maybe unnecessary; we can use early return. But requirement: use virtual code lines.\n\nLet's restructure:\n\nStart // 程式開始執行\n→ Step 1: 設置 while True 循環 // 進入重複流程\n    → Step 2: r1 ← rand7() // 取得第一個隨機數\n    → Step 3: r2 ← rand7() // 取得第二個隨機數\n    → Step 4: num ← (r1-1)*7 + r2 // 合併成 1-49\n    → Decision: 如果 num <= 40? // 可用範圍\n        Yes → Step 5: result ← (num-1) % 10 + 1 // 映射 1-10\n        No  → Step 6: 跳回 Step 2 // 超過 40，重新嘗試\n    → Decision: 已獲得合法結果? // 判斷是否已完成\n        Yes → Step 7: 返回 result // 結束函式\n        No  → Step 8: 跳回 Step 2 // 繼續循環\nEnd // 程式結束\n\nBut the Step 6 and Step 8 maybe duplicates. Could combine.\n\nSimplify: Use while loop with break.\n\nStart\n→ Step 1: Begin while True 循環\n    → Step 2: r1 ← rand7()\n    → Step 3: r2 ← rand7()\n    → Step 4: num ← (r1-1)*7 + r2\n    → Decision: 如果 num <= 40? \n        Yes → Step 5: result ← (num-1) % 10 + 1\n        No  → Step 6: 繼續 // 直接 loop 迴圈\n    → Decision: 是否已得到 result? \n        Yes → Step 7: return result\n        No  → Step 8: 繼續 // 回到 Step 2\n\nBut Step 5 should be followed by return, so no need further decisions.\n\nCould do:\n\nStart // 程式開始執行\n→ Step 1: Begin while True 循環 // 重複直到產生合法值\n    → Step 2: r1 ← rand7() // 產生第一個隨機數\n    → Step 3: r2 ← rand7() // 產生第二個隨機數\n    → Step 4: num ← (r1-1)*7 + r2 // 合併為 1-49\n    → Decision: 如果 num <= 40? // 可接受範圍\n        Yes → Step 5: result ← (num-1) % 10 + 1 // 轉為 1-10\n        No  → Step 6: 繼續 // 超過 40，回到 Step 2\n    → Step 7: return result // 返回最終值\nEnd // 程式結束\n\nBut the \"Yes\" path leads to Step 5 and then we need to exit loop. Step 7 returns; Step 6 loops. That's fine.\n\nHowever, we must ensure each line is a separate output. We can indent but still each line separate.\n\nWe also need to include arrow '→' at each line after Start, but Step 1 uses \"→ Step 1:\" etc. For decisions we have \"→ Decision:\" then indent the Yes and No branches.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Begin while True 循環 // 重複直至產生合法值  \n  → Step 2: r1 ← rand7() // 取得第一個隨機數（1~7）  \n  → Step 3: r2 ← rand7() // 取得第二個隨機數（1~7）  \n  → Step 4: num ← (r1-1)*7 + r2 // 合併為 1~49 的隨機數  \n  → Decision: 如果 num <= 40? // 可接受範圍（40 個數）  \n   Yes → Step 5: result ← (num-1) % 10 + 1 // 轉換為 1~10  \n   No  → Step 6: 繼續 // 超過 40，回到 Step 2 重新嘗試  \n  → Step 7: return result // 取得合法結果後結束函式  \nEnd // 程式結束"
    },
    {
      "title": "Reverse Integer",
      "source_file": "Leetcode/leetcode7.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-321'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '-321'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2 ** 31 - 1\nINT_MIN = -2 ** 31\n\ndef reverse(x: int) -> int:\n    \"\"\"\n    逆轉 32 位有符號整數的位元。\n    若逆轉後的數字超出 32 位範圍，回傳 0。\n    \"\"\"\n    if x == 0:\n        return 0\n\n    sign = 1 if x >= 0 else -1\n    n = x\n    rev = 0\n\n    while n != 0:\n        # 取得最低位（正整數）並丟棄符號\n        digit = abs(n % 10)\n        n //= 10\n\n        # 檢查乘 10 加 digit 是否會溢出 INT_MAX\n        if rev > INT_MAX // 10 or (rev == INT_MAX // 10 and digit > 7):\n            return 0\n\n        rev = rev * 10 + digit\n\n    result = sign * rev\n    if result < INT_MIN or result > INT_MAX:\n        return 0\n    return result\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入並搜尋第一個符合的整數\n    line = sys.stdin.readline()\n    match = re.search(r'[-]?\\d+', line)\n    if not match:\n        print(0)\n    else:\n        x = int(match.group())\n        print(reverse(x))",
      "virtual_code": "Thinking...\nWe need produce virtual code lines, each with explanation, following format: \"虛擬碼步驟 // 解釋\". Use arrows and decision.\n\nNeed to design algorithm for reversing digits of signed 32-bit integer without 64-bit. Typical approach: process digits one by one, using 32-bit ints, but check overflow before multiply/add. Steps: determine sign, take abs, loop while n>0: pop digit, check overflow: if rev > INT_MAX/10 or (rev == INT_MAX/10 and digit > 7) for positive, similar for negative (INT_MIN is -2147483648, so abs INT_MIN is 2147483648 > INT_MAX). Use long? But no 64-bit allowed. So must use 32-bit only, but can use long? No.\n\nWe can do overflow check using 32-bit by comparing rev and digit with thresholds.\n\nPseudo:\n\nStart\n→ Step 1: Input x // get integer\n→ Step 2: Determine sign s = 1 if x>=0 else -1\n→ Step 3: n = abs(x) // careful: if x == INT_MIN, abs overflows, but we can treat separately\n→ Decision: if x == INT_MIN? // special case\n    Yes → Step 4: n = 2147483648 // store as 32-bit unsigned? But cannot store 2147483648 > INT_MAX. But we can use unsigned? Not allowed? We can store as signed but will overflow. But we can process digits by using x = -x? Actually for INT_MIN, its absolute value cannot be represented. Workaround: treat as negative separately: we can compute rev using algorithm that handles negative digits. Another approach: compute rev using sign but allow intermediate negative values.\n\nSimpler: keep original x and process sign later. Use n = x. Use abs logic with check for INT_MIN: if x<0 and x==INT_MIN, we can set n = x (still negative). We'll use n = x; while n != 0: pop digit d = n % 10; rev = rev*10 + d; But rev will be negative as well? But then sign will be lost.\n\nBetter: use unsigned? Hmm.\n\nSimplify: we can use standard algorithm with sign variable, but we need to handle INT_MIN specially: we can compute rev by first negating x: if x<0, we set sign=-1, but if x==INT_MIN, we can treat its abs as 2147483648. Since we cannot store that in signed 32-bit, we can treat as unsigned using bit operations? Or we can process digits by converting to string? Not allowed.\n\nMaybe we can handle overflow before adding digit using 32-bit check. For INT_MIN, when we try to reverse, we may overflow anyway.\n\nSimpler: Use approach: compute rev as signed 32-bit, but before rev = rev*10 + digit, check:\n\nif rev > INT_MAX/10 or (rev == INT_MAX/10 and digit > 7) then overflow.\n\nSimilarly for negative: rev < INT_MIN/10 or (rev == INT_MIN/10 and digit < -8) but digit is 0-9.\n\nSince we are using signed integers, rev will be negative for negative numbers. But we will store rev as positive and apply sign at end? Let's use positive rev and then apply sign.\n\nBut for INT_MIN, the magnitude 2147483648 cannot be represented. But if we take sign = -1, n = abs(x). But abs(INT_MIN) fails. So we must treat INT_MIN specially: we can set n = INT_MAX +1? Actually 2147483648 cannot fit. But we can process n as unsigned 32-bit by using n = x; but n is negative. We can extract digits using negative division? Example: n = -2147483648; n % 10 in C gives -8; n /10 gives -214748364; digits negative. But we want digits positive. We can compute d = -(n % 10); But careful with INT_MIN %10 yields -8, so -(-8)=8. Then n = -(n /10); but -(-214748364) = 214748364. But n /10 with negative rounding? In C, integer division truncates toward zero. For negative numbers, -2147483648 /10 = -214748364. So -( -214748364) = 214748364. Works.\n\nThus we can process n as negative number, compute digits as negative and then convert to positive.\n\nSo algorithm: sign = 1; if x<0 sign=-1; n = x; rev=0; while n !=0: d = abs(n %10); n = n /10; // integer division truncates toward zero\n   // Check overflow before rev=rev*10 + d\n   Decision: if rev > INT_MAX/10 or (rev == INT_MAX/10 and d > 7)? For positive sign. For negative sign, rev*10 + d will be negative but we handle rev positive and apply sign at end, so same thresholds.\n\nSo we need to check rev*10 + d <= INT_MAX. If sign negative, the negative reversed number's magnitude <= INT_MAX+1? Actually -INT_MIN = 2147483648 > INT_MAX. So negative reversed number cannot be -2147483648. The maximum negative is -2147483648? Wait -2147483648 is INT_MIN. It's allowed. The reversed number may produce that value. For example x = -8463847412? Not possible. But consider x = -123; reverse 321 negative -> -321 fits.\n\nBut the overflow condition for negative sign: rev*10 + d must be <= INT_MAX for positive rev; then final number sign*rev may be within 32-bit signed. For negative sign, we can have -rev <= INT_MIN? But rev positive, sign negative, final = -rev. For final to be >= INT_MIN, rev <= INT_MAX +1? Actually -2147483648 = INT_MIN. Rev=2147483648 > INT_MAX; but cannot be represented as signed positive rev. So we cannot handle INT_MIN reversed. But maybe reversed INT_MIN is -8463847412? Not representable. So algorithm will return 0 due to overflow.\n\nThus we can use positive rev and overflow check against INT_MAX for rev. After loop, apply sign: result = sign * rev. Then if result < INT_MIN or > INT_MAX, return 0.\n\nWe need no 64-bit. All operations within 32-bit signed.\n\nLet's produce virtual code accordingly.\n\nMake decisions: if rev > INT_MAX/10 or (rev == INT_MAX/10 and d > 7) then overflow -> return 0.\n\nImplement steps.\n\nAlso initial special case: if x==0 return 0.\n\nLet's produce virtual code lines.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 x // 取得輸入的 32 位有符號整數  \n→ Step 2: 判斷 x 是否為 0?  \n  Yes → Step 3: 輸出 0 // 若為 0，直接回傳 0  \n  No → Step 4: 計算符號 s = 1 若 x≥0 否則 s = -1 // 保存正負號  \n→ Step 5: 設定 n = x // n 用來依序取位元  \n→ Step 6: 設定 rev = 0 // 存儲正向反轉後的數值  \n→ Step 7: Decision: n != 0? // 是否還有位元待處理  \n  Yes → Step 8: 取餘數 d = abs(n % 10) // 取得最低位的正整數位  \n    → Step 9: 更新 n = n / 10 // 去掉已處理的最低位  \n    → Decision: rev > INT_MAX/10 或 (rev == INT_MAX/10 且 d > 7)? // 先檢查乘 10 加 d 是否會溢出  \n     Yes → Step 10: 輸出 0 // 溢出時直接回傳 0  \n     No → Step 11: rev = rev * 10 + d // 合併新位元  \n    → 返回 Step 7 // 回到 while 判斷，繼續處理下一位  \n  No  → Step 12: 計算 result = s * rev // 將符號套回  \n→ Step 13: Decision: result < INT_MIN 或 result > INT_MAX? // 檢查最終結果是否仍在合法範圍  \n  Yes → Step 14: 輸出 0 // 超出範圍則回傳 0  \n  No  → Step 15: 輸出 result // 正常情況回傳反轉後的整數  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    \"\"\"\n    將陣列重新排成 wiggle sequence\n    即 nums[0] < nums[1] > nums[2] < nums[3] ...\n    \"\"\"\n    def wiggleSort(self, nums):\n        \"\"\"\n        直接一次遍歷，若當前索引為奇數且 nums[i] <= nums[i-1]\n        或為偶數且 nums[i] >= nums[i-1]，則交換兩個元素。\n        這樣即可保證所有相鄰元素交替大小。\n        \"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            if i % 2 == 1:          # 奇數位置需要大於前一個\n                if nums[i] <= nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            else:                   # 偶數位置需要小於前一個\n                if nums[i] >= nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n        return nums\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式：可能是 'nums = [1,5,1,1,6,4]' 或直接 '[1,5,1,1,6,4]'\n    if data.startswith('nums'):\n        _, nums_str = data.split('=', 1)\n        nums_str = nums_str.strip()\n    else:\n        nums_str = data\n\n    try:\n        nums = ast.literal_eval(nums_str)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        return\n\n    sol = Solution()\n    sol.wiggleSort(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step to reorder array into wiggle pattern. Problem: given integer array nums, reorder so nums[0] < nums[1] > nums[2] < nums[3] etc. We can do in-place algorithm: iterate i from 1 to n-1, if i is odd, ensure nums[i] > nums[i-1], else ensure nums[i] < nums[i-1]. If condition fails, swap.\n\nWe produce virtual code with lines as described. Use Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow lines.\n\nLet's produce:\n\nStart\n→ Step 1: 設定 n 為 nums 的長度 // 取得陣列長度\n→ Decision: n 是否為 0? // 檢查空陣列\n    No → Step 2: 從索引 1 開始迴圈到 n-1 // 進入迴圈\n        → Step 3: 若 i 為奇數且 nums[i] <= nums[i-1]？ // 檢查奇數位置是否滿足大於前一個\n            Yes → Step 4: 交換 nums[i] 與 nums[i-1] // 交換以滿足條件\n        → Step 5: 若 i 為偶數且 nums[i] >= nums[i-1]？ // 檢查偶數位置是否滿足小於前一個\n            Yes → Step 6: 交換 nums[i] 與 nums[i-1] // 交換以滿足條件\n        → Step 7: i++ // 移動到下一個索引\n    No → Step 8: 直接結束 // 空陣列無需操作\nEnd\n\nWe need to include \"Decision:\" for each if, maybe sub-decisions.\n\nWe should use Yes → and No → arrow. Use indentation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n 為 nums 的長度 // 取得陣列長度  \n→ Decision: n 是否為 0? // 檢查是否為空陣列  \n  No → Step 2: 從索引 1 開始迴圈到 n-1 // 進入主要迴圈  \n   → Step 3: 若 i 為奇數？ // 判斷當前索引為奇數或偶數  \n    Yes → Decision: nums[i] <= nums[i-1]? // 奇數位置是否滿足 > 前一個  \n      Yes → Step 4: 交換 nums[i] 與 nums[i-1] // 交換以滿足 nums[i] > nums[i-1]  \n      No → No → // 不需要交換  \n    No → Decision: nums[i] >= nums[i-1]? // 偶數位置是否滿足 < 前一個  \n      Yes → Step 5: 交換 nums[i] 與 nums[i-1] // 交換以滿足 nums[i] < nums[i-1]  \n      No → No → // 不需要交換  \n   → Step 6: i++ // 移動到下一個索引  \n   → Decision: i < n ? // 判斷是否已到達陣列結尾  \n    Yes → Step 2 // 迴圈繼續  \n    No → No → // 迴圈結束  \n  No → Step 7: 直接結束 // 空陣列不做任何操作  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpi3gziynn.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmpi3gziynn.py\", line 48, in main\n    ops, args = eval(f'({data})', {}, {})\n                ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1, in <module>\nNameError: name 'Input' is not defined. Did you mean: 'input'?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        \"\"\"把元素放進 q1，保持 LIFO 的順序\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"移除並回傳堆疊頂部的元素\"\"\"\n        if not self.q1:\n            return None\n        # 把 q1 里除最後一個元素以外全部轉移到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        popped = self.q1.popleft()          # 最後一個元素即堆疊頂部\n        # 交換兩個佇列，讓 q1 成為主佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return popped\n\n    def top(self) -> int:\n        \"\"\"取得堆疊頂部元素但不移除\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()          # 取得頂部元素\n        self.q2.append(top_val)              # 把它放回 q2，保持結構\n        # 交換兩個佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self) -> bool:\n        \"\"\"判斷堆疊是否為空\"\"\"\n        return not self.q1\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：格式類似 '[\"MyStack\",\"push\",\"push\"], [[],[1],[2]]'\n    # 用 eval 包在括號裡使其成為 tuple\n    ops, args = eval(f'({data})', {}, {})\n    stack = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            outputs.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            outputs.append(None)\n        elif op == \"pop\":\n            outputs.append(stack.pop())\n        elif op == \"top\":\n            outputs.append(stack.top())\n        elif op == \"empty\":\n            outputs.append(stack.empty())\n\n    # 轉換為 LeetCode 風格輸出，None -> null，True/False -> true/false\n    formatted = []\n    for val in outputs:\n        if val is None:\n            formatted.append(\"null\")\n        elif isinstance(val, bool):\n            formatted.append(\"true\" if val else \"false\")\n        else:\n            formatted.append(str(val))\n    print(\"[\" + \", \".join(formatted) + \"]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code outline for implementing a LIFO stack using two queues. The output must be step by step with each line: virtual code step + comment. Use Start, End, Decision, arrow.\n\nWe must not output actual code. Just high-level steps. Each line with // explanation.\n\nWe need to explain operations of push, pop, top, empty. Use two queues: q1 and q2. Standard trick: when pushing, enqueue to q1. For pop/top, move all except last from q1 to q2, retrieve last, then swap. Or better, always keep the stack elements in q1 with the top at front, by moving new element to back of q2 and then transfer all from q1 to q2, then swap.\n\nWe'll outline initialization, push, pop, top, empty. Provide steps.\n\nWe'll produce a flowchart-like pseudocode.\n\nWe must use Start, End, Decision: lines.\n\nWe'll produce each step on new line.\n\nLet's design:\n\nStart\n→ Initialize q1, q2 as empty queues\n→ Define push(x)\n    → q1.enqueue(x)\n→ Define pop()\n    → Decision: If q1.isEmpty? // check empty\n        Yes → Return null or error\n        No  → Decision: q1.size() == 1?\n            Yes → Return q1.dequeue()\n            No  → Loop while q1.size() > 1\n                → temp = q1.dequeue()\n                → q2.enqueue(temp)\n            → popped = q1.dequeue()\n            → Swap q1 and q2\n            → Return popped\n→ Define top()\n    → Similar but peek after loop\n→ Define empty()\n    → Return q1.isEmpty()\n\nBut need to be in virtual code lines. Each step separate. Use indentation maybe.\n\nWe need to output each step as line with arrow and comment. No code block. We'll use \"→\" to show step lines. Use \"Decision:\" for if.\n\nMake sure we include all methods.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialise q1 ← 空佇列, q2 ← 空佇列 // 用兩個佇列來模擬堆疊  \n\n//---------------------------- Push ----------------------------  \n→ Function push(x) // 定義 push 方法  \n    → q1.enqueue(x) // 把元素放到 q1 的尾部，保持 FIFO  \n\n//---------------------------- Pop ----------------------------  \n→ Function pop() // 定義 pop 方法  \n    → Decision: q1.isEmpty()? // 檢查是否有元素  \n        Yes → Return null // 堆疊為空，直接回傳 null 或報錯  \n        No  → Decision: q1.size() == 1? // 只剩一個元素，直接彈出  \n            Yes → popped ← q1.dequeue() // 取出唯一元素  \n            → Return popped  \n            No  → // 有多個元素，須將最後一個元素取出  \n                → While q1.size() > 1 // 移動除最後一個以外的元素  \n                    → temp ← q1.dequeue() // 從前端取出  \n                    → q2.enqueue(temp) // 放到 q2 的尾部  \n                → popped ← q1.dequeue() // 取出最後一個元素（堆疊頂部）  \n                → Swap q1, q2 // 交換兩個佇列，保持 q1 為主佇列  \n                → Return popped // 回傳彈出的元素  \n\n//---------------------------- Top ----------------------------  \n→ Function top() // 定義 top 方法  \n    → Decision: q1.isEmpty()? // 檢查是否有元素  \n        Yes → Return null // 堆疊為空，回傳 null 或報錯  \n        No  → Decision: q1.size() == 1? // 只剩一個元素，直接返回  \n            Yes → Return q1.peek() // 取得 q1 的前端元素（堆疊頂部）  \n            No  → // 有多個元素，需取得最後一個元素但不移除  \n                → While q1.size() > 1 // 移動除最後一個以外的元素  \n                    → temp ← q1.dequeue()  \n                    → q2.enqueue(temp)  \n                → topVal ← q1.peek() // 取得 q1 前端元素（最後一個）  \n                → q1.dequeue() // 把它取走，以便後續交換  \n                → q2.enqueue(topVal) // 把最後一個元素放回 q2  \n                → Swap q1, q2 // 交換兩個佇列，保持結構不變  \n                → Return topVal // 回傳堆疊頂部的值  \n\n//---------------------------- Empty ----------------------------  \n→ Function empty() // 定義 empty 方法  \n    → Return q1.isEmpty() // 若主佇列為空則堆疊為空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.12361817358751975,0.0801161511145321],[0.5525064118466807,0.6409903581266163],[-0.9760461071452166,0.04034093134725485]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.12361817358751975, 0.0801161511145321], [0.5525064118466807, 0.6409903581266163], [-0.9760461071452166, 0.04034093134725485]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())  # 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    lines = sys.stdin.read().strip().splitlines()\n    if not lines:\n        return\n    funcs = json.loads(lines[0])\n    args_list = json.loads(lines[1])\n    result = []\n    obj = None\n    for func, args in zip(funcs, args_list):\n        if func == 'Solution':\n            obj = Solution(*args)\n            result.append(None)\n        else:\n            method = getattr(obj, func)\n            res = method(*args)\n            result.append(res)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, using the specified format. Need to provide algorithm: generate uniform random point inside circle: typical method: generate random radius sqrt(rand()) * R, random angle theta uniform 0 to 2π, then x = x_center + r * cosθ, y = y_center + r * sinθ.\n\nWe need to represent initialization and randPoint method. Virtual code should include steps: Start, initialization, random number generation, etc. Use arrow \"→\". Use Decision if needed, but here not many decisions. Use End at the end of each function? The example shows End for program. We can maybe end each method? The format requires each line contains virtual code step + // explanation.\n\nWe must not output actual code, just virtual code. Let's produce:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→ Constructor: Solution(radius, x_center, y_center) // 初始化圓半徑與中心座標\n    → Store radius as this.radius // 保存半徑\n    → Store x_center as this.xc // 保存中心 x 座標\n    → Store y_center as this.yc // 保存中心 y 座標\n→ Method randPoint() // 產生隨機點\n    → Generate u = random() // 取得 0-1 的隨機數\n    → Compute r = sqrt(u) * this.radius // 產生均勻半徑\n    → Generate θ = random() * 2π // 取得 0-2π 的隨機角度\n    → Compute x = this.xc + r * cos(θ) // 計算 x 座標\n    → Compute y = this.yc + r * sin(θ) // 計算 y 座標\n    → Return [x, y] // 回傳點座標\nEnd // 程式結束\n\nBut need to use arrow notation: For each line we use \"→ Step ...\". Also need to represent decisions maybe not needed. But we need to follow the format: each line includes virtual code step + [space] + // 解釋. The example shows indentation for decisions.\n\nWe can produce a structured flow:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n→ Constructor: Solution(radius, x_center, y_center) // 初始化\n    → Set this.radius = radius // 存半徑\n    → Set this.xc = x_center // 存 x 中心\n    → Set this.yc = y_center // 存 y 中心\n→ Method randPoint() // 產生隨機點\n    → Generate u = random() // 0-1 隨機數\n    → Compute r = sqrt(u) * this.radius // 產生均勻半徑\n    → Generate θ = random() * 2π // 0-2π 隨機角度\n    → Compute x = this.xc + r * cos(θ) // 計算 x\n    → Compute y = this.yc + r * sin(θ) // 計算 y\n    → Return [x, y] // 回傳點\nEnd // 程式結束\n\nMake sure each line has no indentation? In example, indentation for decisions, but we can keep plain. Use arrow \"→\". For indentation, we can just indent with spaces for readability. Use \"→\" at start of each line. For method body, maybe indent lines with spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義 Solution 類別  \n→ Constructor: Solution(radius, x_center, y_center) // 初始化圓半徑與中心座標  \n    → Set this.radius = radius // 存儲半徑  \n    → Set this.xc = x_center // 存儲中心 x 座標  \n    → Set this.yc = y_center // 存儲中心 y 座標  \n→ Method randPoint() // 產生隨機點  \n    → Generate u = random() // 產生 0~1 的隨機數  \n    → Compute r = sqrt(u) * this.radius // 取得均勻分佈的半徑  \n    → Generate θ = random() * 2π // 產生 0~2π 的隨機角度  \n    → Compute x = this.xc + r * cos(θ) // 計算 x 座標  \n    → Compute y = this.yc + r * sin(θ) // 計算 y 座標  \n    → Return [x, y] // 回傳隨機點座標  \nEnd // 程式結束執行"
    },
    {
      "title": "Remove Duplicates from Sorted Array",
      "source_file": "Leetcode/leetcode26.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[1,2,_]'\nGot (Norm):      '2,nums=[1,2,\"_\"]'\n--- (Raw) ---\nRaw Expected: '2, nums = [1,2,_]'\nRaw Got:      \"2, nums = [1, 2, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,2,3,4,_,_,_,_,_]'\nGot (Norm):      '5,nums=[0,1,2,3,4,\"_\",\"_\",\"_\",\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,2,3,4,_,_,_,_,_]'\nRaw Got:      \"5, nums = [0, 1, 2, 3, 4, '_', '_', '_', '_', '_']\""
        }
      ],
      "generated_code": "class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        Remove duplicates from a sorted list in-place.\n        Return the number of unique elements.\n        \"\"\"\n        if not nums:\n            return 0\n\n        slow = 0\n        for fast in range(1, len(nums)):\n            if nums[fast] != nums[slow]:\n                slow += 1\n                nums[slow] = nums[fast]\n        return slow + 1\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list representation from the input string\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        nums = []\n    else:\n        nums_str = data[start:end + 1]\n        nums = eval(nums_str)  # Convert string like \"[1,1,2]\" to a list\n\n    sol = Solution()\n    k = sol.removeDuplicates(nums)\n\n    # Prepare output with underscore placeholders for unused slots\n    display_list = nums[:k] + ['_'] * (len(nums) - k)\n    print(f\"{k}, nums = {display_list}\")",
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudocode for removing duplicates in sorted array in-place. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Must follow structure: Start, End, Decision: with Yes → and No →. Need to output in Traditional Chinese.\n\nLet's craft.\n\nStart\n→ Initialize index i = 0 // 先把第一個元素視為唯一\n→ For each j from 1 to length-1 // 遍歷剩餘元素\n    → Decision: nums[j] != nums[i]? // 判斷是否不同\n        Yes → Increment i, set nums[i] = nums[j] // 移動到下一個唯一位置\n        No → // 兩個相同，跳過\nEnd // 返回 i+1 作為唯一元素個數\n\nBut we need explicit step numbers? Not necessary, just lines.\n\nAdd final return step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: If nums.length == 0, return 0 // 空陣列直接回傳 0\n→ Step 2: Initialize i = 0 // i 為最後一個唯一元素的索引\n→ Step 3: For j from 1 to nums.length - 1\n    → Decision: nums[j] != nums[i]? // 若當前元素不同於已知唯一元素\n        Yes → Step 4: i = i + 1 // 移動唯一元素指標\n               → Step 5: nums[i] = nums[j] // 將新的唯一元素寫入陣列\n        No → // 若相同，忽略\n→ Step 6: Return i + 1 // i 為最後唯一元素索引，回傳元素個數\n\nBut we need to include arrow for loops? We can use arrow for loop start: \"→ Decision: j < nums.length? ...\". But simpler: use \"→ For j from 1 to ...\" as step.\n\nLet's produce final answer with each line and explanation.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 如果 nums.length = 0, 回傳 0 // 空陣列直接結束  \n→ Step 2: 初始化 i = 0 // i 代表最後一個已確定的唯一元素索引  \n→ Step 3: For j 從 1 到 nums.length - 1  \n    → Decision: nums[j] ≠ nums[i]？ // 判斷當前元素是否與已知唯一元素不同  \n        Yes → Step 4: i = i + 1 // 移動唯一元素指標到下一位置  \n               → Step 5: nums[i] = nums[j] // 把新的唯一元素寫入陣列  \n        No  → // 若相同，跳過此元素  \n→ Step 6: 回傳 i + 1 // i 為最後唯一元素索引，+1 得到唯一元素個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)      # 保留原始配置\n        self.current = list(nums)       # 可變陣列\n\n    def reset(self):\n        return list(self.original)      # 回傳原始配置的拷貝\n\n    def shuffle(self):\n        arr = list(self.current)       # 先複製一份進行打亂\n        n = len(arr)\n        for i in range(n - 1, 0, -1):  # 從尾部往前遍歷\n            j = random.randint(0, i)   # 隨機索引\n            arr[i], arr[j] = arr[j], arr[i]  # 交換\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入包成一個外層列表方便 json 解析\n    wrapped = '[' + data + ']'\n    ops, args = json.loads(wrapped)\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0])\n            result.append(None)           # 按 LeetCode 規則返回 null\n        elif op == \"reset\":\n            result.append(obj.reset())\n        elif op == \"shuffle\":\n            result.append(obj.shuffle())\n        else:\n            raise ValueError(f\"Unknown operation {op}\")\n\n    # 將 None 轉為 JSON null\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for the algorithm design. The user wants algorithm to shuffle array with equal probability, reset to original. This is typical LeetCode 384: Shuffle an Array. Virtual code lines: Start, Step: store original copy, Step: shuffle using Fisher-Yates, etc.\n\nWe need to output step by step with each line: virtual code and comment. Use arrows etc. Let's craft a structure:\n\nStart\n→ Step 1: Store original array copy // keep original for reset\n→ Step 2: Define shuffle() // method\n    → Step 2.1: Copy array to local // we will shuffle local\n    → Step 2.2: For i from last to first: // Fisher-Yates\n        → Step 2.2.1: Generate random index j between 0 and i\n        → Step 2.2.2: Swap arr[i] with arr[j]\n    → Step 2.3: Return shuffled arr\n→ Step 3: Define reset() // method\n    → Step 3.1: Return original copy // restore\nEnd\n\nBut they want a class implementation? Virtual code lines must follow pattern. We'll present steps like:\n\nStart\n→ Class Solution // define class\n    → Step 1: Constructor(nums) // initialize\n        → Store original copy // keep original\n        → Store mutable array copy // current array\n    → Step 2: reset() // method\n        → Return copy of original\n    → Step 3: shuffle() // method\n        → Create copy of current array // to shuffle\n        → For i from length-1 downto 1\n            → Generate random index j (0 ≤ j ≤ i)\n            → Swap elements at i and j\n        → Return shuffled array\nEnd\n\nBut we need to ensure each line has \"虛擬碼步驟\" and comment. Let's produce accordingly.\n\nWe should use arrows \"→\" for steps, \"Decision:\" for condition. We might not need Decision for shuffle loop, but we can illustrate for loop. Use Decision? Not necessary.\n\nWe can include decision for random index generation? No.\n\nJust use loops: \"→ Loop i from len-1 downto 1\" with substeps.\n\nLet's format each line:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n    → Step 1: Constructor(nums) // 建構子，接收原始陣列\n        → Store copy of nums as original // 保留原始配置\n        → Store copy of nums as current // 目前可變陣列\n    → Step 2: reset() // 重置方法\n        → Return a copy of original // 回傳原始配置\n    → Step 3: shuffle() // 隨機打亂方法\n        → Create a copy of current as arr // 以副本進行打亂\n        → Loop i from arr.length - 1 down to 1 // 從尾到頭遍歷\n            → Generate random j between 0 and i // 隨機索引\n            → Swap arr[i] with arr[j] // 交換元素\n        → Return arr // 回傳打亂後陣列\nEnd // 程式結束\n\nBut each line must contain virtual code step + space + comment. Indent is optional but we can keep.\n\nWe need to show \"Decision:\" for if conditions? Not necessary.\n\nBut we should reflect each step in separate line. So each \"→ Step 3: shuffle()\" line is a separate line. Then the substeps \"→ Loop...\" should be separate lines. Use indentation maybe but not needed.\n\nAlso the \"Class Solution\" line is separate. So we produce:\n\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n    → Constructor(nums) // 建構子，初始化陣列\n        → original ← copy(nums) // 保留原始陣列\n        → current ← copy(nums) // 儲存目前陣列\n    → reset() // 重置方法\n        → return copy(original) // 回傳原始配置\n    → shuffle() // 隨機打亂方法\n        → arr ← copy(current) // 以副本進行打亂\n        → for i from arr.length-1 downto 1 // 從尾部到頭部遍歷\n            → j ← randomInt(0, i) // 隨機產生 j\n            → swap(arr[i], arr[j]) // 交換元素\n        → return arr // 回傳打亂後陣列\nEnd // 程式結束\n\nMake sure each line ends with comment. Use arrow \"→\" for all steps except Start and End. For loops, we can use \"→ Loop i from ...\". Let's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Class Solution // 定義 Solution 類別\n    → Constructor(nums) // 建構子，接收原始陣列\n        → original ← copy(nums) // 保留原始配置以便 reset\n        → current ← copy(nums) // 目前可變陣列\n    → reset() // 重置方法\n        → return copy(original) // 回傳原始配置\n    → shuffle() // 隨機打亂方法\n        → arr ← copy(current) // 先複製一份陣列進行打亂\n        → Loop i from arr.length-1 downto 1 // 從尾部到頭部遍歷\n            → j ← randomInt(0, i) // 產生 0~i 的隨機索引\n            → swap(arr[i], arr[j]) // 交換 arr[i] 與 arr[j]\n        → return arr // 回傳打亂後的陣列\nEnd // 程式結束\n```"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 將目前的子集複製一份加入結果\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                # 選擇 nums[i] 並繼續遞迴\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                # 回溯：移除最後一個元素\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\ndef parse_input(s: str):\n    \"\"\"\n    從字串中解析出 nums 列表。\n    期望格式為：'nums = [1,2,3]' 或僅 '[1,2,3]'。\n    \"\"\"\n    s = s.strip()\n    if not s:\n        return []\n\n    if '=' in s:\n        _, expr = s.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = s\n\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = []\n\n    if not isinstance(nums, list):\n        nums = []\n    return nums\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n\n    solution = Solution()\n    result = solution.subsets(nums)\n\n    # 輸出結果至標準輸出\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode that returns all subsets of unique elements array. Use recursion or backtracking. Provide each line with explanation. Ensure structure: Start, End, Decision. Use arrows. Provide step-by-step. Each line includes virtual code and comment. Provide entire algorithm. Should be clear.\n\nWe need to output in Chinese. Should be simplified? It's Traditional Chinese. So explanations in Traditional Chinese.\n\nLet's produce:\n\nStart // start\n→ Step 1: 定義函數 GenerateSubsets(nums, index, currentSubset, allSubsets) // 定義遞迴函數\n→ Decision: index 是否等於 nums.Length? // 判斷是否已到末尾\n    Yes → Step 2: 把 currentSubset 複製並加入 allSubsets // 將目前子集加入結果\n        → Step 3: 返回 // 結束此遞迴分支\n    No  → Step 4: Decision: 是否選擇 nums[index]？ // 判斷是否包含當前元素\n        Yes → Step 5: 把 nums[index] 加入 currentSubset // 選擇元素\n            → Step 6: 呼叫 GenerateSubsets(nums, index+1, currentSubset, allSubsets) // 進行下一層遞迴\n            → Step 7: 移除 currentSubset 最後一個元素 // 回溯\n        No  → Step 8: 呼叫 GenerateSubsets(nums, index+1, currentSubset, allSubsets) // 不選擇元素直接遞迴\nEnd // 程式結束\n\nBut need initial call: Step 0? We can start with:\n\n→ Step 0: 初始化 allSubsets 為空集合 // 用於存放所有子集\n→ Step 1: 呼叫 GenerateSubsets(nums, 0, 空子集, allSubsets) // 開始遞迴\n→ Step 2: 返回 allSubsets // 結果\n\nBut we need to integrate within pseudocode steps. Let's produce:\n\nStart // 程式開始執行\n→ Step 0: 初始化 allSubsets 為空集合 // 用於存放所有子集\n→ Step 1: 呼叫 GenerateSubsets(nums, 0, 空子集, allSubsets) // 開始遞迴生成子集\n→ Step 2: 返回 allSubsets // 返回結果\nEnd // 程式結束\n\nDefine GenerateSubsets function:\n\n→ Step 3: 定義函數 GenerateSubsets(nums, idx, curr, res) // idx: 當前索引, curr: 目前子集, res: 所有子集\n→ Decision: idx 是否等於 nums.Length? // 判斷是否已處理完所有元素\n    Yes → Step 4: 把 curr 複製並加入 res // 加入子集到結果\n        → Step 5: 返回 // 完成此分支\n    No  → Step 6: Decision: 是否選擇 nums[idx]? // 決定是否將當前元素加入子集\n        Yes → Step 7: 把 nums[idx] 加入 curr // 選擇元素\n            → Step 8: 呼叫 GenerateSubsets(nums, idx+1, curr, res) // 進一步遞迴\n            → Step 9: 移除 curr 最後一個元素 // 回溯到原狀\n        No  → Step 10: 呼叫 GenerateSubsets(nums, idx+1, curr, res) // 不選擇元素直接遞迴\nEnd // 程式結束\n\nBut must include Step numbers sequentially? It's okay but may cause confusion. But each line must be sequential. We might number within. Provide each line as separate step. Keep numbers consistent: 0,1,2,3... etc.\n\nNeed arrow: \"→\" before each step. Use \"Decision:\" with Yes and No.\n\nMake sure each line ends with comment after \"//\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 初始化 allSubsets 為空集合 // 用於存放所有子集  \n→ Step 1: 呼叫 GenerateSubsets(nums, 0, 空子集, allSubsets) // 開始遞迴生成子集  \n→ Step 2: 返回 allSubsets // 將所有子集返回給使用者  \n\n→ Step 3: 定義函數 GenerateSubsets(nums, idx, curr, res) // idx: 當前索引, curr: 目前子集, res: 所有子集  \n→ Decision: idx 是否等於 nums.Length? // 判斷是否已處理完所有元素  \n  Yes → Step 4: 把 curr 複製並加入 res // 加入子集到結果  \n    → Step 5: 返回 // 完成此分支  \n  No → Step 6: Decision: 是否選擇 nums[idx]? // 決定是否將當前元素加入子集  \n    Yes → Step 7: 把 nums[idx] 加入 curr // 選擇元素  \n      → Step 8: 呼叫 GenerateSubsets(nums, idx+1, curr, res) // 進一步遞迴  \n      → Step 9: 移除 curr 最後一個元素 // 回溯到原狀  \n    No → Step 10: 呼叫 GenerateSubsets(nums, idx+1, curr, res) // 不選擇元素直接遞迴  \nEnd // 程式結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqpt02_3q.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpqpt02_3q.py\", line 27, in main\n    args = ast.literal_eval(args_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式: [\"NumArray\", ...], [[[...]], [...], ...]\n    # 將兩個 list 之間以 '], ' 分割\n    parts = data.split('],', 1)\n    ops_str = parts[0] + ']'\n    args_str = '[' + parts[1].lstrip()\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == 'NumArray':\n            # arg 是 [[nums]]，取其中的 list\n            obj = NumArray(arg[0])\n            results.append(None)   # 代表 null\n        elif op == 'sumRange':\n            res = obj.sumRange(*arg)\n            results.append(res)\n        else:\n            # 若有其他操作可自行處理\n            results.append(None)\n\n    # 以 LeetCode 的輸出格式印出結果: [null, 1, -1, -3]\n    output_str = '[' + ', '.join('null' if x is None else str(x) for x in results) + ']'\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation per line. The user wants to implement NumArray with sumRange using prefix sums.\n\nWe need to produce a virtual code structure using Start, End, Decision, etc. It should be step-by-step, no actual code. For example:\n\nStart // begin\n→ Step 1: Receive array nums // ...\n→ Step 2: Compute prefixSum array // ...\n→ Step 3: Define method sumRange(left, right) // ...\n→ Decision: Validate indices // ...\n    Yes → Step 4: Calculate sum = prefixSum[right+1] - prefixSum[left] // ...\n    No  → Step 5: Return error // ...\nEnd // finish\n\nWe need to be \"逐行\" meaning each line separated by newline.\n\nWe should ensure we include \"→\" arrow lines. For decisions, we indent? In example, decisions had indentation.\n\nWe should produce a \"virtual code\" for class NumArray. Should include initialization and sumRange.\n\nWe need to adhere to format: Each line: \"虛擬碼步驟 [空格] // 解釋/說明\". Use Start, End, Decision:, Yes →, No →.\n\nLet's create:\n\nStart // 程式開始執行\n→ Step 1: 建立 NumArray 類別，接受整數陣列 nums // 初始化對象\n→ Step 2: 產生前綴和陣列 prefixSum，長度為 nums.length + 1 // 方便區間加總\n    → Step 2.1: prefixSum[0] = 0 // 前綴和起始值\n    → Step 2.2: For i from 0 to nums.length-1\n        → Step 2.2.1: prefixSum[i+1] = prefixSum[i] + nums[i] // 累積和\n→ Step 3: 定義 sumRange(left, right) 方法 // 回傳區間總和\n    → Decision: 是否左索引或右索引在合法範圍內? // 檢查邊界\n        Yes → Step 3.1: result = prefixSum[right+1] - prefixSum[left] // 計算區間和\n            → Step 3.2: Return result // 傳回結果\n        No  → Step 3.3: Return error 或抛异常 // 處理不合法輸入\nEnd // 程式執行結束\n\nWe must keep each line in the format \"虛擬碼步驟 // 解釋\".\n\nMake sure \"→\" at beginning of step lines. Decision lines start with \"Decision:\".\n\nIndentation may use spaces or tab; we can indent inside decisions. Use spaces. After Decision, we indent Yes →, No → lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 NumArray 類別，接受整數陣列 nums // 初始化對象  \n→ Step 2: 產生前綴和陣列 prefixSum，長度為 nums.length + 1 // 方便區間加總  \n    → Step 2.1: prefixSum[0] = 0 // 前綴和起始值  \n    → Step 2.2: For i from 0 to nums.length-1  \n        → Step 2.2.1: prefixSum[i+1] = prefixSum[i] + nums[i] // 累積和  \n→ Step 3: 定義 sumRange(left, right) 方法 // 回傳區間總和  \n    → Decision: 左右索引是否在合法範圍內? // 檢查邊界  \n        Yes → Step 3.1: result = prefixSum[right+1] - prefixSum[left] // 計算區間和  \n            → Step 3.2: Return result // 傳回結果  \n        No  → Step 3.3: Return error 或拋出例外 // 處理不合法輸入  \nEnd // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphpbpmk01.py\", line 41, in parse_input\n    result[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmphpbpmk01.py\", line 50, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphpbpmk01.py\", line 43, in parse_input\n    result[key] = int(val)\n                  ^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0nqe0mtr.py\", line 41, in parse_input\n    result[key] = ast.literal_eval(val)\n                  ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmp0nqe0mtr.py\", line 50, in <module>\n    params = parse_input(raw_input)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0nqe0mtr.py\", line 43, in parse_input\n    result[key] = int(val)\n                  ^^^^^^^^\nValueError: invalid literal for int() with base 10: '[1'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom bisect import bisect_left, insort\n\ndef contains_nearby_almost_duplicate(nums, indexDiff, valueDiff):\n    if indexDiff <= 0 or valueDiff < 0:\n        return False\n\n    window = []\n    for i, num in enumerate(nums):\n        # find first element >= num - valueDiff\n        pos = bisect_left(window, num - valueDiff)\n        # check if that element is within valueDiff\n        if pos < len(window) and abs(window[pos] - num) <= valueDiff:\n            return True\n\n        # add current number to the window\n        insort(window, num)\n\n        # keep window size <= indexDiff\n        if len(window) > indexDiff:\n            # remove the element that is now out of window\n            out_idx = i - indexDiff\n            out_val = nums[out_idx]\n            # find out_val in window and remove it\n            remove_pos = bisect_left(window, out_val)\n            if remove_pos < len(window) and window[remove_pos] == out_val:\n                window.pop(remove_pos)\n\n    return False\n\ndef parse_input(data_str):\n    parts = [p.strip() for p in data_str.split(',')]\n    result = {}\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            key = key.strip()\n            val = val.strip()\n            try:\n                result[key] = ast.literal_eval(val)\n            except:\n                result[key] = int(val)\n    return result\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    params = parse_input(raw_input)\n    nums = params.get('nums', [])\n    indexDiff = params.get('indexDiff', 0)\n    valueDiff = params.get('valueDiff', 0)\n    answer = contains_nearby_almost_duplicate(nums, indexDiff, valueDiff)\n    print('true' if answer else 'false')",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm. We need to produce a step-by-step algorithm. The problem: find if there exists i,j such that abs(i-j)<=indexDiff and abs(nums[i]-nums[j]) <= valueDiff.\n\nWe need to produce a step-by-step algorithm. We can use sliding window approach: maintain a balanced BST or SortedList of elements in current window of size indexDiff. For each index i, we look for any number in the set that is within valueDiff of nums[i]. We can use sorted set to find floor/ceiling. Complexity O(n log n). Provide pseudo code.\n\nWe need to use virtual code lines with arrow and decisions. So format:\n\nStart\n→ Step 1: Initialize an empty balanced BST set // etc.\n\nWe need to ensure each line ends with // explanation.\n\nLet's produce about maybe 15-20 lines. We'll include loops, decisions. Use arrows.\n\nWe must not output actual code, just pseudo.\n\nLet's produce:\n\nStart // Program starts\n→ Step 1: Create empty SortedList window // holds numbers within indexDiff\n→ Step 2: For i from 0 to len(nums)-1: // iterate over array\n    → Decision: If i > indexDiff: // Remove element that is out of window\n        → Step 3: Remove nums[i-indexDiff-1] from window // keep window size\n    → Step 4: Search in window for element >= nums[i] - valueDiff // find potential partner\n        → Decision: If found element <= nums[i] + valueDiff: // satisfies valueDiff\n            → Step 5: Return True // pair found\n    → Step 6: Insert nums[i] into window // add current element\n→ Step 7: Return False // no pair found after loop\nEnd // Program ends\n\nWe need to explain each line. Use proper arrows and indent.\n\nAlso include arrow for step numbers. Use \"Decision:\" with Yes and No. We can incorporate decision lines for each condition.\n\nLet's refine:\n\nStart // 程式開始執行\n→ Step 1: 建立空的平衡 BST window // 用來儲存目前滑動視窗內的數值\n→ Decision: 是否有元素在 window? // 初始時為空\n    No → 進入主迴圈 // 直接跳到迴圈\n→ Step 2: 迭代 i 從 0 到 len(nums)-1 // 遍歷陣列\n    → Decision: i > indexDiff? // 判斷是否要移除離開視窗的元素\n        Yes → Step 3: 從 window 移除 nums[i-indexDiff-1] // 將過舊元素丟掉\n        No  → // 不做任何事\n    → Step 4: 在 window 中尋找最小大於等於 nums[i]-valueDiff 的元素 // 可能的匹配\n        → Decision: 找到且該元素 <= nums[i]+valueDiff? // 檢查 valueDiff 條件\n            Yes → Step 5: 回傳 True // 找到符合條件的索引對\n            No  → // 仍需繼續\n    → Step 6: 將 nums[i] 插入 window // 加入當前元素到視窗\n→ Step 7: 回傳 False // 所有元素檢查完畢仍未找到符合條件的對\nEnd // 程式執行結束\n\nWe need to format with arrows and steps. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的平衡 BST window // 用來儲存目前滑動視窗內的數值  \n→ Decision: window 是否為空?  \n    No → Step 2: 迭代 i 從 0 到 len(nums)-1 // 遍歷整個陣列  \n        → Decision: i > indexDiff? // 判斷是否有元素已離開視窗  \n            Yes → Step 3: 從 window 移除 nums[i-indexDiff-1] // 刪除最舊的數值  \n            No  → // 仍保留舊數值  \n        → Step 4: 在 window 中尋找最小的大於等於 nums[i]-valueDiff 的元素 // 可能的配對候選  \n            → Decision: 找到且該元素 <= nums[i]+valueDiff? // 檢查 valueDiff 條件  \n                Yes → Step 5: 回傳 True // 找到符合條件的索引對，結束程式  \n                No  → // 沒找到符合條件的候選，繼續處理  \n        → Step 6: 將 nums[i] 插入 window // 加入當前元素以供後續比較  \n    → Step 7: 回傳 False // 所有元素檢查完畢仍未找到符合條件的對  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Wrap input in brackets to make it a valid Python literal\n    ops, args = ast.literal_eval('[' + data + ']')\n    instance = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            instance = Solution(arg[0])\n            results.append(None)\n        elif op == \"pickIndex\":\n            if instance is None:\n                results.append(None)\n            else:\n                results.append(instance.pickIndex())\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code with explanations. Must be line by line. Use Start, End, Decision, Yes, No. We need to generate pseudocode for class that receives array w and pickIndex method. Steps: compute prefix sums; generate random number r in [0, sum); binary search to find first prefix >= r; return index.\n\nLet's produce stepwise:\n\nStart\n→ Initialize array w\n→ Compute prefix sum array ps\n→ Store total sum\n→ Function pickIndex:\n    → Generate random number r between 0 and total sum (exclusive)\n    → Binary search on ps to find lowest index where ps[idx] > r\n    → Return idx\nEnd\n\nWe need to produce each step line by line, including explanation after //.\n\nNeed to use arrow symbols and structure: maybe Start, End. The decision: binary search loop.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Store input array w // 取得權重陣列\n→ Compute prefix sums ps // 前綴和陣列，ps[i] = sum_{j=0}^{i} w[j]\n→ Set total = ps[last] // 總重量\n→ Define function pickIndex() // 定義隨機選取方法\n    → Generate random number r in [0, total) // 產生隨機重數\n    → Initialize low = 0, high = ps.length - 1 // 二分搜尋範圍\n    → While low < high: // 二分搜尋開始\n        → mid = (low + high) / 2 // 取中點\n        → Decision: if ps[mid] > r? // 檢查中點是否大於 r\n            Yes → high = mid // 搜尋左半區\n            No  → low = mid + 1 // 搜尋右半區\n    → Return low // low 為符合條件的索引\nEnd // 程式結束\n\nNeed to maintain line indent maybe. Provide each line separate.\n\nLet's deliver.\n...done thinking.\n\nStart // 程式開始\n→ Store input array w // 取得權重陣列\n→ Compute prefix sums ps // 前綴和陣列，ps[i] = sum_{j=0}^{i} w[j]\n→ Set total = ps[last] // 總重量\n→ Define function pickIndex() // 定義隨機選取方法\n    → Generate random number r in [0, total) // 產生隨機重數\n    → Initialize low = 0, high = ps.length - 1 // 二分搜尋範圍\n    → While low < high: // 二分搜尋開始\n        → mid = (low + high) / 2 // 取中點\n        → Decision: if ps[mid] > r? // 檢查中點是否大於 r\n            Yes → high = mid // 搜尋左半區\n            No  → low = mid + 1 // 搜尋右半區\n    → Return low // low 為符合條件的索引\nEnd // 程式結束"
    },
    {
      "title": "Multiply Strings",
      "source_file": "Leetcode/leetcode43.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 若其中一個為 0，直接回傳 \"0\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 結果陣列長度為 m + n\n        pos = [0] * (m + n)\n\n        # 從最低位開始進行乘法\n        for i in range(m - 1, -1, -1):\n            a = ord(num1[i]) - 48  # 快速轉成 int\n            for j in range(n - 1, -1, -1):\n                b = ord(num2[j]) - 48\n                mul = a * b\n                p1, p2 = i + j, i + j + 1\n                s = mul + pos[p2]\n\n                pos[p1] += s // 10       # 進位加到高位\n                pos[p2] = s % 10         # 低位\n\n        # 轉成字串並去除前導 0\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中找出第一個兩個整數，支援多種格式。\n    1) 例如: \"num1 = '123', num2 = '456'\"\n    2) 兩行分別給出\n    3) 兩個空白分隔的數字\n    \"\"\"\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        return nums[0], nums[1]\n\n    lines = data.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n\n    parts = data.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 最後的備援：若只有一個數字，第二個視為空字串\n    return data.strip(), \"\"\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    num1, num2 = parse_input(raw)\n    solution = Solution()\n    product = solution.multiply(num1, num2)\n    print(product)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for multiplying two string numbers without BigInteger, using classic grade-school multiplication.\n\nWe need to produce steps line by line with virtual code arrow, Decision etc. No actual code, just pseudocode. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Steps: parse lengths, initialize result array of length m+n, iterate from end of each string, multiply digits, add to result, handle carry, build string, remove leading zeros.\n\nLet's produce. Ensure each line has arrow like \"→\". Start, End, Decision.\n\nWe can group loops etc. Provide details.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 取 num1 與 num2 長度 m, n // 獲取兩字串長度\n→ Decision: m==0 或 n==0? // 檢查是否有零\n    Yes → Step 2: 回傳 \"0\" // 任一為零則結果為 0\n    No  → Step 3: 建立長度 m+n 的數組 result 初始化為 0 // 為乘法結果準備\n→ Step 4: 迴圈 i 從 m-1 到 0 // 逐位遍歷 num1 從低位開始\n    → Step 5: 取 digitA = num1[i] - '0' // 轉成數字\n    → Step 6: 迴圈 j 從 n-1 到 0 // 逐位遍歷 num2\n        → Step 7: 取 digitB = num2[j] - '0' // 轉成數字\n        → Step 8: 乘積 prod = digitA * digitB // 計算單位相乘\n        → Step 9: posLow = i + j + 1 // 低位結果位置\n        → Step 10: sum = prod + result[posLow] // 加入已有值\n        → Step 11: result[posLow] = sum % 10 // 取位數\n        → Step 12: result[posLow-1] += sum / 10 // 將進位加到高位\n→ Step 13: 變量 index = 0 // 設定起始位置\n→ Decision: result[0]==0? // 判斷是否有前導 0\n    Yes → Step 14: index = 1 // 跳過 0\n    No  → // 不跳\n→ Step 15: 建立空字串 builder // 準備拼接結果\n→ Step 16: 從 index 到 m+n-1 迴圈\n    → Step 17: builder.append(result[k]) // 加入每位\n→ Step 18: 回傳 builder.toString() // 輸出乘積字串\nEnd // 程式結束\n\nWe need each line separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取 num1 與 num2 長度 m, n // 取得兩個字串的位數  \n→ Decision: m==0 或 n==0? // 檢查是否有數字為 0  \n Yes → Step 2: 回傳 \"0\" // 任何一個為 0 時結果即為 0  \n No → Step 3: 建立長度 m+n 的數組 result，並初始化為 0 // 為乘法結果預留空間  \n→ Step 4: 迴圈 i 從 m-1 到 0  // 依次處理 num1 的每一位（從低位開始）  \n → Step 5: 取 digitA = num1[i] - '0' // 把字符轉成數字  \n → Step 6: 迴圈 j 從 n-1 到 0  // 依次處理 num2 的每一位  \n  → Step 7: 取 digitB = num2[j] - '0' // 把字符轉成數字  \n  → Step 8: 乘積 prod = digitA * digitB // 計算兩位相乘  \n  → Step 9: posLow = i + j + 1 // 計算 result 中低位的索引  \n  → Step 10: sum = prod + result[posLow] // 加上已有值  \n  → Step 11: result[posLow] = sum % 10 // 取餘數放低位  \n  → Step 12: result[posLow-1] += sum / 10 // 把進位加到高位  \n→ Step 13: 變量 index = 0 // 指標用於跳過前導 0  \n→ Decision: result[0]==0? // 判斷最高位是否為 0  \n Yes → Step 14: index = 1 // 跳過這個 0  \n No  → // 不跳  \n→ Step 15: 建立空字串 builder // 準備拼接最終結果  \n→ Step 16: 迴圈 k 從 index 到 m+n-1  \n → Step 17: builder.append(result[k]) // 把每位數字加入字串  \n→ Step 18: 回傳 builder.toString() // 輸出乘積字串  \nEnd // 程式執行結束"
    }
  ]
}