{
  "run_index": 32,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 291,
  "generation_or_validation_failure_count": 43,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin（如果有輸入），以符合「主程式必須從 stdin 讀取」的要求\n    _ = sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nThe user wants to generate pseudo-code with step-by-step explanation. The output must follow the format specified: each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". They also want arrow notation. Must not output real code.\n\nWe need to write a virtual code that starts, attempts to open file with \"with\" and try/except. It should count lines. If file exists, read lines, count, output count. If not, output \"找不到檔案！\".\n\nWe should structure as:\n\nStart\n→ Step 1: 用 try 打開 data.txt 並使用 with 讀取 // 開啟檔案\n    → Decision: 檔案成功開啟? // 判斷是否進入 try 區塊\n        Yes → Step 2: 讀取所有行並計數 // 讀取行\n        No → Step 3: 輸出 '找不到檔案！' // 檔案不存在\n        End\n\nBut also handle except.\n\nBetter structure:\n\nStart\n→ Step 1: 建立行計數變數 count = 0 // 初始化計數\n→ Decision: 試圖執行以下程式碼? // try block\n    Yes → Step 2: with open('data.txt', 'r') as file: // 開啟檔案\n            → Step 3: 對每行在 file: // 逐行遍歷\n                → Step 4: count += 1 // 計數\n            → Step 5: 輸出 count // 顯示總行數\n        End\n    No → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\nEnd\n\nBut we must use arrow syntax: \"→\" and \"Yes →\", \"No →\" etc. Use Decision. Also use with.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化行計數 count = 0 // 設定計數變數\n→ Decision: 是否可以執行 try? // 判斷是否進入 try 區塊\n    Yes → Step 2: with open('data.txt', 'r') as file: // 以 with 開啟檔案\n        → Step 3: 對於每行 in file: // 遍歷檔案行\n            → Step 4: count += 1 // 計數\n        → Step 5: 輸出 count // 輸出總行數\n    No  → Step 6: 輸出 '找不到檔案！' // 檔案不存在時提示\nEnd // 程式結束\n\nBut we need to represent try/except. The Decision could be \"try?\".\n\nBetter structure:\n\nStart // 程式開始執行\n→ Step 1: 初始化 count = 0 // 設定計數變數\n→ Decision: 進入 try 區塊? // 進行 try\n    Yes → Step 2: with open('data.txt', 'r') as file: // 開啟檔案\n        → Step 3: 對每行 in file: // 逐行讀取\n            → Step 4: count += 1 // 計數\n        → Step 5: 輸出 count // 輸出行數\n    No  → Step 6: 輸出 '找不到檔案！' // 例外處理\nEnd\n\nBut maybe better to show the except path:\n\nDecision: 進入 try? -> Yes (file exists) -> ... ; No (file missing) -> ... .\n\nMake sure we mention with and try/except. We can include comment.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0 // 設定行數計數變數  \n→ Decision: 進入 try 區塊? // 判斷是否能成功執行 try  \n  Yes → Step 2: with open('data.txt', 'r') as file: // 用 with 開啟檔案  \n    → Step 3: 對每行 in file: // 逐行遍歷檔案  \n      → Step 4: count += 1 // 行數累加  \n    → Step 5: 輸出 count // 顯示總行數  \n  No  → Step 6: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,1,5,4,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 1, 5, 4, 4]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取全部輸入，並執行其內容\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, each with // explanation. Format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows.\n\nNeed to include random module usage. We need a function roll_dice(n). The function will simulate rolling n times and return list of results. Steps: define function, create empty list, loop n times, generate random integer 1-6, append to list, after loop return list. Use Start, End. Use Decision? maybe check if n <= 0? But requirement not mention. But we could include a decision to validate n >0. Provide simple. We'll include Decision: If n <= 0? maybe handle error.\n\nLet's craft:\n\nStart\n→ Step 1: 導入 random 模組 // 需要亂數生成\n→ Step 2: 定義函式 roll_dice(n) // 宣告函式\n    → Step 3: 初始化 results = [] // 空串列儲存結果\n    → Decision: 如果 n <= 0? // 檢查次數是否合法\n        Yes → Step 4: 返回空串列 // 若次數非正，直接回傳空串列\n        No  → Step 5: 為 i in range(n) // 迭代擲骰 n 次\n            → Step 6: 隨機產生 dice = random.randint(1, 6) // 產生 1-6 的亂數\n            → Step 7: results.append(dice) // 加入結果\n    → Step 8: 返回 results // 回傳所有擲骰結果\nEnd\n\nBut we need \"虛擬碼步驟\" each line. Also use arrow? They want arrow syntax: → Step 1 etc. For Decision, they have indentation with Yes → and No → lines. Let's produce lines with arrows. Use indentation for nested lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random module // 需要亂數生成  \n→ Step 2: Define function roll_dice(n) // 宣告擲骰函式  \n → Step 3: Initialize results = [] // 空串列儲存結果  \n → Decision: If n <= 0? // 檢查擲骰次數是否合法  \n  Yes → Step 4: Return [] // 次數非正，直接回傳空串列  \n  No  → Step 5: For i in range(n): // 迭代擲骰 n 次  \n    → Step 6: dice = random.randint(1, 6) // 產生 1~6 的亂數  \n    → Step 7: results.append(dice) // 加入結果至串列  \n → Step 8: Return results // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行時間，並回傳秒數（四捨五入到小數點 3 位）\"\"\"\n    start = time.time()\n    func(*args)               # 執行目標函式\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個程式碼字串\n    code = sys.stdin.read()\n\n    # 建立一個包含 measure_time 的執行環境\n    exec_globals = {\"measure_time\": measure_time, \"__builtins__\": __builtins__}\n\n    # 執行讀入的程式碼\n    exec(code, exec_globals)",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with \"虛擬碼步驟\" and \"// 解釋/說明\". Use arrow notation, etc. Should not output actual code. Just pseudocode steps. Steps: import time, define function measure_time(func, *args), record start = time.time(), call result = func(*args), end = time.time(), duration = round(end-start, 3), return duration, result? Wait requirement: \"並回傳結果 (四捨五入到小數點 3 位)。\" Likely return both duration and result? Might mean return the duration. But they say \"回傳結果\" ambiguous. I'd assume return duration and result? But better: return duration. Provide explanation.\n\nLet's produce steps: Start, Step 1: Import time module, Step 2: Define measure_time(func, *args), Step 3: Record start time, Step 4: Execute func with args, capture result, Step 5: Record end time, Step 6: Compute duration rounded to 3 decimal places, Step 7: Return duration (maybe also result) but specify.\n\nWe'll create Decision? maybe no decisions.\n\nOk produce lines with \"→\" arrows.\n\nLet's craft.\n\nRemember to use \"Start\" and \"End\".\n\nWe must adhere to output format exactly. Use \"Start // 程式開始執行\" etc. Provide explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 先載入 Python 的 time 函式庫  \n→ Step 2: Define measure_time(func, *args) // 定義一個函式，用於計時  \n→ Step 3: Record start = time.time() // 取得執行前的時間戳  \n→ Step 4: Call result = func(*args) // 執行傳入的函式，並將回傳值存入 result  \n→ Step 5: Record end = time.time() // 取得執行後的時間戳  \n→ Step 6: Compute duration = round(end - start, 3) // 計算執行時間並四捨五入到小數點 3 位  \n→ Step 7: Return duration // 回傳計算得到的秒數（可選擇同時回傳 result）  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'apple', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（此題不需要實際輸入，僅為符合要求）\n    _ = sys.stdin.read()\n\n    # 建立集合並執行各項操作\n    fruits = {'apple', 'banana'}          # 初始集合\n    fruits.add('orange')                  # 新增 'orange'\n    fruits.update(['grape', 'melon'])     # 一次新增 'grape' 與 'melon'\n    fruits.remove('banana')               # 移除 'banana'\n    fruits.discard('pineapple')           # 嘗試移除 'pineapple'（不存在不拋錯）\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output line by line virtual code with explanation. Use Start, → etc. Must be in traditional Chinese. Provide code steps: Start, define fruits, add, update, remove, discard, output, End. No actual code. Use arrow. Let's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義集合 fruits = {'apple', 'banana'} // 初始化集合  \n→ Step 2: 使用 add() 新增 'orange' // 把 'orange' 加進集合  \n→ Step 3: 使用 update() 一次新增 'grape' 與 'melon' // 同時加入兩個新元素  \n→ Step 4: 使用 remove() 移除 'banana' // 刪除指定元素，若不存在會拋錯  \n→ Step 5: 使用 discard() 嘗試移除 'pineapple' // 若元素不存在則不產生錯誤  \n→ Step 6: 輸出 fruits // 顯示最終集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> float:\n    \"\"\"向 API 取得美元兌台幣匯率並回傳。若失敗回傳 None。\"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=5)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef create_gui() -> None:\n    \"\"\"建立並顯示 tkinter GUI，按鈕可更新匯率。\"\"\"\n    root = tk.Tk()\n    root.title(\"美元兌台幣匯率\")\n\n    # 顯示匯率的標籤，初始文字可隨時更新\n    rate_label = tk.Label(root, text=\"請按下按鈕更新匯率\", font=(\"Helvetica\", 14))\n    rate_label.pack(pady=20)\n\n    def update_label() -> None:\n        rate = fetch_rate()\n        if rate is not None:\n            rate_label.config(text=f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            rate_label.config(text=\"更新失敗，請檢查網路連線\")\n\n    # 按鈕，點擊時呼叫 update_label\n    btn = tk.Button(root, text=\"更新匯率\", command=update_label, width=20)\n    btn.pack(pady=10)\n\n    # 初始載入一次匯率\n    update_label()\n\n    root.mainloop()\n\nif __name__ == \"__main__\":\n    # 若有 piped input（非互動模式）則讀取並直接輸出匯率資訊\n    if not sys.stdin.isatty():\n        _ = sys.stdin.read()  # 讀取但不做處理\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate:.2f} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 互動式執行時啟動 GUI\n        create_gui()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with arrows. Use Start, End, Decision, etc. The code steps: import modules, create Tk window, define function to fetch rate using requests, parse JSON, update label, create button, bind function, run mainloop.\n\nWe must produce line-by-line virtual code. Let's format each line: \"虛擬碼步驟 // 解釋\". Use arrows and indent. Use decision if needed (maybe checking request status). Use Start, End. We'll keep each step separate.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 匯入 requests 模組 // 用於發送 HTTP 請求\n→ Step 2: 匯入 tkinter 模組並命名為 tk // 用於建立 GUI\n→ Step 3: 建立主視窗 root = tk.Tk() // 初始化 tkinter 視窗\n→ Step 4: 設定視窗標題 root.title('美元兌台幣匯率') // 顯示窗口標題\n→ Step 5: 建立顯示匯率的 Label rate_label = tk.Label(root, text='匯率: 取得中…', font=('Helvetica', 14)) // 初始化顯示文字\n→ Step 6: rate_label.pack(pady=20) // 放置 Label 並留白\n→ Step 7: 建立按鈕 update_button = tk.Button(root, text='更新匯率', width=20) // 建立按鈕\n→ Step 8: update_button.pack(pady=10) // 放置按鈕\n→ Step 9: 定義函式 fetch_rate() // 用於向 API 發送請求並更新 Label\n→     Decision: 如果 requests 取得成功? // 檢查 HTTP 回應狀態\n→         Yes → Step 10: 解析 JSON data = response.json() // 轉成 Python dict\n→         Yes → Step 11: 取得 TWD 匯率 rate = data['rates']['TWD'] // 從 dict 取出匯率\n→         Yes → Step 12: 更新 Label  rate_label.config(text=f'匯率: 1 USD = {rate:.2f} TWD') // 顯示新匯率\n→         No  → Step 13: 更新 Label  rate_label.config(text='無法取得匯率，請稍後再試') // 顯示錯誤訊息\n→ Step 14: 將 fetch_rate() 綁定到 update_button 的 click 事件 update_button.config(command=fetch_rate) // 讓按鈕點擊時呼叫函式\n→ Step 15: 呼叫 fetch_rate() 一次以顯示初始匯率 // 初次載入時即更新一次\n→ Step 16: 進入主事件迴圈 root.mainloop() // 開始 GUI 事件循環\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[None,True,False,True,2,True,False,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[None, True, False, True, 2, True, False, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport re\n\nclass RandomizedSet:\n    \"\"\"\n    隨機集合，支持 O(1) 插入、刪除和隨機取值。\n    \"\"\"\n\n    def __init__(self):\n        # 存放所有元素的列表\n        self.values = []\n        # 元素到索引的映射\n        self.val_to_index = {}\n\n    def insert(self, val: int) -> bool:\n        \"\"\"若元素不存在則插入，返回 True；若已存在則不插入，返回 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若元素存在則刪除，返回 True；若不存在則返回 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取得要刪除元素的索引\n        idx = self.val_to_index[val]\n        # 取得列表最後一個元素\n        last_val = self.values[-1]\n        # 用最後一個元素覆蓋待刪除位置\n        self.values[idx] = last_val\n        # 更新覆蓋元素的索引\n        self.val_to_index[last_val] = idx\n        # 刪除最後一個元素\n        self.values.pop()\n        # 移除映射\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回集合中的一個元素。\"\"\"\n        return random.choice(self.values)\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支持兩種格式：\n    1. 兩行分別為 commands 和 args\n    2. 單行中以 '], [' 分隔兩個列表\n    \"\"\"\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        commands = ast.literal_eval(lines[0])\n        args = ast.literal_eval(lines[1])\n    else:\n        # 單行輸入，使用正則表達式拆分\n        match = re.search(r'\\[(.*?)\\],\\s*\\[(.*)\\]', lines[0], re.S)\n        if not match:\n            raise ValueError(\"輸入格式錯誤\")\n        commands = ast.literal_eval('[' + match.group(1) + ']')\n        args = ast.literal_eval('[' + match.group(2) + ']')\n    return commands, args\n\ndef main():\n    data = sys.stdin.read()\n    commands, args = parse_input(data)\n\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == 'RandomizedSet':\n            obj = RandomizedSet()\n            res.append(None)  # constructor 的結果為 null\n        elif cmd == 'insert':\n            res.append(obj.insert(arg[0]))\n        elif cmd == 'remove':\n            res.append(obj.remove(arg[0]))\n        elif cmd == 'getRandom':\n            res.append(obj.getRandom())\n        else:\n            # 若有其他未知方法，簡單忽略或拋錯\n            raise ValueError(f\"未知方法 {cmd}\")\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for RandomizedSet with methods insert, remove, getRandom. Provide explanation each line. Use Start, End, Decision etc.\n\nWe need to illustrate algorithm: use hash map from val to index in array, and array/list to store values. Insert: if val not in map, push to array, map[val]=last index, return true else false. Remove: if val in map, get index, last element = array[last], replace array[index] = last, update map[last] = index, pop last, delete map[val], return true else false. getRandom: pick random index between 0 and len-1, return array[random].\n\nWe'll output line by line with explanation. Use arrows \"→\". Use Decision steps. We need to represent each function as separate virtual steps? Might combine all into one pseudocode flow.\n\nProbably produce high-level algorithm steps for each method.\n\nLet's produce:\n\nStart // initialize class\n→ Step 1: 建立空 list values // 存儲所有元素\n→ Step 2: 建立空 dict posMap // 存儲元素到索引映射\nEnd // 初始化完成\n\nThen methods.\n\nMethod insert(val):\nStart // insert 方法開始\n→ Decision: val 是否存在於 posMap? // 檢查元素是否已存在\n    Yes → Step 1: 返回 false // 已存在，不插入\n    No  → Step 2: Append val 到 values // 將新元素加入尾部\n          Step 3: posMap[val] = len(values)-1 // 記錄索引\n          Step 4: 返回 true // 插入成功\nEnd // insert 結束\n\nMethod remove(val):\nStart // remove 方法開始\n→ Decision: val 是否存在於 posMap? // 檢查元素是否存在\n    Yes → Step 1: idx = posMap[val] // 取得該元素索引\n          Step 2: lastVal = values[-1] // 取得最後一個元素\n          Step 3: values[idx] = lastVal // 用最後一個元素覆蓋要刪除的位置\n          Step 4: posMap[lastVal] = idx // 更新覆蓋元素的索引\n          Step 5: values.pop() // 刪除尾部元素\n          Step 6: Delete posMap[val] // 移除映射\n          Step 7: 返回 true // 刪除成功\n    No  → Step 1: 返回 false // 元素不存在\nEnd // remove 結束\n\nMethod getRandom():\nStart // getRandom 方法開始\n→ Step 1: idx = random integer between 0 and len(values)-1 // 隨機索引\n→ Step 2: 返回 values[idx] // 返回隨機元素\nEnd // getRandom 結束\n\nMake sure each line has \"虛擬碼步驟 [空格] // 解釋\". Use arrows \"→\" before steps.\n\nAlso include Start and End lines with explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 建立空 list values // 用於存放所有元素\n→ Step 2: 建立空 dict posMap // 用於記錄元素到索引的映射\n\nEnd // 初始化完成\n\n--------------------------------------------------------------------\n\nStart // insert 方法開始\n→ Decision: val 是否存在於 posMap? // 檢查元素是否已在集合中\n    Yes → Step 1: 返回 false // 元素已存在，插入失敗\n    No  → Step 2: Append val 到 values // 將新元素放在尾部\n          Step 3: posMap[val] = len(values)-1 // 記錄新元素的索引\n          Step 4: 返回 true // 插入成功\nEnd // insert 方法結束\n\n--------------------------------------------------------------------\n\nStart // remove 方法開始\n→ Decision: val 是否存在於 posMap? // 檢查元素是否存在\n    Yes → Step 1: idx = posMap[val] // 取得要刪除元素的索引\n          Step 2: lastVal = values[-1] // 取得目前最後一個元素\n          Step 3: values[idx] = lastVal // 用最後一個元素覆蓋要刪除的位置\n          Step 4: posMap[lastVal] = idx // 更新覆蓋元素的索引\n          Step 5: values.pop() // 刪除尾部元素\n          Step 6: Delete posMap[val] // 移除被刪除元素的映射\n          Step 7: 返回 true // 刪除成功\n    No  → Step 1: 返回 false // 元素不存在，刪除失敗\nEnd // remove 方法結束\n\n--------------------------------------------------------------------\n\nStart // getRandom 方法開始\n→ Step 1: idx = random integer between 0 and len(values)-1 // 隨機產生索引\n→ Step 2: 返回 values[idx] // 回傳隨機選取的元素\nEnd // getRandom 方法結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[None,[2,0],[1,0],[0,0],None,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[None, [2, 0], [1, 0], [0, 0], None, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass Solution:\n    \"\"\"\n    Randomly flips 0 to 1 in an m x n binary matrix.\n    Each zero index is equally likely to be chosen.\n    \"\"\"\n    def __init__(self, m, n):\n        self.rows = m\n        self.cols = n\n        self.total = m * n          # number of remaining zeros\n        self.map = {}               # maps chosen index to available one\n\n    def flip(self):\n        \"\"\"\n        Returns a random zero index [i, j] and flips it to 1.\n        \"\"\"\n        # Pick a random position from the remaining zeros\n        r = random.randint(0, self.total - 1)\n        # Resolve the actual index, considering previous mappings\n        idx = self.map.get(r, r)\n\n        # Update the remaining count\n        self.total -= 1\n        # Re-map the chosen index to the last available index\n        self.map[r] = self.map.get(self.total, self.total)\n\n        # Convert linear index back to 2D coordinates\n        return [idx // self.cols, idx % self.cols]\n\n    def reset(self):\n        \"\"\"\n        Resets the matrix to all zeros.\n        \"\"\"\n        self.total = self.rows * self.cols\n        self.map.clear()\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into operation list and arguments list\n    split_index = data.find('],')\n    ops_str = data[:split_index + 1]\n    args_str = data[split_index + 2:]\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    output = []\n    sol = None\n\n    for op, arg in zip(ops, args):\n        if op == 'Solution':\n            sol = Solution(arg[0], arg[1])\n            output.append(None)\n        elif op == 'flip':\n            output.append(sol.flip())\n        elif op == 'reset':\n            sol.reset()\n            output.append(None)\n\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines and explanations. Need to propose algorithm: Reservoir? Actually typical LeetCode 501 Random Pick with Blacklist. Here matrix zeros initially all. flip selects random zero. Equivalent to picking random number from 0..m*n-1, mapping to coordinates. We need maintain mapping dictionary to avoid used indices. Implementation: maintain pool count remaining zeros. Each flip: random integer r in [0, remaining-1]; map r to actual index: if map has r use mapped; else r itself. Then decrement remaining. After mapping r to chosen index, map r to last available index (remaining-1) or its mapped value. Also maintain mapping dictionary for used indexes. reset: clear mapping and set remaining to m*n. Complexity O(1) per flip.\n\nWe need produce virtual code line by line, with comments. Include structure. Let's design steps: Start of class. Initialize: m, n, total=m*n, remaining=total, mapping dict. reset: clear mapping, remaining=total. flip: if remaining==0 error. r = random(0, remaining-1). val = mapping.get(r, r). remaining -=1. mapping[r] = mapping.get(remaining, remaining). return val / n, val % n.\n\nBut need to map index to i,j. So after picking val we compute i=val//n, j=val % n.\n\nWe should use virtual code with arrows. Use lines like \"→ Step 1: Initialize mapping dict and remaining\" etc.\n\nLet's write.\n\nWe also need to describe algorithm design: Start -> Step: initialize variables -> Step: random pick -> Decision: check mapping -> Step: map selection -> Step: update mapping -> Step: decrement remaining -> Step: compute coordinates -> Return. Also reset method.\n\nWe'll produce as virtual steps.\n\nNeed to ensure format: each line \"虛擬碼步驟 // 解釋\" with arrow. For methods, start and end.\n\nLet's craft.\n\nPotential outline:\n\nStart\n→ Step 1: Set m, n, total = m*n, remaining = total, map = {}\n→ End\n\nReset:\n→ Step 1: remaining = total\n→ Step 2: clear map\n\nFlip:\n→ Step 1: If remaining == 0 → End (or throw)\n→ Step 2: r = random(0, remaining-1)\n→ Decision: If r in map?\n    Yes → Step 3: val = map[r]\n    No  → Step 3: val = r\n→ Step 4: remaining -= 1\n→ Decision: If remaining in map?\n    Yes → Step 5: map[r] = map[remaining]\n    No  → Step 5: map[r] = remaining\n→ Step 6: i = val // n\n→ Step 7: j = val % n\n→ Step 8: return [i, j]\nEnd\n\nLet's ensure each line with arrow and comment. Use \"Decision:\" lines for branching.\n\nAlso mention that we skip actual random function calls.\n\nWe need to keep each line simple.\n\nWe might also include \"Start\" for class constructor, \"End\" for class.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set m, n, total = m × n, remaining = total, map = {} // 初始化矩陣尺寸、總可用位元、剩餘可翻轉位置與映射表  \nEnd // 物件建構完畢  \n\nReset // 重置矩陣為全零  \n→ Step 1: remaining = total // 重新設定剩餘可用位置為全部位置  \n→ Step 2: map.clear() // 清空所有映射，回到初始狀態  \nEnd // reset 完成  \n\nFlip // 隨機選取一個仍為 0 的位置並翻轉為 1  \n→ Decision: 如果 remaining == 0? // 檢查是否已無空位  \n    Yes → Return error // 無可選位置，拋出錯誤或返回空值  \n    No  →  \n→ Step 3: r = random_int(0, remaining - 1) // 隨機取得 0 ~ remaining-1 的索引  \n→ Decision: 如果 r 在 map? // 判斷 r 是否已被映射  \n    Yes → Step 4: val = map[r] // 若已映射，取映射值  \n    No  → Step 4: val = r // 若未映射，直接使用 r 本身  \n→ Step 5: remaining -= 1 // 從剩餘可用位置中減一，表示已使用一個位置  \n→ Decision: 如果 remaining 在 map? // 檢查剩餘位置的映射  \n    Yes → Step 6: map[r] = map[remaining] // 將 r 映射到 remaining 的映射值  \n    No  → Step 6: map[r] = remaining // 若 remaining 未映射，直接映射到 remaining  \n→ Step 7: i = val // n // 計算行座標  \n→ Step 8: j = val % n // 計算列座標  \n→ Step 9: return [i, j] // 返回已翻轉的位置  \nEnd // flip 完成  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp2d112d_l.py\", line 27, in <module>\n    timeSeries, duration = parse_input(data)\n                           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp2d112d_l.py\", line 17, in parse_input\n    duration_part = parts[1].split('=')[1].strip()\n                    ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptre36r2e.py\", line 27, in <module>\n    timeSeries, duration = parse_input(data)\n                           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptre36r2e.py\", line 17, in parse_input\n    duration_part = parts[1].split('=')[1].strip()\n                    ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            total += min(timeSeries[i + 1] - timeSeries[i], duration)\n        total += duration\n        return total\n\ndef parse_input(data):\n    \"\"\"Parse input of the form 'timeSeries = [1,4], duration = 2'.\"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    time_series_part = parts[0].split('=')[1].strip()\n    duration_part = parts[1].split('=')[1].strip()\n    # Safe eval for list literal\n    timeSeries = eval(time_series_part, {\"__builtins__\": None}, {})\n    duration = int(duration_part)\n    return timeSeries, duration\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    timeSeries, duration = parse_input(data)\n    result = Solution().findPoisonedDuration(timeSeries, duration)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for this problem: total poison time. Classic LeetCode 549. We should produce line-by-line pseudo-code with explanation after each line. Use arrow style.\n\nWe need to handle sum of durations with overlaps.\n\nPseudo: initialize total=0; prev=-1; for each t in timeSeries: if t>prev+duration-1: add duration else add t-prev; update prev=t. Return total.\n\nEdge: first attack. Implementation with loop.\n\nWe need to produce lines following format: Start, → Step..., Decision etc.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: Initialize total = 0 // 記錄總中毒秒數\n→ Step 2: Initialize prev = -duration // 設置上一個攻擊時間為負，確保第一次比較正確\n→ Step 3: 對於每個攻擊時間 t 在 timeSeries: // 逐一處理所有攻擊\n    → Decision: t > prev + duration - 1? // 判斷此攻擊是否在上一個毒效結束後\n        Yes → Step 4a: total += duration // 若不重疊，累加整個毒持續時間\n        No  → Step 4b: total += t - prev // 若重疊，僅累加未被覆蓋的秒數\n    → Step 5: prev = t // 更新上一個攻擊時間\n→ Step 6: Return total // 輸出總中毒秒數\nEnd // 程式執行結束\n\nBut we need to use arrow lines with indentation. Need to ensure each line ends with // explanation. Use arrow syntax: → Step.\n\nBut we need \"Decision:\" lines with Yes →, No →.\n\nAlso need to include Start and End lines.\n\nLet's produce final. Use Chinese comments.\n\nMake sure to not output actual code, just pseudo. Ensure line format: \"虛擬碼步驟 // 解釋\". So each line ends with // and Chinese explanation.\n\nWe must use \"→ Step 1:\" etc. We should not include actual variable assignment? But it's pseudocode. It's fine.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 total ← 0 // 記錄總中毒秒數  \n→ Step 2: 初始化 prev ← -duration // 設置上一個攻擊時間為負，確保第一次比較正確  \n→ Step 3: 對於每個攻擊時間 t 在 timeSeries: // 逐一處理所有攻擊  \n  → Decision: t > prev + duration - 1? // 判斷此攻擊是否在上一個毒效結束後  \n   Yes → Step 4a: total += duration // 若不重疊，累加整個毒持續時間  \n   No  → Step 4b: total += t - prev // 若重疊，僅累加未被覆蓋的秒數  \n  → Step 5: prev ← t // 更新上一個攻擊時間  \n→ Step 6: 返回 total // 輸出總中毒秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = ord(num1[i]) - 48 if i >= 0 else 0  # '0' has ASCII 48\n            y = ord(num2[j]) - 48 if j >= 0 else 0\n            total = x + y + carry\n            res.append(chr((total % 10) + 48))  # prepend digit\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        # reverse the collected characters\n        return ''.join(reversed(res))\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract all digit sequences (handles inputs like: num1 = \"11\", num2 = \"123\")\n    nums = re.findall(r'\\d+', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # Fallback: split by whitespace or commas\n        parts = re.split(r'[,\\s]+', data)\n        if len(parts) >= 2:\n            num1, num2 = parts[0], parts[1]\n        else:\n            # If still not found, assume the entire input is a single number\n            num1 = data\n            num2 = \"0\"\n\n    solution = Solution()\n    result = solution.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for adding two numbers represented as strings, outputting sum string, without using built-in big integer or converting to int directly. We must output step-by-step virtual code with explanation.\n\nWe need to consider algorithm: iterate from end of both strings, add digits with carry, build result string (maybe using array or string builder). At the end, reverse result.\n\nWe will output each line of virtual code with explanation. Format: \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nWe need to structure: Start, then steps, decisions, loops. Should we use while loop? Yes.\n\nPseudo: \nStart\n→ Step 1: Initialize i = length(num1)-1, j = length(num2)-1, carry = 0, result = empty string // Setup indices and variables\n→ Decision: While i>=0 OR j>=0 OR carry>0? // Continue if any digits or carry\n    Yes → Step 2: digit1 = if i>=0 then num1[i]-'0' else 0 // get digit or 0\n    → Step 3: digit2 = if j>=0 then num2[j]-'0' else 0 // get digit or 0\n    → Step 4: sum = digit1 + digit2 + carry // sum digits\n    → Step 5: result = (sum mod 10) concatenated before result // prepend digit\n    → Step 6: carry = sum / 10 // update carry\n    → Step 7: i = i -1\n    → Step 8: j = j -1\nEnd While\n→ Step 9: Return result // output sum string\nEnd\n\nWe must avoid converting whole strings to ints; we only convert individual characters to digit using subtraction.\n\nAdd details: Use char to int conversion via charCodeAt or subtract '0'. Virtual code line can include pseudo \"digit1 = num1[i] - '0'\" but that's still char arithmetic. It's okay.\n\nBut the requirement: no built-in library for large integers, not convert to integers directly. Converting single characters is fine.\n\nLet's produce lines. Use indentation? Not necessary. Use arrow and decision lines. For decision: \"Decision: While i>=0 OR j>=0 OR carry>0?\" with Yes and No branches.\n\nThe final code ends with End.\n\nWe should maintain the format: each line like \"虛擬碼步驟 // 解釋\". For Decision lines, maybe \"Decision: While i>=0 OR j>=0 OR carry>0? // ...\". Then indent sub-steps under Yes branch. Use indentation? Possibly we can show indentation using spaces.\n\nLet's produce. Use no actual code, just pseudo. Provide explanation in Chinese.\n\nLet's write the final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← len(num1) - 1, j ← len(num2) - 1, carry ← 0, result ← \"\" // 初始化索引、進位與結果字串  \n→ Decision: While i ≥ 0 OR j ≥ 0 OR carry > 0? // 只要還有數位或進位，繼續加法  \n  Yes → Step 2: digit1 ← If i ≥ 0 Then num1[i] - '0' Else 0 // 取 num1 的當前位，若已到頭則為 0  \n   → Step 3: digit2 ← If j ≥ 0 Then num2[j] - '0' Else 0 // 取 num2 的當前位，若已到頭則為 0  \n   → Step 4: sum ← digit1 + digit2 + carry // 兩位數與進位相加  \n   → Step 5: result ← (sum mod 10) + result // 把最低位數加到結果前面  \n   → Step 6: carry ← sum / 10 // 更新進位（整數除法）  \n   → Step 7: i ← i - 1 // 移動到 num1 的前一位  \n   → Step 8: j ← j - 1 // 移動到 num2 的前一位  \n  No  → End // 所有位與進位已處理完畢  \n→ Step 9: Return result // 輸出相加後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp1fgxvwim.py\", line 37, in <module>\n    args = ast.literal_eval(args_part.strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    , [[[1, 2, 3, 3, 3]], [3], [1], [3]]\n    ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        self.nums = nums\n\n    def pick(self, target):\n        result = -1\n        count = 0\n        for i, num in enumerate(self.nums):\n            if num == target:\n                count += 1\n                if random.randint(1, count) == 1:\n                    result = i\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Split into commands and arguments\n    split_index = data.find('],')\n    if split_index == -1:\n        # Handle case where there is no comma (unlikely in valid input)\n        commands_part = data\n        args_part = ''\n    else:\n        commands_part = data[:split_index + 1]\n        args_part = data[split_index + 1:]\n\n    # Parse the two parts\n    cmds = ast.literal_eval(commands_part)\n    args = ast.literal_eval(args_part.strip())\n\n    # Execute the commands\n    results = [None]  # The first command is the constructor\n    obj = None\n    for i in range(1, len(cmds)):\n        method_name = cmds[i]\n        if method_name == \"Solution\":\n            obj = Solution(*args[i])\n        else:\n            method = getattr(obj, method_name)\n            res = method(*args[i])\n            results.append(res)\n\n    # Output results in JSON format (None -> null)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step with explanations. The user wants algorithm for the random picking with equal probability, with duplicates. This is typical Reservoir Sampling. Steps: store array. For pick: iterate through array, maintain count of target occurrences seen so far; for each match, generate random integer [1..count]; if random==1, select current index. Finally return selected index. Also store random generator.\n\nWe need to output virtual code lines, using arrow notation etc. Each line: \"虛擬碼步驟 // 解釋\". We'll use lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n→ Step 2: 定義成員變數 nums, random // 用於儲存輸入陣列和隨機產生器\n→ Step 3: Solution(int[] nums) // 建構子\n    → Step 3.1: this.nums = nums // 直接儲存引用\n    → Step 3.2: this.random = new Random() // 初始化隨機數\n→ Step 4: int pick(int target) // pick 方法\n    → Step 4.1: int result = -1 // 初始結果\n    → Step 4.2: int count = 0 // 紀錄目標值出現次數\n    → Step 4.3: for (int i = 0; i < nums.length; i++) // 遍歷陣列\n        → Step 4.3.1: if (nums[i] == target) // 目標值檢查\n            → Step 4.3.1.1: count++ // 次數加一\n            → Step 4.3.1.2: if (random.nextInt(count) == 0) // 等概率選取\n                → Step 4.3.1.2.1: result = i // 記錄此索引\n    → Step 4.4: return result // 回傳選取的索引\nEnd // 程式結束\n\nNeed to ensure we output arrow formatting: '→', 'Yes →', 'No →'. We have no decisions with Yes/No but just simple flow. Use 'Decision:' where needed? We could skip decisions. But we could include decision for if condition: 'Decision: nums[i] == target?' with Yes/No.\n\nSimplify: use Decision lines.\n\nLet's produce.\n\nNote: Each line must contain '虛擬碼步驟' and comment.\n\nWe'll use \"Start\" etc. We'll format as per example.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n→ Step 2: 定義成員變數 nums, random // 用於儲存輸入陣列和隨機產生器\n→ Step 3: Solution(int[] nums) // 建構子\n    → Step 3.1: this.nums = nums // 直接儲存引用\n    → Step 3.2: this.random = new Random() // 初始化隨機數\n→ Step 4: int pick(int target) // pick 方法\n    → Step 4.1: int result = -1 // 初始結果\n    → Step 4.2: int count = 0 // 紀錄目標值出現次數\n    → Step 4.3: for (int i = 0; i < nums.length; i++) // 遍歷陣列\n        → Decision: nums[i] == target? // 檢查當前元素是否等於目標\n            Yes → Step 4.3.1: count++ // 目標出現次數加一\n            Yes → Step 4.3.2: if (random.nextInt(count) == 0) // 隨機選取的機率為 1/count\n                → Step 4.3.2.1: result = i // 目前索引被選中\n    → Step 4.4: return result // 回傳最終選取的索引\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        將字串按字元出現頻率降序排列。\n        \"\"\"\n        # 計算每個字元的頻率\n        freq = Counter(s)\n        # 使用 most_common 取得頻率遞減的字元順序\n        sorted_chars = freq.most_common()\n        # 依序把字元重複 freq 次組成結果字串\n        return ''.join(char * count for char, count in sorted_chars)\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    解析輸入行，支援以下兩種格式：\n    1. 直接給字串，例如: tree\n    2. 變數賦值形式，例如: s = \"tree\"\n    \"\"\"\n    line = line.strip()\n    if '=' in line:\n        # 取等號右側的內容\n        _, rhs = line.split('=', 1)\n        rhs = rhs.strip()\n        # 若以雙引號包住，移除引號\n        if (rhs.startswith('\"') and rhs.endswith('\"')) or (rhs.startswith(\"'\") and rhs.endswith(\"'\")):\n            return rhs[1:-1]\n    # 直接回傳去除空白的原始字串\n    return line\n\ndef main() -> None:\n    # 讀取整個輸入（可能只有一行）\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 只考慮第一行\n    first_line = data.splitlines()[0]\n    s = parse_input(first_line)\n    result = Solution().frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. For string sorting by frequency descending. Steps: input string s, count frequencies (hash map), create list of (char, freq), sort by freq descending, construct result by repeating char freq times. Return. Edge: multiple answers allowed. We'll produce pseudocode with decision, loops, etc.\n\nWe need to use arrows and structure. Provide each line with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取輸入字串 s // 取得要排序的原始字串  \n→ Step 2: 建立空字典 freq_map // 用於紀錄每個字元的出現次數  \n→ Step 3: 循環遍歷 s 的每個字元 c  \n  → Decision: 是否已存在於 freq_map? // 判斷字元是否已被記錄  \n   Yes → freq_map[c] ← freq_map[c] + 1 // 若已存在，次數加一  \n   No  → freq_map[c] ← 1 // 若不存在，初始化次數為一  \n→ Step 4: 將 freq_map 轉換為字元頻率對列表 freq_list = [(c, freq_map[c]) for each key c] // 方便排序  \n→ Step 5: 按頻率降序排序 freq_list // 最高頻率字元排在最前  \n  → Example: freq_list.sort(key=頻率, reverse=True)  \n→ Step 6: 建立空字串 result = \"\" // 儲存最終排序結果  \n→ Step 7: 遍歷 freq_list 中的每個 (c, freq)  \n  → result ← result + c repeated freq 次 // 將字元依頻率重複追加到結果  \n→ Step 8: 返回 result // 輸出排序後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def is_pal(self, s: str) -> bool:\n        \"\"\"Check if string s is a palindrome.\"\"\"\n        l, r = 0, len(s) - 1\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        return True\n\n    def palindromePairs(self, words):\n        # Map reversed word to its index for O(1) lookup\n        rev_to_index = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n        res_set = set()\n\n        # Handle the case when an empty string exists\n        empty_idx = rev_to_index.get(\"\")\n        if empty_idx is not None:\n            for i, w in enumerate(words):\n                if i != empty_idx and self.is_pal(w):\n                    pair1 = (i, empty_idx)\n                    pair2 = (empty_idx, i)\n                    if pair1 not in res_set:\n                        res.append([pair1[0], pair1[1]])\n                        res_set.add(pair1)\n                    if pair2 not in res_set:\n                        res.append([pair2[0], pair2[1]])\n                        res_set.add(pair2)\n\n        # For every word, split it into all possible (prefix, suffix) pairs\n        for i, w in enumerate(words):\n            length = len(w)\n            for j in range(length + 1):\n                prefix = w[:j]\n                suffix = w[j:]\n\n                # If prefix is palindrome, the reversed suffix must be a word\n                if self.is_pal(prefix):\n                    rev_suffix = suffix[::-1]\n                    jdx = rev_to_index.get(rev_suffix)\n                    if jdx is not None and jdx != i:\n                        pair = (jdx, i)\n                        if pair not in res_set:\n                            res.append([pair[0], pair[1]])\n                            res_set.add(pair)\n\n                # If suffix is palindrome and j != length (to avoid duplicates)\n                if j != length and self.is_pal(suffix):\n                    rev_prefix = prefix[::-1]\n                    jdx = rev_to_index.get(rev_prefix)\n                    if jdx is not None and jdx != i:\n                        pair = (i, jdx)\n                        if pair not in res_set:\n                            res.append([pair[0], pair[1]])\n                            res_set.add(pair)\n\n        return res\n\ndef parse_input(input_str: str):\n    \"\"\"Extract a Python list from the input string.\"\"\"\n    # Find the first '[' and the last ']' to isolate the list literal\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start >= end:\n        # Fallback: try to evaluate the entire string\n        return ast.literal_eval(input_str.strip())\n    list_str = input_str[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    try:\n        words = parse_input(data)\n    except Exception as e:\n        # If parsing fails, exit gracefully\n        sys.exit(1)\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanations for algorithm O(total length). Classic problem: palindrome pairs. Approach: Build a map of reversed words to index. For each word, check splits. Complexity linear. So produce pseudocode lines accordingly.\n\nWe must output each line with virtual code and comment. Use arrow lines.\n\nWe need to include Start, End. Use Decision. Provide steps.\n\nLet's craft steps:\n\nStart\n→ Build hashmap revToIndex: for each word, store reverse->index. // Preprocess reversed strings\n→ Initialize result list. // Store pairs\n→ For each word with index i:\n    → Compute len = word.length\n    → For each split position p from 0 to len: // p indicates prefix length\n        → prefix = word[0:p], suffix = word[p:len]\n        → If prefix is palindrome:\n            → revSuffix = reverse(suffix)\n            → If revSuffix in revToIndex and revToIndex[revSuffix] != i:\n                → Add pair (revToIndex[revSuffix], i) // reversed order\n        → If suffix is palindrome and p != len: // avoid duplicate\n            → revPrefix = reverse(prefix)\n            → If revPrefix in revToIndex and revPrefix[revIndex] != i:\n                → Add pair (i, revIndex) // current word first\n→ Return result\nEnd\n\nAlso need special case: empty string.\n\nWe might include that.\n\nAlso include decision for palindrome check.\n\nAdd function isPalindrome(s) using two pointers. But we can mention inline.\n\nBut pseudocode lines must be linear? We'll produce a simplified version.\n\nLet's produce step-by-step lines. Use arrows.\n\nWe must use virtual code lines and comments.\n\nWe need to be careful with indentation but it's just text.\n\nLet's write.\n\nWe can also break into substeps.\n\nWe must avoid actual code syntax.\n\nWe'll use \"→\" before each step.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildMap: For each word w with index i, store Reverse(w) → i in hashmap revToIndex // 建立「倒轉字串 → 原索引」的映射表  \n→ Init result ← empty list // 用於儲存所有符合條件的 (i, j) 對  \n→ Decision: 是否有空字串?  \n    Yes → Find emptyIndex ← revToIndex[\"\"] // 空字串的索引  \n        → For each word w with index i ≠ emptyIndex:  \n            → If w is palindrome:  \n                → Add (i, emptyIndex) to result // 以空字串結尾的回文  \n                → Add (emptyIndex, i) to result // 以空字串開頭的回文  \n    No → // 若沒有空字串，跳過此步  \n→ For each word w with index i:  \n    → Let len ← length of w  \n    → For split point p from 0 to len: // p 為前綴長度  \n        → prefix ← w[0:p]  \n        → suffix ← w[p:len]  \n        → Decision: prefix is palindrome?  \n            Yes → revSuffix ← Reverse(suffix)  \n                → Decision: revSuffix in revToIndex and revToIndex[revSuffix] ≠ i?  \n                    Yes → Add (revToIndex[revSuffix], i) to result // 將倒轉後的後綴放在前面  \n        → Decision: suffix is palindrome?  \n            Yes → If p ≠ len: // 避免重複把整個字串視為後綴  \n                → revPrefix ← Reverse(prefix)  \n                → Decision: revPrefix in revToIndex and revToIndex[revPrefix] ≠ i?  \n                    Yes → Add (i, revToIndex[revPrefix]) to result // 原字串在前  \n→ Return result // 回傳所有回文對  \nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int) -> list[int]:\n    \"\"\"\n    產生 1 ~ n 之字典序排列的所有整數。\n    時間複雜度：O(n)；額外空間：O(1)（不計結果清單）。\n    \"\"\"\n    res = []          # 用於儲存最終結果\n    cur = 1           # 目前正在處理的數字，起始為 1\n\n    while cur <= n:\n        res.append(cur)          # 把目前數字加入結果\n\n        if cur * 10 <= n:\n            # 如果還有更深層的數字可進一步乘 10\n            cur *= 10\n        else:\n            # 不能再往深層，需往右移動\n            # 當 cur 的最後一位是 9，或 cur+1 已超過 n 時\n            # 需要回到上一層，直到可以往右移動為止\n            while cur % 10 == 9 or cur + 1 > n:\n                cur //= 10\n            cur += 1               # 在同一層前進一位\n\n    return res\n\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取 n，計算並輸出字典序結果。\n    \"\"\"\n    data = sys.stdin.read()                    # 讀取所有輸入\n    match = re.search(r'-?\\d+', data)          # 找到第一個整數\n    if not match:\n        return\n    n = int(match.group())                     # 轉成整數\n    result = lexical_order(n)                  # 取得字典序列表\n    print(result)                              # 輸出結果\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that given integer n, returns all numbers in [1,n] sorted lexicographically, using O(n) time, O(1) extra space. That's classic lexicographic order problem: print numbers in lex order like \"1,10,100,...,2,20,3...\" can use DFS traversal or iterative approach like next lexicographic integer. We need to produce virtual code steps line by line with comments. Use Start, End, Decision, etc.\n\nWe should design algorithm: initialize current=1; loop while current<=n: output current; if current*10 <= n: current *=10; else: while current%10==9 or current+1 > n: current/=10; current+=1. That yields lex order. O(n) time, O(1) space. Provide virtual code steps.\n\nWe should produce each line with arrow etc. Let's structure: Start, Step 1: Read n. Step 2: current=1. Step 3: While current <= n: output current. Step 4: If current*10 <= n: current*=10; else: If current%10 != 9 and current+1 <= n: current += 1; else: current/=10; current+=1; Wait but algorithm typical: after output, if current*10 <= n: current*=10; else: while current%10==9 or current+1 > n: current/=10; current+=1. We can split decision into nested. Provide lines.\n\nNeed to keep O(1) space, no recursion. Provide explanation per line.\n\nOk produce steps.\n\nWe'll use arrow -> for each line.\n\nLet's produce.\n\nEdge: We need to output numbers maybe via print. Use \"Output current\" step.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得範圍上限  \n→ Step 2: current ← 1 // 設定目前處理的數字為 1  \n→ Decision: current ≤ n? // 是否還有數字需要輸出  \n    Yes → Step 3: 輸出 current // 依順序輸出目前數字  \n    Yes → Decision: current × 10 ≤ n? // 是否能往下層 10 倍擴展  \n        Yes → Step 4: current ← current × 10 // 進入下一層子節點  \n        No → Decision: current % 10 ≠ 9 且 current + 1 ≤ n? // 能否直接遞增至同層下一個數字？  \n            Yes → Step 5: current ← current + 1 // 在同層前進一位  \n            No → Step 6: current ← current / 10 // 回到上一層  \n            No → Step 7: current ← current + 1 // 在上一層前進一位  \n    Yes → Decision: current ≤ n? // 循環回到第一個決策點  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"\n        找出 DNA 字串中重複出現的 10 個字母長度子序列。\n        \"\"\"\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef extract_sequence(data: str) -> str:\n    \"\"\"\n    從輸入文字中提取 DNA 序列。\n    支援「s = '...'」或「s = \"...\"」的格式；若找不到，直接返回整個字串。\n    \"\"\"\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", data)\n    if match:\n        return match.group(1)\n    return data.strip()\n\ndef main():\n    # 讀取所有輸入\n    data = sys.stdin.read()\n    # 解析 DNA 序列\n    dna_seq = extract_sequence(data)\n    # 取得重複子序列\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(dna_seq)\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for finding all 10-letter-long substrings that occur more than once in a DNA sequence string s. Provide each line with arrow and comment.\n\nWe must not output actual code, just pseudocode steps. Use \"Start\", \"End\". Each line: virtual code step + space + // explanation.\n\nAlso we need to include decisions with Yes →, No →, etc.\n\nSo the pseudocode should read: Start → Step 1: Input string s // get DNA sequence. Then maybe Step 2: define set seen = empty, result = empty set. Then loop over i from 0 to len(s)-10 inclusive. For each substring = s[i:i+10]. Decision: If substring in seen? If yes → add to result if not already; else add to seen. After loop End. Output result.\n\nAlso handle case length <10: return empty.\n\nWe need to include decision branches.\n\nWe need to make sure to show step numbers? Not required but fine.\n\nWe need to include arrow direction.\n\nThe sample shows \"→ Step 1: 輸入使用者數字 // ...\" with no indentation for decision lines but indentation for nested arrows.\n\nLet's produce.\n\nLet's include:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 讀入 DNA 序列\n\nDecision: s 長度 < 10? // 檢查是否足夠長\n    Yes → Step 2: 回傳空集合 // 沒有 10 字母子序列\n    No  → Step 3: 建立 empty set seen // 用於記錄已見子序列\n        → Step 4: 建立 empty set result // 用於儲存重複子序列\n\n→ Step 5: 循環 i 取 0 到 len(s)-10 // 逐個滑動窗口\n    → Step 6: substring = s[i:i+10] // 取得 10 字母子序列\n    → Decision: substring 在 seen? // 判斷是否已出現\n        Yes → Decision: substring 已在 result? // 檢查是否已加入結果\n            Yes → Step 7: 跳過 // 已加入結果，繼續\n            No  → Step 8: 把 substring 加入 result // 新重複序列\n        No  → Step 9: 把 substring 加入 seen // 記錄首次出現\n\n→ Step 10: 回傳 result // 回傳所有重複 10 字母子序列\nEnd // 程式結束\n\nMake sure each line has arrow and explanation.\n\nAlso note that indentation lines start with \"→\" for decisions? In sample, decisions start with \"→ Decision: ...\" then nested arrows. So we follow.\n\nMake sure we include arrows before each line.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 讀入 DNA 序列  \n→ Decision: s 的長度 < 10? // 檢查序列是否足夠長  \n  Yes → Step 2: 回傳空集合 // 沒有 10 字母子序列  \n  No  → Step 3: 建立空集合 seen // 用於記錄已見子序列  \n   → Step 4: 建立空集合 result // 用於儲存重複子序列  \n→ Step 5: 循環 i 從 0 到 len(s)-10 // 逐個滑動窗口  \n  → Step 6: substring ← s[i:i+10] // 取得 10 字母子序列  \n  → Decision: substring 是否在 seen? // 判斷是否已出現  \n    Yes → Decision: substring 是否已在 result? // 檢查是否已加入結果  \n     Yes → Step 7: 跳過 // 已加入結果，直接繼續  \n     No  → Step 8: 把 substring 加入 result // 新重複序列  \n    No  → Step 9: 把 substring 加入 seen // 記錄首次出現  \n→ Step 10: 回傳 result // 回傳所有重複 10 字母子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Try to extract list after '=' if present\n    if '=' in data:\n        part = data.split('=', 1)[1].strip()\n    else:\n        part = data\n    try:\n        nums = ast.literal_eval(part)\n    except Exception:\n        # Fallback: try eval\n        nums = eval(part, {\"__builtins__\": None}, {})\n    solution = Solution()\n    result = solution.permute(nums)\n    # Output without spaces to match expected format\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanations. The problem: generate all permutations of an array of distinct integers. Typical backtracking algorithm. Provide virtual code step-by-step.\n\nWe need to ensure each line includes virtual code + space + // explanation. Use Start, End, Decision, arrow.\n\nWe need to be thorough but not too verbose. For each step, we produce virtual code lines. For example:\n\nStart // begin\n\n→ Step 1: 定義函式 permute(nums) // main function\n\n→ Step 2: 初始化 result = [] // 存儲結果\n\n→ Decision: nums 是否為空? // 檢查\n\n    Yes → Step 3: 返回 result // 空陣列直接返回\n\n    No  → Step 4: 定義 backtrack(startIndex) // 回溯函式\n\nAnd so on.\n\nWe need to list each line. Use arrow arrow.\n\nImportant: Each line must have format: \"虛擬碼步驟 // 解釋\". And using arrows → and Decision etc.\n\nThus produce sequential lines, indent decisions maybe.\n\nWe must ensure the virtual code is clear. Also we can use \"→ Step ...\" for normal steps. For recursion, we need to denote recursion.\n\nLet's design:\n\nStart\n\n→ Step 1: 定義函式 permute(nums) // 主入口函式\n\n→ Step 2: result ← [] // 儲存所有排列\n\n→ Decision: nums 为空? // 若沒有元素\n\n    Yes → Step 3: 返回 result // 空結果\n\n    No  → Step 4: 定義回溯函式 backtrack() // 用於生成排列\n\n→ Step 5: backtrack() // 開始回溯\n\n→ Step 6: 返回 result // 結果\n\n→ End\n\nDefine backtrack:\n\nWe need separate lines inside backtrack function. Since virtual code lines can be inside function.\n\nWe can indent under backtrack? But we need to maintain structure. Use \"→\" to denote new step inside function. We can include \"→\" again.\n\nThus:\n\n→ Step 4: 定義回溯函式 backtrack(startIndex)\n\n    → Step 4.1: Decision: startIndex 等于 nums 长度? // 检查是否完整排列\n\n        Yes → Step 4.2: result.add(nums) // 将当前排列添加到结果\n\n        No  → Step 4.3: for i 从 startIndex 到 nums.length - 1 // 遍历剩余元素\n\n            → Step 4.3.1: Swap nums[startIndex] 与 nums[i] // 交换当前与遍历元素\n\n            → Step 4.3.2: backtrack(startIndex + 1) // 递归生成后续排列\n\n            → Step 4.3.3: Swap nums[startIndex] 与 nums[i] // 交换回原位\n\nWe need to provide each line. Also maybe include \"End\" for backtrack? Not necessary; we can just finish the function definition.\n\nLet's produce.\n\nWe must keep each line distinct. For decision branches, we indent substeps.\n\nWe'll produce lines with the arrow at start of each line. For decisions, we write \"Decision: ...\". For yes/no branches, indent.\n\nImportant: The output format sample uses no numbering, but uses \"→\" at start. We'll follow.\n\nLet's produce.\n\nAlso we must use traditional Chinese for comments. Use // after space.\n\nOk. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 permute(nums) // 主入口，接受輸入陣列  \n→ Step 2: result ← [] // 用來儲存所有排列  \n→ Decision: nums 是否為空? // 檢查是否有元素  \n Yes → Step 3: 返回 result // 若無元素直接返回空結果  \n No  → Step 4: 定義回溯函式 backtrack(startIndex) // 建立遞迴生成排列的函式  \n  → Step 4.1: Decision: startIndex 等於 nums 的長度? // 完成一個排列？  \n   Yes → Step 4.2: result.add(copy_of(nums)) // 加入目前排列（複製以避免後續改變）  \n   No  → Step 4.3: for i 從 startIndex 到 nums.length - 1 // 遍歷剩餘位置  \n    → Step 4.3.1: Swap nums[startIndex] 與 nums[i] // 交換元素以構造新排列  \n    → Step 4.3.2: backtrack(startIndex + 1) // 進一步處理下一個位置  \n    → Step 4.3.3: Swap nums[startIndex] 與 nums[i] // 交換回原位，恢復原始狀態  \n→ Step 5: backtrack(0) // 從索引 0 開始回溯  \n→ Step 6: 返回 result // 回傳所有產生的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Array",
      "source_file": "Leetcode/leetcode189.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "actual_output_or_error": "輸入格式錯誤: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "actual_output_or_error": "輸入格式錯誤: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rotate(self, nums, k):\n        if not nums:\n            return\n        k %= len(nums)\n        # 使用切片重新賦值完成旋轉\n        nums[:] = nums[-k:] + nums[:-k]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析 'nums = [...] , k = ...' 的格式\n    try:\n        parts = data.split(',')\n        nums_part = parts[0].split('=', 1)[1].strip()\n        k_part = parts[1].split('=', 1)[1].strip()\n        nums = ast.literal_eval(nums_part)\n        k = int(k_part)\n    except Exception as e:\n        # 若解析失敗，直接退出\n        sys.exit(f\"輸入格式錯誤: {e}\")\n\n    sol = Solution()\n    sol.rotate(nums, k)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Provide algorithm: e.g., find effective k = k % n, reverse whole array, reverse first k, reverse rest.\n\nWe need to output line by line, with comments after space. Use arrows. Start End. Use Decision blocks.\n\nLet's produce.\n\nSteps:\n\nStart // 程式開始\n→ Step 1: Input array nums and integer k // 取得輸入\n→ Step 2: Compute n = length(nums) // 取得陣列長度\n→ Decision: 如果 n == 0? // 檢查空陣列\n    Yes → Step 3: End // 空陣列直接結束\n    No  → Step 4: k = k mod n // 計算有效步數\n→ Step 5: Reverse nums[0..n-1] // 反轉整個陣列\n→ Step 6: Reverse nums[0..k-1] // 反轉前 k 個元素\n→ Step 7: Reverse nums[k..n-1] // 反轉剩餘元素\n→ Step 8: Output nums // 顯示旋轉後的陣列\nEnd // 程式結束\n\nNeed to use arrow and indentation for decisions. Provide format exactly as requested.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array nums and integer k // 取得輸入  \n→ Step 2: Compute n = length(nums) // 取得陣列長度  \n→ Decision: 如果 n == 0? // 檢查空陣列  \n  Yes → Step 3: End // 空陣列直接結束  \n  No  → Step 4: k = k mod n // 計算有效步數  \n→ Step 5: Reverse nums[0..n-1] // 反轉整個陣列  \n→ Step 6: Reverse nums[0..k-1] // 反轉前 k 個元素  \n→ Step 7: Reverse nums[k..n-1] // 反轉剩餘元素  \n→ Step 8: Output nums // 顯示旋轉後的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpsz3v2t6a.py\", line 54, in <module>\n    words, maxWidth = parse_input(raw_input.strip())\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpsz3v2t6a.py\", line 46, in parse_input\n    words = ast.literal_eval(words_part.split('=', 1)[1].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"This\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp34inn2ps.py\", line 54, in <module>\n    words, maxWidth = parse_input(raw_input.strip())\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp34inn2ps.py\", line 46, in parse_input\n    words = ast.literal_eval(words_part.split('=', 1)[1].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"What\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxq9xm1gt.py\", line 54, in <module>\n    words, maxWidth = parse_input(raw_input.strip())\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxq9xm1gt.py\", line 46, in parse_input\n    words = ast.literal_eval(words_part.split('=', 1)[1].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"Science\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # Determine how many words fit in this line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(w) for w in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # Last line or single word: left-justify\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # Fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef parse_input(data):\n    \"\"\"\n    Parse input like:\n    words = [\"This\", \"is\", ...], maxWidth = 16\n    \"\"\"\n    parts = data.split(',')\n    words_part = parts[0].strip()\n    max_part = parts[1].strip()\n    words = ast.literal_eval(words_part.split('=', 1)[1].strip())\n    max_width = int(max_part.split('=', 1)[1].strip())\n    return words, max_width\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n    words, maxWidth = parse_input(raw_input.strip())\n    sol = Solution()\n    result = sol.fullJustify(words, maxWidth)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code line by line with explanation comments. Use arrow, Decision, etc. Provide steps for text justification algorithm. We'll produce Start, then loop through words, accumulate words for current line until cannot fit, then build line with spacing. Manage last line separately.\n\nLet's outline:\n\nStart\n→ Initialize i=0\n→ Initialize result list\nDecision: while i < len(words)\n    → Build current line words and total_len\n    → While i < len(words) and total_len + len(words[i]) + len(line_words) <= maxWidth\n        → Add words[i] to line_words, update total_len, i++\n    → If i == len(words): // last line\n        → Build left-justified line: join words with single space, pad end with spaces to maxWidth\n    → Else:\n        → num_spaces = maxWidth - total_len\n        → gaps = len(line_words) - 1\n        → If gaps == 0: // single word\n            → line = line_words[0] + spaces(num_spaces)\n        → Else:\n            → space_per_gap = num_spaces // gaps\n            → extra = num_spaces % gaps\n            → For each word except last:\n                → Add word + spaces(space_per_gap + (extra > 0 ? 1 : 0))\n                → Decrement extra\n            → Add last word\n    → Append line to result\nEnd\n→ Return result\n\nWe need to produce each step as a line with explanation. Use virtual arrows, decision blocks. Use indentation for decisions. Each line of virtual code must be like: \"Start // 程式開始執行\". Use arrow \"→\" for next step.\n\nLet's craft:\n\nStart // 程式開始執行\n→ i ← 0 // 指標定位於 words 的起始位置\n→ result ← [] // 儲存格式化後的每一行\nDecision: i < len(words) ? // 是否還有未處理的字詞\n    Yes → line_words ← [] // 暫存當前行的字詞\n        total_len ← 0 // 目前行字詞總長度\n        → While i < len(words) AND total_len + len(words[i]) + len(line_words) ≤ maxWidth\n            → line_words.append(words[i]) // 加入字詞\n            → total_len ← total_len + len(words[i]) // 更新字詞長度\n            → i ← i + 1 // 移動到下一個字詞\n        Decision: i == len(words) ? // 是否為最後一行\n            Yes → // 最後一行左對齊\n                → line ← ' '.join(line_words) // 用單空格連接字詞\n                → line ← line + ' ' * (maxWidth - len(line)) // 右側補空格\n            No  → // 不是最後一行，需完全對齊\n                → spaces_needed ← maxWidth - total_len // 需填充的空格數\n                → gaps ← len(line_words) - 1 // 連接字詞的空格槽數\n                Decision: gaps == 0 ?\n                    Yes → // 行內只有一個字詞\n                        → line ← line_words[0] + ' ' * spaces_needed\n                    No  → // 行內有多個字詞\n                        → space_per_gap ← spaces_needed // gaps // 每個槽至少填空格數\n                        → extra ← spaces_needed % gaps // 剩餘空格分配給左側槽\n                        → line ← ''\n                        → For idx in 0 to len(line_words)-2\n                            → line ← line + line_words[idx] // 加上字詞\n                            → add_spaces ← space_per_gap + (extra > 0 ? 1 : 0)\n                            → line ← line + ' ' * add_spaces // 加上空格\n                            → If extra > 0 : extra ← extra - 1 // 減少剩餘空格\n                        → line ← line + line_words[-1] // 加上最後一個字詞\n        → result.append(line) // 儲存已格式化的行\n    No → // i >= len(words)，所有字詞已處理\nEnd // 程式結束\n\nBut we need each line with arrow and comment after space. Must avoid multi-line for loop etc? We can still break each step line by line. Use indentation for decisions, but each line is a statement. For loop we can show as while loop in a line. For For idx in 0..len-2 we may need multiple lines. Let's do simple approach: Use While loop for building line too. But requirement: \"逐行地產生對應的虛擬碼\" Means each line should be a step, but we can break loops into multiple lines.\n\nLet's produce final output.\n\nEnsure each line ends with comment after space. Provide explanation.\n\nLet's craft final output exactly as requested.\n...done thinking.\n\nStart // 程式開始執行  \n→ i ← 0 // 文字指標從第一個字詞開始  \n→ result ← [] // 建立結果清單以儲存每行文字  \n\nDecision: i < len(words) ? // 是否還有未處理的字詞  \n    Yes → line_words ← [] // 暫存目前行的字詞集合  \n        total_len ← 0 // 目前行字詞總長度  \n        → While i < len(words) AND total_len + len(words[i]) + len(line_words) ≤ maxWidth  \n            → line_words.append(words[i]) // 加入當前字詞  \n            → total_len ← total_len + len(words[i]) // 更新總長度  \n            → i ← i + 1 // 移動到下一個字詞  \n\n    Decision: i == len(words) ? // 是否為最後一行  \n        Yes → // 最後一行左對齊  \n            → line ← ' '.join(line_words) // 用單空格連接字詞  \n            → line ← line + ' ' * (maxWidth - len(line)) // 右側補足空格到 maxWidth  \n\n        No → // 不是最後一行，需要完全對齊  \n            → spaces_needed ← maxWidth - total_len // 需填充的空格總數  \n            → gaps ← len(line_words) - 1 // 連接字詞的空格槽數  \n            Decision: gaps == 0 ? // 行內僅有一個字詞  \n                Yes → // 直接加空格補足  \n                    → line ← line_words[0] + ' ' * spaces_needed  \n                No  → // 行內有多個字詞  \n                    → space_per_gap ← spaces_needed // gaps // 每個槽至少空格數  \n                    → extra ← spaces_needed % gaps // 剩餘空格分配給左側槽  \n                    → line ← '' // 初始化行文字  \n                    → For idx in 0 to len(line_words)-2  \n                        → line ← line + line_words[idx] // 加上字詞  \n                        → add_spaces ← space_per_gap + (extra > 0 ? 1 : 0) // 本槽要加的空格  \n                        → line ← line + ' ' * add_spaces // 加上空格  \n                        → If extra > 0 : extra ← extra - 1 // 右側槽空格數減一  \n                    → line ← line + line_words[-1] // 加上最後一個字詞  \n\n    → result.append(line) // 將已格式化的行加入結果  \n\n    No → // i >= len(words)，所有字詞已處理  \nEnd // 程式結束執行"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare algorithm\n        slow = fast = nums[0]\n        # Phase 1: find intersection point\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # Phase 2: find entrance to the cycle (duplicate number)\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Parse input of the form: nums = [1,3,4,2,2]\n    if \"nums\" in data:\n        _, nums_part = data.split('=', 1)\n        nums_str = nums_part.strip()\n    else:\n        nums_str = data\n\n    nums = ast.literal_eval(nums_str)\n    solution = Solution()\n    duplicate = solution.findDuplicate(nums)\n    print(duplicate)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps: Use Floyd's Tortoise and Hare algorithm. Steps: start, define slow, fast pointers to nums[0] maybe index? Actually we treat array values as pointers. So first phase find intersection. Then second phase find entrance. Steps: Start. Step1: initialize slow = nums[0], fast = nums[nums[0]] // initial pointers. Step2: While slow != fast: slow = nums[slow]; fast = nums[nums[fast]]; // move pointers. Step3: After loop, intersection found. Step4: reset slow = nums[0]; // start from beginning. Step5: While slow != fast: slow = nums[slow]; fast = nums[fast]; // move one step each. Step6: Return slow (or fast) as duplicate. End. Use virtual code arrow syntax.\n\nLet's produce each line with explanation. Use Start, End. Use Decision? maybe not needed. But we can show loops. For loops use Decision: While condition? Eg Decision: 迴圈條件? Or use → Loop? Might use Decision: 如果? Let's keep simple.\n\nWe need no actual code, just virtual. Provide line by line.\n\nMake sure to include each step with arrow and explanation.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 將慢指標指向第一個元素的值\n→ Step 2: fast ← nums[nums[0]] // 將快指標指向由慢指標指向的值所指的元素\n→ Decision: slow ≠ fast? // 判斷兩指標是否相遇\n    Yes → Step 3: slow ← nums[slow] // 慢指標每次移動一步\n        No  → Step 4: fast ← nums[nums[fast]] // 快指標每次移動兩步\n        No  → Step 5: 迴圈結束 // 兩指標相遇\n→ Step 6: slow ← nums[0] // 將慢指標重新定位到陣列起始位置\n→ Decision: slow ≠ fast? // 再次判斷兩指標是否相遇\n    Yes → Step 7: slow ← nums[slow] // 同時移動一步\n        No  → Step 8: fast ← nums[fast] // 同時移動一步\n        No  → Step 9: 迴圈結束 // 兩指標再次相遇\n→ Step 10: return slow // 相遇位置即為重複數字\nEnd // 程式執行結束\n\nBut must use virtual arrow like \"Yes →\", \"No →\". The decision format uses indentation. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化慢指標\n→ Step 2: fast ← nums[nums[0]] // 初始化快指標\n→ Decision: slow ≠ fast? // 檢查指標是否已相遇\n    Yes → Step 3: slow ← nums[slow] // 慢指標前進一步\n        No  → Step 4: fast ← nums[nums[fast]] // 快指標前進兩步\n        No  → Step 5: 迴圈結束 // 相遇完成\n→ Step 6: slow ← nums[0] // 將慢指標重置為起點\n→ Decision: slow ≠ fast? // 檢查是否相遇\n    Yes → Step 7: slow ← nums[slow] // 同時前進一步\n        No  → Step 8: fast ← nums[fast] // 同時前進一步\n        No  → Step 9: 迴圈結束 // 找到重複數字位置\n→ Step 10: return slow // 返回重複數字\nEnd // 程式執行結束\n\nBut need correct indentation: For Decision we indent the Yes and No branches. Also after Yes branch we must have No branch? Actually typical representation: Decision: condition? // explanation\n    Yes → ...\n    No → ...\nBut we have while loop: We want to loop until equal. So we could express loop as Decision: slow ≠ fast? If Yes, do step 3 and 4; No exit. So we show: Decision: slow ≠ fast? // 是否相遇\n    Yes → Step 3: slow ← nums[slow] // ...\n        → Step 4: fast ← nums[nums[fast]] // ...\n        → Go back to Decision: slow ≠ fast? // loop\n    No → Step 5: // loop exit\n\nBut to keep simple, we can use repeated decision. Use arrow to show loop.\n\nBetter: Use loop arrow: ←? But guidelines only mention Decision: If. We'll implement as Decision loops.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化慢指標\n→ Step 2: fast ← nums[nums[0]] // 初始化快指標\n→ Decision: slow ≠ fast? // 檢查是否相遇\n    Yes → Step 3: slow ← nums[slow] // 慢指標前進一步\n        → Step 4: fast ← nums[nums[fast]] // 快指標前進兩步\n        → Decision: slow ≠ fast? // 重新檢查\n    No  → Step 5: // 相遇結束\n→ Step 6: slow ← nums[0] // 重置慢指標至起點\n→ Decision: slow ≠ fast? // 檢查第二次相遇\n    Yes → Step 7: slow ← nums[slow] // 同時前進一步\n        → Step 8: fast ← nums[fast] // 同時前進一步\n        → Decision: slow ≠ fast? // 重新檢查\n    No  → Step 9: // 相遇結束\n→ Step 10: return slow // 重複數字為慢指標指向的位置\nEnd // 程式執行結束\n\nMake sure each line has \"→\" and explanation. Use proper indentation for branches.\n\nAlso we can use \"Yes →\" and \"No →\" as per instructions. Use \"Yes →\" and \"No →\".\n\nAlso ensure lines like \"→ Step 3: ...\" not \"→ Step 3\" but \"→ Step 3:\". Provided.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指標為陣列第一個元素的值  \n→ Step 2: fast ← nums[nums[0]] // 初始化快指標為慢指標所指元素的值  \n→ Decision: slow ≠ fast? // 判斷兩指標是否相遇  \n Yes → Step 3: slow ← nums[slow] // 慢指標每次前進一步  \n  → Step 4: fast ← nums[nums[fast]] // 快指標每次前進兩步  \n  → Decision: slow ≠ fast? // 重新檢查相遇條件  \n No  → Step 5: // 兩指標已相遇，結束第一段搜尋  \n→ Step 6: slow ← nums[0] // 將慢指標重置為陣列起始位置  \n→ Decision: slow ≠ fast? // 判斷第二次相遇位置  \n Yes → Step 7: slow ← nums[slow] // 慢指標每次前進一步  \n  → Step 8: fast ← nums[fast] // 快指標每次前進一步  \n  → Decision: slow ≠ fast? // 重新檢查相遇條件  \n No  → Step 9: // 兩指標再次相遇，找到重複數字  \n→ Step 10: return slow // 回傳相遇位置即為重複的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,1]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        if not self.idx_map[val]:\n            return False\n        remove_idx = self.idx_map[val].pop()\n        last_val = self.data[-1]\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.data)\n\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Wrap the input so it becomes a valid JSON array of two elements\n    if not raw.startswith('['):\n        raw = '[' + raw + ']'\n    try:\n        commands, args_list = json.loads(raw)\n    except Exception:\n        # Fallback to eval if json parsing fails (unlikely for given format)\n        commands, args_list = eval(raw)\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)\n        elif cmd == \"insert\":\n            res = obj.insert(args[0])\n            results.append(res)\n        elif cmd == \"remove\":\n            res = obj.remove(args[0])\n            results.append(res)\n        elif cmd == \"getRandom\":\n            res = obj.getRandom()\n            results.append(res)\n\n    # Format output like LeetCode: null, true, false, numbers\n    formatted = []\n    for r in results:\n        if r is None:\n            formatted.append(\"null\")\n        elif isinstance(r, bool):\n            formatted.append(\"true\" if r else \"false\")\n        else:\n            formatted.append(str(r))\n    print(f\"[{', '.join(formatted)}]\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for RandomizedCollection class with insert, remove, getRandom. Should be O(1) average. Use vector list of values and map from value to set of indices. Pseudocode.\n\nWe should list steps line by line. Use Start, End, Decision etc. Provide explanation comments. Should be in Traditional Chinese. Let's produce.\n\nProbably show initialization, insert: add to list, record index in map set, return false if existed? Actually returns true if new, false otherwise. So check map existence. Insert always adds element; if first time, return true else false. Implementation: if map contains key: add index to set; return false else add set with index; return true.\n\nRemove: if value not present, return false. Else get an arbitrary index from set. Remove index from set. Remove from list: swap with last element, update its index in map set, pop back. Return true.\n\ngetRandom: return random element from list.\n\nWe must produce each line of pseudocode with arrow, etc.\n\nLet's produce steps: Start RandomizedCollection class. Provide initialization. Provide methods.\n\nWe need to use arrows: \"→ Step 1: ...\" etc. Indentation for decisions.\n\nLet's produce.\n\nRemember each line should be separate line. Provide explanation after //.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 RandomizedCollection 物件 // 建立空的向量和映射結構\n    → 建立 Vector<Value> values // 儲存所有元素，允許重複\n    → 建立 Map<Value, Set<Integer>> indices // 每個值對應其在 values 中的索引集合\n→ End // 初始化結束\n\n→ Function: insert(val) // 插入元素\n    → Decision: 是否已存在 val? // 判斷 val 是否已在映射中\n        Yes → Step 2: 取得 indices[val] 集合 // 若已存在，直接取得其索引集合\n            → Step 3: 將 values 的長度作為新索引 idx // 新元素插入的位置\n            → Step 4: values.append(val) // 加入值到 vector\n            → Step 5: indices[val].add(idx) // 在索引集合中加入新位置\n            → Step 6: Return false // 已存在，返回 false\n        No  → Step 7: 建立 indices[val] 為新集合 // 若不存在，建立索引集合\n            → Step 8: 將 values 的長度作為新索引 idx\n            → Step 9: values.append(val)\n            → Step 10: indices[val].add(idx)\n            → Step 11: Return true // 第一次插入，返回 true\n→ End // insert 結束\n\n→ Function: remove(val) // 刪除元素\n    → Decision: indices 中是否含有 val? // 判斷 val 是否存在\n        No  → Step 12: Return false // 不存在，返回 false\n        Yes → Step 13: 取 indices[val] 的任一索引 removeIdx // 任意一個索引\n            → Step 14: 取 values 的最後一個索引 lastIdx\n            → Decision: removeIdx == lastIdx? // 若移除位置即為最後一個\n                Yes → Step 15: values.pop() // 直接移除最後一個\n                No  → Step 16: 取 lastVal = values[lastIdx] // 取得最後一個值\n                    → Step 17: values[removeIdx] = lastVal // 用最後一個值覆蓋要刪除的位置\n                    → Step 18: values.pop() // 移除最後一個\n                    → Step 19: 更新 indices[lastVal]：從 lastIdx 移除，加入 removeIdx // 更新索引位置\n            → Step 20: indices[val].remove(removeIdx) // 從索引集合移除已刪除位置\n            → Decision: indices[val] 是否為空? // 檢查是否還剩下該值\n                Yes → Step 21: 刪除 indices[val] // 若空集合，從映射中刪除該鍵\n                No  → (無操作) // 若仍有剩餘，保持映射\n            → Step 22: Return true // 刪除成功，返回 true\n→ End // remove 結束\n\n→ Function: getRandom() // 隨機取得元素\n    → Step 23: 生成隨機索引 r 介於 0 與 values.size()-1\n    → Step 24: Return values[r] // 返回隨機選中的值\n→ End // getRandom 結束\n\nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # max-heap for lower half (store negatives)\n        self.small = []\n        # min-heap for upper half\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # push into max-heap\n        heapq.heappush(self.small, -num)\n        # maintain order property: largest in small <= smallest in large\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # balance sizes so that the size difference is at most 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # The input is two JSON arrays separated by a comma, wrap them into a single array for parsing\n    commands_and_args = json.loads('[' + data + ']')\n    commands, args_list = commands_and_args[0], commands_and_args[1]\n\n    result = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"MedianFinder\":\n            obj = MedianFinder()\n            result.append(None)\n        elif cmd == \"addNum\":\n            obj.addNum(args[0])\n            result.append(None)\n        elif cmd == \"findMedian\":\n            median = obj.findMedian()\n            result.append(median)\n        else:\n            # unknown command; skip\n            result.append(None)\n\n    # Convert None to null in JSON output\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing MedianFinder with methods addNum and findMedian. Use virtual code with arrows and decisions. We need to explain each line.\n\nWe need to think about typical approach: use two heaps: max-heap for lower half, min-heap for upper half. Balance sizes.\n\nVirtual code: Start, init data structures, etc. Use operations.\n\nWe must use each line \"虛擬碼步驟 // 解釋\". Use arrows. Use Decision. Provide step by step algorithm.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize maxHeap and minHeap // 兩個堆，最大堆存左半，最小堆存右半\n→ Step 2: Define addNum(num) // 方法：加入數字\n    → Decision: maxHeap is empty OR num <= maxHeap.peek()?\n        Yes → Insert num into maxHeap // 小於等於左半最大值放左堆\n        No  → Insert num into minHeap // 大於右半最小值放右堆\n    → Decision: size(maxHeap) > size(minHeap) + 1?\n        Yes → Move maxHeap.peek() to minHeap // 左堆過大，移動一個到右堆\n        No  → Decision: size(minHeap) > size(maxHeap) + 1?\n            Yes → Move minHeap.peek() to maxHeap // 右堆過大，移動一個到左堆\n            No  → // 堆已平衡\n→ Step 3: Define findMedian() // 方法：求中位數\n    → Decision: size(maxHeap) == size(minHeap)?\n        Yes → Return (maxHeap.peek() + minHeap.peek()) / 2.0 // 兩堆相等，平均\n        No  → Decision: size(maxHeap) > size(minHeap)?\n            Yes → Return maxHeap.peek() // 左堆多，取其最大\n            No  → Return minHeap.peek() // 右堆多，取其最小\nEnd\n\nNeed to add the constructor: Start // 初始化MedianFinder\n\nSo:\n\nStart // 程式開始執行\n→ Step 1: MedianFinder() initializes maxHeap and minHeap // 建立兩個堆\n→ Step 2: addNum(num) // 進行插入\n...\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Use arrow. Use Decision with Yes→, No→.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: MedianFinder() initializes maxHeap and minHeap // 建立兩個堆，maxHeap 為最大堆（左半），minHeap 為最小堆（右半）\n→ Step 2: addNum(num) // 定義加入數字的操作\n    → Decision: maxHeap is empty OR num <= maxHeap.peek()?\n        Yes → Insert num into maxHeap // 小於等於左半最大值，放入左堆\n        No  → Insert num into minHeap // 大於左堆最大值，放入右堆\n    → Decision: size(maxHeap) > size(minHeap) + 1?\n        Yes → Move maxHeap.peek() to minHeap // 左堆過大，移動一個到右堆\n        No  → Decision: size(minHeap) > size(maxHeap) + 1?\n            Yes → Move minHeap.peek() to maxHeap // 右堆過大，移動一個到左堆\n            No  → // 堆已平衡，無需移動\n→ Step 3: findMedian() // 定義求中位數的操作\n    → Decision: size(maxHeap) == size(minHeap)?\n        Yes → Return (maxHeap.peek() + minHeap.peek()) / 2.0 // 兩堆相等，取平均值\n        No  → Decision: size(maxHeap) > size(minHeap)?\n            Yes → Return maxHeap.peek() // 左堆多，取左堆最大值\n            No  → Return minHeap.peek() // 右堆多，取右堆最小值\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmp33vqwm.py\", line 59, in <module>\n    result = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmp33vqwm.py\", line 14, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxhaj9ul_.py\", line 59, in <module>\n    result = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxhaj9ul_.py\", line 14, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        Insert a new interval into a sorted, non-overlapping list of intervals\n        and merge if necessary.\n        \"\"\"\n        result = []\n        i, n = 0, len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all intervals that overlap with the new interval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Add the merged interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse input like:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    or multiline:\n        intervals = [[1,3],[6,9]]\n        newInterval = [2,5]\n    Returns a tuple (intervals, newInterval).\n    \"\"\"\n    # Normalize whitespace\n    text = re.sub(r'\\s+', ' ', text.strip())\n    # Find the position of 'newInterval'\n    idx = text.find('newInterval')\n    if idx == -1:\n        raise ValueError(\"Input must contain 'newInterval'\")\n    intervals_part = text[:idx].replace('intervals', '').replace('=', '').strip()\n    new_part = text[idx:].replace('newInterval', '').replace('=', '').strip()\n    intervals = eval(intervals_part) if intervals_part else []\n    new_interval = eval(new_part) if new_part else []\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    intervals, new_interval = parse_input(raw_input)\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code step by step with explanations. We need to solve inserting interval into sorted non-overlapping intervals. Outline: iterate through intervals, add those ending before new start; then merge overlapping ones; then add the rest. Use pseudo-steps. Provide start, decisions, etc.\n\nBe careful to follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrow for flow: \"→ Step ...\". Use \"Decision:\" lines with Yes →, No →.\n\nWe'll produce lines: Start, initialize result, iterate i=0..len-1, decisions.\n\nLet's craft:\n\nStart\n→ Step 1: result = empty list // 初始化輸出結果\n→ Step 2: i = 0 // 索引指向 intervals\n→ Decision: i < len(intervals) ? // 是否還有區間待處理\n    Yes → Decision: intervals[i].end < newInterval.start ? // 此區間結束在新區間開始之前\n        Yes → Step 3: Append intervals[i] to result // 將不重疊的區間加入結果\n        No  → Decision: intervals[i].start > newInterval.end ? // 此區間開始在新區間結束之後\n            Yes → Step 4: Append newInterval to result // 新區間先加入\n            No  → Step 5: newInterval.start = min(newInterval.start, intervals[i].start) // 合併區間開始\n                      → Step 6: newInterval.end = max(newInterval.end, intervals[i].end) // 合併區間結束\n    No → Step 7: Append newInterval to result // 所有舊區間已處理完畢，直接加入剩餘新區間\nEnd\n\nBut we also need to handle while loop increments. Use steps: after each block, increment i accordingly. Provide \"→ Step 8: i += 1\" inside loop, maybe after processing each interval. But easier: Use a for loop approach: iterate through each old interval, decisions, then after loop, check if newInterval not yet added.\n\nWe can restructure: \nStep 1: result = []\nStep 2: for each interval in intervals:\n   Decision: interval.end < new.start? etc.\n\nAt the end, if newInterval not appended, append.\n\nLet's produce final code.\n\nNeed to include arrow for each step and decision.\n\nAlso include End at last.\n\nEnsure we don't produce actual code.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← [] // 初始化輸出結果陣列  \n→ Step 2: newAdded ← False // 旗標表示新區間是否已加入結果  \n→ Step 3: for each interval in intervals // 遍歷所有已排序且不重疊的區間  \n  → Decision: interval.end < newInterval.start? // 此區間完全在新區間之前  \n    Yes → Step 4: append interval to result // 不重疊，直接加入  \n    No  → Decision: interval.start > newInterval.end? // 此區間完全在新區間之後  \n      Yes → Step 5: if not newAdded then append newInterval to result // 若尚未加入新區間，先加入  \n         → Step 6: append interval to result // 再將此區間加入  \n         → Step 7: newAdded ← True // 標記新區間已加入  \n         → Step 8: break // 跳出迴圈，後續區間全部直接加入結果  \n          No → Step 9: newInterval.start ← min(newInterval.start, interval.start) // 合併開始點  \n           → Step 10: newInterval.end ← max(newInterval.end, interval.end) // 合併結束點  \n           → Step 11: // 不進行任何加入操作，繼續檢查下一個區間  \n→ Decision: not newAdded? // 新區間是否還未加入結果  \n  Yes → Step 12: append newInterval to result // 將剩餘的新區間加入  \n  No  → // 已加入，無需再處理  \n→ Step 13: for remaining interval in intervals after break // 將剩餘未檢查的區間直接加入  \n  → Step 14: append interval to result // 直接加入結果  \nEnd // 程式執行結束，回傳 result\n\n---  \n\n此虛擬碼演示了在已排序且不重疊的區間集合中插入新區間並合併重疊區間的完整流程，符合題目要求。"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        將相同字母組成的字串分群，返回群組列表。\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)          # 建立字典，key 為排序後的元組，value 為對應字串列表\n        for s in strs:                        # 逐一處理每個字串\n            key = tuple(sorted(s))            # 把字串排序後轉成不可變元組作為 key\n            anagrams[key].append(s)           # 將原字串加入對應群組\n        return list(anagrams.values())        # 取出所有群組，轉成列表回傳\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析輸入格式，呼叫 groupAnagrams，並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()          # 讀取整個輸入\n    if not data:\n        return\n\n    # 若輸入包含等號，取等號右側為列表字串\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n    else:\n        rhs = data\n\n    rhs = rhs.strip()\n    # 使用安全的 literal_eval 解析列表，若失敗則回退 eval\n    try:\n        strs = ast.literal_eval(rhs)\n    except Exception:\n        strs = eval(rhs)\n\n    # 呼叫解法\n    sol = Solution()\n    result = sol.groupAnagrams(strs)\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, no actual code. For grouping anagrams: iterate strings, use sorted string as key, map to list. Output groups. Provide start, decision? Not much decision but we need virtual flow. We'll present steps: Start, Step 1: initialize map, Step 2: for each string, compute key, add to map, Step 3: collect values, Step 4: return result, End.\n\nWe need arrows: Start → Step 1: ... etc. Use virtual arrow. Use Decision maybe for check map contains key. Provide Yes → / No →? Could incorporate decision: If key exists? Yes add else create new list. That adds a decision structure.\n\nOk. Provide lines:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的字典 map 以儲存排序後的字串作為 key → map[string][]string // 建立空字典\n→ Step 2: 迭代輸入陣列 strs 的每個字串 s // 逐一處理\n    → Step 2.1: 將 s 的字元排序得到 key // 產生鍵\n    → Decision: map 是否已有 key? // 檢查是否已存在鍵\n        Yes → Step 2.2a: 將 s 加入 map[key] 列表 // 已有鍵，追加\n        No  → Step 2.2b: 建立新列表 [s] 並設置 map[key] // 沒有鍵，創建新列表\n→ Step 3: 建立一個結果列表 result 來收集所有的 anagram 群組 // 準備結果\n→ Decision: map 是否為空? // 檢查是否有任何 anagram\n    Yes → Step 3a: result = [] // 仍空\n    No  → Step 3b: 將 map 中所有值（list）依次加入 result // 收集所有群組\n→ Step 4: 回傳 result // 返回答案\nEnd // 程式執行結束\n\nWe should make each line a separate line. Ensure each line ends with comment. Let's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的字典 map 以儲存排序後的字串作為 key // map: string -> []string  \n→ Step 2: 迭代輸入陣列 strs 的每個字串 s // 逐一處理  \n  → Step 2.1: 將 s 的字元排序得到 key // 產生鍵  \n  → Decision: map 是否已有 key? // 檢查是否已存在鍵  \n    Yes → Step 2.2a: 將 s 加入 map[key] 列表 // 已有鍵，追加  \n    No  → Step 2.2b: 建立新列表 [s] 並設置 map[key] // 沒有鍵，創建新列表  \n→ Step 3: 建立一個結果列表 result 來收集所有的 anagram 群組 // 準備結果  \n→ Decision: map 是否為空? // 檢查是否有任何 anagram  \n   Yes → Step 3a: result = [] // 仍空  \n   No  → Step 3b: 將 map 中所有值（list）依次加入 result // 收集所有群組  \n→ Step 4: 回傳 result // 返回答案  \nEnd // 程式執行結束"
    },
    {
      "title": "K^th Smallest Element in a Sorted Matrix",
      "source_file": "Leetcode/leetcode378.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4vq0nyui.py\", line 39, in <module>\n    result = solution.kthSmallest(matrix, k)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4vq0nyui.py\", line 14, in kthSmallest\n    val, r, c = heapq.heappop(heap)\n                ^^^^^^^^^^^^^^^^^^^\nIndexError: index out of range"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-5'\nGot (Norm):      '[-5]'\n--- (Raw) ---\nRaw Expected: '-5'\nRaw Got:      '[-5]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        # 建立最小堆，初始時每一行的第一個元素\n        heap = [(matrix[i][0], i, 0) for i in range(n)]\n        heapq.heapify(heap)\n\n        # 提取 k-1 次最小元素，最後一次彈出的即為第 k 個最小值\n        for _ in range(k - 1):\n            val, r, c = heapq.heappop(heap)\n            if c + 1 < n:\n                heapq.heappush(heap, (matrix[r][c + 1], r, c + 1))\n        return heapq.heappop(heap)[0]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並處理可能存在的空白或換行\n    raw_input = sys.stdin.read().strip()\n\n    # 期望格式: \"matrix = [[...]], k = ...\"\n    if not raw_input:\n        sys.exit(0)\n\n    # 分離 matrix 和 k\n    try:\n        matrix_part, k_part = raw_input.split('k =')\n        matrix_str = matrix_part.replace('matrix =', '').strip()\n        k_str = k_part.strip()\n        matrix = ast.literal_eval(matrix_str)\n        k = int(k_str)\n    except Exception as e:\n        # 若解析失敗，則直接退出\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.kthSmallest(matrix, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for solving the k-th smallest element in an n x n sorted matrix, with memory better than O(n^2). Classic solution: binary search on value space with count of <= mid using row binary search or two pointers. Complexity O(n log(max-min)). Another approach: min-heap of size n, but memory O(n). That is better than O(n^2). Provide virtual code with steps, using Decision, Start, End, arrows. Provide line by line pseudo-code.\n\nWe need to produce each line with virtual code step followed by // explanation.\n\nLet's produce algorithm:\n\nStart\n\n→ Step 1: Set low = matrix[0][0], high = matrix[n-1][n-1] // boundaries\n\n→ Decision: While low < high? // binary search loop\n\n   → Step 2: mid = low + (high - low)/2 // mid value\n\n   → Step 3: count = 0 // counter for elements <= mid\n\n   → Step 4: For each row i from 0 to n-1:\n\n         → Step 4.1: Use binary search to find number of elements <= mid in row i // count per row\n\n         → Step 4.2: Add to count\n\n   → Decision: If count < k? // too few elements\n\n         Yes → low = mid + 1 // adjust low\n\n         No  → high = mid // adjust high\n\n→ Step 5: Return low // low is k-th smallest\n\nEnd\n\nBut we also need memory better than O(n^2). We'll use O(n) or O(1). Count per row uses binary search O(log n) each. So overall O(n log n log(max-min)). Use binary search per row; we can also use two pointers to count O(n). But for simplicity we can use binary search per row.\n\nAlso maybe provide alternative min-heap method:\n\nBut keep it simple.\n\nWe must produce each step line by line, with arrow and decision indentation.\n\nWe need to produce lines exactly in required format. Use 'Start', 'End', 'Decision:', 'Yes →', 'No →', '→'.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: low ← matrix[0][0] // 設定搜尋區間下界\n→ Step 2: high ← matrix[n-1][n-1] // 設定搜尋區間上界\n→ Decision: low < high? // 是否還有搜尋空間\n    Yes →\n        → Step 3: mid ← low + (high - low) / 2 // 取區間中值\n        → Step 4: count ← 0 // 初始化小於等於 mid 的元素個數\n        → Step 5: For i from 0 to n-1 do // 遍歷每一行\n            → Step 5.1: pos ← BinarySearchUpperBound(matrix[i], mid) // 找到第一個 > mid 的位置\n            → Step 5.2: count ← count + pos // 累加該行小於等於 mid 的個數\n        → Decision: count < k? // 小於 k，則 k 號元素更大\n            Yes →\n                → Step 6: low ← mid + 1 // 將下界移至 mid+1\n            No  →\n                → Step 7: high ← mid // 將上界移至 mid\n    No  →\n        → Step 8: Return low // low 即為第 k 個最小的元素\nEnd // 程式結束\n\nBut we need to ensure indentation and arrow formatting.\n\nThe arrow style: \"→\" then step number. For decisions, \"Decision:\" line, then indentation with \"Yes →\" etc. Use consistent spacing.\n\nAlso we need to note that each line should contain the virtual code step followed by a space then comment. So after the code we have ' // explanation'.\n\nFor decisions, we still follow that format: 'Decision: ... // comment'.\n\nMake sure to keep lines separate.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← matrix[0][0] // 設定搜尋區間下界  \n→ Step 2: high ← matrix[n-1][n-1] // 設定搜尋區間上界  \n→ Decision: low < high? // 仍有搜尋空間  \n    Yes →  \n        → Step 3: mid ← low + (high - low) / 2 // 取區間中值  \n        → Step 4: count ← 0 // 初始化小於等於 mid 的元素個數  \n        → Step 5: For i ← 0 to n-1 do // 遍歷每一行  \n            → Step 5.1: pos ← BinarySearchUpperBound(matrix[i], mid) // 找到第一個 > mid 的位置  \n            → Step 5.2: count ← count + pos // 累加該行小於等於 mid 的個數  \n        → Decision: count < k? // 小於 k，則 k 號元素更大  \n            Yes →  \n                → Step 6: low ← mid + 1 // 將下界移至 mid+1  \n            No  →  \n                → Step 7: high ← mid // 將上界移至 mid  \n    No  →  \n        → Step 8: Return low // low 即為第 k 個最小的元素  \nEnd // 程式結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[4,9]'\nGot (Norm):      '[9,4]'\n--- (Raw) ---\nRaw Expected: '[4,9]'\nRaw Got:      '[9, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"Return the intersection of two integer lists with multiplicities.\"\"\"\n        freq = {}\n        # Count occurrences in nums1\n        for num in nums1:\n            freq[num] = freq.get(num, 0) + 1\n\n        result = []\n        # For each element in nums2, if it exists in freq, add to result\n        for num in nums2:\n            if freq.get(num, 0) > 0:\n                result.append(num)\n                freq[num] -= 1\n        return result\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read()\n    # Extract list literals like [1,2,3]\n    lists = re.findall(r'\\[.*?\\]', data)\n    nums1 = ast.literal_eval(lists[0]) if lists else []\n    nums2 = ast.literal_eval(lists[1]) if len(lists) > 1 else []\n\n    sol = Solution()\n    ans = sol.intersect(nums1, nums2)\n    # Print result in Python list format\n    print(ans)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Let's think algorithm: Use hash map to count frequencies of nums1, then iterate nums2, if count>0 add to result and decrement. This yields intersection.\n\nNeed to output step by step virtual code, with arrows, Start, End, decisions. Each line: virtual step + // explanation. Must not output actual code. Must use virtual arrows. Let's craft.\n\nLine1: Start // program begins\nLine2: → Step 1: Initialize empty map freq // map counts for nums1\nLine3: → Step 2: Initialize empty list result // store intersection\nLine4: → Decision: 迭代 nums1? // iterate over nums1\n    Yes → Step 3: For each num in nums1, increment freq[num] // count occurrences\n    No → ... (maybe break when finished)\nBut virtual code: we can just have lines with decisions.\n\nSimplify: Step 1: Iterate nums1 and populate freq.\n\nBut to maintain step by step:\n\nLine: → Decision: 是否有 nums1 元素? // check if still elements\n    Yes → Step: Add to freq\n    No → move to next step\n\nBut we may not need to detail loops explicitly; just high-level.\n\nBetter: Use steps: Step 1: Count nums1 frequencies.\n\nStep 2: Iterate nums2, for each element, if freq > 0, add to result, decrement.\n\nFinally: Return result.\n\nWe can incorporate decision for each element.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 建立空哈希表 freq // 用於存儲 nums1 每個元素的計數\n→ Step 2: 建立空列表 result // 用於儲存交集\n→ Decision: nums1 是否非空? // 檢查 nums1 是否有元素\n    Yes → Step 3: 遍歷 nums1，每個 num: freq[num] += 1 // 計算出現次數\n    No → Step 3: 跳過 // 若 nums1 為空，直接跳過\n→ Decision: nums2 是否非空? // 檢查 nums2 是否有元素\n    Yes → Step 4: 遍歷 nums2，每個 num: 如果 freq[num] > 0 then\n        → Step 4.1: result.append(num) // 加入交集\n        → Step 4.2: freq[num] -= 1 // 減少計數\n    No → Step 4: 跳過 // 若 nums2 為空，直接跳過\n→ Step 5: 回傳 result // 返回交集結果\nEnd // 程式結束\n\nBut need to keep format: each line virtual code step + // explanation. Use arrow arrows.\n\nLet's write each line:\n\nStart // 程式開始執行\n\n→ Step 1: 建立空哈希表 freq // 用於存儲 nums1 每個元素的計數\n\n→ Step 2: 建立空列表 result // 用於儲存交集\n\n→ Decision: nums1 是否非空? // 檢查 nums1 是否有元素\n\n    Yes → Step 3: 遍歷 nums1，對每個 num 執行 freq[num] += 1 // 計算 nums1 中每個數字出現的次數\n\n    No  → Step 3: 跳過 // 若 nums1 為空，直接跳過此步驟\n\n→ Decision: nums2 是否非空? // 檢查 nums2 是否有元素\n\n    Yes → Step 4: 遍歷 nums2，對每個 num 執行\n\n        Yes → Step 4.1: 如果 freq[num] > 0 then\n\n            → Step 4.1.1: result.append(num) // 將公共元素加入結果\n\n            → Step 4.1.2: freq[num] -= 1 // 減少對應計數\n\n        No  → Step 4.1: 跳過 // 若 freq[num] 為 0，則不加入\n\n    No  → Step 4: 跳過 // 若 nums2 為空，直接跳過此步驟\n\n→ Step 5: 回傳 result // 將交集結果返回\n\nEnd // 程式執行結束\n\nBut need to ensure each line is a single line. We have multiline within decision, we can indent but each line must be separate line.\n\nSo each line: \"→ Decision: ...\". Then inside decisions we need to show Yes → Step. The example shows nested decisions inside indentation. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空哈希表 freq // 用於存儲 nums1 每個元素的計數\n→ Step 2: 建立空列表 result // 用於儲存交集\n→ Decision: nums1 是否非空? // 檢查 nums1 是否有元素\n    Yes → Step 3: 遍歷 nums1，對每個 num 執行 freq[num] += 1 // 計算 nums1 中每個數字出現的次數\n    No  → Step 3: 跳過 // 若 nums1 為空，直接跳過此步驟\n→ Decision: nums2 是否非空? // 檢查 nums2 是否有元素\n    Yes → Step 4: 遍歷 nums2，對每個 num 執行\n        Yes → Decision: freq[num] > 0? // 判斷該數字在 nums1 中是否仍有剩餘\n            Yes → Step 4.1: result.append(num) // 將公共元素加入結果\n            Yes → Step 4.2: freq[num] -= 1 // 減少對應計數\n            No  → Step 4.3: 跳過 // 若 freq[num] 為 0，則不加入\n    No  → Step 4: 跳過 // 若 nums2 為空，直接跳過此步驟\n→ Step 5: 回傳 result // 將交集結果返回\nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[4]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[4]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[6,10]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[6, 10]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[2,9,2]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[2, 9, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport re\n\ndef rand7() -> int:\n    \"\"\"隨機產生 1~7 的整數，使用 Python 內建 random 模組。\"\"\"\n    return random.randint(1, 7)\n\ndef rand10() -> int:\n    \"\"\"\n    透過兩次 rand7() 產生 1~49 的均勻分布，並用拒絕抽樣得到 1~10 的均勻整數。\n    \"\"\"\n    while True:\n        a = rand7()\n        b = rand7()\n        num = (a - 1) * 7 + b          # 1~49\n        if num <= 40:                  # 只接受 1~40\n            return 1 + (num - 1) % 10  # 映射到 1~10\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin 的輸入，解析其中的整數 n，產生 n 個 rand10() 的結果並列印。\n    \"\"\"\n    content = sys.stdin.read().strip()\n    if not content:\n        return\n    # 取得字串中的第一個整數，例如 'n = 3' 會得到 3\n    match = re.search(r'\\d+', content)\n    if not match:\n        print([])\n        return\n    n = int(match.group())\n    results = [rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for rand10 using rand7, presumably using rejection sampling. Approach: Use two calls to rand7 to generate 49 outcomes (1-49). Accept 1-40, map to 1-10 using mod 10. Reject 41-49 and repeat. That works.\n\nWe output each step line-by-line.\n\nWe need to use virtual code arrows and decisions. Provide explanations in Chinese. Use \"Start\", \"End\". Each line: \"Step description // explanation\".\n\nWe need to include arrow lines for decision. Use Yes →, No →.\n\nLet's design steps:\n\nStart\n→ Step 1: repeat\n   → Step 2: a = rand7()\n   → Step 3: b = rand7()\n   → Step 4: index = (a-1)*7 + b // convert to 1-49\n   → Decision: index <= 40?\n        Yes → Step 5: result = ((index-1) mod 10) + 1 // map to 1-10\n             → Step 6: return result\n        No  → Step 7: repeat // go back to Step 1\nEnd\n\nNeed to show loops. Use \"repeat\" or \"while true\". Use arrow lines.\n\nOk produce. Ensure each line has virtual code and explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: repeat // 進入重複迴圈，直到產生有效的 rand10 值\n   → Step 2: a ← rand7() // 呼叫 rand7 取得第一個隨機數（1~7）\n   → Step 3: b ← rand7() // 呼叫 rand7 取得第二個隨機數（1~7）\n   → Step 4: index ← (a - 1) * 7 + b // 組合兩個數得到 1~49 的索引\n   → Decision: index ≤ 40? // 檢查索引是否在可接受範圍內\n        Yes → Step 5: result ← ((index - 1) mod 10) + 1 // 將 1~40 映射到 1~10\n            → Step 6: return result // 返回 rand10 的結果\n        No  → Step 7: repeat // 索引 > 40，重複循環\nEnd // 程式執行結束"
    },
    {
      "title": "Search Insert Position",
      "source_file": "Leetcode/leetcode35.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_khxw5hw.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp_khxw5hw.py\", line 28, in parse_input\n    target_expr = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9710bwxm.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp9710bwxm.py\", line 28, in parse_input\n    target_expr = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpy0580tfb.py\", line 37, in <module>\n    nums, target = parse_input(raw_input)\n                   ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpy0580tfb.py\", line 28, in parse_input\n    target_expr = parts[1].split('=')[1].strip()\n                  ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        Binary search that returns the index of target if found,\n        otherwise returns the insertion index to keep nums sorted.\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse a line like 'nums = [1,3,5,6], target = 5' into a list and an int.\n    \"\"\"\n    # Remove any newline characters and collapse spaces\n    data = data.replace('\\n', ' ').strip()\n    parts = data.split(',')\n    # Extract the expression after '=' for each part\n    nums_expr = parts[0].split('=')[1].strip()\n    target_expr = parts[1].split('=')[1].strip()\n    nums = ast.literal_eval(nums_expr)\n    target = int(target_expr)\n    return nums, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit()\n    nums, target = parse_input(raw_input)\n    result = Solution().searchInsert(nums, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for binary search algorithm that returns insertion index. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrow and decision etc. Must be line by line. Start, End, Decision lines, etc.\n\nWe need to incorporate binary search algorithm:\n\nStart\n→ Step 1: Initialize low = 0 // left pointer\n→ Step 2: Initialize high = length-1 // right pointer\n→ Decision: While low <= high? // loop condition\n    Yes →\n        → Step 3: mid = low + (high - low)/2 // middle index\n        → Step 4: Compare arr[mid] with target\n            Decision: if arr[mid] == target? // found\n                Yes → Step 5: return mid // found index\n                No →\n                    Decision: if arr[mid] < target? // target is larger\n                        Yes → Step 6: low = mid + 1 // search right half\n                        No  → Step 7: high = mid - 1 // search left half\n    No → Step 8: return low // insertion index\n\nEnd\n\nWe must ensure virtual code lines each with comment. Use arrow \"→\" before each step, except Start and End maybe. Use \"Decision:\" lines. For nested decisions indent maybe with tabs? Example given uses indentation with spaces. Use 4 spaces indent maybe. Use Yes → and No →.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: low = 0 // 設定左指標\n→ Step 2: high = array.length - 1 // 設定右指標\n→ Decision: low <= high? // 檢查是否還有搜尋區間\n    Yes →\n        → Step 3: mid = low + (high - low) / 2 // 計算中間索引\n        → Step 4: Compare array[mid] 與 target\n            Decision: array[mid] == target? // 是否找到目標\n                Yes → Step 5: return mid // 找到回傳索引\n                No →\n                    Decision: array[mid] < target? // 目標在右側\n                        Yes → Step 6: low = mid + 1 // 調整左指標\n                        No  → Step 7: high = mid - 1 // 調整右指標\n    No → Step 8: return low // 回傳插入位置\nEnd // 程式執行結束\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Provide line by line.\n\nAlso include step numbering maybe. Provide each line separately.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0 // 設定左指標  \n→ Step 2: high = array.length - 1 // 設定右指標  \n→ Decision: low <= high? // 檢查是否還有搜尋區間  \n Yes →  \n  → Step 3: mid = low + (high - low) / 2 // 計算中間索引  \n  → Step 4: Compare array[mid] 與 target // 進行比較  \n   Decision: array[mid] == target? // 是否找到目標  \n    Yes → Step 5: return mid // 找到即回傳索引  \n    No →  \n     Decision: array[mid] < target? // 目標在右側  \n      Yes → Step 6: low = mid + 1 // 調整左指標  \n      No  → Step 7: high = mid - 1 // 調整右指標  \n No → Step 8: return low // 循環結束，回傳插入位置  \nEnd // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp0n2swpwf.py\", line 64, in <module>\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp0n2swpwf.py\", line 31, in calcEquation\n    union(a, b, v)\n  File \"/tmp/tmp0n2swpwf.py\", line 17, in union\n    if x not in parent:\n       ^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjwiftutk.py\", line 64, in <module>\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjwiftutk.py\", line 30, in calcEquation\n    for (a, b), v in zip(equations, values):\n        ^^^^^^\nValueError: too many values to unpack (expected 2)"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3nnndc4p.py\", line 64, in <module>\n    ans = sol.calcEquation(equations, values, queries)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3nnndc4p.py\", line 30, in calcEquation\n    for (a, b), v in zip(equations, values):\n        ^^^^^^\nValueError: not enough values to unpack (expected 2, got 1)"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        parent = {}\n        weight = {}\n\n        def find(x):\n            if parent[x] != x:\n                root, w = find(parent[x])\n                parent[x] = root\n                weight[x] *= w\n            return parent[x], weight[x]\n\n        def union(x, y, ratio):\n            if x not in parent:\n                parent[x] = x\n                weight[x] = 1.0\n            if y not in parent:\n                parent[y] = y\n                weight[y] = 1.0\n            rx, wx = find(x)\n            ry, wy = find(y)\n            if rx == ry:\n                return\n            parent[rx] = ry\n            weight[rx] = ratio * wy / wx\n\n        for (a, b), v in zip(equations, values):\n            union(a, b, v)\n\n        res = []\n        for a, b in queries:\n            if a not in parent or b not in parent:\n                res.append(-1.0)\n                continue\n            ra, wa = find(a)\n            rb, wb = find(b)\n            if ra != rb:\n                res.append(-1.0)\n            else:\n                res.append(wa / wb)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入\n    parts = data.split('values =')\n    eq_part = parts[0].replace('equations =', '').strip()\n    rest = parts[1]\n    values_part, queries_part = rest.split('queries =', 1)\n    values_part = values_part.strip()\n    queries_part = queries_part.strip()\n\n    equations = ast.literal_eval(eq_part)\n    values = ast.literal_eval(values_part)\n    queries = ast.literal_eval(queries_part)\n\n    sol = Solution()\n    ans = sol.calcEquation(equations, values, queries)\n\n    output = '[' + ','.join(f'{x:.5f}' for x in ans) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving equations with division queries. Use union-find with weight. Steps: Build graph, union with ratio. For each query, find root and weight difference. Return -1 if no path. Provide each line with explanation. Ensure start, decision, yes no, etc.\n\nWe need to produce in Traditional Chinese. Virtual code lines: Start, steps.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Build adjacency list and parent map\n\n→ For each equation: union variables with ratio\n\n→ Function find(x): path compression, returns root and product of ratios\n\n→ For each query: check if both variables exist; if not return -1\n\n→ Use find to get roots; if roots differ return -1\n\n→ Else compute ratio as weightX/weightY\n\n→ End.\n\nWe must use arrow notation and decision statements for missing variable or root mismatch.\n\nLet's produce line-by-line.\n\nAlso we need to include decisions: \"如果變數不存在?\" etc.\n\nWill produce about 15 lines.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立父層映射 parent 及權重映射 weight // 每個變數的父節點與相對於父節點的比例\n→ Step 2: 建立並查集初始結構，將所有變數設為自我父節點，權重為 1.0 // 每個變數單獨為一個集合\n→ Decision: 是否有方程式? // 判斷是否需要進行聯結\n    Yes → Step 3: 對於每個方程式 (Ai, Bi, val)： // 逐一處理給定的等式\n        → Step 3a: Union(Ai, Bi, val) // 將 Ai 與 Bi 聯結，並存儲比例\n→ Function: Union(x, y, ratio) // 合併兩個集合並設置比例\n    → Step 4: 找到 x 的根 rootX 與累積比例 weightX // 使用 find 取得根及權重\n    → Step 5: 找到 y 的根 rootY 與累積比例 weightY\n    → Decision: 若 rootX 與 rootY 不同? // 若兩者屬於不同集合\n        Yes → Step 6: 設定 parent[rootX] = rootY // 以 rootY 為新父節點\n        → Step 7: 設定 weight[rootX] = ratio * weightY / weightX // 調整權重以維持比例\n→ Function: Find(x) → (root, weightToRoot) // 透過路徑壓縮找到根並回傳相對權重\n    → Step 8: 若 parent[x] != x: // 若不是根節點\n        → Step 8a: (rootParent, weightParent) = Find(parent[x]) // 先遞迴尋根\n        → Step 8b: parent[x] = rootParent // 路徑壓縮\n        → Step 8c: weight[x] *= weightParent // 更新權重\n    → Step 9: 回傳 (parent[x], weight[x]) // 返回最終根及其權重\n→ Step 10: 針對每個查詢 (C, D)： // 開始處理輸入的查詢\n    → Decision: 若 C 或 D 未在 parent 中? // 檢查變數是否已定義\n        Yes → Step 11: 結果陣列加入 -1.0 // 未定義變數無法計算\n        No → Step 12: (rootC, weightC) = Find(C) // 找到 C 的根與權重\n        → Step 13: (rootD, weightD) = Find(D) // 找到 D 的根與權重\n        → Decision: 若 rootC != rootD? // 根不相同代表不可比\n            Yes → Step 14: 結果陣列加入 -1.0\n            No  → Step 15: 結果陣列加入 weightC / weightD // 取得比值\n→ End // 程式執行結束並返回所有查詢答案\n\n這樣的虛擬碼展示了使用並查集（帶權重）來解決變數除法問題的整個流程。"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp94_dcmx.py\", line 57, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp94_dcmx.py\", line 45, in parse_input\n    prerequisites = ast.literal_eval(prereq_str)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgh2lmikz.py\", line 57, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpgh2lmikz.py\", line 45, in parse_input\n    prerequisites = ast.literal_eval(prereq_str)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,0]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"Parse input string of the form\n    'numCourses = 2, prerequisites = [[1,0]]'\n    \"\"\"\n    # Find numCourses\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n    if not num_match:\n        raise ValueError(\"numCourses not found in input\")\n    numCourses = int(num_match.group(1))\n\n    # Find prerequisites list\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not pre_match:\n        raise ValueError(\"prerequisites not found in input\")\n    prereq_str = pre_match.group(1)\n\n    # Safely evaluate the list\n    prerequisites = ast.literal_eval(prereq_str)\n    if not isinstance(prerequisites, list):\n        prerequisites = []\n\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    numCourses, prerequisites = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for topological sorting (Kahn's algorithm or DFS). Provide step by step. Output each line with virtual code plus explanation. Use arrows. Should include Start, End, Decision.\n\nLet's produce algorithm:\n\nStart\n→ Build adjacency list and indegree array // create graph\n→ Initialize queue with zero indegree nodes // start nodes\n→ While queue not empty // process nodes\n    → Pop node\n    → Append to result\n    → For each neighbor\n        → Decrease indegree\n        → If indegree becomes zero, enqueue neighbor\n→ If result length equals numCourses // all courses scheduled\n    Yes → Return result // success\n    No  → Return empty array // impossible\n\nAlso we need decision after while? Actually after while loop, we check. Also need to check if queue empty prematurely? That will be handled by indegree condition.\n\nAdd comment lines.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Use arrow signs. Provide step by step.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化圖形結構：為每門課建立鄰接清單與入度計數器 // 準備資料結構\n→ Step 2: 遍歷 prerequisites，填充鄰接清單並遞增相應課程的入度 // 記錄前置關係\n→ Step 3: 建立佇列，將所有入度為 0 的課程加入佇列 // 從無前置課程的課開始\n→ Decision: 佇列是否非空? // 判斷是否有可處理的課程\n    Yes → Step 4: 從佇列取出一門課，加入結果序列 // 選取下一個可上課程\n    → Step 5: 遍歷此課程的後續課程\n        → Step 6: 將後續課程的入度減 1 // 完成一個前置課程\n        → Decision: 入度是否變為 0? // 判斷是否已無剩餘前置課程\n            Yes → Step 7: 將該後續課程加入佇列 // 可供進一步處理\n            No  → // 仍有其他前置課程，暫不加入佇列\n    → 回到 Decision：佇列是否非空? // 仍有可處理課程，重複循環\n    No  → // 佇列已空，結束循環\n→ Decision: 結果序列長度是否等於 numCourses? // 判斷是否成功完成所有課程\n    Yes → Step 8: 返回結果序列 // 有效的課程順序\n    No  → Step 9: 返回空陣列 // 無法完成所有課程\nEnd // 程式執行結束\n\nMake sure each line uses \"→\" arrow properly. Also include indentation for nested. Use same style as example.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化圖形結構：為每門課建立鄰接清單與入度計數器 // 準備資料結構  \n→ Step 2: 遍歷 prerequisites，填充鄰接清單並遞增相應課程的入度 // 記錄前置關係  \n→ Step 3: 建立佇列，將所有入度為 0 的課程加入佇列 // 從無前置課程的課開始  \n→ Decision: 佇列是否非空? // 判斷是否有可處理的課程  \n  Yes → Step 4: 從佇列取出一門課，加入結果序列 // 選取下一個可上課程  \n   → Step 5: 遍歷此課程的後續課程  \n    → Step 6: 將後續課程的入度減 1 // 完成一個前置課程  \n    → Decision: 入度是否變為 0? // 判斷是否已無剩餘前置課程  \n     Yes → Step 7: 將該後續課程加入佇列 // 可供進一步處理  \n     No  → // 仍有其他前置課程，暫不加入佇列  \n   → 回到 Decision：佇列是否非空? // 仍有可處理課程，重複循環  \n    Yes → // 繼續 Step 4~Step 7  \n    No  → // 佇列已空，結束循環  \n→ Decision: 結果序列長度是否等於 numCourses? // 判斷是否成功完成所有課程  \n  Yes → Step 8: 返回結果序列 // 有效的課程順序  \n  No  → Step 9: 返回空陣列 // 無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS: find shortest distance to each word and record parents\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            parents[new_word].append(word)\n                            queue.append(new_word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        if endWord not in parents:\n            return []\n\n        res = []\n\n        def dfs(word, path):\n            if word == beginWord:\n                res.append(path[::-1])  # reverse to get start->end order\n                return\n            for prev in parents[word]:\n                dfs(prev, path + [prev])\n\n        dfs(endWord, [endWord])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit(0)\n    # Convert input string into a dictionary\n    # Example input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    try:\n        # Surround with braces to create a dict literal\n        parsed = eval('{' + data + '}')\n    except Exception:\n        print(\"[]\")\n        sys.exit(0)\n\n    beginWord = parsed.get('beginWord', '')\n    endWord = parsed.get('endWord', '')\n    wordList = parsed.get('wordList', [])\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    # Use json.dumps to ensure double quotes as in examples\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nThe user wants a virtual code for finding all shortest transformation sequences in word ladder problem. They want pseudo-code step by step with explanations. Must not output actual code. Use Start, End, Decision, arrows. Must be line-by-line. Provide steps: build adjacency, BFS to find levels, then DFS or backtracking to build paths. Should cover early exit if endWord not in list. Use queue. Mark visited with level. Then build graph of edges from level to next level. Then DFS to get all paths. Provide explanation after each line.\n\nLet's write in Chinese. Use proper arrows. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll need variable names like wordListSet, queue, level, graph, etc. Provide generic pseudo-code.\n\nMake sure to include decision points. Provide enough detail.\n\nLet's produce about maybe 30 lines. Use indentation as indicated by arrows: \"→ Step: ...\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 如果 endWord 不在 wordList 集合中，返回空列表 // 若終點不在字典，無法完成轉換\n\n→ Step 2: 初始化 wordSet 為 wordList 集合 // 為了 O(1) 查詢字典中的單詞\n\n→ Step 3: 建立一個空的圖 graph，鍵為單詞，值為相鄰單詞集合 // 用於儲存合法轉換關係\n\n→ Step 4: 初始化 queue 為一個雙端佇列，加入 beginWord // BFS 的起點\n\n→ Step 5: 建立 visitedMap，將 beginWord 的層級設為 0 // 記錄每個單詞首次被訪問的層級\n\n→ Decision: 若 beginWord 也在 wordSet，從 wordSet 刪除它 // 避免自己成為下一步\n\n→ Step 6: 開始 BFS 循環，直到 queue 為空 // 逐層搜尋所有可達單詞\n\n    → Step 7: 從 queue 取出前一個 word // 取出當前處理的單詞\n\n    → Step 8: 取得 currentLevel = visitedMap[word] // 取得當前單詞的層級\n\n    → Step 9: 產生 word 的所有可能單字變化 candidateList // 逐字改一個字母\n\n    → Decision: 若 candidate 在 wordSet 且未被訪問過\n        Yes → Step 10: 若 candidate 未在 graph[word] 中，加入 graph[word] 和 graph[candidate] // 建立雙向邊\n        Yes → Step 11: 設置 visitedMap[candidate] = currentLevel + 1 // 記錄層級\n        Yes → Step 12: 將 candidate 加入 queue // 下一層處理\n\n    → Decision: 若 candidate 在 visitedMap 且 visitedMap[candidate] == currentLevel + 1\n        Yes → Step 13: 在 graph[word] 和 graph[candidate] 中加入彼此 // 同層級連結，允許多條路徑\n\n    → Decision: 若 candidate 在 visitedMap 且層級 < currentLevel + 1\n        No → // 忽略，已經更短路徑找到\n\n→ Step 14: BFS 結束後，若 endWord 未在 visitedMap，返回空列表 // 無法到達終點\n\n→ Step 15: 初始化 result 為空列表 // 用於存儲所有最短路徑\n\n→ Step 16: 定義遞迴函式 DFS(currentWord, path) // 從 beginWord 開始深度優先搜尋所有路徑\n\n    → Decision: 若 currentWord == endWord\n        Yes → Step 17: 將 path 的拷貝加入 result // 找到一條完整最短路徑\n        No → // 繼續搜尋\n\n    → Step 18: 取得 nextWords = graph[currentWord] // 所有合法下一步\n\n    → Decision: 若 nextWords 為空\n        No → // 回溯\n\n    → Decision: 若 nextWords 不為空\n        Yes → For each nextWord in nextWords\n            → Step 19: 若 visitedMap[nextWord] == visitedMap[currentWord] + 1 // 僅沿著最短層級\n                Yes → Step 20: path.append(nextWord) // 加入下一步\n                Yes → Step 21: DFS(nextWord, path) // 進一步搜尋\n                Yes → Step 22: path.pop() // 回溯到上一層\n\n→ Step 23: 調用 DFS(beginWord, [beginWord]) // 開始深度優先搜尋\n\n→ Step 24: 返回 result // 所有最短轉換序列\n\nEnd // 程式執行結束"
    },
    {
      "title": "Super Washing Machines",
      "source_file": "Leetcode/leetcode517.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    \"\"\"解題類別：計算洗衣機平衡所需的最小步數。\"\"\"\n    def findMinMoves(self, machines):\n        total = sum(machines)          # 所有衣服的總數\n        n = len(machines)              # 洗衣機數量\n        if total % n != 0:             # 若總數不能被 n 整除，無法平均\n            return -1\n\n        avg = total // n               # 每台機器應該有的衣服數\n        res = 0                        # 目前需要的最大步數\n        cum_diff = 0                   # 前綴子集的盈餘（正值表示多餘，負值表示不足）\n\n        for load in machines:\n            cum_diff += load - avg     # 更新前綴子集的盈餘\n            # 步數至少要能處理當前盈餘的絕對值，或是正向傳送的需要\n            res = max(res, abs(cum_diff), cum_diff)\n\n        return res\n\ndef main():\n    \"\"\"主程序：從標準輸入讀取洗衣機資料，計算並輸出結果。\"\"\"\n    # 讀取全部輸入並去除首尾空白\n    data = sys.stdin.read().strip()\n    if not data:\n        return  # 若無輸入則直接結束\n\n    # 解析輸入為 Python 列表（安全方式）\n    machines = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.findMinMoves(machines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps. Problem known as \"Super Washing Machines\" from LeetCode. Approach: compute average, check if possible, then iterate to find max of max(load, total_load) where load is cumulative difference. Steps: compute total sum; if not divisible by n, return -1. Compute target average = sum/n. Then iterate over machines, maintain prefix sum, at each i compute diff = prefix_sum - target*(i+1). Maintain max moves as max of abs(diff), diff (since moves = max(abs(diff), diff?) Actually formula: answer = max(answer, abs(diff), diff) but diff could be negative; answer = max(answer, abs(diff)). However typical solution: answer = max(answer, abs(diff), diff). diff may be positive meaning extra to send right; negative meaning need to receive. The number of moves needed at that point is max(abs(diff), diff) because diff can be positive or negative; but if diff negative, abs(diff) >= diff? Actually diff negative, abs(diff) > diff. So we can use max(answer, abs(diff)). But known solution: answer = max(answer, abs(diff)). But also need to consider current machine load? Wait formula: max_moves = max(max_moves, abs(diff), diff). Where diff is cumulative surplus. That's the known solution. So implement accordingly.\n\nWe need virtual code steps. Provide line by line with explanation.\n\nEdge: if sum% n !=0 -> return -1.\n\nLet's produce steps: Start, compute n, sum, if sum % n !=0 return -1, target = sum/n, initialize answer=0, diff=0, iterate i from 0 to n-1: diff += machines[i] - target, answer = max(answer, abs(diff), diff). At end, return answer. End.\n\nWe produce virtual code with arrows and decision. Provide explanations. Ensure no real code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 計算機器數量 n = machines.length // 取得洗衣機的總數\n→ Step 2: 計算所有衣服總數 total = sum(machines) // 累加所有衣服數量\n→ Decision: 若 total % n != 0? // 檢查衣服數是否能平均分配\n    Yes → Step 3: 回傳 -1 // 無法平均，直接結束\n    No  → Step 4: 計算目標平均 target = total / n // 每台機器應有的衣服數\n→ Step 5: 初始化 answer = 0 // 目前需要的最大步數\n→ Step 6: 初始化 diff = 0 // 目前前綴子集的衣服盈餘\n→ Step 7: 從左到右遍歷每台機器 i = 0 … n-1\n    → SubStep: diff += machines[i] - target // 更新到 i 為止的總盈餘\n    → SubStep: answer = max(answer, abs(diff), diff) // 取當前步數與前綴盈餘的最大值\n→ Step 8: 回傳 answer // 所有機器平均後所需的最小步數\nEnd // 程式執行結束"
    },
    {
      "title": "Non-overlapping Intervals",
      "source_file": "Leetcode/leetcode435.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpnqlyamay.py\", line 27, in main\n    data = ast.literal_eval(data_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    intervals = [[1,2],[2,3],[3,4],[1,3]]\n              ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpnqlyamay.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmpnqlyamay.py\", line 29, in main\n    data = eval(data_str)  # 允許更寬鬆的 eval，若輸入格式正確可行\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    intervals = [[1,2],[2,3],[3,4],[1,3]]\n              ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpetaj5y_c.py\", line 27, in main\n    data = ast.literal_eval(data_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    intervals = [[1,2],[1,2],[1,2]]\n              ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpetaj5y_c.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmpetaj5y_c.py\", line 29, in main\n    data = eval(data_str)  # 允許更寬鬆的 eval，若輸入格式正確可行\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    intervals = [[1,2],[1,2],[1,2]]\n              ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqu37ysh4.py\", line 27, in main\n    data = ast.literal_eval(data_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    intervals = [[1,2],[2,3]]\n              ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpqu37ysh4.py\", line 35, in <module>\n    main()\n  File \"/tmp/tmpqu37ysh4.py\", line 29, in main\n    data = eval(data_str)  # 允許更寬鬆的 eval，若輸入格式正確可行\n           ^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    intervals = [[1,2],[2,3]]\n              ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        以結束時間排序後，用貪心演算法挑選最大不重疊區間數，\n        最後回傳需移除的最小區間數：total - chosen\n        \"\"\"\n        if not intervals:\n            return 0\n        intervals.sort(key=lambda x: x[1])   # 依結束時間升序\n        end = intervals[0][1]               # 最後已選區間的結束點\n        count = 1                           # 已選擇的非重疊區間數\n        for s, e in intervals[1:]:\n            if s >= end:                    # 與已選區間不重疊\n                end = e\n                count += 1\n        return len(intervals) - count        # 需要移除的區間數\n\ndef main():\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n    # 使用 ast.literal_eval 解析輸入，確保安全\n    try:\n        data = ast.literal_eval(data_str)\n    except Exception:\n        data = eval(data_str)  # 允許更寬鬆的 eval，若輸入格式正確可行\n    intervals = data.get('intervals', [])\n    solution = Solution()\n    print(solution.eraseOverlapIntervals(intervals))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem is to remove minimum number of intervals to make the rest non-overlapping. Classic problem: given intervals, find maximum number of non-overlapping intervals, then answer = n - max_non_overlap. Approach: sort by end ascending, then greedily pick intervals whose start >= last_end. Count selected. Then answer is total - selected.\n\nWe need to output step-by-step virtual code with comments. Each line must include the virtual code step and explanation. Use Start, End, Decision. Use arrow. We need to reflect sorting, loop, comparison. Let's produce about maybe 15 lines.\n\nAlso need to mention \"virtual code\" not actual code. So we will describe steps.\n\nWe must obey format: each line \"虛擬碼步驟 // 解釋\". Use Start, End. Use Decision with Yes →, No →.\n\nLet's craft:\n\nStart // 開始程式\n\n→ Step 1: Read input array intervals // 取得所有區間\n\n→ Step 2: Let n = length of intervals // 計算區間總數\n\n→ Decision: If n <= 1? // 檢查是否只有 0 或 1 個區間\n    Yes → Step 3: Return 0 // 無需移除任何區間\n    No  → Continue\n\n→ Step 4: Sort intervals by end ascending // 先按結束時間排序，方便貪心選擇\n\n→ Step 5: Initialize count = 0 // 計數已選擇的非重疊區間\n\n→ Step 6: Initialize last_end = -∞ // 追蹤上一次選擇區間的結束點\n\n→ Step 7: For each interval [s, e] in sorted intervals // 逐一檢查每個區間\n    → Decision: If s >= last_end? // 判斷此區間是否與已選區間不重疊\n        Yes → Step 8: count = count + 1 // 包含此區間\n                → Step 9: last_end = e // 更新最後結束點\n        No  → Step 10: Continue // 跳過此區間\n\n→ Step 11: Compute result = n - count // 移除的最小區間數\n\n→ Step 12: Return result // 回傳答案\n\nEnd // 程式結束\n\nWe need to output each line accordingly. Ensure each line includes explanation comment after //.\n\nAlso ensure arrow formatting: For loops, we can describe: \"→ For each interval [s, e] in sorted intervals // 逐一檢查\". Then inside, decision.\n\nLet's format as per example. Use \"→ Step X:\".\n\nMake sure to include arrow for decision branches.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 intervals 陣列 // 取得所有區間  \n→ Step 2: 讓 n = intervals 的長度 // 計算區間總數  \n→ Decision: 若 n <= 1? // 檢查是否只有 0 或 1 個區間  \n  Yes → Step 3: 回傳 0 // 無需移除任何區間  \n  No  → 繼續執行  \n→ Step 4: 將 intervals 按結束時間 e 升序排序 // 方便貪心選擇  \n→ Step 5: 初始化 count = 0 // 計算已選擇的非重疊區間數  \n→ Step 6: 初始化 last_end = -∞ // 追蹤最後選擇區間的結束點  \n→ Step 7: 對於每個區間 [s, e] 在已排序的 intervals 中 // 逐一檢查  \n  Decision: 若 s >= last_end? // 判斷此區間是否不與已選區間重疊  \n   Yes → Step 8: count = count + 1 // 包含此區間  \n    → Step 9: last_end = e // 更新最後結束點  \n   No  → Step 10: 繼續 // 跳過此區間  \n→ Step 11: 計算 result = n - count // 需要移除的最小區間數  \n→ Step 12: 回傳 result // 結束並輸出答案  \nEnd // 程式執行結束"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef single_number(nums):\n    \"\"\"\n    找出只出現一次的數字。\n    其他數字均出現三次。\n    使用兩個 32 位整數來追蹤每一位出現一次與兩次的狀態，\n    只需常數額外空間且線性時間。\n    \"\"\"\n    ones, twos = 0, 0\n    for num in nums:\n        # 更新兩次出現的位\n        twos = (twos ^ num) & ~ones\n        # 更新一次出現的位\n        ones = (ones ^ num) & ~twos\n    return ones\n\ndef main():\n    \"\"\"\n    讀取輸入、處理並輸出結果。\n    輸入範例：nums = [2,2,3,2]\n    輸出範例：3\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入包含「nums =」則去除前半部分\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = data\n\n    # 安全解析 Python 字面量得到 list\n    nums = ast.literal_eval(rhs)\n\n    result = single_number(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve: find element that appears once while others appear three times, linear time, constant space. Classic bit manipulation: use counters for each bit. Implementation: use 32-bit counters represented by three variables (ones, twos, threes?) Actually typical solution uses two variables: ones and twos. For each num: twos |= ones & num; ones ^= num; mask = ~(ones & twos); ones &= mask; twos &= mask. At end ones holds single number.\n\nWe need to output virtual code lines with explanations. Use \"Start\", \"End\", \"Decision:\" etc. We need to produce step-by-step pseudo code.\n\nWe'll produce:\n\nStart\n→ Step 1: 初始化 ones = 0, twos = 0 // 用來記錄一次出現和兩次出現的位\n→ Step 2: 針對 nums 中每個數字 num 循環 // 主循環\n    → Step 3: twos ← twos OR (ones AND num) // 將已出現一次且現在再次出現的位加到 twos\n    → Step 4: ones ← ones XOR num // 更新 ones\n    → Step 5: mask ← NOT (ones AND twos) // 清除同時出現三次的位\n    → Step 6: ones ← ones AND mask // 移除三次出現的位\n    → Step 7: twos ← twos AND mask // 同上\n→ Step 8: 返回 ones // ones 中剩餘的就是唯一出現一次的數字\nEnd\n\nBut they require decision steps? We can skip decisions if not needed. But maybe add a decision after mask? Actually not necessary.\n\nAlso we might want to show \"For each num in nums:\" but maybe we show as a loop: \"→ Decision: 是否還有元素?\" but not necessary. They didn't require loops but can show with a \"Step 2: For each num in nums\". That is fine.\n\nBut we must follow format: each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use \"Start\" and \"End\".\n\nWe should not output actual code but pseudo. Use \"Step\" labels.\n\nAlso include decisions? Possibly not.\n\nBetter to include a decision for \"If nums empty?\" but not necessary.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化 ones = 0, twos = 0 // 用於追蹤一次和兩次出現的位\n→ Step 2: 循環遍歷 nums 中的每個 num // 主循環\n    → Step 3: twos ← twos OR (ones AND num) // 將已出現一次且現在再次出現的位加入 twos\n    → Step 4: ones ← ones XOR num // 更新 ones\n    → Step 5: mask ← NOT (ones AND twos) // 計算需要清除的位（已出現三次）\n    → Step 6: ones ← ones AND mask // 清除 ones 中的三次出現位\n    → Step 7: twos ← twos AND mask // 同理清除 twos 中的三次出現位\n→ Step 8: 返回 ones // ones 中剩餘的即為唯一出現一次的數字\nEnd // 程式執行結束\n\nWe might want to mention constant space. But it's fine.\n\nMake sure each line is separate.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 ones = 0, twos = 0 // 用於追蹤每一個位元第一次與第二次出現的狀態  \n→ Step 2: 循環遍歷 nums 中的每個 num // 主循環，逐個處理數字  \n  → Step 3: twos ← twos OR (ones AND num) // 把已出現一次且現在再次出現的位加入 twos  \n  → Step 4: ones ← ones XOR num // 更新 ones，捕捉第一次出現的位  \n  → Step 5: mask ← NOT (ones AND twos) // 計算同時出現三次的位，需要將其清除  \n  → Step 6: ones ← ones AND mask // 清除 ones 中三次出現的位  \n  → Step 7: twos ← twos AND mask // 同理清除 twos 中三次出現的位  \n→ Step 8: 返回 ones // ones 裡剩下的即為唯一出現一次的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.9277396447703463,0.20287813738997845],[-0.13696731088626696,0.6852648328317302],[-0.4955850875568591,0.5237700949169942]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.9277396447703463, 0.20287813738997845], [-0.13696731088626696, 0.6852648328317302], [-0.4955850875568591, 0.5237700949169942]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            result.append(None)\n        else:\n            method = getattr(obj, op)\n            res = method(*args)\n            result.append(res)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, following format. Each line: virtual code step + space + // explanation.\n\nWe need to design algorithm: generate random point inside circle uniformly. Approach: generate random radius sqrt(random) * R, random angle uniform [0, 2π). Then x = x_center + r * cosθ, y = y_center + r * sinθ. Steps.\n\nImplement class Solution with constructor and method randPoint. Use pseudocode structure: Start, Decision, etc.\n\nWe should include random number generation. Use function rand() returning uniform [0,1). Use randomAngle = rand() * 2π. randomRadius = sqrt(rand()) * radius.\n\nSo produce steps.\n\nWe must be careful to maintain each step as single line with explanation. Use arrows and decisions. The steps inside method.\n\nWe should include pseudo-variables.\n\nWe'll produce code:\n\nStart\n→ Define class Solution // 定義解決方案類別\n→ Constructor: Solution(radius, x_center, y_center) // 建構子儲存半徑與中心\n    → Set this.radius = radius // 儲存半徑\n    → Set this.x_center = x_center // 儲存中心 x\n    → Set this.y_center = y_center // 儲存中心 y\n→ Method: randPoint() // 產生隨機點\n    → random1 ← rand() // 產生 0-1 隨機數\n    → random2 ← rand() // 再產生 0-1 隨機數\n    → r ← sqrt(random1) * this.radius // 計算半徑（調整分布）\n    → θ ← random2 * 2 * PI // 產生 0-2π 隨機角度\n    → x ← this.x_center + r * cos(θ) // 計算 x 坐標\n    → y ← this.y_center + r * sin(θ) // 計算 y 坐標\n    → Return [x, y] // 回傳點座標\nEnd\n\nBut we must use the arrow syntax. Let's produce like:\n\nStart // 程式開始\n→ Define class Solution // 定義 Solution 類別\n→ Constructor: Solution(radius, x_center, y_center) // 初始化參數\n    → this.radius ← radius // 保存半徑\n    → this.x_center ← x_center // 保存中心 x\n    → this.y_center ← y_center // 保存中心 y\n→ Method: randPoint() // 產生隨機點\n    → random1 ← rand() // 生成 0~1 的隨機數\n    → random2 ← rand() // 生成另一個 0~1 的隨機數\n    → r ← sqrt(random1) * this.radius // 根據分布調整半徑\n    → θ ← random2 * 2 * PI // 產生隨機角度\n    → x ← this.x_center + r * cos(θ) // 計算 x 坐標\n    → y ← this.y_center + r * sin(θ) // 計算 y 坐標\n    → Return [x, y] // 返回座標\nEnd // 程式結束\n\nWe should use arrow for nested lines: each indentation uses arrow. We can use \"→\" for main steps, and for nested lines we use \"→\" as well? In sample, nested inside Decision use indentation but still arrow. So we can indent but still use arrow. Let's match sample:\n\nStart // 程式開始執行\n→ Step 1: ...\n\nBut we can use \"→\" for each line. For nested, we can indent with spaces but still \"→\".\n\nLet's produce:\n\nStart // 程式開始\n→ Define class Solution // 定義類別\n→ Constructor: Solution(radius, x_center, y_center) // 初始化\n    → this.radius ← radius // 儲存半徑\n    → this.x_center ← x_center // 儲存中心 x\n    → this.y_center ← y_center // 儲存中心 y\n→ Method: randPoint() // 產生隨機點\n    → random1 ← rand() // 產生 0~1\n    → random2 ← rand() // 再產生 0~1\n    → r ← sqrt(random1) * this.radius // 調整半徑分布\n    → θ ← random2 * 2 * PI // 隨機角度\n    → x ← this.x_center + r * cos(θ) // 計算 x\n    → y ← this.y_center + r * sin(θ) // 計算 y\n    → Return [x, y] // 回傳座標\nEnd // 程式結束\n\nWe need to keep the arrow at each line. Indentation optional but consistent.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define class Solution // 定義解決方案類別  \n→ Constructor: Solution(radius, x_center, y_center) // 初始化並儲存半徑與中心座標  \n    → this.radius ← radius // 保存半徑值  \n    → this.x_center ← x_center // 保存中心點的 x 坐標  \n    → this.y_center ← y_center // 保存中心點的 y 坐標  \n→ Method: randPoint() // 產生圓內的隨機點  \n    → random1 ← rand() // 產生 0~1 的隨機數，用於調整半徑分布  \n    → random2 ← rand() // 再產生 0~1 的隨機數，用於角度  \n    → r ← sqrt(random1) * this.radius // 根號轉換使半徑均勻分布，並乘以給定半徑  \n    → θ ← random2 * 2 * PI // 產生 0~2π 的隨機角度  \n    → x ← this.x_center + r * cos(θ) // 計算隨機點的 x 座標  \n    → y ← this.y_center + r * sin(θ) // 計算隨機點的 y 座標  \n    → Return [x, y] // 回傳座標數組  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        Remove all occurrences of val from nums in-place.\n        Return the number of elements not equal to val (k).\n        \"\"\"\n        write = 0\n        for read in range(len(nums)):\n            if nums[read] != val:\n                nums[write] = nums[read]\n                write += 1\n        return write\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        nums = [1,2,3], val = 2\n    into a list of integers and an integer value.\n    \"\"\"\n    # Find the array part\n    lbr = data.find('[')\n    rbr = data.find(']', lbr)\n    if lbr == -1 or rbr == -1:\n        raise ValueError(\"Array not found in input.\")\n    nums_str = data[lbr:rbr+1]\n    nums = ast.literal_eval(nums_str)\n\n    # Find the val part\n    val_pos = data.find('val')\n    if val_pos == -1:\n        raise ValueError(\"Value not found in input.\")\n    eq_pos = data.find('=', val_pos)\n    if eq_pos == -1:\n        raise ValueError(\"Equals sign for val not found.\")\n    val_str = data[eq_pos+1:].strip()\n    val = int(val_str)\n    return nums, val\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    nums, val = parse_input(raw)\n    original_len = len(nums)\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # Build output string with underscores for unchanged positions\n    parts = []\n    for i in range(original_len):\n        if i < k:\n            parts.append(str(nums[i]))\n        else:\n            parts.append('_')\n    output = f\"{k}, nums = [{','.join(parts)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for removing elements in-place. Provide line by line with explanation. Use arrows and decisions. Let's produce:\n\nStart\n→ Initialize pointer write = 0 // index to write next non-val element\n→ For each element read from 0 to length-1\n    → If element != val\n        → Write element to nums[write]\n        → Increment write\n→ Return write // number of elements kept\n\nAlso handle case? That's fine. Let's output lines. Use proper formatting with // explanation.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化寫入指標 write = 0 // 這個指標指向下一個要寫入非 val 元素的位置  \n→ Step 2: 從索引 0 到 nums.length - 1 依序遍歷每個元素 // 逐一檢查每個元素是否為要移除的值  \n  → Decision: 如果 nums[i] 不等於 val? // 判斷當前元素是否要保留  \n   Yes → Step 3: nums[write] = nums[i] // 把非 val 元素寫入 write 指向的位置  \n    → Step 4: write += 1 // 移動寫入指標到下一個位置  \n   No  → Step 5: // 當元素等於 val 時直接跳過，不進行寫入  \n→ Step 6: Return write // write 現在等於保留元素的個數 k，符合題目要求  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[1,2,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [1, 2, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 原始陣列的深拷貝，保留原始順序\n        self.nums = list(nums)\n\n    def reset(self):\n        # 直接回傳原始陣列（不改動）\n        return self.nums\n\n    def shuffle(self):\n        # Fisher–Yates 隨機洗牌\n        arr = list(self.nums)\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    # 讀取整個 stdin 作為一行字串\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 把輸入切成兩個部分：方法序列和對應參數\n    idx = raw.find('],')\n    first_part = raw[:idx + 1]           # 例：[\"Solution\", \"shuffle\", ...]\n    second_part = raw[idx + 2:].strip()  # 例：[[[1, 2, 3]], [], [], []]\n\n    # 解析成 Python 物件\n    ops = ast.literal_eval(first_part)\n    args_list = ast.literal_eval(second_part)\n\n    # 執行操作並收集結果\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # 建構子，args 只有一個參數\n            obj = Solution(args[0])\n            results.append(None)\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 若有其他方法，暫時忽略\n            results.append(None)\n\n    # 用 JSON 格式輸出，確保 None 轉成 null\n    print(json.dumps(results, separators=(', ', ': ')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the described algorithm: Random shuffle using Fisher-Yates. Provide reset, shuffle methods, constructor. Virtual code line by line with explanation. Should not produce actual code, only pseudo steps with arrows. Use \"Start\", \"End\", \"Decision:\", \"Yes →\", \"No →\". Provide line numbers? Not required. Just each line separate. Provide step descriptions: initialize original array, copy array, shuffle by random index, return. Need to maintain state: original array copy, current array. Provide resetting by copying original to current. Provide shuffle: copy current, for i from len-1 to 1, pick random j in [0,i], swap.\n\nVirtual code lines:\n\nStart\n→ Step 1: 接收 nums 並儲存為 original // 保存原始陣列\n→ Step 2: 複製 original 為 current // 初始化當前陣列\n→ Step 3: 建立 Random 產生器 // 用於隨機數生成\n→ Step 4: 定義 reset() // 重新設定陣列\n    → Step 4.1: current ← copy of original // 將 current 重新設為原始\n    → Step 4.2: 回傳 current // 返回重置後的陣列\n→ Step 5: 定義 shuffle() // 產生隨機排列\n    → Step 5.1: current ← copy of original // 從原始陣列開始\n    → Step 5.2: i ← length of current - 1 // 從最後一位開始\n    → Decision: i >= 1? // 是否還有位置可交換\n        Yes → Step 5.3: j ← random integer between 0 and i // 隨機選擇交換位置\n        → Step 5.4: swap current[i] 與 current[j] // 交換元素\n        → Step 5.5: i ← i - 1 // 位置左移\n        → Decision: i >= 1? // 迴圈重複\n            Yes → 轉到 Step 5.3\n            No  → Step 5.6: 回傳 current // 所有交換完成，返回隨機陣列\nEnd\n\nWe need to use virtual code arrow style. Use \"→\" after each step. Also decisions indent.\n\nMake sure each line has explanation after //.\n\nLet's craft.\n\nWe should use consistent formatting: \"→ Step 1:\" etc. Use \"Decision:\" and \"Yes →\", \"No →\" lines.\n\nAlso note that inside shuffle loop we need nested decision. We'll use proper indentation. The pseudo-code lines need to be each separate line.\n\nLet's produce.\n\nAlso might include copy array function. But okay.\n\nEnsure we don't output actual code. Only virtual steps.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 儲存輸入陣列 nums 為 original // 保存原始陣列  \n→ Step 2: 產生 current 為 original 的複製 // 初始化當前陣列  \n→ Step 3: 建立 Random 產生器 rng // 用於產生隨機索引  \n→ Step 4: 定義 reset() 方法 // 重置陣列功能  \n  → Step 4.1: current ← copy of original // 重新把 current 設回原始陣列  \n  → Step 4.2: return current // 回傳重置後的陣列  \n→ Step 5: 定義 shuffle() 方法 // 隨機洗牌功能  \n  → Step 5.1: current ← copy of original // 從原始陣列開始混排  \n  → Step 5.2: i ← length(current) - 1 // 從最後一個位置開始  \n  → Decision: i ≥ 1? // 還有可交換的元素嗎？  \n    Yes → Step 5.3: j ← rng.nextInt(i + 1) // 隨機選擇 0~i 的索引  \n     → Step 5.4: swap(current[i], current[j]) // 交換 i 與 j 的元素  \n     → Step 5.5: i ← i - 1 // 移動到前一個位置  \n     → Decision: i ≥ 1? // 仍需繼續迴圈？  \n      Yes → 回到 Step 5.3  \n      No  → Step 5.6: return current // 洗牌完成，返回隨機陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            # 把目前子集加入結果\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                # 選擇元素\n                path.append(nums[i])\n                # 進一步遞迴\n                backtrack(i + 1, path)\n                # 回溯\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期格式為「nums = [1,2,3]」\n    if '=' in data:\n        _, right = data.split('=', 1)\n    else:\n        right = data\n\n    try:\n        nums = ast.literal_eval(right.strip())\n    except Exception:\n        nums = []\n\n    sol = Solution()\n    result = sol.subsets(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of a set of unique elements. The virtual code should be line by line, with comments. Use arrows. Should not output actual code. Should follow example format. Should be in Traditional Chinese. Let's produce a step-by-step algorithm: Start, Step: input array, define result list, call backtrack(index, current), at each call, add current subset to result, iterate i from index to len-1, include nums[i], backtrack(i+1, current+nums[i]), remove last (backtracking). End. Provide comments.\n\nMake sure each line is like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums // 取得使用者提供的唯一元素整數陣列\n→ Step 2: 初始化結果 subsets 為空集合 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 Backtrack(startIndex, currentSubset) // 用於生成子集\n    → Decision: startIndex 是否超過 nums 長度? // 判斷是否已遍歷完所有元素\n        Yes → Step 4: 將 currentSubset 複製到 subsets // 把目前子集加入結果\n        No  → Step 5: 將 currentSubset 複製到 subsets // 先把空子集或當前子集加入結果\n        → For i 從 startIndex 到 nums 長度-1 迭代\n            → Step 6: 將 nums[i] 加入 currentSubset // 選擇該元素\n            → Step 7: 呼叫 Backtrack(i+1, currentSubset) // 進一步遞迴\n            → Step 8: 從 currentSubset 移除最後一個元素 // 回溯\n→ Step 9: 呼叫 Backtrack(0, 空集合) // 開始遞迴\n→ Step 10: 回傳 subsets // 返回所有子集\nEnd // 程式執行結束\n\nBut need arrows and structure as per format: use `→` before each step, but nested decisions need indentation? In example, they used indentation with `Decision:` and `Yes →` etc. So we can mimic.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入陣列 nums // 取得唯一元素整數陣列\n→ Step 2: 建立空列表 subsets // 儲存所有子集\n→ Step 3: 定義函式 Backtrack(startIndex, current) // 產生子集的遞迴\n    → Decision: startIndex 是否大於等於 nums 長度? // 檢查是否已到尾端\n        Yes → Step 4: 將 current 複製並加入 subsets // 把目前子集加入結果\n        No  → Step 5: 將 current 複製並加入 subsets // 先把目前子集加入結果（包含空子集）\n        → For i 從 startIndex 到 nums 長度-1 迭代\n            → Step 6: 將 nums[i] 加入 current // 選擇元素\n            → Step 7: 呼叫 Backtrack(i+1, current) // 繼續遞迴\n            → Step 8: 從 current 移除最後一個元素 // 回溯\n→ Step 9: 呼叫 Backtrack(0, 空列表) // 開始遞迴\n→ Step 10: 回傳 subsets // 返回所有子集\nEnd // 程式執行結束\n\nWe must ensure no code. The virtual code lines are each \"Step X:\" or \"Decision:\" lines. The arrow is preceding each step. Also need indentation. Use spaces or tabs? Use spaces. Use the format: `→ Step 1: ...`. For Decision: `→ Decision: ...`. Then `Yes → ...` and `No → ...`.\n\nNeed to maintain indentation for nested steps. In example, they indented nested steps with spaces. We'll do similar: each indentation level uses two spaces or four? They used three spaces maybe. We'll replicate: For nested under Decision, indent by 4 spaces. For nested for loop, indent by 8 spaces maybe. Keep consistent.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得唯一元素整數陣列  \n→ Step 2: 建立空列表 subsets // 用於儲存所有子集  \n→ Step 3: 定義遞迴函式 Backtrack(startIndex, current) // 產生子集的遞迴  \n    → Decision: startIndex 是否大於等於 nums 長度? // 判斷是否已到尾端  \n        Yes → Step 4: 將 current 複製並加入 subsets // 把目前子集加入結果  \n        No  → Step 5: 將 current 複製並加入 subsets // 先把目前子集加入結果（包含空子集）  \n        → For i 從 startIndex 到 nums 長度-1 迭代  \n            → Step 6: 將 nums[i] 加入 current // 選擇元素  \n            → Step 7: 呼叫 Backtrack(i+1, current) // 繼續遞迴  \n            → Step 8: 從 current 移除最後一個元素 // 回溯  \n→ Step 9: 呼叫 Backtrack(0, 空列表) // 開始遞迴  \n→ Step 10: 回傳 subsets // 返回所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Task Scheduler",
      "source_file": "Leetcode/leetcode621.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '8'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '8'\nRaw Got:      '12'"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '14'\n--- (Raw) ---\nRaw Expected: '10'\nRaw Got:      '14'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"\n    計算最少 CPU 間隔數。\n    1. 先統計每個任務出現的次數。\n    2. 找出最高頻率 max_freq，以及有多少個任務達到此頻率 max_count。\n    3. 先計算「空閒槽」的理想數量：\n       empty_slots = (max_freq - 1) * (n + 1)\n    4. 其餘任務能填入這些槽：\n       filled_slots = total_tasks - max_freq * max_count\n    5. 若空閒槽多於填充槽，就需要額外 idle 時間；否則不需要 idle。\n    6. 最終答案為 total_tasks + idle。\n    \"\"\"\n    freq = Counter(tasks)\n    if not freq:\n        return 0\n    max_freq = max(freq.values())\n    max_count = sum(1 for v in freq.values() if v == max_freq)\n    empty_slots = (max_freq - 1) * (n + 1)\n    filled_slots = len(tasks) - max_freq * max_count\n    idle = max(0, empty_slots - filled_slots)\n    return len(tasks) + idle\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 用正則表達式取得 tasks 列表與 n 整數\n    pattern = r'tasks\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*n\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        # 也許輸入換行分開\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            tasks_line = lines[0]\n            n_line = lines[1]\n            match_tasks = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', tasks_line)\n            match_n = re.search(r'n\\s*=\\s*(-?\\d+)', n_line)\n            if match_tasks and match_n:\n                match = (None, None, None, None, None)\n                match = (match_tasks, None, match_tasks.group(1), match_n, match_n.group(1))\n    if not match:\n        # 若仍無法解析，直接退出\n        return\n\n    # 解析 tasks 列表與 n 整數\n    tasks_str = match.group(1)\n    n_str = match.group(2)\n    tasks = ast.literal_eval(tasks_str)\n    n = int(n_str)\n\n    # 計算並輸出結果\n    result = least_interval(tasks, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm. Standard solution: Count frequencies, find max freq, count how many tasks have that max, compute empty slots = (max-1)*(n+1), filled slots = total tasks - max * numMax, idle = max(0, emptySlots - filledSlots). Total intervals = tasks + idle.\n\nWe'll produce stepwise pseudo-code. Use Start, End, Decision. Provide explanation per line. Let's structure:\n\nStart\n→ Step 1: Count frequency of each task // Count occurrences of each letter\n→ Step 2: Find maxFreq and numMax // Determine highest frequency and how many tasks share it\n→ Step 3: Compute emptySlots = (maxFreq - 1) * (n + 1) // slots between most frequent tasks\n→ Step 4: Compute filledSlots = totalTasks - maxFreq * numMax // tasks that can fill gaps\n→ Step 5: Compute idle = max(0, emptySlots - filledSlots) // idle needed\n→ Step 6: Result = totalTasks + idle // minimal intervals\nEnd\n\nWe can also include decision for idle negative? Use Decision.\n\nLet's write.\n\nNeed to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrows for flow.\n\nLet's produce lines.\n\nAlso include variable definitions.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize freq[26] to 0 // 建立 26 個計數器來存放每個字母的頻率  \n→ Step 2: For each task in tasks, freq[task]++ // 逐個計算每個任務的出現次數  \n→ Step 3: Find maxFreq ← maximum value in freq // 找出最常見任務的頻率  \n→ Step 4: Count numMax ← number of letters whose frequency equals maxFreq // 有多少個任務達到最大頻率  \n→ Step 5: Compute emptySlots ← (maxFreq - 1) * (n + 1) // 計算最頻繁任務之間可用的空間槽  \n→ Step 6: Compute filledSlots ← totalTasks - maxFreq * numMax // 其餘任務可填滿空間槽的數量  \n→ Decision: If emptySlots ≤ filledSlots? // 檢查是否有足夠任務填充空間  \n  Yes → idle ← 0 // 若足夠填充，無需空閒時間  \n  No  → idle ← emptySlots - filledSlots // 若不足，空閒時間等於剩餘空間  \n→ Step 7: Result ← totalTasks + idle // 最小 CPU 時間等於任務總數加上空閒時間  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Twitter",
      "source_file": "Leetcode/leetcode355.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[5],null,null,[6,5],null,[5]]'\nGot (Norm):      '[None,None,[5],None,None,[6,5],None,[5]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [5], null, null, [6, 5], null, [5]]'\nRaw Got:      '[None, None, [5], None, None, [6, 5], None, [5]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        # 時間戳，用於確保推文的相對順序\n        self.time = 0\n        # 每個使用者的推文列表，元素為 (時間戳, tweetId)\n        self.tweets = defaultdict(list)\n        # 每個使用者關注的使用者集合\n        self.following = defaultdict(set)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        # 時間戳遞增，推文按發佈順序存儲\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # 方便自己能看到自己的推文，加入自己的關注集合\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        res = []\n        # 如果用戶不存在或沒有關注誰，直接返回空列表\n        if userId not in self.following:\n            return res\n        # 以最大堆方式合併關注者的最新推文\n        heap = []\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                # 使用負時間戳作為最大堆\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx - 1 >= 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        # 不能解除自己對自己的關注\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    # 去掉外層可能存在的雙引號\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    # 把兩個列表包裹成一個列表以便解析\n    raw_input = '[' + raw_input + ']'\n    try:\n        data = ast.literal_eval(raw_input)\n    except Exception:\n        sys.exit(0)\n    if not isinstance(data, list) or len(data) != 2:\n        sys.exit(0)\n    operations, arguments = data\n    twitter = None\n    outputs = []\n    for op, args in zip(operations, arguments):\n        if op == \"Twitter\":\n            twitter = Twitter()\n            outputs.append(None)\n        elif op == \"postTweet\":\n            twitter.postTweet(*args)\n            outputs.append(None)\n        elif op == \"getNewsFeed\":\n            result = twitter.getNewsFeed(*args)\n            outputs.append(result)\n        elif op == \"follow\":\n            twitter.follow(*args)\n            outputs.append(None)\n        elif op == \"unfollow\":\n            twitter.unfollow(*args)\n            outputs.append(None)\n    # Print results, None will be displayed as None (LeetCode interprets as null)\n    print(outputs)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code, line by line, with explanation, following specified format. Provide steps for implementing Twitter class with operations. Use Start, End, Decision, arrow. Provide pseudo-code steps. We need to include data structures: userTweetMap, followMap, global timestamp. Provide logic for each method.\n\nWe need to output lines with \"虛擬碼步驟 [space] // 解釋/說明\". Use arrows like → and decisions. We need to include Start, End. Each line step.\n\nWe should show initialization, postTweet, getNewsFeed, follow, unfollow. For getNewsFeed, we need to merge tweets from followees and self. We'll describe using min-heap or priority queue of 10. We'll mention using timestamp to sort. Provide decisions.\n\nWe should not output actual code but pseudo. Provide comments after each line.\n\nLet's craft.\n\nWe'll start with \"Start // 程式開始執行\". Then \"→ 初始化全局時間戳 counter = 0 // 用於確保每條推文的時序\" etc.\n\nWe'll also maintain data structures: Map<int, Set<int>> followMap; Map<int, List<(tweetId, timestamp)>> tweetMap.\n\nWe'll describe steps.\n\nMake sure each line ends with comment.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ 初始化全局時間戳 counter = 0 // 讓每條推文都有唯一的發佈順序  \n→ 建立用戶追蹤關係表 followMap = Map<userId, Set<followeeId>> // 追蹤誰跟誰  \n→ 建立推文儲存表 tweetMap = Map<userId, List<(tweetId, timestamp)>> // 以使用者為鍵存放其推文  \n\n// ------------------- postTweet -------------------  \n→ 方法 postTweet(userId, tweetId) // 用戶發佈推文  \n    → 取得使用者推文列表 list = tweetMap[userId] 或建立新列表 // 若使用者無推文則新建  \n    → 將 (tweetId, counter) 加入 list 的前面 // 先插入以保持最新順序  \n    → counter = counter + 1 // 時間戳遞增  \n    → tweetMap[userId] = list // 更新存儲  \n\n// ------------------- follow -------------------  \n→ 方法 follow(followerId, followeeId) // 追蹤另一個使用者  \n    → 取得追蹤集 set = followMap[followerId] 或建立新集合  \n    → set.add(followeeId) // 加入追蹤關係  \n    → followMap[followerId] = set  \n\n// ------------------- unfollow -------------------  \n→ 方法 unfollow(followerId, followeeId) // 取消追蹤  \n    → 如果 followerId 在 followMap 中  \n        → set = followMap[followerId]  \n        → set.remove(followeeId) // 移除追蹤關係  \n        → followMap[followerId] = set  \n\n// ------------------- getNewsFeed -------------------  \n→ 方法 getNewsFeed(userId) // 取得最新 10 條推文  \n    → 建立最小堆 minHeap (size <= 10) // 儲存最熱門的 10 條推文  \n    → 建立集合 candidates = {userId} ∪ followMap[userId] // 自己及追蹤者  \n    → 對每個 uid 在 candidates  \n        → 若 uid 在 tweetMap 中  \n            → list = tweetMap[uid] // 推文列表，最新在前  \n            → 取前 10 條或全部推文，對每條 (id, ts)  \n                → 若 minHeap.size < 10  \n                    → minHeap.add((ts, id)) // 加入堆  \n                → 否則若 ts > minHeap.peek().ts  \n                    → minHeap.poll() // 去除最舊  \n                    → minHeap.add((ts, id)) // 加入新推文  \n    → 從 minHeap 抽取所有元素，按 ts 降序排列成結果列表 result  \n    → 返回 result // 10 條最新推文 ID  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n\n            if not res:  # expr is a single number\n                res.append(int(expr))\n\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract expression: handle formats like\n    #   expression = \"2-1-1\"\n    # or just the raw expression without quotes\n    expr = None\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        expr = data[first_quote + 1:last_quote]\n    else:\n        # Remove any leading variable assignment if present\n        if '=' in data:\n            expr = data.split('=', 1)[1].strip()\n        else:\n            expr = data\n\n    # Compute all possible results\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n\n    # Print the result list\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudocode) step-by-step for computing all possible results from different groupings of a string expression containing numbers and operators. Likely use divide and conquer / recursion. The algorithm: parse expression, for each operator split, recursively compute left and right, combine.\n\nWe need to produce stepwise pseudocode with explanations. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe should include Start, End, Decision, etc. We need to cover steps: read input, parse, recursion, memoization maybe, combine results, output.\n\nAlso need to respect \"逐行\" output.\n\nLet's produce around 20-30 lines.\n\nLet's begin.\n\nLine 1: Start\n\nLine 2: → Step 1: 接收輸入字串 expression // 取得要計算的字串\n\nLine 3: → Step 2: 建立空記憶表 memo // 用於存放已計算子表達式的結果，避免重複計算\n\nLine 4: → Step 3: 呼叫函式 compute(expression) 並將結果存於 results // 取得所有可能結果\n\nLine 5: → Step 4: 輸出 results // 回傳結果列表\n\nLine 6: End\n\nNow define compute function:\n\nStart Compute(expression)\n\n→ Step: 如果 expression 只含數字 // 若子表達式是單一數字\n\n   Yes → Step: 轉換為整數並回傳 [value] // 返回單一值的列表\n\n   No  → Decision: 對於每個索引 i 在 expression 中遍歷\n\n         If char i 是運算符\n\n         → Step: left = compute(substring 0..i-1) // 递归左半部\n\n         → Step: right = compute(substring i+1..end) // 递归右半部\n\n         → Step: For每個 l in left For每個 r in right\n\n                → Step: 計算 l op r 並加入 results\n\n         // End for loops\n\n   // End if\n\n→ Step: 將結果存於 memo[expression] // 記憶化\n\n→ Step: 回傳 results\n\nEnd Compute\n\nWe must include indentation maybe.\n\nLet's write each line.\n\nWe'll produce using arrow and decisions. Use \"→\" to indicate steps.\n\nNeed to include \"Decision:\" lines with Yes/No.\n\nLet's produce.\n\nWe'll label steps as Step X: ... But each line is separate.\n\nAlso we need to maintain format: \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n\nWe'll use \"Start\", \"End\" for functions.\n\nWe'll use \"Decision:\" for if statements.\n\nWe also need to show loops.\n\nWe can use \"Loop:\" maybe but not necessary.\n\nWe can incorporate \"→ Loop: i from 0 to len-1\" etc.\n\nWe can show \"Decision: i is operator?\" etc.\n\nLet's write.\n\nMake sure each line has a single \"→\" arrow if it's a step.\n\nWe can combine multiple steps on one line if necessary but each line is a step. It's okay.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入字串 expression // 取得要計算的字串  \n→ Step 2: 建立空記憶表 memo // 用於存放已計算子表達式的結果，避免重複計算  \n→ Step 3: 呼叫函式 compute(expression) 並將結果存於 results // 取得所有可能結果  \n→ Step 4: 輸出 results // 回傳結果列表  \nEnd // 程式執行結束  \n\n---  \n\nStart compute(expression) // 開始遞歸計算子表達式  \n→ Decision: expression 為純數字? // 檢查子表達式是否只有數字  \n  Yes → Step 5: 將 expression 轉為整數 value 並回傳 [value] // 單一值回傳成列表  \n  No  → Decision: 需要遍歷每個字符以尋找運算符? // 若含有運算符則進行分割  \n    → Loop i from 0 to len(expression)-1 // 遍歷每個字符  \n      Decision: expression[i] 是運算符? // 判斷是否為 +, -, *  \n        Yes → Step 6: left_expr = expression[0:i] // 取得左半部子表達式  \n          → Step 7: right_expr = expression[i+1:] // 取得右半部子表達式  \n          → Step 8: left = compute(left_expr) // 递归計算左半部  \n          → Step 9: right = compute(right_expr) // 递归計算右半部  \n          → Step 10: For each l in left  \n            For each r in right  \n             → Step 11: result = l op r // 計算 l 與 r 的結果  \n             → Step 12: 將 result 加入 results 列表  \n          → Step 13: 結束內部雙層迴圈  \n          → Step 14: 結束左右子表達式處理  \n          → Step 15: 結束運算符判斷  \n          → Step 16: 結束 i 迴圈  \n          → Step 17: 將 results 存入 memo[expression] // 記憶化結果  \n          → Step 18: 回傳 results // 返回所有可能結果  \nEnd compute // 遞歸函式結束  \n\n---  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Contains Duplicate III",
      "source_file": "Leetcode/leetcode220.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpobgumgfs.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpobgumgfs.py\", line 42, in main\n    nums = ast.literal_eval(parts[0])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiprglptj.py\", line 53, in <module>\n    main()\n  File \"/tmp/tmpiprglptj.py\", line 42, in main\n    nums = ast.literal_eval(parts[0])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef contains_nearby_almost_duplicate(nums, index_diff, value_diff):\n    if index_diff <= 0 or value_diff < 0:\n        return False\n\n    window = []  # sorted list for the current window\n\n    for i, num in enumerate(nums):\n        # Find the first element >= num - value_diff\n        pos = bisect.bisect_left(window, num - value_diff)\n        if pos < len(window) and abs(window[pos] - num) <= value_diff:\n            return True\n\n        # Insert current number into the sorted window\n        bisect.insort(window, num)\n\n        # Maintain window size <= index_diff\n        if len(window) > index_diff:\n            # Remove the element that is sliding out of the window\n            old = nums[i - index_diff]\n            idx = bisect.bisect_left(window, old)\n            # The element must exist at idx\n            if idx < len(window) and window[idx] == old:\n                window.pop(idx)\n\n    return False\n\ndef main():\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n\n    # Remove the variable names to isolate values\n    cleaned = raw_input.replace('nums =', '').replace('indexDiff =', '').replace('valueDiff =', '')\n\n    # Split into three parts and strip whitespace\n    parts = [p.strip() for p in cleaned.split(',')]\n\n    # Evaluate the list and convert integers\n    nums = ast.literal_eval(parts[0])\n    index_diff = int(parts[1])\n    value_diff = int(parts[2])\n\n    # Call the solution function\n    result = contains_nearby_almost_duplicate(nums, index_diff, value_diff)\n\n    # Output lowercase 'true' or 'false'\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the algorithm. It's a known problem: \"Contains Duplicate III\" from Leetcode. We can do sliding window with balanced BST or bucket hashing. But produce pseudo-code in steps with decision arrows. Should be line-by-line.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Steps may include loops, decisions. Use arrow arrows.\n\nWe need to be succinct but show algorithm: e.g., use TreeSet or bucket approach.\n\nSimpler: Use sorted set and sliding window. Complexity O(n log n). Pseudocode:\n\nStart\n→ For i from 0 to n-1\n    → If i > indexDiff\n        → Remove nums[i-indexDiff-1] from sorted set\n    → Find lower_bound = floor(nums[i] - valueDiff)\n    → Find upper_bound = ceil(nums[i] + valueDiff)\n    → If there exists any element in sorted set within [lower_bound, upper_bound]\n        → Return true\n    → Add nums[i] to sorted set\n→ Return false\nEnd\n\nWe need to use Decision arrow to check existence. Use \"Decision: 是否存在\"? etc.\n\nLet's produce lines accordingly.\n\nAlso need explanation per line. Use arrow \"→\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize sorted set S // 用來存放滑動視窗內的元素，方便快速查找  \n→ For i from 0 to nums.length - 1 // 遍歷整個陣列  \n    → Decision: i > indexDiff? // 判斷滑動窗口是否已經超過指定長度  \n        Yes → S.remove(nums[i - indexDiff - 1]) // 移除最舊的元素，保持窗口大小 ≤ indexDiff  \n        No  → // 窗口內元素保持不變  \n    → Compute lower = nums[i] - valueDiff // 搜尋範圍下界  \n    → Compute upper = nums[i] + valueDiff // 搜尋範圍上界  \n    → Decision: S 中是否存在 ≥ lower 且 ≤ upper 的元素? // 檢查是否有符合條件的前一個元素  \n        Yes → Return true // 找到符合 i!=j、|i-j|≤indexDiff、|nums[i]-nums[j]|≤valueDiff 的對  \n        No  → S.add(nums[i]) // 將當前元素加入集合，作為未來比對的候選  \n→ Return false // 所有索引均未滿足條件，輸出偽  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,0,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 0, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和陣列，方便後續二分搜尋\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 產生 1~total 的隨機整數\n        target = random.randint(1, self.total)\n        # 以二分搜尋找到最小的 prefix_sum >= target\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 將輸入分成兩個部分：方法名與對應的參數\n    split_index = raw_input.find('],')\n    if split_index == -1:\n        # 若格式不正確，直接退出\n        sys.exit(0)\n\n    methods_part = raw_input[:split_index + 1].strip()\n    args_part = raw_input[split_index + 2:].strip()\n\n    # 解析為 Python 物件\n    methods = json.loads(methods_part)\n    args_list = json.loads(args_part)\n\n    results = []\n    obj = None\n\n    for idx, method in enumerate(methods):\n        args = args_list[idx]\n        if method == \"Solution\":\n            # 建構物件，傳入 w（args[0] 為 w 的列表）\n            obj = Solution(args[0])\n            results.append(None)\n        elif method == \"pickIndex\":\n            # 呼叫 pickIndex，將回傳值加入結果\n            results.append(obj.pickIndex())\n        else:\n            # 其他方法可自行處理\n            results.append(None)\n\n    # 輸出符合 LeetCode 格式的結果\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the described problem: implement a class with constructor receiving array w, build prefix sums, then pickIndex uses random to generate a number between 1 and total sum inclusive, binary search to find index. Use virtual code steps. Each line: virtual code step + // explanation. Use arrows. Should be structured: Start, Step1, Decision, etc. Provide algorithmic steps. Use \"→\" arrow. Provide Start, End. Let's produce step-by-step.\n\nWe need to handle initialization: compute prefix sums array and total sum. Then pickIndex: generate random integer r in [1,totalSum], then binary search to find smallest prefix sum >= r. Return index.\n\nWe'll produce virtual steps. Each line: \"Start // 程式開始執行\". Then steps. Use \"→\". For binary search use Decision. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的前綴和陣列 prefix // 用來儲存累計重量  \n→ Step 2: 初始化 totalSum ← 0 // 追蹤所有重量之和  \n→ Step 3: For 每個 weight w[i] 在輸入陣列 w  \n  → totalSum ← totalSum + w[i] // 加總重量  \n  → prefix.append(totalSum) // 儲存累計值  \n→ End // 建構完成，prefix 與 totalSum 已準備好  \n\n//--- pickIndex 函式 ---  \nStart // 執行 pickIndex  \n→ Step 1: 產生隨機整數 r ← RandomInt(1, totalSum) // 介於 1 與總重量之間  \n→ Step 2: 進入 binary search  \n  → Decision: low = 0, high = prefix.length - 1? // 設定搜尋範圍  \n   Yes → Step 3: mid ← (low + high) // 2 // 取中點  \n   → Decision: r ≤ prefix[mid]? // r 是否在 mid 之前的累計內  \n    Yes → high ← mid - 1 // 將搜尋範圍縮到左半部  \n    No → low ← mid + 1 // 將搜尋範圍縮到右半部  \n   → Decision: low > high? // 搜尋是否結束  \n    Yes → Step 4: 返回 low // low 為符合條件的最小索引  \n    No → 回到 Step 3 // 仍需繼續搜尋  \n→ End // pickIndex 執行結束  \n\n// 使用說明：  \n// 1. 建構時將輸入陣列 w 轉為前綴和與總重量。  \n// 2. pickIndex 隨機產生 1~totalSum，經二分搜尋找出對應索引，確保機率與 w[i]/sum(w) 成正比。"
    },
    {
      "title": "The K Weakest Rows in a Matrix",
      "source_file": "Leetcode/leetcode1337.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcphzjj_p.py\", line 50, in <module>\n    mat, k = parse_input(input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpcphzjj_p.py\", line 42, in parse_input\n    mat = ast.literal_eval(mat_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpmv8zmskv.py\", line 50, in <module>\n    mat, k = parse_input(input_data)\n             ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpmv8zmskv.py\", line 42, in parse_input\n    mat = ast.literal_eval(mat_str)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom typing import List\n\nclass Solution:\n    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n        \"\"\"\n        Count the number of soldiers in each row using binary search.\n        The row consists of 1's (soldiers) followed by 0's (civilians).\n        \"\"\"\n        def count_soldiers(row: List[int]) -> int:\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # Build list of tuples (soldier_count, row_index)\n        soldiers = [(count_soldiers(row), i) for i, row in enumerate(mat)]\n        # Sort by soldier count first, then by row index\n        soldiers.sort()\n        # Extract the indices of the k weakest rows\n        return [idx for _, idx in soldiers[:k]]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse the input string into a matrix and an integer k.\n    Expected format: \"mat = [[...]], k = ...\"\n    \"\"\"\n    # Remove whitespace to simplify parsing\n    data = data.replace(' ', '').strip()\n    # Remove variable names\n    data = data.replace('mat=','').replace('k=','')\n    # Split at the first comma\n    parts = data.split(',', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Invalid input format.\")\n    mat_str, k_str = parts[0], parts[1]\n    mat = ast.literal_eval(mat_str)\n    k = int(k_str)\n    return mat, k\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    if not input_data:\n        sys.exit()\n    mat, k = parse_input(input_data)\n    solution = Solution()\n    result = solution.kWeakestRows(mat, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for solving the problem of returning k weakest rows. Must be line by line, with arrow and explanation. We need to design algorithm: count soldiers per row, using binary search because each row sorted with 1s then 0s. Then sort rows by (count, index). Return first k indices.\n\nWe output pseudocode with Start, Decision, arrow etc. Shouldn't output actual code.\n\nWe need to be careful with lines: each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" to indicate flow. Decision lines \"Decision: ...\". Use Yes →, No →.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化 resultList\n→ Step 2: 初始化 rowsList\n→ Decision: 遍歷每一行? Yes → Step 3: 計算該行士兵數量\n→ Step 4: 把 (soldierCount, rowIndex) 加入 rowsList\n→ Step 5: 走到下一行\n→ Step 6: 完成遍歷所有行\n→ Step 7: 按 (soldierCount, rowIndex) 升序排序 rowsList\n→ Step 8: 取前 k 個 rowIndex 並存入 resultList\n→ End\n\nBut must include explanation. Also need decision for binary search? We could show decision to use binary search to count soldiers: Decision: 1's sorted? Yes -> binary search else linear scan. But given assumption it's sorted, we can skip decision.\n\nBetter produce pseudocode with binary search inside step 3.\n\nAlso need to produce explanation for each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的結果陣列 resultList // 用來存放最弱行的索引\n→ Step 2: 建立空的 rowsList // 用來存放每行的士兵數量與索引\n→ Decision: 需要遍歷所有行? Yes → Step 3: 設定行指標 i = 0 // 從第一行開始\n→ Step 4: 循環直到 i < m // m 為行數\n    → Step 5: 透過二分搜尋計算 row i 中 1 的個數 soldierCount // 1 代表士兵，0 代表平民\n    → Step 6: 把 (soldierCount, i) 加入 rowsList // 以便後續排序\n    → Step 7: i = i + 1 // 進到下一行\n→ Step 8: 對 rowsList 進行升序排序，排序鍵為 (soldierCount, rowIndex) // 同士兵數則靠較小索引排前\n→ Step 9: 取 rowsList 前 k 個元素的 rowIndex 並加入 resultList // 這些即為最弱的 k 行\n→ End // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Compute the h-index for a sorted (non-decreasing) list of citation counts.\n        Uses binary search to achieve O(log n) time.\n        \"\"\"\n        n = len(citations)\n        if n == 0:\n            return 0\n\n        low, high = 0, n - 1\n        best = 0\n\n        while low <= high:\n            mid = (low + high) // 2\n            # Number of papers with at least citations[mid] citations is n - mid\n            h = n - mid\n            if citations[mid] >= h:\n                # This h is feasible, try to find a larger one\n                best = h\n                low = mid + 1\n            else:\n                # Not enough citations for this h, search left side\n                high = mid - 1\n\n        return best\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Extract the list of citations from a string like:\n    'citations = [0,1,3,5,6]'\n    \"\"\"\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    list_str = input_str[start:end+1]\n    return ast.literal_eval(list_str)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    citations = parse_input(raw_input)\n    sol = Solution()\n    result = sol.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, for algorithm: binary search to find maximum h such that citations[n-h] >= h (since sorted). Provide steps.\n\nWe'll output line by line.\n\nLet's craft: Start, input array, n, low, high. While low <= high: mid = (low+high)//2; check citations[n-mid] (since sorted ascending). If citations[n-mid] >= mid: h found but we want maximum so set answer=mid; low=mid+1; else high=mid-1. After loop, output answer.\n\nLet's produce virtual code with arrows. Use \"Decision:\" for while condition? Use \"While\" maybe not in requirement but we can use Decision: While low <= high? Might use Decision. Provide steps.\n\nLet's produce.\n\nWe'll include comments in Chinese.\n\nLet's generate final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入陣列 citations, n ← length(citations) // 取得引用數列長度  \n→ Step 2: low ← 1, high ← n, answer ← 0 // 設定搜尋範圍與初始答案  \n→ Decision: low <= high? // 判斷是否仍有可搜尋區間  \n    Yes → Step 3: mid ← (low + high) // 2 // 取中點作為候選 h 值  \n    → Decision: citations[n - mid] >= mid? // 以升序排列表格查找第 n-mid 個元素  \n        Yes → Step 4: answer ← mid // 找到更大 h，更新答案  \n                    → Step 5: low ← mid + 1 // 搜尋更高的 h  \n        No  → Step 6: high ← mid - 1 // 低於需求，縮小搜尋上限  \n    No → End // 搜尋結束，答案已確定  \n→ Step 7: 輸出 answer // 回傳最終計算出的 h-index  \nEnd // 程式執行結束"
    }
  ]
}