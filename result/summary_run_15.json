{
  "run_index": 15,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 293,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入，若有輸入則忽略，符合「從標準輸入讀取」的要求\n    _ = sys.stdin.read()\n\n    try:\n        # 使用 with 語法安全開啟 data.txt\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n        # 輸出行數\n        print(f'檔案共有 {len(lines)} 行')\n    except FileNotFoundError:\n        # 檔案不存在時顯示錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. Use structure: Start, End, Decision, etc. Use with, try/except. Provide virtual steps. Let's craft.\n\nLine 1: Start // start\n\nLine 2: → Step 1: 初始化行數為 0 // count lines\n\nLine 3: → Decision: 嘗試打開檔案? // try open file\n\nNeed try/except inside? We can represent with Decision for success/failure.\n\nWe can write:\n\n→ Decision: 檔案存在且可開啟? // try open\n\nYes → Step 2: 以 with 讀取檔案 // open file\n\nInside that, read lines loop.\n\nWe might need nested steps: with, for each line increment counter, then after with, output count.\n\nIf fail: No → Step 3: 輸出『找不到檔案！』 // error.\n\nLet's produce.\n\nWe need to maintain correct indentation representation. For Decision with Yes/No, show subsequent steps with indentation.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化行數計數器為 0 // 設定行數為 0\n→ Decision: 檔案存在且可開啟? // 進行檔案開啟嘗試\n    Yes → Step 2: 使用 with 語法開啟 data.txt 為 file // 開啟檔案\n        → Step 3: 讀取每一行並遞增行數計數器 // 計算行數\n        → Step 4: with 區塊結束，輸出行數計數器 // 顯示結果\n    No  → Step 5: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息\nEnd // 程式執行結束\n```\n\nBut we should represent the read each line: Step 3: 讀取每一行並遞增行數計數器.\n\nWe might need an inner loop decision? but we can just note that step.\n\nAlternatively, we can add Decision: 行還存在? but not necessary.\n\nBut the instructions: use with and try/except. So the decision representing try/except is good.\n\nHowever we need to show try/except explicitly? We can represent with Decision: 是否出現例外? Yes → Step 5 etc.\n\nLet's refine:\n\nLine 1: Start\n\nLine 2: → Step 1: 設定行數計數器 = 0\n\nLine 3: → Decision: 嘗試以 with 開啟 data.txt? // try\n\nYes → Step 2: 使用 with open('data.txt','r') as file // open file\n\n    → Step 3: 逐行讀取，對每行行數計數器 +1 // count lines\n\n    → Step 4: with 區塊結束後，輸出行數計數器 // output\n\nNo → Step 5: 輸出 '找不到檔案！' // error message\n\nEnd\n\nYes.\n\nMake sure to include arrow lines. Use \"→\" for normal steps, indent after Decision.\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// 解釋\".\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定行數計數器 = 0 // 初始化行數為 0  \n→ Decision: 嘗試以 with 開啟 data.txt? // 進行檔案開啟嘗試  \n Yes → Step 2: 使用 with open('data.txt','r') as file // 使用 with 語法開啟檔案  \n  → Step 3: 逐行讀取，對每行行數計數器 +1 // 計算檔案中每一行  \n  → Step 4: with 區塊結束後，輸出行數計數器 // 顯示總行數  \n No → Step 5: 輸出 '找不到檔案！' // 檔案不存在時顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[2,6,6,4,6]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[2, 6, 6, 4, 6]'"
        }
      ],
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰，回傳結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # 若輸入形如 print(roll_dice(5))\n    if raw.startswith(\"print(\") and raw.endswith(\")\"):\n        expr = raw[6:-1].strip()\n        try:\n            value = eval(expr, {\"roll_dice\": roll_dice})\n            print(value)\n            sys.exit()\n        except Exception:\n            pass\n\n    # 其他情況：直接把輸入視為整數 n\n    try:\n        n = int(raw)\n        print(roll_dice(n))\n    except Exception:\n        # 無法處理的輸入，保持安靜\n        pass",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Use random module; define function roll_dice(n); simulate n rolls of a six-sided die; return list of results.\n\nWe output each line: \"虛擬碼步驟 // 解釋\" with Start, End, Decision, etc. Use arrow. Let's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Import random module // 導入 random\n\nLine 3: → Function: roll_dice(n) // 定義函數 roll_dice，參數 n\n\nLine 4: → Step 1: results = [] // 初始化結果列表\n\nLine 5: → Decision: 如果 n > 0? // 檢查是否有擲幾次\n\nLine 6:    Yes → Loop 1: for i in range(n): // 循環擲 n 次\n\nLine 7:        → Step 2: roll = random.randint(1, 6) // 擲一次六面骰\n\nLine 8:        → Step 3: results.append(roll) // 將結果加入列表\n\nLine 9:        → End Loop // 結束一次迴圈\n\nLine 10:   No → Step 4: pass // n <= 0 時不做任何操作\n\nLine 11: → Step 5: return results // 回傳結果列表\n\nLine 12: End // 程式執行結束\n\nBut we need proper arrow syntax: → Step 1: ... etc. Also Decision with Yes → etc. Also Start and End. Provide each line with comment.\n\nLet's produce lines.\n\nAlso ensure arrow \"→\" used before each step. For decisions: \"Decision:\" then indent Yes → etc. Use indentation as in sample: but we just show with spaces. In sample they used tab spaces. We'll replicate.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Import random // 導入 random 模組\n\n→ Function: roll_dice(n) // 定義函數 roll_dice，參數為 n\n\n→ Step 1: results = [] // 初始化結果清單\n\n→ Decision: n > 0? // 判斷擲骰次數是否大於 0\n\n    Yes → Loop 1: for i in range(n): // 進入迴圈擲 n 次\n\n        → Step 2: roll = random.randint(1, 6) // 擲一次六面骰\n\n        → Step 3: results.append(roll) // 將擲到的點數加入清單\n\n        → End Loop // 迴圈結束\n\n    No → Step 4: pass // 若 n <= 0，不做任何擲骰\n\n→ Step 5: return results // 回傳所有擲骰結果\n\nEnd // 程式執行結束\n\nMake sure arrow lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random // 導入 random 模組  \n→ Function: roll_dice(n) // 定義函數 roll_dice，參數為 n  \n→ Step 1: results = [] // 初始化結果清單  \n→ Decision: n > 0? // 判斷擲骰次數是否大於 0  \n    Yes → Loop 1: for i in range(n): // 進入迴圈擲 n 次  \n        → Step 2: roll = random.randint(1, 6) // 擲一次六面骰  \n        → Step 3: results.append(roll) // 將擲到的點數加入清單  \n        → End Loop // 迴圈結束  \n    No → Step 4: pass // 若 n <= 0，不做任何擲骰  \n→ Step 5: return results // 回傳所有擲骰結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"測量函式 func 執行所需秒數，回傳四捨五入到小數點 3 位的時間值。\"\"\"\n    start = time.time()          # 開始時間\n    func(*args)                  # 執行傳入的函式\n    end = time.time()            # 結束時間\n    return round(end - start, 3) # 以秒為單位，四捨五入到 3 位小數\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼\n    code = sys.stdin.read()\n    # 在當前命名空間執行讀取的程式碼\n    exec(code, globals())",
      "virtual_code": "Thinking...\nThe user wants virtual code for a function measure_time(func,*args) that uses time module, measures execution time, returns result rounded to 3 decimal places. Provide line-by-line virtual code with arrow and explanation. Need to include Start, End, decisions if any. Steps: import time; define function; start timer; call func with args; end timer; compute duration; round to 3 decimals; return duration.\n\nVirtual code lines: Start; import; define function; start timer; call function; stop timer; compute diff; round; return; End.\n\nUse arrow for steps: e.g., \"→ Step 1: import time module // 引入 time 模組\". And function definition lines maybe like \"→ Step 2: Define function measure_time(func, *args) // 建立函式\". Then inside function: start timer: \"→ Step 3: Record start time // 取得起始時間\". Then call: \"→ Step 4: Execute func(*args) // 執行傳入函式\". Then stop: \"→ Step 5: Record end time // 取得結束時間\". Then compute: \"→ Step 6: Calculate duration = end - start // 計算執行時間\". Then round: \"→ Step 7: Round duration to 3 decimal places // 四捨五入\". Then return: \"→ Step 8: Return rounded duration // 傳回結果\". End.\n\nAlso note that function returns the duration only, not the result of func. The problem says return result (the time) not the func result. So we keep that.\n\nShould we include decision? No decision. So just steps.\n\nReturn value: rounded seconds.\n\nOk. Output format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow \"→\" and \"Start\", \"End\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入 time 模組  \n→ Step 2: Define function measure_time(func, *args) // 建立 measure_time 函式，接受任意函式與參數  \n→ Step 3: Record start_time = time.time() // 取得執行前的時間戳  \n→ Step 4: Execute result = func(*args) // 執行傳入的函式，儲存其回傳值（若需要可忽略）  \n→ Step 5: Record end_time = time.time() // 取得執行後的時間戳  \n→ Step 6: Calculate duration = end_time - start_time // 計算函式執行所耗費的秒數  \n→ Step 7: Round rounded_duration = round(duration, 3) // 四捨五入到小數點 3 位  \n→ Step 8: Return rounded_duration // 傳回已四捨五入的時間值  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"grape\",\"orange\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'grape', 'orange', 'melon', 'apple'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入（若有提供），但對於本題並不需要使用這些資料\n    _ = sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 同時新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'，discard 不會拋出錯誤\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrows. Starting with Start, then steps for each operation, then End. Must follow the format exactly: each line: \"虛擬碼步驟 // 解釋\" with arrow or Decision.\n\nThe operations are straightforward, no decision branches needed except maybe when removing. But we can include Decision for remove? Not necessary. We'll just do Step lines. For discard, we can mention that it's safe. End.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits\n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'\n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'\n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'\n→ Step 6: print(fruits) // 輸出最終集合\nEnd // 程式執行結束\n\nWe should ensure the arrow format: \"→ Step X: ...\". Each line. Yes.\n\nReturn that.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits ← {'apple', 'banana'} // 建立集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update({'grape', 'melon'}) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'  \n→ Step 6: print(fruits) // 輸出最終集合  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.66TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.66 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> str:\n    \"\"\"\n    取得美元兌台幣匯率並回傳字串\n    若請求失敗則回傳錯誤訊息\n    \"\"\"\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()                     # 若 HTTP 狀態碼非 200，拋出例外\n        data = r.json()\n        rate = data['rates']['TWD']\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception as e:\n        return \"更新失敗，請檢查網路連線\"\n\ndef get_rate() -> None:\n    \"\"\"\n    更新 GUI 標籤內容\n    \"\"\"\n    label.config(text=fetch_rate())\n\n# ---------- GUI 設定 ----------\nwin = tk.Tk()\nwin.title('匯率查詢')\n\nlabel = tk.Label(win, text='請按下按鈕更新匯率', font=('Arial', 12))\nlabel.pack(pady=10)\n\nupdate_btn = tk.Button(win, text='更新匯率', command=get_rate)\nupdate_btn.pack(pady=5)\n\n# ---------- 主程式 ----------\nif __name__ == \"__main__\":\n    # 讀取 stdin，若有輸入則視為「更新匯率」指令，直接列印結果\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 只要有任何輸入，就執行一次匯率查詢並輸出\n        print(fetch_rate())\n    else:\n        # 無輸入時，顯示 GUI 介面\n        win.mainloop()",
      "virtual_code": "Thinking...\nWe need produce step-by-step virtual code lines, each with explanation, using the specified format. No actual code. Just steps. Should describe using requests, tkinter, etc. Use Start, End, Decision. Include steps: import modules, define function to fetch rate, create window, label, button, set command to fetch, update label, mainloop.\n\nWe need to be thorough but not too many lines. Each line is a step. Use arrows →. Provide explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 requests 模組 // 引入 HTTP 請求庫  \n→ Step 2: 匯入 tkinter 模組 // 引入 GUI 庫  \n→ Step 3: 定義函式 fetch_rate()  \n  → Step 3.1: 發送 GET 請求至 https://api.exchangerate-api.com/v4/latest/USD // 取得最新美元匯率資料  \n  → Decision: 如果回應狀態碼為 200? // 檢查請求是否成功  \n    Yes → Step 3.2: 解析 JSON 資料 // 取得回傳的 JSON  \n     → Step 3.3: 取得 TWD 匯率值 // 從 JSON 取出 'rates' -> 'TWD'  \n     → Step 3.4: 回傳 TWD 匯率值 // 返回匯率  \n    No → Step 3.5: 回傳 '錯誤' // 失敗時回傳錯誤訊息  \n→ Step 4: 建立 tkinter 視窗 root  \n→ Step 5: 建立標籤 label 用於顯示匯率 // 初始化顯示文字  \n→ Step 6: 建立按鈕 update_btn，文字為 \"更新匯率\"  \n  → Step 6.1: 設定按鈕 command 為 lambda：fetch_rate() 並將結果顯示在 label 上 // 觸發更新操作  \n→ Step 7: 把 label 與 update_btn 放置於視窗中 // 佈局  \n→ Step 8: 呼叫 fetch_rate() 以取得初始匯率並顯示在 label 上 // 開始時顯示一次  \n→ Step 9: 執行 root.mainloop() // 開始事件迴圈，等待使用者互動  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[2,0],[1,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null,[0,0],[2,0],[1,0],null,[2,0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport json\n\nclass Solution:\n    def __init__(self, n_rows: int, n_cols: int):\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols          # 仍未翻轉的格子總數\n        self.flipped = {}                     # 用於映射已交換的索引\n\n    def flip(self) -> list:\n        # 隨機挑選一個在 [0, self.total-1] 的索引\n        r = random.randint(0, self.total - 1)\n        # 取得實際的格子索引，若已映射則取映射值\n        idx = self.flipped.get(r, r)\n        # 將此索引從可用池中移除\n        self.total -= 1\n        # 把最後一個可用索引映射到 r，若已映射則取其映射值\n        self.flipped[r] = self.flipped.get(self.total, self.total)\n        # 轉換成 (row, col)\n        return [idx // self.cols, idx % self.cols]\n\n    def reset(self) -> None:\n        # 重設為全零矩陣\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit()\n    # 解析類似 ['Solution', 'flip', ...], [[3,1], [], ...] 的輸入\n    ops, args_list = ast.literal_eval('[' + input_data + ']')\n    obj = None\n    output = []\n    for op, args in zip(ops, args_list):\n        if op == 'Solution':\n            obj = Solution(args[0], args[1])\n            output.append(None)\n        elif op == 'flip':\n            output.append(obj.flip())\n        elif op == 'reset':\n            obj.reset()\n            output.append(None)\n    # 以 JSON 形式輸出，使用無空格格式\n    print(json.dumps(output, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step. Should not output actual code. Should use arrows. We need to explain each line. For this problem, algorithm: use reservoir of available cells. We can map 1D index to 2D. Use total = m*n. Use list of available indices from 0 to total-1. We can simulate shuffle with mapping dictionary. flip: pick random k between 0 and remaining-1. let idx = mapping.get(k, k). mapping[k] = mapping.get(remaining-1, remaining-1). remaining--. Convert idx to (i, j). return [i, j]. reset: clear mapping and set remaining=total. Also need to handle calls to random minimized: each flip uses one random call. Complexity: O(1) avg time per flip.\n\nWe need virtual code with step lines: Start, Step: Initialize variables. For flip: Step: pick random, map to index, update mapping. Convert. For reset: clear mapping, set count.\n\nLet's produce.\n\nUse format: \nStart // ...\n→ Step 1:  // description\n\nNeed to include arrows. Let's produce each line with // explanation.\n\nWill use decisions maybe not needed. Provide simple flow.\n\nLet's output:\n\nStart // 程式開始執行\n→ Step 1: Set total ← m * n // 計算矩陣總格數\n→ Step 2: Set remaining ← total // 記錄尚未翻轉的格數\n→ Step 3: 初始化 mapping as empty map // 用於存儲已交換的索引\n\nFlip() method:\n→ Step 4: Call rand_int ← random(0, remaining-1) // 隨機取得一個可用位置\n→ Step 5: If rand_int in mapping then idx ← mapping[rand_int] else idx ← rand_int // 取得真實索引\n→ Step 6: Let last ← remaining-1 // 取最後一個可用位置\n→ Step 7: If last in mapping then mapping[rand_int] ← mapping[last] else mapping[rand_int] ← last // 交換\n→ Step 8: Remove mapping[last] if exists // 清除已使用的最後索引映射\n→ Step 9: Decrement remaining ← remaining-1 // 更新剩餘數量\n→ Step 10: Convert idx to (i, j) via i ← idx // m, j ← idx % n // 轉為 2D 坐標\n→ Step 11: Return [i, j] // 返回翻轉的位置\n\nReset() method:\n→ Step 12: Clear mapping // 清空映射表\n→ Step 13: Set remaining ← total // 重置剩餘數量\n→ Step 14: End // 方法結束\n\nBut need to produce each step line with explanation.\n\nAlso use Decision maybe not needed.\n\nLet's format.\n\nMake sure each line: `虛擬碼步驟 // 解釋`.\n\nAlso need to start with Start and End. Provide separate for each method? We could show within the class: but we can show Start for constructor, flip, reset. We'll use separate flows.\n\nWe'll output overall.\n\nLet's craft.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Set total ← m * n // 計算矩陣的總格數\n→ Step 2: Set remaining ← total // 初始時所有格子皆未翻轉\n→ Step 3: Initialize mapping as empty map // 用於動態映射已交換的索引\n\n// =====================  Flip() 方法 =====================\n→ Step 4: rand_idx ← RandomInt(0, remaining - 1) // 隨機取得一個可用索引\n→ Step 5: If rand_idx in mapping then idx ← mapping[rand_idx] else idx ← rand_idx // 得到實際一維索引\n→ Step 6: last_idx ← remaining - 1 // 取最後一個尚未翻轉的位置\n→ Step 7: If last_idx in mapping then mapping[rand_idx] ← mapping[last_idx] else mapping[rand_idx] ← last_idx // 將選中的位置與最後一個位置交換\n→ Step 8: If last_idx in mapping then Remove mapping[last_idx] // 清除已使用的最後索引映射\n→ Step 9: remaining ← remaining - 1 // 更新剩餘未翻轉格子數\n→ Step 10: i ← idx / n // 轉換為行坐標\n→ Step 11: j ← idx % n // 轉換為列坐標\n→ Step 12: Return [i, j] // 返回翻轉後的格子位置\n\n// =====================  Reset() 方法 =====================\n→ Step 13: Clear mapping // 清空所有映射\n→ Step 14: remaining ← total // 重置剩餘格子數\n→ Step 15: End // 方法結束\n```"
    },
    {
      "title": "Heaters",
      "source_file": "Leetcode/leetcode475.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmptnns360_.py\", line 41, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmptnns360_.py\", line 31, in parse_input\n    houses = ast.literal_eval(lst)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk_x7_oz3.py\", line 41, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk_x7_oz3.py\", line 31, in parse_input\n    houses = ast.literal_eval(lst)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvtb737oh.py\", line 41, in <module>\n    houses, heaters = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvtb737oh.py\", line 31, in parse_input\n    houses = ast.literal_eval(lst)\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom bisect import bisect_left\n\ndef find_radius(houses, heaters):\n    \"\"\"計算最小暖化半徑。\"\"\"\n    houses.sort()\n    heaters.sort()\n    max_radius = 0\n    for house in houses:\n        # 找出最靠近右邊的暖器位置\n        idx = bisect_left(heaters, house)\n        # 右邊暖器距離（若不存在則視為無限大）\n        right_dist = heaters[idx] - house if idx < len(heaters) else float('inf')\n        # 左邊暖器距離（若不存在則視為無限大）\n        left_dist = house - heaters[idx - 1] if idx > 0 else float('inf')\n        # 房屋最小需要的半徑\n        min_dist = min(right_dist, left_dist)\n        if min_dist > max_radius:\n            max_radius = min_dist\n    return max_radius\n\ndef parse_input(raw: str):\n    \"\"\"將輸入字串解析為 houses 與 heaters 列表。\"\"\"\n    raw = raw.replace('\\n', ',')          # 將換行視為逗號\n    houses, heaters = [], []\n    for part in raw.split(','):\n        part = part.strip()\n        if part.startswith('houses'):\n            lst = part.split('=', 1)[1].strip()\n            houses = ast.literal_eval(lst)\n        elif part.startswith('heaters'):\n            lst = part.split('=', 1)[1].strip()\n            heaters = ast.literal_eval(lst)\n    return houses, heaters\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    houses, heaters = parse_input(raw_input)\n    result = find_radius(houses, heaters)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find minimal radius such that heaters cover all houses. Classic solution: sort houses and heaters. For each house, find nearest heater distance (using binary search). Then max of these distances. Or two pointers. We'll produce virtual code steps.\n\nWe must output line by line: step description, arrow, explanation.\n\nNo actual code, just pseudo steps.\n\nWe must incorporate Start, End, Decision.\n\nLet's design steps:\n\nStart\n→ Sort houses ascending\n→ Sort heaters ascending\n→ Initialize maxRadius = 0\n→ For each house in houses:\n    → Find index of heater just greater than or equal to house using binary search\n    → If heater exists, compute distanceRight = heater - house\n    → Else distanceRight = INF\n    → If index > 0, compute distanceLeft = house - heaters[index-1]\n    → Else distanceLeft = INF\n    → minDist = min(distanceRight, distanceLeft)\n    → Update maxRadius = max(maxRadius, minDist)\n→ Return maxRadius\nEnd\n\nWe need explanation after each line.\n\nAlso, we need to use arrows: →, Decision: etc. For binary search we can use Decision: if heater index exists.\n\nLet's produce.\n\nMake sure each line has step plus comment. Use simple phrasing.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort houses ascending // 先將房屋位置排序，方便後續比對  \n→ Sort heaters ascending // 同樣將暖器位置排序，確保可做二分搜尋  \n→ Initialize maxRadius = 0 // 以 0 開始，儲存目前所需的最大最小距離  \n→ For each house in houses: // 逐一處理每個房屋  \n  → Find heater index ≥ house using binary search // 找出最靠近右側的暖器  \n   → Decision: heater exists? // 判斷是否有右側暖器  \n    Yes → distanceRight = heater - house // 右側暖器距離  \n    No  → distanceRight = Infinity // 無右側暖器，距離視為無限大  \n   → Decision: index > 0? // 判斷是否有左側暖器  \n    Yes → distanceLeft = house - heaters[index-1] // 左側暖器距離  \n    No  → distanceLeft = Infinity // 無左側暖器，距離視為無限大  \n  → minDist = min(distanceRight, distanceLeft) // 取左右兩者中較小距離  \n  → Update maxRadius = max(maxRadius, minDist) // 若此距離較大，更新最大半徑  \n→ Return maxRadius // 最終輸出最小的標準暖化半徑  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['()()()', '(())()']\""
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # 先計算需要刪除的左括號和右括號數量\n        left_rem, right_rem = 0, 0\n        for ch in s:\n            if ch == '(':\n                left_rem += 1\n            elif ch == ')':\n                if left_rem == 0:\n                    right_rem += 1\n                else:\n                    left_rem -= 1\n\n        res = set()\n\n        def dfs(idx: int, left_rem: int, right_rem: int, open_cnt: int, path: str):\n            if idx == len(s):\n                if open_cnt == 0:\n                    res.add(path)\n                return\n\n            ch = s[idx]\n\n            if ch == '(':\n                # 可以選擇刪除\n                if left_rem > 0:\n                    dfs(idx + 1, left_rem - 1, right_rem, open_cnt, path)\n                # 或保留\n                dfs(idx + 1, left_rem, right_rem, open_cnt + 1, path + ch)\n            elif ch == ')':\n                # 可以選擇刪除\n                if right_rem > 0:\n                    dfs(idx + 1, left_rem, right_rem - 1, open_cnt, path)\n                # 或保留（必須有左括號可配對）\n                if open_cnt > 0:\n                    dfs(idx + 1, left_rem, right_rem, open_cnt - 1, path + ch)\n            else:\n                # 普通字元，直接保留\n                dfs(idx + 1, left_rem, right_rem, open_cnt, path + ch)\n\n        dfs(0, left_rem, right_rem, 0, \"\")\n        return list(res)\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從原始輸入中提取字串 s。\n    支援格式如：\n      s = \"()())()\"\n      \"(()))\"\n      ()()\n    \"\"\"\n    raw = raw.strip()\n    # 找到 '=' 並取 '=' 之後的內容\n    if '=' in raw:\n        raw = raw.split('=', 1)[1].strip()\n    # 去除前後的單引號或雙引號\n    raw = raw.strip('\\'\"')\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.removeInvalidParentheses(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate a virtual code flow for solving \"Remove Invalid Parentheses\" problem. Steps: Start, compute left and right removal counts by scanning. Use DFS/backtracking to generate valid strings. Use set to store results to avoid duplicates. Use recursion with index, leftCount, rightCount, openCount. Use pruning: if too many left or right. Build string builder. When finished, add to set if index==len and openCount==0. Return set as list.\n\nWe need to output each line with arrow and explanation. Use Start, End. Use Decision.\n\nWe need to produce pseudo-code, not real code. Use step format: \"→ Step X: ...\" but the example shows using Step 1 etc. We can just produce generic steps: Step 1: Calculate leftRem, rightRem. Step 2: Define DFS function. Step 3: Call DFS. Step 4: Convert set to list. End.\n\nWe need to use arrows and indentation for decisions. Provide simple explanation.\n\nWe need to output each line with format: \"虛擬碼步驟 // 解釋\". So each line has a virtual code step then a space then comment with explanation.\n\nWe need to use arrows: \"→\". For decisions use \"Decision:\" and Yes/No branches.\n\nWe need to ensure it's clear and follows format.\n\nWe'll output as:\n\nStart // 程式開始執行\n\n→ Step 1: Calculate leftRem and rightRem by scanning s // Count invalid left & right parentheses\n\n→ Step 2: Define DFS(idx, leftRem, rightRem, openCount, path) // Backtracking helper\n\n→ Step 3: In DFS, if idx == len(s) // Check if reached end of string\n\n    Yes → Decision: If openCount == 0? // Ensure all open parentheses are matched\n\n        Yes → Step 4: Add path to result set // Valid string found\n\n        No  → Step 5: Return // Unmatched open parentheses, invalid\n\n    No  → Step 6: current = s[idx] // Current character\n\n    → Decision: If current == '(' // Handle left parenthesis\n\n        Yes → Decision: If leftRem > 0? // Option to skip it\n\n            Yes → Step 7: DFS(idx+1, leftRem-1, rightRem, openCount, path) // Skip '('\n\n            No  → Step 8: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // Keep '('\n\n        No → Step 9: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // Keep '(' (no removal left)\n\n    No → Decision: If current == ')' // Handle right parenthesis\n\n        Yes → Decision: If rightRem > 0? // Option to skip it\n\n            Yes → Step 10: DFS(idx+1, leftRem, rightRem-1, openCount, path) // Skip ')'\n\n            No  → Step 11: Decision: If openCount > 0? // Can match with an open\n\n                Yes → Step 12: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // Keep ')'\n\n                No  → Step 13: Return // No open to match, invalid\n\n        No → Decision: If openCount > 0? // Must match with an open\n\n            Yes → Step 14: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // Keep ')'\n\n            No  → Step 15: Return // Unmatched ')', invalid\n\n    No → Decision: If current is letter // Non-parenthesis characters\n\n        Yes → Step 16: DFS(idx+1, leftRem, rightRem, openCount, path+current) // Keep character\n\n→ Step 17: Call DFS(0, leftRem, rightRem, 0, \"\") // Initiate backtracking\n\n→ Step 18: Convert result set to list and return // Prepare final answer\n\nEnd // 程式執行結束\n\nNeed to ensure each line with arrow and explanation. Use Chinese explanation. Also use indentation? Example didn't indent but used nested lines with indentation for decisions.\n\nWe can follow same style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Calculate leftRem and rightRem by scanning s // 先統計字串中需要刪除的左括號與右括號數量  \n→ Step 2: Define DFS(idx, leftRem, rightRem, openCount, path) // 建立回溯輔助函式  \n→ Step 3: In DFS, if idx == len(s) // 檢查是否已經遍歷完字串  \n  Yes → Decision: If openCount == 0? // 確認所有左括號已配對  \n   Yes → Step 4: Add path to result set // 找到合法字串，加入結果  \n   No  → Step 5: Return // 未配對的左括號，為非法字串  \n  No  → Step 6: current = s[idx] // 取得目前字元  \n  → Decision: If current == '(' // 處理左括號  \n   Yes → Decision: If leftRem > 0? // 可選擇刪除此左括號  \n    Yes → Step 7: DFS(idx+1, leftRem-1, rightRem, openCount, path) // 刪除 '('  \n    No  → Step 8: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // 保留 '('  \n   No → Step 9: DFS(idx+1, leftRem, rightRem, openCount+1, path+'(') // 無需刪除，直接保留  \n  → Decision: If current == ')' // 處理右括號  \n   Yes → Decision: If rightRem > 0? // 可選擇刪除此右括號  \n    Yes → Step 10: DFS(idx+1, leftRem, rightRem-1, openCount, path) // 刪除 ')'  \n    No  → Decision: If openCount > 0? // 需要配對左括號  \n     Yes → Step 11: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // 保留 ')'  \n     No  → Step 12: Return // 沒有左括號可配對，非法字串  \n   No → Decision: If openCount > 0? // 必須有左括號可配對  \n    Yes → Step 13: DFS(idx+1, leftRem, rightRem, openCount-1, path+')') // 保留 ')'  \n    No  → Step 14: Return // 未配對的右括號，非法字串  \n  → Decision: If current is letter // 非括號字元  \n   Yes → Step 15: DFS(idx+1, leftRem, rightRem, openCount, path+current) // 直接保留  \n→ Step 16: Call DFS(0, leftRem, rightRem, 0, \"\") // 開始回溯搜尋  \n→ Step 17: Convert result set to list and return // 產生最終答案列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Unique Substrings in Wraparound String",
      "source_file": "Leetcode/leetcode467.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '3'"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '7'\n--- (Raw) ---\nRaw Expected: '6'\nRaw Got:      '7'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_unique_wraparound_substrings(s: str) -> int:\n    \"\"\"\n    計算字串 s 中所有在無限環繞字母表「abcdefghijklmnopqrstuvwxyz」中出現\n    的非空子字串的個數。只需要考慮以每個字母結尾的最大連續子字串長度，\n    然後將這些長度相加即可得到唯一子字串總數。\n    \"\"\"\n    # dp[i] 代表以 chr(i + ord('a')) 結尾的最大連續子字串長度\n    dp = [0] * 26\n    cur_len = 0  # 當前連續子字串長度\n\n    for i, ch in enumerate(s):\n        # 如果是第一個字母或與前一個字母不是連續的，就重置長度\n        if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n            cur_len += 1\n        else:\n            cur_len = 1\n        idx = ord(ch) - ord('a')\n        dp[idx] = max(dp[idx], cur_len)\n\n    return sum(dp)\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，假設輸入形如：s = \"cac\"\n    raw_input = sys.stdin.read()\n    # 只提取小寫英文字母，忽略其他字符\n    s = ''.join(re.findall('[a-z]', raw_input))\n    result = count_unique_wraparound_substrings(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: count unique non-empty substrings of s that appear in the infinite wraparound string of alphabet. Known solution: track longest suffix ending with each letter, then sum lengths.\n\nSo produce steps: initialize array of 26 zeros. For i over s: track current streak length if current char is consecutive to previous in alphabet (including wrap). Update max for current char. After loop sum.\n\nWe need to produce line-by-line virtual code with comments. Use Start, End, Decision. Provide step labels. Use arrow notation.\n\nLet's draft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化字母表長度陣列 maxLen[26] 為 0 // 用於存儲以每個字母結尾的最大子字串長度  \n→ Step 2: 設定 prevChar ← '' // 上一個字母，初始為空  \n→ Step 3: 設定 currentLen ← 0 // 當前連續子字串長度  \n→ Decision: 是否還有字母 s[i] 在字符串 s ？ // 開始遍歷 s  \n Yes → Step 4: 取當前字母 curChar ← s[i] // 取得 s 的第 i 個字母  \n  Decision: 是否 prevChar 為空 或 curChar 與 prevChar 是字母表順序相鄰？ // 檢查是否可延續  \n   Yes → Step 5: currentLen ← currentLen + 1 // 連續長度加一  \n   No  → Step 6: currentLen ← 1 // 重新開始長度  \n  Step 7: 更新 maxLen[curChar] ← max(maxLen[curChar], currentLen) // 保存以 curChar 結尾的最大長度  \n  Step 8: prevChar ← curChar // 更新上一個字母  \n  → Decision: 是否已到 s 的結尾？  \n   Yes → Step 9: sum ← 0 // 用於累加答案  \n    → For 每個字母 idx 在 0..25  \n      sum ← sum + maxLen[idx] // 加總所有最大長度  \n      → End For  \n     → Step 10: 輸出 sum // 結果即為唯一非空子字串個數  \n     → End // 結束流程  \n    No  → 回到 Decision: 是否還有字母 s[i] 在字符串 s ？ // 繼續遍歷  \n  No  → End // 若第一次迴圈結束，直接結束  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        \"\"\"Return all unique subsets of nums (nums may contain duplicates).\"\"\"\n        nums.sort()                # Sort to group duplicates together\n        res = [[]]                 # Start with the empty subset\n\n        for num in nums:\n            # For each existing subset, create a new subset that includes num\n            new_subsets = [subset + [num] for subset in res]\n            res += new_subsets    # Append new subsets to the result list\n\n        # Remove duplicate subsets that might have been created when nums had duplicates\n        unique_res = []\n        seen = set()\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique_res.append(subset)\n\n        return unique_res\n\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract the list of integers from a string like 'nums = [1,2,2]'.\n    \"\"\"\n    # Find the first '[' and the matching ']'\n    start = data.find('[')\n    if start == -1:\n        raise ValueError(\"Input does not contain a list.\")\n    end = data.rfind(']')\n    if end == -1:\n        raise ValueError(\"Input does not contain a closing ']'.\")\n\n    list_str = data[start:end+1]\n    # Use ast.literal_eval for safe evaluation\n    return ast.literal_eval(list_str)\n\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n\n    try:\n        nums = parse_input(raw_input)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.subsetsWithDup(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step-by-step for generating all subsets of a multiset (array may contain duplicates) with no duplicate subsets. Classic approach: sort array, backtracking, skip duplicates. Provide lines with \"Start\", \"→ Step\", \"Decision:\" etc.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋/說明\". Use arrow etc. Ensure step by step. Use Start and End. No actual code.\n\nWe produce lines like:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先排序以便於跳過重複元素\n→ Step 2: Initialize result list with empty subset // 開始時包含空集\n→ Step 3: Define recursive function backtrack(index, current) // 回溯函數\n    → Decision: 是否已到達陣列末尾? // 判斷是否完成一個子集\n        Yes → Step 4: 複製 current 並加入 result // 將子集加入結果\n        No  → Decision: 先不選取 nums[index]?\n            Yes → Step 5: Call backtrack(index+1, current) // 跳過該元素\n            No  → Step 6: 添加 nums[index] 至 current\n                → Step 7: Call backtrack(index+1, current) // 選取該元素\n                → Step 8: 移除最後一個元素從 current // 回溯\n                → Decision: 若 index>0 且 nums[index]==nums[index-1]?\n                    Yes → Step 9: 回傳 (skip following duplicates) // 跳過重複選取\n                    No  → // 继续\nWait, need proper handling: typical algorithm: for each i from start to end: if i>start and nums[i]==nums[i-1] skip; else add nums[i] and rec backtrack(i+1). So maybe better to implement iteration inside backtrack rather than two decisions.\n\nSimplify: Use iterative approach: For each index, decide to include or skip, but skip duplicates by checking if current index>start and same as previous and not included before? Another typical approach: At each recursion, iterate i from start to n-1: if i>start && nums[i]==nums[i-1] continue; choose nums[i], add to path, backtrack(i+1), backtrack ends, pop.\n\nThus we produce pseudo-code accordingly.\n\nWe need to show each line of pseudo-code with explanation. Use arrows.\n\nLet's produce:\n\nStart\n→ Step 1: Sort nums ascending // 先排序方便跳過重複\n→ Step 2: Initialize result as list containing empty list // 空集始終是子集\n→ Step 3: Call DFS(startIndex=0, currentPath=[]) // 開始回溯\n    → Step 4: Append copy of currentPath to result // 將當前子集加入結果\n    → Step 5: For i from startIndex to length(nums)-1\n        → Decision: 是否已處理完所有元素? // 迴圈控制\n            No → Step 6: Decision: i>startIndex 且 nums[i]==nums[i-1]?\n                Yes → Step 7: Continue // 跳過重複元素，避免重複子集\n                No  → Step 8: Append nums[i] to currentPath // 選取此元素\n                    → Step 9: Call DFS(i+1, currentPath) // 進入下一層\n                    → Step 10: Remove last element from currentPath // 回溯\nEnd\n\nNeed to ensure each line is \"虛擬碼步驟 // 解釋\". Use \"→\" for steps and decisions. Indent inside recursion but just plain lines. The indentation can be shown by indentation spaces. The decisions use \"Decision:\".\n\nLet's write accordingly.\n\nMake sure no actual code but pseudo steps.\n\nWill produce final answer in Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將輸入陣列排序，方便後續跳過重複元素  \n→ Step 2: Initialize result as list containing empty list // 空集始終是合法子集，先加入結果集合  \n→ Step 3: Call DFS(startIndex = 0, currentPath = []) // 開始遞迴回溯  \n    → Step 4: Append copy of currentPath to result // 把目前路徑的子集加入結果  \n    → Step 5: For i from startIndex to length(nums) - 1 // 逐個嘗試把每個元素加入子集  \n        → Decision: i > startIndex AND nums[i] == nums[i-1]? // 檢查是否為重複元素且不在本層首次選擇  \n            Yes → Step 6: Continue // 跳過重複的選擇，避免產生重複子集  \n            No  → Step 7: Append nums[i] to currentPath // 選取該元素，擴展目前子集  \n                → Step 8: Call DFS(i + 1, currentPath) // 進一步探討更深層的子集  \n                → Step 9: Remove last element from currentPath // 回溯，移除剛才加入的元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays",
      "source_file": "Leetcode/leetcode349.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[9,4]'\nGot (Norm):      '[4,9]'\n--- (Raw) ---\nRaw Expected: '[9,4]'\nRaw Got:      '[4,9]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        # 將兩個陣列轉成集合，再取交集，最後轉成 list\n        return list(set(nums1) & set(nums2))\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 先找出所有中括號內的字串（假設第一個是 nums1，第二個是 nums2）\n    brackets = re.findall(r'\\[.*?\\]', data)\n    if len(brackets) >= 2:\n        nums1 = ast.literal_eval(brackets[0])\n        nums2 = ast.literal_eval(brackets[1])\n    else:\n        nums1, nums2 = [], []\n\n    sol = Solution()\n    res = sol.intersection(nums1, nums2)\n    # 為了輸出結果順序可預測，先排序\n    res.sort()\n    # 自訂輸出格式，避免 Python print 之間有空格\n    output = '[' + ','.join(map(str, res)) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. We need to process intersection of two integer arrays, unique elements, order arbitrary. Approach: convert arrays to sets, compute intersection. Steps: Start, Step1 convert nums1 to set1, Step2 convert nums2 to set2, Step3 compute intersectionSet = set1 ∩ set2, Step4 convert to list or array, Step5 return result. Use virtual code style with arrow.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize SetA with elements from nums1 // Build set from first array\n→ Step 2: Initialize SetB with elements from nums2 // Build set from second array\n→ Step 3: Initialize ResultSet as empty set // Prepare container for intersection\n→ Decision: For each element x in SetA // Iterate over first set\n    → Step 4: If x exists in SetB // Check presence in second set\n        Yes → Step 5: Add x to ResultSet // Add to intersection set\n        No → // Do nothing\nEnd // Done\n→ Step 6: Convert ResultSet to array // Prepare output\n→ Step 7: Return the array // Provide final intersection\n\nBut we must keep structure with arrows. Use arrow style: \"→ Step 1:\" etc. And include decision lines. Use Yes/No arrows. Use Start and End. Let's format.\n\nMake sure each line includes explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 SetA，將 nums1 之所有元素加入 // 建立第一個集合  \n→ Step 2: 建立 SetB，將 nums2 之所有元素加入 // 建立第二個集合  \n→ Step 3: 建立空集合 ResultSet // 用於存放交集元素  \n→ Decision: 針對 SetA 中每個元素 x // 循環遍歷第一集合  \n  Yes → Step 4: 若 x 存在於 SetB // 檢查第二集合是否包含該元素  \n   Yes → Step 5: 將 x 加入 ResultSet // 將交集元素加入結果集合  \n   No  → // 不執行任何操作  \nEnd // 迴圈結束  \n→ Step 6: 將 ResultSet 轉換成陣列 // 準備輸出資料結構  \n→ Step 7: 回傳陣列 // 返回唯一交集元素的結果"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,4,0,4]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 4, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    \"\"\"\n    Solution class for random picking of indices.\n    \"\"\"\n    def __init__(self, nums):\n        \"\"\"\n        初始化，將每個數值對應到其所有索引的位置。\n        \"\"\"\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        \"\"\"\n        從 nums 中所有等於 target 的索引中隨機挑選一個返回。\n        \"\"\"\n        return random.choice(self.num_indices[target])\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析方法調用序列，執行並輸出結果。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入包裝成 JSON 數組，方便解析\n    wrapped = f'[{data}]'\n    try:\n        methods, args_list = json.loads(wrapped)\n    except json.JSONDecodeError:\n        # 若已經是合法 JSON，直接解析\n        methods, args_list = json.loads(data)\n\n    outputs = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # args 形如 [[1, 2, 3]]，取第一個元素作為 nums\n            obj = Solution(args[0])\n            outputs.append(None)\n        elif method == \"pick\":\n            # args 形如 [3]，取第一個元素作為 target\n            result = obj.pick(args[0])\n            outputs.append(result)\n\n    # 輸出結果為 JSON 數組\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation, no actual code, just step-by-step logic. The requirements: implement Solution class with constructor and pick method, need to store mapping from target to list of indices, or use reservoir sampling? Since we want equal probability. Approach: In constructor, build hash map from value to list of indices. In pick, retrieve list, pick random index from list. Provide steps.\n\nSo virtual code: Start, Step1: Initialize Solution(nums): Build dictionary mapping number to list of indices. End of constructor. Then pick method: Input target. Retrieve list. Determine length. Generate random integer in [0, len-1]. Return list[randomIndex].\n\nWe need to use virtual code with arrows and decisions. But simple steps. Could also incorporate Decision: If target not in map? but assumption it's present.\n\nLet's craft steps.\n\nUse arrow to show method entry, etc. Provide explanation after each line.\n\nAlso need to show Start/End for entire process? We can show separate flows for constructor and pick. Maybe overall flow Start, → Step: Define class Solution, etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 宣告 Solution 類別\n→ Step 2: 在 constructor 內宣告 map<value, list<indices>> // 建立映射表\n→ Step 3: 循環遍歷 nums, 將索引加入對應 value 的 list // 將每個數字的索引儲存\n→ Step 4: 結束 constructor // 構造完成\n→ Step 5: 定義 pick(target) 方法 // pick 方法入口\n→ Decision: target 是否在 map? // 檢查 target 是否存在\n    Yes → Step 6: 取出 indices list // 取得該目標數字的索引列表\n    No  → Step 7: 直接返回 -1 // (根據假設此分支不會執行)\n→ Step 8: 計算 list 長度 n // 取得有效索引數\n→ Step 9: 生成隨機整數 r 在 [0, n-1] // 隨機選取\n→ Step 10: 回傳 indices[r] // 返回隨機索引\nEnd // 程式執行結束\n\nBut we need \"逐行\" with \"虛擬碼步驟\" + \" // 解釋\". Use arrow or Decision. Also maybe use Step numbers. Provide explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Solution // 宣告 Solution 類別  \n→ Step 2: 在 constructor 內宣告 map<value, list<indices>> // 建立數值到索引列表的映射表  \n→ Step 3: 循環遍歷 nums, 將每個索引 i 加入 map[nums[i]] 的 list // 把所有索引按數值分類  \n→ Step 4: 結束 constructor // 物件初始化完成  \n\n→ Step 5: 定義 pick(target) 方法 // Pick 方法入口  \n→ Decision: target 是否在 map? // 確認目標值已存在（根據假設此分支永遠為 Yes）  \n  Yes → Step 6: 取出 indices list = map[target] // 取得對應目標的所有索引  \n  No  → Step 7: 回傳 -1 // 當 target 未找到時的備用回傳值（理論上不會執行）  \n\n→ Step 8: 計算 n = indices.length // 獲取列表長度  \n→ Step 9: 生成隨機整數 r 在 [0, n-1] // 隨機選擇一個位置  \n→ Step 10: 回傳 indices[r] // 返回被隨機選中的索引  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"Sort characters in string `s` by decreasing frequency.\"\"\"\n        freq = Counter(s)                     # Count each character\n        # most_common returns list sorted by count descending\n        return ''.join([char * count for char, count in freq.most_common()])\n\ndef parse_input(raw: str) -> str:\n    \"\"\"Extract the string value from the raw stdin input.\"\"\"\n    raw = raw.strip()\n    if not raw:\n        return ''\n    # Look for an equals sign to separate variable name and value\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        raw = value.strip()\n    # Remove surrounding quotes if present\n    if (raw.startswith('\"') and raw.endswith('\"')) or (raw.startswith(\"'\") and raw.endswith(\"'\")):\n        raw = raw[1:-1]\n    return raw\n\ndef main():\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Need to adhere to format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrows, Start, End, Decision:. Provide steps: start, input string, count frequencies, create list of pairs char and count, sort by count descending, build result string. Also handle multiple answers any. Use no actual code.\n\nOk. Use steps like:\n\nStart\n→ Step 1: input s // get string\n→ Step 2: create frequency map // count occurrences\n→ Step 3: convert map to list of (char, count) // to sort\n→ Step 4: sort list by count descending // order by freq\n→ Step 5: build result string by repeating each char count times // construct output\n→ Step 6: return result string // output\nEnd\n\nBut need Decision maybe? Not really. But we can include decision for empty string.\n\nWe should produce each line. Each line must contain virtual code and explanation.\n\nWe should use arrow symbols like →. Provide Start and End. Use Decision? optional.\n\nWill produce like:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 從使用者處讀取要排序的字串\n→ Step 2: 建立空頻率映射 freqMap // 用於儲存每個字符的出現次數\n→ Step 3: For each char c in s → freqMap[c] += 1 // 逐字計算頻率\n→ Step 4: 若 s 為空字符串? // 檢查是否需要特別處理\n    Yes → Return \"\" // 空字串直接返回\n    No  → ...\n→ Step 5: 將 freqMap 轉換為列表 pairs = [(c, count) …] // 方便排序\n→ Step 6: 按照 count 進行降序排序 pairs // 以頻率高到低排列\n→ Step 7: 建立結果字符串 result = \"\" // 初始空字符串\n→ Step 8: For each (c, count) in pairs → result += c * count // 重複字符 count 次\n→ Step 9: Return result // 回傳排序後的字串\nEnd // 程式執行結束\n\nNeed to ensure each line ends with // explanation. Also Decision with arrows. Use arrow in Decision: \"Decision:\" then indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者處讀取要排序的字串  \n→ Step 2: 建立空頻率映射 freqMap // 用於儲存每個字符的出現次數  \n→ Step 3: For each char c in s → freqMap[c] += 1 // 逐字計算頻率  \n→ Decision: s 是否為空字串? // 檢查是否需要特別處理  \n    Yes → Return \"\" // 空字串直接返回，流程結束  \n    No  → // 繼續後續步驟  \n→ Step 4: 將 freqMap 轉換為列表 pairs = [(c, count) …] // 方便排序  \n→ Step 5: 按照 count 進行降序排序 pairs // 以頻率高到低排列  \n→ Step 6: 建立結果字符串 result = \"\" // 初始空字符串  \n→ Step 7: For each (c, count) in pairs → result += c * count // 重複字符 count 次  \n→ Step 8: Return result // 回傳排序後的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Best Time to Buy and Sell Stock IV",
      "source_file": "Leetcode/leetcode188.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjlkmybis.py\", line 33, in <module>\n    prices = ast.literal_eval(parts[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpbcqnop35.py\", line 33, in <module>\n    prices = ast.literal_eval(parts[1])\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [3\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        # If k is large enough, it is equivalent to unlimited transactions\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        # DP approach for limited transactions\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]  # best value of (profit from previous transaction - price)\n            for d in range(1, n):\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # Normalize the input string\n    normalized = raw_input.replace('k =', '').replace('prices =', '').replace(' ', '')\n    parts = normalized.split(',')\n    k = int(parts[0])\n    prices = ast.literal_eval(parts[1])\n    result = Solution().maxProfit(k, prices)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving stock profit with at most k transactions. It's typical DP: dp[transaction][day] for max profit up to day with at most transaction transactions. We can use two loops. Pseudocode. Must produce step-by-step lines with explanations.\n\nWe output each line as \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide loops.\n\nLet's produce:\n\nStart\n→ Initialize dp array size (k+1) × n with 0 // set base profits\n→ For transaction from 1 to k:\n    → maxDiff = -prices[0] // best value of buy - profit so far\n    → For day from 1 to n-1:\n        → dp[transaction][day] = max(dp[transaction][day-1], prices[day] + maxDiff) // either keep previous profit or sell today\n        → maxDiff = max(maxDiff, dp[transaction-1][day] - prices[day]) // update best buy value\n→ Result = dp[k][n-1] // maximum profit\nEnd\n\nBut need line-by-line with arrow and decision. Not many decisions. Could add a decision to handle empty array.\n\nWe'll produce each line with explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 如果 prices 為空或 k = 0? // 檢查輸入是否可進行交易\n    Yes → Step: 返回 0 // 無價格或無交易，直接結束\n    No  → \n→ Step: n ← length(prices) // 取得價格長度\n→ Step: 建立 dp 陣列 (k+1) × n，並全部設為 0 // dp[t][d] 表示在第 d 天完成 t 交易時的最大利潤\n→ Decision: 從 1 到 k 迭代? // 逐步處理每一筆交易\n    Yes →\n        → Step: maxDiff ← -prices[0] // 代表「買入」後的剩餘利潤（即賣價減買價）\n        → Decision: 從 1 到 n-1 迭代? // 逐天更新\n            Yes →\n                → Step: dp[t][d] ← max(dp[t][d-1], prices[d] + maxDiff) // 保留前一日利潤或今天賣出\n                → Step: maxDiff ← max(maxDiff, dp[t-1][d] - prices[d]) // 更新最佳買入時機\n            No →\n        → \n    No →\n→ Step: result ← dp[k][n-1] // 取得完成 k 次交易後的最大利潤\n→ Step: 輸出 result // 顯示結果\nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"\n        找出 DNA 字串中所有長度為 10 且重複出現的子字串。\n        使用兩個集合：seen 儲存已經遇到過的子字串，repeated 儲存已被重複的子字串。\n        \"\"\"\n        seen = set()\n        repeated = set()\n        # 迭代所有可能的長度為 10 的子字串\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    \"\"\"\n    主程式入口：從標準輸入讀取資料、處理並輸出結果。\n    \"\"\"\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 從輸入中提取字串 's = 'AAAA...' 的內容\n    # 支援單引號或雙引號包圍的字串\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", raw_input)\n    if not match:\n        # 若找不到符合格式，視為空字串\n        s = \"\"\n    else:\n        s = match.group(1)\n\n    solution = Solution()\n    result = solution.findRepeatedDnaSequences(s)\n\n    # 以 JSON 格式輸出結果，符合範例要求的雙引號風格\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Problem: find repeated 10-letter-long substrings. Approach: sliding window, hash set and result set. We'll produce algorithm: use set seen, set repeated, iterate i from 0 to len(s)-10. substring s[i:i+10]. If in seen, add to repeated; else add to seen. Then output repeated list. Use data structures. Provide start, end. We'll output lines. Each line: \"虛擬碼步驟 // 解釋\". Use arrow and Decision. We'll produce Start, steps. Ensure not actual code, just virtual. Use bullet: Start // ... etc. Use →. Provide maybe Decision? But algorithm simple. But include Decision step for checking if substring seen. So include Decision. Use Yes/No arrow.\n\nLet's produce.\n\nAlso need End.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空集合 seen 以存放已見到的 10 字母子字串 // 建立已觀察過的集合  \n→ Step 2: 定義空集合 repeated 以存放重複出現的 10 字母子字串 // 建立重複集合  \n→ Step 3: 取得 DNA 字串長度 n // 需要用於迴圈範圍  \n→ Decision: 是否有足夠長度的子字串? // 檢查 n 是否大於等於 10  \n  Yes → Step 4: 循環從 i = 0 到 i = n - 10 // 準備滑動視窗  \n    → Step 5: 提取子字串 current = s[i : i+10] // 取得當前 10 字母序列  \n    → Decision: current 是否已存在於 seen? // 判斷是否已見過  \n      Yes → Step 6: 將 current 加入 repeated // 重複出現，加入結果集合  \n      No → Step 7: 將 current 加入 seen // 新出現，加入已見集合  \n    → End // 迴圈結束  \n  No → Step 8: 重複集合仍為空，無需進一步處理 // 字串長度不足以形成 10 字母序列  \n→ Step 9: 轉換 repeated 集合為列表並返回 // 將結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        產生 nums 的所有排列\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])  # 將目前排列加入結果\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # 回溯交換回原位\n\n        backtrack(0)\n        return res\n\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 期望的輸入格式類似 \"nums = [1,2,3]\"\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    # 以安全方式解析列表\n    try:\n        nums = ast.literal_eval(expr.strip())\n    except Exception:\n        nums = eval(expr.strip())  # 失敗時使用 eval\n\n    sol = Solution()\n    result = sol.permute(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm generating all permutations of distinct integers array. Provide each line with explanation comment. Use Start, End, Decision, arrows. Provide virtual code, not real code. Use each step: input array, recursion/backtracking, building permutations. Use arrow and decisions. Each line separate. Provide explanation. Should be clear. Use Chinese.\n\nLet's craft.\n\nStart // start program\n→ Step 1: Initialize result list // create empty list to store permutations\n→ Step 2: Call backtrack with empty path and visited array // start recursion\nBacktrack Function definition:\n    → Decision: 如果 visited 全部 True? // if all numbers used\n        Yes → Append copy of path to result // add current permutation\n        No  → For each index i in range len(nums)\n               → Decision: 如果 visited[i] 為 False? // if number not used\n                   Yes → Mark visited[i] = True // select number\n                      → Append nums[i] to path // add to current permutation\n                      → Call backtrack recursively\n                      → Remove last element from path // backtrack path\n                      → Mark visited[i] = False // backtrack visited\nEnd // finish\n\nWe need to produce lines as in example. Use arrows. Each line: 虛擬碼步驟 + space + // 解釋\n\nLet's produce step by step. Use Start, End. Indentation maybe. But each line must be separate. For nested structure, we can indent with spaces. For decisions, show Yes → etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize result list // 建立空列表以儲存所有排列  \n→ Step 2: Call backtrack with empty path 和 visited flags set 為 False // 啟動遞迴搜尋  \nBacktrack // 定義遞迴函式  \n → Decision: 所有 visited 為 True? // 判斷是否已選完所有數字  \n  Yes → Append copy of path to result // 完成一組排列，加入結果  \n  No → For each index i from 0 to len(nums)-1 // 逐一嘗試每個未使用的數字  \n   → Decision: visited[i] 為 False? // 檢查此數字是否已被選取  \n    Yes → Mark visited[i] = True // 標記為已選  \n     → Append nums[i] to path // 加入到目前的排列中  \n     → Call backtrack recursively // 深入下一層遞迴  \n     → Remove last element from path // 回溯，移除已選數字  \n     → Mark visited[i] = False // 回溯，恢復未選狀態  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        Floyd's Tortoise and Hare algorithm.\n        \"\"\"\n        # Phase 1: Find intersection point of two runners.\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]          # move one step\n            fast = nums[nums[fast]]    # move two steps\n            if slow == fast:\n                break\n\n        # Phase 2: Find the entrance to the cycle (duplicate number).\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read()\n\n    # Extract all integers from the input string\n    numbers = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # If no numbers were found, exit gracefully\n    if not numbers:\n        sys.exit()\n\n    # The first number is part of the array; the rest are array elements\n    nums = numbers\n\n    # Find and print the duplicate number\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code steps with explanations. Problem: find duplicate number in array of n+1 ints 1..n, only one duplicate, no modify array, constant extra space. Classic solution: Floyd's Tortoise and Hare (cycle detection). Virtual steps: Start, initialize slow, fast pointers at first element; loop to find intersection; then find entrance. Provide step lines.\n\nWe should not output real code but virtual code steps. Use arrows. Use decision. Provide explanation after //.\n\nLet's produce:\n\nStart\n→ Step 1: Set slow = nums[0] // initialize slow pointer to first element\n→ Step 2: Set fast = nums[nums[0]] // initialize fast pointer two steps ahead\n→ Decision: while slow != fast? // loop until pointers meet\n    Yes → Step 3: slow = nums[slow] // move slow one step\n         → Step 4: fast = nums[nums[fast]] // move fast two steps\n         → Decision: continue loop? // keep looping\n    No → // pointers have met; intersection found\n→ Step 5: Set finder = nums[0] // initialize finder at start\n→ Decision: while finder != slow? // move both one step\n    Yes → Step 6: finder = nums[finder] // move finder one step\n         → Step 7: slow = nums[slow] // move slow one step\n         → Decision: continue loop\n    No → // pointers meet at duplicate\n→ Step 8: Return finder // duplicate number found\nEnd\n\nAdd explanations. Provide in required format.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指標為第一個元素  \n→ Step 2: fast ← nums[ nums[0] ] // 初始化快指標兩步先行  \n→ Decision: slow ≠ fast? // 進入循環，尋找相遇點  \n    Yes → Step 3: slow ← nums[slow] // 慢指標移動一步  \n         → Step 4: fast ← nums[ nums[fast] ] // 快指標移動兩步  \n         → Decision: 繼續循環? // 只要未相遇就繼續  \n    No → // 慢指標與快指標相遇，找到循環交點  \n→ Step 5: finder ← nums[0] // 將尋找指標初始化到陣列開頭  \n→ Decision: finder ≠ slow? // 同時移動兩指標，尋找入口  \n    Yes → Step 6: finder ← nums[finder] // 尋找指標移動一步  \n         → Step 7: slow ← nums[slow] // 慢指標也移動一步  \n         → Decision: 繼續移動? // 直到兩指標相遇  \n    No → // finder 與 slow 相遇於重複數值  \n→ Step 8: Return finder // 回傳重複的數值  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 用 list 存儲所有元素，支持隨機存取\n        self.data = []\n        # 用 dict 將每個值映射到它在 data 中的索引集合\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        # 把值插到 data 的末尾\n        self.data.append(val)\n        # 把新的索引加入映射\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此值之前不存在，返回 True；否則返回 False\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        # 若此值不存在或映射集合為空，無法移除\n        if not self.idx_map[val]:\n            return False\n        # 從索引集合取出任意一個要刪除的索引\n        remove_idx = self.idx_map[val].pop()\n        # 取出 data 的最後一個元素\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n        # 若不是把自己移除，就把最後一個元素搬到 remove_idx\n        if remove_idx != last_idx:\n            self.data[remove_idx] = last_val\n            # 更新 last_val 的索引集合\n            self.idx_map[last_val].add(remove_idx)\n            self.idx_map[last_val].discard(last_idx)\n        # 移除最後一個元素\n        self.data.pop()\n        # 若此值的索引集合已空，從映射中刪除該鍵\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        # 隨機選取一個索引並返回對應值\n        return random.choice(self.data)\n\ndef parse_input(raw: str):\n    \"\"\"\n    解析輸入，返回兩個列表：operations 與 arguments。\n    支援兩種格式：\n      1. 兩行分開\n      2. 單行，兩個列表以 ',' 分隔\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return [], []\n\n    # 嘗試分離兩個列表\n    # 先檢查是否存在 '],[' 作為分隔\n    if '],[' in raw:\n        parts = raw.split('],[')\n        ops_part = parts[0] + ']'\n        args_part = '[' + parts[1]\n    elif ',' in raw:\n        # 可能是以 '], ' 分隔\n        parts = raw.split('],', 1)\n        ops_part = parts[0] + ']'\n        args_part = parts[1].strip()\n        if not args_part.startswith('['):\n            # 可能沒有完整括號\n            args_part = '[' + args_part\n    else:\n        # 單行沒有分隔符，嘗試逐行\n        lines = raw.splitlines()\n        if len(lines) >= 2:\n            ops_part, args_part = lines[0].strip(), lines[1].strip()\n        else:\n            # 直接作為兩個列表\n            ops_part, args_part = raw, '[]'\n\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n\n    result = []\n    rc = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            rc = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            res = rc.insert(arg[0])\n            result.append(res)\n        elif op == \"remove\":\n            res = rc.remove(arg[0])\n            result.append(res)\n        elif op == \"getRandom\":\n            res = rc.getRandom()\n            result.append(res)\n        else:\n            # 若遇到未知操作，加入 None\n            result.append(None)\n\n    # 輸出 JSON 格式，符合 LeetCode 的輸出風格\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code lines with comments in Chinese. The steps: initialization, insert, remove, getRandom. Use Start, End, Decision. Provide step-by-step pseudo-code. Each line includes code and // explanation. Should use arrows. Need to be linear time. We'll present algorithm using vector and hash map value->set of indices. Use list. Steps.\n\nLet's produce pseudo-code for entire class: initialization, insert, remove, getRandom. We'll break into steps.\n\nMake pseudo-code: Start RandomizedCollection // init\n→ Step: Initialize array list, hashmap, counter maybe.\nThen each function with its own steps.\n\nWe'll produce pseudo-code lines as per format. Ensure each line includes code and comment. Use arrow for transitions. Use Decision with Yes → No →. Ensure each line uses arrow or Start/End.\n\nLet's draft.\n...done thinking.\n\nStart RandomizedCollection // 初始化空的 RandomizedCollection\n→ Step 1: Create empty list `vals` to store all elements // 用於儲存所有值，支持隨機存取\n→ Step 2: Create empty map `idx` mapping value → set of indices in `vals` // 方便 O(1) 插入與刪除\n→ Step 3: Initialize random number generator // 用於 getRandom\n\n// ----------------- 插入 (insert) -----------------\nStart insert(val) // 插入一個值\n→ Decision: 如果 val 未在 idx 中? // 檢查是否為新值\n    Yes → Step 4: 在 idx[val] 創建空集合 // 為新值初始化索引集合\n→ Step 5: 將 val 加入 `vals` 的末尾 // O(1) append\n→ Step 6: 取得新索引 `pos = len(vals)-1` // 位置索引\n→ Step 7: 將 pos 加入 idx[val] 的集合 // 更新索引集合\n→ Decision: 如果 val 原本不存在? // 判斷是否首次插入\n    Yes → Step 8: 回傳 true // 新元素成功插入\n    No  → Step 9: 回傳 false // 已存在，僅多餘一次插入\n\n// ----------------- 刪除 (remove) -----------------\nStart remove(val) // 刪除一個值\n→ Decision: 如果 val 不在 idx 或 idx[val] 為空? // 檢查是否存在\n    Yes → Step 10: 回傳 false // 無此值，無法刪除\n    No  → Step 11: 從 idx[val] 的集合取出任一索引 `remove_idx` // 取出待刪除位置\n→ Step 12: 取得 `last_val = vals[-1]` // 取最後一個元素\n→ Step 13: 取 `last_idx = len(vals)-1` // 最後元素索引\n→ Decision: 如果 remove_idx != last_idx? // 是否需要交換\n    Yes → Step 14: 替換 `vals[remove_idx] = last_val` // 交換位置\n    → Step 15: 更新 idx[last_val]：刪除 last_idx，加入 remove_idx // 更新索引集合\n→ Step 16: 刪除 `vals` 的最後一個元素 // O(1) pop\n→ Step 17: 在 idx[val] 的集合中移除 remove_idx // 刪除索引\n→ Decision: idx[val] 是否為空? // 刪除後是否還剩值\n    Yes → Step 18: 刪除 idx[val] // 清除空集合\n→ Step 19: 回傳 true // 刪除成功\n\n// ----------------- 隨機取值 (getRandom) -----------------\nStart getRandom() // 取得隨機元素\n→ Step 20: 產生隨機索引 `r = rand(0, len(vals)-1)` // 隨機選取\n→ Step 21: 回傳 vals[r] // 返回隨機元素\n\nEnd // RandomizedCollection 完整流程結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass MedianFinder:\n    def __init__(self):\n        # 最大堆（用負值模擬）存儲較小的一半數值\n        self.small = []\n        # 最小堆存儲較大的一半數值\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 將新數字先放入最大堆\n        heapq.heappush(self.small, -num)\n        # 若兩堆之間的最大值與最小值交叉，交換它們\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        # 保持兩堆大小平衡：左堆可比右堆多一個\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離操作列表和參數列表\n    idx = data.find('],')\n    ops_str = data[:idx + 1]        # 包含第一個列表的結尾\n    args_str = data[idx + 2:].strip()  # 跳過 ', '\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    obj = None\n    outputs = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            outputs.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            outputs.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            outputs.append(median)\n        else:\n            # 若有未知操作，視為錯誤但此處簡化為 None\n            outputs.append(None)\n\n    # 轉換 None 為 null，其他數值保持原樣\n    result_strs = ['null' if v is None else str(v) for v in outputs]\n    print('[' + ', '.join(result_strs) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing MedianFinder with methods: constructor, addNum, findMedian. Use data structure of two heaps: max-heap for lower half, min-heap for upper half. Keep sizes balanced: len(maxheap) == len(minheap) or len(maxheap) == len(minheap)+1. In addNum, push into one heap then adjust. findMedian returns top of maxheap if odd else average of tops.\n\nWe need to produce virtual code lines with explanation. Use Start, End. Use arrow. Provide each line.\n\nLet's structure:\n\nStart\n→ Step: 初始化最大堆（maxHeap）和最小堆（minHeap） // 用於存儲左半和右半數據\n→ Step: addNum(num) // 新增數字\n    → Decision: 若 maxHeap 為空 或 num <= maxHeap.top? // 判斷應放入哪個堆\n        Yes → Step: maxHeap.push(num) // 放入左半\n        No  → Step: minHeap.push(num) // 放入右半\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 左堆是否過大\n        Yes → Step: minHeap.push(maxHeap.top()) // 右堆移一個\n        No → Decision: minHeap.size() > maxHeap.size()? // 右堆是否過大\n            Yes → Step: maxHeap.push(minHeap.top()) // 左堆移一個\n            No → // 兩堆已平衡\n    → End // addNum結束\n→ Step: findMedian() // 計算中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量是否相等\n        Yes → Step: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均\n        No  → Step: median = maxHeap.top() // 左堆多一個元素\n    → Step: return median\nEnd\n\nBut must adhere to format: each line with \"虛擬碼步驟 [space] // 解釋\".\n\nAlso use arrow \"→\". For decisions, indent accordingly.\n\nWe need to show Start and End. Each line includes step. For decisions, use Decision:. Indent lines under decision with tabs or spaces.\n\nLet's produce final. Use lines:\n\nStart // 程式開始執行\n→ Step: 初始化最大堆 (maxHeap) 與最小堆 (minHeap) // 用於存儲左半與右半數值\n→ Step: addNum(num) // 新增數字至資料結構\n    → Decision: 若 maxHeap 為空 或 num <= maxHeap.top()? // 判斷數字屬於左半還是右半\n        Yes → Step: maxHeap.push(num) // 放入左半堆\n        No  → Step: minHeap.push(num) // 放入右半堆\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 左堆是否過大\n        Yes → Step: minHeap.push(maxHeap.top()) // 從左堆轉移一個到右堆\n        No → Decision: minHeap.size() > maxHeap.size()? // 右堆是否過大\n            Yes → Step: maxHeap.push(minHeap.top()) // 從右堆轉移一個到左堆\n            No → // 堆已平衡\n    → End // addNum 完成\n→ Step: findMedian() // 取得目前中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量是否相等\n        Yes → Step: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩中間值\n        No  → Step: median = maxHeap.top() // 左堆多一個，取其頂值\n    → Step: return median // 回傳中位數\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". Also maybe each decision block lines indent with 4 spaces. Provide as above.\n\nCheck formatting: each line ends with //.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: 初始化最大堆 (maxHeap) 與最小堆 (minHeap) // 用於存儲左半與右半數值\n→ Step: addNum(num) // 新增數字至資料結構\n    → Decision: 若 maxHeap 為空 或 num <= maxHeap.top()? // 判斷數字屬於左半還是右半\n        Yes → Step: maxHeap.push(num) // 放入左半堆\n        No  → Step: minHeap.push(num) // 放入右半堆\n    → Decision: maxHeap.size() > minHeap.size() + 1? // 左堆是否過大\n        Yes → Step: minHeap.push(maxHeap.top()) // 從左堆轉移一個到右堆\n        No → Decision: minHeap.size() > maxHeap.size()? // 右堆是否過大\n            Yes → Step: maxHeap.push(minHeap.top()) // 從右堆轉移一個到左堆\n            No → // 堆已平衡\n    → End // addNum 完成\n→ Step: findMedian() // 取得目前中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 數量是否相等\n        Yes → Step: median = (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩中間值\n        No  → Step: median = maxHeap.top() // 左堆多一個，取其頂值\n    → Step: return median // 回傳中位數\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwgiusyha.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpwgiusyha.py\", line 38, in main\n    intervals = eval(matches[0])\n                ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,3]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdx5l8ik6.py\", line 46, in <module>\n    main()\n  File \"/tmp/tmpdx5l8ik6.py\", line 38, in main\n    intervals = eval(matches[0])\n                ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1,2]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that end before the new interval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged interval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 找出兩個列表字串\n    matches = re.findall(r'\\[.*?\\]', data)\n    if len(matches) < 2:\n        print([])\n        return\n    intervals = eval(matches[0])\n    newInterval = eval(matches[1])\n\n    sol = Solution()\n    merged = sol.insert(intervals, newInterval)\n    print(merged)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for merging intervals. Provide steps: iterate over intervals, add before, merge, after. Provide decisions. Use virtual code syntax.\n\nLet's outline algorithm:\n\n1. Create result list.\n2. For each interval in intervals:\n   - if interval.end < newInterval.start: no overlap, and before new interval: add to result.\n   - else if interval.start > newInterval.end: no overlap, after new interval: add newInterval if not added, then add rest intervals.\n   - else overlapping: merge: newInterval.start = min(newInterval.start, interval.start); newInterval.end = max(newInterval.end, interval.end).\n3. After loop, if newInterval not added, add it.\n4. Return result.\n\nWe need virtual code line by line. Use arrows. Include decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 result 為空列表 // 用於儲存最終區間\n→ Step 2: 設 flag newAdded 為 False // 標記是否已將 newInterval 加入\n→ Decision: for each interval in intervals? // 迭代所有給定區間\n   Yes → Step 3: 取得 interval.start, interval.end // 讀取當前區間邊界\n   → Decision: interval.end < newInterval.start? // 在新區間前且無重疊\n       Yes → Step 4: 將 interval 加入 result // 直接加入\n       No  → Decision: interval.start > newInterval.end? // 在新區間後且無重疊\n           Yes → Decision: newAdded? // 是否已加入新區間\n               Yes → Step 5: 將 interval 加入 result // 新區間已加入，直接加入\n               No  → Step 6: 將 newInterval 加入 result // 新區間未加入，先加入\n                     → Step 7: newAdded = True // 標記已加入\n                     → Step 8: 將 interval 加入 result // 然後加入當前區間\n           No  → Step 9: newInterval.start = min(newInterval.start, interval.start) // 兩區間重疊，合併起始點\n                 → Step 10: newInterval.end = max(newInterval.end, interval.end) // 合併終止點\n→ Decision: 循環結束後是否已加入新區間? // 判斷最後是否還需要加入\n   Yes → Step 11: End // 已加入，直接結束\n   No  → Step 12: 將 newInterval 加入 result // 仍未加入，追加\n→ End // 回傳 result\n\nBut we need format: each line with `虛擬碼步驟 [空格] // 解釋`. Also need arrow `→`. We can use indentation maybe. Let's craft.\n\nStart // 程式開始執行\n→ Step 1: result ← [] // 建立結果列表\n→ Step 2: newAdded ← False // 標記是否已加入新區間\n→ Decision: For each interval in intervals? // 逐一遍歷所有區間\n    Yes → Step 3: curStart ← interval[0]; curEnd ← interval[1] // 取得當前區間\n    → Decision: curEnd < newInterval[0]? // 在新區間之前且不重疊\n        Yes → Step 4: Append interval to result // 直接加入結果\n        No  → Decision: curStart > newInterval[1]? // 在新區間之後且不重疊\n            Yes → Decision: newAdded? // 是否已加入新區間\n                Yes → Step 5: Append interval to result // 新區間已加入，直接加入\n                No  → Step 6: Append newInterval to result; newAdded ← True // 加入新區間\n                    → Step 7: Append interval to result // 再加入當前區間\n            No  → Step 8: newInterval[0] ← min(newInterval[0], curStart) // 合併起點\n                → Step 9: newInterval[1] ← max(newInterval[1], curEnd) // 合併終點\n→ Decision: newAdded? // 循環結束後檢查是否還需加入\n    Yes → End // 已加入，結束\n    No  → Step 10: Append newInterval to result // 仍未加入，追加\n→ End // 回傳結果\n\nWe need each line with virtual code. Use `Start`, `End`. Indentation not necessary but good.\n\nMake sure to use correct arrow. We'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: result ← [] // 建立結果列表\n→ Step 2: newAdded ← False // 標記是否已加入新區間\n→ Decision: For each interval in intervals? // 逐一遍歷所有區間\n    Yes → Step 3: curStart ← interval[0]; curEnd ← interval[1] // 取得當前區間的開始與結束\n    → Decision: curEnd < newInterval[0]? // 區間位於新區間之前且無重疊\n        Yes → Step 4: Append interval to result // 直接加入結果\n        No  → Decision: curStart > newInterval[1]? // 區間位於新區間之後且無重疊\n            Yes → Decision: newAdded? // 是否已將新區間加入\n                Yes → Step 5: Append interval to result // 新區間已加入，直接加入此區間\n                No  → Step 6: Append newInterval to result; newAdded ← True // 加入新區間並標記已加入\n                    → Step 7: Append interval to result // 再加入當前區間\n            No  → Step 8: newInterval[0] ← min(newInterval[0], curStart) // 合併重疊區間的起點\n                → Step 9: newInterval[1] ← max(newInterval[1], curEnd) // 合併重疊區間的終點\n→ Decision: newAdded? // 迴圈結束後檢查是否仍需加入新區間\n    Yes → End // 已加入，程式結束\n    No  → Step 10: Append newInterval to result // 新區間仍未加入，追加至結果\n→ End // 回傳最終合併後的區間列表"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"Group anagrams from a list of strings.\"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part after '=' if present\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n    else:\n        list_part = data\n    list_part = list_part.strip()\n\n    # Safely evaluate the list string\n    try:\n        strs = ast.literal_eval(list_part)\n    except Exception:\n        # If evaluation fails, treat as empty list\n        strs = []\n\n    # Ensure we have a list of strings\n    if not isinstance(strs, list):\n        strs = []\n\n    # Group anagrams and output as JSON\n    sol = Solution()\n    result = sol.groupAnagrams(strs)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step with explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and structure Start, Decision, End. So produce algorithm for grouping anagrams: For each string, sort characters to form key, add string to hash map. After processing, output values. Steps: Start, declare map, for each str in strs: sort string, key, add to map; after loop: create result list, for each entry in map: add list to result; End.\n\nWe should produce each line separately with explanation. Use arrow \"→\". Should we use \"Step 1:\"? Yes. We'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的雜湊表 hashMap<String, List<String>> // 用於以排序後的字串作為鍵，存放同類型的字串\n→ Step 2: 對輸入陣列 strs 中的每個字串 str 做以下處理 // 逐一處理每個字串\n    → Step 2a: 把 str 的字元排序得到 sortedStr // 產生 anagram 的共通鍵\n    → Step 2b: 如果 hashMap 沒有鍵 sortedStr 則新增一個空的 list // 初始化 bucket\n    → Step 2c: 把 str 加入 hashMap[sortedStr] 的 list // 將字串放進對應 bucket\n→ Step 3: 建立一個空的結果 list result // 用於收集所有 bucket\n→ Step 4: 對 hashMap 的每個 entry 做以下處理\n    → Step 4a: 把 entry.value 加入 result // 將同類型字串組合加入結果\n→ End // 程式結束\n\nBut we need to follow format: each line has the arrow or Start, then comment. Use indentation? They didn't specify indentation, but example shows indentation for nested decisions. We can show indentation with spaces. Use Decision if needed. Here no decision except maybe if key not exists. But we can just mention.\n\nWe'll produce each line.\n\nLet's output in traditional Chinese.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 建立一個空的雜湊表 hashMap<String, List<String>> // 用於以排序後的字串作為鍵，存放同類型的字串\n→ Step 2: 對輸入陣列 strs 中的每個字串 str 做以下處理 // 逐一處理每個字串\n    → Step 2a: 取得 str 的字元排序後的字串 sortedStr // 產生 anagram 的共通鍵\n    → Step 2b: 若 hashMap 尚無鍵 sortedStr，則新增一個空的 list // 初始化 bucket\n    → Step 2c: 把 str 加入 hashMap[sortedStr] 的 list // 將字串放進對應 bucket\n→ Step 3: 建立一個空的結果 list result // 用於收集所有 bucket\n→ Step 4: 對 hashMap 的每個 entry 做以下處理\n    → Step 4a: 把 entry.value 加入 result // 將同類型字串組合加入結果\n→ End // 程式執行結束\n\nThat meets format.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個空的雜湊表 hashMap<String, List<String>> // 用於以排序後的字串作為鍵，存放同類型的字串  \n→ Step 2: 對輸入陣列 strs 中的每個字串 str 做以下處理 // 逐一處理每個字串  \n  → Step 2a: 取得 str 的字元排序後的字串 sortedStr // 產生 anagram 的共通鍵  \n  → Step 2b: 若 hashMap 尚無鍵 sortedStr，則新增一個空的 list // 初始化 bucket  \n  → Step 2c: 把 str 加入 hashMap[sortedStr] 的 list // 將字串放進對應 bucket  \n→ Step 3: 建立一個空的結果 list result // 用於收集所有 bucket  \n→ Step 4: 對 hashMap 的每個 entry 做以下處理  \n  → Step 4a: 把 entry.value 加入 result // 將同類型字串組合加入結果  \n→ End // 程式執行結束"
    },
    {
      "title": "LRU Cache",
      "source_file": "Leetcode/leetcode146.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move key to end to mark as recently used\n        value = self.cache.pop(key)\n        self.cache[key] = value\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # popitem(last=False) pops the first item (least recently used)\n            self.cache.popitem(last=False)\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # Input format: operations list and arguments list separated by comma\n    # Wrap the whole string in brackets to parse as a list of two elements\n    data = ast.literal_eval(f'[{raw}]')\n    ops, args = data[0], data[1]\n\n    result = []\n    cache = None\n\n    for op, arg in zip(ops, args):\n        if op == \"LRUCache\":\n            cache = LRUCache(arg[0])\n            result.append(None)          # constructor returns null\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            result.append(None)          # put returns null\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            result.append(val)\n        else:\n            # Unsupported operation; append None\n            result.append(None)\n\n    # Print results as a Python list literal\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code lines, each line with a comment after space. We must not output actual code. Just pseudo. Steps: Start, initialize data structures: doubly linked list, hash map. Implement get: check map, if not found return -1; else move node to front, return value. Put: check if key exists: update value, move to front; else add new node to front, add to map; if size > capacity, remove tail, delete from map. End. Use Decision lines for conditional checks.\n\nWe need to be concise but clear. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義雙向鏈表節點類 Node(key, value) // 每個節點存儲鍵值及指向前後節點  \n→ Step 2: 初始化 hash map key→Node // 用於 O(1) 查找  \n→ Step 3: 建立雙向鏈表頭 dummyHead 與尾 dummyTail，將 dummyHead.next 指向 dummyTail，dummyTail.prev 指向 dummyHead // 方便插入與刪除  \n→ Step 4: 設置變量 capacity、size 0 // 保存容量與目前大小  \n\n// get 操作  \n→ Step 5: Define get(key) // 查詢指定鍵  \n→ Decision: 如果 key 在 hash map?  \n  Yes → Step 6: node ← map[key] // 找到節點  \n   → Step 7: Remove node from its current position // O(1) 拆除  \n   → Step 8: Insert node right after dummyHead // O(1) 放到最近使用位置  \n   → Step 9: Return node.value // 返回值  \n  No  → Step 10: Return -1 // 鍵不存在  \n\n// put 操作  \n→ Step 11: Define put(key, value) // 插入或更新  \n→ Decision: 如果 key 在 hash map?  \n  Yes → Step 12: node ← map[key] // 找到節點  \n   → Step 13: node.value ← value // 更新值  \n   → Step 14: Remove node from its current position  \n   → Step 15: Insert node right after dummyHead // 更新為最近使用  \n  No  → Step 16: node ← new Node(key, value) // 建立新節點  \n   → Step 17: Insert node right after dummyHead  \n   → Step 18: map[key] ← node // 加入映射  \n   → Step 19: size ← size + 1 // 增加大小  \n   → Decision: 如果 size > capacity?  \n    Yes → Step 20: tailNode ← dummyTail.prev // 最舊節點  \n     → Step 21: Remove tailNode from list  \n     → Step 22: Delete map[tailNode.key] // 從映射中刪除  \n     → Step 23: size ← size - 1 // 減少大小  \n    No  → Step 24: // 不需要裁剪  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1994'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1994'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n                     'C': 100, 'D': 500, 'M': 1000}\n        total = 0\n        prev = 0\n        for ch in reversed(s):\n            val = roman_map[ch]\n            if val < prev:\n                total -= val\n            else:\n                total += val\n            prev = val\n        return total\n\ndef extract_roman(input_data: str) -> str:\n    \"\"\"提取輸入中的羅馬數字字串。\"\"\"\n    input_data = input_data.strip()\n    # 先搜尋雙引號中的內容\n    first_quote = input_data.find('\"')\n    if first_quote != -1:\n        second_quote = input_data.find('\"', first_quote + 1)\n        if second_quote != -1:\n            return input_data[first_quote + 1:second_quote]\n    # 若沒有雙引號，直接使用最後一個單詞，去除可能的引號\n    tokens = input_data.split()\n    if tokens:\n        last = tokens[-1]\n        return last.strip('\"')\n    return \"\"\n\ndef main():\n    raw_input = sys.stdin.read()\n    roman_str = extract_roman(raw_input)\n    if not roman_str:\n        return\n    sol = Solution()\n    result = sol.romanToInt(roman_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting Roman numeral to integer. We must output step by step, with each line containing \"虛擬碼步驟\" then space then \"// 解釋\". Use arrows and structure: Start, End, Decision: etc. Each line must be separate. No actual code, just pseudo.\n\nLet's craft the algorithm: iterate through string, mapping characters to values. When a smaller value before larger indicates subtraction, subtract else add. Approach: for each character i from 0 to n-1, if i < n-1 and value[i] < value[i+1] then total -= value[i] else total += value[i]. At end output total.\n\nAlso could use dictionary for values.\n\nLet's produce pseudo steps:\n\nStart // 程式開始執行\n→ Step 1: 定義字典 roman_map: { 'I':1, 'V':5, ... } // mapping Roman chars to values\n→ Step 2: 初始化 total = 0 // 儲存計算結果\n→ Step 3: 取得輸入字串 s // 需要轉換的羅馬數字\n→ Step 4: 迴圈 i 從 0 到 len(s)-1 // 遍歷每個字符\n   → Decision: i < len(s)-1 AND roman_map[s[i]] < roman_map[s[i+1]]? // 判斷是否為減法情形\n        Yes → Step 5a: total -= roman_map[s[i]] // 小於後面大值，做減法\n        No  → Step 5b: total += roman_map[s[i]] // 否則加上\n→ Step 6: 迴圈結束 // 完成所有字符處理\n→ Step 7: 輸出 total // 回傳整數結果\nEnd // 程式執行結束\n\nWe must ensure each line has \"虛擬碼步驟\" then space then \"// 解釋\". Use arrow characters. Use \"→\" for next steps, \"Decision:\" etc.\n\nLet's format each line accordingly. For nested decision, indent? The example shows indentation using spaces before lines. We'll mimic that.\n\nImportant: We cannot include actual code. Just pseudo text like \"Define roman_map\" etc. Use Chinese explanatory comments.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義字典 roman_map // 建立羅馬字母與其數值對應\n→ Step 2: 初始化 total = 0 // 儲存最終的整數結果\n→ Step 3: 取得輸入字串 s // 需要轉換的羅馬數字\n→ Step 4: 迴圈 i 從 0 到 len(s)-1 // 逐個處理字母\n    → Decision: i < len(s)-1 AND roman_map[s[i]] < roman_map[s[i+1]]? // 判斷是否為減法情形\n        Yes → Step 5a: total -= roman_map[s[i]] // 小於後面大值，執行減法\n        No  → Step 5b: total += roman_map[s[i]] // 否則執行加法\n→ Step 6: 迴圈結束 // 所有字母已處理完畢\n→ Step 7: 輸出 total // 返回轉換後的整數\nEnd // 程式執行結束\n\nCheck formatting: each line should have \"虛擬碼步驟\" plus space then comment. But we use \"→ Step X:\" etc. It's okay. Each line includes the arrow, but after the arrow we include the step description. Then comment.\n\nMake sure no line merges. Let's list each line separately.\n\nWe'll use indentation for nested steps, as example shows. Use 4 spaces indent before nested steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義字典 roman_map // 建立羅馬字母與其數值對應  \n→ Step 2: 初始化 total = 0 // 儲存最終的整數結果  \n→ Step 3: 取得輸入字串 s // 需要轉換的羅馬數字  \n→ Step 4: 迴圈 i 從 0 到 len(s)-1 // 逐個處理字母  \n    → Decision: i < len(s)-1 AND roman_map[s[i]] < roman_map[s[i+1]]? // 判斷是否為減法情形  \n        Yes → Step 5a: total -= roman_map[s[i]] // 小於後面大值，執行減法  \n        No  → Step 5b: total += roman_map[s[i]] // 否則執行加法  \n→ Step 6: 迴圈結束 // 所有字母已處理完畢  \n→ Step 7: 輸出 total // 返回轉換後的整數  \nEnd // 程式執行結束"
    },
    {
      "title": "Design Add and Search Words Data Structure",
      "source_file": "Leetcode/leetcode211.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp9_rxadac.py\", line 42, in <module>\n    ops, args_list = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 85 (char 84)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, idx: int) -> bool:\n            if idx == len(word):\n                return node.is_end\n            ch = word[idx]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, idx + 1):\n                        return True\n                return False\n            else:\n                if ch not in node.children:\n                    return False\n                return dfs(node.children[ch], idx + 1)\n        return dfs(self.root, 0)\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    ops, args_list = json.loads(data)\n\n    results = []\n    wd = None\n    for op, args in zip(ops, args_list):\n        if op == \"WordDictionary\":\n            wd = WordDictionary()\n            results.append(None)\n        elif op == \"addWord\":\n            wd.addWord(args[0])\n            results.append(None)\n        elif op == \"search\":\n            results.append(wd.search(args[0]))\n    # Output results as JSON array\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing WordDictionary with addWord and search with wildcard '.' using likely a Trie with DFS search. Provide each line step with explanation. Use the arrow structure. Start → Step etc. Provide each step. Should include decision nodes for wildcard search recursion. Also include addWord steps building trie. Should be clear but not actual code. Each line with // explanation. Ensure \"虛擬碼步驟\" maybe like \"Start\" etc. Use Start, End, Decision. Should include branching for '.'.\n\nWe need to produce a step-by-step algorithm. Let's outline:\n\nStart\n→ Initialize root node with children map and isWord flag false // root of trie\n\n→ Function addWord(word)\n    → Set current = root\n    → For each char c in word\n        → If current.children does not contain c\n            → Create new node for c\n        → Move current to child c\n    → After loop, set current.isWord = true // mark end of word\n\n→ Function search(word)\n    → Return DFS(root, index 0)\n    → Define DFS(node, idx)\n        → If idx == word.length\n            → Return node.isWord\n        → Let char = word[idx]\n        → If char != '.'\n            → If node.children does not contain char\n                → Return false\n            → Else return DFS(node.children[char], idx+1)\n        → Else // char == '.'\n            → For each child in node.children\n                → If DFS(child, idx+1) true return true\n            → Return false\n\nEnd\n\nNow produce as virtual code lines with each step. Each line must have \"虛擬碼步驟\" then space then comment. Use arrow as indicated: \"→ Step ...\".\n\nAlso must include decision structure: Decision: ... Yes → ... No → ...\n\nUse arrow \"Yes →\" etc. For loops maybe \"→ For each\". Might not require decisions inside loops. For DFS recursion, use Decision: char == '.'? etc. Let's craft accordingly.\n\nRemember each line needs \"虛擬碼步驟\" (like \"Start\") then space then comment. Actually the requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line: \"Start // 程式開始執行\". So no arrow? Wait arrow used inside structure: \"→\". So the first line is \"Start\". For next line we prefix arrow: \"→ Step ...\". So each line includes the arrow as part of the virtual code. That is okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 root 節點，擁有空的 children 映射和 isWord = false // 建立 Trie 根  \n→ Step 2: 定義 addWord(word) 函式  \n    → Step 2.1: 設 current = root // 以根節點開始  \n    → Step 2.2: For each char c in word  \n        → Decision: current.children 是否含 c? // 判斷是否已有子節點  \n            Yes → Step 2.3: current = current.children[c] // 直接移動到該子節點  \n            No  → Step 2.4: 建立新節點並加入 current.children[c] // 建立缺失節點  \n    → Step 2.5: current.isWord = true // 標記單詞結束位置  \n→ Step 3: 定義 search(word) 函式  \n    → Step 3.1: 返回 DFS(root, 0) // 從根節點開始深度優先搜尋  \n    → Step 3.2: 定義 DFS(node, idx)  \n        → Decision: idx == word.length? // 搜尋是否到字串尾  \n            Yes → Step 3.2.1: 返回 node.isWord // 若正好到尾，判斷是否為完整單詞  \n            No  → Step 3.2.2: let ch = word[idx] // 取得目前字元  \n                → Decision: ch == '.'? // 判斷是否為萬用字元  \n                    Yes → Step 3.2.2.1: For each child in node.children  \n                        → Step 3.2.2.1.1: If DFS(child, idx+1) then return true // 任何子節點匹配即成功  \n                    No  → Step 3.2.2.2: Decision: node.children 是否含 ch? // 檢查指定字元是否存在  \n                        Yes → Step 3.2.2.2.1: 返回 DFS(node.children[ch], idx+1) // 進入對應子節點繼續搜尋  \n                        No  → Step 3.2.2.2.2: 返回 false // 沒有對應字元，搜尋失敗  \n→ End // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[6]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[6]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[2,2]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[2, 2]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[2,4,5]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[2, 4, 5]'"
        }
      ],
      "generated_code": "import random\nimport re\nimport sys\n\ndef rand7():\n    \"\"\"Generate a uniform random integer in [1, 7] using Python's random module.\"\"\"\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        \"\"\"Generate a uniform random integer in [1, 10] using only rand7().\"\"\"\n        while True:\n            # Combine two calls to rand7() to produce a uniform integer in [1, 49]\n            num = (rand7() - 1) * 7 + rand7()  # 1 ~ 49\n            if num <= 40:\n                # Map 1 ~ 40 to 1 ~ 10\n                return 1 + (num - 1) % 10\n\ndef main():\n    # Read the entire input and extract the first integer found\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        print([])\n        return\n\n    match = re.search(r'\\d+', input_data)\n    n = int(match.group()) if match else 0\n\n    solution = Solution()\n    results = [solution.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to create rand10() using rand7() uniformly. Standard approach: generate numbers 1-49 using two rand7 calls (like 7*7=49), then map 1-40 to 1-10 (by modulo 10). If >40, reject and repeat. Or can generate 1-63 using 3 calls, etc. The simplest: two calls produce 7*7=49. Use rejection for >40. Implementation: loop until valid. Pseudocode.\n\nNeed to output each line with step and explanation, using Start, Decision, Yes/No arrows. Let's produce:\n\nStart\n→ Step 1: 定義函式 rand10() // 開始定義\n→ Decision: 需要重複? // 進入循環\n    Yes → Step 2: Call rand7() → x // 取得第一個隨機數\n    Yes → Step 3: Call rand7() → y // 取得第二個隨機數\n    Yes → Step 4: 計算 num = (x-1)*7 + y // 將兩個數轉為 1-49\n    Yes → Decision: 如果 num <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: 返回 (num-1)%10 + 1 // 產生 1-10\n        No  → Step 6: 重複循環 // 重新生成\nEnd\n\nBut need to structure loops properly. Use Decision: 重複? Yes → Continue. But we can express loop as Decision: num <=40? Yes→ return else → repeat. Use Start and End.\n\nLet's produce virtual steps:\n\nStart\n→ Step 1: 定義 rand10() // 函式開始\n→ Decision: 是否已獲得有效數? // 判斷是否需要重複\n    No  → Step 2: x ← rand7() // 第一次呼叫\n    No  → Step 3: y ← rand7() // 第二次呼叫\n    No  → Step 4: num ← (x-1)*7 + y // 組合成 1-49\n    No  → Decision: num <= 40? // 是否可映射\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 產生 1-10\n        Yes → Step 6: return result // 結束\n        No  → Step 7: 回到 Decision: 是否已獲得有效數? // 重複循環\nEnd\n\nBut we need to use Yes/No arrows properly. Let's define:\n\nStart\n→ Step 1: 函式 rand10() // 開始\n→ Decision: 是否已獲得有效結果? // 初始不\n    No → Step 2: x ← rand7() // 取得第一個隨機數\n    No → Step 3: y ← rand7() // 取得第二個隨機數\n    No → Step 4: num ← (x-1)*7 + y // 轉成 1-49\n    No → Decision: num <= 40? // 可接受？\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 產生 1-10\n        Yes → Step 6: return result // 結束\n        No  → Step 7: 回到 Decision: 是否已獲得有效結果? // 循環\n\nEnd\n\nBut we need to incorporate arrow Yes →, No →. The \"回到 Decision\" can be represented by a jump back: No → Step 7: goto Decision: 是否已獲得有效結果? But maybe we can structure as loop: Decision: num <= 40? Yes→ return, No→ repeat. So we don't need \"是否已獲得有效結果?\" but just a loop.\n\nBetter:\n\nStart\n→ Step 1: 定義 rand10() // 開始定義\n→ Decision: 無效結果? // 循環判斷\n    No  → Step 2: x ← rand7() // 呼叫 rand7()\n    No  → Step 3: y ← rand7() // 呼叫 rand7()\n    No  → Step 4: num ← (x-1)*7 + y // 產生 1-49\n    No  → Decision: num <= 40? // 是否在可接受範圍\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 將 1-40 映射為 1-10\n        Yes → Step 6: return result // 結束\n        No  → Step 7: 返回到 Decision: 無效結果? // 重複\n\nEnd\n\nBut we need to make sure the virtual code arrow formatting: Use `→`, `Yes →`, `No →`. Also indent for nested decision. Use spaces. Example:\n\n→ Decision: num <= 40? \n    Yes → Step 5...\n    No  → Step 7: 循環\n\nBut we also need to show that Step 7 goes back to the outer Decision (which is the start of loop). But we can express it as `No → Step 2: ...` but we want to show the loop. Let's use a label `LoopStart` or just use the outer Decision as loop. So after No, we can jump to Step 2. So:\n\n→ Decision: num <= 40? \n    Yes → Step 5: ...\n    Yes → Step 6: return\n    No  → Step 2: x ← rand7() // 回到開始\n\nBut that duplicates step. But we can do that.\n\nAlternatively, use `→ Decision: num <= 40?` inside loop and if No → go back to `Step 2`.\n\nLet's produce the final code. Must maintain each line separate. Use indent for nested decisions. Provide short explanation. Use Chinese. Ensure not to output actual code. Use \"虛擬碼步驟\" plus explanation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立 rand10() 的流程\n→ Decision: 是否已得到有效結果? // 進入重複判斷\n    No  → Step 2: x ← rand7() // 呼叫 rand7() 取得第一個隨機數\n    No  → Step 3: y ← rand7() // 呼叫 rand7() 取得第二個隨機數\n    No  → Step 4: num ← (x-1)*7 + y // 將兩個數映射為 1-49\n    No  → Decision: num <= 40? // 檢查是否落在可接受範圍\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 轉成 1-10\n        Yes → Step 6: return result // 回傳結果，結束函式\n        No  → Step 2: x ← rand7() // 超過 40，重新開始循環\nEnd // 程式執行結束\n\nWe need to ensure the structure: the No arrow for Step 2 duplicates, but that's okay.\n\nAlso, we need to use \"Yes →\" and \"No →\" arrows correctly. Provide explanation for each line. This meets requirement.\n\nLet's provide final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 rand10() // 建立 rand10() 的流程\n→ Decision: 是否已得到有效結果? // 進入重複判斷\n    No  → Step 2: x ← rand7() // 呼叫 rand7() 取得第一個隨機數\n    No  → Step 3: y ← rand7() // 呼叫 rand7() 取得第二個隨機數\n    No  → Step 4: num ← (x-1)*7 + y // 將兩個數映射為 1-49\n    No  → Decision: num <= 40? // 檢查是否落在可接受範圍\n        Yes → Step 5: result ← (num-1) mod 10 + 1 // 轉成 1-10\n        Yes → Step 6: return result // 回傳結果，結束函式\n        No  → Step 2: x ← rand7() // 超過 40，重新開始循環\nEnd // 程式執行結束"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      '[\"1+2+3\", \"1*2*3\"]'"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      '[\"2+3*2\", \"2*3+2\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not num_match or not target_match:\n        print(\"[]\")\n        sys.exit()\n    num = num_match.group(1)\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate all expressions that evaluate to target. Use DFS/backtracking. Provide line-by-line steps with explanation. Use Start, Decision, etc. Should be concise. No actual code. Just steps.\n\nWe need to output in Chinese. Use step format: Start, → Step 1, etc. Use decision. Provide explanation after //.\n\nWe'll produce like:\n\nStart // 程式開始\n→ Step 1: 定義回溯函式 DFS(index, path, evaluated, last_operand) // 進行深度優先搜索\n→ Decision: 是否已達到字串末尾? // 檢查是否處理完所有數字\n    Yes → Decision: evaluated 是否等於目標? // 檢查累計值是否符合目標\n        Yes → Step 2: 將 path 加入結果列表 // 找到合法表達式\n        No → Step 3: 直接返回 // 不是目標，不存儲\n    No → Step 4: 對於從 index 開始到字串長度的每個結束位置 i // 取子串作為下一個操作數\n        → Step 5: 取得子串 num[index:i+1] 作為 current_str // 獲取操作數字串\n        → Decision: current_str 是否以 '0' 開頭且長度 > 1? // 避免前導零\n            Yes → Step 6: 續迴下一個 i // 跳過含前導零的子串\n            No → Step 7: 轉換為整數 current_val = int(current_str) // 解析數字\n                → Decision: index 是否為 0? // 第一個操作數\n                    Yes → Step 8: 呼叫 DFS(i+1, current_str, current_val, current_val) // 開始表達式\n                    No → Step 9: 嘗試 '+': 呼叫 DFS(i+1, path+'+'+current_str, evaluated+current_val, current_val)\n                    No → Step 10: 嘗試 '-': 呼叫 DFS(i+1, path+'-'+current_str, evaluated-current_val, -current_val)\n                    No → Step 11: 嘗試 '*': 呼叫 DFS(i+1, path+'*'+current_str, evaluated - last_operand + last_operand*current_val, last_operand*current_val)\nEnd // 程式結束\n\nWe should include the explanation. Also maybe mention result list. That's fine. Ensure each line has explanation. Use arrow for decisions.\n\nLet's format accordingly. Use Start, End. Provide lines. Ensure Chinese explanation after //. Ensure each line ends with // 解釋.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義回溯函式 DFS(index, path, evaluated, last_operand) // 建立深度優先搜尋的參數  \n→ Decision: 是否已達到字串末尾? // 檢查是否處理完所有數字  \n  Yes → Decision: evaluated 是否等於目標? // 判斷累計值是否符合目標  \n    Yes → Step 2: 將 path 加入結果列表 // 找到合法表達式，加入結果  \n    No  → Step 3: 直接返回 // 不是目標值，停止此路徑  \n  No  → Step 4: 從 index 開始遍歷每個結束位置 i 以形成下一個操作數 // 產生子串  \n    → Step 5: 取得子串 num[index:i+1] 作為 current_str // 獲取下一個操作數字串  \n    → Decision: current_str 是否以 '0' 開頭且長度 > 1? // 避免前導零  \n     Yes → Step 6: 續迴下一個 i // 跳過含前導零的子串  \n     No  → Step 7: 轉換為整數 current_val = int(current_str) // 解析數字  \n      → Decision: index 是否為 0? // 判斷是否為第一個操作數  \n       Yes → Step 8: 呼叫 DFS(i+1, current_str, current_val, current_val) // 開始表達式  \n       No  → Step 9: 嘗試 '+': 呼叫 DFS(i+1, path+'+'+current_str, evaluated+current_val, current_val) // 加號操作  \n       No  → Step 10: 嘗試 '-': 呼叫 DFS(i+1, path+'-'+current_str, evaluated-current_val, -current_val) // 減號操作  \n       No  → Step 11: 嘗試 '*': 呼叫 DFS(i+1, path+'*'+current_str, evaluated - last_operand + last_operand*current_val, last_operand*current_val) // 乘法操作，調整累計與上一次操作數  \nEnd // 程式執行結束"
    },
    {
      "title": "Two Sum II - Input Array Is Sorted",
      "source_file": "Leetcode/leetcode167.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxmn9oefz.py\", line 44, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxmn9oefz.py\", line 32, in parse_input\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp5bwsfek1.py\", line 44, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp5bwsfek1.py\", line 32, in parse_input\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [2\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkvo607w1.py\", line 44, in <module>\n    numbers, target = parse_input(raw_input)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkvo607w1.py\", line 32, in parse_input\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [-1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"\n        Find two indices (1‑based) in a sorted list that sum to target.\n        Uses the two‑pointer technique, O(1) extra space.\n        \"\"\"\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            s = numbers[left] + numbers[right]\n            if s == target:\n                return [left + 1, right + 1]\n            elif s < target:\n                left += 1\n            else:\n                right -= 1\n        # The problem guarantees exactly one solution, so this line\n        # will never be reached. It's kept for completeness.\n        return []\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parses a string like:\n        'numbers = [2,7,11,15], target = 9'\n    and returns (numbers, target).\n    \"\"\"\n    parts = input_str.split(',')\n    # Extract the list part after 'numbers ='\n    numbers_part = parts[0].split('=', 1)[1].strip()\n    numbers = ast.literal_eval(numbers_part)  # safe eval for list\n\n    # Extract the target part after 'target ='\n    target_part = parts[1].split('=', 1)[1].strip()\n    target = int(target_part)\n    return numbers, target\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    numbers, target = parse_input(raw_input)\n    solution = Solution()\n    indices = solution.twoSum(numbers, target)\n    # Output in the required format without spaces\n    print(f'[{indices[0]},{indices[1]}]')",
      "virtual_code": "Thinking...\nWe need to produce virtual code for the two-sum problem using sorted array, two-pointer method, constant space. Must use virtual code steps with arrows etc. Provide each line with explanation comment after space. Need to output in Traditional Chinese. Each line \"虛擬碼步驟\" then a space then \"// 解釋/說明\". Use Start, End, Decision, etc. Provide line numbers? Not necessary. Just lines.\n\nWe should include step for initializing two pointers left=0, right=length-1. Then loop while left<right. Compute sum. Decision: if sum==target return [left+1, right+1]. If sum<target left++. If sum>target right--. End when found. End.\n\nEnsure constant space. Provide explanation.\n\nLet's produce.\n\nUse arrows: \"→\" preceding steps. For decisions use \"Decision:\" then indent.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 設定 left = 0, right = numbers.length - 1 // 左指標指向最左端，右指標指向最右端\n→ Decision: 左指標是否小於右指標? // 判斷是否仍有未檢查的組合\n    Yes → Step 2: 計算 currentSum = numbers[left] + numbers[right] // 取得目前兩個數字之和\n    → Decision: currentSum 是否等於 target? // 判斷是否找到符合條件的兩數\n        Yes → Step 3: 回傳 [left + 1, right + 1] // 加上 1 轉換為 1‑index，輸出結果\n        No  → Decision: currentSum 是否小於 target? // 若不等於，決定移動哪一個指標\n            Yes → Step 4: left = left + 1 // sum 小於目標，左指標右移尋找更大的數\n            No  → Step 5: right = right - 1 // sum 大於目標，右指標左移尋找更小的數\n    No → Continue loop // 回到 Decision: 左指標是否小於右指標? 的判斷\nEnd // 程式執行結束\n\nBut need indentation: We have nested decisions. We should use indentation spaces maybe 4 spaces per indent. Provide \"Yes →\" etc. We should include \"Continue loop\" maybe not necessary because loop goes automatically. Could use \"Go back to start of loop\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 left = 0, right = numbers.length - 1 // 左指標指向最左端，右指標指向最右端  \n→ Decision: 左指標是否小於右指標? // 判斷是否仍有未檢查的組合  \n    Yes → Step 2: 計算 currentSum = numbers[left] + numbers[right] // 取得目前兩個數字之和  \n    → Decision: currentSum 是否等於 target? // 判斷是否找到符合條件的兩數  \n        Yes → Step 3: 回傳 [left + 1, right + 1] // 加上 1 轉換為 1‑index，輸出結果  \n        No  → Decision: currentSum 是否小於 target? // 若不等於，決定移動哪一個指標  \n            Yes → Step 4: left = left + 1 // sum 小於目標，左指標右移尋找更大的數  \n            No  → Step 5: right = right - 1 // sum 大於目標，右指標左移尋找更小的數  \n    No → Continue loop // 回到 Decision: 左指標是否小於右指標? 的判斷  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearranges nums in-place to satisfy nums[0] < nums[1] > nums[2] < nums[3] ...\n        \"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            # If i is odd we need nums[i-1] < nums[i]\n            # If i is even we need nums[i-1] > nums[i]\n            if (i % 2 == 1 and nums[i-1] >= nums[i]) or \\\n               (i % 2 == 0 and nums[i-1] <= nums[i]):\n                nums[i-1], nums[i] = nums[i], nums[i-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list expression after '=' or use the whole input if no '='\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    # Safely evaluate the list\n    nums = ast.literal_eval(expr.strip())\n\n    Solution().wiggleSort(nums)\n    print(nums)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo code) line by line with explanation. The algorithm: given array, reorder to wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] ... Standard solution: sort array then swap adjacent pairs? Actually typical approach: iterate i from 1 to n-1, if i odd and nums[i-1] >= nums[i], swap; if i even and nums[i-1] <= nums[i], swap. That produces wiggle. Simpler: for i from 1 to len-1, if (i%2==1 && nums[i-1] >= nums[i]) or (i%2==0 && nums[i-1] <= nums[i]) then swap.\n\nThus virtual code steps: Start, Step 1: 取得陣列長度 n. Step 2: 從 i=1 到 n-1 逐步檢查。 Step 3: Decision: i 奇數? Yes -> if nums[i-1] >= nums[i] then swap. No -> i 偶數 -> if nums[i-1] <= nums[i] then swap. Step 4: 迴圈結束. End.\n\nWe need each line with \"虛擬碼步驟 // 解釋\". Use arrow \"→\". The decision lines must use indentation.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Let n be length of nums // 取得陣列長度\n→ Step 2: For i from 1 to n-1 do // 開始迴圈\n    → Decision: i 是奇數? // 判斷索引是否為奇數\n        Yes → Decision: nums[i-1] >= nums[i]? // 若 nums[i-1] >= nums[i]，需要交換\n            Yes → Step 3: Swap(nums[i-1], nums[i]) // 交換\n            No  → // 不做任何事\n        No  → Decision: nums[i-1] <= nums[i]? // 若 i 為偶數且前小於等於後，需要交換\n            Yes → Step 4: Swap(nums[i-1], nums[i]) // 交換\n            No  → // 不做任何事\n→ End // 程式結束\n\nWe should use \"Step 3\" and \"Step 4\" or unify naming. Could use same Step 3 for swap.\n\nAlso need to include the loop bracket: after Step 2, inside the loop. Should represent indentation maybe using tabs? Provide as per example.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n be length of nums // 取得陣列長度  \n→ Step 2: For i from 1 to n-1 do // 開始逐個索引的檢查  \n → Decision: i 是奇數? // 判斷索引是否為奇數  \n  Yes → Decision: nums[i-1] >= nums[i]? // 奇數位置需大於前一個，若不滿足則交換  \n   Yes → Step 3: Swap(nums[i-1], nums[i]) // 交換兩個元素  \n   No  → // 不需要交換  \n  No  → Decision: nums[i-1] <= nums[i]? // 偶數位置需小於前一個，若不滿足則交換  \n   Yes → Step 4: Swap(nums[i-1], nums[i]) // 交換兩個元素  \n   No  → // 不需要交換  \n→ End // 程式執行結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwrpy6y15.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpwrpy6y15.py\", line 54, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpt8lf2c38.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpt8lf2c38.py\", line 54, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpurj6xja4.py\", line 63, in <module>\n    main()\n  File \"/tmp/tmpurj6xja4.py\", line 54, in main\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\n\ndef calc_equation(equations, values, queries):\n    # Build variable to id mapping\n    var_to_id = {}\n    for a, b in equations:\n        if a not in var_to_id:\n            var_to_id[a] = len(var_to_id)\n        if b not in var_to_id:\n            var_to_id[b] = len(var_to_id)\n    n = len(var_to_id)\n\n    parent = list(range(n))\n    weight = [1.0] * n  # weight[x] = x / parent[x]\n\n    def find(x):\n        if parent[x] != x:\n            orig_parent = parent[x]\n            parent[x] = find(parent[x])\n            weight[x] *= weight[orig_parent]\n        return parent[x]\n\n    # Union operations\n    for (a, b), val in zip(equations, values):\n        ida, idb = var_to_id[a], var_to_id[b]\n        root_a = find(ida)\n        root_b = find(idb)\n        if root_a != root_b:\n            # Merge root_a under root_b\n            parent[root_a] = root_b\n            # weight[root_a] = (a / root_a) * (root_a / root_b)\n            # We want a / b = val => (a / root_a) * (root_a / root_b) * (root_b / b) = val\n            # => root_a / root_b = val * weight[idb] / weight[ida]\n            weight[root_a] = val * weight[idb] / weight[ida]\n\n    # Process queries\n    results = []\n    for c, d in queries:\n        if c not in var_to_id or d not in var_to_id:\n            results.append(-1.0)\n            continue\n        ida, idb = var_to_id[c], var_to_id[d]\n        root_c = find(ida)\n        root_d = find(idb)\n        if root_c != root_d:\n            results.append(-1.0)\n        else:\n            results.append(weight[ida] / weight[idb])\n    return results\n\ndef main():\n    data = sys.stdin.read()\n    local_vars = {}\n    exec(data, {}, local_vars)\n    equations = local_vars['equations']\n    values = local_vars['values']\n    queries = local_vars['queries']\n    answers = calc_equation(equations, values, queries)\n    output = '[' + ','.join(f'{ans:.5f}' for ans in answers) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the problem: evaluate division queries given equations and values. It's like LeetCode 399. Approach: use union-find (disjoint set) with ratio weights. Steps: build graph or union find. For each equation Ai / Bi = val, union sets. Query: if either variable unknown or not connected, answer -1. else compute ratio using weight differences. Provide virtual code line by line.\n\nWe need to follow output format: each line \"虛擬碼步驟 // 解釋\". Use arrows and Decision blocks.\n\nWe'll write something like:\n\nStart\n→ Build mapping from variable to index // assign unique index\n→ Initialize parent array size n // DSU parent\n→ Initialize weight array size n // weight to parent (Ai / parent = weight)\n→ For each equation Ai/Bi = val:\n    → Find roots of Ai, Bi\n    → If roots differ:\n        → Union rootA under rootB\n        → Set parent[rootA] = rootB\n        → Set weight[rootA] = val * weight[Bi] / weight[Ai] // formula\n→ Define function find(x) with path compression:\n    → If parent[x] != x:\n        → Original parent = parent[x]\n        → parent[x] = find(parent[x])\n        → weight[x] *= weight[original parent]\n→ For each query C/D:\n    → If C or D not in mapping: add -1\n    → Else find roots\n    → If roots differ: -1\n    → Else answer = weight[C] / weight[D]\n→ End\n\nWe need to produce each line as separate statement. Use arrows for decisions. Provide explanation. We'll include \"Decision:\" for root equality check etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立映射 varToIdx // 為每個變數指派唯一索引\n→ Step 2: 初始化 parent[0..n-1] ← 自己 // DSU 父節點指向自身\n→ Step 3: 初始化 weight[0..n-1] ← 1.0 // weight[x] 表示 x / parent[x] 的比例\n→ Step 4: 針對每個方程式 (Ai, Bi, val):\n    → Step 4a: 找到 Ai 的根 rootA // find(Ai)\n    → Step 4b: 找到 Bi 的根 rootB // find(Bi)\n    → Decision: rootA 與 rootB 是否相同?\n        Yes → Step 4c: 已連結，跳過\n        No  → Step 4d: 合併 rootA 到 rootB\n            → Step 4d1: parent[rootA] ← rootB\n            → Step 4d2: 計算 weight[rootA] ← val * weight[Bi] / weight[Ai] // 使 Ai/Bi = val 成立\n→ Step 5: 定義函式 find(x) // 路徑壓縮\n    → Decision: parent[x] 是否等於 x?\n        Yes → Step 5a: 回傳 x // 已是根節點\n        No  → Step 5b: 原父節點 oldParent ← parent[x]\n            → Step 5c: parent[x] ← find(oldParent) // 递归找到根\n            → Step 5d: weight[x] ← weight[x] * weight[oldParent] // 更新比例\n            → Step 5e: 回傳 parent[x]\n→ Step 6: 針對每個查詢 (Cj, Dj):\n    → Decision: Cj 或 Dj 是否不在 varToIdx?\n        Yes → Step 6a: 結果加入 -1.0 // 未定義變數\n        No  → Step 6b: 找到根 rootC ← find(Cj)\n            → Step 6c: 找到根 rootD ← find(Dj)\n            → Decision: rootC 與 rootD 是否相同?\n                Yes → Step 6d: 結果 = weight[Cj] / weight[Dj] // 計算比值\n                No  → Step 6e: 結果加入 -1.0 // 無連結\n→ End // 程式執行結束"
    },
    {
      "title": "Concatenated Words",
      "source_file": "Leetcode/leetcode472.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 儲存已處理的較短詞\n        word_set = set()\n        result = []\n\n        # 先根據長度排序，確保較短詞已加入 word_set\n        for word in sorted(words, key=len):\n            if not word:          # 跳過空字串\n                continue\n            if self.can_form(word, word_set):\n                result.append(word)\n            word_set.add(word)\n        return result\n\n    def can_form(self, word, word_set):\n        # 斷詞動態規劃：dp[i] 表示 word[:i] 可被完全組合\n        if not word_set:\n            return False\n        dp = [False] * (len(word) + 1)\n        dp[0] = True\n        for i in range(1, len(word) + 1):\n            for j in range(i):\n                if not dp[j]:\n                    continue\n                if word[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(word)]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 若輸入包含「words =」前綴，移除之\n    if data.lower().startswith('words'):\n        idx = data.find('=')\n        if idx != -1:\n            data = data[idx + 1 :].strip()\n\n    # 解析為列表，若失敗則以空格或換行分隔\n    try:\n        words = ast.literal_eval(data)\n    except Exception:\n        words = data.split()\n\n    if not isinstance(words, list):\n        words = [str(words)]\n\n    sol = Solution()\n    result = sol.findAllConcatenatedWordsInADict(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for problem: Given array of strings words without duplicates, return all concatenated words in the list. Need virtual code steps and short explanations per line.\n\nWe'll create algorithm: sort words by length, use a set for words seen, for each word check if can be segmented into two or more words using DP or recursion with memo. Add to result if true. Then add word to set for future use. Use DFS with memo. Or DP.\n\nWe need step-by-step pseudo code.\n\nLet's outline:\n\nStart\n\n→ Initialize result list // store concatenated words\n\n→ Initialize wordSet // empty set\n\n→ Sort words by length ascending // ensures shorter words processed first\n\n→ For each word in words:\n\n    → If canForm(word, wordSet): // check segmentation\n\n        → Append word to result\n\n    → Add word to wordSet\n\n→ Return result\n\nDefine canForm(word, wordSet):\n\n    → Initialize memo dict // for substring results\n\n    → Return helper(0) where helper(index) returns bool\n\n    → helper(i):\n\n        → If i == len(word): return true\n\n        → If i in memo: return memo[i]\n\n        → For j from i+1 to len(word):\n\n            → sub = word[i:j]\n\n            → If sub in wordSet:\n\n                → If helper(j):\n\n                    → memo[i] = true; return true\n\n        → memo[i] = false; return false\n\nBut we need to avoid using word itself in wordSet; since we only added previous words, it's fine.\n\nAlternatively use DP.\n\nWe'll produce lines with arrows and comments. Provide each line.\n\nLet's write pseudo code with steps:\n\nStart // Program start\n\n→ result = [] // list to hold concatenated words\n\n→ wordSet = {} // set for fast lookup of shorter words\n\n→ wordsSorted = sort(words by length ascending) // process shorter words first\n\n→ For each w in wordsSorted: // iterate through sorted words\n\n    → If canForm(w, wordSet): // check if w can be built from shorter words\n\n        → result.append(w) // w is a concatenated word\n\n    → wordSet.add(w) // add w for future checks\n\n→ Return result // finished\n\nNow define canForm function:\n\n→ Function canForm(word, wordSet): // returns True if word can be segmented into >=2 words from wordSet\n\n    → memo = {} // memoization for recursion\n\n    → Return dfs(0) // start from index 0\n\n→ Function dfs(index): // recursive helper\n\n    → If index == len(word): // reached end of word\n\n        → Return True // valid segmentation\n\n    → If index in memo: // previously computed\n\n        → Return memo[index]\n\n    → For end in range(index+1, len(word)+1): // iterate over possible end positions\n\n        → sub = word[index:end] // substring\n\n        → If sub in wordSet: // substring exists as a shorter word\n\n            → If dfs(end): // continue segmentation from end\n\n                → memo[index] = True\n\n                → Return True\n\n    → memo[index] = False // no valid segmentation found\n\n    → Return False\n\nNow we must produce each line as a \"虛擬碼步驟\" with arrow or structure. Use \"Start\" \"End\" \"Decision:\" etc.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ result = [] // 儲存所有拼接詞\n\n→ wordSet = {} // 用於快速查詢已處理的較短詞\n\n→ wordsSorted = sort(words by length ascending) // 先處理較短的詞\n\n→ For each w in wordsSorted: // 遍歷所有詞\n\n    → Decision: canForm(w, wordSet)? // 判斷 w 是否能由已知詞組合\n\n        Yes → result.append(w) // 若能，加入結果\n\n        No → // 什麼都不做\n\n    → wordSet.add(w) // 把 w 加入已知詞集合，供後續詞使用\n\n→ End // 主要流程結束\n\n// 輔助函式\n\n→ Function canForm(word, wordSet): // 判斷是否可拼接\n\n    → memo = {} // 記錄已計算的子問題\n\n    → Return dfs(0) // 從起始索引開始分割\n\n→ Function dfs(index): // 以 index 為起點遞迴分割\n\n    → Decision: index == len(word)? // 是否已到字串結尾\n\n        Yes → Return True // 成功分割\n\n        No → // 進一步嘗試\n\n    → Decision: index in memo? // 是否已計算過\n\n        Yes → Return memo[index] // 直接回傳結果\n\n        No →\n\n    → For end in range(index+1, len(word)+1): // 遍歷可能的結束位置\n\n        → sub = word[index:end] // 取得子字串\n\n        → Decision: sub in wordSet? // 子字串是否是已知詞\n\n            Yes → Decision: dfs(end)? // 若後續能分割\n\n                Yes → memo[index] = True // 記錄成功\n\n                    → Return True\n\n                No → // 嘗試下一個 end\n\n            No → // 嘗試下一個 end\n\n    → memo[index] = False // 無法分割\n\n    → Return False // 失敗\n\nBut the specification says: each line must contain virtual code step + space + // explanation. Use arrow or structure. Use `Start`, `End`, `Decision:`. The pseudo code must be line by line. So we need to format accordingly.\n\nWe need to use proper indentation maybe with spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ result = [] // 儲存所有拼接詞\n→ wordSet = {} // 以集合儲存已處理的較短詞\n→ wordsSorted = sort(words by length ascending) // 先處理較短的詞\n→ For each w in wordsSorted: // 遍歷所有詞\n    → Decision: canForm(w, wordSet)? // 判斷 w 是否能由已知詞組合\n        Yes → result.append(w) // 若能，加入結果\n        No → // 什麼都不做\n    → wordSet.add(w) // 把 w 加入已知詞集合，供後續詞使用\nEnd // 主要流程結束\n\n// 定義輔助函式 canForm\n→ Function canForm(word, wordSet): // 判斷是否可拼接\n    → memo = {} // 記錄已計算的子問題\n    → Return dfs(0) // 從起始索引開始分割\n\n→ Function dfs(index): // 以 index 為起點遞迴分割\n    → Decision: index == len(word)? // 是否已到字串結尾\n        Yes → Return True // 成功分割\n        No → // 進一步嘗試\n    → Decision: index in memo? // 是否已計算過\n        Yes → Return memo[index] // 直接回傳結果\n        No →\n    → For end in range(index+1, len(word)+1): // 遍歷可能的結束位置\n        → sub = word[index:end] // 取得子字串\n        → Decision: sub in wordSet? // 子字串是否是已知詞\n            Yes → Decision: dfs(end)? // 若後續能分割\n                Yes → memo[index] = True // 記錄成功\n                    → Return True\n                No → // 嘗試下一個 end\n            No → // 嘗試下一個 end\n    → memo[index] = False // 無法分割\n    → Return False // 失敗\n\nNeed to ensure each line ends with // explanation. Provide explanation for each line. We must ensure no extra commentary. Use arrow.\n\nBut the guidelines: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must have code + space + // + explanation. So we need to put explanation after code, separated by space then //.\n\nOur lines above already do that. But we need to ensure that lines with indentation also count. We might need to indent with spaces. Provide \"→\" before each line except Start and End? We can maintain consistent. Eg:\n\nStart // 程式開始執行\n→ result = [] // 儲存所有拼接詞\n...\n\nBut inside for loop we need indentation. We can still use \"→\" at start of each line but use indentation spaces after \"→\" for nested. But guidelines mention use arrow for structure but no requirement for indentation. We can indent with spaces for readability.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ result = [] // 儲存所有拼接詞\n→ wordSet = {} // 以集合儲存已處理的較短詞\n→ wordsSorted = sort(words by length ascending) // 先處理較短的詞\n→ For each w in wordsSorted: // 遍歷所有詞\n    → Decision: canForm(w, wordSet)? // 判斷 w 是否能由已知詞組合\n        Yes → result.append(w) // 若能，加入結果\n        No → // 什麼都不做\n    → wordSet.add(w) // 把 w 加入已知詞集合，供後續詞使用\nEnd // 主要流程結束\n\n// 定義輔助函式 canForm\n→ Function canForm(word, wordSet): // 判斷是否可拼接\n    → memo = {} // 記錄已計算的子問題\n    → Return dfs(0) // 從起始索引開始分割\n\n→ Function dfs(index): // 以 index 為起點遞迴分割\n    → Decision: index == len(word)? // 是否已到字串結尾\n        Yes → Return True // 成功分割\n        No → // 進一步嘗試\n    → Decision: index in memo? // 是否已計算過\n        Yes → Return memo[index] // 直接回傳結果\n        No →\n    → For end in range(index+1, len(word)+1): // 遍歷可能的結束位置\n        → sub = word[index:end] // 取得子字串\n        → Decision: sub in wordSet? // 子字串是否是已知詞\n            Yes → Decision: dfs(end)? // 若後續能分割\n                Yes → memo[index] = True // 記錄成功\n                    → Return True\n                No → // 嘗試下一個 end\n            No → // 嘗試下一個 end\n    → memo[index] = False // 無法分割\n    → Return False // 失敗"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkcgwbybr.py\", line 88, in <module>\n    main()\n  File \"/tmp/tmpkcgwbybr.py\", line 63, in main\n    ops, vals = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpkcgwbybr.py\", line 55, in parse_input\n    raise ValueError(\"Input format incorrect\")\nValueError: Input format incorrect"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented using two queues.\"\"\"\n    def __init__(self):\n        self.q1 = deque()  # primary queue\n        self.q2 = deque()  # auxiliary queue\n\n    def push(self, x: int) -> None:\n        \"\"\"Push element x onto the stack.\"\"\"\n        self.q1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"Remove and return the top element of the stack.\"\"\"\n        if not self.q1:\n            return None\n        # Move all but the last element to the auxiliary queue\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()      # this is the top element\n        # Swap queues to restore state\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def top(self) -> int:\n        \"\"\"Return the top element without removing it.\"\"\"\n        if not self.q1:\n            return None\n        # Move all but the last element to the auxiliary queue\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        res = self.q1.popleft()\n        # Put the top element back into auxiliary queue\n        self.q2.append(res)\n        # Swap queues back\n        self.q1, self.q2 = self.q2, self.q1\n        return res\n\n    def empty(self) -> bool:\n        \"\"\"Check whether the stack is empty.\"\"\"\n        return not self.q1\n\n\ndef parse_input(s: str):\n    \"\"\"\n    Parse the input format:\n    ['MyStack','push','push',...], [[],[1],[2],...]\n    \"\"\"\n    # Extract the two lists using a regex\n    m = re.match(r'\\s*(\\[[^\\]]*\\])\\s*,\\s*(\\[[^\\]]*\\])\\s*', s)\n    if not m:\n        raise ValueError(\"Input format incorrect\")\n    ops = ast.literal_eval(m.group(1))\n    vals = ast.literal_eval(m.group(2))\n    return ops, vals\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, vals = parse_input(raw_input)\n\n    stack = MyStack()\n    results = [None]  # constructor returns null\n\n    # ops[0] is 'MyStack', vals[0] is [] - skip them\n    for op, val in zip(ops[1:], vals[1:]):\n        if op == 'push':\n            # val is a list like [x]\n            stack.push(val[0] if isinstance(val, list) else val)\n            results.append(None)\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n        else:\n            # unknown operation, ignore\n            results.append(None)\n\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with line by line steps and explanation, using virtual code syntax described: Start, → Step X: ..., Decision: ..., Yes →, No →, End.\n\nThe requirement: implement MyStack class with push, pop, top, empty using only two queues. So we design algorithm: maintain two queues q1 and q2. push: enqueue to q1. pop: move all but last from q1 to q2, dequeue last, swap names. top: similar but peek last and then put back. empty: check if q1 empty. Or better: maintain current queue as active. For simplicity, push to q1, pop uses q1 and q2.\n\nWe need to produce virtual code line by line, not actual code. For each operation function.\n\nWe should produce pseudocode for the class and each method. Also maybe include initialization.\n\nLet's outline steps:\n\nStart // Program start\n\n→ Step 1: Initialize queue A // primary queue\n→ Step 2: Initialize queue B // auxiliary queue\n\nThen each method.\n\nDefine push(x):\n→ Step 3: Enqueue x into queue A // add to back\nReturn nothing\n\nDefine pop():\n→ Decision: If queue A empty? // check empty\n    Yes → Return null // or error\n    No → → Step 4: While size of queue A > 1? // move all but last\n        → Step 5: Dequeue front from A, Enqueue to B // transfer\n    → Step 6: Dequeue last from A and store as result // this is top\n    → Step 7: Swap A and B // A becomes B, B becomes A\n    → Step 8: Return result\n\nDefine top():\nSame but don't remove last: similar steps but after capturing result, enqueue it to B, then swap.\n\nDefine empty():\n→ Step 9: Return is empty of queue A // if queue A empty\n\nEnd\n\nBut need to show as virtual code lines with comments.\n\nMake sure each line has virtual code and explanation.\n\nWe also might want to show class structure.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: MyStack() // 建構子，初始化兩個佇列\n    → Step 1.1: queue1 ← New Queue() // 主佇列\n    → Step 1.2: queue2 ← New Queue() // 輔助佇列\n\n→ Step 2: push(x) // 將元素 x 推進堆疊頂部\n    → Step 2.1: queue1.enqueue(x) // 以佇列後端加入\n\n→ Step 3: pop() // 移除並返回堆疊頂部元素\n    → Decision: queue1.isEmpty() ? // 判斷是否為空\n        Yes → Step 3.1: Return null // 或拋出錯誤\n        No  →\n            → Step 3.2: While queue1.size() > 1 do // 移動除最後一個之外的所有元素\n                → Step 3.3: temp ← queue1.dequeue() // 從前端取出\n                → Step 3.4: queue2.enqueue(temp) // 進入輔助佇列\n            → Step 3.5: result ← queue1.dequeue() // 最後一個即頂部元素\n            → Step 3.6: Swap(queue1, queue2) // 交換兩個佇列\n            → Step 3.7: Return result // 回傳頂部元素\n\n→ Step 4: top() // 返回堆疊頂部元素但不移除\n    → Decision: queue1.isEmpty() ?\n        Yes → Step 4.1: Return null\n        No  →\n            → Step 4.2: While queue1.size() > 1 do\n                → Step 4.3: temp ← queue1.dequeue()\n                → Step 4.4: queue2.enqueue(temp)\n            → Step 4.5: result ← queue1.dequeue() // 頂部元素\n            → Step 4.6: queue2.enqueue(result) // 再次加入輔助佇列，保持元素不變\n            → Step 4.7: Swap(queue1, queue2)\n            → Step 4.8: Return result\n\n→ Step 5: empty() // 判斷堆疊是否為空\n    → Step 5.1: Return queue1.isEmpty() // 若主佇列空則堆疊空\n\nEnd // 程式結束\n\nMake sure each line has arrow and explanation.\n\nWe need to be consistent: For virtual code lines, we must include \"→\" before each step line. For nested steps, can indent or use number but still \"→\".\n\nWe might also include \"Decision:\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: MyStack() // 建構子，初始化兩個佇列  \n → Step 1.1: queue1 ← New Queue() // 主佇列，用來儲存堆疊元素  \n → Step 1.2: queue2 ← New Queue() // 輔助佇列，用來暫存元素  \n\n→ Step 2: push(x) // 將元素 x 推進堆疊頂部  \n → Step 2.1: queue1.enqueue(x) // 以佇列後端加入，維持 FIFO  \n\n→ Step 3: pop() // 移除並返回堆疊頂部元素  \n → Decision: queue1.isEmpty() ? // 判斷堆疊是否為空  \n  Yes → Step 3.1: Return null // 或拋出錯誤，視實作需求  \n  No →  \n   → Step 3.2: While queue1.size() > 1 do // 移動除最後一個之外的所有元素  \n     → Step 3.3: temp ← queue1.dequeue() // 從前端取出  \n     → Step 3.4: queue2.enqueue(temp) // 進入輔助佇列  \n   → Step 3.5: result ← queue1.dequeue() // 最後一個即頂部元素  \n   → Step 3.6: Swap(queue1, queue2) // 交換兩個佇列，恢復主佇列為空  \n   → Step 3.7: Return result // 回傳堆疊頂部元素  \n\n→ Step 4: top() // 返回堆疊頂部元素但不移除  \n → Decision: queue1.isEmpty() ?  \n  Yes → Step 4.1: Return null  \n  No →  \n   → Step 4.2: While queue1.size() > 1 do  \n     → Step 4.3: temp ← queue1.dequeue()  \n     → Step 4.4: queue2.enqueue(temp)  \n   → Step 4.5: result ← queue1.dequeue() // 頂部元素  \n   → Step 4.6: queue2.enqueue(result) // 再次加入輔助佇列，保持元素不變  \n   → Step 4.7: Swap(queue1, queue2) // 交換佇列，保持堆疊狀態  \n   → Step 4.8: Return result  \n\n→ Step 5: empty() // 判斷堆疊是否為空  \n → Step 5.1: Return queue1.isEmpty() // 若主佇列空則堆疊空  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpiyz8qtn_.py\", line 47, in <module>\n    num_courses, prerequisites = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpiyz8qtn_.py\", line 38, in parse_input\n    num_courses = int(num_part.replace('numCourses', '').strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 2'"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdyqh83h9.py\", line 47, in <module>\n    num_courses, prerequisites = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdyqh83h9.py\", line 38, in parse_input\n    num_courses = int(num_part.replace('numCourses', '').strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 4'"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpwuiiruqk.py\", line 47, in <module>\n    num_courses, prerequisites = parse_input(input_data)\n                                 ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpwuiiruqk.py\", line 38, in parse_input\n    num_courses = int(num_part.replace('numCourses', '').strip())\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '= 1'"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度陣列\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點進佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'numCourses = 2, prerequisites = [[1,0]]' 的輸入。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return 0, []\n    # 以 ', prerequisites =' 分隔\n    parts = data.split(', prerequisites =')\n    num_part = parts[0].strip()\n    # 移除前綴並轉為整數\n    num_courses = int(num_part.replace('numCourses', '').strip())\n    # 若沒有 prerequisites，預設為空列表\n    prereq_part = parts[1].strip() if len(parts) > 1 else '[]'\n    # 直接 eval 取得列表，輸入格式已經是合法的 Python 列表字面量\n    prerequisites = eval(prereq_part)\n    return num_courses, prerequisites\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    num_courses, prerequisites = parse_input(input_data)\n    solution = Solution()\n    result = solution.findOrder(num_courses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code steps for topological sort problem. Provide steps using Start, Decision, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use appropriate steps: build graph, in-degree array, queue, result list, while loop, pop, add to result, decrease in-degree, push when zero. After loop, check if result length==numCourses. If yes, return result else return empty.\n\nWe should not output actual code but pseudocode steps. Let's craft step-by-step.\n\nStart\n→ Step 1: 初始化圖 adjacency list, 為每門課建立空列表\n→ Step 2: 初始化入度陣列 indegree[0..numCourses-1] 為 0\n→ Decision: 是否有 prereq? \n    Yes → for each pair [a,b] in prerequisites:\n        Step 3: 在 adjacency[b] 中加入 a // 表示 b→a\n        Step 4: indegree[a] +=1\n    No → 無動作\n\n→ Step 5: 建立空佇列 queue\n→ Decision: 對於每門課 i:\n    Yes → 若 indegree[i]==0，將 i 加入 queue // 無前置課程\n    No → 無動作\n\n→ Step 6: 建立空列表 result\n→ Step 7: While queue 非空:\n    → Step 8: 取出 queue 頭節點 cur\n    → Step 9: 將 cur 加入 result\n    → Decision: 是否有鄰接節點？ 若 adjacency[cur] 非空：\n        Yes → 對於每個 neigh in adjacency[cur]:\n            → Step 10: indegree[neigh] -=1\n            → Decision: indegree[neigh]==0? \n                Yes → Step 11: 將 neigh 加入 queue\n                No  → 無動作\n        No → 無動作\n\n→ Decision: result 長度 == numCourses?\n    Yes → Step 12: 回傳 result // 有合法排序\n    No  → Step 13: 回傳空陣列 // 無法完成課程\n\nEnd\n\nWe need to ensure arrow usage and format lines with single spaces. Use Chinese explanation. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 adjacency list 為空列表 // 為每門課建立鄰接表  \n→ Step 2: 初始化 indegree[0..numCourses-1] 為 0 // 記錄各課程的前置課程數量  \n→ Decision: 有 prerequisites 吗? // 檢查是否有先修關係  \n    Yes → for each pair [a,b] in prerequisites: // 處理每個先修條件  \n        → Step 3: adjacency[b] 加入 a // 表示從 b 到 a 的邊  \n        → Step 4: indegree[a] += 1 // a 的前置課程數加一  \n    No  → // 無先修條件，跳過  \n→ Step 5: 建立空佇列 queue // 用於存放入度為 0 的課程  \n→ Decision: 對每門課 i: // 找出入度為 0 的課程  \n    Yes → 若 indegree[i] == 0，queue 加入 i // 無前置課程，可立即修  \n    No  → // 入度不為 0，跳過  \n→ Step 6: 建立空列表 result // 儲存課程完成順序  \n→ Step 7: While queue 非空: // 依序處理可修課程  \n    → Step 8: 取出 queue 頭節點 cur // 從佇列取下一門課  \n    → Step 9: result 加入 cur // 加入完成順序  \n    → Decision: adjacency[cur] 是否有鄰接節點?  \n        Yes → 對每個 neigh in adjacency[cur]: // 遍歷所有後續課程  \n            → Step 10: indegree[neigh] -= 1 // 減少後續課程的前置課程數  \n            → Decision: indegree[neigh] == 0?  \n                Yes → queue 加入 neigh // 先修完成，可修  \n                No  → // 還需等待其他先修課程  \n        No  → // 無後續課程，跳過  \n→ Decision: result 長度 == numCourses? // 檢查是否所有課程都已排完  \n    Yes → Step 12: 回傳 result // 有合法順序  \n    No  → Step 13: 回傳空陣列 // 無法完成所有課程  \nEnd // 程式執行結束"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "source_file": "Leetcode/leetcode4.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2.00000'\nGot (Norm):      '3.00000'\n--- (Raw) ---\nRaw Expected: '2.00000'\nRaw Got:      '3.00000'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # If one array is empty, return median of the other\n        if not nums1:\n            return self._median_single(nums2)\n        if not nums2:\n            return self._median_single(nums1)\n\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        low, high = 0, m\n        total = m + n\n        half = (total + 1) // 2  # Number of elements on the left side\n\n        while low <= high:\n            i = (low + high) // 2\n            j = half - i\n\n            Aleft = nums1[i - 1] if i > 0 else float('-inf')\n            Aright = nums1[i] if i < m else float('inf')\n            Bleft = nums2[j - 1] if j > 0 else float('-inf')\n            Bright = nums2[j] if j < n else float('inf')\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2 == 1:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            elif Aleft > Bright:\n                high = i - 1\n            else:\n                low = i + 1\n\n        # Should not reach here\n        return 0.0\n\n    def _median_single(self, nums):\n        l = len(nums)\n        if l % 2 == 1:\n            return nums[l // 2]\n        return (nums[l // 2 - 1] + nums[l // 2]) / 2.0\n\ndef parse_input(data):\n    # Extract numbers for nums1 and nums2 using regex\n    nums1_str = re.search(r'nums1\\s*=\\s*\\[(.*?)\\]', data, re.S)\n    nums2_str = re.search(r'nums2\\s*=\\s*\\[(.*?)\\]', data, re.S)\n\n    nums1 = []\n    nums2 = []\n\n    if nums1_str:\n        nums1 = [int(x.strip()) for x in nums1_str.group(1).split(',') if x.strip()]\n    if nums2_str:\n        nums2 = [int(x.strip()) for x in nums2_str.group(1).split(',') if x.strip()]\n\n    return nums1, nums2\n\ndef main():\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, using arrow notation. We need to solve median of two sorted arrays, O(log(m+n)) - typical solution: binary search on smaller array, find partition. So produce virtual steps. Should not output actual code. Just virtual steps like \"Start\", \"→ Decision: If nums1 is smaller?\" etc. Provide explanation. Should be concise. Use virtual code syntax: \"Start\", \"→ Step ...\", \"Decision: ...\". Provide each line with // explanation.\n\nWe need to handle binary search on smaller array. Steps:\n\nStart\n→ Decision: 如果 nums1 为空? // handle empty case\n    Yes → Step: 如果 nums1 为空，返回 nums2 的中位数 // empty array\n    No  → Decision: 如果 nums2 为空? // check other\n        Yes → Step: 如果 nums2 为空，返回 nums1 的中位数\n        No  → Decision: 確定較短陣列為 A，較長陣列為 B\n→ Step: 設 low = 0, high = len(A)\n→ While low <= high: // binary search\n    → Step: 計算 i = (low+high)/2, j = (len(A)+len(B)+1)/2 - i\n    → Decision: 如果 A[i-1] > B[j]? // A[i-1] 大於 B[j]\n        Yes → Step: high = i-1 // 將 i 減小\n        No  → Decision: 如果 B[j-1] > A[i]? // B[j-1] 大於 A[i]\n            Yes → Step: low = i+1 // 將 i 增大\n            No  → Step: 已找到正確分割\n→ Step: 計算 maxLeft\n    → Decision: i == 0 ? // A 左邊空\n        Yes → Step: maxLeft = B[j-1]\n        No  → Decision: j == 0 ?\n            Yes → Step: maxLeft = A[i-1]\n            No  → Step: maxLeft = max(A[i-1], B[j-1])\n→ Decision: (len(A)+len(B)) % 2 == 1? // 奇數長度\n    Yes → Step: return maxLeft // 中位數\n    No  → Step: 計算 minRight\n        → Decision: i == len(A)? // A 右邊空\n            Yes → Step: minRight = B[j]\n            No  → Decision: j == len(B)?\n                Yes → Step: minRight = A[i]\n                No  → Step: minRight = min(A[i], B[j])\n        → Step: return (maxLeft + minRight) / 2.0 // 平均\n\nEnd\n\nMake sure each line has // explanation. Ensure format matches: \"虛擬碼步驟 [space] // 解釋\".\n\nLet's craft each line. Also we might need to use \"Decision:\" lines and \"Yes →\", \"No →\" lines as sub-steps. We'll output each line separately.\n\nCheck formatting: Use \"Start // 程式開始執行\" etc. Use \"→\" for steps. The decisions with Yes→ and No→ must be on separate lines? In example, Yes→ and No→ lines are separate. We can follow that pattern.\n\nLet's produce.\n\nAlso need to mention \"Step:\" lines. Good.\n\nLet's create final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 nums1 為空? // 檢查第一個陣列是否為空  \n Yes → Step: 返回 nums2 的中位數 // 空陣列時直接返回另一個陣列的中位數  \n No  → Decision: 如果 nums2 為空? // 檢查第二個陣列是否為空  \n  Yes → Step: 返回 nums1 的中位數 // 另一空陣列時直接返回第一個陣列的中位數  \n  No  → Step: 確定較短陣列為 A，較長陣列為 B // 兩個陣列都非空，選擇較短的作為 A  \n→ Step: low ← 0, high ← len(A) // 初始化二分搜尋範圍  \n→ Decision: 低於或等於高? // 開始二分搜尋  \n Yes → Step: i ← (low + high) // 2，j ← (len(A)+len(B)+1)//2 - i // 計算分割點  \n  Decision: A[i-1] > B[j]? // 檢查左邊是否太大  \n   Yes → Step: high ← i - 1 // i 減小  \n   No  → Decision: B[j-1] > A[i]? // 檢查右邊是否太大  \n    Yes → Step: low ← i + 1 // i 增大  \n    No  → Step: 已找到正確分割點 // 分割點正確，跳出迴圈  \n No  → End // 迴圈結束（實際情況已在分割點處）  \n→ Step: 計算 maxLeft  \n Decision: i == 0? // A 的左邊是否為空  \n  Yes → Step: maxLeft ← B[j-1] // 只取 B 的左邊最大值  \n  No  → Decision: j == 0? // B 的左邊是否為空  \n   Yes → Step: maxLeft ← A[i-1] // 只取 A 的左邊最大值  \n   No  → Step: maxLeft ← max(A[i-1], B[j-1]) // 取兩者中較大的  \n→ Decision: (len(A)+len(B)) % 2 == 1? // 數組長度奇數？  \n Yes → Step: 返回 maxLeft // 奇數時中位數即為 maxLeft  \n No  → Step: 計算 minRight  \n  Decision: i == len(A)? // A 的右邊是否為空  \n   Yes → Step: minRight ← B[j] // 只取 B 的右邊最小值  \n   No  → Decision: j == len(B)? // B 的右邊是否為空  \n    Yes → Step: minRight ← A[i] // 只取 A 的右邊最小值  \n    No  → Step: minRight ← min(A[i], B[j]) // 取兩者中較小的  \n   → Step: 返回 (maxLeft + minRight) / 2.0 // 偶數時取平均作為中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpz6jn_uzn.py\", line 51, in <module>\n    params = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp88r5_5yo.py\", line 51, in <module>\n    params = ast.literal_eval(data)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    {beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]}\n     ^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS 找最短距離，紀錄每個單詞的前驅節點\n        layer = {}\n        layer[beginWord] = 0\n        parents = defaultdict(list)\n\n        queue = deque([beginWord])\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入包成字典字串以便解析\n    data = \"{\" + data + \"}\"\n    params = ast.literal_eval(data)\n    beginWord = params[\"beginWord\"]\n    endWord = params[\"endWord\"]\n    wordList = params[\"wordList\"]\n\n    solution = Solution()\n    result = solution.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines with arrows and explanation. This is typical BFS + backtracking to find all shortest paths. Provide steps: Start, Build adjacency, BFS to record levels, track parents mapping, then DFS or backtracking from endWord to beginWord building sequences, return list.\n\nNeed to write each step line by line with comments. Use arrows. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將 wordList 轉成 Set wordsSet 以便 O(1) 查詢 // 建立快速查詢集合\n→ Decision: 是否存在 endWord 在 wordsSet? // 檢查目標詞是否在字典中\n    Yes → Continue\n    No  → Step 2: 回傳空列表 [] // 沒有可能完成轉換\n→ Step 3: 建立空字典 parents: word → List[previous words] // 用於記錄每個單字的前驅\n→ Step 4: 建立空集合 visited: Set[words] // 記錄已被 BFS 訪問過的單字\n→ Step 5: 建立 queue Q，並加入 (beginWord, 0) // (單字, 級別) 的元組，開始 BFS\n→ Step 6: 進行 BFS，直到 Q 為空或已找到 endWord 的最短層級\n    → While Q not empty:\n        → Step 7: 取出前端元素 (current, level)\n        → Decision: 是否已找到最短路徑且 level > minLevel? // 若已完成且現在級別更深則結束\n            Yes → Break\n            No  →\n                → Decision: 是否將 current 加入 visited? // 避免重複處理\n                    Yes → Continue\n                    No  → Step 8: visited.add(current) // 標記已訪問\n                → Decision: current == endWord? // 是否到達目標\n                    Yes →\n                        → Step 9: 設定 minLevel = level // 記錄最短層級\n                    No  →\n                        → Step 10: 產生所有相鄰單字 nextWord 只差一個字母且在 wordsSet 且未在 visited\n                        → For each nextWord:\n                            → Decision: nextWord 是否已在 parents? // 若無需再建立\n                                Yes → Step 11: parents[nextWord].append(current) // 加入前驅\n                                No  → Step 12: parents[nextWord] = [current] // 建立前驅列表\n                            → Step 13: Q.enqueue((nextWord, level+1)) // 加入下一層級\n→ Decision: minLevel 是否為 None? // 若 BFS 沒有找到 endWord\n    Yes → Step 14: 回傳空列表 [] // 沒有可行序列\n    No  →\n        → Step 15: 建立結果列表 results = []\n        → Step 16: 定義遞迴函式 backtrack(currentWord, path)\n            → Decision: currentWord == beginWord? // 回到起始詞\n                Yes → Step 17: results.append(path[::-1]) // 反轉為正向順序並加入結果\n                No  →\n                    → Step 18: 對於每個 prevWord in parents[currentWord]:\n                        → Step 19: backtrack(prevWord, path + [prevWord]) // 遞迴向前推\n        → Step 20: 呼叫 backtrack(endWord, [endWord]) // 從 endWord 開始回溯\n        → Step 21: 回傳 results // 所有最短轉換序列\nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.6353476670468973,-0.4378010195233728],[-0.7014569173182966,0.07309295028841646],[0.6350305285300633,0.5341867798349382]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.6353476670468973, -0.4378010195233728], [-0.7014569173182966, 0.07309295028841646], [0.6350305285300633, 0.5341867798349382]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 隨機產生半徑（使用 sqrt 保證均勻分布）\n        r = self.radius * math.sqrt(random.random())\n        # 隨機產生角度\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換為笛卡兒座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    # 讀取標準輸入：兩行，第一行為操作名稱列表，第二行為每個操作的參數\n    lines = [line.strip() for line in sys.stdin if line.strip() != '']\n    if len(lines) < 2:\n        return\n    ops = json.loads(lines[0])          # e.g. [\"Solution\", \"randPoint\", ...]\n    args_list = json.loads(lines[1])    # e.g. [[1.0, 0.0, 0.0], [], ...]\n\n    results = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # constructor returns null\n        elif op == \"randPoint\":\n            if obj is not None:\n                results.append(obj.randPoint())\n            else:\n                results.append(None)      # 如果尚未建立對象，返回 null\n        else:\n            results.append(None)          # 未知操作，安全返回 null\n\n    # 輸出結果列表，使用 json.dumps 以得到正確的 null 表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem. Provide step-by-step pseudocode with comments. Steps: start, initialize radius and center, randPoint: generate random radius sqrt(u)*R, random angle between 0 and 2π, compute x = center_x + r*cos(angle), y = center_y + r*sin(angle), return [x,y]. Also decision maybe? Not much decisions. Provide Start, End. Use arrow syntax. Provide each line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立類別以儲存圓的參數\n→ Step 2: 初始化 radius, x_center, y_center // 存入物件屬性\n→ Step 3: 定義方法 randPoint() // 產生隨機點\n    → Step 4: 產生 u ∈ [0,1) // 隨機數\n    → Step 5: 計算隨機半徑 r = sqrt(u) * radius // 保證均勻分佈\n    → Step 6: 產生 θ ∈ [0,2π) // 隨機角度\n    → Step 7: 計算 x = x_center + r * cos(θ) // 點的 x 坐標\n    → Step 8: 計算 y = y_center + r * sin(θ) // 點的 y 坐標\n    → Step 9: 回傳 [x, y] // 回傳隨機點\nEnd // 程式結束\n\nNeed to include arrow indent. Use \"→\" for each step. Indentation for nested steps maybe 4 spaces? Provide decision? Not needed.\n\nWe must ensure each line ends with // 解釋/說明. Provide comment after space.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立類別以儲存圓的參數\n→ Step 2: 初始化 radius, x_center, y_center // 存入物件屬性\n→ Step 3: 定義方法 randPoint() // 產生隨機點\n    → Step 4: 產生 u ∈ [0,1) // 產生均勻分佈的隨機數\n    → Step 5: 計算 r = sqrt(u) * radius // 根據均勻分佈得到隨機半徑\n    → Step 6: 產生 θ ∈ [0,2π) // 產生均勻分佈的角度\n    → Step 7: 計算 x = x_center + r * cos(θ) // 轉換為座標系的 x\n    → Step 8: 計算 y = y_center + r * sin(θ) // 轉換為座標系的 y\n    → Step 9: 回傳 [x, y] // 回傳隨機點\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"Remove all occurrences of val in nums in-place and return the new length.\"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse input like: \"nums = [3,2,2,3], val = 3\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*val\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        print(\"Invalid input format\")\n        return\n\n    nums_str, val_str = match.group(1), match.group(2)\n    nums = ast.literal_eval(nums_str)\n    val = int(val_str)\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # Build representation: first k elements, then underscores for remaining positions\n    elements = [str(nums[i]) for i in range(k)] + ['_' for _ in range(len(nums) - k)]\n    array_repr = ','.join(elements)\n\n    print(f\"{k}, nums = [{array_repr}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. The problem: Remove all occurrences of val from nums array in place, return k. We need to describe algorithm: two pointers: i traverse, j write pointer. For each element, if nums[i] != val, set nums[j]=nums[i], j++. Finally return j.\n\nLet's produce steps: Start, → Step: set writeIndex=0 // pointer for next position. → Loop i from 0 to length-1 // traverse array. → Decision: if nums[i] != val? Yes → assign nums[writeIndex] = nums[i] // keep element, writeIndex++ // move write pointer. No → skip. After loop, k = writeIndex // number of kept elements. End.\n\nAlso maybe we want to clear remaining? Not required.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Decision lines use \"Decision:\". Start/End. Let's produce.\n\nWe need to use \"虛擬碼步驟\" not actual code, but description. So use something like:\n\nStart // 程式開始執行\n→ Step: 設定 writeIndex = 0 // 初始化寫入指標\n→ Step: 從 i = 0 到 nums.length - 1 // 逐一遍歷陣列\n→ Decision: 如果 nums[i] != val? // 判斷當前元素是否為要保留的\n    Yes → Step: nums[writeIndex] = nums[i] // 把元素寫入寫入指標位置\n    Yes → Step: writeIndex++ // 移動寫入指標\n    No  → Step: 跳過 // 直接忽略該元素\n→ Step: k = writeIndex // 最終保留元素個數\nEnd // 程式執行結束\n\nBut format expects each line with step plus comment after space. For decision block, we need sublines. Use indentation maybe.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: writeIndex = 0 // 初始化寫入指標，指向未填入元素的第一個位置  \n→ Step: i = 0, loop until i < nums.length // 逐一遍歷整個陣列  \n→ Decision: 如果 nums[i] != val? // 判斷當前元素是否應保留  \n  Yes → Step: nums[writeIndex] = nums[i] // 把符合條件的元素寫入 writeIndex 所在位置  \n  Yes → Step: writeIndex++ // 移動寫入指標，準備寫入下一個保留元素  \n  No  → Step: 跳過 // 若元素為 val，直接忽略，寫入指標不變  \n→ Step: k = writeIndex // writeIndex 代表保留元素的個數，也是結果 k  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4in5bdqi.py\", line 24, in <module>\n    ops = json.loads(data[0])\n          ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 44 (char 43)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.original = list(nums)\n\n    def reset(self):\n        return self.original\n\n    def shuffle(self):\n        arr = self.original[:]\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = json.loads(data[0])\n    args = json.loads(data[1])\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg)\n            results.append(None)\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code in steps. We need to include Start, End, Decision lines. Provide lines for initializing, reset, shuffle with Fisher-Yates. Use arrays. Provide simple structure. Use arrow symbol '→'. Each line with // explanation. Provide multiple lines. Ensure each line has a virtual code step then space then comment.\n\nLet's craft:\n\nStart // begin\n\n→ Step 1: store original array in field 'original' // keep copy\n→ Step 2: copy original into 'current' // working array\n\nImplement methods:\n\n→ Step 3: Method reset() // reset to original\n    → Return clone of original // return copy\n\n→ Step 4: Method shuffle() // random shuffle\n    → Initialize result = clone of original // start with copy\n    → For i from 0 to len-1:\n        → Generate random index j between i and len-1\n        → Swap result[i] and result[j]\n    → Return result\n\nAlso include random generator.\n\nLet's format with lines. Use 'Decision' maybe not needed. But we can include decision for loop? Not necessary. Just step loops.\n\nWe should follow arrow for each line. Use '→'. For loops we can use Step: For i... But we may include a Decision inside loop to decide swap? Maybe not.\n\nBetter to have lines:\n\n→ Step 5: For i in 0..len-1 // iterate over array\n    → Step 6: j = random(i, len-1) // pick random index\n    → Step 7: Swap result[i], result[j] // swap\n\nMake sure indentation: Use spaces.\n\nAlso need to start class and methods.\n\nBut we cannot output actual code, only virtual steps. So we can represent methods as Step 3: Method reset() ... etc.\n\nLet's produce output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將傳入的數字陣列 nums 複製為 original // 儲存原始順序  \n→ Step 2: 將 original 複製為 current // 供後續操作使用  \n\n→ Step 3: Method reset() // 重設方法  \n    → Step 3.1: Return original.clone() // 以副本回傳原始陣列，避免外部改動  \n\n→ Step 4: Method shuffle() // 洗牌方法  \n    → Step 4.1: result ← original.clone() // 先以原始陣列副本開始  \n    → Step 4.2: len ← result.length // 取得陣列長度  \n    → Step 4.3: For i ← 0 To len-1 Do // 遍歷每個位置  \n        → Step 4.3.1: j ← random(i, len-1) // 產生 i 到 len-1 的隨機索引  \n        → Step 4.3.2: Swap result[i], result[j] // 交換兩個位置的值  \n    → Step 4.4: Return result // 回傳洗牌後的陣列  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        def backtrack(start, path):\n            res.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        sys.exit(0)\n    # Extract the list part after '='\n    try:\n        _, list_part = data.split('=', 1)\n    except ValueError:\n        list_part = data\n    list_part = list_part.strip()\n    # Safely evaluate the list using literal_eval\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        nums = []\n    solution = Solution()\n    result = solution.subsets(nums)\n    # Output without spaces as in the examples\n    print(json.dumps(result, separators=(',', ':')))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all subsets of an array of unique elements, no duplicates, order doesn't matter. It's typical subset generation using recursion/backtracking or iterative bitmask. We'll produce steps: Start, initialize result, define function backtrack(index, current), base: if index == len, add current copy to result; else, include nums[index], call backtrack(index+1, current+[nums[index]]), then exclude, call backtrack(index+1, current). After recursion done, return result.\n\nWe need to produce each line as \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's structure:\n\nStart\n→ Step 1: 定義輸入陣列 nums // 從外部取得數組\n→ Step 2: 初始化結果集 result 為空列表 // 用於存放子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // 將索引與當前子集作為參數\n    → Decision: 如果 idx 等於 nums 長度? // 判斷是否已遍歷完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx]，調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n             → Step 6: 排除 nums[idx]，調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從起始索引和空子集開始\n→ Step 8: 返回 result // 結果即為所有子集\n\nBut each line should have a step number maybe? They didn't require step number but fine. Provide arrow before each step maybe.\n\nWe need to use \"Start\", \"End\", \"Decision:\" etc.\n\nLet's produce as:\n\nStart // 程式開始\n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列\n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合\n    → Decision: idx 是否等於 nums 長度? // 檢查是否已處理完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並遞迴調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並遞迴調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴\n→ Step 8: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nBut we should be careful: In Decision: idx == len? Yes then Step 4, else we should have two branches (include, exclude). We can express as two \"No\" branches maybe with indent. But we can use arrow like:\n\nDecision: idx == len(nums)? \n    Yes → Step 4...\n    No  → Step 5...\n    No  → Step 6...\n\nBut typical representation may be:\n\nDecision: idx == len(nums)? \n    Yes → Step 4: ...\n    No  → Step 5: ...\n    No  → Step 6: ...\n\nBut it's ambiguous. Could also separate as two decisions but better to show as two separate lines under No.\n\nAlternatively:\n\nDecision: idx == len(nums)?\n    Yes → Step 4: add current to result\n    No  → Step 5: include nums[idx]; backtrack(idx+1, current + [nums[idx]])\n    No  → Step 6: exclude nums[idx]; backtrack(idx+1, current)\n\nBut we might need to show the branches properly.\n\nLet's format as:\n\nStart // 程式開始\n→ Step 1: 設定輸入陣列 nums // ...\n→ Step 2: 初始化結果集 result 為空列表 // ...\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // ...\n    → Decision: idx == len(nums)? // ...\n        Yes → Step 4: 把 current 的複製加入 result // ...\n        No  → Step 5: 包含 nums[idx] 並遞迴調用 backtrack(idx+1, current + [nums[idx]]) // ...\n        No  → Step 6: 排除 nums[idx] 並遞迴調用 backtrack(idx+1, current) // ...\n→ Step 7: 調用 backtrack(0, []) // ...\n→ Step 8: 返回 result // ...\nEnd // 程式結束\n\nBut we need each line after the virtual code step include \"//\" and explanation. Provide one line for Start, each step. Indentation maybe with arrows and spaces. We should show indentation like in example: \"    Yes → ...\" etc.\n\nBetter to replicate example style:\n\nStart // 程式開始執行\n→ Step 1: 設定輸入陣列 nums // ...\n→ Step 2: 初始化結果集 result 為空列表 // ...\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // ...\n    → Decision: idx == len(nums)? // ...\n        Yes → Step 4: 把 current 的複製加入 result // ...\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // ...\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // ...\n→ Step 7: 調用 backtrack(0, []) // ...\n→ Step 8: 返回 result // ...\nEnd // 程式結束\n\nBut we need to ensure each line includes the step text and comment. In example, each line shows \"Start // 程式開始執行\". So we need to mimic.\n\nWe need to produce a final answer in Traditional Chinese. Let's craft it.\n\nAlso note: the instruction \"逐行生成虛擬碼\" means each line should be a step. So we should produce one line per step, with appropriate indentation. We should include arrow \"→\" at start of each step line, except Start and End? In example, Start has no arrow. Step lines have arrow. Decision has arrow and then \"Decision: ...\".\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列\n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合\n    → Decision: idx 等於 nums 長度嗎？ // 判斷是否已處理完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴\n→ Step 8: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nBut the \"No  → Step 5\" and \"No  → Step 6\" might be confusing. We could also use indentation like:\n\n→ Step 3: 定義遞迴函式 backtrack(idx, current)\n    → Decision: idx == len(nums)?\n        Yes → Step 4: 把 current 的複製加入 result\n        No  → Step 5: 包含 nums[idx]; backtrack(idx+1, current + [nums[idx]])\n        No  → Step 6: 排除 nums[idx]; backtrack(idx+1, current)\n\nThis might be acceptable.\n\nBut we need to include the explanation after each line. So we need to put // explanation for each step.\n\nLet's format each line accordingly:\n\nStart // 程式開始執行\n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列\n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集\n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合\n    → Decision: idx == len(nums)? // 判斷是否已處理完所有元素\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴\n→ Step 8: 返回 result // 回傳所有子集\nEnd // 程式結束\n\nBut note: The \"No\" branches may appear twice. However, typical pseudocode uses two separate \"No\" branches but we can combine them: after \"Decision:\" we have Yes branch, No branch where we do include and exclude. But we can't have two \"No\" branches. But we can simply have two separate steps after No. But it's okay.\n\nAlternatively, we can restructure:\n\n→ Step 3: 定義遞迴函式 backtrack(idx, current)\n    → Decision: idx == len(nums)?\n        Yes → Step 4: 把 current 的複製加入 result\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n\nBut we have to avoid duplicate \"No\" lines maybe; we can have one No line that does both include and exclude calls? In typical pseudocode, we would have:\n\nDecision: idx == len(nums)?\n    Yes -> ...\n    No -> \n        Step 5: 包含 nums[idx] ...\n        Step 6: 排除 nums[idx] ...\n\nBut they want each line with arrow and explanation. So we could do:\n\n→ Step 3: 定義遞迴函式 backtrack(idx, current)\n    → Decision: idx == len(nums)?\n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果\n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素\n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素\n\nOk.\n\nWe need to keep indentation consistent.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定輸入陣列 nums // 從外部取得唯一元素的整數陣列  \n→ Step 2: 初始化結果集 result 為空列表 // 用於儲存所有子集  \n→ Step 3: 定義遞迴函式 backtrack(idx, current) // idx 為目前索引，current 為已選擇元素集合  \n    → Decision: idx == len(nums)? // 判斷是否已處理完所有元素  \n        Yes → Step 4: 把 current 的複製加入 result // 完整子集加入結果  \n        No  → Step 5: 包含 nums[idx] 並調用 backtrack(idx+1, current + [nums[idx]]) // 選擇當前元素  \n        No  → Step 6: 排除 nums[idx] 並調用 backtrack(idx+1, current) // 不選擇當前元素  \n→ Step 7: 調用 backtrack(0, []) // 從索引 0 和空子集開始遞迴  \n→ Step 8: 返回 result // 回傳所有子集  \nEnd // 程式結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 將輸入中雙引號內的內容作為表達式\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expr = match.group(1)\n    else:\n        # 若未找到雙引號，嘗試直接取等號右側\n        parts = data.split('=', 1)\n        expr = parts[1].strip() if len(parts) > 1 else data.strip()\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for algorithm: given string expression of numbers and operators (+,-,*), return all possible results from different parenthesizations. This is classic LeetCode 241. Use divide and conquer / recursion with memoization. We'll produce step-by-step pseudocode lines.\n\nWe'll create Start, parse input expression string, define recursive function diffWays(index start, end) that returns list of results. Use memoization dict. For each operator in substring, split left and right, get results recursively, combine. If no operator, parse number. Return results. Then call with full string.\n\nWe must output line-by-line pseudocode with comments. Use \"→\" arrow. Also use Decision: etc.\n\nLet's design.\n\nStart // Start program\n→ Input: expression // Receive string expression\n→ Step 1: Define memo dict // Cache results for substrings\n→ Step 2: Define recursive function diffWays(startIdx, endIdx) // compute results for substring\n    → Decision: startIdx > endIdx? // invalid substring\n        No → continue\n    → Decision: substring contains no operator? // all digits\n        Yes → Step 3: Parse number, return [number] // single result\n        No → Step 4: Initialize results list // to collect combinations\n            → Loop i from startIdx to endIdx\n                → Decision: char at i is operator? // '+', '-', '*'\n                    Yes → Step 5: left = diffWays(startIdx, i-1) // left part\n                            Step 6: right = diffWays(i+1, endIdx) // right part\n                            → Loop l in left\n                                → Loop r in right\n                                    → Step 7: compute l op r\n                                    → Step 8: Append to results\n                No → continue loop\n            → Return results\n→ Step 9: Call diffWays(0, length-1) // compute all results\n→ Step 10: Return list from step9\nEnd // Program finished\n\nWe must use \"→\" arrow for each step. Ensure each line includes explanation comment after //.\n\nAlso need decision lines with Yes→ and No→ etc.\n\nLet's format.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Input: expression // 取得輸入字串\n→ Step 1: Define memo = {} // 用於快取子表達式結果\n\nDefine diffWays function: we need to include within step? We'll show nested steps with indentation maybe.\n\nWe need to keep each line with arrow and comment. Use \"Decision:\" for branching.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Input: expression // 取得輸入字串\n→ Step 1: Define memo = {} // 快取已計算的子表達式結果\n\n→ Function diffWays(start, end) // 重新呼叫自分以計算子表達式\n    → Decision: start > end? // 子表達式無效\n        Yes → Return [] // 返空結果\n        No →\n    → Decision: substring [start:end+1] contains no operator? // 只剩數字\n        Yes →\n            → Step 2: num = int(substring) // 轉成整數\n            → Return [num] // 直接回傳\n        No →\n            → Step 3: results = [] // 儲存所有計算結果\n            → Loop i from start to end\n                → Decision: expression[i] is operator? // '+', '-', '*'\n                    Yes →\n                        → left = diffWays(start, i-1) // 計算左半部\n                        → right = diffWays(i+1, end) // 計算右半部\n                        → Loop l in left\n                            → Loop r in right\n                                → Step 4: if operator '+': val = l + r\n                                    → Step 5: else if '-': val = l - r\n                                    → Step 6: else '*': val = l * r\n                                → Append val to results\n                    No →\n            → Return results\n\n→ Step 7: finalResults = diffWays(0, len(expression)-1) // 計算整個表達式\n→ Return finalResults // 將所有可能結果回傳\nEnd // 程式執行結束\n\nBut we need each line in single line with arrow. For nested lines, we can prefix arrow, maybe use indentation? In example they used \"→ Decision:\" with indented sub-lines. We'll replicate that style.\n\nThus each line must be like:\n\nStart // 程式開始執行\n→ Input: expression // 取得輸入字串\n→ Step 1: Define memo = {} // 快取已計算的子表達式結果\n\n→ Function diffWays(start, end) // 計算子表達式的所有結果\n    → Decision: start > end? // 子表達式無效\n        Yes → Return [] // 返空結果\n        No →\n    → Decision: substring(start, end) contains no operator? // 只剩數字\n        Yes →\n            → Step 2: num = int(substring) // 轉成整數\n            → Return [num] // 直接回傳\n        No →\n            → Step 3: results = [] // 儲存所有計算結果\n            → Loop i = start to end\n                → Decision: expression[i] is operator? // '+', '-', '*'\n                    Yes →\n                        → left = diffWays(start, i-1) // 計算左半部\n                        → right = diffWays(i+1, end) // 計算右半部\n                        → Loop l in left\n                            → Loop r in right\n                                → Step 4: if expression[i] == '+': val = l + r\n                                    → Step 5: else if expression[i] == '-': val = l - r\n                                    → Step 6: else: val = l * r\n                                → Append val to results\n                    No →\n            → Return results\n\nBut must ensure each line has arrow and comment. The nested lines might need multiple arrows. The example shows each nested line still starts with arrow, e.g., \"Yes → Step 2: ...\". So we can replicate that.\n\nThus we need to produce a list of lines:\n\n1. Start // 程式開始執行\n2. → Input: expression // 取得輸入字串\n3. → Step 1: Define memo = {} // 快取已計算的子表達式結果\n\n4. → Function diffWays(start, end) // 計算子表達式的所有結果\n5.     → Decision: start > end? // 子表達式無效\n6.         Yes → Return [] // 回傳空結果\n7.         No →\n8.     → Decision: substring(start, end) contains no operator? // 只剩數字\n9.         Yes →\n10.             → Step 2: num = int(substring) // 轉成整數\n11.             → Return [num] // 回傳單一結果\n12.         No →\n13.             → Step 3: results = [] // 儲存所有計算結果\n14.             → Loop i = start to end\n15.                 → Decision: expression[i] is operator? // '+', '-', '*'\n16.                     Yes →\n17.                         → left = diffWays(start, i-1) // 計算左半部\n18.                         → right = diffWays(i+1, end) // 計算右半部\n19.                         → Loop l in left\n20.                             → Loop r in right\n21.                                 → Step 4: if expression[i] == '+': val = l + r\n22.                                 → Step 5: else if expression[i] == '-': val = l - r\n23.                                 → Step 6: else: val = l * r\n24.                                 → Append val to results\n25.                     No →\n26.             → Return results\n\n27. → Step 7: finalResults = diffWays(0, len(expression)-1) // 計算整個表達式\n28. → Return finalResults // 將所有可能結果回傳\n29. End // 程式執行結束\n\nHowever each line must include the arrow only once. For nested lines we need to keep arrow indentation. Example shows:\n\n→ Decision: ... \n    Yes → ...\n    No  → ...\n\nSo indent accordingly. We'll use same pattern. So we need to include indentation spaces before \"Yes →\". The example uses 4 spaces for indentation? They used 4 spaces before \"Yes →\". We'll follow.\n\nThus lines 5-7: \"→ Decision:\" line then sub-lines.\n\nLine 5: \"→ Decision: start > end? // 子表達式無效\"\nLine 6: \"    Yes → Return [] // 回傳空結果\"\nLine 7: \"    No →\"\n\nSimilar for line 8-12.\n\nNow we need to ensure each line has only one arrow. For sub-lines, use indentation but arrow.\n\nNow produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: expression // 取得輸入字串  \n→ Step 1: Define memo = {} // 快取已計算的子表達式結果  \n\n→ Function diffWays(start, end) // 計算子表達式的所有結果  \n→ Decision: start > end? // 子表達式無效  \n    Yes → Return [] // 回傳空結果  \n    No →  \n→ Decision: substring(start, end) contains no operator? // 只剩數字  \n    Yes →  \n        → Step 2: num = int(substring) // 轉成整數  \n        → Return [num] // 回傳單一結果  \n    No →  \n        → Step 3: results = [] // 儲存所有計算結果  \n        → Loop i = start to end  \n            → Decision: expression[i] is operator? // '+', '-', '*',  \n                Yes →  \n                    → left = diffWays(start, i-1) // 計算左半部  \n                    → right = diffWays(i+1, end) // 計算右半部  \n                    → Loop l in left  \n                        → Loop r in right  \n                            → Step 4: if expression[i] == '+': val = l + r  \n                            → Step 5: else if expression[i] == '-': val = l - r  \n                            → Step 6: else: val = l * r  \n                            → Append val to results  \n                No →  \n        → Return results  \n\n→ Step 7: finalResults = diffWays(0, len(expression)-1) // 計算整個表達式  \n→ Return finalResults // 將所有可能結果回傳  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpafyqwour.py\", line 29, in <module>\n    methods, args_list = json.loads(data)\n                         ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 25 (char 24)"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpo3lf_du3.py\", line 29, in <module>\n    methods, args_list = json.loads(data)\n                         ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 73 (char 72)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    建構子接收一個正整數陣列 w，計算前綴和並存起來。\n    pickIndex() 隨機產生一個 1~total 的數字，使用二分搜尋找出最小索引，\n    使 prefix_sum[idx] >= target，回傳該索引。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入為兩個列表：方法名和對應參數\n    methods, args_list = json.loads(data)\n    instance = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            # 建構子，args 為 [[w]]\n            instance = Solution(*args[0])\n            results.append(None)  # 建構子不回傳值\n        elif method == \"pickIndex\":\n            results.append(instance.pickIndex())\n        else:\n            # 若有其他方法，先假設不存在\n            results.append(None)\n\n    # 輸出結果，None 會轉成 JSON 的 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing pickIndex function with weighted random selection. Provide steps: Start, build prefix sums array in constructor, pickIndex generates random number between 0 and total sum, binary search on prefix sums to find index. Provide explanation. Use virtual code syntax as per requirement. Let's craft.\n\nEnsure each line ends with // explanation. Use arrow arrows etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 宣告變數 prefixSum 為空陣列 // 用來存前綴和\n→ Step 2: 宣告變數 totalSum 為 0 // 用來記錄所有權重之和\n→ Decision: w 是否為空陣列? // 檢查輸入合法性\n    Yes → End // 若無權重，直接結束 (可選)\n    No  →  \n→ Step 3: 針對每個索引 i 從 0 到 w.length-1 執行\n    → Step 3a: totalSum ← totalSum + w[i] // 更新總和\n    → Step 3b: prefixSum.append(totalSum) // 將前綴和存入陣列\n→ Step 4: 定義函式 pickIndex() // 建立隨機選取的功能\n    → Step 4a: randomValue ← Random(0, totalSum) // 產生 0~totalSum 的隨機數\n    → Decision: randomValue 與 prefixSum 進行二分搜尋? // 找到最小索引使 prefixSum[i] > randomValue\n        Yes → Step 4b: 找到索引 i 並回傳 i // 返回隨機選取的索引\n        No  → Step 4b: (若未找到，回傳最後一個索引) // 處理極端情況\nEnd // 程式執行結束"
    },
    {
      "title": "H-Index II",
      "source_file": "Leetcode/leetcode275.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def hIndex(self, citations):\n        \"\"\"\n        Compute the h-index for a sorted list of citations in O(log n) time.\n        The algorithm uses binary search to find the smallest index i such that\n        citations[i] >= n - i, where n is the number of papers.\n        The corresponding h-index is then n - i.\n        \"\"\"\n        n = len(citations)\n        left, right = 0, n - 1\n        h = 0\n        while left <= right:\n            mid = (left + right) // 2\n            # n - mid is the number of papers from mid to end\n            if citations[mid] >= n - mid:\n                h = n - mid\n                left = mid + 1          # try to find a larger h\n            else:\n                right = mid - 1         # need more citations\n        return h\n\ndef parse_input(line: str):\n    \"\"\"\n    Parse a single line of input of the form 'citations = [a, b, c]'.\n    \"\"\"\n    if '=' in line:\n        _, expr = line.split('=', 1)\n        return ast.literal_eval(expr.strip())\n    return ast.literal_eval(line.strip())\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Support both single-line and multi-line inputs\n    lines = raw_input.splitlines()\n    if len(lines) == 1:\n        citations = parse_input(lines[0])\n    else:\n        # If multiple lines, assume the first non-empty line contains the list\n        for line in lines:\n            if line.strip():\n                citations = parse_input(line)\n                break\n\n    solution = Solution()\n    result = solution.hIndex(citations)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce pseudocode lines explaining algorithm for h-index with sorted citations ascending. Need log time algorithm: binary search to find first index where citations[i] >= n - i. Wait typical: array sorted ascending, length n. We want maximum h such that at least h papers have >= h citations. Equivalent to find smallest i such that citations[i] >= n - i, then h = n - i. Or binary search for boundary.\n\nWe produce steps: Start; define n; low=0 high=n-1; result=0; while low<=high: mid=(low+high)/2; if citations[mid] >= n-mid: result = n-mid; low = mid+1 else high = mid-1; After loop End. Provide explanation each line. Let's craft virtual code accordingly.\n\nWe need use \"Decision:\" lines etc. Use \"Yes →\" and \"No →\" accordingly. Provide line numbers maybe not required. Just sequential.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 n = citations 的長度 // 取得陣列長度\n→ Step 2: 設定 low = 0, high = n-1, h = 0 // 初始化二分搜尋變數\n→ Decision: 是否還有未檢查區間 (low <= high)? // 判斷是否繼續搜尋\n    Yes → Step 3: 計算 mid = (low + high) // 2 // 取中間索引\n    → Decision: citations[mid] 是否大於等於 (n - mid)? // 判斷是否符合 h 指標\n        Yes → Step 4: 設定 h = n - mid // 更新可能的 h 指標\n            → Step 5: low = mid + 1 // 向右搜尋更大 h\n        No  → Step 6: high = mid - 1 // 向左搜尋較小索引\n    No  → End // 搜尋完成\nEnd // 程式執行結束\n\nBut need \"Yes →\" \"No →\" inside decisions. Use indentation. Provide explanation after //.\n\nLet's produce final output accordingly. Ensure each line ends with // explanation. Use 虛擬碼步驟.\n\nLet's finalize.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n = citations 的長度 // 取得陣列長度  \n→ Step 2: 設定 low = 0, high = n-1, h = 0 // 初始化二分搜尋變數  \n→ Decision: 是否還有未檢查區間 (low <= high)? // 判斷是否繼續搜尋  \n&nbsp;&nbsp;Yes → Step 3: 計算 mid = (low + high) // 2 // 取中間索引  \n&nbsp;&nbsp;&nbsp;&nbsp;Decision: citations[mid] 是否大於等於 (n - mid)? // 判斷是否符合 h 指標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 4: 設定 h = n - mid // 更新可能的 h 指標  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: low = mid + 1 // 向右搜尋更大 h  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → Step 6: high = mid - 1 // 向左搜尋較小索引  \n&nbsp;&nbsp;No  → End // 搜尋完成  \nEnd // 程式執行結束"
    }
  ]
}