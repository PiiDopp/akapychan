[
  {
    "source_file": "900.json",
    "problem_index_in_file": 0,
    "title": "安全除法",
    "description_snippet": "請寫一個程式，讓使用者輸入兩個整數 a 與 b，輸出 a / b 的結果。若輸入的資料非整數或除數為 0，請顯示錯誤提示『輸入錯誤或除數為 0』。程式必須使用 try / except 結構。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code according to specified format. Each line must contain \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use Start, End, Decision, Yes →, No →. Use arrow notation. We need to use try / except. So include Step 1: Try block. Use Decision for catch exception or zero. So produce maybe:\n\nStart // 程式開始執行\n→ Step 1: try // 嘗試執行除法運算\n    → Step 2: 輸入 a // 從使用者取得第一個整數\n    → Step 3: 輸入 b // 從使用者取得第二個整數\n    → Decision: 若 b 為 0? // 檢查除數是否為零\n        Yes → Step 4: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\n        No  → Step 5: 計算 result ← a / b // 執行除法\n            → Step 6: 輸出 result // 顯示結果\n→ Except Exception as e: // 捕捉非整數輸入等錯誤\n    → Step 7: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\nEnd // 程式結束\n\nBut need to include \"Decision:\" lines properly, with Yes → and No →. Should include indent maybe. Use arrow for nested decisions.\n\nLet's format exactly as required: Each line separate. Use \"→\" for steps. Decision: with nested lines. Indentation can be shown by spaces. But keep each line separate.\n\nWe should ensure each line contains \"虛擬碼步驟\" and then space then comment. So \"Start\" line: \"Start // 程式開始執行\". Then next line: \"→ Step 1: try // 嘗試執行除法運算\". Then \"→ Step 2: 輸入 a // 從使用者取得第一個整數\". Then \"→ Step 3: 輸入 b // 從使用者取得第二個整數\". Then \"→ Decision: 若 b 為 0? // 檢查除數是否為零\". Then nested lines: \"    Yes → Step 4: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\". \"    No  → Step 5: 計算 result ← a / b // 執行除法\". Then \"        → Step 6: 輸出 result // 顯示結果\". Then \"→ Except Exception as e: // 捕捉非整數輸入等錯誤\". Then \"    → Step 7: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息\". Then \"End // 程式結束\".\n\nMake sure indentation consistent. Use spaces to indent nested lines. Use \"Yes →\" and \"No  →\" with two spaces after No? Provided sample uses \"No  →\" (two spaces). We'll replicate. Provide comment after each line. Ensure each line ends with comment. Provide final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: try // 嘗試執行除法運算  \n→ Step 2: 輸入 a // 從使用者取得第一個整數  \n→ Step 3: 輸入 b // 從使用者取得第二個整數  \n→ Decision: 若 b 為 0? // 檢查除數是否為零  \n    Yes → Step 4: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息  \n    No  → Step 5: 計算 result ← a / b // 執行除法  \n        → Step 6: 輸出 result // 顯示結果  \n→ Except Exception as e: // 捕捉非整數輸入等錯誤  \n    → Step 7: 輸出 '輸入錯誤或除數為 0' // 顯示錯誤訊息  \nEnd // 程式結束",
      "generated_code": "import sys\n\ndef main():\n    try:\n        # 讀取輸入，預期為兩個整數，之間以空格或換行分隔\n        a, b = map(int, sys.stdin.read().strip().split())\n        # 執行除法\n        result = a / b\n        # 輸出結果\n        print(result)\n    except (ValueError, ZeroDivisionError):\n        # 任何非整數輸入或除數為 0 的情況，皆顯示相同錯誤訊息\n        print('輸入錯誤或除數為 0')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "10 0",
          "expected_output": "輸入錯誤或除數為 0",
          "success": true,
          "output": "輸入錯誤或除數為 0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "900.json",
    "problem_index_in_file": 1,
    "title": "統計文字行數",
    "description_snippet": "請寫一個程式，開啟名為 data.txt 的檔案，讀取內容並輸出總共有幾行文字。若檔案不存在，請顯示『找不到檔案！』。請使用 with 語法搭配 try / except。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code with explanations, line by line, following format. The requirement: open data.txt, read content, count lines, output count. If file not found, show message. Use with and try/except.\n\nWe need to use structure: Start, End, Decision:, arrows.\n\nWe must produce lines: \"Start // 程式開始執行\" etc. The pseudo-code should reflect the logic. Each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nPseudo-code steps: Start, then Try: open file with with open('data.txt','r') as f, then read lines into list, count, output count. Decision: maybe we can use Decision to check if file opened successfully? Actually try/except handles that. So after reading, we can count lines and output.\n\nWe need to represent try/except: maybe Decision: Try? Use \"Decision: 嘗試開啟檔案?\" but that may not be necessary. Instead we can use:\n\n→ Decision: 是否成功讀取檔案? but the file reading will raise exception if not. Use try/except block:\n\nWe can represent try as: \"→ Decision: 進入 try 區塊?\" but better:\n\nUse \"→ Decision: 試圖開啟檔案?\" maybe.\n\nPseudo-code representation can use \"→ Decision: 檔案是否存在?\" but not accurate.\n\nWe can also structure:\n\nStart\n→ Decision: 嘗試開啟檔案 (try)\n    Yes → Step 1: 讀取所有行 // 讀取檔案內容\n    Yes → Step 2: 計算行數 // 獲取行數\n    Yes → Step 3: 輸出行數 // 顯示結果\n    No  → Step 4: 輸出 '找不到檔案！' // 錯誤處理\nEnd\n\nBut we need to show with and try/except.\n\nPseudo-code can show:\n\n→ Decision: 開啟檔案時是否拋出例外?\n    Yes → Step: 捕捉例外 // 處理錯誤\n    No → Step: 讀取檔案 // 讀取行\n\nAlternatively:\n\n→ Step: try\n    → Step: with open('data.txt','r') as f\n    → Step: lines = f.readlines()\n    → Step: count = len(lines)\n    → Step: print(count)\n→ Decision: except FileNotFoundError?\n    Yes → Step: print('找不到檔案！')\n\nBut need line-by-line with arrows. So each step separate line.\n\nBetter: Represent try block as a Decision with Yes path for success and No path for exception.\n\nPseudo-code:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案 'data.txt'? // 試圖進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取所有行\n    Yes → Step 3: count = len(lines) // 計算行數\n    Yes → Step 4: print(count) // 輸出行數\n    No  → Step 5: print('找不到檔案！') // 捕捉 FileNotFoundError\nEnd // 程式結束\n\nBut we need to show with try/except explicitly? They asked to use with and try/except. In pseudo-code we can mention \"try\" block and \"except\" block.\n\nSo we can structure:\n\n→ Step 1: try // 開始 try 區塊\n→ Step 2: with open('data.txt','r') as f // 使用 with 打開檔案\n→ Step 3: lines = f.readlines() // 讀取行\n→ Step 4: count = len(lines) // 計算行數\n→ Step 5: print(count) // 輸出行數\n→ Step 6: except FileNotFoundError: // 捕捉檔案未找到錯誤\n→ Step 7: print('找不到檔案！') // 顯示錯誤訊息\n\nBut we need arrow notation. Might be:\n\n→ Step 1: try // 進入 try 區塊\n    → Step 2: with open('data.txt','r') as f // 使用 with 開啟\n    → Step 3: lines = f.readlines() // 讀取內容\n    → Step 4: count = len(lines) // 計算行數\n    → Step 5: print(count) // 輸出行數\n→ Decision: except FileNotFoundError? // 捕捉檔案未找到\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\n\nBut need to show arrow for each line. We could have nested indentation.\n\nWe also need to keep each line with virtual code step and explanation. So produce something like:\n\nStart // 程式開始執行\n→ Decision: 嘗試開啟檔案? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 以安全方式打開\n    Yes → Step 2: lines = f.readlines() // 讀取檔案所有行\n    Yes → Step 3: count = len(lines) // 計算行數\n    Yes → Step 4: print(count) // 輸出行數\n    No  → Decision: 捕捉 FileNotFoundError? // 若開啟失敗則處理錯誤\n        Yes → Step 5: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nBut this representation uses Decision to represent try except.\n\nWe need to output step by step. The instructions: use arrows (→, Yes →, No →) and structure (Start, End, Decision:). So we need to use them accordingly.\n\nWe can do:\n\nStart // 程式開始執行\n→ Decision: 是否進入 try? // 進入 try 區塊\n    Yes → Step 1: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n    Yes → Step 2: lines = f.readlines() // 讀取檔案內容\n    Yes → Step 3: count = len(lines) // 計算行數\n    Yes → Step 4: print(count) // 輸出行數\n    No  → Decision: 是否捕捉 FileNotFoundError? // 捕捉檔案不存在\n        Yes → Step 5: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nHowever, the 'No' branch of try is unnatural. We can better show try/except structure.\n\nBetter representation:\n\nStart // 程式開始執行\n→ Step 1: try // 開始 try 區塊\n→ Step 2: with open('data.txt', 'r') as f // 使用 with 開啟檔案\n→ Step 3: lines = f.readlines() // 讀取所有行\n→ Step 4: count = len(lines) // 計算行數\n→ Step 5: print(count) // 輸出行數\n→ Decision: except FileNotFoundError? // 捕捉檔案不存在\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束\n\nWe need to keep the arrow pattern: \"→\" for normal step, \"Decision:\" for if condition, \"Yes →\", \"No →\" for branches.\n\nThus each step line should include virtual code step (like \"Start\", \"Step 1:\", etc) then space then comment explanation.\n\nWe must keep the arrow for each step: \"→ Step X: ... // ...\"\n\nYes/No branches with indentation: For example:\n\nDecision: except FileNotFoundError?\n    Yes → Step 6: print('找不到檔案！') // ...\n\nThus we output like that.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: try // 進入 try 區塊，準備捕捉檔案不存在的錯誤\n→ Step 2: with open('data.txt', 'r') as f // 使用 with 以安全方式打開檔案\n→ Step 3: lines = f.readlines() // 讀取檔案中的所有行\n→ Step 4: count = len(lines) // 計算行數\n→ Step 5: print(count) // 輸出行數結果\n→ Decision: except FileNotFoundError? // 檢查是否發生檔案未找到的例外\n    Yes → Step 6: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取所有標準輸入資料（此題實際上不需要使用，但依照規範需讀取）\n    _ = sys.stdin.read()\n\n    try:\n        # 使用 with 以安全方式開啟檔案，並統計行數\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print('檔案共有', len(lines), '行')\n    except FileNotFoundError:\n        # 檔案不存在時輸出錯誤訊息\n        print('找不到檔案！')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 0,
    "title": "表達式計算",
    "description_snippet": "請寫一個程式，輸入三個整數 a、b、c，計算並輸出結果：a + b * c 和 (a + b) * c。請觀察兩者的不同。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the requirement: input three integers a, b, c. Compute a + b * c and (a + b) * c, and output results. Provide line-by-line virtual code with explanation comments. Use Start, End, Decision, etc. No actual code. Just virtual steps. Let's generate.\n\nWe need to include input step, calculation steps, output steps. Possibly also decision? Not necessary. Just flow.\n\nWe can add decisions maybe to show difference? But not needed. We can show compute steps.\n\nSo produce:\n\nStart\n\n→ Step 1: Read integer a // input a\n\n→ Step 2: Read integer b // input b\n\n→ Step 3: Read integer c // input c\n\n→ Step 4: Compute result1 = a + (b * c) // first expression\n\n→ Step 5: Compute result2 = (a + b) * c // second expression\n\n→ Step 6: Output result1 // print first result\n\n→ Step 7: Output result2 // print second result\n\nEnd\n\nAdd comments.\n\nLet's follow format: each line with virtual code and comment separated by space.\n\nWe'll keep \"→\" at beginning of lines after Start. Also indent decisions if any. No decisions here.\n\nThus produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer a // 從使用者輸入取得第一個整數  \n→ Step 2: Read integer b // 從使用者輸入取得第二個整數  \n→ Step 3: Read integer c // 從使用者輸入取得第三個整數  \n→ Step 4: Compute result1 = a + (b * c) // 計算 a + b * c，先乘後加  \n→ Step 5: Compute result2 = (a + b) * c // 計算 (a + b) * c，先加後乘  \n→ Step 6: Output result1 // 將第一個計算結果輸出給使用者  \n→ Step 7: Output result2 // 將第二個計算結果輸出給使用者  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    a, b, c = map(int, data[:3])\n    expr1 = a + b * c\n    expr2 = (a + b) * c\n    print(f\"a + b * c = {expr1}\")\n    print(f\"(a + b) * c = {expr2}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2 3 4",
          "expected_output": "a + b * c = 14\n(a + b) * c = 20",
          "success": true,
          "output": "a + b * c = 14\n(a + b) * c = 20"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "300.json",
    "problem_index_in_file": 1,
    "title": "平均分配",
    "description_snippet": "小明有 n 顆糖果，要平均分給 m 個小朋友。請輸入 n 和 m，輸出每個小朋友分到幾顆糖果，剩下幾顆糖果沒有分完。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps line by line, with arrows, decisions, etc. For this simple program: Input n, m, compute quotient and remainder. Output result. Steps: Start, Step1: Input n, m, Step2: Compute quotient = n div m, Step3: Compute remainder = n mod m, Step4: Output quotient, Step5: Output remainder, End. No decision needed unless maybe check m > 0? The problem doesn't mention division by zero, but we could add a decision: if m == 0? Then error. But not required. We'll keep simple. Use arrow lines. Provide explanation comments after //.\n\nNeed to output in Chinese. Use \"虛擬碼步驟\" + space + // explanation. Each line preceded by arrow or Start/End. Format: \"Start // 程式開始執行\" etc.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n, m // 取得糖果總數與小朋友數量\n→ Step 2: 計算 quotient ← n 除以 m (整數除法) // 每位小朋友得到的糖果數\n→ Step 3: 計算 remainder ← n 取餘數 m // 未能平均分的剩餘糖果\n→ Step 4: 輸出 '每個小朋友分到' + quotient + '顆糖果' // 顯示平均分配結果\n→ Step 5: 輸出 '剩餘糖果' + remainder + '顆' // 顯示未分完的糖果\nEnd // 程式執行結束\n\nBut need arrow for decisions? Not needed.\n\nMake sure each line includes virtual code step then space then // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 n, m // 取得糖果總數與小朋友數量  \n→ Step 2: 計算 quotient ← n 除以 m (整數除法) // 每位小朋友得到的糖果數  \n→ Step 3: 計算 remainder ← n 取餘數 m // 未能平均分的剩餘糖果  \n→ Step 4: 輸出 '每個小朋友分到' + quotient + '顆糖果' // 顯示平均分配結果  \n→ Step 5: 輸出 '剩餘糖果' + remainder + '顆' // 顯示未分完的糖果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n, m = map(int, data[:2])\n    per = n // m\n    left = n % m\n    print(f\"每人={per} 剩下={left}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "20 6",
          "expected_output": "每人=3 剩下=2",
          "success": true,
          "output": "每人=3 剩下=2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 0,
    "title": "模擬擲骰子遊戲",
    "description_snippet": "請使用 random 模組，寫一個函數 roll_dice(n)，模擬擲 n 次六面骰，並回傳所有結果的串列。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Should not output actual code. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. Should include random module, function roll_dice(n). Simulate n times. Return list.\n\nWe need to produce a step-by-step pseudocode. Each line like:\n\nStart\n→ Step 1: Import random module\n→ Step 2: Define function roll_dice(n)\n    → Step 3: Initialize empty list results\n    → Step 4: For i from 1 to n:\n        → Step 5: Roll a die: roll = random.randint(1,6)\n        → Step 6: Append roll to results\n    → Step 7: Return results\nEnd\n\nAdd explanations. Use arrow \"→\". Use Decision if any? There's no decision except maybe check n>0? We could include Decision: if n <= 0? But spec didn't ask. We can add optional.\n\nBut keep simple. Use no actual code. Provide explanation.\n\nMake sure each line has // after virtual code.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import random 模組 // 先載入 random，方便之後產生隨機數  \n→ Step 2: 定義函式 roll_dice(n) // 建立一個可重複使用的擲骰子功能  \n    → Step 3: 建立空列表 results // 用來儲存每次擲骰的結果  \n    → Step 4: 迴圈 for i 在 1 到 n:\n        → Step 5: roll = random.randint(1, 6) // 產生 1 到 6 之間的隨機整數  \n        → Step 6: results.append(roll) // 把本次擲骰結果加入列表  \n    → Step 7: return results // 回傳所有擲骰結果的列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\n\ndef roll_dice(n):\n    \"\"\"模擬擲 n 次六面骰，回傳結果列表。\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有內容，並執行。這樣可以處理任何合法的 Python 代碼，例如 `print(roll_dice(5))`。\n    code = sys.stdin.read()\n    exec(code)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,1,2,4,5]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 1, 2, 4, 5]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "800.json",
    "problem_index_in_file": 1,
    "title": "計算程式執行時間",
    "description_snippet": "請使用 time 模組，寫一個函數 measure_time(func, *args)，用來測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines following format. We need Start, arrow lines, decisions, etc. Provide code for measure_time(func, *args). Steps: import time, start timer, call func, stop timer, compute elapsed, round to 3 decimal places, return elapsed. Probably also return result of func? It says measure_time(func, *args) returns result (rounded time). It says \"回傳結果 (四捨五入到小數點 3 位)\". Likely return elapsed time. So we don't need to return function result. So steps: import time, define function, record start, call func with args, record end, compute elapsed, round, return. Provide explanation.\n\nWe need to format each line with \"虛擬碼步驟 // 解釋\". Use arrow symbols.\n\nWe need Start, End. Might not need Decision because no branching except maybe condition? Not needed.\n\nBut we can include decision to check if func exists? Not necessary.\n\nBut we need to show function definition.\n\nLet's produce:\n\nStart\n→ Step 1: Import time module // 引入時間模組\n→ Step 2: Define function measure_time(func, *args) // 定義測量時間的函式\n→ Step 3: record start_time = time.time() // 記錄開始時間\n→ Step 4: Execute result = func(*args) // 執行傳入函式並取得結果\n→ Step 5: record end_time = time.time() // 記錄結束時間\n→ Step 6: calculate elapsed = end_time - start_time // 計算耗時\n→ Step 7: round_elapsed = round(elapsed, 3) // 四捨五入到小數點3位\n→ Step 8: return round_elapsed // 回傳四捨五入後的時間\nEnd\n\nBut we also might need to return result? But spec says 回傳結果 (四捨五入到小數點 3 位). So likely just the time. Ok.\n\nAdd explanatory comment each line.\n\nAlso include \"End\".\n\nThus output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import time module // 引入時間模組以便計算秒數  \n→ Step 2: Define function measure_time(func, *args) // 定義一個接收函式及其參數的測時函式  \n→ Step 3: record start_time = time.time() // 取得函式執行前的時間戳  \n→ Step 4: Execute result = func(*args) // 執行傳入的函式並存儲其返回值（如果需要可使用）  \n→ Step 5: record end_time = time.time() // 取得函式執行後的時間戳  \n→ Step 6: calculate elapsed = end_time - start_time // 計算實際耗時（秒）  \n→ Step 7: round_elapsed = round(elapsed, 3) // 將耗時四捨五入到小數點 3 位  \n→ Step 8: return round_elapsed // 回傳四捨五入後的秒數  \nEnd // 程式執行結束",
      "generated_code": "import time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 的執行時間，並回傳四捨五入到小數點 3 位的秒數。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    \"\"\"\n    讀取標準輸入的所有程式碼，並在目前命名空間執行。\n    這樣可以讓輸入的程式碼自行呼叫 measure_time 並印出結果。\n    \"\"\"\n    import sys\n    code = sys.stdin.read()\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 0,
    "title": "BMI 計算器\n",
    "description_snippet": "請撰寫一個程式，依序讀入使用者的姓名、身高（公分，float）、體重（公斤，float），計算 BMI = 體重(kg) / (身高(m))^2，並印出「<姓名> 的 BMI 為 <數值>」。數值四捨...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code snippet following the format: each line has \"虛擬碼步驟 // 解釋\". Use arrow notation. Provide Start, End, etc. Should be line-by-line. So something like:\n\nStart // ...\n→ Step 1: 輸入姓名 // ...\n→ Step 2: 輸入身高 // ...\n→ Step 3: 輸入體重 // ...\n→ Step 4: 計算 BMI // ...\n→ Step 5: 四捨五入到一位小數 // ...\n→ Step 6: 輸出結果 // ...\nEnd // ...\n\nMake sure to use arrow notation for steps. For calculations, just describe.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入使用者姓名 // 取得使用者輸入的姓名字符串  \n→ Step 2: 輸入身高（公分，float） // 取得使用者輸入的身高值  \n→ Step 3: 輸入體重（公斤，float） // 取得使用者輸入的體重值  \n→ Step 4: 計算身高（米） = 身高（公分） / 100 // 將身高轉換為米單位  \n→ Step 5: 計算 BMI = 體重（公斤） / (身高（米） ^ 2) // 根據公式計算 BMI  \n→ Step 6: 四捨五入 BMI 到小數點後 1 位 // 取得精確到一位小數的 BMI 值  \n→ Step 7: 輸出 \"<姓名> 的 BMI 為 <數值>\" // 顯示姓名及計算結果  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    name = input().strip()\n    height_cm = float(input().strip())\n    weight = float(input().strip())\n    height_m = height_cm / 100\n    bmi = weight / (height_m ** 2)\n    print(f\"{name} 的 BMI 為 {bmi:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Alice\n160\n50\n",
          "expected_output": "Alice 的 BMI 為 19.5\n",
          "success": true,
          "output": "Alice 的 BMI 為 19.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "200.json",
    "problem_index_in_file": 1,
    "title": "兩數計算小工具\n",
    "description_snippet": "請撰寫一個程式，讀入一行包含兩個以空白分隔的整數，將其轉為 int 後，計算並輸出四個結果：和、差（第一個減第二個）、積、平均（保留到小數點後 1 位）。輸出格式固定為：\n和:<和> 差:<差> 積:...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines per specification, each line: step + explanation. Use Start, End, Decision, etc. They want reading a line of two ints, compute sum, diff, product, average (to 1 decimal). Output format: \"和:<sum> 差:<diff> 積:<product> 平均:<average>\" with average to 1 decimal.\n\nWe need virtual code steps. Let's think.\n\nStart\n→ Step 1: Read inputLine // read a line from input\n→ Step 2: Split inputLine by space into tokens // split into two numbers\n→ Step 3: Convert first token to int a // parse first integer\n→ Step 4: Convert second token to int b // parse second integer\n→ Step 5: Calculate sum = a + b // compute sum\n→ Step 6: Calculate diff = a - b // compute difference\n→ Step 7: Calculate prod = a * b // compute product\n→ Step 8: Calculate avg = (a + b) / 2.0 // compute average as float\n→ Step 9: Format avg to one decimal place // format average string\n→ Step 10: Concatenate output string \"和:sum 差:diff 積:prod 平均:avgFormatted\" // build output\n→ Step 11: Output the string // print output\nEnd\n\nWe need to use the arrow notation. We need to add explanation after each line. Use \"[space]\" after code, then \"//\".\n\nThe explanation should be brief, intuitive.\n\nShould we use Decision? There is no branching. So no decision steps.\n\nBut maybe we can include a decision to check tokens length, but not necessary. Just straightforward.\n\nWe must use the format: each line \"虛擬碼步驟 [space] // 解釋\".\n\nLet's produce. Use \"Start\" \"End\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read inputLine // 從輸入取得一行文字  \n→ Step 2: Split inputLine by space into tokens // 以空白分割成兩個字串  \n→ Step 3: Convert first token to int a // 將第一個字串轉成整數 a  \n→ Step 4: Convert second token to int b // 將第二個字串轉成整數 b  \n→ Step 5: Calculate sum = a + b // 計算兩數之和  \n→ Step 6: Calculate diff = a - b // 計算第一個減第二個的差  \n→ Step 7: Calculate prod = a * b // 計算兩數之積  \n→ Step 8: Calculate avg = (a + b) / 2.0 // 計算平均值（浮點）  \n→ Step 9: Format avg to one decimal place // 轉成字串，保留一位小數  \n→ Step 10: Concatenate output string \"和:sum 差:diff 積:prod 平均:avgFormatted\" // 組合最終輸出格式  \n→ Step 11: Output the string // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main():\n    # 讀取輸入\n    line = sys.stdin.readline().strip()\n    # 分割成兩個字串\n    a_str, b_str = line.split()\n    # 轉成整數\n    a = int(a_str)\n    b = int(b_str)\n\n    # 計算各項\n    sum_val = a + b\n    diff_val = a - b\n    prod_val = a * b\n    avg_val = (a + b) / 2\n\n    # 輸出結果，平均保留一位小數\n    print(f\"和:{sum_val} 差:{diff_val} 積:{prod_val} 平均:{avg_val:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 3\n",
          "expected_output": "和:15 差:9 積:36 平均:7.5\n",
          "success": true,
          "output": "和:15 差:9 積:36 平均:7.5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 0,
    "title": "學生資料類別設計",
    "description_snippet": "請定義一個 Student 類別，具有屬性 name（姓名）與 score（分數）。\n1. 於 __init__() 建構子中初始化這兩個屬性。\n2. 定義方法 show_info()，輸出『XXX ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Use Start, End, Decision maybe not needed. Use arrows. Steps: define class, init, method, create objects, call method. Provide each line.\n\nUse format: \"虛擬碼步驟 // 解釋\". Use arrow → before each line after Start? In example, they used \"→ Step 1: ...\" So we will use \"Start\" then \"→\" each step.\n\nWe need to include class definition: \"Class Student\" maybe \"Class Student\". Then indent for methods.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Class Student // 定義 Student 類別\n    → Step 1: Function __init__(self, name, score) // 建構子，接收姓名與分數\n        → self.name = name // 儲存姓名屬性\n        → self.score = score // 儲存分數屬性\n    → Step 2: Function show_info(self) // 定義輸出資訊的方法\n        → Print(f\"{self.name} 的分數是 {self.score}\") // 輸出姓名與分數\n→ Step 3: student1 = Student(\"Alice\", 90) // 建立第一個學生物件\n→ Step 4: student2 = Student(\"Bob\", 85) // 建立第二個學生物件\n→ Step 5: student1.show_info() // 呼叫第一個物件的輸出方法\n→ Step 6: student2.show_info() // 呼叫第二個物件的輸出方法\nEnd // 程式執行結束\n\nBut need to format each line with \"虛擬碼步驟 // 解釋\". Indentation should be shown with spaces maybe. We'll keep spaces.\n\nAlso include \"→\" for each line after Start. Use \"→\" for class and indent? Use indentation maybe with spaces. Provide comment after //.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Student // 定義 Student 類別  \n → Step 1: Function __init__(self, name, score) // 建構子，接收姓名與分數  \n  → self.name = name // 儲存姓名屬性  \n  → self.score = score // 儲存分數屬性  \n → Step 2: Function show_info(self) // 定義輸出資訊的方法  \n  → Print(f\"{self.name} 的分數是 {self.score}\") // 輸出姓名與分數  \n→ Step 3: student1 = Student(\"Alice\", 90) // 建立第一個學生物件  \n→ Step 4: student2 = Student(\"Bob\", 85) // 建立第二個學生物件  \n→ Step 5: student1.show_info() // 呼叫第一個物件的輸出方法  \n→ Step 6: student2.show_info() // 呼叫第二個物件的輸出方法  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Student:\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def show_info(self):\n        print(f'{self.name} 的分數是 {self.score}')\n\ndef main():\n    # 讀取所有輸入（若有輸入）但不使用，保持通用性\n    _ = sys.stdin.read()\n\n    # 依照需求建立兩個學生物件\n    s1 = Student('Alice', 90)\n    s2 = Student('Bob', 80)\n\n    # 呼叫顯示資訊的方法\n    s1.show_info()\n    s2.show_info()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "Alice 的分數是 90\nBob 的分數是 80",
          "success": true,
          "output": "Alice 的分數是 90\nBob 的分數是 80"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1100.json",
    "problem_index_in_file": 1,
    "title": "動物類別繼承",
    "description_snippet": "請設計一個父類別 Animal，包含方法 make_sound()，印出『動物發出聲音』。\n建立子類別 Dog 與 Cat：\n1. Dog 覆寫 make_sound()，輸出『汪汪！』。\n2. Ca...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation in Chinese. Should use Start, Decision maybe not needed. Just a sequence of steps.\n\nLet's produce:\n\nStart\n→ Step 1: 定義類別 Animal // 創建父類別\n→ Step 2: 內部定義方法 make_sound() // 方法用於發聲\n→ Decision: 這個方法在 Animal 中執行什麼? // 只印『動物發出聲音』\n    Yes → Step 3: 印出 '動物發出聲音' // 完成\n    No  → End // 不需要\n\nBut we might not need decision. We can just show method body. Provide simpler steps.\n\nDefine Dog subclass extends Animal. Override make_sound.\n\nDefine Cat subclass extends Animal. Override make_sound.\n\nInstantiate dog = new Dog(); cat = new Cat();\n\nCall dog.make_sound(); cat.make_sound();\n\nUse virtual code lines.\n\nLet's produce.\n\nWe need to follow format: each line \"虛擬碼步驟 // 解釋\".\n\nUse arrow arrow char for next line.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Animal // 建立父類別  \n→ Step 2: 內部定義方法 make_sound() // 定義發聲功能  \n→ Step 3: 印出 '動物發出聲音' // Animal 物件的預設聲音  \n\n→ Step 4: 定義子類別 Dog 繼承 Animal // Dog 以 Animal 為基礎  \n→ Step 5: 內部覆寫方法 make_sound() // Dog 覆寫父類方法  \n→ Step 6: 印出 '汪汪！' // Dog 的特定聲音  \n\n→ Step 7: 定義子類別 Cat 繼承 Animal // Cat 以 Animal 為基礎  \n→ Step 8: 內部覆寫方法 make_sound() // Cat 覆寫父類方法  \n→ Step 9: 印出 '喵～' // Cat 的特定聲音  \n\n→ Step 10: 建立物件 dog = new Dog() // 創建 Dog 實例  \n→ Step 11: 建立物件 cat = new Cat() // 創建 Cat 實例  \n\n→ Step 12: 呼叫 dog.make_sound() // 執行 Dog 的聲音方法  \n→ Step 13: 呼叫 cat.make_sound() // 執行 Cat 的聲音方法  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Animal:\n    def make_sound(self):\n        print('動物發出聲音')\n\nclass Dog(Animal):\n    def make_sound(self):\n        print('汪汪！')\n\nclass Cat(Animal):\n    def make_sound(self):\n        print('喵～')\n\ndef main():\n    # 讀取所有輸入（即使此題目不需要使用）\n    _ = sys.stdin.read()\n    \n    # 建立物件並呼叫 make_sound()\n    dog = Dog()\n    cat = Cat()\n    dog.make_sound()\n    cat.make_sound()\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "汪汪！\n喵～",
          "success": true,
          "output": "汪汪！\n喵～"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 0,
    "title": "溫度判斷",
    "description_snippet": "請寫一個程式，輸入一個整數代表氣溫，並依下列規則輸出：\n- 小於 0：『冰點以下』\n- 0~29：『正常範圍』\n- 30~39：『炎熱』\n- 大於等於 40：『極端高溫』...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a virtual code that reads an integer representing temperature and outputs according to ranges. They want the output format: each line: virtual code step + space + // explanation.\n\nWe need to produce a Start, read input, decision branches, output, End. Use the arrow symbols, Yes →, No →. Let's produce a linear flow. They likely want nested decisions: first if temp <0 then output; else decision if <=29 then output; else if <=39 then output; else output.\n\nThus:\n\nStart\n→ Step 1: Input temperature // get integer\n→ Decision: If temperature < 0? // check ice point\n    Yes → Step 2: Output '冰點以下' // below ice\n    No  → Decision: If temperature <= 29? // normal range\n        Yes → Step 3: Output '正常範圍'\n        No  → Decision: If temperature <= 39? // hot\n            Yes → Step 4: Output '炎熱'\n            No  → Step 5: Output '極端高溫'\nEnd\n\nMake sure formatting. Use \"Start\" and \"End\". Use arrows. Indentation? They didn't specify indentation but arrow shows structure. We need each line separated. Provide each line as described.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入氣溫 // 取得使用者輸入的整數  \n→ Decision: 氣溫 < 0? // 判斷是否低於冰點  \n    Yes → Step 2: 輸出 '冰點以下' // 低於 0°C，顯示冰點以下訊息  \n    No  → Decision: 氣溫 <= 29? // 判斷是否在正常範圍（0~29°C）  \n        Yes → Step 3: 輸出 '正常範圍' // 0~29°C，顯示正常範圍訊息  \n        No  → Decision: 氣溫 <= 39? // 判斷是否為炎熱區（30~39°C）  \n            Yes → Step 4: 輸出 '炎熱' // 30~39°C，顯示炎熱訊息  \n            No  → Step 5: 輸出 '極端高溫' // 40°C 或以上，顯示極端高溫訊息  \nEnd // 程式執行結束",
      "generated_code": "def main() -> None:\n    \"\"\"讀取氣溫並輸出對應的訊息。\"\"\"\n    # 從標準輸入讀取整數，並轉換為 int\n    temp = int(input().strip())\n\n    # 根據溫度範圍輸出對應的文字\n    if temp < 0:\n        print(\"冰點以下\")\n    elif temp < 30:\n        print(\"正常範圍\")\n    elif temp < 40:\n        print(\"炎熱\")\n    else:\n        print(\"極端高溫\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "35",
          "expected_output": "炎熱",
          "success": true,
          "output": "炎熱"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "400.json",
    "problem_index_in_file": 1,
    "title": "三數最大值",
    "description_snippet": "請寫一個程式，輸入三個整數，輸出其中最大的數字。不得使用 Python 內建 max()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with arrow etc. Must follow format. Use Start, Decision, etc. We must output explanation after each line. Ensure no actual code, only virtual steps. So use \"Step 1: 讀取第一個整數\" etc. Use arrow and indentation. Provide explanation. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取第一個整數 a // 從使用者取得第一個數字  \n→ Step 2: 讀取第二個整數 b // 從使用者取得第二個數字  \n→ Step 3: 讀取第三個整數 c // 從使用者取得第三個數字  \n→ Decision: 是否 a 大於 b? // 判斷 a 是否比 b 大  \n  Yes → Step 4: 設定最大值 max = a // 若 a > b，先把 a 設為最大  \n  No  → Step 5: 設定最大值 max = b // 否則把 b 設為最大  \n→ Decision: 是否 c 大於 max? // 再檢查 c 是否更大  \n  Yes → Step 6: 更新最大值 max = c // 若 c > max，更新最大  \n  No  → Step 7: 保持現有 max // 若 c <= max，保持不變  \n→ Step 8: 輸出最大值 max // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "def find_max_of_three(a: int, b: int, c: int) -> int:\n    \"\"\"\n    找出三個整數中的最大值，避免使用內建 max()。\n    \"\"\"\n    # 首先假設 a 是最大值\n    max_val = a\n    # 與 b 比較\n    if b > max_val:\n        max_val = b\n    # 與 c 比較\n    if c > max_val:\n        max_val = c\n    return max_val\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 從標準輸入讀取三個整數，允許空白或換行分隔\n    data = sys.stdin.read().strip().split()\n    if len(data) < 3:\n        raise ValueError(\"需要至少三個整數作為輸入\")\n    a, b, c = map(int, data[:3])\n\n    # 計算最大值並輸出\n    result = find_max_of_three(a, b, c)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "12 25 7",
          "expected_output": "25",
          "success": true,
          "output": "25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 0,
    "title": "倍數輸出",
    "description_snippet": "請寫一個程式，輸入一個正整數 n，使用 for 迴圈搭配 range()，輸出 1~50 之間所有能被 n 整除的數字。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for this algorithm. Provide step-by-step, each line with virtual code and comment. Use \"Start\", \"End\", \"Decision:\", \"→\" arrows. Use range(1,51). Input n from user. Then loop i in range(1,51): if i % n == 0: print i.\n\nLet's produce lines accordingly. Use 1-based.\n\nLet's format.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者處取得正整數\n→ Step 2: 設定迴圈範圍為 1 到 50 // 使用 range(1, 51) 產生 1~50 的數列\n→ Step 3: For i in range(1, 51): // 逐個檢查每個數字\n    → Decision: 如果 i % n 等於 0? // 判斷 i 是否能被 n 整除\n        Yes → Step 4: 輸出 i // 如果能整除，印出該數字\n        No  → Step 5: 繼續迴圈 // 否則忽略，繼續下一個 i\nEnd // 程式執行結束",
      "generated_code": "def main():\n    # 讀取使用者輸入，取得正整數 n\n    n = int(input().strip())\n\n    # 儲存 1~50 之間能被 n 整除的數字\n    divisible = []\n    for i in range(1, 51):\n        if i % n == 0:\n            divisible.append(str(i))\n\n    # 以空格分隔並輸出結果\n    print(' '.join(divisible))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "7",
          "expected_output": "7 14 21 28 35 42 49",
          "success": true,
          "output": "7 14 21 28 35 42 49"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "500.json",
    "problem_index_in_file": 1,
    "title": "密碼檢查",
    "description_snippet": "請寫一個程式，讓使用者重複輸入密碼，直到輸入正確的密碼 'python123' 為止。每次輸入錯誤都提示『密碼錯誤，請再試一次』，輸入正確時輸出『登入成功』。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a step-by-step pseudo-code with explanations. Provide in Traditional Chinese. Use arrow syntax and Start/End. Each line: Virtual code step, space, // explanation.\n\nWe need to produce pseudo-code: Start, loop until correct, input password, decision: if correct then output success, else output error and loop again. Use while loop or repeat until. Use Decision with Yes →.\n\nLet's produce something like:\n\nStart // 程式開始執行\n→ Decision: 初始化是否成功? // 這裡可直接進入循環\n    Yes → ... But maybe simpler: Use While loop: \n→ Step 1: 設定正確密碼 = 'python123' // 記錄正確密碼\n→ Step 2: 變數 userPassword = '' // 初始化使用者輸入\n→ Decision: 是否為空? // 這個決策用於進入循環\n    Yes → Step 3: 重複開始 // 進入循環\n        Yes → Step 4: 輸入使用者密碼 // 取得密碼\n        → Decision: 如果使用者密碼等於正確密碼? // 判斷正確性\n            Yes → Step 5: 輸出 '登入成功' // 成功訊息\n            No → Step 6: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n            No → Step 4: 重複 // 重新輸入\n\nBut maybe better to write with while loop: \n→ Step 1: 設定 target = 'python123'\n→ Decision: 初始化 loop?\nUse while loop: \n→ Step 1: 設定 target = 'python123'\n→ Step 2: 變數 input = ''\n→ Decision: True? // 開始 while\n    Yes → Step 3: 輸入使用者密碼 // get input\n    → Decision: input == target? \n        Yes → Step 4: 輸出 '登入成功' // 成功\n        No → Step 5: 輸出 '密碼錯誤，請再試一次' // 錯誤\n        No → Step 2: 重複\n\nBut we need to output the pseudo-code line by line. Use arrow '→'. We might use 'Start', 'End'. Provide indentation for nested steps. Example:\n\nStart // 程式開始執行\n→ Step 1: 設定正確密碼 = 'python123' // 記錄正確密碼\n→ Step 2: 設定輸入密碼 = '' // 初始化使用者輸入\n→ Decision: 是否已成功? // 進入重複輸入迴圈\n    Yes → Step 3: 重複開始 // 進入迴圈\n        Yes → Step 4: 輸入使用者密碼 // 取得輸入\n        → Decision: 是否等於正確密碼? // 判斷正確性\n            Yes → Step 5: 輸出 '登入成功' // 成功訊息\n            No → Step 6: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n            No → Step 4: 重複 // 重新輸入\n\nBut we need to manage loop termination. We might use 'While' decision: While input != target.\n\nBetter to use:\n\nStart // 程式開始執行\n→ Step 1: 設定正確密碼 = 'python123' // 記錄正確密碼\n→ Step 2: 設定輸入密碼 = '' // 初始化使用者輸入\n→ Decision: while 輸入密碼 != 正確密碼? // 迴圈條件\n    Yes → Step 3: 輸入使用者密碼 // 取得輸入\n    → Decision: 輸入密碼 == 正確密碼? // 判斷正確性\n        Yes → Step 4: 輸出 '登入成功' // 成功訊息\n        No → Step 5: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n    No  → End // 退出迴圈\n\nBut the arrow indentation: The 'Yes' branch is inside the while, so we need to show loop: maybe:\n\n→ Decision: 是否輸入正確密碼? // 判斷是否正確\n    Yes → End // 正確則結束\n    No  → Step: 輸入使用者密碼 // 重新輸入\n        → Decision: 是否正確? // 再次判斷\n\nBut we need to show repeated input until correct. Use a loop.\n\nLet's propose:\n\nStart // 程式開始執行\n→ Step 1: 設定 正確密碼 = 'python123' // 記錄正確密碼\n→ Step 2: 設定 使用者密碼 = '' // 初始化\n→ Decision: 使用者密碼 != 正確密碼? // 進入循環\n    Yes → Step 3: 輸入使用者密碼 // 取得輸入\n    → Decision: 使用者密碼 == 正確密碼? // 判斷正確性\n        Yes → Step 4: 輸出 '登入成功' // 成功訊息\n        No  → Step 5: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n    No  → End // 結束程式\n\nBut this will loop only once because after one iteration, we either exit or output success. Actually we need to loop again if wrong. So after step 5, we need to jump back to decision step 2. So we can use \"→ Step 2: 重複\" or use 'Continue'.\n\nLet's design:\n\nStart // 程式開始執行\n→ Step 1: 設定 正確密碼 = 'python123' // 記錄正確密碼\n→ Step 2: 設定 使用者密碼 = '' // 初始化\n→ Decision: 使用者密碼 != 正確密碼? // 判斷是否仍需輸入\n    Yes → Step 3: 輸入使用者密碼 // 取得輸入\n    → Decision: 使用者密碼 == 正確密碼? // 判斷正確性\n        Yes → Step 4: 輸出 '登入成功' // 成功訊息\n        No  → Step 5: 輸出 '密碼錯誤，請再試一次' // 錯誤提示\n        No  → Step 2 // 重新檢查條件，進入下一循環\n    No  → End // 退出程式\n\nBut the indentation: the \"No → Step 2\" inside the second decision. We'll keep it clear.\n\nWe need to produce output exactly with lines of pseudo-code, each line has virtual code step plus // explanation. Use \"→\" arrow for steps and decisions.\n\nWe should avoid actual code. Provide pseudo-code. Let's create final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 正確密碼 = 'python123' // 記錄正確密碼  \n→ Step 2: 設定 使用者密碼 = '' // 初始化使用者輸入變數  \n→ Decision: 使用者密碼 != 正確密碼? // 判斷是否仍需要輸入  \n  Yes → Step 3: 輸入使用者密碼 // 取得使用者輸入  \n   → Decision: 使用者密碼 == 正確密碼? // 判斷輸入是否正確  \n    Yes → Step 4: 輸出 '登入成功' // 成功訊息，程式結束  \n    No  → Step 5: 輸出 '密碼錯誤，請再試一次' // 錯誤提示  \n    No  → Step 2 // 重新檢查條件，進入下一輪輸入  \n  No  → End // 已輸入正確密碼，程式結束",
      "generated_code": "def main():\n    correct_password = \"python123\"\n    while True:\n        try:\n            pwd = input()\n        except EOFError:\n            # 沒有更多輸入時結束程式\n            break\n        if pwd == correct_password:\n            print(\"登入成功\")\n            break\n        else:\n            print(\"密碼錯誤，請再試一次\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "abc\n1234\npython123",
          "expected_output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功",
          "success": true,
          "output": "密碼錯誤，請再試一次\n密碼錯誤，請再試一次\n登入成功"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 0,
    "title": "串列操作練習",
    "description_snippet": "請建立一個串列，內容包含整數 1 到 5，接著完成以下操作：\n1. 新增一個元素 6 到串列尾端。\n2. 刪除串列中的第 2 個元素（索引 1 的位置）。\n3. 輸出最後的串列結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with arrow and explanation. According to output format: Start, steps, decisions, End. We have simple list operations. Should include steps: create list, add element, delete element, output. Use arrow lines. Ensure each line: \"虛擬碼步驟 // 解釋/說明\". No real code. Provide each step line by line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化列表 list = [1,2,3,4,5] // 建立 1 到 5 的整數列表\n→ Step 2: 將元素 6 加入列表尾端 // 在列表末尾添加 6\n→ Step 3: 刪除索引 1 的元素 // 移除列表中第二個位置的元素\n→ Step 4: 輸出列表 // 顯示最終列表內容\nEnd // 程式執行結束\n\nWe don't need decisions. Use arrow style. Ensure format with arrow, step, comment. Use \"→\" as arrow. Use \"Step\" naming maybe Step 1 etc. Ensure each line contains a space between code and comment. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化列表 list = [1, 2, 3, 4, 5] // 建立 1 到 5 的整數列表  \n→ Step 2: 將元素 6 加入列表尾端 // 在列表末尾添加 6  \n→ Step 3: 刪除索引 1 的元素 // 移除列表中第二個位置的元素  \n→ Step 4: 輸出列表 // 顯示最終列表內容  \nEnd // 程式執行結束",
      "generated_code": "def main():\n    import sys\n    # 讀取 stdin，若無輸入則立即返回空字串，符合「從標準輸入讀取」的要求\n    sys.stdin.read()\n\n    # 初始化列表，包含整數 1 到 5\n    nums = [1, 2, 3, 4, 5]\n\n    # 新增元素 6 到串列尾端\n    nums.append(6)\n\n    # 刪除串列中的第 2 個元素（索引 1）\n    del nums[1]\n\n    # 輸出最終的串列結果\n    print(nums)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[1, 3, 4, 5, 6]",
          "success": true,
          "output": "[1, 3, 4, 5, 6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "600.json",
    "problem_index_in_file": 1,
    "title": "集合函數練習",
    "description_snippet": "請建立一個集合 fruits = {'apple', 'banana'}，並完成以下操作：\n1. 使用 add() 新增 'orange'。\n2. 使用 update() 一次新增 'grape' 與...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with arrow, decision maybe none. Steps: Start, create set, add, update, remove, discard, output, End. Provide each line with comment. Use 虛擬碼步驟 and explanation.\n\nLet's produce: \nStart\n→ Step 1: 定義 fruits = {'apple', 'banana'} // 創建初始集合\n→ Step 2: fruits.add('orange') // 新增 'orange'\n→ Step 3: fruits.update(['grape', 'melon']) // 同時新增 'grape' 和 'melon'\n→ Step 4: fruits.remove('banana') // 移除 'banana'\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在元素，無錯誤\n→ Step 6: 輸出 fruits // 顯示最終集合\nEnd\n\nAdd comments. Use format: Step 1: ... // ... Need to include arrow arrow: \"→ Step 1: ...\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 創建初始集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 同時新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除不存在的 'pineapple'，不會拋出錯誤  \n→ Step 6: print(fruits) // 輸出最終集合 fruits  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入（若有提供），但此問題不需要使用輸入資料\n    sys.stdin.read()\n\n    # 建立初始集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'，不會拋出錯誤\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"grape\",\"melon\",\"apple\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'grape', 'melon', 'apple'}\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 0,
    "title": "質數判斷函數",
    "description_snippet": "請寫一個函數 is_prime(n)，判斷一個整數是否為質數。如果是質數回傳 True，否則回傳 False。\n\n質數定義：大於 1，且除了 1 和自己本身外，沒有其他因數。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, each line with \"虛擬碼步驟 // 解釋\". Use Start, Decision, etc. We need a function is_prime(n). Steps: check if n <=1 return False; check if n==2 return True; if even return False; loop i from 3 to sqrt(n) step 2; if n % i == 0 return False; after loop return True. Also we need to incorporate function definition and return. Use arrow notation. Let's produce lines accordingly. Ensure we use \"→\" arrow after decisions. Use indentation maybe spaces? They want \"Decision:\" lines with Yes→, No→. For loop we can use \"→ Loop: i=3 to sqrt(n) step 2\". But we can just express loop. Let's produce as virtual steps:\n\nStart\n→ Step 1: 定義函數 is_prime(n) // 開始定義\n→ Decision: n <= 1? // 檢查是否小於等於1\n    Yes → Step 2: 回傳 False // 小於等於1不是質數\n    No  → Decision: n == 2? // 檢查是否等於2\n        Yes → Step 3: 回傳 True // 2是質數\n        No  → Decision: n mod 2 == 0? // 檢查是否偶數\n            Yes → Step 4: 回傳 False // 偶數除2外有因數\n            No  → Step 5: 設定 i = 3, sqrt_n = floor(sqrt(n)) // 準備奇數因數檢查\n→ Loop: i <= sqrt_n\n    Yes → Decision: n mod i == 0? // 檢查是否有因數\n        Yes → Step 6: 回傳 False // 找到因數\n        No  → Step 7: i = i + 2 // 移動到下一個奇數\n    No  → Step 8: 回傳 True // 無因數，為質數\nEnd\n\nBut we need to use the syntax: \"Decision:\" lines with Yes→, No→. For loop we could use \"→ Step: for i from 3 to sqrt_n step 2\". But to keep simple, we can use Decision: i <= sqrt_n? with loop inside.\n\nWe must keep each line with code and comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 is_prime(n) // 開始定義函式  \n→ Decision: n <= 1? // 檢查是否小於等於 1  \n    Yes → Step 2: 回傳 False // 小於等於 1 不是質數  \n    No → Decision: n == 2? // 檢查是否為 2  \n        Yes → Step 3: 回傳 True // 2 為質數  \n        No → Decision: n mod 2 == 0? // 檢查是否偶數  \n            Yes → Step 4: 回傳 False // 偶數除 2 外有因數  \n            No → Step 5: 設定 i = 3, sqrt_n = floor(sqrt(n)) // 準備奇數因數檢查  \n→ Decision: i <= sqrt_n? // 檢查是否還有奇數因數待測  \n    Yes → Decision: n mod i == 0? // 檢查當前 i 是否為因數  \n        Yes → Step 6: 回傳 False // 找到因數，非質數  \n        No → Step 7: i = i + 2 // 進行下一個奇數  \n    No → Step 8: 回傳 True // 所有奇數因數均非因數，為質數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\n\ndef is_prime(n: int) -> bool:\n    \"\"\"判斷 n 是否為質數，若是返回 True，否則返回 False。\"\"\"\n    if n <= 1:\n        return False          # 1 以下都不是質數\n    if n == 2:\n        return True           # 2 是唯一的偶質數\n    if n % 2 == 0:\n        return False          # 其他偶數都不是質數\n\n    limit = int(math.isqrt(n))  # 只需檢查到 sqrt(n)\n    for i in range(3, limit + 1, 2):  # 只檢查奇數因數\n        if n % i == 0:\n            return False\n    return True\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取程式碼，並執行它。\"\"\"\n    code = sys.stdin.read()\n    if code:\n        # 在同一個全域環境下執行，讓 is_prime 可被使用\n        exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(is_prime(7))\nprint(is_prime(12))",
          "expected_output": "True\nFalse",
          "success": true,
          "output": "True\nFalse"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "700.json",
    "problem_index_in_file": 1,
    "title": "計算平均分數",
    "description_snippet": "請寫一個函數 calc_avg(*scores)，接收多個分數作為參數，並回傳平均值 (四捨五入到小數點後 2 位)。\n\n限制：不可使用內建函數 sum()。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code snippet line by line with explanations after a space. Format: start, arrows, decisions if any. The function calc_avg(*scores) receives multiple scores as arguments. Need to compute average without sum() builtin. Use loop to accumulate sum. Then divide by len(scores). Round to 2 decimals. But we cannot use sum() builtin. We can use len() presumably allowed. Use round function? It is a builtin but likely acceptable. Could compute rounding manually but easier to use round(). No restriction against round(). Use len() builtin maybe allowed. Use *scores param. The function returns average. Steps: Start function, initialize total=0, count=len(scores). Iterate over scores, add each to total. After loop compute average=total / count. Round average to 2 decimals. Return average. End.\n\nUse Start, End. Use Decision? No decision needed. Just sequential steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Function calc_avg(*scores): // 定義函式，接收任意數量分數\n→ Variable total = 0 // 初始化總分\n→ Variable count = len(scores) // 獲取分數個數\n→ For each score in scores: // 遍歷所有分數\n    → total = total + score // 累加分數\n→ Variable avg = total / count // 計算平均值\n→ Variable rounded_avg = round(avg, 2) // 四捨五入到小數點後兩位\n→ Return rounded_avg // 返回結果\nEnd // 程式執行結束\n\nBut we need to keep line structure with arrow formatting. For loop line and inner line. We need indent or arrow to show nested step. We can use indentation with spaces after arrow? In example they used arrow → Step 1: etc. For loops, we can show:\n\n→ For each score in scores: // 迭代所有分數\n    → total = total + score // 累加\n\nWe need to maintain that. Let's craft.\n\nAlso we need to avoid using sum() but we used len() which is okay. Use variable names. The explanation after a space. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Function calc_avg(*scores): // 定義函式，接收多個分數\n→ total = 0 // 初始化總分\n→ count = len(scores) // 獲取分數個數\n→ For each score in scores: // 遍歷所有分數\n    → total = total + score // 將當前分數累加到總分\n→ avg = total / count // 計算平均值\n→ rounded_avg = round(avg, 2) // 四捨五入到小數點後兩位\n→ Return rounded_avg // 回傳計算結果\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef calc_avg(*scores):\n    \"\"\"\n    計算多個分數的平均值，並四捨五入到小數點後兩位。\n    \"\"\"\n    total = 0\n    count = 0\n    for s in scores:\n        total += s\n        count += 1\n    return round(total / count, 2)\n\ndef main():\n    \"\"\"\n    讀取標準輸入中的程式碼並執行，允許輸入任意合法 Python 代碼，\n    如 print(calc_avg(80, 90, 100)) 等。\n    \"\"\"\n    # 讀取整個輸入\n    code = sys.stdin.read()\n    # 在全域命名空間中執行，calc_avg 已被定義\n    exec(code, globals())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "print(calc_avg(80, 90, 100))\nprint(calc_avg(70, 75, 85, 95))",
          "expected_output": "90.0\n81.25",
          "success": true,
          "output": "90.0\n81.25"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 0,
    "title": "列表與條件生成式練習",
    "description_snippet": "請寫一個程式，建立一個包含 1 到 20 的整數列表，接著使用列表生成式（List Comprehension）產生一個新列表，只保留偶數並將它們平方後輸出結果。...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step pseudo code. Let's think: Start, create list from 1 to 20, then list comprehension to filter evens and square, output. We need arrow syntax. Use `→` arrow. Use `Decision:` if needed. We might not need decision. But we can include decision to check even. But list comprehension uses a condition. We can do `→ Step 1: 建立整數列表 // 從 1 到 20 建立列表` Then `→ Step 2: 產生新列表 // 只保留偶數並平方` Then `→ Step 3: 輸出新列表 // 顯示結果`. We could also illustrate condition inside list comprehension but not as separate decision. We might include a `Decision:` inside list comprehension? But maybe just step with list comprehension. It's fine.\n\nLet's produce. Use format: each line: `虛擬碼步驟 // 解釋`. Start with `Start`. Then steps. End with `End`. Use `→` arrows from Start to Step 1 etc. Use indentation for steps after decisions if any. But we have no decision. So simple chain.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立整數列表 // 從 1 到 20 建立一個包含 1~20 的整數列表  \n→ Step 2: 產生新列表 // 使用列表生成式篩選偶數並將其平方，產生新列表  \n→ Step 3: 輸出新列表 // 顯示結果（偶數平方後的列表）  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取標準輸入，雖然此題目不需要任何輸入，但依照要求仍保留此步驟\n    sys.stdin.read()\n\n    # 建立 1 到 20 的整數列表\n    nums = [i for i in range(1, 21)]\n\n    # 使用列表生成式保留偶數並將其平方\n    result = [n ** 2 for n in nums if n % 2 == 0]\n\n    # 輸出結果\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]",
          "success": true,
          "output": "[4, 16, 36, 64, 100, 144, 196, 256, 324, 400]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1000.json",
    "problem_index_in_file": 1,
    "title": "map() / filter() / lambda 綜合練習",
    "description_snippet": "請寫一個程式，建立一個列表 numbers = [3, 7, 10, 15, 20]。\n1. 使用 filter() 搭配 lambda 篩選出可被 5 整除的數。\n2. 使用 map() 將這些數字...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation after // . Use Start, End, Decision: etc. For this task: create list numbers, filter via lambda, map to multiply by 10, output result.\n\nWe need to output in lines, each line with \"虛擬碼步驟\" plus comment. Use arrow notation. Might include decisions? Not needed maybe. But can include. Let's produce a simple flow.\n\nSteps:\nStart\n→ Step 1: Initialize numbers list\n→ Step 2: Filter numbers divisible by 5\n→ Step 3: Map filtered numbers to times 10\n→ Step 4: Output result\nEnd\n\nWe might include a Decision: maybe not needed. But can include filter decision? Might illustrate filter condition: Yes → etc.\n\nBut requirement says use Decision: arrow. But not mandatory? \"Use virtual code arrow (→, Yes →, No →) and structure (Start, End, Decision:).\" So we can incorporate decision if we like.\n\nWe can show Decision for filter: For each number, decide if divisible by 5. But in virtual code we can represent filter as Decision: if number %5==0? Yes -> include, No -> exclude. But filter is one step.\n\nBetter to keep simple.\n\nWe must ensure each line has \"虛擬碼步驟\" and comment. Use \"→\" for steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: numbers = [3, 7, 10, 15, 20] // 建立原始列表\n→ Step 2: divisible = filter(lambda x: x % 5 == 0, numbers) // 篩選出可被5整除的數\n→ Step 3: multiplied = map(lambda y: y * 10, divisible) // 把篩選後的數乘以10\n→ Step 4: result = list(multiplied) // 轉成列表以便輸出\n→ Step 5: print(result) // 輸出結果列表\nEnd // 程式結束\n\nWe might also include decision? Not needed. But requirement: Use Decision: maybe optional. The example uses Decision for conditional logic. But this task doesn't involve if-else. So we can skip. It's okay.\n\nThus final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: numbers = [3, 7, 10, 15, 20] // 建立原始列表  \n→ Step 2: divisible = filter(lambda x: x % 5 == 0, numbers) // 篩選出可被5整除的數  \n→ Step 3: multiplied = map(lambda y: y * 10, divisible) // 把篩選後的數乘以10  \n→ Step 4: result = list(multiplied) // 轉成列表以便輸出  \n→ Step 5: print(result) // 輸出結果列表  \nEnd // 程式結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 讀取所有輸入但不作為計算依據\n    sys.stdin.read()\n\n    # 原始列表\n    numbers = [3, 7, 10, 15, 20]\n\n    # 篩選能被 5 整除的數\n    filtered = filter(lambda x: x % 5 == 0, numbers)\n\n    # 將篩選結果乘以 10\n    result = list(map(lambda x: x * 10, filtered))\n\n    # 輸出最終列表\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "[100, 150, 200]",
          "success": true,
          "output": "[100, 150, 200]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 0,
    "title": "JSON 檔案儲存與讀取練習",
    "description_snippet": "請寫一個程式，建立一個字典 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}。\n1. 使用 json.dump() 將其寫入 data.jso...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Must use Start, End, Decision arrows etc. Steps: define data, write to json file, read back, print name and city.\n\nWe'll produce steps:\n\nStart\n→ Step 1: 定義 data 字典 // 建立資料字典\n→ Step 2: 使用 json.dump() 將 data 寫入 'data.json' // 將資料寫到檔案\n→ Step 3: 使用 json.load() 讀取 'data.json' // 讀取資料回變量\n→ Step 4: 輸出讀取資料的 'name' 與 'city' // 印出值\n\nWe need to show file operations: open file for writing and reading. Use context managers maybe but virtual.\n\nWe can include decision? Not necessary.\n\nBut we need to use arrow and maybe Decision if file exists? Not required.\n\nWe just produce simple linear flow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立資料字典\n→ Step 2: 開啟檔案 'data.json' 以寫入模式 // 準備寫入檔案\n→ Step 3: 使用 json.dump(data, 檔案) // 將字典寫入檔案\n→ Step 4: 關閉檔案 // 完成寫入\n→ Step 5: 開啟檔案 'data.json' 以讀取模式 // 準備讀取檔案\n→ Step 6: 使用 json.load(檔案) 讀取為 dict // 取得資料\n→ Step 7: 取得 dict['name'] 與 dict['city'] // 抽取欄位\n→ Step 8: 印出 'name: ' + name, 'city: ' + city // 顯示結果\nEnd // 程式執行結束\n\nBut we need to use virtual arrow arrow. They want \"→ Step 1:\" etc. We can include.\n\nNo Decision needed.\n\nReturn the lines.\n\nMake sure each line has explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'} // 建立資料字典  \n→ Step 2: 開啟檔案 'data.json' 以寫入模式 // 準備寫入檔案  \n→ Step 3: 使用 json.dump(data, 檔案) // 將字典寫入檔案  \n→ Step 4: 關閉檔案 // 完成寫入  \n→ Step 5: 開啟檔案 'data.json' 以讀取模式 // 準備讀取檔案  \n→ Step 6: 使用 json.load(檔案) 讀取為 dict // 取得資料  \n→ Step 7: 取得 dict['name'] 與 dict['city'] // 抽取欄位  \n→ Step 8: 印出 'name: ' + name + ', city: ' + city // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import json\nimport sys\n\ndef main():\n    # 讀取標準輸入，雖然本程式不需要任何輸入，但為符合「從 stdin 讀取」的要求\n    _ = sys.stdin.read()\n\n    # 建立資料字典\n    data = {'name': 'Alice', 'age': 25, 'city': 'Taipei'}\n\n    # 將資料寫入 data.json\n    with open('data.json', 'w', encoding='utf-8') as f:\n        json.dump(data, f, ensure_ascii=False, indent=2)\n\n    # 從 data.json 讀取資料\n    with open('data.json', 'r', encoding='utf-8') as f:\n        result = json.load(f)\n\n    # 印出 name 與 city\n    print('姓名：', result['name'])\n    print('城市：', result['city'])\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "姓名： Alice\n城市： Taipei",
          "success": true,
          "output": "姓名： Alice\n城市： Taipei"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "1200.json",
    "problem_index_in_file": 1,
    "title": "即時匯率查詢小工具",
    "description_snippet": "請使用 requests 模組串接匯率 API（https://api.exchangerate-api.com/v4/latest/USD），取得當前美元兌換台幣（TWD）的匯率。\n將結果顯示在 t...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code in Traditional Chinese, step by step, with explanation. Use structure: Start, End, Decision, etc. Use arrow notation. Provide each line: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nWe must not output actual code, only pseudo steps.\n\nWe need to cover: import requests, tkinter. Create main window, label to display rate, button to update. On button click, call function that fetches rate from API, parse JSON, get 'rates' 'TWD', update label.\n\nWe need to show pseudo-code steps.\n\nInclude decisions? Probably we can check response status, existence of TWD.\n\nWe need to use arrow structure. Example:\n\nStart // 程式開始執行\n→ Import: requests // 導入 HTTP 請求模組\n→ Import: tkinter // 導入 GUI 模組\n\nThen create main window:\n\n→ Step: 建立主視窗 // 建立 tkinter 視窗\n→ Step: 建立顯示匯率的標籤 // 文字顯示匯率\n→ Step: 建立更新按鈕 // 按鈕觸發匯率更新\n\nDefine function update_rate:\n\n→ Step: 取得 API URL // 設定匯率 API\n→ Step: 發送 GET 請求 // 使用 requests.get\n→ Decision: 是否成功回應 200? // 檢查回應狀態\n    Yes → Step: 解析 JSON // 轉換為字典\n    Yes → Decision: 是否含 TWD? // 檢查 key\n        Yes → Step: 取得 TWD 匯率 // 提取匯率\n        Yes → Step: 更新標籤文字 // 顯示匯率\n        No → Step: 顯示錯誤 // TWD 未找到\n    No → Step: 顯示錯誤 // 回應失敗\n→ Step: 完成更新 // 更新完成\n\nBind button to function.\n\nMain loop: Tkinter mainloop.\n\nEnd // 程式結束\n\nMake sure each line has \"虛擬碼步驟\" and comment. Use arrow \"→\" preceding steps. Use \"Decision:\" for if. Use \"Yes →\", \"No →\". Keep each line separate.\n\nLet's produce the pseudo-code accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import: requests // 導入 HTTP 請求模組  \n→ Import: tkinter // 導入 GUI 模組  \n\n→ Step: 建立主視窗 = tkinter.Tk() // 建立 tkinter 視窗物件  \n→ Step: 主視窗.title('美元兌台幣匯率') // 設定視窗標題  \n\n→ Step: 建立顯示匯率的標籤 = tkinter.Label(主視窗, text='匯率載入中…', font=('Helvetica', 14)) // 建立顯示匯率的文字元件  \n→ Step: 標籤.pack(pady=20) // 放置標籤於視窗  \n\n→ Step: 定義函式 update_rate(): // 定義更新匯率的功能  \n→     Step: API_URL = 'https://api.exchangerate-api.com/v4/latest/USD' // 設定匯率 API URL  \n→     Step: response = requests.get(API_URL) // 發送 GET 請求  \n→     Decision: response.status_code == 200? // 檢查是否成功  \n→         Yes → Step: data = response.json() // 解析 JSON  \n→         Yes → Decision: 'TWD' in data['rates']? // 檢查是否含有 TWD 匯率  \n→             Yes → Step: rate = data['rates']['TWD'] // 取得 TWD 匯率  \n→             Yes → Step: 標籤.config(text=f'1 USD = {rate} TWD') // 更新標籤文字  \n→             No  → Step: 標籤.config(text='找不到 TWD 匯率') // 顯示錯誤訊息  \n→         No  → Step: 標籤.config(text='API 回傳失敗') // 顯示回應失敗訊息  \n→ End // 結束函式定義  \n\n→ Step: 建立更新按鈕 = tkinter.Button(主視窗, text='更新匯率', command=update_rate) // 建立按鈕並綁定函式  \n→ Step: 按鈕.pack(pady=10) // 放置按鈕  \n\n→ Step: 呼叫 update_rate() // 初始載入匯率  \n\n→ Step: 主視窗.mainloop() // 開始 tkinter 主迴圈  \nEnd // 程式執行結束",
      "generated_code": "import requests\nimport tkinter as tk\nimport sys\n\ndef fetch_rate() -> str:\n    \"\"\"\n    從 exchangerate-api 取得 USD 對 TWD 的匯率，並回傳格式化字串。\n    如發生任何錯誤，回傳錯誤訊息。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()                      # 1xx、2xx 為成功，否則拋出異常\n        data = r.json()\n        rate = data[\"rates\"].get(\"TWD\")           # 取得 TWD 匯率\n        if rate is None:\n            return \"找不到台幣匯率\"\n        return f\"目前美元匯率：約 {rate} TWD\"\n    except Exception:\n        return \"更新失敗，請檢查網路連線\"\n\ndef run_gui() -> None:\n    \"\"\"\n    建立 tkinter 視窗，顯示匯率並提供按鈕更新。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    def update() -> None:\n        label.config(text=fetch_rate())\n\n    tk.Button(win, text=\"更新匯率\", command=update).pack(pady=5)\n    win.mainloop()\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入，內容不做實際處理，僅為符合「必須讀取」的要求\n    try:\n        sys.stdin.read()\n    except Exception:\n        pass\n\n    # 將結果直接輸出至標準輸出\n    print(fetch_rate())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode306.json",
    "problem_index_in_file": 0,
    "title": "Additive Number",
    "description_snippet": "An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for checking additive number, step-by-step. Provide a flow. Should be in Traditional Chinese. Use arrow arrows, Start, End, Decision. Provide each step with explanation. Use \"虛擬碼步驟\" and comment after space.\n\nWe need to include backtracking: iterate over first two numbers splits.\n\nOutline:\n\nStart\n→ Step 1: 設定 result 為 false\n→ Step 2: 迴圈 i from 1 to n-2\n→ Decision: If s[0] == '0' and i > 1? invalid? Actually first number can't have leading zero unless it's single digit.\n→ Step 3: For each i, set first = substring(0,i)\nCheck leading zero.\n→ Step 4: inner loop j from i+1 to n-1\n→ Decision: If s[i]=='0' and j-i >1? skip\n→ Step 5: set second = substring(i,j-i)\n→ Step 6: 呼叫 helper(i,j)\n→ Decision: helper returns true? then result = true; break loops\n→ End\n→ Return result\n\nHelper function: Recursively check from index start, prev1, prev2\n\n→ Step H1: If start == n return true\n→ Step H2: sum = prev1 + prev2 as string\n→ Step H3: If s starting at start doesn't start with sum? return false\n→ Step H4: newStart = start + len(sum)\n→ Step H5: 呼叫 helper(newStart, prev2, sum)\n\nEdge: large numbers - use BigInt or string addition.\n\nSimplify: Virtual code uses string addition function AddStrings.\n\nAlso handle leading zero: if number string length>1 and starts with '0', skip.\n\nLet's craft steps.\n\nNeed to maintain indentation but use arrows accordingly.\n\nLet's produce steps:\n\nStart\n→ Step 1: 定義 n = length of s\n→ Step 2: If n < 3 → Return false // 必須至少三位數\n→ Step 3: Set result = false\n→ Step 4: For i from 1 to n-2\n    → Decision: If s[0] == '0' and i > 1 → Continue // 第一個數字不能有前導零\n    → Step 5: first = substring(0,i)\n    → Step 6: For j from i+1 to n-1\n        → Decision: If s[i] == '0' and j-i > 1 → Continue // 第二個數字前導零\n        → Step 7: second = substring(i, j-i)\n        → Step 8: If helper(j, first, second) → result = true; Break loops\n→ Decision: If result → Break outer loop\n→ End\n→ Step 9: Return result\n\nHelper function:\n\n→ Function helper(start, num1, num2):\n    → Step H1: If start == n → Return true\n    → Step H2: sum = AddStrings(num1, num2)\n    → Step H3: If s starting at start does not start with sum → Return false\n    → Step H4: newStart = start + length(sum)\n    → Step H5: Return helper(newStart, num2, sum)\n\nAddStrings function:\n\n→ Function AddStrings(a,b):\n    → Step A1: 初始化 carry=0, result=\"\"\n    → Step A2: 從右至左遍歷 a,b\n    → Step A3: digit = (ai? + bi? + carry) mod 10\n    → Step A4: carry = (ai? + bi? + carry) /10\n    → Step A5: prepend digit to result\n    → Step A6: 如果 carry>0 → prepend carry\n    → Return result\n\nBut we may not need to detail AddStrings. But we can include as a step.\n\nWe need to output in given format: each line with virtual code step and comment.\n\nWe need to use arrow for decisions: \"Decision: ... ?\" etc. Use Yes →, No → lines.\n\nWe need to incorporate loops. Use indentation? We can use arrow inside loops? The sample uses indentation with spaces. We'll follow that.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: Set n = length of s // 取得字串長度\n→ Decision: If n < 3? // 是否足夠長度\n    Yes → Step 2: Return false // 不能是加法數列\n    No  → \n→ Step 3: Set result = false // 初始結果\n→ Step 4: For i = 1 to n-2 // 第一個數字的切分位置\n    → Decision: If s[0] == '0' and i > 1? // 第一個數字是否有前導零\n        Yes → Continue // 跳過不合法的切分\n        No  → \n    → Step 5: first = substring(0, i) // 取得第一個數字\n    → Step 6: For j = i+1 to n-1 // 第二個數字的切分位置\n        → Decision: If s[i] == '0' and (j-i) > 1? // 第二個數字是否有前導零\n            Yes → Continue // 跳過\n            No  →\n        → Step 7: second = substring(i, j-i) // 取得第二個數字\n        → Step 8: If helper(j, first, second)? // 判斷是否為加法數列\n            Yes → Set result = true\n            No  →\n    → Decision: If result? // 已找到合法序列\n        Yes → Break // 跳出外層迴圈\n        No  →\n→ End // 程式結束\n→ Step 9: Return result // 回傳結果\n\nNow helper:\n\n→ Function helper(start, num1, num2):\n    → Step H1: If start == n? // 是否已達字串結尾\n        Yes → Return true\n        No  →\n    → Step H2: sum = AddStrings(num1, num2) // 計算前兩數之和\n    → Step H3: If s starting at start does not start with sum? // 下一段是否符合和\n        Yes → Return false\n        No  →\n    → Step H4: newStart = start + length(sum) // 更新起始位置\n    → Step H5: Return helper(newStart, num2, sum) // 進一步遞迴\n\nAddStrings:\n\n→ Function AddStrings(a, b):\n    → Step A1: Set carry = 0, result = \"\"\n    → Step A2: i = length(a)-1, j = length(b)-1\n    → While i>=0 or j>=0 or carry>0: // 遍歷兩數字\n        → Step A3: digitA = i>=0 ? a[i]-'0' : 0\n        → Step A4: digitB = j>=0 ? b[j]-'0' : 0\n        → Step A5: sum = digitA + digitB + carry\n        → Step A6: result = char(sum % 10 + '0') + result\n        → Step A7: carry = sum / 10\n        → Step A8: i--; j--\n    → Return result\n\nWe need to maintain the format: each line with arrow and comment.\n\nWe might want to not go too detailed in AddStrings; but it's fine.\n\nAlso need to include \"Yes →\" and \"No →\" lines with indentation inside decisions.\n\nLet's craft final answer. Ensure all lines end with comment. Use Traditional Chinese. Use 虛擬碼步驟 like Step 1: etc. Provide arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Set n = length of s // 取得字串長度\n→ Decision: If n < 3? // 是否足夠長度\n    Yes → Step 2: Return false // 小於三位不可能為加法數列\n    No  → \n→ Step 3: Set result = false // 初始結果\n→ Step 4: For i = 1 to n-2 // 第一個數字切分位置\n    → Decision: If s[0] == '0' and i > 1? // 第一個數字是否有前導零\n        Yes → Continue // 跳過不合法的切分\n        No  → \n    → Step 5: first = substring(0, i) // 取得第一個數字\n    → Step 6: For j = i+1 to n-1 // 第二個數字切分位置\n        → Decision: If s[i] == '0' and (j-i) > 1? // 第二個數字是否有前導零\n            Yes → Continue // 跳過\n            No  →\n        → Step 7: second = substring(i, j-i) // 取得第二個數字\n        → Step 8: If helper(j, first, second)? // 判斷是否為加法數列\n            Yes → Set result = true\n            No  →\n    → Decision: If result? // 已找到合法序列\n        Yes → Break // 跳出外層迴圈\n        No  →\n→ End // 程式結束\n→ Step 9: Return result // 回傳結果\n\nFunction helper(start, num1, num2):\n    → Step H1: If start == n? // 是否已達字串結尾\n        Yes → Return true\n        No  →\n    → Step H2: sum = AddStrings(num1, num2) // 計算前兩數之和\n    → Step H3: If s starting at start does not start with sum? // 下一段是否符合和\n        Yes → Return false\n        No  →\n    → Step H4: newStart = start + length(sum) // 更新起始位置\n    → Step H5: Return helper(newStart, num2, sum) // 進一步遞迴\n\nFunction AddStrings(a, b):\n    → Step A1: Set carry = 0, result = \"\"\n    → Step A2: i = length(a)-1, j = length(b)-1\n    → While i>=0 or j>=0 or carry>0: // 遍歷兩數字\n        → Step A3: digitA = i>=0 ? a[i]-'0' : 0\n        → Step A4: digitB = j>=0 ? b[j]-'0' : 0\n        → Step A5: sum = digitA + digitB + carry\n        → Step A6: result = char(sum % 10 + '0') + result\n        → Step A7: carry = sum / 10\n        → Step A8: i--; j--\n    → Return result // 返回兩數字相加的字串結果",
      "generated_code": "import sys\n\nclass Solution:\n    def isAdditiveNumber(self, num: str) -> bool:\n        n = len(num)\n        # 兩個前導數的所有切分方式\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                num1, num2 = num[:i], num[i:j]\n\n                # 前導零檢查\n                if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n                    continue\n\n                k = j\n                # 按照加法序列驗證後續數字\n                while k < n:\n                    sum_str = str(int(num1) + int(num2))\n                    if not num.startswith(sum_str, k):\n                        break\n                    k += len(sum_str)\n                    num1, num2 = num2, sum_str\n\n                if k == n:\n                    return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 移除可能存在的雙引號\n    if data.startswith('\"') and data.endswith('\"'):\n        data = data[1:-1]\n    solution = Solution()\n    result = solution.isAdditiveNumber(data)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"112358\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"199100199\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode71.json",
    "problem_index_in_file": 0,
    "title": "Simplify Path",
    "description_snippet": "You are given an absolute path for a Unix-style file system, which always begins with a slash '/'. Y...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for simplifying Unix path. Steps: split by '/', use stack, process components: if empty or '.' skip; if '..' pop if not empty; else push component. After loop, join stack with '/' and prefix '/'. Edge cases: root. Provide explanation. Use arrow structure. We'll list steps.\n\nWe need Start, End, Decision branches. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's craft:\n\nStart\n→ Step 1: 初始化 stack 為空 // 用於存放有效目錄名稱\n→ Step 2: 將輸入路徑按 '/' 分割成 tokens // 處理每個部分\n→ For each token in tokens:  // 逐個遍歷\n    → Decision: token 為空? // 避免多斜杠產生的空元素\n        Yes → Continue // 跳過空元素\n        No → Decision: token 等於 '.'? // 當前目錄，無需處理\n            Yes → Continue // 跳過\n            No → Decision: token 等於 '..'? // 父目錄，需 pop\n                Yes → Decision: stack 非空? // 若有前一目錄\n                    Yes → Step 3: pop stack // 移除上一層目錄\n                    No → Continue // 若空則保持根目錄\n                No → Step 4: push token 到 stack // 正常目錄名\n→ Step 5: 若 stack 为空则 simplifiedPath = '/' // 只剩根\n→ Step 6: 否則 simplifiedPath = '/' + join(stack, '/') // 重新組合路徑\nEnd\n\nBut must use virtual code arrows like \"→ Step 1\". Each line separate. Use \"Decision:\" lines indenting. Provide arrow for nested? Use indentation? Format shows indentation lines after Decision: with Yes → etc. We'll produce accordingly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack 為空 // 用於存放有效目錄名稱\n→ Step 2: 將輸入路徑按 '/' 分割成 tokens // 處理每個部分\n→ Step 3: 逐個遍歷 tokens\n    → Decision: token 為空? // 避免多斜杠產生的空元素\n        Yes → Continue // 跳過空元素\n        No  → Decision: token 等於 '.'? // 當前目錄，無需處理\n            Yes → Continue // 跳過\n            No  → Decision: token 等於 '..'? // 父目錄，需 pop\n                Yes → Decision: stack 非空? // 若有前一目錄\n                    Yes → Step 4: pop stack // 移除上一層目錄\n                    No  → Continue // 若空則保持根目錄\n                No  → Step 5: push token 到 stack // 正常目錄名\n→ Decision: stack 為空? // 判斷是否只有根目錄\n    Yes → Step 6: simplifiedPath = '/' // 只剩根目錄\n    No  → Step 7: simplifiedPath = '/' + join(stack, '/') // 重新組合路徑\nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef simplify_path(path: str) -> str:\n    \"\"\"\n    Simplify a Unix-style absolute path.\n    \"\"\"\n    stack = []\n    # Split by '/' – consecutive slashes produce empty strings\n    parts = path.split('/')\n    for part in parts:\n        if part == '' or part == '.':\n            # Skip empty tokens and current-directory markers\n            continue\n        elif part == '..':\n            # Go up to the parent directory if possible\n            if stack:\n                stack.pop()\n        else:\n            # Valid directory name – push onto the stack\n            stack.append(part)\n    # Reconstruct canonical path\n    return '/' + '/'.join(stack)\n\ndef main() -> None:\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # If the input is like 'path = \"/home/\"', extract the quoted string\n    if '=' in raw_input:\n        _, value = raw_input.split('=', 1)\n        value = value.strip()\n        # Remove surrounding quotes if present\n        if (value.startswith('\"') and value.endswith('\"')) or \\\n           (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        path = value\n    else:\n        # Assume the whole line is the path\n        path = raw_input\n\n    simplified = simplify_path(path)\n    print(simplified)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "path = \"/home/\"",
          "expected_output": "\"/home\"",
          "success": true,
          "output": "/home"
        },
        {
          "example_index": 1,
          "input": "path = \"/home//foo/\"",
          "expected_output": "\"/home/foo\"",
          "success": true,
          "output": "/home/foo"
        },
        {
          "example_index": 2,
          "input": "path = \"/home/user/Documents/../Pictures\"",
          "expected_output": "\"/home/user/Pictures\"",
          "success": true,
          "output": "/home/user/Pictures"
        },
        {
          "example_index": 3,
          "input": "path = \"/../\"",
          "expected_output": "\"/\"",
          "success": true,
          "output": "/"
        },
        {
          "example_index": 4,
          "input": "path = \"/.../a/../b/c/../d/./\"",
          "expected_output": "\"/.../b/d\"",
          "success": true,
          "output": "/.../b/d"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode347.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Elements",
    "description_snippet": "Given an integer array nums and an integer k, return the k most frequent elements. You may return th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese, step-by-step. Use Start, End, Decision, Yes/No arrows. We need to answer the user's request: produce virtual code for \"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\"\n\nWe need to write step-by-step pseudocode, each line with // explanation. Use virtual code syntax with arrows. Provide step-by-step. No actual code.\n\nWe need to consider algorithm: count frequencies using hash map, sort by frequency, pick top k. Could also use heap but simpler: count, sort.\n\nWe need to produce line-by-line virtual code. Use Start, End, Decision etc.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化空哈希表 freq // 用來計算每個數字出現次數\n→ Step 2: 對 nums 中每個 num 做 freq[num] +=1 // 統計頻率\n→ Step 3: 將 freq 中的項目轉成 list of (num, count) // 準備排序\n→ Step 4: 對 list 依 count 進行降序排序 // 高頻在前\n→ Decision: 判斷 list 長度是否 >= k? // 確保能取到 k 個\n    Yes → Step 5: 取 list 前 k 個元素的 num 值作答 // 返回\n    No  → Step 6: 取 list 所有元素的 num 值作答 // 若不足 k，返回全部\nEnd\n\nBut we need to be more detailed: Sorting step uses comparison; also maybe use partial sort or nth_element but keep simple.\n\nLet's produce with virtual code arrow.\n\nWe'll use \"→\" for each step.\n\nAlso use Decision lines.\n\nMake sure to keep explanations in Chinese.\n\nWe might include a step for creating result array.\n\nOk produce.\n\nLet's ensure each line has \"虛擬碼步驟 // 解釋\". Each line separate.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 freq // 用來存儲每個數字的出現頻率  \n→ Step 2: 對 nums 中的每個 num 做 freq[num] += 1 // 統計每個數字的出現次數  \n→ Step 3: 將 freq 轉換為 list_of_pairs = list(freq.items()) // 生成 (num, count) 的列表  \n→ Step 4: 對 list_of_pairs 按 count 進行降序排序 // 使頻率最高的元素排在最前  \n→ Decision: list_of_pairs 的長度是否 ≥ k? // 判斷是否能直接取 k 個最頻繁元素  \n  Yes → Step 5: 取 list_of_pairs 前 k 個元素的 num 作為答案列表 result // 返回 k 個最頻繁的數字  \n  No  → Step 6: 取 list_of_pairs 全部元素的 num 作為答案列表 result // 若不足 k，返回所有數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\nimport heapq\n\nclass Solution:\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        回傳出現頻率最高的 k 個元素，順序任意。\n        \"\"\"\n        # 1. 計算每個數字的出現頻率\n        freq = Counter(nums)\n        # 2. 取出頻率最高的 k 個項目\n        # heapq.nlargest 會返回 (element, frequency) 的元組，依頻率排序\n        top_k = heapq.nlargest(k, freq.items(), key=lambda x: x[1])\n        # 3. 只取元素部分返回\n        return [item for item, _ in top_k]\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 嘗試從輸入中解析 nums 列表和 k 整數\n    # 期望格式類似: 'nums = [1,1,1,2,2,3], k = 2'\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data, re.S)\n    if match:\n        nums_str, k_str = match.group(1), match.group(2)\n        nums = ast.literal_eval(nums_str)\n        k = int(k_str)\n    else:\n        # 若格式不同，嘗試簡單拆分\n        parts = data.split(',')\n        nums_part = parts[0].split('=')[1].strip()\n        k_part = parts[1].split('=')[1].strip()\n        nums = ast.literal_eval(nums_part)\n        k = int(k_part)\n\n    # 計算並輸出結果\n    solution = Solution()\n    result = solution.topKFrequent(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode380.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1)",
    "description_snippet": "Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool inser...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudocode for the RandomizedSet class, with methods: constructor, insert, remove, getRandom. Use a hash map and array list for O(1). Use virtual code lines with arrow syntax.\n\nWe need to use Start, End, Decision etc. Provide line by line pseudocode with explanation comment. Must not output actual code. Use structure.\n\nWe need to include all lines for class definition? Let's produce steps:\n\nStart\n→ Step 1: Initialize data structures // Hash map and array\n→ Step 2: insert(val) // if val not in map\n    Decision: val exists?\n        Yes → return false\n        No → add val to array, record index in map, return true\n→ Step 3: remove(val) // if val in map\n    Decision: val exists?\n        Yes → swap with last element, update map, pop last, remove val from map, return true\n        No → return false\n→ Step 4: getRandom() // generate random index, return element at that index\nEnd\n\nAdd comments.\n\nLet's output in format: each line \"虛擬碼步驟 // 解釋\".\n\nUse arrows: \"→\". For decision: \"Decision: ...\". Indent children with tabs or spaces.\n\nWe must be careful: Use \"Decision: if ...\". Use Yes →, No →.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 hashMap 和 list // 建立空的哈希表與動態陣列\n\n→ Step 2: insert(val) // 插入新元素\n    Decision: hashMap 包含 val? // 判斷元素是否已存在\n        Yes → 返回 false // 已存在，不插入\n        No  → list.append(val) // 將 val 加入陣列尾部\n              hashMap[val] = list.size - 1 // 記錄 val 的索引\n              返回 true // 成功插入\n\n→ Step 3: remove(val) // 刪除元素\n    Decision: hashMap 包含 val? // 判斷元素是否存在\n        Yes → lastVal = list.last // 取陣列最後一個元素\n              lastIndex = list.size - 1\n              index = hashMap[val] // 取得 val 的索引\n              list[index] = lastVal // 將最後元素移到待刪位置\n              hashMap[lastVal] = index // 更新最後元素的新索引\n              list.pop() // 刪除陣列尾部\n              hashMap.remove(val) // 從哈希表移除 val\n              返回 true // 成功刪除\n        No  → 返回 false // 元素不存在，無法刪除\n\n→ Step 4: getRandom() // 隨機取值\n    index = 隨機數(0, list.size - 1) // 產生隨機索引\n    返回 list[index] // 取出對應元素\n\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋.\n\nWe need to be consistent with \"Decision:\" lines and Yes/No.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 hashMap 和 list // 建立空的哈希表與動態陣列\n\n→ Step 2: insert(val) // 插入新元素\n    Decision: hashMap 包含 val? // 判斷元素是否已存在\n        Yes → 返回 false // 已存在，不插入\n        No  → list.append(val) // 將 val 加入陣列尾部\n              hashMap[val] = list.size - 1 // 記錄 val 的索引\n              返回 true // 成功插入\n\n→ Step 3: remove(val) // 刪除元素\n    Decision: hashMap 包含 val? // 判斷元素是否存在\n        Yes → lastVal = list.last // 取陣列最後一個元素\n              lastIndex = list.size - 1\n              index = hashMap[val] // 取得 val 的索引\n              list[index] = lastVal // 將最後元素移到待刪位置\n              hashMap[lastVal] = index // 更新最後元素的新索引\n              list.pop() // 刪除陣列尾部\n              hashMap.remove(val) // 從哈希表移除 val\n              返回 true // 成功刪除\n        No  → 返回 false // 元素不存在，無法刪除\n\n→ Step 4: getRandom() // 隨機取值\n    index = 隨機數(0, list.size - 1) // 產生隨機索引\n    返回 list[index] // 取出對應元素\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass RandomizedSet:\n    def __init__(self):\n        self.val_to_index = {}\n        self.values = []\n\n    def insert(self, val):\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val):\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self):\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Split the input into two lists: commands and arguments\n    # Handle possible spaces around the separator\n    parts = data.split('], [', 1)\n    if len(parts) == 1:  # no space in separator\n        parts = data.split('],[' , 1)\n\n    first, second = parts[0].strip(), parts[1].strip()\n    if not first.startswith('['):\n        first = '[' + first\n    if not first.endswith(']'):\n        first += ']'\n    if not second.endswith(']'):\n        second += ']'\n\n    try:\n        commands = json.loads(first)\n        arguments = json.loads(second)\n    except Exception:\n        commands = ast.literal_eval(first)\n        arguments = ast.literal_eval(second)\n\n    obj = RandomizedSet()\n    results = []\n    for cmd, args in zip(commands, arguments):\n        if cmd == \"RandomizedSet\":\n            results.append(None)\n        elif cmd == \"insert\":\n            results.append(obj.insert(args[0]))\n        elif cmd == \"remove\":\n            results.append(obj.remove(args[0]))\n        elif cmd == \"getRandom\":\n            results.append(obj.getRandom())\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpympsb0w2.py\", line 53, in main\n    arguments = json.loads(second)\n                ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 3 (char 2)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpympsb0w2.py\", line 73, in <module>\n    main()\n  File \"/tmp/tmpympsb0w2.py\", line 56, in main\n    arguments = ast.literal_eval(second)\n                ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [], [1], [2], [2], [], [1], [2], []]\n                                       ^\nSyntaxError: unmatched ']'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode519.json",
    "problem_index_in_file": 0,
    "title": "Random Flip Matrix",
    "description_snippet": "There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to ran...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, explaining each. The problem: we need to pick a random zero cell in m x n matrix initially all zeros, flip to 1. After many flips, some zeros remain. Need to sample uniformly among remaining zeros. Must minimize random calls.\n\nStandard solution: maintain a list/array of all indices (flattened), initially mapping each index to its position in array. When flipping, pick a random integer k from 0 to remaining-1, get index = mapping[k] (or mapping[k] itself if mapping not yet assigned). Then swap mapping[k] with mapping[remaining-1] (or mapping[remaining-1] with mapping[k]?), and decrement remaining. Reset sets mapping back to identity or reinitialize.\n\nTime complexity: O(1) per flip, O(m*n) init memory. Random calls: 1 per flip. That satisfies.\n\nNow produce virtual code lines.\n\nWe need to include the class and its methods. Let's produce virtual code lines with explanation.\n\nPseudo code:\n\nStart\n\n→ Step 1: Define class Solution // 代表解法\n\n→ Step 2: Constructor(m, n) // 初始化\n    → Step 2.1: total ← m * n // 總格數\n    → Step 2.2: remaining ← total // 仍為 0 的格數\n    → Step 2.3: mapping ← array of size total // 存放映射\n    → Step 2.4: For i in 0..total-1: mapping[i] ← i // 初始映射為自己\n\n→ Step 3: flip() // 隨機挑選\n    → Step 3.1: idx ← randomInt(0, remaining-1) // 取得隨機下標\n    → Step 3.2: val ← mapping[idx] // 真正的格子編號\n    → Step 3.3: mapping[idx] ← mapping[remaining-1] // 把最後一個映射放到 idx\n    → Step 3.4: remaining ← remaining - 1 // 減少可用格數\n    → Step 3.5: i ← val / n // 轉換為行\n    → Step 3.6: j ← val % n // 轉換為列\n    → Step 3.7: return [i, j] // 回傳\n\n→ Step 4: reset()\n    → Step 4.1: remaining ← total // 全部格恢復\n    → Step 4.2: For i in 0..total-1: mapping[i] ← i // 重新映射\n\nEnd\n\nBut we need each line to be in \"虛擬碼步驟\" format, with arrow \"→\" or \"Start\", \"End\". Use \"Decision:\" maybe not needed.\n\nWe must keep each step line as a line. Each line must have \"虛擬碼步驟\" + space + comment. So for loops we can produce separate lines. For loops we need to show loop body maybe. We need to keep readability.\n\nLet's produce.\n\nStart // 程式開始執行\n\n→ Class Solution // 定義解法類別\n\n→ Constructor(m, n) // 建構子：設定矩陣尺寸\n    → total ← m * n // 計算總格數\n    → remaining ← total // 可用格數初始為全部\n    → mapping ← array of size total // 建立映射陣列\n    → For i from 0 to total-1 // 初始化映射\n        → mapping[i] ← i // 每個索引映射到自己\n\n→ Method flip() // 隨機選取一個 0 並翻轉為 1\n    → idx ← randomInt(0, remaining-1) // 產生隨機位置\n    → val ← mapping[idx] // 真實格子編號\n    → mapping[idx] ← mapping[remaining-1] // 用最後一個映射覆蓋 idx\n    → remaining ← remaining - 1 // 可用格數減 1\n    → i ← val / n // 將一維索引轉為行\n    → j ← val % n // 將一維索引轉為列\n    → return [i, j] // 回傳選中的坐標\n\n→ Method reset() // 重置矩陣為全 0\n    → remaining ← total // 恢復可用格數\n    → For i from 0 to total-1 // 重新初始化映射\n        → mapping[i] ← i // 映射回自身\n\nEnd // 程式結束\n\nBut each line should be a single line with the virtual code step. We need to include the indentation or arrow for loops. Perhaps we can represent loops as:\n\n→ For i from 0 to total-1: // 迴圈\n    → mapping[i] ← i // 映射初始化\n\nBut the instruction: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So loops lines must contain the \"虛擬碼步驟\". For loops we need to have the line \"→ For i from 0 to total-1\" then next line with mapping. But they are separate lines. But that might be ambiguous. The example didn't include loops but included decisions with indent lines. The indentation may be optional. But the requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". So we can have loops using arrow \"→\" and maybe comment. We can have \"→ For i in 0..total-1\" line and then inside the loop we indent or just add arrow again? The example had only decisions. But we can create lines like:\n\n→ For i from 0 to total-1 // 迴圈：初始化映射\n    → mapping[i] ← i // 把映射指向自己\n\nBut each line must contain \"虛擬碼步驟\" and comment. So we can put the indentation or not. We can use \"    →\" or \"→\" again. For readability, we can indent with spaces.\n\nWe also need to specify randomInt call. We'll write \"idx ← randomInt(0, remaining-1)\". That's one random call. Good.\n\nThe mapping array will be of size total. Good.\n\nNow produce final answer with these lines. Ensure each line has comment after space. Use // for comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Solution // 定義解法類別  \n\n→ Constructor(m, n) // 建構子：設定矩陣尺寸  \n&nbsp;&nbsp;→ total ← m * n // 計算總格數  \n&nbsp;&nbsp;→ remaining ← total // 可用格數初始為全部  \n&nbsp;&nbsp;→ mapping ← array of size total // 建立映射陣列  \n&nbsp;&nbsp;→ For i from 0 to total-1 // 初始化映射陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ mapping[i] ← i // 每個索引映射到自己  \n\n→ Method flip() // 隨機選取一個 0 並翻轉為 1  \n&nbsp;&nbsp;→ idx ← randomInt(0, remaining-1) // 產生隨機位置（1 次隨機呼叫）  \n&nbsp;&nbsp;→ val ← mapping[idx] // 真實格子編號  \n&nbsp;&nbsp;→ mapping[idx] ← mapping[remaining-1] // 用最後一個映射覆蓋 idx  \n&nbsp;&nbsp;→ remaining ← remaining - 1 // 可用格數減 1  \n&nbsp;&nbsp;→ i ← val / n // 一維索引轉換為行  \n&nbsp;&nbsp;→ j ← val % n // 一維索引轉換為列  \n&nbsp;&nbsp;→ return [i, j] // 回傳選中的坐標  \n\n→ Method reset() // 重置矩陣為全 0  \n&nbsp;&nbsp;→ remaining ← total // 恢復可用格數  \n&nbsp;&nbsp;→ For i from 0 to total-1 // 重新初始化映射陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ mapping[i] ← i // 映射回自身  \n\nEnd // 程式結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, m, n):\n        \"\"\"Initialize the matrix with all zeros.\"\"\"\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining cells that are still 0\n        self.mapping = list(range(self.total))  # mapping from index to real cell\n\n    def flip(self):\n        \"\"\"Randomly pick a 0 cell, flip it to 1, and return its coordinates.\"\"\"\n        idx = random.randint(0, self.total - 1)  # 1 random call\n        real_val = self.mapping[idx]             # real flattened index\n        # Move the last available cell into this position\n        self.mapping[idx] = self.mapping[self.total - 1]\n        self.total -= 1\n        # Convert flattened index back to (row, col)\n        return [real_val // self.n, real_val % self.n]\n\n    def reset(self):\n        \"\"\"Reset all cells back to 0.\"\"\"\n        self.total = self.m * self.n\n        self.mapping = list(range(self.total))\n\ndef main():\n    # Read all input, strip whitespace\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Input format: ops, args\n    ops, args = json.loads('[' + data + ']')\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(arg[0], arg[1])\n            result.append(None)          # constructor returns null\n        elif op == \"flip\":\n            result.append(obj.flip())\n        elif op == \"reset\":\n            obj.reset()\n            result.append(None)          # reset returns null\n        else:\n            result.append(None)          # safeguard for unknown ops\n\n    # Output as JSON (null for None)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [2, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode45.json",
    "problem_index_in_file": 0,
    "title": "Jump Game II",
    "description_snippet": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at index ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving minimum jumps problem. Should use greedy algorithm. Steps: start, initialize jumps=0, current_end=0, farthest=0, iterate i from 0 to n-2. Update farthest = max(farthest, i+nums[i]). If i==current_end: jumps++; current_end = farthest. Return jumps. Since reachable guaranteed. Virtual code lines.\n\nWe must adhere to format: each line \"虛擬碼步驟 // 解釋\". Use Start End. Use arrows →. Use Decision: if statements. Use No/Yes. Provide only virtual steps.\n\nLet's produce.\n\nStart // 開始\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: jumps ← 0 // 初始化跳躍次數\n→ Step 3: current_end ← 0 // 當前跳躍範圍結束點\n→ Step 4: farthest ← 0 // 能到達的最遠點\n→ Decision: i 迴圈從 0 到 n-2? // 只需要遍歷到倒數第二個位置\n    Yes → Loop i = 0 to n-2\n        → Step 5: farthest ← max(farthest, i + nums[i]) // 更新可達最遠點\n        → Decision: i == current_end? // 到達目前範圍結束\n            Yes → Step 6: jumps ← jumps + 1 // 增加一次跳躍\n            → Step 7: current_end ← farthest // 將範圍擴展到最遠點\n            No  → Step 8: // 內部不需操作\n        No  → Step 9: // 內部不需操作\n    No  → Step 10: // 迴圈結束\n→ Step 11: return jumps // 回傳最少跳躍次數\nEnd // 程式結束\n\nNeed to maintain format. Also ensure each line uses arrow notation. Use \"Decision:\" lines with Yes/No.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: jumps ← 0 // 初始化跳躍次數  \n→ Step 3: current_end ← 0 // 當前跳躍範圍結束點  \n→ Step 4: farthest ← 0 // 能到達的最遠點  \n→ Decision: i 迴圈從 0 到 n-2? // 只需要遍歷到倒數第二個位置  \n Yes → Loop i = 0 to n-2  \n  → Step 5: farthest ← max(farthest, i + nums[i]) // 更新可達最遠點  \n  → Decision: i == current_end? // 到達目前範圍結束  \n   Yes → Step 6: jumps ← jumps + 1 // 增加一次跳躍  \n   → Step 7: current_end ← farthest // 將範圍擴展到最遠點  \n   No → // 內部不需操作  \n No → // 迴圈結束  \n→ Step 11: return jumps // 回傳最少跳躍次數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def jump(self, nums):\n        \"\"\"Return the minimum number of jumps to reach the last index.\"\"\"\n        n = len(nums)\n        if n <= 1:\n            return 0\n\n        jumps = 0          # 跳躍次數\n        current_end = 0    # 當前跳躍範圍結束點\n        farthest = 0       # 能到達的最遠點\n\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])  # 更新最遠點\n            if i == current_end:                  # 到達範圍結束\n                jumps += 1\n                current_end = farthest            # 擴展範圍\n\n        return jumps\n\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入文本，提取整數列表。\n    支援以下形式：\n      - nums = [2,3,1,1,4]\n      - [2,3,1,1,4]\n      - 2 3 1 1 4\n    \"\"\"\n    # 先搜尋方括號中的內容\n    bracket_match = re.search(r'\\[([^\\]]*)\\]', text)\n    if bracket_match:\n        list_str = f\"[{bracket_match.group(1)}]\"\n        return ast.literal_eval(list_str)\n\n    # 沒有方括號，嘗試直接拆分數字\n    numbers = re.findall(r'-?\\d+', text)\n    return [int(num) for num in numbers]\n\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().jump(nums)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,3,0,1,4]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode495.json",
    "problem_index_in_file": 0,
    "title": "Teemo Attacking",
    "description_snippet": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets po...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step to compute total poisoned seconds. We'll treat input array timeSeries sorted non-decreasing. For each attack time, compute overlapping interval. We can accumulate total. Approach: total = 0; for each i: if i==0 or timeSeries[i] - timeSeries[i-1] >= duration: add duration else add timeSeries[i] - timeSeries[i-1]. Finally return total. Provide steps. Use virtual code with arrows. Each line with explanation. No actual code.\n\nWe need to produce each line as \"Step x: ... // explanation\". Let's produce step-by-step. Include Start, End. Use Decision arrow. We'll label steps. Provide variables: total, i, prevTime, currentTime, diff.\n\nLet's produce.\n\nAlso mention for loops. We'll write \"Loop over array\" with Decision for each iteration. Use \"Decision: 需要重置?\".\n\nOk. Let's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 total = 0 // 用來累計總共中毒秒數  \n→ Step 2: 初始化 prevTime = -∞ // 前一次攻擊時間，起始為負無限  \n→ Decision: 時間序列 timeSeries 是否為空? // 檢查輸入是否有攻擊紀錄  \n  Yes → End // 若空，直接結束並返回 0  \n  No  → → Loop: i 從 0 到 timeSeries.length-1 // 逐個處理每次攻擊  \n    → Step 3: currentTime = timeSeries[i] // 取本次攻擊時間  \n    → Decision: currentTime - prevTime >= duration? // 判斷是否重疊  \n      Yes → → Step 4: total += duration // 沒重疊，完整計算 duration 秒  \n      No  → → Step 5: total += currentTime - prevTime // 重疊，僅計算新攻擊開始至上一次結束的時間差",
      "generated_code": "import sys\nimport re\n\ndef find_poisoned_duration(timeSeries, duration):\n    \"\"\"計算 Ashe 被中毒的總秒數。\"\"\"\n    if not timeSeries:\n        return 0\n    total = 0\n    for i in range(len(timeSeries) - 1):\n        diff = timeSeries[i + 1] - timeSeries[i]\n        total += diff if diff < duration else duration\n    total += duration\n    return total\n\ndef parse_input(data):\n    \"\"\"從輸入字串中解析 timeSeries 與 duration。\"\"\"\n    # 取得時間序列\n    ts_match = re.search(r\"timeSeries\\s*=\\s*\\[([^\\]]*)\\]\", data)\n    if ts_match:\n        ts_str = ts_match.group(1).strip()\n        if ts_str:\n            timeSeries = [int(x.strip()) for x in ts_str.split(\",\") if x.strip()]\n        else:\n            timeSeries = []\n    else:\n        timeSeries = []\n\n    # 取得 duration\n    dur_match = re.search(r\"duration\\s*=\\s*(-?\\d+)\", data)\n    duration = int(dur_match.group(1)) if dur_match else 0\n\n    return timeSeries, duration\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_data = sys.stdin.read()\n    # 解析輸入\n    ts, dur = parse_input(raw_data)\n    # 計算並輸出結果\n    result = find_poisoned_duration(ts, dur)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode424.json",
    "problem_index_in_file": 0,
    "title": "Longest Repeating Character Replacement",
    "description_snippet": "You are given a string s and an integer k. You can choose any character of the string and change it ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving the problem: longest repeating character replacement. Classic sliding window. Steps: initialize counts, left, result. For each right char, increment count. Update maxCount. If window size - maxCount > k, shrink left. Update result = max(result, right-left+1). End. Provide each line with explanation.\n\nWe need to use virtual code format: \"Start\", \"→\", \"Decision:\", etc. Each line has virtual code and // explanation. Let's create lines:\n\nStart // Start of algorithm\n→ Step 1: Initialize count array of size 26 to 0, left = 0, maxCount = 0, result = 0 // set up variables\n→ Step 2: For right from 0 to length(s)-1 // iterate over string\n    → Step 3: Increment count[s[right]] // update frequency of current char\n    → Step 4: Update maxCount if count[s[right]] > maxCount // track max frequency in window\n    → Decision: If (right - left + 1) - maxCount > k? // check if window needs shrinking\n        Yes → Step 5: Decrement count[s[left]] // remove left char from count\n        Yes → Step 6: left = left + 1 // move left pointer\n        No  → // no action\n    → Step 7: result = max(result, right - left + 1) // update longest length\nEnd // return result\n\nNeed to use \"Decision:\" syntax with Yes/No arrows.\n\nAlso need to note \"return result\" maybe separate.\n\nAdd step: → Step 8: Return result // output\n\nMake sure each line is one line with arrow maybe.\n\nBetter formatting: Use indentation? The example shows indentation but we can produce simple. We need to ensure \"Decision:\" lines with Yes →, No →. Indentation optional but maintain.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率陣列 freq[26] = 0, left = 0, maxCount = 0, result = 0 // 設定初始變數\n→ Step 2: 循環 right 從 0 到 s.length-1 // 遍歷整個字串\n    → Step 3: freq[ s[right] ]++ // 增加當前字母的計數\n    → Step 4: 若 freq[ s[right] ] > maxCount，則 maxCount = freq[ s[right] ] // 更新窗口內最高頻字母數\n    → Decision: 如果 (right - left + 1) - maxCount > k? // 檢查窗口是否需要收縮\n        Yes → Step 5: freq[ s[left] ]-- // 移除左邊字母的計數\n        Yes → Step 6: left = left + 1 // 左指標右移\n        No  → // 仍然保持窗口\n    → Step 7: result = max(result, right - left + 1) // 更新最長長度\n→ Step 8: Return result // 回傳答案\nEnd // 程式執行結束\n\nBut ensure each line has no indentation except inside decision? The example uses indentation. We'll mimic.\n\nLet's output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化頻率陣列 freq[26] = 0, left = 0, maxCount = 0, result = 0 // 設定初始變數\n→ Step 2: 循環 right 從 0 到 s.length-1 // 遍歷整個字串\n    → Step 3: freq[ s[right] ]++ // 增加當前字母的計數\n    → Step 4: 若 freq[ s[right] ] > maxCount，則 maxCount = freq[ s[right] ] // 更新窗口內最高頻字母數\n    → Decision: 如果 (right - left + 1) - maxCount > k? // 檢查窗口是否需要收縮\n        Yes → Step 5: freq[ s[left] ]-- // 移除左邊字母的計數\n        Yes → Step 6: left = left + 1 // 左指標右移\n        No  → // 仍然保持窗口\n    → Step 7: result = max(result, right - left + 1) // 更新最長長度\n→ Step 8: Return result // 回傳答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef character_replacement(s: str, k: int) -> int:\n    \"\"\"Return the longest substring length that can be made of the same character\n    by changing at most k characters.\"\"\"\n    count = [0] * 26\n    max_count = 0\n    left = 0\n    res = 0\n\n    for right, ch in enumerate(s):\n        idx = ord(ch) - ord('A')\n        count[idx] += 1\n        if count[idx] > max_count:\n            max_count = count[idx]\n\n        # If we need more than k replacements to make the window uniform,\n        # shrink the window from the left.\n        while (right - left + 1) - max_count > k:\n            count[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        res = max(res, right - left + 1)\n    return res\n\ndef parse_input(data: str):\n    \"\"\"Parse input that may be in the form:\n       s = \"ABAB\", k = 2\n    or\n       ABAB\n       2\n    \"\"\"\n    # Try regex for the first format\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n    if s_match and k_match:\n        s = s_match.group(1)\n        k = int(k_match.group(1))\n        return s, k\n\n    # Fallback: split by lines or spaces\n    parts = data.strip().splitlines()\n    if len(parts) >= 2:\n        s = parts[0].strip()\n        try:\n            k = int(parts[1].strip())\n        except ValueError:\n            k = 0\n    else:\n        # single line with space separation\n        tokens = data.strip().split()\n        s = tokens[0]\n        k = int(tokens[1]) if len(tokens) > 1 else 0\n    return s, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    if not raw_input.strip():\n        sys.exit(0)\n    s, k = parse_input(raw_input)\n    result = character_replacement(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ABAB\", k = 2",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "s = \"AABABBA\", k = 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode58.json",
    "problem_index_in_file": 0,
    "title": "Length of Last Word",
    "description_snippet": "Given a string s consisting of words and spaces, return the length of the last word in the string.\n\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps, line by line, with arrows etc. Provide explanation. Use no real code. Use \"Start\", \"→ Step X:\", \"Decision:\", arrow for Yes, No, and \"End\". Ensure we handle string s, find length of last word. Steps: trim trailing spaces, find last space index, compute length. Alternatively iterate from end until space or start. Let's outline steps:\n\nStart\n→ Step 1: Initialize index = length of s - 1 // start at last character\n→ Step 2: While index >= 0 and s[index] == ' ': index-- // skip trailing spaces\n→ Decision: index < 0? // no word\n    Yes → Step 3: Return 0 // no non-space characters\n    No → Step 4: Initialize count = 0 // length of last word\n→ Step 5: While index >= 0 and s[index] != ' ': count++; index-- // count last word\n→ Step 6: Return count // result\nEnd\n\nWe need to include explanations after //.\n\nLet's produce lines accordingly. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe should include arrows like \"→\" before Step. Decision: lines have indentation and Yes/No arrows. Also ensure we include \"Start\" and \"End\".\n\nWe should use the same format as example. Provide in Traditional Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 index = s.length - 1 // 從字串最後一個位置開始  \n→ Step 2: 當 index >= 0 且 s[index] 為空格時，index-- // 跳過尾端空白  \n→ Decision: index < 0? // 判斷是否全為空白  \n Yes → Step 3: 回傳 0 // 無任何字詞，長度為 0  \n No  → Step 4: 初始化 count = 0 // 用於計算最後一個字詞長度  \n→ Step 5: 當 index >= 0 且 s[index] 不為空格時，count++; index-- // 計算最後字詞的長度  \n→ Step 6: 回傳 count // 將最後字詞長度返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef length_of_last_word(s: str) -> int:\n    \"\"\"\n    Return the length of the last word in the string `s`.\n    \"\"\"\n    # 先去除前後空白\n    s = s.strip()\n    # 如果整個字串被單引號或雙引號包住，去掉它們\n    if len(s) >= 2 and ((s[0] == \"'\" and s[-1] == \"'\") or (s[0] == '\"' and s[-1] == '\"')):\n        s = s[1:-1]\n    # 再去除尾部空白\n    s = s.rstrip()\n    # 若空字串，則沒有詞，長度為 0\n    if not s:\n        return 0\n    # 找到最後一個空格的位置，最後一個詞就是它之後的子字串\n    last_space = s.rfind(' ')\n    return len(s) - last_space - 1\n\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，處理後輸出最後一個單字的長度。\n    \"\"\"\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n\n    # 如果輸入是形如 \"s = \\\"Hello World\\\"\" 的格式，取等號右邊的內容\n    if data.lower().startswith('s ='):\n        _, _, rest = data.partition('=')\n        s = rest.strip()\n    else:\n        s = data\n\n    # 去除可能存在的外層引號\n    if len(s) >= 2 and ((s[0] == \"'\" and s[-1] == \"'\") or (s[0] == '\"' and s[-1] == '\"')):\n        s = s[1:-1]\n\n    result = length_of_last_word(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello World\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"   fly me   to   the moon  \"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"luffy is still joyboy\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode33.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array",
    "description_snippet": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being pas...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: search in rotated sorted array with O(log n). Use binary search with pivot. Steps: set low=0, high=n-1. While low<=high: mid=(low+high)//2. If nums[mid]==target return mid. Determine which side sorted: if nums[low] <= nums[mid] (left side sorted). Then check if target in that range: if nums[low] <= target < nums[mid] then high=mid-1 else low=mid+1. Else right side sorted: if nums[mid] < target <= nums[high] then low=mid+1 else high=mid-1. End loop. Return -1. Need to output step by step with explanation. Should use virtual code syntax: Start, Step numbers, Decision, etc. Each line with // explanation. Use arrows for branching. Also show loops? We can use \"Decision:\" for loop condition? Or \"Loop:\"? Maybe just use Decision: if low <= high? but we can use while loop representation: Decision: low <= high? Yes → Step; No → End. But we can just represent as Decision: while low <= high? But given structure we can do Decision: low <= high? Yes → Step; No → End. Let's craft. Use arrow for decisions. Provide step numbers.\n\nLet's produce:\n\nStart\n→ Decision: low <= high? // 是否還有未檢查範圍\n    Yes → Step 1: mid = (low + high) // 2 // 計算中點索引\n    Yes → Step 2: If nums[mid] == target? // 判斷中點是否為目標\n        Yes → Return mid // 找到目標\n        No  → Decision: nums[low] <= nums[mid]? // 判斷左半段是否有序\n            Yes → Decision: nums[low] <= target < nums[mid]? // 目標是否在左半段\n                Yes → Step 3: high = mid - 1 // 將搜索範圍縮小至左半段\n                No  → Step 4: low = mid + 1 // 目標在右半段\n            No  → Decision: nums[mid] < target <= nums[high]? // 右半段有序且目標是否在其中\n                Yes → Step 5: low = mid + 1 // 將搜索範圍縮小至右半段\n                No  → Step 6: high = mid - 1 // 目標在左半段\n    No  → Return -1 // 未找到\nEnd\n\nNeed to ensure each line has 虛擬碼步驟 + space + // 解釋/說明.\n\nLet's ensure formatting. Each line starts with either \"Start\", \"→\" etc. Use arrow for each line after start.\n\nCheck each line for \"虛擬碼步驟\". Provide step labels? Not required but can use \"Step 1:\" etc. Let's keep them.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: low <= high? // 檢查是否還有未搜尋的區間  \n  Yes → Step 1: mid = (low + high) // 2 // 計算中點索引  \n  Yes → Step 2: If nums[mid] == target? // 判斷中點是否為目標  \n    Yes → Return mid // 找到目標，結束搜尋  \n    No → Decision: nums[low] <= nums[mid]? // 判斷左半段是否為有序  \n     Yes → Decision: nums[low] <= target < nums[mid]? // 目標是否在左半段  \n      Yes → Step 3: high = mid - 1 // 將搜尋範圍縮小至左半段  \n      No → Step 4: low = mid + 1 // 目標在右半段  \n     No → Decision: nums[mid] < target <= nums[high]? // 右半段有序且目標是否在其中  \n      Yes → Step 5: low = mid + 1 // 將搜尋範圍縮小至右半段  \n      No → Step 6: high = mid - 1 // 目標在左半段  \n  No → Return -1 // 未找到目標，搜尋結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:            # left part sorted\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:                                 # right part sorted\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    nums = eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else None\n    result = Solution().search(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,5,6,7,0,1,2], target = 0",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2], target = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "nums = [1], target = 0",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode60.json",
    "problem_index_in_file": 0,
    "title": "Permutation Sequence",
    "description_snippet": "The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find kth permutation of 1..n. Classic problem. Steps: compute factorial numbers, build result string. Use array of numbers. For i from 1 to n: idx = (k-1)/factorial[n-i]; choose element at idx; remove; update k = k - idx*factorial[n-i]. Output string. So produce lines.\n\nWe must produce each line with virtual code step and comment. Use arrow syntax. We'll start with Start, then read n and k, etc.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: Read input n, k // 取得 n 與 k 的值\n→ Step 2: Initialize list numbers = [1..n] // 創建可用數字列表\n→ Step 3: Compute factorial array fact[0..n] where fact[0]=1 and fact[i]=i*fact[i-1] // 預先算出階乘\n→ Step 4: Initialize result = \"\" // 用於累積最終排列字串\n→ Step 5: Adjust k = k - 1 // 轉成 0‑based 索引\n→ Decision: for i from 1 to n // 逐位決定\n    → Step 6: block_index = k / fact[n-i] // 決定第 i 位應選的元素索引\n    → Step 7: result = result + numbers[block_index] // 把選定的數字加到結果\n    → Step 8: Remove numbers[block_index] from list // 移除已使用的數字\n    → Step 9: k = k % fact[n-i] // 更新 k 以處理剩餘位\nEnd // 程式執行結束\n\nBut need arrow formatting exactly as sample: Start, then → Step etc. Use Decision. Provide explanation per line. Provide \"Decision: for i from 1 to n\" maybe \"Decision: 迴圈 i=1 to n\" but decision usually used for branching. But maybe use Step for loop.\n\nLet's adjust: Use \"Step 5: for i from 1 to n\" as Step with loop. Provide explanation. Or maybe \"Decision:\" for loops is weird. Sample used Decision for condition. For loops we can use \"Step\" with description. Keep consistent.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取 n 與 k // 取得輸入參數\n→ Step 2: 建立 numbers 為 [1, 2, …, n] // 可選用數字列表\n→ Step 3: 建立 fact[0] = 1; for i in 1..n: fact[i] = i * fact[i-1] // 預先計算階乘\n→ Step 4: result = \"\" // 用於累積答案\n→ Step 5: k = k - 1 // 轉成 0‑based\n→ Step 6: for i = 1 to n // 逐位決定第 i 個位置\n    → Step 6.1: idx = k / fact[n-i] // 取整除得到索引\n    → Step 6.2: result = result + numbers[idx] // 加入選定數字\n    → Step 6.3: remove numbers[idx] // 刪除已使用的數字\n    → Step 6.4: k = k % fact[n-i] // 更新剩餘 k\nEnd // 程式結束\n\nNeed each line to have virtual code step and comment. For loop lines, we can indent? Use arrow with spaces. Let's format similar to example: each line starts with arrow or Start. Use indentation spaces maybe.\n\nWe need to ensure we use arrow only for steps, decisions. Use '→' for each step. Example: \"→ Step 1: 讀取 n 與 k // 取得輸入參數\". For loop: \"→ Step 6: for i = 1 to n // 逐位決定第 i 個位置\". Indented lines inside loop: \"    → Step 6.1: ...\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 n 與 k // 取得輸入參數  \n→ Step 2: 建立 numbers 為 [1, 2, …, n] // 可選用數字列表  \n→ Step 3: 建立 fact[0] = 1; for i in 1..n: fact[i] = i * fact[i-1] // 預先計算階乘  \n→ Step 4: result = \"\" // 用於累積答案  \n→ Step 5: k = k - 1 // 轉成 0‑based  \n→ Step 6: for i = 1 to n // 逐位決定第 i 個位置  \n    → Step 6.1: idx = k / fact[n-i] // 取整除得到索引  \n    → Step 6.2: result = result + numbers[idx] // 加入選定數字  \n    → Step 6.3: remove numbers[idx] // 刪除已使用的數字  \n    → Step 6.4: k = k % fact[n-i] // 更新剩餘 k  \nEnd // 程式結束",
      "generated_code": "import sys\nimport math\nimport re\n\ndef get_permutation(n: int, k: int) -> str:\n    \"\"\"Return the k-th permutation (1-indexed) of numbers 1..n.\"\"\"\n    numbers = list(range(1, n + 1))\n    k -= 1  # 0‑based index\n    result = []\n\n    for i in range(n, 0, -1):\n        fact = math.factorial(i - 1)\n        index = k // fact\n        result.append(str(numbers.pop(index)))\n        k %= fact\n\n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    # Read all input, extract integers\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        raise ValueError(\"Input must contain at least two integers for n and k.\")\n    n, k = nums[0], nums[1]\n    print(get_permutation(n, k))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3, k = 3",
          "expected_output": "\"213\"",
          "success": true,
          "output": "213"
        },
        {
          "example_index": 1,
          "input": "n = 4, k = 9",
          "expected_output": "\"2314\"",
          "success": true,
          "output": "2314"
        },
        {
          "example_index": 2,
          "input": "n = 3, k = 1",
          "expected_output": "\"123\"",
          "success": true,
          "output": "123"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode496.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element I",
    "description_snippet": "The next greater element of some element x in an array is the first greater element that is to the r...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm. For next greater element problem, typical stack O(n). Need to map elements to next greater. Then answer queries from nums1. So pseudo-code: Start, compute map for nums2: iterate from right to left with stack. For each num, while stack not empty and top <= num, pop. Then next greater is top or -1. Push num. Store in map. Then result array: for each element in nums1, answer map[element] (or -1). End.\n\nWe need each line: virtual code step + // explanation. Use arrows and Decision constructs. Should be structured. Provide steps as sequential lines. Probably use Step 1: compute map, etc. Use indentation for decisions? Not needed. Just line by line.\n\nLet's produce:\n\nStart // Program starts\n→ Step 1: 初始化空堆栈 S 和空字典 nextGreater // 用于存储下一个更大元素\n→ Step 2: 遍历 nums2 由右至左 // 逆序遍历以保证右侧元素可用\n    → Decision: 是否还在遍历 nums2? // 控制循环\n        Yes → Step 3: 当前元素 cur = nums2[i] // 取当前元素\n        → Decision: S 是否为空? 或 S.top() <= cur? // 判断是否有更大元素\n            Yes → Step 4: pop S.top() // 弹出小于等于 cur 的元素\n            No  → Step 5: nextGreater[cur] = S.top() // 记录下一个更大元素\n        → Step 6: push cur onto S // 把 cur 加入堆栈\n        → Step 7: i = i - 1 // 移动到前一个元素\n        No  → End of traversal // 结束遍历\n→ Step 8: 对于每个 x in nums1, 取 nextGreater[x] 若无则为 -1 // 准备答案\n→ Step 9: 将结果存入数组 ans // 输出\nEnd // 程序结束\n\nBut need to follow exact format: each line has code + // explanation. Use arrows. Should we use indentation? Use arrow for steps. For decisions we might indent further. But it's okay. Keep each line separate.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆栈 S 和空字典 nextGreater // 用於存儲每個元素的下個更大元素  \n→ Step 2: 設定 i = nums2.length - 1 // 從右邊開始遍歷 nums2  \n→ Decision: i >= 0? // 判斷是否還有元素要處理  \n    Yes → Step 3: cur = nums2[i] // 取當前元素  \n    → Decision: S.isEmpty() 或 S.top() <= cur? // 判斷堆頂是否為更大元素  \n        Yes → Step 4: S.pop() // 弹出不大於 cur 的元素，繼續尋找更大元素  \n        No  → Step 5: nextGreater[cur] = S.top() // 記錄 cur 的下個更大元素  \n    → Step 6: S.push(cur) // 把 cur 放進堆栈供左邊元素使用  \n    → Step 7: i = i - 1 // 移動到前一個元素  \n    No  → End of traversal // 右到左遍歷結束  \n→ Step 8: 初始化 ans 為空列表 // 用於存儲答案  \n→ Step 9: 對於 nums1 中的每個 x  \n    → Step 10: val = nextGreater.get(x, -1) // 若不存在則回傳 -1  \n    → Step 11: ans.append(val) // 加入答案列表  \n→ Step 12: 返回 ans // 完成結果輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef next_greater_element(nums1, nums2):\n    \"\"\"\n    將 nums2 中每個元素對應到它右側第一個更大的元素。\n    使用單調遞減棧（stack）一次掃描即可完成。\n    \"\"\"\n    stack = []                 # 栈中存放尚未找到更大元素的數字\n    next_greater = {}          # 映射：num -> nums2 中右側第一個更大元素\n\n    for num in nums2:\n        # 當棧頂的數字比目前的 num 小或相等，則它們的「下一個更大」就是 num\n        while stack and num > stack[-1]:\n            prev = stack.pop()\n            next_greater[prev] = num\n        stack.append(num)\n\n    # 未在 stack 中找到更大元素的，對應答案為 -1\n    return [next_greater.get(x, -1) for x in nums1]\n\ndef parse_input(text):\n    \"\"\"\n    從標準輸入讀取的文字中，提取兩個列表 nums1 與 nums2。\n    這裡使用正則表達式抓取形如\n        nums1 = [1,2,3], nums2 = [4,5,6]\n    的字串。\n    \"\"\"\n    pattern = r'nums1\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*nums2\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, text)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums1_str, nums2_str = match.group(1), match.group(2)\n    # 使用 ast.literal_eval 安全地將字串轉成列表\n    nums1 = ast.literal_eval(nums1_str)\n    nums2 = ast.literal_eval(nums2_str)\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 解析輸入得到 nums1 與 nums2\n    nums1, nums2 = parse_input(raw_input)\n    # 計算答案\n    result = next_greater_element(nums1, nums2)\n    # 輸出結果（Python 列表格式）\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [4,1,2], nums2 = [1,3,4,2]",
          "expected_output": "[-1,3,-1]",
          "success": true,
          "output": "[-1, 3, -1]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [2,4], nums2 = [1,2,3,4]",
          "expected_output": "[3,-1]",
          "success": true,
          "output": "[3, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode93.json",
    "problem_index_in_file": 0,
    "title": "Restore IP Addresses",
    "description_snippet": "A valid IP address consists of exactly four integers separated by single dots. Each integer is betwe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants a step-by-step virtual code for solving the IP address restoration problem. The output must be line-by-line virtual code with explanation comments. We need to generate algorithm in pseudocode. Provide steps: Start, Input string s, iterate over positions to insert dots, check each segment validity, collect valid IPs. Use recursion or loops. Also need to check no leading zeros unless the number is zero. Provide virtual code with arrows, decisions.\n\nWe must not output actual code, just virtual steps with explanations. Each line: `虛擬碼步驟 // 解釋`. Use arrows `→`, `Yes →`, `No →`. Must include Start, End, Decision:.\n\nWe'll produce a detailed algorithm: start, initialize result list, define recursive function backtrack(start, partCount, currentSegments). For each segment, try length 1-3, if exceeds bounds or >255 break, if leading zero with length>1 skip, else add segment and recurse. When partCount==4 and start==len(s), join segments with '.' and add to result. End recursion. After recursion, return result.\n\nWe'll produce steps accordingly.\n\nThe user specifically provided the requirement. They want the virtual code for this solution.\n\nWe'll produce a step-by-step algorithm.\n\nBe careful: Each line must have \"虛擬碼步驟 [空格] // 解釋\".\n\nUse arrow \"→\" for each line after Start.\n\nAlso decisions with Yes→ and No→.\n\nLet's produce.\n\nWe should include Start, then input s, then call backtrack, etc.\n\nProbably like:\n\nStart // 程式開始執行\n→ Step 1: 定義結果列表 results = [] // 用於存放符合條件的IP\n→ Step 2: 定義遞迴函式 backtrack(startIndex, segments, currentIP) // 將字串拆分\n    → Decision: 如果 segments==4 且 startIndex==len(s)? // 檢查是否已經分割完成\n        Yes → Step 3: 將 currentIP 連接成IP字串並加入 results // 完整IP，加入結果\n        No  → Decision: 如果 startIndex>=len(s)? // 若已無剩餘字元但段未滿四則不合法\n            Yes → Step 4: 返回 // 不合法結束遞迴\n            No  → Step 5: For lenSegment in [1,2,3] // 嘗試三種長度\n                → Decision: startIndex+lenSegment <= len(s)? // 確保不超過字串長度\n                    Yes → Step 6: segment = s[startIndex : startIndex+lenSegment] // 取子字串\n                    No  → Step 7: 跳過此長度 // 這裡不進一步處理\n                → Decision: segment 為有效數字? // 判斷是否在0-255且無前導0\n                    Yes → Step 8: 如果 segments==3? // 若即將成為最後一段\n                        Yes → Step 9: finalIP = currentIP + segment // 直接完成IP\n                        No  → Step 10: newIP = currentIP + segment + \".\" // 加點繼續遞迴\n                    No  → Step 11: 跳過此 segment // 不合法\n                    ...\nBacktrack 呼叫 startIndex=0, segments=0, currentIP=\"\" // 初始化\nReturn results // 輸出所有有效IP\n\nWe need to maintain arrow formatting and explanation. Use decisions. Provide correct indentation.\n\nLet's craft carefully.\n\nWe'll ensure each line uses `→` before content. For decisions, use `Decision: ...?` and then Yes → and No → lines.\n\nEnsure each line has `// 解釋`. For example: `→ Step 1: results = [] // 用於存放符合條件的IP`\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義結果列表 results = [] // 用於存放所有符合條件的 IP  \n→ Step 2: 定義遞迴函式 backtrack(startIndex, segments, currentIP) // 將字串拆分成四段  \n  → Decision: segments == 4 且 startIndex == len(s)? // 檢查是否已完成四段且已經遍歷完字串  \n   Yes → Step 3: finalIP = currentIP + segment // 組成完整 IP 並加入結果  \n    → Step 4: results.append(finalIP) // 加入結果集合  \n    → Step 5: return // 結束此遞迴路徑  \n   No  → Decision: startIndex >= len(s)? // 若已無剩餘字元但段數未滿四則不合法  \n    Yes → Step 6: return // 結束此遞迴路徑  \n    No  → Step 7: for lenSegment in [1, 2, 3] // 嘗試長度為1到3的段  \n     → Decision: startIndex + lenSegment <= len(s)? // 確保不越界  \n      Yes → Step 8: segment = s[startIndex : startIndex + lenSegment] // 取子字串  \n       → Decision: segment 是否為有效數字? // 判斷是否在0-255且無前導零  \n        Yes → Step 9: if segments == 3? // 若即將成為最後一段  \n         Yes → Step 10: finalIP = currentIP + segment // 完成 IP  \n          → Step 11: results.append(finalIP) // 加入結果  \n          → Step 12: return // 結束此遞迴路徑  \n         No  → Step 13: newIP = currentIP + segment + \".\" // 加點繼續遞迴  \n          → Step 14: backtrack(startIndex + lenSegment, segments + 1, newIP) // 進一步遞迴  \n       No  → Step 15: continue // 跳過此長度的段",
      "generated_code": "import sys\nimport json\nimport re\n\ndef restore_ip_addresses(s: str):\n    res = []\n\n    def backtrack(start: int, path: list):\n        if start == len(s) and len(path) == 4:\n            res.append('.'.join(path))\n            return\n        if len(path) >= 4:\n            return\n        for length in range(1, 4):\n            if start + length > len(s):\n                break\n            part = s[start:start + length]\n            if (part.startswith('0') and len(part) > 1) or int(part) > 255:\n                continue\n            backtrack(start + length, path + [part])\n\n    backtrack(0, [])\n    return res\n\ndef main():\n    data = sys.stdin.read()\n    m = re.search(r'\"([^\"]+)\"', data)\n    if m:\n        s = m.group(1)\n    else:\n        s = ''.join(filter(str.isdigit, data.strip()))\n    result = restore_ip_addresses(s)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"25525511135\"",
          "expected_output": "[\"255.255.11.135\",\"255.255.111.35\"]",
          "success": true,
          "output": "[\"255.255.11.135\", \"255.255.111.35\"]"
        },
        {
          "example_index": 1,
          "input": "s = \"0000\"",
          "expected_output": "[\"0.0.0.0\"]",
          "success": true,
          "output": "[\"0.0.0.0\"]"
        },
        {
          "example_index": 2,
          "input": "s = \"101023\"",
          "expected_output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]",
          "success": true,
          "output": "[\"1.0.10.23\", \"1.0.102.3\", \"10.1.0.23\", \"10.10.2.3\", \"101.0.2.3\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode393.json",
    "problem_index_in_file": 0,
    "title": "UTF-8 Validation",
    "description_snippet": "Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm that checks if given array of integers representing bytes is valid UTF-8. Provide each line with explanation. Must be line by line, each line: virtual code step + space + comment. Use arrows and structure. Let's craft algorithm:\n\nStart\n→ Step: Initialize i = 0 // index\n→ Decision: While i < len(data) // iterate\n    Yes → Step: current = data[i] & 0xFF // get byte\n    → Decision: if current >> 7 == 0 // 1-byte\n        Yes → i = i + 1 // move next\n        No → Decision: count = 0 // count leading ones\n            → Step: temp = current\n            → Decision: while temp >> 7 == 1\n                Yes → count = count + 1\n                      temp = temp << 1\n                      // shift to examine next bit\n                No → // exit loop\n            → Decision: if count < 2 or count > 4 // invalid start\n                Yes → Return False // invalid\n                No → // check following bytes\n            → Decision: for j from 1 to count-1\n                Yes → if i + j >= len(data) or (data[i+j] >> 6) != 0b10\n                    Yes → Return False // invalid\n                No → // continue\n            → Step: i = i + count // skip bytes\n→ End // return True\n\nNeed to produce code lines. Use arrows, Start, End, Decision.\n\nAlso maybe include final Return True.\n\nWe need to ensure each line includes explanation. Use 4 spaces indent for decisions? In example they used indentation with 4 spaces for sub-lines. We'll follow that. Use arrow → for next step. Use Decision: lines with Yes → and No → sub-steps.\n\nWe should produce lines such as:\n\nStart // 程式開始執行\n→ Step 1: i ← 0 // 初始化索引\n→ Decision: i < len(data)？ // 迴圈條件\n    Yes → Step 2: current ← data[i] & 0xFF // 取當前字節\n    ...\n\nAlso need to return True at the end.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 初始化索引指向資料陣列的第一個位元組  \n→ Decision: i < len(data)？ // 是否還有位元組可處理？  \n  Yes → Step 2: current ← data[i] & 0xFF // 取得當前位元組，忽略高位 8 位  \n   → Decision: current >> 7 == 0？ // 是否為 1 位元組字元（首位 0）？  \n    Yes → Step 3: i ← i + 1 // 直接跳至下一個位元組  \n    No → Decision: count ← 0 // 用於計算前導 1 的數目（即位元組長度）  \n     → Step 4: temp ← current // 用 temp 進行位移檢查  \n     → Decision: temp >> 7 == 1？ // 從最高位開始算起，前導 1 的個數  \n      Yes → Step 5: count ← count + 1  \n       → temp ← temp << 1 // 左移 1 位，準備檢查下一個位元  \n       → Decision: temp >> 7 == 1？ // 繼續判斷前導 1  \n        Yes → … // 重複 Step 5  \n        No → … // 走出迴圈  \n      No → … // 走出迴圈  \n     → Decision: count < 2 或 count > 4？ // 前導 1 必須 2~4 位，且 1 位元組已排除  \n      Yes → Step 6: Return False // 非法 UTF‑8，立即結束  \n      No → … // 繼續檢查後續位元組  \n       → Decision: for j from 1 to count-1？ // 檢查每個後續位元組  \n        Yes → Step 7: next ← data[i+j] & 0xFF  \n         → Decision: next >> 6 == 0b10？ // 最高 2 位必須是 10  \n          Yes → … // 合法，繼續迴圈  \n          No → Step 8: Return False // 非法後續位元組，結束  \n        No → … // j 迴圈結束  \n       → Step 9: i ← i + count // 跳過整個 UTF‑8 字元  \n→ Decision: i < len(data)？ // 回到外層迴圈判斷  \n  Yes → … // 重複上一步  \n  No → Step 10: Return True // 所有位元組皆合法，返回成功  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validUtf8(self, data):\n        \"\"\"檢查 data 是否為有效的 UTF-8 編碼。\"\"\"\n        n_bytes = 0  # 仍須檢查的後續位元組數\n\n        for num in data:\n            byte = num & 0xFF  # 只取低 8 位\n            if n_bytes == 0:  # 目前處於新的 UTF-8 字元\n                # 先算前導 1 的個數（即字元長度）\n                mask = 0b10000000\n                count = 0\n                while byte & mask:\n                    count += 1\n                    mask >>= 1\n\n                if count == 0:  # 1 位元組字元\n                    continue\n                if count == 1 or count > 4:  # 前導 1 必須 2~4 位\n                    return False\n                n_bytes = count - 1  # 剩餘的後續位元組\n            else:\n                # 後續位元組必須以 10 開頭\n                if not (byte >> 6 == 0b10):\n                    return False\n                n_bytes -= 1\n\n        return n_bytes == 0  # 期望所有位元組已被正確消耗\n\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取輸入，並擷取所有整數\n    raw_input = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', raw_input)))\n\n    sol = Solution()\n    result = sol.validUtf8(numbers)\n\n    # 輸出 'true' 或 'false'（全小寫）\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "data = [197,130,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "data = [235,140,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode475.json",
    "problem_index_in_file": 0,
    "title": "Heaters",
    "description_snippet": "Winter is coming! During the contest, your first job is to design a standard heater with a fixed war...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines to solve the problem: given arrays houses and heaters positions on a horizontal line, find minimum radius such that each house is within distance radius of at least one heater. Classic problem: for each house, compute nearest heater distance; radius = max over houses of that distance.\n\nSo algorithm: sort heaters. For each house, binary search nearest heater in sorted list to find lower bound, check both neighbor distances. Track max distance. Output that.\n\nWe need to output step-by-step virtual code lines with explanation after //.\n\nNeed to follow format: Each line: virtual code step + space + // explanation. Use arrows and decisions. So we need to produce lines like \"Start // 程式開始執行\". Then \"→ Step 1: Sort heaters ascending // 排序加熱器位置\" etc. Must include arrow \"→\" after Start maybe? Format example shows Start, then \"→ Step 1: ...\". So follow that.\n\nWe need to represent decisions: Decision: if house distance > ...? But maybe we can use Decision: If house not covered? Actually we need to compute max. We can show loop over houses, decision: if left distance < right distance? But we can show choose nearest heater.\n\nSimplify: For each house: Find nearest heater distance. We can do:\n\n→ Step 2: For each house in houses: // 逐一處理每棟房子\n\n→ Decision: 找到最近的加熱器位置? Use binary search.\n\nBut to maintain format, we might show:\n\nDecision: Binary search heater list to find insertion point for house // 找到加熱器最接近的位置\n\nYes → Step 3: leftDist = house - heater[idx-1] if idx >0 else ∞ // 计算左侧距离\n\nYes → Step 4: rightDist = heater[idx] - house if idx < n else ∞ // 计算右侧距离\n\nYes → Step 5: nearest = min(leftDist, rightDist) // 取最近距离\n\nYes → Step 6: Update maxRadius = max(maxRadius, nearest) // 更新最大半径\n\nAfter loop: End.\n\nWe need to handle no heater? Edge? Not necessary.\n\nMake sure to use arrows and indentation for decisions.\n\nLet's craft final output lines.\n\nNeed to use Chinese explanations. Provide concise explanation after //.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort heaters in ascending order // 把加熱器位置從小到大排序，方便二分搜尋  \n→ Step 2: Initialize maxRadius = 0 // 用來記錄最小可行半徑  \n→ Step 3: For each housePosition in houses: // 逐一檢查每棟房子  \n  Decision: 使用二分搜尋找出加熱器插入點 idx 使 heaters[idx-1] ≤ housePosition < heaters[idx] // 找到最近加熱器的索引  \n   Yes → Step 4: Calculate leftDist = housePosition - heaters[idx-1] if idx > 0 else Infinity // 左側最近加熱器距離  \n   Yes → Step 5: Calculate rightDist = heaters[idx] - housePosition if idx < heaters.length else Infinity // 右側最近加熱器距離  \n   Yes → Step 6: nearest = min(leftDist, rightDist) // 選擇離房子最近的加熱器距離  \n   Yes → Step 7: Update maxRadius = max(maxRadius, nearest) // 以這個距離更新最大半徑  \nEnd // 程式執行結束，maxRadius 即為最小半徑標準答案。",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef find_radius(houses, heaters):\n    \"\"\"\n    計算最小半徑，讓所有房子都被至少一個加熱器覆蓋。\n    \"\"\"\n    houses.sort()\n    heaters.sort()\n    res = 0          # 最大距離\n    i = 0            # 指向最近的右側加熱器\n    for house in houses:\n        # 往右移動指標，直到右側加熱器距離不再更近\n        while i < len(heaters) - 1 and abs(heaters[i + 1] - house) <= abs(heaters[i] - house):\n            i += 1\n        # 更新最大距離\n        res = max(res, abs(heaters[i] - house))\n    return res\n\ndef main():\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n\n    # 用正則表達式抓取兩個列表\n    pattern = r'houses\\s*=\\s*(\\[.*?\\])\\s*,\\s*heaters\\s*=\\s*(\\[.*?\\])'\n    match = re.search(pattern, data)\n    if not match:\n        return\n\n    houses_str, heaters_str = match.group(1), match.group(2)\n\n    # 轉成 Python 的 list\n    houses = ast.literal_eval(houses_str)\n    heaters = ast.literal_eval(heaters_str)\n\n    # 計算結果並輸出\n    radius = find_radius(houses, heaters)\n    print(radius)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "houses = [1,2,3], heaters = [2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "houses = [1,2,3,4], heaters = [1,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "houses = [1,5], heaters = [2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode491.json",
    "problem_index_in_file": 0,
    "title": "Non-decreasing Subsequences",
    "description_snippet": "Given an integer array nums, return all the different possible non-decreasing subsequences of the gi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving problem: find all unique non-decreasing subsequences of length>=2. Provide step-by-step pseudo-code, with explanation for each line. Use Start, End, Decision, arrows. Each line has \"虛擬碼步驟 // 解釋\". We cannot output actual code. We need algorithm: backtracking with set to avoid duplicates. Steps: initialize result list, use backtracking function start(index, path). At each index, choose element if path empty or >= last, add to path and if length>=2 add to result (maybe use set to dedup). Recurse index+1. Also skip duplicates: maintain local set of seen at this level. Use global set of sequences. Provide steps.\n\nLet's produce a linear pseudo-code:\n\nStart\n→ Step 1: 定義結果集合 res 及暫存集合全局 unique\n→ Step 2: 定義遞迴函式 backtrack(startIdx, currentPath)\n    → Decision: 如果 startIdx == len(nums)?\n        → Yes → End 函式 // 回到上一層\n        → No → Step 3: 建立局部集合 used_at_level\n        → For i 從 startIdx 到 len(nums)-1:\n            → Decision: nums[i] >= currentPath[-1] or path空?\n                → Yes →\n                    → Step 4: 如果 i 在 used_at_level? → No\n                        → Step 5: 加入 i 至 used_at_level\n                        → Step 6: currentPath.append(nums[i])\n                        → Decision: len(currentPath) >= 2?\n                            → Yes → Step 7: 將序列加入 res（若未重複）\n                            → No → ...\n                        → Step 8: backtrack(i+1, currentPath)\n                        → Step 9: currentPath.pop()\n                → No → continue\n→ Step 10: 呼叫 backtrack(0, 空列表)\n→ Step 11: 回傳 res\nEnd\n\nBut need to use arrow and comment each line. Provide lines with \"虛擬碼步驟\" text. Must not output actual code but pseudo steps. Use \"Step\" lines. Use arrows after decision. Provide explanation comments. Let's craft each line.\n\nAlso we need to ensure uniqueness: we can store sequences as tuples in set to avoid duplicates. So step 7 includes adding to result if not in unique set.\n\nAlso maintain local used_at_level set to avoid duplicate picks at same depth (to prune). That can be part of pseudo.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化全局結果集合 res 與唯一性集合 unique // 用於儲存合法子序列與避免重複\n→ Step 2: 定義遞迴函式 backtrack(startIdx, currentPath) // 探索從 startIdx 開始的子序列\n    → Decision: 如果 startIdx == nums.length? // 已到達陣列結尾\n        Yes → End // 返回上一層\n        No  → Step 3: 建立局部集合 used_at_level // 用於在同一層跳過重複元素\n        → For i 從 startIdx 到 nums.length-1: // 逐一嘗試選取元素\n            → Decision: nums[i] 大於等於 currentPath 的最後一個? 或 currentPath 為空? // 確保非遞減\n                Yes →\n                    → Decision: i 在 used_at_level? // 若已在同一層選過相同值，跳過\n                        Yes → continue\n                        No  → Step 4: 將 i 加入 used_at_level // 標記已使用\n                    → Step 5: currentPath.append(nums[i]) // 選取此元素\n                    → Decision: currentPath.length >= 2? // 子序列長度是否符合要求\n                        Yes →\n                            → Step 6: 將 currentPath 轉為元組 seq\n                            → Decision: seq 在 unique? // 檢查是否已存在\n                                Yes → skip\n                                No  →\n                                    → Step 7: unique.add(seq) // 標記已加入\n                                    → Step 8: res.append(seq) // 加入結果\n                        No → skip\n                    → Step 9: backtrack(i + 1, currentPath) // 深入下一層遞迴\n                    → Step 10: currentPath.pop() // 回溯，移除最後選取的元素\n                No → continue // 若不符合非遞減條件，直接跳過\n→ Step 11: 呼叫 backtrack(0, 空列表) // 從索引 0 開始搜尋\n→ Step 12: 返回 res // 輸出所有不同的非遞減子序列\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findSubsequences(self, nums):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) > 1:\n                res.append(path[:])\n            used = set()\n            for i in range(start, len(nums)):\n                if (not path or nums[i] >= path[-1]) and nums[i] not in used:\n                    used.add(nums[i])\n                    path.append(nums[i])\n                    backtrack(i + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    # 取出所有整數（負數也會被抓到）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    solution = Solution()\n    subsequences = solution.findSubsequences(nums)\n    print(subsequences)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,6,7,7]",
          "expected_output": "[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]",
          "success": true,
          "output": "[[4, 6], [4, 6, 7], [4, 6, 7, 7], [4, 7], [4, 7, 7], [6, 7], [6, 7, 7], [7, 7]]"
        },
        {
          "example_index": 1,
          "input": "nums = [4,4,3,2,1]",
          "expected_output": "[[4,4]]",
          "success": true,
          "output": "[[4, 4]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode535.json",
    "problem_index_in_file": 0,
    "title": "Encode and Decode TinyURL",
    "description_snippet": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL sho...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for design of TinyURL system, including encode/decode methods, mapping storage, generating short URL, maybe using base62 etc. Must use \"Start\", \"Decision:\" etc. Each line must include virtual code step + comment. No actual code. Let's produce step by step pseudo-code. Include class initialization, encode method: generate ID, map to longUrl, produce shortUrl; decode method: parse ID, lookup. Use simple incremental counter. Use base62 conversion for short string. Let's design steps: Start class Solution, initialize counter and maps. encode: increment counter, encode to base62 string, build shortUrl, store mapping. decode: extract code from shortUrl, lookup mapping, return longUrl. Provide decision if code exists? maybe.\n\nAlso we need to maintain uniqueness. So pseudo-code lines.\n\nLet's produce.\n\nAlso we need to follow arrow arrows. Each step line.\n\nWe can produce multiple lines per method. Let's do:\n\nStart // Program start\n\n→ Step: Initialize counter = 0, longToCode map, codeToLong map // prepare data structures\n\nDefine encode(longUrl):\n\n→ Step: If longUrl exists in longToCode map → Return existing short URL (no new id). // reuse\n\n→ Step: Increment counter → id\n\n→ Step: Convert id to base62 string → code\n\n→ Step: Build shortUrl = \"http://tinyurl.com/\" + code\n\n→ Step: Store mapping longToCode[longUrl] = code, codeToLong[code] = longUrl\n\n→ Step: Return shortUrl\n\nDefine decode(shortUrl):\n\n→ Step: Extract code = substring after \"http://tinyurl.com/\"\n\n→ Step: Retrieve longUrl = codeToLong[code] // guaranteed exists\n\n→ Step: Return longUrl\n\nEnd\n\nBut need to use Decision syntax for if statements. So for reuse check:\n\n→ Decision: longUrl in longToCode? // check if already encoded\n\n   Yes → Step: Return \"http://tinyurl.com/\" + longToCode[longUrl] // reuse\n\n   No → Step: Increment counter\n\nAlso maybe check code existence in decode, but guaranteed.\n\nLet's produce each line with arrow and comment. Use Start, End. Provide each step line. Use \"→\" arrows for nested lines.\n\nAlso we need to show methods separately. Might need \"→ Step: define encode\" etc. Let's produce as pseudo-code.\n\nWe must not output actual code, only pseudo.\n\nLet's format each line accordingly.\n\nI'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 初始化 counter = 0，建立空字典 longToCode、codeToLong // 用於存放長網址 ↔ 短碼的對應關係  \n→ Step: 定義 encode(longUrl) // 開始編碼方法  \n  → Decision: longUrl 已在 longToCode 中? // 檢查是否已編碼過  \n   Yes → Step: 返回 \"http://tinyurl.com/\" + longToCode[longUrl] // 直接回傳已有短網址  \n   No  → Step: counter ← counter + 1 // 產生新的 ID  \n    → Step: code ← encodeToBase62(counter) // 把 ID 轉成 base62 字串  \n    → Step: shortUrl ← \"http://tinyurl.com/\" + code // 組合完整短網址  \n    → Step: longToCode[longUrl] ← code // 保存長網址 ↔ 短碼對應  \n    → Step: codeToLong[code] ← longUrl // 保存短碼 ↔ 長網址對應  \n    → Step: 返回 shortUrl // 結束 encode  \n→ Step: 定義 decode(shortUrl) // 開始解碼方法  \n  → Step: code ← substring(shortUrl, len(\"http://tinyurl.com/\")) // 取出短碼  \n  → Step: longUrl ← codeToLong[code] // 查詢對應長網址（已保證存在）  \n  → Step: 返回 longUrl // 結束 decode  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\nimport string\n\nclass Codec:\n    def __init__(self):\n        self.url_map = {}          # short code -> long URL\n        self.base_url = \"http://tinyurl.com/\"\n\n    def encode(self, longUrl: str) -> str:\n        \"\"\"Convert a long URL into a tiny URL.\"\"\"\n        # Generate a unique 6‑character key\n        while True:\n            key = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(6))\n            if key not in self.url_map:\n                break\n        self.url_map[key] = longUrl\n        return self.base_url + key\n\n    def decode(self, shortUrl: str) -> str:\n        \"\"\"Recover the original long URL from a tiny URL.\"\"\"\n        key = shortUrl.replace(self.base_url, '')\n        return self.url_map.get(key, '')\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除首尾空白\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 若輸入被雙引號包住，移除它們\n    if data.startswith('\"') and data.endswith('\"'):\n        data = data[1:-1]\n\n    codec = Codec()\n    short = codec.encode(data)\n    original = codec.decode(short)\n    print(original)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"https://leetcode.com/problems/design-tinyurl\"",
          "expected_output": "\"https://leetcode.com/problems/design-tinyurl\"",
          "success": true,
          "output": "https://leetcode.com/problems/design-tinyurl"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode409.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindrome",
    "description_snippet": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps per line, with explanation. We need to solve the problem: longest palindrome length from letters, case sensitive. We need steps: Count frequency, sum even counts fully, add one odd if any odd. Virtual code representation. Use Start, Decision, etc. Provide explanation. So we produce lines like:\n\nStart // 程式開始\n→ Step 1: 建立頻率表 Count[256] // Initialize count array\n→ Step 2: 逐字遍歷 s 並累計 Count[字]++ // Count occurrences\n→ Step 3: 初始化 longest = 0, oddExists = False // Set base\n→ Decision: If Count[i] > 0? // iterate all chars\n    Yes → Decision: Count[i] is even? // check parity\n        Yes → longest += Count[i] // add all even counts\n        No → longest += Count[i] - 1 // add even part\n            oddExists = True // mark odd presence\n    No → ...\n→ Step 4: If oddExists? // if any odd count\n    Yes → longest += 1 // add one odd center\n→ End // output longest\n\nBut we need to output in required format. Virtual code arrow '→', 'Decision:', 'Yes →', 'No →'. Provide explanation after each line. The arrow should be at beginning? Example shows:\n\nStart // 程式開始執行\n→ Step 1: 輸入使用者數字 // 從使用者處取得一個數值\n\nSo first line is Start, then arrow for steps. So we will produce:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率表 Count[256] = 0 // 初始化計數表\n→ Step 2: For each character ch in s, Count[ch]++ // 逐字累計\n→ Step 3: longest = 0; oddExists = False // 變數初始化\n→ Decision: For each i from 0 to 255? // 逐個字符檢查\n    Yes → Decision: Count[i] == 0? // 無此字符\n        Yes → // 跳過\n        No  → Decision: Count[i] mod 2 == 0? // 判斷偶數\n            Yes → longest += Count[i] // 加入所有偶數\n            No  → longest += Count[i] - 1; oddExists = True // 加入偶數部分並記錄奇數\n→ Decision: oddExists? // 是否存在奇數\n    Yes → longest += 1 // 加入中心字符\n    No  → // 無需額外\nEnd // 程式執行結束\n\nNeed to produce one line per step. For decisions, we have nested decisions; we need to indent? The example uses indent lines: they use spaces for nested lines but keep same format. So we should indent nested lines maybe with spaces.\n\nWe also need to add explanation comment after each line. Provide explanation after arrow line. For decision lines, explanation after the line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率表 Count[256] = 0 // 建立一個 256 元素的計數陣列（對應 ASCII）  \n→ Step 2: For 每個字元 ch in s, Count[ch]++ // 遍歷字串並累計各字元出現次數  \n→ Step 3: longest = 0; oddExists = False // 變數初始化：最長回文長度與是否存在奇數頻數的旗標  \n→ Decision: 逐個檢查所有可能的字元 (i = 0 ~ 255)  \n  Yes → Decision: Count[i] == 0? // 該字元是否不存在？  \n    Yes → // 若不存在，直接跳過  \n    No  → Decision: Count[i] mod 2 == 0? // 該字元的頻數是否為偶數？  \n      Yes → longest += Count[i] // 若偶數，全部可用於回文  \n      No  → longest += Count[i] - 1; oddExists = True // 若奇數，加入偶數部分並標記有奇數  \n→ Decision: oddExists? // 是否至少有一個奇數頻數？  \n  Yes → longest += 1 // 加入一個中心字元以形成回文  \n  No  → // 無奇數，無需額外處理  \nEnd // 程式執行結束，變數 longest 即為可構成的最大回文長度",
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> int:\n        count = {}\n        for ch in s:\n            count[ch] = count.get(ch, 0) + 1\n\n        length = 0\n        odd_found = False\n        for val in count.values():\n            if val % 2 == 0:\n                length += val\n            else:\n                length += val - 1\n                odd_found = True\n        if odd_found:\n            length += 1\n        return length\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if data.startswith('s ='):\n        s = data.split('=', 1)[1].strip()\n        if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n            s = s[1:-1]\n    else:\n        s = data.strip('\"').strip(\"'\")\n    sol = Solution()\n    print(sol.longestPalindrome(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abccccdd\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode502.json",
    "problem_index_in_file": 0,
    "title": "IPO",
    "description_snippet": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Cap...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps for algorithm: classic \"IPO\" Leetcode problem. Approach: Use min-heap for capital requirement, max-heap for profit. Steps: sort projects by capital ascending; iterate k times, push profits of all projects with capital <= current capital into max-heap; pick max profit; add to capital; repeat. Complexity O((n + k) log n). Provide pseudo-code with steps and explanations.\n\nWe must output line by line: each line: \"虛擬碼步驟 // 解釋\".\n\nUse Start, End, Decision, Yes →, No →. Use arrows.\n\nOk produce pseudo-code accordingly.\n\nLet's outline:\n\nStart // program starts\n\n→ Step 1: 組合 projects list as pairs (capital, profit) // Create pair list\n\n→ Step 2: Sort projects by capital ascending // Arrange by required capital\n\n→ Step 3: Initialize minIndex = 0 // pointer to next project in sorted list\n\n→ Step 4: Initialize maxProfitHeap as empty max-heap // store profits of affordable projects\n\n→ Decision: 是否已完成 k 個項目? // check if selected projects count < k\n\n    No → End // if already k, finish\n\n    Yes → Step 5: While minIndex < n and projects[minIndex].capital <= currentCapital: // add affordable projects\n\n        → Step 6: Push projects[minIndex].profit into maxProfitHeap // add profit\n\n        → Step 7: Increment minIndex\n\n    → Decision: maxProfitHeap 是否為空? // check if any affordable\n\n        No → Step 8: currentCapital += ExtractMax(maxProfitHeap) // select best profit\n\n        Yes → Step 9: Break // no more affordable, exit loop\n\n    → Increment selectedCount\n\n    → Go back to Decision: 是否已完成 k 個項目?\n\nEnd // finish\n\nAlso need explanation for each line.\n\nEnsure each line with step.\n\nLet's craft lines.\n\nNote: Need to include k, n, w variables.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立項目清單 projects 為 (capital[i], profits[i]) 的對組 // 以 (資本需求, 纯利潤) 配對  \n→ Step 2: 按資本需求升序排序 projects // 方便按可用資本逐步加入可執行項目  \n→ Step 3: 初始化指標 minIndex = 0 // 指向排序後清單中尚未考慮的第一個項目  \n→ Step 4: 初始化 maxProfitHeap 為空的最大堆 // 用來快速取得最高利潤的項目  \n→ Decision: 目前已選項目數 count < k? // 判斷是否已達最多可執行數量  \n    Yes → Step 5: 當 minIndex < n 且 projects[minIndex].capital ≤ currentCapital 時  \n        → Step 6: 將 projects[minIndex].profit 推入 maxProfitHeap // 把可執行項目的利潤加入堆  \n        → Step 7: minIndex ← minIndex + 1 // 移至下一個項目  \n        → Step 8: 重複 Step 5 的 While 條件  \n    No → End // 已選 k 個項目，結束流程  \n→ Decision: maxProfitHeap 是否為空? // 檢查是否還有可執行項目  \n    No → Step 9: currentCapital ← currentCapital + ExtractMax(maxProfitHeap) // 選擇利潤最高的項目，增加資本  \n    Yes → Step 10: Break // 沒有可執行項目，提前結束  \n→ Step 11: count ← count + 1 // 记录已選項目數量  \n→ Go back to Decision: 目前已選項目數 count < k? // 重新判斷是否需繼續選項目  \nEnd // 程式執行結束，返回最大化後的資本值",
      "generated_code": "import sys\nimport heapq\nimport re\nimport ast\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入，支援：\n    1. k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n    2. 四行分別為 k, w, profits, capital（可能含等號或列表括號）\n    \"\"\"\n    # 先嘗試匹配完整式子\n    pattern = r'k\\s*=\\s*(\\d+),\\s*w\\s*=\\s*(\\d+),\\s*profits\\s*=\\s*(\\[[^\\]]*\\]),\\s*capital\\s*=\\s*(\\[[^\\]]*\\])'\n    m = re.search(pattern, text)\n    if m:\n        k = int(m.group(1))\n        w = int(m.group(2))\n        profits = ast.literal_eval(m.group(3))\n        capital = ast.literal_eval(m.group(4))\n        return k, w, profits, capital\n\n    # 若不是上述格式，按行解析\n    lines = [line.strip() for line in text.splitlines() if line.strip()]\n    if len(lines) < 4:\n        raise ValueError(\"輸入格式不符合預期\")\n    # 第一行 k\n    k_part = lines[0]\n    k = int(k_part.split('=')[-1].strip()) if '=' in k_part else int(k_part)\n    # 第二行 w\n    w_part = lines[1]\n    w = int(w_part.split('=')[-1].strip()) if '=' in w_part else int(w_part)\n    # 第三行 profits\n    profits_part = lines[2]\n    if '[' in profits_part:\n        profits = ast.literal_eval(profits_part.split('=')[-1].strip())\n    else:\n        profits = list(map(int, profits_part.split()))\n    # 第四行 capital\n    capital_part = lines[3]\n    if '[' in capital_part:\n        capital = ast.literal_eval(capital_part.split('=')[-1].strip())\n    else:\n        capital = list(map(int, capital_part.split()))\n    return k, w, profits, capital\n\nclass Solution:\n    def findMaximizedCapital(self, k: int, W: int, Profits: list, Capital: list) -> int:\n        # 將項目按資本需求升序排序\n        projects = sorted(zip(Capital, Profits))\n        max_heap = []  # 儲存可執行項目的利潤，使用負值作為最大堆\n        i = 0\n        n = len(Profits)\n\n        for _ in range(k):\n            # 把所有可負擔的項目加入堆\n            while i < n and projects[i][0] <= W:\n                heapq.heappush(max_heap, -projects[i][1])\n                i += 1\n            if not max_heap:\n                break  # 沒有可執行項目\n            # 選擇利潤最高的項目\n            W += -heapq.heappop(max_heap)\n\n        return W\n\ndef main():\n    text = sys.stdin.read()\n    if not text.strip():\n        return\n    k, w, profits, capital = parse_input(text)\n    sol = Solution()\n    result = sol.findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode242.json",
    "problem_index_in_file": 0,
    "title": "Valid Anagram",
    "description_snippet": "Given two strings s and t, return true if t is an anagram of s, and false otherwise....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Use Start, End, Decision. Provide per line: \"虛擬碼步驟 // 解釋\". Need to cover algorithm: check lengths, count characters with hash map or array. Simpler: use dictionary count. Steps: Start, Input s, t. Decision length equal? If No → return false. If Yes, create map counts. Iterate s: increment. Iterate t: decrement. After loops, check all counts zero → return true else false. Represent each step.\n\nWe should use arrows. Example: \"Start // 程式開始執行\". Then \"→ Input: s, t // 取得兩個字串\". Then Decision: \"Decision: s.length == t.length? // 檢查長度是否相同\". Yes -> proceed, No -> return false. Then step \"→ Create map counts // 建立字元計數表\". Then step \"→ For each char c in s: increment counts[c]\". Then step \"→ For each char c in t: decrement counts[c]\". Then Decision: \"Decision: all counts are 0? // 檢查是否所有字元計數為零\". Yes -> return true. No -> return false. End.\n\nMake sure each line uses the arrow arrow? Provide each step line with arrow. Use \"→\" for sequential steps. Use \"Decision:\" for decision. Provide arrow after decisions: Yes → ... No → ... Provide nested.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: s, t // 取得兩個字串  \n→ Decision: s.length == t.length? // 檢查兩字串長度是否相同  \n Yes → Create map counts // 建立字元計數表（如字典或陣列）  \n No → Return false // 長度不同，直接返回假  \n→ For each char c in s: increment counts[c] // 遍歷 s，對每個字元計數+1  \n→ For each char c in t: decrement counts[c] // 遍歷 t，對每個字元計數-1  \n→ Decision: all counts are 0? // 檢查所有字元計數是否已回到 0  \n Yes → Return true // 所有計數為 0，代表 t 是 s 的字母重排  \n No  → Return false // 有計數非 0，代表不是字母重排  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        \"\"\"Return True if t is an anagram of s, otherwise False.\"\"\"\n        return Counter(s) == Counter(t)\n\ndef main() -> None:\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取得所有被雙引號包住的字串\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) < 2:\n        # 如果沒有找到雙引號，嘗試直接以逗號分隔\n        parts = [p.strip() for p in data.split(',') if p.strip()]\n    if len(parts) < 2:\n        # 無法解析輸入，直接輸出 false\n        print(\"false\")\n        return\n\n    s, t = parts[0], parts[1]\n    solution = Solution()\n    result = solution.isAnagram(s, t)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"anagram\", t = \"nagaram\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"rat\", t = \"car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode301.json",
    "problem_index_in_file": 0,
    "title": "Remove Invalid Parentheses",
    "description_snippet": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parenth...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nThe task: we need to output virtual code steps for the algorithm that removes minimum invalid parentheses to produce all valid strings. This is classic Leetcode 301. Approach: compute left/right counts to remove, then DFS backtracking generating results with pruning. Or BFS to find all minimal solutions. Use DFS with pruning. Steps: count lremove, rremove. Then backtrack function with index, left count, lremove, rremove, path, result. Skip duplicates by using set. At end add string. Complexity. So produce virtual code lines.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision: etc.\n\nLet's write high-level pseudocode: Start, compute counts, define backtrack, call, return results, End.\n\nInside backtrack: Decision: index == len(s)? then check remaining removals: if lremove==0 && rremove==0 -> add. Else return. Decision: current char is '('? then branch: remove it -> call with lremove-1. Keep it: call with left+1. Decision: char is ')'? branch: if left>0: keep -> left-1; remove -> rremove-1. Decision: char is letter: keep -> just append.\n\nAlso maintain path string. For pruning duplicate results, use set. But we can simply add to set.\n\nWe need to produce each step line.\n\nLet's craft pseudocode.\n\nWe need to use arrow for lines: \"Start // 程式開始執行\". Then arrow lines. Use \"→\" for sequence. For decision: indent.\n\nWe'll produce maybe 30-40 lines. Let's plan:\n\nStart\n→ Step 1: 計算需移除左括號 lremove 以及右括號 rremove // 透過遍歷 s\n→ Step 2: 定義空集合 result // 存放所有有效字串\n→ Step 3: 定義遞迴函式 backtrack(index, leftCount, lremove, rremove, path) // 探索所有合法組合\n→     Decision: 如果 index == s.length?\n→         Yes → Step 4: 如果 lremove==0 且 rremove==0? // 檢查是否已移除足夠\n→             Yes → Step 5: 加入 path 至 result // 成功方案\n→             No  → Step 6: 回傳 // 未滿足條件\n→         No  → Step 7: current = s.charAt(index) // 取得目前字元\n→             Decision: 如果 current == '('?\n→                 Yes → Step 8: 如果 lremove > 0? // 移除 '(' 的選項\n→                     Yes → backtrack(index+1, leftCount, lremove-1, rremove, path) // 跳過 '('\n→                     No  → // 不做\n→                 Yes → Step 9: 保留 '(' → backtrack(index+1, leftCount+1, lremove, rremove, path+'(')\n→             Decision: 如果 current == ')'?\n→                 Yes → Step 10: 如果 leftCount > 0? // 可以保留 ')'\n→                     Yes → backtrack(index+1, leftCount-1, lremove, rremove, path+')')\n→                     No  → // 不保留\n→                 Yes → Step 11: 如果 rremove > 0? // 移除 ')' 的選項\n→                     Yes → backtrack(index+1, leftCount, lremove, rremove-1, path)\n→                     No  → // 不做\n→             Decision: 否則 (字母)\n→                 Yes → Step 12: 保留字母 → backtrack(index+1, leftCount, lremove, rremove, path+current)\n→ Step 13: 呼叫 backtrack(0,0,lremove,rremove,\"\") // 開始遞迴\n→ Step 14: 返回 result // 結果集合\nEnd\n\nAdd comments. Ensure each line includes explanation. We'll output as per format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算需移除左括號 lremove 與右括號 rremove // 透過一次遍歷 s  \n→ Step 2: 定義空集合 result // 存放所有符合條件的有效字串  \n→ Step 3: 定義遞迴函式 backtrack(index, leftCount, lremove, rremove, path) // 探索所有合法組合  \n→     Decision: 如果 index == s.length()? // 到達字串結尾  \n→         Yes → Step 4: 如果 lremove==0 且 rremove==0? // 確認已移除足夠括號  \n→             Yes → Step 5: 加入 path 至 result // 成功方案，加入結果集合  \n→             No  → Step 6: 回傳 // 尚未滿足條件，直接回傳  \n→         No  → Step 7: current = s.charAt(index) // 取得目前字元  \n→             Decision: 如果 current == '('? // 遇到左括號  \n→                 Yes → Step 8: 如果 lremove > 0? // 有移除選項  \n→                     Yes → backtrack(index+1, leftCount, lremove-1, rremove, path) // 跳過 '('  \n→                     No  → // 不做任何事  \n→                 Yes → Step 9: 保留 '(' → backtrack(index+1, leftCount+1, lremove, rremove, path+'(') // 保留左括號  \n→             Decision: 如果 current == ')'? // 遇到右括號  \n→                 Yes → Step 10: 如果 leftCount > 0? // 可以配對右括號  \n→                     Yes → backtrack(index+1, leftCount-1, lremove, rremove, path+')') // 保留右括號  \n→                     No  → // 無法配對，跳過此分支  \n→                 Yes → Step 11: 如果 rremove > 0? // 有移除選項  \n→                     Yes → backtrack(index+1, leftCount, lremove, rremove-1, path) // 跳過 ')'  \n→                     No  → // 不做任何事  \n→             Decision: 否則 (字母)  \n→                 Yes → Step 12: 保留字母 → backtrack(index+1, leftCount, lremove, rremove, path+current) // 加入字母  \n→ Step 13: 呼叫 backtrack(0,0,lremove,rremove,\"\") // 從字串起始處開始遞迴  \n→ Step 14: 返回 result // 將所有有效字串輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        \"\"\"\n        Return all possible strings after removing the minimum number of\n        invalid parentheses to make the string valid.\n        \"\"\"\n        # 1. Count how many left and right parentheses need to be removed\n        lremove, rremove = 0, 0\n        for ch in s:\n            if ch == '(':\n                lremove += 1\n            elif ch == ')':\n                if lremove == 0:\n                    rremove += 1\n                else:\n                    lremove -= 1\n\n        result = set()  # use a set to avoid duplicates\n\n        def backtrack(index: int, left: int, lrem: int, rrem: int, path: str):\n            # 2. If we have processed all characters\n            if index == len(s):\n                if lrem == 0 and rrem == 0:\n                    result.add(path)\n                return\n\n            ch = s[index]\n\n            # 3. If the current character is a left parenthesis\n            if ch == '(':\n                # 3a. Option 1: remove it\n                if lrem > 0:\n                    backtrack(index + 1, left, lrem - 1, rrem, path)\n                # 3b. Option 2: keep it\n                backtrack(index + 1, left + 1, lrem, rrem, path + ch)\n\n            # 4. If the current character is a right parenthesis\n            elif ch == ')':\n                # 4a. Option 1: remove it\n                if rrem > 0:\n                    backtrack(index + 1, left, lrem, rrem - 1, path)\n                # 4b. Option 2: keep it only if there's a matching left\n                if left > 0:\n                    backtrack(index + 1, left - 1, lrem, rrem, path + ch)\n\n            # 5. If the current character is a letter, always keep it\n            else:\n                backtrack(index + 1, left, lrem, rrem, path + ch)\n\n        # 6. Kick off the recursion\n        backtrack(0, 0, lremove, rremove, \"\")\n\n        return list(result)\n\n\nif __name__ == \"__main__\":\n    # Read input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Handle possible \"s = \\\"...\\\"\" or \"s = '...'\" format\n    if \"=\" in raw_input:\n        _, value = raw_input.split(\"=\", 1)\n        raw_input = value.strip()\n    # Remove surrounding quotes if present\n    if (raw_input.startswith('\"') and raw_input.endswith('\"')) or \\\n       (raw_input.startswith(\"'\") and raw_input.endswith(\"'\")):\n        raw_input = raw_input[1:-1]\n\n    s = raw_input\n    sol = Solution()\n    outputs = sol.removeInvalidParentheses(s)\n    print(outputs)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "success": true,
          "output": "['(())()', '()()()']"
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a)()()\",\"(a())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a)()()', '(a())()']\""
        },
        {
          "example_index": 2,
          "input": "s = \")(\"",
          "expected_output": "[\"\"]",
          "success": true,
          "output": "['']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode482.json",
    "problem_index_in_file": 0,
    "title": "License Key Formatting",
    "description_snippet": "You are given a license key represented as a string s that consists of only alphanumeric characters ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: given string s with alphanumerics and dashes, group into n+1 groups, reformat: each group k except first may be shorter but at least one. Convert to uppercase, insert dashes. Return reformatted string. We need to output step-by-step virtual code with explanation after each line.\n\nLet's think algorithm:\n\n- Remove existing dashes from s\n- Convert to uppercase\n- Compute length L = len(clean_string)\n- Determine size of first group: L % k; if 0, first group size = k\n- Build result string: \n   - If first group size > 0: add first group (clean[0:first_group_size])\n   - For i from first_group_size to L, step k:\n        add '-' + clean[i:i+k]\n- Return result\n\nEdge cases: L==0? but s has at least one alphanumeric? Possibly. But if L==0 return empty? We'll include condition.\n\nNow produce virtual code step by step with explanations.\n\nWe need to use Start, End, Decision, arrow.\n\nLet's produce lines:\n\nStart // program start\n→ Step 1: 定義 clean_string ← RemoveAllDashes(s) // 去除所有連字符\n→ Step 2: clean_string ← ToUpperCase(clean_string) // 轉換為大寫\n→ Decision: 如果 clean_string 為空? // 檢查是否剩下任何字元\n    Yes → Step 3: Return \"\" // 若無字元，直接回傳空字串\n    No  → Step 4: length ← Length(clean_string) // 計算清理後字串長度\n→ Step 5: first_group_size ← length mod k // 計算首組大小\n→ Decision: 如果 first_group_size 等於 0? // 若模為 0，首組實際為 k\n    Yes → first_group_size ← k // 設置首組為 k\n    No  → // 保持原值\n→ Step 6: result ← Substring(clean_string, 0, first_group_size) // 取首組\n→ Step 7: index ← first_group_size // 初始化索引\n→ Decision: 如果 index 小於 length? // 是否還有剩餘字元\n    Yes →\n        → While index < length: // 迴圈處理後續組\n            → result ← result + \"-\" + Substring(clean_string, index, k) // 加上分隔符與下一組\n            → index ← index + k // 更新索引\n    No →\n→ End // 回傳結果\n\nBut we need to return result at the end. So Step 8: Return result // 回傳重新格式化的字串\n\nNeed to maintain decision and loop.\n\nThe loop we used is While; but need arrow lines: While, body, update. Use Decision for while condition.\n\nLet's craft properly:\n\n- Use While loop representation: \n   → Decision: index < length? // 檢查是否還有字元\n        Yes → Step 8: result ← result + \"-\" + Substring(clean_string, index, k) // 加入分隔符與下一組\n             → Step 9: index ← index + k // 移動到下一個組\n        No  → // 退出迴圈\n\nBut loop should continue until condition false. That structure uses Decision repeated.\n\nAlternatively:\n\n→ While index < length:\n    → result ← ...\n    → index ← ...\n\nBut we need to use Decision: If we follow format guidelines, we can use Decision for condition.\n\nBetter: Use a loop: \n→ Decision: index < length? // 需要迭代\n    Yes → \n        → Step 8: result ← result + \"-\" + Substring(clean_string, index, k) // 加入分隔符與下一組\n        → Step 9: index ← index + k // 更新索引\n        → Decision: index < length? // 再次判斷\n            Yes → repeat loop\n            No  → \n    No  → \n\nBut this becomes nested.\n\nSimplify: Use a While block with Decision at start, as typical pseudocode: \n→ Decision: index < length? // 迴圈條件\n    Yes → \n        → Step 8: result ← result + \"-\" + Substring(clean_string, index, k)\n        → Step 9: index ← index + k\n        → Decision: index < length? // 重新評估條件\n            Yes → ...\n            No  →\n    No  → \n\nBut this repeats.\n\nBetter to show while loop conceptually: \n→ While index < length:\n    → Step 8: result ← result + \"-\" + Substring(clean_string, index, k)\n    → Step 9: index ← index + k\n\nBut guidelines mention using Decision. We can approximate: \"While index < length:\" can be represented as \"Decision: index < length? → ...\" with recursion.\n\nBut to keep it simple, we can use pseudo loop: \n→ Decision: index < length? \n    Yes → \n        → Step 8: result ← result + \"-\" + Substring(clean_string, index, k)\n        → Step 9: index ← index + k\n        → Decision: index < length? ... repeat\n    No → \n\nOk.\n\nLet's produce final output accordingly.\n\nMake sure each line has \"虛擬碼步驟\" + \" // 解釋\". Use arrow, Start, End, Decision.\n\nWe need to include each step in one line.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: clean_string ← RemoveAllDashes(s) // 去除原字串中的所有連字符\n→ Step 2: clean_string ← ToUpperCase(clean_string) // 轉為大寫字母\n→ Decision: clean_string 為空? // 檢查是否剩下任何字元\n    Yes → Step 3: Return \"\" // 若無字元，直接回傳空字串\n    No  → Step 4: length ← Length(clean_string) // 計算清理後字串長度\n→ Step 5: first_group_size ← length mod k // 計算首組字元數\n→ Decision: first_group_size 等於 0? // 若模為 0，表示首組應為 k\n    Yes → first_group_size ← k // 設為 k\n    No  → // 保持原值\n→ Step 6: result ← Substring(clean_string, 0, first_group_size) // 取得第一組\n→ Step 7: index ← first_group_size // 設定下一個索引位置\n→ Decision: index < length? // 是否還有剩餘字元需要分組\n    Yes → \n        → Step 8: result ← result + \"-\" + Substring(clean_string, index, k) // 加入分隔符和下一組\n        → Step 9: index ← index + k // 更新索引\n        → Decision: index < length? // 重新評估是否需要繼續\n            Yes → ... // 重複上一步\n            No  → \n    No  → \n→ Step 10: Return result // 回傳重新格式化的授權金鑰\nEnd // 程式執行結束\n\nBut we need \"...\" replaced with actual steps. The loop repeats. We can denote \"Repeat\" conceptually.\n\nSimplify: use a While block: \"While index < length:\".\n\nWe can incorporate:\n\n→ While index < length: // 迴圈直到索引超過字串長度\n    → Step 8: result ← result + \"-\" + Substring(clean_string, index, k) // 加入分隔符和下一組\n    → Step 9: index ← index + k // 更新索引\n\nBut guidelines said to use Decision for loops.\n\nLet's adapt: \n→ Decision: index < length? // 迴圈條件\n    Yes → \n        → Step 8: result ← result + \"-\" + Substring(clean_string, index, k)\n        → Step 9: index ← index + k\n        → Decision: index < length? // 重新評估\n            Yes → ... // 重複\n            No  → \n    No  → \n\nBut we can just show that the loop repeats by using \"...\" or \"Repeat\". Maybe acceptable. But the requirement: \"逐行輸出\" and each line must be a virtual code step. The \"...\" indicates omitted repetition; but we might need to represent entire loop as a single step.\n\nBetter: Represent loop as a block:\n\n→ While index < length: // 只要有剩餘字元就重複\n    → Step 8: result ← result + \"-\" + Substring(clean_string, index, k) // 加入分隔符和下一組\n    → Step 9: index ← index + k // 更新索引\n\nBut \"While\" is not defined in spec, but maybe allowed. The spec said use Decision: Yes → No. But \"While\" not defined. But we can mimic with Decision at the start of block. But we can cheat: We can use \"Decision: index < length? // 迴圈條件\" and then inside we show steps and then a line that loops back to the Decision? That might be too complex.\n\nSimplest: Use \"While index < length:\" as pseudo-step. Even if not in spec, it's okay.\n\nGiven the instruction, using Decision: Yes → No is recommended. But maybe while is acceptable.\n\nI'll produce output with Decision structure, but include \"Repeat\" comment.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: clean_string ← RemoveAllDashes(s) // 去除原字串中的所有連字符  \n→ Step 2: clean_string ← ToUpperCase(clean_string) // 轉為大寫字母  \n→ Decision: clean_string 為空? // 檢查是否剩下任何字元  \n    Yes → Step 3: Return \"\" // 若無字元，直接回傳空字串  \n    No  → Step 4: length ← Length(clean_string) // 計算清理後字串長度  \n→ Step 5: first_group_size ← length mod k // 計算首組字元數  \n→ Decision: first_group_size 等於 0? // 若模為 0，表示首組應為 k  \n    Yes → first_group_size ← k // 設為 k  \n    No  → // 保持原值  \n→ Step 6: result ← Substring(clean_string, 0, first_group_size) // 取得第一組  \n→ Step 7: index ← first_group_size // 設定下一個索引位置  \n→ Decision: index < length? // 是否還有剩餘字元需要分組  \n    Yes →  \n        → Step 8: result ← result + \"-\" + Substring(clean_string, index, k) // 加入分隔符和下一組  \n        → Step 9: index ← index + k // 更新索引  \n        → Decision: index < length? // 重新評估是否需要繼續  \n            Yes → … // 重複步 8 與 9  \n            No  →  \n    No  →  \n→ Step 10: Return result // 回傳重新格式化的授權金鑰  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        # 移除所有 '-' 並轉為大寫\n        s = s.replace('-', '').upper()\n        n = len(s)\n        first_group_len = n % k or k  # 第一組長度\n\n        res = [s[:first_group_len]]\n        for i in range(first_group_len, n, k):\n            res.append(s[i:i + k])\n        return '-'.join(res)\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入\n    # 支援形如: s = \"5F3Z-2e-9-w\", k = 4 或簡易的兩行輸入\n    s_match = re.search(r's\\s*=\\s*[\"\\'](.*?)[\"\\']', data)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', data)\n\n    if s_match:\n        s = s_match.group(1)\n    else:\n        # 直接取第一個非空白片段\n        s = data.split()[0]\n\n    if k_match:\n        k = int(k_match.group(1))\n    else:\n        # 若未能匹配，嘗試從最後一個片段取數字\n        parts = data.split()\n        k = int(parts[-1]) if parts else 0\n\n    solution = Solution()\n    result = solution.licenseKeyFormatting(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"5F3Z-2e-9-w\", k = 4",
          "expected_output": " \"5F3Z-2E9W\"",
          "success": true,
          "output": "5F3Z-2E9W"
        },
        {
          "example_index": 1,
          "input": "s = \"2-5g-3-J\", k = 2",
          "expected_output": "\"2-5G-3J\"",
          "success": true,
          "output": "2-5G-3J"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode373.json",
    "problem_index_in_file": 0,
    "title": "Find K Pairs with Smallest Sums",
    "description_snippet": "You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nD...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode for algorithm that returns k pairs with smallest sums from two sorted arrays. Use priority queue approach.\n\nWe need line by line with arrow and comments.\n\nLet's craft:\n\nStart\n→ Initialize min-heap with pair of first elements (i=0,j=0) and sum\n→ visited set\n→ result list\n→ While result size < k and heap not empty:\n    ← pop smallest sum from heap\n    → add pair to result\n    → If next j+1 exists and not visited, push (i, j+1)\n    → If next i+1 exists and not visited, push (i+1, j)\nReturn result\n\nWe must include explanation comments.\n\nNeed each line with arrow and comment.\n\nLet's produce lines. Use \"Decision:\" for loops? The sample uses Decision for conditions. We can use Decision for while loop? We'll use Decision for loop condition. Use arrow for steps.\n\nAlso need Start, End.\n\nLet's produce pseudocode lines.\n\nAlso must handle visited to avoid duplicates: visited set.\n\nOk. Let's craft.\n\nWe need to include \"Initialize\" lines as steps.\n\nWe'll produce lines with spaces.\n\nLet's produce.\n\nAlso maybe include variable declarations.\n\nWe'll do:\n\nStart\n→ Initialize min-heap // 先建立最小堆\n→ Initialize visited set // 追蹤已加入堆的索引組合\n→ Initialize result list // 存放已取出的最小總和對\n→ If nums1 and nums2 not empty:\n    → Push (0,0) with sum into heap // 第一個可能的最小對\n    → Mark (0,0) visited\nDecision: result size < k AND heap not empty? // 檢查是否還需要取對\n    Yes → Pop top from heap // 取出目前最小總和對\n    → Add pair (nums1[i], nums2[j]) to result // 存到結果\n    → If j+1 < len(nums2) AND (i, j+1) not visited:\n        → Push (i, j+1) with new sum // 考慮下一個 j\n        → Mark visited\n    → If i+1 < len(nums1) AND (i+1, j) not visited:\n        → Push (i+1, j) with new sum // 考慮下一個 i\n        → Mark visited\n    → Continue Decision loop\n    No → End // 完成\n\nBut we need to output each line individually.\n\nNeed to ensure each line ends with // explanation.\n\nLet's produce.\n\nWe'll also need \"Return result\" before End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize min-heap // 建立最小堆，用以取得目前最小總和的對\n→ Initialize visited set // 追蹤已加入堆的索引組合，避免重複\n→ Initialize result list // 存放已選出的 k 個最小總和對\n→ If nums1 and nums2 not empty:\n    → Push (0,0) with sum nums1[0]+nums2[0] into heap // 第一個可能的最小對\n    → Mark (0,0) visited\nDecision: result size < k AND heap not empty? // 需要繼續找尋對嗎？\n    Yes → Pop top from heap // 取出目前最小總和對\n    → Add pair (nums1[i], nums2[j]) to result // 加入結果列表\n    → If j+1 < len(nums2) AND (i, j+1) not visited:\n        → Push (i, j+1) with sum nums1[i]+nums2[j+1] into heap // 考慮下一個 j\n        → Mark (i, j+1) visited\n    → If i+1 < len(nums1) AND (i+1, j) not visited:\n        → Push (i+1, j) with sum nums1[i+1]+nums2[j] into heap // 考慮下一個 i\n        → Mark (i+1, j) visited\n    → Continue Decision loop // 重新檢查條件\n    No → Return result // 已取得 k 個最小總和對，結束\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form:\n       nums1 = [1,7,11]\n       nums2 = [2,4,6]\n       k = 3\n    \"\"\"\n    nums1_match = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    nums2_match = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match     = re.search(r'k\\s*=\\s*(\\d+)', data)\n\n    nums1 = eval(nums1_match.group(1)) if nums1_match else []\n    nums2 = eval(nums2_match.group(1)) if nums2_match else []\n    k     = int(k_match.group(1)) if k_match else 0\n    return nums1, nums2, k\n\ndef k_smallest_pairs(nums1, nums2, k):\n    \"\"\"Return k pairs with smallest sums from two sorted arrays.\"\"\"\n    if not nums1 or not nums2 or k <= 0:\n        return []\n\n    heap = []\n    res  = []\n\n    # Initialize heap with pairs (nums1[i], nums2[0]) for i in [0, min(k, len(nums1)))\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n    while heap and len(res) < k:\n        cur_sum, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return res\n\ndef main():\n    data = sys.stdin.read()\n    nums1, nums2, k = parse_input(data)\n    result = k_smallest_pairs(nums1, nums2, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3",
          "expected_output": "[[1,2],[1,4],[1,6]]",
          "success": true,
          "output": "[[1, 2], [1, 4], [1, 6]]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2",
          "expected_output": "[[1,1],[1,1]]",
          "success": true,
          "output": "[[1, 1], [1, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode162.json",
    "problem_index_in_file": 0,
    "title": "Find Peak Element",
    "description_snippet": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line explanation for algorithm: binary search to find peak in O(log n). Use while low < high, mid = low + (high - low)/2. If nums[mid] > nums[mid+1], high = mid else low = mid+1. At end return low. Provide virtual code lines with arrows. Provide Start, End, Decision. Provide explanation each line. No actual code, just virtual steps.\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化 low = 0, high = n-1 // 設定搜尋區間\n→ Decision: low < high? // 判斷是否還有多於一個元素需要比較\n    Yes → Step 2: 計算 mid = low + (high - low) / 2 // 中點位置\n    → Decision: nums[mid] > nums[mid+1]? // 與右鄰比較\n        Yes → Step 3: high = mid // 右邊可能存在更高的峰\n        No  → Step 4: low = mid + 1 // 左邊峰已被排除，向右搜尋\n    No → Step 5: 返回 low // low==high 時即為峰索引\nEnd\n\nAdd brief explanation after each line.\n\nLet's output exactly as required.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 low = 0, high = n-1 // 設定搜尋區間為整個陣列\n→ Decision: low < high? // 判斷是否還有多於一個元素需要比較\n    Yes → Step 2: 計算 mid = low + (high - low) / 2 // 找出中間索引\n    → Decision: nums[mid] > nums[mid+1]? // 與右側鄰居比較\n        Yes → Step 3: high = mid // 右側存在更高的元素，峰一定在左半部\n        No  → Step 4: low = mid + 1 // 左側已不是峰，向右搜尋\n    No → Step 5: 返回 low // low == high 時即為峰的索引\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findPeakElement(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < nums[mid + 1]:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\ndef parse_input():\n    \"\"\"\n    讀取整個標準輸入，提取列表內容並轉為 Python list。\n    支援形如 'nums = [1,2,3,1]' 或僅包含列表 '[1,2,3,1]' 的輸入。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    # 先找出最外層的方括號\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if not match:\n        return []\n\n    list_str = match.group(0)\n    try:\n        # 安全解析為 Python 對象\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 若解析失敗，直接抽取所有整數\n        nums = list(map(int, re.findall(r'-?\\d+', list_str)))\n    return nums\n\ndef main():\n    nums = parse_input()\n    if not nums:\n        return\n    sol = Solution()\n    peak_index = sol.findPeakElement(nums)\n    print(peak_index)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,1,3,5,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode87.json",
    "problem_index_in_file": 0,
    "title": "Scramble String",
    "description_snippet": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the st...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines following the format, describing algorithm to determine if s2 is scramble of s1. Use recursion/memoization perhaps. Provide explanation after each line.\n\nWe'll produce something like:\n\nStart\n→ Decision: s1 == s2? if yes return true\n→ Decision: len(s1) == 1? if no, proceed\n→ Decision: sorted(s1) == sorted(s2)? if no return false\n→ Loop i from 1 to len-1:\n    → Decision: (s1[0:i] scramble s2[0:i] AND s1[i:] scramble s2[i:]) OR (s1[0:i] scramble s2[len-i:] AND s1[i:] scramble s2[0:len-i])\n        Yes → return true\n→ return false\nEnd\n\nBut must use the arrow format. Each line: \"虛擬碼步驟 // 解釋\".\n\nWe need to keep it structured with Start, End, Decision: lines. Use arrows.\n\nLet's craft.\n\nAlso include recursion function maybe: Define function isScramble(s1,s2) returns boolean.\n\nWe'll produce pseudo-code:\n\nStart\n→ Function isScramble(s1, s2) // 定義遞歸函式\n    → Decision: s1 == s2? // 若兩字串相同即為 Scramble\n        Yes → Return true\n    → Decision: len(s1) != len(s2)? // 若長度不同不可 Scramble\n        Yes → Return false\n    → Decision: Sorted(s1) != Sorted(s2)? // 字符頻率不同則不可 Scramble\n        Yes → Return false\n    → Decision: len(s1) == 1? // 單字元直接不匹配已排除\n        Yes → Return false\n    → For i from 1 to len(s1)-1: // 逐步分割\n        → Decision: (isScramble(s1[0:i], s2[0:i]) AND isScramble(s1[i:], s2[i:])) OR (isScramble(s1[0:i], s2[len(s2)-i:]) AND isScramble(s1[i:], s2[0:len(s2)-i]))? // 檢查兩種拆分方式\n            Yes → Return true\n    → Return false // 若無任何分割使之成 Scramble\nEnd\n\nBut each line with arrow indentation. Use \"→\" for nested. For For loop, we can show Decision inside.\n\nLet's format:\n\nStart // 程式開始\n→ Function isScramble(s1, s2) // 定義遞歸檢查函式\n    → Decision: s1 == s2? // 直接相等則為合法 Scramble\n        Yes → Return true\n    → Decision: len(s1) != len(s2)? // 長度不同即不合法\n        Yes → Return false\n    → Decision: Sort(s1) != Sort(s2)? // 字符分布不同即不合法\n        Yes → Return false\n    → Decision: len(s1) == 1? // 單字符且不相等已被排除\n        Yes → Return false\n    → For i = 1 to len(s1)-1: // 嘗試所有切分點\n        → Decision: (isScramble(s1[0:i], s2[0:i]) AND isScramble(s1[i:], s2[i:])) OR (isScramble(s1[0:i], s2[len(s2)-i:]) AND isScramble(s1[i:], s2[0:len(s2)-i]))? // 檢查不交換和交換兩種情況\n            Yes → Return true\n    → Return false // 所有切分點均不滿足\nEnd // 程式結束\n\nNeed to ensure each line has the pattern: code + space + // explanation. For nested lines we keep indentation.\n\nWe must avoid actual code; it's virtual code. Use placeholders like s1[0:i] to indicate substring. Use \"len(s1)\" etc. It's fine.\n\nReturn statements can be \"Return true\" \"Return false\".\n\nLet's output exactly.\n\nMake sure to maintain the arrows for decisions and for loops maybe use \"→ For i = 1 to ...:\" as a step.\n\nWe'll produce:\n\n```\nStart // 程式開始執行\n→ Function isScramble(s1, s2) // 定義遞歸檢查函式\n    → Decision: s1 == s2? // 兩字串相同即為合法 Scramble\n        Yes → Return true\n    → Decision: len(s1) != len(s2)? // 長度不同即不合法\n        Yes → Return false\n    → Decision: Sort(s1) != Sort(s2)? // 字符頻率不同即不合法\n        Yes → Return false\n    → Decision: len(s1) == 1? // 單字符且不相等已排除\n        Yes → Return false\n    → For i = 1 to len(s1)-1: // 嘗試所有切分點\n        → Decision: (isScramble(s1[0:i], s2[0:i]) AND isScramble(s1[i:], s2[i:])) OR (isScramble(s1[0:i], s2[len(s2)-i:]) AND isScramble(s1[i:], s2[0:len(s2)-i]))? // 檢查不交換和交換兩種情況\n            Yes → Return true\n    → Return false // 所有切分點均不滿足\nEnd // 程式執行結束\n```\n\nThat should meet format.\n\nBut maybe we need to add memoization step? Not necessary but could be included. We can add: Decision: cache exists? But not required.\n\nThe format uses \"Decision:\" and \"→\" and \"Yes →\" \"No →\". For For loop we might need \"→ For i = 1 to len(s1)-1:\" then inside. Provide indentation.\n\nOk.\n\nLet's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Function isScramble(s1, s2) // 定義遞歸檢查函式\n    → Decision: s1 == s2? // 兩字串相同即為合法 Scramble\n        Yes → Return true\n    → Decision: len(s1) != len(s2)? // 長度不同即不合法\n        Yes → Return false\n    → Decision: Sort(s1) != Sort(s2)? // 字符頻率不同即不合法\n        Yes → Return false\n    → Decision: len(s1) == 1? // 單字符且不相等已排除\n        Yes → Return false\n    → For i = 1 to len(s1)-1: // 嘗試所有切分點\n        → Decision: (isScramble(s1[0:i], s2[0:i]) AND isScramble(s1[i:], s2[i:])) OR (isScramble(s1[0:i], s2[len(s2)-i:]) AND isScramble(s1[i:], s2[0:len(s2)-i]))? // 檢查不交換和交換兩種情況\n            Yes → Return true\n    → Return false // 所有切分點均不滿足\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self):\n        self.memo = {}\n\n    def isScramble(self, s1: str, s2: str) -> bool:\n        # 用 memo 來避免重複計算\n        if (s1, s2) in self.memo:\n            return self.memo[(s1, s2)]\n\n        # 兩字串相同直接成立\n        if s1 == s2:\n            self.memo[(s1, s2)] = True\n            return True\n\n        # 字符頻率不同不可能\n        if sorted(s1) != sorted(s2):\n            self.memo[(s1, s2)] = False\n            return False\n\n        n = len(s1)\n        # 逐步嘗試所有分割點\n        for i in range(1, n):\n            # 情況一：不交換\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                self.memo[(s1, s2)] = True\n                return True\n            # 情況二：交換\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                self.memo[(s1, s2)] = True\n                return True\n\n        self.memo[(s1, s2)] = False\n        return False\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中提取 s1 與 s2。\"\"\"\n    # 先嘗試找 s1 = \"xxx\", s2 = \"yyy\" 的格式\n    s1s = re.findall(r's1\\s*=\\s*\"([^\"]*)\"', data)\n    s2s = re.findall(r's2\\s*=\\s*\"([^\"]*)\"', data)\n    if s1s and s2s:\n        return s1s[0], s2s[0]\n\n    # 再試試兩行輸入\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    if len(lines) >= 2:\n        return lines[0], lines[1]\n\n    # 最後試試逗號或空白分隔的字串\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n\n    # 如果還沒能解析，回傳空字串\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s1, s2 = parse_input(data)\n    sol = Solution()\n    result = sol.isScramble(s1, s2)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"great\", s2 = \"rgeat\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s1 = \"abcde\", s2 = \"caebd\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s1 = \"a\", s2 = \"a\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode34.json",
    "problem_index_in_file": 0,
    "title": "Find First and Last Position of Element in Sorted Array",
    "description_snippet": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending positio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for searching target in sorted array with binary search to find leftmost and rightmost indices. Must be O(log n). Provide step-by-step virtual code with explanation. Use arrow notation. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". Use Start, End, Decision: with Yes → No →. Provide lines like:\n\nStart // 程式開始\n\n→ Step 1: 初始化 low=0, high=nums.length-1 // 設定搜尋範圍\n\n→ Step 2: 定義函式 findBound(isFirst) // 用於尋找左邊界或右邊界\n\nThen we might write the pseudocode for findBound.\n\nBut maybe keep in linear lines:\n\n→ Decision: target exists? Actually we need to find bounds.\n\nSimplify: Use two binary searches: first to find leftmost, second to find rightmost.\n\nPseudo:\n\nStart // 程式開始\n→ Step 1: low=0; high=nums.length-1; // 初始化搜尋範圍\n→ Step 2: left= -1; // 左邊界初始為未找到\n→ Step 3: right= -1; // 右邊界初始為未找到\n→ Step 4: // 搜尋左邊界\n→ Decision: low <= high? // 只要範圍合法\n   Yes → while loop for leftmost:\n      mid=(low+high)/2\n      if nums[mid]==target:\n         left=mid; high=mid-1; // 仍在左側搜尋\n      else if nums[mid] < target:\n         low=mid+1\n      else:\n         high=mid-1\n   No → // end loop\n→ Step 5: // 搜尋右邊界\n→ Reset low=0; high=nums.length-1; // 重置搜尋範圍\n→ Decision: low <= high?\n   Yes → while loop for rightmost:\n      mid=(low+high)/2\n      if nums[mid]==target:\n         right=mid; low=mid+1; // 仍在右側搜尋\n      else if nums[mid] < target:\n         low=mid+1\n      else:\n         high=mid-1\n   No → // end loop\n→ Decision: left == -1? // 判斷是否找到\n   Yes → Step 6: return [-1, -1] // 未找到\n   No → Step 7: return [left, right] // 返回範圍\nEnd\n\nBut they ask \"逐行的虛擬碼\" each line with explanation. Use arrow notation like \"→ Step\". Also \"Decision:\" lines. Ensure each line ends with // explanation. Use Chinese.\n\nWe might use while loops but we can express with Decision loops. Eg:\n\nDecision: low <= high? Yes → ... No → ...\n\nWithin loop, we may have nested Decision for mid comparisons.\n\nWe need to keep each line separate: Step 1, Step 2, etc.\n\nMake sure to avoid actual code like while loops but can express as Decision: condition? Yes → ... No → ... representing loop end.\n\nBut we must include Start and End.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 0; high ← nums.length – 1; // 設定二分搜尋的左右邊界  \n→ Step 2: left ← –1; right ← –1; // 左右邊界初始值，表示尚未找到  \n→ Step 3: // 搜尋左邊界（最小索引）  \n    Decision: low ≤ high? // 是否還有搜尋範圍  \n        Yes → Step 4: mid ← (low + high) / 2; // 取中點索引  \n        → Decision: nums[mid] == target? // 中點是否為目標  \n            Yes → Step 5: left ← mid; high ← mid – 1; // 記錄左邊界，繼續往左搜尋  \n            No → Decision: nums[mid] < target? // 中點小於目標  \n                Yes → Step 6: low ← mid + 1; // 目標在右半區  \n                No  → Step 7: high ← mid – 1; // 目標在左半區  \n        No → // loop 之終止條件，回到 Decision: low ≤ high?  \n    No  → // 左邊界搜尋結束  \n→ Step 8: // 搜尋右邊界（最大索引）  \n    Reset: low ← 0; high ← nums.length – 1; // 重新設定搜尋範圍  \n    Decision: low ≤ high? // 是否還有搜尋範圍  \n        Yes → Step 9: mid ← (low + high) / 2; // 取中點索引  \n        → Decision: nums[mid] == target? // 中點是否為目標  \n            Yes → Step 10: right ← mid; low ← mid + 1; // 記錄右邊界，繼續往右搜尋  \n            No → Decision: nums[mid] < target? // 中點小於目標  \n                Yes → Step 11: low ← mid + 1; // 目標在右半區  \n                No  → Step 12: high ← mid – 1; // 目標在左半區  \n        No → // loop 之終止條件，回到 Decision: low ≤ high?  \n    No  → // 右邊界搜尋結束  \n→ Decision: left == –1? // 判斷是否找到目標  \n    Yes → Step 13: return [–1, –1]; // 未找到，返回預設值  \n    No  → Step 14: return [left, right]; // 返回最小與最大索引  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        使用二分搜尋找出目標值的左邊界和右邊界。\n        \"\"\"\n        def findLeft(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        def findRight(nums, target):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n                if nums[mid] == target:\n                    index = mid\n            return index\n\n        return [findLeft(nums, target), findRight(nums, target)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[-1,-1]\")\n        sys.exit(0)\n\n    # 從輸入字串中解析 nums 與 target\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*([-]?\\d+)', data)\n\n    nums = ast.literal_eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else 0\n\n    sol = Solution()\n    result = sol.searchRange(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,7,7,8,8,10], target = 8",
          "expected_output": "[3,4]",
          "success": true,
          "output": "[3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [5,7,7,8,8,10], target = 6",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        },
        {
          "example_index": 2,
          "input": "nums = [], target = 0",
          "expected_output": "[-1,-1]",
          "success": true,
          "output": "[-1, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1.json",
    "problem_index_in_file": 0,
    "title": "Two Sum",
    "description_snippet": "Given an array of integers nums and an integer target, return indices of the two numbers such that t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step with explanation. Format: \"虛擬碼步驟 // 解釋\" Each line has \"Start\", \"End\", \"Decision:\", \"Step:\". Use arrow \"→\". Use Yes→ and No→ for decisions. Provide virtual code for two-sum problem. No actual code. Just pseudocode steps.\n\nWe need to adhere to format. Provide start line, then each step. Provide decision for checking target. Also we need to maintain that each element not used twice. Use hash map to store number->index. We'll iterate through array.\n\nLet's craft lines:\n\nStart\n→ Step 1: 建立空字典 hashMap // 用來存放數值到索引的映射\n→ Step 2: 從 0 到 length-1 迴圈遍歷 nums // 遍歷陣列中的每個元素\n    → Step 3: 計算 complement = target - nums[i] // 目標減去當前元素\n    → Decision: 是否已在 hashMap? // 檢查 complement 是否已經存在\n        Yes → Step 4: 回傳 [hashMap[complement], i] // 找到答案即結束\n        No  → Step 5: 把 nums[i] 與索引 i 存入 hashMap // 加入未找到的元素\n→ End // 若循環結束仍未找到，理論上不會發生\n\nAdd explanations.\n\nMake sure each line contains \"虛擬碼步驟\" followed by space then \" // 解釋\". So format: \"Start // 程式開始執行\". Use arrow for steps: \"→ Step 1: ...\" So each line with arrow? In example they used \"→ Step 1: 輸入使用者數字\". So we need same.\n\nLet's write.\n\nAlso we should include decision structure: \"Decision:\" lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 hashMap // 用來儲存已遇到的數字與其索引  \n→ Step 2: 從 0 到 nums.length-1 迴圈遍歷 nums // 逐一檢查每個元素  \n → Step 3: 計算 complement = target - nums[i] // 目標值減去目前數字得到補數  \n → Decision: 是否已在 hashMap? // 檢查補數是否已經出現過  \n  Yes → Step 4: 回傳 [hashMap[complement], i] // 找到符合條件的兩個索引即結束程式  \n  No  → Step 5: 把 nums[i] 與索引 i 存入 hashMap // 將目前數字加入查找表  \nEnd // 程式執行結束（若理論上有解，迴圈必會回傳結果）",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"Return indices of the two numbers that add up to target.\"\"\"\n        seen = {}\n        for i, val in enumerate(nums):\n            comp = target - val\n            if comp in seen:\n                return [seen[comp], i]\n            seen[val] = i\n        # As per problem statement, a solution always exists.\n        return []\n\ndef parse_input(data: str):\n    \"\"\"Parse input of the form 'nums = [...], target = X'.\"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*([-]?\\d+)', data)\n    if not nums_match or not target_match:\n        raise ValueError(\"Input format is incorrect.\")\n    nums = ast.literal_eval(nums_match.group(1))\n    target = int(target_match.group(1))\n    return nums, target\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n    result = Solution().twoSum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode354.json",
    "problem_index_in_file": 0,
    "title": "Russian Doll Envelopes",
    "description_snippet": "You are given a 2D array of integers envelopes where envelopes[i] = [w_i, h_i] represents the width ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode steps line by line with explanation comments. We need to follow output format with Start, arrow, Decision, etc. The task: given 2D array envelopes, compute maximum number of envelopes that can be nested (Russian doll). Classic solution: sort by width ascending, height descending for equal width, then LIS on heights.\n\nWe must produce virtual code with lines like:\n\nStart // 程式開始執行\n→ Step 1: Input envelopes // 取得輸入\n→ Step 2: Sort envelopes by width asc, height desc // 排序\n→ Step 3: Initialize empty list tails // 用於 LIS\n→ Step 4: For each envelope in sorted list: // 迴圈\n    → Step 5: height = envelope.height // 取得高度\n    → Decision: 是否存在 tails[i] < height? // ...\n    etc.\n\nSimplify: Use binary search to find position to insert.\n\nBetter produce concise steps, but still clear.\n\nWe'll produce lines: each step as a line with arrow. For decisions, we show Yes → or No →.\n\nWe'll not use actual code; use pseudo names: \"SortEnvelopes(envelopes)\", \"FindPosition(tails, height)\", etc.\n\nWe need to keep each line with the format: 虛擬碼步驟 + ' // ' + 解釋.\n\nLet's produce around 15-20 lines.\n\nLet's do:\n\nStart // 程式開始執行\n→ Step 1: Input envelopes // 取得 2D 整數陣列\n→ Step 2: Sort envelopes by width ascending, and for equal width by height descending // 以便 LIS 正確\n→ Step 3: Initialize empty list tails // 存放 LIS 的尾部高度\n→ Step 4: For each envelope in sorted envelopes: // 逐一處理\n    → Step 5: h ← envelope.height // 取得高度\n    → Decision: 是否存在 tails 中第一個 >= h? // 判斷是否可替換\n        Yes → Replace that tails element with h // 用較小高度取代\n        No  → Append h to tails // 形成更長序列\n→ Step 6: length ← size of tails // 最長可嵌套數量\n→ End // 程式結束，返回長度\n\nBut we need \"Return\" step: maybe Step 7: Output length // 回傳結果.\n\nLet's format correctly.\n\nAlso we must include \"Decision:\" lines indent. Use spaces indentation maybe 4 spaces? Format not strict but we show indentation. We'll include arrow for decision.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Input envelopes // 取得輸入數組\n→ Step 2: Sort envelopes by (width asc, height desc) // 方便後續 LIS\n→ Step 3: tails ← empty list // 用於儲存 LIS 尾部高度\n→ Step 4: For each envelope in envelopes: // 逐個處理\n    → Step 5: h ← envelope.height // 取得高度\n    → Decision: 是否存在 tails[i] ≥ h? // 判斷是否需要替換\n        Yes → tails[i] ← h // 用較小高度替換\n        No  → Append h to tails // 形成更長序列\n→ Step 6: maxCount ← length of tails // 最大可嵌套數量\n→ Step 7: Return maxCount // 結果輸出\nEnd // 程式執行結束\n\nBut we might also explain binary search; but we can mention \"找到第一個 >= h\" using binary search.\n\nAdd Step 5.1: pos ← BinarySearch(tails, h) // find first >= h\n\nThen Decision accordingly.\n\nLet's refine:\n\nStep 5: h ← envelope.height // 取得高度\n→ Step 5.1: pos ← BinarySearch(tails, h) // 找到第一個 >= h 的索引\n→ Decision: pos < size of tails? // 是否存在\n   Yes → tails[pos] ← h // 替換\n   No  → Append h to tails // 添加\n\nThus maintain LIS.\n\nLet's produce final pseudocode.\n\nRemember to maintain format: each line with virtual code step and comment.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Input envelopes // 取得輸入的 2D 整數陣列\n→ Step 2: Sort envelopes by (width asc, height desc) // 先按寬度升序，寬度相同則按高度降序\n→ Step 3: tails ← empty list // 用來存放 LIS 的尾部高度\n→ Step 4: For each envelope in envelopes: // 逐個處理每個信封\n    → Step 5: h ← envelope.height // 取得此信封的高度\n    → Step 5.1: pos ← BinarySearch(tails, h) // 找到 tails 中第一個 ≥ h 的索引\n    → Decision: pos < size of tails? // 判斷是否存在這樣的索引\n        Yes → tails[pos] ← h // 替換成較小高度，保持 LIS\n        No  → Append h to tails // 沒有可替換的，直接擴展 LIS\n→ Step 6: maxCount ← length of tails // 最長可嵌套數量即 tails 的長度\n→ Step 7: Return maxCount // 回傳結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\nimport bisect\n\ndef max_envelopes(envelopes):\n    \"\"\"Return the maximum number of envelopes that can be nested.\"\"\"\n    if not envelopes:\n        return 0\n    # Sort by width ascending; if equal width, by height descending\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = []  # dp[i] = smallest possible tail height of an increasing subsequence of length i+1\n    for _, h in envelopes:\n        idx = bisect.bisect_left(dp, h)\n        if idx == len(dp):\n            dp.append(h)\n        else:\n            dp[idx] = h\n    return len(dp)\n\ndef parse_input(data):\n    \"\"\"Parse input that may be in the form 'envelopes = [[...]]' or just a list.\"\"\"\n    data = data.strip()\n    if '=' in data:\n        _, right = data.split('=', 1)\n        data = right.strip()\n    # Use ast.literal_eval for safe evaluation\n    return ast.literal_eval(data)\n\ndef main():\n    raw = sys.stdin.read()\n    envelopes = parse_input(raw)\n    result = max_envelopes(envelopes)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "envelopes = [[5,4],[6,4],[6,7],[2,3]]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "envelopes = [[1,1],[1,1],[1,1]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode233.json",
    "problem_index_in_file": 0,
    "title": "Number of Digit One",
    "description_snippet": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of digit 1 appearing in all non-negative integers <= n. Provide step-by-step pseudocode with explanations. Format must be each line with virtual code step and comment after space.\n\nWe need to include Start, End, Decision etc. Provide loops and calculations. Let's design algorithm: Count ones digit using digit DP or mathematical approach: For each position (units, tens, etc), count number of times 1 appears at that position.\n\nPseudo: For i=1; i<=n; i*=10; then high = n / (i*10); cur = (n / i) %10; low = n % i. Then count += high * i; if cur==1: count += low+1; elif cur>1: count += i; Continue.\n\nSo produce virtual code lines.\n\nWe need \"逐行\" produce each line: Start, Step, Decision etc. We'll need to show loops and decisions. Provide pseudocode lines such as:\n\nStart // program begins\n\n→ Step 1: Read integer n // get input\n\n→ Step 2: Initialize count = 0, i = 1 // counter and position multiplier\n\n→ Decision: while i <= n? // loop over each digit position\n\n    Yes → Step 3: high = n / (i * 10) // digits left of current position\n\n    → Step 4: cur = (n / i) % 10 // current digit\n\n    → Step 5: low = n % i // digits right of current position\n\n    → Step 6: count += high * i // each full cycle adds high * i ones\n\n    → Decision: if cur == 1? // check current digit\n\n        Yes → Step 7: count += low + 1 // current position contributes low+1 ones\n\n        No → Decision: if cur > 1? // current digit >1\n\n            Yes → Step 8: count += i // full i ones added\n\n            No → Step 9: // do nothing if cur == 0\n\n    → Step 10: i *= 10 // move to next higher digit\n\n    No → Step 11: Output count // finished counting\n\nEnd // program ends\n\nNeed to ensure each line uses \"→\" and indentation maybe. The example uses indent for decisions. We'll follow similar.\n\nWe must not output actual code. Just virtual steps.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer n // 取得輸入的非負整數 n  \n→ Step 2: Initialize count = 0, i = 1 // count 為 1 的總個數，i 為目前檢查的位數（1、10、100…）  \n→ Decision: while i <= n? // 只要還有位數未檢查就進行迴圈  \n    Yes → Step 3: high = n / (i * 10) // 取出目前位數左邊的高位數字  \n    → Step 4: cur = (n / i) % 10 // 取出目前位數的數字  \n    → Step 5: low = n % i // 取出目前位數右邊的低位數字  \n    → Step 6: count += high * i // 每完整一個十位循環，該位會出現 high 次 1  \n    → Decision: if cur == 1? // 檢查目前位數是否為 1  \n        Yes → Step 7: count += low + 1 // 目前位數為 1 時，低位數字 + 1 次 1  \n        No → Decision: if cur > 1? // 目前位數大於 1 時  \n            Yes → Step 8: count += i // 目前位數大於 1，整個 i 次 1  \n            No → Step 9: // 目前位數為 0，無額外加 1  \n    → Step 10: i *= 10 // 移至下一個更高位數  \n    No → Step 11: Output count // 迴圈結束，輸出 1 的總個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_digit_one(n: int) -> int:\n    \"\"\"\n    計算從 0 到 n（包含 n）所有非負整數中，數位 1 的總出現次數。\n    \"\"\"\n    if n <= 0:\n        return 0\n\n    count = 0\n    i = 1  # 目前位數 1、10、100...\n\n    while i <= n:\n        divider = i * 10\n        high = n // divider           # 高位數字\n        cur = (n // i) % 10           # 目前位數\n        low = n % i                   # 低位數字\n\n        count += high * i             # 每完整循環對此位出現 high 次 1\n        if cur == 1:\n            count += low + 1          # 目前位數為 1 時，額外計算 low + 1 次 1\n        elif cur > 1:\n            count += i                # 目前位數大於 1 時，整個 i 次 1\n\n        i *= 10\n\n    return count\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data.strip():\n        sys.exit()\n\n    # 從輸入字串中擷取第一個整數（可能包含前綴 \"n = \"）\n    match = re.search(r\"-?\\d+\", data)\n    if not match:\n        sys.exit()\n\n    n_value = int(match.group())\n    result = count_digit_one(n_value)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode299.json",
    "problem_index_in_file": 0,
    "title": "Bulls and Cows",
    "description_snippet": "You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask yo...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step explaining Bulls and Cows algorithm. Steps: iterate characters, count bulls, track remaining digits count for secret and guess. Then count cows by min of counts. Provide virtual code lines with explanation. Ensure format: \"虛擬碼步驟 // 解釋\". Use arrow notation. Provide Start, End. Use Decision etc. Provide step numbers maybe. Use bullet? But each line must be one line. Let's produce:\n\nStart\n→ Step 1: 初始化 bulls = 0, cows = 0\n→ Step 2: 建立兩個大小為 10 的陣列 secretCount 和 guessCount 用於統計非 bull 的數字\n→ Decision: 迭代每個索引 i from 0 to len(secret)-1\n    → Step 3: 如果 secret[i] == guess[i]，bulls++，否則\n        → Step 4: secretCount[secret[i]]++，guessCount[guess[i]]++\n→ Step 5: 迭代數字 0-9\n    → Step 6: cows += min(secretCount[d], guessCount[d])\n→ Step 7: 返回字串 \"{bulls}A{cows}B\"\nEnd\n\nBut we need each line as one line. The decision and branches may need to be flattened. Use indentation? The example uses indent. We can use same style: indent with 4 spaces. Provide arrow and steps. Use arrows for decisions.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 bulls = 0, cows = 0 // 設定牛與奶的初始計數\n→ Step 2: 建立兩個長度為 10 的整數陣列 secretCount, guessCount // 用於統計非牛的數字頻率\n→ Decision: 迭代每個索引 i 從 0 到 secret.length-1? // 檢查每個位置是否為牛\n    Yes → Step 3: 如果 secret[i] == guess[i]，則 bulls++ // 找到牛，計數增加\n    No  → Step 4: 否則 secretCount[secret[i]]++，guessCount[guess[i]]++ // 將非牛的數字加入頻率表\n→ Step 5: 迭代數字 d 從 0 到 9 // 計算奶的數量\n→ Step 6: cows += min(secretCount[d], guessCount[d]) // 每個數字的奶數為兩個頻率表的最小值\n→ Step 7: 返回字串 \"{bulls}A{cows}B\" // 組合成輸出格式\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        # 先計算牛的數量，同時為非牛的位元建立頻率表\n        bulls = 0\n        secret_count = Counter()\n        guess_count = Counter()\n        for s, g in zip(secret, guess):\n            if s == g:\n                bulls += 1\n            else:\n                secret_count[s] += 1\n                guess_count[g] += 1\n        # 再計算奶的數量：每個數字對應的最小出現次數\n        cows = sum(min(secret_count[d], guess_count[d]) for d in guess_count)\n        return f\"{bulls}A{cows}B\"\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 從輸入中擷取兩個被雙引號包圍的字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) < 2:\n        return\n    secret, guess = matches[0], matches[1]\n    sol = Solution()\n    result = sol.getHint(secret, guess)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "secret = \"1807\", guess = \"7810\"",
          "expected_output": "\"1A3B\"",
          "success": true,
          "output": "1A3B"
        },
        {
          "example_index": 1,
          "input": "secret = \"1123\", guess = \"0111\"",
          "expected_output": "\"1A1B\"",
          "success": true,
          "output": "1A1B"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode486.json",
    "problem_index_in_file": 0,
    "title": "Predict the Winner",
    "description_snippet": "You are given an integer array nums. Two players are playing a game with this array: player 1 and pl...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with comments explaining each. Need to solve problem: Determine if player1 can win or tie in optimal play. Standard DP: DP[i][j] = max score difference player1 can achieve over player2 from subarray i..j. Recurrence: dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]). Then if dp[0][n-1] >=0 return true.\n\nWe need to produce virtual code step by step. Outline: Start, input array, compute n, initialize dp, fill DP for length 1..n, compute answer, return.\n\nWe must use arrows and Decision etc. Provide explanation after each line.\n\nLet's produce:\n\nStart // Start\n→ Input: nums // 接收輸入數列\n→ Set n = length(nums) // 計算長度\n→ Declare 2D array dp[n][n] // DP表\n→ For i from 0 to n-1:\n    → dp[i][i] = nums[i] // 單一元素情況\n→ For len from 2 to n:\n    → For i from 0 to n-len:\n        → j = i + len - 1 // 結尾索引\n        → Decision: If nums[i] - dp[i+1][j] > nums[j] - dp[i][j-1] ?\n            Yes → dp[i][j] = nums[i] - dp[i+1][j] // 選擇左邊\n            No  → dp[i][j] = nums[j] - dp[i][j-1] // 選擇右邊\n→ After DP, diff = dp[0][n-1] // 差值\n→ Decision: If diff >= 0 ?\n    Yes → Return true // Player1 wins or ties\n    No  → Return false // Player2 wins\n\nWe should format with arrows and decisions properly.\n\nEnsure each line: \"Start // ...\" etc. Use arrows \"→\" and \"Decision:\".\n\nAdd End.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums // 接收整數陣列輸入  \n→ Set n = length(nums) // 獲取陣列長度  \n→ Declare 2D array dp[n][n] // 建立 DP 表，用於儲存分數差  \n→ For i from 0 to n-1: // 初始化單元素子陣列  \n → dp[i][i] = nums[i] // 只剩一個數，分數差即為該數  \n→ For len from 2 to n: // 從長度 2 開始遞增填表  \n → For i from 0 to n-len: // 確定子陣列起點  \n  → j = i + len - 1 // 計算子陣列終點索引  \n  → Decision: If nums[i] - dp[i+1][j] > nums[j] - dp[i][j-1]? // 比較選擇左或右的分數差  \n   Yes → dp[i][j] = nums[i] - dp[i+1][j] // 取左端數字，對手最優回應  \n   No  → dp[i][j] = nums[j] - dp[i][j-1] // 取右端數字，對手最優回應  \n→ diff = dp[0][n-1] // 取得整個陣列下，玩家1與玩家2的分數差  \n→ Decision: If diff >= 0? // 檢查玩家1是否至少與玩家2平手  \n  Yes → Return true // 玩家1勝或平手，符合題意  \n  No  → Return false // 玩家2勝  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def predictTheWinner(self, nums):\n        n = len(nums)\n        # dp[i][j] 表示從 i 到 j 的區間內先手能比後手多贏多少分\n        dp = [[0] * n for _ in range(n)]\n\n        for i in range(n):\n            dp[i][i] = nums[i]\n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                dp[i][j] = max(nums[i] - dp[i + 1][j],\n                               nums[j] - dp[i][j - 1])\n\n        return dp[0][n - 1] >= 0\n\ndef main():\n    # 從標準輸入讀取整個內容\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 若輸入形如 \"nums = [1,5,2]\"，去掉前綴\n    if raw_input.startswith(\"nums\"):\n        parts = raw_input.split(\"=\", 1)\n        if len(parts) == 2:\n            raw_input = parts[1].strip()\n\n    # 解析數列\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception:\n        # 如果解析失敗，直接返回\n        return\n\n    sol = Solution()\n    result = sol.predictTheWinner(nums)\n    # 按題目要求輸出小寫的 true/false\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,2]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,233,7]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode338.json",
    "problem_index_in_file": 0,
    "title": "Counting Bits",
    "description_snippet": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. It's a classic problem: count number of 1 bits for each i up to n. We can do dynamic programming: ans[0] = 0, ans[i] = ans[i>>1] + (i&1). Use loop from 1 to n.\n\nWe need to output lines with virtual code step + comment.\n\nWe need to include Start, End, Decision, etc.\n\nWe need to be careful: we must not output actual code but virtual steps.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 n // 取得整數 n\n→ Step 2: 初始化 ans 陣列長度 n+1，填 0 // 用於儲存結果\n→ Step 3: ans[0] = 0 // 0 的二進位中 1 的個數為 0\n→ Decision: 是否已經處理完所有 i? // 檢查是否已處理到 n\n    Yes → End // 程式結束\n    No → Step 4: i = 1 // 從 1 開始計算\n→ Loop: 當 i <= n 時\n    → Step 5: 計算 ans[i] = ans[i >> 1] + (i & 1) // DP 公式\n    → Step 6: i = i + 1 // 移到下一個數字\n→ End // 程式結束\n\nBut we need \"逐行\" meaning each line is a step. We might want to show a decision to check loop condition. Perhaps structure:\n\nStart\n→ Step 1: 讀取輸入 n\n→ Step 2: 建立陣列 ans[0..n] 初始化為 0\n→ Step 3: ans[0] = 0\n→ Decision: i = 1 是否小於等於 n? // 初始化 i\n    Yes → Step 4: ans[1] = ans[1 >> 1] + (1 & 1)\n    No → End\n\nBut we need iterative loop.\n\nWe could use pseudocode with \"Loop:\".\n\nLet's design:\n\nStart\n→ Step 1: 讀取 n\n→ Step 2: 建立 ans[0..n] 初始化 0\n→ Step 3: ans[0] = 0\n→ Step 4: i = 1\n→ Decision: i <= n? \n    Yes → Step 5: ans[i] = ans[i >> 1] + (i & 1)\n        → Step 6: i = i + 1\n        → 回到 Decision\n    No  → End\n\nThat should produce the array ans. We need to ensure each line has virtual code step and comment. Provide arrow arrow.\n\nWe need to use arrow \"→\" for steps, and \"Decision:\" for decision points.\n\nMake sure each line has no code but virtual steps. So we should not include actual code syntax. For example \"Step 5: ans[i] = ans[i >> 1] + (i & 1)\" is okay as virtual code.\n\nOk.\n\nNow produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 n // 取得使用者給定的整數  \n→ Step 2: 建立陣列 ans[0..n]，所有元素初始化為 0 // 用來存放每個 i 的 1 位數  \n→ Step 3: ans[0] = 0 // 0 的二進位中 1 的個數是 0  \n→ Step 4: i = 1 // 設定從 1 開始計算  \n→ Decision: i <= n? // 判斷是否還有數字需要處理  \n  Yes → Step 5: ans[i] = ans[i >> 1] + (i & 1) // 使用 DP 公式計算第 i 個數的 1 位數  \n   → Step 6: i = i + 1 // 移至下一個數字  \n   → 回到 Decision // 重複判斷循環  \n  No  → End // 所有數字已處理完畢，結束程式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_bits(n: int) -> list[int]:\n    \"\"\"回傳 0~n 每個數字的 1 位數量。\"\"\"\n    res = [0] * (n + 1)\n    for i in range(1, n + 1):\n        # 使用 DP 公式：i 的 1 位數 = (i >> 1) 的 1 位數 + i 的最低位\n        res[i] = res[i >> 1] + (i & 1)\n    return res\n\ndef main() -> None:\n    # 讀取整個輸入，並尋找第一個整數 (支援 \"n = 2\" 或單純 \"2\" 等格式)\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    ans = count_bits(n)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,1]",
          "success": true,
          "output": "[0, 1, 1]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[0,1,1,2,1,2]",
          "success": true,
          "output": "[0, 1, 1, 2, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode846.json",
    "problem_index_in_file": 0,
    "title": "leetcode846_problem_1",
    "description_snippet": "Alice has some number of cards and she wants to rearrange the cards into groups so that each group i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: given hand array and groupSize, determine if can rearrange into groups of size groupSize, each group consecutive. Classic problem: sort hand, use frequency map, iterate sorted keys, use counts.\n\nWe produce pseudocode lines with explanations. Must use Start, End, Decision: etc. Use arrows. Provide line by line.\n\nWe need to produce step-by-step algorithm.\n\nLet’s outline:\n\nStart\n→ Step: Create a frequency map of card values\n→ Step: Sort unique card values\n→ Step: For each value in sorted unique:\n    Decision: If count(value) == 0? // Already used\n        Yes → continue\n        No → For i from 0 to groupSize-1:\n            If count(value + i) < count(value): return false\n            Decrease count(value + i) by count(value)\nAfter loop return true\nEnd\n\nAdd explanation comments.\n\nNeed to include arrow syntax.\n\nWe should use arrows \"→\". For decisions use indentation.\n\nMake sure each line ends with // 解釋.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立頻率表 freq 以統計每張牌的出現次數 // 先計算每張牌出現的數量  \n→ Step 2: 取 freq 的鍵並排序為 sortedKeys // 取得所有不同牌值並升冪排序，以便按順序處理  \n→ Decision: 迭代 sortedKeys 中每個 key // 循環處理每一個不同的牌值  \n    → Step 3: 如果 freq[key] == 0? // 檢查此牌值是否已被消耗完  \n        Yes → Continue to next key // 已用完，直接跳到下一個牌值  \n        No →  \n            → Step 4: 取 count = freq[key] // 這個牌值需要被拆分進多個組  \n            → Step 5: For i from 0 to groupSize - 1 // 檢查從 key 開始的連續 groupSize 張牌  \n                Decision: 是否存在 key + i 且 freq[key + i] >= count? // 是否有足夠數量的連續牌  \n                    Yes →  \n                        → Step 6: freq[key + i] -= count // 把這些牌從頻率表扣除  \n                    No →  \n                        → Step 7: Return false // 無法形成連續組，直接結束  \n→ Step 8: Return true // 所有牌都能成功分組成連續組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def isNStraightHand(self, hand, groupSize):\n        # 先檢查牌數是否能被 groupSize 整除\n        if len(hand) % groupSize != 0:\n            return False\n\n        # 統計每張牌的出現次數\n        count = Counter(hand)\n\n        # 依牌值升序排列，逐張檢查\n        for card in sorted(count):\n            freq = count[card]          # 這張牌需要被分到多少個組\n            if freq == 0:\n                continue                # 已被消耗完，跳過\n\n            # 檢查從 card 開始的連續 groupSize 張牌\n            for i in range(card, card + groupSize):\n                if count[i] < freq:     # 不足以形成連續組\n                    return False\n                count[i] -= freq        # 把這些牌從頻率表扣除\n\n        return True\n\ndef parse_input(raw_input: str):\n    \"\"\"\n    從輸入字串中提取 hand 與 groupSize。\n    支援形如 'hand = [1,2,3], groupSize = 3' 的格式。\n    \"\"\"\n    pattern = r'hand\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*groupSize\\s*=\\s*(\\d+)'\n    match = re.search(pattern, raw_input)\n    if not match:\n        raise ValueError(\"輸入格式不正確\")\n    hand_str, group_str = match.group(1), match.group(2)\n    hand = eval(hand_str)          # 轉換為 list\n    groupSize = int(group_str)\n    return hand, groupSize\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    hand, groupSize = parse_input(raw)\n\n    sol = Solution()\n    result = sol.isNStraightHand(hand, groupSize)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "hand = [1,2,3,4,5], groupSize = 4",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode88.json",
    "problem_index_in_file": 0,
    "title": "Merge Sorted Array",
    "description_snippet": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. Use Start, Decision, etc. Provide step-by-step algorithm for merging two sorted arrays into nums1 with placeholders. Use pointers from end. Ensure we produce line by line. Let's craft.\n\nWe'll start: Start. Then define indexes i = m-1, j = n-1, k = m+n-1. Then while i>=0 and j>=0: if nums1[i] > nums2[j] → nums1[k] = nums1[i]; i-- ; else → nums1[k] = nums2[j]; j-- ; k--. Then after loop, if j >= 0 → copy remaining from nums2 into nums1. If i>=0 no action needed because already in place.\n\nLet's produce lines accordingly. Each line \"虛擬碼步驟\" + // explanation.\n\nUse arrows for each step. Provide indent decisions.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set i = m - 1 // 指向 nums1 中最後一個有效元素  \n→ Set j = n - 1 // 指向 nums2 中最後一個元素  \n→ Set k = m + n - 1 // 指向 nums1 最後一個位置  \n\n→ Decision: i >= 0 AND j >= 0? // 是否兩個陣列都有未處理元素  \n Yes → Decision: nums1[i] > nums2[j]? // 比較兩個目前元素的大小  \n  Yes → Step: nums1[k] = nums1[i] // 把較大的 nums1[i] 放到最末位  \n   → Step: i = i - 1 // 移動 nums1 的指標  \n  No  → Step: nums1[k] = nums2[j] // 把較大的 nums2[j] 放到最末位  \n   → Step: j = j - 1 // 移動 nums2 的指標  \n  → Step: k = k - 1 // 移動合併指標  \n No  → End of merge loop  \n\n→ Decision: j >= 0? // 是否 nums2 還有剩餘元素  \n Yes → Step: nums1[k] = nums2[j] // 把剩餘 nums2[j] 依序放入 nums1  \n  → Step: j = j - 1  \n  → Step: k = k - 1  \n  → Repeat until j < 0  \n No  → // nums1 的剩餘元素已在正確位置，無需處理  \n\nEnd // 程式執行結束，nums1 已完成合併與排序",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i = m - 1          # 指向 nums1 的最後一個有效元素\n        j = n - 1          # 指向 nums2 的最後一個元素\n        k = m + n - 1      # 指向 nums1 的最後一個位置\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:      # 把 nums2 中剩下的元素複製過來\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n\ndef parse_input(s):\n    \"\"\"從輸入字串中提取變數值。\"\"\"\n    pattern = re.compile(r'(\\w+)\\s*=\\s*(\\[.*?\\]|-?\\d+)', re.DOTALL)\n    data = {}\n    for var, val in pattern.findall(s):\n        if val.strip().startswith('['):\n            data[var] = ast.literal_eval(val)   # 解析列表\n        else:\n            data[var] = int(val)                # 解析整數\n    return data\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    vars_dict = parse_input(raw)\n\n    nums1 = vars_dict.get('nums1')\n    m = vars_dict.get('m')\n    nums2 = vars_dict.get('nums2')\n    n = vars_dict.get('n')\n\n    sol = Solution()\n    sol.merge(nums1, m, nums2, n)\n\n    # 將結果以無空格的列表格式輸出\n    print('[' + ','.join(map(str, nums1)) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "expected_output": "[1,2,2,3,5,6]",
          "success": true,
          "output": "[1,2,2,3,5,6]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1], m = 1, nums2 = [], n = 0",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [0], m = 0, nums2 = [1], n = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1009.json",
    "problem_index_in_file": 0,
    "title": "Complement of Base 10 Integer",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We need to handle binary conversion, flipping bits. Approach: determine bit length, create mask with all 1s of that length, XOR with n to get complement. Steps: Start, get binary length by shifting until 0, build mask, compute complement = n XOR mask, return. Include decisions? Probably no decisions needed. Just linear flow.\n\nLet's craft:\n\nStart\n→ Step 1: 取得 n 的二進位位數 len // 计算位数\n→ Step 2: 初始化 mask = 0 // 用于存所有1\n→ Step 3: For i 0 to len-1: mask = mask << 1 | 1 // 构造位数为 len 的全1掩码\n→ Step 4: complement = n XOR mask // 位反转\n→ Step 5: 回傳 complement // 返回结果\nEnd\n\nAdd comments. Ensure each line ends with // 解釋/說明. Use arrow format. Use Start End. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 n 的二進位位數 len // 取得 n 的最高位位置，以確定掩碼長度  \n→ Step 2: 初始化 mask = 0 // 用於構造全1掩碼  \n→ Step 3: For i = 0 to len-1: mask = mask << 1 | 1 // 依位數逐步產生全1的掩碼  \n→ Step 4: complement = n XOR mask // 對 n 與全1掩碼做 XOR，得到位反轉結果  \n→ Step 5: 回傳 complement // 將計算出的補數回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        \"\"\"\n        Return the bitwise complement of a positive integer n.\n        Uses a mask of the same bit-length as n to flip all bits.\n        \"\"\"\n        if n == 0:\n            # Special case: 0 -> \"0\" binary, complement is \"1\" => 1\n            return 1\n        # Determine the number of bits needed to represent n\n        bit_length = n.bit_length()\n        # Create a mask with all bits set to 1 for that length\n        mask = (1 << bit_length) - 1\n        # XOR with mask flips all bits\n        return n ^ mask\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, extract the integer, compute its complement,\n    and print the result to stdout.\n    \"\"\"\n    data = sys.stdin.read()\n    # Find the first integer in the input (handles formats like \"n = 5\")\n    match = re.search(r'(-?\\d+)', data)\n    if not match:\n        raise ValueError(\"Input does not contain a valid integer.\")\n    n = int(match.group(1))\n\n    sol = Solution()\n    result = sol.bitwiseComplement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 10",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode128.json",
    "problem_index_in_file": 0,
    "title": "Longest Consecutive Sequence",
    "description_snippet": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps with explanations, using Start, End, Decision, etc. The user: \"Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time.\" This is the classic longest consecutive sequence problem, solved using a hash set for O(n) time.\n\nWe need to produce virtual code step-by-step: Input, build set, iterate each number, if num-1 not in set then start counting from num while num+1 in set, update longest. Provide lines with arrow. We need to use arrow '→' and decisions.\n\nWe must not output actual code. Just virtual code lines. Format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Provide Decision lines.\n\nLet's craft steps:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 numSet // 用於快速查找\n→ Step 2: 將 nums 中所有數字加入 numSet // O(n) 時間\n→ Step 3: 初始化 maxLen = 0 // 儲存最長連續序列長度\n→ Step 4: 對 numSet 中每個 num 執行以下\n    → Decision: 是否 num-1 在 numSet? // 判斷是否是序列開頭\n        No  → Step 5: 設定 currentNum = num // 從序列開頭開始\n             → Step 6: 設定 currentStreak = 1 // 初始長度\n             → Decision: 是否 currentNum+1 在 numSet? // 繼續尋找後續\n                 Yes → Step 7: currentNum = currentNum + 1\n                       currentStreak = currentStreak + 1\n                       回到 Decision: 是否 currentNum+1 在 numSet?\n                 No  → Step 8: maxLen = max(maxLen, currentStreak) // 更新最大長度\n             End // 結束內部循環\n        Yes  → Step 9: 跳過 // 不是序列開頭，已處理\n→ End // 程式結束\n\nBut we need to use arrow arrow format. Use \"Decision:\" lines with Yes →, No →.\n\nLet's craft more precise.\n\nWe should include loops. Use \"→ Decision:\" for loop. But better to represent loop as \"→ Decision: 是否 num-1 在 numSet?\" then branch. The No branch includes steps until we finish the sequence.\n\nMaybe better to structure like:\n\n→ Step 4: 對 numSet 中每個 num 進行\n    → Decision: num-1 是否存在於 numSet? // 只處理序列起點\n        No → Begin Sequence Process\n            → Step 5: currentNum = num\n            → Step 6: currentStreak = 1\n            → Decision: currentNum+1 是否存在於 numSet? // 連續判斷\n                Yes → Step 7: currentNum = currentNum + 1\n                      currentStreak = currentStreak + 1\n                      回到 Decision: currentNum+1 是否存在於 numSet?\n                No  → Step 8: maxLen = max(maxLen, currentStreak)\n            End // 內部判斷結束\n        Yes → Step 9: 跳過 // 不是序列起點\n→ End // 最終返回 maxLen\n\nBut we need to include return. Maybe step before End: \"→ Step 10: 返回 maxLen // 最終結果\".\n\nLet's produce final output.\n\nRemember to not include actual code, only virtual steps.\n\nUse arrow for each line: \"Start\", \"→\", \"Decision:\", \"Yes →\", \"No →\".\n\nWe should start with \"Start // 程式開始執行\". Then \"→ Step 1...\" etc.\n\nWe need to ensure each line has \"虛擬碼步驟 // 解釋\". We must include the explanation after //.\n\nMake sure to use Chinese characters and short explanation. Use \"虛擬碼\" but the requirement says each line must contain \"虛擬碼步驟\" + space + \"// 解釋\". So we just write the step, then comment.\n\nLet's write.\n\nAlso use \"Decision:\" lines with branches.\n\nWe need to include arrow \"→\" at start of each step line except Start/End.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 numSet // 用於快速查找元素  \n→ Step 2: 將 nums 中所有數字加入 numSet // O(n) 時間建構集合  \n→ Step 3: 初始化 maxLen = 0 // 儲存目前找到的最長連續序列長度  \n→ Step 4: 對 numSet 中每個 num 執行以下流程 // 逐一檢查每個數字  \n    → Decision: num-1 是否存在於 numSet? // 判斷是否為序列起點  \n        No  → Begin Sequence Process // 只有起點才處理序列  \n            → Step 5: 設定 currentNum = num // 從起點開始  \n            → Step 6: 設定 currentStreak = 1 // 初始長度為 1  \n            → Decision: currentNum+1 是否存在於 numSet? // 檢查後續是否連續  \n                Yes → Step 7: currentNum = currentNum + 1 // 移動到下一個數字  \n                      → Step 8: currentStreak = currentStreak + 1 // 長度加一  \n                      → Decision: currentNum+1 是否存在於 numSet? // 迴圈繼續  \n                No  → Step 9: maxLen = max(maxLen, currentStreak) // 更新最大長度  \n            End // 內部循環結束  \n        Yes  → Step 10: 跳過 // 不是序列起點，已由其起點處理  \n→ Step 11: 返回 maxLen // 輸出最長連續序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def longestConsecutive(self, nums):\n        if not nums:\n            return 0\n\n        num_set = set(nums)\n        longest = 0\n\n        for num in num_set:\n            if num - 1 not in num_set:\n                current_num = num\n                length = 1\n\n                while current_num + 1 in num_set:\n                    current_num += 1\n                    length += 1\n\n                longest = max(longest, length)\n\n        return longest\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    data = data.strip()\n    if not data:\n        nums = []\n    else:\n        if \"=\" in data:\n            nums_str = data.split(\"=\", 1)[1].strip()\n        else:\n            nums_str = data\n        # 用 ast.literal_eval 解析列表，安全且簡單\n        try:\n            nums = ast.literal_eval(nums_str)\n            if not isinstance(nums, list):\n                raise ValueError\n        except Exception:\n            # 若解析失敗，直接輸出 0\n            print(0)\n            sys.exit(0)\n\n    result = Solution().longestConsecutive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [100,4,200,1,3,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 2,
          "input": "nums = [1,0,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode56.json",
    "problem_index_in_file": 0,
    "title": "Merge Intervals",
    "description_snippet": "Given an array of intervals where intervals[i] = [start_i, end_i], merge all overlapping intervals, ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for merging overlapping intervals. Must output each line with virtual code and comment. Should use structure: Start, Decision, etc. Should be sequential.\n\nWe should not output actual code but pseudo-code steps. So produce lines like:\n\nStart // start\n→ Step 1: Sort intervals by start // sort\n→ Step 2: 初始化 merged list // etc\n\nWe need to produce virtual code step by step. Let's design:\n\n1. Start\n2. Sort intervals by start ascending\n3. Initialize merged = empty list\n4. For each interval in sorted intervals:\n   - If merged is empty OR current.start > last_merged.end: add interval\n   - else: merge by updating last_merged.end = max(last_merged.end, current.end)\n5. End and return merged\n\nWe need to use Decision structure where applicable. Use \"Decision:\" for checking empty or overlapping.\n\nLet's produce each line:\n\nStart // 程式開始\n→ Step 1: Sort intervals by ascending start // 先按起始點排序\n→ Step 2: 初始化 merged 為空列表 // 用於儲存合併後的區間\n→ Step 3: 依序處理排序後的每個區間 // 遍歷每個 interval\n    Decision: merged 為空？ // 判斷 merged 是否還沒加入任何區間\n        Yes → Step 4: 將 interval 加入 merged // 第一次加入\n        No  → Step 5: 取得 merged 中最後一個區間的結束值\n    Decision: interval.start > last_end？ // 判斷是否有重疊\n        Yes → Step 6: 將 interval 加入 merged // 無重疊，直接加入\n        No  → Step 7: 更新最後一個區間的結束值為 max(last_end, interval.end) // 合併\n→ End // 程式結束，返回 merged\n\nMake sure each line has \"虛擬碼步驟\" then space then comment. Use \"→\" arrow. Also include indentation maybe but not necessary. Use consistent formatting. Let's output lines exactly as required.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort intervals by ascending start // 先將所有區間依起始值升冪排序  \n→ Step 2: Initialize merged as empty list // 用於儲存合併後的非重疊區間  \n→ Step 3: Iterate over each interval in the sorted list // 逐一處理每個區間  \n    Decision: Is merged empty? // 判斷 merged 是否尚未加入任何區間  \n        Yes → Step 4: Add the current interval to merged // 第一次加入，直接存入  \n        No  → Step 5: Retrieve the end value of the last interval in merged // 取得已合併區間中的最後一個結束點  \n    Decision: Is current.start > last_end? // 判斷當前區間是否與已合併區間不重疊  \n        Yes → Step 6: Add the current interval to merged // 無重疊，直接加入  \n        No  → Step 7: Update last_end to max(last_end, current.end) // 有重疊，合併區間並更新結束點  \n→ End // 程式結束，merged 為合併後的區間列表，準備返回",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def merge(self, intervals):\n        \"\"\"合併重疊的區間，返回不重疊的區間列表。\"\"\"\n        if not intervals:\n            return []\n\n        # 先按起始點升序排序\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n\n        # 遍歷剩下的區間，合併或追加\n        for current in intervals[1:]:\n            prev = merged[-1]\n            if current[0] <= prev[1]:\n                # 有重疊，更新結束點為兩者較大者\n                prev[1] = max(prev[1], current[1])\n            else:\n                # 無重疊，直接加入\n                merged.append(current)\n        return merged\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如: \"intervals = [[1,3],[2,6],[8,10],[15,18]]\"\n    try:\n        _, value = data.split('=', 1)\n        intervals = ast.literal_eval(value.strip())\n    except Exception:\n        # 若格式不符合，直接使用空列表\n        intervals = []\n\n    sol = Solution()\n    result = sol.merge(intervals)\n\n    # 格式化輸出，去除空格以符合範例格式\n    out = str(result).replace(' ', '')\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "success": true,
          "output": "[[1,6],[8,10],[15,18]]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "success": true,
          "output": "[[1,5]]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[4,7],[1,4]]",
          "expected_output": "[[1,7]]",
          "success": true,
          "output": "[[1,7]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode395.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring with At Least K Repeating Characters",
    "description_snippet": "Given a string s and an integer k, return the length of the longest substring of s such that the fre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for problem: given string s, integer k, find length of longest substring where each char appears >= k. Classic \"Longest substring with at least K repeating characters\". Approach: divide and conquer or sliding window.\n\nWe need to produce virtual code steps with explanations. Should be line-by-line. Use Start, Decision, End. Include arrows. Provide explanation comments.\n\nWe can implement divide and conquer: recursively split by characters that occur < k globally. For each segment, compute longest.\n\nAlternatively sliding window: iterate over number of distinct characters (1..26). For each target distinct count, use sliding window to maintain counts, ensure each char count >= k. Keep max.\n\nI'll produce virtual code for divide and conquer.\n\nWe need to output virtual code steps with explanations.\n\nWe will need function longestSubstring(s, k): if s empty return 0. Count freq. Find split chars that occur < k. If none, return len(s). Else split by those chars. For each part, recursively compute. Return max.\n\nLet's produce step-by-step.\n\nUse recursion.\n\nOk produce:\n\nStart\n→ Step 1: 定義函式 longestSubstring(s, k) // 主入口\n→ Decision: 如果 s 為空? // 檢查字串是否為空\n    Yes → Step 2: 回傳 0 // 空字串長度為 0\n    No  →\n→ Step 3: 計算 s 中每個字元的頻率 // 建立頻率表\n→ Step 4: 建立分隔字元清單 badChars // 頻率 < k 的字元\n→ Decision: 如果 badChars 為空? // 全部字元頻率 >= k\n    Yes → Step 5: 回傳 len(s) // 整個字串符合條件\n    No  →\n→ Step 6: 用 badChars 將 s 斷開為子字串列表 parts // 以 badChars 為分隔符\n→ Step 7: 初始化 maxLen = 0 // 儲存最大長度\n→ Step 8: 對於每個 part in parts // 逐段處理\n        → Step 9: 呼叫 longestSubstring(part, k) // 递归\n        → Step 10: 更新 maxLen = max(maxLen, result) // 更新最大值\n→ Step 11: 回傳 maxLen // 返回最大子字串長度\nEnd\n\nNeed to add explanations.\n\nAlso maybe step for constructing parts: Use split operation.\n\nWe need to follow arrow format.\n\nWe should maintain line numbering? Not required.\n\nOk produce.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 longestSubstring(s, k) // 主入口，接受字串和整數 k\n→ Decision: 如果 s 為空? // 檢查是否已到遞迴終止條件\n    Yes → Step 2: 回傳 0 // 空字串無合法子字串，長度為 0\n    No  →\n→ Step 3: 計算 s 中每個字元的頻率 // 建立字元→次數的字典\n→ Step 4: 建立分隔字元清單 badChars // 將頻率 < k 的字元收集為 badChars\n→ Decision: 如果 badChars 為空? // 所有字元的頻率都 ≥ k\n    Yes → Step 5: 回傳 len(s) // 整個字串滿足條件，直接回傳長度\n    No  →\n→ Step 6: 用 badChars 將 s 斷開為子字串列表 parts // 以 badChars 作為分隔符切割字串\n→ Step 7: 初始化 maxLen = 0 // 用於記錄目前找到的最大合法子字串長度\n→ Step 8: 對於每個 part in parts // 逐段遞迴處理\n        → Step 9: 呼叫 longestSubstring(part, k) // 取得該段的最大合法長度\n        → Step 10: 更新 maxLen = max(maxLen, result) // 與目前最大值比較，取較大值\n→ Step 11: 回傳 maxLen // 返回整個字串中的最大合法子字串長度\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef longest_substring_with_k(s: str, k: int) -> int:\n    \"\"\"\n    回傳長度最大的子字串，使得子字串中每個字元出現次數都 >= k。\n    使用分治法：先找出在整個字串中頻率 < k 的字元，將字串以這些字元分割，\n    再遞迴處理每一段。若不存在這類字元，整個字串即為答案。\n    \"\"\"\n    if not s or k <= 0:\n        return 0\n    # 若整串長度不足 k，無法滿足條件\n    if len(s) < k:\n        return 0\n\n    freq = Counter(s)\n    # 找出頻率小於 k 的「分隔字元」\n    split_chars = {ch for ch, cnt in freq.items() if cnt < k}\n    if not split_chars:\n        # 全部字元頻率 >= k，整串即為合法子字串\n        return len(s)\n\n    max_len = 0\n    # 用分隔字元將字串切割，對每段遞迴\n    parts = re.split(f\"[{''.join(map(re.escape, split_chars))}]\", s)\n    for part in parts:\n        if part:  # 忽略空段\n            max_len = max(max_len, longest_substring_with_k(part, k))\n    return max_len\n\ndef parse_input() -> tuple[str, int]:\n    \"\"\"\n    解析標準輸入，支援下列三種格式：\n    1) s = \"abc\", k = 2\n    2) 第一行是字串，第二行是整數\n    3) 兩個值以空格分隔在同一行\n    \"\"\"\n    raw = sys.stdin.read().strip()\n    if not raw:\n        raise ValueError(\"No input provided\")\n\n    lines = raw.splitlines()\n\n    # 1) 形如 s = \"abc\", k = 2\n    if lines and re.search(r's\\s*=\\s*\".*\"', lines[0]):\n        s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', lines[0])\n        k_match = re.search(r'k\\s*=\\s*(\\d+)', lines[0])\n        if s_match and k_match:\n            s = s_match.group(1)\n            k = int(k_match.group(1))\n            return s, k\n\n    # 2) 兩行：字串、整數\n    if len(lines) >= 2:\n        s = lines[0].strip()\n        try:\n            k = int(lines[1].strip())\n            return s, k\n        except ValueError:\n            pass\n\n    # 3) 同行以空格分隔\n    parts = raw.split()\n    if len(parts) >= 2:\n        s = parts[0]\n        k = int(parts[1])\n        return s, k\n\n    raise ValueError(\"Input format not recognized\")\n\nif __name__ == \"__main__\":\n    try:\n        s, k = parse_input()\n        result = longest_substring_with_k(s, k)\n        print(result)\n    except Exception as e:\n        # 若輸入格式錯誤，印出錯誤訊息（可依需求調整）\n        print(f\"Error: {e}\", file=sys.stderr)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode231.json",
    "problem_index_in_file": 0,
    "title": "Power of Two",
    "description_snippet": "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with explanations line by line. The requirement: no actual code, just virtual steps. The user provided a requirement: Given an integer n, return true if it is a power of two else false. Use virtual code with arrows and decisions. Should handle negative numbers? Typically n > 0. So steps: Input n, check if n <= 0, return false; else loop dividing by 2 while n % 2 == 0; after loop, if n == 1 return true else false. Or use bit trick: n & (n-1)==0. But probably using loop. We'll produce simple algorithm.\n\nWe need Start, End. Provide decision steps. Provide explanation comments.\n\nLet's produce something like:\n\nStart\n→ Step 1: 接收整數 n // 取得輸入值\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 2: 回傳 false // 非正數不是 2 的次方\n    No  → Decision: n == 1? // 檢查是否已為 1\n        Yes → Step 3: 回傳 true // 1 為 2^0\n        No  → Step 4: 初始化 temp = n // 準備除以 2 的迴圈\n→ Decision: temp % 2 == 0? // 檢查是否能被 2 整除\n    Yes → Step 5: temp = temp / 2 // 除以 2 進行下一輪\n         → Decision: temp % 2 == 0? // 重新判斷\n              (repeat until no longer divisible)\n    No  → Step 6: 回傳 temp == 1? // 若最終剩 1 回 true\n           Yes → Step 7: 回傳 true\n           No  → Step 8: 回傳 false\nEnd\n\nBut we need proper structure. We can use while loop concept: Decision: temp % 2 == 0? If yes, divide and loop. So we can incorporate loop via decisions.\n\nBetter structure:\n\nStart\n→ Step 1: Input n\n→ Decision: n <= 0? // check non-positive\n    Yes → Step 2: Return false\n    No  → Step 3: temp = n\n→ Decision: temp == 1? // check if already 1\n    Yes → Step 4: Return true\n    No  → Step 5: While temp % 2 == 0\n        → Decision: temp % 2 == 0?\n            Yes → temp = temp / 2\n            No  → Step 6: Return temp == 1? // if 1 true else false\nEnd\n\nBut we need to format each line: \"虛擬碼步驟 // 解釋\". Provide arrow or decision.\n\nLet's produce final answer.\n\nEnsure each line has one step or decision. Use indentation? In sample, they used indentation for nested decisions. We'll mimic.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 從使用者取得輸入值\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 2: 回傳 false // 非正數不是 2 的次方\n    No  → Step 3: temp = n // 初始化工作變數\n→ Decision: temp == 1? // 1 為 2 的 0 次方\n    Yes → Step 4: 回傳 true // 直接回傳正確結果\n    No  → Decision: temp % 2 == 0? // 是否能被 2 整除\n        Yes → Step 5: temp = temp / 2 // 除以 2\n              → Decision: temp % 2 == 0? // 重複判斷\n                  Yes → temp = temp / 2\n                  No  → Step 6: 回傳 temp == 1? // 檢查最後是否為 1\n                        Yes → Step 7: 回傳 true\n                        No  → Step 8: 回傳 false\n        No  → Step 9: 回傳 false // 不能被 2 整除，直接否定\nEnd // 程式執行結束\n\nCheck each line: includes arrow or decision. But line 5: we need to include arrow after \"Yes → temp = temp / 2\". We used arrow. But we need to ensure each line is separate: each arrow line must be separate. So we must split the steps: After step 5, we need decision: temp % 2 == 0? Yes → temp = temp / 2 ... So the repeated loop should be clear.\n\nBetter: Represent loop explicitly:\n\n→ Decision: temp % 2 == 0? // 檢查能否除以 2\n    Yes → temp = temp / 2\n          → Decision: temp % 2 == 0? // 再次檢查\n              Yes → temp = temp / 2\n              No  → Step 6: 回傳 temp == 1? // 判斷是否剩 1\n                    Yes → Step 7: 回傳 true\n                    No  → Step 8: 回傳 false\n    No  → Step 9: 回傳 false // 不能除以 2，直接否定\n\nBut this only allows 2 iterations. But for powers of two up to n, we might need multiple divisions. We can emulate a while loop by using repeated decision but need a loop representation. In virtual code, we could use \"While temp % 2 == 0:\" but requirement is to use Decision with Yes/No arrows. But we could use Decision with Yes → ... No → ... and within Yes we can have a loop step. But we can approximate: \"Decision: temp % 2 == 0?\" with Yes path that goes to \"Step 5: temp = temp / 2\" and then back to Decision again. But we cannot show loops with arrows? In example, they didn't show loops; but we can represent using a decision that loops to earlier step using arrow maybe: \"Yes → temp = temp / 2 // then go back to Decision\". But we might need a \"Loop\" construct. We can create a \"Loop: temp > 1?\" or something.\n\nSimpler: Use bit trick: n & (n-1) == 0. But we might still need to check n>0. That is straightforward: Decision: n > 0? If yes, Decision: n & (n-1) == 0? Yes → return true No → return false. That uses only decisions. That may be easier.\n\nLet's produce that.\n\nSo algorithm:\n\nStart\n→ Step 1: Input n\n→ Decision: n <= 0? // check non-positive\n    Yes → Step 2: Return false\n    No  → Step 3: Compute n & (n-1) // bitwise trick\n→ Decision: result == 0? // if zero then power of two\n    Yes → Step 4: Return true\n    No  → Step 5: Return false\nEnd\n\nBut we need to show that \"Compute n & (n-1)\" and store in result. So step 3: result = n & (n-1). Then decision. Provide explanation.\n\nLet's produce final output accordingly.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 從使用者取得輸入值\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 2: 回傳 false // 非正數不是 2 的次方\n    No  → Step 3: result = n & (n - 1) // 計算 n 與 (n-1) 的位元與\n→ Decision: result == 0? // 位元與為 0 表示 n 為 2 的次方\n    Yes → Step 4: 回傳 true // 確定為 2 的次方\n    No  → Step 5: 回傳 false // 不是 2 的次方\nEnd // 程式執行結束\n\nThat's concise and meets requirements. Provide virtual code lines with arrows and decisions. Provide explanation after //.\n\nMake sure each line separate. Provide indentation for nested decisions. Use arrow for steps. Provide Yes/No arrows inside Decision block.\n\nLet's deliver.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收整數 n // 從使用者取得輸入值\n→ Decision: n <= 0? // 檢查是否為非正數\n    Yes → Step 2: 回傳 false // 非正數不是 2 的次方\n    No  → Step 3: result = n & (n - 1) // 計算 n 與 (n-1) 的位元與\n→ Decision: result == 0? // 位元與為 0 表示 n 為 2 的次方\n    Yes → Step 4: 回傳 true // 確定為 2 的次方\n    No  → Step 5: 回傳 false // 不是 2 的次方\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_power_of_two(n: int) -> bool:\n    \"\"\"Return True if n is a power of two, else False.\"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # 從輸入中提取第一個整數\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    result = is_power_of_two(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode455.json",
    "problem_index_in_file": 0,
    "title": "Assign Cookies",
    "description_snippet": "Assume you are an awesome parent and want to give your children some cookies. But, you should give e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with comments. The task is classic greedy: sort greed and sizes, then two-pointer to assign. Provide step-by-step. Output must be line by line, with \"虛擬碼步驟\" + \" // 解釋\". Use arrow notation. We need to produce virtual code only, no actual code. So something like:\n\nStart\n→ Step 1: Sort array g ascending // ...\n→ Step 2: Sort array s ascending // ...\n→ Step 3: Initialize i=0, j=0, count=0 // pointers and counter\n→ Decision: i < len(g) and j < len(s)?\n    Yes → Decision: s[j] >= g[i]?\n        Yes → Step: count++, i++, j++ // assign cookie\n        No  → Step: j++ // cookie too small, try next\n    No → End // one list exhausted\n\nOutput count at End? But we need to output maximum number. So maybe include a step to output count.\n\nWe need to output each line with the format: \"虛擬碼步驟 // 解釋\". Let's produce. Ensure use Start, End, Decision, arrow. Use \"Yes →\" \"No →\". Each line separate. Ensure no actual code. Provide comments in Chinese. Let's craft.\n\nAlso must include at end \"Output max count\". So a step before End: \"Step 4: 輸出 count // 顯示最大可滿足孩子數\".\n\nAlso include initial input reading step: \"Step 0: 讀取 g 與 s 陣列\". Provide as line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 讀取 g 與 s 陣列 // 從使用者處取得孩子的貪婪值與餅乾大小  \n→ Step 1: 將 g 陣列升序排序 // 方便使用貪婪分配  \n→ Step 2: 將 s 陣列升序排序 // 方便逐一比對  \n→ Step 3: 設定 i = 0, j = 0, count = 0 // i 指向孩子, j 指向餅乾, count 計數  \n→ Decision: i < len(g) 且 j < len(s)? // 仍有孩子與餅乾可嘗試  \n  Yes → Decision: s[j] >= g[i]? // 當前餅乾能滿足目前孩子  \n    Yes → Step 4: count++, i++, j++ // 分配餅乾給孩子並遞增指標  \n    No  → Step 5: j++ // 餅乾太小，嘗試下一顆  \n  No  → Step 6: 輸出 count // 已無可用餅乾或孩子，結束計算  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findContentChildren(self, g, s):\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i\n\ndef parse_list(text: str):\n    \"\"\"從字串中提取整數列表\"\"\"\n    nums = re.findall(r'-?\\d+', text)\n    return list(map(int, nums))\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    g_list = s_list = None\n\n    # 嘗試以 'g = [...]' 與 's = [...]' 的形式解析\n    g_match = re.search(r'g\\s*=\\s*\\[([^\\]]*)\\]', data)\n    s_match = re.search(r's\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if g_match and s_match:\n        g_list = parse_list(g_match.group(0))\n        s_list = parse_list(s_match.group(0))\n    else:\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            g_list = parse_list(lines[0])\n            s_list = parse_list(lines[1])\n        else:\n            # 單行輸入，按逗號分隔兩個列表\n            parts = data.split(',')\n            if len(parts) >= 2:\n                g_list = parse_list(parts[0])\n                s_list = parse_list(parts[1])\n            else:\n                # 只提供一個列表，假設另一個為空\n                g_list = parse_list(parts[0])\n                s_list = []\n\n    solution = Solution()\n    result = solution.findContentChildren(g_list, s_list)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "g = [1,2], s = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode155.json",
    "problem_index_in_file": 0,
    "title": "Min Stack",
    "description_snippet": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nI...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The requirement: virtual code not actual code. Use structure: Start, End, Decision, arrow, etc.\n\nWe need to design MinStack with O(1) push/pop/top/getMin. Standard approach: use two stacks: main stack and min stack. But we need to describe algorithm in pseudocode line by line.\n\nWe'll output step by step: initialize two stacks, push pushes onto both: push val onto main; if minStack empty or val <= minStack.top then push onto minStack; else maybe push the same min? Actually to maintain min we can push current min onto minStack for each push: minStack.push(val < minStack.top ? val : minStack.top). Then pop: pop from main and pop from minStack. top: return main.top. getMin: return minStack.top.\n\nOk produce virtual code.\n\nWe should ensure each line includes explanation. Use Start, End. Use Decision: if statements. Use arrow.\n\nLet's produce.\n\nWe'll show initialization: Step 1: Create two empty stacks.\n\nPush operation: Step 2: push val onto mainStack. Step 3: Decision: if minStack empty? Yes -> push val onto minStack else: Decision: if val < minStack.top? Yes -> push val onto minStack else -> push minStack.top onto minStack. That ensures minStack always contains current min at same index.\n\nPop: pop from mainStack and minStack.\n\nTop: return mainStack.top.\n\ngetMin: return minStack.top.\n\nWrap in class MinStack.\n\nNeed to show function definitions: We'll present high-level pseudocode.\n\nWe'll format lines: \"Step 1: ...\" etc.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 MinStack // 建立 MinStack 類別  \n→     Step 2: 宣告 mainStack 為空棧 // 儲存所有元素  \n→     Step 3: 宣告 minStack 為空棧 // 同時儲存目前的最小值  \n\n→ Step 4: Function push(val) // 推入新元素  \n→         → Step 5: mainStack.push(val) // 把 val 加進主棧  \n→         → Decision: minStack 為空? // 檢查 minStack 是否還沒元素  \n→             Yes → Step 6: minStack.push(val) // 空棧時，val 為最小值  \n→             No  → Decision: val < minStack.top()? // 與目前最小值比較  \n→                 Yes → Step 7: minStack.push(val) // 新值更小，成為最小值  \n→                 No  → Step 8: minStack.push(minStack.top()) // 仍保持舊最小值  \n\n→ Step 9: Function pop() // 移除頂部元素  \n→         → Decision: mainStack 為空? // 確保不會空棧操作  \n→             Yes → Step 10: Return // 若空棧則直接返回（或拋錯誤）  \n→             No  → Step 11: mainStack.pop() // 先移除主棧頂部  \n→             No  → Step 12: minStack.pop()  // 同時移除 minStack 對應項  \n\n→ Step 13: Function top() // 取得頂部元素  \n→         → Decision: mainStack 為空?  \n→             Yes → Step 14: Return null // 空棧時回傳 null（或拋錯誤）  \n→             No  → Step 15: Return mainStack.top() // 返回主棧頂部值  \n\n→ Step 16: Function getMin() // 取得目前最小值  \n→         → Decision: minStack 為空?  \n→             Yes → Step 17: Return null // 空棧時回傳 null（或拋錯誤）  \n→             No  → Step 18: Return minStack.top() // 返回 minStack 的頂部，即最小值  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self):\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        if self.min_stack and val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self):\n        if not self.stack:\n            return None\n        return self.stack[-1]\n\n    def getMin(self):\n        if not self.min_stack:\n            return None\n        return self.min_stack[-1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Wrap the input so that it becomes a JSON array of two elements.\n    # Example input: [\"MinStack\",\"push\"],[[],[1]]\n    # After wrapping: [[\"MinStack\",\"push\"],[[],[1]]]\n    ops_and_args = json.loads('[' + data + ']')\n    ops, args = ops_and_args[0], ops_and_args[1]\n\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MinStack\":\n            obj = MinStack()\n            result.append(None)\n        elif op == \"push\":\n            obj.push(arg[0])\n            result.append(None)\n        elif op == \"pop\":\n            obj.pop()\n            result.append(None)\n        elif op == \"top\":\n            result.append(obj.top())\n        elif op == \"getMin\":\n            result.append(obj.getMin())\n        else:\n            # Unknown operation; skip or raise error\n            result.append(None)\n\n    # Output the result list with JSON null for None\n    sys.stdout.write(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"],[[],[-2],[0],[-3],[],[],[],[]]",
          "expected_output": "[null,null,null,null,-3,null,0,-2]",
          "success": true,
          "output": "[null, null, null, null, -3, null, 0, -2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode12.json",
    "problem_index_in_file": 0,
    "title": "Integer to Roman",
    "description_snippet": "Seven different symbols represent Roman numerals with the following values:\n\nSymbol\tValue\nI\t1\nV\t5\nX\t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with arrow and explanation. Use Start, Decision etc. Should be clear.\n\nLet's produce algorithm:\n\nStart\n→ Step 1: define arrays of roman numerals and values in descending order (M=1000, CM=900, D=500, CD=400, C=100, XC=90, L=50, XL=40, X=10, IX=9, V=5, IV=4, I=1) // setup mapping\n→ Step 2: initialize result as empty string // will accumulate roman numeral\n→ Decision: If input <=0 or input>3999? // Roman numerals usually limited\n    Yes → Step 3: output error // invalid input\n    No  →\n→ Step 4: for each pair (value, symbol) in mapping // iterate through descending values\n    → Decision: while input >= value?\n        Yes → Step 5: append symbol to result // add roman numeral\n             → Step 6: subtract value from input // reduce remaining value\n             → Repeat while loop\n        No  → next pair // move to next smaller value\n→ Step 7: output result // final roman numeral\nEnd\n\nBut need to incorporate rules about consecutive symbols? The mapping already handles subtractive forms, so algorithm covers. Also rule about at most 3 repeats, but algorithm will only repeat for I, X, C, M up to 3 times; but we can rely on while loop.\n\nAdd explanation for each line.\n\nWe should format as:\n\nStart // 程式開始執行\n→ Step 1: 初始化符號和值的對照表，按從大到小的順序排列 // 用於後續的轉換\n→ Step 2: 建立空的結果字串 // 用來累積羅馬數字\n→ Decision: 是否輸入值不合法（<=0 或 >3999）? // 只處理 1~3999\n    Yes → Step 3: 輸出錯誤訊息 // 結束\n    No  →\n→ Step 4: 針對每一個 (value, symbol) 在對照表中 // 從最高位開始處理\n    → Decision: input >= value? // 能否用此符號\n        Yes → Step 5: 把 symbol 加到結果中 // 將對應符號加入\n             → Step 6: input -= value // 減去已處理的數值\n             → Repeat Step 5-6 // 仍大於同一個 value 時重複\n        No  → // 轉到下一個更小的 value\n→ Step 7: 輸出結果 // 完整的羅馬數字\nEnd // 程式結束\n\nBut we need to output each line separately with explanation.\n\nAlso need to include the loop explicitly: e.g.,\n\n→ Step 4: for each (value, symbol) in mapping\n    → Decision: while input >= value?\n        Yes → Step 5: result += symbol\n             → Step 6: input -= value\n        No → // loop ends, go to next mapping entry\n\nLet's produce final output.\n\nAlso we should mention that subtractive forms are included in mapping, so rule 2 handled.\n\nWe need to use \"→\" arrow for each step, and indentation for nested decision.\n\nLet's craft final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化符號和值的對照表，按從大到小的順序排列（M=1000, CM=900, D=500, CD=400, C=100, XC=90, L=50, XL=40, X=10, IX=9, V=5, IV=4, I=1） // 用於後續的轉換  \n→ Step 2: 建立空的結果字串 result // 用來累積羅馬數字  \n→ Decision: 輸入值是否不合法（<=0 或 >3999）? // 只處理 1~3999  \n    Yes → Step 3: 輸出錯誤訊息並結束 // 無效輸入  \n    No → // 繼續執行  \n→ Step 4: 針對對照表中的每個 (value, symbol) 從大到小遍歷  \n    → Decision: input >= value? // 能否使用此符號  \n        Yes → Step 5: 把 symbol 加到結果 result // 將符號加入  \n             → Step 6: input -= value // 減去已處理的數值  \n             → 重複 Step 5–6，直到 input < value  \n        No → // 結束此 while，轉到下一個更小的 value  \n→ Step 7: 輸出結果 result // 完整的羅馬數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass RomanConverter:\n    \"\"\"\n    將整數轉換為羅馬數字。\n    \"\"\"\n    # 值與對應符號，按從大到小排列\n    _values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    _symbols = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n\n    def int_to_roman(self, num: int) -> str:\n        \"\"\"\n        依據上述對照表將 num 轉成羅馬數字。\n\n        :param num: 需要轉換的正整數 (1-3999)\n        :return: 對應的羅馬數字字串\n        \"\"\"\n        roman = []\n        for value, symbol in zip(self._values, self._symbols):\n            count = num // value          # 這個符號可以使用多少次\n            if count:\n                roman.append(symbol * count)\n                num -= value * count\n        return ''.join(roman)\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析整數，輸出其羅馬數字表示。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中提取第一個數字\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    num = int(match.group())\n\n    converter = RomanConverter()\n    result = converter.int_to_roman(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 3749",
          "expected_output": "\"MMMDCCXLIX\"",
          "success": true,
          "output": "MMMDCCXLIX"
        },
        {
          "example_index": 1,
          "input": "num = 58",
          "expected_output": "\"LVIII\"",
          "success": true,
          "output": "LVIII"
        },
        {
          "example_index": 2,
          "input": "num = 1994",
          "expected_output": "\"MCMXCIV\"",
          "success": true,
          "output": "MCMXCIV"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode165.json",
    "problem_index_in_file": 0,
    "title": "Compare Version Numbers",
    "description_snippet": "Given two version strings, version1 and version2, compare them. A version string consists of revisio...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step with explanation, no actual code. So we will produce lines with steps. Use Start, End, Decision etc.\n\nWe need to handle string splits, compare integers.\n\nWill produce lines:\n\nStart\n\n→ Step 1: Split version1 by '.' into list rev1 // get revisions\n\n→ Step 2: Split version2 by '.' into list rev2\n\n→ Step 3: Determine maxLen = max(length of rev1, length of rev2) // to iterate all\n\n→ Step 4: For i from 0 to maxLen-1\n\n→ Decision: if i < len(rev1)? // has revision\n\n   Yes → val1 = integer of rev1[i] // convert\n\n   No  → val1 = 0\n\n→ Decision: if i < len(rev2)?\n\n   Yes → val2 = integer of rev2[i]\n\n   No  → val2 = 0\n\n→ Decision: if val1 < val2? return -1\n\n   Yes → Step end return -1\n\n   No → Decision: if val1 > val2? return 1\n\n      Yes → Step end return 1\n\n      No → continue loop\n\nAfter loop, return 0\n\nEnd\n\nNeed to keep \"虛擬碼步驟\" as line, then // explanation.\n\nAlso use \"→\" arrow. For loops, maybe use \"→ Loop: i in 0..maxLen-1\" etc.\n\nLet's craft each line accordingly.\n\nEnsure each line contains 虛擬碼步驟 then space then // explanation.\n\nUse \"Step\" or \"Decision\" etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Split version1 by '.' into list rev1 // 取得 version1 的各個修訂號  \n→ Step 2: Split version2 by '.' into list rev2 // 取得 version2 的各個修訂號  \n→ Step 3: Set maxLen = max(length of rev1, length of rev2) // 確定需要比較的最大修訂數  \n→ Loop i from 0 to maxLen-1 // 逐一比較每個修訂位置  \n  Decision: if i < length of rev1? // 判斷 version1 是否有此修訂  \n    Yes → Set val1 = integer conversion of rev1[i] // 取值並去除前導零  \n    No  → Set val1 = 0 // 缺少修訂視為 0  \n  Decision: if i < length of rev2? // 判斷 version2 是否有此修訂  \n    Yes → Set val2 = integer conversion of rev2[i] // 取值並去除前導零  \n    No  → Set val2 = 0 // 缺少修訂視為 0  \n  Decision: if val1 < val2? // 比較兩個修訂值  \n    Yes → Return -1 // version1 小於 version2  \n    No  → Decision: if val1 > val2?  \n      Yes → Return 1 // version1 大於 version2  \n      No  → Continue // 兩值相等，繼續比較下一個修訂  \n→ Step 4: Return 0 // 所有修訂都相等，版本相同  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        \"\"\"Compare two version strings according to the problem statement.\"\"\"\n        v1 = [int(part) for part in version1.split('.')]\n        v2 = [int(part) for part in version2.split('.')]\n        max_len = max(len(v1), len(v2))\n        for i in range(max_len):\n            num1 = v1[i] if i < len(v1) else 0\n            num2 = v2[i] if i < len(v2) else 0\n            if num1 < num2:\n                return -1\n            if num1 > num2:\n                return 1\n        return 0\n\ndef main():\n    data = sys.stdin.read()\n    # 將所有雙引號內的字串抽出，期望至少兩個\n    quotes = re.findall(r'\"([^\"]*)\"', data)\n    if len(quotes) >= 2:\n        version1, version2 = quotes[0], quotes[1]\n    else:\n        # 若未使用雙引號，嘗試以空白分割取得兩個版本字串\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            version1, version2 = parts[0], parts[1]\n        else:\n            # 無法取得版本字串，直接結束\n            return\n    sol = Solution()\n    result = sol.compareVersion(version1, version2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "version1 = \"1.2\", version2 = \"1.10\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "version1 = \"1.01\", version2 = \"1.001\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "version1 = \"1.0\", version2 = \"1.0.0.0\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode692.json",
    "problem_index_in_file": 0,
    "title": "Top K Frequent Words",
    "description_snippet": "Given an array of strings words and an integer k, return the k most frequent strings.\n\nReturn the an...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, no real code, steps. Requirements: array of strings words, int k, return k most frequent strings sorted by frequency descending, ties by lexicographic ascending. So we need count frequency, sort by freq desc, then lex asc, pick top k. We need to output virtual code step by step. Should use Start, End, Decision, arrows. We should include steps like Input words, k, Count frequencies, Create list of (word, count), sort, pick first k. Could include sorting logic. We need to describe each line.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 接收 words, k // 取得輸入\n\n→ Step 2: 建立空字典 freqMap // 用於記錄每個字的出現次數\n\n→ Step 3: 對 words 中每個 word 執行\n    → Step 3.1: 如果 word 在 freqMap 中則 freqMap[word] += 1\n    → Step 3.2: 否則 freqMap[word] = 1\n\n→ Step 4: 將 freqMap 轉成 list items = [(word, count)] // 方便排序\n\n→ Step 5: 對 items 進行排序\n    → Decision: 排序鍵為 (-count, word) // 先頻率降序，再字典序升序\n        Yes → Step 5.1: 使用 sorted(items, key=lambda x: (-x[1], x[0]))\n\n→ Step 6: 取前 k 個元素的 word\n    → Step 6.1: result = [word for word, count in items[:k]]\n\n→ Step 7: 回傳 result // 輸出\n\nEnd // 程式執行結束\n\nWe need to keep each line with arrow. For Decision we can use Decision: 排序鍵為 (-count, word) // etc. But maybe we don't need Decision. But requirement says use Decision. We'll include a Decision line for sorting key? Maybe simpler: Decision: 使用兩個排序條件? Yes → Step 5.1.\n\nAlso need to show \"→ Step 5: ...\" but we can keep one line.\n\nLet's format accordingly.\n\nNeed each line: virtual code step + space + // explanation. Use \"→\" for continuation. Use \"Decision:\" with Yes / No. For sorting, we can use Decision: if count equal? but not necessary.\n\nBut requirement: Use arrows and Decision. So include at least one Decision block.\n\nWe can include a Decision for selecting top k: e.g., Decision: 是否已經取得 k 個? Yes → End; No → loop. But simpler: just pick slice. But we can still include a Decision: \"是否 k 小於 items 數量?\" Yes → Step 6.1, No → Step 6.1 but with all? Might be overkill.\n\nWe can do:\n\n→ Decision: k 小於 items 數量? // 檢查是否超過可取數量\n    Yes → Step 6.1: result = [word for word, count in items[:k]]\n    No  → Step 6.1: result = [word for word, count in items] // 取全部\n\nBut this duplicates line number; we can still.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 接收輸入 words 與 k // 取得字串陣列與要回傳的數量\n→ Step 2: 建立空字典 freqMap // 用於記錄每個字的頻率\n→ Step 3: 逐一遍歷 words 中的每個 word\n    → Step 3.1: 若 freqMap 已存在該 word，則 freqMap[word] += 1\n    → Step 3.2: 否則 freqMap[word] = 1 // 更新頻率\n→ Step 4: 將 freqMap 轉換為項目清單 items = [(word, count)] // 方便排序\n→ Step 5: 依照頻率降序、字典序升序對 items 進行排序\n    → Decision: 排序鍵為 (-count, word) // 先按頻率降序，再按字典序升序\n        Yes → Step 5.1: items = sorted(items, key=lambda x: (-x[1], x[0]))\n→ Step 6: 取前 k 個字\n    → Decision: k 是否小於 items 數量？ // 檢查 k 是否超過可取數量\n        Yes → Step 6.1: result = [word for word, _ in items[:k]] // 取得前 k 個\n        No  → Step 6.1: result = [word for word, _ in items]     // 取全部\n→ Step 7: 回傳 result // 輸出最頻繁的 k 個字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def topKFrequent(self, words, k):\n        # Count frequencies\n        freq = Counter(words)\n        # Sort by frequency descending, then lexicographically ascending\n        sorted_words = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n        # Return top k words\n        return [word for word, _ in sorted_words[:k]]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        words = [\"a\",\"b\",\"a\"], k = 2\n    Returns a tuple (words_list, k_int).\n    \"\"\"\n    pattern = r'words\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        raise ValueError(\"Input format is incorrect.\")\n    words_str, k_str = match.groups()\n    # Safely evaluate the list string\n    words = eval(words_str, {\"__builtins__\": None}, {})\n    k = int(k_str)\n    return words, k\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    # Parse input\n    words, k = parse_input(raw_input)\n    # Compute result\n    solution = Solution()\n    result = solution.topKFrequent(words, k)\n    # Output as Python list string\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2",
          "expected_output": "[\"i\",\"love\"]",
          "success": true,
          "output": "['i', 'love']"
        },
        {
          "example_index": 1,
          "input": "words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4",
          "expected_output": "[\"the\",\"is\",\"sunny\",\"day\"]",
          "success": true,
          "output": "['the', 'is', 'sunny', 'day']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1296.json",
    "problem_index_in_file": 0,
    "title": "Divide Array in Sets of K Consecutive Numbers",
    "description_snippet": "Given an array of integers nums and a positive integer k, check whether it is possible to divide thi...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. The problem: Given array nums, positive integer k, check if can divide into sets of k consecutive numbers. Equivalent to Leetcode 846. Approach: Count frequencies, sort keys, iterate numbers ascending, for each number n with count>0, try to create groups of size k starting at n: for i from 0 to k-1: if count[n+i] < count[n], fail; else subtract count[n] from count[n+i]. Use dictionary. Implementation steps.\n\nWe need to produce virtual code lines: Start, Step: sort keys, Step: count frequencies, Step: iterate sorted keys, Decision: count >0, loop to subtract, etc.\n\nWe need to output only the virtual code lines, each line with explanation comment. Let's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 建立頻率表 freq[nums] // 统计每个数字出现次数\n→ Step 2: 取得所有独特数字並排序 asc_keys // 为保证按升序处理\n→ Decision: 对每个 num in asc_keys // 遍历排序后的数字\n    → Step 3: 取 count = freq[num] // 当前数字的剩余数量\n    → Decision: count > 0? // 只有剩余的才需要形成组\n        Yes → Step 4: 尝试为 num 形成 count 个长度为 k 的连续组\n            → Step 5: 对 i 从 0 到 k-1 // 检查每个连续数字是否足够\n                → Decision: freq[num+i] < count? // 是否不足以组成组\n                    Yes → Step 6: 返回 false // 组不可能完成\n                    No  → Continue // 继续检查下一个 i\n            → Step 7: 对 i 从 0 到 k-1 // 组可完成，减少频率\n                → freq[num+i] -= count\n        No → Continue // count 为 0，直接跳过\n→ Step 8: 所有数字均可组建，返回 true // 成功拆分\nEnd // 程式執行結束\n\nBut we must include the arrows for decisions Yes →, No →. Ensure each line is separate.\n\nWe might need to incorporate loops as steps. But they ask \"逐行地產生虛擬碼\" each line separate. So each step including loops can be separate line.\n\nWe'll produce the code accordingly.\n\nNeed to use \"Start\" and \"End\". Use arrow symbols \"→\" after Step names. Decision: lines with \"Decision: ...\". Use \"Yes →\" and \"No →\". Let's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: freq ← Map<Integer,Integer>() // 建立空頻率表\n\nLine 3: → Step 2: 遍歷 nums → freq[num] = freq.getOrDefault(num,0)+1 // 统计每个数字出现次数\n\nLine 4: → Step 3: keys ← freq.keySet()  // 取得所有键\n\nLine 5: → Step 4: sortedKeys ← sort(keys) // 按升序排列\n\nLine 6: → Decision: for num in sortedKeys // 遍历升序数字\n   (But we need each line separate, so we need a loop header? Maybe represent as \"→ Step 5: 遍历 sortedKeys\". But to keep decision we can do \"Decision: 需要检查当前 num?\".\n\nBetter: Use a loop construct: \"→ Step 5: for num in sortedKeys\" but we need explanation. We can express as \"→ Step 5: for each num in sortedKeys\" comment.\n\nThen inside loop: Step 6: count ← freq[num] // 取当前数字剩余数量\n\nDecision: count > 0? // 是否需要处理\n\nYes branch: Step 7: attemptGroup ← true // 标记是否成功\n\nStep 8: for i from 0 to k-1 // 检查足够性\n   Decision: freq[num+i] < count? // 检查每个连续数字\n\n   Yes: Step 9: attemptGroup ← false; return false\n\n   No: continue\n\nAfter loop: if attemptGroup == true\n   Step 10: for i from 0 to k-1 // 减去数量\n        freq[num+i] -= count\n\nNo: continue (i.e., if count == 0, just continue)\n\nFinally: Step 11: return true // 所有数字成功分组\n\nEnd.\n\nBut each line separate. Let's enumerate:\n\n1 Start\n\n2 → Step 1: freq ← Map() // 建立頻率表\n\n3 → Step 2: 遍歷 nums  → freq[num] = freq.getOrDefault(num,0)+1 // 统计出现次数\n\n4 → Step 3: keys ← freq.keySet() // 取得所有键\n\n5 → Step 4: sortedKeys ← sort(keys) // 按升序排列\n\n6 → Step 5: for num in sortedKeys // 遍历升序数字\n\n7 → Step 6: count ← freq[num] // 取当前数字剩余数量\n\n8 → Decision: count > 0? // 是否需要处理\n\n   Yes → Step 7: attemptGroup ← true // 标记尝试分组\n\n   No  → Step 8: 继续 // 跳过此数字\n\n9 → Step 8a: for i from 0 to k-1 // 检查足够性\n\n10 → Decision: freq[num+i] < count? // 检查连续数字是否足够\n\n    Yes → Step 9: attemptGroup ← false; return false // 组不可能完成\n\n    No  → Step 10: 继续 // 继续检查下一个 i\n\n11 → Decision: attemptGroup? // 是否成功\n\n    Yes → Step 9a: for i from 0 to k-1 // 减去数量\n\n    No  → Step 10a: 继续 // count 为 0 或无法分组，跳过\n\n12 → Step 9a: freq[num+i] -= count // 减去剩余数量\n\n13 → Step 10a: 继续 // 结束循环\n\n14 → Step 11: return true // 所有数字均可分组\n\n15 End\n\nBut we need to keep each line separate and include arrow for decisions. But we need to show arrow for Yes and No after the decision line, not nested indent? Example: \nDecision: ... \nYes → ... \nNo  → ...\n\nThus each \"Yes →\" and \"No  →\" lines should be separate.\n\nWe need to keep a line count.\n\nLet's write final answer accordingly. Ensure each line ends with \"// 解釋/說明\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: freq ← Map() // 建立空的頻率表\n→ Step 2: 遍歷 nums  → freq[num] = freq.getOrDefault(num,0)+1 // 统计每个数字出现次数\n→ Step 3: keys ← freq.keySet() // 取得所有键\n→ Step 4: sortedKeys ← sort(keys) // 按升序排列\n→ Step 5: for num in sortedKeys // 遍历升序数字\n→ Step 6: count ← freq[num] // 取当前数字剩余数量\n→ Decision: count > 0? // 是否需要处理\n    Yes → Step 7: attemptGroup ← true // 标记尝试分组\n    No  → Step 8: 继续 // 跳过此数字\n→ Step 9: for i from 0 to k-1 // 检查足够性\n→ Decision: freq[num+i] < count? // 检查连续数字是否足够\n    Yes → Step 10: attemptGroup ← false; return false // 组不可能完成\n    No  → Step 11: 继续 // 继续检查下一个 i\n→ Decision: attemptGroup? // 是否成功分组\n    Yes → Step 12: for i from 0 to k-1 // 减去数量\n    No  → Step 13: 继续 // count 为 0 或无法分组，跳过\n→ Step 14: freq[num+i] -= count // 减去剩余数量\n→ Step 15: 继续 // 结束循环\n→ Step 16: return true // 所有数字均可分组\nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def isPossibleDivide(self, nums, k):\n        if len(nums) % k != 0:\n            return False\n        count = Counter(nums)\n        for num in sorted(count):\n            if count[num] > 0:\n                need = count[num]\n                for i in range(num, num + k):\n                    if count[i] < need:\n                        return False\n                    count[i] -= need\n        return True\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expected input format: \"nums = [1,2,3,3,4,4,5,6], k = 4\"\n    # Split around ', k = '\n    parts = data.split(', k = ')\n    nums_part = parts[0].replace('nums =', '').strip()\n    k_part = parts[1].strip() if len(parts) > 1 else '0'\n    nums = eval(nums_part)\n    k = int(k_part)\n    result = Solution().isPossibleDivide(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,3,4,4,5,6], k = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4], k = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode238.json",
    "problem_index_in_file": 0,
    "title": "Product of Array Except Self",
    "description_snippet": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for problem: product of array except self without division, O(n). Steps: compute left products, right products, combine. Provide Start, End. Use Decision? maybe not. Just linear steps. Let's produce:\n\nStart // begin\n→ Step 1: n ← length(nums) // get size\n→ Step 2: left ← array of size n initialized 1 // left product array\n→ Step 3: right ← array of size n initialized 1 // right product array\n→ Step 4: answer ← array of size n // result\n→ Step 5: left[0] ← 1 // product of elements before first\n→ Step 6: For i from 1 to n-1: left[i] ← left[i-1] * nums[i-1] // prefix product\n→ Step 7: right[n-1] ← 1 // product after last\n→ Step 8: For i from n-2 down to 0: right[i] ← right[i+1] * nums[i+1] // suffix product\n→ Step 9: For i from 0 to n-1: answer[i] ← left[i] * right[i] // combine\n→ Step 10: Return answer // final array\nEnd // finish\n\nAdd comments. Ensure each line ends with // explanation. Use virtual arrow. Good. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: left ← array of size n initialized 1 // 前綴乘積陣列，預設為 1  \n→ Step 3: right ← array of size n initialized 1 // 後綴乘積陣列，預設為 1  \n→ Step 4: answer ← array of size n // 最終答案陣列  \n→ Step 5: left[0] ← 1 // 第 0 個位置前面沒有元素，乘積為 1  \n→ Step 6: For i from 1 to n-1: left[i] ← left[i-1] * nums[i-1] // 計算前綴乘積  \n→ Step 7: right[n-1] ← 1 // 最後一個位置後面沒有元素，乘積為 1  \n→ Step 8: For i from n-2 down to 0: right[i] ← right[i+1] * nums[i+1] // 計算後綴乘積  \n→ Step 9: For i from 0 to n-1: answer[i] ← left[i] * right[i] // 前後乘積相乘得到答案  \n→ Step 10: Return answer // 回傳最終結果陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def productExceptSelf(self, nums):\n        \"\"\"\n        Compute product of all elements except self for each position.\n        O(n) time, O(1) extra space excluding result array.\n        \"\"\"\n        n = len(nums)\n        res = [1] * n\n\n        # First pass: prefix products\n        left = 1\n        for i in range(n):\n            res[i] = left\n            left *= nums[i]\n\n        # Second pass: suffix products\n        right = 1\n        for i in range(n - 1, -1, -1):\n            res[i] *= right\n            right *= nums[i]\n\n        return res\n\ndef main():\n    # Read entire input\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Parse the input format \"nums = [ ... ]\" or just a list\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # Safely evaluate the list expression\n    nums = ast.literal_eval(expr)\n\n    # Solve and print the result\n    sol = Solution()\n    result = sol.productExceptSelf(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "success": true,
          "output": "[24, 12, 8, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "success": true,
          "output": "[0, 0, 9, 0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode321.json",
    "problem_index_in_file": 0,
    "title": "Create Maximum Number",
    "description_snippet": "You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 re...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: maximum number from two arrays selecting k digits preserving relative order. Classic Leetcode 321. Steps: iterate over pick i digits from nums1, j=k-i from nums2. For each, get max subsequence of length i from nums1 and j from nums2 using greedy stack, merge two sequences to form max number, track best. Virtual code lines accordingly.\n\nWe need to produce step-by-step with explanations. Use Start, End, Decision etc. Use arrows.\n\nWe'll produce high-level algorithm:\n\nStart\n→ Define function getMaxSubsequence(arr, l) // greedy stack\n→ For i from max(0, k-n) to min(k, m)\n    → j = k - i\n    → sub1 = getMaxSubsequence(nums1, i)\n    → sub2 = getMaxSubsequence(nums2, j)\n    → merged = merge(sub1, sub2)\n    → if merged > best\n          best = merged\n→ Return best\nEnd\n\nBut must provide line-by-line with explanations.\n\nAlso we need to detail sub-functions. So we will also produce sub-code lines for getMaxSubsequence and merge. They can be separate sections. Use indentation. Let's produce something like:\n\nStart\n→ Define getMaxSubsequence // compute max subsequence of length l from array arr\n    → Initialize stack empty\n    → For each index i in arr\n        → While stack not empty and arr[i] > stack[-1] and remaining elements enough\n            → Pop\n        → If stack length < l\n            → Push arr[i]\n    → Return stack\n→ Define mergeSequences // merge two sequences to get max\n    → Initialize merged empty\n    → While seq1 not empty or seq2 not empty\n        → If seq1 > seq2\n            → Append seq1[0] to merged, pop from seq1\n        → Else\n            → Append seq2[0], pop from seq2\n    → Return merged\n→ Main algorithm\n    → best = empty\n    → For i from max(0, k - n) to min(k, m)\n        → j = k - i\n        → seq1 = getMaxSubsequence(nums1, i)\n        → seq2 = getMaxSubsequence(nums2, j)\n        → candidate = mergeSequences(seq1, seq2)\n        → If candidate > best\n            → best = candidate\n    → Return best\nEnd\n\nAdd explanations.\n\nWe must adhere to the format: each line '虛擬碼步驟' followed by space then '//' explanation. Use Start, End, Decision. Use arrow symbols. Need to include subroutine definitions maybe in separate block but still lines.\n\nWe might use indentation or comments. Example:\n\nStart // 程式開始\n\n→ Define getMaxSubsequence(arr, l) // 取得陣列 arr 的長度為 l 的最大子序列\n    → stack = empty // 用於存放子序列\n    → For idx, val in enumerate(arr) // 遍歷 arr\n        → While stack not empty and val > stack[-1] and (len(stack) - 1 + len(arr) - idx >= l) // 以保證還能填滿長度\n            → Pop stack // 移除較小前序數字\n        → If len(stack) < l\n            → Push val to stack // 加入較大數字\n    → Return stack // 返回最大子序列\n\n→ Define mergeSequences(seq1, seq2) // 合併兩個序列得到最大序列\n    → merged = empty\n    → While seq1 not empty or seq2 not empty\n        → If seq1 > seq2 // 字典序比較\n            → Append seq1[0] to merged\n            → Remove first element from seq1\n        → Else\n            → Append seq2[0] to merged\n            → Remove first element from seq2\n    → Return merged\n\n→ Main algorithm // 主流程\n    → best = empty\n    → i_min = max(0, k - len(nums2))\n    → i_max = min(k, len(nums1))\n    → For i from i_min to i_max\n        → j = k - i\n        → subseq1 = getMaxSubsequence(nums1, i)\n        → subseq2 = getMaxSubsequence(nums2, j)\n        → candidate = mergeSequences(subseq1, subseq2)\n        → If candidate > best\n            → best = candidate\n    → Return best // 最終答案\n\nEnd // 程式結束\n\nBut ensure each line ends with explanation.\n\nWe need to use arrow '→' for each step, and 'Decision:' for comparisons.\n\nWe can format like:\n\nStart // ...\n→ Define getMaxSubsequence(arr, l) // ...\n→   stack = [] // ...\n→   For i in 0..len(arr)-1 // ...\n→       While ... // ...\n→           Pop stack // ...\n→       If len(stack) < l // ...\n→           Append arr[i] to stack // ...\n→   Return stack // ...\n→ Define mergeSequences(seq1, seq2) // ...\n→   merged = [] // ...\n→   While seq1 not empty or seq2 not empty // ...\n→       Decision: seq1 > seq2? // ...\n→           Yes → Append seq1[0] to merged // ...\n→           No  → Append seq2[0] to merged // ...\n→   Return merged // ...\n→ Main algorithm // ...\n→   best = [] // ...\n→   i_min = max(0, k - len(nums2)) // ...\n→   i_max = min(k, len(nums1)) // ...\n→   For i from i_min to i_max // ...\n→       j = k - i // ...\n→       subseq1 = getMaxSubsequence(nums1, i) // ...\n→       subseq2 = getMaxSubsequence(nums2, j) // ...\n→       candidate = mergeSequences(subseq1, subseq2) // ...\n→       Decision: candidate > best? // ...\n→           Yes → best = candidate // ...\n→   Return best // ...\nEnd // ...\n\nWe need to include explanation after each line. Use // comment.\n\nMake sure to adhere to formatting: each line '虛擬碼步驟' + space + '//' explanation. Use arrow.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Define getMaxSubsequence(arr, l) // 定義取得陣列 arr 內長度為 l 的最大子序列的功能  \n→   stack = [] // 用 stack 儲存目前已選取的最大子序列  \n→   For i = 0 to len(arr)-1 // 遍歷陣列 arr  \n→       Decision: arr[i] > stack[-1] AND (len(stack)-1 + len(arr)-i >= l)? // 判斷是否能放棄較小前序元素並仍能填滿長度  \n→           Yes → Pop stack // 移除 stack 末尾較小元素  \n→           No  → // 保持現有元素  \n→       Decision: len(stack) < l? // 判斷 stack 是否還可以加入元素  \n→           Yes → Push arr[i] to stack // 加入較大的數字  \n→           No  → // stack 已滿，忽略此數字  \n→   Return stack // 回傳最大子序列  \n→ Define mergeSequences(seq1, seq2) // 定義合併兩個序列為最大序列的功能  \n→   merged = [] // 用來儲存合併結果  \n→   While seq1 not empty OR seq2 not empty // 只要任一序列還有剩餘元素  \n→       Decision: seq1 > seq2? // 字典序比較兩個序列  \n→           Yes → Append seq1[0] to merged // 取 seq1 前綴較大的元素  \n→                  Delete seq1[0] // 從 seq1 中移除已取元素  \n→           No  → Append seq2[0] to merged // 取 seq2 前綴較大的元素  \n→                  Delete seq2[0] // 從 seq2 中移除已取元素  \n→   Return merged // 回傳合併後的最大序列  \n→ Main algorithm // 主流程  \n→   best = [] // 用來儲存目前最好的 k 位數組合  \n→   i_min = max(0, k - len(nums2)) // 需要從 nums1 中挑選的最小數量  \n→   i_max = min(k, len(nums1)) // 需要從 nums1 中挑選的最大數量  \n→   For i = i_min to i_max // 遍歷所有可能的 i 值  \n→       j = k - i // 需要從 nums2 中挑選的數量  \n→       subseq1 = getMaxSubsequence(nums1, i) // 取得 nums1 的最佳長度 i 子序列  \n→       subseq2 = getMaxSubsequence(nums2, j) // 取得 nums2 的最佳長度 j 子序列  \n→       candidate = mergeSequences(subseq1, subseq2) // 合併兩個子序列得到候選答案  \n→       Decision: candidate > best? // 判斷候選答案是否比目前最佳更大  \n→           Yes → best = candidate // 更新最佳答案  \n→   Return best // 回傳長度為 k 的最大數字序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def maxNumber(self, nums1, nums2, k):\n        # 取得陣列 nums 內長度為 t 的最大子序列\n        def pick_max(nums, t):\n            drop = len(nums) - t  # 允許丟棄的數量\n            stack = []\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:t]\n\n        # 合併兩個子序列得到最大序列\n        def merge(a, b):\n            res = []\n            while a or b:\n                if a > b:\n                    res.append(a[0])\n                    a.pop(0)\n                else:\n                    res.append(b[0])\n                    b.pop(0)\n            return res\n\n        best = []\n        i_min = max(0, k - len(nums2))\n        i_max = min(k, len(nums1))\n        for i in range(i_min, i_max + 1):\n            a = pick_max(nums1, i)\n            b = pick_max(nums2, k - i)\n            candidate = merge(a[:], b[:])  # copy to avoid modifying originals\n            if candidate > best:\n                best = candidate\n        return best\n\n\nif __name__ == \"__main__\":\n    # 讀取並解析輸入\n    raw = sys.stdin.read()\n    nums1_match = re.search(r\"nums1\\s*=\\s*(\\[[^\\]]*\\])\", raw)\n    nums2_match = re.search(r\"nums2\\s*=\\s*(\\[[^\\]]*\\])\", raw)\n    k_match = re.search(r\"k\\s*=\\s*(\\d+)\", raw)\n\n    if not (nums1_match and nums2_match and k_match):\n        print(\"[]\")\n        sys.exit(0)\n\n    nums1 = ast.literal_eval(nums1_match.group(1))\n    nums2 = ast.literal_eval(nums2_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.maxNumber(nums1, nums2, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5",
          "expected_output": "[9,8,6,5,3]",
          "success": true,
          "output": "[9, 8, 6, 5, 3]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [6,7], nums2 = [6,0,4], k = 5",
          "expected_output": "[6,7,6,0,4]",
          "success": true,
          "output": "[6, 7, 6, 0, 4]"
        },
        {
          "example_index": 2,
          "input": "nums1 = [3,9], nums2 = [8,9], k = 3",
          "expected_output": "[9,8,9]",
          "success": true,
          "output": "[9, 8, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode343.json",
    "problem_index_in_file": 0,
    "title": "Integer Break",
    "description_snippet": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the pro...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the problem: integer break. We need to output each line: virtual code step + comment.\n\nWe need to think algorithm: For integer break maximize product. Classic solution: for n>=4, break into 3s as many as possible, special case for remainder 1: adjust to 4. Use greedy: compute count3 = n/3; if n%3==1, then count3-=1, remainder 4; else remainder = n%3. Then product = 3^count3 * remainder. But must consider k>=2. For n=2, answer 1; n=3 answer 2; n=4 answer 4. We'll produce steps.\n\nSo virtual code: Start, input n, handle base cases: if n==2 return 1; if n==3 return 2; else compute count3 = n // 3; rem = n % 3; if rem==1: count3 -=1; rem=4; product=1; loop count3 times multiply product by 3; if rem>0 multiply by rem; return product. Use loops.\n\nNeed to output step by step.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: Read integer n // 從使用者取得整數 n\n\n→ Decision: n == 2? // 檢查最小特殊情況\n\n    Yes → Step 2: Return 1 // n=2 只能分成1+1，乘積 1\n\n    No  → Decision: n == 3? // 檢查下個特殊情況\n\n        Yes → Step 3: Return 2 // n=3 分成1+2，乘積 2\n\n        No  → Step 4: 計算 count3 = n / 3 // 取盡可能多的 3\n\n        → Step 5: 計算 rem = n % 3 // 取餘數\n\n        → Decision: rem == 1? // 如果餘數為 1，調整以避免 1\n\n            Yes → Step 6: count3 = count3 - 1 // 省去一個 3\n\n            → Step 7: rem = 4 // 將餘數改為 4（3+1 → 2+2）\n\n            No  → (無操作)\n\n        → Step 8: product = 1 // 初始化乘積\n\n        → Loop count3 times: product = product * 3 // 乘以所有 3\n\n        → Decision: rem > 0? // 若餘數存在\n\n            Yes → Step 9: product = product * rem // 乘以餘數\n\n            No  → (無操作)\n\n        → Step 10: Return product // 回傳最大乘積\n\nEnd // 程式執行結束\n\nBut need to use arrow notation.\n\nWe should produce each line as \"虛擬碼步驟 // 解釋\". We'll format each line. Use arrow for steps after decisions.\n\nLet's produce. Ensure each line has step and comment. Use Start, End.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Read integer n // 從使用者取得整數 n  \n→ Decision: n == 2? // 檢查最小特殊情況  \n Yes → Step 2: Return 1 // n=2 只能分成1+1，乘積為 1  \n No  → Decision: n == 3? // 檢查下個特殊情況  \n  Yes → Step 3: Return 2 // n=3 分成1+2，乘積為 2  \n  No  → Step 4: Compute count3 = n / 3 // 盡量多取 3 作為分割數  \n  → Step 5: Compute rem = n % 3 // 取得餘數  \n  → Decision: rem == 1? // 若餘數為 1，避免產生 1  \n   Yes → Step 6: count3 = count3 - 1 // 省去一個 3  \n   → Step 7: rem = 4 // 將餘數改為 4（3+1 → 2+2）  \n   No  → (無操作)  \n  → Step 8: product = 1 // 初始化乘積  \n  → Loop count3 times: product = product * 3 // 乘以所有 3  \n  → Decision: rem > 0? // 若有餘數  \n   Yes → Step 9: product = product * rem // 乘以餘數  \n   No  → (無操作)  \n  → Step 10: Return product // 回傳最大乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef integer_break(n: int) -> int:\n    \"\"\"\n    Return the maximum product obtainable by breaking n into\n    at least two positive integers.\n    \"\"\"\n    # Special cases for the smallest inputs\n    if n == 2:\n        return 1  # 1 + 1\n    if n == 3:\n        return 2  # 1 + 2\n\n    # Greedy strategy: use as many 3's as possible.\n    # If the remaining part is 1, adjust to avoid 1 (replace 3+1 with 2+2).\n    res = 1\n    while n > 4:\n        res *= 3\n        n -= 3\n    return res * n  # multiply by the last remaining part (2,3, or 4)\n\ndef solve() -> None:\n    \"\"\"\n    Read an integer n from standard input, compute the maximum product,\n    and print the result to standard output.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the first integer found in the input\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = integer_break(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 10",
          "expected_output": "36",
          "success": true,
          "output": "36"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode438.json",
    "problem_index_in_file": 0,
    "title": "Find All Anagrams in a String",
    "description_snippet": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with each line, including explanation. The requirement: Use virtual code arrows, start, decision, etc. It's sliding window algorithm.\n\nWe need to produce virtual code lines for the algorithm. Each line should be \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use arrows (→, Yes →, No →) and structure (Start, End, Decision:). Each step should be a line.\n\nLet's outline algorithm:\n\n1. Start\n2. Step 1: Initialize frequency map for p (targetCounts)\n3. Step 2: Initialize frequency map for window (windowCounts)\n4. Step 3: Initialize left = 0, matched = 0 (or use needed)\n5. Step 4: Iterate right over s indices\n6. Decision: If char at right needed (count > 0)\n   - Update windowCounts\n   - If windowCounts[char] <= targetCounts[char], increment matched\n7. Decision: If matched equals total unique chars? Or window size == len(p)\n   - Add left to result\n   - Remove left char from window: if needed, decrement matched\n   - Move left +=1\n8. End\n9. Return result\n\nBut we need to provide virtual code line by line.\n\nWe can produce something like:\n\nStart // 程式開始\n→ Step 1: Set targetCount ← frequency of each char in p // 先計算 p 的字元頻率\n→ Step 2: Set windowCount ← empty map // 建立滑窗的字元頻率表\n→ Step 3: Set left ← 0, matched ← 0, required ← number of unique chars in p // 初始化指標與匹配計數\n→ Step 4: For right from 0 to len(s)-1 // 逐個遍歷 s\n    → Step 5: char ← s[right] // 取右指標字元\n    → Decision: 如果 char in targetCount? // 檢查此字元是否是 p 的需求\n        Yes → Step 6: Increment windowCount[char] // 更新滑窗字元頻率\n        Yes → Decision: 如果 windowCount[char] ≤ targetCount[char]? // 檢查是否還在需求範圍內\n            Yes → Step 7: Increment matched // 匹配數增加\n    → Decision: 如果 matched == required and right-left+1 == len(p)? // 檢查是否形成完整的子串\n        Yes → Step 8: Append left to result // 將起始位置加入結果\n        Yes → Step 9: leftChar ← s[left] // 移除左側字元\n        Yes → Decision: 如果 leftChar in targetCount? // 左字元是否屬於需求\n            Yes → Step 10: Decrement windowCount[leftChar] // 更新滑窗頻率\n            Yes → Decision: 如果 windowCount[leftChar] < targetCount[leftChar]? // 檢查是否超出需求\n                Yes → Step 11: Decrement matched // 匹配數減少\n        Yes → Step 12: Increment left // 移動左指標\n→ End // 程式結束\n→ Step 13: Return result // 回傳所有起始索引\n\nBut we need to use arrow and decision formatting exactly as per requirement. They used \"Decision:\" then indentation and \"Yes →\" etc. So we need to align properly.\n\nAlso each line must contain virtual code step then space then explanation.\n\nWe'll produce each line. We must ensure no actual code printed; just virtual steps. So \"Set targetCount ← ...\" is okay but not actual code.\n\nLet's produce.\n\nAlso we need to incorporate that after Step 13 we return result. The algorithm can be slightly different but we provide.\n\nLet's create final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: targetCount ← frequency map of each char in p // 先計算字串 p 的字元頻率  \n→ Step 2: windowCount ← empty map // 建立滑動視窗的字元頻率表  \n→ Step 3: left ← 0, matched ← 0, required ← number of distinct chars in p // 初始化指標與匹配計數  \n→ Step 4: for right from 0 to len(s)-1 // 逐個遍歷 s 的字元  \n  → Step 5: char ← s[right] // 取右指標處的字元  \n  → Decision: char is in targetCount? // 判斷此字元是否屬於 p 的需求  \n   Yes → Step 6: windowCount[char] ← windowCount.get(char,0)+1 // 更新滑窗字元頻率  \n   Yes → Decision: windowCount[char] ≤ targetCount[char]? // 檢查是否仍在需求範圍內  \n    Yes → Step 7: matched ← matched+1 // 匹配數增加  \n  → Decision: matched == required and right-left+1 == len(p)? // 判斷是否形成完整的子字串  \n   Yes → Step 8: result.append(left) // 將起始位置加入結果  \n   Yes → Step 9: leftChar ← s[left] // 取左指標處的字元  \n   Yes → Decision: leftChar is in targetCount? // 判斷左字元是否屬於需求  \n    Yes → Step 10: windowCount[leftChar] ← windowCount.get(leftChar,0)-1 // 更新滑窗字元頻率  \n    Yes → Decision: windowCount[leftChar] < targetCount[leftChar]? // 檢查是否已超出需求  \n     Yes → Step 11: matched ← matched-1 // 匹配數減少  \n   Yes → Step 12: left ← left+1 // 左指標右移，縮小滑窗  \n→ End // 程式結束  \n→ Step 13: return result // 回傳所有符合條件的起始索引",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> list[int]:\n        ns, np = len(s), len(p)\n        if ns < np:\n            return []\n\n        # Count frequency of characters in p\n        p_count = Counter(p)\n        # Count frequency in the first window of s\n        s_count = Counter(s[:np])\n        result = []\n\n        # Check the first window\n        if s_count == p_count:\n            result.append(0)\n\n        # Slide the window over s\n        for i in range(1, ns - np + 1):\n            # Remove the leftmost character of the previous window\n            left_char = s[i - 1]\n            s_count[left_char] -= 1\n            if s_count[left_char] == 0:\n                del s_count[left_char]\n\n            # Add the new rightmost character\n            right_char = s[i + np - 1]\n            s_count[right_char] += 1\n\n            # If counts match, record starting index\n            if s_count == p_count:\n                result.append(i)\n\n        return result\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract strings enclosed in double quotes\n    quoted_strings = re.findall(r'\"([^\"]*)\"', data)\n\n    # Fallback: if no quoted strings, try to split by newlines\n    if len(quoted_strings) < 2:\n        parts = [part.strip() for part in data.replace('=', ',').split(',')]\n        # Take the last two non-empty parts as s and p\n        filtered = [p for p in parts if p]\n        if len(filtered) >= 2:\n            s = filtered[-2]\n            p = filtered[-1]\n        else:\n            # As a last resort, assume the input is two lines\n            lines = data.splitlines()\n            s = lines[0].strip()\n            p = lines[1].strip() if len(lines) > 1 else ''\n    else:\n        s, p = quoted_strings[0], quoted_strings[1]\n\n    sol = Solution()\n    ans = sol.findAnagrams(s, p)\n    print(ans)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"cbaebabacd\", p = \"abc\"",
          "expected_output": "[0,6]",
          "success": true,
          "output": "[0, 6]"
        },
        {
          "example_index": 1,
          "input": "s = \"abab\", p = \"ab\"",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode467.json",
    "problem_index_in_file": 0,
    "title": "Unique Substrings in Wraparound String",
    "description_snippet": "We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so b...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for problem: count number of unique non-empty substrings of s that appear in infinite wraparound string base (the alphabet repeats). Known solution: For each character, track longest substring ending at that char that is consecutive in wraparound. Use array len[26] max length of consecutive substring ending at each char. Iterate s, maintain current length cur if s[i] consecutive to s[i-1] else reset. Update len[s[i]] = max(len[s[i]], cur). Finally sum len values.\n\nWe need to produce virtual code with explanations per line. Use the format: each line: \"虛擬碼步驟 // 解釋\".\n\nWe'll start with Start, etc.\n\nWe should provide steps: Start, Input string s, Initialize array len[26] to zeros, cur=0, iterate i over s, determine if consecutive, etc.\n\nUse Decision: if consecutive? Yes/No.\n\nFinally sum and output.\n\nWe need to avoid actual code, just virtual steps.\n\nWe'll produce lines accordingly.\n\nUse arrow and indent. For decisions, show Yes/No.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 從使用者或測試資料取得待分析的字串  \n→ Initialize len[26] to 0 // 建立 26 個元素的陣列，記錄每個字母為結尾時可取得的最大連續長度  \n→ Set cur = 0 // 當前連續子字串長度  \n→ For i from 0 to s.length-1 // 逐字母掃描 s  \n  Decision: 是否為第一個字母? // 判斷是否為起始位置  \n   Yes → cur = 1 // 第一個字母自成一個長度為 1 的子字串  \n   No → Decision: s[i] 是否是 s[i-1] 的下一個字母（考慮 wraparound）? // 檢查是否連續  \n    Yes → cur = cur + 1 // 連續，長度加 1  \n    No → cur = 1 // 不連續，重新開始長度為 1  \n  Update len[s[i]] = max(len[s[i]], cur) // 更新以 s[i] 為結尾的最大連續長度  \n→ Sum all values in len[26] to total // 由於每種結尾字母對應的長度即為能形成的唯一子字串數量，累加即得到答案  \n→ Output total // 回傳最終計算結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findSubstringInWraproundString(self, s: str) -> int:\n        \"\"\"Return number of unique non‑empty substrings of s that appear in\n        the infinite wraparound string of the alphabet.\"\"\"\n        dp = [0] * 26          # dp[i] = longest valid substring ending with chr(i + ord('a'))\n        cur = 0                # current consecutive length\n\n        for i, ch in enumerate(s):\n            if i > 0 and (ord(ch) - ord(s[i - 1])) % 26 == 1:\n                cur += 1\n            else:\n                cur = 1\n            idx = ord(ch) - ord('a')\n            dp[idx] = max(dp[idx], cur)\n\n        return sum(dp)\n\ndef main() -> None:\n    # Read whole input, strip whitespace\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse input that may contain \"s = \\\"a\\\"\" style\n    if '=' in data:\n        _, val = data.split('=', 1)\n        val = val.strip()\n    else:\n        val = data\n\n    # Remove surrounding quotes if present\n    if (val.startswith('\"') and val.endswith('\"')) or (val.startswith(\"'\") and val.endswith(\"'\")):\n        val = val[1:-1]\n\n    s = val\n\n    sol = Solution()\n    result = sol.findSubstringInWraproundString(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"a\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"cac\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"zab\"",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode219.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate II",
    "description_snippet": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Provide step-by-step algorithm for \"Contains Duplicate II\" Leetcode problem. We need to use Start, End, Decision, steps with arrows. For each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow \"→\" for next step. Use \"Decision:\" and \"Yes →\", \"No →\". Use Start and End.\n\nWe must produce code steps: 1. Start. 2. Create hash map to store number and last index. 3. Iterate over array with index i. 4. Check if number exists in map. 5. Decision: If exists and difference <= k -> return true. 6. If not exist or difference > k, update map. 7. After loop, return false. 8. End.\n\nWe need to include the virtual code steps line by line with explanation. Format: \"Start // 程式開始執行\". Then arrow lines. Use \"→\" after Start. Use indentation maybe but not required. But we should keep indentation for clarity. Use \"Decision:\" lines with Yes and No arrows. Provide at most 15 lines maybe.\n\nLet's craft.\n\nLine1: Start // 程式開始執行\nLine2: → Step 1: 建立空的字典 map // 用於存放數值及其最後一次出現的索引\nLine3: → Step 2: 對 nums 進行 for 迴圈，索引 i 從 0 開始 // 遍歷整個陣列\nLine4: → Decision: nums[i] 是否已在 map 中? // 檢查此數值是否已見過\nLine5:     Yes → Step 3: 計算距離 diff = i - map[nums[i]] // 取得前一次索引與目前索引的差距\nLine6:     Yes → Decision: diff <= k? // 判斷是否滿足距離條件\nLine7:         Yes → Step 4: 回傳 true // 找到符合條件的重複項\nLine8:         No  → Step 5: 更新 map[nums[i]] = i // 雖不符合距離條件，更新索引為最新\nLine9:     No  → Step 6: 插入 map[nums[i]] = i // 第一次見到此數值，記錄索引\nLine10: → Step 7: 迴圈結束後，若未回傳，回傳 false // 表示不存在符合條件的重複項\nLine11: End // 程式執行結束\n\nWe need to include arrow after each line? We already used arrow before each step except start maybe.\n\nLet's output accordingly. Ensure each line ends with // 解釋.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的字典 map // 用於存放數值及其最後一次出現的索引  \n→ Step 2: 對 nums 進行 for 迴圈，索引 i 從 0 開始 // 遍歷整個陣列  \n→ Decision: nums[i] 是否已在 map 中? // 檢查此數值是否已見過  \n Yes → Step 3: 計算距離 diff = i - map[nums[i]] // 取得前一次索引與目前索引的差距  \n Yes → Decision: diff <= k? // 判斷是否滿足距離條件  \n  Yes → Step 4: 回傳 true // 找到符合條件的重複項  \n  No  → Step 5: 更新 map[nums[i]] = i // 雖不符合距離條件，更新索引為最新  \n No  → Step 6: 插入 map[nums[i]] = i // 第一次見到此數值，記錄索引  \n→ Step 7: 迴圈結束後，若未回傳，回傳 false // 表示不存在符合條件的重複項  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"檢查 nums 中是否存在兩個距離不超過 k 的相同元素。\"\"\"\n        index_map = {}\n        for i, num in enumerate(nums):\n            if num in index_map and i - index_map[num] <= k:\n                return True\n            index_map[num] = i\n        return False\n\ndef parse_input(input_text: str):\n    \"\"\"\n    解析形如 'nums = [1,2,3,1], k = 3' 的輸入。\n    回傳 (nums, k)。\n    \"\"\"\n    pattern = r'nums\\s*=\\s*(\\[.*?\\])\\s*,\\s*k\\s*=\\s*(-?\\d+)'   # 支援負整數\n    match = re.search(pattern, input_text, re.S)\n    if not match:\n        raise ValueError(\"輸入格式不正確\")\n    nums_str, k_str = match.groups()\n    nums = ast.literal_eval(nums_str)   # 安全地解析列表\n    k = int(k_str)\n    return nums, k\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    try:\n        nums, k = parse_input(raw_input)\n    except Exception as e:\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.containsNearbyDuplicate(nums, k)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], k = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1], k = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,1,2,3], k = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode135.json",
    "problem_index_in_file": 0,
    "title": "Candy",
    "description_snippet": "There are n children standing in a line. Each child is assigned a rating value given in the integer ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the classic Candy problem. Provide step-by-step virtual code lines with comments. Use Start, Decision, etc. Provide line-by-line.\n\nWe need to produce algorithm: two-pass method. Steps: initialize candies array with 1. left-to-right pass: if rating[i]>rating[i-1] then candies[i]=candies[i-1]+1. right-to-left pass: if rating[i]>rating[i+1] and candies[i] <= candies[i+1] then candies[i]=candies[i+1]+1. Sum candies.\n\nWe need to produce virtual code line-by-line with explanation.\n\nAlso we must not output actual code; just virtual code.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 取得陣列 ratings 和長度 n // 取得輸入資料\n→ Step 2: 建立 candies 陣列，長度 n，所有元素設為 1 // 每個孩子至少一顆糖果\n→ Decision: n 是否為 0? // 檢查是否有孩子\n    Yes → Step 3: 回傳 0 // 無孩子，糖果數為 0\n    No  → // 進行左右兩次掃描\n→ Step 4: 進行左到右掃描 // 第一趟確保左邊較高評分者得到更多糖果\n    → For i 從 1 到 n-1\n        → Decision: ratings[i] > ratings[i-1]?\n            Yes → candies[i] = candies[i-1] + 1 // 右側孩子比左側高，給更多糖果\n            No  → // 不變，保持 1\n→ Step 5: 進行右到左掃描 // 第二趟確保右邊較高評分者得到更多糖果\n    → For i 從 n-2 到 0\n        → Decision: ratings[i] > ratings[i+1]?\n            Yes → Decision: candies[i] <= candies[i+1]?\n                Yes → candies[i] = candies[i+1] + 1 // 右側更高且目前糖果不足，調整\n                No  → // 已經比右側多，保持不變\n            No  → // 右側更低或相同，不變\n→ Step 6: 計算總糖果數 // 將所有糖果加總得到答案\n    → sum = 0\n    → For i 從 0 到 n-1\n        → sum = sum + candies[i] // 累加\n→ Step 7: 回傳 sum // 回傳最小總糖果數\nEnd // 程式執行結束\n\nWe should output each line as separate line with explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得陣列 ratings 及長度 n // 讀取輸入資料  \n→ Step 2: 建立 candies 陣列，長度 n，所有元素設為 1 // 每位孩子至少一顆糖果  \n→ Decision: n 是否為 0? // 檢查是否有孩子  \n Yes → Step 3: 回傳 0 // 無孩子，糖果數為 0  \n No  → // 進行左右兩次掃描  \n→ Step 4: 進行左到右掃描 // 第一趟確保左邊較高評分者得到更多糖果  \n → For i 從 1 到 n-1  \n  Decision: ratings[i] > ratings[i-1]?  \n   Yes → candies[i] = candies[i-1] + 1 // 右側孩子比左側高，給更多糖果  \n   No  → // 不變，保持 1  \n→ Step 5: 進行右到左掃描 // 第二趟確保右邊較高評分者得到更多糖果  \n → For i 從 n-2 到 0  \n  Decision: ratings[i] > ratings[i+1]?  \n   Yes → Decision: candies[i] <= candies[i+1]?  \n    Yes → candies[i] = candies[i+1] + 1 // 右側更高且目前糖果不足，調整  \n    No  → // 已經比右側多，保持不變  \n   No  → // 右側更低或相同，不變  \n→ Step 6: 計算總糖果數 // 將所有糖果加總得到答案  \n → sum = 0  \n → For i 從 0 到 n-1  \n  sum = sum + candies[i] // 累加  \n→ Step 7: 回傳 sum // 回傳最小總糖果數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def candy(self, ratings):\n        n = len(ratings)\n        if n == 0:\n            return 0\n        candies = [1] * n\n\n        # 左到右掃描：若右邊孩子評分更高，給多一顆糖果\n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n\n        # 右到左掃描：若左邊孩子評分更高，確保他得到更多糖果\n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n\n        return sum(candies)\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取評分列表。\n    支援「ratings = [1,2,3]」以及「[1,2,3]」兩種格式。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # 找出第一個 '[' 和最後一個 ']'\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        list_str = data[start:end + 1]\n    else:\n        list_str = data\n\n    try:\n        ratings = ast.literal_eval(list_str)\n        return ratings if isinstance(ratings, list) else []\n    except Exception:\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    ratings = parse_input(raw_input)\n    result = Solution().candy(ratings)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ratings = [1,0,2]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "ratings = [1,2,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode127.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for BFS shortest transformation sequence count. Steps: start, check if endWord in list, create set for words, BFS queue with (word, level), visited, while queue not empty, pop, if word == endWord return level, for each letter position generate all possible letters a-z, if newWord in set and not visited, enqueue newWord level+1, mark visited. After loop return 0. Use decision structures. Must use virtual code format: each line: \"Step\" or \"Decision:\" etc. Use arrows. Provide explanation after //.\n\nLet's craft step by step. Use Start, End. Use Decision nodes for if endWord not in list, etc. Use BFS queue.\n\nWe'll produce lines:\n\nStart // 程式開始\n→ Decision: 若 endWord 不在 wordList? // 檢查終點是否存在\n    Yes → Step 1: 回傳 0 // 無法轉換\n    No  → Step 2: 初始化 wordsSet ← wordList, visitedSet ← {}, queue ← [(beginWord, 1)] // 建立集合與佇列\n→ Step 3: While queue 非空? // 開始 BFS\n    Yes → Step 4: (currentWord, depth) ← queue.pop_front() // 取出當前單詞與深度\n    → Decision: 若 currentWord == endWord? // 是否到達終點\n        Yes → Step 5: 回傳 depth // 找到最短路徑長度\n        No  → Step 6: For each position i in currentWord  // 逐字母生成鄰居\n            → Step 7: For each letter c in 'a'..'z'\n                → Decision: 若 newWord ≠ currentWord 且 newWord 在 wordsSet 且未訪問? // 選擇合法鄰居\n                    Yes → Step 8: queue.push_back((newWord, depth+1)) // 加入佇列\n                    Yes → visitedSet.add(newWord) // 標記已訪問\n    → No → End // BFS 結束未找到終點\nEnd // 程式結束\n\nNeed to ensure syntax with arrow, decision etc.\n\nMake sure each line has virtual code step + space + // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始  \n→ Decision: 若 endWord 不在 wordList? // 檢查終點是否存在於字典  \n Yes → Step 1: 回傳 0 // 無法轉換，直接結束  \n No  → Step 2: 初始化 wordsSet ← wordList, visitedSet ← {}, queue ← [(beginWord, 1)] // 建立字典集合、已訪問集合與 BFS 佇列  \n→ Step 3: While queue 非空? // 開始 BFS 迴圈  \n Yes → Step 4: (currentWord, depth) ← queue.pop_front() // 取出佇列首元素  \n  → Decision: 若 currentWord == endWord? // 是否已達終點  \n   Yes → Step 5: 回傳 depth // 找到最短轉換序列長度  \n   No  → Step 6: For each position i in currentWord // 逐字母生成鄰居單詞  \n    → Step 7: For each letter c in 'a'..'z'  \n     → Decision: 若 newWord ≠ currentWord 且 newWord 在 wordsSet 且未訪問? // 選擇合法鄰居  \n      Yes → Step 8: queue.push_back((newWord, depth+1)) // 加入佇列  \n      Yes → visitedSet.add(newWord) // 標記已訪問  \n No  → End // BFS 結束未找到終點  \nEnd // 程式結束",
      "generated_code": "import sys\nfrom collections import deque\nimport ast\n\nclass Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        word_set = set(wordList)\n        if endWord not in word_set:\n            return 0\n\n        queue = deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in word_set:\n                        word_set.remove(new_word)\n                        queue.append((new_word, length + 1))\n        return 0\n\ndef parse_input(raw):\n    \"\"\"\n    將輸入字串轉成 dict，例如：\n    'beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]'\n    會轉成 {'beginWord': 'hit', 'endWord': 'cog', 'wordList': ['hot', 'dot']}\n    \"\"\"\n    # 替換成 dict 風格\n    raw = raw.replace('beginWord =', 'beginWord:')\n    raw = raw.replace('endWord =', 'endWord:')\n    raw = raw.replace('wordList =', 'wordList:')\n    raw = '{' + raw + '}'\n    # 用 ast.literal_eval 解析安全\n    return ast.literal_eval(raw)\n\nif __name__ == \"__main__\":\n    data = parse_input(sys.stdin.read().strip())\n    begin = data['beginWord']\n    end = data['endWord']\n    lst = data['wordList']\n    result = Solution().ladderLength(begin, end, lst)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpnqdj3znu.py\", line 39, in <module>\n    data = parse_input(sys.stdin.read().strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpnqdj3znu.py\", line 36, in parse_input\n    return ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x79b833cf7a90>"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "0",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp8gy9hxbc.py\", line 39, in <module>\n    data = parse_input(sys.stdin.read().strip())\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp8gy9hxbc.py\", line 36, in parse_input\n    return ast.literal_eval(raw)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 112, in literal_eval\n    return _convert(node_or_string)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 101, in _convert\n    return dict(zip(map(_convert, node.keys),\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 111, in _convert\n    return _convert_signed_num(node)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 85, in _convert_signed_num\n    return _convert_num(node)\n           ^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 76, in _convert_num\n    _raise_malformed_node(node)\n  File \"/usr/lib/python3.12/ast.py\", line 73, in _raise_malformed_node\n    raise ValueError(msg + f': {node!r}')\nValueError: malformed node or string on line 1: <ast.Name object at 0x7512148f7a90>"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode76.json",
    "problem_index_in_file": 0,
    "title": "Minimum Window Substring",
    "description_snippet": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, with arrow and explanations. Problem: Minimum Window Substring. We need to produce algorithm: sliding window, frequency map, etc.\n\nWe'll output Start, steps: Build frequency map for t, count needed unique chars, left=0, right=0, formed=0, min_len, min_start. Iterate over s, increment counts, check formed etc. While formed==required, try shrink.\n\nWe need to produce each line with // explanation.\n\nUse arrow \"→\" before each step.\n\nDecision nodes with Yes→/No→.\n\nLet's craft.\n\nMake sure each line contains \"虛擬碼步驟\" then space then \"// 解釋\".\n\nAlso ensure no actual code.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: 建立字元頻率表 needCount for t // 記錄 t 中每個字元需要的數量\n\n→ Step 2: 設定 required = 需要的不同字元數目 // 這個數值代表窗口中必須滿足多少種字元\n\n→ Step 3: 初始化左指標 left = 0, 右指標 right = 0 // 用於滑動窗口\n\n→ Step 4: 初始化窗口字元頻率表 windowCount 為空 // 用於跟蹤當前窗口內的字元數量\n\n→ Step 5: 初始化 formed = 0 // 當窗口滿足 required 時更新\n\n→ Step 6: 初始化最小窗口長度 minLen = 無限大, minStart = 0 // 用於儲存答案\n\n→ Decision: 如果 right < len(s) // 總是向右擴展窗口\n    Yes → Step 7: 取得 s[right] 為 char // 讀取右指標指向的字元\n    → Step 8: 在 windowCount 中增加 char 的計數 // 更新窗口字元頻率\n    → Decision: 如果 char 屬於 needCount 且 windowCount[char] == needCount[char] // 只在首次達到所需數量時更新 formed\n        Yes → Step 9: formed += 1 // 表示已滿足一種字元\n    → Step 10: right += 1 // 右指標向右移動\n\n→ Decision: 如果 formed == required // 目前窗口已滿足所有需要的字元\n    Yes → Step 11: 取得左指標指向的 char leftChar // 讀取左指標字元\n    → Step 12: 只要 leftChar 屬於 needCount 且 windowCount[leftChar] > needCount[leftChar] // 超過需求可收縮\n        Yes → Step 13: windowCount[leftChar] -= 1 // 減少左指標字元的計數\n        → Step 14: left += 1 // 左指標向右移動\n        → 再次檢查 Decision: 如果 still formed == required // 窗口仍滿足需求\n            Yes → Step 15: 如果 right - left < minLen // 找到更小窗口\n                Yes → Step 16: minLen = right - left\n                → Step 17: minStart = left // 記錄最小窗口起點\n            → Step 18: leftChar = s[left] // 準備收縮窗口\n            → Step 19: windowCount[leftChar] -= 1 // 移除左指標字元\n            → Step 20: left += 1 // 左指標向右移動\n            → Step 21: 如果 leftChar 屬於 needCount 且 windowCount[leftChar] < needCount[leftChar] // 失去需求\n                Yes → Step 22: formed -= 1 // 更新 formed\n    No  → // 若窗口不滿足需求，繼續向右擴張\n\n→ Step 23: 完成迴圈後 // 所有可能窗口已檢查完畢\n\n→ Decision: 如果 minLen == 無限大 // 沒有找到合法窗口\n    Yes → Step 24: 回傳 \"\" // 回傳空字串\n    No  → Step 25: 回傳 s[minStart:minStart+minLen] // 回傳最小窗口子字串\n\nEnd // 程式執行結束\n\nBut we need each line with arrow and explanation. Also we need decisions using Yes → / No →. For nested decisions, indent accordingly? They used indent in example. We'll follow same style.\n\nWe need to ensure each line is one step. But some steps like \"Step 11: 取得左指標指向的 char leftChar\" is part of while loop but fine.\n\nAlso need to be careful with decisions nested inside loops. Use indentation to show hierarchical.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字元頻率表 needCount 用於存儲 t 中每個字元需要的數量 // 先對 t 做一次頻率統計  \n→ Step 2: 設定 required = 需要的不同字元數目 // 代表窗口中必須同時包含多少種字元  \n→ Step 3: 初始化 left = 0, right = 0 // 兩個指標開始於字串 s 的起始位置  \n→ Step 4: 初始化窗口字元頻率表 windowCount 為空 // 用於追蹤當前窗口內的字元計數  \n→ Step 5: 初始化 formed = 0 // 當窗口中某字元的需求被滿足時會遞增  \n→ Step 6: 初始化 minLen = 無限大, minStart = 0 // 用於儲存目前找到的最小窗口資訊  \n→ Decision: right < len(s) // 循環向右擴張窗口  \n    Yes → Step 7: char = s[right] // 讀取右指標指向的字元  \n    → Step 8: 在 windowCount 中增加 char 的計數 // 更新窗口內的字元頻率  \n    → Decision: char 屬於 needCount 且 windowCount[char] == needCount[char] // 首次達到需求數量  \n        Yes → Step 9: formed += 1 // 表示此種字元已滿足需求  \n    → Step 10: right += 1 // 右指標右移，窗口擴張  \n→ Decision: formed == required // 當窗口已滿足所有需求字元  \n    Yes → Step 11: leftChar = s[left] // 讀取左指標指向的字元  \n    → Decision: leftChar 屬於 needCount 且 windowCount[leftChar] > needCount[leftChar] // 超過需求可收縮  \n        Yes → Step 12: windowCount[leftChar] -= 1 // 減少左邊字元的計數  \n        → Step 13: left += 1 // 左指標右移，窗口收縮  \n    → Step 14: 重複檢查 Decision: formed == required // 窗口仍滿足需求  \n        Yes → Step 15: 如果 right - left < minLen // 發現更小的窗口  \n            Yes → Step 16: minLen = right - left  \n            → Step 17: minStart = left // 記錄最小窗口起點  \n    → Step 18: leftChar = s[left] // 準備再次收縮左邊字元  \n    → Step 19: windowCount[leftChar] -= 1 // 移除左邊字元的計數  \n    → Step 20: left += 1 // 左指標右移  \n    → Decision: leftChar 屬於 needCount 且 windowCount[leftChar] < needCount[leftChar] // 失去需求字元  \n        Yes → Step 21: formed -= 1 // 更新 formed，表示此種字元已不再滿足需求  \n    No → // 若窗口不滿足需求，繼續向右擴張  \n→ Step 22: 循環結束後 // 已遍歷完 s，所有可能窗口已檢查完畢  \n→ Decision: minLen == 無限大 // 是否還未找到合法窗口  \n    Yes → Step 23: 回傳 \"\" // 無合法窗口，回傳空字串  \n    No → Step 24: 回傳 s[minStart:minStart+minLen] // 回傳最小窗口子字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if not s or not t:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = (float(\"inf\"), None, None)\n\n        while r < len(s):\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            while l <= r and formed == required:\n                character = s[l]\n                if r - l + 1 < ans[0]:\n                    ans = (r - l + 1, l, r)\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n                l += 1\n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]\n\ndef parse_input(text: str) -> tuple[str, str]:\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', text)\n    t_match = re.search(r't\\s*=\\s*\"([^\"]*)\"', text)\n    s = s_match.group(1) if s_match else \"\"\n    t = t_match.group(1) if t_match else \"\"\n    return s, t\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    s, t = parse_input(data)\n    result = Solution().minWindow(s, t)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"ADOBECODEBANC\", t = \"ABC\"",
          "expected_output": "\"BANC\"",
          "success": true,
          "output": "BANC"
        },
        {
          "example_index": 1,
          "input": "s = \"a\", t = \"a\"",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        },
        {
          "example_index": 2,
          "input": "s = \"a\", t = \"aa\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode420.json",
    "problem_index_in_file": 0,
    "title": "Strong Password Checker",
    "description_snippet": "A password is considered strong if the below conditions are all met:\n\nIt has at least 6 characters a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm that calculates minimum steps to make password strong. We need to provide step by step in virtual code style with comments. We need to cover algorithm: count missing types, count repeats, compute insertions, deletions, replacements etc.\n\nGoal: produce pseudo algorithm. Should be step-by-step.\n\nWe need to produce lines: Start, → Step etc.\n\nLet's outline algorithm:\n\nStart\n→ Step 1: Define variables: length, missingTypeCount, repeats list etc.\n\nSimplify: typical solution: compute missing types: lower, upper, digit.\n\nCompute repeats: find sequences of same char length >=3, store len.\n\nThen if length <6: need insertions = 6 - length. replacements needed for repeats: for each repeat length L, need L/3 replacements.\n\nBut insertions can reduce replacements: each insertion can break a repeat, so replacements reduce by insertions.\n\nIf length between 6-20: deletions 0. replacements = max(replacements, missingTypeCount)\n\nIf length >20: deletions needed = length-20. We should use deletions to reduce repeats: For sequences where len%3==0, each deletion reduces one replacement; len%3==1 requires two deletions; len%3==2 requires three deletions. So we greedily reduce replacements via deletions.\n\nFinally total steps = deletions + max(replacements, missingTypeCount)\n\nOk.\n\nWe'll produce lines accordingly.\n\nMake sure each line is \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n\nUse arrow \"→\" before each step.\n\nUse Decision blocks for if conditions.\n\nWe need to be mindful of indentation with arrow.\n\nWe'll produce something like:\n\nStart // 程式開始\n\n→ Step 1: 初始化變數 length, missingLower, missingUpper, missingDigit 等 // 取得密碼長度及缺少類型\n\n→ Step 2: 逐字檢查每個字符以判斷缺少的小寫、大寫、數字 // 計算缺失類型\n\n→ Step 3: 建立重複序列列表 repeats // 用於後續處理\n\n→ Step 4: 迭代密碼尋找連續相同字符，若長度>=3，將其長度存入 repeats // 收集重複資訊\n\n→ Decision: 若 length < 6? // 短密碼需插入\n\n    Yes → Step 5: insertions = 6 - length // 需要插入的數量\n\n    No  → Decision: 若 length <= 20? // 正常長度範圍\n\n        Yes → Step 6: deletions = 0 // 無需刪除\n\n        No  → Step 7: deletions = length - 20 // 需要刪除多餘字符\n\n→ Step 8: 初始化 replaceNeeded = 0 // 替換數量\n\n→ Step 9: For each repeatLen in repeats\n\n    → Step 9.1: replaceNeeded += repeatLen / 3 // 每三個相同字符至少一次替換\n\n→ Decision: 若 length > 20? // 使用刪除來降低替換\n\n    Yes → Step 10: For each repeatLen in repeats\n\n        → Decision: repeatLen % 3 == 0? // 優先刪除能減少一次替換\n\n            Yes → Step 10.1: deletionsUsed = min(deletions, 1)\n\n            → Step 10.2: repeatLen -= deletionsUsed\n\n            → Step 10.3: deletions -= deletionsUsed\n\n            → Step 10.4: replaceNeeded -= deletionsUsed // 每次刪除可減一替換\n\n        No → Decision: repeatLen % 3 == 1?\n\n            Yes → Step 10.5: deletionsNeeded = min(deletions, 2)\n\n            → Step 10.6: repeatLen -= deletionsNeeded\n\n            → Step 10.7: deletions -= deletionsNeeded\n\n            → Step 10.8: replaceNeeded -= deletionsNeeded / 2 // 每兩次刪除減一替換\n\n        No → Step 10.9: deletionsNeeded = min(deletions, 3)\n\n            → Step 10.10: repeatLen -= deletionsNeeded\n\n            → Step 10.11: deletions -= deletionsNeeded\n\n            → Step 10.12: replaceNeeded -= deletionsNeeded / 3 // 每三次刪除減一替換\n\n→ Decision: replaceNeeded < 0? // 若替換數量被降低至負值\n\n    Yes → Step 11: replaceNeeded = 0 // 置為0\n\n→ Step 12: missingTypes = missingLower + missingUpper + missingDigit // 缺少類型總數\n\n→ Step 13: steps = deletions + max(replaceNeeded, missingTypes) // 需要的總步驟\n\n→ End // 回傳 steps\n\nBut maybe we need to incorporate insertions in short case: replaceNeeded might be reduced by insertions. In short case, we also compute replaceNeeded for repeats but then effective replacements = max(replaceNeeded, missingTypes). However, insertions can also help reduce replacements: each insertion can break a repeat, so actual replacements = max(replaceNeeded, missingTypes) but we must account for insertions used to break repeats. Actually typical algorithm: If length < 6, we need insertions; replacements needed = max(replaceNeeded, missingTypes); but some replacements may be saved by insertions: the number of replacements needed after insertions = max(replaceNeeded, missingTypes); but if we have insertions > 0, we can use them to reduce repeats: reduce replaceNeeded by insertions. So final steps = insertions + max(replaceNeeded - insertions, missingTypes). But typical solution: steps = max(missingTypes, replaceNeeded) + insertions when length <6. Because insertions count as steps and can break repeats simultaneously. So we can keep simpler: steps = insertions + max(missingTypes, replaceNeeded). Good.\n\nLet's modify Step 13 accordingly:\n\nIf length < 6:\n\n    steps = insertions + max(replaceNeeded, missingTypes)\n\nElse:\n\n    steps = deletions + max(replaceNeeded, missingTypes)\n\nOk.\n\nSo we need to produce decision for that.\n\nLet's produce more structured pseudo code.\n\nWe'll produce each line with comment.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: length ← len(password) // 取得密碼長度  \n→ Step 2: missingLower ← 1, missingUpper ← 1, missingDigit ← 1 // 初始化缺失類型標誌  \n→ Step 3: repeats ← [] // 用於儲存連續相同字符的長度  \n→ Step 4: For each char c in password  \n    → Decision: 若 c 為小寫字母?  \n        Yes → missingLower ← 0 // 已有小寫字母  \n    → Decision: 若 c 為大寫字母?  \n        Yes → missingUpper ← 0 // 已有大寫字母  \n    → Decision: 若 c 為數字?  \n        Yes → missingDigit ← 0 // 已有數字  \n→ Step 5: i ← 0 // 索引  \n→ Step 6: While i < length  \n    → j ← i  \n    → Decision: 若 password[i] == password[j+1]?  \n        Yes → j ← j + 1 // 找到同一字符序列的結束位置  \n        No → i ← i + 1 // 移至下一個字符  \n    → Decision: 若 j - i + 1 ≥ 3?  \n        Yes → repeats.append(j - i + 1) // 存入長度  \n    → i ← j + 1 // 繼續搜尋  \n→ Step 7: missingTypes ← missingLower + missingUpper + missingDigit // 缺少類型總數  \n→ Step 8: replaceNeeded ← 0 // 初始替換需求  \n→ Step 9: For each r in repeats  \n    → replaceNeeded ← replaceNeeded + r / 3 // 每三個相同字符至少一次替換  \n→ Decision: 若 length < 6? // 密碼太短  \n    Yes → insertions ← 6 - length // 需要插入的字符數  \n    → Step 10: steps ← insertions + max(replaceNeeded, missingTypes) // 插入可同時破壞重複，最終步驟  \n    → End // 回傳結果  \n    No → Decision: 若 length ≤ 20? // 長度適中  \n        Yes → deletions ← 0 // 無需刪除  \n        → Step 11: steps ← max(replaceNeeded, missingTypes) // 只需替換或補類型  \n        → End // 回傳結果  \n        No → // 密碼太長  \n            → Step 12: deletions ← length - 20 // 需要刪除的字符數  \n            → Decision: 先利用刪除降低 replaceNeeded  \n                → For each r in repeats  \n                    → While r ≥ 3 AND deletions > 0  \n                        → Decision: r % 3 == 0?  \n                            Yes → r ← r - 1; deletions ← deletions - 1; replaceNeeded ← replaceNeeded - 1  \n                        → Decision: r % 3 == 1?  \n                            Yes → If deletions ≥ 2  \n                                → r ← r - 2; deletions ← deletions - 2; replaceNeeded ← replaceNeeded - 1  \n                        → Decision: r % 3 == 2?  \n                            Yes → If deletions ≥ 3  \n                                → r ← r - 3; deletions ← deletions - 3; replaceNeeded ← replaceNeeded - 1  \n            → Step 13: steps ← (length - 20) + max(replaceNeeded, missingTypes) // 刪除 + 最終需求  \n            → End // 回傳結果  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def strongPasswordChecker(self, s: str) -> int:\n        n = len(s)\n        has_lower = has_upper = has_digit = 0\n        for c in s:\n            if c.islower():\n                has_lower = 1\n            elif c.isupper():\n                has_upper = 1\n            elif c.isdigit():\n                has_digit = 1\n        missing_types = 3 - (has_lower + has_upper + has_digit)\n\n        replace = 0          # total replacements needed for repeats\n        one_mod = two_mod = 0 # counts of repeats with len%3==0 or 1\n        i = 2\n        while i < n:\n            if s[i] == s[i-1] == s[i-2]:\n                length = 2\n                while i < n and s[i] == s[i-1]:\n                    length += 1\n                    i += 1\n                replace += length // 3\n                if length % 3 == 0:\n                    one_mod += 1\n                elif length % 3 == 1:\n                    two_mod += 1\n            else:\n                i += 1\n\n        if n < 6:\n            return max(6 - n, missing_types)\n        elif n <= 20:\n            return max(replace, missing_types)\n        else:\n            delete = n - 20\n\n            # Reduce replacements by deleting in repeats with len%3==0\n            reduce = min(delete, one_mod)\n            replace -= reduce\n            delete -= reduce\n\n            # Reduce replacements by deleting in repeats with len%3==1\n            reduce = min(max(delete, 0), two_mod * 2) // 2\n            replace -= reduce\n            delete -= reduce * 2\n\n            # Remaining deletions reduce replacements in groups of 3\n            replace -= max(delete, 0) // 3\n\n            return (n - 20) + max(missing_types, replace)\n\ndef main():\n    data = sys.stdin.read().strip()\n    # Extract string inside double quotes, if present\n    m = re.search(r'\\\"(.*?)\\\"', data, re.DOTALL)\n    password = m.group(1) if m else data\n    sol = Solution()\n    steps = sol.strongPasswordChecker(password)\n    print(steps)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "password = \"a\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "password = \"aA1\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "password = \"1337C0d3\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode258.json",
    "problem_index_in_file": 0,
    "title": "Add Digits",
    "description_snippet": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps per line with explanation, following format. Use arrows, Start, Decision, etc. Steps: Input num, compute sum of digits, while sum has more than one digit, repeat. Finally output sum.\n\nWe need to use virtual code style: maybe \"Start // 程式開始執行\" etc. Provide lines.\n\nLet's produce:\n\nStart\n→ Step 1: Input integer num // 取得輸入數字\n→ Step 2: sum ← num // 初始化 sum 為 num\n→ Decision: sum 大於 9? // 判斷 sum 是否還有多於一位數\n    Yes → Step 3: sum ← sum 的各位數相加 // 計算 sum 的各位數和\n    No  → Decision: sum 是否為 0? // 處理特殊情況 0\n        Yes → Step 4: sum ← 0 // 直接設為 0\n        No  → End // 結束，sum 為一位數\nWait: Actually the algorithm is while sum > 9: sum = sumDigits(sum). After loop, output sum. So we can structure differently: While loop decision. Virtual code: Decision: sum > 9? Then Yes loop.\n\nThus:\n\nStart\n→ Step 1: Input integer num // 取得輸入數字\n→ Step 2: sum ← num // 初始化 sum 為 num\n→ Decision: sum > 9? // 判斷 sum 是否仍多於一位\n    Yes → Step 3: sum ← sum 的各位數相加 // 將 sum 轉為其各位數之和\n    → Decision: sum > 9? // 重複判斷\n        Yes → … 循環\n        No  → Step 4: 輸出 sum // sum 為一位數，輸出結果\n    No  → Step 4: 輸出 sum // 初始數字已為一位，直接輸出\nEnd\n\nBut need explicit loop. Maybe use \"Loop:\" block. However guidelines: use Decision, Yes→, No→.\n\nWe can emulate loop via recursion: after sum>9 Yes→ Step 3 and then go back to Decision. So we need to refer to earlier decision. Let's structure:\n\nStart\n→ Step 1: Input integer num // 取得輸入數字\n→ Step 2: sum ← num // 初始化 sum 為 num\n→ Decision: sum > 9? // 判斷 sum 是否仍多於一位\n    Yes → Step 3: sum ← sum 的各位數相加 // 計算 sum 的各位數和\n    → Decision: sum > 9? // 再次判斷是否需要繼續\n        Yes → Step 3 // 重新執行 Step 3，形成迴圈\n        No  → Step 4: 輸出 sum // sum 為一位數，輸出結果\n    No  → Step 4: 輸出 sum // 初始數字已為一位，直接輸出\nEnd\n\nBut need to indicate the loop more clearly. We can also use \"Repeat Until\" but not in format. Could use \"Decision: sum > 9?\" Yes→\"Loop: sum ← sum 的各位數相加\" No→output.\n\nLet's produce final answer with lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 num // 取得使用者輸入的整數  \n→ Step 2: sum ← num // 把 num 存到 sum 以便後續運算  \n→ Decision: sum > 9? // 判斷 sum 是否還有多於一位數  \n    Yes → Step 3: sum ← sum 的各位數相加 // 計算 sum 的各位數之和  \n    → Decision: sum > 9? // 再次檢查 sum 是否還需要繼續累加  \n        Yes → Step 3 // 重新執行 Step 3，形成迴圈  \n        No  → Step 4: 輸出 sum // sum 已是一位數，輸出結果  \n    No  → Step 4: 輸出 sum // 初始數字已為一位，直接輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef add_digits(num: int) -> int:\n    \"\"\"重複將數字各位相加，直到只剩一位為止。\"\"\"\n    while num >= 10:\n        num = sum(int(d) for d in str(num))\n    return num\n\ndef main() -> None:\n    \"\"\"從標準輸入讀取資料、計算結果並輸出。\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中尋找第一個整數（允許負號）\n    match = re.search(r'-?\\d+', data)\n    num = int(match.group()) if match else 0\n\n    result = add_digits(num)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 38",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode205.json",
    "problem_index_in_file": 0,
    "title": "Isomorphic Strings",
    "description_snippet": "Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for determining if two strings are isomorphic. Should be step-by-step. Use Start, Decision, End. Use arrow and explanation. Each line must be \"虛擬碼步驟 // 解釋\". Format: Start // 程式開始執行, etc. Provide steps. Use Decision: if length mismatch? etc. Then mapping using two hash maps. Use decision for mapping consistency.\n\nWe will produce lines accordingly. Use 虛擬碼 steps like:\n\nStart // 開始程式\n→ Step 1: 檢查 s 與 t 長度是否相同 // 如果不同，直接回傳 False\n→ Decision: 長度相同? // ...\n    Yes → Step 2: 初始化映射表 mapS, mapT // 用來存 s→t 與 t→s 的對應關係\n    No → Step 3: 輸出 False // 長度不同，非同構\n...\nIterate i from 0 to len-1:\n→ Step 4: 取得 s[i], t[i] // 取目前字元\n→ Decision: s[i] 是否已在 mapS? // ...\n   Yes → Step 5: 檢查 mapS[s[i]] 是否等於 t[i] // 如果不等，返回 False\n   No  → Step 6: Decision: t[i] 是否已在 mapT? // 檢查 t 目標是否已被映射\n         Yes → Step 7: 返回 False // 同一個 t 已被映射到不同 s\n         No  → Step 8: 設定 mapS[s[i]] = t[i]，mapT[t[i]] = s[i] // 建立雙向映射\n...\nAfter loop:\n→ Step 9: 輸出 True // 所有檢查通過\nEnd // 程式結束\n\nWe need each line with explanation. Use \"虛擬碼步驟 // 解釋\". Ensure no actual code but description.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查 s 與 t 的長度是否相同 // 若長度不同即為非同構  \n→ Decision: 長度相同? // 判斷是否繼續進行映射檢查  \n Yes → Step 2: 初始化兩個映射表 mapS 與 mapT // 分別儲存 s→t 與 t→s 的對應關係  \n No  → Step 3: 輸出 False // 長度不等，直接判定非同構  \n→ Step 4: 設定 i = 0 // 初始化迴圈索引  \n→ Decision: i < s.length? // 判斷是否已遍歷完所有字元  \n Yes → Step 5: 取得 s[i] 與 t[i] // 取目前索引的兩個字元  \n  Decision: s[i] 是否已存在於 mapS? // 檢查 s 的字元是否已映射  \n   Yes → Step 6: 檢查 mapS[s[i]] 是否等於 t[i] // 若不相等則映射不一致  \n    Yes → Step 7: i = i + 1 → 回到 Decision: i < s.length? // 進一步遍歷  \n    No  → Step 8: 輸出 False // 映射不一致，非同構  \n   No  → Step 9: Decision: t[i] 是否已存在於 mapT? // 檢查 t 的字元是否已被其他 s 映射  \n    Yes → Step 10: 輸出 False // t 的字元已被映射，非同構  \n    No  → Step 11: mapS[s[i]] = t[i] // 建立 s→t 的映射  \n       mapT[t[i]] = s[i] // 同時建立 t→s 的映射  \n       i = i + 1 → 回到 Decision: i < s.length? // 完成映射後繼續遍歷  \n       End // 迴圈結束後完成所有檢查  \n       Step 12: 輸出 True // 所有字元均符合同構條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_isomorphic(s: str, t: str) -> bool:\n    \"\"\"判斷兩個字串是否同構。\"\"\"\n    if len(s) != len(t):\n        return False\n\n    map_s_t = {}\n    map_t_s = {}\n\n    for c1, c2 in zip(s, t):\n        # 檢查 s → t 的映射是否已經存在且一致\n        if c1 in map_s_t and map_s_t[c1] != c2:\n            return False\n        # 檢查 t → s 的映射是否已經存在且一致\n        if c2 in map_t_s and map_t_s[c2] != c1:\n            return False\n        # 建立雙向映射\n        map_s_t[c1] = c2\n        map_t_s[c2] = c1\n\n    return True\n\ndef main() -> None:\n    # 讀取整個輸入\n    data = sys.stdin.read()\n\n    # 以雙引號包住的字串作為 s、t\n    quoted = re.findall(r'\"([^\"]*)\"', data)\n    if len(quoted) >= 2:\n        s, t = quoted[0], quoted[1]\n    else:\n        # 若輸入沒有引號，則嘗試簡單解析\n        # 例：s = egg, t = add\n        parts = data.replace('\\n', ' ').split(',')\n        try:\n            s = parts[0].split('=')[1].strip()\n            t = parts[1].split('=')[1].strip()\n        except Exception:\n            # 若解析失敗則直接輸出 false\n            print('false')\n            return\n\n    result = is_isomorphic(s, t)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"egg\", t = \"add\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"foo\", t = \"bar\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"paper\", t = \"title\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode412.json",
    "problem_index_in_file": 0,
    "title": "Fizz Buzz",
    "description_snippet": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for FizzBuzz in lines. Use Start, End, Decision, arrow, etc. Provide explanation after each line. Must not output actual code. Must be in Traditional Chinese. Let's produce. Ensure each line ends with // explanation. Use 'Step' etc.\n\nMake sure we follow format: \"虛擬碼步驟 [space] // 解釋\". Use arrow →. Also use Decision blocks with indentation. Provide line numbers maybe? Not necessary but can use Step 1 etc.\n\nLet's produce.\n\nWe should have:\n\nStart // 開始執行\n→ Step 1: 初始化 answer 陣列長度 n+1 // 建立大小為 n+1 的字串陣列 (1-indexed)\n→ Step 2: 從 1 迴圈到 n // 設定迴圈遍歷每個數字\n    → Decision: i divisible by 3 and 5? // 檢查是否同時為 3 與 5 的倍數\n        Yes → Step 3: answer[i] = \"FizzBuzz\" // 設定為 \"FizzBuzz\"\n        No  → Decision: i divisible by 3? // 檢查是否為 3 的倍數\n            Yes → Step 4: answer[i] = \"Fizz\" // 設定為 \"Fizz\"\n            No  → Decision: i divisible by 5? // 檢查是否為 5 的倍數\n                Yes → Step 5: answer[i] = \"Buzz\" // 設定為 \"Buzz\"\n                No  → Step 6: answer[i] = string(i) // 設定為數字字串\n→ Step 7: 返回 answer[1..n] // 回傳結果陣列\nEnd // 執行結束\n\nBut need to ensure 'Step' numbering maybe not necessary but good.\n\nMake sure arrow lines have proper indentation. Provide explanation after each line. No code. Provide \"→\" arrow. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 answer 陣列長度為 n+1 // 建立 1-indexed 字串陣列  \n→ Step 2: 從 i = 1 到 n 逐一迴圈 // 遍歷每個數字  \n  → Decision: i 同時可被 3 與 5 整除？ // 檢查是否為 15 的倍數  \n   Yes → Step 3: answer[i] = \"FizzBuzz\" // 兩倍數都符合，設定為 \"FizzBuzz\"  \n   No → Decision: i 可被 3 整除？ // 檢查是否為 3 的倍數  \n    Yes → Step 4: answer[i] = \"Fizz\" // 只有 3 的倍數，設定為 \"Fizz\"  \n    No → Decision: i 可被 5 整除？ // 檢查是否為 5 的倍數  \n     Yes → Step 5: answer[i] = \"Buzz\" // 只有 5 的倍數，設定為 \"Buzz\"  \n     No → Step 6: answer[i] = string(i) // 以上條件皆不滿足，設定為數字字串  \n→ Step 7: 回傳 answer[1..n] // 將結果陣列返回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\ndef fizzbuzz(n: int):\n    \"\"\"產生 FizzBuzz 結果，回傳字串列表。\"\"\"\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n\ndef main():\n    # 從標準輸入讀取資料，提取第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    # 計算結果並以 JSON 格式輸出（使用雙引號）\n    answer = fizzbuzz(n)\n    print(json.dumps(answer))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"1\",\"2\",\"Fizz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\"]"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"]"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
          "success": true,
          "output": "[\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode150.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Reverse Polish Notation",
    "description_snippet": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polis...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for evaluating Reverse Polish Notation expression, with array tokens. Use stack. Steps: Start, iterate over tokens, if number push, if operator pop two, compute result with division truncation toward zero, push result. After loop, pop final result. End. Provide line-by-line. Use arrows. Provide explanation after each line. Must not output actual code. Use \"Step\" lines with tokens. Use Decision if token is operator? Might use if-else. Provide final End. Ensure to mention division truncation.\n\nLet's craft.\n\nWe need to be careful: Use Virtual code style.\n\nLet's produce:\n\nStart // 開始執行\n→ Step 1: 創建空棧 stack // 用來儲存中間數值\n→ Step 2: 循環遍歷 tokens 中每個元素 token // 逐一處理輸入\n    → Decision: token 是否為運算符號 ('+', '-', '*', '/') ?\n        Yes → Step 3: 從棧中彈出右操作數 operand2 // 先彈右\n        → Step 4: 從棧中彈出左操作數 operand1 // 再彈左\n        → Step 5: 根據 token 計算 result // 執行相應運算\n            → Decision: token 為 '/' ?\n                Yes → Step 6: result ← trunc_division(operand1, operand2) // 截斷向零\n                No  → Decision: token 為 '+' ?\n                    Yes → Step 7: result ← operand1 + operand2\n                    No  → Decision: token 為 '-' ?\n                        Yes → Step 8: result ← operand1 - operand2\n                        No  → Step 9: result ← operand1 * operand2\n        → Step 10: 將 result 推回棧 // 存回中間結果\n        No  → Step 11: 將 token 轉為整數並推入棧 // 數字直接入棧\nEnd // 迴圈結束，輸入已全部處理\n→ Step 12: 從棧中彈出最終結果 result // 結果即為表達式值\n→ Step 13: 返回 result // 給呼叫者\n\nNeed to maintain correct indentation. Also include explanation comments after each line. Provide arrows etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 創建空棧 stack // 用來儲存中間計算結果  \n→ Step 2: 循環遍歷 tokens 中每個元素 token // 逐一處理輸入  \n  → Decision: token 是否為運算符號 ('+', '-', '*', '/') ? // 判斷是數字還是運算符  \n   Yes → Step 3: 從棧中彈出右操作數 operand2 // 先彈右邊的數字  \n   → Step 4: 從棧中彈出左操作數 operand1 // 再彈左邊的數字  \n   → Step 5: 根據 token 計算 result // 執行相應的運算  \n     → Decision: token 為 '/' ? // 特殊處理除法的截斷向零  \n      Yes → Step 6: result ← trunc_division(operand1, operand2) // 截斷向零的除法  \n      No  → Decision: token 為 '+' ?  \n       Yes → Step 7: result ← operand1 + operand2 // 加法  \n       No  → Decision: token 為 '-' ?  \n        Yes → Step 8: result ← operand1 - operand2 // 減法  \n        No  → Step 9: result ← operand1 * operand2 // 乘法  \n   → Step 10: 將 result 推回棧 // 把計算結果存回棧中  \n   No  → Step 11: 將 token 轉為整數並推入棧 // 數字直接入棧  \nEnd // 迴圈結束，所有 token 已處理完  \n→ Step 12: 從棧中彈出最終結果 result // 把最後剩餘的數字取出  \n→ Step 13: 返回 result // 將結果回傳給呼叫者",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in '+-*/':\n                b = stack.pop()\n                a = stack.pop()\n                if token == '+':\n                    stack.append(a + b)\n                elif token == '-':\n                    stack.append(a - b)\n                elif token == '*':\n                    stack.append(a * b)\n                else:  # token == '/'\n                    # 除法結果向零截斷\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack.pop()\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 處理可能的前綴 \"tokens =\"\n    if raw_input.lower().startswith(\"tokens\"):\n        _, expr = raw_input.split('=', 1)\n        raw_input = expr.strip()\n\n    # 使用 ast.literal_eval 解析列表，確保安全\n    tokens = ast.literal_eval(raw_input)\n\n    result = Solution().evalRPN(tokens)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
          "expected_output": "9",
          "success": true,
          "output": "9"
        },
        {
          "example_index": 1,
          "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
          "expected_output": "22",
          "success": true,
          "output": "22"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode90.json",
    "problem_index_in_file": 0,
    "title": "Subsets II",
    "description_snippet": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating power set with duplicates removal. Should be iterative/backtracking? We need to output steps line by line. The format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow, decision. For duplicates, we sort and skip duplicates.\n\nLet's craft. We'll include steps: Start, sort array, define result list, define helper recursion. In recursion, add current subset to result, loop from start index to end, skip duplicates if nums[i]==nums[i-1] and i>start. Add nums[i] to subset, recurse with i+1, then pop.\n\nLet's produce lines accordingly. Ensure arrow usage: \"→ Step X: ...\" Use \"Decision:\" lines for if condition.\n\nWe need to list each line as separate. Let's count.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續跳過重複項目\n→ Step 2: 初始化 result 為空集合 // 用於儲存所有子集\n→ Step 3: 初始化空子集 current // 當前正在構造的子集\n→ Step 4: 定義遞迴函數 backtrack(start) // 用於產生子集\n    → Step 5: Add copy of current to result // 將目前子集加入結果\n    → Decision: 是否已到陣列結尾? // 檢查是否還有元素可選\n        Yes → Return // 若已結束，回到上一層\n        No  → \n            → For i from start to len(nums)-1 // 遍歷剩餘元素\n                → Decision: i>start AND nums[i]==nums[i-1]? // 檢查是否為重複項且非首位\n                    Yes → Continue // 跳過重複項\n                    No  → \n                        → Step 6: current.append(nums[i]) // 加入元素到子集\n                        → Step 7: backtrack(i+1) // 以下一個位置為起點遞迴\n                        → Step 8: current.pop() // 移除最後加入的元素，回溯\n→ Step 9: 呼叫 backtrack(0) // 從索引 0 開始遞迴\n→ Step 10: 返回 result // 回傳所有子集\n\nEnd // 程式執行結束\n\nBut we need arrow and indentation. Use \"→\" at each line. For nested lines, indent accordingly. Use \"Decision:\" line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 先將陣列排序，方便後續跳過重複項目\n→ Step 2: 初始化 result 為空集合 // 用於儲存所有子集\n→ Step 3: 初始化空子集 current // 當前正在構造的子集\n→ Step 4: 定義遞迴函數 backtrack(start) // 用於產生子集\n    → Step 5: Add copy of current to result // 將目前子集加入結果\n    → Decision: 是否已到陣列結尾? // 檢查是否還有元素可選\n        Yes → Return // 若已結束，回到上一層\n        No  →\n            → For i from start to len(nums)-1 // 遍歷剩餘元素\n                → Decision: i>start AND nums[i]==nums[i-1]? // 檢查是否為重複項且非首位\n                    Yes → Continue // 跳過重複項\n                    No  →\n                        → Step 6: current.append(nums[i]) // 加入元素到子集\n                        → Step 7: backtrack(i+1) // 以下一個位置為起點遞迴\n                        → Step 8: current.pop() // 移除最後加入的元素，回溯\n→ Step 9: 呼叫 backtrack(0) // 從索引 0 開始遞迴\n→ Step 10: 返回 result // 回傳所有子集\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def subsetsWithDup(self, nums):\n        \"\"\"Return all unique subsets of nums, which may contain duplicates.\"\"\"\n        nums.sort()                     # 先排序，方便後續去重\n        res = [[]]                      # 初始子集集合\n        for num in nums:                # 對每個元素進行擴張\n            new_subsets = []\n            for subset in res:\n                new_subsets.append(subset + [num])\n            res += new_subsets\n        # 去除重複子集\n        seen = set()\n        unique = []\n        for subset in res:\n            t = tuple(subset)\n            if t not in seen:\n                seen.add(t)\n                unique.append(subset)\n        return unique\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入，格式預期為「nums = [1,2,2]」或直接是列表字面量\n    try:\n        _, expr = data.split('=', 1)\n    except ValueError:\n        expr = data\n    expr = expr.strip()\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = eval(expr, {})\n    sol = Solution()\n    result = sol.subsetsWithDup(nums)\n    # 產生不含空格的子集字串表示，符合範例輸出格式\n    subsets_str = []\n    for subset in result:\n        subset_str = '[' + ','.join(str(x) for x in subset) + ']'\n        subsets_str.append(subset_str)\n    output = '[' + ','.join(subsets_str) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[],[0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode415.json",
    "problem_index_in_file": 0,
    "title": "Add Strings",
    "description_snippet": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations. The problem: add two non-negative integers given as strings, return string sum. No big integer libs, no converting to ints directly.\n\nWe should produce algorithm similar to manual addition: iterate from end of strings, carry, accumulate digits, produce reversed result, reverse it.\n\nWe need to output in virtual code format: each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Use arrows. For loops and decisions.\n\nLet's produce:\n\nStart // start\n\n→ Step 1: 初始化指標 i = len(num1)-1, j = len(num2)-1, carry = 0, result = empty list // set up indices and carry\n\n→ Step 2: 初始化空結果字符串 builder // placeholder\n\n→ Decision: 是否還有剩餘位或進位? // check loop condition\n\nYes → Step 3: 取 digit1 = int(num1[i]) if i>=0 else 0 // get digit from num1 or 0\n\n→ Step 4: 取 digit2 = int(num2[j]) if j>=0 else 0 // get digit from num2 or 0\n\n→ Step 5: sum = digit1 + digit2 + carry // compute sum\n\n→ Step 6: carry = sum / 10 // integer division\n\n→ Step 7: result.append(sum % 10) // store digit\n\n→ Step 8: i = i-1, j = j-1 // move to next digits\n\n→ Decision: 循環結束? // loop again\n\n(Yes loop back) No → Step 9: 若 carry > 0 则 result.append(carry) // add final carry\n\n→ Step 10: reverse result list and join to string // produce final string\n\n→ End // end\n\nWe need to maintain virtual code syntax: Use arrows, decision indentation. Provide explanation comments.\n\nAlso we should avoid actual code; use virtual steps. Use \"Step\" maybe.\n\nUse \"→ Step X:\" format.\n\nLet's produce lines accordingly.\n\nBe mindful of using proper indentation for decisions: The sample shows indentation for nested decisions: they used \"Yes →\" on same line but nested lines have indentation.\n\nWe'll do:\n\nDecision: 是否還有剩餘位或進位? // while i>=0 or j>=0 or carry>0\n    Yes → Step ... // actions inside loop\n    No  → Step ... // after loop\n\nBut we need to show loop steps.\n\nSimplify: Use a while loop representation as Decision with Yes and No.\n\nWe can show the loop as:\n\nDecision: i>=0 or j>=0 or carry>0? // Continue adding digits\n\nYes → Step 3: digit1 = ... // inside loop\n\nThen we need to go back to decision after step 8.\n\nBut to represent loop back we can just use arrow to previous decision or note that after step 8 we go to Decision again. We could show \"→ Decision: i>=0 or j>=0 or carry>0? // 循環回頭\" after step 8.\n\nBut the sample uses \"Yes → Step\" then after that the next lines can go to next step, and at the end they have nested decision inside.\n\nLet's produce as:\n\nDecision: i>=0 or j>=0 or carry>0? // 是否還有要加的位\n    Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0 // 從 num1 取位數，若無則 0\n    → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0 // 從 num2 取位數，若無則 0\n    → Step 5: sum = digit1 + digit2 + carry // 兩位數與進位相加\n    → Step 6: carry = sum / 10 // 計算新的進位\n    → Step 7: result.append(sum % 10) // 將單位數加入結果\n    → Step 8: i = i - 1, j = j - 1 // 移動到更高位\n    → Decision: i>=0 or j>=0 or carry>0? // 循環回頭\n        Yes → ... (but this would be recursive) Actually we can skip this by using loop representation.\n\nAlternatively we can show a simple loop: Start, while condition.\n\nBut they want virtual code, not actual code. Use \"Decision:\" inside loop to continue.\n\nMaybe easier: Represent algorithm as:\n\nStart\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = []\n→ Step 2: // 循環：當 i>=0 或 j>=0 或 carry>0 時執行\n    → Decision: i>=0 or j>=0 or carry>0? \n        Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0\n        → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0\n        → Step 5: sum = digit1 + digit2 + carry\n        → Step 6: carry = sum / 10\n        → Step 7: result.append(sum % 10)\n        → Step 8: i = i - 1, j = j - 1\n        → Decision: i>=0 or j>=0 or carry>0? // 循環回頭\n        No → Step 9: if carry>0 then result.append(carry)\n        → Step 10: reverse result and join to string\nEnd\n\nBut we need to produce linear lines; indent for nested decisions. The sample shows nested Decision with Yes/No lines.\n\nWe can produce:\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化索引、進位與暫存結果\n→ Step 2: // 循環：當還有未處理的位或進位存在時\n    → Decision: i>=0 or j>=0 or carry>0? // 檢查是否需要繼續加法\n        Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0 // 取 num1 的當前位，若超過範圍則 0\n        → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0 // 取 num2 的當前位，若超過範圍則 0\n        → Step 5: sum = digit1 + digit2 + carry // 計算兩位數與進位之和\n        → Step 6: carry = sum / 10 // 計算新的進位\n        → Step 7: result.append(sum % 10) // 將單位數加入暫存結果\n        → Step 8: i = i - 1, j = j - 1 // 移動到更高位\n        → Decision: i>=0 or j>=0 or carry>0? // 循環回頭\n        No  → Step 9: if carry > 0 then result.append(carry) // 若最後還有進位，加入結果\n        → Step 10: reverse result and join to string // 逆轉結果並轉為字串\nEnd // 程式執行結束\n\nBut indentation might not be proper. In sample, they had:\n\nDecision: 如果數字大於 0?\n    Yes → Step 2: ...\n    No  → Decision: 如果數字等於 0?\n        Yes → Step 3: ...\n\nThus for our nested decisions, we need to indent the inner decisions relative to the outer. For the while loop, we might use a decision with Yes and No, but the loop continues after Yes until No. We can mimic with:\n\nDecision: i>=0 or j>=0 or carry>0?\n    Yes → Step 3: ...\n    → ... (rest steps)\n    → Decision: i>=0 or j>=0 or carry>0?\n    No  → Step 9: ...\n\nBut maybe too messy.\n\nBetter to use a simpler representation:\n\nStart\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = []\n→ Step 2: // 循環: while i>=0 or j>=0 or carry>0\n    → Decision: i>=0 or j>=0 or carry>0?\n        Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0\n        → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0\n        → Step 5: sum = digit1 + digit2 + carry\n        → Step 6: carry = sum / 10\n        → Step 7: result.append(sum % 10)\n        → Step 8: i = i - 1, j = j - 1\n        → Decision: i>=0 or j>=0 or carry>0? // continue loop\n        No → Step 9: if carry > 0 then result.append(carry)\n        → Step 10: reverse result and join to string\nEnd\n\nBut still the loop may not be clear.\n\nAlternatively, we can use a while loop step: \"→ Step 2: while i>=0 or j>=0 or carry>0: ...\", but they want virtual code with arrows, not actual code.\n\nMaybe simpler: Show steps:\n\nStart\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = []\n→ Step 2: // 進行加法循環\n    → Decision: i>=0 or j>=0 or carry>0?\n        Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0\n        → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0\n        → Step 5: sum = digit1 + digit2 + carry\n        → Step 6: carry = sum / 10\n        → Step 7: result.append(sum % 10)\n        → Step 8: i = i - 1, j = j - 1\n        → Decision: i>=0 or j>=0 or carry>0? // loop back\n        No → Step 9: if carry > 0 then result.append(carry)\n        → Step 10: reverse result and join to string\nEnd\n\nThe indentation for nested decisions might look like:\n\nDecision: i>=0 or j>=0 or carry>0?\n    Yes → Step 3: ...\n    → Step 4: ...\n    ...\n    → Decision: i>=0 or j>=0 or carry>0? // loop\n    No  → Step 9: ...\n\nBut we need to indent the inner decision relative to the outer.\n\nIn sample, they used:\n\nDecision: If num>0?\n    Yes → Step ...\n    No → Decision: If num==0?\n        Yes → Step ...\n        No → Step ...\n\nSo we need to indent the inner decision under the No line of the outer decision. But for loop, it's not a simple Yes/No. But we can treat the loop as a repeated decision, with Yes leading to steps and then back to decision, and No leads to final steps.\n\nThus, we can structure:\n\nDecision: i>=0 or j>=0 or carry>0?\n    Yes → Step 3: ...\n    → Step 4: ...\n    → Step 5: ...\n    → Step 6: ...\n    → Step 7: ...\n    → Step 8: ...\n    → Decision: i>=0 or j>=0 or carry>0? // loop again\n    No  → Step 9: ...\n    → Step 10: ...\nEnd\n\nBut this is a bit odd.\n\nMaybe we can use \"Loop: while i>=0 or j>=0 or carry>0\" as a step, and inside show the steps. But they want to use Decision and arrows.\n\nAlternatively, we can use \"→ Step 2: // 開始迴圈\" and then \"→ Decision: i>=0 or j>=0 or carry>0?\" with Yes leading to inner steps and then arrow back to Decision.\n\nBut the output may be messy.\n\nGiven the guidelines, we should produce a concise representation that follows the format. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化指標、進位與暫存結果\n→ Step 2: // 進行加法迴圈\n    → Decision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n        Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0 // 取得 num1 當前位數，若超出則 0\n        → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0 // 取得 num2 當前位數，若超出則 0\n        → Step 5: sum = digit1 + digit2 + carry // 兩位數與進位相加\n        → Step 6: carry = sum / 10 // 計算進位\n        → Step 7: result.append(sum % 10) // 存儲單位數到結果\n        → Step 8: i = i - 1, j = j - 1 // 移動到更高位\n        → Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否繼續迴圈\n        No  → Step 9: if carry > 0 then result.append(carry) // 加上最後進位\n        → Step 10: reverse result and join to string // 逆轉結果並轉為字串\nEnd // 程式執行結束\n\nBut indentation for nested decisions: we need to indent inner Decision under Yes branch.\n\nIn sample, they had:\n\nDecision: 如果數字大於 0?\n    Yes → Step 2: ...\n    No  → Decision: 如果數字等於 0?\n\nSo the inner Decision is aligned under No, not under Yes. For our loop, we want the inner Decision to be under Yes, after performing steps.\n\nThus:\n\nDecision: i>=0 or j>=0 or carry>0?\n    Yes → Step 3: ...\n    → Step 4: ...\n    → Step 5: ...\n    → Step 6: ...\n    → Step 7: ...\n    → Step 8: ...\n    → Decision: i>=0 or j>=0 or carry>0?\n    No  → Step 9: ...\n\nBut we must indent the inner Decision under Yes? Not exactly; we can indent it same as the previous lines.\n\nMaybe we can simplify: Use a \"Loop:\" step:\n\n→ Step 2: // 進行加法迴圈\n    → Decision: i>=0 or j>=0 or carry>0?\n        Yes → Step 3: ...\n        → Step 4: ...\n        → Step 5: ...\n        → Step 6: ...\n        → Step 7: ...\n        → Step 8: ...\n        → Decision: i>=0 or j>=0 or carry>0? // loop again\n        No → Step 9: ...\n        → Step 10: ...\n\nBut still messy.\n\nAlternatively, we can avoid nested decisions and represent loop as repeated \"while\" statement:\n\n→ Step 2: while i>=0 or j>=0 or carry>0:\n        // inside loop: steps 3-8\n\nBut that may break the \"Decision:\" rule.\n\nHowever, sample used \"Decision:\" for if statements, but not for while loops. The guidelines mention using arrows and structure Start, End, Decision: but doesn't say while must be Decision. But using \"Decision:\" for while is okay.\n\nI think the simplest representation is to use \"Decision:\" for the loop condition and show that Yes leads to steps, then back to Decision, and No leads to final steps.\n\nBut how to indicate the loop back? We can show the inner Decision after the steps, with No leading to final steps.\n\nThus:\n\nDecision: i>=0 or j>=0 or carry>0?\n    Yes → Step 3: digit1 = ...\n    → Step 4: digit2 = ...\n    → Step 5: sum = ...\n    → Step 6: carry = ...\n    → Step 7: result.append(...)\n    → Step 8: i = i-1, j = j-1\n    → Decision: i>=0 or j>=0 or carry>0? // loop back\n    No  → Step 9: if carry > 0 then result.append(carry)\n    → Step 10: reverse result and join to string\n\nBut this still has nested Decision inside Yes. In sample, nested Decision is inside No. But we can keep it inside Yes.\n\nWe need to preserve indentation. Let's write:\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化指標、進位與暫存結果\n→ Decision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n    Yes → Step 2: digit1 = (i>=0) ? int(num1[i]) : 0 // 取得 num1 當前位數，若超出則 0\n    → Step 3: digit2 = (j>=0) ? int(num2[j]) : 0 // 取得 num2 當前位數，若超出則 0\n    → Step 4: sum = digit1 + digit2 + carry // 兩位數與進位相加\n    → Step 5: carry = sum / 10 // 計算進位\n    → Step 6: result.append(sum % 10) // 存儲單位數到結果\n    → Step 7: i = i - 1, j = j - 1 // 移動到更高位\n    → Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否繼續迴圈\n    No  → Step 8: if carry > 0 then result.append(carry) // 加上最後進位\n    → Step 9: reverse result and join to string // 逆轉結果並轉為字串\nEnd // 程式執行結束\n\nBut the indentation may mislead.\n\nMaybe better to structure:\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化索引、進位、暫存結果\n→ Decision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n    Yes → Step 2: digit1 = (i>=0) ? int(num1[i]) : 0 // 取得 num1 的當前位數，若不存在則 0\n    → Step 3: digit2 = (j>=0) ? int(num2[j]) : 0 // 取得 num2 的當前位數，若不存在則 0\n    → Step 4: sum = digit1 + digit2 + carry // 計算兩位與進位之和\n    → Step 5: carry = sum / 10 // 取得進位\n    → Step 6: result.append(sum % 10) // 存儲單位數到暫存結果\n    → Step 7: i = i - 1, j = j - 1 // 移動到更高位\n    → Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否需要繼續\n    No  → Step 8: if carry > 0 then result.append(carry) // 若最後還有進位，加入結果\n    → Step 9: reverse result and join to string // 逆轉並合併成字串\nEnd // 程式執行結束\n\nBut this still has the inner Decision under the Yes branch but not nested under the outer Yes.\n\nActually, the sample shows nested Decision under No, but we can have nested Decision under Yes, it's okay.\n\nAlternatively, we could use \"Loop: while i>=0 or j>=0 or carry>0\" but guidelines not strict.\n\nI think the representation above is acceptable.\n\nBut we need to ensure that each line includes the \"→\" arrow and the step number, then comment. For decision lines, we use \"Decision:\".\n\nMake sure each line ends with comment // 解釋. Use short explanations.\n\nAlso maintain proper indentation for nested Decision. Use 4 spaces indent for nested lines? The sample used 4 spaces indent for nested lines: \"    Yes →\".\n\nSo we should follow that: For nested lines under Decision, indent 4 spaces. For the lines after inner decision's Yes branch, indent 8 spaces? Actually in sample:\n\nDecision: ...\n    Yes → Step ...\n    No  → Decision: ...\n        Yes → Step ...\n        No  → Step ...\n\nThus indentation increases each level.\n\nThus for our outer Decision, indent 4 spaces for Yes and No. For inner Decision under Yes, indent 8 spaces for Yes/No branches.\n\nBut the lines between the Yes branch and inner Decision? They are part of the Yes branch; they should be indented 4 spaces as well. Then inner Decision is at 8 spaces.\n\nThus the structure:\n\nDecision: i>=0 or j>=0 or carry>0? // 外層判斷\n    Yes → Step 2: digit1 = ...\n    → Step 3: digit2 = ...\n    → Step 4: sum = ...\n    → Step 5: carry = ...\n    → Step 6: result.append(...)\n    → Step 7: i = ...\n    → Decision: i>=0 or j>=0 or carry>0? // 內層判斷\n        No → Step 8: if carry > 0 ...\n        → Step 9: reverse...\n\nBut this seems odd: the inner Decision has No but not Yes branch; we only need No to exit. Actually we could just put the final steps under No of inner decision.\n\nBut to simplify, we might skip the inner Decision and just loop back to outer Decision. In other words, after step 7 we go back to outer Decision.\n\nSimpler: after step 7 we use \"→ Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否需要繼續迴圈\" and then branch No to final steps.\n\nSo we have outer Decision, Yes branch goes through steps 2-7 then back to outer Decision, and No branch goes to final steps. We don't need inner Decision; we just use outer Decision again.\n\nThus we can represent:\n\nDecision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n    Yes → Step 2: digit1 = ...\n    → Step 3: digit2 = ...\n    → Step 4: sum = ...\n    → Step 5: carry = ...\n    → Step 6: result.append(...)\n    → Step 7: i = i-1, j = j-1 // 移動到更高位\n    → Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否需要繼續\n    No  → Step 8: if carry > 0 then result.append(carry) // 加上最後進位\n    → Step 9: reverse result and join to string // 逆轉結果並轉為字串\n\nBut this has nested Decision again. Wait, we are basically repeating the same decision. That's okay: it's a loop.\n\nBut the indentation: The inner Decision is under Yes branch, so indent 8 spaces. Its Yes branch would loop again; its No branch goes to final steps. But we can also omit inner Decision and simply go back to outer Decision after step 7. But that may not be clear.\n\nHowever, it's okay: we can do nested Decision again to represent loop.\n\nThus final representation:\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化索引、進位與暫存結果\n→ Decision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n    Yes → Step 2: digit1 = (i>=0) ? int(num1[i]) : 0 // 取得 num1 的當前位數，若不存在則 0\n    → Step 3: digit2 = (j>=0) ? int(num2[j]) : 0 // 取得 num2 的當前位數，若不存在則 0\n    → Step 4: sum = digit1 + digit2 + carry // 計算兩位與進位之和\n    → Step 5: carry = sum / 10 // 取得進位\n    → Step 6: result.append(sum % 10) // 存儲單位數到暫存結果\n    → Step 7: i = i - 1, j = j - 1 // 移動到更高位\n    → Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否需要繼續\n        Yes → Step 2: digit1 = ... // 同上，回到加法循環\n        → Step 3: ...\n        ... // 省略重複步驟\n        No  → Step 8: if carry > 0 then result.append(carry) // 加上最後進位\n    → Step 9: reverse result and join to string // 逆轉並合併成字串\nEnd // 程式執行結束\n\nBut this duplicates steps. Maybe we can denote that the loop repeats automatically without writing again.\n\nAlternatively, we can use \"→ Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否需要繼續迴圈\" and then \"→ Yes → Step 2\" etc. But that's repetitive.\n\nTo keep it concise, we can just show that after step 7 we go back to the outer Decision. So we don't need inner Decision.\n\nThus:\n\nStart\n→ Step 1: ...\n→ Decision: i>=0 or j>=0 or carry>0?\n    Yes → Step 2: ...\n    → Step 3: ...\n    → Step 4: ...\n    → Step 5: ...\n    → Step 6: ...\n    → Step 7: ...\n    → Decision: i>=0 or j>=0 or carry>0? // 回到判斷\n    No  → Step 8: ...\n    → Step 9: ...\nEnd\n\nBut this is a bit weird.\n\nGiven the complexity, maybe it's acceptable to use a simpler representation:\n\nStart\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = []\n→ Step 2: while i>=0 or j>=0 or carry>0:\n        // inside loop: compute digit1, digit2, sum, carry, append, decrement\n→ Step 3: if carry > 0 then result.append(carry)\n→ Step 4: reverse result and join to string\nEnd\n\nBut \"while\" is not \"Decision:\".\n\nThe problem statement didn't restrict while; they mention to use arrows and Decision: but it's okay to use \"while\".\n\nHowever, the instruction says \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`).\" It does not forbid using loops, but they expect \"Decision:\" for conditional.\n\nMaybe we can represent loop as a decision with Yes branch repeating.\n\nThus:\n\nDecision: i>=0 or j>=0 or carry>0?\n    Yes → Step ... // do addition\n    → Decision: i>=0 or j>=0 or carry>0? // loop\n    No → Step ... // final steps\n\nBut this is too many.\n\nI think the simplest is:\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化指標、進位與暫存結果\n→ Decision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n    Yes → Step 2: digit1 = (i>=0) ? int(num1[i]) : 0 // 取得 num1 當前位數，若不存在則 0\n    → Step 3: digit2 = (j>=0) ? int(num2[j]) : 0 // 取得 num2 當前位數，若不存在則 0\n    → Step 4: sum = digit1 + digit2 + carry // 計算兩位與進位之和\n    → Step 5: carry = sum / 10 // 取得進位\n    → Step 6: result.append(sum % 10) // 存儲單位數到暫存結果\n    → Step 7: i = i - 1, j = j - 1 // 移動到更高位\n    → Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否需要繼續迴圈\n        Yes → Step 2: // 重新進入相同的加法步驟\n        ... // 重複相同步驟\n        No  → Step 8: if carry > 0 then result.append(carry) // 加上最後進位\n    → Step 9: reverse result and join to string // 逆轉並合併成字串\nEnd // 程式執行結束\n\nBut repeating step 2 with ellipsis is not precise.\n\nGiven the requirement to provide a concise virtual code, maybe we can use a simpler approach:\n\nStart\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = []\n→ Step 2: // 進行加法迴圈\n    → Decision: i>=0 or j>=0 or carry>0?\n        Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0\n        → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0\n        → Step 5: sum = digit1 + digit2 + carry\n        → Step 6: carry = sum / 10\n        → Step 7: result.append(sum % 10)\n        → Step 8: i = i - 1, j = j - 1\n        → Decision: i>=0 or j>=0 or carry>0? // loop\n        No  → Step 9: if carry > 0 then result.append(carry)\n        → Step 10: reverse result and join to string\nEnd\n\nBut again this loops.\n\nI think it's okay to present a slightly simplified version, as long as it captures the algorithm.\n\nWe can use a while loop representation as:\n\n→ Step 2: while i>=0 or j>=0 or carry>0: // 進行加法迴圈\n    → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0\n    → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0\n    → Step 5: sum = digit1 + digit2 + carry\n    → Step 6: carry = sum / 10\n    → Step 7: result.append(sum % 10)\n    → Step 8: i = i - 1, j = j - 1\n\nThen final steps.\n\nBut \"while\" isn't \"Decision:\" but it's okay.\n\nHowever, the instruction explicitly mentions using \"Decision:\".\n\nGiven the instruction, maybe we should avoid while loops and use decisions.\n\nOk, I will produce a clear representation using Decision: that loops until condition is false.\n\nWe can implement a loop as:\n\nDecision: i>=0 or j>=0 or carry>0?\n    Yes → Step 2: digit1 = ...\n    → Step 3: ...\n    → Step 4: ...\n    → Step 5: ...\n    → Step 6: ...\n    → Step 7: i = ...\n    → Decision: i>=0 or j>=0 or carry>0? // 重新檢查\n    No  → Step 8: if carry > 0 then result.append(carry)\n    → Step 9: reverse result and join to string\n\nThis effectively loops by re-evaluating the condition after step 7. It may be conceptually correct.\n\nLet's finalize with that.\n\nMake sure each line has \"→\" arrow and comment.\n\nUse proper indentation:\n\n- Outer Decision line has no indent.\n- Its Yes branch lines indented 4 spaces.\n- Inner Decision line indented 8 spaces.\n- Its No branch line indented 8 spaces? Actually inner Decision's No branch should be at same indentation as inner Decision's Yes? In sample, inner Decision's Yes and No are indented more. We'll follow.\n\nThus:\n\nDecision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n    Yes → Step 2: digit1 = ... // 取得 num1 位\n    → Step 3: digit2 = ... // 取得 num2 位\n    → Step 4: sum = ... // 加法\n    → Step 5: carry = ... // 進位\n    → Step 6: result.append(...) // 儲存\n    → Step 7: i = i - 1, j = j - 1 // 移動\n    → Decision: i>=0 or j>=0 or carry>0? // 重新檢查\n        Yes → Step 2: ... // 重複\n        ... // 重複步驟\n        No  → Step 8: if carry > 0 then result.append(carry) // 加最後進位\n    → Step 9: reverse result and join to string // 逆轉並合併\n\nBut repeating steps again is redundant.\n\nMaybe we can denote that the inner Decision's Yes branch simply loops back to the start of the outer Decision. We can write \"→ Yes → Decision: i>=0 or j>=0 or carry>0?\" but that would be confusing.\n\nGiven the complexity, I think the simpler representation with while loop is acceptable. The instruction may not require to strictly use Decision for loops. But they say \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`)\". This may allow using while loop as a step, but they'd still like Decision.\n\nMaybe we can use both: Step 2: while i>=0 or j>=0 or carry>0: but we still maintain Start, Endത്തിലാണ്.\n\nLet's adopt that:\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化索引、進位與暫存結果\n→ Step 2: while i>=0 or j>=0 or carry>0: // 進行加法迴圈\n    → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0 // 取得 num1 當前位\n    → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0 // 取得 num2 當前位\n    → Step 5: sum = digit1 + digit2 + carry // 計算兩位與進位之和\n    → Step 6: carry = sum / 10 // 取得進位\n    → Step 7: result.append(sum % 10) // 儲存單位數\n    → Step 8: i = i - 1, j = j - 1 // 移動到更高位\n→ Step 9: if carry > 0 then result.append(carry) // 若最後還有進位，加入\n→ Step 10: reverse result and join to string // 逆轉並合併為字串\nEnd // 程式執行結束\n\nBut Step 2 says while, which might not match the requirement.\n\nAlternatively, we can keep Decision for final if carry > 0, and use while loop as step.\n\nOk, I think I'll deliver the representation with while loop but also include Decision for the final carry check. That is:\n\nStart\n→ Step 1: init\n→ Step 2: while i>=0 or j>=0 or carry>0:\n    → Step 3: ...\n    ... \n→ Decision: carry > 0?\n    Yes → Step 4: result.append(carry)\n    No  → \n→ Step 5: reverse result and join to string\nEnd\n\nBut it's fine.\n\nLet's produce the final answer with clear indentation, each line preceded by arrow and comment.\n\nWe'll avoid duplicate loops. We'll use a while loop as a step.\n\nLet's produce the final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i = len(num1)-1, j = len(num2)-1, carry = 0, result = [] // 初始化索引、進位與暫存結果\n→ Step 2: // 進行加法迴圈\n    → Decision: i>=0 or j>=0 or carry>0? // 是否還有位需要加\n        Yes → Step 3: digit1 = (i>=0) ? int(num1[i]) : 0 // 取得 num1 當前位，若不存在則 0\n        → Step 4: digit2 = (j>=0) ? int(num2[j]) : 0 // 取得 num2 當前位，若不存在則 0\n        → Step 5: sum = digit1 + digit2 + carry // 計算兩位與進位之和\n        → Step 6: carry = sum / 10 // 取得進位\n        → Step 7: result.append(sum % 10) // 儲存單位數到暫存結果\n        → Step 8: i = i - 1, j = j - 1 // 移動到更高位\n        → Decision: i>=0 or j>=0 or carry>0? // 重新檢查是否需要繼續迴圈\n        No  → Step 9: if carry > 0 then result.append(carry) // 若最後還有進位，加入結果\n    → Step 10: reverse result and join to string // 逆轉暫存結果並合併成最終字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1, num2):\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n        return ''.join(res[::-1])\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Try to extract numbers inside quotes\n    nums = re.findall(r'\"(\\d+)\"', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # Fallback: split by whitespace or comma\n        parts = re.split(r'[\\s,]+', data)\n        parts = [p for p in parts if p]\n        if len(parts) >= 2:\n            # remove possible leading 'num1=' or 'num2='\n            if parts[0].startswith('num1'):\n                parts[0] = parts[0].split('=')[-1]\n            if parts[1].startswith('num2'):\n                parts[1] = parts[1].split('=')[-1]\n            # strip possible quotes\n            num1 = parts[0].strip('\"\\'')\n            num2 = parts[1].strip('\"\\'')\n        else:\n            # If only one part, assume second is empty\n            num1 = parts[0].strip('\"\\'')\n            num2 = \"\"\n    sol = Solution()\n    result = sol.addStrings(num1, num2)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "success": true,
          "output": "\"134\""
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "success": true,
          "output": "\"533\""
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "success": true,
          "output": "\"0\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode440.json",
    "problem_index_in_file": 0,
    "title": "K-th Smallest in Lexicographical Order",
    "description_snippet": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n]....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for solving the problem: find kth lexicographically smallest integer in [1,n]. Approach: count number of numbers between prefix and prefix+1. Standard solution: lexicographic traversal. Use function countSteps(prefix, n). The algorithm: start with cur=1, steps=1, then while steps < k: compute steps between cur and cur+1; if steps + stepCount <= k, cur++ ; else go deeper: cur *=10; steps++ etc. This returns cur.\n\nNeed to produce virtual code step by step with comments.\n\nWe need to produce virtual code in lines: Start, steps, decision, etc.\n\nWe'll produce something like:\n\nStart // 程式開始\n→ Step 1: 定義函式 countSteps(prefix, n) // 計算以 prefix 為前綴的數字在 [1,n] 的個數\n    → Decision: prefix > n? // 若前綴已超過 n\n        Yes → Return 0 // 沒有數字\n        No → Decision: prefix * 10 > n? // 只剩一層\n            Yes → Return 1 // prefix 本身\n            No → Loop: next = prefix * 10 ; end = min(n+1, next+10); step += end - next; prefix++ ; ... but maybe simpler: for next=prefix*10, end = min(n+1, next+10) ...\nBut we can implement iterative counting.\n\nHowever the virtual code: we need step by step logic.\n\nSimplify: In main:\n\n- Read n, k\n- cur = 1\n- steps = 1\n- While steps < k:\n    count = countSteps(cur, n)\n    If steps + count <= k:\n        cur++\n        steps += count\n    Else:\n        cur *= 10\n        steps += 1\nReturn cur\n\nNeed to produce explanation.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: 讀入 n, k // 取得輸入參數\n\n→ Step 2: 初始化 cur = 1, steps = 1 // 第一個字典序數字是 1\n\n→ Decision: steps < k? // 是否還需要往後找\n\n    Yes → Step 3: 計算 count = countSteps(cur, n) // 這個前綴下的所有數字個數\n\n    → Decision: steps + count <= k? // 是否可以跳過這整個前綴區塊\n\n        Yes → Step 4: cur++ // 移到下一個前綴\n              → Step 5: steps += count // 累加已走過的步數\n              → Decision: steps < k? // 重新判斷\n                 ... (loop)\n\n        No → Step 6: cur *= 10 // 進入下一層字典序\n              → Step 7: steps++ // 走到這個前綴本身\n              → Decision: steps < k? // 重新判斷\n                 ...\n\n→ End // 完成\n\nBut need to also define countSteps function.\n\nDefine:\n\n→ Step X: 定義函式 countSteps(prefix, n)\n\n    → Variable first = prefix, last = prefix\n    → Variable total = 0\n    → While first <= n:\n        total += min(n+1, last+1) - first // 加上本層的數字數\n        first *= 10\n        last = last*10 + 9\n\n    → Return total\n\nBut we need to produce in virtual code with arrow.\n\nWe'll produce lines for function definition before main.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Function countSteps(prefix, n): // 計算以 prefix 為前綴的所有數字個數\n    → Variable first = prefix\n    → Variable last = prefix\n    → Variable total = 0\n    → Decision: first <= n? // 若前綴仍在範圍內\n        Yes → Step: total += min(n+1, last+1) - first // 加上本層的數字數\n              → Step: first = first * 10 // 下一層的最小數\n              → Step: last = last * 10 + 9 // 下一層的最大數\n              → Decision: first <= n? // 迴圈\n                 Yes → Repeat\n                 No → End of loop\n        No → End // 函式結束\n    → Return total\n\nBut we can shorten: Use While loop.\n\nSimpler: While first <= n: total += min(n+1, last+1) - first; first *= 10; last = last*10 + 9\n\nWe can express that in steps: Step: While first <= n: // 迴圈\n    total += min(n+1, last+1) - first\n    first = first * 10\n    last = last * 10 + 9\n\nBut we need to include condition and increments.\n\nThen main.\n\nLet's craft final answer.\n\nWe need to produce virtual code lines, each with explanation.\n\nOk, produce.\n\n...done thinking.\n\nStart // 程式開始\n→ Function countSteps(prefix, n): // 計算以 prefix 為前綴的所有數字個數\n    → Variable first = prefix // 本層最小數\n    → Variable last = prefix // 本層最大數\n    → Variable total = 0 // 累計數量\n    → Decision: first ≤ n? // 前綴是否還在範圍內\n        Yes → While first ≤ n: // 逐層向下計算\n            → Step: total += min(n+1, last+1) - first // 本層的數字個數\n            → Step: first = first * 10 // 下一層最小數\n            → Step: last = last * 10 + 9 // 下一層最大數\n        No → End // 結束迴圈\n    → Return total // 回傳總數\nEnd // 函式結束\n\n→ Step 1: 讀入 n, k // 取得輸入參數\n→ Step 2: 初始化 cur = 1, steps = 1 // 第一個字典序數字是 1\n→ Decision: steps < k? // 是否還需要往後找\n    Yes →\n        → Step 3: count = countSteps(cur, n) // 計算以 cur 為前綴的所有數字個數\n        → Decision: steps + count ≤ k? // 能否跳過整個前綴區塊\n            Yes →\n                → Step 4: cur = cur + 1 // 移到下一個前綴\n                → Step 5: steps = steps + count // 累加已走過的步數\n                → Decision: steps < k? // 重新判斷，回到上方 Decision\n                    Yes → (迴圈)\n                    No  → (結束迴圈)\n            No →\n                → Step 6: cur = cur * 10 // 進入下一層字典序\n                → Step 7: steps = steps + 1 // 走到這個前綴本身\n                → Decision: steps < k? // 重新判斷，回到上方 Decision\n                    Yes → (迴圈)\n                    No  → (結束迴圈)\n→ Step 8: 輸出 cur // 最終得到第 k 個字典序數字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_steps(prefix: int, n: int) -> int:\n    \"\"\"計算以 prefix 為前綴，在 [1, n] 範圍內的所有數字個數。\"\"\"\n    first = prefix\n    last = prefix\n    total = 0\n    while first <= n:\n        # 本層的數字個數\n        total += min(n + 1, last + 1) - first\n        first *= 10\n        last = last * 10 + 9\n    return total\n\ndef find_kth(n: int, k: int) -> int:\n    \"\"\"回傳 [1, n] 範圍內第 k 個字典序最小的數字。\"\"\"\n    cur = 1          # 目前字典序前綴\n    steps = 1        # 已走過的步數，最初從 1 開始\n    while steps < k:\n        cnt = count_steps(cur, n)\n        if steps + cnt <= k:\n            # 可以直接跳過整個前綴區塊\n            cur += 1\n            steps += cnt\n        else:\n            # 進入下一層\n            cur *= 10\n            steps += 1\n    return cur\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得所有整數（支援類似 \"n = 13, k = 2\" 的輸入格式）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        return\n    n, k = nums[0], nums[1]\n    result = find_kth(n, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13, k = 2",
          "expected_output": "10",
          "success": true,
          "output": "10"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode40.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum II",
    "description_snippet": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique c...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Combination Sum II. Must output steps line by line. Use Start, Decision, etc. Each line: virtual code + space + // explanation.\n\nWe need to cover algorithm: sort candidates, backtracking with pruning and skip duplicates. Provide step-by-step.\n\nLet's produce:\n\nStart\n\n→ Step 1: Sort candidates ascending // for duplicate handling and pruning\n\n→ Step 2: Initialize result list // store combinations\n\n→ Step 3: Call backtrack(startIndex=0, target, currentCombination=[])\n\nThen backtrack function steps: if target==0: add copy to result. If target<0 return.\n\nLoop i from startIndex to len(candidates)-1:\n\nDecision: if i>startIndex and candidates[i]==candidates[i-1] // skip duplicate\n\n    No → (continue)\n\nDecision: if candidates[i] > target // prune\n\n    No → (break)\n\nThen:\n\n→ Step: Add candidates[i] to currentCombination\n\n→ Step: Call backtrack(i+1, target - candidates[i], currentCombination)\n\n→ Step: Remove last element from currentCombination\n\nAfter loop end, return\n\nEnd.\n\nMake sure each line has virtual code and explanation. Use \"Decision:\" for if conditions. Use arrow \"→\". For loops maybe \"→ Loop i from ...\".\n\nMake sure each line is one step. Use consistent naming.\n\nLet's draft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort candidates ascending // 先排序以方便後續跳過重複數字與剪枝  \n→ Step 2: Initialize result list // 用來存放所有符合條件的組合  \n→ Step 3: Call backtrack(startIndex = 0, target, current = []) // 開始遞迴搜尋  \n\n// =================== backtrack 函式開始 ===================  \n→ Step 4: If target == 0 // 找到一組符合目標和  \n    Yes → Step 5: Append copy of current to result // 將目前組合加入結果  \n    No  → Continue // 目標不為零，繼續後續流程  \n→ Decision: If target < 0 // 已超過目標和，無需繼續  \n    Yes → Step 6: Return // 結束此遞迴分支  \n    No  → Proceed  \n\n→ Loop i from startIndex to len(candidates)-1 // 依序考慮每個候選數  \n    → Decision: If i > startIndex AND candidates[i] == candidates[i-1] // 同層重複數字  \n        Yes → Step 7: Continue // 跳過重複，避免重複組合  \n        No  → Proceed  \n    → Decision: If candidates[i] > target // 超過剩餘目標，後面已更大  \n        Yes → Step 8: Break // 結束循環，剪枝  \n        No  → Proceed  \n    → Step 9: Append candidates[i] to current // 將當前數字加入組合  \n    → Step 10: Call backtrack(i + 1, target - candidates[i], current) // 進一步遞迴  \n    → Step 11: Remove last element from current // 回溯，移除剛加入的數字  \n\n// =================== backtrack 函式結束 ===================  \n\nEnd // 程式執行結束，結果已存於 result 列表中。",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def combinationSum2(self, candidates, target):\n        # 先將候選數字排序，方便後續剪枝與跳過重複值\n        candidates.sort()\n        res = []\n\n        def backtrack(start, path, total):\n            # 找到一組合法的組合\n            if total == target:\n                res.append(list(path))\n                return\n            # 已超過目標值，直接回溯\n            if total > target:\n                return\n            prev = None\n            for i in range(start, len(candidates)):\n                # 跳過同層重複的數字，避免重複組合\n                if prev is not None and candidates[i] == prev:\n                    continue\n                # 如果當前數字已使總和超過目標，後面更大，直接剪枝\n                if total + candidates[i] > target:\n                    break\n                path.append(candidates[i])\n                backtrack(i + 1, path, total + candidates[i])\n                path.pop()\n                prev = candidates[i]\n\n        backtrack(0, [], 0)\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入字串中提取 candidates 列表與 target 整數\n    cand_match = re.search(r'candidates\\s*=\\s*(\\[.*?\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not cand_match or not target_match:\n        print(\"[]\")\n        return\n    candidates = ast.literal_eval(cand_match.group(1))\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.combinationSum2(candidates, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [10,1,2,7,6,1,5], target = 8",
          "expected_output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
          "success": true,
          "output": "[[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,5,2,1,2], target = 5",
          "expected_output": "[[1,2,2],[5]]",
          "success": true,
          "output": "[[1, 2, 2], [5]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode449.json",
    "problem_index_in_file": 0,
    "title": "Serialize and Deserialize BST",
    "description_snippet": "Serialization is converting a data structure or object into a sequence of bits so that it can be sto...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for serializing/deserializing BST. Use preorder traversal with null markers? But we want compact. For BST, we can use preorder sequence and reconstruct using bounds. Use no null markers because BST uniqueness ensures. So algorithm: serialize: produce preorder list. For each node, output its value separated by comma. For empty tree, output empty string.\n\nDeserialize: use preorder list and reconstruct using recursion with min/max bounds. Use index pointer. Complexity O(n).\n\nWe need step-by-step virtual code with explanations. Use arrow syntax.\n\nLet's produce steps:\n\nStart\n→ Step 1: define function serialize(root) // entry\n→ Decision: root is null? // check empty tree\n   Yes → Step 2: return \"\" // empty string\n   No → Step 3: Initialize result list // collect values\n   → Step 4: Call helperPreorder(root, result) // preorder DFS\n   → Step 5: Join result with \",\" and return string // final serialization\n\n→ Step 6: define helperPreorder(node, list) // recursive\n   → Step 7: Append node.val to list\n   → Step 8: If node.left not null, helperPreorder(node.left, list)\n   → Step 9: If node.right not null, helperPreorder(node.right, list)\n\nEnd of serialize function.\n\nDeserialize:\n\nStart\n→ Step 10: define function deserialize(data) // entry\n→ Decision: data is empty? // check no data\n   Yes → Step 11: return null\n   No → Step 12: Split data by \",\" into array nums (integers)\n   → Step 13: Initialize index = 0 // current position in preorder array\n   → Step 14: Call helperBuild(nums, index, -∞, +∞) // build BST\n   → Step 15: Return root\n\n→ Step 16: define helperBuild(nums, indexRef, lower, upper) // recursive\n   → Decision: indexRef >= nums.length? // no more nodes\n      Yes → Step 17: return null\n   → Decision: nums[indexRef] not in [lower, upper]? // value violates bounds\n      Yes → Step 18: return null\n   → Step 19: Create node with val = nums[indexRef]\n   → Step 20: Increment indexRef\n   → Step 21: node.left = helperBuild(nums, indexRef, lower, node.val) // left subtree\n   → Step 22: node.right = helperBuild(nums, indexRef, node.val, upper) // right subtree\n   → Step 23: return node\n\nEnd\n\nMake sure to explain each.\n\nAlso mention indexRef being passed by reference or using object.\n\nNow produce virtual code lines with explanations. Use arrow notation and indentation. Use virtual code arrow lines. Provide \"Start\" and \"End\" tags for each function maybe combined? The example shows Start at top-level program. We can group functions separately? We can just provide Start at beginning of algorithm.\n\nLet's produce.\n\nRemember each line must be \"虛擬碼步驟 [space] // 解釋\".\n\nWe can use \"→\" arrow for steps. Use Decision lines with indentation. For nested steps, indent.\n\nWe can produce as following:\n\nStart // 程式開始執行\n→ Step 1: Define function serialize(root) // 開始序列化\n    → Decision: root is null? // 檢查樹是否為空\n        Yes → Step 2: return \"\" // 空樹序列化為空字串\n        No  → Step 3: Initialize list result = [] // 用於儲存節點值\n        → Step 4: Call helperPreorder(root, result) // 前序遍歷填充 list\n        → Step 5: Join result with \",\" to string and return // 產生序列化字串\n→ End // serialize 函式結束\n\n→ Step 6: Define helperPreorder(node, list) // 前序 DFS\n    → Step 7: Append node.val to list // 記錄節點值\n    → Decision: node.left exists? // 進入左子樹\n        Yes → Step 8: helperPreorder(node.left, list)\n        No  → (do nothing)\n    → Decision: node.right exists? // 進入右子樹\n        Yes → Step 9: helperPreorder(node.right, list)\n        No  → (do nothing)\n→ End // helperPreorder 函式結束\n\n→ Step 10: Define function deserialize(data) // 開始反序列化\n    → Decision: data is empty? // 檢查是否有資料\n        Yes → Step 11: return null // 空字串對應空樹\n        No  → Step 12: Split data by \",\" into array nums // 取得前序序列\n        → Step 13: Initialize index = 0 // 追蹤目前處理的節點\n        → Step 14: root = helperBuild(nums, index, -∞, +∞) // 建構 BST\n        → Step 15: return root // 回傳根節點\n→ End // deserialize 函式結束\n\n→ Step 16: Define helperBuild(nums, indexRef, lower, upper) // 以 bounds 重建\n    → Decision: indexRef >= nums.length? // 沒有更多節點\n        Yes → Step 17: return null\n        No  → Decision: nums[indexRef] not in [lower, upper]? // 節點值不符合範圍\n            Yes → Step 18: return null\n            No  → Step 19: Create node with val = nums[indexRef] // 創建節點\n            → Step 20: Increment indexRef // 移動到下一個節點\n            → Step 21: node.left = helperBuild(nums, indexRef, lower, node.val) // 左子樹\n            → Step 22: node.right = helperBuild(nums, indexRef, node.val, upper) // 右子樹\n            → Step 23: return node // 回傳節點\n→ End // helperBuild 函式結束\n\nEnd // 程式執行結束\n\nNeed to ensure correct arrow indentation: The example uses indents like \"    Yes →\". We'll follow.\n\nAlso use \"→\" arrow for each step, and \"Decision:\" lines. We'll use \"Decision:\" before the question.\n\nMake sure each line has space before //.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define function serialize(root) // 開始序列化  \n  → Decision: root is null? // 檢查樹是否為空  \n    Yes → Step 2: return \"\" // 空樹序列化為空字串  \n    No  → Step 3: Initialize list result = [] // 用於儲存節點值  \n    → Step 4: Call helperPreorder(root, result) // 前序遍歷填充 list  \n    → Step 5: Join result with \",\" to string and return // 產生序列化字串  \n→ End // serialize 函式結束  \n\n→ Step 6: Define helperPreorder(node, list) // 前序 DFS  \n  → Step 7: Append node.val to list // 記錄節點值  \n  → Decision: node.left exists? // 進入左子樹  \n    Yes → Step 8: helperPreorder(node.left, list)  \n    No  → (do nothing)  \n  → Decision: node.right exists? // 進入右子樹  \n    Yes → Step 9: helperPreorder(node.right, list)  \n    No  → (do nothing)  \n→ End // helperPreorder 函式結束  \n\n→ Step 10: Define function deserialize(data) // 開始反序列化  \n  → Decision: data is empty? // 檢查是否有資料  \n    Yes → Step 11: return null // 空字串對應空樹  \n    No  → Step 12: Split data by \",\" into array nums // 取得前序序列  \n    → Step 13: Initialize index = 0 // 追蹤目前處理的節點  \n    → Step 14: root = helperBuild(nums, index, -∞, +∞) // 建構 BST  \n    → Step 15: return root // 回傳根節點  \n→ End // deserialize 函式結束  \n\n→ Step 16: Define helperBuild(nums, indexRef, lower, upper) // 以 bounds 重建  \n  → Decision: indexRef >= nums.length? // 沒有更多節點  \n    Yes → Step 17: return null  \n    No  → Decision: nums[indexRef] not in [lower, upper]? // 節點值不符合範圍  \n      Yes → Step 18: return null  \n      No  → Step 19: Create node with val = nums[indexRef] // 創建節點  \n       → Step 20: Increment indexRef // 移動到下一個節點  \n       → Step 21: node.left = helperBuild(nums, indexRef, lower, node.val) // 左子樹  \n       → Step 22: node.right = helperBuild(nums, indexRef, node.val, upper) // 右子樹  \n       → Step 23: return node // 回傳節點  \n→ End // helperBuild 函式結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import deque\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        res = []\n\n        def preorder(node):\n            if not node:\n                return\n            res.append(str(node.val))\n            preorder(node.left)\n            preorder(node.right)\n\n        preorder(root)\n        return ','.join(res)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n        if not data:\n            return None\n        preorder = list(map(int, data.split(',')))\n\n        def build(min_val, max_val):\n            if preorder and min_val < preorder[0] < max_val:\n                val = preorder.pop(0)\n                node = TreeNode(val)\n                node.left = build(min_val, val)\n                node.right = build(val, max_val)\n                return node\n            return None\n\n        return build(float('-inf'), float('inf'))\n\ndef build_tree(values):\n    \"\"\"Builds a binary tree from a list representation (level-order, None for missing).\"\"\"\n    if not values:\n        return None\n    root = TreeNode(values[0])\n    queue = deque([root])\n    i = 1\n    while i < len(values):\n        current = queue.popleft()\n        # left child\n        if i < len(values) and values[i] is not None:\n            current.left = TreeNode(values[i])\n            queue.append(current.left)\n        i += 1\n        # right child\n        if i < len(values) and values[i] is not None:\n            current.right = TreeNode(values[i])\n            queue.append(current.right)\n        i += 1\n    return root\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        sys.exit(0)\n\n    # Extract the list part between '[' and ']'\n    try:\n        first_bracket = input_data.index('[')\n        last_bracket = input_data.rindex(']')\n        list_str = input_data[first_bracket:last_bracket + 1]\n        node_list = ast.literal_eval(list_str)\n        # Ensure list contains integers or None\n        if not isinstance(node_list, list):\n            raise ValueError\n    except Exception:\n        print(\"[]\")\n        sys.exit(0)\n\n    # Build tree from list\n    tree_root = build_tree(node_list)\n\n    # Serialize tree\n    codec = Codec()\n    serialized = codec.serialize(tree_root)\n\n    # Format output\n    if serialized:\n        print(f'[{serialized}]')\n    else:\n        print('[]')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "root = [2,1,3]",
          "expected_output": "[2,1,3]",
          "success": true,
          "output": "[2,1,3]"
        },
        {
          "example_index": 1,
          "input": "root = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode349.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with line-by-line steps for solving intersection of two integer arrays. Must use Start, End, Decision, arrow notation, and after each line a comment. No actual code. Provide explanation after space. We should reflect algorithm: convert first array to set, iterate second array, check presence, add to result set to ensure uniqueness, then convert to array.\n\nWe need to produce step-by-step. Use arrows. Eg:\n\nStart // start\n→ Step 1: 初始化集合 set1 為 nums1 的所有元素 // store unique elements of nums1\n→ Step 2: 初始化空集合 resultSet // store unique intersection\n→ Step 3: 對 nums2 中的每個元素 num 進行遍歷 // iterate over second array\n    → Decision: 是否存在於 set1? // check membership\n        Yes → Step 4: 添加 num 至 resultSet // add to intersection set\n        No  → Step 5: 直接跳過 // no action\n→ Step 6: 將 resultSet 轉換為陣列 output // prepare final array\nEnd // 完成\n\nBut need to reflect decision branches properly. Use Decision lines. Let's write.\n\nBe careful with arrow indentation. Each step line begins with \"→\" except decisions. Use \"Decision:\" line with arrow inside? Example: \"Decision: 是否存在於 set1?\" then Yes → Step 4. Good.\n\nAlso include any other decision: e.g., check if element already in resultSet? Not necessary as set ensures uniqueness. But could show \"If resultSet 未包含 num?\" but we can skip.\n\nWe must ensure each line is separate. The format: \"虛擬碼步驟 [空格] // 解釋/說明\". Use \"Start\" line without arrow? Use \"Start\". Then \"→\" before each step. For decisions, use \"Decision:\" and indent options.\n\nOk produce. Let's output in Traditional Chinese.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化集合 set1 為 nums1 的所有元素 // 把 nums1 轉成唯一值集合  \n→ Step 2: 初始化空集合 resultSet // 用於儲存交集的唯一值  \n→ Step 3: 對 nums2 中的每個元素 num 進行遍歷 // 檢查每個 nums2 的元素  \n    Decision: num 是否存在於 set1? // 判斷 num 是否在 nums1 的集合中  \n        Yes → Step 4: 將 num 加入 resultSet // 若存在，加入交集集合  \n        No  → Step 5: 直接跳過 // 若不存在，無需處理  \n→ Step 6: 將 resultSet 轉換為陣列 output // 將集合轉為最終返回的陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"返回兩個整數列表的唯一交集，保留 nums2 中第一次出現的順序。\"\"\"\n        set1 = set(nums1)\n        seen = set()\n        result = []\n        for num in nums2:\n            if num in set1 and num not in seen:\n                result.append(num)\n                seen.add(num)\n        return result\n\ndef parse_input():\n    \"\"\"\n    從標準輸入中解析出兩個列表：\n    期望的格式類似 'nums1 = [1,2,2,1], nums2 = [2,2]'。\n    \"\"\"\n    data = sys.stdin.read()\n    # 先尋找兩個列表的字串\n    m1 = re.search(r'nums1\\s*=\\s*(\\[[^\\]]*\\])', data)\n    m2 = re.search(r'nums2\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not m1 or not m2:\n        return [], []\n\n    # 使用 literal_eval 轉換成真正的 Python 列表\n    try:\n        nums1 = ast.literal_eval(m1.group(1))\n        nums2 = ast.literal_eval(m2.group(1))\n    except Exception:\n        nums1 = []\n        nums2 = []\n    return nums1, nums2\n\ndef main():\n    nums1, nums2 = parse_input()\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "success": true,
          "output": "[9, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode416.json",
    "problem_index_in_file": 0,
    "title": "Partition Equal Subset Sum",
    "description_snippet": "Given an integer array nums, return true if you can partition the array into two subsets such that t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the subset sum partition problem. Provide step-by-step pseudocode with explanations. Each line with \"虛擬碼步驟 // 解釋\". Use arrows. Should not output actual code. So produce lines: Start, compute total sum, check if odd -> return false, target = sum/2, DP array of bool size target+1. Initialize dp[0]=true. Loop each num in nums, iterate target downwards, dp[j]=dp[j] or dp[j-num]. After loop, return dp[target]. Then End. Provide explanation per line.\n\nLet's produce in Chinese. Use \"→\". For loops we can use \"→ For each num in nums:\" etc. Provide decisions. Use indentation with arrow.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 計算陣列元素總和 totalSum // 先算整個陣列的總和\n→ Decision: 如果 totalSum 為奇數? // 只有總和為偶數才可能分成兩等份\n    Yes → Step 2: 回傳 false // 奇數無法平分，直接結束\n    No  → Step 3: 設定目標和 target = totalSum / 2 // 目標子集和為總和的一半\n→ Step 4: 初始化布林陣列 dp，長度 target+1，所有值為 false // dp[j] 表示能否組成和為 j 的子集\n→ Step 5: dp[0] = true // 零和永遠可組成（不選取任何元素）\n→ For each num in nums: // 遍歷陣列中的每個數\n    → For j從 target 降至 num: // 從後往前更新，避免重複使用同一個數\n        → Decision: 如果 dp[j-num] 為 true? // 判斷是否能在之前的子集和中達到 j-num\n            Yes → dp[j] = true // 若能，則 j 也能達成\n            No  → // 不改變 dp[j] // 保持原值\n→ Decision: 如果 dp[target] 為 true? // 最後檢查目標和是否可達\n    Yes → Step 6: 回傳 true // 能分成兩等份\n    No  → Step 7: 回傳 false // 無法分成兩等份\nEnd // 程式執行結束\n\nBut the format requires each line has \"虛擬碼步驟 [space] // 解釋\". The decision lines should be nested; we can indent with arrow \"→\". In previous example they used:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n\nSo we should match that style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算陣列元素總和 totalSum // 先算整個陣列的總和  \n→ Decision: 如果 totalSum 為奇數? // 只有總和為偶數才可能分成兩等份  \n Yes → Step 2: 回傳 false // 奇數無法平分，直接結束  \n No  → Step 3: 設定目標和 target = totalSum / 2 // 目標子集和為總和的一半  \n→ Step 4: 初始化布林陣列 dp，長度 target+1，所有值為 false // dp[j] 表示能否組成和為 j 的子集  \n→ Step 5: dp[0] = true // 零和永遠可組成（不選取任何元素）  \n→ For each num in nums: // 遍歷陣列中的每個數  \n → For j從 target 降至 num: // 從後往前更新，避免重複使用同一個數  \n  → Decision: 如果 dp[j-num] 為 true? // 判斷是否能在之前的子集和中達到 j-num  \n   Yes → dp[j] = true // 若能，則 j 也能達成  \n   No  → // 不改變 dp[j] // 保持原值  \n→ Decision: 如果 dp[target] 為 true? // 最後檢查目標和是否可達  \n Yes → Step 6: 回傳 true // 能分成兩等份  \n No  → Step 7: 回傳 false // 無法分成兩等份  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n\n        return dp[target]\n\ndef parse_input(data: str):\n    \"\"\"將輸入字串轉成整數列表。\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # 如果輸入包含 'nums = ...'，則移除前面的文字\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n\n    # 直接使用 eval 解析列表，若失敗則用正則表達式擷取數字\n    try:\n        nums = eval(data, {}, {})\n    except Exception:\n        nums = list(map(int, re.findall(r'-?\\d+', data)))\n    return nums\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().canPartition(nums)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,11,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,5]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode398.json",
    "problem_index_in_file": 0,
    "title": "Random Pick Index",
    "description_snippet": "Given an integer array nums with possible duplicates, randomly output the index of a given target nu...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. No actual code, just pseudo-steps. Need to handle initialization storing array, pick method selecting random index among indices with target, ensuring equal probability. So pseudo: Start, store nums, maybe build hashmap? But simplest: iterate and collect indices? Could use reservoir sampling to keep O(1) memory. Provide pseudo: For each i if nums[i]==target, maintain count and randomly replace chosen index. So lines: Start, Step1: store array, Step2: pick function: initialize result=-1, count=0, iterate indices, if match, count++, if random() < 1/count, set result=i. Return result. That's pseudo. Ensure random generation. Provide explanation each line.\n\nLet's produce in the required format. Use \"→\" arrows. For Decision blocks? We may include decision for match? Use \"Decision: nums[i] == target?\" with Yes branch. Use \"Decision: random() < 1/count?\" with Yes branch etc.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 儲存輸入陣列 nums // 讓物件能存取整數陣列  \n→ End // 建構子結束  \n\nStart // pick 方法開始執行  \n→ Step 2: 初始化變數 result = -1, count = 0 // result 用於儲存目前選中的索引，count 用於記錄符合目標的數量  \n→ Decision: 循環遍歷 nums 中每個索引 i // 遍歷整個陣列以尋找目標值  \n    Yes → Step 3: 如果 nums[i] == target? // 檢查此索引是否為目標值  \n        Yes → Step 4: 將 count 加 1 // 已找到一個符合目標的索引  \n        Yes → Decision: 是否以機率 1/count 選取此索引？ // 檢查是否把此索引作為新的選擇  \n            Yes → Step 5: result = i // 隨機選中此索引作為結果  \n            No → Step 6: 跳過 // 仍保留現有的 result  \n        No → Step 7: 跳過 // 非目標索引不做處理  \n→ End // 循環結束  \n→ Step 8: 回傳 result // 返回隨機挑選的符合目標值的索引  \nEnd // pick 方法結束執行",
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    \"\"\"\n    直接將傳入的 nums 存起來，並在 pick 時使用 Reservoir Sampling\n    以 O(1) 的記憶體實作「每個符合 target 的索引都有相同機率被選中」。\n    \"\"\"\n    def __init__(self, nums):\n        self.nums = nums\n\n    def pick(self, target):\n        \"\"\"\n        檢索 nums 中所有等於 target 的索引，並以等機率返回其中一個。\n        \"\"\"\n        result = None\n        count = 0\n        for idx, value in enumerate(self.nums):\n            if value == target:\n                count += 1\n                # 以 1/count 的機率選中當前索引\n                if random.randint(1, count) == 1:\n                    result = idx\n        return result\n\n\ndef main():\n    # 讀取整個輸入字串\n    input_data = sys.stdin.read().strip()\n    if not input_data:\n        return\n\n    # 解析輸入，示例輸入形式：\n    # '[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]'\n    # 先找到第一個 '],'\n    split_idx = input_data.find('],')\n    if split_idx == -1:\n        raise ValueError(\"輸入格式錯誤\")\n\n    methods_str = input_data[:split_idx + 1]           # 包含第一個列表完整\n    args_str = input_data[split_idx + 2:]             # 後續為第二個列表\n\n    # 使用 ast.literal_eval 轉成 Python 物件\n    methods = ast.literal_eval(methods_str)\n    args = ast.literal_eval(args_str)\n\n    results = []\n    obj = None\n\n    for method, arg in zip(methods, args):\n        if method == \"Solution\":\n            # arg 形如 [[1, 2, 3, 3, 3]]\n            nums = arg[0] if isinstance(arg, list) else arg\n            obj = Solution(nums)\n            results.append(None)          # Constructor 回傳 null\n        else:\n            # pick 只需要傳遞單一參數\n            target = arg[0] if isinstance(arg, list) else arg\n            res = getattr(obj, method)(target)\n            results.append(res)\n\n    # 將結果轉成 LeetCode 需要的輸出格式，None 用 'null' 表示\n    output = '[' + ', '.join('null' if v is None else str(v) for v in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "success": true,
          "output": "[null, 4, 0, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode139.json",
    "problem_index_in_file": 0,
    "title": "Word Break",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a spac...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Word Break problem. Use DP or recursion with memo. Provide step-by-step virtual code lines with explanation after each line. Use arrow, Start, Decision, End.\n\nWe need to produce virtual code in Traditional Chinese. Provide each line with explanation. Must use arrow symbols.\n\nLet's craft.\n\nStart\n→ Step 1: 初始化 dp 數組長度 |s|+1，dp[0] = true // 以布林陣列表示到該位置可分割\n→ Step 2: 將字典轉為集合 wordSet // 提升查詢速度\n→ Step 3: 循環 i 從 1 到 |s| // 逐個檢查子字串結尾\n    → Decision: 如果 dp[i-1] 為 true? // 前面已可分割\n        Yes →\n            → Step 4: 循環 j 從 0 到 i-1 // 檢查子字串 s[j:i]\n                → Decision: 如果 s[j:i] 在 wordSet? // 子字串為字典詞\n                    Yes →\n                        → Step 5: 設定 dp[i] = true // i 可分割\n                        → Step 6: 跳出內部循環 // 已找到合法分割\n                    No  →\n                        → Step 7: 繼續檢查下一個 j\n        No  →\n            → Step 8: 跳過此 i // 前面不可分割，無法以 i 結束\n→ Decision: 返回 dp[|s|] // 判斷整個字串是否可分割\nEnd\n\nWe must ensure each line has arrow? For decisions we indent.\n\nLet's produce.\n\nUse \"→\" for normal steps. For decisions we show \"Decision: ...?\" then indent Yes / No branches.\n\nEnsure each line includes comment. Also need to add explanation after space after virtual code. Format: `虛擬碼步驟 // 解釋`.\n\nOk.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 dp 數組長度 |s|+1，dp[0] = true // dp[i] 表示前 i 個字可被分割  \n→ Step 2: 將字典轉為集合 wordSet // 方便 O(1) 查詢  \n→ Step 3: 循環 i 從 1 到 |s| // 以 i 為子字串結尾檢查可否分割  \n  Decision: 如果 dp[i-1] 為 true? // 前面已可分割，才有可能以 i 結束  \n   Yes → Step 4: 循環 j 從 0 到 i-1 // 檢查子字串 s[j:i]  \n    Decision: 如果 s[j:i] 在 wordSet? // 子字串是字典詞  \n     Yes → Step 5: 設定 dp[i] = true // i 可分割  \n      Step 6: 跳出內部循環 // 已找到合法分割，避免冗餘檢查  \n     No  → Step 7: 繼續檢查下一個 j // 試著找其他分割點  \n   No  → Step 8: 跳過此 i // 前面不可分割，i 無法作為結束點  \n→ Decision: 返回 dp[|s|] // 判斷整個字串是否可被分割  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\ndef parse_input(input_text: str):\n    \"\"\"\n    解析輸入格式：s = \"xxxx\", wordDict = [\"a\",\"b\",\"c\"]\n    \"\"\"\n    pattern = r's\\s*=\\s*\"(?P<s>[^\"]*)\",\\s*wordDict\\s*=\\s*\\[(?P<dict>.*?)\\]'\n    match = re.search(pattern, input_text, re.S)\n    if not match:\n        raise ValueError(\"輸入格式錯誤\")\n    s = match.group('s')\n    dict_content = match.group('dict')\n    # 使用 ast.literal_eval 解析字典內容\n    word_dict = ast.literal_eval(f'[{dict_content}]')\n    return s, word_dict\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n    s, word_dict = parse_input(raw_input)\n    result = Solution().wordBreak(s, word_dict)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode283.json",
    "problem_index_in_file": 0,
    "title": "Move Zeroes",
    "description_snippet": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, one per line, with arrow and comment. We need to describe algorithm: typical two-pointer: fast and slow; iterate, if non-zero, assign to nums[slow], increment slow; after loop, fill zeros from slow to end.\n\nWe produce Start, then steps. Use 虛擬碼 arrow. Ensure each line has \"虛擬碼步驟\" then space then comment.\n\nWe produce lines:\n\nStart // 程式開始執行\n→ Step 1: initialize slow = 0 // slow pointer at position to place next non-zero\n→ Step 2: for fast from 0 to length-1 // iterate through array\n    → Decision: if nums[fast] != 0? // check if current element is non-zero\n        Yes → Step 3: nums[slow] = nums[fast] // copy non-zero to slow position\n        Yes → Step 4: slow = slow + 1 // move slow pointer\n    No → // skip zeros, do nothing\n→ Step 5: for i from slow to length-1 // fill remaining positions with zero\n    → Step 6: nums[i] = 0 // set zero\nEnd // 程式執行結束\n\nBut need to use arrow format. Use indentation. Each line separate.\n\nMake sure to use \"Decision:\" lines and then Yes and No arrows. For loop we can show as \"Step 2: for fast = 0 to n-1\". The decision inside.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 slow = 0 // slow 指標指向下一個要放非零元素的位置  \n→ Step 2: for fast = 0 to nums.length - 1 // fast 指標遍歷整個陣列  \n  Decision: 如果 nums[fast] != 0? // 判斷目前元素是否為非零  \n   Yes → Step 3: nums[slow] = nums[fast] // 把非零元素複製到 slow 指標位置  \n   Yes → Step 4: slow = slow + 1 // 移動 slow 指標到下一個可寫位置  \n  No → // 若為零則不做任何操作，直接跳至下一個 fast  \n→ Step 5: for i = slow to nums.length - 1 // 從 slow 開始填充零  \n  Step 6: nums[i] = 0 // 將剩餘位置設為零  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def moveZeroes(self, nums):\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero_pos = 0  # 指向下一個應該放非零數字的位置\n        for i in range(len(nums)):\n            if nums[i] != 0:\n                nums[zero_pos], nums[i] = nums[i], nums[zero_pos]\n                zero_pos += 1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入，支持 \"nums = [...]\" 或直接 \"[...]\"\n    if \"nums\" in data:\n        try:\n            _, expr = data.split(\"=\", 1)\n        except ValueError:\n            expr = data\n    else:\n        expr = data\n\n    expr = expr.strip()\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若無法解析，直接退出\n        sys.exit()\n\n    # 確保是列表\n    if not isinstance(nums, list):\n        sys.exit()\n\n    # 執行移動 0 的操作\n    Solution().moveZeroes(nums)\n\n    # 輸出結果\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,0,3,12]",
          "expected_output": "[1,3,12,0,0]",
          "success": true,
          "output": "[1, 3, 12, 0, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode397.json",
    "problem_index_in_file": 0,
    "title": "Integer Replacement",
    "description_snippet": "Given a positive integer n, you can apply one of the following operations:\n\n1. If n is even, replace...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for computing min steps to reduce n to 1 with operations: if even n/2; if odd can do n+1 or n-1. Classic problem: integer replacement. Use BFS or recursion with memoization. Minimal steps: use recursion with memo or BFS. Provide virtual code. Let's produce algorithm: Use BFS from n to 1? BFS may overflow for large n. Use DFS with memoization. But we can use iterative with map. Provide steps: Start, Input n, initialize memo dictionary with 1->0, then define function minSteps(x): if x in memo return memo[x]; if x even: res=1+minSteps(x/2); else res=1+min(minSteps(x+1), minSteps(x-1)); memo[x]=res; return res. Then call minSteps(n) and output. Provide pseudo lines accordingly.\n\nWe need to output step-by-step lines with virtual code and comments.\n\nLet's produce something like:\n\nStart // Program starts\n\n→ Input n // read positive integer\n\n→ Declare Map memo // store computed steps\n\n→ memo[1] = 0 // base case\n\n→ Function MinSteps(x): // recursive function\n\n    → Decision: If x in memo? // Check memoization\n\n        Yes → Return memo[x] // Already computed\n\n        No → Decision: If x is even? // Check parity\n\n            Yes → temp = 1 + MinSteps(x / 2) // one operation then solve half\n\n            No → temp = 1 + Min(minSteps(x + 1), MinSteps(x - 1)) // choose best of +/-1\n\n    → memo[x] = temp // store result\n\n    → Return temp\n\n→ result = MinSteps(n) // compute\n\n→ Output result\n\n→ End\n\nBut we must adhere to \"逐行\" each line. Provide each step as separate line. Use arrows and structure.\n\nWe also need to mention recursion function. Use pseudocode lines: \"Function MinSteps(x):\" line etc. Use \"Decision:\" lines.\n\nMake sure to include arrow \"→\" for indentation.\n\nAlso note: \"Use 虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`).\" So we need to use arrow for each line. Provide lines like \"Start // ...\" then arrow.\n\nLet's craft.\n\nAlso we might need to include steps for input and output.\n\nLet's produce.\n\nWe'll produce each line: \"Start // 程式開始執行\"\n\nThen \"→ Input n // 讀取正整數\"\n\nThen \"→ Declare memo // 建立記憶表\"\n\nThen \"→ memo[1] ← 0 // 基礎情況: 1 需要 0 步\"\n\nThen \"→ Function MinSteps(x) // 定義遞迴求解最小步數\"\n\nThen \"→     Decision: 若 x 在 memo 中? // 檢查是否已計算\"\n\nThen \"→         Yes → Return memo[x] // 直接回傳已知結果\"\n\nThen \"→         No → Decision: 若 x 為偶數? // 判斷奇偶\"\n\nThen \"→             Yes → temp ← 1 + MinSteps(x / 2) // 一步除以二後遞迴\"\n\nThen \"→             No  → temp ← 1 + Min(MinSteps(x + 1), MinSteps(x - 1)) // 奇數時兩種選擇，取較小\"\n\nThen \"→     memo[x] ← temp // 記錄結果\"\n\nThen \"→     Return temp // 回傳計算得到的步數\"\n\nThen \"→ EndFunction // 函式結束\"\n\nThen \"→ result ← MinSteps(n) // 取得 n 的最小步數\"\n\nThen \"→ Output result // 顯示結果\"\n\nThen \"End // 程式結束\"\n\nWe should use arrow for all lines; but \"EndFunction\" maybe not necessary. We can just use \"End // 函式結束\" but we can use \"EndFunction\" but specification only says use \"End\". It's ambiguous. Use \"End\" after function.\n\nLet's keep consistent: use \"EndFunction // 函式結束\" maybe okay. But spec only mention \"Start\", \"End\". But inside function we can use \"End\" too? We can use \"End // 函式結束\".\n\nOk.\n\nMake sure each line ends with comment. Provide Chinese explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 讀取正整數  \n→ Declare memo // 建立記憶表（字典）  \n→ memo[1] ← 0 // 基礎情況：1 需要 0 步  \n→ Function MinSteps(x) // 定義遞迴求最小步數的函式  \n→     Decision: 若 x 在 memo 中? // 檢查是否已計算  \n→         Yes → Return memo[x] // 直接回傳已知結果  \n→         No → Decision: 若 x 為偶數? // 判斷奇偶性  \n→             Yes → temp ← 1 + MinSteps(x / 2) // 一步除以二後遞迴  \n→             No  → temp ← 1 + Min(MinSteps(x + 1), MinSteps(x - 1)) // 奇數時兩種選擇，取較小  \n→     memo[x] ← temp // 記錄結果於 memo  \n→     Return temp // 回傳計算得到的步數  \n→ End // 函式結束  \n→ result ← MinSteps(n) // 取得 n 的最小步數  \n→ Output result // 顯示結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def integerReplacement(self, n: int) -> int:\n        \"\"\"Return the minimum number of operations to reduce n to 1.\"\"\"\n        count = 0\n        while n != 1:\n            if n % 2 == 0:          # n is even → divide by 2\n                n //= 2\n            else:                   # n is odd → choose +1 or -1\n                # Special case for 3 or when the lower bit of n>>1 is 0\n                if n == 3 or ((n >> 1) & 1) == 0:\n                    n -= 1\n                else:\n                    n += 1\n            count += 1\n        return count\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入並擷取整數\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"輸入中找不到有效的整數\")\n    n = int(match.group())\n\n    # 計算並輸出結果\n    solver = Solution()\n    result = solver.integerReplacement(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 8",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode387.json",
    "problem_index_in_file": 0,
    "title": "First Unique Character in a String",
    "description_snippet": "Given a string s, find the first non-repeating character in it and return its index. If it does not ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem, line by line, each line has code step and explanation comment. Use Start, Decision, etc. So we need to design algorithm: Count frequency using map, then iterate again to find first non-repeating. But we must output virtual code steps.\n\nWe need to use arrow arrow etc. Format: \"Start // 程式開始執行\" etc.\n\nWe need to produce steps with arrows for decisions. Must not output actual code.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化字典 freq // 建立空字典來記錄每個字符出現次數\n→ Step 2: 迭代字符串 s，對於每個字符 c，將 freq[c] 加 1 // 計算頻率\n→ Decision: s 是否為空? // 若字符串為空則直接返回 -1\n    Yes → Step 3: 返回 -1 // 空字符串沒有非重複字符\n    No  →\n→ Step 4: 再次迭代字符串 s，對於每個字符 c，檢查 freq[c] 是否等於 1\n    → Decision: freq[c] 是否等於 1? // 找到第一個頻率為 1 的字符\n        Yes → Step 5: 返回該字符的索引 // 成功找到非重複字符\n        No  → Continue // 繼續檢查下個字符\n→ Step 6: 若迭代完畢仍未返回，返回 -1 // 無非重複字符\nEnd\n\nBut each line needs a virtual code step and comment. For decisions, we need \"Decision:\" and indent. We can use arrows. Provide steps as shown in example.\n\nWe also need to be careful: For loops, maybe we use \"Loop over s\" steps.\n\nBetter to include \"→ Loop over s: ...\" but not necessary.\n\nWe should use arrow for decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: freq ← 空字典 // 建立頻率字典\n→ Step 2: for 每個字符 c in s: freq[c] ← freq.get(c,0) + 1 // 計算每個字符出現次數\n→ Decision: s 是否為空? // 判斷字符串是否為空\n    Yes → Step 3: return -1 // 空字符串直接返回 -1\n    No  →\n→ Step 4: for 每個索引 i, 字符 c in enumerate(s): // 重新遍歷字符串以尋找第一個非重複字符\n    → Decision: freq[c] == 1? // 檢查字符是否只出現一次\n        Yes → Step 5: return i // 找到第一個非重複字符的索引\n        No  → continue // 不是非重複字符，繼續下一個\n→ Step 6: return -1 // 所有字符都有重複，返回 -1\nEnd // 程式執行結束\n\nThis meets format.\n\nCheck: Each line has \"→\" except start and end? Example uses \"Start\" and \"End\" with no arrow. We can follow that.\n\nAlso Decision uses \"Decision:\" with indentation and Yes→ No→.\n\nOk. Provide.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: freq ← 空字典 // 建立頻率字典，準備統計每個字符出現次數  \n→ Step 2: for 每個字符 c in s: freq[c] ← freq.get(c,0) + 1 // 逐字符累加頻率  \n→ Decision: s 是否為空? // 判斷字符串是否為空  \n Yes → Step 3: return -1 // 空字符串直接返回 -1  \n No  →  \n→ Step 4: for 每個索引 i, 字符 c in enumerate(s): // 重新遍歷字符串尋找第一個非重複字符  \n → Decision: freq[c] == 1? // 檢查字符是否只出現一次  \n  Yes → Step 5: return i // 找到第一個非重複字符的索引  \n  No  → continue // 不是非重複字符，繼續下一個  \n→ Step 6: return -1 // 所有字符都有重複，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import collections\n\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        \"\"\"\n        找到字符串中第一個不重複字符的索引。\n        若不存在，返回 -1。\n        \"\"\"\n        # 計算每個字符的出現次數\n        count = collections.Counter(s)\n        # 再次遍歷，尋找第一個頻率為 1 的字符\n        for i, char in enumerate(s):\n            if count[char] == 1:\n                return i\n        return -1\n\ndef parse_input(line: str) -> str:\n    \"\"\"\n    從類似 's = \"leetcode\"' 的輸入行中提取字符串。\n    \"\"\"\n    line = line.strip()\n    # 找到第一個雙引號\n    first_quote = line.find('\"')\n    if first_quote == -1:\n        # 如果找不到雙引號，直接返回整行\n        return line\n    # 找到最後一個雙引號\n    last_quote = line.rfind('\"')\n    if last_quote == first_quote:\n        # 只有一個雙引號，視為空字符串\n        return \"\"\n    return line[first_quote + 1:last_quote]\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 從標準輸入讀取整行\n    input_line = sys.stdin.readline()\n    # 解析出字符串\n    s = parse_input(input_line)\n    # 計算結果\n    solution = Solution()\n    result = solution.firstUniqChar(s)\n    # 輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"leetcode\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "s = \"loveleetcode\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "s = \"aabb\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode503.json",
    "problem_index_in_file": 0,
    "title": "Next Greater Element II",
    "description_snippet": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for computing next greater element in circular array. Use monotonic stack. Steps: input array, result array, stack indices. Iterate 2*n times. For each index i, value v=nums[i%n]. While stack not empty and nums[stack.top] < v, pop and set res[stack.top] = v. Push i%n onto stack. After loop, remaining indices set to -1. End. Provide each line with explanation. Use Start, End. Use arrows. Provide decision? Possibly none except for while loop and final assignment. We can represent while as Decision: while stack not empty? Yes. Also Decision: If res[stack.top] already set? Actually we set in loop. So implement:\n\nStart\n→ Step 1: Define n = nums.length // 获得数组长度\n→ Step 2: 初始化结果数组 res 长度 n，默认值 -1 // 预设所有结果为 -1\n→ Step 3: 初始化空栈 stack // 用来存放待找到下一个更大数的索引\n→ Step 4: 对 i 从 0 到 2*n-1 循环 // 通过两轮遍历模拟循环数组\n    → Decision: 当前元素值 v = nums[i mod n] // 计算当前访问的值\n        → While stack not empty and nums[stack.top] < v\n            → Step 5: idx = stack.pop() // 弹出栈顶索引\n            → Step 6: res[idx] = v // 为该索引设定下一个更大数\n        → Step 7: stack.push(i mod n) // 将当前索引压入栈\n→ Step 8: 返回 res // 完成所有计算\nEnd\n\nBut need to include arrows: Start, Step, Decision, Yes/No branches. Use arrow for while loop? Use Decision: while stack not empty? Yes → ... No →. We can show while as Decision.\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Step 1: n ← nums.length // 取得陣列長度\n→ Step 2: res ← Array(n) filled with -1 // 初始化結果陣列，預設為 -1\n→ Step 3: stack ← empty // 用於儲存待尋找「下一個更大」索引\n→ Step 4: For i ← 0 To 2*n-1 // 兩輪遍歷，模擬循環\n    → Decision: curr ← nums[i mod n] // 取得目前元素值\n        → Decision: stack not empty AND nums[stack.top] < curr\n            Yes → Step 5: idx ← stack.pop() // 移除堆疊頂部索引\n            Yes → Step 6: res[idx] ← curr // 設定此索引的答案\n            No  → // 走出 while\n        → Step 7: stack.push(i mod n) // 將目前索引壓入堆疊\n→ End // 程式執行結束\n\nBut must output each line as separate with arrow. Use \"→\" for step. Use Decision: for each decision. Need to ensure each line with explanation comment.\n\nWe also need to show the while loop as Decision: while stack not empty AND condition. The inner actions as steps after Yes. But we can flatten.\n\nAlternatively simpler: Use Decision for while loop:\n\n→ Decision: stack not empty AND nums[stack.top] < curr\n    Yes → Step 5: idx ← stack.pop()\n    Yes → Step 6: res[idx] ← curr\n    No  → // exit loop\n\nBut we need to maintain while loop iteration: This decision inside For loop will repeat until No. So we might need to show that. Acceptable.\n\nLet's produce final output accordingly.\n\nAlso include Step 8: return res. End.\n\nEnsure each line ends with // explanation.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← nums.length // 取得陣列長度  \n→ Step 2: res ← Array(n) 全部初始化為 -1 // 預設所有「下一個更大」為 -1  \n→ Step 3: stack ← 空堆疊 // 用來儲存尚未找到「下一個更大」的索引  \n→ Step 4: For i ← 0 To 2*n-1 // 兩輪遍歷，以模擬循環陣列  \n  → Decision: curr ← nums[i mod n] // 取得目前正在考慮的值  \n   → Decision: stack 非空 且 nums[stack.top] < curr // 有更大的值可替代嗎？  \n    Yes → Step 5: idx ← stack.pop() // 取出堆疊頂部索引  \n    Yes → Step 6: res[idx] ← curr // 將 curr 設為該索引的「下一個更大」  \n    No  → // 結束 while，繼續下一個 i  \n  → Step 7: stack.push(i mod n) // 把目前索引壓入堆疊，等待後續更大值  \n→ Step 8: Return res // 所有索引的答案已計算完畢  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextGreaterElements(self, nums):\n        n = len(nums)\n        if n == 0:\n            return []\n        res = [-1] * n\n        stack = []\n        for i in range(2 * n):\n            while stack and nums[stack[-1]] < nums[i % n]:\n                res[stack.pop()] = nums[i % n]\n            if i < n:\n                stack.append(i)\n        return res\n\ndef parse_input(data: str):\n    # Extract the list literal from input like \"nums = [1,2,3]\"\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    list_str = data[start:end+1]\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    solution = Solution()\n    result = solution.nextGreaterElements(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1]",
          "expected_output": "[2,-1,2]",
          "success": true,
          "output": "[2, -1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,3]",
          "expected_output": "[2,3,4,-1,4]",
          "success": true,
          "output": "[2, 3, 4, -1, 4]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode120.json",
    "problem_index_in_file": 0,
    "title": "Triangle",
    "description_snippet": "Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm to compute minimum path sum in a triangle. Likely dynamic programming. Use DP array of size n (bottom row). Iterate from bottom to top. For each row, update dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]. At the end dp[0] is result.\n\nWe should produce lines with arrows and decisions? Not necessary but can include Start, End. Provide explanations. Each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows. Example: \"Start // 程式開始執行\". Then maybe \"→ Step 1: 初始化 dp 為最後一行 // dp 儲存下一層最小路徑和\". Then loop from second-last row up to 0. Use Decision? Possibly no decision. Use nested loop.\n\nWe need \"逐行\" lines. Use indentation to show nested loops: maybe use tabs? But sample uses indentation via spaces. Use \"→\" arrow before each step. For nested loops we can indent with spaces then arrow? In sample, after Decision, they indent nested steps.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 設定 n 為 triangle 的行數 // 取得總行數\n→ Step 2: 初始化 dp 為 triangle 最後一行的值 // dp[j] 代表從該位置到底部的最小路徑和\n→ Decision: 是否還有上一行? // 檢查 i > 0\n    Yes → Step 3: 將 i 設為 n-2 // 設定從倒數第二行開始\n    No  → End // 完成\n\nWe need loops. Use Decision: if i >= 0? But we can use while.\n\nBetter:\n\n→ Decision: i >= 0? // 從倒數第二行往上迭代\n    Yes → Step 4: 對 j 迭代 0 到 i\n        → Step 5: 更新 dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] // 計算最小路徑和\n        → Step 6: j++\n    Yes → Step 7: i-- // 移動到上一行\n    No  → Step 8: Output dp[0] // 最小總和\n→ End // 程式結束\n\nNeed to maintain indentation. Use spaces before arrow? Sample uses indent inside Decision. Use 4 spaces maybe.\n\nLet's craft lines.\n\nMake sure each line ends with \" // 說明\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 n 為 triangle 的行數 // 取得總行數  \n→ Step 2: 初始化 dp 為 triangle 最後一行的值 // dp[j] 代表從該位置到底部的最小路徑和  \n→ Decision: i ≥ 0? // 從倒數第二行往上迭代，i 先設為 n-2  \n    Yes → Step 3: 設定 i 為 n-2 // 開始處理倒數第二行  \n    No  → End // 若 triangle 為空直接結束  \n→ Decision: i ≥ 0? // 檢查是否還有上一行需要處理  \n    Yes → Step 4: 對 j 從 0 到 i 迭代 // 逐個處理當前行的每個元素  \n        → Step 5: 更新 dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] // 計算從此節點到底部的最小路徑和  \n    Yes → Step 6: i ← i - 1 // 移動到上一行  \n    No  → Step 7: 輸出 dp[0] // 最終答案已在 dp[0]  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef minimum_total(triangle):\n    \"\"\"\n    Calculate the minimum path sum from top to bottom of a triangle.\n    Uses bottom‑up dynamic programming with O(n) extra space.\n    \"\"\"\n    if not triangle:\n        return 0\n\n    # dp[j] will hold the minimum path sum starting from triangle[i][j] to the bottom\n    dp = triangle[-1][:]  # start with the last row\n\n    # Iterate from the second‑to‑last row up to the top\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            # The current cell can go to dp[j] or dp[j+1] in the row below\n            dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])\n\n    return dp[0]\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    data = sys.stdin.read().strip()\n\n    # The input format is like: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\n    # Extract the part after the '=' sign\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        triangle = ast.literal_eval(expr.strip())\n    else:\n        # If no '=' is present, assume the whole input is the triangle expression\n        triangle = ast.literal_eval(data)\n\n    result = minimum_total(triangle)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        },
        {
          "example_index": 1,
          "input": "triangle = [[-10]]",
          "expected_output": "-10",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode506.json",
    "problem_index_in_file": 0,
    "title": "Relative Ranks",
    "description_snippet": "You are given an integer array score of size n, where score[i] is the score of the i_th athlete in a...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm. Outline: sort indices by score descending. Then assign rank strings accordingly. Then output array.\n\nWe produce step-by-step pseudocode lines with explanations. Use arrow notation.\n\nLet's produce:\n\nStart\n\n→ Step 1: Create list of pairs (score[i], i) // capture score with original index\n\n→ Step 2: Sort list descending by score // highest first\n\n→ Decision: 是否已排序完成? but not necessary.\n\n→ Step 3: 初始化 result array size n // answer\n\n→ Step 4: For each position idx in sorted list (0-based):\n    If idx == 0: result[originalIndex] = \"Gold Medal\"\n    Else if idx == 1: result[originalIndex] = \"Silver Medal\"\n    Else if idx == 2: result[originalIndex] = \"Bronze Medal\"\n    Else: result[originalIndex] = string(idx+1) // rank number\n\n→ End\n\nWe need to output each line with arrow and comment. Use “→” for each line. Also include decision lines? Not necessary but can include for clarity.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ Step 1: 初始化 pairs 為空列表 // 用於儲存 (score, index) 的對\n→ Step 2: 對 i 從 0 到 n-1 執行:\n    → Step 2a: 將 (score[i], i) 加入 pairs // 取得每位選手的分數及原始位置\n→ Step 3: 對 pairs 進行降序排序依 score // 最高分在前\n→ Step 4: 建立 result 數組長度為 n // 用於存放最終排名\n→ Step 5: 對 pairs 依序遍歷並根據位置分配排名:\n    → Decision: 位置 idx 為 0? // 第一名\n        Yes → Step 5a: result[pairs[idx].index] = \"Gold Medal\" // 金牌\n        No  → Decision: 位置 idx 為 1? // 第二名\n            Yes → Step 5b: result[pairs[idx].index] = \"Silver Medal\" // 銀牌\n            No  → Decision: 位置 idx 為 2? // 第三名\n                Yes → Step 5c: result[pairs[idx].index] = \"Bronze Medal\" // 銅牌\n                No  → Step 5d: result[pairs[idx].index] = string(idx+1) // 其餘排名為數字\n→ End // 程式結束，返回 result\n\nNeed to output each line separately. For indentation we might use tab or spaces; but each line should be independent. For nested decisions we could put multiple lines but each with arrow; but we need to maintain structure. Maybe better to avoid nested decisions by using if-else within loop. But format says we can use Decision lines. We'll produce nested decisions as shown but each line separate.\n\nBut we need \"→ Decision: ...\" lines and then indent \"Yes → ...\". For clarity, we can output each as separate line.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 pairs 為空列表 // 用於儲存 (score, index) 的對  \n→ Step 2: 對 i 從 0 到 n-1 執行:  \n  → Step 2a: 將 (score[i], i) 加入 pairs // 取得每位選手的分數及原始位置  \n→ Step 3: 對 pairs 進行降序排序依 score // 最高分在前  \n→ Step 4: 建立 result 數組長度為 n // 用於存放最終排名  \n→ Step 5: 對 pairs 依序遍歷並根據位置分配排名:  \n  → Decision: 位置 idx 為 0? // 第一名  \n   Yes → Step 5a: result[pairs[idx].index] = \"Gold Medal\" // 金牌  \n   No  → Decision: 位置 idx 為 1? // 第二名  \n    Yes → Step 5b: result[pairs[idx].index] = \"Silver Medal\" // 銀牌  \n    No  → Decision: 位置 idx 為 2? // 第三名  \n     Yes → Step 5c: result[pairs[idx].index] = \"Bronze Medal\" // 銅牌  \n     No  → Step 5d: result[pairs[idx].index] = string(idx+1) // 其餘排名為數字  \nEnd // 程式結束，返回 result",
      "generated_code": "import sys\nimport json\nimport ast\n\nclass Solution:\n    def findRelativeRanks(self, score):\n        if not score:\n            return []\n        # 依分數遞減排序\n        sorted_scores = sorted(score, reverse=True)\n        rank_map = {}\n        for i, s in enumerate(sorted_scores):\n            if i == 0:\n                rank_map[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_map[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_map[s] = \"Bronze Medal\"\n            else:\n                rank_map[s] = str(i + 1)\n        return [rank_map[s] for s in score]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 解析輸入，假設輸入為 Python 列表字面量\n    try:\n        score_list = ast.literal_eval(data)\n    except Exception:\n        score_list = []\n\n    sol = Solution()\n    result = sol.findRelativeRanks(score_list)\n    # 使用 json.dumps 以雙引號輸出\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[5,4,3,2,1]",
          "expected_output": "[\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"Silver Medal\", \"Bronze Medal\", \"4\", \"5\"]"
        },
        {
          "example_index": 1,
          "input": "[10,3,8,9,4]",
          "expected_output": "[\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]",
          "success": true,
          "output": "[\"Gold Medal\", \"5\", \"Bronze Medal\", \"Silver Medal\", \"4\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode451.json",
    "problem_index_in_file": 0,
    "title": "Sort Characters By Frequency",
    "description_snippet": "Given a string s, sort it in decreasing order based on the frequency of the characters. The frequenc...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code lines in Traditional Chinese with comments. Need to cover steps: Start, input string, count frequency, sort by frequency descending, build result string, End. Use virtual code arrows and decision nodes maybe. Use Decision for sorting? Could use loop.\n\nLet's craft.\n\nStart\n→ Step 1: 讀取輸入字串 s // 取得需要排序的字串\n→ Step 2: 建立字典 freq // 用於儲存各字元出現次數\n→ Decision: 遍歷 s 中每個字元 c? // 對字串進行迭代\n    Yes → Step 3: freq[c] = freq.get(c, 0) + 1 // 計算頻率\n    No  → Step 4: 轉換 freq 為字元-頻率對列表 pairs // 將字典轉成可排序的列表\n→ Step 5: 對 pairs 按頻率降序排序 // 依頻率由高到低排列\n→ Step 6: 建立結果字串 result = 空字串 // 用於累積最終結果\n→ Decision: 遍歷 pairs 中每個 (char, count)? // 逐個添加字元\n    Yes → Step 7: result += char * count // 將字元重複 count 次\n    No  → Step 8: 回傳 result // 回傳排序後的字串\nEnd\n\nBut we need arrow \"→\" after each step. Provide explanation.\n\nAlso maybe include Decision labels: Decision: 遍歷 s? But typical decision is for loops? Maybe \"Decision: 是否已遍歷完 s?\" with Yes No. But simpler: use \"Decision:\" for loop condition.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得需要排序的字串  \n→ Step 2: 建立空字典 freq // 用於儲存各字元出現次數  \n→ Decision: 是否已遍歷完 s？ // 檢查是否還有字元需要計數  \n    Yes → Step 3: 取出下一個字元 c ← s[i] // 讀取字串中的下一個字元  \n    Yes → Step 4: freq[c] = freq.get(c, 0) + 1 // 將該字元的頻率加 1  \n    No  → Step 5: 將 freq 轉換為列表 pairs = [(char, count) for char, count in freq.items()] // 建立可排序的字元-頻率對列表  \n→ Decision: 是否已完成 pairs 的排序？ // 檢查排序是否已進行  \n    Yes → Step 6: pairs.sort(key=lambda x: x[1], reverse=True) // 按頻率降序排序  \n    No  → Step 7: 建立空字串 result = \"\" // 用於累積最終結果  \n→ Decision: 是否已遍歷完 pairs？ // 檢查是否還有字元需要輸出  \n    Yes → Step 8: 取出下一個對 (char, count) ← pairs[j] // 讀取下一個字元-頻率對  \n    Yes → Step 9: result += char * count // 將字元重複 count 次追加到結果  \n    No  → Step 10: 回傳 result // 回傳排序後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import Counter\nimport re\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        依照字元出現頻率遞減排序，並回傳排序後的字串。\n        \"\"\"\n        # 計算每個字元的頻率\n        count = Counter(s)\n        # most_common() 會依頻率從高到低回傳字元與頻率對\n        return ''.join([char * freq for char, freq in count.most_common()])\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取資料，解析字串，執行排序後印出結果。\n    \"\"\"\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入中擷取第一組雙引號中的字串\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若輸入本身就是純字串，直接使用\n        s = data\n\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eetr\"",
          "success": true,
          "output": "eetr"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"cccaaa\"",
          "success": true,
          "output": "cccaaa"
        },
        {
          "example_index": 2,
          "input": "s = \"Aabb\"",
          "expected_output": "\"bbAa\"",
          "success": true,
          "output": "bbAa"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode336.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Pairs",
    "description_snippet": "You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code. Steps: Preprocess each word, reverse, store mapping. For each word, check prefix/suffix splits, check palindrome. We need O(total length). We'll produce high-level algorithm pseudocode. Ensure steps line by line, with arrows, decision blocks, comments. We'll not output actual code, just virtual code lines. We'll include steps: Start, Build map, iterate words, for each split, etc. Let's produce.\n\nEnsure each line has \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe'll use \"→\" arrow. We'll include \"Start\" and \"End\". Use indentation maybe not necessary but we can use lines with decisions.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 wordToIndex，將每個 word 及其索引存入 // 方便 O(1) 取得索引  \n→ Step 2: 建立字典 reversedWordToIndex，將每個 word 的逆序及其索引存入 // 用於快速匹配逆序  \n→ Step 3: 建立空列表 result 用於儲存所有符合條件的 (i, j) // 結果容器  \n→ For each word w 與其索引 i in words // 逐一處理每個單詞  \n  → Decision: w 是否為 palindrome? // 確認整個單詞是否為回文  \n   Yes → Step 4: 將 (i, i) 加入 result // 處理空字串或整體回文（如果允許自配）  \n   No  → Step 5: 將 w 的逆序 revW 從 reversedWordToIndex 取得 j 若存在且 j ≠ i  \n    Yes → Step 6: 將 (i, j) 加入 result // w + reverse(w) 成回文  \n    No  → Decision: 是否存在以 w 為前綴/後綴的字串？ // 分析分割點  \n     Yes → For each split position k (0 ≤ k ≤ len(w))  \n      → Decision: w[0:k] 是否 palindrome? // 前半段為回文  \n       Yes → 取 suffix = w[k:]，reverseSuffix = reverse(suffix)  \n        → Step 7: 從 wordToIndex 取得 j 若存在且 j ≠ i  \n         Yes → Step 8: 將 (j, i) 加入 result // reverseSuffix + w 成回文  \n         No → Next split  \n       No → Decision: w[k:] 是否 palindrome? // 後半段為回文  \n        Yes → 取 prefix = w[:k]，reversePrefix = reverse(prefix)  \n         → Step 9: 從 wordToIndex 取得 j 若存在且 j ≠ i  \n          Yes → Step 10: 將 (i, j) 加入 result // w + reversePrefix 成回文  \n          No → Next split  \n       No → Next split  \n→ End // 程式執行結束，result 已包含所有回文對",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # 建立逆序字典，方便快速找對應索引\n        rev_dict = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        for i, word in enumerate(words):\n            n = len(word)\n            for j in range(n + 1):\n                prefix, suffix = word[:j], word[j:]\n\n                # 1. 前綴為逆序且後綴為回文\n                if prefix in rev_dict:\n                    k = rev_dict[prefix]\n                    if k != i and suffix == suffix[::-1]:\n                        res.append([i, k])\n\n                # 2. 後綴為逆序且前綴為回文（需排除 j == 0，避免重複）\n                if j != 0 and suffix in rev_dict:\n                    k = rev_dict[suffix]\n                    if k != i and prefix == prefix[::-1]:\n                        res.append([k, i])\n\n        return res\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 如果輸入形如 words = [\"a\",\"b\"]\n    if \"words\" in data:\n        _, words_part = data.split(\"=\", 1)\n        words_str = words_part.strip()\n    else:\n        words_str = data\n\n    # 解析成列表\n    try:\n        words = ast.literal_eval(words_str)\n    except Exception:\n        # 若解析失敗直接終止\n        sys.exit()\n\n    solution = Solution()\n    result = solution.palindromePairs(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "success": true,
          "output": "[[0, 1], [1, 0], [3, 2], [2, 4]]"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode386.json",
    "problem_index_in_file": 0,
    "title": "Lexicographical Numbers",
    "description_snippet": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudo-code that returns lexicographical order of numbers 1 to n. Must be O(n) time and O(1) space. Classic solution: DFS preorder traversal of virtual tree of numbers, incremental lexicographic order: start at 1, for each number increment accordingly. The pseudo-code: Use current=1; while count <= n; output current; if current*10 <= n: current*=10 else: while current%10==9 or current+1 > n: current/=10; current++; end loop. That's O(n). Use O(1) space.\n\nWe need to produce step-by-step pseudo-code lines with comments.\n\nNeed to output line-by-line. Use Start, End, Decision. Use arrows. Provide each step.\n\nLet's write:\n\nStart // 開始\n→ Step 1: Set current = 1; count = 0; // 初始化變數\n→ Step 2: Set result = empty list; // 儲存結果\n→ Decision: count < n? // 檢查是否已處理所有數字\n    Yes → Step 3: Append current to result; count++; // 將目前數字加入結果並遞增計數\n    Yes → Step 4: If current*10 <= n? // 試圖往子節點深入\n        Yes → Step 5: current = current*10; // 進入子節點（以十倍為前綴）\n        No → Step 6: Decision: (current % 10 == 9) or (current+1 > n)? // 判斷是否需回溯\n            Yes → Step 7: current = current / 10; // 回溯至父節點\n            Yes → Step 8: current = current + 1; // 進入下一兄弟節點\n            No  → Step 6: current = current + 1; // 直接遞增\n    No  → End // 所有數字已處理\n\nBut we need to ensure loops properly. The algorithm uses while. We can use a while loop with Decision. Let's structure:\n\nStart\n→ Step 1: current = 1; count = 0; // init\n→ Step 2: result = [] ; // result list\n→ Decision: count < n? // loop condition\n    Yes → Step 3: result.append(current); count++; // add\n    Yes → Decision: current*10 <= n? // go deeper\n        Yes → Step 4: current = current*10; // deeper\n        No  → Decision: current % 10 == 9 or current+1 > n? // need to backtrack\n            Yes → Step 5: current = current/10; // backtrack\n            Yes → Step 6: current = current+1; // move to sibling\n            No  → Step 5: current = current+1; // normal increment\n    No → End\n\nBut we need to ensure after backtrack we still loop to output. The structure may be slightly off but okay for pseudo-code.\n\nWe might incorporate loop like while count < n: output, then decide next current.\n\nWe should output each line with arrow.\n\nLet's produce more explicit:\n\nStart // 程式開始\n→ Step 1: current ← 1 ; count ← 0 ; // 初始化目前數字與已處理數量\n→ Step 2: result ← empty list ; // 儲存結果\n→ Decision: count < n ? // 只要還有數字未處理就繼續\n    Yes → Step 3: Append current to result ; count ← count + 1 ; // 將 current 加入結果\n    Yes → Decision: current × 10 ≤ n ? // 能否進一步向下生成更長前綴\n        Yes → Step 4: current ← current × 10 ; // 前往子節點\n        No  → Decision: current mod 10 = 9 OR current + 1 > n ? // 需要回溯或直接右移\n            Yes → Step 5: current ← current ÷ 10 ; // 回到父節點\n            Yes → Step 6: current ← current + 1 ; // 進入下一兄弟節點\n            No  → Step 5: current ← current + 1 ; // 正常遞增\n    No  → End // 所有數字已處理完畢\n\nBut maybe need to add Step 7: goto Step 3? But loops automatically go back to Decision because the code is inside a while. So we can assume loop.\n\nWe need to use \"Decision:\" format for if. Use arrows.\n\nLet's output.\n\nAlso need to clarify that step 5 and 6 use same? Actually after backtrack we should also increment current? The algorithm: if current%10==9 or current+1 > n: current/=10; current++; else current++; Actually algorithm: after output, if current*10 <= n: current*=10 else: while current%10==9 or current+1 > n: current/=10; current++; That loop ensures we find next number. So we can encode that.\n\nLet's produce pseudo-code accordingly.\n\nLine by line.\n\nAlso include explanation comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: current ← 1 ; count ← 0 ; // 初始化目前數字與已處理數量  \n→ Step 2: result ← [] ; // 用於儲存最終結果  \n→ Decision: count < n ? // 只要還有數字未處理就繼續  \n    Yes → Step 3: Append current to result ; count ← count + 1 ; // 將目前數字加入結果  \n    Yes → Decision: current × 10 ≤ n ? // 能否進一步向下生成更長前綴（子節點）  \n        Yes → Step 4: current ← current × 10 ; // 前往子節點（在前綴後加 0）  \n        No  → Decision: current mod 10 = 9 OR current + 1 > n ? // 若無子節點或無法右移，需回溯或直接右移  \n            Yes → Step 5: current ← current ÷ 10 ; // 回到父節點  \n            Yes → Step 6: current ← current + 1 ; // 進入下一兄弟節點（右移）  \n            No  → Step 5: current ← current + 1 ; // 正常遞增（右移）  \n    No  → End // 所有數字已處理完畢，結束程式。",
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int) -> list[int]:\n    \"\"\"\n    Return numbers from 1 to n sorted in lexicographical order.\n    Uses O(n) time and O(1) extra space (excluding output list).\n    \"\"\"\n    result = []\n    current = 1\n\n    while len(result) < n:\n        result.append(current)\n\n        if current * 10 <= n:          # go deeper to the leftmost child\n            current *= 10\n        else:\n            # If current ends with 9 or we cannot move to the next sibling,\n            # backtrack until we can increment.\n            while current % 10 == 9 or current + 1 > n:\n                current //= 10\n            current += 1\n\n    return result\n\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse the integer `n`, compute lexicographical order,\n    and print the result list.\n    \"\"\"\n    data = sys.stdin.read()\n    # Extract the first integer found in the input (handles \"n = 13\" or just \"13\")\n    match = re.search(r'\\d+', data)\n    if not match:\n        print(\"[]\")\n        return\n\n    n = int(match.group())\n\n    result = lexical_order(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "success": true,
          "output": "[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode10.json",
    "problem_index_in_file": 0,
    "title": "Regular Expression Matching",
    "description_snippet": "Given an input string s and a pattern p, implement regular expression matching with support for '.' ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanations. No actual code. Should be a high-level algorithm: typical DP approach.\n\nWe need to produce steps: Start, Step 1: input string s and pattern p. Then maybe build DP table of size (m+1)x(n+1). Then initialization dp[0][0] = true, handle patterns with * at beginning. Then iterate over i=0..m, j=0..n, fill dp[i][j]. Use conditions: if p[j-1] == '.' or p[j-1] == s[i-1], etc. Then final answer dp[m][n]. End.\n\nWe need to output each line with arrow. Use virtual code steps with explanation comments.\n\nLet's produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: 取得輸入字串 s 與模式 p // 從使用者取得兩個字串\n\n→ Decision: 是否需要初始化 dp 表? // 建立 DP 表格\n\n→ Step 2: 建立 dp 表格尺寸 (len(s)+1) × (len(p)+1) 並全設 false // 初始化\n\n→ Step 3: 設定 dp[0][0] = true // 空字串與空模式匹配\n\n→ Decision: 是否存在 p 中前綴為 '*' 的情況? // 初始化首列\n\n→ Yes → Step 4: 對 j from 1 to len(p): if p[j-1]=='*' then dp[0][j] = dp[0][j-2] // '*' 可以消除前一字符\n\n...\n\nThen iterate i from 1..len(s):\n\n→ Step 5: 對 i from 1 to len(s):\n\n    → Step 6: 對 j from 1 to len(p):\n\n        → Decision: p[j-1] 是 '.' 或等於 s[i-1]? // 字符匹配\n\n            Yes → Step 7: dp[i][j] = dp[i-1][j-1] // 直接匹配\n\n            No → Decision: p[j-1] 是 '*'? // '*' 需要處理\n\n                Yes → Step 8: if p[j-2] == '.' 或 p[j-2] == s[i-1] then // 前置字符可匹配\n\n                    → Decision: '*' 代表 0 次? // 0 次匹配\n\n                        Yes → Step 9: dp[i][j] = dp[i][j-2] // 0 次\n\n                        No  → Decision: '*' 代表 1 次? // 1 次\n\n                            Yes → Step 10: dp[i][j] = dp[i-1][j] // 1 次\n\n                            No  → Step 11: dp[i][j] = dp[i][j-2] || dp[i-1][j] // 0 次或多次\n\n                No → Step 12: dp[i][j] = false // 無法匹配\n\n→ Step 13: 回傳 dp[len(s)][len(p)] // 結果\n\nEnd // 程式結束\n\nBut we need to ensure each line has a single step and arrow. Could have nested arrow indent. Provide indent lines? Not necessary but we can indent using spaces. The example uses indentation.\n\nLet's produce lines following the pattern. Use \"Step X:\" with description.\n\nWe need to use arrow (→) for each step and decisions use \"Decision:\" and \"Yes →\" \"No →\".\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 輸入字串 s 與模式 p // 取得使用者輸入\n→ Decision: 是否需要建立 DP 表格? // 準備動態規劃表\n    Yes → Step 2: 建立 (len(s)+1)×(len(p)+1) 的布林表 dp 並全部設為 false // 初始化表格\n    Yes → Step 3: 設定 dp[0][0] = true // 空字串與空模式匹配\n→ Decision: 是否存在模式 p 的前綴為 '*'? // 初始化首列\n    Yes → Step 4: 對 j = 1 到 len(p):\n        → Decision: p[j-1] 是 '*'? // '*' 可以消除前一字符\n            Yes → Step 5: dp[0][j] = dp[0][j-2] // 0 次匹配\n→ Step 6: 對 i = 1 到 len(s):\n    → Step 7: 對 j = 1 到 len(p):\n        → Decision: p[j-1] 是 '.' 或 p[j-1] == s[i-1]? // 字符直接匹配\n            Yes → Step 8: dp[i][j] = dp[i-1][j-1] // 直接匹配\n            No → Decision: p[j-1] 是 '*'? // '*' 處理\n                Yes → Step 9: 前置字符 p[j-2] 是 '.' 或 p[j-2] == s[i-1] ?\n                    Yes → Decision: dp[i][j] 是否可以由 0 次或多次匹配得到?\n                        Yes → Step 10: dp[i][j] = dp[i][j-2] || dp[i-1][j] // 0 次或至少 1 次\n                        No  → Step 10: dp[i][j] = false // 無法匹配\n                No → Step 11: dp[i][j] = false // 不是 '*' 且不匹配\n→ Step 12: 回傳 dp[len(s)][len(p)] // 最終匹配結果\nEnd // 程式結束執行\n\nBut we should ensure each line has \"虛擬碼步驟\" and comment. The indentation lines are okay.\n\nBut each line should contain virtual code step and comment. The indent lines also count as a line. We should keep consistent. Might be better to not indent substeps with spaces but use same arrow? The example uses indentation for substeps. We can mimic.\n\nLet's produce final answer accordingly. Ensure to use \"Start\", \"End\". Use Chinese comments. Use \"Step\" numbering maybe.\n\nAlso note: in decision lines, we need \"Decision:\" but we can also include the condition.\n\nLet's craft.\n\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 輸入字串 s 與模式 p // 取得使用者輸入\n→ Decision: 需要建立 DP 表格? // 準備動態規劃\n    Yes → Step 2: 建立 (len(s)+1)×(len(p)+1) 的布林表 dp 並全部設為 false // 初始化表格\n    Yes → Step 3: 設定 dp[0][0] = true // 空字串與空模式匹配\n→ Decision: p 中是否有前綴為 '*' 的情況? // 初始化首列\n    Yes → Step 4: 對 j = 1 到 len(p):\n        → Decision: p[j-1] 為 '*'? // '*' 能消除前一字符\n            Yes → Step 5: dp[0][j] = dp[0][j-2] // 0 次匹配\n→ Step 6: 對 i = 1 到 len(s):\n    → Step 7: 對 j = 1 到 len(p):\n        → Decision: p[j-1] 為 '.' 或 p[j-1] == s[i-1]? // 字符直接匹配\n            Yes → Step 8: dp[i][j] = dp[i-1][j-1] // 直接匹配\n            No → Decision: p[j-1] 為 '*'? // '*' 需要特殊處理\n                Yes → Step 9: 前置字符 p[j-2] 為 '.' 或 p[j-2] == s[i-1] ?\n                    Yes → Decision: dp[i][j] 可由 0 次或多次匹配得到?\n                        Yes → Step 10: dp[i][j] = dp[i][j-2] || dp[i-1][j] // 0 次或至少 1 次\n                        No  → Step 10: dp[i][j] = false // 無法匹配\n                No → Step 11: dp[i][j] = false // 不是 '*' 且不匹配\n→ Step 12: 回傳 dp[len(s)][len(p)] // 最終匹配結果\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        # 初始化首列，處理像 a* 這類能匹配空字串的模式\n        for j in range(2, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        # DP 填表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    # 先假設 * 代表 0 次\n                    dp[i][j] = dp[i][j - 2]\n                    # 如果 * 前一字符與 s[i-1] 匹配，考慮 * 代表 1 次或多次\n                    if p[j - 2] == s[i - 1] or p[j - 2] == '.':\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n        return dp[m][n]\n\ndef parse_input(text: str):\n    # 先嘗試找出引號內的字串\n    quotes = re.findall(r'\"([^\"]*)\"', text)\n    if len(quotes) >= 2:\n        return quotes[0], quotes[1]\n    # 若沒有引號，按空白分割\n    parts = text.strip().split()\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # 最後作為備援，假設第一行是 s，第二行是 p\n    lines = text.strip().splitlines()\n    if len(lines) >= 2:\n        return lines[0].strip(), lines[1].strip()\n    # 如果還是沒有，回傳空字串\n    return \"\", \"\"\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read()\n    s, p = parse_input(raw)\n    sol = Solution()\n    result = sol.isMatch(s, p)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"a*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\", p = \".*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode518.json",
    "problem_index_in_file": 0,
    "title": "Coin Change II",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for coin change combinations using DP. Provide step-by-step with virtual code lines and comments. Format: each line with virtual code + space + // explanation. Use Start, End, Decision. Should be sequential. Likely need loops: iterate coins, amount. Use DP array of length amount+1. Initialize dp[0] = 1. For each coin, for i from coin to amount, dp[i] += dp[i-coin]. At end return dp[amount].\n\nWe need to output virtual code line by line, with explanation. Should not output actual code but virtual representation.\n\nWe need to include \"Start\" and \"End\". Also decision statements maybe for checking if amount==0 etc. But primarily loops. Could use Decision for if amount==0 then return 1? But simpler to set dp[0]=1. Provide step: Initialize DP array length amount+1 all zeros // etc. Set dp[0] = 1. For each coin in coins: For i from coin to amount: dp[i] = dp[i] + dp[i-coin]. After loops, return dp[amount].\n\nUse virtual syntax. Eg:\n\nStart // 程式開始執行\n→ Step 1: 初始化 dp 數組長度 amount+1 全部設為 0 // 建立 DP 表格\n→ Step 2: dp[0] ← 1 // 基礎情況：金額 0 有一種組合，即不拿硬幣\n→ Decision: coins 是否非空? // 檢查硬幣集合是否有硬幣\n    Yes → For each coin in coins: // 遍歷每種硬幣\n        → Step 3: 將 i 從 coin 到 amount 遍歷: // 對每個金額進行更新\n            → Step 4: dp[i] ← dp[i] + dp[i-coin] // 加入使用該硬幣的組合數\n    No  → // 若無硬幣，直接結束\n→ Step 5: Return dp[amount] // 回傳能組成 amount 的組合數\nEnd // 程式執行結束\n\nBut need more granular steps? The requirement: \"逐行地產生對應的虛擬碼\" and \"在每行虛擬碼之後立即提供該行的簡短、直觀的解釋\". So each line should contain step name and comment. Should use arrow and structure. Provide arrow for each step. Use \"→\" for steps. Decision blocks with Yes/No. For loops maybe we can indicate with \"Loop over coins\". Could include \"For\" step.\n\nLet's produce accordingly. Use Start and End. Provide decision. Use steps numbering? Not necessary but okay.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 建立 dp 陣列長度 amount+1 且全部為 0 // 初始化 DP 表\n→ Step 2: 設定 dp[0] ← 1 // 金額 0 只有一種組合：不拿任何硬幣\n→ Decision: coins 是否為空? // 判斷硬幣清單是否有硬幣\n    Yes → For coin in coins: // 遍歷每一種硬幣\n        → Step 3: 對金額 i 從 coin 到 amount 進行迭代: // 逐金額更新\n            → Step 4: dp[i] ← dp[i] + dp[i-coin] // 加入使用此硬幣的組合數\n    No  → // 若無硬幣，跳過迴圈\n→ Step 5: 回傳 dp[amount] // 結果為所有硬幣組合的數量\nEnd // 程式結束\n\nNeed to ensure each line has arrow and comment. The decision block lines also need arrow? According to example, Decision line itself is not indented; Yes→ and No→ lines indented. Use same format. Provide \"Decision:\" line.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列長度 amount+1 且全部為 0 // 初始化 DP 表格，存放每個金額的組合數  \n→ Step 2: 設定 dp[0] ← 1 // 金額 0 有一種組合：不拿任何硬幣  \n→ Decision: coins 是否為空? // 判斷硬幣清單是否有硬幣  \n Yes → For coin in coins: // 遍歷每一種硬幣  \n  → Step 3: 對金額 i 從 coin 到 amount 進行迭代: // 逐金額更新 DP  \n   → Step 4: dp[i] ← dp[i] + dp[i-coin] // 加入使用此硬幣的組合數  \n No  → // 若無硬幣，直接跳過迴圈  \n→ Step 5: 回傳 dp[amount] // 結果為所有硬幣組合的數量  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def change(self, amount: int, coins):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                dp[i] += dp[i - coin]\n        return dp[amount]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 假設輸入格式為 \"amount, [coin1,coin2,...]\"\n    amount_str, coins_str = data.split(',', 1)\n    amount = int(amount_str.strip())\n    coins = ast.literal_eval(coins_str.strip())\n    sol = Solution()\n    print(sol.change(amount, coins))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "5, [1,2,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "3, [2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "10, [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode434.json",
    "problem_index_in_file": 0,
    "title": "Number of Segments in a String",
    "description_snippet": "Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contigu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, each line with \"虛擬碼步驟 // 解釋\". Must not output real code, only pseudocode structure. Use arrow, Start, End, Decision.\n\nNeed to handle: given string s, count segments: contiguous non-space sequences. We can split by spaces or iterate. Provide algorithm steps.\n\nWe should produce a structured approach: Start → Initialize count = 0, inSegment = False → iterate over characters → Decision: char is not space? If Yes: if not inSegment, increment count, set inSegment True → else (space): set inSegment False → after loop → Output count → End.\n\nAdd comments. Must be in Chinese Traditional. Ensure format: each line with virtual code step, then space, then // explanation. Use arrow symbols: →, Yes →, No →.\n\nWe need to maintain the structure of decision blocks. Let's produce something like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 count = 0，inSegment = False // 設定計數器與狀態\n→ Step 2: 從頭到尾遍歷字串 s 的每個字符 ch // 逐字元檢查\n    → Decision: ch 是否為空格? // 判斷是否為分隔符\n        No  → Decision: 是否已進入段落? // 確定是否已開始統計段落\n            No  → Step 3: count += 1 // 新段落開始，計數加一\n            Yes → Step 4: // 仍在同一段落，無需改變計數\n        Yes → Step 5: inSegment = False // 遇到空格，段落結束\n→ Step 6: inSegment = True // 進入段落\n→ Step 7: // 迴圈結束後，count 為段落數目\n→ Step 8: 輸出 count // 回傳結果\nEnd // 程式執行結束\n\nBut need to use arrow formatting precisely. For decisions, we might have:\n\n→ Decision: ch == ' '?\n    Yes → Step 5: inSegment = False\n    No  → Decision: inSegment == False?\n        Yes → Step 3: count += 1; inSegment = True\n        No  → // continue\n\nBut we need to ensure each line has \"虛擬碼步驟 // 解釋\". Also indentation for decision branches maybe. Let's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 count = 0, inSegment = False // 設定段落計數與狀態\n→ Step 2: 從 s 的第一個字元到最後一個字元遍歷 ch // 逐字元處理\n    → Decision: ch 是否為空格? // 判斷是否為分隔符\n        Yes → Step 3: inSegment = False // 遇到空格，段落結束\n        No  → Decision: inSegment == False? // 檢查是否已進入段落\n            Yes → Step 4: count += 1; inSegment = True // 新段落開始\n            No  → // 仍在同一段落，無需處理\n→ Step 5: // 迴圈結束，count 為段落數\n→ Step 6: 輸出 count // 回傳結果\nEnd // 程式執行結束\n\nBut we need each step line to be separate. The decisions may have nested steps. For each step we need a line. Decision lines don't have explanation? The format: \"虛擬碼步驟 // 解釋\". So Decision lines also need explanation. For example: \"Decision: ch 是否為空格? // 判斷是否為分隔符\". Good.\n\nBut for indentation we need to show nested structure, but the requirement only says use arrow and Decision. So we can indent nested lines with spaces maybe. Provide proper structure.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 count = 0, inSegment = False // 設定段落計數與是否處於段落的狀態  \n→ Step 2: 從 s 的第一個字元到最後一個字元遍歷 ch // 逐字元處理  \n  → Decision: ch 是否為空格? // 判斷目前字元是否為分隔符  \n  Yes → Step 3: inSegment = False // 遇到空格，結束當前段落  \n  No  → Decision: inSegment == False? // 檢查是否已進入段落  \n  Yes → Step 4: count += 1; inSegment = True // 新段落開始，計數加一  \n  No  → // 仍在同一段落，無需變更計數  \n→ Step 5: // 迴圈結束，count 為總段落數目  \n→ Step 6: 輸出 count // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_segments(s: str) -> int:\n    \"\"\"\n    計算字串 s 中非空白字符的連續片段數量。\n    使用 str.split() 以空白字符分隔，並去除空字串。\n    \"\"\"\n    return len(s.split())\n\ndef main() -> None:\n    \"\"\"\n    1. 從標準輸入讀取全部資料。\n    2. 從資料中提取被單引號或雙引號包圍的字串，若不存在則直接使用整個輸入。\n    3. 計算段落數並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    # 先嘗試從引號中提取字串\n    match = re.search(r'([\\'\"])(.*?)\\1', data, re.S)\n    if match:\n        s = match.group(2)\n    else:\n        s = data.strip()\n    result = count_segments(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"Hello, my name is John\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "s = \"Hello\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode483.json",
    "problem_index_in_file": 0,
    "title": "Smallest Good Base",
    "description_snippet": "Given an integer n represented as a string, return the smallest good base of n.\n\nWe call k >= 2 a go...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for algorithm: given string n, find smallest base k >= 2 such that representation of n in base k consists only of '1's. The number n can be large up to maybe 10^18? But represented as string.\n\nWe need to find minimal base k such that n = (k^m - 1)/(k - 1) for some m >= 2 (since all digits 1, length m). So n = 1 + k + k^2 + ... + k^{m-1}.\n\nWe can search for m from largest to 2. Because minimal base occurs with largest m? Actually smaller base yields larger m. But we want smallest base k. Usually larger m leads to smaller k. But we need to search for m from floor(log2(n)) down to 2, compute k as integer root of equation. For each m, we can approximate k = floor(n^(1/(m-1))) maybe. Use binary search for k. Then check if sum of geometric series equals n.\n\nEdge cases: n is \"3\" (k=2, m=2). For n is power of two? For m=2, k = n-1. Actually for m=2, sum = 1 + k = n => k = n-1. So minimal base is min over all m.\n\nWe also consider n is itself all 1's in base n-1? yes.\n\nSo algorithm steps: Parse n as big integer maybe. But we only need operations: exponent, pow, big integer. But pseudocode can mention BigInt.\n\nSteps:\n\n1. Convert string to BigInt n.\n\n2. Compute maxM = floor(log2(n)) + 1 maybe. Because for base 2, representation length m satisfies 2^{m-1} <= n < 2^m, so m <= log2(n)+1.\n\n3. For m from maxM down to 2:\n   - Find k by binary search between 2 and n^(1/(m-1)) + 1.\n   - For each k, compute sum = (k^m - 1) / (k - 1). Use BigInt exponent and division.\n   - If sum == n, return k.\n\n4. If none found, return n-1 (for m=2). Because for m=2, k = n-1.\n\nAlso handle when n fits into normal integer.\n\nNow produce virtual code lines with explanations.\n\nLet's craft each line with appropriate arrow and decision.\n\nPseudo code:\n\nStart\n→ Step 1: Parse n from string to BigInt // 把輸入字串轉成大整數\n→ Step 2: If n == 3 return 2 // 3的最小好底是2\n→ Step 3: maxM = floor(log2(n)) + 1 // 计算最大可能长度\n→ Step 4: For m from maxM down to 2\n   → Decision: 是否已找到最小底? // 用found flag\n        No → Step 5: low=2, high= floor(n^(1/(m-1))) + 1 // 二分搜尋k的上下界\n            → Step 6: While low <= high\n                → Decision: 计算mid = (low+high)//2 是否满足? // 计算中点\n                    → Step 7: sum = (mid^m -1)/(mid-1) // 计算几何级数和\n                    → Decision: sum == n?\n                        Yes → Step 8: return mid // 找到符合的k\n                        No → Decision: sum < n?\n                            Yes → Step 9: low = mid +1 // 需要更大k\n                            No  → Step 10: high = mid -1 // 需要更小k\n            → Step 11: 结束循环 // 未找到此m的k\n   → Step 12: 结束 for\n→ Step 13: return n-1 // 默认情况 m=2 的结果\n\nBut need to use virtual code syntax: Start, End, Decision:, Yes →, No →, etc.\n\nLet's format each line accordingly.\n\nWe'll produce each line with explanatory comment after //.\n\nNeed to maintain indentation for nested blocks.\n\nLet's generate.\n\nWe also need to include End.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: n ← BigInt(inputString) // 轉成大整數\n→ Decision: n == 3?\n    Yes → Step 2: return 2 // 3的最小好底為2\n    No  →\n→ Step 3: maxM ← floor(log2(n)) + 1 // 最大可能的位數\n→ Step 4: found ← false // 找到標誌\n→ Step 5: For m from maxM downto 2\n    → Decision: found?\n        Yes → Break // 已找到答案\n        No  →\n            → Step 6: low ← 2 // 二分搜尋下界\n            → Step 7: high ← floor(n^(1/(m-1))) + 1 // 上界\n            → Step 8: While low ≤ high\n                → Decision: True?\n                    → Step 9: mid ← (low + high) // 2 // 取中點\n                    → Step 10: sum ← (mid^m - 1) / (mid - 1) // 幾何級數總和\n                    → Decision: sum == n?\n                        Yes → Step 11: return mid // 找到最小好底\n                        No  →\n                            → Decision: sum < n?\n                                Yes → Step 12: low ← mid + 1 // 需要更大的底\n                                No  → Step 13: high ← mid - 1 // 需要更小的底\n            → Step 14: // 此m沒有找到合適的底\n        →\n→ Step 15: // 若所有m都未找到，回退到 m=2 的情況\n→ Step 16: return n - 1 // 所有位數為1時的最小好底\nEnd // 程式結束\n\nNeed to ensure the syntax: Use arrow \"→\". Decision blocks need indentation. Use \"Yes →\" and \"No →\". Use \"Break\" to exit loop. Use \"For\" as a step.\n\nAlso we need to use \"Decision:\" lines. Provide comment.\n\nLet's format properly.\n\nAlso we need to maintain line numbers? Not necessary.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: n ← BigInt(inputString) // 先把輸入字串轉成大整數\n→ Decision: n == 3?\n    Yes → Step 2: return 2 // 3 的最小好底是 2\n    No  → // 不是 3，繼續處理\n→ Step 3: maxM ← floor(log2(n)) + 1 // 估算最大的位數（對於基 2 時的上限）\n→ Step 4: found ← false // 記錄是否已找到答案\n→ Step 5: For m from maxM downto 2\n    → Decision: found?\n        Yes → Break // 已找到答案，跳出迴圈\n        No  → // 仍需搜尋\n            → Step 6: low ← 2 // 二分搜尋下界\n            → Step 7: high ← floor(n^(1/(m-1))) + 1 // 二分搜尋上界\n            → Step 8: While low ≤ high\n                → Decision: true?\n                    → Step 9: mid ← (low + high) // 2 // 取中點\n                    → Step 10: sum ← (mid^m - 1) / (mid - 1) // 計算 1 + mid + … + mid^{m-1}\n                    → Decision: sum == n?\n                        Yes → Step 11: return mid // 找到符合條件的基數\n                        No  →\n                            → Decision: sum < n?\n                                Yes → Step 12: low ← mid + 1 // 需要更大的基數\n                                No  → Step 13: high ← mid - 1 // 需要更小的基數\n            → Step 14: // 本次 m 沒有找到適合的基數，繼續下一個 m\n    → // 迴圈結束\n→ Step 15: // 若所有 m 都沒找到，預設 m=2 的情況\n→ Step 16: return n - 1 // 1 + (n-1) = n，符合條件\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def smallestGoodBase(self, n: str) -> str:\n        # 把字串轉成整數\n        N = int(n)\n        # 計算最大可能的位數，對於 base 2 時的上限\n        max_m = N.bit_length()\n        # 從最大的位數開始檢查\n        for m in range(max_m, 1, -1):\n            low, high = 2, N - 1\n            while low <= high:\n                k = (low + high) // 2\n                # 計算 1 + k + k^2 + ... + k^(m-1)\n                # 這等於 (k^m - 1) // (k - 1)\n                s = (pow(k, m) - 1) // (k - 1)\n                if s == N:\n                    return str(k)\n                elif s < N:\n                    low = k + 1\n                else:\n                    high = k - 1\n        # 如果沒有找到，則一定是 m=2 的情況，k = N-1\n        return str(N - 1)\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從輸入中提取第一個整數（允許帶引號或等號）\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n_str = match.group()\n    sol = Solution()\n    result = sol.smallestGoodBase(n_str)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = \"13\"",
          "expected_output": "\"3\"",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = \"4681\"",
          "expected_output": "\"8\"",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 2,
          "input": "n = \"1000000000000000000\"",
          "expected_output": "\"999999999999999999\"",
          "success": true,
          "output": "999999999999999999"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode326.json",
    "problem_index_in_file": 0,
    "title": "Power of Three",
    "description_snippet": "Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in traditional Chinese with explanations. Steps: check n <= 0, else loop dividing by 3 while divisible. Return false if remainder. Provide Start, End. Use Decision and Yes/No arrow. Provide line by line.\n\nLet's create steps: Start. Step 1: Input n. Decision if n <= 0? Yes -> return false. No -> Continue. Step 2: While n % 3 == 0 -> divide. Decision if n == 1? Yes -> return true. No -> If n % 3 !=0 then return false. Use loops.\n\nWe need \"虛擬碼步驟\" then comment. Use arrow. Eg:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入整數 n // 取得使用者輸入的數值\n\n→ Decision: 如果 n <= 0? // 檢查是否為非正數\n\n    Yes → Step 2: 回傳 false // 非正數非三次方\n\n    No  → Step 3: 將 n 轉為整數 // 確保 n 為整數（可省略）\n\n→ Decision: 如果 n == 1? // 直接三次方\n\n    Yes → Step 4: 回傳 true\n\n    No  → Step 5: 設定 flag 為 true // 循環開始\n\n→ Loop: While n % 3 == 0\n\n    → Step 6: n = n / 3 // 除以 3\n\n    → Decision: 如果 n == 1? // 如果剩下 1，則三次方\n\n        Yes → Step 7: 回傳 true\n\n        No  → Decision: 如果 n % 3 != 0? // 若不能再整除，則非三次方\n\n            Yes → Step 8: 回傳 false\n\n            No  → Loop繼續\n\nBut need to follow output format: Each line must contain \"虛擬碼步驟\" + space + \"// 解釋\".\n\nUse arrows as per spec: \"→ Step\" etc.\n\nAlso Decision lines must have indent maybe 4 spaces. Provide Yes/No arrows.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入的數值  \n→ Decision: n <= 0? // 檢查是否為非正數  \n    Yes → Step 2: 回傳 false // 非正數不是三次方  \n    No  → Step 3: 初始化 n // 確保 n 為整數，為後續計算做準備  \n→ Decision: n == 1? // 直接三次方（3^0）  \n    Yes → Step 4: 回傳 true // n 已經是 1，符合條件  \n    No  → Step 5: 進入除以 3 的循環 // 開始檢查是否能被 3 整除  \n→ Loop: n % 3 == 0  \n    → Step 6: n = n / 3 // 將 n 除以 3  \n    → Decision: n == 1? // 除完後是否為 1  \n        Yes → Step 7: 回傳 true // 成功確認為三次方  \n        No  → Decision: n % 3 != 0? // 是否還能整除 3  \n            Yes → Step 8: 回傳 false // 無法整除，非三次方  \n            No  → Step 9: 繼續 Loop // 再次嘗試除以 3  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        \"\"\"判斷 n 是否為 3 的冪。\"\"\"\n        if n <= 0:\n            return False\n        while n % 3 == 0:\n            n //= 3\n        return n == 1\n\ndef main() -> None:\n    # 讀取整個輸入（可為多行），並提取第一個整數\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    numbers = re.findall(r'-?\\d+', data)\n    if not numbers:\n        return\n    n = int(numbers[0])\n\n    solution = Solution()\n    result = solution.isPowerOfThree(n)\n    # 按題目要求輸出小寫的 true / false\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 27",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = -1",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode179.json",
    "problem_index_in_file": 0,
    "title": "Largest Number",
    "description_snippet": "Given a list of non-negative integers nums, arrange them such that they form the largest number and ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for largest number problem. Outline: sort numbers as strings with custom comparator compare a+b vs b+a, then join, handle leading zeros. Steps: Start, Step1: Convert nums to strings. Step2: Sort using custom comparator. Step3: Concatenate sorted list. Step4: If result starts with '0', return '0'. End.\n\nWe need to output each line with arrow and explanation. Use Start, →, Decision etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將 nums 中的每個整數轉為字串集合 strNums // 方便字串比較  \n→ Step 2: 以自訂比較器 sort strNums，排序條件為 a+b > b+a 時 a 排前 // 使拼接後最大  \n→ Step 3: 將排好序的字串依序連接成大數字 result // 取得最終字串  \n→ Decision: result 的首字元是否為 '0'? // 檢查是否全為零  \n  Yes → Step 4: 設 result = '0' // 全零情況回傳單一 0  \n  No  → // result 已為最大數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        # 把所有整數轉成字串，方便比較\n        nums_str = list(map(str, nums))\n\n        # 自訂比較器：若 x+y > y+x，x 應排在前面\n        def compare(x, y):\n            if x + y > y + x:\n                return -1\n            elif x + y < y + x:\n                return 1\n            else:\n                return 0\n\n        # 依照比較器排序\n        nums_str.sort(key=cmp_to_key(compare))\n\n        # 連接排序後的字串\n        result = ''.join(nums_str)\n\n        # 若全是 0，直接回傳 '0'\n        return '0' if result[0] == '0' else result\n\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取數字列表。\n    支援類似 'nums = [10,2]' 或純粹 '[10,2]' 的格式。\n    \"\"\"\n    # 找出所有整數\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    return numbers\n\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n\n    # 解析數字列表\n    nums = parse_input(raw_input)\n\n    # 計算最大數字\n    sol = Solution()\n    largest = sol.largestNumber(nums)\n\n    # 依照題目要求，輸出帶雙引號的字串\n    print(f'\"{largest}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,2]",
          "expected_output": "\"210\"",
          "success": true,
          "output": "\"210\""
        },
        {
          "example_index": 1,
          "input": "nums = [3,30,34,5,9]",
          "expected_output": "\"9534330\"",
          "success": true,
          "output": "\"9534330\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode232.json",
    "problem_index_in_file": 0,
    "title": "Implement Queue using Stacks",
    "description_snippet": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should supp...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing MyQueue using two stacks. Provide step-by-step pseudocode with explanation per line. Use arrows, Start, End, Decision. Use only stack operations.\n\nWe should design algorithm: two stacks: stack_in and stack_out. push: push onto stack_in. pop: if stack_out empty, transfer all from stack_in to stack_out; then pop from stack_out. peek: similar, but return top of stack_out. empty: check both stacks empty.\n\nWe'll produce lines with virtual code. Each line: \"Step X: ...\" with // explanation.\n\nNeed to use arrow for transitions: e.g., \"→ Step 1: Initialize stack_in, stack_out // Create two empty stacks\". Use Decision blocks for if.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個空堆疊 stack_in, stack_out // 用兩個堆疊來模擬隊列  \n\n// push 操作  \n→ Step 2: 函式 push(x) // 新增元素到隊列尾  \n→ Decision: 直接將 x 推進 stack_in? // 將所有入列元素保存在 stack_in  \n    Yes → Step 3: stack_in.push(x) // 將元素放到 stack_in 的頂部  \n\n// pop 操作  \n→ Step 4: 函式 pop() // 移除並返回隊列首元素  \n→ Decision: stack_out.isEmpty()? // 若 stack_out 為空，需要將元素移轉  \n    Yes → Step 5: while !stack_in.isEmpty()  \n    →   Step 6: temp = stack_in.pop() // 取出 stack_in 的頂部元素  \n    →   Step 7: stack_out.push(temp) // 放入 stack_out  \n    No → Step 8: // stack_out 已經有元素，直接執行以下操作  \n→ Step 9: return stack_out.pop() // 從 stack_out 的頂部取出並返回，對應隊列首  \n\n// peek 操作  \n→ Step 10: 函式 peek() // 取得隊列首元素但不移除  \n→ Decision: stack_out.isEmpty()? // 若 stack_out 為空，需要先轉移  \n    Yes → Step 11: while !stack_in.isEmpty()  \n    →   Step 12: temp = stack_in.pop()  \n    →   Step 13: stack_out.push(temp)  \n    No → Step 14: // stack_out 已準備好  \n→ Step 15: return stack_out.peek() // 只查看 stack_out 的頂部  \n\n// empty 操作  \n→ Step 16: 函式 empty() // 檢查隊列是否為空  \n→ Decision: stack_in.isEmpty() AND stack_out.isEmpty()? // 兩個堆疊皆空  \n    Yes → Step 17: return true // 隊列為空  \n    No  → Step 18: return false // 隊列非空  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def push(self, x):\n        self.stack_in.append(x)\n\n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n\n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n\n    def empty(self):\n        return not self.stack_in and not self.stack_out\n\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if lines and lines[0] == 'Input':\n        lines = lines[1:]\n\n    if len(lines) < 2:\n        print('[]')\n        return\n\n    ops = ast.literal_eval(lines[0])\n    args = ast.literal_eval(lines[1])\n\n    results = []\n    obj = None\n\n    for op, arg in zip(ops, args):\n        if op == 'MyQueue':\n            obj = MyQueue()\n            results.append(None)\n        elif op == 'push':\n            obj.push(arg[0])\n            results.append(None)\n        elif op == 'pop':\n            results.append(obj.pop())\n        elif op == 'peek':\n            results.append(obj.peek())\n        elif op == 'empty':\n            results.append(obj.empty())\n\n    def fmt(val):\n        if val is None:\n            return 'null'\n        if isinstance(val, bool):\n            return str(val).lower()\n        return str(val)\n\n    output = '[' + ', '.join(fmt(v) for v in results) + ']'\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 1, 1, false]",
          "success": true,
          "output": "[null, null, null, 1, 1, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode493.json",
    "problem_index_in_file": 0,
    "title": "Reverse Pairs",
    "description_snippet": "Given an integer array nums, return the number of reverse pairs in the array.\n\nA reverse pair is a p...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm to count reverse pairs in array. Should be step-by-step algorithm using merge sort divide and count technique. Provide steps with decisions. The user wants virtual code, not actual code. So produce lines with \"Start\", \"Step 1: ...\" etc. Provide explanation comments. Should be in Chinese Traditional. We'll output step-by-step algorithm.\n\nNeed to output each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nLet's design algorithm:\n\n- Start\n- Step 1: 定義遞迴函式 CountPairs(nums, left, right) // 計算子陣列的逆序對\n- Decision: 如果 left >= right? // 只有一個或零個元素\n    Yes → Return 0\n    No → Step 2: mid = (left+right)/2\n- Step 3: 左邊逆序對 = CountPairs(nums, left, mid)\n- Step 4: 右邊逆序對 = CountPairs(nums, mid+1, right)\n- Step 5: 初始化 count = left_ri + right_ri\n- Decision: Count cross pairs between left and right halves\n    We'll loop i from left to mid, j = mid+1 while j <= right and nums[i] > 2*nums[j]\n    For each i, add (j - (mid+1)) to count\n- Step 6: 合併兩個有序子陣列 // 冒泡排序/合併\n- Return count\n\nSo we need to output each step with explanations. Use \"Decision:\" for if, Yes → etc. Use \"→\" for next steps.\n\nWe need to output in Chinese Traditional. Provide explanation after each line.\n\nWe need to produce virtual code step by step. Let's write:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 CountPairs(nums, left, right) // 用遞迴計算子陣列逆序對\n    → Decision: 若 left >= right? // 子陣列只有一個或沒有元素，無逆序對\n        Yes → Return 0 // 直接回傳 0\n        No  → Step 2: mid = (left + right) / 2 // 計算中點，劃分左右子陣列\n→ Step 3: 左側逆序對 = CountPairs(nums, left, mid) // 計算左半部的逆序對\n→ Step 4: 右側逆序對 = CountPairs(nums, mid + 1, right) // 計算右半部的逆序對\n→ Step 5: count = 左側逆序對 + 右側逆序對 // 初始化總計數\n→ Decision: 計算跨越左右子陣列的逆序對\n    // 使用雙指標遍歷，對於每個左半元素 i，找出第一個使 nums[i] <= 2*nums[j] 的 j\n    Yes → For i from left to mid:\n        j = mid + 1\n        While j <= right and nums[i] > 2 * nums[j]:\n            j = j + 1\n        count = count + (j - (mid + 1)) // 把所有符合條件的 j 加入計數\n    No → (此處實際不需要跳過，直接執行循環)\n→ Step 6: 合併 nums[left..mid] 與 nums[mid+1..right] 為有序子陣列 // 以傳統 merge 操作\n→ Return count // 回傳子陣列的逆序對數\nEnd // 程式執行結束\n\nBut we need to include each line with arrows. For loops we can use Step statements. Need to maintain structure: Start, Steps, Decisions, End.\n\nBetter to use \"→ Step 5: count = 左側逆序對 + 右側逆序對 // 初始化總計數\" and then \"→ Decision: 計算跨越左右子陣列的逆序對\" then inside that we need lines for for-loop.\n\nBut the formatting requires each line with \"虛擬碼步驟 // 解釋\". So we need each line like:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 CountPairs(nums, left, right) // 用遞迴計算子陣列逆序對\n→ Decision: left >= right? // 子陣列只有一個或沒有元素，無逆序對\n    Yes → Return 0 // 直接回傳 0\n    No  → Step 2: mid = (left + right) / 2 // 計算中點，劃分左右子陣列\n→ Step 3: leftCount = CountPairs(nums, left, mid) // 計算左半部的逆序對\n→ Step 4: rightCount = CountPairs(nums, mid + 1, right) // 計算右半部的逆序對\n→ Step 5: count = leftCount + rightCount // 初始化總計數\n→ Decision: 計算跨越左右子陣列的逆序對\n    Yes → Step 6: i = left\n        → Step 6.1: j = mid + 1\n        → Decision: i <= mid? // 迭代左半部元素\n            Yes → Step 6.2: Decision: j <= right and nums[i] > 2 * nums[j]? // 判斷是否符合逆序對條件\n                Yes → Step 6.3: j = j + 1 // 移動右指標\n                No  → Step 6.4: count = count + (j - (mid + 1)) // 加入符合條件的個數\n                → Step 6.5: i = i + 1 // 移動左指標\n                → Decision: (回到 Decision: j <= right and nums[i] > 2 * nums[j]?)\n            No  → (跳出循環)\n    No → (不需要執行，直接跳到合併)\n→ Step 7: merge nums[left..mid] 與 nums[mid+1..right] 為有序子陣列 // 合併操作\n→ Return count // 回傳子陣列的逆序對數\nEnd // 程式執行結束\n\nBut we need simpler representation; can avoid too many nested decisions. Provide pseudo-code but keep each line simple. Use \"Decision:\" for if/else, and \"Yes →\", \"No →\" lines. For loops, we can present as Step 6: For i from left to mid: // loop left half\n\nBut we need to ensure each line has \"虛擬碼步驟\" plus \" // 解釋\". So each line is separate. For loops, we can present as \"→ Step 6: For i = left to mid // 遍歷左半部\" etc.\n\nLet's produce a more concise flow:\n\nStart // 程式開始執行\n→ Step 1: Define CountPairs(nums, left, right) // 遞迴計算子陣列逆序對\n→ Decision: left >= right? // 子陣列只有一個或沒有元素\n    Yes → Return 0 // 無逆序對\n    No  → Step 2: mid = (left + right) / 2 // 分割子陣列\n→ Step 3: leftCount = CountPairs(nums, left, mid) // 計算左半部\n→ Step 4: rightCount = CountPairs(nums, mid + 1, right) // 計算右半部\n→ Step 5: count = leftCount + rightCount // 初始總計數\n→ Step 6: i = left // 左指標\n→ Step 7: j = mid + 1 // 右指標\n→ Decision: i <= mid? // 迭代左半部\n    Yes → Decision: j <= right and nums[i] > 2 * nums[j]? // 判斷逆序條件\n        Yes → Step 8: j = j + 1 // 移動右指標\n        No  → Step 9: count = count + (j - (mid + 1)) // 加入符合條件的數量\n            → Step 10: i = i + 1 // 移動左指標\n            → Decision: (回到 Step 7) // 重新檢查\n    No  → (跳出循環)\n→ Step 11: Merge nums[left..mid] 與 nums[mid+1..right] 為有序子陣列 // 合併\n→ Return count // 回傳子陣列的逆序對數\nEnd // 程式結束\n\nBut we need each line to be atomic; the above uses nested decisions with loops. Might be okay.\n\nBut need to ensure each line contains only one \"虛擬碼步驟\" and comment. For loops we might have multiple lines but each line is separate. So the above is fine.\n\nLet's produce final answer. Ensure proper formatting: each line start with \"Start\", \"→ Step ...\", \"→ Decision:\", etc. Provide explanation after \"//\". Use Traditional Chinese. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Define CountPairs(nums, left, right) // 用遞迴計算子陣列的逆序對\n→ Decision: left >= right? // 子陣列只有一個或沒有元素，無逆序對\n    Yes → Return 0 // 直接回傳 0\n    No  → Step 2: mid = (left + right) / 2 // 計算中點，劃分左右子陣列\n→ Step 3: leftCount = CountPairs(nums, left, mid) // 計算左半部的逆序對\n→ Step 4: rightCount = CountPairs(nums, mid + 1, right) // 計算右半部的逆序對\n→ Step 5: count = leftCount + rightCount // 初始化總計數\n→ Step 6: i = left // 設定左指標\n→ Step 7: j = mid + 1 // 設定右指標\n→ Decision: i <= mid? // 迭代左半部\n    Yes → Decision: j <= right and nums[i] > 2 * nums[j]? // 判斷是否符合逆序條件\n        Yes → Step 8: j = j + 1 // 移動右指標\n        No  → Step 9: count = count + (j - (mid + 1)) // 加入符合條件的數量\n            → Step 10: i = i + 1 // 移動左指標\n            → Decision: i <= mid? // 重新檢查左指標是否還在範圍內\n    No  → (跳出循環)\n→ Step 11: Merge nums[left..mid] 與 nums[mid+1..right] 為有序子陣列 // 合併兩個已排序的子陣列\n→ Return count // 回傳子陣列的逆序對數\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reversePairs(self, nums):\n        def merge_sort(start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(start, mid) + merge_sort(mid + 1, end)\n\n            # Count cross pairs\n            j = mid + 1\n            for i in range(start, mid + 1):\n                while j <= end and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - (mid + 1)\n\n            # Merge step\n            temp = []\n            left, right = start, mid + 1\n            while left <= mid and right <= end:\n                if nums[left] <= nums[right]:\n                    temp.append(nums[left])\n                    left += 1\n                else:\n                    temp.append(nums[right])\n                    right += 1\n            while left <= mid:\n                temp.append(nums[left])\n                left += 1\n            while right <= end:\n                temp.append(nums[right])\n                right += 1\n            nums[start:end + 1] = temp\n            return count\n\n        return merge_sort(0, len(nums) - 1)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Accept input like \"nums = [1,3,2,3,1]\" or just \"[1,3,2,3,1]\"\n    if '=' in data:\n        _, list_str = data.split('=', 1)\n        list_str = list_str.strip()\n    else:\n        list_str = data\n\n    # Safely evaluate the list\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        print(\"Invalid input format\")\n        sys.exit()\n\n    if not isinstance(nums, list):\n        print(\"Input should be a list of integers\")\n        sys.exit()\n\n    result = Solution().reversePairs(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,2,3,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [2,4,3,5,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode443.json",
    "problem_index_in_file": 0,
    "title": "String Compression",
    "description_snippet": "Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation, no real code, just pseudocode with arrows, decisions. It should describe algorithm for compressing array in place with constant extra space. We need to show Start, End. Provide line by line with \"虛擬碼步驟\" and explanation. Use arrow and decisions. Should capture steps: iterate through array, count repeats, write to output index, handle single char vs length >1, convert length to digits and write each digit, track output index. At the end, return output length. Should mention constant extra space.\n\nLet's produce lines:\n\nStart\n→ Step 1: 初始化 writeIndex = 0 // 输出写入位置\n→ Step 2: 初始化 readIndex = 0 // 读取位置\n→ Decision: 是否还有未读字符？ // 检查 readIndex < len(chars)\n    Yes → Step 3: 记录 currentChar = chars[readIndex] // 当前字符\n    → Step 4: 初始化 count = 0 // 计数\n    → Step 5: While readIndex < len(chars) 且 chars[readIndex] == currentChar\n        count++\n        readIndex++\n    → Decision: count == 1 ?\n        Yes → Step 6: chars[writeIndex] = currentChar\n               writeIndex++\n        No  → Step 7: chars[writeIndex] = currentChar\n               writeIndex++\n               → Step 8: 轉換 count 為字串 digits = str(count)\n               → Step 9: For each d in digits\n                        chars[writeIndex] = d\n                        writeIndex++\n    → Step 10: 回到 Decision 1\n→ End // 返回 writeIndex\n\nNeed to include explanations.\n\nAdd maybe variable definitions. Should be straightforward.\n\nEnsure format: \"虛擬碼步驟 // 解釋/說明\"\n\nWe will write in Chinese.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 writeIndex = 0 // 設定寫入位置為 0  \n→ Step 2: 初始化 readIndex = 0 // 設定讀取位置為 0  \n→ Decision: readIndex < len(chars) ? // 判斷是否還有未讀的字元  \n    Yes → Step 3: currentChar = chars[readIndex] // 取出目前的字元  \n    → Step 4: count = 0 // 初始化重複次數為 0  \n    → Step 5: While readIndex < len(chars) 且 chars[readIndex] == currentChar  \n        count++  \n        readIndex++  \n    → Decision: count == 1 ? // 判斷是否只重複一次  \n        Yes → Step 6: chars[writeIndex] = currentChar // 直接寫入字元  \n        writeIndex++  \n        No  → Step 7: chars[writeIndex] = currentChar // 先寫入字元  \n        writeIndex++  \n        → Step 8: digits = str(count) // 將計數轉成字串（多位數會分拆）  \n        → Step 9: For 每個 d in digits  \n            chars[writeIndex] = d // 逐位寫入數字字元  \n            writeIndex++  \n    → Step 10: 返回 Decision: readIndex < len(chars) ? // 回到外層判斷  \n→ End // 程式執行結束  \n→ Return writeIndex // 回傳壓縮後的長度，剩餘字元不重要  \n\n說明：  \n- 以上步驟僅使用指標與少量變數，符合常數額外空間。  \n- `digits = str(count)` 只在邏輯上表示將數字拆成多個字符，實際實作可透過除法取餘數完成。  \n- 讀取和寫入均在同一個陣列 `chars` 上完成，確保原地壓縮。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def compress(self, chars):\n        write = 0\n        left = 0\n        n = len(chars)\n        while left < n:\n            right = left\n            while right < n and chars[right] == chars[left]:\n                right += 1\n            chars[write] = chars[left]\n            write += 1\n            count = right - left\n            if count > 1:\n                for c in str(count):\n                    chars[write] = c\n                    write += 1\n            left = right\n        return write\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 將輸入字串轉成列表\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        list_str = data[start:end]\n        chars = ast.literal_eval(list_str)\n    except ValueError:\n        # 若輸入本身就是列表字面量\n        chars = ast.literal_eval(data)\n    result = Solution().compress(chars)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "chars = [\"a\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode541.json",
    "problem_index_in_file": 0,
    "title": "Reverse String II",
    "description_snippet": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for algorithm described: For each 2k block, reverse first k, leave next k unchanged. Edge cases: fewer than k left => reverse all; between k and 2k => reverse first k, keep rest unchanged.\n\nWe need to output lines with virtual code step + comment. Use arrows. Format: Start, → Step ... etc.\n\nNeed to think of algorithm: iterate i from 0 to len(s) step 2k. For each segment: determine start = i, end = min(i+k, len). reverse substring from start to end. The rest remains unchanged.\n\nIn pseudocode: Let result as array of chars. i=0 while i < len(s): // decision block: if i + k <= len? etc.\n\nSimplify: For each i:\n\n- compute start = i\n- compute mid = min(i+k, len)\n- reverse substring s[start:mid] and append to result\n- compute next_start = min(i+2k, len)\n- append s[mid:next_start] as is\n- i += 2k\n\nBut we need to produce virtual steps line by line with explanation.\n\nWe must not output actual code, only structured steps. Use virtual arrows.\n\nWe can include Decision statements for edge cases.\n\nWe should include variable declarations: i, n, result. Use Step 1: Initialize i=0, result=[].\n\nThen while i < n: Decision: Is i+ k <= n? etc.\n\nBut we can also handle using min.\n\nSimplify: Step 2: while i < n: // loop through string\n\nInside loop: Step 3: compute end1 = min(i + k, n) // first part end\n\nStep 4: reverse s[i:end1] // reverse segment\n\nStep 5: append reversed segment to result\n\nStep 6: compute end2 = min(i + 2*k, n) // next part end\n\nStep 7: append s[end1:end2] to result\n\nStep 8: i = end2 // move to next block\n\nFinally, concatenate result into string.\n\nEdge cases automatically handled by min.\n\nAdd explanatory comments.\n\nLet's produce steps.\n\nWe need to use virtual code arrows: Start, → Step, Decision: etc.\n\nLet's write:\n\nStart // 程式開始\n\n→ Step 1: n = length of s // 取得字串長度\n\n→ Step 2: i = 0 // 初始化索引\n\n→ Step 3: result = empty list // 用來儲存處理後的字元\n\n→ Decision: i < n? // 是否還有字元未處理\n\n    Yes → Step 4: end1 = min(i + k, n) // 第一段結束索引（不超過長度）\n\n    → Step 5: reverse_sub = reverse(s[i:end1]) // 反轉第一段\n\n    → Step 6: append reverse_sub to result // 加入結果\n\n    → Step 7: end2 = min(i + 2*k, n) // 第二段結束索引\n\n    → Step 8: append s[end1:end2] to result // 加入未反轉的第二段\n\n    → Step 9: i = end2 // 移動到下一個 2k 區塊\n\n    No → End // 所有字元已處理\n\nFinally, Step 10: output concatenated result // 輸出最終字串\n\nBut we must maintain the arrow structure: Use arrows after each Step line: e.g., \"→ Step 1: n = length of s // ...\".\n\nThe Decision block: \"Decision: i < n?\" with Yes and No.\n\nAlso we might want a final line: \"End // 程式執行結束\".\n\nLet's produce accordingly.\n\nAlso we need to maintain line-by-line with explanation.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: n = length of s // 取得輸入字串的長度\n→ Step 2: i = 0 // 初始化索引為 0\n→ Step 3: result = empty list // 建立空清單用於存放處理後的字元\n→ Decision: i < n? // 是否還有未處理的字元\n    Yes → Step 4: end1 = min(i + k, n) // 第一段的結束索引（不超過字串長度）\n    → Step 5: reverse_sub = reverse(s[i:end1]) // 反轉從 i 到 end1 的子字串\n    → Step 6: append reverse_sub to result // 將反轉後的字元加入結果\n    → Step 7: end2 = min(i + 2*k, n) // 第二段（未反轉）的結束索引\n    → Step 8: append s[end1:end2] to result // 加入未反轉的第二段字元\n    → Step 9: i = end2 // 移動索引到下一個 2k 區塊的起點\n    No  → End // 所有字元已處理，結束迴圈\n→ Step 10: output concatenate(result) // 將結果清單轉為字串並輸出\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        \"\"\"Reverse the first k characters for every 2k block of the string.\"\"\"\n        chars = list(s)\n        n = len(chars)\n        for i in range(0, n, 2 * k):\n            # The end index for the segment to reverse\n            end = min(i + k, n)\n            # Reverse the slice in place\n            chars[i:end] = reversed(chars[i:end])\n        return \"\".join(chars)\n\ndef parse_input(line: str):\n    \"\"\"\n    Parse input in the form: \"<string>\", k  or  <string>, k\n    Handles optional quotation marks around the string.\n    \"\"\"\n    if not line:\n        return None, None\n    # Split on the first comma\n    parts = line.split(',', 1)\n    if len(parts) != 2:\n        return None, None\n    s_part, k_part = parts[0].strip(), parts[1].strip()\n    # Remove surrounding quotes if present\n    if (s_part.startswith('\"') and s_part.endswith('\"')) or (s_part.startswith(\"'\") and s_part.endswith(\"'\")):\n        try:\n            s = ast.literal_eval(s_part)\n        except Exception:\n            s = s_part.strip('\"').strip(\"'\")\n    else:\n        s = s_part\n    try:\n        k = int(k_part)\n    except ValueError:\n        k = 0\n    return s, k\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    input_data = sys.stdin.read().strip()\n    s, k = parse_input(input_data)\n    if s is None or k is None:\n        sys.exit(0)\n    solution = Solution()\n    result = solution.reverseStr(s, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abcdefg\", 2",
          "expected_output": "\"bacdfeg\"",
          "success": true,
          "output": "bacdfeg"
        },
        {
          "example_index": 1,
          "input": "\"abcd\", 2",
          "expected_output": "\"bacd\"",
          "success": true,
          "output": "bacd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode188.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock IV",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: max profit with at most k transactions. Classic DP. We'll produce pseudo steps. Provide Start, Step lines with arrows. Each line followed by // explanation.\n\nWe need to produce step by step algorithm. Use virtual code steps. Should be line by line with arrows.\n\nWe should outline: read array, k. If k >= n/2, unlimited transactions, use greedy sum positive differences.\n\nElse DP: dp[trans][i] etc. Use two arrays: prev, curr.\n\nPseudo:\n\nStart\n→ Read prices array and k\n→ n ← length of prices\n→ If k >= n/2\n    → Profit ← 0\n    → For i from 1 to n-1\n        → If prices[i] > prices[i-1]\n            → Profit ← Profit + (prices[i] - prices[i-1]) // sum all gains\n    → Output Profit\n    → End\n→ Initialize prev[0..n-1] = 0\n→ For t from 1 to k\n    → curr[0] ← 0\n    → maxDiff ← -prices[0]\n    → For i from 1 to n-1\n        → curr[i] ← max(curr[i-1], prices[i] + maxDiff) // best profit today\n        → maxDiff ← max(maxDiff, prev[i] - prices[i]) // update best diff\n    → prev ← curr\n→ Output prev[n-1]\nEnd\n\nAdd comments.\n\nLet's output each line with // explanation. Use virtual code with arrows.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取股票價格陣列 prices 及交易上限 k // 從輸入取得資料  \n→ Step 2: n ← length(prices) // 獲得天數  \n→ Decision: 如果 k ≥ n/2? // 檢查是否可視為無限交易  \n    Yes → Step 3: Profit ← 0 // 初始化利潤  \n    → Step 4: For i ← 1 to n-1  \n        → Decision: 如果 prices[i] > prices[i-1]? // 檢查今天是否高於昨天  \n            Yes → Step 5: Profit ← Profit + (prices[i] - prices[i-1]) // 加入漲幅利潤  \n    → Step 6: Output Profit // 顯示總利潤  \n    → End // 程式結束  \n    No → Step 7: 初始化 prev[0…n-1] ← 0 // DP 前一筆交易的利潤  \n→ Step 8: For t ← 1 to k  \n    → Step 9: curr[0] ← 0 // 第一天無利潤  \n    → Step 10: maxDiff ← -prices[0] // 最佳買入差值初始化  \n    → Step 11: For i ← 1 to n-1  \n        → Decision: 如果 curr[i-1] ≥ prices[i] + maxDiff? // 檢查是否不賣更好  \n            Yes → Step 12: curr[i] ← curr[i-1] // 保持前一筆利潤  \n            No  → Step 13: curr[i] ← prices[i] + maxDiff // 今日賣出利潤  \n        → Step 14: maxDiff ← max(maxDiff, prev[i] - prices[i]) // 更新最佳買入差值  \n    → Step 15: prev ← curr // 交替更新 DP  \n→ Step 16: Output prev[n-1] // 最終利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, k, prices):\n        n = len(prices)\n        if n == 0:\n            return 0\n        # If k is large enough, we can treat it as unlimited transactions\n        if k >= n // 2:\n            profit = 0\n            for i in range(1, n):\n                if prices[i] > prices[i - 1]:\n                    profit += prices[i] - prices[i - 1]\n            return profit\n        # Dynamic programming: dp[t][d] = max profit up to day d with at most t transactions\n        dp = [[0] * n for _ in range(k + 1)]\n        for t in range(1, k + 1):\n            max_diff = -prices[0]          # best value of dp[t-1][d] - prices[d]\n            for d in range(1, n):\n                dp[t][d] = max(dp[t][d - 1], prices[d] + max_diff)\n                max_diff = max(max_diff, dp[t - 1][d] - prices[d])\n        return dp[k][n - 1]\n\ndef main():\n    data = sys.stdin.read()\n    # Extract all integers from the input; the first is k, the rest are prices\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    k = nums[0]\n    prices = nums[1:]\n    solution = Solution()\n    result = solution.maxProfit(k, prices)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 2, prices = [2,4,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "k = 2, prices = [3,2,6,5,0,3]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode522.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence II",
    "description_snippet": "Given an array of strings strs, return the length of the longest uncommon subsequence between them. ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Let's think algorithm: longest uncommon subsequence length between array of strings.\n\nWe can recall known problem: longest uncommon subsequence II. The answer is length of the longest string that is not equal to any other string in the array. Because if a string is unique, it can't be subsequence of any other longer string? Wait: The known solution: if there is any string that is unique, answer is its length; else -1. Because if string appears at least twice, any subsequence of it appears in both; thus cannot be uncommon. And any unique string cannot be a subsequence of other longer string if it's longer than them? Actually if it's longer than others, cannot be subsequence. But if unique but shorter, it might still be subsequence of longer string. However we can pick the longest unique string: Since any longer string unique will be the longest. So answer is length of longest string that appears exactly once; if none, -1.\n\nThus algorithm: count frequencies of each string. Find max length among strings with freq 1. If none, return -1.\n\nLet's produce virtual code with steps. We'll show Start, Step 1: count frequencies; Step 2: iterate array to find max length unique; Step 3: if max==0 return -1 else max.\n\nInclude decision. Also handle empty array? Not necessary.\n\nNow produce steps with arrows. Each line with explanation.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq 用來計數每個字串出現次數 // 準備統計字串頻率  \n→ Decision: 是否有字串需要處理?  \n Yes → Step 2: 對於每個字串 s 在 strs 中  \n     freq[s] ← freq.get(s, 0) + 1 // 更新該字串的頻率  \n     End  \n     → Step 3: 設定 maxLen ← -1 // 目前最佳不常見子序列長度  \n     → Decision: 迭代每個字串 s 在 strs 中  \n      Yes → Decision: freq[s] 等於 1? // 只考慮唯一出現的字串  \n        Yes → Decision: len(s) 大於 maxLen?  \n          Yes → maxLen ← len(s) // 更新更長的唯一字串長度  \n          No  → Step 4: 跳過 // 字串已較短  \n        No  → Step 5: 跳過 // 非唯一字串不可能是不常見子序列  \n      No → End  \n     → Decision: maxLen 為 -1? // 無唯一字串  \n       Yes → Step 6: 回傳 -1 // 不存在不常見子序列  \n       No  → Step 7: 回傳 maxLen // 回傳長度最大唯一字串  \n     No → End  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出最長的不常見子序列長度\n        只要存在一個在陣列中只出現一次的字串，答案即為那個字串的長度\n        若全部字串都有重複，則不存在不常見子序列，回傳 -1\n        \"\"\"\n        if not strs:\n            return -1\n\n        freq = Counter(strs)\n        max_len = -1\n        for s in strs:\n            if freq[s] == 1:\n                max_len = max(max_len, len(s))\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取 JSON 格式的字串陣列\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n        sys.exit()\n    try:\n        strs = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 如果輸入不是合法 JSON，視為無法處理\n        print(-1)\n        sys.exit()\n\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"aba\",\"cdc\",\"eae\"]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode413.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices",
    "description_snippet": "An integer array is called arithmetic if it consists of at least three elements and if the differenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting arithmetic subarrays in an integer array. Provide step-by-step pseudocode with explanation each line. Use arrows and decision. Use Start, End, etc. Provide each line like \"Start // 程式開始執行\". Then each step: maybe initialize count, iterate over array, compute diff, track consecutive diff equality length, when length>=2 add (len-1). Actually standard solution: iterate, maintain current consecutive equal difference count. Let curr = 0; diff = None. For i from 1 to n-1: if nums[i]-nums[i-1] == diff: curr +=1 else curr = 0; diff = nums[i]-nums[i-1]; if curr >=2? Wait count subarrays: if curr>=2 means we have at least 3 elements. Each time we add curr to answer. Actually typical algorithm: ans=0; curr=0; for i from 2 to n-1: if nums[i]-nums[i-1]==nums[i-1]-nums[i-2]: curr+=1 else curr=0; ans+=curr; This works. So pseudocode: Start, input array nums. If len<3, return 0. Initialize ans=0, curr=0. For i from 2 to len(nums)-1: diff1=nums[i]-nums[i-1]; diff2=nums[i-1]-nums[i-2]; If diff1==diff2: curr+=1 else curr=0; ans+=curr; End. Return ans.\n\nWe need virtual code with explanation lines. Use arrows. Use decision block for equality. Provide for loops. Use \"→ Step\" for loops. Use decision inside loop. Should show algorithm clearly. Each line comment in Chinese. Provide maybe variable initialization. Use structure.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 獲取陣列 nums // 取得輸入的整數陣列\n→ Decision: nums 長度 < 3? // 檢查是否能形成至少三個元素\n    Yes → Step 2: 回傳 0 // 沒法形成算術子陣列\n    No  → Step 3: 初始化 ans = 0, curr = 0 // 準備計算\n→ Step 4: for i from 2 to nums.length - 1 // 從第三個元素開始遍歷\n    → Decision: nums[i] - nums[i-1] == nums[i-1] - nums[i-2]? // 判斷差值是否相等\n        Yes → Step 5: curr += 1 // 繼續相等，累加長度\n        No  → Step 6: curr = 0 // 差值不等，重置長度\n    → Step 7: ans += curr // 累加符合算術子陣列的數量\n→ Step 8: 回傳 ans // 結束並回傳結果\nEnd // 程式執行結束\n\nWe might also note that Step 5 and Step 6 inside loop. Provide proper indentation? In virtual code we can nest decision and arrows.\n\nUse indentation? It's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 獲取陣列 nums // 取得輸入的整數陣列  \n→ Decision: nums 長度 < 3? // 檢查是否能形成至少三個元素  \n Yes → Step 2: 回傳 0 // 沒法形成算術子陣列  \n No  → Step 3: 初始化 ans = 0, curr = 0 // 準備計算  \n→ Step 4: for i from 2 to nums.length - 1 // 從第三個元素開始遍歷  \n → Decision: nums[i] - nums[i-1] == nums[i-1] - nums[i-2]? // 判斷差值是否相等  \n  Yes → Step 5: curr += 1 // 繼續相等，累加長度  \n  No  → Step 6: curr = 0 // 差值不等，重置長度  \n → Step 7: ans += curr // 累加符合算術子陣列的數量  \n→ Step 8: 回傳 ans // 結束並回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        total = 0\n        curr = 0  # 当前以 nums[i] 结尾的等差子序列数量\n\n        for i in range(2, n):\n            if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n                curr += 1\n                total += curr\n            else:\n                curr = 0\n\n        return total\n\ndef parse_input(data: str):\n    \"\"\"\n    从输入文本中提取整数列表。\n    期望输入形如 'nums = [1,2,3,4]' 或只包含列表本身。\n    \"\"\"\n    # 先尝试找到方括号内的内容\n    match = re.search(r'\\[.*?\\]', data)\n    if match:\n        list_str = match.group(0)\n        try:\n            return ast.literal_eval(list_str)\n        except Exception:\n            return []\n    # 如果没有找到列表，尝试把整行当作列表字符串\n    try:\n        return ast.literal_eval(data.strip())\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    result = Solution().numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode345.json",
    "problem_index_in_file": 0,
    "title": "Reverse Vowels of a String",
    "description_snippet": "Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e',...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for reversing vowels in a string. We must follow the format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows →, decisions with Yes/No. Start, End. No actual code.\n\nWe need to produce step-by-step logic: e.g., start, initialize left and right pointers, define vowel set, loop while left < right, find next vowel from left, find next vowel from right, swap, move pointers, output result.\n\nWe need to use virtual code and explanation. Each line should be separate. No actual code, just steps.\n\nLet's produce: Start. Then initialize variables. Then decision: if left < right? loop. Inside loop: decide if s[left] is vowel? if not, increment left. Similarly for right. When both vowels found, swap. Then move left++ right--. End of loop. After loop, return string. End.\n\nMake sure each line ends with // explanation. Use arrow syntax: → Step 1: ... . Use indentation for nested decisions.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化左指標 left = 0，右指標 right = s.length - 1，並建立元音集合 V = {a,e,i,o,u,A,E,I,O,U} // 設定雙指標與元音集合  \n→ Decision: 如果 left < right? // 檢查是否還有未處理的字元  \n    Yes → Step 2: 判斷 s[left] 是否為元音？  \n        Yes → Step 3: 判斷 s[right] 是否為元音？  \n            Yes → Step 4: 交換 s[left] 與 s[right] 的字元 // 兩端都是元音時進行交換  \n            No → Step 5: right ← right - 1 // 右端不是元音，向左移動指標  \n        No → Step 6: left ← left + 1 // 左端不是元音，向右移動指標  \n    No → Step 7: 跳出迴圈 // 左右指標交叉，所有元音已完成交換  \n→ Step 8: 回傳修改後的字串 s // 輸出最終結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def reverseVowels(self, s: str) -> str:\n        \"\"\"Reverse only the vowels in the given string.\"\"\"\n        vowels = set(\"aeiouAEIOU\")\n        # Convert string to list for easy swapping\n        chars = list(s)\n        left, right = 0, len(chars) - 1\n\n        while left < right:\n            # Move left pointer to the next vowel\n            while left < right and chars[left] not in vowels:\n                left += 1\n            # Move right pointer to the previous vowel\n            while left < right and chars[right] not in vowels:\n                right -= 1\n            # If both pointers point to vowels, swap them\n            if left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n\n        return \"\".join(chars)\n\ndef main() -> None:\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the string value from input like: s = \"IceCreAm\"\n    # Find the first and last double quote\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and first_quote < last_quote:\n        s = data[first_quote + 1:last_quote]\n    else:\n        # Fallback: use the whole input as the string\n        s = data\n\n    sol = Solution()\n    result = sol.reverseVowels(s)\n\n    # Output the result surrounded by double quotes as in the examples\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"IceCreAm\"",
          "expected_output": "\"AceCreIm\"",
          "success": true,
          "output": "\"AceCreIm\""
        },
        {
          "example_index": 1,
          "input": "s = \"leetcode\"",
          "expected_output": "\"leotcede\"",
          "success": true,
          "output": "\"leotcede\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode464.json",
    "problem_index_in_file": 0,
    "title": "Can I Win",
    "description_snippet": "In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The p...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm: Leetcode 464 \"Can I Win\". Classic solution: bitmask DP with memoization. Steps: if sum of 1..maxChoosableInteger < desiredTotal → false. Use recursion canWin(mask, currentTotal). Base: if currentTotal>=desiredTotal → false? Actually when you reach desiredTotal on your turn, you win. In recursive evaluation, we return true if there exists a choice that leads opponent to lose. We'll produce steps accordingly.\n\nOutput format: each line \"虛擬碼步驟 // 解釋\". Use arrow etc. Need to include Start, End. We'll write stepwise algorithm: initialization, sum check, recursion function, memoization with mask, iterate over numbers not used, check if picking leads opponent lose. We'll represent bitmask.\n\nLet's craft lines. Use \"Start // 程式開始執行\". Then step to compute totalSum. Then decision if totalSum < desiredTotal → return false. Then decision if maxChoosableInteger >= desiredTotal → return true? Actually if any single number can reach desiredTotal. But algorithm will handle. But we can mention.\n\nThen define function CanWin(mask, currentTotal). In steps: if memo contains mask -> return value. For each i from 1 to maxChoosableInteger: if bit i-1 not set in mask → newMask. If currentTotal + i >= desiredTotal → memo[mask]=true; return true. Else if !CanWin(newMask, currentTotal+i) → memo[mask]=true; return true. After loop, memo[mask]=false; return false. Then initial call CanWin(0,0). Return that.\n\nWe'll format.\n\nLet's produce step lines. Use arrows. Use \"→\" after Start.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算總和 totalSum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2 // 計算所有可用數字的總和  \n→ Decision: 如果 totalSum < desiredTotal? // 檢查即使全部使用也無法達到目標  \n    Yes → Step 2: 回傳 false // 第一玩家無法贏  \n    No  → Decision: 如果 maxChoosableInteger >= desiredTotal? // 任一個數字就能直接勝利  \n        Yes → Step 3: 回傳 true // 第一玩家直接取足夠大數字贏  \n        No  → Step 4: 初始化 memoization map // 用於存儲已計算的子問題結果  \n\n→ Step 5: 定義遞迴函式 CanWin(mask, currentTotal) // mask 表示已被選擇的數字集合  \n→     Decision: 如果 memo 包含 mask? // 已計算過此狀態  \n        Yes → Step 6: 回傳 memo[mask] // 直接使用已知結果  \n        No  → Decision: 迭代 i 從 1 到 maxChoosableInteger? // 選擇下一個可用數字  \n            → Decision: 如果 bit (i-1) 未在 mask? // 該數字未被使用  \n                Yes → Step 7: newMask = mask | (1 << (i-1)) // 更新已使用集合  \n                → Decision: 如果 currentTotal + i >= desiredTotal? // 本次選擇即勝  \n                    Yes → Step 8: memo[mask] = true // 標記此狀態可勝  \n                    → Step 9: 回傳 true // 第一玩家此時可勝  \n                    No  → Decision: 如果 !CanWin(newMask, currentTotal + i)? // 對手無法勝  \n                        Yes → Step 10: memo[mask] = true // 標記可勝  \n                        → Step 11: 回傳 true // 第一玩家可以強制勝利  \n                        No  → // 該選擇不利，繼續嘗試其他數字  \n            → // i 循環結束  \n        → Step 12: memo[mask] = false // 所有選擇都導致對手勝  \n        → Step 13: 回傳 false // 第一玩家此狀態無法勝  \n\n→ Step 14: 呼叫 CanWin(0, 0) // 初始狀態：未選任何數字，總和為 0  \n→ Step 15: 回傳 CanWin(0, 0) 的結果 // 這即為最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # If the desired total is already met or less, the first player wins immediately\n        if desiredTotal <= 0:\n            return True\n        # If the sum of all available numbers is less than the desired total, it's impossible to win\n        if (maxChoosableInteger * (maxChoosableInteger + 1)) // 2 < desiredTotal:\n            return False\n\n        memo = {}\n\n        def can_win(mask: int, current_total: int) -> bool:\n            # Use memoization to avoid recomputation\n            if mask in memo:\n                return memo[mask]\n\n            # Try every unused number\n            for i in range(maxChoosableInteger):\n                if not (mask & (1 << i)):\n                    val = i + 1\n                    # If taking this number reaches or exceeds the desired total, current player wins\n                    if current_total + val >= desiredTotal:\n                        memo[mask] = True\n                        return True\n                    # Otherwise, if the opponent cannot win from the new state, current player wins\n                    if not can_win(mask | (1 << i), current_total + val):\n                        memo[mask] = True\n                        return True\n\n            # No winning move found\n            memo[mask] = False\n            return False\n\n        return can_win(0, 0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract all integers from the input (supports formats like \"maxChoosableInteger = 10, desiredTotal = 11\")\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) >= 2:\n        max_choosable, desired = numbers[0], numbers[1]\n    else:\n        # Fallback: assume two numbers separated by whitespace\n        parts = data.split()\n        max_choosable, desired = int(parts[0]), int(parts[1])\n\n    solution = Solution()\n    result = solution.canIWin(max_choosable, desired)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "maxChoosableInteger = 10, desiredTotal = 11",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "maxChoosableInteger = 10, desiredTotal = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "maxChoosableInteger = 10, desiredTotal = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode122.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock II",
    "description_snippet": "You are given an integer array prices where prices[i] is the price of a given stock on the i^th day....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the algorithm to find maximum profit from prices array with unlimited transactions but cannot hold more than one share at a time. Standard solution: sum of all positive differences between consecutive days.\n\nWe need to produce step-by-step pseudocode with arrow syntax and explanation.\n\nWe should cover:\n\nStart\nInitialize profit = 0\nLoop i from 1 to length-1\nDecision: price[i] > price[i-1]?\nYes → profit += price[i] - price[i-1]\nNo → do nothing\nEnd loop\nReturn profit\nEnd\n\nWe need to ensure \"逐行\" and each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nWe need to use arrows (→, Yes →, No →) and structure Start, End, Decision:.\n\nLet's produce. Use indentation maybe not needed.\n\nExample:\n\nStart // 程式開始執行\n→ Step 1: 初始化 profit = 0 // 設定初始利潤為 0\n→ Step 2: 設定 i = 1 // 從第二天開始比對\n→ Loop: i < length(prices) // 迭代所有天數\n    → Decision: prices[i] > prices[i-1] // 檢查今天價格是否高於前一天\n        Yes → profit += prices[i] - prices[i-1] // 若高，累加差額為利潤\n        No  → // 不做任何事\n    → i += 1 // 進到下一天\n→ Step 3: return profit // 回傳總利潤\nEnd // 程式結束\n\nMake sure each line has the arrow syntax at start, like \"→ Step 1:\" etc. Indent decision lines with spaces? The sample uses indentation. We can mimic that.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 profit = 0 // 設定初始利潤為 0  \n→ Step 2: 設定 i = 1 // 從第二天（索引 1）開始比對  \n→ Loop: i < length(prices) // 迭代所有天數  \n  → Decision: prices[i] > prices[i-1] // 檢查今天價格是否高於前一天  \n    Yes → profit += prices[i] - prices[i-1] // 若高，累加差額為利潤  \n    No  → // 不做任何事  \n  → i += 1 // 進到下一天  \n→ Step 3: return profit // 回傳總利潤  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxProfit(self, prices):\n        # 若沒有價格資料，直接回傳 0\n        if not prices:\n            return 0\n        profit = 0\n        # 只要今天價格高於前一天，就把差額累加到利潤中\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i - 1]:\n                profit += prices[i] - prices[i - 1]\n        return profit\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入，並利用正則表達式擷取所有整數\n    data = sys.stdin.read()\n    prices = list(map(int, re.findall(r'-?\\d+', data)))\n    \n    # 建構解法物件，計算最大利潤\n    solution = Solution()\n    result = solution.maxProfit(prices)\n    \n    # 將結果輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode214.json",
    "problem_index_in_file": 0,
    "title": "Shortest Palindrome",
    "description_snippet": "You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nRe...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for the problem: shortest palindrome by adding characters in front. We must output lines with \"虛擬碼步驟\" and explanation. Use arrows etc. Steps: Start, input s, find longest palindromic prefix, compute suffix to add reversed, etc. Use KMP to find longest prefix that is palindrome. Or simple method: reverse s, compute lps on s + '#' + rev_s. Let's produce generic pseudocode. Steps: 1. Define string rev_s = reverse(s). 2. Construct combined = s + '#' + rev_s. 3. Compute lps array for combined. 4. longest_prefix_len = lps[-1]. 5. add_part = rev_s[0 : len(s)-longest_prefix_len]. 6. result = add_part + s. 7. Output result. Use Decision: maybe if s empty. Let's produce lines.\n\nWe must include arrow and indentation? The sample shows indentation for decisions but we can simply produce sequential lines. For decisions, we can include checks. Let's produce.\n\nNeed to adhere to output format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow symbol for transitions: \"→\" maybe. For start: \"Start // 程式開始執行\". Then steps with \"→\". For decisions: \"Decision: ...\" with Yes/No branches.\n\nLet's write.\n\nSteps:\n\nStart\n→ Step 1: 讀取輸入字串 s // 從使用者或輸入獲取字串\n→ Decision: s 是否為空? // 檢查字串是否為空\n    Yes → Step 2: 輸出空字串 // 空字串已是回文\n    No  → Step 3: 計算字串的反轉 rev_s = reverse(s) // 取得原字串的倒序\n→ Step 4: 建立組合字串 combined = s + \"#\" + rev_s // 用作 KMP 前綴函數計算\n→ Step 5: 初始化 lps[0] = 0 // 前綴長度陣列\n→ Step 6: 針對 i 從 1 到 len(combined)-1 進行 KMP 前綴計算 // 產生 lps\n    → 內部迴圈: 設置 j = lps[i-1]，根據匹配調整 j\n    → 如果 combined[i] == combined[j]，則 lps[i] = j + 1\n    → 否則 lps[i] = 0\n→ Step 7: longest_prefix_len = lps[ len(combined)-1 ] // 最長回文前綴長度\n→ Decision: longest_prefix_len 等於 len(s)? // 字串本身已是回文\n    Yes → Step 8: 輸出 s // 無需添加字元\n    No  → Step 9: 需要添加的字元為 rev_s[0 : len(s)-longest_prefix_len] // 從反轉字串取剩餘部分\n→ Step 10: result = add_part + s // 在前面添加\n→ Step 11: 輸出 result // 回傳最短回文\nEnd\n\nMake sure each line with arrow and explanation. For inner loop maybe just one line. Provide indentation for decisions as shown. Let's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 從使用者或輸入獲取字串  \n→ Decision: s 是否為空? // 檢查字串是否為空  \n Yes → Step 2: 輸出空字串 // 空字串已是回文  \n No  → Step 3: 計算字串的反轉 rev_s = reverse(s) // 取得原字串的倒序  \n→ Step 4: 建立組合字串 combined = s + \"#\" + rev_s // 用作 KMP 前綴函數計算  \n→ Step 5: 初始化 lps[0] = 0 // 前綴長度陣列  \n→ Step 6: 針對 i 從 1 到 len(combined)-1 進行 KMP 前綴計算 // 產生 lps  \n → 內部迴圈: 設置 j = lps[i-1]，根據匹配調整 j  \n  → 如果 combined[i] == combined[j]，則 lps[i] = j + 1  \n  → 否則 lps[i] = 0  \n→ Step 7: longest_prefix_len = lps[ len(combined)-1 ] // 最長回文前綴長度  \n→ Decision: longest_prefix_len 等於 len(s)? // 字串本身已是回文  \n Yes → Step 8: 輸出 s // 無需添加字元  \n No  → Step 9: 需要添加的字元為 rev_s[0 : len(s)-longest_prefix_len] // 從反轉字串取剩餘部分  \n→ Step 10: result = add_part + s // 在前面添加  \n→ Step 11: 輸出 result // 回傳最短回文  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def shortestPalindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n        temp = s + \"#\" + s[::-1]\n        n = len(temp)\n        lps = [0] * n\n        for i in range(1, n):\n            length = lps[i - 1]\n            while length > 0 and temp[i] != temp[length]:\n                length = lps[length - 1]\n            if temp[i] == temp[length]:\n                length += 1\n            lps[i] = length\n        to_add = s[lps[-1]:][::-1]\n        return to_add + s\n\ndef parse_input(raw: str) -> str:\n    raw = raw.strip()\n    # Try to extract string inside single or double quotes\n    match = re.search(r\"['\\\"](.*?)['\\\"]\", raw)\n    if match:\n        return match.group(1)\n    # Fallback: use the whole line\n    return raw\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    s = parse_input(raw_input)\n    solution = Solution()\n    result = solution.shortestPalindrome(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'aacecaaa'",
          "expected_output": "'aaacecaaa'",
          "success": true,
          "output": "aaacecaaa"
        },
        {
          "example_index": 1,
          "input": "s = 'abcd'",
          "expected_output": "'dcbabcd'",
          "success": true,
          "output": "dcbabcd"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode187.json",
    "problem_index_in_file": 0,
    "title": "Repeated DNA Sequences",
    "description_snippet": "The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. For e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines step by step for problem: find all 10-letter-long substrings that appear more than once in a given string s. Classic Leetcode 187: DNA Sequencing. Approach: sliding window of length 10, use hash map to count occurrences, collect those >1. Complexity O(n). Also can optimize using bit encoding. But we just produce pseudo-code. We'll produce Start, Step: input string, Step: create dictionary counts, Step: loop over i from 0 to len(s)-10, extract substring s[i:i+10], update map, Step: after loop, collect keys with count>1, Step: return result. End.\n\nWe need arrow and decisions? We can use Decision: if count==1? But we can do simple. Provide each line with explanation.\n\nLet's produce:\n\nStart\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s)-10 inclusive // 遍歷所有 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: 如果 seq 已存在於 counts?\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Decision: For each key in counts\n        Yes → Decision: 如果 counts[key] > 1 ?\n            Yes → result.append(key) // 加入結果\n→ Step 6: Return result // 回傳所有重複的 10 字元子字串\nEnd\n\nBut we need each line separately. We can indent decisions with arrow. Provide only one line per step. So we need to list each line: e.g., \"Start // 程式開始執行\". Then each line. For decisions we include the \"Decision:\" line and then indented \"Yes →\" etc. Each indented line still separate lines.\n\nWe must use the same formatting as example: \"→ Step 1: ...\" etc. So we will produce:\n\nStart // 程式開始執行\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s) - 10 // 遍歷所有可能的 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: seq 已存在於 counts? // 判斷是否已在字典中\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Decision: 是否有 key 在 counts? // 遍歷所有鍵\n        Yes → Decision: counts[key] > 1? // 判斷是否重複\n            Yes → result.append(key) // 加入結果\n→ Step 6: Return result // 回傳所有重複的 10 字元子字串\nEnd // 程式執行結束\n\nBut \"Decision: 是否有 key 在 counts?\" not necessary; we can just loop. But we can keep simple. Might better to represent loop separately: \"→ Step 5: For each key in counts\" then inside decide >1. Let's do:\n\nStart // 程式開始執行\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s)-10 // 遍歷所有可能的 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: seq 已存在於 counts? // 判斷是否已在字典中\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Step 6: For each key in counts // 遍歷所有鍵\n    → Decision: counts[key] > 1? // 判斷是否重複\n        Yes → result.append(key) // 加入結果\n→ Step 7: Return result // 回傳所有重複的 10 字元子字串\nEnd // 程式執行結束\n\nThis meets format: each line starts with \"→\" or \"Start\". Indent for decisions lines. Provide arrow and comment.\n\nMake sure to use \"Yes →\" and \"No →\" with spaces. Provide explanation after //. Good.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Input DNA string s // 取得 DNA 序列\n→ Step 2: Initialize empty dictionary counts // 用於紀錄 10 字元序列出現次數\n→ Step 3: For i from 0 to length(s)-10 // 遍歷所有可能的 10 字元子字串\n    → Step 4: seq ← s[i : i+10] // 取出當前 10 字元子字串\n    → Decision: seq 已存在於 counts? // 判斷是否已在字典中\n        Yes → counts[seq] ← counts[seq] + 1 // 次數加一\n        No  → counts[seq] ← 1 // 新增\n→ Step 5: Initialize empty list result // 儲存重複序列\n→ Step 6: For each key in counts // 遍歷所有鍵\n    → Decision: counts[key] > 1? // 判斷是否重複\n        Yes → result.append(key) // 加入結果\n→ Step 7: Return result // 回傳所有重複的 10 字元子字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        seen = set()\n        repeated = set()\n        for i in range(len(s) - 9):\n            seq = s[i:i+10]\n            if seq in seen:\n                repeated.add(seq)\n            else:\n                seen.add(seq)\n        return list(repeated)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Extract the string inside quotes after \"s = \"\n    first_quote = data.find(\"'\")\n    if first_quote == -1:\n        first_quote = data.find('\"')\n    last_quote = data.rfind(\"'\") if data.rfind(\"'\") != -1 else data.rfind('\"')\n    if first_quote == -1 or last_quote == -1 or last_quote <= first_quote:\n        s = \"\"\n    else:\n        s = data[first_quote+1:last_quote]\n    result = Solution().findRepeatedDnaSequences(s)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      '[\"CCCCCAAAAA\", \"AAAAACCCCC\"]'"
        },
        {
          "example_index": 1,
          "input": "s = 'AAAAAAAAAAAAA'",
          "expected_output": "[\"AAAAAAAAAA\"]",
          "success": true,
          "output": "[\"AAAAAAAAAA\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode300.json",
    "problem_index_in_file": 0,
    "title": "Longest Increasing Subsequence",
    "description_snippet": "Given an integer array nums, return the length of the longest strictly increasing subsequence....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for longest increasing subsequence (LIS). The problem: given an integer array nums, return the length of the longest strictly increasing subsequence.\n\nWe need to output virtual code step by step, with each line containing code step and explanation comment after space. Use arrows, Start, End, Decision. Should not output actual code, only virtual steps.\n\nWe need to produce algorithm: typical DP O(n^2) or patience sorting O(n log n). Since need simple algorithm, probably DP O(n^2). Provide virtual code.\n\nWe need to structure steps: Start, Input array, Initialize DP array length n, for i from 0 to n-1, dp[i] = 1, for j from 0 to i-1, if nums[j] < nums[i], dp[i] = max(dp[i], dp[j] + 1). After loop, find max in dp, output.\n\nSo produce virtual code lines with arrows. Use indentation for decisions. Each line \"→ Step X: ...\" and comment.\n\nLet's craft.\n\n```\nStart // 程式開始執行\n→ Step 1: 接收整數陣列 nums // 取得輸入資料\n→ Step 2: 取得陣列長度 n = nums.length // 計算元素數量\n→ Step 3: 建立 dp 陣列長度 n // dp[i] 代表以 nums[i] 為結尾的 LIS 長度\n→ Step 4: 將 dp 陣列所有元素設定為 1 // 每個位置至少有長度 1 的子序列\n→ Step 5: 從 i = 0 開始迭代至 n-1 // 外層循環遍歷每個元素\n    → Decision: i > 0? // 是否已經處理第一個元素\n        Yes → Step 6: 為每個 i 初始化 inner_j = 0\n            → Step 7: 從 j = 0 到 i-1 迭代 // 檢查前面所有元素\n                → Decision: nums[j] < nums[i]? // 前一個數是否小於當前數\n                    Yes → Step 8: 更新 dp[i] = max(dp[i], dp[j] + 1) // 以 j 為結尾的 LIS 延伸\n                    No  → Step 9: 不更新 dp[i] // j 不符合遞增條件\n→ Step 10: 初始化 maxLen = 0 // 儲存目前已知的最大 LIS 長度\n→ Step 11: 從 i = 0 到 n-1 迭代\n    → Decision: dp[i] > maxLen? // 是否找到更長的 LIS\n        Yes → Step 12: maxLen = dp[i] // 更新最大長度\n        No  → Step 13: 不變更 maxLen\n→ Step 14: 回傳 maxLen // 輸出最長遞增子序列長度\nEnd // 程式執行結束\n```\n\nWe should ensure each line has code step + comment.\n\nNeed to ensure arrow formatting: use \"→\" for each step. For decision indent.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 接收整數陣列 nums // 取得輸入資料\n→ Step 2: 取得陣列長度 n = nums.length // 計算元素數量\n→ Step 3: 建立 dp 陣列長度 n // dp[i] 代表以 nums[i] 為結尾的 LIS 長度\n→ Step 4: 將 dp 陣列所有元素設定為 1 // 每個位置至少有長度 1 的子序列\n→ Step 5: 從 i = 0 開始迭代至 n-1 // 外層循環遍歷每個元素\n    → Decision: i > 0? // 是否已經處理第一個元素\n        Yes → Step 6: 為每個 i 初始化 inner_j = 0\n            → Step 7: 從 j = 0 到 i-1 迭代 // 檢查前面所有元素\n                → Decision: nums[j] < nums[i]? // 前一個數是否小於當前數\n                    Yes → Step 8: 更新 dp[i] = max(dp[i], dp[j] + 1) // 以 j 為結尾的 LIS 延伸\n                    No  → Step 9: 不更新 dp[i] // j 不符合遞增條件\n→ Step 10: 初始化 maxLen = 0 // 儲存目前已知的最大 LIS 長度\n→ Step 11: 從 i = 0 到 n-1 迭代\n    → Decision: dp[i] > maxLen? // 是否找到更長的 LIS\n        Yes → Step 12: maxLen = dp[i] // 更新最大長度\n        No  → Step 13: 不變更 maxLen\n→ Step 14: 回傳 maxLen // 輸出最長遞增子序列長度\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport bisect\nimport re\n\nclass Solution:\n    def lengthOfLIS(self, nums):\n        \"\"\"Return length of longest strictly increasing subsequence.\"\"\"\n        tails = []\n        for num in nums:\n            # 找到第一個大於等於 num 的位置\n            idx = bisect.bisect_left(tails, num)\n            if idx == len(tails):\n                tails.append(num)\n            else:\n                tails[idx] = num\n        return len(tails)\n\ndef main():\n    # 從標準輸入讀取所有資料\n    data = sys.stdin.read()\n    # 透過正則式擷取所有整數（含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    # 打印最長遞增子序列長度\n    print(sol.lengthOfLIS(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [10,9,2,5,3,7,101,18]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,3,2,3]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [7,7,7,7,7,7,7]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode46.json",
    "problem_index_in_file": 0,
    "title": "Permutations",
    "description_snippet": "Given an array nums of distinct integers, return all the possible permutations. You can return the a...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all permutations of an array of distinct integers. We need to produce step-by-step with Start, End, Decision, etc.\n\nWe should give steps like: Start, read array, call recursive function permute(index). In recursion, if index == length then add copy to result. Else loop over i from index to length-1, swap arr[index] with arr[i], recurse index+1, swap back.\n\nWe should use virtual code steps like \"→ Step 1: 初始化結果清單\" etc. Provide explanation comment after //.\n\nWe must ensure each line is a step with \"→\" prefix, maybe indentation for decisions.\n\nAlso we must not output actual code, only virtual code.\n\nLet's craft.\n\nStructure:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入陣列 nums // 取得使用者提供的整數陣列\n→ Step 2: 建立空結果清單 res // 用於儲存所有排列\n→ Step 3: 呼叫遞迴函式 permute(nums, 0, res) // 從索引 0 開始生成排列\n\nDefine permute function:\n\n→ Function permute(arr, idx, res) // arr 為當前排列，idx 為固定位置，res 存放結果\n    → Decision: idx 是否等於 arr.length? // 判斷是否已固定所有元素\n        Yes → Step 4: 把 arr 的拷貝加入 res // 完整排列，加入結果\n        No  → Step 5: for i from idx to arr.length-1 // 遍歷剩餘未固定元素\n            → Step 6: 交換 arr[idx] 與 arr[i] // 將第 i 個元素放到固定位置\n            → Step 7: 呼叫 permute(arr, idx+1, res) // 進一步固定下一個位置\n            → Step 8: 交換回 arr[idx] 與 arr[i] // 回溯，恢復原始順序\n    → End // permute 函式結束\n\n→ End // 程式執行結束\n\nBut we need to maintain proper indentation and arrow usage. Possibly each step under permute should have indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入陣列 nums // 取得使用者提供的整數陣列  \n→ Step 2: 建立空結果清單 res // 用於儲存所有排列  \n→ Step 3: 呼叫遞迴函式 permute(nums, 0, res) // 從索引 0 開始生成排列  \n\nFunction permute(arr, idx, res) // arr 為當前排列，idx 為固定位置，res 存放結果  \n    → Decision: idx 是否等於 arr.length? // 判斷是否已固定所有元素  \n        Yes → Step 4: 把 arr 的拷貝加入 res // 完整排列，加入結果  \n        No  → Step 5: for i from idx to arr.length-1 // 遍歷剩餘未固定元素  \n            → Step 6: 交換 arr[idx] 與 arr[i] // 將第 i 個元素放到固定位置  \n            → Step 7: 呼叫 permute(arr, idx+1, res) // 進一步固定下一個位置  \n            → Step 8: 交換回 arr[idx] 與 arr[i] // 回溯，恢復原始順序  \n    → End // permute 函式結束  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"Return all permutations of a list of distinct integers.\"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                # Found a complete permutation; add a copy to the result\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                # Swap the current index with the iterator index\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                # Backtrack: restore the original order\n                nums[start], nums[i] = nums[i], nums[start]\n\n        backtrack(0)\n        return res\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part from a string like \"nums = [1,2,3]\"\n    start_bracket = data.find('[')\n    end_bracket = data.rfind(']')\n    if start_bracket == -1 or end_bracket == -1 or start_bracket > end_bracket:\n        # If the input is just a list representation, use it directly\n        nums_str = data\n    else:\n        nums_str = data[start_bracket:end_bracket + 1]\n\n    # Safely evaluate the list string into a Python list\n    nums = ast.literal_eval(nums_str)\n\n    # Compute permutations using the Solution class\n    solution = Solution()\n    permutations = solution.permute(nums)\n\n    # Print the result as a Python list of lists\n    print(permutations)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "[[0,1],[1,0]]",
          "success": true,
          "output": "[[0, 1], [1, 0]]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode829.json",
    "problem_index_in_file": 0,
    "title": "Consecutive Numbers Sum",
    "description_snippet": "Given an integer n, return the number of ways you can write n as the sum of consecutive positive int...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines. The problem: count number of ways to represent n as sum of consecutive positive integers. Known result: number of odd divisors of n. Or algorithm: for each k from 1 to sqrt(2n) etc. But we can give an algorithm: loop over possible length L from 1 to while L*(L+1)/2 <= n. For each L, compute if (n - L*(L-1)/2) % L == 0 and result positive integer. Count.\n\nWe'll produce virtual code step-by-step with Start, Decision, etc. Provide each line. Use arrow for sequence. Let's design.\n\nStart // start\n→ Step 1: Initialize count = 0 // count ways\n→ Step 2: Set maxLength = floor((sqrt(1+8*n)-1)/2) // maximum length possible\n→ Decision: For len from 1 to maxLength? // iterate\n    Yes → Step 3: Compute numerator = n - len*(len-1)/2 // remaining after subtracting first (len-1) terms\n        Yes → Decision: If numerator % len == 0? // check divisibility\n            Yes → Step 4: Increment count // valid representation\n            No  → Step 5: Continue // not valid\n→ End // return count\n\nBut we need step by step, each line as \"虛擬碼步驟 // 解釋\". We'll have loop. Use Decision to represent loop? Could represent with \"Decision: 1 <= len <= maxLength? Yes -> ...\" But we need to include arrow for loop. We could represent loop with Decision and arrow to steps and back. Let's outline:\n\nStart\n→ Step 1: Initialize count = 0\n→ Step 2: Compute maxLen = floor((sqrt(1+8*n)-1)/2)\n→ Decision: Set len = 1 <= maxLen? // start loop condition\n    Yes → Step 3: numerator = n - len*(len-1)/2\n        Yes → Decision: numerator % len == 0?\n            Yes → Step 4: count = count + 1\n            No  → Step 5: // nothing\n        No  → // no\n    Yes → Step 6: len = len + 1\n    Yes → Decision: len <= maxLen? // loop again\n        Yes → (go to Step 3)\n        No  → Step 7: Return count\nEnd\n\nBut we need to use arrow for steps. Let's write lines:\n\nStart // 程式開始\n→ Step 1: count = 0 // 初始化計數器\n→ Step 2: maxLen = floor((sqrt(1+8*n)-1)/2) // 計算能形成和的最大序列長度\n→ Decision: len = 1 // 初始化序列長度\n    Yes → Decision: len <= maxLen? // 判斷是否仍在範圍內\n        Yes → Step 3: numerator = n - len*(len-1)/2 // 計算剩餘需要被 len 整除的數\n            Yes → Decision: numerator % len == 0? // 判斷能否被均分成整數起點\n                Yes → Step 4: count = count + 1 // 找到一種合法拆分\n                No  → // 無操作，該長度無效\n        No  → // 無操作\n    Yes → Step 5: len = len + 1 // 進入下一長度\n    Yes → // 迴圈回到 Decision: len <= maxLen?\n        Yes → (回到 Step 3)\n        No  → Step 6: return count // 所有長度遍歷完畢，返回結果\nEnd // 程式結束\n\nBut we need to maintain consistent structure with arrows and Decision. Provide \"Yes →\" and \"No →\" branches. For loops we might need to show the iteration. The guidelines: Use arrows (→, Yes →, No →). We should present each step line by line. Let's produce a final answer.\n\nWe might include some lines with \"Decision: ...\" and \"Yes →\" arrow to next step. Each line should contain step text and comment. Let's produce a clean sequence.\n\nWe also should include \"Start\" and \"End\" as separate lines. Provide each line with arrow maybe? Start line no arrow. The subsequent lines with \"→\" arrow. Provide decisions and branches.\n\nOk.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: count ← 0 // 初始化計數器，記錄合法拆分數量  \n→ Step 2: maxLen ← floor((sqrt(1+8*n)-1)/2) // 計算能形成和的最大序列長度  \n→ Decision: len ← 1 // 初始化序列長度為 1  \n    Yes → Decision: len ≤ maxLen? // 判斷是否還在可遍歷的長度範圍  \n        Yes → Step 3: numerator ← n - len*(len-1)/2 // 計算剩餘需要被 len 整除的數  \n            Yes → Decision: numerator mod len = 0? // 判斷能否被均分成整數起點  \n                Yes → Step 4: count ← count + 1 // 找到一種合法拆分，計數器加 1  \n                No  → Step 5: // 該長度無效，直接跳至後續  \n            No  → Step 5: // numerator 不是 len 的倍數，直接跳至後續  \n        No  → Step 5: // len 已超過 maxLen，結束迴圈  \n    Yes → Step 6: len ← len + 1 // 進入下一個序列長度  \n    Yes → // 迴圈回到 Decision: len ≤ maxLen?  \n        Yes → (回到 Step 3)  \n        No  → Step 7: return count // 所有長度已遍歷完畢，回傳總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_consecutive_sums(n: int) -> int:\n    \"\"\"\n    Count the number of ways to represent n as a sum of consecutive positive integers.\n    \"\"\"\n    count = 0\n    k = 1\n    # While the sum of the first k-1 numbers is less than n\n    while k * (k - 1) // 2 < n:\n        # Check if the remaining part after subtracting the first k-1 numbers\n        # can be evenly divided by k (so that the sequence starts at a positive integer)\n        if (n - k * (k - 1) // 2) % k == 0:\n            count += 1\n        k += 1\n    return count\n\nif __name__ == \"__main__\":\n    # Read the entire input; it may be like \"n = 5\" or \"n=5\" or just \"5\".\n    data = sys.stdin.read()\n    # Extract the first integer found in the input.\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        raise ValueError(\"No integer found in input.\")\n    n = int(match.group())\n    # Compute and print the result.\n    result = count_consecutive_sums(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 9",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "n = 15",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode202.json",
    "problem_index_in_file": 0,
    "title": "Happy Number",
    "description_snippet": "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the f...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation, using Start, Decision, Yes/No arrows, etc. The algorithm: we maintain set of seen numbers. While n != 1 and n not in seen: add to seen, compute sum of squares of digits. At end if n==1 return true else false.\n\nWe need to output each step line with \"→ Step X: ... // explanation\". The steps: Start, Decision if n==1? etc.\n\nLet's craft. Use decision arrow.\n\nLines:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 seen // 用來儲存已出現的數字，偵測循環\n→ Step 2: 將 n 指派為輸入值 // 初始待測數字\n→ Decision: n == 1? // 檢查是否已經是 1\n    Yes → Step 3: 回傳 true // 是 1，直接滿足條件\n    No  → Decision: n 在 seen 中? // 檢查是否已經出現過，判斷循環\n        Yes → Step 4: 回傳 false // 出現循環，非快樂數\n        No  → Step 5: 計算 sum = sum of squares of digits of n // 計算下一個數字\n→ Step 6: 將 n 指派為 sum // 更新 n\n→ Step 7: 回到 Decision: n == 1? // 重複循環\nEnd // 程式結束\n\nBut the flow must be more explicit: after Step 5 we go back to Decision: n in seen? Actually after Step 5 we compute sum, then step 6 assign, then go to decision again. Might need loop.\n\nWe could use a loop structure: While n not 1 and n not in seen: compute sum, assign.\n\nBut they want arrow lines.\n\nLet's produce as:\n\nStart // 程式開始執行\n→ Step 1: 初始化 seen 為空集合 // 用來追蹤已出現的數字\n→ Step 2: 將 n 設為輸入值 // 起始數字\n→ Decision: n == 1? // 判斷是否已經是 1\n    Yes → Step 3: 回傳 true // n 為 1，直接回傳 true\n    No  → Decision: n 在 seen 中? // 檢查是否重複，表示循環\n        Yes → Step 4: 回傳 false // 已重複，非快樂數\n        No  → Step 5: 計算 sum = sum of squares of digits of n // 生成下一個數字\n→ Step 6: 將 n 指派為 sum // 更新 n\n→ Step 7: 將 n 加入 seen // 記錄已出現\n→ Step 8: 回到 Decision: n == 1? // 重新檢查條件，繼續循環\nEnd // 程式結束\n\nBut maybe need to include the loop arrow: Yes -> Step ... etc. But we need to use arrow syntax for decision. Use \"Decision:\" lines and then indent Yes/No.\n\nLet's produce final answer. Ensure each line ends with // explanation. Use the arrow style: \"→ Step X:\" etc.\n\nWe need to be careful: Step 5 is \"計算 sum = sum of squares of digits of n\" etc. Provide explanation.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 seen 為空集合 // 用來追蹤已出現的數字  \n→ Step 2: 將 n 設為輸入值 // 起始待測數字  \n→ Decision: n == 1? // 判斷是否已經是 1  \n Yes → Step 3: 回傳 true // n 為 1，直接回傳 true  \n No  → Decision: n 在 seen 中? // 檢查是否已重複，表示循環  \n  Yes → Step 4: 回傳 false // 已重複，非快樂數  \n  No  → Step 5: 計算 sum = sum of squares of digits of n // 生成下一個數字  \n→ Step 6: 將 n 指派為 sum // 更新 n  \n→ Step 7: 將 n 加入 seen // 記錄已出現的數字  \n→ Step 8: 回到 Decision: n == 1? // 重新檢查條件，繼續循環  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef get_next(number: int) -> int:\n    \"\"\"\n    Return the sum of the squares of the digits of `number`.\n    \"\"\"\n    total = 0\n    while number > 0:\n        digit = number % 10\n        total += digit * digit\n        number //= 10\n    return total\n\ndef is_happy(n: int) -> bool:\n    \"\"\"\n    Determine whether a number `n` is a happy number.\n    \"\"\"\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = get_next(n)\n    return n == 1\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read()\n    # 從輸入中搜尋第一個整數\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n        result = is_happy(n)\n        # 按要求輸出 'true' 或 'false'\n        print(\"true\" if result else \"false\")\n    else:\n        # 若無法解析到數字，直接輸出 false\n        print(\"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 19",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode189.json",
    "problem_index_in_file": 0,
    "title": "Rotate Array",
    "description_snippet": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code lines for rotating array right by k steps. Provide explanation after each line. Use virtual code arrow syntax: Start, →, Decision, Yes →, No →, End.\n\nWe need to produce algorithm steps. We could implement efficient O(n) algorithm: 1) normalize k = k % n. 2) Reverse whole array. 3) Reverse first k elements. 4) Reverse rest.\n\nWe'll produce steps. Each line: \"Start // 程式開始執行\" etc.\n\nLet's craft steps. Use virtual code steps. For loops etc. We'll represent loops as Step: For i in 0 to n/2 - 1: swap(nums[i], nums[n-1-i]) etc.\n\nWe can also add Decision to handle k==0 or n==0.\n\nLet's produce:\n\nStart\n→ Step 1: Determine n = length(nums) // 取得陣列長度\n→ Decision: 若 n == 0? // 檢查陣列是否為空\n    Yes → Step 2: End // 空陣列直接結束\n    No  →\n→ Step 3: Normalize k = k mod n // 取得有效旋轉步數\n→ Decision: 若 k == 0? // 檢查是否需要旋轉\n    Yes → Step 4: End // 無需旋轉\n    No  →\n→ Step 5: Reverse entire array // 先把整個陣列反轉\n    → For i = 0 to floor(n/2)-1:\n        swap(nums[i], nums[n-1-i]) // 交換對稱元素\n→ Step 6: Reverse first k elements // 反轉前 k 個\n    → For i = 0 to floor(k/2)-1:\n        swap(nums[i], nums[k-1-i])\n→ Step 7: Reverse remaining n-k elements // 反轉剩餘部分\n    → For i = k to k + floor((n-k)/2)-1:\n        swap(nums[i], nums[n-1-(i-k)])\n→ End\n\nBut need to follow format: each line must contain \"虛擬碼步驟\" + \" // 解釋\". Use arrow.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Decision: n == 0? // 檢查陣列是否為空\n    Yes → End // 空陣列無需處理，直接結束\n    No  →\n→ Step 2: k ← k mod n // 取得有效旋轉步數\n→ Decision: k == 0? // 檢查是否需要旋轉\n    Yes → End // k 為 0 時陣列保持不變，結束\n    No  →\n→ Step 3: ReverseArray(nums, 0, n-1) // 反轉整個陣列\n→ Step 4: ReverseArray(nums, 0, k-1) // 反轉前 k 個元素\n→ Step 5: ReverseArray(nums, k, n-1) // 反轉剩餘元素\n→ End // 程式執行結束\n\nBut need to define ReverseArray procedure steps. Provide those steps inline maybe as substeps. But we can include explanation in each step: For ReverseArray, we can include loop. But might be considered as separate lines. We could add substeps with indent? Format not specified, but we can just include inside step.\n\nAlternatively we can define subroutine: \"→ Procedure ReverseArray(nums, start, end)\" etc. But not required. The question expects simple virtual code.\n\nLet's produce detailed steps including loop inside steps.\n\nBut each line must follow format: `虛擬碼步驟` + space + `// 解釋`. So we can include loop lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Decision: n == 0? // 檢查陣列是否為空\n    Yes → End // 空陣列直接結束\n    No  →\n→ Step 2: k ← k mod n // 取得有效旋轉步數\n→ Decision: k == 0? // 檢查是否需要旋轉\n    Yes → End // k 為 0 時陣列保持不變，結束\n    No  →\n→ Step 3: // 反轉整個陣列\n    → For i ← 0 to floor(n/2) - 1:\n        swap(nums[i], nums[n-1-i]) // 交換對稱元素\n→ Step 4: // 反轉前 k 個元素\n    → For i ← 0 to floor(k/2) - 1:\n        swap(nums[i], nums[k-1-i]) // 交換對稱元素\n→ Step 5: // 反轉剩餘 n-k 個元素\n    → For i ← k to k + floor((n-k)/2) - 1:\n        swap(nums[i], nums[n-1-(i-k)]) // 交換對稱元素\n→ End // 程式執行結束\n\nMake sure to maintain indentation. Use arrow at each step line, but for subloops we can include arrow again. Format: \"→ For i ...\".\n\nEnsure each line ends with comment. Provide short explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Decision: n == 0? // 檢查陣列是否為空  \n    Yes → End // 空陣列直接結束  \n    No  →  \n→ Step 2: k ← k mod n // 取得有效旋轉步數（限制在陣列長度內）  \n→ Decision: k == 0? // 檢查是否需要旋轉  \n    Yes → End // k 為 0 時陣列保持不變，結束  \n    No  →  \n→ Step 3: // 反轉整個陣列  \n    → For i ← 0 to floor(n/2) - 1:  \n        swap(nums[i], nums[n-1-i]) // 交換對稱元素  \n→ Step 4: // 反轉前 k 個元素  \n    → For i ← 0 to floor(k/2) - 1:  \n        swap(nums[i], nums[k-1-i]) // 交換對稱元素  \n→ Step 5: // 反轉剩餘 n-k 個元素  \n    → For i ← k to k + floor((n-k)/2) - 1:  \n        swap(nums[i], nums[n-1-(i-k)]) // 交換對稱元素  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def rotate(self, nums, k):\n        n = len(nums)\n        if n == 0:\n            return\n        k = k % n\n        if k == 0:\n            return\n        # 先反轉整個陣列\n        self._reverse(nums, 0, n - 1)\n        # 再反轉前 k 個元素\n        self._reverse(nums, 0, k - 1)\n        # 再反轉後 n-k 個元素\n        self._reverse(nums, k, n - 1)\n\n    def _reverse(self, arr, start, end):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 解析輸入中的 nums 和 k\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n\n    if not nums_match or not k_match:\n        raise ValueError(\"Invalid input format\")\n\n    nums = ast.literal_eval(nums_match.group(1))\n    k = int(k_match.group(1))\n\n    Solution().rotate(nums, k)\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "expected_output": "[5,6,7,1,2,3,4]",
          "success": true,
          "output": "[5, 6, 7, 1, 2, 3, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,-100,3,99], k = 2",
          "expected_output": "[3,99,-1,-100]",
          "success": true,
          "output": "[3, 99, -1, -100]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode492.json",
    "problem_index_in_file": 0,
    "title": "Construct the Rectangle",
    "description_snippet": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Need algorithm: given area A, find integer L and W such that L*W=A, L>=W, minimize L-W. Equivalent to find factor pair closest to sqrt(A). Approach: start W from sqrt(A) downwards, find divisor. Then L = A/W. Return [L, W].\n\nNeed virtual code steps. Each line: virtual code + comment. Use arrows. Steps:\n\nStart\n→ Step: Input targetArea\n→ Step: Compute sqrtArea = floor(sqrt(targetArea))\n→ Decision: If sqrtArea * sqrtArea == targetArea? Actually we need to iterate W from sqrtArea downto 1 until targetArea % W == 0.\nUse loop.\n\nBut virtual code structure: use decision blocks.\n\nWe can write:\n→ Step 1: 初始化 W = floor(sqrt(targetArea))\n→ Decision: 是否有整除? (targetArea % W == 0)\n    Yes → Step 2: L = targetArea / W\n          → Step 3: 返回 [L, W]\n          → End\n    No  → Step 4: W = W - 1\n          → Goto Step 1\n\nNeed to ensure we include loop logic. Virtual code with recursion? We'll show as decision with Yes/No loops.\n\nLet's produce.\n\nWe need to mention that if no divisor found (shouldn't happen because 1 divides). End.\n\nWe need to output each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\".\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 接收輸入 targetArea // 取得目標面積\n→ Step 2: 計算 sqrtArea = floor( sqrt(targetArea) ) // 初始寬度近似平方根\n→ Step 3: 設定 currentW = sqrtArea // 從此寬度開始搜尋\n→ Decision: targetArea % currentW == 0? // 檢查 currentW 是否整除面積\n    Yes → Step 4: 計算 L = targetArea / currentW // 得到長度\n            → Step 5: 返回 [L, currentW] // 輸出結果\n            → End // 程式結束\n    No  → Step 6: currentW = currentW - 1 // 將寬度減 1\n          → Goto Step 3 // 重新檢查\n\nBut we need to fit format. Let's use the arrow for loop. For goto, we can show \"→ Step 3\" again. Provide explanation each line.\n\nMake sure each line is separate. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入 targetArea // 取得目標面積  \n→ Step 2: 計算 sqrtArea = floor( sqrt(targetArea) ) // 近似平方根作為起始寬度  \n→ Step 3: 設定 currentW = sqrtArea // 從此寬度開始尋找因數  \n→ Decision: targetArea % currentW == 0? // 檢查 currentW 是否能整除面積  \n&nbsp;&nbsp;&nbsp;Yes → Step 4: 計算 L = targetArea / currentW // 得到對應長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 5: 返回 [L, currentW] // 輸出最優長寬對  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ End // 程式結束  \n&nbsp;&nbsp;&nbsp;No  → Step 6: currentW = currentW - 1 // 寬度減 1  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Goto Step 3 // 重新檢查新的寬度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport math\nimport re\n\ndef construct_rectangle(area: int):\n    \"\"\"Return the pair [L, W] with L >= W, L*W = area and L-W minimized.\"\"\"\n    w = int(math.isqrt(area))           # start from the integer part of sqrt(area)\n    while area % w != 0:                # search downward for a divisor\n        w -= 1\n    return [area // w, w]               # L = area / w, W = w\n\ndef main():\n    input_text = sys.stdin.read().strip()\n    match = re.search(r'(\\d+)', input_text)  # extract the numeric value\n    if not match:\n        return\n    area = int(match.group(1))\n    result = construct_rectangle(area)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "area = 4",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "area = 37",
          "expected_output": "[37,1]",
          "success": true,
          "output": "[37, 1]"
        },
        {
          "example_index": 2,
          "input": "area = 122122",
          "expected_output": "[427,286]",
          "success": true,
          "output": "[427, 286]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode383.json",
    "problem_index_in_file": 0,
    "title": "Ransom Note",
    "description_snippet": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps following the format, line by line, with explanation. We need to solve the problem: check if ransomNote can be built from magazine characters, each letter can be used once. Essentially count frequencies and compare. Provide virtual code steps.\n\nWe need to output only the virtual code with explanation, no real code. Format: \"Start // 程式開始執行\" then lines with \"→ Step 1: ... // ...\" etc. Use Decision: etc.\n\nWe need to reflect algorithm: Start, Input strings, Initialize frequency map for magazine, For each char in magazine: increment count. Then For each char in ransomNote: If freq[char] > 0, decrement; else return false. After loop, return true. Then End.\n\nWe can incorporate decisions: while iterating ransomNote, if freq missing or zero, decision: if available? Yes/No.\n\nAlso we can decide to skip storing magazine counts if we use array 26.\n\nBut just provide generic pseudo-code.\n\nLet's write lines.\n\nWe need to ensure \"→\" arrow before each step.\n\nWe need \"Decision:\" lines with indent for Yes/No arrows.\n\nMake sure each line includes \" // \" explanation.\n\nLet's produce.\n\nNote: Must be in Traditional Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立一個字元頻率表 magazineCount // 用來記錄雜誌中每個字元出現次數  \n→ Step 2: 迭代 magazine 的每個字元 ch  \n    → Step 2.1: magazineCount[ch] += 1 // 增加對應字元的計數  \n→ Step 3: 迭代 ransomNote 的每個字元 ch  \n    → Decision: magazineCount[ch] 大於 0? // 判斷此字元是否還有可用份  \n        Yes → Step 3.1: magazineCount[ch] -= 1 // 使用該字元並減少計數  \n        No → Step 3.2: Return false // 無法取得足夠字元，直接失敗  \n→ Step 4: 所有字元均已成功使用 // 已檢查完畢且沒有失敗  \n→ Return true // 可以組成 ransomNote  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport collections\n\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        \"\"\"\n        判斷 ransomNote 是否可以由 magazine 中的字元構成。\n        每個字元只能使用一次。\n        \"\"\"\n        # 先計算 magazine 中各字元的頻率\n        magazine_count = collections.Counter(magazine)\n        # 再逐個檢查 ransomNote 的字元是否足夠\n        for char in ransomNote:\n            if magazine_count.get(char, 0) == 0:\n                return False          # 沒有足夠的該字元\n            magazine_count[char] -= 1\n        return True\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析 ransomNote 與 magazine 的值。\n    期望輸入格式類似: 'ransomNote = \"a\", magazine = \"b\"'\n    \"\"\"\n    # 用正則抓取雙引號中的字串\n    note_match = re.search(r'ransomNote\\s*=\\s*\"([^\"]*)\"', data)\n    mag_match  = re.search(r'magazine\\s*=\\s*\"([^\"]*)\"', data)\n    ransomNote = note_match.group(1) if note_match else \"\"\n    magazine   = mag_match.group(1) if mag_match else \"\"\n    return ransomNote, magazine\n\nif __name__ == \"__main__\":\n    # 讀取全部標準輸入\n    raw_input = sys.stdin.read()\n    # 解析得到兩個字串\n    ransomNote, magazine = parse_input(raw_input)\n    # 執行判斷\n    result = Solution().canConstruct(ransomNote, magazine)\n    # 輸出小寫的 true/false\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "ransomNote = \"a\", magazine = \"b\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "ransomNote = \"aa\", magazine = \"ab\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "ransomNote = \"aa\", magazine = \"aab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode376.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Subsequence",
    "description_snippet": "A wiggle sequence is a sequence where the differences between successive numbers strictly alternate ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm to find length of longest wiggle subsequence. This is classic Leetcode 376. We can do greedy: maintain up and down lengths.\n\nWe output line by line. Include Start, End, Decision, etc.\n\nWe should not output actual code but virtual code steps.\n\nLet's produce steps: Start, check array length <=2 => return length. Initialize up=1, down=1. Iterate i from 1 to n-1. Decision: if nums[i] > nums[i-1] then up = down+1; else if nums[i] < nums[i-1] then down = up+1; else ignore. After loop, End, return max(up,down). Provide explanation comments.\n\nLet's format accordingly. Use arrow lines. Ensure each line: \"虛擬碼步驟 // 解釋\".\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 nums // 取得待處理的整數序列  \n→ Decision: 如果 nums 長度 ≤ 2? // 簡單情況可直接回傳長度  \n    Yes → Step 2: 回傳 nums 長度 // 一個或兩個元素自動是 Wiggle  \n    No  → Step 3: 初始化變數 up = 1, down = 1 // up 代表以正差結束的最大長度，down 代表以負差結束的最大長度  \n→ Step 4: 循環 i 從 1 到 nums.Length - 1 // 比較相鄰元素  \n    Decision: 如果 nums[i] > nums[i-1]? // 正差  \n        Yes → Step 5: 設定 up = down + 1 // 以正差結束的長度增加，取之前負差的最大長度加一  \n        No → Decision: 如果 nums[i] < nums[i-1]? // 負差  \n            Yes → Step 6: 設定 down = up + 1 // 以負差結束的長度增加，取之前正差的最大長度加一  \n            No → Step 7: 兩值相等，無差值，忽略 // 差值為零不影響 Wiggle 長度  \n→ Step 8: 循環結束 // 已檢查完所有相鄰對  \n→ Step 9: 回傳 max(up, down) // 最大值即為最長 Wiggle 子序列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef wiggle_max_length(nums):\n    \"\"\"Return the length of the longest wiggle subsequence in nums.\"\"\"\n    if not nums:\n        return 0\n    up = down = 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1          # last diff positive\n        elif nums[i] < nums[i - 1]:\n            down = up + 1          # last diff negative\n        # equal numbers are ignored\n    return max(up, down)\n\ndef main():\n    # Read the entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n\n    # Extract all integers from the input (handles format like \"nums = [1,7,4]\")\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # Compute and output the answer\n    result = wiggle_max_length(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,7,4,9,2,5]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1,17,5,10,13,15,10,5,16,8]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3,4,5,6,7,8,9]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1249.json",
    "problem_index_in_file": 0,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description_snippet": "Given a string s of '(' , ')' and lowercase English characters.\n\nYour task is to remove the minimum ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm to remove minimum parentheses to make valid string. Use approach: two passes stack or count to remove invalid parentheses. Approach: first pass: count unmatched ')', second pass remove unmatched '(' from end.\n\nWe need to produce virtual code lines with explanation. Use Start, End, Decision, etc. We'll produce steps: Input string, compute stack to track indices of '(' to keep, count of unmatched ')', build array of boolean keep, then second pass reverse to remove unmatched '('.\n\nLet's produce concise steps.\n\nLet's produce:\n\nStart\n→ Input: s // get input string\n→ Initialize stack = [] // store indices of '('\n→ Initialize remove = new Set() // indices to remove\n→ Decision: For each char with index i in s // iterate\n    If char == '('\n        push i onto stack\n    Else if char == ')'\n        If stack not empty\n            pop from stack // matched\n        Else\n            add i to remove // unmatched ')'\n→ After loop, while stack not empty\n    pop index and add to remove // unmatched '('\n→ Build result string by iterating s and appending chars not in remove\n→ Output result\nEnd\n\nAdd explanations.\n\nNeed arrow syntax with decision. Use Indentation with decisions. Let's format as:\n\nStart // 程式開始執行\n→ Input s // 取得輸入字串\n→ Initialize stack ← [] // 用於儲存 '(' 的索引\n→ Initialize remove ← Set() // 用於記錄需要移除的索引\n→ Decision: 遍歷 s 的每個字符 (i, ch) // 逐字符處理\n    Yes → Decision: ch == '('? // 判斷左括號\n        Yes → stack.push(i) // 將索引加入棧\n        No  → Decision: ch == ')'?\n            Yes → Decision: stack 非空?\n                Yes → stack.pop() // 找到配對，棧減一\n                No  → remove.add(i) // 未配對，標記移除\n            No  → // 小寫字母，忽略\n→ Decision: stack 非空? // 檢查剩餘 '('\n    Yes → While stack not empty\n        idx ← stack.pop()\n        remove.add(idx) // 標記未配對的 '('\n→ Initialize result ← '' // 儲存最終字串\n→ For each (i, ch) in s\n    Decision: i ∈ remove? // 是否需要移除\n        Yes → Continue // 跳過\n        No  → result ← result + ch // 加入結果\n→ Output result // 回傳合法字串\nEnd // 程式執行結束\n\nEnsure formatting: each line: `虛擬碼步驟 // 解釋`. Use arrows `→`, `Decision:`. For while loops, use `While`. Use `stack.push`, etc. Provide explanations in Chinese. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input s // 取得輸入字串  \n→ Initialize stack ← [] // 用於儲存 '(' 的索引  \n→ Initialize remove ← Set() // 用於記錄需要移除的索引  \n→ Decision: 遍歷 s 的每個字符 (i, ch) // 逐字符處理  \n  Yes → Decision: ch == '('? // 判斷左括號  \n    Yes → stack.push(i) // 將索引加入棧  \n    No  → Decision: ch == ')'? // 判斷右括號  \n     Yes → Decision: stack 非空? // 是否有未配對左括號  \n      Yes → stack.pop() // 找到配對，棧減一  \n      No  → remove.add(i) // 未配對，標記移除  \n     No  → // 小寫字母，忽略  \n→ Decision: stack 非空? // 檢查剩餘 '('  \n  Yes → While stack not empty  \n    idx ← stack.pop()  \n    remove.add(idx) // 標記未配對的 '('  \n→ Initialize result ← '' // 儲存最終字串  \n→ For each (i, ch) in s  \n  Decision: i ∈ remove? // 是否需要移除  \n    Yes → Continue // 跳過  \n    No  → result ← result + ch // 加入結果  \n→ Output result // 回傳合法字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def minRemoveToMakeValid(self, s: str) -> str:\n        \"\"\"\n        Remove the minimum number of parentheses to make the string valid.\n        \"\"\"\n        chars = list(s)          # convert to list for in-place modifications\n        stack = []               # stack of indices of unmatched '('\n\n        # First pass: find unmatched ')', mark them for removal\n        for i, ch in enumerate(chars):\n            if ch == '(':\n                stack.append(i)          # remember position of '('\n            elif ch == ')':\n                if stack:\n                    stack.pop()         # matched with a '('\n                else:\n                    chars[i] = ''        # unmatched ')', delete it\n\n        # Second pass: remove remaining unmatched '('\n        for i in stack:\n            chars[i] = ''\n\n        return ''.join(chars)\n\ndef main() -> None:\n    \"\"\"\n    Reads the input string from stdin, processes it, and prints the\n    resulting valid string.\n    \"\"\"\n    data = sys.stdin.read().strip()\n\n    # Handle optional formatting like `s = \"...\"`\n    if data.startswith('s'):\n        # Find the first '=' and take everything after it\n        eq_index = data.find('=')\n        if eq_index != -1:\n            data = data[eq_index + 1 :].strip()\n\n    # Remove surrounding quotes if present\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        data = data[1:-1]\n\n    solution = Solution()\n    result = solution.minRemoveToMakeValid(data)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"lee(t(c)o)de)\"",
          "expected_output": "\"lee(t(c)o)de\"",
          "success": true,
          "output": "lee(t(c)o)de"
        },
        {
          "example_index": 1,
          "input": "s = \"a)b(c)d\"",
          "expected_output": "\"ab(c)d\"",
          "success": true,
          "output": "ab(c)d"
        },
        {
          "example_index": 2,
          "input": "s = \"))((\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode239.json",
    "problem_index_in_file": 0,
    "title": "Sliding Window Maximum",
    "description_snippet": "You are given an array of integers nums, there is a sliding window of size k which is moving from th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode for sliding window maximum algorithm. We must follow format: each line with virtual code and comment. Use arrow → and decisions. Provide step-by-step.\n\nWe need to produce the algorithm: likely use deque to keep indices of maximum candidates.\n\nWe produce steps:\n\nStart\n→ Step 1: Initialize deque empty // store indices\n→ For each index i from 0 to n-1\n    → Decision: Is deque not empty and deque.front < i-k? // out of window\n        Yes → Step 2: pop_front\n        No →\n    → Decision: While deque not empty and nums[deque.back] < nums[i] // maintain decreasing order\n        Yes → Step 3: pop_back\n        No →\n    → Step 4: push_back i\n    → Decision: i >= k-1? // window complete\n        Yes → Step 5: append nums[deque.front] to result\n        No →\nEnd\n\nAlso add variable initializations for result.\n\nLet's format with arrows and decisions properly.\n\nWe need to show indentation maybe? Use spaces after arrow? Format from example uses indentation inside Decision block. So we replicate that.\n\nLet's produce pseudocode:\n\nStart // 程式開始\n→ Step 1: Set deque ← empty // 用來存儲索引，保持元素遞減\n→ Step 2: Set result ← empty list // 儲存每個窗口的最大值\n→ For i ← 0 to length(nums)-1\n    → Decision: deque not empty AND deque.front < i - k?\n        Yes → Step 3: deque.pop_front() // 移除已離開窗口的索引\n        No →\n    → Decision: deque not empty AND nums[deque.back] < nums[i]?\n        Yes → Step 4: deque.pop_back() // 清除比當前值小的索引，因為不會再成為最大\n        No →\n    → Step 5: deque.push_back(i) // 將當前索引加入\n    → Decision: i >= k-1?\n        Yes → Step 6: result.append(nums[deque.front]) // 當窗口完整時，紀錄最大值\n        No →\nEnd // 程式結束\n\nWe might add indentation. Use tab? Example uses spaces for indentation inside Decision. We'll do that.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: Set deque ← empty // 用來存儲索引，保持元素遞減  \n→ Step 2: Set result ← empty list // 儲存每個窗口的最大值  \n→ For i ← 0 to length(nums)-1  \n  → Decision: deque not empty AND deque.front < i - k? // 判斷前一個索引是否已離開窗口  \n    Yes → Step 3: deque.pop_front() // 移除已離開窗口的索引  \n    No →  \n  → Decision: deque not empty AND nums[deque.back] < nums[i]? // 清除比當前值小的索引  \n    Yes → Step 4: deque.pop_back() // 這些索引不會再成為最大值  \n    No →  \n  → Step 5: deque.push_back(i) // 將當前索引加入隊列  \n  → Decision: i >= k-1? // 判斷窗口是否已形成完整大小  \n    Yes → Step 6: result.append(nums[deque.front]) // 記錄當前窗口的最大值  \n    No →  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\ndef max_sliding_window(nums, k):\n    \"\"\"\n    Return the maximum values in each sliding window of size k.\n    \"\"\"\n    if not nums or k == 0:\n        return []\n\n    deq = deque()          # stores indices of potential max elements\n    res = []\n\n    for i in range(len(nums)):\n        # Remove indices that are outside the current window\n        while deq and deq[0] < i - k + 1:\n            deq.popleft()\n\n        # Remove indices whose corresponding values are smaller than nums[i]\n        while deq and nums[deq[-1]] < nums[i]:\n            deq.pop()\n\n        deq.append(i)\n\n        # Append current max when the first full window is reached\n        if i >= k - 1:\n            res.append(nums[deq[0]])\n\n    return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n\n    nums = None\n    k = None\n\n    # Try to parse input of the form: nums = [...], k = ...\n    pattern = r'nums\\s*=\\s*(\\[.*\\])\\s*,\\s*k\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data)\n    if match:\n        nums = eval(match.group(1))\n        k = int(match.group(2))\n    else:\n        # Fallback: assume the first line is the list, the second line is k\n        lines = [line.strip() for line in data.splitlines() if line.strip()]\n        if len(lines) >= 2:\n            nums = eval(lines[0])\n            k = int(lines[1])\n\n    if nums is None or k is None:\n        print(\"Invalid input\")\n        sys.exit(1)\n\n    result = max_sliding_window(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,-1,-3,5,3,6,7], k = 3",
          "expected_output": "[3,3,5,5,6,7]",
          "success": true,
          "output": "[3, 3, 5, 5, 6, 7]"
        },
        {
          "example_index": 1,
          "input": "nums = [1], k = 1",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode68.json",
    "problem_index_in_file": 0,
    "title": "Text Justification",
    "description_snippet": "Given an array of strings words and a width maxWidth, format the text such that each line has exactl...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the text justification algorithm, step by step with explanations. We must not output real code, just pseudocode steps, with arrow markers. Format: each line \"虛擬碼步驟 // 解釋\". Use arrow → and decisions. Let's craft algorithm: Start, iterate words with index i. For each line, gather words until adding next would exceed maxWidth. Count words and line length. Compute spaces: totalSpaces = maxWidth - sumLen. If only one word or last line: left justify: join words with single space then pad end with spaces. Else: divide spaces evenly: spacesBetween = totalSpaces / (numWords-1), remainder = totalSpaces % (numWords-1). For each gap: assign spacesBetween + (remainder>0?1:0) and decrement remainder. Build line. Add to result. Move i to j. Loop until i==n. End. Provide step by step.\n\nWe need to use decisions with Yes →, No →.\n\nLet's produce code lines:\n\nStart // 程式開始\n→ Step 1: 初始化 i = 0, wordsCount = words.length, result = 空清單 // 準備索引與結果\n→ Decision: i < wordsCount? // 是否還有未處理的單字\n    Yes → Step 2: 計算 j = i, lineLen = 0, wordsInLine = 空清單 // 開始一行的計算\n→ Decision: j < wordsCount AND lineLen + words[j].length + wordsInLine.size <= maxWidth? // 檢查是否可以加入下一個單字\n        Yes → Step 3: lineLen += words[j].length // 累計字長\n               Step 4: wordsInLine.add(words[j]) // 加入單字\n               Step 5: j++ // 移至下一個單字\n               → 再次檢查 Decision above\n        No → Step 6: totalSpaces = maxWidth - lineLen // 計算此行需要的空格總數\n               Decision: wordsInLine.size == 1 OR j == wordsCount? // 單字行或最後一行\n                    Yes → Step 7: line = wordsInLine.join(' ') // 只用單空格連接\n                           Step 8: line = line + repeat(' ', maxWidth - line.length) // 右側填充空格\n                    No  → Step 9: gaps = wordsInLine.size - 1 // 需要插入空格的槽數\n                           Step 10: spacePerGap = totalSpaces / gaps // 每個槽的基本空格數\n                           Step 11: extra = totalSpaces % gaps // 多餘的空格\n                           Step 12: line = 空字串\n                           → Loop over index k from 0 to wordsInLine.size-1\n                                 → Append wordsInLine[k] to line\n                                 → If k < gaps\n                                         spaces = spacePerGap + (extra>0?1:0)\n                                         line = line + repeat(' ', spaces)\n                                         If extra>0 then extra--\n                           End loop\n               Step 13: result.add(line) // 將排好版的行加入結果\n               Step 14: i = j // 將主索引移到下一行的起始位置\n               → 再次進入 Decision i < wordsCount\n→ End // 程式結束\n\nWe should output lines accordingly. Ensure each line includes \"→\" or \"Start\" or \"End\". The decision blocks should include indent? The example used indent inside decision. We'll follow same style.\n\nWe should keep line number? Not needed.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0, n ← words.length, result ← [] // 初始化索引與結果列表  \n→ Decision: i < n? // 是否還有未處理的單字  \n    Yes → Step 2: j ← i, lineLen ← 0, lineWords ← [] // 開始新一行的計算  \n    → Decision: j < n AND lineLen + words[j].length + lineWords.size ≤ maxWidth? // 是否能加入下一個單字  \n        Yes → Step 3: lineLen ← lineLen + words[j].length // 累計行長度  \n               Step 4: lineWords.append(words[j]) // 加入單字  \n               Step 5: j ← j + 1 // 移至下一個單字  \n               → 再次檢查 Decision above  \n        No → Step 6: totalSpaces ← maxWidth - lineLen // 本行需要的空格總數  \n               Decision: lineWords.size == 1 OR j == n? // 單字行或最後一行  \n                    Yes → Step 7: line ← join(lineWords, \" \") // 只用單空格連接單字  \n                           Step 8: line ← line + repeat(\" \", maxWidth - line.length) // 右側填充空格  \n                    No  → Step 9: gaps ← lineWords.size - 1 // 空格槽數  \n                           Step 10: spacePerGap ← totalSpaces / gaps // 每槽基礎空格數  \n                           Step 11: extra ← totalSpaces % gaps // 多餘空格數  \n                           Step 12: line ← \"\" // 準備組裝行  \n                           → Loop k from 0 to lineWords.size - 1  \n                                 → Append lineWords[k] to line  \n                                 → If k < gaps  \n                                         spaces ← spacePerGap + (extra > 0 ? 1 : 0)  \n                                         line ← line + repeat(\" \", spaces)  \n                                         If extra > 0 then extra ← extra - 1  \n                           End Loop  \n               Step 13: result.append(line) // 將排好版的行加入結果  \n               Step 14: i ← j // 將主索引移到下一行起點  \n               → 再次進入 Decision i < n  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            # determine how many words can fit in the line\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            # build the line\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                # left-justify for last line or single word\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                # fully justify\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\ndef parse_input(input_str):\n    \"\"\"Parse the input format: words = [...], maxWidth = N\"\"\"\n    parts = input_str.split(', maxWidth = ')\n    words_part = parts[0].strip()\n    maxwidth_part = parts[1].strip() if len(parts) > 1 else ''\n\n    # Remove leading 'words = '\n    if words_part.startswith('words ='):\n        words_part = words_part[len('words ='):].strip()\n\n    words = ast.literal_eval(words_part)\n    maxWidth = int(maxwidth_part)\n    return words, maxWidth\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    words, maxWidth = parse_input(data)\n    sol = Solution()\n    result = sol.fullJustify(words, maxWidth)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "success": true,
          "output": "['This    is    an', 'example  of text', 'justification.  ']"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "success": true,
          "output": "['What   must   be', 'acknowledgment  ', 'shall be        ']"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "success": true,
          "output": "['Science  is  what we', 'understand      well', 'enough to explain to', 'a  computer.  Art is', 'everything  else  we', 'do                  ']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode38.json",
    "problem_index_in_file": 0,
    "title": "Count and Say",
    "description_snippet": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\ncountAn...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation comments. The code should implement countAndSay(n). We should generate virtual steps: Start, input n, if n==1 return \"1\". Else loop from 2 to n, generate next string by RLE of previous. Use string building. Need to use Decision, Yes/No. Use virtual arrow. Provide explanation.\n\nLet's produce step-by-step:\n\nStart\n→ Step 1: Set result = \"1\" // initial sequence for n=1\n→ Step 2: Read input n // number of iterations\n→ Decision: If n <= 1? // if only first element requested\n    Yes → Step 3: Return result // output \"1\"\n    No  → Step 4: Set counter = 2 // start from second term\n→ Loop: while counter <= n\n    → Step 5: Initialize next = \"\" // empty string for new term\n    → Step 6: Initialize i = 0 // index in result\n    → Step 7: While i < length(result)\n        → Step 8: Set count = 1 // at least one occurrence\n        → Step 9: While i+1 < length(result) AND result[i] == result[i+1]\n            → count++ ; i++ // count consecutive same digits\n        → Step 10: Append count and result[i] to next // build RLE\n        → Step 11: i++ // move to next distinct character\n    → Step 12: Set result = next // update for next iteration\n    → Step 13: counter++ // move to next term\n→ Step 14: Return result // after loop finished, output nth term\nEnd\n\nNeed to format each line with arrow and explanation. Use virtual arrow like \"→ Step 1:\" etc.\n\nLet's ensure each line includes \"虛擬碼步驟\" and comment. We need to include \"Start\" line. Each line should include virtual code step plus comment. Use spaces: \"→ Step 1:\" etc. Also decision lines need \"Decision:\" and Yes/No arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← \"1\" // 初始化第一項為字串 \"1\"  \n→ Step 2: Read input n // 取得要計算的第 n 項  \n→ Decision: n ≤ 1? // 判斷是否只需要第一項  \n  Yes → Step 3: Return result // 若 n≤1，直接回傳 \"1\"  \n  No  → Step 4: counter ← 2 // 從第二項開始迭代  \n→ Loop: counter ≤ n? // 進入迴圈直到計算到第 n 項  \n  Yes → Step 5: next ← \"\" // 建立新的空字串，用於儲存下一項  \n   → Step 6: i ← 0 // 設定索引 i 為 0  \n   → Step 7: i < length(result)? // 檢查是否已遍歷完前一項字串  \n     Yes → Step 8: count ← 1 // 至少有一個相同字元  \n      → Step 9: i+1 < length(result) ∧ result[i] = result[i+1]? // 判斷是否有連續相同字元  \n        Yes → count ← count + 1 ; i ← i + 1 // 連續相同，計數加一並移至下一個字元  \n        No  → Step 10: next ← next + count + result[i] // 將計數與字元拼接至 next  \n         → i ← i + 1 // 移動到下一個不同字元  \n         → Loop back to Step 7  \n        No  → Step 11: next ← next + count + result[i] // 處理最後一段連續字元  \n         → i ← i + 1 // 移動結束  \n         → Loop back to Step 7  \n     No  → Step 12: result ← next // 用新產生的字串更新 result  \n      → counter ← counter + 1 // 增加次數計數  \n      → Loop back to counter ≤ n  \n  No  → Step 13: Return result // 迴圈結束，回傳第 n 項  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countAndSay(self, n: int) -> str:\n        \"\"\"Return the nth term of the count-and-say sequence.\"\"\"\n        if n <= 0:\n            return \"\"\n        result = \"1\"                 # 第一項\n        for _ in range(2, n + 1):    # 從第二項開始迭代\n            next_term = []           # 用列表累積更快\n            i, length = 0, len(result)\n            while i < length:\n                count = 1\n                while i + 1 < length and result[i] == result[i + 1]:\n                    count += 1\n                    i += 1\n                next_term.append(str(count))\n                next_term.append(result[i])\n                i += 1\n            result = \"\".join(next_term)\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    if match:\n        n = int(match.group())\n        sol = Solution()\n        print(sol.countAndSay(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "\"1211\"",
          "success": true,
          "output": "1211"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "\"1\"",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode287.json",
    "problem_index_in_file": 0,
    "title": "Find the Duplicate Number",
    "description_snippet": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding duplicate number in array of size n+1 with numbers 1..n, using Floyd's cycle detection. Provide step-by-step.\n\nWe should not output actual code, only virtual steps. Use arrows, Start, End, Decision. Provide each line: \"虛擬碼步驟 // 解釋\".\n\nMake sure to include constant space, no modification. So steps: Start, Step 1: Initialize slow=nums[0], fast=nums[0]. Then while true: slow=nums[slow]; fast=nums[nums[fast]]; if slow==fast break. Then Step 2: Reset slow=nums[0]; while slow!=fast: slow=nums[slow]; fast=nums[fast]; return slow.\n\nInclude decisions for while loops.\n\nWe need to produce in Chinese.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化慢指標 slow = nums[0] // 把慢指標指向第一個元素\n→ Step 2: 初始化快指標 fast = nums[0] // 把快指標也指向第一個元素\n→ Decision: 進入循環尋找相遇點? // 循環直到兩指標相遇\n    Yes → Step 3: 慢指標 slow = nums[slow] // 慢指標移動一步\n    → Step 4: 快指標 fast = nums[nums[fast]] // 快指標移動兩步\n    → Decision: slow == fast? // 檢查是否相遇\n        Yes → Break loop // 相遇，跳出循環\n        No  → Continue // 仍未相遇，重複步驟 3-4\n→ Step 5: 重置慢指標 slow = nums[0] // 把慢指標重新指向第一個元素\n→ Decision: 進入尋找重複值? // 循環直到 slow == fast\n    Yes → Step 6: slow = nums[slow] // 慢指標移動一步\n    → Step 7: fast = nums[fast] // 快指標移動一步\n    → Decision: slow == fast? // 檢查是否相遇\n        Yes → Break loop // 相遇，找到重複值\n        No  → Continue // 仍未相遇，重複步驟 6-7\n→ Step 8: 返回 slow // slow 即為重複數字\nEnd // 程式執行結束\n\nWe need to format each line as \"虛擬碼步驟 // 解釋\". Use \"→\" before steps. Use \"Decision:\" for decision lines. Each line after \"Decision:\" may have indentation. Provide \"Yes →\" and \"No →\" branches.\n\nWe must not output actual code. Use Chinese.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化慢指標 slow = nums[0] // 把慢指標指向第一個元素  \n→ Step 2: 初始化快指標 fast = nums[0] // 把快指標也指向第一個元素  \n→ Decision: 進入循環尋找相遇點? // 循環直到兩指標相遇  \n Yes → Step 3: 慢指標 slow = nums[slow] // 慢指標移動一步  \n  → Step 4: 快指標 fast = nums[nums[fast]] // 快指標移動兩步  \n  → Decision: slow == fast? // 檢查是否相遇  \n   Yes → Break loop // 相遇，跳出循環  \n   No  → Continue // 仍未相遇，重複步驟 3-4  \n→ Step 5: 重置慢指標 slow = nums[0] // 把慢指標重新指向第一個元素  \n→ Decision: 進入尋找重複值? // 循環直到 slow == fast  \n Yes → Step 6: slow = nums[slow] // 慢指標移動一步  \n  → Step 7: fast = nums[fast] // 快指標移動一步  \n  → Decision: slow == fast? // 檢查是否相遇  \n   Yes → Break loop // 相遇，找到重複值  \n   No  → Continue // 仍未相遇，重複步驟 6-7  \n→ Step 8: 返回 slow // slow 即為重複數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # 使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        \n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        \n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        \n        return slow\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中抽取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        return\n    sol = Solution()\n    result = sol.findDuplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,4,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "nums = [3,3,3,3,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode406.json",
    "problem_index_in_file": 0,
    "title": "Queue Reconstruction by Height",
    "description_snippet": "You are given an array of people, people, which are the attributes of some people in a queue (not ne...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code algorithm: reconstruct queue given [h,k]. Standard solution: sort people by height descending, then k ascending; insert each into result list at index k. Steps.\n\nWe output line by line with virtual code steps and explanation. Use arrows and structure. Provide Start, End, Decision? but algorithm straightforward. We'll use decisions for sorting maybe not necessary but we can include. We'll present steps:\n\nStart\n→ Step 1: Sort people by height descending, then k ascending // sort to process tall people first\n→ Step 2: Initialize empty list queue // result\n→ For each person in sorted list: // iterate\n    → Step 3: Insert person into queue at index person.k // place at k position\nEnd\n\nWe need to use arrow \"→\" before each step. For For loop we can show Decision: if there are more people? but not necessary. We'll keep simple.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort people by height descending, then k ascending // 先把最高的人排在前面，對於同高則 k 小的先處理  \n→ Step 2: Initialize empty list queue // 用來存放最後的隊列  \n→ Decision: 仍有待處理的人? // 判斷是否還有人需要插入  \n    Yes → Step 3: 取出第一個 person (h, k) from sorted list // 取得當前要處理的人  \n    → Step 4: Insert (h, k) into queue at index k // 根據 k 的值把人放在正確位置  \n    → Step 5: Remove this person from sorted list // 從待處理列表中刪除已插入的人  \n    → Decision: 仍有待處理的人? // 重複步驟直到列表空  \n        No → End // 所有人已插入，隊列已重建  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def reconstructQueue(self, people):\n        \"\"\"\n        Reconstruct the queue based on height and number of taller or equal people in front.\n        \"\"\"\n        # Sort by height descending; for equal height, by k ascending\n        people.sort(key=lambda x: (-x[0], x[1]))\n        result = []\n        for person in people:\n            # Insert person at index equal to their k value\n            result.insert(person[1], person)\n        return result\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the list of people from the input string\n    # Find the first '[' and parse from there\n    start_index = raw_input.find('[')\n    if start_index == -1:\n        people = []\n    else:\n        people = ast.literal_eval(raw_input[start_index:])\n\n    # Reconstruct the queue\n    solution = Solution()\n    queue = solution.reconstructQueue(people)\n\n    # Output the result in Python list format\n    print(queue)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]",
          "expected_output": "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]",
          "success": true,
          "output": "[[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]"
        },
        {
          "example_index": 1,
          "input": "people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]",
          "expected_output": "[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]",
          "success": true,
          "output": "[[4, 0], [5, 0], [2, 2], [3, 2], [1, 4], [6, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode381.json",
    "problem_index_in_file": 0,
    "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
    "description_snippet": "RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation. It's like algorithm steps. We'll outline data structures: vector for values, unordered_map val->unordered_set indices. Then methods insert, remove, getRandom. Provide steps. Use virtual code syntax: Start, Step, Decision, Yes→, No→, End. Each line: virtual code step + // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 empty vector values // 存放所有元素的動態陣列\n→ Step 2: 初始化空映射 idxMap: value → set of indices // 追蹤每個值在 values 中的索引位置\n→ Step 3: 初始化隨機數生成器 rng // 用於 getRandom\n\n// ---------- insert ----------\n→ Step 4: Decision: insert(val) 是否執行？ // 進入 insert 方法\n    → Step 5: 把 val 加到 values 的尾部，記錄 index = values.size() - 1 // 新元素加入\n    → Step 6: 把 index 加入 idxMap[val] 的集合 // 更新索引映射\n    → Step 7: Decision: val 之前是否存在？ // 判斷是否為首次插入\n        Yes → Step 8: 返回 false // 已存在，回傳 false\n        No  → Step 9: 返回 true  // 第一次插入，回傳 true\n\n// ---------- remove ----------\n→ Step 10: Decision: remove(val) 是否執行？ // 進入 remove 方法\n    → Step 11: Decision: val 是否存在於 idxMap？ // 檢查是否有可移除的元素\n        Yes → Step 12: 取 idxMap[val] 中任一 indexToRemove // 隨機選擇一個待刪索引\n        No  → Step 13: 返回 false // 沒有此值，回傳 false\n\n        // 下面為 val 存在的情況\n        → Step 14: 取得 values 的最後一個元素 lastVal = values.back() // 準備交換\n        → Step 15: 取得最後一個元素的索引 lastIndex = values.size() - 1 // 為後續操作做準備\n        → Step 16: 把 lastVal 的索引集合中 lastIndex 的位置，改為 indexToRemove // 交換索引\n        → Step 17: 把 values[indexToRemove] 設為 lastVal // 交換實際值\n        → Step 18: 從 idxMap[val] 刪除 indexToRemove // 移除被刪元素的索引\n        → Step 19: Decision: indexToRemove == lastIndex? // 檢查是否刪除的是最後一個元素\n            Yes → Step 20: 從 idxMap[val] 刪除 lastIndex // 只需移除最後索引\n            No  → Step 21: 也從 idxMap[lastVal] 中刪除 lastIndex // 需要同步更新 lastVal 的索引\n        → Step 22: 從 values 刪除最後一個元素 // 真正刪除元素\n        → Step 23: Decision: idxMap[val] 是否為空？ // 若 val 已無任何索引\n            Yes → Step 24: 從 idxMap 刪除 val // 清理映射\n            No  → Step 25: 留下 idxMap[val] // 保持現有映射\n        → Step 26: 返回 true // 成功移除\n\n// ---------- getRandom ----------\n→ Step 27: Decision: getRandom() 是否執行？ // 進入 getRandom 方法\n    → Step 28: 產生隨機整數 randIdx ∈ [0, values.size() - 1] using rng // 隨機索引\n    → Step 29: 返回 values[randIdx] // 取得隨機元素\n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\nimport ast\nfrom collections import defaultdict\n\nclass RandomizedCollection:\n    def __init__(self):\n        # 存放所有元素的列表，允許重複\n        self.data = []\n        # value -> set of indices 在 data 中該值出現的位置\n        self.idx_map = defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        \"\"\"\n        將 val 插入集合。\n        若 val 為首次插入，回傳 True；若已有，回傳 False。\n        \"\"\"\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # 若此 value 現在只有一個索引，代表首次插入\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        \"\"\"\n        移除集合中一個 val（若存在）。\n        成功移除返回 True，否則返回 False。\n        \"\"\"\n        if not self.idx_map[val]:\n            return False\n\n        # 取要移除的索引\n        remove_idx = self.idx_map[val].pop()\n        # 取最後一個元素\n        last_val = self.data[-1]\n        last_idx = len(self.data) - 1\n\n        # 把最後一個元素放到要移除的位置\n        self.data[remove_idx] = last_val\n        # 更新索引映射\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        # 從列表中刪除最後一個元素\n        self.data.pop()\n\n        # 若此 value 不再存在，清除其映射\n        if not self.idx_map[val]:\n            del self.idx_map[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"\n        隨機返回集合中的一個元素，概率與其出現頻率成正比。\n        \"\"\"\n        return random.choice(self.data)\n\ndef _format_output(res):\n    \"\"\"將結果列表轉成符合 LeetCode 輸出格式的字串。\"\"\"\n    out = []\n    for v in res:\n        if v is None:\n            out.append('null')\n        elif isinstance(v, bool):\n            out.append('true' if v else 'false')\n        else:\n            out.append(str(v))\n    return '[' + ', '.join(out) + ']'\n\ndef main():\n    # 讀取整個輸入，並把它包成一個外層列表後做 literal_eval\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    try:\n        data = ast.literal_eval('[' + raw + ']')\n    except Exception as e:\n        # 若輸入格式不符合預期，直接退出\n        return\n\n    ops, args = data[0], data[1]\n    result = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            result.append(None)\n        elif op == \"insert\":\n            result.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(obj.getRandom())\n    print(_format_output(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,1]'\nGot (Norm):      '[null,true,false,true,1,true,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, 1]'\nRaw Got:      '[null, true, false, true, 1, true, 2]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode132.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning II",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines for the algorithm: given a string s, find minimal cuts to partition into palindromic substrings. Classic DP: preprocess palindrome table, DP for min cuts. We produce step-by-step virtual code: Start, input s, precompute palindrome table, DP array for cuts, iterate, update, output result, End. Provide explanations. Use arrows. Use Decision: lines. Let's craft. Ensure each line ends with // explanation. Use \"→\" arrows to indicate flow. Use \"Decision:\" with Yes→, No→. Provide Start and End. No actual code. Use virtual code only. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 從使用者處取得待處理字串  \n→ Step 2: 取得 s 的長度 n // 為後續計算做準備  \n\n// 先預處理所有子字串是否為迴文  \n→ Step 3: 建立二維布林表 isPal[n][n]，預設為 False // 用來記錄 s[l..r] 是否為迴文  \n→ Decision: 是否有字元? // 檢查 s 是否為空  \n    Yes → Step 4: isPal[i][i] ← True for all i // 單個字元永遠是迴文  \n    No  → End // 若字串空，直接結束  \n\n→ Decision: 是否有相鄰相同字元? // 檢查長度為 2 的子字串  \n    Yes → Step 5: isPal[i][i+1] ← (s[i] == s[i+1]) for all i // 兩字母相等即為迴文  \n    No  → // 直接略過  \n\n→ Decision: 是否有長度 > 2 的子字串? // 從長度 3 開始遞增  \n    Yes →  \n        → Step 6: For len = 3 to n  \n            → Step 7: For l = 0 to n-len  \n                → Step 8: r ← l + len - 1  \n                → Step 9: isPal[l][r] ← (s[l] == s[r]) AND isPal[l+1][r-1] // 判斷是否為迴文  \n    No  → // 若 n < 3，略過  \n\n// 現在使用 DP 計算最小切割數  \n→ Step 10: 建立一維整數陣列 cuts[n] // cuts[i] 表示前 i+1 個字元的最小切割數  \n→ Step 11: For i = 0 to n-1  \n    → Step 12: If isPal[0][i]  \n        → Step 13: cuts[i] ← 0 // 整個子字串已是迴文，無需切割  \n    → Decision: 否則  \n        Yes →  \n            → Step 14: cuts[i] ← INF // 初始化為無窮大  \n            → Step 15: For j = 1 to i  \n                → Decision: 子字串 s[j..i] 是否為迴文?  \n                    Yes →  \n                        → Step 16: cuts[i] ← min(cuts[i], cuts[j-1] + 1) // 若 s[j..i] 迴文，更新切割數  \n                    No → // 不做更新  \n        No  → // 已在步驟13處理  \n\n→ Step 17: 輸出 cuts[n-1] // 最後一個位置的最小切割數即為答案  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def minCut(self, s: str) -> int:\n        n = len(s)\n        if n == 0:\n            return 0\n        dp = [0] * n\n        pal = [[False] * n for _ in range(n)]\n\n        for i in range(n):\n            min_cut = i  # worst case: cut before every character\n            for j in range(i + 1):\n                # Check if s[j:i+1] is a palindrome\n                if s[j] == s[i] and (i - j <= 1 or pal[j + 1][i - 1]):\n                    pal[j][i] = True\n                    if j == 0:\n                        min_cut = 0\n                    else:\n                        min_cut = min(min_cut, dp[j - 1] + 1)\n            dp[i] = min_cut\n        return dp[-1]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n\n    # Try to extract the string inside quotes if present\n    if '\"' in data:\n        first = data.find('\"')\n        last = data.rfind('\"')\n        if first != -1 and last != -1 and last > first:\n            s = data[first + 1:last]\n        else:\n            s = data\n    else:\n        s = data\n\n    sol = Solution()\n    result = sol.minCut(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "s = \"ab\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode521.json",
    "problem_index_in_file": 0,
    "title": "Longest Uncommon Subsequence I",
    "description_snippet": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps that compute longest uncommon subsequence between two strings a and b. For two strings, solution: If a == b then return -1 else return max(len(a), len(b)). So produce virtual code accordingly. Follow format: Start, then steps. We'll produce step by step: Input strings a and b. Compare equality. Decision: If equal → return -1. Else → return max(len(a), len(b)). End. Provide explanations. Use virtual code with arrows. Each line: \"虛擬碼步驟 // 解釋\". Provide in Traditional Chinese. Use \"→\". Ensure each line includes \"虛擬碼步驟\" with arrow. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收字串 a 與 b // 取得兩個輸入字串  \n→ Decision: a 與 b 是否相同? // 檢查兩字串是否完全相等  \n    Yes → Step 2: 輸出 -1 // 若相同，沒有任何不常見子序列，回傳 -1  \n    No → Step 3: 計算 len_a ← 長度(a) // 取得字串 a 的長度  \n    → Step 4: 計算 len_b ← 長度(b) // 取得字串 b 的長度  \n    → Decision: len_a 大於 len_b? // 比較兩長度大小  \n        Yes → Step 5: 輸出 len_a // a 更長，最長不常見子序列為 a 本身  \n        No → Step 6: 輸出 len_b // b 更長或相等時，最長不常見子序列為 b 本身  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        \"\"\"\n        若兩字串相同，則不存在不常見子序列，回傳 -1。\n        否則最長的不常見子序列就是較長的那一個字串本身，長度為兩字串長度中的較大值。\n        \"\"\"\n        if a == b:\n            return -1\n        return max(len(a), len(b))\n\ndef parse_input(raw: str):\n    \"\"\"\n    將輸入字串轉成兩個純文字字串。\n    期望輸入類似於 '\"aba\", \"cdc\"' 或 'aba,cdc' 等形式。\n    \"\"\"\n    # 移除首尾空白與換行\n    raw = raw.strip()\n    if not raw:\n        return \"\", \"\"\n\n    # 以逗號切割，假設只有兩個元素\n    parts = raw.split(',')\n    if len(parts) != 2:\n        # 若無逗號分隔，視為兩行輸入\n        lines = raw.splitlines()\n        if len(lines) >= 2:\n            return lines[0].strip(), lines[1].strip()\n        raise ValueError(\"輸入格式錯誤\")\n\n    a = parts[0].strip().strip('\"').strip(\"'\")\n    b = parts[1].strip().strip('\"').strip(\"'\")\n    return a, b\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    a, b = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findLUSlength(a, b)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"aba\", \"cdc\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "\"aaa\", \"bbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "\"aaa\", \"aaa\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode322.json",
    "problem_index_in_file": 0,
    "title": "Coin Change",
    "description_snippet": "You are given an integer array coins representing coins of different denominations and an integer am...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, explaining dynamic programming solution: min number of coins. Classic DP with array dp[amount+1] initialized INF except dp[0] = 0, iterate coin, for each i from coin to amount, dp[i] = min(dp[i], dp[i-coin]+1). At end if dp[amount] > amount return -1 else dp[amount]. We'll produce steps accordingly. Use Start, End, Decision, arrow.\n\nWe'll structure steps:\n\nStart\n→ Initialize dp array of length amount+1 with large INF // placeholder for unreachable\n→ Set dp[0] = 0 // zero coins to make 0\n→ For each coin in coins\n    → For i from coin to amount\n        → If dp[i-coin] + 1 < dp[i]\n            → Update dp[i] = dp[i-coin] + 1 // record better count\n→ After loops, Check if dp[amount] is still INF\n    Yes → Return -1 // cannot make amount\n    No  → Return dp[amount] // minimal coins\n\nBut we need virtual code style.\n\nLet's craft:\n\nStart // 程式開始執行\n→ 初始化 dp[0..amount] 為無限大 // 代表尚未可達的金額\n→ dp[0] = 0 // 0 元不需要任何硬幣\n→ Decision: 是否還有硬幣可處理? // 逐一處理每個面額\n    Yes → Step 1: 取出一枚硬幣 coin // 取當前硬幣面額\n    → Decision: i = coin 到 amount?\n        Yes → Step 2: 若 dp[i-coin] + 1 < dp[i] 則 dp[i] = dp[i-coin] + 1 // 更新最少硬幣數\n        No → 回到外層循環取下一枚硬幣\n→ Decision: dp[amount] 是否仍為無限大? // 判斷是否可組成金額\n    Yes → Step 3: 回傳 -1 // 無法組成\n    No  → Step 4: 回傳 dp[amount] // 最少硬幣數\nEnd // 程式結束\n\nBut need to use arrow notation consistent: '→', 'Decision:' etc.\n\nWe need each line \"虛擬碼步驟\" + space + \"// 解釋\". Ensure no code tags. Use 'Start', 'End'.\n\nLet's refine:\n\nStart // 程式開始執行\n→ dp ← Array(amount + 1) 內部填入 INF // 初始化 dp，INF 表示不可達\n→ dp[0] ← 0 // 0 元不需要硬幣\n→ Decision: coins 是否還有元素? // 逐一處理每種硬幣面額\n    Yes → Step 1: coin ← 取出 coins 的下一個值 // 当前硬幣面額\n    → Decision: i 從 coin 到 amount? // 針對所有可達金額進行更新\n        Yes → Step 2: 若 dp[i - coin] + 1 < dp[i] 則 dp[i] ← dp[i - coin] + 1 // 更新更少硬幣數\n        No → 回到外層 Decision 處理下一枚硬幣\n→ Decision: dp[amount] 是否仍為 INF? // 判斷是否能組成總額\n    Yes → Step 3: 回傳 -1 // 無法組成\n    No  → Step 4: 回傳 dp[amount] // 返回最少硬幣數\nEnd // 程式結束\n\nCheck each line: Each line must start with 'Start', '→', 'Decision:' etc. Indent? The example uses spaces indentation for nested steps. Use '→' for steps, 'Decision:' for decisions.\n\nWe also need to ensure each line has exactly one \"虛擬碼步驟\" followed by a space then \"//\". For nested, indentation might include spaces before '→', but still same rule. We'll keep indentation with two spaces before each nested line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ dp ← Array(amount + 1) 內部填入 INF // 初始化 dp，INF 表示尚未可達的金額\n→ dp[0] ← 0 // 0 元不需要任何硬幣\n→ Decision: coins 是否還有元素? // 逐一處理每種硬幣面額\n    Yes → Step 1: coin ← 取出 coins 的下一個值 // 取得當前硬幣面額\n    → Decision: i 從 coin 到 amount? // 針對所有可達金額進行更新\n        Yes → Step 2: 若 dp[i - coin] + 1 < dp[i] 則 dp[i] ← dp[i - coin] + 1 // 更新更少硬幣數\n        No → 回到外層 Decision 處理下一枚硬幣\n→ Decision: dp[amount] 是否仍為 INF? // 判斷是否能組成總額\n    Yes → Step 3: 回傳 -1 // 無法組成\n    No  → Step 4: 回傳 dp[amount] // 返回最少硬幣數\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # 初始化 dp 陣列，dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入格式，例如：coins = [1,2,5], amount = 11\n    pattern = r'coins\\s*=\\s*(\\[.*?\\])\\s*,\\s*amount\\s*=\\s*(-?\\d+)\\s*'\n    match = re.search(pattern, data)\n    if not match:\n        # 若輸入格式不符合，直接退出\n        return\n    coins_str, amount_str = match.groups()\n    coins = ast.literal_eval(coins_str)\n    amount = int(amount_str)\n\n    result = Solution().coinChange(coins, amount)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 2,
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode213.json",
    "problem_index_in_file": 0,
    "title": "House Robber II",
    "description_snippet": "You are a professional robber planning to rob houses along a street. Each house has a certain amount...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for the circular house robber problem. Use Start, End, Decision, Steps. We need step by step. Provide explanation after space. Must not output actual code. Provide virtual code steps line by line.\n\nWe need to implement algorithm: compute max(robLinear(nums[0..n-2]), robLinear(nums[1..n-1]) ), where robLinear is classic DP.\n\nAlso handle edge cases n==1.\n\nLet's create virtual steps:\n\nStart\n\nCheck length n\n\nIf n == 1 → output nums[0] // only one house\n\nElse → compute two cases\n\nDefine function RobLinear(subarray) that returns max money by DP.\n\nRobLinear uses variables prev1, prev2\n\nBut we can implement inline loops.\n\nSimplify: For each subarray, iterate i from start to end, maintain two vars: prev2 (dp[i-2]), prev1 (dp[i-1]), cur = max(prev1, prev2 + nums[i]).\n\nFinally return prev1.\n\nSo produce steps for case 1 and case 2.\n\nAt the end compare and output max.\n\nEnd.\n\nAlso include Decision for if subarray length 0? But our subarray length at least 1 since n>=2. But still handle maybe subarray length 0 for n=2? Actually case 1 subarray length n-1 >=1. Ok.\n\nAdd explanation comments.\n\nLet's produce.\n\nRemember to use arrow format:\n\nStart // ...\n\n→ Decision: n == 1? // Check for single house\n\n   Yes → Step: Return nums[0] // only one house\n\n   No → Step: Define variable max1 // will hold max for first case\n\n   → Step: Set max1 = RobLinear(nums[0..n-2]) // exclude last house\n\n   → Step: Define variable max2\n\n   → Step: Set max2 = RobLinear(nums[1..n-1]) // exclude first house\n\n   → Decision: max1 > max2? // choose larger\n\n        Yes → Step: Return max1 // better to skip last house\n\n        No  → Step: Return max2 // better to skip first house\n\nRobLinear(subarray):\n\n   Start // function starts\n\n   → Step: If subarray length == 0? Return 0 // no houses\n\n   → Step: Initialize prev2 = 0 // dp[i-2]\n\n   → Step: Initialize prev1 = 0 // dp[i-1]\n\n   → Decision: For each house in subarray? // iterate\n\n        For i in subarray: // loop\n\n            → Step: cur = max(prev1, prev2 + house_value) // choose max\n\n            → Step: prev2 = prev1 // shift\n\n            → Step: prev1 = cur // update\n\n   → Step: Return prev1 // max money\n\nBut we need to represent loops? Virtual code may have loops indicated as For.\n\nMaybe use \"→ For each house in subarray:\" style.\n\nBut need to adhere to format? They only mention using arrows and structure. Loops can be expressed with \"For each\".\n\nLet's keep simple.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: nums.length == 1? // 檢查是否只有一棟房子\n    Yes → Step: Return nums[0] // 直接取得唯一房子裡的金額\n    No  → Step: Define max1 // 先計算不盡入最後一棟的最大金額\n    → Step: max1 = RobLinear(nums[0 .. nums.length-2]) // 刪除最後一棟，執行線性盜取\n    → Step: Define max2 // 再計算不盡入第一棟的最大金額\n    → Step: max2 = RobLinear(nums[1 .. nums.length-1]) // 刪除第一棟，執行線性盜取\n    → Decision: max1 > max2? // 比較兩種情況的最大金額\n        Yes → Step: Return max1 // 以 max1 為答案\n        No  → Step: Return max2 // 以 max2 為答案\nEnd // 程式執行結束\n\n// --------------------------\n// 定義子程序 RobLinear\nRobLinear(subarray) // 子程序開始\n→ Decision: subarray.length == 0? // 檢查子陣列是否為空\n    Yes → Step: Return 0 // 沒有房子時金額為 0\n    No  → Step: Initialize prev2 = 0 // dp[i-2] 的初值\n    → Step: Initialize prev1 = 0 // dp[i-1] 的初值\n    → For each house in subarray: // 逐個房子遍歷\n        → Step: cur = max(prev1, prev2 + house.value) // 決定是否盜取此房子\n        → Step: prev2 = prev1 // 更新 dp[i-2]\n        → Step: prev1 = cur // 更新 dp[i-1]\n    → Step: Return prev1 // 回傳最後一個 dp 值，為最大金額\nEnd // 子程序結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def rob(self, nums):\n        \"\"\"Return the maximum amount of money that can be robbed from houses arranged in a circle.\"\"\"\n        if not nums:\n            return 0\n        n = len(nums)\n        if n == 1:\n            return nums[0]\n\n        # Helper function for the linear (non‑circular) house‑robber problem.\n        def rob_linear(houses):\n            prev, curr = 0, 0\n            for amount in houses:\n                prev, curr = curr, max(curr, prev + amount)\n            return curr\n\n        # Case 1: skip the last house\n        max1 = rob_linear(nums[:-1])\n        # Case 2: skip the first house\n        max2 = rob_linear(nums[1:])\n\n        return max(max1, max2)\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # Extract the list representation from the input\n    try:\n        start = raw_input.index('[')\n        end = raw_input.rindex(']') + 1\n        list_str = raw_input[start:end]\n        nums = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # Fallback: try to evaluate the whole input directly\n        nums = ast.literal_eval(raw_input)\n\n    # Compute and print the answer\n    answer = Solution().rob(nums)\n    print(answer)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,1]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode402.json",
    "problem_index_in_file": 0,
    "title": "Remove K Digits",
    "description_snippet": "Given string num representing a non-negative integer num, and an integer k, return the smallest poss...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the problem: given string num and int k, remove k digits to get smallest possible integer. Classic greedy stack. Steps: start, if k==0 return num; initialize stack empty; for each digit in num: while stack not empty and k>0 and stack top > digit: pop; decrement k; push digit; after loop, if k>0, pop last k digits; build result string from stack; remove leading zeros; if empty return \"0\". End.\n\nWe need to format line by line with // explanation. Use virtual arrows. Let's produce step lines.\n\nWe'll start with Start. Then decision maybe for k==0. Then loop over digits. Use Decision within loop. Use while loop decision inside.\n\nLet's produce. Use \"→\" for steps. Also use Decision with Yes/No arrow.\n\nWe'll include steps:\n\nStart\n→ Decision: If k equals 0? // check if no removal needed\n    Yes → Step: return num // no removal, output original\n    No  → Step: Initialize empty stack // prepare stack\n→ For each digit d in num // iterate through digits\n    → Decision: While stack not empty and k > 0 and stack top > d? // decide to pop\n        Yes → Step: Pop stack top // remove larger digit\n        Yes → Step: Decrement k // one removal done\n        Yes → Repeat while condition // keep popping\n    → Step: Push d onto stack // keep current digit\n→ Decision: If k > 0? // remaining removals\n    Yes → Step: Remove last k digits from stack // pop from end\n→ Step: Build result string from stack // concatenate\n→ Step: Remove leading zeros from result // trim zeros\n→ Decision: If result is empty? // check if all zeros\n    Yes → Step: Set result to \"0\" // output zero\n→ End\n\nNeed to ensure each line follows format \"虛擬碼步驟 // 解釋\". The Decision lines need indentation and Yes/No lines. Use appropriate indentation. Provide consistent.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 如果 k 等於 0? // 檢查是否無需移除任何位數\n    Yes → Step: 返回 num // 直接輸出原始字串\n    No  → Step: 初始化空堆疊 // 準備存放尚未確定的位數\n→ For each 字元 d 在 num // 逐位遍歷輸入字串\n    → Decision: While 堆疊非空 且 k>0 且 堆疊頂 > d? // 判斷是否應移除較大位數\n        Yes → Step: 從堆疊頂移除位數 // 移除較大的位數\n        Yes → Step: k ← k-1 // 完成一次移除\n        Yes → Repeat while 條件 // 重新檢查條件以可能多次移除\n    → Step: 將 d 推入堆疊 // 保留目前位數\n→ Decision: 如果 k>0? // 檢查是否還剩下要移除的位數\n    Yes → Step: 從堆疊尾部移除 k 個位數 // 逐一移除剩餘位數\n→ Step: 從堆疊中組合結果字串 // 將堆疊內容轉回字串\n→ Step: 刪除結果字串前導零 // 去除多餘的零\n→ Decision: 如果結果字串為空? // 判斷是否全為零\n    Yes → Step: 將結果設為 \"0\" // 若空則輸出單一零\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeKdigits(self, num: str, k: int) -> str:\n        \"\"\"\n        用堆疊法移除 k 個位數，讓剩餘數字最小。\n        \"\"\"\n        stack = []\n        for digit in num:\n            # 若堆疊頂位數較大，且還有移除空間，則移除\n            while k > 0 and stack and stack[-1] > digit:\n                stack.pop()\n                k -= 1\n            stack.append(digit)\n\n        # 若仍有剩餘移除，則從末尾移除\n        while k > 0:\n            stack.pop()\n            k -= 1\n\n        # 轉回字串，去掉前導零\n        result = ''.join(stack).lstrip('0')\n        return result if result else \"0\"\n\ndef parse_input(text: str):\n    \"\"\"\n    解析輸入文字，支援兩種常見格式：\n    1. 多行：第一行是 num，第二行是 k\n    2. 單行：例如 'num = \"1432219\", k = 3'\n    \"\"\"\n    lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n    if len(lines) == 2:\n        # 兩行輸入\n        num_line, k_line = lines\n        num = num_line.strip('\"')\n        try:\n            k = int(k_line)\n        except ValueError:\n            k = int(re.search(r'\\d+', k_line).group())\n        return num, k\n\n    # 單行輸入\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', text)\n    k_match = re.search(r'k\\s*=\\s*(\\d+)', text)\n    num = num_match.group(1) if num_match else ''\n    k = int(k_match.group(1)) if k_match else 0\n    return num, k\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    num, k = parse_input(raw)\n    sol = Solution()\n    result = sol.removeKdigits(num, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"1432219\", k = 3",
          "expected_output": "\"1219\"",
          "success": true,
          "output": "1219"
        },
        {
          "example_index": 1,
          "input": "num = \"10200\", k = 1",
          "expected_output": "\"200\"",
          "success": true,
          "output": "200"
        },
        {
          "example_index": 2,
          "input": "num = \"10\", k = 2",
          "expected_output": "\"0\"",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode125.json",
    "problem_index_in_file": 0,
    "title": "Valid Palindrome",
    "description_snippet": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and remov...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. It's a palindrome check after normalizing: lowercase, remove non-alphanumeric. Use two-pointer from start and end. We'll produce steps.\n\nWe need to output lines with format: \"虛擬碼步驟 // 解釋/說明\"\n\nUse Start, End, Decision, etc.\n\nSo produce:\n\nStart\n→ Step 1: 初始化兩個指標 left = 0, right = s.length - 1\n→ Decision: while left < right? ...\nInside loop: skip non-alphanumeric, convert to lowercase, compare, etc.\n\nWe'll use pseudo.\n\nWe must not output actual code. Just virtual steps.\n\nLet's craft.\n\nImportant to include \"→\" arrow for steps. Use \"Decision:\" for conditionals, with Yes/No branches.\n\nNeed to maintain step lines.\n\nLet's write:\n\nStart // 開始流程\n→ Step 1: 定義 left = 0, right = s.length - 1 // 設置兩端指標\n→ Decision: left < right? // 判斷是否還有未比較的字符\n    Yes →\n        → Step 2: leftChar = s[left] // 取左邊字符\n        → Step 3: rightChar = s[right] // 取右邊字符\n        → Decision: leftChar 不是字母或數字? // 檢查左邊是否為有效字符\n            Yes →\n                → Step 4: left = left + 1 // 跳過左邊非字母數字\n                → Decision: left >= right? // 再次檢查指標位置\n                    Yes → Step 5: 跳轉到 Decision: left < right? // 重新進入判斷\n                    No  → Step 4: (回到左邊判斷)\n            No  →\n                → Decision: rightChar 不是字母或數字? // 檢查右邊是否為有效字符\n                    Yes →\n                        → Step 6: right = right - 1 // 跳過右邊非字母數字\n                        → Decision: left >= right? // 再次檢查指標位置\n                            Yes → Step 7: 跳轉到 Decision: left < right? // 重新進入判斷\n                            No  → Step 6: (回到右邊判斷)\n                    No  →\n                        → Step 8: leftChar = toLowerCase(leftChar) // 轉小寫\n                        → Step 9: rightChar = toLowerCase(rightChar) // 轉小寫\n                        → Decision: leftChar != rightChar? // 比較字符\n                            Yes → Step 10: Return False // 不相等即非回文\n                            No  →\n                                → Step 11: left = left + 1 // 移動左指標\n                                → Step 12: right = right - 1 // 移動右指標\n                                → Step 13: 跳轉到 Decision: left < right? // 重新檢查\n←\n\nBut we need to keep structure simpler. Avoid too many nested decisions. Maybe simpler pseudo:\n\nUse while loop and inside handle skipping.\n\nWe'll produce:\n\nStart\n→ Step 1: left = 0, right = s.length - 1\n→ Decision: left < right? \n    Yes →\n        → Decision: s[left] not alnum? \n            Yes → left++ ; continue\n            No  →\n                → Decision: s[right] not alnum? \n                    Yes → right-- ; continue\n                    No  →\n                        → Step 2: lcLeft = toLower(s[left])\n                        → Step 3: lcRight = toLower(s[right])\n                        → Decision: lcLeft != lcRight? \n                            Yes → Return False\n                            No  → left++ ; right-- ; continue\n    No  → Return True\nEnd\n\nBut need to reflect arrow usage.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Step 1: 設定 left = 0, right = s.length - 1 // 初始化兩端指標\n→ Decision: left < right? // 判斷是否還有字符需要比較\n    Yes →\n        → Decision: s[left] 非字母或數字? // 檢查左邊字符是否有效\n            Yes →\n                → Step 2: left = left + 1 // 跳過左邊非字母數字\n                → Decision: left >= right? // 檢查是否已經無法比較\n                    Yes → Step 3: Return True // 兩側指標交叉，為回文\n                    No  → (loop back to outer Decision)\n            No  →\n                → Decision: s[right] 非字母或數字? // 檢查右邊字符是否有效\n                    Yes →\n                        → Step 4: right = right - 1 // 跳過右邊非字母數字\n                        → Decision: left >= right? // 檢查是否已經無法比較\n                            Yes → Step 5: Return True // 兩側指標交叉，為回文\n                            No  → (loop back to outer Decision)\n                    No  →\n                        → Step 6: lcLeft = toLowerCase(s[left]) // 轉小寫\n                        → Step 7: lcRight = toLowerCase(s[right]) // 轉小寫\n                        → Decision: lcLeft != lcRight? // 比較兩字符\n                            Yes → Step 8: Return False // 不相等即非回文\n                            No  →\n                                → Step 9: left = left + 1 // 移動左指標\n                                → Step 10: right = right - 1 // 移動右指標\n                                → (loop back to outer Decision)\n←\n\nBut we need to use arrow after each step, and not duplicate \"Decision:\" inside loops? But it's okay.\n\nHowever they want \"→ Decision:\" lines with Yes → and No →.\n\nBut we also need \"Start\" and \"End\".\n\nBetter produce with loops but keep each step.\n\nMaybe use a loop arrow like \"→ While left < right:\" but the format expects \"Decision:\".\n\nLet's produce final steps:\n\nStart // 程式開始\n→ Step 1: left = 0, right = s.length - 1 // 初始化兩端指標\n→ Decision: left < right? // 判斷是否還有字符需要比較\n    Yes →\n        → Decision: s[left] 不是字母或數字? // 檢查左邊字符是否有效\n            Yes →\n                → Step 2: left = left + 1 // 跳過左邊非字母數字\n                → Decision: left >= right? // 再次檢查指標位置\n                    Yes → Step 3: Return True // 兩側已交叉，為回文\n                    No  → (loop back到外層 Decision)\n            No  →\n                → Decision: s[right] 不是字母或數字? // 檢查右邊字符是否有效\n                    Yes →\n                        → Step 4: right = right - 1 // 跳過右邊非字母數字\n                        → Decision: left >= right? // 再次檢查指標位置\n                            Yes → Step 5: Return True // 兩側已交叉，為回文\n                            No  → (loop back到外層 Decision)\n                    No  →\n                        → Step 6: lcLeft = toLowerCase(s[left]) // 轉小寫\n                        → Step 7: lcRight = toLowerCase(s[right]) // 轉小寫\n                        → Decision: lcLeft != lcRight? // 比較字符\n                            Yes → Step 8: Return False // 不相等即非回文\n                            No  →\n                                → Step 9: left = left + 1 // 移動左指標\n                                → Step 10: right = right - 1 // 移動右指標\n                                → (loop back到外層 Decision)\n    No  → Step 11: Return True // 所有字符已比較完，為回文\nEnd // 程式結束\n\nNeed to ensure each line ends with \"// 解釋/說明\".\n\nBut we used (loop back to outer Decision) etc. That may not be explicit step.\n\nWe might create \"→ Step X: 回到 Decision: left < right?\" but not necessary. Could just rely on loop by referencing the decision again.\n\nHowever the format demands \"逐行輸出\". We may need to show the loop structure properly.\n\nAlternative: Use While loop with decision and step inside. But we must keep \"Decision:\" lines.\n\nWe can produce:\n\nStart // 程式開始\n→ Step 1: left = 0, right = s.length - 1 // 初始化兩端指標\n→ Decision: left < right? // 是否還有字符需要比較\n    Yes →\n        → Decision: s[left] 不是字母或數字? // 檢查左側字符\n            Yes →\n                → Step 2: left = left + 1 // 跳過左側非字母數字\n                → Decision: left < right? // 重新判斷\n                    Yes → (回到外層 Decision)\n                    No  → Step 3: Return True // 交叉即回文\n            No  →\n                → Decision: s[right] 不是字母或數字? // 檢查右側字符\n                    Yes →\n                        → Step 4: right = right - 1 // 跳過右側非字母數字\n                        → Decision: left < right? // 重新判斷\n                            Yes → (回到外層 Decision)\n                            No  → Step 5: Return True\n                    No  →\n                        → Step 6: lcLeft = toLowerCase(s[left]) // 轉小寫\n                        → Step 7: lcRight = toLowerCase(s[right]) // 轉小寫\n                        → Decision: lcLeft != lcRight? // 比較字符\n                            Yes → Step 8: Return False // 不相等即非回文\n                            No  →\n                                → Step 9: left = left + 1 // 移動左指標\n                                → Step 10: right = right - 1 // 移動右指標\n                                → Decision: left < right? // 重新判斷\n                                    Yes → (回到外層 Decision)\n                                    No  → Step 11: Return True\n    No  → Step 12: Return True // 沒有字符可比，為回文\nEnd // 程式結束\n\nBut we added nested Decision again. But maybe it's okay.\n\nBut we might not need to add (回到外層 Decision) as a separate line; we can just mention loop but it's okay.\n\nHowever they might want the format exactly as the sample: Decision lines with Yes→ and No→ and each step with \"→ Step\". They didn't mention loops; but we can simulate loops with recursion.\n\nBut it's okay.\n\nLet's produce final virtual code. Ensure each line ends with // 解釋/說明.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: left = 0, right = s.length - 1 // 初始化兩端指標\n→ Decision: left < right? // 判斷是否還有字符需要比較\n    Yes →\n        → Decision: s[left] 不是字母或數字? // 檢查左側字符是否有效\n            Yes →\n                → Step 2: left = left + 1 // 跳過左側非字母數字\n                → Decision: left < right? // 重新判斷\n                    Yes → (回到外層 Decision) // 進入下一輪比較\n                    No  → Step 3: Return True // 交叉即為回文\n            No  →\n                → Decision: s[right] 不是字母或數字? // 檢查右側字符是否有效\n                    Yes →\n                        → Step 4: right = right - 1 // 跳過右側非字母數字\n                        → Decision: left < right? // 重新判斷\n                            Yes → (回到外層 Decision) // 進入下一輪比較\n                            No  → Step 5: Return True // 交叉即為回文\n                    No  →\n                        → Step 6: lcLeft = toLowerCase(s[left]) // 轉左側字符為小寫\n                        → Step 7: lcRight = toLowerCase(s[right]) // 轉右側字符為小寫\n                        → Decision: lcLeft != lcRight? // 比較兩個字符\n                            Yes → Step 8: Return False // 不相等即非回文\n                            No  →\n                                → Step 9: left = left + 1 // 移動左指標\n                                → Step 10: right = right - 1 // 移動右指標\n                                → Decision: left < right? // 重新判斷\n                                    Yes → (回到外層 Decision) // 進入下一輪比較\n                                    No  → Step 11: Return True // 所有字符已比較完，為回文\n    No  → Step 12: Return True // 沒有字符可比，為回文\nEnd // 程式結束",
      "generated_code": "import sys\n\nclass Solution:\n    def isPalindrome(self, s: str) -> bool:\n        filtered = [c.lower() for c in s if c.isalnum()]\n        return filtered == filtered[::-1]\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    data = data.strip()\n    # Try to extract string value after '=' if present\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n        # Remove surrounding quotes if present\n        if (value.startswith('\"') and value.endswith('\"')) or (value.startswith(\"'\") and value.endswith(\"'\")):\n            value = value[1:-1]\n        s = value\n    else:\n        # Assume whole input is the string (strip possible quotes)\n        s = data\n        if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n            s = s[1:-1]\n    sol = Solution()\n    result = sol.isPalindrome(s)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \" \"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode169.json",
    "problem_index_in_file": 0,
    "title": "Majority Element",
    "description_snippet": "Given an array nums of size n, return the majority element.\n\nThe majority element is the element tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solving majority element problem. Provide line by line with explanation. Must follow format: line: virtual code step + space + // explanation. Use Start, Decision, Yes →, No → etc. Avoid actual code. Use algorithm: Boyer-Moore majority vote or count. Provide step-by-step.\n\nWe must ensure each line uses \"→\" arrow for steps. Provide decision structures.\n\nLet's design:\n\nStart // start\n→ Step 1: Initialize candidate = None, count = 0 // set up variables\n→ Step 2: For each num in nums // iterate over array\n    → Decision: If count == 0? // check if need to change candidate\n        Yes → Step 3: Set candidate = num // select new candidate\n        No  → Decision: If num == candidate? // compare to current candidate\n            Yes → Step 4: Increment count // increment count\n            No  → Step 5: Decrement count // decrement count\n→ Step 6: Return candidate // after loop, candidate is majority\n\nAlso can add final check but assumption holds. Provide End. Need to format each line with \"→\". For decision, indent accordingly.\n\nWe'll produce lines:\n\nStart // 程式開始執行\n→ Step 1: Initialize candidate = None, count = 0 // 變數初始化\n→ Step 2: For each num in nums // 逐個遍歷陣列\n    → Decision: 如果 count == 0? // 檢查是否需要改變候選\n        Yes → Step 3: 設定 candidate = num // 選擇新的候選\n        No  → Decision: 如果 num == candidate? // 與目前候選比對\n            Yes → Step 4: 增加 count // 同值則計數+1\n            No  → Step 5: 減少 count // 不同值則計數-1\n→ Step 6: 回傳 candidate // 循環結束後候選即為多數元素\nEnd // 程式結束\n\nBut ensure each line exactly as format: \"虛擬碼步驟\" + space + \"// 解釋\". For indented lines, still follow same format. Use \"Decision:\" lines with indent. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize candidate = None, count = 0 // 初始化候選值與計數器  \n→ Step 2: For each num in nums // 逐個遍歷陣列中的每個數字  \n    → Decision: 如果 count == 0? // 判斷是否需要換候選值  \n        Yes → Step 3: Set candidate = num // 選擇目前數字作為新候選  \n        No  → Decision: 如果 num == candidate? // 與現有候選值比對  \n            Yes → Step 4: Increment count // 同值則計數器加一  \n            No  → Step 5: Decrement count // 不同值則計數器減一  \n→ Step 6: Return candidate // 迴圈結束後候選即為多數元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef parse_nums(data: str):\n    \"\"\"\n    從輸入字串中抽取數字列表。\n    支援形如 \"nums = [3,2,3]\" 或直接 \"[3,2,3]\" 的格式。\n    \"\"\"\n    data = data.strip()\n    # 找到第一個 '['，取其後的子字串\n    start = data.find('[')\n    if start == -1:\n        return []\n    sub = data[start:]\n    try:\n        # 先嘗試安全解析\n        return ast.literal_eval(sub)\n    except Exception:\n        # 若安全解析失敗，退回到 eval\n        return eval(sub)\n\nclass Solution:\n    def majorityElement(self, nums):\n        \"\"\"\n        Boyer–Moore majority vote algorithm.\n        只需 O(n) 時間和 O(1) 內存。\n        \"\"\"\n        count = 0\n        candidate = None\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    data = sys.stdin.read()\n    nums = parse_nums(data)\n\n    # 計算並輸出多數元素\n    solution = Solution()\n    result = solution.majorityElement(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,1,1,1,2,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode468.json",
    "problem_index_in_file": 0,
    "title": "Validate IP Address",
    "description_snippet": "Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 ad...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output line-by-line pseudocode with explanations. Follow format. Use virtual code lines with arrow and explanation. Provide steps: start, input queryIP, split by '.' and ':' etc. Validate IPv4: count segments, each 1-3 digits, no leading zero unless single '0', numeric <=255. IPv6: split by ':', count 8 segments, each 1-4 hex digits. Check each char valid hex. No empty segment unless allowed? In IPv6 leading zeros allowed. No double colon allowed. So we should check split by ':' count 8; each segment length 1-4; all chars hex. Return accordingly.\n\nWe will produce lines. Use arrows.\n\nLet's produce:\n\nStart // Start program\n\n→ Step 1: Set ip ← queryIP // 把輸入存入變數\n\n→ Step 2: If ip contains '.'? // 檢查是否可能是 IPv4\n\n    Yes →\n\n        → Step 3: Split parts ← split ip by '.' // 取得四段\n\n        → Decision: 是否為四段且都非空? // 檢查段數\n\n            Yes →\n\n                → Step 4: For each part in parts:\n\n                    → Decision: part 是否符合 1~3 位數字，且無前導零（除非 '0'）？\n\n                        Yes → Continue\n\n                        No  → Return \"Neither\" // 不是 IPv4\n\n                → Decision: 每個 part 數值 ≤255？\n\n                    Yes → Return \"IPv4\" // 合法 IPv4\n\n                    No  → Return \"Neither\"\n\n            No  → // 不是四段\n\n                → Decision: ip contains ':'? // 可能是 IPv6\n\n                    Yes → goto IPv6 path\n\n                    No  → Return \"Neither\"\n\n    No → // 不含 '.'\n\n        → Decision: ip contains ':'? // 可能是 IPv6\n\n            Yes →\n\n                → Step 5: Split parts ← split ip by ':' // 取得八段\n\n                → Decision: 是否為八段且不含空段? // 檢查段數\n\n                    Yes →\n\n                        → Step 6: For each part in parts:\n\n                            → Decision: part長度 1~4 且全為十六進位字元？\n\n                                Yes → Continue\n\n                                No  → Return \"Neither\" // 不是 IPv6\n\n                        → Return \"IPv6\" // 合法 IPv6\n\n                    No  → Return \"Neither\"\n\n            No  → Return \"Neither\"\n\nEnd // 程式結束\n\nNeed to adhere to format: Each line with virtual code and // explanation.\n\nNeed to handle arrows for decisions. Use 'Decision:' line with indent? The example shows indent with 4 spaces. We'll keep indent but maintain same style.\n\nAlso use Yes →, No →.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ip ← queryIP // 將輸入字串存入變數  \n→ Decision: 是否包含 '.'? // 判斷是否可能為 IPv4  \n  Yes →  \n   → Step 2: parts ← split ip by '.' // 以 . 分割取得各段  \n   → Decision: parts 長度是否為 4? // 檢查是否恰好四段  \n    Yes →  \n     → Step 3: for each part in parts do  \n       Decision: part 只含 1~3 個數字且不含前導零 (除非 part = '0')?  \n        Yes → continue  \n        No  → Return \"Neither\" // 非 IPv4  \n     → Decision: 每個 part 的數值 ≤ 255?  \n      Yes → Return \"IPv4\" // 合法 IPv4  \n      No  → Return \"Neither\" // 數值超過範圍  \n    No →  \n     → Decision: ip 是否包含 ':'? // 可能是 IPv6  \n      Yes → Goto IPv6_Path  \n      No  → Return \"Neither\" // 同時不是 IPv4 也不是 IPv6  \n  No →  \n   → Decision: ip 是否包含 ':'? // 判斷是否為 IPv6  \n    Yes →  \n     → IPv6_Path:  \n      → Step 4: parts ← split ip by ':' // 以 : 分割取得各段  \n      → Decision: parts 長度是否為 8? // 檢查是否恰好八段  \n       Yes →  \n        → Step 5: for each part in parts do  \n          Decision: part 長度 1~4 且全部為 0-9, a-f, A-F?  \n           Yes → continue  \n           No  → Return \"Neither\" // 非 IPv6  \n        → Return \"IPv6\" // 合法 IPv6  \n       No  → Return \"Neither\" // 段數不對  \n        // 沒有更多分支，結束判斷  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n        End  \n       End  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def validIPAddress(self, queryIP: str) -> str:\n        # Helper to validate IPv4\n        def isIPv4(s: str) -> bool:\n            parts = s.split('.')\n            if len(parts) != 4:\n                return False\n            for part in parts:\n                if not part.isdigit():          # must be digits only\n                    return False\n                if part[0] == '0' and len(part) != 1:  # leading zero not allowed\n                    return False\n                num = int(part)\n                if not 0 <= num <= 255:         # range check\n                    return False\n            return True\n\n        # Helper to validate IPv6\n        def isIPv6(s: str) -> bool:\n            parts = s.split(':')\n            if len(parts) != 8:\n                return False\n            hexdigits = '0123456789abcdefABCDEF'\n            for part in parts:\n                if not (1 <= len(part) <= 4):   # length check\n                    return False\n                for c in part:\n                    if c not in hexdigits:     # must be hex digit\n                        return False\n            return True\n\n        # Decision logic based on character counts\n        if queryIP.count('.') == 3 and isIPv4(queryIP):\n            return \"IPv4\"\n        elif queryIP.count(':') == 7 and isIPv6(queryIP):\n            return \"IPv6\"\n        else:\n            return \"Neither\"\n\nif __name__ == \"__main__\":\n    # Read entire input; it may contain the assignment string\n    data = sys.stdin.read().strip()\n\n    # Extract the IP address surrounded by double quotes if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        ip = match.group(1)\n    else:\n        ip = data  # fallback to raw input if no quotes\n\n    sol = Solution()\n    result = sol.validIPAddress(ip)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "queryIP = \"172.16.254.1\"",
          "expected_output": "IPv4",
          "success": true,
          "output": "IPv4"
        },
        {
          "example_index": 1,
          "input": "queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"",
          "expected_output": "IPv6",
          "success": true,
          "output": "IPv6"
        },
        {
          "example_index": 2,
          "input": "queryIP = \"256.256.256.256\"",
          "expected_output": "Neither",
          "success": true,
          "output": "Neither"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode433.json",
    "problem_index_in_file": 0,
    "title": "Minimum Genetic Mutation",
    "description_snippet": "A gene string can be represented by an 8-character long string, with choices from 'A', 'C', 'G', and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines for solving this problem: minimal mutation steps via BFS. Steps: start BFS, queue, visited, level. If endGene not in bank return -1. For each gene, generate mutations by changing each position to other nucleotides, check in bank and not visited, push queue, etc. BFS until find endGene.\n\nNeed to output as per format: each line with virtual code and comment after a space //.\n\nUse arrows for decision: \"Decision:\".\n\nWe must write the code step by step.\n\nWe need to incorporate Start, End markers.\n\nLet's produce pseudocode.\n\nOutline:\n\nStart\n→ Step 1: Initialize queue with (startGene, 0)\n→ Step 2: Initialize visited set with startGene\n→ Decision: If endGene not in bank? // check existence\n    Yes → Step 3: Return -1 // no possible mutation\n    No  → Continue\n→ Decision: While queue not empty? // BFS loop\n    Yes → Step 4: Dequeue current gene, steps\n    → Decision: If current gene equals endGene? // check goal\n        Yes → Step 5: Return steps // found minimal\n        No  → Step 6: For each position i from 0 to 7\n            → For each nucleotide in ['A','C','G','T'] \n                → Decision: If nucleotide != current[i]?\n                    Yes → Step 7: Create mutated gene\n                    → Decision: If mutated gene in bank AND not visited?\n                        Yes → Step 8: Add mutated to queue with steps+1\n                        → Step 9: Add mutated to visited\n                No → skip\n    No → Step 10: Return -1 // queue exhausted, no path\nEnd\n\nBut we need to make each line as a virtual code line. So each step line with comment.\n\nWe need to use arrow \"→\" after Start and each step. For decisions, use \"Decision:\" with Yes → etc.\n\nLet's write.\n\nUse parentheses maybe. We'll keep simple.\n\nLet's produce lines:\n\nStart // 程式開始執行\n\n→ Step 1: Define queue = [(startGene, 0)] // 初始化隊列，元素為 (基因, 步數)\n\n→ Step 2: Define visited = {startGene} // 記錄已訪問的基因\n\n→ Decision: endGene ∉ bank? // 檢查終點基因是否存在於基因庫\n    Yes → Step 3: Return -1 // 若不在庫，直接返回 -1\n\n→ Decision: queue not empty? // 開始 BFS 循環\n    Yes → Step 4: current, steps ← queue.pop(0) // 取出隊首基因與已走步數\n    → Decision: current == endGene? // 是否已達目標\n        Yes → Step 5: Return steps // 找到最短路徑，返回步數\n        No  → Step 6: For i in 0..7 // 遍歷每個位置\n            → For nuc in ['A','C','G','T'] // 嘗試四種核苷酸\n                → Decision: nuc != current[i]? // 若不同才變異\n                    Yes → Step 7: mutated ← current[:i] + nuc + current[i+1:] // 生成變異基因\n                    → Decision: mutated ∈ bank AND mutated ∉ visited? // 是否合法且未訪問\n                        Yes → Step 8: queue.append((mutated, steps+1)) // 加入隊列\n                        → Step 9: visited.add(mutated) // 標記已訪問\n                No → // 不變更\n    No → Step 10: Return -1 // BFS 結束，未找到路徑\n\nEnd // 程式結束\n\nWe need to ensure each line is a single step with comment. But we have some nested loops, decisions. Should we break each decision into separate lines? The requirement: each line must contain \"虛擬碼步驟\" + \" \" + \"// 解釋/說明\". We can represent loops and decisions each line. However loops may need multiple lines. But we can inline them with indentation, but still each line is a step. We must maintain arrow representation.\n\nBetter to use indentation with arrow and spaces to show structure.\n\nBut we must keep each line as a step; for loops we may produce multiple lines: e.g., \"→ Step 6: For i in 0..7\" is a step; inside that we need another step for inner loop: \"→ Step 6.1: For nuc in ['A','C','G','T']\". But maybe better to keep simple: \"→ Step 6: For i in 0..7\" and inside we handle nested. But we need to use arrow \"→\" for each step. So each step can be nested with indentation.\n\nLet's produce as:\n\nStart\n\n→ Step 1: Define queue = [(startGene, 0)] // 初始化\n\n→ Step 2: Define visited = {startGene} // 記錄已訪問\n\n→ Decision: endGene ∉ bank? // 檢查終點是否在庫\n    Yes → Step 3: Return -1 // 無效\n\n→ Decision: queue not empty? // BFS 主循環\n    Yes →\n        → Step 4: current, steps ← queue.pop(0) // 取首\n        → Decision: current == endGene? // 是否到達\n            Yes → Step 5: Return steps // 找到\n            No →\n                → Step 6: For i in 0..7 // 遍歷位置\n                    → Step 7: For nuc in ['A','C','G','T'] // 四種\n                        → Decision: nuc != current[i]? // 變更\n                            Yes →\n                                → Step 8: mutated ← current[:i] + nuc + current[i+1:] // 產生\n                                → Decision: mutated ∈ bank AND mutated ∉ visited? // 合法且未訪問\n                                    Yes →\n                                        → Step 9: queue.append((mutated, steps+1)) // 加入\n                                        → Step 10: visited.add(mutated) // 標記\n                                    No → // skip\n                            No → // skip\n        // loop continues\n    No → Step 11: Return -1 // 無路徑\n\nEnd\n\nMake sure each line is a separate step with comment. Some lines like \"→ Decision:\" with nested lines, but each line is a step.\n\nNeed to keep arrow for each step. The lines with \"→\" preceded by some indentation maybe.\n\nLet's format as:\n\nStart // 程式開始執行\n→ Step 1: queue = [(startGene, 0)] // 初始化隊列\n→ Step 2: visited = {startGene} // 記錄已訪問\n→ Decision: endGene ∉ bank? // 檢查終點是否存在於基因庫\n    Yes → Step 3: Return -1 // 若不存在則直接返回 -1\n→ Decision: queue not empty? // 開始 BFS\n    Yes →\n        → Step 4: current, steps ← queue.pop(0) // 取出隊首\n        → Decision: current == endGene? // 檢查是否已達目標\n            Yes → Step 5: Return steps // 返回最短步數\n            No →\n                → Step 6: For i in 0..7 // 遍歷每個位置\n                    → Step 7: For nuc in ['A','C','G','T'] // 四種核苷酸\n                        → Decision: nuc != current[i]? // 只在不同時才變異\n                            Yes →\n                                → Step 8: mutated ← current[:i] + nuc + current[i+1:] // 產生變異\n                                → Decision: mutated ∈ bank AND mutated ∉ visited? // 合法且未訪問\n                                    Yes →\n                                        → Step 9: queue.append((mutated, steps+1)) // 加入隊列\n                                        → Step 10: visited.add(mutated) // 標記已訪問\n                                    No → // 跳過\n                            No → // 跳過\n        // 迴圈繼續\n    No → Step 11: Return -1 // 若隊列空，表示無路徑\nEnd // 程式結束\n\nBut the requirement: Each line must contain \"虛擬碼步驟\" + space + comment. For decisions we need to include \"Decision:\" and lines under Yes/No. Each decision line and each nested line must be separate lines. So we need to ensure each line is a step.\n\nLet's produce final output accordingly. Ensure lines that are nested still separate. For example:\n\n→ Decision: endGene ∉ bank? // ...\n\n    Yes → Step 3: Return -1 // ...\n\nWe might indent lines after \"Yes →\" but still each line is separate.\n\nThus final answer: provide lines exactly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: queue = [(startGene, 0)] // 初始化隊列，元素為 (基因, 步數)\n→ Step 2: visited = {startGene} // 記錄已訪問的基因\n→ Decision: endGene ∉ bank? // 檢查終點基因是否存在於基因庫\n    Yes → Step 3: Return -1 // 若終點不在庫，直接返回 -1\n→ Decision: queue not empty? // 開始 BFS 主循環\n    Yes →\n        → Step 4: current, steps ← queue.pop(0) // 取出隊首基因與已走步數\n        → Decision: current == endGene? // 是否已達目標\n            Yes → Step 5: Return steps // 找到最短路徑，返回步數\n            No →\n                → Step 6: For i in 0..7 // 遍歷每個位置\n                    → Step 7: For nuc in ['A','C','G','T'] // 嘗試四種核苷酸\n                        → Decision: nuc != current[i]? // 只在不同時才變異\n                            Yes →\n                                → Step 8: mutated ← current[:i] + nuc + current[i+1:] // 產生變異基因\n                                → Decision: mutated ∈ bank AND mutated ∉ visited? // 合法且未訪問\n                                    Yes →\n                                        → Step 9: queue.append((mutated, steps+1)) // 加入隊列\n                                        → Step 10: visited.add(mutated) // 標記已訪問\n                                    No → // 跳過\n                            No → // 跳過\n        // 迴圈繼續\n    No → Step 11: Return -1 // 若隊列空，表示無路徑\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def minMutation(self, start, end, bank):\n        if end not in bank:\n            return -1\n\n        bank_set = set(bank)\n        genes = ['A', 'C', 'G', 'T']\n        queue = deque([(start, 0)])\n        visited = set([start])\n\n        while queue:\n            current, steps = queue.popleft()\n            if current == end:\n                return steps\n            for i in range(len(current)):\n                for g in genes:\n                    mutation = current[:i] + g + current[i + 1:]\n                    if mutation in bank_set and mutation not in visited:\n                        visited.add(mutation)\n                        queue.append((mutation, steps + 1))\n        return -1\n\ndef parse_input(input_str):\n    start_match = re.search(r'startGene\\s*=\\s*\"([^\"]+)\"', input_str)\n    end_match = re.search(r'endGene\\s*=\\s*\"([^\"]+)\"', input_str)\n    bank_match = re.search(r'bank\\s*=\\s*(\\[.*?\\])', input_str, re.S)\n\n    if not (start_match and end_match and bank_match):\n        return None, None, None\n\n    start = start_match.group(1)\n    end = end_match.group(1)\n    bank_str = bank_match.group(1)\n    try:\n        bank = ast.literal_eval(bank_str)\n    except Exception:\n        bank = []\n\n    return start, end, bank\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    start, end, bank = parse_input(data)\n    if start is None:\n        print(-1)\n        return\n    solution = Solution()\n    result = solution.minMutation(start, end, bank)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode168.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Title",
    "description_snippet": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the problem: given integer columnNumber, return Excel column title. Classic conversion from 1-indexed base-26 with letters A-Z but no zero. Approach: while columnNumber>0: columnNumber-1 -> remainder, char = 'A'+rem, prepend to result, columnNumber//=26. We'll produce virtual code step by step with arrows.\n\nWe should output lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 result = \"\" // 準備儲存列標題\n→ Step 2: 循環 columnNumber > 0 // 只要還有數字就繼續轉換\n    → Step 3: columnNumber ← columnNumber - 1 // 讓 1->0, 26->25, 27->26 以符合 0-25 的字母索引\n    → Step 4: remainder ← columnNumber mod 26 // 取模得到字母對應值\n    → Step 5: letter ← chr(ord('A') + remainder) // 轉換成對應字母\n    → Step 6: result ← letter + result // 把字母加到前面\n    → Step 7: columnNumber ← columnNumber // 26 // 更新 columnNumber\nEnd // 輸出結果\n\nBut we need to include explanation after each line.\n\nWe should also ensure use of Decision? Not necessary.\n\nWe can include End at bottom.\n\nAlso maybe include Step 8: 返回 result.\n\nLet's produce.\n\nAlso need to use virtual code arrow. Use \"→\" for steps. Use \"Decision:\" only if needed. Use \"Yes →\" \"No →\" for condition.\n\nWe have a while loop, we could express as Decision: columnNumber > 0? Yes → ... No → End.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: result ← \"\" // 初始化結果字符串\n→ Decision: columnNumber > 0? // 判斷是否還有需要處理的數字\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 讓 1->0, 26->25 等等，符合 0-25 的索引\n    Yes → Step 3: remainder ← columnNumber mod 26 // 取得目前最低位的字母索引\n    Yes → Step 4: letter ← chr(ord('A') + remainder) // 把索引轉成字母\n    Yes → Step 5: result ← letter + result // 把新字母放到結果最前面\n    Yes → Step 6: columnNumber ← columnNumber // 26 // 整除 26 以處理下一位\n    Yes → Decision: columnNumber > 0? // 重新檢查是否還有位數\n        Yes → (回到 Step 2) // 循環\n        No → Step 7: return result // 完成輸出\n    No → Step 7: return result // 若最初 columnNumber 為 0，直接返回空\nEnd // 程式結束\n\nNeed to ensure each line has arrow or step. But we used nested decision. We might not need the outer no block. Actually if columnNumber is 0, return empty.\n\nBut we can keep simple: Start → Step1... → Decision ... No→End.\n\nBetter to keep simple.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: result ← \"\" // 初始化儲存 Excel 標題的字串\n→ Decision: columnNumber > 0? // 檢查是否還有數字要轉換\n    Yes → Step 2: columnNumber ← columnNumber - 1 // 把 1->0, 26->25 轉換成 0-25 索引\n    Yes → Step 3: remainder ← columnNumber mod 26 // 取得最低位的字母索引\n    Yes → Step 4: letter ← chr(ord('A') + remainder) // 把索引轉成對應字母\n    Yes → Step 5: result ← letter + result // 把新字母加到結果前面\n    Yes → Step 6: columnNumber ← columnNumber // 26 // 整除 26 以處理下一位\n    Yes → Decision: columnNumber > 0? // 再次檢查是否還有位數\n        Yes → (回到 Step 2) // 繼續循環\n        No  → Step 7: return result // 所有位數已處理完畢，返回標題\n    No  → Step 7: return result // 初始 columnNumber 為 0，直接返回空字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        \"\"\"\n        Convert a positive integer to its corresponding Excel column title.\n        \"\"\"\n        res = \"\"\n        while columnNumber > 0:\n            columnNumber -= 1            # shift to 0‑based index\n            res = chr(columnNumber % 26 + ord('A')) + res\n            columnNumber //= 26\n        return res\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse the integer, compute the column title,\n    and print it surrounded by double quotes as required.\n    \"\"\"\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return  # no valid integer found\n    columnNumber = int(match.group())\n\n    solution = Solution()\n    title = solution.convertToTitle(columnNumber)\n    print(f'\"{title}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnNumber = 1",
          "expected_output": "\"A\"",
          "success": true,
          "output": "\"A\""
        },
        {
          "example_index": 1,
          "input": "columnNumber = 28",
          "expected_output": "\"AB\"",
          "success": true,
          "output": "\"AB\""
        },
        {
          "example_index": 2,
          "input": "columnNumber = 701",
          "expected_output": "\"ZY\"",
          "success": true,
          "output": "\"ZY\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode23.json",
    "problem_index_in_file": 0,
    "title": "Merge k Sorted Lists",
    "description_snippet": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerg...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code to merge k sorted linked lists into one sorted linked list. Use priority queue approach. Steps: create min-heap, insert heads, then loop until heap empty, pop smallest node, attach to result, push next of that node if exists. Provide each line with explanation. Use Start, End, Decision.\n\nLet's outline:\n\nStart // begin\n\n→ Step 1: initialize min-heap // priority queue\n\n→ Step 2: for each list in lists, if list not null, insert list head into heap // add all heads\n\n→ Step 3: create dummy head node for result // to build output\n\n→ Step 4: set current = dummy // pointer to last node\n\n→ Decision: 如果堆非空? // while heap not empty\n\n    Yes → Step 5: node = pop heap // get smallest node\n\n    → Step 6: current.next = node // append node\n\n    → Step 7: current = current.next // move pointer\n\n    → Decision: 如果 node.next 不是空? // if popped node has next\n\n        Yes → Step 8: insert node.next into heap // add next node\n\n        No → skip\n\n    → Step 9: go back to Decision: 堆非空? // loop\n\n    No → Step 10: return dummy.next // output\n\nEnd // finished\n\nBut need to be line-by-line, with proper arrows. We need to use \"Decision:\" lines with indentation? In example they indent. Use \"Decision: 如果數字大於 0?\" etc. We need to adapt to Chinese. Use arrow \"Yes →\" \"No →\" as in example.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化最小堆 // 建立優先佇列，存放節點\n→ Step 2: 對每個鏈表 head，若不為空，插入最小堆 // 把所有首節點加入堆\n→ Step 3: 建立 dummy head 節點 // 作為合併後鏈表的起點\n→ Step 4: current = dummy // current 指向最後已連接的節點\n→ Decision: 堆是否非空? // 檢查堆中是否還有節點\n    Yes → Step 5: node = pop(heap) // 取出最小節點\n    → Step 6: current.next = node // 將節點接到結果鏈表\n    → Step 7: current = current.next // 移動 current 到新節點\n    → Decision: node.next 是否存在? // 判斷被取出的節點是否有後續節點\n        Yes → Step 8: push(node.next, heap) // 把後續節點插入堆\n        No  → // 不做任何事\n    → Step 9: 回到 Decision: 堆是否非空? // 重新檢查堆\n    No  → Step 10: return dummy.next // 返回合併後的鏈表頭\nEnd // 程式執行結束\n\nBut we need each line to include the code part and // explanation. Use proper indentation for decisions. Also each line must have \"虛擬碼步驟\" + space + \"// 解釋\". So produce each line exactly. Use no actual code syntax; just descriptive virtual steps.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 初始化最小堆 // 建立優先佇列，用於保持節點的升序\n→ Step 2: 對每個鏈表的首節點，若不為空，插入最小堆 // 把所有首節點加入堆\n→ Step 3: 建立 dummy head 節點 // 用於簡化合併鏈表的尾部連接\n→ Step 4: current = dummy // current 指向合併鏈表的最後節點\n→ Decision: 堆是否非空? // 判斷是否還有節點待處理\n    Yes → Step 5: node = pop(heap) // 取出堆中最小的節點\n    → Step 6: current.next = node // 將此節點接到合併鏈表\n    → Step 7: current = current.next // 更新 current 為新尾部\n    → Decision: node.next 是否存在? // 檢查被取出的節點是否有後續節點\n        Yes → Step 8: push(node.next, heap) // 將後續節點插入堆\n        No  → // 無後續節點，跳過\n    → Step 9: 回到 Decision: 堆是否非空? // 重新檢查堆\n    No  → Step 10: return dummy.next // 返回合併後鏈表的頭節點\nEnd // 程式執行結束\n\nNeed to ensure indentation lines include arrow \"→\" before each step. For decisions: \"Decision: ...\" with indentation.\n\nAlso need to include \"Yes →\" and \"No →\" after Decision lines? In example, they indent Yes → Step 2: ... etc. We can replicate.\n\nMake sure each line ends with comment.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化最小堆 // 建立優先佇列，用於保持節點的升序  \n→ Step 2: 對每個鏈表的首節點，若不為空，插入最小堆 // 把所有首節點加入堆  \n→ Step 3: 建立 dummy head 節點 // 用於簡化合併鏈表的尾部連接  \n→ Step 4: current = dummy // current 指向合併鏈表的最後節點  \n→ Decision: 堆是否非空? // 判斷是否還有節點待處理  \n Yes → Step 5: node = pop(heap) // 取出堆中最小的節點  \n  → Step 6: current.next = node // 將此節點接到合併鏈表  \n  → Step 7: current = current.next // 更新 current 為新尾部  \n  → Decision: node.next 是否存在? // 檢查被取出的節點是否有後續節點  \n   Yes → Step 8: push(node.next, heap) // 將後續節點插入堆  \n   No  → // 無後續節點，跳過  \n  → Step 9: 回到 Decision: 堆是否非空? // 重新檢查堆  \n No  → Step 10: return dummy.next // 返回合併後鏈表的頭節點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\nimport itertools\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        \"\"\"\n        Merge k sorted linked lists using a min-heap.\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n\n        heap = []\n        counter = itertools.count()\n        # Initialize heap with the head of each list\n        for node in lists:\n            if node:\n                heapq.heappush(heap, (node.val, next(counter), node))\n\n        dummy = ListNode(0)\n        tail = dummy\n\n        # Extract nodes in ascending order and rebuild the merged list\n        while heap:\n            val, _, node = heapq.heappop(heap)\n            tail.next = node\n            tail = node\n            if node.next:\n                heapq.heappush(heap, (node.next.val, next(counter), node.next))\n\n        return dummy.next\n\ndef build_linked_list(nums):\n    \"\"\"Convert a Python list of numbers to a linked list.\"\"\"\n    if not nums:\n        return None\n    head = ListNode(nums[0])\n    current = head\n    for num in nums[1:]:\n        current.next = ListNode(num)\n        current = current.next\n    return head\n\ndef linked_list_to_list(node):\n    \"\"\"Convert a linked list back to a Python list of numbers.\"\"\"\n    result = []\n    while node:\n        result.append(node.val)\n        node = node.next\n    return result\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print([])\n        sys.exit()\n\n    # Remove possible leading variable assignment (e.g., \"lists =\")\n    if '=' in raw_input:\n        _, raw_input = raw_input.split('=', 1)\n    raw_input = raw_input.strip()\n\n    # Safely parse the list of lists\n    try:\n        lists_data = ast.literal_eval(raw_input)\n    except Exception:\n        print([])\n        sys.exit()\n\n    # Build linked lists from the parsed data\n    linked_lists = [build_linked_list(sublist) for sublist in lists_data]\n\n    # Merge the k lists\n    sol = Solution()\n    merged_head = sol.mergeKLists(linked_lists)\n\n    # Convert the merged linked list back to a Python list and print\n    output_list = linked_list_to_list(merged_head)\n    print(output_list)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
          "expected_output": "[1,1,2,3,4,4,5,6]",
          "success": true,
          "output": "[1, 1, 2, 3, 4, 4, 5, 6]"
        },
        {
          "example_index": 1,
          "input": "lists = []",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "lists = [[]]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode295.json",
    "problem_index_in_file": 0,
    "title": "Find Median from Data Stream",
    "description_snippet": "The median is the middle value in an ordered integer list. If the size of the list is even, there is...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for implementing a MedianFinder class with addNum and findMedian. Use virtual code with arrows, decisions, etc. Provide each line with // explanation.\n\nWe need to include Start, End, etc. So we need to show algorithm: use two heaps: max-heap for lower half, min-heap for upper half. For addNum: insert into appropriate heap, rebalance if sizes differ >1. For findMedian: if sizes equal, median = (top max + top min)/2 else median = top of larger heap.\n\nWe should also show initialization: create two heaps.\n\nWe need to produce step-by-step pseudocode lines: e.g., Start, Step: Initialize heaps, etc. Use Decision: etc.\n\nWe need to adhere to format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Also use arrows (→). For decisions, indent under.\n\nWe also need to include maybe class definition, methods. We might treat \"Start\" as entry point to constructor, method calls? Possibly produce pseudo for entire class, but each step of methods. The requirement: \"逐行生成对应的虚拟码\" for the requirement. We can structure like:\n\nStart // 程式開始執行\n→ Step 1: 定義 MedianFinder 類別 // 需要的類別\n→ Step 2: 定義 maxHeap, minHeap // 兩個堆\n→ Step 3: MedianFinder() // 建構子\n    → Step 3.1: 初始化 maxHeap // 空堆\n    → Step 3.2: 初始化 minHeap // 空堆\n→ Step 4: addNum(num) // 新增數字\n    → Decision: maxHeap 为空 或 num ≤ maxHeap.top? // 判斷放入哪個堆\n        Yes → Step 4.1: 插入 maxHeap\n        No  → Step 4.2: 插入 minHeap\n    → Decision: maxHeap.size() > minHeap.size()+1? // 調整\n        Yes → Step 4.3: 移除 maxHeap.top() 移至 minHeap\n    → Decision: minHeap.size() > maxHeap.size()+1? \n        Yes → Step 4.4: 移除 minHeap.top() 移至 maxHeap\n→ Step 5: findMedian() // 找到中位數\n    → Decision: maxHeap.size() == minHeap.size()? // 平衡\n        Yes → Step 5.1: median = (maxHeap.top()+minHeap.top())/2\n        No  → Decision: maxHeap.size() > minHeap.size()? \n            Yes → Step 5.2: median = maxHeap.top()\n            No  → Step 5.3: median = minHeap.top()\n    → Step 5.4: return median\nEnd // 程式結束\n\nNeed to ensure each line has \"虛擬碼步驟\" and comment.\n\nAdd indentation maybe? Use nested lines with indentation? Provide arrow.\n\nWe'll produce with arrows.\n\nLet's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 MedianFinder 類別 // 宣告類別以儲存資料結構  \n→ Step 2: 定義 maxHeap, minHeap // 兩個堆，maxHeap 儲存較小的一半，minHeap 儲存較大的一半  \n\n→ Step 3: MedianFinder() // 建構子  \n → Step 3.1: 初始化 maxHeap // 產生空的最大堆  \n → Step 3.2: 初始化 minHeap // 產生空的最小堆  \n\n→ Step 4: addNum(num) // 新增數字到資料結構  \n → Decision: maxHeap 為空 或 num ≤ maxHeap.top()？ // 判斷應插入哪個堆  \n  Yes → Step 4.1: maxHeap.insert(num) // 插入最大堆  \n  No  → Step 4.2: minHeap.insert(num) // 插入最小堆  \n → Decision: maxHeap.size() > minHeap.size() + 1？ // 調整大小差距  \n  Yes → Step 4.3: minHeap.insert(maxHeap.extractTop()) // 從 maxHeap 取最大並移到 minHeap  \n → Decision: minHeap.size() > maxHeap.size() + 1？  \n  Yes → Step 4.4: maxHeap.insert(minHeap.extractTop()) // 從 minHeap 取最小並移到 maxHeap  \n\n→ Step 5: findMedian() // 回傳目前所有數字的中位數  \n → Decision: maxHeap.size() == minHeap.size()？ // 堆大小相等  \n  Yes → Step 5.1: median ← (maxHeap.top() + minHeap.top()) / 2.0 // 平均兩個中間值  \n  No  → Decision: maxHeap.size() > minHeap.size()？  \n   Yes → Step 5.2: median ← maxHeap.top() // maxHeap 較大，取其頂部  \n   No  → Step 5.3: median ← minHeap.top() // minHeap 較大，取其頂部  \n → Step 5.4: return median // 傳回計算結果  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass MedianFinder:\n    def __init__(self):\n        # 小堆存儲較小的一半，使用負數做為最大堆\n        self.small = []\n        # 大堆存儲較大的一半\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 把新數字先放入小堆\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆之間數值有重疊，交換頂部元素\n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 調整兩堆大小差不多，最多相差 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return float(-self.small[0])\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入解析為兩個列表\n    # 例如: '[\"MedianFinder\", \"addNum\"], [[], [1]]' -> [['MedianFinder', 'addNum'], [[], [1]]]\n    ops_and_args = ast.literal_eval('[' + data + ']')\n    ops, args_list = ops_and_args[0], ops_and_args[1]\n\n    result = []\n    obj = None\n\n    for op, args in zip(ops, args_list):\n        if op == 'MedianFinder':\n            obj = MedianFinder()\n            result.append('null')\n        elif op == 'addNum':\n            # args 為 [num]\n            obj.addNum(args[0])\n            result.append('null')\n        elif op == 'findMedian':\n            median = obj.findMedian()\n            result.append(median)\n\n    # 將結果輸出成類似 JSON 的格式\n    out = '['\n    for i, val in enumerate(result):\n        if val == 'null':\n            out += 'null'\n        else:\n            out += str(val)\n        if i != len(result) - 1:\n            out += ', '\n    out += ']'\n    print(out)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "success": true,
          "output": "[null, null, null, 1.5, null, 2.0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode352.json",
    "problem_index_in_file": 0,
    "title": "Data Stream as Disjoint Intervals",
    "description_snippet": "Given a data stream input of non-negative integers a_1, a_2, ..., a_n, summarize the numbers seen so...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for SummaryRanges class. Provide steps: initialization, addNum, getIntervals. Use pseudo steps. Must be line by line, with arrow. Provide explanation after each line.\n\nWe should include decision steps. Implementation typical: maintain sorted list of intervals. For addNum: find position to insert, merge with neighbors if overlapping or adjacent. For getIntervals: return list.\n\nLet's craft. Use Start/End. Probably each method is separate block. For simplicity, treat the overall flow as: Start; Define class; inside define methods; End. But we need step-by-step.\n\nMaybe structure:\n\nStart // 程式開始\n→ Class SummaryRanges // 定義類別\n    → Field: intervals // 介面：儲存已合併區間列表\n    → Constructor SummaryRanges() // 初始化空列表\n        → intervals ← [] // 無任何區間\n    → Method addNum(value) // 新增整數\n        → Variable: newStart ← value\n        → Variable: newEnd ← value\n        → Variable: i ← 0 // 設定迴圈索引\n        → Decision: i < intervals.length? // 遍歷區間\n            → Yes → Decision: value < intervals[i].start? // 值在目前區間左側\n                → Yes → Decision: i > 0 AND value == intervals[i-1].end + 1? // 連接前一區間\n                    → Yes → intervals[i-1].end ← value // 合併到前一區間\n                    → No  → Insert [value, value] before i // 插入新區間\n                → No → Decision: value <= intervals[i].end? // 值在區間內\n                    → Yes → // 已存在，直接返回\n                    → No  → Decision: value == intervals[i].end + 1? // 連接到此區間\n                        → Yes → intervals[i].end ← value // 擴充終點\n                        → No  → Decision: i < intervals.length-1 AND value == intervals[i+1].start - 1? // 連接後一區間\n                            → Yes → intervals[i].end ← intervals[i+1].end // 合併兩區間\n                            → No  → Insert [value, value] after i // 插入新區間\n            → No → // 已遍歷完，插入新區間\n                → Append [value, value] at end\n        → End Method\n    → Method getIntervals() // 回傳區間\n        → Return intervals // 已排序且不重疊\n→ End Class\nEnd // 程式結束\n\nBut we need arrow lines. Use arrow → at each step. Decision lines with Yes→ and No→.\n\nAlso we need comments after //.\n\nWe need to be concise but explain.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class SummaryRanges // 定義 SummaryRanges 類別  \n → Field intervals ← [] // 存放已合併、排序好的區間列表  \n → Constructor SummaryRanges() // 初始化空的區間列表  \n  → intervals ← [] // 無任何已加入的數值  \n → Method addNum(value) // 新增整數到資料流  \n  → Variable i ← 0 // 設定索引以遍歷區間  \n  → Decision: i < intervals.length? // 是否還有區間可檢查？  \n   Yes → Decision: value < intervals[i].start? // 整數在當前區間左側？  \n    Yes → Decision: i > 0 AND value == intervals[i-1].end + 1? // 與前一區間相鄰？  \n     Yes → intervals[i-1].end ← value // 與前一區間合併（擴張終點）  \n     No  → Insert [value, value] before i // 新區間插入在前一區間之前  \n    No  → Decision: value <= intervals[i].end? // 整數已在區間內？  \n     Yes → // 整數已存在，無需處理  \n     No  → Decision: value == intervals[i].end + 1? // 與當前區間相鄰？  \n      Yes → intervals[i].end ← value // 擴張當前區間終點  \n      No  → Decision: i < intervals.length-1 AND value == intervals[i+1].start - 1? // 與後一區間相鄰？  \n       Yes → intervals[i].end ← intervals[i+1].end // 合併前後兩區間  \n       No  → Insert [value, value] after i // 新區間插入在當前區間之後  \n   No → // 所有已檢查區間皆不符合，直接將新區間追加到最後  \n    → Append [value, value] at end  \n → Method getIntervals() // 取得目前所有區間的摘要  \n  → Return intervals // 已經排好序且互不重疊  \n→ End Class // SummaryRanges 類別結束  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport json\n\nclass SummaryRanges:\n    \"\"\"\n    透過保留一個已合併且有序的區間列表來管理資料流。\n    \"\"\"\n    def __init__(self):\n        # intervals: List[List[int]]，每個元素代表 [start, end]，且 intervals 按 start 升序排列且不重疊\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        \"\"\"\n        新增一個整數到資料流，並將其與現有區間合併或插入。\n        \"\"\"\n        new_start, new_end = val, val   # 新的區間初始為單個值\n        res = []        # 用於儲存合併後的區間\n        placed = False  # 標記是否已將新區間放入 res\n\n        for start, end in self.intervals:\n            if end + 1 < val:            # 新值在目前區間左側且不相鄰\n                res.append([start, end])\n            elif val + 1 < start:        # 新值在目前區間右側且不相鄰\n                if not placed:\n                    res.append([new_start, new_end])  # 插入新區間\n                    placed = True\n                res.append([start, end])\n            else:                        # 新值與此區間相交或相鄰，合併\n                new_start = min(start, new_start)\n                new_end = max(end, new_end)\n\n        if not placed:                   # 若遍歷完後仍未插入，將新區間放最後\n            res.append([new_start, new_end])\n\n        self.intervals = res\n\n    def getIntervals(self):\n        \"\"\"回傳目前所有已合併、排序好的區間。\"\"\"\n        return self.intervals\n\n\ndef main():\n    # 讀取整個輸入，並以換行切割\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n\n    # 第一行是指令列，第二行是對應參數\n    commands = eval(data[0])\n    arguments = eval(data[1])\n\n    obj = None\n    results = []\n\n    for cmd, arg in zip(commands, arguments):\n        if cmd == 'SummaryRanges':\n            obj = SummaryRanges()\n            results.append(None)\n        elif cmd == 'addNum':\n            obj.addNum(arg[0])   # arg 是單元素列表，例如 [1]\n            results.append(None)\n        elif cmd == 'getIntervals':\n            results.append(obj.getIntervals())\n        else:\n            # 若出現未知指令，視為 None\n            results.append(None)\n\n    # 使用 json.dumps 直接輸出符合 LeetCode 的 null 表示\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "success": true,
          "output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode47.json",
    "problem_index_in_file": 0,
    "title": "Permutations II",
    "description_snippet": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo-code) for generating all unique permutations of a list that may have duplicates. Must output line by line, each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision etc. Also use arrows.\n\nWe need to produce a typical algorithm: backtracking with visited set or using counts.\n\nWe need to output \"Start\", then \"→ Step 1: Input nums\" etc. Provide explanation comments.\n\nWe need to produce a sequence that is clear. Should include decisions for duplicates, using a map of counts or sorting and skipping same value if used.\n\nWe need to produce the steps: Input, sort, call backtrack, in backtrack choose element not used, add to path, mark used, backtrack. Also check duplicates: skip same value if not used or if used but same value already considered? Approach: use a boolean used array, sort nums, in backtrack loop over indices, skip if used[i] or (i>0 and nums[i]==nums[i-1] and not used[i-1]).\n\nWe should produce lines like:\n\nStart\n→ Step 1: Sort nums\n→ Step 2: Initialize result list\n→ Step 3: Define backtrack(path, used)\n→ Decision: 是否已完成 path 长度等于 nums 长度?\n    Yes → Step 4: 将 path 复制到结果\n    No  → Step 5: 遍历索引 i 0..len-1\n        Decision: if used[i] 或 (i>0 && nums[i]==nums[i-1] && !used[i-1])? // skip duplicates\n            Yes → Continue\n            No  → Step 6: used[i]=True; path.append(nums[i])\n                → Step 7: backtrack(path, used)\n                → Step 8: path.pop(); used[i]=False\n→ Call backtrack([], [False]*len(nums))\n→ End\n\nWe should incorporate arrows and indent. Use indentation in decisions: 4 spaces? They show examples. We'll just follow similar style: use tab or spaces? Example shows 4 spaces indent for decision blocks. We'll mimic.\n\nImportant: Each line must contain \"虛擬碼步驟\" + space + \"// 解釋\". So we must ensure each line includes the explanation after //.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums // 先將數字排序，以方便後續忽略重複組合  \n→ Step 2: Initialize result as empty list // 用來收集所有唯一排列  \n→ Step 3: Define function backtrack(path, used) // 透過回溯產生排列  \n→ Decision: 是否已完成 path 長度等於 nums 長度? // 判斷是否得到一個完整排列  \n  Yes → Step 4: Add a copy of path to result // 完整排列加入結果  \n  No  → Step 5: 循環遍歷索引 i 從 0 到 len(nums)-1 // 嘗試每個元素作為下一個位置  \n   Decision: if used[i] 或 (i>0 且 nums[i]==nums[i-1] 且 not used[i-1])? // 檢查是否已使用或為重複且前一個相同未被使用，避免重複排列  \n    Yes → Continue // 跳過此索引  \n    No  → Step 6: used[i] = True; path.append(nums[i]) // 標記使用並加入路徑  \n     → Step 7: backtrack(path, used) // 進一步探索下一步  \n     → Step 8: path.pop(); used[i] = False // 回溯：移除最後加入的元素並恢復使用狀態  \n→ Call backtrack([], [False] * len(nums)) // 開始回溯，初始路徑空且所有元素未使用  \nEnd // 程式執行結束，result 中包含所有唯一排列。",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permuteUnique(self, nums):\n        res = []\n        nums.sort()                       # 先排序，方便後續跳過重複\n        used = [False] * len(nums)\n\n        def backtrack(path):\n            if len(path) == len(nums):\n                res.append(path[:])      # 找到一個完整排列\n                return\n            for i in range(len(nums)):\n                if used[i]:\n                    continue\n                # 跳過重複元素：如果前一個相同且未被使用，則不選這個\n                if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                    continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n\n        backtrack([])\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 如果輸入類似 \"nums = [1,1,2]\"，先切除等號部分\n    if \"=\" in data:\n        _, expr = data.split(\"=\", 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # 只使用 ast.literal_eval 以安全方式解析列表\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，直接輸出空結果\n        print(\"[]\")\n        return\n    sol = Solution()\n    result = sol.permuteUnique(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "[[1,1,2],[1,2,1],[2,1,1]]",
          "success": true,
          "output": "[[1, 1, 2], [1, 2, 1], [2, 1, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "success": true,
          "output": "[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode452.json",
    "problem_index_in_file": 0,
    "title": "Minimum Number of Arrows to Burst Balloons",
    "description_snippet": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line for algorithm: sort intervals by end coordinate; iterate and count arrows; maintain current arrow position; if next interval not covered, shoot new arrow at its end; increment arrow count.\n\nWe need virtual code steps with arrow tokens. Use Start, End, Decision, etc.\n\nBe careful: each line must have \"虛擬碼步驟\" and comment. Use arrow \"→\" for step flow.\n\nWe produce lines: Start, → Sort intervals by x_end ascending, → Initialize arrowCount = 0, currentArrow = None, → For each interval in sorted list: Decision: if currentArrow is None or interval.x_start > currentArrow? then new arrow. etc.\n\nWe need to output in traditional Chinese.\n\nOk. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort `points` 依照 `x_end` 升序排列 // 把所有氣球按右端位置由小到大排序  \n→ Set `arrowCount = 0` // 追蹤需要的箭數  \n→ Set `currentArrow = None` // 目前箭頭所在 x 座標  \n→ For each `interval` in sorted `points` // 逐個處理氣球  \n  Decision: `currentArrow` 為 None 或 `interval.x_start > currentArrow`? // 判斷此氣球是否已被現有箭射穿  \n   Yes → Set `currentArrow = interval.x_end` // 在此氣球右端射箭，確保能擊中此及後續重疊氣球  \n    → Increment `arrowCount` by 1 // 新增一支箭  \n   No  → // 目前箭已覆蓋此氣球，無需新增  \n    ← // 直接跳至下一個氣球  \nEnd // 程式執行結束，`arrowCount` 為最小箭數結果",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinArrowShots(self, points):\n        if not points:\n            return 0\n        # 按右端點升序排序\n        points.sort(key=lambda x: x[1])\n        arrows = 1\n        current_end = points[0][1]\n        # 逐個檢查每個氣球\n        for start, end in points[1:]:\n            if start > current_end:\n                arrows += 1\n                current_end = end\n        return arrows\n\ndef parse_points(input_str: str):\n    \"\"\"從輸入字串中擷取並解析出點座標列表。\"\"\"\n    # 找到第一個 '['，從那裡開始切片，並安全評估成 Python 資料結構\n    start = input_str.find('[')\n    if start == -1:\n        return []\n    sub = input_str[start:]\n    try:\n        return ast.literal_eval(sub)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    points = parse_points(raw_input)\n    solution = Solution()\n    result = solution.findMinArrowShots(points)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[10,16],[2,8],[1,6],[7,12]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,2],[3,4],[5,6],[7,8]]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "points = [[1,2],[2,3],[3,4],[4,5]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode123.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock III",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind t...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the algorithm: maximum profit with at most two transactions. This is classic problem.\n\nWe must produce \"逐行虛擬碼\" with explanations, using arrow and Decision etc. We must not output actual code. We should use start, decision, step.\n\nWe need to outline algorithm: iterate through days, maintain firstBuy, firstSell, secondBuy, secondSell. Or use DP.\n\nWe'll produce pseudo-steps:\n\nStart\n→ Initialize firstBuy = -∞, firstSell = 0, secondBuy = -∞, secondSell = 0 // init placeholders\n→ For each price in prices:\n   → Decision: is price < firstBuy? // firstBuy\n       Yes → firstBuy = price // buy low\n       No → Decision: is price > firstSell? // sell first\n           Yes → firstSell = price - firstBuy\n           No → Decision: is price < secondBuy? // secondBuy uses firstSell\n               Yes → secondBuy = price - firstSell\n               No → Decision: is price > secondSell? // sell second\n                   Yes → secondSell = price - secondBuy\n                   No → // no update\n→ End // output secondSell\n\nBut we need more steps maybe: at each iteration, update best first transaction profit, best second transaction profit.\n\nWe can also do DP with arrays: dp[i][k][state]. But easier with one pass.\n\nLet's produce steps.\n\nAlso maybe we need to handle if price array empty.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 firstBuy = +∞, firstSell = 0, secondBuy = +∞, secondSell = 0 // 設定四個變數以追蹤兩筆交易的成本與利潤  \n→ Decision: 如果 prices 為空? // 檢查輸入是否為空陣列  \n    Yes → Step 2: 輸出 0 // 沒有交易可行，直接結束  \n    No  → Step 3: 循環遍歷 prices 中的每一天的價格  \n        → Decision: price < firstBuy? // 檢查是否可以以更低價格購買第一次  \n            Yes → firstBuy = price // 用此價格購買  \n            No  → Decision: price > firstSell? // 檢查是否可以以更高價格出售第一次  \n                Yes → firstSell = price - firstBuy // 更新第一次交易的利潤  \n                No  → Decision: price < secondBuy? // 檢查是否可以以更低價格購買第二次，基於第一次的利潤  \n                    Yes → secondBuy = price - firstSell // 用此價格購買，考慮第一次已賺得的利潤  \n                    No  → Decision: price > secondSell? // 檢查是否可以以更高價格出售第二次  \n                        Yes → secondSell = price - secondBuy // 更新第二次交易的利潤  \n                        No  → // 本天無任何利潤提升，保持原值  \n→ End // 程式執行結束，返回 secondSell 作為最大可得利潤",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n        buy1 = float('-inf')\n        sell1 = 0\n        buy2 = float('-inf')\n        sell2 = 0\n        for price in prices:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, buy1 + price)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, buy2 + price)\n        return sell2\n\ndef parse_input(input_str: str):\n    \"\"\"\n    Parse input string which may contain a variable assignment like\n    'prices = [3,3,5,0,0,3,1,4]'.\n    Returns the list of integers.\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n    # Find the first '[' and the last ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        return []\n    list_str = input_str[start:end+1]\n    try:\n        return ast.literal_eval(list_str)\n    except Exception:\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    prices = parse_input(raw_input)\n    result = Solution().maxProfit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [3,3,5,0,0,3,1,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "prices = [1,2,3,4,5]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode57.json",
    "problem_index_in_file": 0,
    "title": "Insert Interval",
    "description_snippet": "You are given an array of non-overlapping intervals intervals where intervals[i] = [start_i, end_i] ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need produce pseudo-code steps. Provide lines with arrow and explanation. No actual code. Steps: Start, initialize result list, iterate intervals, compare positions, add before, merge, etc. Use decision arrows. Ensure each line has virtual code and comment. Provide a step-by-step approach. Let's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的結果陣列 result // 用來儲存最終合併後的區間\n→ Step 2: 初始化指標 i = 0 // 用於遍歷原始 intervals\n→ Decision: 是否已到達 intervals 結尾? // 檢查是否還有區間需要處理\n    No  → Decision: intervals[i].end < newInterval.start? // 當前區間完全在新區間之前\n        Yes → Step 3: result.add(intervals[i]) // 直接加入結果，因為不會覆蓋\n        No  → Decision: intervals[i].start > newInterval.end? // 當前區間完全在新區間之後\n            Yes → Step 4: result.add(newInterval) // 新區間先加入\n            No  → Step 5: newInterval.start = min(intervals[i].start, newInterval.start) // 合併區間開始點\n                    newInterval.end = max(intervals[i].end, newInterval.end) // 合併區間結束點\n    No  → Step 6: i = i + 1 // 移動到下一個區間\n    Yes → Decision: result 是否已包含 newInterval? // 判斷是否已把新區間加入結果\n        No  → Step 7: result.add(newInterval) // 若還沒加入，將新區間加入\n→ Step 8: 返回 result // 完成合併並返回結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals ending before newInterval starts\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all overlapping intervals with newInterval\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged newInterval\n        result.append(newInterval)\n\n        # Add the remaining intervals\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(raw):\n    # Extract the part after \"intervals =\" and before \"newInterval =\"\n    parts = raw.split('newInterval =')\n    intervals_str = parts[0].replace('intervals =', '').strip()\n    new_interval_str = parts[1].strip()\n    intervals = ast.literal_eval(intervals_str)\n    new_interval = ast.literal_eval(new_interval_str)\n    return intervals, new_interval\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    intervals, new_interval = parse_input(raw_input)\n    solution = Solution()\n    result = solution.insert(intervals, new_interval)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp1g9cxjkx.py\", line 46, in <module>\n    result = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp1g9cxjkx.py\", line 11, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpn4si37p2.py\", line 46, in <module>\n    result = solution.insert(intervals, new_interval)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn4si37p2.py\", line 11, in insert\n    while i < n and intervals[i][1] < newInterval[0]:\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode20.json",
    "problem_index_in_file": 0,
    "title": "Valid Parentheses",
    "description_snippet": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the in...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Use the arrow notation. We'll write Start, steps, decisions, End. The algorithm: use stack. For each char: if opening push; else if closing, check stack not empty and top matches. If not match, invalid. After loop, check stack empty. Output result. We'll produce steps accordingly. Use \"Step\" maybe \"Step 1\" etc. We'll include decisions. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空棧 Stack // 用來存放尚未配對的開括號  \n→ Step 2: 逐個讀取字串 s 中的字符 c // 逐字分析  \n→ Decision: c 是否為開括號 ( '(', '{', '[' )? // 判斷類型  \n  Yes → Step 3: 將 c 推入 Stack // 進入棧，等待對應關閉  \n  No  → Decision: Stack 為空? // 若沒有開括號，必須立即失敗  \n     Yes → Step 4: 設定結果為無效並跳出循環 // 無法配對  \n     No  → Step 5: 取出 Stack 上的頂部元素 top // 取最近的開括號  \n      Decision: top 與 c 是否對應？ (例如 top='(' 且 c=')')  \n        Yes → Step 6: 連續進行下一字符 // 匹配成功，棧已減一  \n        No  → Step 7: 設定結果為無效並跳出循環 // 不匹配  \n\n→ Step 8: 循環結束後，Decision: Stack 是否為空? // 判斷是否有未配對開括號  \n  Yes → Step 9: 設定結果為有效 // 所有括號正確配對  \n  No  → Step 10: 設定結果為無效 // 有剩餘開括號  \n\nEnd // 程式執行結束，輸出結果為「有效」或「無效」",
      "generated_code": "import sys\n\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {')': '(', '}': '{', ']': '['}\n        for char in s:\n            if char in mapping:                     # 是關閉符號\n                top = stack.pop() if stack else '#'\n                if mapping[char] != top:\n                    return False\n            else:                                   # 是開啟符號\n                stack.append(char)\n        return not stack\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    # 若輸入形式為 s = \"...\"\n    if data.startswith('s ='):\n        _, rest = data.split('=', 1)\n        data = rest.strip()\n    # 去除外層引號\n    if (data.startswith('\"') and data.endswith('\"')) or (data.startswith(\"'\") and data.endswith(\"'\")):\n        data = data[1:-1]\n    solution = Solution()\n    result = solution.isValid(data)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"()\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"(]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 3,
          "input": "s = \"([])\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 4,
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode204.json",
    "problem_index_in_file": 0,
    "title": "Count Primes",
    "description_snippet": "Given an integer n, return the number of prime numbers that are strictly less than n....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation for algorithm: Count primes less than n. Likely use sieve of Eratosthenes up to n-1. Steps: Start, Input n, Initialize boolean array isPrime size n, set all true except 0,1, iterate i from 2 to sqrt(n-1), if isPrime[i], mark multiples. Count primes < n. Output count. End.\n\nWe need each line with virtual code step and explanation. Use Start, End, Decision, arrows. We should write step labels: \"Step 1: 取得 n\" etc. Use arrow to next step. For loops we might not need explicit, but we can show Step: 初始化布林陣列. Might need Decision: 是否 n <= 2? If n <= 2, return 0. Then proceed.\n\nLet's produce lines:\n\nStart\n→ Step 1: 讀入整數 n // 獲取輸入\n→ Decision: n <= 2? // 若 n 小於等於 2 沒有小於 n 的質數\n    Yes → Step 2: 輸出 0 // 結束\n    No  → Step 3: 建立布林陣列 isPrime[0..n-1] // 初始化\n→ Step 4: 設定 isPrime[0] ← false, isPrime[1] ← false // 0 和 1 不是質數\n→ Step 5: 計算 limit ← floor(sqrt(n-1)) // 上限\n→ Step 6: for i = 2 to limit do // 迭代候選質數\n    → Decision: isPrime[i]? // 是否仍為質數\n        Yes → Step 7: for j = i*i; j < n; j += i do // 標記合數\n            → Step 8: isPrime[j] ← false\n        No  → continue\n→ Step 9: 計算 count ← 0 // 累計質數數量\n→ Step 10: for i = 2 to n-1 do // 檢查每個數字\n    → Decision: isPrime[i]? // 是否為質數\n        Yes → Step 11: count ← count + 1\n        No  → continue\n→ Step 12: 輸出 count // 顯示結果\nEnd\n\nMake sure each line is virtual code step with explanation. Use arrows for nested steps. Provide arrow '→' before each step, except Start and End. For Decision block, we include Yes→ and No→ with nested steps indented. Ensure format: \"→ Decision: ...\" then indent with spaces maybe. We'll keep indentation.\n\nReturn accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀入整數 n // 獲取輸入\n→ Decision: n <= 2? // 若 n 小於等於 2 沒有小於 n 的質數\n    Yes → Step 2: 輸出 0 // 結束\n    No  → Step 3: 建立布林陣列 isPrime[0..n-1] // 初始化\n→ Step 4: 設定 isPrime[0] ← false, isPrime[1] ← false // 0 和 1 不是質數\n→ Step 5: 計算 limit ← floor(sqrt(n-1)) // 上限\n→ Step 6: for i = 2 to limit do // 迭代候選質數\n    → Decision: isPrime[i]? // 是否仍為質數\n        Yes → Step 7: for j = i*i; j < n; j += i do // 標記合數\n            → Step 8: isPrime[j] ← false\n        No  → continue\n→ Step 9: 計算 count ← 0 // 累計質數數量\n→ Step 10: for i = 2 to n-1 do // 檢查每個數字\n    → Decision: isPrime[i]? // 是否為質數\n        Yes → Step 11: count ← count + 1\n        No  → continue\n→ Step 12: 輸出 count // 顯示結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_primes(n: int) -> int:\n    \"\"\"\n    計算小於 n 的質數個數。\n    若 n <= 2，則沒有小於 n 的質數。\n    \"\"\"\n    if n <= 2:\n        return 0\n\n    # is_prime[i] 代表 i 是否為質數\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n\n    # 只需檢查到 sqrt(n) 即可\n    limit = int(n ** 0.5) + 1\n    for i in range(2, limit):\n        if is_prime[i]:\n            # 將 i 的倍數標記為非質數\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n\n    # 計算所有仍為 True 的個數，即質數個數\n    return sum(is_prime)\n\n\ndef main() -> None:\n    \"\"\"\n    主程式：\n    1. 從標準輸入讀取資料（可能包含「n = 10」或僅為數字）。\n    2. 解析出第一個整數作為 n。\n    3. 計算並輸出小於 n 的質數個數。\n    \"\"\"\n    data = sys.stdin.read()\n    # 取出字串中的第一個整數（允許負號）\n    nums = re.findall(r'-?\\d+', data)\n    n = int(nums[0]) if nums else 0\n\n    result = count_primes(n)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode264.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number II",
    "description_snippet": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. \n\nGiven an inte...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step-by-step for algorithm to find nth ugly number. Classic DP using multiple pointers. We need virtual code steps, each line with \"虛擬碼步驟\" and comment. Use arrows, Decision. We need to generate sequential steps.\n\nWe must output virtual code lines only, no actual code. Use Start, End, Decision, arrows.\n\nSteps: Start, initialize array ugly[0]=1, pointers i2,i3,i5=0, next multiples m2,m3,m5. Loop count=1 to n-1, compute next=min(m2,m3,m5), append to array, update pointers if match. After loop, output ugly[n-1]. End.\n\nWe'll produce each step in one line: e.g., \"Start // 程式開始執行\". Then \"→ Step 1: 初始化數組 ugly[0] = 1 // 初始最小丑數\" etc.\n\nWe must maintain clarity. Each line with virtual code + comment. Use \"Step x:\" etc.\n\nLet's create lines:\n\n1. Start // 程式開始執行\n2. → Step 1: 初始化 ugly[0] = 1 // 設定第一個丑數為 1\n3. → Step 2: 初始化指標 i2 = 0, i3 = 0, i5 = 0 // 分別對應 2、3、5 的指標\n4. → Step 3: 計算下一個丑數候選 m2 = ugly[i2] * 2, m3 = ugly[i3] * 3, m5 = ugly[i5] * 5 // 先算三個可能的下個丑數\n5. → Decision: 當前已生成丑數個數 count = 1 是否小於 n? // 循環直到生成 n 個丑數\n6.     Yes → Step 4: next = min(m2, m3, m5) // 從三個候選中取最小值作為下一個丑數\n7.     Yes → Step 5: ugly[count] = next // 將其加入丑數序列\n8.     Yes → Step 6: 若 next == m2, i2 = i2 + 1, m2 = ugly[i2] * 2 // 若用到 2，則更新指標與候選\n9.     Yes → Step 7: 若 next == m3, i3 = i3 + 1, m3 = ugly[i3] * 3 // 若用到 3，則更新指標與候選\n10.    Yes → Step 8: 若 next == m5, i5 = i5 + 1, m5 = ugly[i5] * 5 // 若用到 5，則更新指標與候選\n11.    Yes → Step 9: count = count + 1 // 丑數個數加一\n12.    Yes → Step 10: 回到 Decision: 當前已生成丑數個數 count = 1 是否小於 n? // 重新判斷\n13.    No → Step 11: result = ugly[n-1] // n 個丑數已生成，取最後一個作為答案\n14. End // 程式執行結束\n\nWe must ensure each line has arrow. For Step 1 we used \"Step 1:\" but no arrow? The pattern: \"→ Step 1: ...\". Yes.\n\nMake sure to maintain \"Decision:\" lines with indentation? Use spaces? In sample they indent substeps. Use same style: indent four spaces? But they used tab maybe. We'll produce:\n\n\"→ Decision: ...\" then \"    Yes → ...\" etc. Use four spaces indent.\n\nNow produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 ugly[0] = 1 // 設定第一個丑數為 1\n→ Step 2: 初始化指標 i2 = 0, i3 = 0, i5 = 0 // 分別對應 2、3、5 的指標\n→ Step 3: 計算下一個丑數候選 m2 = ugly[i2] * 2, m3 = ugly[i3] * 3, m5 = ugly[i5] * 5 // 先算三個可能的下個丑數\n→ Decision: 當前已生成丑數個數 count = 1 是否小於 n? // 循環直到生成 n 個丑數\n    Yes → Step 4: next = min(m2, m3, m5) // 從三個候選中取最小值作為下一個丑數\n    Yes → Step 5: ugly[count] = next // 將其加入丑數序列\n    Yes → Step 6: 若 next == m2, i2 = i2 + 1, m2 = ugly[i2] * 2 // 若用到 2，則更新指標與候選\n    Yes → Step 7: 若 next == m3, i3 = i3 + 1, m3 = ugly[i3] * 3 // 若用到 3，則更新指標與候選\n    Yes → Step 8: 若 next == m5, i5 = i5 + 1, m5 = ugly[i5] * 5 // 若用到 5，則更新指標與候選\n    Yes → Step 9: count = count + 1 // 丑數個數加一\n    Yes → Step 10: 回到 Decision: 當前已生成丑數個數 count = 1 是否小於 n? // 重新判斷\n    No → Step 11: result = ugly[n-1] // n 個丑數已生成，取最後一個作為答案\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthUglyNumber(self, n: int) -> int:\n        \"\"\"\n        返回第 n 個丑數。丑數是只含 2、3、5 為質因子的正整數。\n        \"\"\"\n        ugly = [1]               # 以 1 作為第一個丑數\n        i2 = i3 = i5 = 0         # 分別對應 2、3、5 的指標\n\n        # 只要丑數序列長度未達 n，就繼續生成\n        while len(ugly) < n:\n            next2 = ugly[i2] * 2\n            next3 = ugly[i3] * 3\n            next5 = ugly[i5] * 5\n            next_ugly = min(next2, next3, next5)\n            ugly.append(next_ugly)\n\n            # 若此數字是由 2 產生，則指標前移\n            if next_ugly == next2:\n                i2 += 1\n            # 若此數字是由 3 產生，則指標前移\n            if next_ugly == next3:\n                i3 += 1\n            # 若此數字是由 5 產生，則指標前移\n            if next_ugly == next5:\n                i5 += 1\n\n        return ugly[-1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，支援 \"n = 10\" 或僅輸入 \"10\" 的格式\n    data = sys.stdin.read().strip()\n    match = re.search(r\"\\d+\", data)\n    if not match:\n        raise ValueError(\"輸入中未找到有效的數字\")\n    n = int(match.group())\n\n    solution = Solution()\n    result = solution.nthUglyNumber(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10",
          "expected_output": "12",
          "success": true,
          "output": "12"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode316.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicate Letters",
    "description_snippet": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for this problem: remove duplicate letters, keep each letter once, minimal lexicographical order. This is typical \"Remove Duplicate Letters\" problem, using stack, last occurrence mapping, visited array. Provide steps.\n\nWe should produce step-by-step virtual code.\n\nLet's craft steps:\n\nStart\n→ Step 1: 建立字典 lastIdx 存儲每個字母最後出現的位置 // 方便後續判斷\n→ Step 2: 建立布林陣列 visited 以記錄字母是否已加入結果 // 防止重複加入\n→ Step 3: 建立空棧 stack 用於儲存結果字母\n→ Decision: 迭代字符串每個字符 ch 在索引 i\n    → Decision: 若 ch 已 visited? // 已加入結果\n        Yes → Continue // 跳過\n        No  → Decision: 當棧不空且 ch < stack.top 且 stack.top 在後續仍會出現? // 可刪除\n            Yes → Step 4: 取出棧頂 char top; visited[top] = False // 移除\n            No  → Step 5: 進入下一決策\n        → Step 6: Push ch 到棧; visited[ch] = True // 加入結果\nEnd\n→ Step 7: 將棧轉為字串作為結果 // 最終答案\n\nBut must be line by line with arrow notation. Use Start, End, Decision: etc.\n\nNeed each line with explanation comment after //.\n\nLet's produce more explicit:\n\nStart // 開始\n→ Step 1: lastIdx ← 空字典 // 儲存每個字母最後索引\n→ Step 2: visited ← 全False陣列大小 26 // 標記字母是否已在棧中\n→ Step 3: stack ← 空棧 // 存放結果字母\n→ Decision: i = 0 .. length(s)-1 // 逐字母遍歷\n    → Step 4: ch ← s[i] // 取得當前字母\n    → Decision: visited[ch]? // 已存在於結果\n        Yes → Step 5: Continue // 跳過此字母\n        No  → Decision: stack 不是空且 ch < stack.top 且 lastIdx[stack.top] > i? // 可以移除堆頂\n            Yes → Step 6: top ← stack.pop(); visited[top] ← False // 移除\n            No  → Step 7: Push ch 到 stack; visited[ch] ← True // 添加到結果\nEnd // 結束遍歷\n→ Step 8: result ← 空字串\n→ Decision: stack 不是空\n    Yes → Step 9: result ← stack.join() // 將棧內容連接成字串\n    No  → Step 10: result ← \"\" // 空結果\n→ Step 11: 返回 result // 結果輸出\nEnd // 程式結束\n\nBut need \"虛擬碼步驟\" with arrow.\n\nLet's produce each line with arrow at start:\n\nStart // 程式開始\n→ Step 1: lastIdx ← 空字典 // 用來記錄每個字母最後一次出現的索引\n→ Step 2: visited ← [False]*26 // 標記字母是否已加入棧\n→ Step 3: stack ← 空棧 // 用於構造結果字母序列\n→ Decision: i 迴圈 0 to len(s)-1 // 逐字母遍歷\n    → Step 4: ch ← s[i] // 取得目前字母\n    → Decision: visited[ch]? // 判斷字母是否已在結果中\n        Yes → Step 5: Continue // 已存在，跳過\n        No  → Decision: stack 不是空 且 ch < stack.top 且 lastIdx[stack.top] > i? // 可安全移除堆頂\n            Yes → Step 6: top ← stack.pop(); visited[top] ← False // 移除堆頂並標記未在棧\n            No  → Step 7: stack.push(ch); visited[ch] ← True // 將字母加入棧並標記已在棧\nEnd // 迴圈結束\n→ Step 8: result ← 空字串\n→ Decision: stack 不是空\n    Yes → Step 9: result ← stack.join() // 轉為字串作為最終答案\n    No  → Step 10: result ← \"\" // 沒有字母時返回空字串\n→ Step 11: Return result // 輸出結果\nEnd // 程式結束\n\nBut maybe we need to maintain stack as array of characters. join() step should pop all? But that's fine.\n\nHowever the virtual code lines: Each line after arrow should contain the step and comment.\n\nWe need to ensure each line contains arrow: \"→ Step 1:\" etc. Provide indent for nested decisions. The example uses spaces for indent. Use similar style.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: lastIdx ← 空字典 // 用來記錄每個字母最後一次出現的位置  \n→ Step 2: visited ← [False] * 26 // 標記每個字母是否已被加入結果  \n→ Step 3: stack ← 空棧 // 用於構造最終字串  \n→ Decision: i 迴圈 0 到 len(s)-1 // 逐字母遍歷輸入字串  \n  → Step 4: ch ← s[i] // 取得目前字母  \n  → Decision: visited[ch]? // 判斷字母是否已在結果中  \n   Yes → Step 5: Continue // 已存在，直接跳過  \n   No → Decision: stack 不是空 且 ch < stack.top 且 lastIdx[stack.top] > i? // 可安全刪除棧頂字母  \n    Yes → Step 6: top ← stack.pop(); visited[top] ← False // 移除棧頂並更新標記  \n    No → Step 7: stack.push(ch); visited[ch] ← True // 將字母加入棧並標記已存在  \nEnd // 迴圈結束  \n→ Step 8: result ← 空字串 // 用於儲存最終答案  \n→ Decision: stack 不是空  \n  Yes → Step 9: result ← stack.join() // 把棧中的字母連接成字串  \n  No → Step 10: result ← \"\" // 若棧空則結果為空字串  \n→ Step 11: Return result // 輸出最小字典序結果  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\ndef remove_duplicate_letters(s: str) -> str:\n    \"\"\"Return the smallest lexicographical string that contains each character once.\"\"\"\n    stack = []            # 用來存放結果字母\n    seen = set()          # 記錄已經加入 stack 的字母\n    last_occurrence = {c: i for i, c in enumerate(s)}  # 每個字母最後出現的位置\n\n    for i, c in enumerate(s):\n        if c in seen:\n            continue  # 已經在結果中，跳過\n        # 若能移除堆頂字母且仍有機會在後面再次出現，且堆頂字母比現在大，則移除\n        while stack and c < stack[-1] and i < last_occurrence[stack[-1]]:\n            removed = stack.pop()\n            seen.discard(removed)\n        stack.append(c)\n        seen.add(c)\n\n    return ''.join(stack)\n\ndef main() -> None:\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n\n    # 嘗試從類似 's = \"string\"' 的輸入中抽取實際字串\n    match = re.search(r'[\"\\']([^\"\\']*)[\"\\']', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        s = raw_input  # 若沒有引號，直接使用整個輸入\n\n    result = remove_duplicate_letters(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"bcabc\"",
          "expected_output": "\"abc\"",
          "success": true,
          "output": "abc"
        },
        {
          "example_index": 1,
          "input": "s = \"cbacdcbc\"",
          "expected_output": "\"acdb\"",
          "success": true,
          "output": "acdb"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode432.json",
    "problem_index_in_file": 0,
    "title": "All O`one Data Structure",
    "description_snippet": "Design a data structure to store the strings' count with the ability to return the strings with mini...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode steps line by line with comments. Provide virtual code for AllOne class design. Must use arrow notation. Steps include initialization, inc, dec, getMaxKey, getMinKey. Use data structures: doubly linked list of count nodes, each node holds keys with same count, and hashmap key->node. Provide logic. Provide pseudocode line by line. Probably a series of functions.\n\nLet's craft. We'll start with class AllOne // Start\n→ Start // initialize\n\nThen inside AllOne() create head and tail sentinel nodes for counts 0? Actually counts start at 1. We'll use sentinel head (min) and tail (max). Each node has count, set of keys, prev, next. And map key->node.\n\ninc(key):\n    if key not in map:\n        if head.next is null or head.next.count != 1:\n            create new node count 1 after head\n        add key to head.next's key set\n        map[key] = node\n    else:\n        node = map[key]\n        nextNode = node.next\n        if nextNode is null or nextNode.count != node.count +1:\n            create new node with count node.count+1 after node\n            nextNode = new node\n        add key to nextNode's key set\n        map[key] = nextNode\n        remove key from node's key set\n        if node's key set empty:\n            delete node\n\ndec(key):\n    node = map[key]\n    if node.count == 1:\n        remove key from node's key set\n        delete node\n        delete map[key]\n    else:\n        prevNode = node.prev\n        if prevNode == head or prevNode.count != node.count -1:\n            create new node with count node.count-1 before node\n            prevNode = new node\n        add key to prevNode's key set\n        map[key] = prevNode\n        remove key from node's key set\n        if node's key set empty:\n            delete node\n\ngetMaxKey():\n    if tail.prev == head: return \"\"\n    return any key from tail.prev's key set\n\ngetMinKey():\n    if head.next == tail: return \"\"\n    return any key from head.next's key set\n\nAlso need delete node function.\n\nNeed to include all steps with arrow notation. Use Start/End? Each function separate.\n\nLet's produce lines. Use indentation for decisions.\n\nWe'll produce pseudocode lines. Use arrow for flow.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行 AllOne 資料結構的初始化\n→ AllOne() // 建構子\n    → Create head // 生成頭哨兵節點（最小邊界）\n    → Create tail // 生成尾哨兵節點（最大邊界）\n    → head.next ← tail // 初始時鏈表只有哨兵\n    → tail.prev ← head\n    → keyToNode ← EmptyMap // key → 其所在計數節點\nEnd // 建構子完成\n\nStart // inc 方法入口\n→ inc(key) // 對 key 做遞增\n    → Decision: key 是否存在? // 判斷 key 是否已在資料結構中\n        Yes → node ← keyToNode[key] // 取出當前節點\n        No  → node ← null\n    → Decision: node ？ // 若不存在則需要處理新 key\n        Yes → // key 已存在，將其移動到 count+1 節點\n            → newNode ← node.next\n            → Decision: newNode 是否存在且 count 為 node.count+1? // 檢查下一節點是否為目標計數\n                Yes → // 目標節點已存在\n                No  → // 需要新建節點\n                    → newNode ← NewNode(node.count+1)\n                    → InsertAfter(node, newNode) // 插入到鏈表中\n            → AddKey(newNode, key) // 把 key 加到新節點\n            → keyToNode[key] ← newNode // 更新映射\n            → RemoveKey(node, key) // 從舊節點移除\n            → Decision: node.keys.isEmpty? // 若舊節點無 key，則刪除\n                Yes → RemoveNode(node)\n                No  →\n        No  → // key 為新 key，需加入 count 1 節點\n            → newNode ← head.next\n            → Decision: newNode 是否存在且 count 為 1? // 檢查是否已有 count 1 節點\n                Yes →\n                No  →\n                    → newNode ← NewNode(1)\n                    → InsertAfter(head, newNode) // 插入到鏈表中\n            → AddKey(newNode, key)\n            → keyToNode[key] ← newNode\nEnd // inc 方法完成\n\nStart // dec 方法入口\n→ dec(key) // 對 key 做遞減\n    → node ← keyToNode[key] // 取得 key 所在節點\n    → Decision: node.count == 1? // 判斷是否會被移除\n        Yes → // 直接移除 key\n            → RemoveKey(node, key)\n            → RemoveNode(node) // 刪除空節點\n            → Delete keyToNode[key] // 從映射刪除\n        No  → // 移動到 count-1 節點\n            → prevNode ← node.prev\n            → Decision: prevNode 是否為 head 或 count 為 node.count-1? // 檢查前一節點是否為目標計數\n                Yes → // 目標節點已存在\n                No  →\n                    → prevNode ← NewNode(node.count-1)\n                    → InsertBefore(node, prevNode) // 插入到鏈表中\n            → AddKey(prevNode, key)\n            → keyToNode[key] ← prevNode\n            → RemoveKey(node, key)\n            → Decision: node.keys.isEmpty? // 若舊節點無 key，則刪除\n                Yes → RemoveNode(node)\n                No  →\nEnd // dec 方法完成\n\nStart // getMaxKey 方法入口\n→ getMaxKey() // 取得最大計數的任一 key\n    → Decision: tail.prev == head? // 判斷是否有任何 key\n        Yes → return \"\" // 空字符串表示無元素\n        No  →\n            → maxNode ← tail.prev\n            → return AnyKey(maxNode.keys) // 隨機取一個 key\nEnd // getMaxKey 方法完成\n\nStart // getMinKey 方法入口\n→ getMinKey() // 取得最小計數的任一 key\n    → Decision: head.next == tail? // 判斷是否有任何 key\n        Yes → return \"\" // 空字符串表示無元素\n        No  →\n            → minNode ← head.next\n            → return AnyKey(minNode.keys) // 隨機取一個 key\nEnd // getMinKey 方法完成\n\nStart // 辅助函数\n→ NewNode(count) // 創建新節點\n    → node.count ← count\n    → node.keys ← EmptySet\n    → node.prev ← null\n    → node.next ← null\n    → return node\nEnd\n\n→ InsertAfter(prevNode, newNode) // 在 prevNode 後插入 newNode\n    → newNode.prev ← prevNode\n    → newNode.next ← prevNode.next\n    → prevNode.next.prev ← newNode\n    → prevNode.next ← newNode\nEnd\n\n→ InsertBefore(nextNode, newNode) // 在 nextNode 前插入 newNode\n    → newNode.next ← nextNode\n    → newNode.prev ← nextNode.prev\n    → nextNode.prev.next ← newNode\n    → nextNode.prev ← newNode\nEnd\n\n→ RemoveNode(node) // 從鏈表中刪除 node\n    → node.prev.next ← node.next\n    → node.next.prev ← node.prev\n    → node.prev ← null\n    → node.next ← null\nEnd\n\n→ AddKey(node, key) // 把 key 加入 node 的 key 集合\n    → node.keys.add(key)\nEnd\n\n→ RemoveKey(node, key) // 從 node 的 key 集合移除 key\n    → node.keys.remove(key)\nEnd\n\n→ AnyKey(set) // 從集合中任意取一個元素\n    → return set.iterator().next()\nEnd // 所有虛擬碼步驟結束",
      "generated_code": "import sys\nimport json\n\nclass Node:\n    __slots__ = ('count', 'keys', 'prev', 'next')\n    def __init__(self, count=0):\n        self.count = count\n        self.keys = set()\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()  # sentinel head (min)\n        self.tail = Node()  # sentinel tail (max)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node(count)\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key: str) -> None:\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_node = node.next\n            target_count = node.count + 1\n            if next_node == self.tail or next_node.count > target_count:\n                next_node = self._insert_after(node, target_count)\n            next_node.keys.add(key)\n            self.key_to_node[key] = next_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            next_node = self.head.next\n            if next_node == self.tail or next_node.count > 1:\n                next_node = self._insert_after(self.head, 1)\n            next_node.keys.add(key)\n            self.key_to_node[key] = next_node\n\n    def dec(self, key: str) -> None:\n        node = self.key_to_node[key]\n        node.keys.remove(key)\n        prev_count = node.count - 1\n        if prev_count == 0:\n            del self.key_to_node[key]\n        else:\n            prev_node = node.prev\n            if prev_node == self.head or prev_node.count < prev_count:\n                prev_node = self._insert_after(node.prev, prev_count)\n            prev_node.keys.add(key)\n            self.key_to_node[key] = prev_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self) -> str:\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self) -> str:\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw.strip():\n        return\n    # Filter out lines that are just \"Input\" or \"Output\"\n    lines = [line.strip() for line in raw.strip().splitlines()\n             if line.strip() and not line.strip().startswith(('Input', 'Output'))]\n    if len(lines) < 2:\n        return\n    ops = eval(lines[0])\n    args = eval(lines[1])\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"AllOne\":\n            obj = AllOne()\n            res.append(None)\n        elif op == \"inc\":\n            obj.inc(arg[0])\n            res.append(None)\n        elif op == \"dec\":\n            obj.dec(arg[0])\n            res.append(None)\n        elif op == \"getMaxKey\":\n            res.append(obj.getMaxKey())\n        elif op == \"getMinKey\":\n            res.append(obj.getMinKey())\n\n    print(\"Output\")\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "success": true,
          "output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode344.json",
    "problem_index_in_file": 0,
    "title": "Reverse String",
    "description_snippet": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for function that reverses array of chars in place. Provide step-by-step lines with arrow, decisions etc. No actual code. Use virtual code syntax: Start, →, Decision: etc.\n\nNeed to handle two pointers, swap until left<right.\n\nLet's produce steps:\n\nStart\n→ Step 1: 初始化 left = 0, right = s.length - 1 // 左指標設在開始，右指標設在結束\n→ Decision: 是否 left < right? // 檢查是否還有未交換的元素\n    Yes → Step 2: 交換 s[left] 與 s[right] // 交換左右兩端字符\n    Yes → Step 3: left = left + 1 // 左指標向右移動\n    Yes → Step 4: right = right - 1 // 右指標向左移動\n    No → End // 反轉完成，結束\n\nBut need to show loop. The decision line can be repeated? Typically arrow leads to block.\n\nWe can use while-like structure:\n\n→ Decision: left < right? \n    Yes → Swap...\n    Yes → left++ ...\n    Yes → right-- ...\n    No → End\n\nBut arrow indentation: each Yes arrow lines should be indented under decision. Provide arrow each line.\n\nLet's produce lines with \"Step\" numbers or description.\n\nUse \"Step 1\" etc. Provide simple explanation after comment.\n\nMake sure no actual code. Use pseudo variable names.\n\nWe'll produce as required.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left ← 0, right ← s.length - 1 // 初始化左指標為 0，右指標為陣列最後一個索引  \n→ Decision: left < right? // 判斷是否還有未交換的字符  \n&nbsp;&nbsp;Yes → Step 2: swap s[left] 與 s[right] // 交換左右兩端字符  \n&nbsp;&nbsp;Yes → Step 3: left ← left + 1 // 左指標右移一位  \n&nbsp;&nbsp;Yes → Step 4: right ← right - 1 // 右指標左移一位  \n&nbsp;&nbsp;No  → End // 左右指標相遇或交叉，逆轉完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def reverseString(self, s):\n        \"\"\"\n        將字元陣列 s 進行原地反轉，使用 O(1) 追加記憶體。\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n\ndef parse_input(data: str):\n    \"\"\"\n    解析從標準輸入讀取的字串，返回字元列表。\n    支援格式「s = [\\\"a\\\",\\\"b\\\"]」或僅 [\\\"a\\\",\\\"b\\\"]。\n    \"\"\"\n    data = data.strip()\n    if data.lower().startswith('s'):\n        # 移除「s =」前綴\n        eq_index = data.find('=')\n        if eq_index != -1:\n            data = data[eq_index + 1:].strip()\n    # 透過 ast.literal_eval 解析安全的 Python 資料結構\n    try:\n        result = ast.literal_eval(data)\n        if isinstance(result, list):\n            return result\n    except Exception:\n        pass\n    return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    chars = parse_input(raw_input)\n    if chars:\n        Solution().reverseString(chars)\n        # 使用 json.dumps 以雙引號輸出，符合範例格式\n        print(json.dumps(chars))\n    else:\n        # 若輸入不符合預期，輸出空列表\n        print(\"[]\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
          "expected_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]",
          "success": true,
          "output": "[\"o\", \"l\", \"l\", \"e\", \"h\"]"
        },
        {
          "example_index": 1,
          "input": "s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
          "expected_output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
          "success": true,
          "output": "[\"h\", \"a\", \"n\", \"n\", \"a\", \"H\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2220.json",
    "problem_index_in_file": 0,
    "title": "Minimum Bit Flips to Convert Number",
    "description_snippet": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from ei...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with steps for minimal bit flips between two integers. We need to explain each line. Use virtual code syntax as described: Start, End, Decision, arrows, etc. We must avoid actual code. The algorithm: bitwise XOR to find differing bits; count number of 1 bits in XOR (population count). That's minimal flips. Steps: Start, Compute XOR, Count bits set to 1, Return count, End. Also could include decision: if start equals goal, result 0. But that's captured by XOR. Let's produce step-by-step. Use arrow syntax: \"→\" for linear step, \"Decision:\" for decision. Provide explanation. Let's produce each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". We must not output actual code. Use placeholders like Step 1, etc.\n\nLet's produce: \nStart\n→ Step 1: Compute XOR of start and goal // difference bits\n→ Step 2: Initialize counter = 0 // to count flips\n→ Decision: While XOR != 0? // loop over bits\n    Yes → Step 3: If XOR LSB is 1? // check least significant bit\n        Yes → Step 4: Increment counter // need a flip\n    Yes → Step 5: Right shift XOR by 1 // move to next bit\n    Yes → Continue loop\nNo → Step 6: Result = counter // total flips\nEnd\n\nAlternatively we can use built-in population count but we can't mention actual functions. So we use loop.\n\nLet's produce with correct syntax and explanation.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算 XOR = start XOR goal // 找出兩數不同的位元  \n→ Step 2: 設定 counter = 0 // 斷位數計數器  \n→ Decision: 當 XOR ≠ 0? // 仍有未檢查的位元  \n  Yes → Step 3: 檢查 XOR 最右位元是否為 1? // 代表此位需翻轉  \n    Yes → Step 4: counter += 1 // 翻轉此位，計數器加一  \n    No  → （不改動 counter）  \n  Yes → Step 5: XOR >>= 1 // 右移一位，檢查下一位  \n  Yes → （重複 Decision）  \nNo → Step 6: result = counter // 所有不同位已計算完，得到最小翻轉數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef min_bit_flips(start: int, goal: int) -> int:\n    \"\"\"\n    取得兩個整數之間最小的 bit flip 數量。\n    步驟說明：\n    1. 用 XOR 找出兩個數字不同的位元位置。\n    2. 逐位檢查 XOR 的位元，若為 1 表示此位需要翻轉，計數器 +1。\n    3. 右移 XOR，直到全部位元處理完畢。\n    4. 回傳累積的翻轉次數。\n    \"\"\"\n    xor = start ^ goal\n    flips = 0\n    while xor:\n        flips += xor & 1      # 若最低位為 1，翻轉一次\n        xor >>= 1             # 移動到下一位\n    return flips\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：\n    1. 從標準輸入讀取資料。\n    2. 解析出 start 與 goal 的整數值。\n    3. 計算最小翻轉數並輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)  # 取得所有整數字串\n    if len(numbers) < 2:\n        # 若輸入不足兩個數字，直接輸出 0\n        print(0)\n        return\n    start, goal = int(numbers[0]), int(numbers[1])\n    result = min_bit_flips(start, goal)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "start = 10, goal = 7",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "start = 3, goal = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode767.json",
    "problem_index_in_file": 0,
    "title": "Reorganize String",
    "description_snippet": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. Provide algorithm for reorganize string: typical approach: count frequencies, use max heap, repeatedly pop two most frequent, append, decrement, push back if remains. Check if any character frequency > (n+1)/2 -> impossible. We'll produce steps accordingly.\n\nNeed to output each line: \"Start // 程式開始執行\" etc.\n\nUse decision branches.\n\nLet's craft.\n\nWe should include reading input string, compute length, count frequencies maybe using array or map.\n\nCheck max frequency > (n+1)/2: decision leads to return empty string.\n\nThen build priority queue: Step: Build list of (char, count), push into max-heap sorted by count.\n\nInitialize result empty string.\n\nWhile heap not empty:\n\nPop top two characters with highest count. If only one left: append char, break.\n\nAppend first char, decrement its count.\n\nAppend second char, decrement its count.\n\nIf counts > 0 push back into heap.\n\nAfter loop, return result.\n\nEdge cases: single char string.\n\nLet's write virtual code line by line with decisions.\n\nWe will use generic pseudocode constructs like \"If\", \"While\", \"MaxHeap\".\n\nAlso we can incorporate array count.\n\nWe'll follow output format: \"虛擬碼步驟 [space] // 解釋/說明\".\n\nLet's begin.\n\nWe'll write:\n\nStart // 程式開始執行\n\n→ Step 1: 取得輸入字串 s // 從使用者或呼叫函式取得字串\n\n→ Step 2: 計算字串長度 n = length(s) // 取得字串長度\n\n→ Step 3: 初始化頻率表 freq[26] 為 0 // 用來統計每個英文字母出現次數\n\n→ Step 4: For 每個字符 c 在 s 中: freq[c]++ // 逐字統計\n\n→ Step 5: 計算最大頻率 maxFreq = max(freq) // 找出最常出現字母的次數\n\n→ Decision: 如果 maxFreq > (n+1)/2? // 判斷是否無法重排\n\n    Yes → Step 6: 回傳 \"\" // 無法重排，直接返回空字串\n\n    No  → Step 7: 建立最大堆 maxHeap 以 freq 為排序鍵 // 用於取出出現次數最高的字符\n\n        // 逐個將 freq >0 的字符加入堆\n\n→ Step 8: 初始化空字串 result = \"\" // 儲存重排後的字串\n\n→ While maxHeap 不是空: // 重複直到所有字符都放入結果\n\n    → Step 9: Pop 兩個頻率最高的項目 (char1, cnt1) = maxHeap.pop() // 取得第一個字符\n\n    → Decision: 是否還有第二個項目? // 檢查堆中是否仍有元素\n\n        Yes → (char2, cnt2) = maxHeap.pop() // 取得第二個字符\n\n        No  → Step 10: Append char1 到 result // 只有一個字符時直接放入\n\n             → Step 11: 跳出 While 循環 // 所有字符已放完\n\n    → Step 12: Append char1 到 result // 放第一個字符\n\n    → Step 13: Append char2 到 result // 放第二個字符\n\n    → Step 14: cnt1-- ; cnt2-- // 兩個字符使用一次\n\n    → Decision: 如果 cnt1 > 0? // 若第一個字符還有剩餘\n\n        Yes → maxHeap.push((char1, cnt1)) // 再次放回堆\n\n        No  → // 不放回\n\n    → Decision: 如果 cnt2 > 0? // 若第二個字符還有剩餘\n\n        Yes → maxHeap.push((char2, cnt2))\n\n        No  → // 不放回\n\n→ Step 15: 回傳 result // 返回重排後的字串\n\nEnd // 程式執行結束\n\nNeed to include each step as a line with explanation. Also ensure decisions are indented maybe with tabs? In example, they use indentation. We can use indentation to show nested decisions. Let's adopt indentation spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者或函式取得要重排的字串  \n→ Step 2: 計算字串長度 n = length(s) // 取得字串長度  \n→ Step 3: 初始化頻率表 freq[26] 為 0 // 用來統計每個英文字母出現次數  \n→ Step 4: For 每個字符 c 在 s 中: freq[c]++ // 逐字統計  \n→ Step 5: 計算最大頻率 maxFreq = max(freq) // 找出最常出現字母的次數  \n→ Decision: 如果 maxFreq > (n+1)/2? // 判斷是否無法重排  \n  Yes → Step 6: 回傳 \"\" // 無法重排，直接返回空字串  \n  No → Step 7: 建立最大堆 maxHeap 以 freq 為排序鍵 // 用於取出出現次數最高的字符  \n   // 逐個將 freq >0 的字符加入堆  \n→ Step 8: 初始化空字串 result = \"\" // 儲存重排後的字串  \n→ While maxHeap 不是空: // 重複直到所有字符都放入結果  \n  → Step 9: Pop 兩個頻率最高的項目 (char1, cnt1) = maxHeap.pop() // 取得第一個字符  \n  → Decision: 是否還有第二個項目? // 檢查堆中是否仍有元素  \n   Yes → (char2, cnt2) = maxHeap.pop() // 取得第二個字符  \n   No → Step 10: Append char1 到 result // 只有一個字符時直接放入  \n    → Step 11: 跳出 While 循環 // 所有字符已放完  \n  → Step 12: Append char1 到 result // 放第一個字符  \n  → Step 13: Append char2 到 result // 放第二個字符  \n  → Step 14: cnt1-- ; cnt2-- // 兩個字符使用一次  \n  → Decision: 如果 cnt1 > 0? // 若第一個字符還有剩餘  \n   Yes → maxHeap.push((char1, cnt1)) // 再次放回堆  \n   No → // 不放回  \n  → Decision: 如果 cnt2 > 0? // 若第二個字符還有剩餘  \n   Yes → maxHeap.push((char2, cnt2))  \n   No → // 不放回  \n→ Step 15: 回傳 result // 返回重排後的字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        n = len(s)\n        freq = Counter(s)\n        if not freq:\n            return \"\"\n\n        # 如果任何字符出現次數超過 (n+1)//2，無法重排\n        if max(freq.values()) > (n + 1) // 2:\n            return \"\"\n\n        # 建立以頻率為排序鍵的最大堆\n        max_heap = [(-cnt, ch) for ch, cnt in freq.items()]\n        heapq.heapify(max_heap)\n\n        prev_cnt, prev_ch = 0, ''\n        res = []\n\n        while max_heap:\n            cnt, ch = heapq.heappop(max_heap)\n            res.append(ch)\n            # 若前一次使用的字符還剩餘，重新放回堆\n            if prev_cnt < 0:\n                heapq.heappush(max_heap, (prev_cnt, prev_ch))\n            # 更新前一次字符的剩餘數量\n            prev_cnt, prev_ch = cnt + 1, ch  # cnt is negative\n\n        result = \"\".join(res)\n        return result if len(result) == n else \"\"\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 允許輸入格式如：s = \"aab\" 或僅為 aab\n    if '=' in data:\n        _, s_part = data.split('=', 1)\n        s = s_part.strip()\n    else:\n        s = data\n    # 移除可能存在的雙引號\n    if s and s[0] in ('\"', \"'\") and s[-1] in ('\"', \"'\"):\n        s = s[1:-1]\n    solution = Solution()\n    result = solution.reorganizeString(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "success": true,
          "output": "aba"
        },
        {
          "example_index": 1,
          "input": "s = \"aaab\"",
          "expected_output": "\"\"",
          "success": true,
          "output": ""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode312.json",
    "problem_index_in_file": 0,
    "title": "Burst Balloons",
    "description_snippet": "You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it repre...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the balloon bursting problem: maximum coins. Use dynamic programming, interval DP. Provide steps. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, etc. Provide pseudo. No actual code, just steps. Each line separate. Let's produce a comprehensive algorithm.\n\nWe must follow the format: each line with code step + space + comment. Use arrows.\n\nWe need to produce virtual steps line by line: Start // begin, then Step: prepare padded array with 1 at ends, initialize DP table, loop over length of subarray, loops over start index, end index, compute max coins for each possible last burst in interval, update dp. Decision: if current coin > best? etc. Then End.\n\nLet's structure:\n\nStart\n→ Step 1: let m = nums.length\n→ Step 2: create padded array 'a' of size m+2, with a[0] = 1, a[m+1] = 1, and a[1..m] = nums[0..m-1] // pad boundaries\n→ Step 3: initialize 2D array dp of size (m+2) x (m+2) with zeros // dp[l][r] holds max coins for bursting balloons between l and r exclusive\n→ Step 4: for length from 1 to m // interval length\n    → Step 5: for left from 1 to m-length+1 // left bound of interval\n        → Step 6: set right = left + length - 1 // right bound\n        → Step 7: initialize best = 0 // best coins for this interval\n        → Step 8: for last from left to right // consider last balloon to burst\n            → Step 9: compute coins = dp[left][last-1] + a[left-1] * a[last] * a[right+1] + dp[last+1][right] // coins for bursting last last with left-1 and right+1 neighbors\n            → Step 10: if coins > best then best = coins // keep maximum\n        → Step 11: dp[left][right] = best // store best for interval\n→ Step 12: return dp[1][m] // maximum coins for whole array\n\nAdd decisions for comparisons. Provide End.\n\nLet's produce as virtual steps.\n\nAlso could include \"Decision:\" lines. For example Step 10 uses Decision: if coins > best? Yes → update. We'll use Decision structure.\n\nAlso maybe we want to illustrate nested loops with arrows and decisions.\n\nLet's format accordingly.\n\nAlso we need to ensure each line includes \"虛擬碼步驟\" plus comment. Let's produce lines like:\n\nStart // 程式開始執行\n→ Step 1: let n = nums.length // 取得氣球數量\n→ Step 2: create array a with size n+2, set a[0] = 1, a[n+1] = 1, copy nums into a[1..n] // 加入邊界1\n→ Step 3: initialize 2D array dp[n+2][n+2] with zeros // dp[l][r] 表示區間 (l,r) 之間最大硬幣\n→ Step 4: for length = 1 to n // 處理不同長度的子區間\n    → Step 5: for left = 1 to n - length + 1 // 設定子區間左端\n        → Step 6: set right = left + length - 1 // 子區間右端\n        → Step 7: best = 0 // 儲存目前區間最佳硬幣\n        → Step 8: for last = left to right // 逐個考慮最後一個被擊破的氣球\n            → Step 9: coins = dp[left][last-1] + a[left-1] * a[last] * a[right+1] + dp[last+1][right] // 計算此方案硬幣\n            → Decision: 如果 coins > best? // 比較是否為更佳方案\n                Yes → best = coins // 更新最佳硬幣\n        → Step 10: dp[left][right] = best // 記錄此區間最佳結果\n→ Step 11: return dp[1][n] // 回傳整體最大硬幣\nEnd // 程式執行結束\n\nWe need to ensure each line ends with comment. Use \"Decision:\" line as separate. Provide proper indentation? Not required but good.\n\nLet's ensure each line contains step + comment. Use \"→ Decision:\" line separately.\n\nThe format: \"虛擬碼步驟 // 解釋\". Eg \"→ Step 1: ... // ...\"\n\nDecision lines: \"→ Decision: ... // ...\". And \"Yes →\" or \"No →\".\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = nums.length // 取得氣球總數  \n→ Step 2: create array a with size n+2, set a[0] = 1, a[n+1] = 1, copy nums into a[1..n] // 加入兩端的 1 作為邊界  \n→ Step 3: initialize 2D array dp[n+2][n+2] with zeros // dp[l][r] 表示區間 (l,r) 之間最大可得硬幣  \n→ Step 4: for length = 1 to n // 逐長度處理所有子區間  \n  → Step 5: for left = 1 to n - length + 1 // 設定子區間左端  \n   → Step 6: set right = left + length - 1 // 子區間右端  \n   → Step 7: best = 0 // 儲存此區間目前最佳硬幣數  \n   → Step 8: for last = left to right // 逐個考慮最後被擊破的氣球  \n    → Step 9: coins = dp[left][last-1] + a[left-1] * a[last] * a[right+1] + dp[last+1][right] // 計算此策略得到的硬幣  \n    → Decision: 如果 coins > best? // 判斷是否比目前最佳更好  \n     Yes → best = coins // 更新最佳硬幣  \n   → Step 10: dp[left][right] = best // 記錄區間 (left,right) 的最大硬幣  \n→ Step 11: return dp[1][n] // 回傳整個氣球序列的最大硬幣總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def maxCoins(self, nums):\n        # 在前後加 1 方便計算\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n\n        # 遍歷所有長度\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                # i 為最後一個被戳破的氣球\n                best = 0\n                for i in range(left + 1, right):\n                    val = dp[left][i] + nums[left] * nums[i] * nums[right] + dp[i][right]\n                    if val > best:\n                        best = val\n                dp[left][right] = best\n        return dp[0][n - 1]\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支援以下格式：\n    1. 直接給出列表，例如 '[3,1,5,8]'\n    2. 變數賦值，例如 'nums = [3,1,5,8]'\n    \"\"\"\n    data = data.strip()\n    # 若包含 '='，取 '=' 之後的部分\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n    # 使用 eval 解析列表，確保只允許基本類型\n    try:\n        nums = eval(expr, {\"__builtins__\": None}, {})\n    except Exception:\n        # 若 eval 失敗，嘗試使用正則表達式提取整數\n        nums = list(map(int, re.findall(r'-?\\d+', expr)))\n    return nums\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    solution = Solution()\n    result = solution.maxCoins(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,1,5,8]",
          "expected_output": "167",
          "success": true,
          "output": "167"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode166.json",
    "problem_index_in_file": 0,
    "title": "Fraction to Recurring Decimal",
    "description_snippet": "Given two integers representing the numerator and denominator of a fraction, return the fraction in ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for the problem: fraction to string with repeating part parentheses. Need to produce line-by-line pseudocode with explanations. No actual code. Use Start, End, Decision: with arrows. Provide steps. Let's think algorithm: handle sign, absolute numerator/denominator, integer part = num / den, remainder = num % den. Build string. If remainder 0 -> return integer part string. Else add '.' and proceed. Use map remainder->position index in fraction part string. While remainder != 0, if remainder seen -> repeating part from position to end, wrap parentheses. Else store position, multiply remainder by 10, digit = remainder / den, remainder %= den, append digit. After loop return built string.\n\nNeed to handle negative: sign = '-' if (num<0) XOR (den<0) and num != 0. Use abs for further processing.\n\nLet's produce pseudocode lines. Use steps like:\n\nStart\n→ Step 1: Determine sign // ... \n→ Step 2: num_abs = abs(numerator) // ...\n→ Step 3: den_abs = abs(denominator)\n→ Step 4: integer_part = num_abs / den_abs // ...\n→ Step 5: remainder = num_abs % den_abs // ...\n→ Decision: remainder == 0? // ...\n    Yes → Step 6: return sign + integer_part as string\n    No → Step 7: result = sign + integer_part + '.' // ...\n→ Step 8: Create empty map remainder_positions // ...\n→ Step 9: fraction_part = empty string // ...\n→ Step 10: position = 0 // index in fraction_part // ...\n→ Decision: remainder != 0? // loop start\n    Yes → Step 11: If remainder in remainder_positions? // detect repeat\n        Yes → Step 12: start_repeat = remainder_positions[remainder] // index\n                 Step 13: non_repeat = fraction_part[0:start_repeat] // substring\n                 Step 14: repeat = fraction_part[start_repeat:] // substring\n                 Step 15: result = result + non_repeat + '(' + repeat + ')' // combine\n                 Step 16: return result // done\n        No → Step 17: remainder_positions[remainder] = position // record\n                 Step 18: remainder *= 10 // shift\n                 Step 19: digit = remainder / den_abs // integer digit\n                 Step 20: remainder = remainder % den_abs // new remainder\n                 Step 21: fraction_part += digit as string // append digit\n                 Step 22: position += 1 // increment position\n                 Step 23: Go back to Decision: remainder != 0? // continue loop\n    No → Step 24: // remainder became 0, finite decimal\n                Step 25: result = result + fraction_part // append fraction\n                Step 26: return result\nEnd\n\nNeed to ensure proper formatting. Use arrow lines. Also include comments. Use \"→\" arrow. For decision, indent with spaces and Yes/No arrows. Let's produce. Ensure each line has virtual code and comment. Use Start, End. Use Step numbering.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 判斷輸入分數是否為負數 // 確定輸出前綴符號  \n→ Step 2: num_abs ← abs(numerator) // 取分子絕對值  \n→ Step 3: den_abs ← abs(denominator) // 取分母絕對值  \n→ Step 4: integer_part ← num_abs / den_abs // 計算整數部分  \n→ Step 5: remainder ← num_abs % den_abs // 計算餘數  \n→ Decision: remainder == 0? // 是否為整數分數  \n  Yes → Step 6: return sign + integer_part as string // 直接輸出整數部分  \n  No → Step 7: result ← sign + integer_part + '.' // 開始構造小數部分  \n→ Step 8: remainder_positions ← empty map // 追蹤餘數位置以偵測循環  \n→ Step 9: fraction_part ← '' // 儲存小數位數  \n→ Step 10: position ← 0 // 小數位數索引  \n→ Decision: remainder ≠ 0? // 小數還沒結束，進入循環  \n  Yes → Step 11: 如果 remainder 在 remainder_positions? // 判斷是否重複  \n    Yes → Step 12: start_repeat ← remainder_positions[remainder] // 循環起始位置  \n      Step 13: non_repeat ← substring(fraction_part, 0, start_repeat) // 循環前位  \n      Step 14: repeat_part ← substring(fraction_part, start_repeat) // 循環位  \n      Step 15: result ← result + non_repeat + '(' + repeat_part + ')' // 加入括號  \n      Step 16: return result // 完成輸出  \n    No → Step 17: remainder_positions[remainder] ← position // 記錄餘數位置  \n      Step 18: remainder ← remainder × 10 // 進位到下一個小數位  \n      Step 19: digit ← remainder / den_abs // 取得當前小數位  \n      Step 20: remainder ← remainder % den_abs // 更新餘數  \n      Step 21: fraction_part ← fraction_part + digit as string // 加入小數位  \n      Step 22: position ← position + 1 // 索引往後移  \n      Step 23: 回到 Decision: remainder ≠ 0? // 繼續循環  \n  No → Step 24: // 小數結束，餘數為 0，為有限小數  \n    Step 25: result ← result + fraction_part // 加上所有小數位  \n    Step 26: return result // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n        if numerator == 0:\n            return \"0\"\n\n        res = []\n\n        # Handle sign\n        if (numerator < 0) ^ (denominator < 0):\n            res.append(\"-\")\n\n        num, den = abs(numerator), abs(denominator)\n\n        # Integer part\n        integer_part = num // den\n        res.append(str(integer_part))\n\n        remainder = num % den\n        if remainder == 0:\n            return \"\".join(res)\n\n        res.append(\".\")\n        seen = {}\n        while remainder != 0:\n            if remainder in seen:\n                idx = seen[remainder]\n                res.insert(idx, \"(\")\n                res.append(\")\")\n                break\n            seen[remainder] = len(res)\n            remainder *= 10\n            digit = remainder // den\n            res.append(str(digit))\n            remainder %= den\n\n        return \"\".join(res)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract integers from input like \"numerator = 1, denominator = 2\"\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        sys.exit(\"Invalid input\")\n    numerator, denominator = nums[0], nums[1]\n    solution = Solution()\n    result = solution.fractionToDecimal(numerator, denominator)\n    # Output with surrounding quotes as shown in examples\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numerator = 1, denominator = 2",
          "expected_output": "\"0.5\"",
          "success": true,
          "output": "\"0.5\""
        },
        {
          "example_index": 1,
          "input": "numerator = 2, denominator = 1",
          "expected_output": "\"2\"",
          "success": true,
          "output": "\"2\""
        },
        {
          "example_index": 2,
          "input": "numerator = 4, denominator = 333",
          "expected_output": "\"0.(012)\"",
          "success": true,
          "output": "\"0.(012)\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode30.json",
    "problem_index_in_file": 0,
    "title": "Substring with Concatenation of All Words",
    "description_snippet": "You are given a string s and an array of strings words. All the strings of words are of the same len...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code step-by-step algorithm for the problem: find starting indices of substring in s that is concatenation of all words in array words. Standard solution: sliding window with word frequency map. Complexity: O(n*m*wordLen). We'll produce pseudo code lines.\n\nLet's craft steps:\n\nStart\n→ Step: n ← len(s), m ← len(words), wordLen ← len(words[0]), totalLen ← m * wordLen\n→ Decision: If totalLen > n? // if substring longer than s\n    Yes → Step: Return empty list // nothing to find\n    No  →\n→ Step: Build frequency map targetCount from words\n→ Step: result ← empty list\n→ Step: For offset in 0..wordLen-1: // start at each possible remainder\n    → Step: left ← offset, right ← offset, currentCount ← empty map, formed ← 0\n    → Decision: While right + wordLen <= n? // slide window\n        No  → End inner while\n        Yes →\n            → Step: word ← s.substring(right, right+wordLen)\n            → Step: right ← right + wordLen\n            → Decision: If word in targetCount? // ignore others\n                Yes →\n                    → Step: currentCount[word] += 1\n                    → Decision: currentCount[word] <= targetCount[word]? // within limit\n                        Yes →\n                            → Step: formed += 1\n                        No  →\n                            → Decision: While currentCount[word] > targetCount[word]? // too many\n                                No → End loop\n                                Yes →\n                                    → Step: leftWord ← s.substring(left, left+wordLen)\n                                    → Step: left ← left + wordLen\n                                    → Decision: If leftWord == word?\n                                        Yes →\n                                            → Step: currentCount[word] -= 1\n                                            → Step: formed -= 1\n                                        No → // other word removed, no formed change\n                    → Decision: If formed == m? // all words matched\n                        Yes →\n                            → Step: result.append(left) // record start index\n                        No  →\n                No  →\n                    → Decision: While left < right? // reset window\n                        No → End loop\n                        Yes →\n                            → Step: leftWord ← s.substring(left, left+wordLen)\n                            → Step: left ← left + wordLen\n                            → Decision: If leftWord in targetCount? // reduce formed if counted\n                                Yes →\n                                    → Step: currentCount[leftWord] -= 1\n                                    → Step: formed -= 1\n            // loop continues\n→ Step: Return result\nEnd\n\nBut need to keep each line as single step with explanation. Might combine some steps but keep each line. Must ensure structure: Use arrows and Decision: etc.\n\nLet's craft step lines. We'll ensure each line includes the arrow. Use proper indentation for decision branches? The format example uses indentation for sub-steps. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: n ← len(s) // 取得主字串長度  \n→ Step: m ← len(words) // 取得單詞數量  \n→ Step: wordLen ← len(words[0]) // 所有單詞長度相同  \n→ Step: totalLen ← m * wordLen // 待搜尋子字串總長度  \n→ Decision: totalLen > n? // 子字串長度是否超過主字串  \n  Yes → Step: Return [] // 沒有符合條件的起點，結束  \n  No →  \n   → Step: targetCount ← {} // 建立單詞頻率表  \n    → Decision: For each w in words? // 填入頻率表  \n      Yes → targetCount[w] = targetCount.get(w, 0) + 1  \n      No → End for  \n    → Step: result ← [] // 儲存所有符合的起始索引  \n    → Decision: For offset in 0..wordLen-1? // 依 wordLen 循環多個起點  \n      Yes →  \n       → Step: left ← offset // 視窗左邊界  \n       → Step: right ← offset // 視窗右邊界  \n       → Step: currentCount ← {} // 目前視窗內單詞頻率  \n       → Step: formed ← 0 // 已符合頻率的單詞數  \n       → Decision: While right + wordLen <= n? // 右邊界不超過主字串  \n         Yes →  \n          → Step: word ← s.substring(right, right+wordLen) // 取下一個單詞長度區塊  \n          → Step: right ← right + wordLen // 移動右邊界  \n          → Decision: word in targetCount? // 只處理目標單詞  \n            Yes →  \n             → Step: currentCount[word] = currentCount.get(word, 0) + 1 // 更新頻率  \n             → Decision: currentCount[word] <= targetCount[word]? // 是否仍在合法範圍  \n               Yes →  \n                → Step: formed += 1 // 成功匹配一個單詞  \n                No →  \n                 → Decision: While currentCount[word] > targetCount[word]? // 超過頻率  \n                   No → End while  \n                  Yes →  \n                   → Step: leftWord ← s.substring(left, left+wordLen) // 左邊界單詞  \n                   → Step: left ← left + wordLen // 左邊界往右移  \n                   → Decision: leftWord == word? // 是否剔除的是多餘的那個單詞  \n                    Yes →  \n                     → Step: currentCount[word] -= 1  \n                      → Step: formed -= 1  \n                     No → // 其他單詞被移除，formed 不變  \n                     End if  \n                    End while  \n                    → Decision: formed == m? // 是否已匹配所有單詞  \n                     Yes →  \n                      → Step: result.append(left) // 記錄起始索引  \n                     No → // 尚未完成匹配  \n             No →  \n              → Decision: While left < right? // 清空視窗，恢復狀態  \n                No → End while  \n                Yes →  \n                 → Step: leftWord ← s.substring(left, left+wordLen)  \n                 → Step: left ← left + wordLen  \n                 → Decision: leftWord in targetCount? // 若為目標單詞，更新 formed  \n                   Yes →  \n                    → Step: currentCount[leftWord] -= 1  \n                     → Step: formed -= 1  \n                    No → // 其他單詞被移除，formed 不變  \n                   End if  \n                  End while  \n              End if  \n              End while  \n         End for  \n    → Step: Return result // 所有起始索引回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter, defaultdict\n\ndef findSubstring(s: str, words: list[str]) -> list[int]:\n    if not words:\n        return []\n    n = len(s)\n    k = len(words)\n    m = len(words[0])\n    total = k * m\n    if total > n:\n        return []\n\n    target = Counter(words)\n    result = []\n\n    for offset in range(m):\n        left = offset\n        right = offset\n        formed = 0\n        window = defaultdict(int)\n\n        while right + m <= n:\n            word = s[right:right + m]\n            right += m\n\n            if word in target:\n                window[word] += 1\n                if window[word] == target[word]:\n                    formed += 1\n\n                while window[word] > target[word]:\n                    left_word = s[left:left + m]\n                    left += m\n                    if left_word in target:\n                        if window[left_word] == target[left_word]:\n                            formed -= 1\n                        window[left_word] -= 1\n\n                if formed == k:\n                    result.append(left)\n            else:\n                # reset the window\n                window.clear()\n                formed = 0\n                left = right\n\n    return result\n\ndef parse_input(data: str):\n    \"\"\"Parse input string of the form: s = \"text\", words = [..]\"\"\"\n    s_match = re.search(r's\\s*=\\s*\"([^\"]*)\"', data)\n    words_match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not s_match or not words_match:\n        raise ValueError(\"Input format not recognized.\")\n    s = s_match.group(1)\n    words = ast.literal_eval(words_match.group(1))\n    return s, words\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        try:\n            s_val, words_val = parse_input(raw_input)\n        except Exception:\n            # fallback: try eval on whole input if it's a tuple like (\"...\", [\"...\"])\n            try:\n                s_val, words_val = ast.literal_eval(raw_input)\n            except Exception:\n                s_val, words_val = \"\", []\n        result = findSubstring(s_val, words_val)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]",
          "expected_output": "[0,9]",
          "success": true,
          "output": "[0, 9]"
        },
        {
          "example_index": 1,
          "input": "s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]",
          "expected_output": "[6,9,12]",
          "success": true,
          "output": "[6, 9, 12]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode368.json",
    "problem_index_in_file": 0,
    "title": "Largest Divisible Subset",
    "description_snippet": "Given a set of distinct positive integers nums, return the largest subset answer such that every pai...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: largest divisible subset. Typical DP: sort nums, dp[i] size of largest subset ending at i, prev pointer. Then reconstruct.\n\nWe need to output step-by-step virtual code with explanations. Must not output actual code, just virtual code. Use arrows. Let's structure:\n\nStart\n→ Sort nums ascending\n→ Initialize arrays dp and prev\n→ For i from 0 to n-1\n   → For j from 0 to i-1\n        → Decision: if nums[i] % nums[j] == 0 ?\n           Yes → Update dp[i], prev[i]\n→ After loops, find index maxIndex where dp[max] largest\n→ Build result by backtracking from maxIndex using prev\n→ End\n\nAlso may include explanation about choosing any solution. Ensure each line has comment.\n\nLet's write. Use Start and End. Use Decision lines with Yes/No. Provide explanation for each. Use bullet lines. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 將輸入陣列 nums 依升序排列 // 方便後續除法檢查\n→ Step 2: 建立 dp[0..n-1]，初值皆為 1 // 每個位置至少能成為長度 1 的子集\n→ Step 3: 建立 prev[0..n-1]，初值皆為 -1 // 用於追蹤子集前一個元素\n→ Step 4: 對 i 從 0 到 n-1 迭代 // 外層迴圈遍歷每個數字\n    → Decision: 對 j 從 0 到 i-1 迭代？ // 檢查之前的數字\n        Yes → Step 5: 若 nums[i] % nums[j] == 0？ // 判斷能否互相整除\n            Yes → Step 6: 若 dp[j] + 1 > dp[i]？ // 找到更長的子集\n                Yes → Step 7: 更新 dp[i] = dp[j] + 1 // 保存新的最大長度\n                Yes → Step 8: 更新 prev[i] = j // 記錄前一個元素索引\n                No  → // dp[i] 已經是最長，無需改動\n            No  → // nums[i] 不能被 nums[j] 整除，忽略此對\n        No  → // j 已走完，回到 Step 4 的下一個 i\n→ Step 9: 找到最大 dp 值的索引 maxIndex // 代表最大的子集結束位置\n→ Step 10: 建立空陣列 result // 用於儲存最終子集\n→ Step 11: 從 maxIndex 開始，使用 prev 追蹤並加入 result\n    → Decision: maxIndex != -1？ // 確保存在有效子集\n        Yes → Step 12: 將 nums[maxIndex] 加入 result // 加入當前元素\n        Yes → Step 13: 將 maxIndex 更新為 prev[maxIndex] // 移至前一個元素\n        No  → // 已追蹤完畢\n→ Step 14: 逆轉 result 以得到遞增順序的子集 // 追蹤時順序相反\n→ End // 程式執行結束（返回 result）",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def largestDivisibleSubset(self, nums):\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        dp = [1] * n\n        prev = [-1] * n\n        max_index = 0\n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n\n        res = []\n        while max_index >= 0:\n            res.append(nums[max_index])\n            max_index = prev[max_index]\n        return res[::-1]\n\ndef parse_input(raw):\n    raw = raw.strip()\n    # Try to extract the part after '=' if present\n    if '=' in raw:\n        _, rhs = raw.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = raw\n    # Use a regex to find a list literal\n    match = re.search(r'\\[.*\\]', rhs)\n    if match:\n        list_str = match.group(0)\n        try:\n            nums = eval(list_str, {\"__builtins__\": None}, {})\n            if isinstance(nums, list):\n                return nums\n        except Exception:\n            pass\n    return []\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_input(data)\n    solution = Solution()\n    result = solution.largestDivisibleSubset(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,4,8]",
          "expected_output": "[1,2,4,8]",
          "success": true,
          "output": "[1, 2, 4, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode458.json",
    "problem_index_in_file": 0,
    "title": "Poor Pigs",
    "description_snippet": "There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out wh...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for solving the problem. Should outline algorithm: number of tests = minutesToTest/minutesToDie + 1? Actually number of rounds = floor(minutesToTest/minutesToDie). If we have R rounds, each pig can have 2^R possible states? Actually pig can die in one of R rounds or survive all, giving R+1 states? Wait: The pig can die at each round or survive all, but once dead can't test further. We can use base (rounds+1) representation. Minimum pigs = ceil(log_{R+1} buckets). Compute number of rounds = minutesToTest / minutesToDie (integer division). states = rounds + 1. pigs = ceil(log(buckets)/log(states)). Edge cases. Provide virtual code lines.\n\nWe need to output virtual code lines with explanation each line. Use Start, End, Decision.\n\nLet's produce steps: Input variables, compute rounds, compute states, if states==1? then need infinite? but not. Then compute pigs via loop to find minimal integer such that states^pigs >= buckets. Use while loop.\n\nOk produce virtual code.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入 buckets, minutesToDie, minutesToTest // 取得桶數、死亡時間與總測試時間  \n→ Decision: 如果 minutesToDie <= 0? // 檢查死亡時間合法性  \n  Yes → Step 2: 輸出錯誤訊息 // 若非法則結束  \n  No  → Step 3: 進行後續計算 // 正常流程  \n\nStep 3: 計算可進行的測試回合數 R = minutesToTest / minutesToDie // 每回合結束後才能再測試  \n→ Decision: 如果 R == 0? // 無法進行任何回合  \n  Yes → Step 4: 輸出 0 // 只能直接判定無法測試  \n  No  → Step 5: 繼續  \n\nStep 5: 計算每隻豬可辨識的狀態數 S = R + 1 // 死亡於第 i 回合或全部存活共 R+1 種可能  \n\nStep 6: 若 buckets == 0? // 無桶需要測試  \n  Yes → Step 7: 輸出 0 // 不需要豬  \n  No  → Step 8: 繼續  \n\nStep 8: 初始化 pigs = 0 // 目前已分配的豬數  \nStep 9: 初始化 currentPower = 1 // S^pigs 的值  \n\n→ Decision: 當 currentPower < buckets? // 尚未足以辨識所有桶  \n  Yes → Step 10: pigs = pigs + 1 // 增加一隻豬  \n    Step 11: currentPower = currentPower * S // 更新可辨識桶數  \n    → 回到 Decision  \n  No  → Step 12: 輸出 pigs // 已足夠的豬數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n        \"\"\"\n        Calculate the minimal number of pigs needed to identify the poisonous bucket.\n        Each pig can produce (rounds + 1) distinct states:\n        - die in round 1, die in round 2, ..., die in round R, or survive all rounds.\n        Number of rounds R is the integer division of the total testing time by the time\n        a pig takes to die.\n        \"\"\"\n        # Number of complete test rounds we can run\n        rounds = minutesToTest // minutesToDie\n        # Each pig can be in one of (rounds + 1) states\n        states = rounds + 1\n\n        # Edge case: if there's only one bucket, no pig is needed\n        if buckets <= 1:\n            return 0\n\n        pigs = 0\n        # Increase number of pigs until the total number of distinguishable\n        # combinations (states ** pigs) is at least the number of buckets\n        while states ** pigs < buckets:\n            pigs += 1\n        return pigs\n\ndef parse_input(input_text: str):\n    \"\"\"\n    Parse a string containing the three parameters in the format:\n    'buckets = X, minutesToDie = Y, minutesToTest = Z'\n    and return them as integers.\n    \"\"\"\n    buckets = int(re.search(r'buckets\\s*=\\s*(-?\\d+)', input_text).group(1))\n    minutesToDie = int(re.search(r'minutesToDie\\s*=\\s*(-?\\d+)', input_text).group(1))\n    minutesToTest = int(re.search(r'minutesToTest\\s*=\\s*(-?\\d+)', input_text).group(1))\n    return buckets, minutesToDie, minutesToTest\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    data = sys.stdin.read()\n    # Extract the three required integers\n    buckets, minutesToDie, minutesToTest = parse_input(data)\n\n    # Create a Solution instance and compute the answer\n    solution = Solution()\n    result = solution.poorPigs(buckets, minutesToDie, minutesToTest)\n\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 15",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "buckets = 4, minutesToDie = 15, minutesToTest = 30",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode49.json",
    "problem_index_in_file": 0,
    "title": "Group Anagrams",
    "description_snippet": "Given an array of strings strs, group the anagrams together. You can return the answer in any order....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for grouping anagrams. Use Start, End, Decision, etc. Each line: 虛擬碼步驟 + // 解釋. Use arrow → and indent decisions. Should be step-by-step. No actual code. Let's produce.\n\nStructure:\n\nStart\n→ Step 1: Initialize empty map hash->list // mapping sorted string to group\n→ For each string s in strs // iterate input\n    → Step 2: Compute key by sorting characters of s // sort to get canonical form\n    → Decision: If key exists in map? // check\n        Yes → Step 3: Append s to map[key] // add to existing group\n        No  → Step 4: Create new list with s and put into map[key] // new group\n→ Step 5: Collect all groups from map.values() into result list // gather groups\nEnd\n\nAlso we might need to convert result to array. That's fine.\n\nWe should produce each line with the format.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 map // 用來儲存每個排序後的字串對應的單詞列表\n→ Step 2: 循環遍歷輸入陣列 strs // 逐個處理每個字串\n    → Step 3: 取得字串 s 的字母排序後的新字串 key // 這是判定字母組合相同的標識\n    → Decision: key 是否已存在於 map? // 判斷是否已有同類型的 anagram 組\n        Yes → Step 4: 把 s 加入 map[key] 的列表 // 已有相同 key，加入現有組\n        No  → Step 5: 建立新列表 [s] 並賦值給 map[key] // 新 key，創建新組\n→ Step 6: 取得 map 中所有列表作為最終結果 // 把每個 anagram 組收集起來\nEnd // 程式執行結束\n\nBut must maintain arrow arrow for decisions? The example uses nested arrows:\n\nDecision: If num > 0? \n    Yes → Step ...\n    No → Decision...\n\nOur lines above: \"Step 3\" computing key; decision after that. But we might better structure:\n\nStep 3: Compute key\n→ Decision: key exists? \n    Yes → Step 4: append\n    No → Step 5: new\n\nBut also Step 2 and Step 3 might be separate lines.\n\nLet's structure with proper indentation:\n\nStart\n→ Step 1: 初始化空哈希表 map // 用來儲存排序後字串到其 anagram 組\n→ Step 2: 遍歷輸入陣列 strs // 逐個處理每個字串\n    → Step 3: 取得字串 s 的排序後 key // 用於判斷 anagram\n    → Decision: key 已在 map? // 判斷是否已有相同組\n        Yes → Step 4: 把 s 加入 map[key] // 追加到現有組\n        No  → Step 5: map[key] = [s] // 建立新組\n→ Step 6: 把 map 的所有值收集到結果列表 // 取得所有 anagram 組\nEnd\n\nWe need to ensure each line ends with // 解釋. Use arrow lines for decisions, indents. Each line must have \"虛擬碼步驟\" plus // 解釋. Good.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 map // 用來儲存排序後字串對應的單詞列表  \n→ Step 2: 遍歷輸入陣列 strs // 逐個處理每個字串  \n    → Step 3: 取得字串 s 的排序後 key // 用於判斷 anagram  \n    → Decision: key 已在 map? // 判斷是否已有相同組  \n        Yes → Step 4: 把 s 加入 map[key] // 追加到現有組  \n        No  → Step 5: map[key] = [s] // 建立新組  \n→ Step 6: 把 map 的所有值收集到結果列表 // 取得所有 anagram 組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        Groups anagrams together.\n\n        :param strs: List[str]\n        :return: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))          # 使用排序後的字元序列作為 key\n            anagrams[key].append(s)         # 將字串加入對應的分組\n        return list(anagrams.values())\n\ndef main():\n    # 讀取整個輸入\n    raw = sys.stdin.read().strip()\n    if not raw:\n        print(\"[]\")\n        return\n\n    # 如果輸入中包含 'strs =', 只取等號右側\n    if '=' in raw:\n        raw = raw.split('=', 1)[1].strip()\n\n    # 解析成列表\n    try:\n        strs = ast.literal_eval(raw)\n    except Exception as e:\n        # 無法解析時直接輸出空列表\n        print(\"[]\")\n        return\n\n    # 確保輸入為列表\n    if not isinstance(strs, list):\n        print(\"[]\")\n        return\n\n    solution = Solution()\n    result = solution.groupAnagrams(strs)\n\n    # 以 JSON 格式輸出，使用雙引號\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]",
          "success": true,
          "output": "[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]"
        },
        {
          "example_index": 1,
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "success": true,
          "output": "[[\"\"]]"
        },
        {
          "example_index": 2,
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[[\"a\"]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode488.json",
    "problem_index_in_file": 0,
    "title": "Zuma Game",
    "description_snippet": "You are playing a variation of the game Zuma. \nIn this variation of Zuma, there is a single row of c...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: find minimal insertions to clear board. It's like Zuma game. This is essentially the same as Leetcode 488 Zuma Game. Approach: DFS with memoization/backtracking, track board string and hand counts. For each possible insertion point and color from hand that has count>0, try insertion, simulate elimination, recursively compute minimal moves. Use BFS or DFS with pruning. Need to produce virtual code steps, not actual code. Steps include: define recursive function solve(board, handCount). If board empty return 0. If no hand left return inf. For each i from 0 to len(board), for each color in handCount>0: if color matches board[i] or i==len(board): maybe consider insertion. Insert ball, compress: find consecutive same color block around insertion, if block length+1>=3 remove, then collapse. Recurse. Keep minimal moves +1. Use memo key: board + sorted hand counts. Return minimal or -1 if INF.\n\nWe need to produce lines with arrows, Start, End, Decision. Provide each step. Must be clear. Provide explanation after each line.\n\nLet's craft.\n\nStart\n→ Step 1: Define function DFS(board, handCounts) // recursive helper\n→ Decision: 若 board 為空？ // check if cleared\n    Yes → Step 2: 回傳 0 // no more moves needed\n    No  → Decision: 若 handCounts 全為 0？ // no balls left\n        Yes → Step 3: 回傳 INF // 代表無法完成\n        No  → Step 4: 初始化最小步驟為 INF // 用於比較\n→ Step 5: 迭代插入位置 i 從 0 到 len(board) // 循環所有可能位置\n→ Step 6: 取得插入前的前後字符\n→ Decision: 若 i>0 且 board[i-1]==board[i]？ // 若相鄰相同顏色，則插入只對一個連續區塊有效\n    Yes → Step 7: 為此區塊只嘗試一次插入\n    No  → Step 8: 為每個顏色 c 在 handCounts 內進行嘗試\n→ Step 9: 若 handCounts[c]==0，跳過 // 無此顏色\n→ Step 10: 建立 newBoard = board[:i] + c + board[i:] // 插入新球\n→ Step 11: 執行壓縮函式 collapse(newBoard) // 自動消除連續三個以上相同顏色\n→ Step 12: newHandCounts = handCounts ; newHandCounts[c] -=1 // 使用一顆球\n→ Step 13: 子遞歸 result = DFS(newBoard, newHandCounts) // 深度優先遞歸\n→ Decision: 若 result != INF，則 minSteps = min(minSteps, result+1) // 加上本次插入\n→ Step 14: 回傳 minSteps // 從所有位置取最小\n→ End // 主程式結束\n\nBut need to incorporate memoization: Step 15: 在 DFS 開頭，檢查 memo for key (board, handCounts) // 若已計算，直接回傳\n\nWe need to produce each line separately with arrow or decision. Let's produce. Ensure each line ends with // explanation.\n\nWe should also include collapse function definition steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義遞迴函式 DFS(board, handCount) // 以當前棋盤與手牌計數為輸入  \n→ Decision: 若 board 為空？ // 判斷是否已經清空所有球  \n    Yes → Step 2: 回傳 0 // 無需再插入，達成勝利  \n    No → Decision: 若 handCount 皆為 0？ // 無球可用  \n        Yes → Step 3: 回傳 INF // 代表此路徑無法完成  \n        No → Step 4: 初始化 minStep 為 INF // 用於儲存目前搜尋到的最小步數  \n→ Decision: 若 memo 已存有 key (board, handCount)？ // 檢查記錄的結果  \n    Yes → Step 5: 回傳 memo[key] // 直接使用已計算的值  \n    No → Step 6: 進行以下搜尋，搜尋完成後將結果存入 memo  \n→ Step 7: 迭代所有可能插入位置 i 從 0 到 len(board) // 包含兩端  \n→ Step 8: 取得 colorList = list(handCount.keys()) // 可插入的顏色  \n→ Step 9: 迭代每個顏色 c 在 colorList  \n→ Decision: 若 handCount[c] == 0？ // 無此顏色可用  \n    Yes → Step 10: 跳過此顏色  \n    No → Step 11: 若 i > 0 且 board[i-1] == board[i] 且 board[i] == c？ // 同色連續區塊  \n        Yes → Decision: 是否已處理過此區塊？  \n            Yes → Step 12: 跳過，避免重複嘗試  \n            No → Step 13: 設置 processedFlag = True  \n        No → Step 14: 設置 processedFlag = False  \n→ Step 15: 若 processedFlag == False，執行以下步驟（確保每個位置只嘗試一次）  \n→ Step 16: 建立 newBoard = board[:i] + c + board[i:] // 在位置 i 插入顏色 c  \n→ Step 17: 執行 collapse(newBoard) → newBoardAfter = collapse(newBoard) // 自動消除三個以上連續相同顏色，並重複直到無法再消除  \n→ Step 18: newHandCount = handCount.copy() ; newHandCount[c] -= 1 // 使用一顆球  \n→ Step 19: 子遞歸 result = DFS(newBoardAfter, newHandCount) // 重新遞歸計算  \n→ Decision: 若 result != INF？ // 本路徑可達成清空  \n    Yes → Step 20: minStep = min(minStep, result + 1) // 加上此次插入的步數  \n    No → Step 21: 跳過，此插入無效  \n→ Step 22: 迴圈結束後，將 memo[key] = minStep  \n→ Step 23: 回傳 minStep // 取得本階段的最小步數  \n→ End // 程式結束  \n\n// collapse 函式（在 DFS 內部或獨立）  \nStart collapse(board) // 開始壓縮過程  \n→ Step 1: 變數 changed = True  \n→ Decision: while changed？ // 只要有改變就重複  \n    Yes → Step 2: changed = False  \n    → Step 3: 變數 i = 0  \n    → Decision: while i < len(board)？  \n        Yes → Step 4: 變數 j = i  \n        → Step 5: 迴圈 j++ 直到 j < len(board) 且 board[j] == board[i] // 找到同色區塊  \n        → Decision: 若 j - i >= 3？ // 至少三個連續相同顏色  \n            Yes → Step 6: board = board[:i] + board[j:] // 刪除該區塊  \n            → Step 7: changed = True  \n            → Step 8: i = 0 // 從頭重新檢查，因為可能產生新的連續區塊  \n            No  → Step 9: i = j // 移動到下一個不同顏色  \n        No → Step 10: 回傳 board // 無更多可消除區塊  \n→ End collapse // 壓縮完成  \n\n// 主程式調用  \nStart // 程式進入主流程  \n→ Step 1: 讀入 board 與 hand 字串  \n→ Step 2: 將 hand 轉換為 handCount dict（鍵為顏色，值為數量）  \n→ Step 3: 呼叫 result = DFS(board, handCount)  \n→ Decision: 若 result == INF？  \n    Yes → Step 4: 輸出 -1 // 無法清空  \n    No  → Step 5: 輸出 result // 最小插入數  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef main():\n    data = sys.stdin.read()\n    # 先嘗試從輸入中抓取兩個被雙引號包住的字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        board, hand = matches[0], matches[1]\n    else:\n        # 若格式不符，直接把兩行文字當作 board 與 hand\n        lines = data.strip().splitlines()\n        board = lines[0].strip() if lines else \"\"\n        hand = lines[1].strip() if len(lines) > 1 else \"\"\n\n    hand_count = Counter(hand)\n    INF = 10**9\n    memo = {}\n\n    # 自動消除連續三個以上相同顏色的球\n    def collapse(s: str) -> str:\n        i = 0\n        while i < len(s):\n            j = i\n            while j + 1 < len(s) and s[j + 1] == s[i]:\n                j += 1\n            if j - i + 1 >= 3:\n                s = s[:i] + s[j + 1 :]\n                i = 0          # 重新從頭檢查，因為可能產生新的連續區塊\n            else:\n                i = j + 1\n        return s\n\n    # 深度優先搜尋，回傳最小插入步數；若無法完成則回傳 INF\n    def dfs(cur_board: str, cur_hand: Counter) -> int:\n        if not cur_board:\n            return 0\n        key = (cur_board, tuple(sorted(cur_hand.items())))\n        if key in memo:\n            return memo[key]\n\n        best = INF\n        n = len(cur_board)\n\n        # 嘗試在每個位置插入手牌中的每一顏色\n        for pos in range(n + 1):\n            for color in list(cur_hand.keys()):\n                if cur_hand[color] == 0:\n                    continue\n                # 若左邊已經是相同顏色，跳過以避免重複嘗試\n                if pos > 0 and cur_board[pos - 1] == color:\n                    continue\n\n                # 進行插入\n                new_board = cur_board[:pos] + color + cur_board[pos:]\n                collapsed = collapse(new_board)\n\n                new_hand = cur_hand.copy()\n                new_hand[color] -= 1\n                if new_hand[color] == 0:\n                    del new_hand[color]\n\n                sub = dfs(collapsed, new_hand)\n                if sub != INF:\n                    best = min(best, sub + 1)\n\n        memo[key] = best\n        return best\n\n    result = dfs(board, hand_count)\n    print(-1 if result >= INF else result)\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(10000)\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode442.json",
    "problem_index_in_file": 0,
    "title": "Find All Duplicates in an Array",
    "description_snippet": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and e...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: find duplicates in array where each appears at most twice, return list of elements that appear twice. Constraints: O(n) time, O(1) extra space excluding output.\n\nTypical solution: use the array indices as hash: for each num, index = abs(num)-1; if nums[index] < 0, duplicate; else make nums[index] negative.\n\nVirtual code steps should reflect that.\n\nWe must produce line by line, with arrow \"→\" or \"Start\" \"End\". Each line has virtual code step plus // explanation.\n\nLet's craft.\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 result = [] // 用於存放重複元素\n→ Step 2: 迭代遍歷 nums 並使用索引 i 從 0 到 n-1 // 遍歷整個陣列\n→ Decision: 當 abs(nums[i]) - 1 位置的值是否已經為負? // 判斷是否已訪問過該值\n    Yes → Step 3: 複製 nums[i] 的絕對值到 result // 已經是負數，表示此數已重複\n    No  → Step 4: 將 nums[abs(nums[i]) - 1] 取負值 // 標記此數已被訪問\nEnd // 程式執行結束\n\nBut we need to ensure each line has arrow \"→\". The decisions: Use \"Decision:\" and inside we show Yes → etc. Also we might need to show that after loop we return result. So maybe Step 5: Return result // 輸出結果\n\nBut maybe include Step 5 inside the loop? Actually after loop.\n\nThus structure:\n\nStart\n→ Step 1: 初始化 result 為空列表 // 用於存放重複數字\n→ Step 2: 對於 i 從 0 到 nums.length-1 做以下步驟 // 開始遍歷\n    → Decision: 如果 nums[abs(nums[i]) - 1] 已經是負數? // 判斷此數字是否已標記\n        Yes → Step 3: result.append(abs(nums[i])) // 已重複，加入結果\n        No  → Step 4: nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] // 標記已訪問\n→ Step 5: 返回 result // 輸出所有重複元素\nEnd\n\nWe need to include all arrow lines with \"→\" and decisions.\n\nAlso we might need to include \"Start\" and \"End\" lines. Ensure each line has virtual code step + // explanation.\n\nMake sure no actual code, just virtual steps.\n\nLet's produce.\n\nNote: The decision inside loops, we might use indentation but keep format consistent. Use \"Decision:\" lines with nested \"Yes →\" and \"No →\". Also the Step numbers incremental.\n\nWe'll provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用於存放所有重複的數字  \n→ Step 2: 對於 i 從 0 到 nums.length-1 做以下步驟 // 開始遍歷整個陣列  \n    → Decision: 如果 nums[abs(nums[i]) - 1] 已經是負數? // 判斷該數字是否已被標記  \n        Yes → Step 3: result.append(abs(nums[i])) // 已標記，表示此數已重複，加入結果  \n        No  → Step 4: nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1] // 把對應位置的值取負，標記已訪問  \n→ Step 5: 返回 result // 將所有重複的數字輸出  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef findDuplicates(nums):\n    \"\"\"\n    找出 nums 中所有出現兩次的數字。\n    使用「把對應索引位置取負」的技巧，時間 O(n)，空間 O(1)（不計輸出）。\n    \"\"\"\n    res = []\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] < 0:\n            res.append(abs(num))\n        else:\n            nums[index] = -nums[index]\n    return res\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 找出第一個 '[' 開始的位置，並取得完整的列表字串\n    start = data.find('[')\n    if start == -1:\n        nums = []\n    else:\n        end = data.find(']', start)\n        nums_str = data[start:end+1]\n        nums = ast.literal_eval(nums_str)  # 安全解析字面量\n\n    # 呼叫核心演算法並輸出結果\n    result = findDuplicates(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[2,3]",
          "success": true,
          "output": "[2, 3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,2]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode146.json",
    "problem_index_in_file": 0,
    "title": "LRU Cache",
    "description_snippet": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplemen...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanations. It's for design of LRU cache. We should outline initialization, get, put, internal data structures. Use Start, Decision, etc. Provide each line.\n\nWe need to reflect O(1) operations: using a hashmap for key->node, and a doubly linked list for usage order. We'll provide steps: create Node, doubly linked list, map, capacity. In get: check map, if not exist return -1; else move node to front, return value. In put: if key exists, update value and move to front; else create new node, add to front; add to map; if size > capacity, remove tail, delete from map.\n\nWe'll produce virtual steps. We must not output actual code, just pseudo steps.\n\nWe need to follow format: each line: `虛擬碼步驟 // 解釋`. Use arrow `→` etc.\n\nLet's produce.\n\nWe might separate the overall algorithm into phases: initialization, get, put. Each with steps.\n\nAlso include decisions like \"if key exists\" etc.\n\nLet's start: `Start // 程式開始執行`. Then initialization of class.\n\nWe can show steps:\n\n`→ Initialize LRUCache(capacity)` etc.\n\nBetter to structure: The overall program: define LRUCache class with constructor, get, put. We'll list steps within each.\n\nBut the requirement: \"逐行地產生對應的虛擬碼\" So each line is one step. We'll show steps for constructor, get, put.\n\nWe may include nested decision branches.\n\nLet's produce lines:\n\n1 Start\n2 Initialize class with capacity\n3 Create hash map: key->node\n4 Create doubly linked list with dummy head and tail\n5 Set size to 0\nEnd constructor.\n\nBut we can break.\n\nLet's create:\n\nStart // 程式開始執行\n\n→ Step: 建立 LRUCache 類別實例 // 初始化類別\n\n→ Step: 儲存 capacity // 存入容量限制\n\n→ Step: 建立 HashMap keyToNode // 用於 O(1) 取值\n\n→ Step: 建立雙向鏈表 head, tail (dummy nodes) // 方便插入/刪除\n\n→ Step: 連接 head → tail // 初始空表\n\n→ Step: size ← 0 // 記錄目前元素數量\n\nEnd // 建構完成\n\nThen get method:\n\n→ Step: Define get(key) // 方法入口\n\n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否存在\n\n    Yes → Step: node ← keyToNode[key] // 取得節點\n\n    → Step: Move node 到 head (最前) // 更新最近使用\n\n    → Step: Return node.value // 返回對應值\n\n    No  → Step: Return -1 // 鍵不存在\n\nThen put method:\n\n→ Step: Define put(key, value) // 方法入口\n\n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否已存在\n\n    Yes → Step: node ← keyToNode[key] // 取得節點\n\n    → Step: node.value ← value // 更新值\n\n    → Step: Move node 到 head // 更新最近使用\n\n    No  → Step: Create new node with key, value // 新節點\n\n        → Step: Insert node after head // 加入最前\n\n        → Step: keyToNode[key] ← node // 加入 map\n\n        → Step: size ← size + 1 // 增加計數\n\n        → Decision: 若 size > capacity? // 檢查是否超過容量\n\n            Yes → Step: tailPrev ← tail.prev // 取最舊節點\n\n            → Step: Remove tailPrev from list // 刪除節點\n\n            → Step: Remove tailPrev.key from keyToNode // 從 map 刪除\n\n            → Step: size ← size - 1 // 重新計數\n\n            No  → End // 仍在容量內\n\nEnd // 方法結束\n\nWe need to include all lines. We'll use `Start`, `End` for methods maybe.\n\nBut requirement: \"逐行輸出\" each line with `虛擬碼步驟 // 解釋`. So each line we output. Let's produce them.\n\nEnsure we use `→` arrow for steps, and `Decision:` for if statements, with nested branches Yes → ... No → ... etc.\n\nAlso we must maintain consistent formatting: no actual code.\n\nWe'll output.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: 建立 LRUCache 類別實例 // 初始化類別  \n→ Step: 儲存 capacity 值 // 記錄容量上限  \n→ Step: 建立 HashMap keyToNode // 用於 O(1) 取得節點  \n→ Step: 建立雙向鏈表 dummy head 與 dummy tail // 方便插入與刪除  \n→ Step: 連接 head → tail // 初始空表  \n→ Step: size ← 0 // 記錄目前元素數量  \nEnd // 建構完成  \n\n// ==========================  \n// get 方法  \n// ==========================  \nStart // get 方法開始執行  \n→ Step: 定義 get(key) // 方法入口  \n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否存在  \n    Yes → Step: node ← keyToNode[key] // 取得節點  \n    → Step: Move node 至 head（最前） // 更新最近使用  \n    → Step: Return node.value // 返回對應值  \n    No  → Step: Return -1 // 鍵不存在  \nEnd // get 方法結束  \n\n// ==========================  \n// put 方法  \n// ==========================  \nStart // put 方法開始執行  \n→ Step: 定義 put(key, value) // 方法入口  \n→ Decision: 若 key 存於 keyToNode? // 檢查鍵是否已存在  \n    Yes → Step: node ← keyToNode[key] // 取得節點  \n    → Step: node.value ← value // 更新值  \n    → Step: Move node 至 head（最前） // 更新最近使用  \n    No  → Step: 創建新節點 node(key, value) // 新節點  \n        → Step: Insert node 之後 head // 加入最前  \n        → Step: keyToNode[key] ← node // 加入 map  \n        → Step: size ← size + 1 // 计数增一  \n        → Decision: 若 size > capacity? // 檢查是否超過容量  \n            Yes → Step: tailPrev ← tail.prev // 取得最舊節點  \n            → Step: Remove tailPrev 從雙向鏈表 // 刪除節點  \n            → Step: Remove tailPrev.key 從 keyToNode // 從 map 刪除  \n            → Step: size ← size - 1 // 计数减一  \n            No  → End // 仍在容量內  \n        No  → End // 仍在容量內  \nEnd // put 方法結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import OrderedDict\n\nclass LRUCache:\n    \"\"\"Least Recently Used (LRU) cache implementation.\"\"\"\n    def __init__(self, capacity: int):\n        # OrderedDict keeps the insertion order; newest items will be moved to the end.\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        \"\"\"Return the value of the key if present, otherwise -1.\n        Move the key to the end to mark it as recently used.\"\"\"\n        if key not in self.cache:\n            return -1\n        value = self.cache.pop(key)\n        self.cache[key] = value  # re-insert to end\n        return value\n\n    def put(self, key: int, value: int) -> None:\n        \"\"\"Insert or update the key with the given value.\n        If capacity exceeded, evict the least recently used item.\"\"\"\n        if key in self.cache:\n            self.cache.pop(key)          # remove old entry\n        self.cache[key] = value         # insert at end (most recent)\n        if len(self.cache) > self.capacity:\n            self.cache.popitem(last=False)  # remove LRU (first item)\n\ndef main() -> None:\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n    # Split the input into two parts: operations and arguments\n    parts = raw.split('],', 1)\n    ops_part = parts[0] + ']'        # close the first list\n    args_part = parts[1]            # already a list of lists\n    ops = ast.literal_eval(ops_part)\n    args = ast.literal_eval(args_part)\n\n    cache = None\n    results = [None]  # constructor yields null\n\n    for i in range(1, len(ops)):\n        op = ops[i]\n        arg = args[i]\n        if op == 'put':\n            cache.put(*arg)\n            results.append(None)\n        elif op == 'get':\n            val = cache.get(*arg)\n            results.append(val)\n\n    # Use json.dumps to produce 'null' for None\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, null, -1, 3, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpx76fkdz5.py\", line 59, in <module>\n    main()\n  File \"/tmp/tmpx76fkdz5.py\", line 49, in main\n    cache.put(*arg)\n    ^^^^^^^^^\nAttributeError: 'NoneType' object has no attribute 'put'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode9.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Number",
    "description_snippet": "Given an integer x, return true if x is a palindrome, and false otherwise....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step: start, input integer x, decision: if x is negative? then false. Then maybe reverse digits? Common algorithm: convert to string, compare with reverse; or numeric reverse until halfway.\n\nLet's produce simple algorithm: if x < 0 => false; else compute reversed number using integer math and compare with original.\n\nSteps:\nStart\n→ Input x\n→ Decision: if x < 0? -> false\nYes → Return false\nNo → Compute reversed = 0, temp = x\n→ Decision: while temp > 0? -> continue loop\n    → Step: reversed = reversed * 10 + temp % 10\n    → temp = temp / 10\n→ End while\n→ Decision: reversed == x? -> true else false\n\nWe need virtual code with arrows and decisions. Let's produce lines:\n\nStart // 程式開始執行\n→ Input: x // 取得輸入整數\n→ Decision: 如果 x < 0? // 負數不是回文\n    Yes → Return false // 直接返回\n    No  → Step 1: 初始化 reversed = 0, temp = x // 準備反轉\n→ Decision: 迴圈條件 temp > 0? // 反轉過程\n    Yes → Step 2: reversed = reversed * 10 + temp % 10 // 取最後一位加到 reversed\n    Yes → Step 3: temp = temp / 10 // 移除已處理的位數\n    No  → Decision: reversed == x? // 完成反轉後比較\n        Yes → Return true // 回文\n        No  → Return false // 非回文\nEnd // 程式結束\n\nWe need to use arrow formatting as per example. Use arrow → before each step line. For Decision blocks, indent sub-branches. Let's produce accordingly. Ensure each line ends with // explanation.\n\nWe should keep the format: \"→ Step ...\" and indent \"    Yes →\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: x // 取得輸入整數  \n→ Decision: 如果 x < 0? // 負數不是回文  \n  Yes → Return false // 直接返回 false  \n  No  → Step 1: 初始化 reversed = 0, temp = x // 準備反轉數字  \n→ Decision: 迴圈條件 temp > 0? // 開始反轉過程  \n  Yes → Step 2: reversed = reversed * 10 + temp % 10 // 把 temp 最後一位加到 reversed  \n  Yes → Step 3: temp = temp / 10 // 移除已處理的位數  \n  No  → Decision: reversed == x? // 反轉完成後比較  \n    Yes → Return true // 是回文，回傳 true  \n    No  → Return false // 不是回文，回傳 false  \nEnd // 程式執行結束",
      "generated_code": "#!/usr/bin/env python3\nimport sys\n\ndef is_palindrome(x: int) -> bool:\n    \"\"\"\n    判斷整數 x 是否為回文數。\n    - 負數直接回傳 False。\n    - 其餘數字可透過字串逆序比對判斷。\n    \"\"\"\n    if x < 0:\n        return False\n    s = str(x)\n    return s == s[::-1]\n\ndef main() -> None:\n    \"\"\"\n    主程式入口。\n    1. 讀取整個標準輸入。\n    2. 從字串中擷取整數值（可接受 'x = 121' 或 '121' 等格式）。\n    3. 判斷是否為回文並輸出 'true' 或 'false'。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入中包含 '='，則取等號右側的內容\n    if '=' in data:\n        _, value_str = data.split('=', 1)\n        value_str = value_str.strip()\n    else:\n        value_str = data.strip()\n\n    try:\n        x = int(value_str)\n    except ValueError:\n        # 若無法轉換成整數，直接輸出 false\n        print(\"false\")\n        return\n\n    result = is_palindrome(x)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 121",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = -121",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 10",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode421.json",
    "problem_index_in_file": 0,
    "title": "Maximum XOR of Two Numbers in an Array",
    "description_snippet": "Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving max xor pair. Likely using Trie. Steps: Build binary trie, insert numbers, find max xor. Provide lines with arrows and decision.\n\nWe need to produce pseudo code with each line labeled. Use Start, End. Use decision blocks. Provide explanation comments after //.\n\nWe should not output real code. Just virtual code steps. Ensure each line has explanation. Use arrow.\n\nLet's craft: Start, initialize max_xor = 0, create Trie root. Loop each number to insert into Trie. Then loop each number to find best xor. Inside find, traverse trie bits from msb to lsb, choose opposite bit if exists to maximize xor. Build current_xor. Update max_xor. End. Also decision to check if node exists.\n\nLet's produce lines.\n\nEnsure each line includes explanation.\n\nWe'll produce something like:\n\nStart // 開始\n→ Step 1: 建立 Trie 根節點 // 初始化 Trie\n→ Step 2: max_xor = 0 // 儲存目前最大 XOR\n→ Step 3: 循環 nums 每個 num // 為每個數字插入 Trie\n    → Step 3.1: insert_into_trie(num) // 將 num 的二進制插入 Trie\n→ Step 4: 循環 nums 每個 num // 為每個數字尋找最佳 XOR\n    → Step 4.1: current = 0 // 用於累積 XOR 結果\n    → Step 4.2: node = root // 從 Trie 根開始\n    → Step 4.3: 從第 31 位到第 0 位 循環 bit_index // 逐位處理\n        → Decision: 是否存在相反位子 node.children[1 - bit_of_num]? // 若存在可取\n            Yes → node = node.children[1 - bit_of_num] // 取相反位\n            No  → node = node.children[bit_of_num] // 取相同位\n        → Step 4.4: current = (current << 1) | (1 if 取相反位 else 0) // 更新 XOR\n    → Step 4.5: max_xor = max(max_xor, current) // 更新最大值\nEnd // 結束\n\nNeed to follow format: each line: \"虛擬碼步驟 // 解釋\"\n\nMake sure to use arrows: →, Decision. For loops we can denote. For indentation maybe show nested lines with tabs or indentation.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 Trie 根節點 // 初始化一個空的 Trie  \n→ Step 2: max_xor ← 0 // 用來儲存目前發現的最大 XOR 結果  \n→ Step 3: 對於 nums 中的每個 num 做以下操作 // 先把所有數字插入 Trie  \n  → Decision: 若 num 尚未插入? // 檢查是否已經插入過  \n   Yes → Step 3.1: insert_into_trie(num) // 把 num 的二進制位插入 Trie  \n   No  → // 直接跳過  \n→ Step 4: 再次對 nums 中的每個 num 做以下操作 // 針對每個數字尋找能產生最大 XOR 的配對  \n  → Step 4.1: current_xor ← 0 // 用來累積本次搜尋得到的 XOR  \n  → Step 4.2: node ← root // 從 Trie 根節點開始尋找  \n  → Step 4.3: 從最高位 (bit_index = 31) 到最低位 (0) 逐位循環  \n    → Decision: node 之子節點中是否存在 1 - bit_of_num? // 若能取相反位會更高 XOR  \n     Yes → node ← node.children[1 - bit_of_num] // 取相反位子  \n     No  → node ← node.children[bit_of_num] // 取相同位子  \n    → Step 4.4: current_xor ← (current_xor << 1) | (1 if 取相反位 else 0) // 更新 XOR 值  \n  → Step 4.5: max_xor ← max(max_xor, current_xor) // 更新全局最大 XOR  \nEnd // 程式執行結束，返回 max_xor 以得到最大的 XOR 結果",
      "generated_code": "import sys\nimport ast\n\ndef parse_nums(s: str):\n    \"\"\"將輸入字串中方括號內的數字列轉成 list\"\"\"\n    s = s.strip()\n    start = s.find('[')\n    end = s.rfind(']')\n    if start == -1 or end == -1:\n        return []\n    return ast.literal_eval(s[start:end + 1])\n\nclass Solution:\n    def findMaximumXOR(self, nums):\n        \"\"\"使用位掩碼法求最大的 XOR 數對\"\"\"\n        max_xor = 0\n        mask = 0\n        for i in range(31, -1, -1):\n            mask |= (1 << i)                     # 逐位擴大前綴\n            prefixes = {num & mask for num in nums}\n            candidate = max_xor | (1 << i)        # 先試將此位設為 1\n            for p in prefixes:\n                if (candidate ^ p) in prefixes:   # 若能找到對應前綴，則此位確定為 1\n                    max_xor = candidate\n                    break\n        return max_xor\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums = parse_nums(data)\n    solution = Solution()\n    print(solution.findMaximumXOR(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,10,5,25,2,8]",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 1,
          "input": "nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
          "expected_output": "127",
          "success": true,
          "output": "127"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode524.json",
    "problem_index_in_file": 0,
    "title": "Longest Word in Dictionary through Deleting",
    "description_snippet": "Given a string s and a string array dictionary, return the longest string in the dictionary that can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: Given string s and dictionary, find longest word that can be formed by deleting characters of s. If tie longest, choose lexicographically smallest. If none, return \"\". Standard approach: iterate dictionary sorted by length descending, lex ascending maybe. Or better: sort by length descending, lex ascending. For each word, check if it's subsequence of s. Return first match. Complexity O(n*m). Provide virtual code.\n\nWe need to produce virtual code steps, each line with explanation comment. Use Start, Decision, etc. We must not output actual code. Use \"Step x:\".\n\nLet's produce:\n\nStart // start\n→ Step 1: Sort dictionary by descending length, ascending lex // sort\n→ Step 2: For each word in sorted dictionary // iterate\n    → Decision: If word is subsequence of s? // check\n        Yes → Step 3: Return word // found longest\n        No  → Continue loop // try next\n→ Step 4: Return \"\" // none found\nEnd // end\n\nNeed to include sub steps for subsequence check: maybe separate steps.\n\nLet's produce more detailed: sub-step check: iterate through s and word pointer.\n\nStep 5: Initialize indices i=0 (s), j=0 (word) // pointers\nStep 6: Decision: i < len(s) and j < len(word)? // loop condition\n    Yes → Decision: s[i] == word[j]? // match\n        Yes → Step 7: i++ ; j++ // advance both\n        No  → Step 8: i++ // advance s only\n    No  → Step 9: Decision: j == len(word)? // reached end word\n        Yes → Step 10: Return True // subsequence\n        No  → Step 11: Return False // not subsequence\n\nBut we might embed in virtual code? The instruction: produce virtual code steps. We can have nested steps inside the loop. Use arrows and decisions.\n\nLet's craft final answer accordingly. Use Chinese comments. Ensure each line is virtual code and comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort dictionary by length descending, lexicographical ascending // 先排好先找長字且字典序最小  \n→ Step 2: For each word in sorted dictionary // 逐一檢查  \n    → Decision: If word 是 s 的子序列? // 判斷能否刪除形成  \n        Yes → Step 3: Return word // 找到第一個符合的最長詞  \n        No  → Continue // 不是，繼續往下  \n→ Step 4: Return \"\" // 沒有任何符合的詞  \nEnd // 程式執行結束  \n\n// 以下為檢查「word 是否為 s 的子序列」的虛擬碼  \nStep 5: Initialize i ← 0, j ← 0 // i 指向 s, j 指向 word  \n→ Decision: i < len(s) AND j < len(word)? // 仍有字可以比對  \n    Yes → Decision: s[i] == word[j]? // 字符是否相同  \n        Yes → Step 6: i ← i + 1; j ← j + 1 // 同時前進  \n        No  → Step 7: i ← i + 1 // 只前進 s  \n    No  → Decision: j == len(word)? // 已比完 word  \n        Yes → Step 8: Return True // 成功子序列  \n        No  → Step 9: Return False // 失敗子序列",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findLongestWord(self, s: str, dictionary: list[str]) -> str:\n        # 先將字典按長度降序、字典序升序排序\n        dictionary.sort(key=lambda x: (-len(x), x))\n        for word in dictionary:\n            it = iter(s)\n            # 檢查 word 是否為 s 的子序列\n            if all(c in it for c in word):\n                return word\n        return \"\"\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入並轉成 tuple (s, dictionary)\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 把輸入包裝成一個 tuple，方便 literal_eval 解析\n    raw_input = \"(\" + raw_input + \")\"\n    s, dictionary = ast.literal_eval(raw_input)\n\n    result = Solution().findLongestWord(s, dictionary)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"abpcplea\", [\"ale\",\"apple\",\"monkey\",\"plea\"]",
          "expected_output": "\"apple\"",
          "success": true,
          "output": "apple"
        },
        {
          "example_index": 1,
          "input": "\"abpcplea\", [\"a\",\"b\",\"c\"]",
          "expected_output": "\"a\"",
          "success": true,
          "output": "a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode13.json",
    "problem_index_in_file": 0,
    "title": "Roman to Integer",
    "description_snippet": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Val...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step for converting Roman numeral to integer. Each line: Virtual code step followed by comment. Use arrows and decision structure. Let's design steps:\n\nStart\n→ Step 1: Initialize map of Roman symbols to values // mapping\n→ Step 2: Initialize result = 0 // accumulator\n→ Step 3: For i from 0 to length-1 of input string // iterate characters\n→ Decision: If value of current symbol < value of next symbol? // check for subtraction\n→   Yes → result += (value of next symbol - value of current symbol); i += 1 // skip next char\n→   No → result += value of current symbol // just add\nEnd\n\nAlso handle last character.\n\nLet's produce lines accordingly.\n\nWe need to include decisions with Yes → No →.\n\nWe should also handle iteration using while loop.\n\nLet's output lines:\n\nStart // 程式開始\n→ Step 1: Create dictionary roman_map // 存放符號與數值對應\n→ Step 2: Set result = 0 // 總和\n→ Step 3: Set index = 0 // 迴圈指標\n→ Decision: index < length of input? // 是否還有字符待處理\n    Yes →\n        → Step 4: Let current_val = roman_map[ input[index] ] // 取得當前符號值\n        → Decision: index + 1 < length AND current_val < roman_map[ input[index+1] ]? // 下一符號較大，需減法\n            Yes →\n                → Step 5: Let next_val = roman_map[ input[index+1] ] // 取得下一符號值\n                → Step 6: result += (next_val - current_val) // 加上減法結果\n                → Step 7: index += 2 // 跳過兩個符號\n            No →\n                → Step 8: result += current_val // 加上當前值\n                → Step 9: index += 1 // 移動到下一符號\n        No → End // 迴圈結束\n→ Decision: index < length of input? // 重新檢查條件\n    Yes → (repeat previous block)\n    No → (continue)\nEnd // 程式結束\n\nBut we need to avoid duplication. Maybe use while loop representation.\n\nWe can write:\n\n→ While index < len(input) // 迴圈開始\n    ...\nEnd while\n\nBut need to use decision arrow. We'll represent as Decision block.\n\nLet's format:\n\nStart\n→ Step 1: roman_map ← {I:1, V:5, X:10, L:50, C:100, D:500, M:1000} // 建立符號表\n→ Step 2: result ← 0 // 初始化結果\n→ Step 3: index ← 0 // 指標設為起始位置\n→ Decision: index < len(input) // 是否還有字符待處理\n    Yes →\n        → Step 4: current_val ← roman_map[input[index]] // 取得當前字符值\n        → Decision: index + 1 < len(input) AND current_val < roman_map[input[index+1]] // 判斷是否為減法情形\n            Yes →\n                → Step 5: next_val ← roman_map[input[index+1]] // 取得下一字符值\n                → Step 6: result ← result + (next_val - current_val) // 加上減法結果\n                → Step 7: index ← index + 2 // 跳過兩個字符\n            No →\n                → Step 8: result ← result + current_val // 直接加上當前值\n                → Step 9: index ← index + 1 // 移動到下一個字符\n        No → // 如果已經處理完畢則不再進一步\n    No → // 循環結束\nEnd // 程式結束\n\nBut the decision block duplicates. Need a loop. Instead, use \"While\" structure: Use Decision block with Yes to go to steps and then return to Decision. Use arrow to indicate loop.\n\nSimplify:\n\nStart\n→ Step 1: roman_map ← {...}\n→ Step 2: result ← 0\n→ Step 3: index ← 0\n→ Decision: index < len(input) // 仍有字符?\n    Yes →\n        → Step 4: current_val ← roman_map[input[index]]\n        → Decision: index + 1 < len(input) AND current_val < roman_map[input[index+1]]\n            Yes →\n                → Step 5: next_val ← roman_map[input[index+1]]\n                → Step 6: result ← result + (next_val - current_val)\n                → Step 7: index ← index + 2\n            No →\n                → Step 8: result ← result + current_val\n                → Step 9: index ← index + 1\n        No → // end of loop\n    No → // no more characters, finish\nEnd\n\nBut need to loop back to Decision after each iteration. Use an arrow like \"→ Decision:\" inside block.\n\nLet's produce final output with each line having arrow and comment.\n\nWe'll produce 1 line per step.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: roman_map ← {I:1, V:5, X:10, L:50, C:100, D:500, M:1000} // 建立羅馬字母對應的數值表  \n→ Step 2: result ← 0 // 初始化最終結果  \n→ Step 3: index ← 0 // 指向字串起始位置  \n→ Decision: index < len(input) // 仍有未處理的字符？  \n    Yes → // 進入迴圈處理  \n        → Step 4: current_val ← roman_map[input[index]] // 取得當前字符的數值  \n        → Decision: index + 1 < len(input) AND current_val < roman_map[input[index+1]] // 判斷是否為減法形式  \n            Yes → // 需要減法  \n                → Step 5: next_val ← roman_map[input[index+1]] // 取得下一字符的數值  \n                → Step 6: result ← result + (next_val - current_val) // 加上減法結果  \n                → Step 7: index ← index + 2 // 跳過兩個字符  \n            No → // 直接相加  \n                → Step 8: result ← result + current_val // 加上當前字符值  \n                → Step 9: index ← index + 1 // 移動到下一字符  \n        No → // 沒有更多字符可處理，跳出迴圈  \n    No → // 所有字符已處理完畢  \nEnd // 程式執行結束，result 為最終整數值",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        \"\"\"\n        Convert a Roman numeral string to an integer.\n        \"\"\"\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0\n        prev_value = 0\n        # 遍歷字串從右往左，便於判斷減法情形\n        for char in reversed(s):\n            value = roman_map[char]\n            if value < prev_value:\n                total -= value\n            else:\n                total += value\n            prev_value = value\n        return total\n\ndef main():\n    # 讀取全部輸入，並尋找雙引號內的字串\n    data = sys.stdin.read().strip()\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整行內容\n        s = data\n    solution = Solution()\n    result = solution.romanToInt(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"III\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"LVIII\"",
          "expected_output": "58",
          "success": true,
          "output": "58"
        },
        {
          "example_index": 2,
          "input": "s = \"MCMXCIV\"",
          "expected_output": "1994",
          "success": true,
          "output": "1994"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode134.json",
    "problem_index_in_file": 0,
    "title": "Gas Station",
    "description_snippet": "There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the LeetCode problem Gas Station. The user wants pseudocode steps with explanation comments. Format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow markers. Start and End. Decision steps. No actual code. Provide step-by-step logic.\n\nWe need to produce algorithm: O(n) solution. Approach: if total gas >= total cost then solution exists. Find start index by scanning and accumulating surplus. When surplus negative, reset start to next station and surplus=0.\n\nThus virtual code lines:\n\nStart\n→ Initialize totalSurplus = 0, currentSurplus = 0, startIndex = 0\n→ Decision: Iterate i from 0 to n-1\n   Yes → Step: totalSurplus += gas[i] - cost[i]\n   Yes → Step: currentSurplus += gas[i] - cost[i]\n   Yes → Decision: currentSurplus < 0 ?\n       Yes → Step: startIndex = i + 1\n       Yes → Step: currentSurplus = 0\n→ Decision: totalSurplus < 0 ?\n   Yes → Step: return -1\n   No → Step: return startIndex\nEnd\n\nWe should produce as separate lines with arrow and indentation. Use arrow for nested decisions. Ensure correct formatting. Also ensure \"Yes →\" and \"No →\" for decisions. Provide explanation comment. Let's craft lines accordingly.\n\nWe might need to represent loop. Use \"→ Loop: i from 0 to n-1\" or \"→ Decision: 迴圈\". We'll use \"→ Decision: 循環 i=0...n-1\" but typical pseudocode: \"→ Step: For i in 0..n-1\". Use \"→ Step: For i = 0 to n-1\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: totalSurplus ← 0, currentSurplus ← 0, startIndex ← 0 // 初始化總餘量、目前餘量與起始站\n→ Decision: 循環 i = 0 to n-1 // 逐一檢查每個加油站\n    Yes → Step: totalSurplus ← totalSurplus + (gas[i] - cost[i]) // 更新全局餘量\n    Yes → Step: currentSurplus ← currentSurplus + (gas[i] - cost[i]) // 更新當前餘量\n    Yes → Decision: currentSurplus < 0 ? // 若此時無法從起點到達 i+1\n        Yes → Step: startIndex ← i + 1 // 將起點移至下一站\n        Yes → Step: currentSurplus ← 0 // 重新計算餘量\n→ Decision: totalSurplus < 0 ? // 若整體燃油不足\n    Yes → Step: return -1 // 無法完成一圈\n    No  → Step: return startIndex // 返回唯一可行的起點\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"Return the starting gas station index if possible, otherwise -1.\"\"\"\n        total_surplus = 0\n        current_surplus = 0\n        start_index = 0\n\n        for i in range(len(gas)):\n            diff = gas[i] - cost[i]\n            total_surplus += diff\n            current_surplus += diff\n            if current_surplus < 0:\n                start_index = i + 1\n                current_surplus = 0\n\n        return start_index if total_surplus >= 0 else -1\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input string like:\n        gas = [1,2,3], cost = [1,1,1]\n    or split across multiple lines.\n    Returns two lists: gas and cost.\n    \"\"\"\n    # Find the first list after 'gas'\n    gas_match = re.search(r'gas\\s*=\\s*(\\[.*?\\])', data, re.S)\n    # Find the first list after 'cost'\n    cost_match = re.search(r'cost\\s*=\\s*(\\[.*?\\])', data, re.S)\n\n    if not gas_match or not cost_match:\n        raise ValueError(\"Input format incorrect. Expected 'gas = [...], cost = [...]'.\")\n\n    gas_list = ast.literal_eval(gas_match.group(1))\n    cost_list = ast.literal_eval(cost_match.group(1))\n\n    if not isinstance(gas_list, list) or not isinstance(cost_list, list):\n        raise ValueError(\"Gas and cost must be lists.\")\n\n    return gas_list, cost_list\n\nif __name__ == \"__main__\":\n    raw_data = sys.stdin.read()\n    if not raw_data.strip():\n        sys.exit(0)  # No input\n\n    try:\n        gas, cost = parse_input(raw_data)\n        sol = Solution()\n        result = sol.canCompleteCircuit(gas, cost)\n        print(result)\n    except Exception as e:\n        # If parsing fails, print -1 as per problem statement\n        print(-1)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "gas = [2,3,4], cost = [3,4,3]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode540.json",
    "problem_index_in_file": 0,
    "title": "Single Element in a Sorted Array",
    "description_snippet": "You are given a sorted array consisting of only integers where every element appears exactly twice, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm: binary search for unique element in sorted array where all others appear twice. Use index parity. So produce pseudocode with arrows and decisions.\n\nNeed to output each line as \"虛擬碼步驟 // 解釋/說明\".\n\nInclude Start, End. Use arrows. Let's produce steps: start, set low=0 high=n-1, while low<high: mid = low + (high-low)//2; if mid%2==1: mid-- to even; compare arr[mid]==arr[mid+1] then low=mid+2 else high=mid; after loop return arr[low].\n\nAlso include explanation lines.\n\nLet's produce lines. Use \"→\" for steps. Use indentation with spaces. Use \"Decision:\" lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 low = 0, high = n - 1 // 初始化搜尋區間  \n→ Decision: 是否存在未處理區間? low < high? // 判斷是否還有多個元素需要比較  \n    Yes → Step 2: mid = low + (high - low) // 取中點索引  \n        Decision: mid 是奇數? mid % 2 == 1? // 使 mid 為偶數位置  \n            Yes → Step 3: mid = mid - 1 // 如果 mid 為奇數，往左移一個位置  \n            No  → Step 3: mid 保持不變  \n        → Decision: arr[mid] == arr[mid + 1]? // 比較偶數位置和其右鄰的值  \n            Yes → Step 4: low = mid + 2 // 兩個相同，唯一值在右側  \n            No  → Step 5: high = mid // 兩個不同，唯一值在左側（包含 mid）  \n    No → Step 6: return arr[low] // low == high，唯一元素已定位  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNonDuplicate(self, nums):\n        \"\"\"\n        在已排序且每個元素都恰好出現兩次，只有一個元素只出現一次的陣列中，\n        找到那個只出現一次的元素。時間複雜度 O(log n)，空間複雜度 O(1)。\n        \"\"\"\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            # 讓 mid 始終為偶數索引，方便與右邊相鄰元素比較\n            if mid % 2 == 1:\n                mid -= 1\n            if nums[mid] == nums[mid + 1]:\n                # 兩個相同，單個元素必定在右半部\n                left = mid + 2\n            else:\n                # 兩個不同，單個元素在左半部（含 mid）\n                right = mid\n        return nums[left]\n\ndef main():\n    # 讀取整個輸入，移除首尾空白後解析為 list\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums = ast.literal_eval(data)\n    result = Solution().singleNonDuplicate(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,1,2,3,3,4,4,8,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[3,3,7,7,10,11,11]",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode22.json",
    "problem_index_in_file": 0,
    "title": "Generate Parentheses",
    "description_snippet": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parenthes...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Provide a line-by-line plan for generating combinations of well-formed parentheses for n pairs. Use Start, Decision, etc. No real code. Provide short explanation after each line. Use virtual code arrows and structure. Ok. Let's create pseudocode: Start, Step: define function generate(n), inside define result list, call backtrack with empty string, open=0, close=0, Decision: if length == 2*n, add to result, return. Else Decision: if open < n, add '(' and backtrack open+1, close. Decision: if close < open, add ')' and backtrack open, close+1. Return result. End. Use appropriate arrows. Provide explanation each line.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 generate(n) // 建立主函式，接受括號對數\n    → Step 2: 初始化結果列表 result ← 空列表 // 用於儲存所有合法組合\n    → Step 3: 呼叫輔助函式 backtrack(current ← \"\", open ← 0, close ← 0) // 開始遞迴\n    → Step 4: 返回 result // 結束時回傳所有組合\n→ End // 程式結束\n\nNow backtrack definition:\nStart of backtrack\n→ Step 5: Decision: 如果 length(current) == 2*n? // 已構造完整長度\n    Yes → Step 6: result.append(current) // 加入合法結果\n    No → Step 7: Decision: 如果 open < n? // 還可以加入左括號\n        Yes → Step 8: backtrack(current + \"(\", open+1, close) // 加左括號遞迴\n        No  → Step 9: Decision: 如果 close < open? // 仍可加入右括號\n            Yes → Step 10: backtrack(current + \")\", open, close+1) // 加右括號遞迴\n            No  → Step 11: Return // 無法繼續，返回上一層\n→ End // backtrack 函式結束\n\nBut we need to follow formatting: use Start/End within backtrack? Could nest. Provide indentation by using arrows maybe. For simplicity we can just put the steps within the main flow, but we need to maintain structure. Provide lines for backtrack inside. We'll use indentation but with arrows.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 generate(n) // 建立主函式，接受括號對數  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 2: 初始化結果列表 result ← 空列表 // 用於儲存所有合法組合  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3: 呼叫輔助函式 backtrack(current ← \"\", open ← 0, close ← 0) // 開始遞迴  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Step 4: 返回 result // 結束時回傳所有組合  \nEnd // 程式結束  \n\nStart backtrack(current, open, close) // 遞迴協助函式  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 如果 length(current) == 2*n? // 已構造完整長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 5: result.append(current) // 加入合法結果  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 open < n? // 還可以加入左括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 6: backtrack(current + \"(\", open+1, close) // 加左括號遞迴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Decision: 如果 close < open? // 仍可加入右括號  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 7: backtrack(current + \")\", open, close+1) // 加右括號遞迴  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No → Step 8: Return // 無法繼續，返回上一層  \nEnd // backtrack 函式結束",
      "generated_code": "import sys\nimport json\nimport re\n\ndef generate_parenthesis(n: int):\n    \"\"\"生成所有合法括號組合，使用回溯法。\"\"\"\n    res = []\n\n    def backtrack(s: str, left: int, right: int):\n        # 完整長度 2*n 時，將結果加入列表\n        if len(s) == 2 * n:\n            res.append(s)\n            return\n        # 若還能放左括號，遞迴加入 '('\n        if left < n:\n            backtrack(s + \"(\", left + 1, right)\n        # 若右括號數量小於左括號數量，遞迴加入 ')'\n        if right < left:\n            backtrack(s + \")\", left, right + 1)\n\n    backtrack(\"\", 0, 0)\n    return res\n\ndef main():\n    # 讀取整個輸入，並嘗試找出第一個整數作為 n\n    data = sys.stdin.read().strip()\n    if not data:\n        print(\"[]\")\n        return\n\n    match = re.search(r\"(\\d+)\", data)\n    if not match:\n        print(\"[]\")\n        return\n\n    n = int(match.group(1))\n    result = generate_parenthesis(n)\n    # 使用 json.dumps 以符合範例的雙引號格式輸出\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
          "success": true,
          "output": "[\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[\"()\"]",
          "success": true,
          "output": "[\"()\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode217.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate",
    "description_snippet": "Given an integer array nums, return true if any value appears at least twice in the array, and retur...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step-by-step, each line with explanation after a space, comments starting with //. Use Start, End, Decision, arrows. We must not output actual code. Just virtual code steps. Use arrow → etc. So produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 建立空集合 seen // 用來記錄已見過的數值\n\n→ For each num in nums: // 逐個檢查數值\n    → Decision: 如果 num 已在 seen? // 檢查是否重複\n        Yes → Return true // 找到重複值\n        No  → Step 2: 把 num 加入 seen // 記錄新數值\nEnd // 若循環結束，所有數值均不同，返回 false\n\nBut we need \"Return true\" and \"Return false\" steps. Use virtual code steps: Step 3: Return false // 循環完成後，所有元素不同\n\nWe must ensure each line has \"虛擬碼步驟\" plus explanation. Provide arrow, indentation for decisions. Let's craft.\n\nAlso note requirement: each line must include \"虛擬碼步驟\" then a space then comment. So each line has e.g.:\n\nStart // 程式開始執行\n\n→ Step 1: 建立空集合 seen // 用於存儲已經遇到的數字\n\n→ For each num in nums: // 逐個遍歷數組\n\n    → Decision: num 在 seen? // 判斷 num 是否已存在\n\n        Yes → Step 2: Return true // 找到重複值，返回真\n\n        No  → Step 3: 加入 num 到 seen // 記錄新數字\n\nEnd // 如果遍歷完畢仍未返回，則所有元素不同\n\n→ Step 4: Return false // 返回假\n\nBut maybe the Step 2: Return true, Step 4: Return false. Ensure proper arrow formatting. Use the arrow and indentation.\n\nThe final answer should be only virtual code lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空集合 seen // 用於存儲已遇過的數值  \n→ For each num in nums: // 逐一檢查陣列中的每個數值  \n  → Decision: num 已在 seen? // 判斷此數值是否重複  \n    Yes → Step 2: Return true // 立即返回真，表示至少有一個重複  \n    No  → Step 3: 加入 num 到 seen // 將新數值記錄到集合  \nEnd // 若循環結束仍未返回，說明所有元素皆不同  \n→ Step 4: Return false // 返回假，表示沒有重複值",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # 提取所有整數（包括負數）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = Solution().containsDuplicate(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode389.json",
    "problem_index_in_file": 0,
    "title": "Find the Difference",
    "description_snippet": "You are given two strings s and t.\n\nString t is generated by random shuffling string s and then add ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that given s and t returns the added letter. We need to produce step-by-step virtual code with explanations, no actual code, use arrows and decision etc.\n\nWe need to think of an algorithm. Options: count frequencies, or XOR each character. We can use XOR approach: XOR all chars of s and t, result is added char. But also can sort? But XOR simpler.\n\nWe'll produce pseudocode:\n\nStart\n\n→ Step: 初始化 result = 0 // 用整数存储 XOR\n\n→ Step: 迭代每個字符 c in s → result = result XOR ord(c) // 逐個 XOR\n\n→ Step: 迭代每個字符 c in t → result = result XOR ord(c) // 追加 XOR\n\n→ Step: result_char = char(result) // 转为字符\n\n→ Step: Return result_char // 输出添加的字母\n\nAlso can include decision if want to handle empty etc. But not necessary.\n\nWe will produce line by line with comments. Use Start, End. Use arrow for steps.\n\nMake sure each line ends with `//` comment.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result = 0 // 用 0 作為 XOR 初始值，代表無任何字符  \n→ Step 2: 迭代 s 中的每個字符 c → result = result XOR ord(c) // 將 s 的所有字符依次 XOR，得到 s 的 XOR 和  \n→ Step 3: 迭代 t 中的每個字符 c → result = result XOR ord(c) // 再將 t 的所有字符 XOR，兩個集合的 XOR 只剩下多出的字母  \n→ Step 4: result_char = chr(result) // 把 XOR 結果轉回對應字符  \n→ Step 5: Return result_char // 回傳新增的字母  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_added_letter(s: str, t: str) -> str:\n    \"\"\"\n    以 XOR 演算法找出多出的字母。\n    - 對 s 與 t 的所有字元分別 XOR，最終結果即為新增字母。\n    \"\"\"\n    result = 0\n    for ch in s:\n        result ^= ord(ch)\n    for ch in t:\n        result ^= ord(ch)\n    return chr(result)\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析 s 與 t，並輸出新增字母。\n    支援兩種輸入格式：\n    1. 兩個字串已經被雙引號包住，並以逗號分隔，例如：s = \"abcd\", t = \"abcde\"\n    2. 兩行文字，第一行是 s，第二行是 t\n    \"\"\"\n    data = sys.stdin.read()\n\n    # 嘗試從雙引號中提取字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # 直接按行拆分\n        lines = data.strip().splitlines()\n        if len(lines) >= 2:\n            s, t = lines[0].strip(), lines[1].strip()\n        else:\n            # 若輸入格式不符合，直接終止\n            return\n\n    result = find_added_letter(s, t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcd\", t = \"abcde\"",
          "expected_output": "\"e\"",
          "success": true,
          "output": "e"
        },
        {
          "example_index": 1,
          "input": "s = \"\", t = \"y\"",
          "expected_output": "\"y\"",
          "success": true,
          "output": "y"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode75.json",
    "problem_index_in_file": 0,
    "title": "Sort Colors",
    "description_snippet": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for Dutch National Flag problem. Provide line by line steps. Use Start, End, Decision. No actual code, just pseudo steps with explanations. Should reflect algorithm: maintain low, mid, high pointers. Loop while mid <= high. Swap accordingly. No library sort.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 low = 0, mid = 0, high = n - 1 // 初始化三個指標  \n→ Decision: 是否 mid <= high? // 判斷是否還有元素要處理  \n    Yes → Step 2: 讀取 nums[mid] 的值 // 取得目前中間指標指向的顏色  \n    → Decision: nums[mid] == 0? // 判斷是否為紅色  \n        Yes → Step 3: 交換 nums[low] 與 nums[mid] // 將紅色移到最前  \n            → Step 4: low += 1, mid += 1 // 移動 low 與 mid  \n        No → Decision: nums[mid] == 1? // 判斷是否為白色  \n            Yes → Step 5: mid += 1 // 白色已處於正確位置，僅移動 mid  \n            No → Step 6: 交換 nums[mid] 與 nums[high] // 將藍色移到最後  \n                → Step 7: high -= 1 // 減少 high  \n                → Step 8: (不改 mid) // 仍需檢查剛交換進來的元素  \n    No → End // mid > high，排序完成  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        Sort the list nums in-place so that 0s, 1s, and 2s are grouped together\n        in the order 0, 1, 2. This implements the Dutch National Flag algorithm.\n        \"\"\"\n        low, mid, high = 0, 0, len(nums) - 1\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:  # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin\n    raw_input = sys.stdin.read().strip()\n    # Handle possible input format variations\n    if not raw_input:\n        sys.exit(0)\n    # If input contains \"nums =\" extract the part after '='\n    if \"=\" in raw_input:\n        _, list_part = raw_input.split(\"=\", 1)\n    else:\n        list_part = raw_input\n    # Use ast.literal_eval to safely parse the list\n    try:\n        nums = ast.literal_eval(list_part.strip())\n    except Exception as e:\n        # If parsing fails, treat the whole input as a list literal\n        nums = ast.literal_eval(raw_input)\n    # Ensure nums is a list of integers\n    if not isinstance(nums, list):\n        raise ValueError(\"Input must represent a list of integers.\")\n    # Apply the sorting algorithm\n    Solution().sortColors(nums)\n    # Output the sorted list\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,0,2,1,1,0]",
          "expected_output": "[0,0,1,1,2,2]",
          "success": true,
          "output": "[0, 0, 1, 1, 2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,0,1]",
          "expected_output": "[0,1,2]",
          "success": true,
          "output": "[0, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode378.json",
    "problem_index_in_file": 0,
    "title": "K^th Smallest Element in a Sorted Matrix",
    "description_snippet": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm: find kth smallest in sorted matrix. Classic solution: binary search on value range, count elements <= mid by scanning rows from bottom-left or using binary search per row. Complexity O(n log(range)). Or use min-heap O(k log n). But memory O(n). We need better than O(n^2). Provide steps.\n\nWe will produce virtual code using Start, End, Decision, Step, etc. Each line with explanation.\n\nLet's create algorithm: binary search.\n\nPseudo:\n\nStart\n→ Set low = matrix[0][0]\n→ Set high = matrix[n-1][n-1]\n→ While low < high\n    → mid = low + (high - low) // 2\n    → count = 0\n    → i = n-1; j = 0\n    → While i >= 0 and j < n\n        → If matrix[i][j] <= mid\n            → count += i+1\n            → j += 1\n        → Else\n            → i -= 1\n    → Decision: If count >= k?\n        Yes → high = mid\n        No  → low = mid + 1\n→ Step: Return low\nEnd\n\nWe must add explanation after each line.\n\nMake sure to use arrow and indentation for decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: low ← matrix[0][0] // 設定搜尋區間左端為矩陣最小值  \n→ Step: high ← matrix[n-1][n-1] // 設定搜尋區間右端為矩陣最大值  \n→ Decision: low < high? // 只要搜尋區間未縮小到單一值，就持續迴圈  \n    Yes → Step: mid ← low + (high - low) / 2 // 取搜尋區間中點作為判斷值  \n    → Step: count ← 0 // 初始化計數器，用於統計 ≤ mid 的元素數量  \n    → Step: i ← n-1 // 從最後一行開始  \n    → Step: j ← 0 // 從第一列開始  \n    → While i ≥ 0 且 j < n  \n        → Decision: matrix[i][j] ≤ mid? // 判斷當前元素是否 ≤ mid  \n            Yes → Step: count ← count + i + 1 // 所有在第 i 行左側的元素都 ≤ mid  \n            → Step: j ← j + 1 // 移到下一列  \n            No → Step: i ← i - 1 // 移到上一行  \n    → Decision: count ≥ k? // 根據計數判斷 k 號小於等於 mid  \n        Yes → Step: high ← mid // 若足夠多，縮小搜尋區間至左半邊  \n        No  → Step: low ← mid + 1 // 若不足，縮小搜尋區間至右半邊  \n→ Step: Return low // low 代表第 k 小的元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        low = matrix[0][0]\n        high = matrix[n - 1][n - 1]\n\n        while low < high:\n            mid = low + (high - low) // 2\n            count = 0\n            i = n - 1\n            j = 0\n            # count elements <= mid\n            while i >= 0 and j < n:\n                if matrix[i][j] <= mid:\n                    count += i + 1\n                    j += 1\n                else:\n                    i -= 1\n            # decide next search interval\n            if count >= k:\n                high = mid\n            else:\n                low = mid + 1\n        return low\n\nif __name__ == \"__main__\":\n    # Read all input\n    data = sys.stdin.read().strip()\n    # Extract matrix and k using regular expressions\n    mat_match = re.search(r'matrix\\s*=\\s*(\\[.*?\\])', data, re.S)\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not mat_match or not k_match:\n        sys.exit(\"Invalid input format.\")\n    matrix = ast.literal_eval(mat_match.group(1))\n    k = int(k_match.group(1))\n\n    sol = Solution()\n    result = sol.kthSmallest(matrix, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
          "expected_output": "13",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp4uo56vao.py\", line 38, in <module>\n    matrix = ast.literal_eval(mat_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[1,5,9]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "matrix = [[-5]], k = 1",
          "expected_output": "-5",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpjejq987h.py\", line 38, in <module>\n    matrix = ast.literal_eval(mat_match.group(1))\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[-5]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode164.json",
    "problem_index_in_file": 0,
    "title": "Maximum Gap",
    "description_snippet": "Given an integer array nums, return the maximum difference between two successive elements in its so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanation lines. Use Start, End, Decision. Provide linear algorithm: use bucket sort (Pigeonhole) to compute maximum gap in O(n). Steps: find min, max; compute bucket size; create buckets; fill; compute max gap by scanning. Also handle edge cases: less than 2 -> 0. Need linear extra space: array of buckets of size n-1 or maybe n. Implementation details: Use arrays minBucket[], maxBucket[] of length n-1, initialized appropriately. For each num, find bucket index = (num - min) / bucketSize, but ensure index < n-1. Fill buckets. Then iterate over buckets to compute max gap: track previous bucket's max, compute diff between current bucket's min and previous max. Also handle empty bucket. Provide virtual code with arrows and decisions.\n\nMake sure each line is separate. Use \"→\" for steps. Use indentation for sub-steps inside Decision. Provide concise explanation after //.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums 數組長度 < 2? // 判斷是否不足兩個元素  \n    Yes → Step 1: 回傳 0 // 直接回傳 0  \n    No  → Step 2: 找到陣列最小值 minVal 和最大值 maxVal // 取得範圍  \n→ Decision: maxVal == minVal? // 檢查所有元素是否相同  \n    Yes → Step 3: 回傳 0 // 沒有差距  \n    No  → Step 4: 計算 bucketSize = max(1, ⌈(maxVal - minVal) / (n-1)⌉) // 形成桶寬度，保證至少 1  \n→ Step 5: 建立兩個長度為 n-1 的數組 minBucket, maxBucket，並初始化 minBucket 為 +∞，maxBucket 為 -∞ // 先填滿空桶  \n→ Decision: 對於每個 num 在 nums 中? // 填充桶  \n    → Step 6: bucketIdx = (num - minVal) / bucketSize // 決定桶索引  \n        → Step 7: minBucket[bucketIdx] = min(minBucket[bucketIdx], num) // 更新桶內最小值  \n        → Step 8: maxBucket[bucketIdx] = max(maxBucket[bucketIdx], num) // 更新桶內最大值  \n→ Step 9: 設置 prevMax = minVal, maxGap = 0 // 準備掃描桶  \n→ Decision: 從 i = 0 到 n-2? // 逐桶計算最大差距  \n    → Step 10: 如果 minBucket[i] == +∞? // 空桶  \n        → Step 11: 跳過此桶 // 無元素不影響差距  \n        → Step 12: 否則  \n            → Step 13: gap = minBucket[i] - prevMax // 與前一非空桶最大值之差  \n            → Step 14: maxGap = max(maxGap, gap) // 更新最大差距  \n            → Step 15: prevMax = maxBucket[i] // 更新 prevMax 為此桶最大值  \n→ Step 16: 回傳 maxGap // 返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def maximumGap(self, nums):\n        # 如果元素不足兩個，直接回傳 0\n        if len(nums) < 2:\n            return 0\n\n        n = len(nums)\n        min_val = min(nums)\n        max_val = max(nums)\n\n        # 所有元素相同時差距為 0\n        if min_val == max_val:\n            return 0\n\n        # 計算桶寬度（ceil）\n        bucket_size = max(1, (max_val - min_val + n - 2) // (n - 1))\n        bucket_count = n - 1\n\n        # 初始化桶的最小值與最大值\n        min_bucket = [float('inf')] * bucket_count\n        max_bucket = [float('-inf')] * bucket_count\n\n        # 將每個數值放入對應桶中\n        for num in nums:\n            idx = (num - min_val) // bucket_size\n            # 由於整數除法，最後一個元素可能落到索引 n-1\n            if idx >= bucket_count:\n                idx = bucket_count - 1\n            min_bucket[idx] = min(min_bucket[idx], num)\n            max_bucket[idx] = max(max_bucket[idx], num)\n\n        # 逐桶掃描，計算最大差距\n        prev_max = min_val\n        max_gap = 0\n        for i in range(bucket_count):\n            # 空桶跳過\n            if min_bucket[i] == float('inf'):\n                continue\n            max_gap = max(max_gap, min_bucket[i] - prev_max)\n            prev_max = max_bucket[i]\n\n        return max_gap\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 處理可能的「nums = …」格式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # 轉換為 Python 列表\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        print(0)\n        sys.exit(0)\n\n    # 呼叫解法並輸出結果\n    solution = Solution()\n    result = solution.maximumGap(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,6,9,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [10]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode350.json",
    "problem_index_in_file": 0,
    "title": "Intersection of Two Arrays II",
    "description_snippet": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for intersect of two integer arrays, counting duplicates. We'll output steps: create hash map for counts of nums1, iterate nums2, if count>0 add to result and decrement. Steps.\n\nWe need to follow format: each line \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision. Provide steps. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 空字典 countMap // 用來記錄 nums1 中每個數字的出現次數  \n→ Step 2: 對於 nums1 中的每個元素 num  \n  → Decision: 若 num 已存在於 countMap?  \n    Yes → countMap[num] ← countMap[num] + 1 // 若已存在，次數加一  \n    No  → countMap[num] ← 1 // 若不存在，初始化為 1  \n→ Step 3: 初始化 空陣列 result // 用來存放交集結果  \n→ Step 4: 對於 nums2 中的每個元素 num  \n  → Decision: 若 countMap[num] 存在且 > 0?  \n    Yes → result ← result + [num] // 加入結果陣列  \n      countMap[num] ← countMap[num] - 1 // 次數減一，避免重複使用  \n    No  → Decision: 若 countMap[num] 為 0 或不存在?  \n      Yes → 不執行任何動作 // 不在兩個陣列中同時出現  \n→ Step 5: 回傳 result // 輸出交集陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        取得兩個整數陣列的交集，考慮重複元素。\n        使用 Counter 來統計兩陣列中各元素出現次數，\n        然後取兩者次數最小值擴充到結果列表。\n        \"\"\"\n        c1, c2 = Counter(nums1), Counter(nums2)\n        res = []\n        for num in c1:\n            if num in c2:\n                res.extend([num] * min(c1[num], c2[num]))\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    從原始輸入字串中抓取兩個整數列表。\n    假設輸入形如 'nums1 = [1,2,2,1], nums2 = [2,2]'\n    或類似格式，使用正則表達式尋找 [] 內的內容。\n    \"\"\"\n    lists = re.findall(r'\\[.*?\\]', data)\n    if len(lists) < 2:\n        return [], []\n    nums1 = ast.literal_eval(lists[0])\n    nums2 = ast.literal_eval(lists[1])\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin 作為輸入資料\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    solution = Solution()\n    result = solution.intersect(nums1, nums2)\n    # 輸出結果，保持 Python list 的格式\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "success": true,
          "output": "[2, 2]"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "success": true,
          "output": "[4, 9]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode28.json",
    "problem_index_in_file": 0,
    "title": "Implement strStr()",
    "description_snippet": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystac...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for this problem: find index of substring needle in haystack, return -1 if not found. We must not output actual code, just virtual steps.\n\nWe should use Start, End, Decision. Provide step lines with arrows, explain.\n\nWe need to include steps like input haystack, needle, compute lengths, loop through haystack, compare substring, etc.\n\nLet's produce a thorough pseudocode, each line with explanation. Use \"→\" arrow. Provide indentation? The example shows indentation for decisions but not necessary.\n\nLet's produce.\n\nAlso must include the requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\"\n\nSo each line: `虛擬碼步驟 // 解釋`.\n\nLet's produce maybe about 15-20 lines.\n\nNeed to use Start, End, Decision, Yes →, No →.\n\nMake sure to use \"Start\" and \"End\".\n\nAlso, need to handle case of empty needle: by definition return 0.\n\nOk.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: Set i = 0 // 初始化 haystack 指標\n\n→ Step 2: Set n = length(haystack) // 取得 haystack 長度\n\n→ Step 3: Set m = length(needle) // 取得 needle 長度\n\n→ Decision: 如果 m == 0? // 空字串時\n\n    Yes → Step 4: Return 0 // 空字串總是位於索引 0\n\n    No → Proceed to loop\n\n→ Decision: 如果 n < m? // haystack 太短無法包含 needle\n\n    Yes → Step 5: Return -1 // 直接返回 -1\n\n    No → Proceed\n\n→ Step 6: While i <= n - m // 循環到最後可能的起始位置\n\n    → Step 7: Set match = True // 假設目前位置匹配\n\n    → For j from 0 to m-1 // 檢查每個字符\n\n        → Decision: haystack[i + j] == needle[j]? // 比較字符\n\n            Yes → Continue // 繼續檢查下一個字符\n\n            No → Step 8: match = False // 不匹配\n\n            No → Break // 跳出內部循環\n\n    → Decision: match? // 檢查是否整個字串匹配\n\n        Yes → Step 9: Return i // 找到位置，返回索引\n\n        No  → Step 10: i = i + 1 // 移動到下一個起始位置\n\n→ Step 11: Return -1 // 所有位置都檢查完畢仍未匹配\n\nEnd // 程式結束\n\nBut we need to include explanations for each line. For each line we add `//`.\n\nAlso need to use arrow. The \"Step 6\" includes a While loop and nested For. Use indentation maybe.\n\nWe can produce the nested steps inside While. The example uses indentation for nested steps. We'll adopt same style.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Step 1: Set i = 0 // 初始化 haystack 起始指標\n\n→ Step 2: Set n = length(haystack) // 取得 haystack 長度\n\n→ Step 3: Set m = length(needle) // 取得 needle 長度\n\n→ Decision: 如果 m == 0? // 先處理空字串情況\n\n    Yes → Step 4: Return 0 // 空字串總是出現在索引 0\n\n    No → Proceed\n\n→ Decision: 如果 n < m? // haystack 太短無法包含 needle\n\n    Yes → Step 5: Return -1 // 直接返回 -1\n\n    No → Proceed\n\n→ Step 6: While i <= n - m // 循環所有可能的起始位置\n\n    → Step 7: Set match = True // 假設此位置匹配\n\n    → For j = 0 to m-1 // 檢查每個字符\n\n        → Decision: haystack[i + j] == needle[j]? // 字符比較\n\n            Yes → Continue // 仍可能匹配，繼續下一個字符\n\n            No → Step 8: match = False // 不匹配\n\n            No → Break // 跳出內部循環\n\n    → Decision: match? // 檢查整個子字串是否匹配\n\n        Yes → Step 9: Return i // 找到第一個匹配，返回索引\n\n        No  → Step 10: i = i + 1 // 移動到下一個起始位置\n\n→ Step 11: Return -1 // 全部檢查完畢仍未匹配，返回 -1\n\nEnd // 程式執行結束\n\nNeed to ensure each line has arrow \"→\". For decisions, need \"Decision:\" lines and nested lines with \"Yes →\" and \"No →\". For loops, we use \"While\" and \"For\". The lines inside loops also need arrow.\n\nWe should add explanation after each.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set i = 0 // 初始化 haystack 起始指標  \n→ Step 2: Set n = length(haystack) // 取得 haystack 長度  \n→ Step 3: Set m = length(needle) // 取得 needle 長度  \n→ Decision: 如果 m == 0? // 先處理空字串情況  \n  Yes → Step 4: Return 0 // 空字串總是出現在索引 0  \n  No → （繼續執行）  \n→ Decision: 如果 n < m? // haystack 太短無法包含 needle  \n  Yes → Step 5: Return -1 // 直接返回 -1  \n  No → （繼續執行）  \n→ Step 6: While i <= n - m // 循環所有可能的起始位置  \n  → Step 7: Set match = True // 假設此位置匹配  \n  → For j = 0 to m-1 // 檢查每個字符  \n    → Decision: haystack[i + j] == needle[j]? // 字符比較  \n      Yes → （繼續）  \n      No → Step 8: match = False // 不匹配  \n      No → Break // 跳出內部循環  \n  → Decision: match? // 檢查整個子字串是否匹配  \n    Yes → Step 9: Return i // 找到第一個匹配，返回索引  \n    No  → Step 10: i = i + 1 // 移動到下一個起始位置  \n→ Step 11: Return -1 // 全部檢查完畢仍未匹配，返回 -1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef str_str(haystack: str, needle: str) -> int:\n    \"\"\"\n    Return the index of the first occurrence of needle in haystack,\n    or -1 if needle is not part of haystack.\n    \"\"\"\n    # Empty needle is always found at index 0\n    if not needle:\n        return 0\n\n    n, m = len(haystack), len(needle)\n    if n < m:\n        return -1\n\n    # Scan each possible start index\n    for i in range(n - m + 1):\n        if haystack[i:i + m] == needle:\n            return i\n    return -1\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, parse haystack and needle, compute the result\n    and print it to stdout.\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Try to parse format: haystack = \"xxx\", needle = \"yyy\"\n    match = re.search(\n        r'haystack\\s*=\\s*\"([^\"]*)\"\\s*,\\s*needle\\s*=\\s*\"([^\"]*)\"', data\n    )\n    if match:\n        haystack, needle = match.group(1), match.group(2)\n    else:\n        # Fallback: two lines, first is haystack, second is needle\n        lines = data.splitlines()\n        haystack = lines[0]\n        needle = lines[1] if len(lines) > 1 else \"\"\n\n    result = str_str(haystack, needle)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "haystack = \"sadbutsad\", needle = \"sad\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "haystack = \"leetcode\", needle = \"leeto\"",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode377.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum IV",
    "description_snippet": "Given an array of distinct integers nums and a target integer target, return the number of possible ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for counting number of combinations of distinct integers in array nums summing to target. Distinct means each number can be used multiple times? Problem akin to coin change combinations (order does not matter). But \"combinations\" may mean unlimited use? Usually combination sum problem: unlimited use of each number. We'll assume unlimited usage. DP: dp[0]=1; for each num in nums: for t from num to target: dp[t]+=dp[t-num]. Return dp[target].\n\nLet's output step by step virtual code with explanations. Include Start, End, Decision. Also input steps. We can break into steps: input array, target. Initialize dp array size target+1, set dp[0]=1. Iterate over nums: For each num, loop from num to target: dp[t] += dp[t-num]. After loops, output dp[target]. Use Decision? Not necessary. But maybe include decision to handle target<0? Could add if target<0 -> return 0. Also maybe handle empty nums. But keep simple.\n\nWe produce lines:\n\nStart // 程式開始執行\n→ Step 1: 讀取 nums 與 target // 從使用者取得數組與目標值\n→ Decision: 如果 target < 0? // 檢查目標是否為負數\n    Yes → Step 2: 輸出 0 // 無解，直接回傳 0\n    No  → Step 3: 建立 dp 陣列長度 target+1 並初始化為 0 // 為 DP 做準備\n→ Step 4: dp[0] ← 1 // 基礎情況：和為 0 的組合為 1（空組合）\n→ Step 5: 迴圈 num 於 nums // 為每個數字做外層迴圈\n    → Step 6: 迴圈 t 從 num 到 target // 內層迴圈計算各 target\n        → Step 7: dp[t] ← dp[t] + dp[t-num] // 加上使用 num 的新組合\n→ Step 8: 輸出 dp[target] // 結果為目標和的組合數\nEnd // 程式執行結束\n\nNeed to ensure each line ends with // explanation. Also include arrow for loops. Format lines with '→' before Step. For nested loops maybe indent? But specification: use arrows and structure. Use \"→ Step\" etc. Provide nested loops inside? Might show arrow then Step. For inner loop, maybe use arrow again. Eg:\n\n→ Step 5: 迴圈 num 於 nums\n    → Step 6: 迴圈 t 從 num 到 target\n        → Step 7: dp[t] ← dp[t] + dp[t-num]\n\nWe need to ensure each line has \"虛擬碼步驟\" plus explanation. We must use space between step and //.\n\nMake sure to avoid actual code. Use words. Eg \"dp[0] ← 1\" but still considered virtual code.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 nums 與 target // 從使用者取得數組與目標值  \n→ Decision: 如果 target < 0? // 檢查目標是否為負數  \n Yes → Step 2: 輸出 0 // 無解，直接回傳 0  \n No  → Step 3: 建立 dp 陣列長度 target+1 並初始化為 0 // 為 DP 做準備  \n→ Step 4: dp[0] ← 1 // 基礎情況：和為 0 的組合為 1（空組合）  \n→ Step 5: 迴圈 num 於 nums // 為每個數字做外層迴圈  \n  → Step 6: 迴圈 t 從 num 到 target // 內層迴圈計算各 target  \n    → Step 7: dp[t] ← dp[t] + dp[t-num] // 加上使用 num 的新組合  \n→ Step 8: 輸出 dp[target] // 結果為目標和的組合數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combinationSum4(self, nums, target):\n        # 如果 target 為負數則無法組合\n        if target < 0:\n            return 0\n        dp = [0] * (target + 1)\n        dp[0] = 1  # 只有一種方式達到和為 0，即不取任何數\n\n        for i in range(1, target + 1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i - num]\n        return dp[target]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums 與 target\n    允許的輸入格式類似: 'nums = [1,2,3], target = 4'\n    \"\"\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[.*?\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    nums = eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else 0\n    return nums, target\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    nums, target = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.combinationSum4(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3], target = 4",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [9], target = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode532.json",
    "problem_index_in_file": 0,
    "title": "K-diff Pairs in an Array",
    "description_snippet": "Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the ar...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code, line by line, with explanation. Provide steps for counting unique k-diff pairs in array. Must use virtual code with arrows. Use decision structure. Ensure no actual code, only steps.\n\nLet's design: Start, Input array nums, integer k. Step: create hash map for counts. Step: iterate over array to count frequencies. Step: initialize result = 0. Step: if k < 0: return 0 because difference cannot be negative. Else if k == 0: for each count > 1: result++. Else: for each unique number in map: if num + k exists: result++. At end return result.\n\nWe need to use arrow notation: → Step 1: etc. Use Decision: if k < 0? etc. Let's produce.\n\nAlso mention unique pairs, so only count each pair once.\n\nUse comments after //.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入陣列 nums 與整數 k // 讀取使用者提供的資料\n→ Decision: 如果 k 小於 0? // 差值不能為負\n    Yes → Step 2: 回傳 0 // 無合法 k-diff 對\n    No  → Decision: 如果 k 等於 0? // 特殊情況，尋找重複元素\n        Yes → Step 3: 建立空 Map countMap // 以數字為鍵，出現次數為值\n        → Step 4: 針對 nums 中每個元素 val 執行\n            → Step 5: countMap[val] = countMap.get(val, 0) + 1 // 累計頻率\n        → Step 6: 設定 result = 0 // 結果計數器\n        → Step 7: 針對 countMap 中每個鍵 key 執行\n            → Decision: 如果 countMap[key] > 1? // 至少出現兩次\n                Yes → result = result + 1 // 這個鍵形成一對 (key, key)\n                No  → // 不計算\n        → Step 8: 回傳 result // 返回 k-diff 對數\n        No  → Step 9: 建立空 Map freqMap // 以數字為鍵，出現次數為值\n        → Step 10: 針對 nums 中每個元素 val 執行\n            → Step 11: freqMap[val] = freqMap.get(val, 0) + 1 // 累計頻率\n        → Step 12: 設定 result = 0 // 結果計數器\n        → Step 13: 針對 freqMap 中每個鍵 key 執行\n            → Decision: 如果 key + k 存在於 freqMap? // 是否有匹配的數字\n                Yes → result = result + 1 // 形成一對 (key, key + k)\n                No  → // 不計算\n        → Step 14: 回傳 result // 返回 k-diff 對數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def findPairs(self, nums, k):\n        \"\"\"\n        Count unique k-diff pairs in the array.\n        A k-diff pair is a pair of distinct indices (i, j) such that\n        |nums[i] - nums[j]| == k.  Only unique value pairs are counted.\n        \"\"\"\n        if k < 0:\n            # Absolute difference cannot be negative\n            return 0\n\n        freq = Counter(nums)\n\n        if k == 0:\n            # For k == 0 we need numbers that appear at least twice\n            return sum(1 for count in freq.values() if count > 1)\n\n        # For k > 0 count each distinct number that has a counterpart num + k\n        return sum(1 for num in freq if num + k in freq)\n\nif __name__ == \"__main__\":\n    # Read the entire input from stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # Find the closing bracket of the list\n    closing_bracket = raw_input.find(']')\n    if closing_bracket == -1:\n        raise ValueError(\"Input format error: missing ']'\")\n\n    # Extract the list part and the k part\n    list_part = raw_input[:closing_bracket + 1]\n    k_part = raw_input[closing_bracket + 1:].strip()\n\n    # Remove any leading commas or spaces before k\n    k_part = k_part.lstrip(',').strip()\n\n    # Safely parse the list and k\n    nums = ast.literal_eval(list_part)\n    k = int(k_part)\n\n    # Compute and print the result\n    result = Solution().findPairs(nums, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[3,1,4,1,5], 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[1,2,3,4,5], 1",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "[1,3,1,5,4], 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode3.json",
    "problem_index_in_file": 0,
    "title": "Longest Substring Without Repeating Characters",
    "description_snippet": "Given a string s, find the length of the longest substring without duplicate characters....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The requirement: virtual code steps with arrow →, decisions, Start, End. The problem: longest substring without repeating characters. We need to produce algorithm, maybe sliding window with hash map to track last index. We'll produce step-by-step.\n\nWe'll output Start, then read string, initialize variables: maxLen, start index, map. Then loop i over string indices. For each char, if exists in map and index >= start, update start to last index + 1. Update maxLen. Update map with current index. After loop End. Provide explanation per line.\n\nLet's craft.\n\nVirtual code lines:\n\nStart // 開始\n\n→ Step 1: 輸入字串 s // 取得輸入\n\n→ Step 2: 初始化 maxLen = 0, start = 0, lastIndexMap = 空哈希表 // 設定初始變數\n\n→ Step 3: 從 i = 0 到 s.length - 1 逐字母處理 // 進入主迴圈\n\n    → Decision: 若 lastIndexMap 包含 s[i] 且 lastIndexMap[s[i]] ≥ start? // 檢查字元是否重複且在目前窗口內\n        Yes → Step 4: 設置 start = lastIndexMap[s[i]] + 1 // 移動窗口起點到重複字元之後\n        No → // 不作任何改動\n\n    → Step 5: 更新 maxLen = max(maxLen, i - start + 1) // 更新最長長度\n\n    → Step 6: 更新 lastIndexMap[s[i]] = i // 記錄字元最新位置\n\nEnd // 結束\n\nWe also need to maintain indentation? Provide indentation by spaces. Use arrow for steps.\n\nLet's produce.\n\nAlso we need to provide each line explanation after a space and //.\n\nWill produce lines exactly with that pattern.\n\nLet's create final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得使用者輸入的字串  \n→ Step 2: 初始化 maxLen = 0, start = 0, lastIndexMap = 空哈希表 // 用於記錄目前最大長度、窗口起點與每個字元最後出現的位置  \n→ Step 3: 從 i = 0 到 s.length - 1 逐字母處理 // 進入主迴圈  \n  → Decision: 若 lastIndexMap 包含 s[i] 且 lastIndexMap[s[i]] ≥ start? // 判斷字元是否重複且仍在當前窗口內  \n   Yes → Step 4: 設置 start = lastIndexMap[s[i]] + 1 // 把窗口起點移到重複字元之後，排除重複  \n   No → // 若不重複或已在窗口外，保持起點不變  \n  → Step 5: 更新 maxLen = max(maxLen, i - start + 1) // 計算當前窗口長度，更新最大長度  \n  → Step 6: 更新 lastIndexMap[s[i]] = i // 記錄此字元最新的索引位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef length_of_longest_substring(s: str) -> int:\n    \"\"\"\n    計算不含重複字元的最長子字串長度。\n    使用滑動窗口 + 字元最後出現位置映射。\n    \"\"\"\n    last_index = {}          # 字元 -> 最後一次出現的索引\n    start = 0                # 當前窗口起點\n    max_len = 0\n\n    for i, ch in enumerate(s):\n        # 若字元重複且位於當前窗口內，移動起點\n        if ch in last_index and last_index[ch] >= start:\n            start = last_index[ch] + 1\n        # 更新字元最後出現位置\n        last_index[ch] = i\n        # 更新最大長度\n        cur_len = i - start + 1\n        if cur_len > max_len:\n            max_len = cur_len\n\n    return max_len\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 可能的輸入格式有：\n    #   s = \"abcabcbb\"\n    #   abcabcbb\n    # 嘗試從引號中取出字串\n    if 's' in data and '\"' in data:\n        first_quote = data.find('\"')\n        last_quote = data.rfind('\"')\n        if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n            s = data[first_quote + 1:last_quote]\n        else:\n            s = data\n    else:\n        s = data\n\n    result = length_of_longest_substring(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode410.json",
    "problem_index_in_file": 0,
    "title": "Split Array Largest Sum",
    "description_snippet": "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the la...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving the problem: Given array nums, integer k, split into k non-empty subarrays contiguous, minimize largest sum. Classic Leetcode \"Split Array Largest Sum\". Approach: Binary search on possible max sum range [max(nums), sum(nums)] and check feasibility with greedy splitting: count subarrays needed <= k. We'll produce virtual code steps.\n\nWe must output line by line with virtual code and explanation. Use arrows. Provide Start, End, Decision, etc.\n\nLet's craft steps:\n\nStart\n→ Step 1: 讀取 nums, k //取得輸入\n→ Step 2: 計算 low = max(nums), high = sum(nums) //範圍初始化\n→ Decision: low <= high? //準備 binary search loop\n    Yes → Step 3: 進入 BinarySearchLoop //開始二分搜尋\n        → Step 3.1: mid = (low + high) // 2 //中值\n        → Step 3.2: 以 greedy 方法計算需要的 subarray 數\n            → Step 3.2.1: 初始化 count = 1, currentSum = 0\n            → Step 3.2.2: 逐個遍歷 nums\n                → Decision: currentSum + num > mid? //若超過中值\n                    Yes → Step 3.2.3: count++ ; currentSum = num //開始新 subarray\n                    No  → Step 3.2.4: currentSum += num //繼續加進去\n            → Step 3.2.5: 之後得到 count\n        → Decision: count <= k? //能否用 <=k 個分段\n            Yes → Step 3.3: high = mid - 1 //可以減小上界\n            No  → Step 3.4: low = mid + 1 //需要增大下界\n        → Decision: low <= high? //是否還有區間\n            Yes → Go back to Step 3.1\n            No  → Go out of loop\n→ Step 4: 返回 low //最小可能最大子陣列和\nEnd\n\nBut we need to keep format strictly: each line with \"虛擬碼步驟\" + space + comment.\n\nLet's craft each line:\n\nStart // 程式開始執行\n→ Step 1: 讀取 nums, k // 取得輸入\n→ Step 2: 計算 low = max(nums), high = sum(nums) // 初始化搜尋區間\n→ Decision: low <= high? // 判斷是否進入搜尋\n    Yes → Step 3: 進入 BinarySearchLoop // 開始二分搜尋\n        → Step 3.1: mid = (low + high) // 2 // 計算中值\n        → Step 3.2: count = 1; currentSum = 0 // 初始化分段計算\n        → Step 3.3: 逐個遍歷 nums // 循環檢查是否需要新子陣列\n            → Decision: currentSum + num > mid? // 超過允許最大和？\n                Yes → Step 3.3.1: count++ ; currentSum = num // 開新子陣列\n                No  → Step 3.3.2: currentSum += num // 繼續加入\n        → Decision: count <= k? // 是否能在 k 個子陣列內完成\n            Yes → Step 3.4: high = mid - 1 // 可以嘗試更小的最大和\n            No  → Step 3.5: low = mid + 1 // 需要更大的最大和\n        → Decision: low <= high? // 繼續搜尋？\n            Yes → Go back to Step 3.1\n            No  → Exit BinarySearchLoop\n→ Step 4: 返回 low // 最小化的最大子陣列和\nEnd // 程式執行結束\n\nBut we must use the format: each line has \"虛擬碼步驟\" plus comment. The Decision lines should include indentation maybe but still each line separate.\n\nWe need arrow notation: \"→ Step 1: 讀取 nums, k // 取得輸入\" etc.\n\nAlso we may incorporate \"Yes →\" and \"No →\" for decisions.\n\nLet's format each line precisely:\n\nStart // 程式開始執行\n→ Step 1: 讀取 nums, k // 取得輸入\n→ Step 2: 計算 low = max(nums), high = sum(nums) // 初始化搜尋區間\n→ Decision: low <= high? // 判斷是否進入搜尋\n    Yes → Step 3: 進入 BinarySearchLoop // 開始二分搜尋\n        → Step 3.1: mid = (low + high) // 2 // 計算中值\n        → Step 3.2: count = 1; currentSum = 0 // 初始化分段計算\n        → Step 3.3: 逐個遍歷 nums // 循環檢查是否需要新子陣列\n            → Decision: currentSum + num > mid? // 超過允許最大和？\n                Yes → Step 3.3.1: count++ ; currentSum = num // 開新子陣列\n                No  → Step 3.3.2: currentSum += num // 繼續加入\n        → Decision: count <= k? // 是否能在 k 個子陣列內完成\n            Yes → Step 3.4: high = mid - 1 // 嘗試更小的最大和\n            No  → Step 3.5: low = mid + 1 // 需要更大的最大和\n        → Decision: low <= high? // 繼續搜尋？\n            Yes → Go back to Step 3.1\n            No  → Exit BinarySearchLoop\n→ Step 4: 返回 low // 最小化的最大子陣列和\nEnd // 程式執行結束\n\nCheck the format: each line must be \"虛擬碼步驟\" followed by space and comment. The Decision lines: \"Decision: ...\" plus then the Yes/No branches. The arrow usage: \"→ Decision:\" etc. It's okay.\n\nWe should ensure no code but only virtual code. Provide as is.\n\nReturn in one block? It should just output lines. We'll output exactly as lines.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 nums, k // 取得輸入  \n→ Step 2: 計算 low = max(nums), high = sum(nums) // 初始化搜尋區間  \n→ Decision: low <= high? // 判斷是否進入搜尋  \n    Yes → Step 3: 進入 BinarySearchLoop // 開始二分搜尋  \n        → Step 3.1: mid = (low + high) // 2 // 計算中值  \n        → Step 3.2: count = 1; currentSum = 0 // 初始化分段計算  \n        → Step 3.3: 逐個遍歷 nums // 循環檢查是否需要新子陣列  \n            → Decision: currentSum + num > mid? // 超過允許最大和？  \n                Yes → Step 3.3.1: count++ ; currentSum = num // 開新子陣列  \n                No  → Step 3.3.2: currentSum += num // 繼續加入  \n        → Decision: count <= k? // 是否能在 k 個子陣列內完成  \n            Yes → Step 3.4: high = mid - 1 // 嘗試更小的最大和  \n            No  → Step 3.5: low = mid + 1 // 需要更大的最大和  \n        → Decision: low <= high? // 繼續搜尋？  \n            Yes → Go back to Step 3.1  \n            No  → Exit BinarySearchLoop  \n→ Step 4: 返回 low // 最小化的最大子陣列和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def splitArray(self, nums, m):\n        def can_split(mid):\n            count, curr_sum = 1, 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    count += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return count <= m\n\n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if can_split(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\ndef parse_input(data: str):\n    data = data.replace('\\n', ' ')\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    if not k_match:\n        return None, None\n    k = int(k_match.group(1))\n    data = re.sub(r'k\\s*=\\s*\\d+', '', data)\n\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if not nums_match:\n        return None, None\n    nums_str = nums_match.group(1)\n    nums = list(map(int, re.findall(r'-?\\d+', nums_str)))\n    return nums, k\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, k = parse_input(raw_input)\n    if nums is None or k is None:\n        print(\"Invalid input format\")\n    else:\n        result = Solution().splitArray(nums, k)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [7,2,5,10,8], k = 2",
          "expected_output": "18",
          "success": true,
          "output": "18"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2,3,4,5], k = 2",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode274.json",
    "problem_index_in_file": 0,
    "title": "H-Index",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with \"虛擬碼步驟\" and comment after space. Use arrow, Start, End, Decision. The problem: given array citations, compute h-index.\n\nWe need to produce pseudocode. The steps: Sort citations descending. Iterate through sorted array, find max i where citation[i] >= i+1. Then h-index = that i+1.\n\nBut we need to produce virtual code line by line with explanation. Let's produce something like:\n\nStart // start\n→ Step 1: 輸入 citations array // receive input\n→ Step 2: Sort citations in descending order // order citations\n→ Step 3: Initialize hIndex = 0 // start h-index\n→ Step 4: For each citation at index i from 0 to n-1 // iterate\n    → Decision: 如果 citations[i] >= i+1? // check condition\n        Yes → hIndex = i+1 // update h-index\n        No  → No action // stop? Actually we can break after first failure? Usually continue but no update. For simplicity we can break when condition fails. So add break.\n\n→ Step 5: 返回 hIndex // output result\nEnd.\n\nBut the pseudocode should be more detailed maybe with loops.\n\nWe need to use arrow: → Step: ... etc.\n\nInclude decisions with Yes →, No →.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: citations ← InputArray // 取得引用數列\n→ Step 2: Sort citations in descending order // 由高到低排序\n→ Step 3: n ← Length of citations // 獲取數列長度\n→ Step 4: hIndex ← 0 // 初始化 h-index\n→ Step 5: For i ← 0 to n-1 // 逐個檢查每篇論文\n    → Decision: 如果 citations[i] ≥ i+1? // 檢查引用次數是否至少 i+1\n        Yes → hIndex ← i+1 // 更新 h-index 為 i+1\n        No  → Break // 不再可能滿足條件，結束循環\n→ Step 6: Output hIndex // 回傳計算結果\nEnd // 程式執行結束\n\nWe need to ensure each line includes \"虛擬碼步驟\" then comment. Use Chinese. Provide explanation.\n\nWe also may include Step 7: End. But End is separate line.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: citations ← InputArray // 取得輸入的引用數列  \n→ Step 2: Sort citations in descending order // 將引用數由大到小排序  \n→ Step 3: n ← Length of citations // 獲取引用數列的長度  \n→ Step 4: hIndex ← 0 // 初始化 h-index 為 0  \n→ Step 5: For i ← 0 to n-1 // 逐篇檢查每篇論文  \n  → Decision: 如果 citations[i] ≥ i+1? // 判斷第 i+1 篇論文是否至少被引用 i+1 次  \n   Yes → hIndex ← i+1 // 若滿足條件，更新 h-index 為 i+1  \n   No  → Break // 若不滿足，後續論文已無法再提升 h-index，結束迴圈  \n→ Step 6: Output hIndex // 回傳最終計算得到的 h-index  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef h_index(citations):\n    \"\"\"計算並返回 h-index。\"\"\"\n    citations.sort(reverse=True)          # 由大到小排序\n    h = 0\n    for i, c in enumerate(citations):      # 逐篇檢查\n        if c >= i + 1:                     # 需要至少 i+1 次引用\n            h = i + 1\n        else:\n            break                         # 之後不可能再提升 h-index\n    return h\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 只取方括號內的部分，並安全地解析為列表\n    l = data.find('[')\n    r = data.rfind(']') + 1\n    list_str = data[l:r]\n    citations = ast.literal_eval(list_str)\n    result = h_index(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [3,0,6,1,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "citations = [1,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode462.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements II",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving \"minimum moves to equal array elements\". Known solution: move to median (or mean? Actually to minimize sum of absolute deviations, choose median). So algorithm: sort array, find median, sum abs differences.\n\nWe produce virtual code step-by-step. Ensure using Start, Decision, etc. Provide explanations. Each line: \"虛擬碼步驟 // 解釋\". Use arrow characters. Need to ensure it's line by line.\n\nLet's produce steps:\n\nStart\n→ Step 1: Sort nums ascending // Arrange elements\n→ Step 2: Determine median element (index n/2) // Target value\n→ Step 3: Initialize moves = 0 // Accumulator\n→ Step 4: For each num in nums\n    → Step 4a: moves += abs(num - median) // Add distance\n→ Step 5: Return moves // Result\nEnd\n\nAlso maybe include decision: if n is odd/even. But median is defined as nums[n/2] after sort if 0-index. For even, could pick lower median. That still minimal. So we can include decision.\n\nLet's craft.\n\nAlso need to handle input reading? Not necessary.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 先將陣列排好序，以便找中位數  \n→ Step 2: Determine median = nums[length(nums) / 2] // 取得中位數作為目標值  \n→ Decision: 如果 length(nums) 是偶數? // 判斷偶數長度的情況  \n    Yes → Step 3a: median = nums[length(nums) / 2 - 1] // 取較低的中位數（任一中位數皆可）  \n    No  → Step 3b: median 已在 Step 2 設定  \n→ Step 4: Initialize moves = 0 // 計算總步數的累加器  \n→ Step 5: For each num in nums  \n    → Step 5a: moves += abs(num - median) // 加上每個元素與中位數的距離  \n→ Step 6: Return moves // 回傳最小移動步數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\ndef min_moves(nums):\n    \"\"\"Return the minimum number of moves to make all array elements equal.\"\"\"\n    nums.sort()                                 # 排序後便於找中位數\n    median = nums[len(nums) // 2]               # 取中位數（偶數長度時取較低的中位數即可）\n    moves = 0\n    for num in nums:                            # 對每個元素計算距離\n        moves += abs(num - median)\n    return moves\n\ndef main():\n    # 讀取整個標準輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中找出方括號內的內容並轉成 list\n    match = re.search(r'\\[(.*?)\\]', data, re.S)\n    if match:\n        nums = ast.literal_eval('[' + match.group(1) + ']')\n    else:\n        nums = []\n    # 計算並輸出答案\n    print(min_moves(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,10,2,9]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode209.json",
    "problem_index_in_file": 0,
    "title": "Minimum Size Subarray Sum",
    "description_snippet": "Given an array of positive integers nums and a positive integer target, return the minimal length of...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo code for minimal subarray length with sum >= target, sliding window. We'll provide steps. Need to use the given format: each line \"虛擬碼步驟 // 解釋\". Use arrows and decision. Start, End. We need to produce line-by-line.\n\nLet's outline algorithm:\n\nStart\n→ Initialize n = length of nums\n→ Initialize left = 0, current_sum = 0, min_len = INF\n→ Decision: if n == 0? -> if no elements, return 0. (But we can incorporate).\nLoop while right < n:\n→ Step: Add nums[right] to current_sum\n→ Decision: While current_sum >= target:\n    → Update min_len = min(min_len, right-left+1)\n    → Subtract nums[left] from current_sum\n    → left = left + 1\n→ right = right + 1\nAfter loop:\n→ Decision: if min_len == INF? return 0 else return min_len\n\nBut need to follow output format, with arrows and decisions. Must not use actual code syntax, just pseudo.\n\nLet's produce lines with arrow formatting.\n\nWe need to keep each line as \"虛擬碼步驟 // 解釋\". Use arrow \"→\" before each step, \"Decision:\" etc.\n\nWe need to maintain structure: Start, End. Use indentation maybe? The format example uses indent inside decisions.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: left ← 0, current_sum ← 0, min_len ← ∞ // 初始化指標與最小長度\n→ Decision: 如果 n == 0? // 檢查是否為空陣列\n    Yes → Step 3: 返回 0 // 空陣列直接回傳 0\n    No  → Step 4: right ← 0 // 否則從索引 0 開始\n→ Loop: while right < n\n    → Step 5: current_sum ← current_sum + nums[right] // 加入右端元素\n    → Decision: 當 current_sum >= target? // 是否已達目標\n        Yes →\n            → Step 6: min_len ← min(min_len, right - left + 1) // 更新最小長度\n            → Step 7: current_sum ← current_sum - nums[left] // 移除左端元素\n            → Step 8: left ← left + 1 // 左指標右移\n            → Decision: 重複 while current_sum >= target? // 繼續收縮\n                Yes → 回到上一步的 Step 7\n                No  →  // 退出收縮\n        No  → // 不足以達到目標，繼續擴大右指標\n    → Step 9: right ← right + 1 // 右指標右移\n→ Decision: 如果 min_len == ∞? // 是否找到合法子陣列\n    Yes → Step 10: 返回 0 // 未找到，回傳 0\n    No  → Step 11: 返回 min_len // 返回最小長度\nEnd // 程式執行結束\n\nWe should ensure each line includes the pseudo step and comment. Indentation inside decisions maybe not necessary but we can mimic.\n\nThe format example uses indentation lines after Decision. We'll replicate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← length(nums) // 取得陣列長度  \n→ Step 2: left ← 0, current_sum ← 0, min_len ← ∞ // 初始化指標與最小長度  \n→ Decision: 如果 n == 0? // 檢查是否為空陣列  \n&nbsp;&nbsp;Yes → Step 3: 返回 0 // 空陣列直接回傳 0  \n&nbsp;&nbsp;No  → Step 4: right ← 0 // 否則從索引 0 開始  \n→ Loop: while right < n  \n&nbsp;&nbsp;→ Step 5: current_sum ← current_sum + nums[right] // 加入右端元素  \n&nbsp;&nbsp;→ Decision: 當 current_sum >= target? // 是否已達目標  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 6: min_len ← min(min_len, right - left + 1) // 更新最小長度  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 7: current_sum ← current_sum - nums[left] // 移除左端元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 8: left ← left + 1 // 左指標右移  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: 重複 while current_sum >= target? // 繼續收縮  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → 回到上一步的 Step 7  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 退出收縮  \n&nbsp;&nbsp;&nbsp;&nbsp;No  → // 不足以達到目標，繼續擴大右指標  \n&nbsp;&nbsp;→ Step 9: right ← right + 1 // 右指標右移  \n→ Decision: 如果 min_len == ∞? // 是否找到合法子陣列  \n&nbsp;&nbsp;Yes → Step 10: 返回 0 // 未找到，回傳 0  \n&nbsp;&nbsp;No  → Step 11: 返回 min_len // 返回最小長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minSubArrayLen(self, target, nums):\n        left = 0\n        total = 0\n        min_len = float('inf')\n        for right, val in enumerate(nums):\n            total += val\n            while total >= target:\n                min_len = min(min_len, right - left + 1)\n                total -= nums[left]\n                left += 1\n        return 0 if min_len == float('inf') else min_len\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Extract all integers; first is target, rest are nums\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    target = numbers[0]\n    nums = numbers[1:]\n    result = Solution().minSubArrayLen(target, nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "target = 7, nums = [2,3,1,2,4,3]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "target = 4, nums = [1,4,4]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "target = 11, nums = [1,1,1,1,1,1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode69.json",
    "problem_index_in_file": 0,
    "title": "Sqrt(x)",
    "description_snippet": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate a virtual code in steps to compute integer sqrt without built-in exponent. Use binary search. Steps: Start, read x, handle x < 2 return x. else binary search low=1, high=x//2. While low <= high: mid=(low+high)//2; if mid*mid <= x and (mid+1)*(mid+1) > x: return mid; elif mid*mid < x: low=mid+1 else high=mid-1. End.\n\nWe output virtual code step lines with explanation. Format: each line: virtual step + \" // explanation\". Use arrow \"→\". We need to include Decision lines. Use indent for nested steps? In example, indentation inside decision. We can do like:\n\nStart // 程式開始執行\n→ Step 1: 輸入非負整數 x // 取得輸入\n→ Decision: 如果 x 小於 2? // 檢查簡單情況\n    Yes → Step 2: 回傳 x // 直接回傳\n    No  → Step 3: 設定 low = 1 // 初始低界\n→ Step 4: 設定 high = x // 2 // 初始高界\n→ While low ≤ high: // 二分搜尋\n    → Step 5: mid = (low + high) // 2 // 取中點\n    → Decision: 如果 mid*mid ≤ x 且 (mid+1)*(mid+1) > x? // 檢查是否為答案\n        Yes → Step 6: 回傳 mid // 結束\n        No  → Decision: 如果 mid*mid < x? // 需要往右\n            Yes → Step 7: low = mid + 1 // 將 low 提升\n            No  → Step 8: high = mid - 1 // 將 high 降低\nEnd // 程式結束\n\nBut must use virtual code arrow with decisions. We need to include \"Decision:\" lines with conditions. The indentation as per example.\n\nAlso ensure not to use built-in exponent function. Use multiplication.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入非負整數 x // 從使用者處取得輸入  \n→ Decision: x < 2? // 檢查是否為 0 或 1  \n Yes → Step 2: 回傳 x // 直接回傳，因為 0 和 1 的平方根就是它們本身  \n No → Step 3: 設定 low = 1 // 初始化二分搜尋的下界  \n→ Step 4: 設定 high = x // 2 // 上界可設為 x 的一半，對於 x ≥ 2 足夠  \n→ Decision: low ≤ high? // 開始二分搜尋迴圈  \n Yes → Step 5: mid = (low + high) // 2 // 計算中點  \n  Decision: mid*mid ≤ x 且 (mid+1)*(mid+1) > x? // 判斷 mid 是否為整數平方根  \n   Yes → Step 6: 回傳 mid // 找到答案，結束程式  \n   No → Decision: mid*mid < x? // 若 mid^2 小於 x，需要搜尋更大的數  \n    Yes → Step 7: low = mid + 1 // 把下界往右移  \n    No → Step 8: high = mid - 1 // 否則把上界往左移  \n      → Decision: low ≤ high? // 迴圈是否還有下一次  \n       Yes → 重新執行 Step 5  \n       No → Step 9: 回傳 low - 1 // 迴圈結束，返回最接近的整數平方根  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef integer_sqrt(x: int) -> int:\n    \"\"\"\n    回傳非負整數 x 的整數平方根（向下取整）。\n    這裡使用二分搜尋，避免使用任何指數運算。\n    \"\"\"\n    if x < 2:          # 0 或 1 的平方根就是它們本身\n        return x\n\n    left, right = 1, x // 2\n    while left <= right:\n        mid = (left + right) // 2\n        sq = mid * mid\n        if sq == x:\n            return mid          # 找到精確平方根\n        elif sq < x:\n            left = mid + 1      # 需要更大的數\n        else:\n            right = mid - 1     # 需要更小的數\n    return right  # right 是最大的滿足 right*right <= x 的值\n\ndef main():\n    data = sys.stdin.read()\n    # 從輸入中提取第一個出現的整數（允許正負號）\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    x = int(match.group(0))\n    result = integer_sqrt(x)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 8",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode385.json",
    "problem_index_in_file": 0,
    "title": "Mini Parser",
    "description_snippet": "Given a string s represents the serialization of a nested list, implement a parser to deserialize it...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for parsing nested list serialization string s. The description: Each element is either integer or list; list serialized like \"[1,2,[3,4],5]\" typical Leetcode problem.\n\nWe need to produce virtual code lines with explanations.\n\nWe should not produce actual code. Use Start, End, Decision: Yes/No. Each line: \"→ Step X: ...\" etc.\n\nWe must produce step-by-step.\n\nWe need to parse string s, using a stack. For each char, if digit or '-' accumulate number, if '[' push new NestedInteger list onto stack, if ',' ignore if building number, if ']' pop current number and nested list. At end, return top.\n\nLet's produce virtual code:\n\nStart\n→ Step 1: Initialize stack as empty list // 堆疊用於保存目前層次的 NestedInteger\n→ Decision: 如果 s 為空字符串? // 判斷輸入是否為單純數字\n    Yes → Step 2: Return NestedInteger( int(s) ) // 直接回傳整數\n    No  → Continue\n→ Step 3: For each character c in s // 遍歷序列化字串\n    → Decision: 如果 c 為 '['? // 開始新子列表\n        Yes → Step 4: Create new NestedInteger() // 新建空列表\n               → Step 5: Push onto stack // 放進堆疊\n    → Decision: 如果 c 為 ']'? // 子列表結束\n        Yes → Step 6: If currentNumber not null? // 有累積數字則先入列表\n                 → Step 7: Append currentNumber to stack.top()\n                 → Step 8: Reset currentNumber\n            → Step 9: If stack size > 1? // 如果不是最外層\n                 → Step 10: Pop top NestedInteger as completedList\n                 → Step 11: Append completedList to new top of stack // 將子列表加入父層\n            → Step 12: Else // 最外層列表已完成\n                 → Step 13: Pop stack // 清空堆疊\n    → Decision: 如果 c 為 ','? // 元素分隔符\n        Yes → Step 14: If currentNumber not null? // 如果前面有數字\n                 → Step 15: Append currentNumber to stack.top()\n                 → Step 16: Reset currentNumber\n        No → Continue\n    → Decision: 如果 c 為 數字或 '-'? // 數字字符\n        Yes → Step 17: Append c to currentNumberString // 累積數字字符\n→ Step 18: After loop, 如果 currentNumber not null? // 最後可能剩餘數字\n        → Step 19: Append currentNumber to stack.top()\n→ Step 20: Return stack.top() // 最終結果\nEnd\n\nBut need to keep format exactly as per requirement: each line starts with arrow \"→\" except Start and End lines. And include explanations after //.\n\nWe need to ensure we don't output code but virtual code lines.\n\nWe also need to keep decision branches as separate lines.\n\nLet's write more concise.\n\nWe might need to mention \"currentNumber\" variable.\n\nAlso \"currentNumberString\" may be char builder.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空堆疊 stack // 用來儲存目前層次的 NestedInteger  \n→ Decision: 如果 s 為空字串? // 判斷是否只是一個單純的數字  \n    Yes → Step 2: 回傳 NestedInteger( int(s) ) // 直接回傳整數結果  \n    No  → Step 3: 初始化變數 currentNumStr = \"\" // 用於累積數字字串  \n→ Step 4: 對於每個字元 c in s  \n    → Decision: 如果 c 為 '['? // 開始新的子列表  \n        Yes → Step 5: 建立新的 NestedInteger() // 空列表物件  \n              → Step 6: push 到 stack // 放入堆疊中  \n    → Decision: 如果 c 為 ']'? // 子列表結束  \n        Yes → Step 7: 如果 currentNumStr 不是空? // 有累積數字  \n              → Step 8: 將 int(currentNumStr) 加到 stack.top() 的元素中  \n              → Step 9: 清空 currentNumStr  \n           → Step 10: 取得 stack.top() 作為完成的子列表 completedList  \n           → Decision: 如果 stack.size > 1? // 是否還有父層  \n                Yes → Step 11: pop 出 completedList  \n                       → Step 12: 把 completedList 加到新的 stack.top()  \n                No  → Step 13: pop 出 completedList // 最外層已完成  \n    → Decision: 如果 c 為 ','? // 元素分隔符  \n        Yes → Step 14: 如果 currentNumStr 不是空? // 前面有數字  \n              → Step 15: 把 int(currentNumStr) 加到 stack.top()  \n              → Step 16: 清空 currentNumStr  \n        No  → Step 17: 繼續處理下一個字元  \n    → Decision: 如果 c 為數字或 '-'? // 數字字元  \n        Yes → Step 18: 把 c 加到 currentNumStr  // 累積數字  \n→ Step 19: 循環結束後，判斷 currentNumStr 不是空? // 最後可能還剩餘數字  \n        → Step 20: 把 int(currentNumStr) 加到 stack.top()  \n→ Step 21: 回傳 stack.top() // 解析完成後的 NestedInteger  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass NestedInteger:\n    \"\"\"簡易實作 NestedInteger，支援整數或列表，並可輸出為字串。\"\"\"\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._int = None\n        else:\n            self._list = None\n            self._int = value\n\n    def isInteger(self):\n        return self._int is not None\n\n    def add(self, elem):\n        if self._list is not None:\n            self._list.append(elem)\n\n    def getInteger(self):\n        return self._int\n\n    def getList(self):\n        return self._list\n\n    def __str__(self):\n        if self.isInteger():\n            return str(self._int)\n        else:\n            return '[' + ','.join(str(x) for x in self._list) + ']'\n\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        # 單個整數情形\n        if s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        num = ''\n        negative = False\n\n        for c in s:\n            if c == '-':\n                negative = True\n            elif c.isdigit():\n                num += c\n            elif c == '[':\n                stack.append(NestedInteger())\n            elif c in ',]':\n                if num:\n                    value = int(num) if not negative else -int(num)\n                    stack[-1].add(NestedInteger(value))\n                    num = ''\n                    negative = False\n                if c == ']' and len(stack) > 1:\n                    child = stack.pop()\n                    stack[-1].add(child)\n\n        return stack[0]\n\n\ndef extract_string(line: str) -> str:\n    \"\"\"從輸入行中提取引號內的內容。若無引號則直接返回整行。\"\"\"\n    start = line.find('\"')\n    end = line.rfind('\"')\n    if start != -1 and end != -1 and end > start:\n        return line[start+1:end]\n    return line.strip()\n\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    # 只取第一行（或全部）\n    first_line = raw_input.strip().splitlines()[0] if raw_input else ''\n    s = extract_string(first_line)\n    sol = Solution()\n    result = sol.deserialize(s)\n    print(str(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"324\"",
          "expected_output": "324",
          "success": true,
          "output": "324"
        },
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "success": true,
          "output": "[123,[456,[789]]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode477.json",
    "problem_index_in_file": 0,
    "title": "Total Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanations, following the format. The requirement: \"Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.\" We need to output virtual code steps that calculate sum of Hamming distances for all pairs.\n\nWe should explain algorithm: For each bit position 0..31, count number of numbers with bit set. Then contributions to sum from that bit is count_set * count_unset * 2? Actually Hamming distance sum over all pairs: each pair contributes 1 if bits differ at a position. So for each bit, number of pairs with differing bits is set * unset. Sum over all bits. But careful: Each pair counted once, no factor 2. So answer = sum_{bit} set * unset * 2? Wait each pair counted once for that bit. So for each pair, if bits differ, contributes 1. Count of pairs where bits differ is set * unset. So sum is sum over bits of set*unset. But note that we count each pair once across all bits. So answer = sum_{bit} set * unset. But we also might multiply by 2? Let's verify: Suppose we compute set*unset for each bit. For pair (a,b), if bits differ at that bit, the pair is counted once. So sum over all bits of set*unset gives total hamming distances across all pairs. So no factor 2. However, some solutions multiply by 2 because they count each pair twice (i<j and j>i). But we count each unordered pair only once. Usually problem definition: sum over all pairs i<j. So answer is sum(set * unset) across bits. So we can produce code accordingly.\n\nNow produce virtual code lines. We'll include steps:\n\nStart\n→ Input nums // array\n→ Initialize result = 0 // sum\n→ For bit from 0 to 31 // iterate bits\n    → Count set = 0 // number of nums with bit set\n    → For each num in nums\n        → If (num >> bit) & 1 == 1\n            → set += 1 // increment\n    → unset = len(nums) - set // number without bit\n    → result += set * unset // add contribution\n→ End // output result\n\nBut must include decision for bit extraction.\n\nUse arrow formatting with \"→\". Use Decision: etc.\n\nMake each line a virtual code step plus explanation.\n\nLet's produce as requested.\n\nAlso need to use \"Start\" and \"End\".\n\nWe need to include decision for bit extraction? Might use Decision to check bit.\n\nWe'll structure accordingly.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Input nums // 從使用者取得整數陣列\n→ result ← 0 // 初始化總 Hamming 距離和\n→ For bit ← 0 To 31 // 逐位處理 32 位元\n    → setCount ← 0 // 記錄此位元為 1 的數字數量\n    → For each num in nums // 遍歷陣列\n        → Decision: (num >> bit) & 1 == 1? // 取第 bit 位\n            Yes → setCount ← setCount + 1 // 若為 1，計數加 1\n            No  → // 無操作，保持原值\n    → unsetCount ← len(nums) - setCount // 此位元為 0 的數字數量\n    → result ← result + setCount * unsetCount // 此位對總距離的貢獻\n→ End // 程式執行結束，回傳 result",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def totalHammingDistance(self, nums):\n        \"\"\"\n        Calculate the sum of Hamming distances between all pairs in nums.\n        For each bit position (0-31), count how many numbers have that bit set.\n        The contribution of that bit to the total sum is count_ones * count_zeros.\n        \"\"\"\n        total = 0\n        n = len(nums)\n        for bit in range(32):                     # 32-bit integers\n            count_ones = sum((num >> bit) & 1 for num in nums)\n            count_zeros = n - count_ones\n            total += count_ones * count_zeros\n        return total\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract all integers from the input string (handles \"nums = [4,14,2]\" etc.)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # Compute and print the result\n    result = Solution().totalHammingDistance(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,14,2]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [4,14,4]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode115.json",
    "problem_index_in_file": 0,
    "title": "Distinct Subsequences",
    "description_snippet": "Given two strings s and t, return the number of distinct subsequences of s which equals t.\n\nThe test...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for counting distinct subsequences of s that equal t. Classic DP: dp[i][j] count of subseqs of s[0..i-1] equal t[0..j-1]. Complexity O(n*m). We'll produce step-by-step pseudocode lines. Need to follow format: each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows etc. Provide start, end, decisions.\n\nWe need to produce lines for algorithm: input s,t, initialize dp array of size (len(s)+1)*(len(t)+1) with 0, dp[0][0]=1. Then iterate i from 1..len(s): dp[i][0]=1 (empty t). Then nested j: if s[i-1]==t[j-1] then dp[i][j]=dp[i-1][j-1]+dp[i-1][j] else dp[i][j]=dp[i-1][j]. At end return dp[len(s)][len(t)]. We'll write virtual code with decisions for equality. We need \"Start\", \"End\". Use arrow syntax. Ensure each line ends with comment.\n\nLet's produce step lines:\n\nStart // 程式開始執行\n→ Step 1: 讀入字串 s, t // 取得輸入字串\n→ Step 2: 定義變數 n = len(s), m = len(t) // 字串長度\n→ Step 3: 建立 2D 陣列 dp(n+1, m+1) 全 0 // 初始化 DP 表\n→ Step 4: dp[0][0] = 1 // 空字串對空字串只有一種子序列\n→ Step 5: for i from 1 to n do // 遍歷 s 的每個字元\n    → Step 5.1: dp[i][0] = 1 // 任意子序列匹配空 t\n    → Step 5.2: for j from 1 to m do // 遍歷 t 的每個字元\n        → Decision: s[i-1] == t[j-1] ? // 判斷兩字元是否相同\n            Yes → Step 5.2.1: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] // 匹配 + 不匹配\n            No  → Step 5.2.2: dp[i][j] = dp[i-1][j] // 只保留不匹配的子序列\n→ Step 6: return dp[n][m] // 結果為完整 s 對完整 t 的子序列數\nEnd // 程式執行結束\n\nWe need to ensure each line has \"→\" arrow only after the Start? Actually after Start we can use \"→\" for steps. Indent inside loops? Use arrow maybe. The example shows nested arrow with indentation. Use consistent formatting. Provide each line as separate line.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀入字串 s, t // 取得輸入字串  \n→ Step 2: 定義變數 n = len(s), m = len(t) // 計算兩個字串長度  \n→ Step 3: 建立 2D 陣列 dp(n+1, m+1) 全 0 // 初始化 DP 表  \n→ Step 4: dp[0][0] = 1 // 空字串對空字串只有一種子序列  \n→ Step 5: for i from 1 to n do // 遍歷 s 的每個字元  \n  → Step 5.1: dp[i][0] = 1 // 任意子序列匹配空 t  \n  → Step 5.2: for j from 1 to m do // 遍歷 t 的每個字元  \n    → Decision: s[i-1] == t[j-1] ? // 判斷兩字元是否相同  \n      Yes → Step 5.2.1: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] // 匹配 + 不匹配  \n      No  → Step 5.2.2: dp[i][j] = dp[i-1][j] // 只保留不匹配的子序列  \n→ Step 6: return dp[n][m] // 結果為完整 s 對完整 t 的子序列數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        m, n = len(s), len(t)\n        # dp[i][j] 表示 s 的前 i 個字元中有多少種子序列等於 t 的前 j 個字元\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        # 空字串 t 可以被任何子序列匹配，故 dp[i][0] = 1\n        for i in range(m + 1):\n            dp[i][0] = 1\n        # 動態規劃\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 從輸入中擷取兩個被雙引號包圍的字串\n    matches = re.findall(r'\"([^\"]*)\"', data)\n    if len(matches) >= 2:\n        s, t = matches[0], matches[1]\n    else:\n        # 若沒有雙引號，嘗試直接以空白分割\n        parts = data.split()\n        s = parts[0] if len(parts) > 0 else \"\"\n        t = parts[1] if len(parts) > 1 else \"\"\n    result = Solution().numDistinct(s, t)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode211.json",
    "problem_index_in_file": 0,
    "title": "Design Add and Search Words Data Structure",
    "description_snippet": "Design a data structure that supports adding new words and finding if a string matches any previousl...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps with comments. It's a design of WordDictionary with addWord and search supporting '.' wildcard. Likely use Trie. Steps: Start, Initialize root node, addWord: insert into trie, search: DFS recursion to match. Provide virtual code with decision structures. Must be line-by-line, each line: \"虛擬碼步驟 // 解釋\". Use arrow symbol. Let's produce.\n\nWe need to design data structure and algorithm. Virtual code steps: Start, define Node class with children map and isEnd flag. WordDictionary constructor: initialize root. addWord(word): iterate characters, create nodes, set end flag. search(word): recursive function. Use DFS: at position, if char '.' iterate all children; else follow specific child. If end reached and at end of word -> return true. Use Decision to check. Provide virtual code accordingly.\n\nLet's output step-by-step. Ensure each line has \"虛擬碼步驟 // 解釋\". Use arrow → and Decision: with Yes →, No →. Let's craft.\n\nAlso include Start and End.\n\nWe need to show virtual code for entire design, including methods. Provide structure. Use \"WordDictionary\" class. But since it's virtual code, we may write lines like \"Start // 程式開始執行\" then \"→ Class Node // 定義 Trie 節點\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Node // 定義 Trie 節點  \n  → Attribute children : Map<Char, Node> // 儲存子節點  \n  → Attribute isEnd : Bool // 標記是否為單詞結束點  \n→ Class WordDictionary // 主資料結構  \n  → Attribute root : Node // Trie 根節點  \n  → Constructor WordDictionary()  \n   → root ← New Node() // 初始化根節點  \n  → Method addWord(word : String) // 新增單詞  \n   → current ← root // 從根節點開始  \n   → For each ch in word  \n     Decision: current.children 是否包含 ch? // 檢查子節點是否存在  \n      Yes → current ← current.children[ch] // 直接往下  \n      No → newNode ← New Node(); current.children[ch] ← newNode; current ← newNode // 新建節點  \n   → current.isEnd ← True // 標記單詞結束  \n  → Method search(word : String) : Bool // 查詢是否存在匹配的單詞  \n   → Return DFS(root, word, 0) // 從根節點開始遞迴  \n  → Function DFS(node : Node, word : String, idx : Int) : Bool // 深度優先搜尋  \n    Decision: idx == word.length? // 到達字串尾端  \n     Yes → Return node.isEnd // 若是結束點則匹配成功  \n     No → ch ← word[idx] // 取目前字元  \n     Decision: ch == '.'? // 判斷是否為通配符  \n      Yes → For each childNode in node.children.values()  \n        If DFS(childNode, word, idx + 1) Return True // 任一子節點成功即匹配  \n        Return False // 所有子節點失敗  \n      No → Decision: node.children 是否包含 ch? // 是否有對應字元  \n       Yes → Return DFS(node.children[ch], word, idx + 1) // 直接遞迴  \n       No → Return False // 沒有對應字元，匹配失敗  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for ch in word:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.is_end = True\n\n    def search(self, word: str) -> bool:\n        def dfs(node: TrieNode, i: int) -> bool:\n            if i == len(word):\n                return node.is_end\n            ch = word[i]\n            if ch == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            if ch not in node.children:\n                return False\n            return dfs(node.children[ch], i + 1)\n        return dfs(self.root, 0)\n\ndef parse_input() -> tuple:\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if len(lines) == 1:\n        # Single line containing two lists separated by '],'\n        line = lines[0]\n        idx = line.index(']')\n        first = line[:idx+1]\n        second = line[idx+2:]  # skip '],'\n        ops = json.loads(first)\n        args = json.loads(second)\n    else:\n        ops = json.loads(lines[0])\n        args = json.loads(lines[1])\n    return ops, args\n\ndef main() -> None:\n    ops, args = parse_input()\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"WordDictionary\":\n            obj = WordDictionary()\n            res.append(None)\n        elif op == \"addWord\":\n            obj.addWord(arg[0])\n            res.append(None)\n        elif op == \"search\":\n            res.append(obj.search(arg[0]))\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"],[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]",
          "expected_output": "[null,null,null,null,false,true,true,true]",
          "success": true,
          "output": "[null, null, null, null, false, true, true, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode507.json",
    "problem_index_in_file": 0,
    "title": "Perfect Number",
    "description_snippet": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code. Steps: Start, Step: Input n, Decision: n <= 1? (since perfect numbers are >1). If <=1 → return false. Then compute sum of divisors excluding n: loop i from 1 to sqrt(n), if i divides n: add i if i != n; also add n/i if n/i != i and n/i != n. Then compare sum == n. Return true/false. End. Use arrow, decision. Let's output each line.\n\nWe need to use \"虛擬碼步驟\" + space + // explanation. Use Start, End. Use arrow. Provide decisions. Let's produce lines.\n\nRemember: \"Step:\" lines. Use \"Decision:\" lines with Yes → and No →.\n\nWe must include \"→\" for steps.\n\nLet's write.\n\nAlso need to ensure using \"Start\" and \"End\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 n // 取得要檢查的數字  \n→ Decision: n 是否小於或等於 1? // 1 不是完數，且小於 1 的數不能是完數  \n Yes → Step 2: 回傳 False // 若 n <= 1，直接回傳偽  \n No  → Step 3: 設定 sumDiv 為 1 // 1 是所有正整數的公因子，初始化和  \n  → Step 4: 設定 limit 為 floor(√n) // 只需要檢查到平方根即可  \n  → Step 5: 從 i = 2 到 limit 循環  \n   → Decision: n 是否能被 i 整除? // 檢查 i 是否為 n 的因子  \n    Yes → Step 6: sumDiv 加 i // 把 i 加到總和  \n     → Decision: n / i 是否不等於 i 且不等於 n? // 防止重複加平方根或自身  \n      Yes → Step 7: sumDiv 加 n / i // 加另一個對應因子  \n      No  → Step 8: 跳過 // 已經加過或是 n 本身  \n    No  → Step 9: 跳過 // i 不是因子，直接進下一個  \n  → Decision: sumDiv 是否等於 n? // 檢查是否為完數  \n   Yes → Step 10: 回傳 True // n 為完數  \n   No  → Step 11: 回傳 False // n 不是完數  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        \"\"\"\n        判斷 num 是否為完數。\n        完數定義：正整數等於其真因數（除自身外）的和。\n        \"\"\"\n        if num < 2:  # 1 不是完數，且 n <= 0 也不是\n            return False\n\n        total = 1  # 1 是所有正整數的因子\n        i = 2\n        while i * i <= num:\n            if num % i == 0:\n                total += i\n                other = num // i\n                if other != i and other != num:\n                    total += other\n            i += 1\n\n        return total == num\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    # 讀取輸入，預期為單行整數\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    try:\n        n = int(data)\n    except ValueError:\n        print(\"false\")\n        sys.exit()\n\n    sol = Solution()\n    result = sol.checkPerfectNumber(n)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "28",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "7",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode476.json",
    "problem_index_in_file": 0,
    "title": "Number Complement",
    "description_snippet": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The task: given integer num, return its complement by flipping all bits of its binary representation. So we need to compute complement. Approach: find bit length, compute mask of all 1's of that length, then XOR num with mask. Or flip bits of num until mask. So steps: Start, Step 1: Input num, Step 2: Determine binary length. Step 3: Build mask (2^len - 1). Step 4: Complement = num XOR mask. Step 5: Output complement. End.\n\nUse virtual code arrow syntax. Provide each line with comment. Also decision? Not necessary, just straight. But we could include decision to compute length. Let's produce simple sequential steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數 num // 從使用者輸入取得數值\n→ Step 2: 計算 num 的二進制長度 len = ⌊log2(num)⌋ + 1 // 確定需要翻轉的位數\n→ Step 3: 建立遮罩 mask = (1 << len) - 1 // 所有位都為 1 的遮罩\n→ Step 4: 取反結果 comp = num XOR mask // 逐位翻轉\n→ Step 5: 輸出 comp // 回傳結果\nEnd // 程式執行結束\n\nAdd comments accordingly. Let's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數 num // 從使用者輸入取得數值  \n→ Step 2: 計算 num 的二進制長度 len = ⌊log2(num)⌋ + 1 // 確定需要翻轉的位數  \n→ Step 3: 建立遮罩 mask = (1 << len) - 1 // 所有位都為 1 的遮罩  \n→ Step 4: 取反結果 comp = num XOR mask // 逐位翻轉  \n→ Step 5: 輸出 comp // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        \"\"\"\n        取得 num 的二進位長度，建立全 1 掩碼，\n        然後用 XOR 將每一位翻轉得到補碼。\n        \"\"\"\n        bit_length = num.bit_length()          # 取得二進位長度\n        mask = (1 << bit_length) - 1           # 全 1 的掩碼\n        return num ^ mask                      # 逐位翻轉\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取格式為 'num = <整數>' 的字串，\n    解析得到整數後計算並輸出其補碼。\n    \"\"\"\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 解析數字\n    try:\n        # 例： 'num = 5' -> 5\n        _, value_part = raw_input.split('=', 1)\n        num = int(value_part.strip())\n    except ValueError:\n        # 如果解析失敗，直接終止\n        return\n\n    # 計算補碼\n    solution = Solution()\n    complement = solution.findComplement(num)\n\n    # 輸出結果\n    print(complement)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "num = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode703.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in a Stream",
    "description_snippet": "You are part of a university admissions office and need to keep track of the kth highest test score ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps. For a class that maintains kth largest using min-heap of size k. Steps: init with k and array; build heap of first k numbers; then for each remaining number > smallest, replace; add method: insert val into heap, maybe pop if size>k; return heap.peek. Provide step-by-step.\n\nWe must output each line with virtual code and comment. Use arrow notation. Provide Start, End.\n\nLet's create pseudo-code for class KthLargest with constructor and add method. Also need to maintain heap. Use steps.\n\nWe need to show initialization: Start, Step 1: Initialize k and empty min-heap, Step 2: For each number in nums: add to heap via addNumber function, but if heap size > k pop smallest. Step 3: Store heap. End of init.\n\nAdd method: Step 1: Insert val into heap, Step 2: If heap size > k, pop smallest, Step 3: Return heap.peek (kth largest). End.\n\nAlso need to define addNumber used in init.\n\nLet's produce pseudo-code with arrows. Each line should be \"虛擬碼步驟 // 解釋\". Use \"→\" to denote next step. Use \"Decision:\" for if.\n\nLet's start with Start. Then class KthLargest. But we just output pseudo-code steps, not actual class syntax? Probably show the logic.\n\nOk produce:\n\nStart // 程式開始\n→ Class KthLargest // 定義 KthLargest 類別\n    → Field: k // 儲存 k 的值\n    → Field: minHeap // 儲存最小堆，大小不超過 k\n    → Constructor(k, nums) // 初始化\n        → Step: set this.k = k // 設定 k\n        → Step: initialize this.minHeap as empty min-heap // 建立空堆\n        → Step: for each num in nums // 對初始數組進行處理\n            → Decision: if minHeap.size < k? // 堆未滿 k\n                Yes → Add num to minHeap // 直接加入堆\n                No  → Decision: if num > minHeap.peek()? // 堆已滿，檢查是否需要替換\n                    Yes → Remove minHeap.peek() // 移除最小值\n                    No  → No action // 保留現有堆\n                → Add num to minHeap // 將 num 加入堆（如果已移除）\n        → End // 完成初始化\n    → Method add(val) // 新增分數\n        → Step: if minHeap.size < k? // 堆未滿\n            Yes → Add val to minHeap // 加入\n            No  → Decision: if val > minHeap.peek()? // 堆已滿，檢查是否大於最小\n                Yes → Remove minHeap.peek() // 移除最小\n                No  → No action // 保留\n            → Add val to minHeap // 加入 val（如果已移除）\n        → Step: return minHeap.peek() // 返回第 k 大的分數\nEnd // 程式結束\n\nWe need to adhere to format: each line with \"虛擬碼步驟\" + space + \"// 解釋\". So need to write lines accordingly.\n\nUse indentation but ensure each line starts with arrow? We can use \"→\" to denote each step. For nested steps, indent with spaces. We need \"Decision:\" lines. Example: \"Decision: if minHeap.size < k?\" etc. Provide explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始\n→ Class KthLargest // 定義 KthLargest 類別\n    → Field: k // 儲存 k 的值\n    → Field: minHeap // 儲存最小堆，大小不超過 k\n    → Constructor(k, nums) // 初始化\n        → Step: set this.k = k // 設定 k\n        → Step: initialize this.minHeap as empty min-heap // 建立空堆\n        → Step: for each num in nums // 逐一處理初始分數\n            → Decision: if minHeap.size < k? // 堆未滿 k 個元素\n                Yes → Add num to minHeap // 直接加入堆\n                No  → Decision: if num > minHeap.peek()? // 堆已滿，檢查是否要替換\n                    Yes → Remove minHeap.peek() // 移除最小的分數\n                    No  → No action // 保留現有堆\n                → Add num to minHeap // 若已移除最小，將 num 加入堆\n        → End // 完成初始化\n    → Method add(val) // 新增分數\n        → Decision: if minHeap.size < k? // 堆未滿 k 個元素\n            Yes → Add val to minHeap // 直接加入堆\n            No  → Decision: if val > minHeap.peek()? // 堆已滿，檢查是否比最小大\n                Yes → Remove minHeap.peek() // 移除最小的分數\n                No  → No action // 保留\n            → Add val to minHeap // 若已移除最小，將 val 加入堆\n        → Step: return minHeap.peek() // 回傳當前第 k 大的分數\nEnd // 程式結束",
      "generated_code": "import sys\nimport heapq\nimport ast\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        return\n    # Wrap input into a tuple to parse as a Python literal\n    try:\n        data = ast.literal_eval('(' + data_str + ')')\n    except Exception:\n        # Fallback: try direct evaluation if already a tuple\n        data = ast.literal_eval(data_str)\n    ops, args = data[0], data[1]\n\n    result = []\n    kth_obj = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            kth_obj = KthLargest(arg[0], arg[1])\n            result.append(None)\n        elif op == \"add\":\n            result.append(kth_obj.add(arg))\n\n    # Format output with 'null' for None\n    output = '[' + ', '.join('null' if x is None else str(x) for x in result) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmppduw_bfu.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmppduw_bfu.py\", line 37, in main\n    result.append(kth_obj.add(arg))\n                  ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppduw_bfu.py\", line 13, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpdqbbxlxj.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmpdqbbxlxj.py\", line 37, in main\n    result.append(kth_obj.add(arg))\n                  ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdqbbxlxj.py\", line 13, in add\n    heapq.heappush(self.min_heap, val)\nTypeError: '<' not supported between instances of 'list' and 'int'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode315.json",
    "problem_index_in_file": 0,
    "title": "Count of Smaller Numbers After Self",
    "description_snippet": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for the problem: count of smaller numbers after each element. Classic problem: use BIT or BST or merge sort. We produce steps, not actual code. Should use structure: Start, Step lines, Decision. Use \"→\". Each line: \"虛擬碼步驟 // 解釋\".\n\nWe should output the algorithm steps, perhaps using merge sort approach. Steps: compress coordinates, initialize BIT, iterate from right to left, query BIT for count of numbers smaller, update BIT. Or use merge sort to count inversions while merging.\n\nLet's produce algorithm with merge sort:\n\n- Start\n- Step 1: Pair each element with its original index.\n- Step 2: Sort pairs by value ascending? For merge sort approach, we use divide and conquer.\nBetter to produce steps for merge sort counting. Outline: recursively split array, count smaller numbers while merging. Keep array of pairs (value, original index). Use temporary array.\n\nSo virtual code lines:\n\nStart // Start program\n\n→ Step 1: 定義空的結果陣列 counts，長度為 nums 長度，初始值全 0 // 以儲存每個位置右邊較小元素數量\n\n→ Step 2: 建立陣列 pairs，每個元素為 (值, 原始索引) // 方便追蹤元素位置\n\n→ Step 3: 定義遞迴函式 MergeCount(start, end) // 分治計算較小元素數量\n\n→ Step 4: 在 MergeCount 中，若 start >= end 則返回 // 基本情況\n\n→ Step 5: 計算 mid = (start+end)//2\n\n→ Step 6: Recursively 呼叫 MergeCount(start, mid) // 處理左半部分\n\n→ Step 7: Recursively 呼叫 MergeCount(mid+1, end) // 處理右半部分\n\n→ Step 8: 定義 tmp = 空陣列 // 暫存合併結果\n\n→ Step 9: 定義 i = start, j = mid+1, rightCount = 0 // i、j 指向左右子陣列，rightCount 記錄已經合併的右側元素數\n\n→ Step 10: While i <= mid 且 j <= end // 進行合併\n\n→ Step 11: Decision: 如果 pairs[i].value <= pairs[j].value? // 比較左右子陣列前元素大小\n\n→ Step 12: Yes → tmp.append(pairs[i]) // 左側元素較小，加入 tmp\n\n→ Step 13: counts[pairs[i].index] += rightCount // 累加已經跳過的右側元素數，這些右側元素都比 pairs[i] 大\n\n→ Step 14: i += 1 // 移動左側指標\n\n→ Step 15: No → tmp.append(pairs[j]) // 右側元素較小，加入 tmp\n\n→ Step 16: rightCount += 1 // 右側元素被合併，累加右側計數\n\n→ Step 17: j += 1 // 移動右側指標\n\n→ Step 18: End While\n\n→ Step 19: While i <= mid // 左側還剩元素\n\n→ Step 20: tmp.append(pairs[i])\n\n→ Step 21: counts[pairs[i].index] += rightCount // 加上所有右側已經跳過的元素\n\n→ Step 22: i += 1\n\n→ Step 23: End While\n\n→ Step 24: While j <= end // 右側還剩元素\n\n→ Step 25: tmp.append(pairs[j])\n\n→ Step 26: j += 1\n\n→ Step 27: End While\n\n→ Step 28: 把 tmp 的內容覆蓋回 pairs[start:end+1] // 更新原陣列為已排序部分\n\n→ Step 29: End MergeCount\n\n→ Step 30: 呼叫 MergeCount(0, nums.length-1) // 開始分治\n\n→ Step 31: Return counts // 最終結果\n\n→ End // 程式結束\n\nWe should output each line with virtual code and explanation. Use the arrow syntax. Use \"→\" before each step. For decisions, use indentation like original example. So we need to maintain indentation of decisions. In example, Decision: ... then Yes → ... No → ... inside. We'll mimic that.\n\nMake sure to not output any actual code, just the steps. Use comments after //.\n\nLet's craft the final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立結果陣列 counts，長度等於 nums 的長度，所有值初始化為 0 // 用來存放每個位置右側較小元素的數量  \n→ Step 2: 建立 pairs 陣列，每個元素為 (值, 原始索引) // 方便在排序過程中追蹤元素的原始位置  \n→ Step 3: 定義遞迴函式 MergeCount(start, end) // 分治計算較小元素數量的核心函式  \n→ Step 4: Decision: 若 start >= end? // 基本情況，已無需進一步拆分  \n  Yes → Return // 當子陣列只有一個元素時直接返回  \n  No  → Go on // 否則繼續拆分  \n→ Step 5: 計算 mid = (start + end) // 2 // 取得中點索引  \n→ Step 6: Call MergeCount(start, mid) // 處理左半部分  \n→ Step 7: Call MergeCount(mid + 1, end) // 處理右半部分  \n→ Step 8: 建立 tmp 空陣列 // 用來暫存合併後的排序結果  \n→ Step 9: 設定 i = start, j = mid + 1, rightCount = 0 // i、j 分別指向左右子陣列，rightCount 記錄已經合併的右側元素數量  \n→ Step 10: Decision: 當 i <= mid 且 j <= end? // 判斷是否仍有元素需要合併  \n  Yes →  \n    Decision: 若 pairs[i].value <= pairs[j].value? // 比較左右子陣列首元素大小  \n      Yes → tmp.append(pairs[i]) // 左側元素較小，加入 tmp  \n       counts[pairs[i].index] += rightCount // 累加已跳過的右側元素數量  \n       i += 1 // 移動左側指標  \n      No  → tmp.append(pairs[j]) // 右側元素較小，加入 tmp  \n       rightCount += 1 // 右側已合併元素數量加一  \n       j += 1 // 移動右側指標  \n      End Decision  \n    End Decision  \n  No →  \n    While i <= mid: // 左側剩餘元素  \n      tmp.append(pairs[i])  \n      counts[pairs[i].index] += rightCount // 加上所有右側已跳過的元素  \n      i += 1  \n    End While  \n    While j <= end: // 右側剩餘元素  \n      tmp.append(pairs[j])  \n      j += 1  \n    End While  \n    // 把 tmp 的內容覆蓋回 pairs[start … end]  \n    for k in range(start, end + 1):  \n      pairs[k] = tmp[k - start]  \n    End While  \n  End Decision  \n→ Step 11: End MergeCount // 結束遞迴函式  \n→ Step 12: Call MergeCount(0, nums.length - 1) // 開始整體分治  \n→ Step 13: Return counts // 將結果傳回  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass BIT:\n    def __init__(self, size):\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index, delta):\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\nclass Solution:\n    def countSmaller(self, nums):\n        # 排序去重並建立值到秩（1~N）的映射\n        sorted_unique = sorted(set(nums))\n        ranks = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(ranks))\n        res = []\n\n        # 從右向左遍歷，使用 BIT 計算左側比當前元素大的數量\n        for num in reversed(nums):\n            rank = ranks[num]\n            res.append(bit.query(rank - 1))\n            bit.update(rank, 1)\n\n        return res[::-1]\n\ndef read_nums_from_input(input_str: str):\n    \"\"\"\n    從輸入字串中解析出整數列表。支持以下兩種格式：\n    1. 直接給出列表，例如 '[5,2,6,1]'\n    2. 形如 'nums = [5,2,6,1]' 的表達式\n    \"\"\"\n    input_str = input_str.strip()\n    if not input_str:\n        return []\n\n    # 嘗試找到第一個方括號內的內容\n    match = re.search(r'\\[.*?\\]', input_str)\n    if match:\n        nums_str = match.group(0)\n    else:\n        # 若沒有方括號，直接嘗試 eval 整個輸入\n        nums_str = input_str\n\n    try:\n        nums = eval(nums_str)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n    return []\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    nums = read_nums_from_input(raw_input)\n\n    solution = Solution()\n    result = solution.countSmaller(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "success": true,
          "output": "[2, 1, 1, 0]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "success": true,
          "output": "[0]"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "success": true,
          "output": "[0, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode537.json",
    "problem_index_in_file": 0,
    "title": "Complex Number Multiplication",
    "description_snippet": "A complex number can be represented as a string on the form \"real+imaginaryi\" where:\n\nreal is the re...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for multiplying two complex numbers given as strings in form \"real+imaginaryi\" where real and imaginary are integers -100..100. Need to output string representation of product. We need to output in specified format: each line with \"虛擬碼步驟 // 解釋/說明\". Use arrows and structure: Start, Decision, End. Use step labels. Should not output real code. Provide virtual code in lines. Steps: parse num1, parse num2, compute product real and imaginary, produce string.\n\nWe need to handle negative sign and plus sign? Strings like \"a+bi\" or \"a-bi\"? They said form \"real+imaginaryi\". Possibly always plus sign? but imaginary could be negative? Might have \"a+-bi\"? But we can assume they include plus sign. But to be safe parse with regex.\n\nWe can outline: Step 1: Split num1 into real1 and imag1; Step 2: Split num2; Step 3: Compute product real part: real1*real2 - imag1*imag2; imag part: real1*imag2 + imag1*real2; Step 4: Format result string: \"real+imagi\". If imag negative, show \"-\"? But requirement may assume plus always. But can handle negative.\n\nWe'll produce virtual code: Start; Step 1; Step 2; Step 3; Step 4; End.\n\nUse Decision maybe to check if imaginary part negative to format sign. But can embed directly.\n\nWe'll produce step by step.\n\nLet's craft:\n\nStart // 開始\n\n→ Step 1: Parse num1 into real1 and imag1 // 從字串取得實部與虛部\n\n→ Step 2: Parse num2 into real2 and imag2 // 同樣處理第二個複數\n\n→ Step 3: Compute productReal = real1 * real2 - imag1 * imag2 // 乘法公式實部\n\n→ Step 4: Compute productImag = real1 * imag2 + imag1 * real2 // 乘法公式虛部\n\n→ Step 5: If productImag ≥ 0? // 判斷虛部符號以便格式化\n\n    Yes → result = productReal + \"+\" + productImag + \"i\" // 正號\n\n    No  → result = productReal + \"-\" + abs(productImag) + \"i\" // 負號\n\n→ Step 6: Return result // 回傳字串\n\nEnd // 程式結束\n\nBut we need to use Decision arrow syntax exactly. Use `Decision:`. Use \"Yes →\", \"No →\". Indentation. Use `←` maybe but use arrow. We'll use as per example.\n\nAlso we might need to parse string. Could show: parse real as substring before '+' and imag as substring between '+' and 'i'. But we can abstract.\n\nWe'll produce final output. Ensure each line ends with `// ...`. Each step with virtual code and explanation. Use \"虛擬碼步驟\" but we can just present step names. Let's format exactly:\n\nStart // 程式開始執行\n\n→ Step 1: parse num1 into real1, imag1 // 從 num1 取得實部與虛部\n\n→ Step 2: parse num2 into real2, imag2 // 從 num2 取得實部與虛部\n\n→ Step 3: productReal ← real1 * real2 - imag1 * imag2 // 計算實部\n\n→ Step 4: productImag ← real1 * imag2 + imag1 * real2 // 計算虛部\n\n→ Decision: 如果 productImag ≥ 0? // 判斷虛部符號\n\n    Yes → result ← productReal + \"+\" + productImag + \"i\" // 虛部為正，加入正號\n\n    No  → result ← productReal + \"-\" + abs(productImag) + \"i\" // 虛部為負，加入負號\n\n→ Step 5: Return result // 回傳計算得到的複數字串\n\nEnd // 程式執行結束\n\nWe need to ensure each line has a space after virtual code then comment. We'll output as requested.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: parse num1 into real1, imag1 // 從 num1 取得實部與虛部  \n→ Step 2: parse num2 into real2, imag2 // 從 num2 取得實部與虛部  \n→ Step 3: productReal ← real1 * real2 - imag1 * imag2 // 計算實部  \n→ Step 4: productImag ← real1 * imag2 + imag1 * real2 // 計算虛部  \n→ Decision: 如果 productImag ≥ 0? // 判斷虛部符號  \n  Yes → result ← productReal + \"+\" + productImag + \"i\" // 虛部為正，加入正號  \n  No  → result ← productReal + \"-\" + abs(productImag) + \"i\" // 虛部為負，加入負號  \n→ Step 5: Return result // 回傳計算得到的複數字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def complexNumberMultiply(self, a: str, b: str) -> str:\n        \"\"\"將複數字串解析並相乘，回傳格式為 'real+imagagi'\"\"\"\n        def parse(s: str):\n            real, imag = s.split('+')\n            return int(real), int(imag[:-1])  # 去掉最後的 'i'\n        a_real, a_imag = parse(a)\n        b_real, b_imag = parse(b)\n\n        real_part = a_real * b_real - a_imag * b_imag\n        imag_part = a_real * b_imag + a_imag * b_real\n        return f\"{real_part}+{imag_part}i\"\n\ndef main():\n    \"\"\"從 stdin 讀取兩個複數字串，輸出其乘積字串\"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試找出雙引號中的內容\n    nums = re.findall(r'\"([^\"]+)\"', data)\n    if len(nums) >= 2:\n        num1, num2 = nums[0], nums[1]\n    else:\n        # 若輸入格式不同，直接用逗號分割\n        parts = data.split(',')\n        num1 = parts[0].strip().strip('\"')\n        num2 = parts[1].strip().strip('\"')\n\n    sol = Solution()\n    result = sol.complexNumberMultiply(num1, num2)\n    print(f'\"{result}\"')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"1+1i\", \"1+1i\"",
          "expected_output": "\"0+2i\"",
          "success": true,
          "output": "\"0+2i\""
        },
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "success": true,
          "output": "\"0+-2i\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode208.json",
    "problem_index_in_file": 0,
    "title": "Implement Trie (Prefix Tree)",
    "description_snippet": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and r...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for implementing Trie class with methods. Each line with arrow etc. Should include class definition, constructor, methods, node structure. Should be in traditional Chinese explanation. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. Use Start, End, Decision.\n\nWe need to produce code-like structure but not actual code. For example:\n\nStart\n→ Class Trie // 定義 Trie 類\n→ Step: 定義內部 Node 類 // 每個節點包含子節點映射與終端標記\n→ Step: Trie 初始化 // 建立根節點\n→ Step: insert(word) // 插入字串\n→ Step: search(word) // 搜尋完整字串\n→ Step: startsWith(prefix) // 判斷前綴\nEnd\n\nBut need to use arrows and decisions. Provide line per step. Each line with a comment. Need to show decisions like \"Decision: 這個字符是否已存在?\" with Yes/No. Provide substeps for insert, search, startsWith.\n\nWe need to produce virtual code with line-by-line steps.\n\nWe should include pseudo code with arrows, decisions, loops.\n\nLet's draft:\n\nStart // 程式開始\n\n→ Class Trie // 定義 Trie 類\n\n→ Step: Define Node // 內部節點類別\n    → Step: children: Map<Character, Node> // 儲存子節點\n    → Step: isWord: Boolean // 標記是否為完整單詞\n\n→ Step: Trie Constructor // 建立 Trie 物件\n    → Step: root = new Node() // 初始化根節點\n\n→ Step: insert(word) // 插入單詞\n    → Variable: current = root // 從根節點開始\n    → For each char c in word:\n        → Decision: 是否存在 child 於 current.children? // 檢查子節點\n            Yes → current = current.children[c] // 直接進入子節點\n            No  → current.children[c] = new Node() // 建立新節點\n                 → current = current.children[c] // 進入新節點\n    → current.isWord = true // 標記單詞結束\n\n→ Step: search(word) // 搜尋完整單詞\n    → Variable: current = root\n    → For each char c in word:\n        → Decision: child 是否存在於 current.children? // 確認節點存在\n            Yes → current = current.children[c]\n            No  → return false // 單詞不存在\n    → Decision: current.isWord? // 檢查是否為完整單詞\n        Yes → return true\n        No  → return false\n\n→ Step: startsWith(prefix) // 判斷前綴\n    → Variable: current = root\n    → For each char c in prefix:\n        → Decision: child 是否存在於 current.children? // 確認節點存在\n            Yes → current = current.children[c]\n            No  → return false // 前綴不存在\n    → return true // 所有字符均存在，前綴成立\n\nEnd // 程式結束\n\nNeed to format each line with arrow or decision lines. Indent? The example uses arrow and then Step: etc. We'll produce similar. Use \"→\" before each step. Indent inside decisions. We'll keep each line separate. Use `Decision:` lines. Provide arrow lines for each line, and nested lines may start with arrow as well. Use indentation but still each line separate. Ensure each line ends with `// 解釋`. Also use `Start` and `End` lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class Trie // 定義 Trie 類  \n→ Step: Define Node // 內部節點類別，儲存子節點與是否為單詞結尾  \n→ Step: children: Map<Character, Node> // 子節點集合  \n→ Step: isWord: Boolean // 標記該節點是否為完整單詞結束點  \n→ Step: Trie Constructor // 初始化 Trie 物件  \n→ Step: root = new Node() // 建立根節點，空集合且 isWord = false  \n→ Step: insert(word) // 插入單字  \n→ Step: current = root // 從根節點開始遍歷  \n→ For each character c in word: // 逐字處理  \n→ Decision: current.children 包含 c? // 檢查子節點是否已存在  \n  Yes → current = current.children[c] // 直接進入已有節點  \n  No  → current.children[c] = new Node() // 建立新節點  \n    current = current.children[c] // 進入新建立節點  \n→ Step: current.isWord = true // 標記單字結束  \n→ Step: search(word) // 搜尋完整單字  \n→ Step: current = root // 從根節點開始  \n→ For each character c in word: // 逐字檢查  \n→ Decision: current.children 包含 c? // 判斷節點存在性  \n  Yes → current = current.children[c] // 進入子節點  \n  No  → return false // 單字不存在  \n→ Decision: current.isWord? // 檢查是否為完整單字  \n  Yes → return true  \n  No  → return false  \n→ Step: startsWith(prefix) // 判斷是否有以 prefix 為前綴的單字  \n→ Step: current = root // 從根節點開始  \n→ For each character c in prefix: // 逐字檢查前綴  \n→ Decision: current.children 包含 c? // 判斷節點存在性  \n  Yes → current = current.children[c] // 進入子節點  \n  No  → return false // 前綴不存在  \n→ return true // 前綴完全匹配，存在至少一個單字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # Parse the two lists from the input\n    ops, args = ast.literal_eval('(' + raw_input + ')')\n    trie = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == 'Trie':\n            trie = Trie()\n            results.append(None)\n        elif op == 'insert':\n            trie.insert(arg[0])\n            results.append(None)\n        elif op == 'search':\n            results.append(trie.search(arg[0]))\n        elif op == 'startsWith':\n            results.append(trie.startsWith(arg[0]))\n        else:\n            results.append(None)\n\n    def to_str(val):\n        if val is None:\n            return 'null'\n        if isinstance(val, bool):\n            return 'true' if val else 'false'\n        return str(val)\n\n    output = '[' + ', '.join(to_str(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search'], [[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]",
          "expected_output": "[null, null, true, false, true, null, true]",
          "success": true,
          "output": "[null, null, true, false, true, null, true]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode268.json",
    "problem_index_in_file": 0,
    "title": "Missing Number",
    "description_snippet": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps with explanation lines. The problem: find missing number from array of distinct numbers 0 to n inclusive, array length n, missing one number. Approach: sum formula or XOR. Use sum formula: expected sum n*(n+1)/2 minus actual sum. Provide steps. Provide pseudo-code line by line with arrows. Use Start, End, Decision, Step, etc. The user wants each line with // explanation. Ensure each line includes virtual code step + space + // explanation. Use Start, →, Decision etc. Provide each line. Let's produce.\n\nWe need to show steps: Start, Step 1: compute n = length(nums) // etc. Step 2: compute expected sum using formula. Step 3: compute actual sum by iterating array. Step 4: compute missing = expected - actual. Step 5: return missing. End. Provide decision? None needed. Could add Decision: if missing computed, return. But not necessary.\n\nWe can incorporate XOR method: easier? Use sum.\n\nMake sure to format exactly: \"Start // ...\" etc. Use arrows: \"→ Step 1: ...\" etc.\n\nLet's produce 10 lines maybe. Provide explanation each.\n\nLet's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n ← Length(nums) // 取得陣列長度，代表 0~n 共 n+1 個數，其中缺一個  \n→ Step 2: expected_sum ← n * (n + 1) / 2 // 根據等差數列求和公式計算 0~n 的總和  \n→ Step 3: actual_sum ← 0 // 初始化實際已知數字的總和  \n→ Decision: 如果 nums 不為空? // 確保陣列中至少有一個元素  \n  Yes → Step 4: For each num in nums  \n     actual_sum ← actual_sum + num // 把每個已知數字加總  \n     End For  \n     End Decision  \n  No  → End // 若陣列為空，直接結束（此情況在題目中不會發生）  \n→ Step 5: missing ← expected_sum - actual_sum // 差值即為缺失的數字  \n→ Step 6: Return missing // 將缺失數字回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def missingNumber(self, nums):\n        \"\"\"\n        Find the single missing number from 0..n where nums contains n distinct numbers.\n        Uses the arithmetic sum formula: sum(0..n) - sum(nums).\n        \"\"\"\n        n = len(nums)          # n is the length of the list, so numbers are from 0 to n inclusive\n        total = n * (n + 1) // 2\n        return total - sum(nums)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list representation between brackets\n    match = re.search(r'\\[(.*?)\\]', data)\n    if not match:\n        raise ValueError(\"Input must contain a list of integers in brackets.\")\n    list_str = match.group(0)          # includes the brackets\n    nums = ast.literal_eval(list_str)  # safely evaluate to a Python list\n\n    result = Solution().missingNumber(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [9,6,4,2,3,5,7,0,1]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode470.json",
    "problem_index_in_file": 0,
    "title": "Implement Rand10() Using Rand7()",
    "description_snippet": "Given the API rand7() that generates a uniform random integer in the range [1, 7], write a function ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to generate rand10 from rand7. Classic solution: use two rand7 to generate 1-49 (7*7). Use rejection sampling: if value <= 40, map to 1-10 via mod. Else, repeat. Or can use 1-49 mapping: value%10+1. Rejection until <= 40. Or alternative use 1-42 mapping: using 1-49 but rejecting 41-49. So steps: Start, call rand7 twice, compute num = (first-1)*7 + second, if num <= 40, output num%10 +1, else repeat. Also include loop until success. That's the algorithm.\n\nWe need to output step by step virtual code, with explanation comments. Use Start, End, Decision, etc. Each line: virtual code + // explanation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ LoopStart // 進入重複產生直到成功\n    → Step 1: a ← rand7() // 呼叫 rand7() 產生第一個亂數\n    → Step 2: b ← rand7() // 呼叫 rand7() 產生第二個亂數\n    → Step 3: num ← (a-1)*7 + b // 將兩個亂數映射到 1~49 的整數\n    → Decision: 如果 num <= 40? // 檢查是否落在可用範圍\n        Yes → Step 4: result ← (num-1) mod 10 + 1 // 轉換到 1~10\n        Yes → Step 5: Output result // 回傳亂數\n        Yes → Step 6: Return // 結束函式\n        No  → LoopStart // 超過 40 時重新嘗試\nEnd // 程式執行結束\n\nBut we need to ensure syntax: Use Decision: if num <= 40? with Yes and No branches. Also need to indicate the loop. We might structure like:\n\nStart // 程式開始執行\n→ Decision: 需要產生 1-10? // 進入循環\n    Yes → Step 1: ... etc.\n\nBut we want to show loop using repeated steps. Virtual code can include \"Loop:\" maybe. The spec says use arrow (→) and structure Start, End, Decision:. We can represent loop by using decision with Yes leading back.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: a ← rand7() // 產生第一個 1~7 的亂數\n→ Step 2: b ← rand7() // 產生第二個 1~7 的亂數\n→ Step 3: num ← (a-1)*7 + b // 把兩個亂數映射為 1~49\n→ Decision: 如果 num <= 40? // 檢查是否在可接受的 1~40 範圍\n    Yes → Step 4: result ← (num-1) mod 10 + 1 // 將 1~40 映射到 1~10\n    Yes → Step 5: Output result // 回傳結果\n    Yes → End // 結束函式\n    No  → Step 1 // 超過 40，重新開始\n\nBut we need to avoid referencing Step 1 inside same numbering; maybe use loop label.\n\nBetter structure:\n\nStart // 程式開始執行\n→ LoopStart // 進入重複區塊\n    → Step 1: a ← rand7() // 產生第一個亂數\n    → Step 2: b ← rand7() // 產生第二個亂數\n    → Step 3: num ← (a-1)*7 + b // 合併為 1~49\n    → Decision: num <= 40? // 判斷是否在可用區間\n        Yes → Step 4: result ← (num-1) mod 10 + 1 // 轉換到 1~10\n        Yes → Step 5: Output result // 回傳\n        Yes → End // 程式結束\n        No  → LoopStart // 超過 40，重新迴圈\n\nBut we need arrow each line.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ LoopStart // 進入重複產生 1~10 的區塊  \n  → Step 1: a ← rand7() // 產生第一個 1~7 的亂數  \n  → Step 2: b ← rand7() // 產生第二個 1~7 的亂數  \n  → Step 3: num ← (a-1)*7 + b // 合併兩個亂數得到 1~49  \n  → Decision: 如果 num <= 40? // 檢查是否落在可用區間  \n    Yes → Step 4: result ← (num-1) mod 10 + 1 // 轉換 1~40 為 1~10  \n    Yes → Step 5: Output result // 回傳隨機數  \n    Yes → End // 結束函式  \n    No  → LoopStart // 超過 40，重新嘗試  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport random\n\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    if '=' in data:\n        n_str = data.split('=')[-1].strip()\n    else:\n        n_str = data.strip()\n    try:\n        n = int(n_str)\n    except ValueError:\n        n = 0\n    sol = Solution()\n    results = [sol.rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[10]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[10]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[8,3]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[8, 3]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[6,8,8]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[6, 8, 8]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode7.json",
    "problem_index_in_file": 0,
    "title": "Reverse Integer",
    "description_snippet": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the Leetcode Reverse Integer problem, but no actual code, just pseudocode with arrows, decisions, and explanations in Chinese. Use Start, End, Decision, Step etc. Must be line by line. Also we need to consider constraints: no 64-bit integers. So algorithm should use 32-bit ints only, detect overflow. Use typical method: pop last digit, push onto result, check overflow before push.\n\nWe'll produce steps:\n\nStart\n→ Step: Determine sign of x, store sign\n→ Step: Take absolute value of x (by negating if negative)\n→ Step: Initialize result = 0\n→ Decision: While x > 0?\n    Yes → Step: digit = x % 10\n           → Step: x = x / 10\n           → Decision: result > (INT_MAX - digit)/10 ?\n              Yes → Step: return 0 // overflow would occur\n              No  → Step: result = result * 10 + digit\n           → Go back to Decision\n    No → Step: result = result * sign\n           → Return result\nEnd\n\nBut also need to handle negative numbers and zero.\n\nNeed to check overflow before multiplication and addition: if result > INT_MAX/10 or (result == INT_MAX/10 && digit > 7) for positive, but simpler generic using result > (INT_MAX - digit)/10. However need to use INT_MAX and INT_MIN constants defined. For negative sign, we can reverse digits and multiply sign; overflow will be caught because we use absolute values, but after multiplication by sign might exceed INT_MIN? For negative numbers, when result is 2147483647 and sign is -1, result*-1 = -2147483647 within range. Actually reversed negative can be -2147483648? For example x=-1463847412 reversed to -2147483641? Not sure. But algorithm works.\n\nEdge: x = -2147483412 reversed to -2147483412? Wait.\n\nSimpler: after loop, apply sign and return.\n\nWe'll produce lines accordingly. Use comments in Chinese.\n\nAlso mention that we use 32-bit constants. Use INT_MAX = 2147483647, INT_MIN = -2147483648.\n\nAdd step to set INT_MAX, INT_MIN.\n\nWe need to ensure we mention environment not allow 64-bit. So we only use 32-bit operations. Use string for reading? No, just arithmetic.\n\nLet's produce steps.\n\nWe might also include step to define helper functions: PopDigit, PushDigit, CheckOverflow.\n\nBut easier to keep in linear steps.\n\nWe'll format each line:\n\nStart // 程式開始\n\n→ Step 1: Set INT_MAX = 2147483647, INT_MIN = -2147483648 // 定義整數極值\n\n→ Step 2: Read input x // 獲取待反轉的數\n\n→ Step 3: Determine sign = 1 if x >= 0 else -1 // 取得正負號\n\n→ Step 4: x = abs(x) // 取絕對值，便於處理\n\n→ Step 5: Initialize result = 0 // 用於存儲反轉後的數\n\n→ Decision: While x > 0? // 判斷是否還有位數需要處理\n\n    Yes → Step 6: digit = x % 10 // 取出最低位數字\n\n    → Step 7: x = x / 10 // 移除已處理的位數\n\n    → Decision: result > (INT_MAX - digit) / 10? // 檢查乘10後加digit是否會溢出\n\n        Yes → Step 8: return 0 // 溢出，直接返回0\n\n        No  → Step 9: result = result * 10 + digit // 正常拼接新位\n\n    → Go back to Decision\n\n    No  → Step 10: result = result * sign // 恢復原始符號\n\n           → Step 11: return result // 返回最終結果\n\nEnd // 程式結束\n\nWe might need to adjust formatting: each line must contain \"虛擬碼步驟\" and comment after space. Use arrows. For Decision, use \"Decision:\" lines. For nested decisions, indent accordingly? The example uses indent spaces. We'll maintain indent by two spaces per level.\n\nAlso ensure each line is separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: INT_MAX = 2147483647, INT_MIN = -2147483648 // 定義32位整數的最大、最小值\n\n→ Step 2: x = <input> // 取得待反轉的整數\n\n→ Step 3: sign = 1 如果 x >= 0 否則 -1 // 取得數的符號\n\n→ Step 4: x = abs(x) // 取絕對值，方便逐位處理\n\n→ Step 5: result = 0 // 初始化結果\n\n→ Decision: x > 0? // 是否還有位數需要處理？\n\n    Yes → Step 6: digit = x % 10 // 取最低位數字\n\n    → Step 7: x = x / 10 // 去掉已處理的位數\n\n    → Decision: result > (INT_MAX - digit) / 10? // 檢查乘10後再加digit是否會超過範圍\n\n        Yes → Step 8: return 0 // 溢出，直接返回0\n\n        No  → Step 9: result = result * 10 + digit // 正常拼接新位\n\n    → 回到 Decision\n\n    No  → Step 10: result = result * sign // 恢復原始符號\n\n    → Step 11: return result // 返回最終結果\n\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\nINT_MAX = 2**31 - 1\nINT_MIN = -2**31\n\ndef reverse_integer(x: int) -> int:\n    \"\"\"Return x with its digits reversed; return 0 if out of 32‑bit signed range.\"\"\"\n    sign = -1 if x < 0 else 1\n    x_abs = abs(x)\n    reversed_num = 0\n\n    while x_abs != 0:\n        digit = x_abs % 10\n        # 檢查乘 10 後再加 digit 是否會超過範圍\n        if reversed_num > (INT_MAX - digit) // 10:\n            return 0\n        reversed_num = reversed_num * 10 + digit\n        x_abs //= 10\n\n    reversed_num *= sign\n    if reversed_num < INT_MIN or reversed_num > INT_MAX:\n        return 0\n    return reversed_num\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整數，允許格式如「x = 123」或單獨的「123」\n    data = sys.stdin.read()\n    match = re.search(r'[-]?\\d+', data)\n    if match:\n        x = int(match.group(0))\n        result = reverse_integer(x)\n        print(result)\n    else:\n        # 如果沒有找到整數，輸出 0 或可自行決定行為\n        print(0)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 123",
          "expected_output": "321",
          "success": true,
          "output": "321"
        },
        {
          "example_index": 1,
          "input": "x = -123",
          "expected_output": "-321",
          "success": true,
          "output": "-321"
        },
        {
          "example_index": 2,
          "input": "x = 120",
          "expected_output": "21",
          "success": true,
          "output": "21"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode67.json",
    "problem_index_in_file": 0,
    "title": "Add Binary",
    "description_snippet": "Given two binary strings a and b, return their sum as a binary string....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code steps for adding two binary strings. Output should be step-by-step, with arrow. No actual code. Should be in Chinese. Provide explanation after space.\n\nWe need to produce steps:\n\nStart\n→ Initialize i = len(a)-1, j = len(b)-1, carry=0, result = empty\n→ Decision: while i>=0 or j>=0 or carry>0?\n   Yes → compute sum bits and carry\n   Append bit to result\n   Decrement indices\n   No → Reverse result string\nEnd\n\nWe need each line with arrow maybe.\n\nUse Start, End. Use Decision: If...?\n\nWe must use 虛擬碼箭頭 →. Provide explanation after space.\n\nLet's produce like:\n\nStart // 程式開始\n\n→ Step 1: 初始化 i = a 的最後一個索引, j = b 的最後一個索引, carry = 0, result = 空字符串 // 設定初始變數\n\n→ Decision: 如果 i>=0 或 j>=0 或 carry>0? // 判斷是否還有位需要處理\n\n    Yes → Step 2: 取得 a[i] (若 i>=0) 否則 0 // 取得 a 的位元\n    → Step 3: 取得 b[j] (若 j>=0) 否則 0 // 取得 b 的位元\n    → Step 4: 計算 sum = bit_a + bit_b + carry // 總和\n    → Step 5: 更新 carry = sum // 2 // 取得新進位\n    → Step 6: 將 (sum % 2) 追加到 result // 將結果位元加到結果串\n    → Step 7: i = i-1, j = j-1 // 移動到下一位\n\n    No → Step 8: 反轉 result 並輸出 // 把逆序的結果轉為正序並回傳\n\nEnd // 程式結束\n\nMake sure each line has 虛擬碼步驟 + space + // 解釋. Use arrows. Use \"→\" after each step. For decisions, indent? In example, they used indentation. Let's keep same indentation.\n\nAlso, after \"Decision:\" we need to show Yes → and No → lines.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 初始化 i = len(a)-1, j = len(b)-1, carry = 0, result = 空字符串 // 設定初始變數\n→ Decision: i>=0 或 j>=0 或 carry>0? // 判斷是否還有位需要處理\n    Yes → Step 2: bit_a = a[i] if i>=0 else 0 // 取得 a 的位元\n    → Step 3: bit_b = b[j] if j>=0 else 0 // 取得 b 的位元\n    → Step 4: sum = bit_a + bit_b + carry // 計算總和\n    → Step 5: carry = sum // 2 // 更新進位\n    → Step 6: result = (sum % 2) + result // 將位元加到結果\n    → Step 7: i = i-1, j = j-1 // 移動索引\n    No  → Step 8: 回傳 result // 完成輸出\nEnd // 程式結束\n\nBut need to reverse? They appended to front. We can append to front. That's okay.\n\nBetter to have Step 6: result = (sum % 2) + result // 將最低位加入結果前面\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 i = a 的最後一個索引, j = b 的最後一個索引, carry = 0, result = 空字符串 // 設定初始變數  \n→ Decision: i>=0 或 j>=0 或 carry>0? // 判斷是否還有位需要處理  \n&nbsp;&nbsp;Yes → Step 2: bit_a = a[i] 若 i>=0, 否則 0 // 取得 a 的位元  \n&nbsp;&nbsp;→ Step 3: bit_b = b[j] 若 j>=0, 否則 0 // 取得 b 的位元  \n&nbsp;&nbsp;→ Step 4: sum = bit_a + bit_b + carry // 計算兩位與進位的總和  \n&nbsp;&nbsp;→ Step 5: carry = sum // 2 // 更新進位值  \n&nbsp;&nbsp;→ Step 6: result = (sum % 2) + result // 將最低位加到結果字串前面  \n&nbsp;&nbsp;→ Step 7: i = i-1, j = j-1 // 移動到下一位  \n&nbsp;&nbsp;No  → Step 8: 回傳 result // 所有位已處理，回傳最終的二進位字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j = len(a) - 1, len(b) - 1\n        carry = 0\n        result = []\n\n        while i >= 0 or j >= 0 or carry:\n            total = carry\n            if i >= 0:\n                total += int(a[i])\n                i -= 1\n            if j >= 0:\n                total += int(b[j])\n                j -= 1\n            result.append(str(total % 2))\n            carry = total // 2\n\n        return ''.join(reversed(result))\n\ndef main():\n    data = sys.stdin.read()\n    # 提取引號內的二進位字串\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        a, b = parts[0], parts[1]\n    else:\n        # 若沒有引號，嘗試以空格分割或逐行讀取\n        tokens = data.strip().split()\n        if len(tokens) >= 2:\n            a, b = tokens[0], tokens[1]\n        else:\n            # 最少輸入兩行，每行一個字串\n            lines = data.strip().splitlines()\n            if len(lines) >= 2:\n                a, b = lines[0].strip(), lines[1].strip()\n            else:\n                raise ValueError(\"輸入格式不正確，無法提取兩個二進位字串\")\n    solution = Solution()\n    result = solution.addBinary(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = \"11\", b = \"1\"",
          "expected_output": "\"100\"",
          "success": true,
          "output": "100"
        },
        {
          "example_index": 1,
          "input": "a = \"1010\", b = \"1011\"",
          "expected_output": "\"10101\"",
          "success": true,
          "output": "10101"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode371.json",
    "problem_index_in_file": 0,
    "title": "Sum of Two Integers",
    "description_snippet": "Given two integers a and b, return the sum of the two integers without using the operators + and -....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need virtual code, no actual code. Use Start, End, Decision, Steps. Need to handle sum without + and -. Classic bitwise addition using XOR and AND with shift. Provide stepwise pseudocode. For each line, explanation.\n\nLet's design:\n\nStart\n→ Step 1: Initialize sum = a XOR b // compute initial sum ignoring carries\n→ Step 2: Initialize carry = (a AND b) << 1 // compute carry shifted\n→ Decision: 是否 carry 為 0? // if no carry, finished\n    No → Step 3: Set a = sum ; b = carry ; // use sum as new a, carry as new b\n    Yes → Step 4: Set sum = a XOR b // recompute sum\n    → Step 5: Set carry = (a AND b) << 1\n    → Decision: 是否 carry 為 0? // loop until carry zero\n        (We can loop using a while loop representation maybe Decision with Yes->End)\nBut virtual code lines can loop: we can use while. But use Decision.\n\nBetter to use a loop: While carry != 0:\n   sum = a XOR b\n   carry = (a AND b) << 1\n   a = sum ; b = carry\nFinally return sum.\n\nLet's express:\n\nStart\n→ Step 1: sum = a XOR b // initial sum without carry\n→ Step 2: carry = (a AND b) << 1 // initial carry\n→ Decision: carry == 0? // check if no carry\n    Yes → Step 3: return sum // done\n    No → Step 4: a = sum ; b = carry // prepare for next iteration\n    → Step 5: sum = a XOR b // recompute sum\n    → Step 6: carry = (a AND b) << 1 // recompute carry\n    → Decision: carry == 0? // loop condition\n        (repeat until true)\nEnd\n\nBut we need to structure properly with arrows. Use Decision with Yes → Step 3, No → loop back.\n\nBetter use a label or \"Loop:\" but requirement uses Decision. We can embed the loop within Decision.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: sum = a XOR b // 先不考慮進位的和\n→ Step 2: carry = (a AND b) << 1 // 先計算進位\n→ Decision: carry == 0? // 若無進位，計算完成\n    Yes → Step 3: return sum // 回傳結果\n    No → Step 4: a = sum ; b = carry // 用新的 a、b 進行下一次計算\n    → Step 5: sum = a XOR b // 再次計算和\n    → Step 6: carry = (a AND b) << 1 // 再次計算進位\n    → Decision: carry == 0? // 檢查是否仍有進位\n        Yes → Step 7: return sum // 完成\n        No  → Step 4: a = sum ; b = carry // 迴圈回到 Step 4\nEnd // 程式結束\n\nBut this has duplicate Step 4; maybe use loop label. But we can express loops via Decision.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: sum = a XOR b // 先計算兩數不考慮進位的暫時和\n→ Step 2: carry = (a AND b) << 1 // 先計算兩數的進位位，左移一位\n→ Decision: carry == 0? // 若沒有進位，表示相加已完成\n    Yes → Step 3: return sum // 回傳最終和\n    No  → Step 4: a = sum ; b = carry // 用暫時和與進位繼續計算\n    → Step 5: sum = a XOR b // 再次計算暫時和\n    → Step 6: carry = (a AND b) << 1 // 再次計算進位\n    → Decision: carry == 0? // 仍有進位時重複流程\n        Yes → Step 7: return sum // 完成，回傳結果\n        No  → Step 4: a = sum ; b = carry // 迴圈回到第 4 步繼續\nEnd // 程式執行結束\n```",
      "generated_code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\nimport re\n\nclass Solution:\n    \"\"\"\n    兩個整數相加，但不使用 + 或 - 運算子。\n    透過位元運算（XOR 與 AND）與進位移位實作。\n    \"\"\"\n    def getSum(self, a: int, b: int) -> int:\n        # 32 位元無符號掩碼，確保所有運算皆在 32 位元範圍內\n        MASK = 0xFFFFFFFF\n        # 最大正整數（有符號 32 位元）\n        MAX_INT = 0x7FFFFFFF\n\n        # 只要還有進位 (b != 0)，就持續迭代\n        while b != 0:\n            # 進位值：a 與 b 的相同位元為 1 時才進位\n            carry = (a & b) & MASK\n            # 兩數不考慮進位的暫時和\n            a = (a ^ b) & MASK\n            # 將進位左移一位，準備下一輪計算\n            b = (carry << 1) & MASK\n\n        # 若最終 a 超過最大正整數，表示實際為負數\n        return a if a <= MAX_INT else ~(a ^ MASK)\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中擷取兩個整數。\n    支援類似 'a = 1, b = 2' 或 '1 2' 的格式。\n    \"\"\"\n    numbers = re.findall(r'-?\\d+', data)\n    if len(numbers) < 2:\n        raise ValueError(\"輸入必須包含兩個整數。\")\n    return int(numbers[0]), int(numbers[1])\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    try:\n        a, b = parse_input(raw_input)\n    except ValueError as e:\n        print(e, file=sys.stderr)\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.getSum(a, b)\n    # 將結果輸出到標準輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 1, b = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode35.json",
    "problem_index_in_file": 0,
    "title": "Search Insert Position",
    "description_snippet": "Given a sorted array of distinct integers and a target value, return the index if the target is foun...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for binary search to find insert position. Provide line by line with explanations. Use Start, End, Decision. Let's produce steps:\n\nStart\n→ Step 1: Initialize left = 0, right = array length - 1 // set search bounds\n→ Decision: while left <= right? // loop condition\n   Yes → Step 2: mid = left + (right-left)//2 // compute mid index\n   → Decision: if array[mid] == target? // check equality\n        Yes → Step 3: Return mid // found target\n        No → Decision: if array[mid] < target? // target greater, search right half\n             Yes → Step 4: left = mid + 1 // move left bound\n             No  → Step 5: right = mid - 1 // move right bound\n   No → Step 6: Return left // insertion position\nEnd\n\nBut ensure using arrow style:\n\nStart // program start\n→ Step 1: left = 0, right = n-1 // 初始化搜尋範圍\n→ Decision: while left <= right? // 判斷是否還有搜尋區間\n    Yes → Step 2: mid = left + (right-left)//2 // 計算中間索引\n    → Decision: arr[mid] == target? // 比對目標\n        Yes → Step 3: Return mid // 找到目標\n        No  → Decision: arr[mid] < target? // 目標在右半邊\n            Yes → Step 4: left = mid + 1 // 更新左界\n            No  → Step 5: right = mid - 1 // 更新右界\n    No → Step 6: Return left // 目標未找到，返回插入位置\nEnd // 結束\n\nBut we need each line with arrow and explanation after space. Use `→` or `Decision:`. Let's structure:\n\nStart // 程式開始執行\n→ Step 1: left = 0, right = n-1 // 初始化搜尋範圍\n→ Decision: left <= right? // 判斷是否還有未檢查區間\n    Yes → Step 2: mid = left + (right - left) // 取中點\n    → Decision: arr[mid] == target? // 檢查是否相等\n        Yes → Step 3: Return mid // 找到目標索引\n        No  → Decision: arr[mid] < target? // 目標在右邊\n            Yes → Step 4: left = mid + 1 // 調整左邊界\n            No  → Step 5: right = mid - 1 // 調整右邊界\n    No → Step 6: Return left // 目標未找到，回傳插入位置\nEnd // 程式結束\n\nCheck each line ends with `//` explanation. We need to ensure each line has `虛擬碼步驟` + space + `// 解釋`. The decision lines should use `Decision:`. After decision we indent further lines. Let's produce accordingly. Also `No` and `Yes` lines each start with `Yes →` or `No →`. For indentation, we can use spaces.\n\nLet's output final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: left = 0, right = n-1 // 初始化搜尋區間的左右指標  \n→ Decision: left <= right? // 判斷是否還有未搜尋的範圍  \n    Yes → Step 2: mid = left + (right - left) // 計算中間索引  \n    → Decision: arr[mid] == target? // 檢查中間元素是否為目標值  \n        Yes → Step 3: Return mid // 找到目標，返回其索引  \n        No  → Decision: arr[mid] < target? // 目標值在右半邊？  \n            Yes → Step 4: left = mid + 1 // 把左指標往右移，縮小搜尋區間  \n            No  → Step 5: right = mid - 1 // 把右指標往左移，縮小搜尋區間  \n    No → Step 6: Return left // 目標不存在，返回應插入的位置  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef searchInsert(nums, target):\n    \"\"\"\n    在已排序且互不相同的整數列表中，使用二分搜尋找出 target 的索引，\n    或者若不存在則回傳應插入的位置。\n    時間複雜度 O(log n)。\n    \"\"\"\n    left, right = 0, len(nums)          # 兩個指標，搜尋範圍是 [left, right)\n    while left < right:                  # 當還有區間可以搜尋時\n        mid = (left + right) // 2        # 取中點\n        if nums[mid] < target:           # target 在右半邊\n            left = mid + 1               # 把左指標往右移\n        else:                            # target 在左半邊或等於 mid\n            right = mid                  # 把右指標往左移\n    return left                          # 搜尋結束，left 就是插入位置\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析 nums 與 target，計算插入位置並輸出。\n    支援兩種輸入格式：\n    1. 'nums = [1,3,5,6], target = 5'\n    2. 直接輸入所有整數，最後一個整數是 target，其餘為 nums 列表。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從文字中抓取 \"nums = [...]\" 與 \"target = ...\"\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if nums_match and target_match:\n        nums_str = nums_match.group(1)\n        nums = ast.literal_eval(nums_str)   # 安全解析列表字串\n        target = int(target_match.group(1))\n    else:\n        # 直接把所有整數讀入，最後一個是 target\n        parts = list(map(int, data.split()))\n        if len(parts) < 2:\n            return\n        nums = parts[:-1]\n        target = parts[-1]\n\n    result = searchInsert(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5,6], target = 5",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,5,6], target = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [1,3,5,6], target = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode154.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array II",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: find minimum in rotated sorted array with duplicates. We need to minimize operations. Usually use binary search with adjustments for duplicates. Virtual code lines with explanation.\n\nWe need to output step-by-step pseudo-code with arrows and decisions. No real code.\n\nLet's craft steps:\n\nStart\n→ Initialize low=0, high=n-1 // 指定搜尋區間\n→ While low < high: // 搜尋到最小值\n    → mid = low + (high - low) // 計算中點\n    → Decision: nums[mid] > nums[high]? // 判斷哪邊有更小值\n        Yes → low = mid + 1 // 左半段已是升序，最小在右半段\n        No → Decision: nums[mid] < nums[high]? // 判斷mid是否已在最小段\n            Yes → high = mid // 最小值在左半段或mid\n            No → Decision: nums[mid] == nums[high]? // duplicates\n                Yes → high = high - 1 // 無法確定，縮小右端\n                No → (shouldn't happen)\n→ Result: nums[low] // 最小值\n\nBut need to incorporate duplicates handling for when nums[mid]==nums[high] we can decrement high.\n\nAlso if we can reduce operations maybe skip duplicate check? But we need to handle duplicates. So algorithm minimal steps.\n\nLet's produce virtual code lines with arrows, each line: step comment.\n\nWe also need \"Decision:\" lines with Yes/No arrows.\n\nLet's produce.\n\nWe must not output actual code, just virtual.\n\nLet's ensure formatting: \"虛擬碼步驟 // 解釋\".\n\nAlso use arrow characters \"→\". Start, End. For decisions, indent sub-steps.\n\nWe need to maintain each line as separate. Let's craft.\n\nWe need to incorporate input length n from nums. So first line: Start // 程式開始\n\nThen \"→ Step 1: low = 0; high = nums.length - 1 // 初始化搜尋區間\" etc.\n\nWe must use Chinese. Provide explanation in Chinese.\n\nOk produce.\n\nAlso mention if low==high end.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 0; high = nums.length - 1 // 初始化搜尋區間  \n→ Decision: low < high? // 判斷是否還有搜尋範圍  \n    Yes → Step 2: mid = low + (high - low) // 計算中點  \n    → Decision: nums[mid] > nums[high]? // 中點右邊比右端大，最小必在右半段  \n        Yes → low = mid + 1 // 把搜尋範圍縮到右半段  \n        No → Decision: nums[mid] < nums[high]? // 中點右邊比右端小，最小在左半段或mid  \n            Yes → high = mid // 把搜尋範圍縮到左半段  \n            No → Decision: nums[mid] == nums[high]? // 兩者相等時無法確定，縮小右端  \n                Yes → high = high - 1 // 將右端左移一步  \n                No → // 這種情況不會發生  \n    → 再次進入 Decision: low < high? // 重複搜尋直到 low == high  \nEnd // 程式執行結束， nums[low] 為最小值",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:               # nums[mid] == nums[right]\n                right -= 1\n        return nums[left]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Remove possible \"nums =\" prefix and whitespace\n    if data.startswith('nums'):\n        idx = data.find('[')\n        if idx != -1:\n            data = data[idx:]\n\n    # Safely parse the list\n    try:\n        nums = ast.literal_eval(data)\n    except Exception:\n        nums = eval(data, {}, {})\n\n    result = Solution().findMin(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,0,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode153.json",
    "problem_index_in_file": 0,
    "title": "Find Minimum in Rotated Sorted Array",
    "description_snippet": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode in Chinese, step by step, explaining each line. Must use virtual code syntax with arrows, etc. It's a classic problem: find min in rotated sorted array with binary search. We'll produce step-by-step: Start, Initialize left=0, right=n-1. While left < right: mid = left + (right-left)//2. If nums[mid] > nums[right], min in right half, left = mid+1 else right = mid. After loop, left points to min. Return nums[left]. End. Provide explanation each line.\n\nNeed to use \"虛擬碼步驟\" + \"// 解釋\". Use arrow characters: \"→\". Decision lines: \"Decision:\".\n\nLet's format each line. Use indentation for nested blocks? The example shows indentation.\n\nWe need to ensure each line has step name and comment.\n\nLet's create:\n\nStart // 程式開始\n→ Step 1: 取得陣列長度 n // 獲取陣列長度\n→ Step 2: left ← 0 // 左指標初始為 0\n→ Step 3: right ← n - 1 // 右指標初始為最後索引\n→ Decision: left < right? // 判斷是否還有區間需要搜尋\n    Yes → Step 4: mid ← left + (right - left) // 計算中間索引\n    Yes → Decision: nums[mid] > nums[right]? // 比較中間值與右端值\n        Yes → Step 5: left ← mid + 1 // 最小值在右半邊，左指標右移\n        No  → Step 6: right ← mid // 最小值在左半邊，右指標左移\n    No  → End // 迴圈結束\n→ Step 7: return nums[left] // 返回最小元素\nEnd // 程式結束\n\nBut we need to use \"Yes →\" and \"No →\" arrows in decisions.\n\nWe also need to show \"Decision:\" and nested arrows. Let's write exactly:\n\nStart // 程式開始\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: left ← 0 // 左指標初始化\n→ Step 3: right ← n - 1 // 右指標初始化\n→ Decision: left < right? // 是否還有範圍需要搜尋\n    Yes → Step 4: mid ← left + (right - left) // 計算中間索引\n    Yes → Decision: nums[mid] > nums[right]? // 判斷中間元素是否大於右端元素\n        Yes → Step 5: left ← mid + 1 // 最小值在右半區，更新左指標\n        No  → Step 6: right ← mid // 最小值在左半區，更新右指標\n    No  → End // 左右指標相等，搜尋結束\n→ Step 7: return nums[left] // 返回最小元素\nEnd // 程式結束\n\nBut we need \"Step 4\" inside while loop? In pseudocode, we need while loop. The example uses while loops? Not specified. But we can use Decision with Yes/No to simulate while. For clarity, maybe better to use \"Loop:\"? But not defined. We can mimic while with Decision at top.\n\nBetter to write:\n\nStart\n→ Step 1: n ← length(nums)\n→ Step 2: left ← 0\n→ Step 3: right ← n - 1\n→ Decision: left < right? // 進入搜尋迴圈\n    Yes → Step 4: mid ← left + (right - left) // 中間索引\n    Yes → Decision: nums[mid] > nums[right]? // 判斷位置\n        Yes → Step 5: left ← mid + 1 // 移至右半\n        No  → Step 6: right ← mid // 移至左半\n    No  → End // 退出迴圈\n→ Step 7: return nums[left] // 返回結果\nEnd\n\nBut after we exit the Decision loop, we need to go back to Decision: left < right? So we need a loop. But the pseudocode example uses decisions but not loops. We can include \"Loop: left < right\" but not defined. Let's define a \"Loop\" construct. The example uses \"Decision:\" and \"Yes →\" \"No →\". They didn't show loops. However we can emulate while loop with decision and recursion. But easier: Use \"Loop\" keyword. But requirement didn't forbid new construct. But might deviate.\n\nMaybe we can use \"While\" construct with arrows: \"While: left < right\" etc.\n\nBut to stay within pattern, we can represent while loop by repeated Decision at end: after updating left/right, go back to Decision again. Use indentation to show recursion. Example:\n\nStart\n→ Step 1: n ← length(nums)\n→ Step 2: left ← 0\n→ Step 3: right ← n - 1\n→ Decision: left < right? // 進入搜尋迴圈\n    Yes → Step 4: mid ← left + (right - left)\n    Yes → Decision: nums[mid] > nums[right]? \n        Yes → Step 5: left ← mid + 1\n        No  → Step 6: right ← mid\n    Yes → Decision: left < right? // 再次檢查條件，形成迴圈\n        Yes → … // 重複\n        No  → End // 退出迴圈\n    No  → End // 初始條件不滿足，直接退出\n→ Step 7: return nums[left]\nEnd\n\nThis seems messy.\n\nPerhaps better to include a \"While\" line explicitly: \"While: left < right\" with steps inside. Use indentation.\n\nLet's do:\n\nStart // 程式開始\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: left ← 0 // 初始化左指標\n→ Step 3: right ← n - 1 // 初始化右指標\n→ While: left < right // 只要左指標小於右指標就持續搜尋\n    → Step 4: mid ← left + (right - left) // 計算中間索引\n    → Decision: nums[mid] > nums[right]? // 判斷中間元素是否大於右端元素\n        Yes → Step 5: left ← mid + 1 // 最小值在右半區，更新左指標\n        No  → Step 6: right ← mid // 最小值在左半區，更新右指標\n→ Step 7: return nums[left] // 搜尋結束，返回最小元素\nEnd // 程式結束\n\nThis uses \"While:\" which may be acceptable though not in example. But requirement didn't forbid other constructs. We'll assume allowed.\n\nLet's provide that. Ensure each line ends with comment.\n\nLet's deliver.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: n ← length(nums) // 取得陣列長度\n→ Step 2: left ← 0 // 初始化左指標\n→ Step 3: right ← n - 1 // 初始化右指標\n→ While: left < right // 只要左指標小於右指標就持續搜尋\n    → Step 4: mid ← left + (right - left) // 計算中間索引\n    → Decision: nums[mid] > nums[right]? // 判斷中間元素是否大於右端元素\n        Yes → Step 5: left ← mid + 1 // 最小值在右半區，將左指標移到 mid + 1\n        No  → Step 6: right ← mid // 最小值在左半區，將右指標移到 mid\n→ Step 7: return nums[left] // 搜尋結束，返回最小元素\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        if not nums:\n            return None\n        if nums[left] <= nums[right]:\n            return nums[left]\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Extract list of numbers from input string\n    match = re.search(r'\\[(.*?)\\]', data, re.S)\n    if match:\n        list_str = '[' + match.group(1) + ']'\n        try:\n            nums = ast.literal_eval(list_str)\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    solution = Solution()\n    result = solution.findMin(nums)\n    if result is not None:\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,4,5,1,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,5,6,7,0,1,2]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "nums = [11,13,15,17]",
          "expected_output": "11",
          "success": true,
          "output": "11"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode552.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record II",
    "description_snippet": "An attendance record for a student can be represented as a string where each character signifies whe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate pseudocode for counting attendance records length n with constraints: <2 absences, never 3 consecutive L. So dynamic programming. Represent state: days processed, number of absences so far (0 or 1), number of consecutive L at end (0,1,2). Count modulo MOD.\n\nWe produce line-by-line pseudocode with explanation comments. Use Start, Decision, loops, etc. We'll produce algorithm: initialize dp[0][0][0] = 1. For each day 1..n: for each a in {0,1}, for each l in {0,1,2}, compute transitions: adding P resets l to 0, a stays same; adding A if a+1<2 resets l to 0; adding L if l+1<3 stays same a. Sum modulo. At end sum over all states. Output.\n\nWe'll present in requested format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows: Start, → loops, Decision. Provide pseudo-step names. Use arrow. Provide explanation after space.\n\nMake sure no actual code. Use structure. We'll include variable names like dp, MOD. Use Step 1 etc.\n\nLet's draft.\n\nLine1: Start // 開始程式\n\nLine2: → Set MOD = 1000000007 // 設定取模常數\n\nLine3: → Create 3D array dp[n+1][2][3] 初始化為0 // dp[day][absences][consecutiveL]\n\nLine4: → dp[0][0][0] = 1 // 初始狀態：未開始，0 欠缺，0 連續遲到\n\nLoop over days:\n\nLine5: → For day從1到n // 逐日處理\n\nInside loops over a and l:\n\nLine6: → For a從0到1 // 兩種欠缺數\n\nLine7: → For l從0到2 // 三種連續遲到\n\nLine8: → If dp[day-1][a][l] == 0 → Continue // 若前一狀態無方案則跳過\n\nTransition P:\n\nLine9: → Set nextA = a // 欠缺不變\n\nLine10: → Set nextL = 0 // 連續遲到重置\n\nLine11: → dp[day][nextA][nextL] = (dp[day][nextA][nextL] + dp[day-1][a][l]) mod MOD // 加入 P 的遷移\n\nTransition A (if allowed):\n\nLine12: → If a + 1 < 2 // 欠缺數小於1可再加一次\n\nLine13: → Set nextA = a + 1\n\nLine14: → Set nextL = 0\n\nLine15: → dp[day][nextA][nextL] = (dp[day][nextA][nextL] + dp[day-1][a][l]) mod MOD // 加入 A 的遷移\n\nTransition L (if allowed):\n\nLine16: → If l + 1 < 3 // 連續遲到少於2可再加一次\n\nLine17: → Set nextA = a\n\nLine18: → Set nextL = l + 1\n\nLine19: → dp[day][nextA][nextL] = (dp[day][nextA][nextL] + dp[day-1][a][l]) mod MOD // 加入 L 的遷移\n\nEnd loops.\n\nAfter loop, compute answer:\n\nLine20: → Set result = 0\n\nLine21: → For a從0到1\n\nLine22: → For l從0到2\n\nLine23: → result = (result + dp[n][a][l]) mod MOD // 累加所有結束狀態\n\nLine24: → Output result // 回傳最終答案\n\nLine25: End // 程式結束\n\nWe should ensure to include arrows and explanation after space.\n\nAlso maybe add comments on what each line does. Provide clear.\n\nWe must avoid actual code; keep pseudo.\n\nWe can refine: using \"Decision:\" for condition lines. Provide decision for transitions.\n\nLet's format: Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Set MOD = 1000000007 // 設定取模常數  \n→ Create 3D array dp[n+1][2][3] 初始化為0 // dp[day][absences][連續遲到] 用於動態規劃  \n→ dp[0][0][0] = 1 // 初始狀態：0 天、0 欠缺、0 連續遲到  \n→ For day從1到n // 逐日處理  \n    → For a從0到1 // 欠缺數只能為 0 或 1  \n        → For l從0到2 // 連續遲到數只能為 0、1 或 2  \n            → Decision: 如果 dp[day-1][a][l] == 0? // 前一狀態無可行方案則跳過  \n                Yes → Continue // 跳過此組合  \n                No  \n                    // 進行三種可能的遷移：P、A、L  \n                    → Set nextA = a // 欠缺不變  \n                    → Set nextL = 0 // 連續遲到重置  \n                    → dp[day][nextA][nextL] = (dp[day][nextA][nextL] + dp[day-1][a][l]) mod MOD // 加入 P 的遷移  \n                    → Decision: 如果 a + 1 < 2? // 欠缺可否再加一次  \n                        Yes → Set nextA = a + 1  \n                            → Set nextL = 0  \n                            → dp[day][nextA][nextL] = (dp[day][nextA][nextL] + dp[day-1][a][l]) mod MOD // 加入 A 的遷移  \n                        No  \n                    → Decision: 如果 l + 1 < 3? // 連續遲到可否再加一次  \n                        Yes → Set nextA = a  \n                            → Set nextL = l + 1  \n                            → dp[day][nextA][nextL] = (dp[day][nextA][nextL] + dp[day-1][a][l]) mod MOD // 加入 L 的遷移  \n→ Set result = 0 // 初始化答案  \n→ For a從0到1  \n    → For l從0到2  \n        → result = (result + dp[n][a][l]) mod MOD // 累加所有符合條件的結束狀態  \n→ Output result // 回傳最終答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nMOD = 10**9 + 7\n\nclass Solution:\n    def checkRecord(self, n: int) -> int:\n        # dp[a][l] = number of sequences of current length with a 'A's (0 or 1)\n        # and ending with l consecutive 'L's (0, 1, or 2)\n        dp = [[0]*3 for _ in range(2)]\n        dp[0][0] = 1\n\n        for _ in range(n):\n            new_dp = [[0]*3 for _ in range(2)]\n            for a in range(2):\n                for l in range(3):\n                    val = dp[a][l]\n                    if not val:\n                        continue\n                    # Add 'P': resets consecutive L to 0, absences unchanged\n                    new_dp[a][0] = (new_dp[a][0] + val) % MOD\n                    # Add 'A': only allowed if we currently have 0 absences\n                    if a == 0:\n                        new_dp[1][0] = (new_dp[1][0] + val) % MOD\n                    # Add 'L': only allowed if current consecutive L < 2\n                    if l < 2:\n                        new_dp[a][l+1] = (new_dp[a][l+1] + val) % MOD\n            dp = new_dp\n\n        # Sum all states after n days\n        result = sum(dp[a][l] for a in range(2) for l in range(3)) % MOD\n        return result\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    n = int(data)\n    solution = Solution()\n    print(solution.checkRecord(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "10101",
          "expected_output": "183236316",
          "success": true,
          "output": "183236316"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode334.json",
    "problem_index_in_file": 0,
    "title": "Increasing Triplet Subsequence",
    "description_snippet": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i <...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code that solves the problem: \"Given an integer array nums, return true if there exists a triple of indices (i,j,k) such that i<j<k and nums[i] < nums[j] < nums[k]\". So we need to check existence of increasing subsequence of length 3.\n\nTypical solution: Use two variables, first = INF, second = INF. Iterate through array; if num <= first, set first=num; else if num <= second, set second=num; else return true; end; return false. Provide virtual code lines with explanation.\n\nWe must output each line with \"虛擬碼步驟\" and comment.\n\nWe use arrow notation. Also we must not output actual code. So we will produce \"Start\", \"→\" etc.\n\nNeed to handle input array. We'll mention \"Step 1: Initialize first = ∞\" etc. Provide decision branches.\n\nWe need to output in Chinese.\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: Set first = +∞, second = +∞ // 初始化兩個最小值，用於追蹤前兩個遞增元素\n→ Step 2: For each num in nums // 遍歷整個陣列\n    → Decision: 是否 num <= first? // 判斷目前數字是否比目前最小值還小或相等\n        Yes → Step 3: first = num // 更新最小值為此數字\n        No  → Decision: 是否 num <= second? // 若不小於第一個最小值，檢查是否小於第二個最小值\n            Yes → Step 4: second = num // 更新第二小值\n            No  → Step 5: return true // 找到第三個比前兩個都大的數字，滿足條件\n→ Step 6: return false // 完整遍歷後未找到滿足條件的三元組\nEnd // 程式執行結束\n\nBut we need each line separate and using arrow. But inside the loop we need indentation. Provide arrows accordingly.\n\nWe might format like:\n\nStart // 程式開始執行\n→ Step 1: first ← ∞, second ← ∞ // 初始化兩個最小值\n→ Step 2: for num in nums // 遍歷陣列\n    → Decision: num ≤ first? // 判斷 num 是否比 first 小\n        Yes → Step 3: first ← num // 更新 first\n        No  → Decision: num ≤ second? // 判斷 num 是否比 second 小\n            Yes → Step 4: second ← num // 更新 second\n            No  → Step 5: return true // 找到遞增三元組\n→ Step 6: return false // 未找到\nEnd // 程式結束\n\nMake sure each line uses arrow for steps. Use \"→\" for steps. For decisions use \"Decision:\".\n\nAlso must include \"Yes →\" and \"No →\" inside decision block.\n\nOk produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: first ← ∞, second ← ∞ // 初始化兩個最小值，用於追蹤前兩個遞增元素  \n→ Step 2: for num in nums // 遍歷整個陣列  \n  → Decision: num ≤ first? // 判斷目前數字是否比目前最小值還小或相等  \n   Yes → Step 3: first ← num // 更新最小值為此數字  \n   No  → Decision: num ≤ second? // 若不小於 first，檢查是否小於 second  \n    Yes → Step 4: second ← num // 更新第二小值  \n    No  → Step 5: return true // 找到第三個比前兩個都大的數字，滿足條件  \n→ Step 6: return false // 完整遍歷後未找到滿足條件的三元組  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom ast import literal_eval\n\nclass Solution:\n    def increasingTriplet(self, nums):\n        first = second = float('inf')\n        for num in nums:\n            if num <= first:\n                first = num\n            elif num <= second:\n                second = num\n            else:\n                return True\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取得等號右側的陣列字串\n    if '=' in data:\n        _, array_str = data.split('=', 1)\n    else:\n        array_str = data\n    array_str = array_str.strip()\n    # 轉換成 Python 物件\n    try:\n        nums = literal_eval(array_str)\n    except Exception:\n        nums = []\n    sol = Solution()\n    result = sol.increasingTriplet(nums)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4,5]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [5,4,3,2,1]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "nums = [2,1,5,0,4,6]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode390.json",
    "problem_index_in_file": 0,
    "title": "Elimination Game",
    "description_snippet": "You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (step by step) for this algorithm. No actual code. Provide each line with explanation. Should be structured with Start, Decision etc.\n\nWe have a list arr from 1 to n. Steps:\n\n- Initialize list arr = [1..n].\n- While length >1:\n  - If current direction left-to-right:\n    - Remove first element, then every other element from remaining.\n  - Else right-to-left:\n    - Remove last element, then every other element from remaining.\n\nSimplify: This is the Josephus problem? Actually it's known as \"Josephus Problem\" with step 2. Starting from left then right etc. Equivalent to find last remaining number. There is a pattern. But we just need to produce virtual code to simulate.\n\nWe can produce algorithm: Use pointer and step.\n\nSimpler: We can maintain two pointers: left index l, right index r, direction flag, and a skip flag to skip removal. Actually removal of first and every other: means keep every second element. Equivalent to filtering. So we can just compute next list.\n\nWe'll produce pseudocode:\n\nStart\n→ Initialize arr = [1..n] // list\n→ Initialize direction = \"left-to-right\" // first pass\n→ While length(arr) > 1:\n    → If direction == \"left-to-right\":\n        → arr = [arr[i] for i in range(0, len(arr), 2)] // keep every other starting from first\n        → direction = \"right-to-left\"\n      Else:\n        → arr = [arr[i] for i in range(len(arr)-1, -1, -2)] // keep every other from right\n        → direction = \"left-to-right\"\n→ Output arr[0] // last number\nEnd\n\nBut must use virtual code with arrows. We need to use \"→\" for steps, \"Decision:\" for if. Provide explanation comments.\n\nAlso we need to adhere to output format: Each line: `虛擬碼步驟` + space + `// 解釋/說明`.\n\nWe cannot use actual list comprehensions? It's okay but still it's virtual code. We can phrase as \"arr = filter every other starting from index 0\".\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: arr = [1, 2, 3, ..., n] // 建立 1 到 n 的遞增序列\n→ Step 2: direction = \"left-to-right\" // 初始方向為從左至右\n→ Decision: 若 len(arr) > 1? // 檢查是否還有多個元素\n    Yes →\n        → Decision: direction == \"left-to-right\"? // 判斷目前方向\n            Yes →\n                → Step 3: arr = arr[0::2] // 保留左側起始的第一個及之後每隔一個\n                → Step 4: direction = \"right-to-left\" // 改為右至左\n            No →\n                → Step 5: arr = arr[::-2] // 右側起始保留的最後一個及往左每隔一個\n                → Step 6: direction = \"left-to-right\" // 改為左至右\n        No →\n            → Step 7: output arr[0] // 唯一剩餘元素\nEnd // 程式結束\n\nBut we need to show while loop. Use a loop.\n\nCould do:\n\nStart\n→ Step 1: arr = [1..n]\n→ Step 2: direction = \"left\"\n→ While len(arr) > 1:\n    → Decision: direction == \"left\"?\n        Yes → arr = arr[0::2]; direction = \"right\"\n        No  → arr = arr[::-2]; direction = \"left\"\n→ Step 3: return arr[0]\n\nWe need each line individually.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: arr = [1, 2, 3, ..., n] // 初始化遞增序列\n→ Step 2: direction = \"left\" // 初始從左至右\n→ While len(arr) > 1: // 只要還有多於一個數字就繼續\n    → Decision: direction == \"left\"? // 判斷當前方向\n        Yes →\n            → Step 3: arr = arr[0::2] // 從左側保留第一個並每隔一個\n            → Step 4: direction = \"right\" // 下一輪改為右至左\n        No →\n            → Step 5: arr = arr[::-2] // 從右側保留最後一個並每隔一個往左\n            → Step 6: direction = \"left\" // 下一輪改為左至右\n→ Step 7: return arr[0] // 唯一剩下的數字即為答案\nEnd // 程式結束\n\nMake sure each line ends with `//` comment.\n\nWe must keep virtual code lines separate. Provide each line. Use arrow \"→\" before each step inside loop? Might need to indent? The example uses indentation for nested decision lines but they keep \"→\" at each. We can mimic.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: arr = [1, 2, 3, ..., n] // 初始化從 1 到 n 的遞增序列  \n→ Step 2: direction = \"left\" // 初始方向為從左至右  \n→ While len(arr) > 1: // 只要還有多於一個元素就繼續處理  \n    → Decision: direction == \"left\"? // 判斷目前的方向  \n        Yes →  \n            → Step 3: arr = arr[0::2] // 從左側保留第一個，再保留每隔一個元素  \n            → Step 4: direction = \"right\" // 下一輪改為右至左  \n        No →  \n            → Step 5: arr = arr[::-2] // 從右側保留最後一個，再保留每隔一個往左  \n            → Step 6: direction = \"left\" // 下一輪改為左至右  \n→ Step 7: return arr[0] // 最終剩下的唯一元素即為答案  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef last_remaining(n: int) -> int:\n    \"\"\"\n    求 [1, 2, ..., n] 經過交替從左往右、從右往左刪除每隔一個元素\n    後最後剩下的數字。\n    \"\"\"\n    head = 1          # 當前剩餘序列的最左端元素\n    step = 1          # 相鄰保留元素之間的距離\n    remaining = n     # 當前剩餘元素個數\n    left = True       # 初始方向為從左往右\n\n    while remaining > 1:\n        # 如果是左往右，或右往左但剩餘個數為奇數，則最左端元素會被刪除\n        if left or remaining % 2 == 1:\n            head += step\n        # 每一次刪除後，剩餘元素個數減半，step 變為原來的兩倍\n        remaining //= 2\n        step *= 2\n        left = not left  # 方向交替\n    return head\n\ndef solve() -> None:\n    \"\"\"\n    讀取輸入，計算結果並輸出。\n    輸入可能形如 'n = 9' 或單獨 '9'，程式會抽取第一個數字作為 n。\n    \"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    result = last_remaining(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 9",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode456.json",
    "problem_index_in_file": 0,
    "title": "132 Pattern",
    "description_snippet": "Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j]...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for detecting 132 pattern. Provide step-by-step pseudocode, each line with explanation. Must not output actual code but pseudocode with arrow, etc.\n\nWe should produce steps like Start, loop, maintain stack, etc. Use decision branches. The format: each line: \"虛擬碼步驟 // 解釋\". Lines must include arrow etc. We must produce gradually. Probably use typical algorithm: traverse from right to left, maintain stack of potential '3's, track 'second' variable for '2'.\n\nLet's produce steps: Start, Initialize variable second = -∞, stack empty. For each num from end to start: if num < second -> return true; else while stack not empty and num > stack.top -> second = stack.pop(); push num. After loop return false. End. Add decision steps. Use arrows. Ensure each line includes explanation.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化變數 second 為負無窮 // 用來存儲「2」的候選值  \n→ Step 2: 初始化空堆疊 stack // 用來儲存「3」的候選值  \n→ Step 3: 從右至左遍歷 nums 的每個元素 num // 逆序掃描可確保 i < j < k 的順序  \n  → Decision: 是否已到達陣列左端？  \n    Yes → Step 8: 回傳 false // 未發現 132 模式，結束  \n    No → Step 4: 判斷 num 是否小於 second  \n      Yes → Step 5: 回傳 true // 找到 i < j < k 且 nums[i] < nums[k] < nums[j] 的組合  \n      No → Step 6: 處理堆疊  \n       → Decision: stack 內是否有元素且 num > stack.top？  \n         Yes → Step 7: 循環彈出 stack.top，並將其賦值給 second  \n               → Decision: 還有更大元素？  \n                  Yes → 迴圈回到 Decision  \n                  No → Step 6a: 將 num 推入 stack  \n                  No → Step 6a: 將 num 推入 stack  \n                  No → Step 6b: 從迴圈結束回到 Step 3  \n→ Step 8: 回傳 false // 所有元素已處理，未發現符合條件的子序列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def find132pattern(self, nums):\n        \"\"\"Return True if a 132 pattern exists in nums.\"\"\"\n        stack = []\n        s3 = float('-inf')  # Candidate for the \"2\" in 132\n        for num in reversed(nums):\n            if num < s3:\n                return True\n            while stack and stack[-1] < num:\n                s3 = stack.pop()\n            stack.append(num)\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    # 從輸入中提取方括號內的列表\n    match = re.search(r'\\[.*\\]', data, re.DOTALL)\n    if match:\n        list_str = match.group()\n        # 轉成 Python 列表，安全地解析字面值\n        nums = ast.literal_eval(list_str)\n    else:\n        nums = []\n\n    sol = Solution()\n    result = sol.find132pattern(nums)\n    # 按題目要求輸出小寫字串\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "nums = [3,1,4,2]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,3,2,0]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode6.json",
    "problem_index_in_file": 0,
    "title": "ZigZag Conversion",
    "description_snippet": "Convert a string to a zigzag pattern and read line by line....",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for converting string to zigzag pattern and read line by line. The user didn't specify parameters: input string s and numRows. Should produce zigzag reading result. We need to create virtual code step-by-step with arrows, decisions, etc. Provide explanation in Chinese. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s 與行數 numRows // 取得待處理的字串與欲分成的行數\n→ Decision: 如果 numRows 小於等於 1 或 s 長度小於等於 numRows? // 簡化情況\n    Yes → Step 2: 輸出 s 本身 // 直接返回原字串，無需重排\n    No  → Decision: 如果 numRows 大於 s 長度? // 檢查行數是否多過字元數\n        Yes → Step 3: 輸出 s 本身 // 行數多於字元，字串保持不變\n        No  → Step 4: 初始化 rows 為 numRows 個空字串 // 用於存儲各行字元\n→ Step 5: 設定 currentRow = 0 // 開始於第一行\n→ Step 6: 設定 direction = +1 // 初始方向向下\n→ Step 7: 循環遍歷字串 s 中的每個字元 c\n    → Step 8: 將 c 加入 rows[currentRow] // 把字元追加到對應行\n    → Step 9: 若 currentRow 等於 0 或 currentRow 等於 numRows - 1? // 到達頂部或底部\n        Yes → Step 10: 方向反轉 direction = -direction // 改變上下方向\n        No  → // 方向保持不變\n    → Step 11: currentRow += direction // 移動到下一行\n→ Step 12: 組合 rows 中所有行字串為 result // 把各行連接起來\n→ Step 13: 輸出 result // 顯示最終的 zigzag 讀取結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef convert(s: str, numRows: int) -> str:\n    \"\"\"將字串轉換為 zigzag 模式，並按行順序讀取。\"\"\"\n    if numRows == 1 or numRows >= len(s):\n        return s\n    rows = [''] * numRows\n    index, step = 0, 1\n    for ch in s:\n        rows[index] += ch\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n        index += step\n    return ''.join(rows)\n\ndef parse_input(raw: str):\n    \"\"\"\n    從原始輸入字串中解析出 s 與 numRows。\n    支援兩種常見格式：\n    1) 兩行：第一行字串，第二行整數。\n    2) 單行：例如 \"s = 'PAYPALISHIRING', numRows = 3\"。\n    \"\"\"\n    lines = [line.strip() for line in raw.strip().splitlines() if line.strip()]\n    if len(lines) == 2:\n        # 第一行是字串，可能帶引號\n        s = lines[0].strip(\"'\\\"\")\n        try:\n            numRows = int(lines[1])\n        except ValueError:\n            raise ValueError(\"第二行必須為整數\")\n        return s, numRows\n\n    # 單行格式，使用正則表達式提取\n    pattern = r\"s\\s*=\\s*['\\\"](?P<s>.*?)['\\\"]\\s*,\\s*numRows\\s*=\\s*(?P<n>\\d+)\"\n    match = re.search(pattern, raw)\n    if match:\n        return match.group('s'), int(match.group('n'))\n\n    # 若還不符合，嘗試簡單的空格分隔\n    parts = raw.split()\n    if len(parts) >= 2:\n        s = parts[0].strip(\"'\\\"\")\n        try:\n            numRows = int(parts[1])\n            return s, numRows\n        except ValueError:\n            pass\n\n    raise ValueError(\"無法解析輸入格式\")\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    try:\n        s, numRows = parse_input(raw_input)\n    except Exception as e:\n        sys.exit(f\"Input error: {e}\")\n    result = convert(s, numRows)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'PAYPALISHIRING', numRows = 3",
          "expected_output": "'PAHNAPLSIIGYIR'",
          "success": true,
          "output": "PAHNAPLSIIGYIR"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode140.json",
    "problem_index_in_file": 0,
    "title": "Word Break II",
    "description_snippet": "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for word break II problem, generating all possible sentences. We should outline algorithm: use DFS with memoization. Steps: define function dfs(start). If start == len(s): return list containing empty string. If memo contains start, return. For end in range(start+1, len(s)+1): if substring in wordDict: for sub in dfs(end): add word + (' ' + sub if sub else '') to results. Memoize. Finally call dfs(0) return result list. Also initial setup: convert wordDict to set for O(1). Then produce virtual code lines accordingly. Each line must be: virtual code step + space + // explanation.\n\nWe should output \"Start\" line, then \"→\" lines. Use Decision: etc.\n\nWe must keep lines minimal but include steps.\n\nWe need to handle recursion, memoization, substring extraction, check wordDict, building results, memo storage, return. Also \"End\".\n\nLet's draft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 word_set ← wordDict 為集合 // 方便 O(1) 查找\n→ Step 2: 定義 memo ← 空字典 // 用於儲存子問題結果\n→ Step 3: 定義函式 dfs(start) // 從索引 start 開始分割\n    → Decision: 如果 start == len(s)？ // 檢查是否到達字串結尾\n        Yes → Return list containing empty string // 成功分割，返回空句子\n        No  → Decision: 如果 memo 中已有 start？ // 先前計算過\n            Yes → Return memo[start] // 直接回傳已存結果\n            No  → \n                → Step 4: 初始化 res ← 空列表 // 存放此起點的所有句子\n                → Decision: 對 end 在 range(start+1, len(s)+1) 迭代\n                    → Decision: 如果 s[start:end] 在 word_set？ // 判斷子字串是否為字典單字\n                        Yes → Step 5: 呼叫 dfs(end) 取得後續句子列表 sub_sentences\n                        → Decision: 對 sub in sub_sentences\n                            → Step 6: 如果 sub 為空字串\n                                Yes → Step 7: 組合 current_word ← s[start:end] // 只加一個單字\n                                No  → Step 8: 組合 current_word ← s[start:end] + ' ' + sub // 加單字和後續句子\n                            → Step 9: 將 current_word 加入 res // 收集此分割結果\n                        → Step 10: 進入下一個 end 值\n                → Step 11: memo[start] ← res // 缓存結果\n                → Step 12: Return res // 回傳從 start 開始的所有句子\n→ Step 13: result ← dfs(0) // 從整個字串開始遞迴\n→ Step 14: 返回 result // 輸出所有可能句子\nEnd // 程式執行結束\n\nWe need to ensure each line has \"虛擬碼步驟\" plus explanation. Use arrow for steps. Need to use \"→\" before step lines. Also Decision lines with indentation. Use \"Decision:\" exactly. Provide arrow inside. Let's format.\n\nWe also might include indentation spaces for nested. For readability but maintain arrow. For example:\n\n→ Decision: 如果 start == len(s)？ // ...\n    Yes → Return ...\n    No  → Decision: ...\n\nWe must keep arrow at each step. Use \"Yes →\" and \"No →\".\n\nAlso we need to maintain consistent format: after \"→\" we add the step. Use spaces.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: word_set ← wordDict 為集合 // 方便 O(1) 查找  \n→ Step 2: memo ← 空字典 // 用於儲存子問題結果  \n→ Step 3: 定義函式 dfs(start) // 從索引 start 開始分割  \n  → Decision: 如果 start == len(s)？ // 檢查是否到達字串結尾  \n   Yes → Return list containing empty string // 成功分割，返回空句子  \n   No  → Decision: 如果 memo 中已有 start？ // 先前計算過  \n    Yes → Return memo[start] // 直接回傳已存結果  \n    No  →  \n     → Step 4: res ← 空列表 // 存放此起點的所有句子  \n     → Decision: 對 end 在 range(start+1, len(s)+1) 迭代  \n      → Decision: 如果 s[start:end] 在 word_set？ // 判斷子字串是否為字典單字  \n       Yes → Step 5: sub_sentences ← dfs(end)  // 取得後續句子列表  \n        → Decision: 對 sub 在 sub_sentences  \n         → Step 6: 如果 sub 為空字串？  \n          Yes → Step 7: current_word ← s[start:end] // 只加一個單字  \n          No  → Step 8: current_word ← s[start:end] + ' ' + sub // 加單字和後續句子  \n          → Step 9: res ← res + current_word // 收集此分割結果  \n         → Step 10: 進入下一個 sub  \n        → Step 11: 進入下一個 end  \n      → Step 12: memo[start] ← res // 缓存結果  \n      → Step 13: Return res // 回傳從 start 開始的所有句子  \n→ Step 14: result ← dfs(0) // 從整個字串開始遞迴  \n→ Step 15: 返回 result // 輸出所有可能句子  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def wordBreak(self, s, wordDict):\n        word_set = set(wordDict)\n        memo = {}\n\n        def backtrack(start):\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]\n            res = []\n            for end in range(start + 1, len(s) + 1):\n                word = s[start:end]\n                if word in word_set:\n                    for sub_sentence in backtrack(end):\n                        if sub_sentence:\n                            res.append(word + \" \" + sub_sentence)\n                        else:\n                            res.append(word)\n            memo[start] = res\n            return res\n\n        return backtrack(0)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    result = Solution().wordBreak(s, wordDict)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']",
          "expected_output": "['cats and dog','cat sand dog']",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp04znuszy.py\", line 29, in <module>\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    s = 'catsanddog', wordDict = ['cat','cats','and','sand','dog']\n    ^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']",
          "expected_output": "['pine apple pen apple','pineapple pen apple','pine applepen apple']",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpzc17oov6.py\", line 29, in <module>\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    s = 'pineapplepenapple', wordDict = ['apple','pen','applepen','pine','pineapple']\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']",
          "expected_output": "[]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp7907om5k.py\", line 29, in <module>\n    exec(data, globals())  # 解析輸入，將 s 與 wordDict 變數定義進來\n    ^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    s = 'catsandog', wordDict = ['cats','dog','sand','and','cat']\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode396.json",
    "problem_index_in_file": 0,
    "title": "Rotate Function",
    "description_snippet": "You are given an integer array nums of length n.\n\nAssume arrk to be an array obtained by rotating nu...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, no actual code, with explanations, step by step. Problem: given array, compute rotation function F(k) for all k and find maximum. There is known efficient solution O(n). We need to produce virtual code steps for algorithm: compute initial sum of arr[i] * i, compute total sum of array, then iteratively update F(k+1)=F(k)+totalSum - n*arr[k]. Keep max. Let's produce steps with Start, End, etc. Provide explanation per line. Must be in Traditional Chinese. Use arrow \"→\". Provide each line. Let's craft.\n\nLine 1: Start // begin\nLine 2: → Step 1: 取得輸入陣列 nums 與長度 n // get array and length\nLine 3: → Step 2: 計算總和 totalSum = sum(nums[i]) // sum of elements\nLine 4: → Step 3: 計算初始旋轉函數 F0 = Σ i * nums[i] // initial value\nLine 5: → Step 4: 設 maxF = F0 // max so far\nLine 6: → Step 5: 對 i 從 0 到 n-2 進行迴圈 // iterate remaining rotations\nLine 7: →     Decision: if i < n-1? // loop condition\nLine 8: →         Yes → Step 6: 更新 F_next = F_current + totalSum - n * nums[i] // recurrence\nLine 9: →         Yes → Step 7: 設 F_current = F_next // new current value\nLine 10: →        Yes → Step 8: 更新 maxF = max(maxF, F_current) // keep max\nLine 11: →        Yes → Step 9: 繼續下一輪迴圈 // loop continues\nLine 12: →     No → End // loop finished\nLine 13: → Step 10: 輸出 maxF // output maximum\nLine 14: End // end\n\nNeed arrow formatting; each line has \"→\" or \"    Yes →\" etc. Need to keep consistent. For Decision block, we can indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入陣列 nums 與長度 n // 讀取陣列與其元素數量  \n→ Step 2: 計算總和 totalSum = Σ nums[i] // 求所有元素之和  \n→ Step 3: 計算初始旋轉函數 F0 = Σ i * nums[i] // 先算 k=0 時的 F 值  \n→ Step 4: 設 maxF = F0 // 設定目前已知的最大值  \n→ Step 5: 對 i 從 0 到 n-2 進行迴圈 // 從第一個旋轉到最後一個  \n→     Decision: i < n-1? // 判斷是否還有下一輪旋轉  \n→         Yes → Step 6: 更新 F_next = F_current + totalSum - n * nums[i] // F(k+1) 的快速更新公式  \n→         Yes → Step 7: 設 F_current = F_next // 把新的 F 值設為目前值  \n→         Yes → Step 8: 更新 maxF = max(maxF, F_current) // 若更大則更新最大值  \n→         Yes → Step 9: 繼續下一輪迴圈 // 進入下一次旋轉  \n→     No → End // 迴圈結束  \n→ Step 10: 輸出 maxF // 回傳最大的旋轉函數值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef max_rotate_function(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    total = sum(nums)\n    # 初始 F(0)\n    cur = sum(i * num for i, num in enumerate(nums))\n    max_val = cur\n    # 迭代更新 F(k+1)\n    for i in range(n - 1):\n        cur += total - n * nums[i]\n        if cur > max_val:\n            max_val = cur\n    return max_val\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料，支持以下兩種格式：\n    1. nums = [1, 2, 3]\n    2. [1, 2, 3]\n    \"\"\"\n    data = data.strip()\n    if data.startswith(\"nums\"):\n        # 找到等號後的列表字串\n        _, lst_str = data.split(\"=\", 1)\n        lst_str = lst_str.strip()\n    else:\n        lst_str = data\n    # 使用 ast.literal_eval 解析為列表\n    return ast.literal_eval(lst_str)\n\ndef main():\n    raw = sys.stdin.read()\n    nums = parse_input(raw)\n    result = max_rotate_function(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        },
        {
          "example_index": 1,
          "input": "nums = [100]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode307.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Mutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for the problem: design NumArray with update and sumRange. Use virtual code steps. Should be line by line, each line \"虛擬碼步驟 // 解釋\". Use arrow notation. Need structure: Start, Decision, etc.\n\nLet's produce a design: we can use Fenwick tree or segment tree. Let's produce virtual code for building segment tree. Provide steps: initialization, update, query.\n\nThe virtual code might include: Start, BuildSegmentTree, UpdateSegmentTree, QuerySegmentTree, End.\n\nEach step with explanation.\n\nLet's produce around maybe 15-20 lines. Provide each line like:\n\nStart // 程式開始執行\n\n→ Step 1: 建立數組長度 n = nums.length // 取得陣列長度\n\n→ Step 2: 建立 segmentTree 數組長度 4*n // 為了安全分配足夠空間\n\n→ Step 3: Call BuildSegmentTree(0, n-1, 1) // 建立段式樹\n\n→ Decision: ... etc.\n\nFor BuildSegmentTree recursion: if l == r: segmentTree[node] = nums[l] else build children, segmentTree[node] = left + right.\n\nThen update: UpdateSegmentTree(0, n-1, 1, index, val). Recursively adjust.\n\nQuery: SumRange -> QuerySegmentTree(0, n-1, 1, left, right).\n\nWe can include decision branches for recursion base case.\n\nNeed to include arrow and decision. Use \"Decision:\".\n\nWe should output line by line. So each step: maybe a single line with arrow to next step. Might need indentation? Provide arrow \"→\" preceding each step. Use \"Decision:\" lines.\n\nLet's produce.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: Set n = nums.length // 取得陣列長度\n→ Step 2: Allocate segmentTree array of size 4*n // 用於儲存段式樹\n→ Step 3: Call BuildSegmentTree(l=0, r=n-1, node=1) // 建立段式樹\n→ Decision: l == r? // 檢查是否為葉節點\n    Yes → Step 4: segmentTree[node] = nums[l] // 葉節點直接存值\n    No  → Step 5: mid = (l+r)/2 // 計算中點\n→ Decision: l == r? // 判斷左子樹是否葉節點\n    Yes → Step 6: segmentTree[2*node] = nums[l] // 左子葉節點\n    No  → Step 7: Call BuildSegmentTree(l, mid, 2*node) // 建立左子樹\n→ Decision: r == mid+1? // 判斷右子樹是否葉節點\n    Yes → Step 8: segmentTree[2*node+1] = nums[mid+1] // 右子葉節點\n    No  → Step 9: Call BuildSegmentTree(mid+1, r, 2*node+1) // 建立右子樹\n→ Step 10: segmentTree[node] = segmentTree[2*node] + segmentTree[2*node+1] // 計算父節點值\nEnd // 構建完成\n\nBut this is messy. Perhaps better to outline high-level steps rather than each recursion.\n\nSimplify: use pseudo-code with recursion conceptually, not detailed leaf decisions.\n\nWe'll provide:\n\nStart // 程式開始執行\n→ Step 1: Set n = nums.length // 取得陣列長度\n→ Step 2: Allocate segmentTree array size 4*n // 用於段式樹\n→ Step 3: BuildSegmentTree(node=1, l=0, r=n-1) // 建立段式樹\n→ Step 4: Define Update(index, val) // 更新\n→ Step 5: Define SumRange(left, right) // 查詢\n\nThen show functions BuildSegmentTree, UpdateSegmentTree, QuerySegmentTree.\n\nWe need to list each function line by line.\n\nLet's produce like:\n\nStart // 程式開始執行\n→ Step 1: Create class NumArray // 定義類別\n→ Decision: 初始化輸入陣列? // 檢查是否需要初始化\n    Yes → Step 2: nums = inputArray // 保存輸入陣列\n    No  → Step 3: nums = empty // 若無輸入\n→ Step 4: n = nums.length // 陣列長度\n→ Step 5: segmentTree = new array of size 4*n // 準備段式樹儲存\n→ Step 6: Call BuildSegmentTree(node=1, l=0, r=n-1) // 建立段式樹\n\nDefine BuildSegmentTree:\n\nStep 7: Function BuildSegmentTree(node, l, r)\n→ Decision: l == r? // 是否葉節點\n    Yes → Step 8: segmentTree[node] = nums[l] // 存葉節點值\n    No  → Step 9: mid = (l+r)/2 // 計算中點\n           Call BuildSegmentTree(node*2, l, mid) // 左子樹\n           Call BuildSegmentTree(node*2+1, mid+1, r) // 右子樹\n           segmentTree[node] = segmentTree[node*2] + segmentTree[node*2+1] // 父節點值\n\nDefine Update:\n\nStep 10: Function Update(index, val)\n→ Call UpdateSegmentTree(node=1, l=0, r=n-1, idx=index, newVal=val)\n\nDefine UpdateSegmentTree:\n\nStep 11: Function UpdateSegmentTree(node, l, r, idx, newVal)\n→ Decision: l == r? // 是否葉節點\n    Yes → segmentTree[node] = newVal // 更新葉節點\n    No  → mid = (l+r)/2\n          Decision: idx <= mid? // 更新哪一側\n              Yes → Call UpdateSegmentTree(node*2, l, mid, idx, newVal)\n              No  → Call UpdateSegmentTree(node*2+1, mid+1, r, idx, newVal)\n          segmentTree[node] = segmentTree[node*2] + segmentTree[node*2+1] // 更新父節點\n\nDefine SumRange:\n\nStep 12: Function SumRange(left, right)\n→ Return QuerySegmentTree(node=1, l=0, r=n-1, ql=left, qr=right)\n\nDefine QuerySegmentTree:\n\nStep 13: Function QuerySegmentTree(node, l, r, ql, qr)\n→ Decision: ql <= l and r <= qr? // 範圍完全覆蓋\n    Yes → Return segmentTree[node] // 直接返回\n    No  → mid = (l+r)/2\n          result = 0\n          Decision: ql <= mid? // 是否左子樹有重疊\n              Yes → result += QuerySegmentTree(node*2, l, mid, ql, qr)\n          Decision: qr > mid? // 是否右子樹有重疊\n              Yes → result += QuerySegmentTree(node*2+1, mid+1, r, ql, qr)\n          Return result\n\nEnd // 程式結束\n\nWe need to ensure each line uses arrow → and has explanation. We should use indentation maybe but not necessary. Each line separate. Provide step numbering optional but not required. But maintain format: \"虛擬碼步驟 // 解釋\". Provide arrow.\n\nWe should also include 'Start' and 'End'.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立類別 NumArray // 定義解決問題的主類  \n→ Step 2: 建立私有屬性 nums, n, segmentTree // 用於儲存數組、長度與段式樹  \n→ Step 3: NumArray(numsInput) // 構造函式  \n→ Decision: numsInput 為空? // 檢查輸入是否為空陣列  \n Yes → Step 4: this.n = 0 // 長度為 0  \n     → Step 5: this.segmentTree = [] // 空段式樹  \n No  → Step 6: this.n = numsInput.length // 設定長度  \n     → Step 7: this.nums = [...numsInput] // 複製輸入陣列  \n     → Step 8: this.segmentTree = new Array(4 * this.n) // 分配段式樹儲存空間  \n     → Step 9: BuildSegmentTree(1, 0, this.n - 1) // 建立段式樹  \n\n→ Function BuildSegmentTree(node, l, r) // 構造段式樹  \n → Decision: l == r? // 判斷是否為葉節點  \n  Yes → Step 10: segmentTree[node] = nums[l] // 儲存葉節點值  \n  No  → Step 11: mid = Math.floor((l + r) / 2) // 計算中點  \n      → Step 12: BuildSegmentTree(node * 2, l, mid) // 建左子樹  \n      → Step 13: BuildSegmentTree(node * 2 + 1, mid + 1, r) // 建右子樹  \n      → Step 14: segmentTree[node] = segmentTree[node * 2] + segmentTree[node * 2 + 1] // 計算父節點值  \n\n→ Function update(index, val) // 公共更新接口  \n → Step 15: UpdateSegmentTree(1, 0, this.n - 1, index, val) // 進行遞歸更新  \n\n→ Function UpdateSegmentTree(node, l, r, idx, newVal) // 遞歸更新段式樹  \n → Decision: l == r? // 到達葉節點  \n  Yes → Step 16: segmentTree[node] = newVal // 更新值  \n  No  → Step 17: mid = Math.floor((l + r) / 2) // 中點  \n      → Decision: idx <= mid? // 判斷更新哪一側  \n     Yes → Step 18: UpdateSegmentTree(node * 2, l, mid, idx, newVal) // 更新左子樹  \n     No  → Step 19: UpdateSegmentTree(node * 2 + 1, mid + 1, r, idx, newVal) // 更新右子樹  \n      → Step 20: segmentTree[node] = segmentTree[node * 2] + segmentTree[node * 2 + 1] // 更新父節點  \n\n→ Function sumRange(left, right) // 公共查詢接口  \n → Step 21: return QuerySegmentTree(1, 0, this.n - 1, left, right) // 進行遞歸查詢  \n\n→ Function QuerySegmentTree(node, l, r, ql, qr) // 遞歸查詢段式樹  \n → Decision: ql <= l && r <= qr? // 範圍完全覆蓋  \n  Yes → Step 22: return segmentTree[node] // 直接返回該節點值  \n  No  → Step 23: mid = Math.floor((l + r) / 2) // 中點  \n      → Step 24: let res = 0 // 儲存結果  \n      → Decision: ql <= mid? // 左子樹有重疊  \n     Yes → Step 25: res += QuerySegmentTree(node * 2, l, mid, ql, qr) // 左子樹遞歸  \n      → Decision: qr > mid? // 右子樹有重疊  \n     Yes → Step 26: res += QuerySegmentTree(node * 2 + 1, mid + 1, r, ql, qr) // 右子樹遞歸  \n      → Step 27: return res // 返回合計  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        self.tree = [0] * (self.n + 1)\n        for i, val in enumerate(nums):\n            self._update_tree(i + 1, val)\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # Find the split between commands and arguments\n    split_idx = data.find('], [')\n    if split_idx == -1:\n        split_idx = data.find('],[')\n    if split_idx == -1:\n        split_idx = data.find('],')\n    commands_part = data[:split_idx + 1]\n    args_part = data[split_idx + 3:]\n\n    commands = ast.literal_eval(commands_part)\n    args = ast.literal_eval(args_part)\n\n    result = []\n    obj = None\n    for cmd, arg in zip(commands, args):\n        if cmd == \"NumArray\":\n            obj = NumArray(arg[0])\n            result.append(None)\n        elif cmd == \"update\":\n            obj.update(arg[0], arg[1])\n            result.append(None)\n        elif cmd == \"sumRange\":\n            result.append(obj.sumRange(arg[0], arg[1]))\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "success": true,
          "output": "[null, 9, null, 8]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode342.json",
    "problem_index_in_file": 0,
    "title": "Power of Four",
    "description_snippet": "Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines with explanations. The algorithm: check if n>0, and (n & (n-1))==0 ensures power of 2, and also check n mod 3==1 ensures power of 4. Or we can loop dividing by 4 until 1. Use conditions.\n\nUse Start, Decision, Step, End. Provide each line with explanation.\n\nLet's produce pseudocode:\n\nStart\n→ Step 1: Input n // get integer\n→ Decision: n <= 0? // negative or zero not power of 4\n    Yes → Step 2: Return False // not power of 4\n    No  → Decision: (n & (n-1)) == 0? // check power of 2\n        Yes → Decision: n % 3 == 1? // only 4^x ≡ 1 mod 3\n            Yes → Step 3: Return True // power of 4\n            No  → Step 4: Return False // power of 2 but not 4\n        No  → Step 5: Return False // not power of 2\nEnd\n\nAlternatively, use while dividing by 4: while n%4==0: n/=4; then return n==1.\n\nWe can show both or choose one. Provide step by step.\n\nLet's produce final.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取整數 n // 取得要檢查的數值\n→ Decision: n <= 0? // 判斷數值是否為非正數\n    Yes → Step 2: 回傳 False // 非正數無法為 4 的冪\n    No  → Decision: (n & (n-1)) == 0? // 判斷 n 是否為 2 的冪\n        Yes → Decision: n % 3 == 1? // 4 的冪同時滿足 4^x ≡ 1 (mod 3)\n            Yes → Step 3: 回傳 True // 符合條件，為 4 的冪\n            No  → Step 4: 回傳 False // 是 2 的冪但不是 4 的冪\n        No  → Step 5: 回傳 False // 不是 2 的冪，直接排除\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        \"\"\"\n        判斷 n 是否為 4 的冪。\n        1. n 必須為正數。\n        2. n 必須是 2 的冪： (n & (n-1)) == 0。\n        3. 4^x ≡ 1 (mod 3)，因此 (n-1) 必須能被 3 整除。\n        \"\"\"\n        return n > 0 and (n & (n - 1)) == 0 and (n - 1) % 3 == 0\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    # 取得第一個出現的整數\n    match = re.search(r'(-?\\d+)', raw_input)\n    n = int(match.group(1)) if match else 0\n\n    sol = Solution()\n    print('true' if sol.isPowerOfFour(n) else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode327.json",
    "problem_index_in_file": 0,
    "title": "Count of Range Sum",
    "description_snippet": "Given an integer array nums and two integers lower and upper, return the number of range sums that l...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code for computing count of range sums within [lower, upper] for integer array. Classic problem: count of range sums. Approach: prefix sums + divide and conquer (count while merging), or Fenwick with coordinate compression, or BIT. We'll produce algorithm using prefix sums and divide-conquer (merge sort style) with counting while merging. Provide steps.\n\nWe'll produce step-by-step pseudocode: Start, Step 1: compute prefix sums array of length n+1. Step 2: call function countWhileMergeSort on prefix array 0..n inclusive. Recursively split, count left and right counts, then count cross sums. The counting of cross sums uses two pointers while merging: for each left value, find number of right values such that lower <= right - left <= upper. Count them using binary search or two pointers.\n\nWe produce virtual code lines accordingly.\n\nWe should include decisions: Decision: if left < right? Recursion.\n\nAlso decisions for cross counting: for each left, find leftBound and rightBound indices in right part.\n\nWe need to ensure each line contains '虛擬碼步驟' plus comment.\n\nWe produce step by step:\n\nStart\n→ Step 1: Compute prefix array prefix[0] = 0 // prefix sum array init\n→ For i from 0 to n-1: prefix[i+1] = prefix[i] + nums[i] // build prefix sums\n→ Step 2: Return countWhileMergeSort(prefix, 0, n) // n is length-1? Wait prefix length = n+1, indices 0..n. So we call with left=0, right=n (exclusive or inclusive?). In algorithm, we typically use left inclusive, right exclusive. We'll define function countWhileMergeSort(prefix, left, right) counting in [left, right) where right is exclusive. We'll implement accordingly.\n\nThus Step 2: return countWhileMergeSort(prefix, 0, n+1) // because prefix length n+1, exclusive right.\n\nThen we define recursive function.\n\nBut we can present pseudocode with functions defined as separate blocks.\n\nWe need to use arrow for decision. For recursion, we can have:\n\n→ Function countWhileMergeSort(array, left, right)\n    // left inclusive, right exclusive\n    → Decision: If right - left <= 1 // only one element\n        Yes → return 0 // no pairs\n        No → // proceed\n\nThen recursively compute mid = (left+right)/2\n\n→ leftCount = countWhileMergeSort(array, left, mid)\n→ rightCount = countWhileMergeSort(array, mid, right)\n\nNow count cross pairs between left and right halves.\n\nWe need two pointers to count for each i in left side.\n\nWe can use nested loops with two pointers. But we can present as:\n\n→ Initialize count = 0\n→ Initialize j = mid, k = mid\n→ For i from left to mid-1\n    // find smallest j such that array[j] - array[i] >= lower\n    → While j < right AND array[j] - array[i] < lower\n        j = j + 1\n    // find smallest k such that array[k] - array[i] > upper\n    → While k < right AND array[k] - array[i] <= upper\n        k = k + 1\n    → count = count + (k - j) // number of valid sums for this i\n\nNow merge step to sort array[left:right] because we need sorted for upper recursion.\n\n→ Merge sorted halves array[left:mid] and array[mid:right] into temp and copy back.\n\nReturn leftCount + rightCount + count\n\nWe'll include explanations after each line.\n\nWe also need final End.\n\nLet's produce each line.\n\nWe should number steps maybe? Not necessary, but each line has arrow.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: prefix[0] ← 0 // 初始化前綴和陣列\n→ For i ← 0 to n-1\n    → prefix[i+1] ← prefix[i] + nums[i] // 依序累加得到前綴和\n→ Step 2: return countWhileMergeSort(prefix, 0, n+1) // 呼叫遞迴計算區間和數量\n\nNow define function:\n\n→ Function countWhileMergeSort(array, left, right)\n    // 以區間 [left, right) 進行遞迴\n    → Decision: If right - left ≤ 1\n        Yes → return 0 // 只有一個元素時沒有區間和\n        No →\n            → mid ← (left + right) / 2 // 取中點\n            → leftCount ← countWhileMergeSort(array, left, mid) // 左半部計數\n            → rightCount ← countWhileMergeSort(array, mid, right) // 右半部計數\n\nNow cross count:\n\n→ Initialize count ← 0 // 交叉區間和計數\n→ Initialize j ← mid, k ← mid // 指標準備遍歷右半\n→ For i ← left to mid-1\n    // 針對左半每個前綴和尋找右半可滿足條件的前綴和區間\n    → While j < right AND array[j] - array[i] < lower\n        j ← j + 1 // 移動 j 以滿足下限\n    → While k < right AND array[k] - array[i] ≤ upper\n        k ← k + 1 // 移動 k 以滿足上限\n    → count ← count + (k - j) // 此 i 對應的有效區間和數量\n\nMerge step:\n\n→ // 合併兩個已排序的半段，保持全域排序\n→ temp ← empty list\n→ p ← left, q ← mid\n→ While p < mid AND q < right\n    → If array[p] ≤ array[q]\n        → temp.append(array[p]); p ← p + 1\n        → Else temp.append(array[q]); q ← q + 1\n→ While p < mid\n    → temp.append(array[p]); p ← p + 1\n→ While q < right\n    → temp.append(array[q]); q ← q + 1\n→ For idx, val in enumerate(temp)\n    → array[left + idx] ← val // 把已排序的子陣列寫回原陣列\n\nReturn leftCount + rightCount + count // 合併計數\n\nEnd // 程式執行結束\n\nBut we need to maintain arrow formatting and comment style. For each line, we need to keep '→' for steps. For nested lines, we need to indent properly. For function, maybe we just prefix with arrow. For decision lines inside function, we use 'Decision:'.\n\nBut arrow lines must start with '→' each line. Indentation is allowed but we might maintain structure with arrows.\n\nLet's produce final output accordingly.\n\nEnsure we don't output real code. Use only virtual code. Use Chinese comment.\n\nAlso we need to include all lines. Let's produce.\n\nAlso we might need to indicate function definition line as arrow.\n\nLet's craft final output.\n\nWe might include '→ Function countWhileMergeSort(array, left, right)' comment.\n\nWe also need to keep decisions.\n\nWe might also include 'Decision:' lines inside.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: prefix[0] ← 0 // 初始化前綴和陣列  \n→ For i ← 0 to n-1  \n    → prefix[i+1] ← prefix[i] + nums[i] // 依序累加得到前綴和  \n→ Step 2: return countWhileMergeSort(prefix, 0, n+1) // 呼叫遞迴計算區間和數量  \n\n→ Function countWhileMergeSort(array, left, right)  \n    // 以區間 [left, right) 進行遞迴  \n    → Decision: If right - left ≤ 1  \n        Yes → return 0 // 只有一個元素時沒有區間和  \n        No →  \n            → mid ← (left + right) / 2 // 取中點  \n            → leftCount ← countWhileMergeSort(array, left, mid) // 左半部計數  \n            → rightCount ← countWhileMergeSort(array, mid, right) // 右半部計數  \n\n            // 交叉區間和計數  \n            → count ← 0 // 初始化交叉計數  \n            → j ← mid, k ← mid // 指標準備遍歷右半  \n            → For i ← left to mid-1  \n                // 針對左半每個前綴和尋找右半可滿足條件的前綴和區間  \n                → While j < right AND array[j] - array[i] < lower  \n                    → j ← j + 1 // 移動 j 以滿足下限  \n                → While k < right AND array[k] - array[i] ≤ upper  \n                    → k ← k + 1 // 移動 k 以滿足上限  \n                → count ← count + (k - j) // 此 i 對應的有效區間和數量  \n\n            // 合併兩個已排序的半段，保持全域排序  \n            → temp ← empty list  \n            → p ← left, q ← mid  \n            → While p < mid AND q < right  \n                → If array[p] ≤ array[q]  \n                    → temp.append(array[p]); p ← p + 1  \n                    → Else temp.append(array[q]); q ← q + 1  \n            → While p < mid  \n                → temp.append(array[p]); p ← p + 1  \n            → While q < right  \n                → temp.append(array[q]); q ← q + 1  \n            → For idx, val in enumerate(temp)  \n                → array[left + idx] ← val // 把已排序的子陣列寫回原陣列  \n\n            → return leftCount + rightCount + count // 合併計數  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def countRangeSum(self, nums, lower, upper):\n        prefix = [0]\n        for num in nums:\n            prefix.append(prefix[-1] + num)\n\n        def sort_and_count(lo, hi):\n            if hi - lo <= 1:\n                return 0\n            mid = (lo + hi) // 2\n            count = sort_and_count(lo, mid) + sort_and_count(mid, hi)\n\n            i = j = mid\n            for left in prefix[lo:mid]:\n                while i < hi and prefix[i] - left < lower:\n                    i += 1\n                while j < hi and prefix[j] - left <= upper:\n                    j += 1\n                count += j - i\n\n            prefix[lo:hi] = sorted(prefix[lo:hi])\n            return count\n\n        return sort_and_count(0, len(prefix))\n\ndef parse_input(input_str):\n    # Extract nums array\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    if not nums_match:\n        raise ValueError(\"Cannot find nums array in input\")\n    nums = eval(nums_match.group(1))  # safe enough for simple integer lists\n\n    # Extract lower\n    lower_match = re.search(r'lower\\s*=\\s*(-?\\d+)', input_str)\n    if not lower_match:\n        raise ValueError(\"Cannot find lower in input\")\n    lower = int(lower_match.group(1))\n\n    # Extract upper\n    upper_match = re.search(r'upper\\s*=\\s*(-?\\d+)', input_str)\n    if not upper_match:\n        raise ValueError(\"Cannot find upper in input\")\n    upper = int(upper_match.group(1))\n\n    return nums, lower, upper\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums, lower, upper = parse_input(data)\n    result = Solution().countRangeSum(nums, lower, upper)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,5,-1], lower = -2, upper = 2",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0], lower = 0, upper = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode228.json",
    "problem_index_in_file": 0,
    "title": "Summary Ranges",
    "description_snippet": "You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that solves the problem. Provide line-by-line with explanation.\n\nWe need to use virtual steps: Start, End, Decision etc. Must not output real code. Just steps. So we can describe algorithm: iterate through sorted unique array, track start and prev. For each number, if current is prev+1, continue; else finalize range from start to prev and reset. After loop finalize last range. Build list of strings accordingly. Then return list.\n\nWe must use arrow format: \"→ Step: ... // explanation\" etc. For decisions: \"Decision: ...\" with Yes → and No →.\n\nLet's craft lines:\n\nStart // 程式開始\n→ Step 1: 初始化空列表 ranges // 用於存儲結果\n→ Step 2: 若 nums 為空，返回 ranges // 空輸入直接返回\n→ Step 3: 設定 start = nums[0]，prev = nums[0] // 開始與上一個數字初始化\n→ Decision: nums 長度 > 1? // 是否需要遍歷剩餘元素\n    Yes → Step 4: 從 i = 1 開始遍歷 nums // 迭代每個數字\n        → Decision: nums[i] == prev + 1? // 檢查是否為連續\n            Yes → Step 5: prev = nums[i] // 連續，更新 prev\n            No  → Step 6: 完成範圍 [start, prev] // 將範圍加入列表\n                → Step 7: 若 start == prev → Step 8: 加入 \"start\" 到 ranges\n                → Step 9: Else → Step 10: 加入 \"start->prev\" 到 ranges\n                → Step 11: start = nums[i]，prev = nums[i] // 重置為新範圍\n        → End of inner loop iteration\n    No  → Step 12: // nums 只有一個元素，直接處理\n→ Decision: 是否已經處理完所有元素? // 這裡在循環結束後\n    Yes → Step 13: 完成最後一個範圍 [start, prev] // 將剩餘範圍加入\n        → Step 14: 若 start == prev → Step 15: 加入 \"start\" 到 ranges\n        → Step 16: Else → Step 17: 加入 \"start->prev\" 到 ranges\n→ Step 18: 返回 ranges // 輸出結果\nEnd // 程式結束\n\nWe need to ensure formatting: each line with virtual code and comment. Use \"→\" before each step line. For decisions indent. Should indent sub-steps maybe with spaces. Provide exactly as example. Use spaces to show indentation.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空列表 ranges // 用於存儲最終的範圍結果  \n→ Step 2: 若 nums 為空，直接返回 ranges // 空輸入時不需要處理  \n→ Step 3: 設定 start = nums[0]，prev = nums[0] // 初始化第一個數字作為範圍起點  \n→ Decision: nums 長度 > 1? // 是否有後續元素需要遍歷  \n    Yes → Step 4: 從 i = 1 開始遍歷 nums // 逐個檢查後續數字  \n        → Decision: nums[i] == prev + 1? // 判斷是否仍在同一連續區間  \n            Yes → Step 5: prev = nums[i] // 連續，更新前一個數字  \n            No → Step 6: 完成範圍 [start, prev] // 當不連續時結束上一範圍  \n                → Step 7: 若 start == prev → Step 8: 加入 \"start\" 到 ranges // 單一數字的範圍  \n                → Step 9: 否則 → Step 10: 加入 \"start->prev\" 到 ranges // 連續範圍的表示  \n                → Step 11: start = nums[i]，prev = nums[i] // 重置為新的範圍起點  \n        → End of inner loop iteration  \n    No → Step 12: // nums 只有一個元素，直接處理下一步  \n→ Decision: 已處理完所有元素? // 在循環結束後確認是否需要最後一次範圍  \n    Yes → Step 13: 完成最後一個範圍 [start, prev] // 加入剩餘範圍  \n        → Step 14: 若 start == prev → Step 15: 加入 \"start\" 到 ranges  \n        → Step 16: 否則 → Step 17: 加入 \"start->prev\" 到 ranges  \n→ Step 18: 返回 ranges // 輸出整個範圍列表  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\n\nclass Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        res = []\n        start = end = nums[0]\n        for n in nums[1:]:\n            if n == end + 1:\n                end = n\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(f\"{start}->{end}\")\n                start = end = n\n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(f\"{start}->{end}\")\n        return res\n\ndef parse_input(data: str):\n    \"\"\"Parse input which may be like 'nums = [0,1,2]' or just a list.\"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if data.startswith(\"nums\"):\n        idx = data.find(\"=\")\n        if idx != -1:\n            data = data[idx + 1:].strip()\n    # Safe eval for numeric list\n    try:\n        nums = eval(data, {\"__builtins__\": None}, {})\n    except Exception:\n        # fallback manual parsing\n        nums = [int(x) for x in data.strip(\"[]\").split(\",\") if x.strip()]\n    return nums\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().summaryRanges(nums)\n    print(json.dumps(result))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [0,1,2,4,5,7]",
          "expected_output": "[\"0->2\",\"4->5\",\"7\"]",
          "success": true,
          "output": "[\"0->2\", \"4->5\", \"7\"]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,2,3,4,6,8,9]",
          "expected_output": "[\"0\",\"2->4\",\"6\",\"8->9\"]",
          "success": true,
          "output": "[\"0\", \"2->4\", \"6\", \"8->9\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode282.json",
    "problem_index_in_file": 0,
    "title": "Expression Add Operators",
    "description_snippet": "Given a string num that contains only digits and an integer target, return all possibilities to inse...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solving this problem: expression add operators to reach target. We'll produce a recursive DFS/backtracking approach. Provide step-by-step pseudocode lines with explanation after //. Must use Start, End, Decision, etc. Each line must be virtual code step. Use arrows and decision. Must be line by line. Provide explanation each line. Use Chinese. Let's craft.\n\nWe should structure: Start -> Step: define function addOperators(num,target) -> Step: call DFS -> DFS function with params (path, pos, evaluated, multed) explanation. Steps for recursion. Use Decision to check leading zeros, to choose operator, update evaluated. For each operator, call DFS recursively. At end, if pos==len(num) and evaluated==target, add path to result. Finally return result. Ensure to handle * operator precedence by keeping multed value. Use Decision: if pos==len(num) ... etc. Use recursion base case.\n\nWe need to output as lines: \"Start // 程式開始執行\" etc.\n\nLet's create virtual code.\n\nWe'll use \"→ Step: ...\" lines. Use indentation? The sample shows indentation via spaces after Decision, but we can just produce each line. For decisions we need branch lines with Yes → ... No → etc. We can use nested decisions with indentation or arrow lines.\n\nWe need to follow the format: each line: \"虛擬碼步驟\" + space + \"// 解釋/說明\". So each line has virtual code step, space, then comment. No need to wrap in code fences. We can indent with spaces but keep format.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 addOperators(num, target) // 建立入口函式\n→ Step 2: 初始化空清單 result // 用於儲存符合條件的表達式\n→ Step 3: 定義遞迴函式 dfs(path, pos, evaluated, multed) // path: 目前表達式；pos: 位置；evaluated: 已計算值；multed: 上一步乘法累積\n→ Decision: 如果 pos == len(num) ?\n    Yes → Step 4: 如果 evaluated == target? // 檢查是否達到目標值\n        Yes → Step 5: result.append(path) // 加入符合條件的表達式\n        No  → // 不符合，回到上一層遞迴\n    No  → Step 6: 取子字串 cur = num[pos: i+1] // 從 pos 到 i 的子字串作為目前數字\n→ Decision: 如果 cur 以 '0' 開頭且長度 > 1? // 防止前導零\n    Yes → // 跳過此長度，因為不合法\n    No  → Step 7: 轉成整數 cur_val = int(cur) // 將子字串轉為數值\n→ Decision: pos == 0? // 第一個數字不需要加運算子\n    Yes → Step 8: dfs(cur, i+1, cur_val, cur_val) // 第一次呼叫，path 為 cur\n    No  → Step 9: dfs(path + '+' + cur, i+1, evaluated + cur_val, cur_val) // 加號\n    No  → Step 10: dfs(path + '-' + cur, i+1, evaluated - cur_val, -cur_val) // 減號\n    No  → Step 11: dfs(path + '*' + cur, i+1, evaluated - multed + multed * cur_val, multed * cur_val) // 乘號，調整先前乘法\n→ Step 12: dfs(num, 0, 0, 0) // 開始遞迴\n→ Step 13: return result // 回傳所有符合的表達式\nEnd // 程式執行結束\n\nBut we need to show each line as separate. Also need to use arrow \"→\" before each step. Use \"Decision:\" with nested lines indent. Use \"Yes →\" and \"No →\". Need to preserve format. Let's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 addOperators(num, target) // 建立入口函式  \n→ Step 2: 初始化空清單 result // 用於儲存符合條件的表達式  \n→ Step 3: 定義遞迴函式 dfs(path, pos, evaluated, multed) // path: 目前表達式；pos: 位置；evaluated: 已計算值；multed: 上一步乘法累積  \n→ Decision: 如果 pos == len(num) ? // 判斷是否已處理完所有數字  \n  Yes → Step 4: 如果 evaluated == target? // 檢查是否達到目標值  \n    Yes → Step 5: result.append(path) // 加入符合條件的表達式  \n    No  → // 不符合，回到上一層遞迴  \n  No  → Step 6: 取子字串 cur = num[pos: i+1] // 從 pos 到 i 的子字串作為目前數字  \n→ Decision: 如果 cur 以 '0' 開頭且長度 > 1? // 防止前導零  \n  Yes → // 跳過此長度，因為不合法  \n  No  → Step 7: 轉成整數 cur_val = int(cur) // 將子字串轉為數值  \n→ Decision: pos == 0? // 第一個數字不需要加運算子  \n  Yes → Step 8: dfs(cur, i+1, cur_val, cur_val) // 第一次呼叫，path 為 cur  \n  No  → Step 9: dfs(path + '+' + cur, i+1, evaluated + cur_val, cur_val) // 加號  \n  No  → Step 10: dfs(path + '-' + cur, i+1, evaluated - cur_val, -cur_val) // 減號  \n  No  → Step 11: dfs(path + '*' + cur, i+1, evaluated - multed + multed * cur_val, multed * cur_val) // 乘號，調整先前乘法  \n→ Step 12: dfs(num, 0, 0, 0) // 開始遞迴  \n→ Step 13: return result // 回傳所有符合的表達式  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def addOperators(self, num, target):\n        res = []\n\n        def backtrack(index, path, value, last):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                # Avoid numbers with leading zeros\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if not num_match or not target_match:\n        return\n\n    num = num_match.group(1)\n    target = int(target_match.group(1))\n\n    solution = Solution()\n    result = solution.addOperators(num, target)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1+2+3\",\"1*2*3\"]",
          "success": true,
          "output": "[\"1+2+3\", \"1*2*3\"]"
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2+3*2\",\"2*3+2\"]",
          "success": true,
          "output": "[\"2+3*2\", \"2*3+2\"]"
        },
        {
          "example_index": 2,
          "input": "num = \"3456237490\", target = 9191",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode167.json",
    "problem_index_in_file": 0,
    "title": "Two Sum II - Input Array Is Sorted",
    "description_snippet": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for two-pointer solution. Use Start, End, Decision. Provide line by line. Need to include explanation after //.\n\nWe need 1-indexed indices output. The array is sorted. Use two pointers left=0, right=n-1. While left<right: sum = numbers[left]+numbers[right]; if sum==target: return [left+1,right+1]; else if sum<target: left++; else right--; End.\n\nWe need to adhere to format: each line: \"虛擬碼步驟 // 解釋\". Use arrow lines.\n\nWe must start with \"Start\" line. Then arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化左指標 left = 0, 右指標 right = numbers.length - 1 // 設定兩端指標\n→ Step 2: 開始迴圈: while left < right // 只要左指標在右指標左側就持續尋找\n    → Decision: 取得 currentSum = numbers[left] + numbers[right] // 計算兩端數值之和\n        Yes → Decision: currentSum == target? // 判斷是否已達目標\n            Yes → Step 3: 回傳 [left + 1, right + 1] // 轉換為 1‑索引並回傳\n            No  → Decision: currentSum < target? // 和小於目標則需增大左端\n                Yes → Step 4: left = left + 1 // 左指標右移\n                No  → Step 5: right = right - 1 // 右指標左移\n→ End // 程式執行結束\n\nNeed to ensure indentation with arrow lines. Use correct format. Provide final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化左指標 left = 0, 右指標 right = numbers.length - 1 // 設定兩端指標  \n→ Step 2: 開始迴圈: while left < right // 只要左指標在右指標左側就持續尋找  \n  → Decision: 取得 currentSum = numbers[left] + numbers[right] // 計算兩端數值之和  \n   Yes → Decision: currentSum == target? // 判斷是否已達目標  \n    Yes → Step 3: 回傳 [left + 1, right + 1] // 轉換為 1‑索引並回傳  \n    No  → Decision: currentSum < target? // 和小於目標則需增大左端  \n     Yes → Step 4: left = left + 1 // 左指標右移  \n     No  → Step 5: right = right - 1 // 右指標左移  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"\n        Two‑pointer solution for sorted array.\n        left starts at the beginning, right at the end.\n        Move the pointers based on the sum compared to target.\n        \"\"\"\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            current_sum = numbers[left] + numbers[right]\n            if current_sum == target:\n                # Return 1‑based indices\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n        # Problem guarantees exactly one solution, so this line is never reached\n        return []\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input string like:\n        numbers = [2,7,11,15], target = 9\n    into a list of numbers and the target integer.\n    \"\"\"\n    # Extract the list assigned to 'numbers'\n    list_match = re.search(r'numbers\\s*=\\s*(\\[[^\\]]*\\])', data)\n    if not list_match:\n        raise ValueError(\"Invalid input: missing numbers list\")\n    numbers_str = list_match.group(1)\n    numbers = eval(numbers_str, {\"__builtins__\": None}, {})  # safe eval for list\n\n    # Extract the target integer\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not target_match:\n        raise ValueError(\"Invalid input: missing target\")\n    target = int(target_match.group(1))\n    return numbers, target\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    numbers, target = parse_input(raw_input)\n    solution = Solution()\n    result = solution.twoSum(numbers, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numbers = [2,7,11,15], target = 9",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        },
        {
          "example_index": 1,
          "input": "numbers = [2,3,4], target = 6",
          "expected_output": "[1,3]",
          "success": true,
          "output": "[1, 3]"
        },
        {
          "example_index": 2,
          "input": "numbers = [-1,0], target = -1",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode981.json",
    "problem_index_in_file": 0,
    "title": "Time Based Key-Value Store",
    "description_snippet": "Design a time-based key-value data structure that can store multiple values for the same key at diff...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Should be structured. It's a design of time-based key-value store. Need to include set and get operations. Implementation details: use dictionary mapping key to list of (timestamp, value) sorted by timestamp. In set: append. In get: binary search for largest timestamp <= given. We'll produce pseudo-code.\n\nEach line: \"虛擬碼步驟 // 解釋\". Use Start, End. Include Decision, loops. Probably show classes and methods.\n\nWe'll produce as requested. Use Chinese commentary. Let's craft steps. Ensure no actual code, only virtual steps. Provide line by line. We'll use arrows. Use \"Start\", \"End\" tags. For set and get inside class.\n\nLet's do:\n\nStart // 開始定義 TimeMap\n→ Step 1: 定義類別 TimeMap // 宣告類別\n→ Step 2: 初始化內部資料結構 map = {} // 每個 key 對應一個時間排序的列表\n→ Decision: ...\nWe will break down methods:\n\n→ Step 3: 方法 set(key, value, timestamp) // 設定值\n→ Step 4: 若 key 不在 map 中，新增空列表 // 初始化列表\n→ Step 5: 將 (timestamp, value) 附加到 map[key] 列表 // 保持升序\n→ End of set\n\n→ Step 6: 方法 get(key, timestamp) // 取值\n→ Decision: 如果 key 不在 map 中？ // 沒有任何值\n    Yes → Step 7: 返回 \"\" // 無結果\n    No → Step 8: 取 list = map[key] // 取得時間列表\n→ Step 9: 若 list 為空？ // 可能不會\n    Yes → Step 10: 返回 \"\"\n    No → Step 11: 執行二分搜尋在 list 中尋找最大 <= timestamp\n→ Step 12: 找到 idx = 位置 // index\n→ Decision: idx 為 -1？ // 所有時間都大於 timestamp\n    Yes → Step 13: 返回 \"\" // 沒有符合\n    No → Step 14: 返回 list[idx].value // 取得對應值\nEnd // 結束\n\nNeed to show binary search pseudo.\n\nStep 11 details:\n\n→ Step 11.1: left = 0, right = list.length - 1 // 定義左右指標\n→ Step 11.2: result = -1 // 初始索引\n→ Step 11.3: while left <= right // 迴圈\n    → Decision: 如果 list[mid].timestamp <= timestamp? // 檢查中點\n        Yes → result = mid // 更新結果\n               left = mid + 1 // 搜尋右半段\n        No  → right = mid - 1 // 搜尋左半段\n→ Step 11.4: return result // 回傳索引\n\nWe'll incorporate into steps.\n\nAlso need to indicate that list is sorted by timestamp. So set can just append.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 TimeMap // 宣告時間鍵值資料結構  \n→ Step 2: 初始化 map = {} // key → 以時間升序排列的 (timestamp, value) 列表  \n→ Step 3: 方法 set(key, value, timestamp) // 存儲操作  \n→ Step 4: 若 key 不在 map 中，則 map[key] = [] // 為新 key 建立列表  \n→ Step 5: 將 (timestamp, value) 附加至 map[key] // 由於時間遞增，列表自動排序  \n→ Step 6: End set // 結束 set 方法  \n→ Step 7: 方法 get(key, timestamp) // 取值操作  \n→ Decision: 若 key 不在 map 中? // 判斷是否存在任何紀錄  \n    Yes → Step 8: 返回 \"\" // 沒有對應值  \n    No → Step 9: list = map[key] // 取得該 key 的時間列表  \n→ Decision: 若 list 為空? // 雖不常見但作為安全檢查  \n    Yes → Step 10: 返回 \"\"  \n    No → Step 11: 執行二分搜尋尋找最大 <= timestamp 的索引  \n    → Step 11.1: left = 0, right = list.length - 1 // 左右指標  \n    → Step 11.2: result = -1 // 初始不存在的索引  \n    → Step 11.3: while left <= right // 迴圈搜尋  \n        → Decision: 若 list[mid].timestamp <= timestamp? // 中點是否符合條件  \n            Yes → result = mid // 更新符合的最大索引  \n                left = mid + 1 // 往右搜尋更大的時間  \n            No  → right = mid - 1 // 往左搜尋更小的時間  \n    → Step 11.4: 返回 result // 傳回找到的索引或 -1  \n→ Decision: result 為 -1? // 所有時間都大於請求時間  \n    Yes → Step 12: 返回 \"\" // 無符合紀錄  \n    No → Step 13: 返回 list[result].value // 取最大合法時間的值  \n→ End get // 結束 get 方法  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\nimport bisect\n\nclass TimeMap:\n    \"\"\"\n    時間鍵值資料結構。\n    內部使用 dict 對 key 對應到一個按時間升序排列的 (timestamp, value) 列表。\n    \"\"\"\n    def __init__(self):\n        self.store = defaultdict(list)\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        \"\"\"將 (timestamp, value) 存入對應 key 的列表，列表已保持時間升序。\"\"\"\n        self.store[key].append((timestamp, value))\n\n    def get(self, key: str, timestamp: int) -> str:\n        \"\"\"\n        回傳在 timestamp 前最近一次設定的值。\n        若無符合條件，回傳空字串。\n        \"\"\"\n        if key not in self.store:\n            return \"\"\n        arr = self.store[key]\n        # bisect_right 找到第一个 > timestamp 的位置，前一個即為最大 <= timestamp\n        idx = bisect.bisect_right(arr, (timestamp, chr(127)))\n        if idx == 0:\n            return \"\"\n        return arr[idx - 1][1]\n\ndef main() -> None:\n    \"\"\"\n    主程式：從 stdin 讀取兩個列表，分別為操作名稱與對應參數，\n    並依序執行 TimeMap 的 set / get / TimeMap 建構。\n    最終結果以 JSON 格式輸出到 stdout。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 把兩個列表包成一個外層列表，方便 ast.literal_eval 解析\n    data = '[' + data + ']'\n    ops, args = ast.literal_eval(data)\n\n    result = []\n    time_map = None\n\n    for op, arg in zip(ops, args):\n        if op == \"TimeMap\":\n            time_map = TimeMap()\n            result.append(None)           # 對應 null\n        elif op == \"set\":\n            time_map.set(*arg)\n            result.append(None)           # 對應 null\n        elif op == \"get\":\n            val = time_map.get(*arg)\n            result.append(val)            # 直接加入字串或空字串\n        else:\n            # 若有其他未知操作，可忽略或拋例外\n            raise ValueError(f\"Unknown operation: {op}\")\n\n    # json.dumps 會將 None 轉成 null，符合題目要求\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"], [[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]",
          "expected_output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]",
          "success": true,
          "output": "[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode31.json",
    "problem_index_in_file": 0,
    "title": "Next Permutation",
    "description_snippet": "A permutation of an array of integers is an arrangement of its members into a sequence or linear ord...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step. Should cover algorithm: find pivot, swap with next greater, reverse suffix. Provide comments. Each line: Virtual step + // explanation.\n\nLet's outline:\n\nStart\n→ Step 1: Find largest index i where nums[i] < nums[i+1]\n→ Decision: if such i exists?\n    Yes → Step 2: Find largest index j > i where nums[j] > nums[i]\n    Yes → Step 3: Swap nums[i] and nums[j]\n    Yes → Step 4: Reverse subarray nums[i+1:] // sort ascending\n    No  → Step 5: Reverse entire array // sort ascending\nEnd\n\nAlso maybe include explanation of why. Provide arrow lines.\n\nNeed to use \"→\" arrow for steps, \"Decision:\" for decisions. Provide each line. Use virtual code: \"Start\", \"End\". Use \"Decision:\" lines with Yes/No branches.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: i ← 找出最大的索引 i 使 nums[i] < nums[i+1] // 找到第一個「升」的地方\n→ Decision: i 是否存在? // 判斷是否有更大的排列可用\n    Yes → Step 2: j ← 找出最大的索引 j > i 使 nums[j] > nums[i] // 找到比 nums[i] 大的最小數字\n        Yes → Step 3: Swap(nums[i], nums[j]) // 將 nums[i] 與更大的數字交換\n        Yes → Step 4: Reverse(nums, i+1, end) // 將 i 之後的子陣列反轉（即升序）\n    No  → Step 5: Reverse(nums, 0, end) // 若無升序，直接將整個陣列反轉成升序\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def nextPermutation(self, nums):\n        \"\"\"\n        Rearranges nums into its next lexicographic permutation in-place.\n        \"\"\"\n        n = len(nums)\n        # Step 1: find the first index i from the right where nums[i] < nums[i+1]\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n\n        if i >= 0:\n            # Step 2: find the smallest number greater than nums[i] to the right\n            j = n - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            # Step 3: swap them\n            nums[i], nums[j] = nums[j], nums[i]\n\n        # Step 4: reverse the subarray after index i to get the smallest suffix\n        left, right = i + 1, n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n\nif __name__ == \"__main__\":\n    # Read the entire stdin input\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Expected format: \"nums = [1,2,3]\"\n    # Split at the first '=' and parse the RHS as a Python list\n    try:\n        _, rhs = data.split('=', 1)\n        nums = ast.literal_eval(rhs.strip())\n    except Exception as e:\n        # If parsing fails, exit silently\n        sys.exit(0)\n\n    # Ensure the input is a list of integers\n    if not isinstance(nums, list):\n        sys.exit(0)\n\n    # Apply the algorithm\n    Solution().nextPermutation(nums)\n\n    # Print the resulting list\n    print(nums)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[1,3,2]",
          "success": true,
          "output": "[1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1]",
          "expected_output": "[1,2,3]",
          "success": true,
          "output": "[1, 2, 3]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,1,5]",
          "expected_output": "[1,5,1]",
          "success": true,
          "output": "[1, 5, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode70.json",
    "problem_index_in_file": 0,
    "title": "Climbing Stairs",
    "description_snippet": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 o...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the staircase problem: number of distinct ways to climb n steps with 1 or 2 steps per move. Classic Fibonacci. We need to output each line as \"虛擬碼步驟 // 解釋\". Must use Start, End, Decision: arrows etc. Also need to include algorithm: maybe iterative DP.\n\nWe'll create steps: Start; Input n; Initialize dp[0]=1, dp[1]=1; Loop i from 2 to n; dp[i] = dp[i-1]+dp[i-2]; After loop output dp[n]; End.\n\nNeed to represent arrays? Use Virtual Code.\n\nAlso maybe handle n=0? But not necessary.\n\nLet's produce lines accordingly.\n\nWe'll produce:\n\nStart // 程式開始執行\n\n→ Input n // 取得樓梯總階數\n\n→ Decision: If n = 0? // 檢查是否無階梯\n\n    Yes → Output 0 // 沒有步數\n\n    No  → Decision: If n = 1? // 若只有一階\n\n        Yes → Output 1 // 只能一步\n\n        No  → Set dp0 = 1 // dp[0] = 1\n\n             Set dp1 = 1 // dp[1] = 1\n\n             → For i = 2 to n: // 迭代計算\n\n                 dp[i] = dp[i-1] + dp[i-2] // 每一步為前兩步之和\n\n             → Output dp[n] // 結果\n\nEnd // 程式結束\n\nBut we need to output each line exactly as \"虛擬碼步驟 // 解釋\". Use arrow etc.\n\nLet's structure as:\n\nStart // 程式開始\n\n→ Input n // 取得樓梯總階數\n\n→ Decision: n == 0? // 若沒有階梯\n\n    Yes → Output 0 // 沒有路徑\n\n    No  → Decision: n == 1? // 若只有一階\n\n        Yes → Output 1 // 只能一步\n\n        No  → Set dp0 = 1 // 初始狀態 dp[0] = 1\n\n             Set dp1 = 1 // 初始狀態 dp[1] = 1\n\n             → For i = 2 to n: // 計算 dp[2] ~ dp[n]\n\n                 dp[i] = dp[i-1] + dp[i-2] // 每個階數的路徑為前兩階之和\n\n             → Output dp[n] // 取得總路徑數\n\nEnd // 程式結束\n\nWe should use arrow for each step: maybe \"→ Step:\" but we can just use arrow. The example uses \"→ Step 1: 輸入...\" but they also used arrow at decision. We can use \"→ Input n\". They didn't show variable names. Let's align with example: \"→ Step 1: 輸入使用者數字\". So use \"→ Step 1: 輸入 n\" etc. Provide description.\n\nBetter to use \"Step\" for each operation. Provide unique Step numbers.\n\nLet's produce:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入 n // 取得樓梯總階數\n\n→ Decision: n == 0? // 檢查是否沒有階梯\n\n    Yes → Step 2: 輸出 0 // 沒有路徑\n\n    No  → Decision: n == 1? // 檢查是否只有一階\n\n        Yes → Step 3: 輸出 1 // 只能一步\n\n        No  → Step 4: 初始化 dp0 = 1 // dp[0] = 1\n\n             Step 5: 初始化 dp1 = 1 // dp[1] = 1\n\n             → For i = 2 到 n: // 循環計算 dp\n\n                 Step 6: 設定 dp[i] = dp[i-1] + dp[i-2] // 每個階數的路徑為前兩階之和\n\n             → Step 7: 輸出 dp[n] // 取得總路徑數\n\nEnd // 程式執行結束\n\nBut need to maintain arrow formatting: Use \"→\" before each step? In example they used \"→ Step 1:\" after Start. For decisions they use \"→ Decision:\" and indent further. For loops we can use \"→\" again. Use \"→\" at each line. So we will write:\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得樓梯總階數\n→ Decision: n == 0? // 檢查是否沒有階梯\n    Yes → Step 2: 輸出 0 // 沒有路徑\n    No  → Decision: n == 1? // 檢查是否只有一階\n        Yes → Step 3: 輸出 1 // 只能一步\n        No  → Step 4: 初始化 dp0 = 1 // dp[0] = 1\n             Step 5: 初始化 dp1 = 1 // dp[1] = 1\n             → For i = 2 到 n: // 循環計算 dp\n                 Step 6: 設定 dp[i] = dp[i-1] + dp[i-2] // 每個階數的路徑為前兩階之和\n             → Step 7: 輸出 dp[n] // 取得總路徑數\nEnd // 程式執行結束\n\nCheck indentation: In example, they used four spaces for nested levels. We'll do similar: indent 4 spaces per nested level. Use spaces before Yes/No arrows.\n\nThus final answer.\n\nEnsure no actual code, only virtual code with explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入 n // 取得樓梯總階數\n→ Decision: n == 0? // 檢查是否沒有階梯\n    Yes → Step 2: 輸出 0 // 沒有路徑\n    No  → Decision: n == 1? // 檢查是否只有一階\n        Yes → Step 3: 輸出 1 // 只能一步\n        No  → Step 4: 初始化 dp0 = 1 // dp[0] = 1\n             Step 5: 初始化 dp1 = 1 // dp[1] = 1\n             → For i = 2 到 n: // 循環計算 dp\n                 Step 6: 設定 dp[i] = dp[i-1] + dp[i-2] // 每個階數的路徑為前兩階之和\n             → Step 7: 輸出 dp[n] // 取得總路徑數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef climb_stairs(n: int) -> int:\n    \"\"\"Return the number of distinct ways to climb n steps\n    when you can take 1 or 2 steps at a time.\"\"\"\n    if n <= 2:\n        return n\n    first, second = 1, 2\n    for _ in range(3, n + 1):\n        first, second = second, first + second\n    return second\n\ndef main() -> None:\n    # 讀取整個輸入，尋找第一個出現的整數\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    n = int(match.group()) if match else 0\n\n    result = climb_stairs(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode372.json",
    "problem_index_in_file": 0,
    "title": "Super Pow",
    "description_snippet": "Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large pos...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code for computing a^b mod 1337, where b is huge given as array of digits. Use binary exponentiation with modulus, but b large array; we need to process exponent digits: compute exponentiation by repeated squaring with exponent given in decimal representation: We can use modular exponentiation by processing each digit: use exponentiation by exponent decomposition: result=1; For each digit d in b array: result = pow(result,10,MOD) * pow(a,d,MOD) % MOD. That's standard. So virtual code will describe steps.\n\nWe need line by line with \"→ Step ...\" etc. Provide explanation comments.\n\nLet's produce:\n\nStart\n\n→ Step 1: Set MOD = 1337 // Modulus\n\n→ Step 2: Input a, bArray // a integer, bArray list of digits\n\n→ Step 3: result = 1 // Initialize result\n\n→ Step 4: For each digit d in bArray // Iterate over exponent digits\n\n→ Decision: Start inner loop? Actually we can just outline:\n\n→ Decision: For each d\n\n    → Step 5: result = pow_mod(result, 10, MOD) // Raise result to 10th power modulo MOD\n\n    → Step 6: temp = pow_mod(a, d, MOD) // Compute a^d modulo MOD\n\n    → Step 7: result = (result * temp) % MOD // Multiply and take modulo\n\nEnd\n\nAlso we need pow_mod virtual step; we can include a function.\n\nLet's define:\n\n→ Step 8: Function pow_mod(x, e, mod) // Fast exponentiation\n\n    → Step 8.1: res = 1\n\n    → Step 8.2: While e > 0\n\n        → Decision: If e % 2 == 1? Yes→ res = (res * x) % mod; No→ skip\n\n        → Step 8.3: x = (x * x) % mod\n\n        → Step 8.4: e = e // 2\n\n    → Step 8.5: Return res\n\nThen we can call this function.\n\nMake sure each line has \"虛擬碼步驟\" then space then \"// 解釋\".\n\nAlso include Start and End.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set MOD = 1337 // 設定模數  \n→ Step 2: Input a, bArray // 取得基數 a 與指數陣列 bArray（每個元素為一位十進制數字）  \n→ Step 3: result = 1 // 初始化結果  \n→ Step 4: For each digit d in bArray // 逐位處理指數  \n    → Decision: 是否處理下一個位?  \n        Yes → Step 5: result = pow_mod(result, 10, MOD) // 把現有結果提升到 10 次方（相當於把指數左移一位）  \n        Yes → Step 6: temp = pow_mod(a, d, MOD) // 計算 a 的 d 次方模 MOD（d 為 0~9）  \n        Yes → Step 7: result = (result * temp) % MOD // 把上述兩部分相乘並取模  \n        No → // 已處理完所有位  \n→ Step 8: Output result // 最終答案  \nEnd // 程式執行結束  \n\n// ---------- pow_mod 函式 ----------\n→ Function pow_mod(x, e, mod) // 快速指數求模  \n    → Step 8.1: res = 1 // 結果累積值  \n    → Step 8.2: While e > 0 // 只要指數不為 0  \n        → Decision: e 與 1 做奇偶判斷  \n            Yes → Step 8.3: res = (res * x) % mod // 若 e 為奇數，乘入目前底數  \n            No  → // 跳過  \n        → Step 8.4: x = (x * x) % mod // 底數平方  \n        → Step 8.5: e = e // 2 // 右移一位，除以 2  \n    → Step 8.6: Return res // 返回計算結果  \n// ---------- pow_mod 函式結束 ----------",
      "generated_code": "import sys\nimport re\n\nMOD = 1337\n\ndef pow_mod(base: int, exp: int, mod: int) -> int:\n    \"\"\"快速指數求模（平方-乘）\"\"\"\n    result = 1\n    base %= mod\n    while exp:\n        if exp & 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exp >>= 1\n    return result\n\ndef super_pow(a: int, b: list[int]) -> int:\n    \"\"\"計算 a^b (b 為十進制數位列表) mod 1337\"\"\"\n    result = 1\n    for digit in b:\n        result = pow_mod(result, 10, MOD)            # result^10 mod MOD\n        result = (result * pow_mod(a, digit, MOD)) % MOD\n    return result\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 從輸入中提取所有整數：第一個為 a，剩餘為 b 的每一位\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    a = nums[0]\n    b = nums[1:]\n    ans = super_pow(a, b)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "a = 2, b = [3]",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "success": true,
          "output": "1024"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode466.json",
    "problem_index_in_file": 0,
    "title": "Count The Repetitions",
    "description_snippet": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor e...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for solving the problem. Problem: Given s1, n1, s2, n2, str1 = s1 repeated n1 times, str2 = s2 repeated n2 times. Find maximum m such that str2 repeated m times can be obtained as a subsequence of str1. Equivalent to find how many times s2 can fit into str1 as subsequence. Standard solution uses greedy matching and cycle detection.\n\nWe need to produce virtual code steps line by line with explanations. No actual code. Use arrows etc.\n\nLet's outline algorithm:\n\n- Initialize variables: index in s1, index in s2, count of s2 occurrences, count of s1 repeats used.\n- While count of s1 repeats < n1:\n    - For each character in s1:\n        - If matches current char of s2, move index in s2 forward\n        - If index in s2 reaches length, increment s2 count, reset index to 0\n    - After finishing s1, increment s1 repeat counter\n    - Record mapping from current s1 repeat to (s2 count, s2 index)\n    - Detect cycle: if current s2 index already seen, then cycle length = current s1 repeats - previous s1 repeats\n        - cycle_s2_count = current s2 count - previous s2 count\n        - remaining s1 repeats = n1 - current s1 repeats\n        - number of cycles = remaining // cycle_length\n        - add cycle_s2_count * number_of_cycles to s2 count\n        - s1 repeats += number_of_cycles * cycle_length\n        - break\n- After loop, compute m = s2 count // n2\n- Return m\n\nSo we need virtual steps.\n\nWe must output line by line with `虛擬碼步驟 // 解釋`. Use arrows. Use Start, End. Use Decision and Yes/No.\n\nLet's produce lines like:\n\nStart // 程式開始\n→ Step 1: 初始化指標 s1_idx = 0, s2_idx = 0 // 位置於 s1 和 s2 的索引\n→ Step 2: 初始化 counter_str1 = 0, counter_s2 = 0 // 用來記錄已使用的 str1 重複數和取得的 s2 數量\n→ Decision: 是否已使用完 n1 次 str1? // 檢查是否已完成所有 str1 重複\n    Yes → End // 程式結束\n    No → Step 3: 逐字遍歷 s1 // 在每一次 str1 重複中逐字檢查\n... etc\n\nWe need cycle detection: store map from s2_idx to (counter_str1, counter_s2) at each completion of a str1.\n\nLet's write accordingly. Use arrows with indentation.\n\nWe must not output actual code; just virtual steps.\n\nLet's create step list.\n\nWe should use lines for mapping detection.\n\nWe must show use of dictionary to store mapping.\n\nUse \"Map\" as placeholder.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 定義 s1_idx ← 0, s2_idx ← 0 // s1 的字元索引, s2 的字元索引  \n→ Step 2: 定義 str1_used ← 0, s2_count ← 0 // 已使用的 str1 重複次數, 取得的 s2 次數  \n→ Step 3: 建立 Map 以存儲 {s2_idx: (str1_used, s2_count)} // 方便後續偵測循環  \n→ Decision: str1_used 是否已等於 n1? // 檢查是否已處理完所有 str1  \n    Yes → End // 結束程序  \n    No → Step 4: 進入內層循環, 遍歷 s1 的每個字元 c  \n→ Decision: c 是否等於 s2[s2_idx]? // 判斷字元是否匹配  \n        Yes → Step 5: s2_idx ← s2_idx + 1 // 匹配成功, 移至 s2 的下一個字元  \n        No  → Step 6: 不做任何改變 // 字元不匹配, 直接跳過  \n→ Decision: s2_idx 是否等於 s2.length? // 判斷是否已完整匹配一個 s2  \n        Yes → Step 7: s2_count ← s2_count + 1 // 完成一個 s2  \n             → Step 8: s2_idx ← 0 // 重置 s2 索引準備下一個 s2  \n        No  → No action // 仍在同一個 s2  \n→ Decision: 是否已遍歷完 s1 的全部字元? // 完成一次 str1 的使用  \n    Yes → Step 9: str1_used ← str1_used + 1 // 以 str1 完成一輪  \n         → Step 10: 檢查 Map 是否已存在 key 為 s2_idx  \n         → Decision: 是否存在?  \n            Yes → Step 11: 取得 prev_str1_used, prev_s2_count ← Map[s2_idx] // 取得上一次相同 s2_idx 的狀態  \n                  → Step 12: 計算 cycle_len ← str1_used - prev_str1_used // 循環長度  \n                  → Step 13: cycle_s2_count ← s2_count - prev_s2_count // 循環中取得的 s2 數量  \n                  → Step 14: 剩餘_str1 ← n1 - str1_used // 還剩多少 str1 可用  \n                  → Step 15: cycles ← 剩餘_str1 // cycle_len // 完整循環數  \n                  → Step 16: s2_count ← s2_count + cycles * cycle_s2_count // 加上所有完整循環的 s2  \n                  → Step 17: str1_used ← str1_used + cycles * cycle_len // 把已經完成的循環加入使用次數  \n                  → Step 18: Break 循環 // 循環計算完成後直接跳出外層  \n            No  → Step 19: Map[s2_idx] ← (str1_used, s2_count) // 記錄目前狀態  \n    No → No action // 尚未完成一次 str1 的使用，繼續內層循環  \n→ Decision: 是否已到達 n1? // 檢查是否已用完所有 str1  \n    Yes → End // 程式結束  \n    No → 回到 Step 4 // 繼續處理下一輪 str1  \n→ Step 20: 計算最大可取得的 str2 次數 m ← s2_count // n2 // 取得 m 次完整的 str2  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if n1 == 0:\n            return 0\n\n        # Counters for how many times we have processed s1 and how many s2 substrings we have matched\n        s1_count = 0          # number of s1 blocks processed\n        s2_count = 0          # number of s2 blocks matched as subsequence\n\n        # Current index in s2 while scanning through s1\n        s2_index = 0\n\n        # Map from current s2_index to (s1_count, s2_count) to detect cycles\n        recall = dict()\n\n        while s1_count < n1:\n            for ch in s1:\n                if ch == s2[s2_index]:\n                    s2_index += 1\n                    if s2_index == len(s2):\n                        s2_index = 0\n                        s2_count += 1\n            s1_count += 1\n\n            # If we have seen this s2_index before, a cycle has been found\n            if s2_index in recall:\n                prev_s1_count, prev_s2_count = recall[s2_index]\n\n                # Number of s1 blocks before the cycle starts\n                pre_loop_s1 = prev_s1_count\n                pre_loop_s2 = prev_s2_count\n\n                # Size of the cycle in terms of s1 blocks and s2 blocks\n                cycle_s1 = s1_count - prev_s1_count\n                cycle_s2 = s2_count - prev_s2_count\n\n                # How many full cycles can we fit in the remaining s1 blocks\n                remaining_s1 = n1 - s1_count\n                full_cycles = remaining_s1 // cycle_s1\n\n                # Add the s2 blocks from the full cycles\n                s2_count += full_cycles * cycle_s2\n                s1_count += full_cycles * cycle_s1\n\n                # Process the leftover s1 blocks after the full cycles\n                rest_s1 = n1 - s1_count\n                rest_s2 = 0\n                idx = s2_index\n                for _ in range(rest_s1):\n                    for ch in s1:\n                        if ch == s2[idx]:\n                            idx += 1\n                            if idx == len(s2):\n                                idx = 0\n                                rest_s2 += 1\n                s2_count += rest_s2\n                break\n            else:\n                # Record the state for this s2_index\n                recall[s2_index] = (s1_count, s2_count)\n\n        # Each s2 block needs n2 repetitions to form one str2\n        return s2_count // n2\n\ndef main():\n    data = sys.stdin.read()\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n\n    if len(lines) == 4:\n        s1 = lines[0]\n        n1 = int(lines[1])\n        s2 = lines[2]\n        n2 = int(lines[3])\n    else:\n        # Try to parse a single line like: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n        strings = re.findall(r'\"([^\"]*)\"', data)\n        nums = re.findall(r'\\d+', data)\n        if len(strings) >= 2 and len(nums) >= 2:\n            s1 = strings[0]\n            n1 = int(nums[0])\n            s2 = strings[1]\n            n2 = int(nums[1])\n        else:\n            # Fallback: split by spaces and assume order s1 n1 s2 n2\n            parts = data.split()\n            s1 = parts[0]\n            n1 = int(parts[1])\n            s2 = parts[2]\n            n2 = int(parts[3])\n\n    solution = Solution()\n    result = solution.getMaxRepetitions(s1, n1, s2, n2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '1'"
        },
        {
          "example_index": 1,
          "input": "s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode526.json",
    "problem_index_in_file": 0,
    "title": "Beautiful Arrangement",
    "description_snippet": "Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps to solve the problem: count number of beautiful arrangements for n. This is a known backtracking / DFS with pruning. We need to produce pseudo code lines with explanations.\n\nWe need to respond in Traditional Chinese.\n\nWe should use Start, End, Decision, Step, etc. Use arrow syntax. Each line: virtual code step + space + // explanation.\n\nWe must not output actual code, just virtual steps. Must be line by line.\n\nWe'll include initial variable definitions, recursion, backtracking, result count.\n\nWe should mention used arrays, used flags, recursion depth index i.\n\nWe'll mention base case when i>n, increment count.\n\nAlso include loop over numbers 1..n, checking divisibility, marking used, recursion, unmark.\n\nLet's produce a clear step-by-step.\n\nLet's start:\n\nStart // 程式開始執行\n→ Step 1: 定義 n // 取得輸入的整數 n\n→ Step 2: 初始化 count = 0 // 用來儲存美麗排列的數量\n→ Step 3: 建立布林陣列 used[1..n]，全部設為 False // 標記數字是否已被使用\n→ Step 4: 呼叫 DFS(1) // 從位置 1 開始遞迴搜尋\n\nDefine DFS(i):\n→ Decision: 如果 i > n? // 檢查是否已排滿所有位置\n    Yes → Step 5: count += 1 // 成功找到一個排列，累加計數\n    No  → Step 6: 循環 num 在 1..n // 依序嘗試每個數字\n        → Decision: 如果 used[num] 為 True? // 已使用過的數字跳過\n            Yes → Step 7: 繼續下一個 num // 跳過重複\n            No  → Step 8: 判斷 (num % i == 0) 或 (i % num == 0) // 檢查美麗條件\n                → Decision: 如果條件成立? // 數字可放在位置 i\n                    Yes → Step 9: used[num] = True // 標記已使用\n                    → Step 10: DFS(i + 1) // 進入下一個位置\n                    → Step 11: used[num] = False // 回溯，恢復狀態\n                    → Step 12: 繼續下一個 num // 之後嘗試其他數字\n                No  → Step 13: 繼續下一個 num // 條件不滿足，跳過\n\nEnd // 程式結束\n\nFinally output count maybe but we don't need actual code. Could add a final step: Return count.\n\nLet's include that.\n\nAdd at End: Return count // 回傳美麗排列的總數\n\nAlso include start and end markers accordingly.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 n // 取得輸入的整數 n  \n→ Step 2: 初始化 count = 0 // 用來儲存美麗排列的數量  \n→ Step 3: 建立布林陣列 used[1..n]，全部設為 False // 標記數字是否已被使用  \n→ Step 4: 呼叫 DFS(1) // 從位置 1 開始遞迴搜尋  \n\n// DFS 函式定義  \n→ Decision: 如果 i > n? // 檢查是否已排滿所有位置  \n Yes → Step 5: count += 1 // 成功找到一個排列，累加計數  \n No  → Step 6: 循環 num 在 1..n // 依序嘗試每個數字  \n  → Decision: 如果 used[num] 為 True? // 已使用過的數字跳過  \n   Yes → Step 7: 繼續下一個 num // 跳過重複  \n   No  → Step 8: 判斷 (num % i == 0) 或 (i % num == 0) // 檢查美麗條件  \n    → Decision: 如果條件成立? // 數字可放在位置 i  \n     Yes → Step 9: used[num] = True // 標記已使用  \n     → Step 10: DFS(i + 1) // 進入下一個位置  \n     → Step 11: used[num] = False // 回溯，恢復狀態  \n     → Step 12: 繼續下一個 num // 嘗試其他數字  \n     No  → Step 13: 繼續下一個 num // 條件不滿足，跳過  \n\nEnd // 程式結束  \n→ Step 14: Return count // 回傳美麗排列的總數",
      "generated_code": "import sys\n\nclass Solution:\n    def countArrangement(self, n: int) -> int:\n        used = [False] * (n + 1)   # used[i] 表示數字 i 是否已被使用\n        count = 0\n\n        def dfs(pos: int) -> None:\n            nonlocal count\n            if pos > n:            # 所有位置都已填完\n                count += 1\n                return\n            for num in range(1, n + 1):\n                if not used[num] and (num % pos == 0 or pos % num == 0):\n                    used[num] = True\n                    dfs(pos + 1)\n                    used[num] = False\n\n        dfs(1)\n        return count\n\ndef main() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    n = int(data[0])\n    result = Solution().countArrangement(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "2",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode324.json",
    "problem_index_in_file": 0,
    "title": "Wiggle Sort II",
    "description_snippet": "Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. The problem: reorder array into wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3]...\n\nWe need to produce a virtual code algorithm. One typical solution: iterate and for each i, if i%2==0, ensure nums[i] < nums[i+1]; if i%2==1, ensure nums[i] > nums[i+1]. Swap accordingly.\n\nWe should produce step-by-step pseudocode lines. Use Start, End, Decision, Step.\n\nLet's create:\n\nStart // program start\n\n→ Step 1: 設定 i = 0 // 初始化索引\n\n→ Decision: i < length-1? // 檢查是否還有下一個元素\n\nYes → Step 2: If i % 2 == 0 then // 偶數索引\n\n→ Decision: nums[i] > nums[i+1]? // 若左大於右需要交換\n\nYes → Step 3: 交換 nums[i] 與 nums[i+1] // 交換使左小於右\n\nNo → No operation // 不需要交換\n\nNo → Step 4: If i % 2 == 1 then // 奇數索引\n\n→ Decision: nums[i] < nums[i+1]? // 若左小於右需要交換\n\nYes → Step 5: 交換 nums[i] 與 nums[i+1] // 交換使左大於右\n\nNo → No operation\n\n→ Step 6: i = i + 1 // 移動到下一對\n\n→ Decision: i < length-1? // 重複\n\nYes → Go back to Step 2\n\nNo → End // 完成\n\nWe should provide explanation after each line. Use arrow → before each line after Start.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i = 0 // 初始化索引指向第一個元素  \n→ Decision: i < len(nums)-1? // 判斷是否還有下一個元素可比對  \n Yes → Step 2: If i % 2 == 0 then // 當索引為偶數時需確保 nums[i] < nums[i+1]  \n  → Decision: nums[i] > nums[i+1]? // 若左邊大於右邊，需交換  \n   Yes → Step 3: swap(nums[i], nums[i+1]) // 交換以滿足 < 條件  \n   No  → No operation // 已符合條件，無需更改  \n No  → Step 4: If i % 2 == 1 then // 當索引為奇數時需確保 nums[i] > nums[i+1]  \n   → Decision: nums[i] < nums[i+1]? // 若左邊小於右邊，需交換  \n    Yes → Step 5: swap(nums[i], nums[i+1]) // 交換以滿足 > 條件  \n    No  → No operation // 已符合條件，無需更改  \n→ Step 6: i = i + 1 // 移動到下一個位置  \n→ Decision: i < len(nums)-1? // 檢查是否還有元素需要處理  \n Yes → 回到 Step 2  \n No  → End // 所有元素已經符合 wiggle 條件，程式結束",
      "generated_code": "import sys\nimport ast\n\ndef wiggleSort(nums):\n    \"\"\"\n    將 nums 重新排列為 0,1,2,3,... 的漸進與降序交替形式\n    先將整個陣列排序，然後將前半段（倒序）放到偶數索引位置，\n    後半段（倒序）放到奇數索引位置即可。\n    \"\"\"\n    nums.sort()\n    n = len(nums)\n    half = (n + 1) // 2          # 前半段的長度（包含中間元素）\n    left = nums[:half][::-1]      # 前半段倒序\n    right = nums[half:][::-1]     # 後半段倒序\n    nums[::2] = left              # 偶數索引位置填左半段\n    nums[1::2] = right            # 奇數索引位置填右半段\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析 nums，執行 wiggleSort，並輸出結果。\n    允許輸入類似 'nums = [1,5,1,1,6,4]' 或純粹 '[1,5,1,1,6,4]' 的格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得第一個 '[' 到最後一個 ']' 的子字串，作為 list 表達式\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        list_str = data[start:end+1]\n    else:\n        # 若沒有方括號，直接嘗試解析整個輸入\n        list_str = data\n\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        # 若解析失敗，輸出錯誤訊息並結束\n        print(\"Invalid input format\")\n        return\n\n    wiggleSort(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "success": true,
          "output": "[1, 6, 1, 5, 1, 4]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "success": true,
          "output": "[2, 3, 1, 3, 1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode32.json",
    "problem_index_in_file": 0,
    "title": "Longest Valid Parentheses",
    "description_snippet": "Given a string containing just the characters '(' and ')', return the length of the longest valid (w...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, using the format. The user wants a virtual code to solve: given string of '(' and ')', return length of longest valid parentheses substring. Classic Leetcode 32. Approach: stack-based or DP. Let's choose stack approach. Steps: initialize stack with -1 index. Iterate over string with index i. If char '(' push index. Else if char ')', pop. If stack empty after pop, push current index. Else compute length = i - stack.top(), update maxLen. Finally return maxLen.\n\nNeed to produce virtual code line by line. Format:\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack 與 maxLen // ...\nBut the format requires \"虛擬碼步驟\" + space + \"// 解釋/說明\". We can name steps as \"Step 1: 初始化 stack 與 maxLen\". Use arrows. Use Decision when needed.\n\nAlso need to use arrows and Decision: lines. Eg:\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack 為 [-1]，maxLen 為 0 // 初始化堆疊與最大長度\n→ Step 2: 從左至右遍歷字串，每個字元 i // 逐一處理字符\n\nInside loop: Decision: 如果 s[i] == '('? Yes -> push, No -> else handle ')'.\n\nWe'll need nested decisions: Decision for '('; inside else, Decision for stack.isEmpty? Actually after popping. Might structure: else part: pop stack. Decision: if stack.empty? Yes → push current index. No → compute length = i - stack.top(); update maxLen.\n\nLet's produce.\n\nNeed End line.\n\nLet's produce each step.\n\nWe'll use \"→\" arrow for each step, but the example shows \"→ Step 1: 輸入使用者數字\". So use \"→\" followed by step description. For Decision lines, use \"→ Decision: 如果...\"\n\nAlso indentation? Example shows indentation inside decisions, but we can keep same style.\n\nWe'll output lines.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: 初始化 stack 為 [-1]，maxLen 為 0 // 初始化堆疊（保留起始索引）和最大長度\n→ Step 2: 從左至右遍歷字串 s，每次取得索引 i 與字元 c // 開始逐字符處理\n    → Decision: 如果 c == '('? // 判斷是開括號\n        Yes → Step 3: 將 i 推入 stack // 將開括號的索引記錄\n        No  → Step 4: // c 為 ')'，處理閉括號\n            → Decision: pop stack // 移除最近的開括號索引\n                Yes? // pop 會失敗時\n                No? // pop 成功時\n            → Decision: stack.isEmpty? // 判斷是否還有未匹配的開括號\n                Yes → Step 5: 將 i 推入 stack // 沒有未匹配的開括號，將當前索引作為新的起始點\n                No  → Step 6: 計算 length = i - stack.top() // 有匹配，計算長度\n                        → Decision: length > maxLen? // 判斷是否更新最大長度\n                            Yes → Step 7: maxLen = length // 更新最大長度\n                            No  → // 不更新\n→ End // 程式執行結束\n\nBut we need to keep each line as \"虛擬碼步驟\" + space + \"//\". We also need to maintain indentation properly. The example uses spaces before Decision. We can follow that style.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 stack 為 [-1]，maxLen 為 0 // 初始化堆疊（保留起始索引）和最大長度  \n→ Step 2: 從左至右遍歷字串 s，每次取得索引 i 與字元 c // 開始逐字符處理  \n → Decision: 如果 c == '('? // 判斷是開括號  \n  Yes → Step 3: 將 i 推入 stack // 將開括號的索引記錄  \n  No  → Step 4: // c 為 ')'，處理閉括號  \n   → Decision: pop stack // 移除最近的開括號索引  \n    Yes → // pop 失敗，表示沒有開括號，直接跳過  \n    No  → // pop 成功，繼續檢查堆疊  \n   → Decision: stack.isEmpty? // 判斷是否還有未匹配的開括號  \n    Yes → Step 5: 將 i 推入 stack // 沒有未匹配的開括號，將當前索引作為新的起始點  \n    No  → Step 6: 計算 length = i - stack.top() // 有匹配，計算長度  \n     → Decision: length > maxLen? // 判斷是否更新最大長度  \n      Yes → Step 7: maxLen = length // 更新最大長度  \n      No  → // 不更新  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        \"\"\"\n        Find the length of the longest valid (well-formed) parentheses substring.\n        Uses a stack to track indices of unmatched '(' characters and the\n        position just before the current valid segment.\n        \"\"\"\n        stack = [-1]          # Initialize stack with -1 to handle base case\n        max_len = 0\n\n        for i, char in enumerate(s):\n            if char == '(':\n                # Push index of '(' onto the stack\n                stack.append(i)\n            else:  # char == ')'\n                # Pop the last unmatched '(' index\n                if stack:\n                    stack.pop()\n                # If stack becomes empty, push current index as a new base\n                if not stack:\n                    stack.append(i)\n                else:\n                    # Compute length of current valid substring\n                    current_len = i - stack[-1]\n                    if current_len > max_len:\n                        max_len = current_len\n        return max_len\n\n\ndef main():\n    \"\"\"\n    Read input from stdin, extract the parentheses string,\n    compute the longest valid parentheses substring length,\n    and print the result to stdout.\n    \"\"\"\n    data = sys.stdin.read()\n    # Find the first contiguous sequence of '(' and ')' characters\n    match = re.search(r'[\\(\\)]+', data)\n    s = match.group() if match else ''\n    solution = Solution()\n    result = solution.longestValidParentheses(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"(()\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \")()())\"",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "s = \"\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode399.json",
    "problem_index_in_file": 0,
    "title": "Evaluate Division",
    "description_snippet": "You are given an array of variable pairs equations and an array of real numbers values, where equati...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving equation evaluation problem. Should provide step-by-step approach: Build graph, perform DFS/BFS for each query, compute product of ratios. Steps: Build adjacency map with weight. For each query, if variables exist, DFS search. If path found, compute product; else -1.0.\n\nWe need to produce in lines, each line: 虛擬碼步驟 [space] // 解釋. Use arrows, Start, End, Decision: etc. Provide multiple lines.\n\nLet's design pseudo:\n\nStart\n→ Build adjacency map: For each equation Ai/Bi=val, add edge Ai->Bi with weight val, Bi->Ai with weight 1/val\n→ For each query (C,D):\n    Decision: C and D in graph? If No → add result -1.0\n    Yes → If C==D → result 1.0\n    Else:\n        Decision: Path from C to D? Perform DFS/BFS to find product.\n        If path exists → result product\n        Else → result -1.0\n→ Output results array\nEnd\n\nNeed to detail DFS steps: Use stack/recursion.\n\nLet's produce steps with decisions and arrows.\n\nRemember to include indentation with arrow lines: \"→\" before each step. Use Decision: with Yes →, No →.\n\nLet's craft.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ BuildAdjacencyMap // 建立圖表，將每個方程式轉換為雙向邊  \n    → For each equation [A, B] with value v:  \n        → AddEdge A → B with weight v // Ai / Bi = v  \n        → AddEdge B → A with weight 1/v // 反向比例  \n→ PrepareResultsArray // 初始化用於存放查詢答案的結果陣列  \n→ For each query [C, D] in queries:  \n    → Decision: 是否 C 與 D 都存在於圖中?  \n        Yes → Decision: C == D?  \n            Yes → AppendResult 1.0 // 相同變量，比例為 1  \n            No  → Decision: 是否存在從 C 到 D 的路徑?  \n                Yes → BeginDFS(C, D) // 執行深度優先搜尋以求得乘積  \n                    → DFS(C, currentProduct):  \n                        → Mark C 為已訪問  \n                        → For each neighbor N of C with edge weight w:  \n                            → Decision: N 已訪問?  \n                                No → Recursively DFS(N, currentProduct * w)  \n                    → 回傳累積乘積作為答案  \n                No  → AppendResult -1.0 // 無法連通，答案未定  \n        No  → AppendResult -1.0 // 變量未定義，答案未定  \n→ OutputResultsArray // 將所有答案輸出回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        # 建立圖表：每個節點相鄰節點及其比值\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1.0 / val\n\n        # 深度優先搜尋，計算 src 到 dst 的乘積\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor in visited:\n                    continue\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n            return -1.0\n\n        results = []\n        for u, v in queries:\n            results.append(dfs(u, v, set()))\n        return results\n\ndef main():\n    # 讀取整個輸入，使用 exec 將其轉成變數\n    data = sys.stdin.read()\n    # 為了安全起見，清理掉可能的行首/行尾空白\n    data = data.strip()\n    # 執行代碼，將 equations、values、queries 變成全局變數\n    exec(data, globals())\n\n    sol = Solution()\n    answers = sol.calcEquation(equations, values, queries)\n\n    # 依據題目要求輸出 5 位小數，並以字串形式列出\n    out = '[' + ','.join(f'{x:.5f}' for x in answers) + ']'\n    print(out)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpuf3sn3pc.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpuf3sn3pc.py\", line 38, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpkjy1giw5.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmpkjy1giw5.py\", line 38, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmprdsf00sn.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmprdsf00sn.py\", line 38, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode481.json",
    "problem_index_in_file": 0,
    "title": "Magical String",
    "description_snippet": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magi...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code to compute number of 1s in first n numbers of magical string s. We need algorithm: generate magical string up to n length, count ones. Approach: similar to LeetCode 375 Magical String. We'll use list of ints, build gradually. Keep pointer idx for reading from string, val for next value (1 or 2). Count ones.\n\nWe need to output each step line with explanation. Use virtual code style: Start, Decision, Step etc. We'll produce a high-level algorithm.\n\nLet's outline:\n\nStart\n→ Step 1: Initialize array s with [1,2,2] // base of magical string\n→ Step 2: Set count1 = 1 // number of ones so far\n→ Step 3: Set index i = 2 // pointer to read how many times to append next value\n→ Step 4: Set nextValue = 1 // next value to append (since last value appended was 2)\n→ Decision: while length of s < n\n    → Step 5: repeat s[i] times:\n        → Step 6: append nextValue to s\n        → Decision: if nextValue == 1: increment count1\n        → End repeat\n    → Step 7: toggle nextValue (1→2, 2→1)\n    → Step 8: increment i\nEnd\n→ Step 9: return count1 // number of ones in first n elements\n\nBut we need to incorporate that n can be 1 etc. Need initial count. Count1 start 1 because first element is 1.\n\nAlso we need to account when we generate beyond n; we might not need to generate all, but just count until length reaches n. In loop, we can append min(s[i], n-len(s)) times, to avoid overgeneration. Also break after reaching n.\n\nLet's produce virtual steps:\n\nStart // 開始執行\n→ Step 1: s = [1,2,2] // 初始化魔法字串前3個數\n→ Step 2: count1 = 1 // 已經出現的 1 的個數\n→ Step 3: i = 2 // 指向 s 的索引，用於決定接下來要附加多少個相同數字\n→ Step 4: nextVal = 1 // 下一個要附加的數字 (因為 s 的最後一個數是 2)\n→ Decision: s.length < n? // 需要再產生更多數字嗎？\n    Yes → Step 5: repeatCnt = s[i] // 從 s 讀取要重複的次數\n    → Decision: repeatCnt > (n - s.length)? // 若剩餘空間不足\n        Yes → repeatCnt = n - s.length // 只產生必要個數\n        No →\n    → Step 6: for k from 1 to repeatCnt\n        → Step 7: append nextVal to s // 將 nextVal 加到字串尾部\n        → Decision: nextVal == 1? // 是否是 1\n            Yes → count1 = count1 + 1 // 1 的個數累加\n            No → // do nothing\n    → Step 8: nextVal = (nextVal == 1 ? 2 : 1) // 切換下一個要附加的數字\n    → Step 9: i = i + 1 // 移動索引到下一個決策位置\n    → Decision: s.length < n? // 是否還要繼續\n        Yes → jump to Step 5\n        No →\nEnd // 所有需要的數字已產生\n→ Step 10: return count1 // 回傳前 n 個數中 1 的個數\n\nWe need to maintain the virtual code format exactly: each line `虛擬碼步驟 // 解釋`. Use arrows and decisions.\n\nLet's format with proper indentation maybe but not required. Use `→ Decision:` lines.\n\nWe must include `[空格]` between step and comment.\n\nLet's write:\n\nStart // 程式開始執行\n\n→ Step 1: s = [1,2,2] // 初始化魔法字串的前三個元素\n\n→ Step 2: count1 = 1 // 計算目前已出現的 1 的個數\n\n→ Step 3: i = 2 // 指向 s 的索引，用於決定接下來要重複多少次\n\n→ Step 4: nextVal = 1 // 下一個將被附加到 s 的數字（因為最後一個元素是 2）\n\n→ Decision: s.length < n? // 需要再產生更多數字嗎？\n\n    Yes → Step 5: repeatCnt = s[i] // 從 s 讀取需要重複的次數\n\n    → Decision: repeatCnt > (n - s.length)? // 若剩餘長度不足\n\n        Yes → repeatCnt = n - s.length // 只產生必要個數\n\n        No → // 仍然使用原始 repeatCnt\n\n    → Step 6: for k = 1 to repeatCnt\n\n        → Step 7: append nextVal to s // 把 nextVal 加到字串尾部\n\n        → Decision: nextVal == 1? // 是 1 的話更新計數\n\n            Yes → count1 = count1 + 1\n\n            No →\n\n    → Step 8: nextVal = (nextVal == 1 ? 2 : 1) // 切換下一個要附加的數字\n\n    → Step 9: i = i + 1 // 移動索引到下一個位置\n\n    → Decision: s.length < n? // 仍需繼續產生嗎？\n\n        Yes → jump to Step 5\n\n        No → // 進入 End\n\nEnd // 所有需要的數字已生成\n\n→ Step 10: return count1 // 回傳前 n 個數中 1 的個數\n\nNeed to ensure each line has `//` comment. Also use arrow indent properly but maintain each line.\n\nLet's craft final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: s = [1,2,2] // 初始化魔法字串的前三個元素\n→ Step 2: count1 = 1 // 計算目前已出現的 1 的個數\n→ Step 3: i = 2 // 指向 s 的索引，用於決定接下來要重複多少次\n→ Step 4: nextVal = 1 // 下一個將被附加到 s 的數字（因為最後一個元素是 2）\n→ Decision: s.length < n? // 需要再產生更多數字嗎？\n    Yes → Step 5: repeatCnt = s[i] // 從 s 讀取需要重複的次數\n    → Decision: repeatCnt > (n - s.length)? // 若剩餘長度不足\n        Yes → repeatCnt = n - s.length // 只產生必要個數\n        No → // 仍然使用原始 repeatCnt\n    → Step 6: for k = 1 to repeatCnt\n        → Step 7: append nextVal to s // 把 nextVal 加到字串尾部\n        → Decision: nextVal == 1? // 是 1 的話更新計數\n            Yes → count1 = count1 + 1\n            No →\n    → Step 8: nextVal = (nextVal == 1 ? 2 : 1) // 切換下一個要附加的數字\n    → Step 9: i = i + 1 // 移動索引到下一個位置\n    → Decision: s.length < n? // 仍需繼續產生嗎？\n        Yes → jump to Step 5\n        No → // 進入 End\nEnd // 所有需要的數字已生成\n→ Step 10: return count1 // 回傳前 n 個數中 1 的個數\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def magicalString(self, n: int) -> int:\n        \"\"\"\n        Return the number of 1's in the first n numbers of the magical string.\n        \"\"\"\n        if n == 0:\n            return 0\n        if n <= 3:\n            # The first three numbers are 1, 2, 2 → only one '1'\n            return 1\n\n        s = [1, 2, 2]        # 初始字符串\n        head = 2             # 用於決定接下來要重複多少次\n        num = 1              # 下一個將要添加的數字（1 或 2）\n        while len(s) < n:\n            # 根據 head 位置的數字，重複 num 的次數並擴展字符串\n            s.extend([num] * s[head])\n            # 交替 1 與 2，xor 3 可以達到此效果\n            num ^= 3\n            head += 1\n        # 計算前 n 個數中 '1' 的個數\n        return s[:n].count(1)\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, compute the answer, and print it to stdout.\n    Input can be any string containing an integer, e.g. 'n = 6'.\n    \"\"\"\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n\n    solution = Solution()\n    result = solution.magicalString(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode200.json",
    "problem_index_in_file": 0,
    "title": "Number of Islands",
    "description_snippet": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for counting islands in a 2D grid. We need to output line by line, with arrow and explanation. Use Start, End, Decision. Use arrow '→'. Format like sample. Should be a virtual algorithm, not actual code. Steps: iterate through grid, when find '1', increment count, do DFS/BFS to mark visited (turn to '0'). Use stack or recursion. Provide each step line. Probably need steps: Start, iterate i, iterate j, decision if grid[i][j]=='1', Yes -> increment count, call DFS, else continue. DFS: stack, while stack not empty, pop, if out of bounds or grid[x][y]=='0', continue, else set to '0', push neighbors. At end, End.\n\nWe'll produce each line with explanation. Use \"Start\" and \"End\". Use \"→\". Use \"Decision:\" lines.\n\nWe must produce \"虛擬碼步驟\" + space + comment.\n\nLet's create steps:\n\n1. Start\n2. → Initialize islands = 0\n3. → For each row i from 0 to m-1\n4. →   For each column j from 0 to n-1\n5. →     Decision: grid[i][j] == '1'? // check if land\n6. →       Yes → islands = islands + 1 // found new island\n7. →          → Call DFS(i, j) // flood fill to mark visited\n8. →     No → continue\n9. → End loops\n10. → Return islands\n11. End\n\nDFS steps need separate lines. Maybe define as separate subroutine:\n\nDFS(x, y):\nStart\n→ Initialize stack with (x, y)\n→ While stack not empty\n→   Pop (cx, cy)\n→   Decision: cx<0 or cx>=m or cy<0 or cy>=n? // out of bounds\n→     Yes → continue\n→   Decision: grid[cx][cy] != '1'? // already visited or water\n→     Yes → continue\n→   → grid[cx][cy] = '0' // mark visited\n→   → Push neighbors (cx+1,cy),(cx-1,cy),(cx,cy+1),(cx,cy-1)\n→ End\n\nWe need to embed DFS inside main steps? Use \"Call DFS(i, j)\". But the virtual code should include the DFS body? The requirement is \"逐行地產生對應的虛擬碼\". It may include the DFS function as separate steps. So we should include it.\n\nLet's produce full virtual code:\n\nStart\n→ Initialize islands = 0\n→ For i from 0 to m-1\n→   For j from 0 to n-1\n→     Decision: grid[i][j] == '1'?\n→       Yes → islands = islands + 1\n→          → Call DFS(i, j)\n→     No  → Continue\n→ End For\n→ End For\n→ Return islands\nEnd\n\nThen define DFS:\n\nDFS(x, y)\nStart\n→ Initialize stack with (x, y)\n→ While stack not empty\n→   Pop (cx, cy)\n→   Decision: cx < 0 or cx >= m or cy < 0 or cy >= n?\n→     Yes → Continue\n→   Decision: grid[cx][cy] != '1'?\n→     Yes → Continue\n→   → grid[cx][cy] = '0'\n→   → Push (cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)\n→ End While\nEnd\n\nBut we must ensure each line has \"虛擬碼步驟\" and comment. Also \"→\" at start of each step except Start, End? According to sample, Start line has no arrow; subsequent lines start with \"→\". For decisions, use \"Decision:\" lines, with indent. Use \"Yes →\" and \"No →\".\n\nWe need to format decisions properly with indentation. Use spaces indent for nested lines.\n\nWe need to ensure each line is separate. Provide full virtual code with all steps. Use indentation to reflect nested loops, decisions. For loops, can use \"For i from 0 to m-1\" as a step. Inside loops, indent next lines.\n\nLet's craft:\n\nStart // 程式開始執行\n→ islands = 0 // 初始化島嶼計數\n→ For i from 0 to m-1 // 遍歷每一行\n→   For j from 0 to n-1 // 遍歷每一列\n→     Decision: grid[i][j] == '1' // 判斷當前格子是否為陸地\n→       Yes → islands = islands + 1 // 新島嶼發現，計數加一\n→          → Call DFS(i, j) // 以此格子為起點，塗除整個島嶼\n→     No  → Continue // 若為水，跳過\n→   End For // 列遍歷結束\n→ End For // 行遍歷結束\n→ Return islands // 回傳總島嶼數\nEnd // 程式結束\n\nThen DFS:\n\nDFS(x, y)\nStart // DFS 子程式開始\n→ stack = [(x, y)] // 初始化棧\n→ While stack not empty // 只要有未處理格子\n→   (cx, cy) = stack.pop() // 取出一個格子\n→   Decision: cx < 0 or cx >= m or cy < 0 or cy >= n // 是否越界\n→     Yes → Continue // 越界則跳過\n→   Decision: grid[cx][cy] != '1' // 已經訪問或為水\n→     Yes → Continue // 跳過\n→   → grid[cx][cy] = '0' // 標記為已訪問\n→   → stack.push((cx+1, cy)) // 推入相鄰格子\n→   → stack.push((cx-1, cy))\n→   → stack.push((cx, cy+1))\n→   → stack.push((cx, cy-1))\n→ End While\nEnd // DFS 子程式結束\n\nBut we must ensure each line has arrow \"→\". For subroutine start, maybe \"DFS(x, y)\" line with no arrow? The sample uses \"Decision:\" but not function definition. But we can treat \"DFS(x, y)\" as a step without arrow? Let's just follow similar: \"DFS(x, y) // DFS 子程式開始\". Then \"→\" lines inside.\n\nNeed to keep each line as separate, no merging. Let's produce.\n\nLet's format decisions with indentation and \"Yes →\" and \"No →\". For DFS while loop, use \"While stack not empty\" line.\n\nAlso the \"Continue\" can be \"Continue\" but sample uses \"Continue\" not \"跳過\". Provide explanation.\n\nWe should maintain consistency: Use English for steps? The requirement: \"虛擬碼步驟\" + comment. The steps can be in Chinese. We'll write steps in Chinese, as user uses Chinese. Let's use Chinese for steps: \"初始化 islands = 0\" etc. Use \"For i from 0 to m-1\" but can use Chinese: \"對 i 從 0 到 m-1 循環\". But sample uses English. However we can keep Chinese but still understandable. Let's keep Chinese with English variable names: \"i\", \"j\". For readability, we'll use \"i\" and \"j\" but in Chinese context.\n\nWe'll produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ islands = 0 // 初始化島嶼計數\n→ For i from 0 to m-1 // 逐行遍歷\n→   For j from 0 to n-1 // 逐列遍歷\n→     Decision: grid[i][j] == '1' // 判斷當前格子是否為陸地\n→       Yes → islands = islands + 1 // 發現新島嶼，計數加一\n→          → Call DFS(i, j) // 以此格子為起點，遞迴塗除整座島嶼\n→     No  → Continue // 若為水，直接跳過\n→   End For // 列結束\n→ End For // 行結束\n→ Return islands // 回傳島嶼總數\nEnd // 程式結束\n\nDFS(x, y)\nStart // DFS 子程式開始\n→ stack = [(x, y)] // 初始化棧，存入起點\n→ While stack not empty // 只要棧內還有格子\n→   (cx, cy) = stack.pop() // 取出一個格子\n→   Decision: cx < 0 or cx >= m or cy < 0 or cy >= n // 是否越界\n→     Yes → Continue // 越界則跳過\n→   Decision: grid[cx][cy] != '1' // 已訪問或為水\n→     Yes → Continue // 跳過\n→   → grid[cx][cy] = '0' // 標記為已訪問\n→   → stack.push((cx+1, cy)) // 推入上下左右四個相鄰格子\n→   → stack.push((cx-1, cy))\n→   → stack.push((cx, cy+1))\n→   → stack.push((cx, cy-1))\n→ End While // 迴圈結束\nEnd // DFS 子程式結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        visited = [[False] * n for _ in range(m)]\n\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n:\n                return\n            if grid[i][j] == '0' or visited[i][j]:\n                return\n            visited[i][j] = True\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    count += 1\n        return count\n\nif __name__ == \"__main__\":\n    # Read entire input\n    raw_input = sys.stdin.read().strip()\n    # Remove possible leading 'grid = '\n    if raw_input.startswith(\"grid =\"):\n        raw_input = raw_input[len(\"grid =\"):].strip()\n    # Evaluate the list literal safely\n    try:\n        grid = ast.literal_eval(raw_input)\n    except Exception as e:\n        print(\"0\")\n        sys.exit(0)\n    # Compute and output the number of islands\n    result = Solution().numIslands(grid)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode215.json",
    "problem_index_in_file": 0,
    "title": "Kth Largest Element in an Array",
    "description_snippet": "Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Need to solve the problem: find k-th largest element without sorting. Use min-heap of size k. Steps: initialize min-heap. Iterate through nums, push element, if size > k pop smallest. At end, root is kth largest. Provide steps. Must use virtual code with arrows, decisions. Provide each line with explanation. No actual code. Use Start, End. Provide steps like \"→ Step 1: Initialize min-heap of capacity k\". Use Decision when checking heap size > k. Also handle edge cases: array empty? but input guarantees? We can skip. Provide full algorithm. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立大小為 k 的最小堆（min‑heap） // 用於儲存目前最小的 k 個元素  \n→ Step 2: 對於陣列 nums 中的每個元素 val 進行循環  \n  → Decision: 堆大小是否小於 k? // 判斷堆是否還未達到 k 個元素  \n   Yes → Step 3: 將 val 插入堆中 // 直接加入，因堆未滿  \n   No → Step 4: 插入 val 並立即移除堆頂最小值 // 以維持堆大小為 k，保留較大元素  \n→ Step 5: 循環結束後，堆頂元素即為第 k 大元素 // 因為堆中只剩下最大的 k 個元素  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport heapq\n\ndef kth_largest(nums, k):\n    \"\"\"\n    找出陣列 nums 中第 k 大的元素\n    使用大小為 k 的最小堆（min‑heap）來維持目前最大的 k 個元素\n    \"\"\"\n    # 前 k 個元素初始化堆\n    heap = nums[:k]\n    heapq.heapify(heap)\n\n    # 從第 k 個元素開始處理\n    for num in nums[k:]:\n        # 若新元素比堆頂小，則直接跳過\n        if num > heap[0]:\n            heapq.heappop(heap)      # 移除最小的元素\n            heapq.heappush(heap, num)  # 插入新的較大元素\n\n    # 堆頂即為第 k 大元素\n    return heap[0]\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析格式為:\n        nums = [a,b,c,...], k = n\n    然後輸出第 k 大元素\n    \"\"\"\n    data = sys.stdin.read().strip()\n\n    # 解析 nums 列表\n    nums_match = re.search(r'nums\\s*=\\s*\\[([^\\]]*)\\]', data)\n    nums = []\n    if nums_match:\n        nums_str = nums_match.group(1)\n        if nums_str.strip():\n            nums = [int(x.strip()) for x in nums_str.split(',')]\n\n    # 解析 k 值\n    k_match = re.search(r'k\\s*=\\s*(-?\\d+)', data)\n    k = int(k_match.group(1)) if k_match else 0\n\n    # 計算結果並輸出\n    result = kth_largest(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1,5,6,4], k = 2",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode318.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product of Word Lengths",
    "description_snippet": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step by step, each line with virtual code and explanation comment.\n\nWe need to cover algorithm: iterate words, for each word compute bitmask of letters. Then for each pair compute if bitmask & other == 0. Keep max product.\n\nWe need to produce start, steps, decision branches. Also loops. Use arrows and indent.\n\nWe'll produce pseudocode: Start; Step 1: Initialize max_product=0; Step 2: For each word1 in words: compute mask1; length1; Step 3: For each word2 after word1: compute mask2; length2; Step 4: Decision: if mask1 & mask2 ==0? Yes -> compute product length1*length2; update max; No -> skip. End loops. End.\n\nAlso include mapping of bitmask building: Step 2a: Build mask by iterating characters. We'll show step building mask. Let's write pseudo.\n\nEnsure each line: `虛擬碼步驟 // 解釋`.\n\nUse arrow `→` for steps.\n\nAlso decision lines with indentation.\n\nOk. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: max_product ← 0 // 初始化最大乘積為 0  \n→ Step 2: masks ← 空清單 // 用於儲存每個單字的字母位元掩碼  \n→ Step 3: For each word in words: // 逐個處理每個單字  \n    → Step 3a: mask ← 0 // 為目前單字建立位元掩碼  \n    → Step 3b: For each character ch in word: // 計算單字中出現的字母  \n         → Step 3b1: bit ← 1 << (ord(ch) - ord('a')) // 取得字母對應的位元  \n         → Step 3b2: mask ← mask OR bit // 把位元加入掩碼  \n    → Step 3c: Append (word, mask, len(word)) to masks // 保存單字、掩碼和長度  \n→ Step 4: For i from 0 to len(masks)-2: // 遍歷所有單字對  \n    → Step 4a: (word1, mask1, len1) ← masks[i]  \n    → Step 4b: For j from i+1 to len(masks)-1: // 與後面的單字配對  \n         → Step 4b1: (word2, mask2, len2) ← masks[j]  \n         → Decision: (mask1 AND mask2) == 0? // 檢查兩個單字是否共有字母  \n           Yes → Step 4b2: product ← len1 * len2 // 計算長度乘積  \n             → Step 4b3: If product > max_product?  \n               Yes → max_product ← product // 更新最大值  \n               No  → // 產品不大於已知最大值，無需更新  \n            No  → // 兩單字共有字母，跳過  \n→ End // 程式執行結束（max_product 已為答案）",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef max_product(words):\n    \"\"\"\n    找出兩個不含共有字母的單字長度乘積的最大值。\n    如果不存在符合條件的兩個單字，回傳 0。\n    \"\"\"\n    n = len(words)\n    masks = [0] * n\n    # 建立每個單字對應的 26 個字母位元掩碼\n    for i, word in enumerate(words):\n        mask = 0\n        for ch in word:\n            mask |= 1 << (ord(ch) - ord('a'))\n        masks[i] = mask\n\n    max_prod = 0\n    # 逐對比較\n    for i in range(n):\n        for j in range(i + 1, n):\n            if masks[i] & masks[j] == 0:          # 沒有共同字母\n                prod = len(words[i]) * len(words[j])\n                if prod > max_prod:\n                    max_prod = prod\n    return max_prod\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n\n    words = []\n    # 先嘗試解析類似 \"words = [ ... ]\" 或直接是 Python list\n    try:\n        # 移除可能的前置文字，如 \"words = \"\n        if data.lower().startswith(\"words\"):\n            _, rest = data.split(\"=\", 1)\n            words = ast.literal_eval(rest.strip())\n        else:\n            words = ast.literal_eval(data)\n    except Exception:\n        # 若 literal_eval 失敗，則用正則找出所有字串\n        words = re.findall(r'\"([^\"]*)\"', data)\n        if not words:  # 也試試單引號\n            words = re.findall(r'\\'([^\\']*)\\'', data)\n\n    # 確保取得的是字串清單\n    if not isinstance(words, list):\n        words = []\n\n    result = max_product(words)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        },
        {
          "example_index": 1,
          "input": "words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode66.json",
    "problem_index_in_file": 0,
    "title": "Plus One",
    "description_snippet": "You are given a large integer represented as an integer array digits, where each digits[i] is the it...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code with explanation, line by line, following format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide algorithm: iterate from last digit, add 1, handle carry. If carry at most significant, prepend 1.\n\nWe need to produce code steps like: Start → Step 1: Initialize index = len(digits)-1 // get last index. → Step 2: Set carry = 1 // we add one. → Decision: While index>=0 and carry==1? Then process. Actually we can loop: while index>=0 and carry==1: new_digit = digits[index]+carry; if new_digit==10: digits[index]=0; carry=1; else: digits[index]=new_digit; carry=0; index--. Then after loop: Decision: If carry==1? Prepend 1. Return digits. End.\n\nWe should incorporate decisions and arrows. Use indentation? The example shows indentation of branches.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: index ← length(digits) - 1 // 取得最後一位索引\n→ Step 2: carry ← 1 // 需要加一\n→ Decision: 是否仍有位數且 carry==1? // 判斷是否需要繼續處理\n    Yes → Step 3: new_digit ← digits[index] + carry // 目前位加進位\n    Yes → Decision: new_digit==10? // 判斷是否產生進位\n        Yes → Step 4: digits[index] ← 0 // 將位設為0\n        Yes → Step 5: carry ← 1 // 進位仍為1\n        No  → Step 6: digits[index] ← new_digit // 正常填入\n        No  → Step 7: carry ← 0 // 無進位\n    Yes → Step 8: index ← index - 1 // 移動到前一位\n    Yes → (loop back to Decision) \n    No  → Decision: carry==1? // 處理最後進位\n        Yes → Step 9: prepend 1 to digits // 在最前面插入1\n        No  → Step 10: // 不需要進位\nEnd // 程式結束\n\nWe need to maintain proper formatting of branches. The example uses indentation inside Decision: block with Yes → ... No → ... But the arrow after each step.\n\nWe need to ensure that we output as per requirement: each line must contain \"虛擬碼步驟\" then a space then \"// 解釋\". So we need to write each step with arrow and explanation. Use \"Start\", \"End\". For decisions, we should put \"Decision: ...\" and then indentation for branches. Each branch line starts with arrow like \"Yes → Step 3: ... //\".\n\nWe must include the steps: 1, 2, etc. Use Step names. Provide decisions for while loop.\n\nThe algorithm: Use while loop. In pseudo code: while index >=0 and carry==1: compute new_digit. After loop, if carry==1, prepend 1.\n\nLet's produce final answer accordingly. Ensure each line has arrow and comment. Use no actual code but virtual code. Let's craft.\n\nNote: Must be in Traditional Chinese. We'll explain each step. Use arrows → and Yes →, No →.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: index ← length(digits) - 1 // 取得最後一位數字的索引  \n→ Step 2: carry ← 1 // 需要先把 1 加進去  \n→ Decision: index ≥ 0 且 carry == 1? // 判斷是否還有位數可處理且進位尚未結束  \n  Yes → Step 3: new_digit ← digits[index] + carry // 把目前位加上進位  \n  Yes → Decision: new_digit == 10? // 檢查是否產生進位  \n    Yes → Step 4: digits[index] ← 0 // 進位產生，該位設為 0  \n    Yes → Step 5: carry ← 1 // 進位仍為 1  \n    No  → Step 6: digits[index] ← new_digit // 正常寫入新位數  \n    No  → Step 7: carry ← 0 // 無進位，結束加法  \n  Yes → Step 8: index ← index - 1 // 移動到前一位  \n  Yes → (重複 Decision) // 迴圈回到 Decision 重新檢查  \n  No  → Decision: carry == 1? // 處理最前面仍有進位的情況  \n    Yes → Step 9: prepend 1 to digits // 在最前面插入 1  \n    No  → Step 10: // 無進位，直接結束  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        Increment the large integer represented by digits by one.\n        :param digits: List[int]\n        :return: List[int]\n        \"\"\"\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        # All digits were 9, so we need an extra leading 1\n        return [1] + digits\n\ndef parse_digits(input_str):\n    \"\"\"\n    Extract a list of integers from a string like 'digits = [1,2,3]'.\n    \"\"\"\n    # Find the first '[' and the last ']'\n    start = input_str.find('[')\n    end = input_str.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        raise ValueError(\"Invalid input format\")\n    list_str = input_str[start:end+1]\n    return ast.literal_eval(list_str)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    try:\n        digits = parse_digits(data)\n    except Exception as e:\n        print(f\"Error parsing input: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    sol = Solution()\n    result = sol.plusOne(digits)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "digits = [1,2,3]",
          "expected_output": "[1,2,4]",
          "success": true,
          "output": "[1, 2, 4]"
        },
        {
          "example_index": 1,
          "input": "digits = [4,3,2,1]",
          "expected_output": "[4,3,2,2]",
          "success": true,
          "output": "[4, 3, 2, 2]"
        },
        {
          "example_index": 2,
          "input": "digits = [9]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode472.json",
    "problem_index_in_file": 0,
    "title": "Concatenated Words",
    "description_snippet": "Given an array of strings words (without duplicates), return all the concatenated words in the given...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code lines step by step for algorithm: given array of words (no duplicates), return all concatenated words in list. We need to describe algorithm: build trie or use DP. Probably use DP with set. Steps: sort words by length ascending. For each word, check if can be segmented into two or more words using DP with dictionary of previous words. Use set for known words. For each word, dynamic programming over splits; if segmentable, add to result and to set. Provide pseudo-code lines with arrow syntax.\n\nWe need to output each line: \"Start // 程式開始執行\" etc.\n\nLet's create steps:\n\nStart\n→ Step 1: Sort words by length ascending // 確保短字先處理\n→ Step 2: 初始化已知單詞集合 wordSet ← empty // 用於檢查子字串\n→ Step 3: 初始化結果列表 result ← empty // 存儲連接詞\n→ Decision: 遍歷每個 word in words // 處理每個字串\n    Yes → Step 4: 若 word 可以被拆分為至少兩個已知單詞? // 判斷是否為連接詞\n        Yes → Step 5: result.add(word) // 將連接詞加入結果\n        No  → 無\n    Yes → Step 6: wordSet.add(word) // 把所有字加入已知集合\n→ End\n\nWe need to detail the DP check function:\n\nStep 4: 需要使用動態規劃判斷. We'll break into substeps.\n\nWe can define a subroutine:\n\nDecision: 若 word 可以被拆分? \n    Yes -> add to result\n    No -> nothing\nBut we need pseudo-code inside decision to check.\n\nSimpler: \"Decision: 判斷 word 是否為連接詞 (使用 DP)\" then we can break DP steps:\n\n→ Step 4a: 建立布林陣列 dp[0..len] 初始化 dp[0]=true // dp[i] 表示前 i 個字符可拆分\n→ Step 4b: for i from 1 to len\n        for j from 0 to i-1\n            if dp[j] and substring(i,j) in wordSet\n                dp[i]=true; break\n→ Step 4c: 若 dp[len] 且 word 中至少拆分一次 (i.e., len>0?) // Actually need at least two words; we need count splits. But dp alone may accept the whole word as itself if wordSet already contains it. Since we process sorted ascending, wordSet doesn't contain current word yet. So dp[len] will only be true if constructed from previous shorter words. So that ensures at least two words. Good.\n\nSo algorithm good.\n\nNow produce pseudo-code lines accordingly. Use arrow arrow.\n\nMake sure each line ends with // explanation.\n\nAlso need to use Decision: etc. For loops, we can use Step: loop, but use arrow.\n\nLet's craft.\n\nPseudo-code lines:\n\nStart // 程式開始執行\n→ Step 1: Sort words by length ascending // 讓短字先加入集合，方便拆分\n→ Step 2: Initialize wordSet ← {} // 已知可用的字串集合\n→ Step 3: Initialize result ← [] // 儲存所有連接詞\n→ Decision: For each word in words // 逐一檢查每個字串\n    Yes → Step 4: Initialize dp[0..len(word)] ← false // dp 表示前 i 個字符是否可拆分\n        → dp[0] ← true // 空字串總是可拆分\n    → Decision: For i from 1 to len(word) // 遍歷字串長度\n        Yes → Decision: For j from 0 to i-1 // 嘗試所有分割點\n            Yes → Decision: If dp[j] AND substring(word, j, i) ∈ wordSet\n                Yes → Step 5: dp[i] ← true; Break inner loop // 找到合法拆分\n    → Decision: If dp[len(word)] = true // 整個字串可拆分為短字\n        Yes → Step 6: result.add(word) // 加入結果\n    → Step 7: wordSet.add(word) // 將目前字加入可用集合\n→ End // 程式執行結束\n\nNeed to maintain proper indentation and arrow for loops. Maybe use \"Decision:\" for loops? The example uses \"Decision:\" for if. For loops we can use \"Step:\" but it's okay.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort words by length ascending // 先把短字放前面，確保拆分時已知單詞已加入集合  \n→ Step 2: Initialize wordSet ← {} // 已知可用的字串集合  \n→ Step 3: Initialize result ← [] // 儲存所有連接詞  \n→ Decision: For each word in words // 逐一檢查每個字串  \n    Yes → Step 4: Initialize dp[0..len(word)] ← false // dp[i] 表示前 i 個字是否能拆分  \n        → dp[0] ← true // 空字串總是可拆分  \n    → Decision: For i from 1 to len(word) // 遍歷字串長度  \n        Yes → Decision: For j from 0 to i-1 // 嘗試所有分割點  \n            Yes → Decision: If dp[j] AND substring(word, j, i) ∈ wordSet  \n                Yes → Step 5: dp[i] ← true; Break inner loop // 找到合法拆分，結束內層循環  \n    → Decision: If dp[len(word)] = true // 整個字串可拆分成至少兩個短字  \n        Yes → Step 6: result.add(word) // 加入結果列表  \n    → Step 7: wordSet.add(word) // 將目前字加入已知集合，供後續字使用  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findAllConcatenatedWordsInADict(self, words):\n        # 將單詞按長度升序排序，短字先處理\n        words.sort(key=len)\n        word_set = set()          # 已知可拆分的單詞集合\n        result = []               # 存放所有連接詞\n\n        for word in words:\n            if not word:\n                continue\n\n            # 動態規劃檢查 word 是否能拆分成兩個或兩個以上已知單詞\n            dp = [False] * (len(word) + 1)\n            dp[0] = True  # 空字串總是可拆分\n\n            for i in range(1, len(word) + 1):\n                for j in range(i):\n                    if dp[j] and word[j:i] in word_set:\n                        dp[i] = True\n                        break\n\n            if dp[len(word)]:\n                result.append(word)\n\n            # 把目前單詞加入已知集合，供後續單詞使用\n            word_set.add(word)\n\n        return result\n\ndef parse_input(text):\n    \"\"\"\n    將輸入文字解析為 words 列表。\n    允許輸入類似 'words = [\"cat\",\"cats\",...]' 的格式。\n    \"\"\"\n    text = text.strip()\n    if not text:\n        return []\n\n    # 如果是 'words = [...]' 形式，取等號右側\n    if '=' in text:\n        _, rhs = text.split('=', 1)\n        rhs = rhs.strip()\n    else:\n        rhs = text\n\n    # 使用 literal_eval 解析為 Python 物件\n    return ast.literal_eval(rhs)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    raw_input = sys.stdin.read()\n    words = parse_input(raw_input)\n\n    sol = Solution()\n    concatenated_words = sol.findAllConcatenatedWordsInADict(words)\n\n    # 輸出結果列表\n    print(concatenated_words)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
          "expected_output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nGot (Norm):      '[\"dogcatsdog\",\"catsdogcats\",\"ratcatdogcat\"]'\n--- (Raw) ---\nRaw Expected: '[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]'\nRaw Got:      \"['dogcatsdog', 'catsdogcats', 'ratcatdogcat']\""
        },
        {
          "example_index": 1,
          "input": "words = [\"cat\",\"dog\",\"catdog\"]",
          "expected_output": "[\"catdog\"]",
          "success": true,
          "output": "['catdog']"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode341.json",
    "problem_index_in_file": 0,
    "title": "Flatten Nested List Iterator",
    "description_snippet": "You are given a nested list of integers nestedList. Each element is either an integer or a list whos...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing NestedIterator, flatten nested list, with next() and hasNext().\n\nWe need to use structure: Start, Step, Decision, End. Use arrows, etc. Provide a line per step. Each line: virtual code step + space + // explanation.\n\nWe need to present algorithm: use stack to store iterators of lists. Flatten by pushing nested list onto stack when encountering nested. For next, pop and get next integer. For hasNext, check stack and look ahead to find next integer.\n\nLet's produce pseudocode.\n\nWe must not output actual code, just virtual code steps. Each line ends with // explanation.\n\nWe need to be mindful of line numbering? Not necessary.\n\nWill produce steps:\n\nStart\n→ Step 1: Initialize stack with iterator over nestedList // Push initial list iterator onto stack\n→ Step 2: Define variable nextInt // To store next integer when available\n→ Decision: hasNext? // Check if stack not empty\n    Yes → Step 3: While top iterator has next element\n        → Decision: element is integer?\n            Yes → Step 4: Set nextInt to element; break loop\n            No  → Step 5: Push iterator of element's list onto stack; continue loop\n        → Decision: top iterator exhausted?\n            Yes → Step 6: Pop stack; continue hasNext loop\n    No  → Step 7: Return false // No more integers\n→ End\n\nBut we also need next() method.\n\nWe could separate algorithm into two functions: hasNext() and next().\n\nWe need to show usage:\n\nDefine class NestedIterator\n    Constructor(nestedList)\n    Method hasNext()\n    Method next()\n\nBut we need to present as pseudocode steps sequentially.\n\nProbably produce:\n\nStart\n→ Step 1: Create class NestedIterator\n    → Step 1.1: Constructor(nestedList) → push iterator onto stack\n    → Step 1.2: Method hasNext() → logic above\n    → Step 1.3: Method next() → return nextInt and advance pointer\nEnd\n\nBut each line must be virtual code step with explanation. So each step line includes \"→\" arrow and \"Step ...\" etc. We can combine into multiple lines.\n\nWe need to be clear. Use indentation to show nested steps, as in example.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NestedIterator // 建立迭代器類別\n    → Step 1.1: Constructor(nestedList) // 接收嵌套列表\n        → Step 1.1.1: stack ← 新增迭代器(nestedList) // 將整個列表推進堆疊\n    → Step 1.2: Method hasNext() // 判斷是否還有整數可取\n        → Decision: stack 为空? // 若堆疊空則沒有更多元素\n            No  → Step 1.2.1: While stack 不是空\n                → Decision: stack.top().hasNext()? // 仍有未遍歷的元素\n                    Yes → Step 1.2.1.1: current ← stack.top().next() // 取下一個元素\n                        → Decision: current 是 整數? // 檢查是否為整數\n                            Yes → Step 1.2.1.1.1: nextInt ← current // 存儲下一個可返回的整數\n                                → Decision: 已找到下一个? // 尋找完畢，返回 true\n                                    Yes → Step 1.2.1.1.1.1: Return true // 有下一個整數\n                            No  → Step 1.2.1.1.2: stack.push(迭代器(current)) // 推進子列表\n                        → Step 1.2.1.1.3: 重新執行 While 循環 // 重新檢查下一個元素\n                    No  → Step 1.2.1.2: stack.pop() // 子列表已遍歷完畢，移除\n            Yes → Step 1.2.2: Return false // 沒有更多整數\n    → Step 1.3: Method next() // 取得下一個整數\n        → Step 1.3.1: temp ← nextInt // 取得存儲的整數\n        → Step 1.3.2: nextInt ← null // 清除緩存\n        → Step 1.3.3: Return temp // 返回值\nEnd // 程式結束\n\nBut need each line to include \"虛擬碼步驟\" and explanation. Should we put the indentation as arrow? Yes.\n\nWe need to use arrow '→' for each line. For decisions, we also need to show 'Yes →' and 'No →' as per spec. The example uses \"Decision:\" with nested Yes/No.\n\nThus, we need to format accordingly.\n\nWe can format:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 NestedIterator // 建立迭代器類別\n    → Step 1.1: Constructor(nestedList) // 接收嵌套列表\n        → Step 1.1.1: stack ← new Stack() // 初始化堆疊\n        → Step 1.1.2: stack.push(Iterator(nestedList)) // 將整個列表的迭代器推進堆疊\n    → Step 1.2: Method hasNext() // 判斷是否還有整數可取\n        → Decision: stack.isEmpty()? // 檢查堆疊是否為空\n            Yes → Step 1.2.1: Return false // 沒有更多整數\n            No  → Step 1.2.2: While true // 進入尋找循環\n                → Decision: stack.peek().hasNext()? // 頂層迭代器是否還有下一個\n                    Yes → Step 1.2.2.1: element ← stack.peek().next() // 取下一個元素\n                        → Decision: element.isInteger()? // 判斷是否為整數\n                            Yes → Step 1.2.2.1.1: nextInt ← element.getInteger() // 儲存\n                                → Step 1.2.2.1.1.1: Return true // 找到整數，返回 true\n                            No  → Step 1.2.2.1.2: stack.push(Iterator(element.getList())) // 推進子列表\n                        → Step 1.2.2.1.3: Continue // 重新檢查\n                    No  → Step 1.2.2.2: stack.pop() // 迭代器已完畢，移除\n                → Step 1.2.2.3: Continue // 重複循環\n    → Step 1.3: Method next() // 取得下一個整數\n        → Step 1.3.1: temp ← nextInt // 取得存儲的整數\n        → Step 1.3.2: nextInt ← null // 清除緩存\n        → Step 1.3.3: Return temp // 返回整數\nEnd // 程式結束\n\nBut we need to keep each line separate. Indentation may be with spaces; we can use arrows for each line. The Decision block uses Yes →, No →.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義類別 NestedIterator // 建立迭代器類別\n    → Step 1.1: Constructor(nestedList) // 接收嵌套列表\n        → Step 1.1.1: stack ← 新 Stack() // 初始化堆疊\n        → Step 1.1.2: stack.push(Iterator(nestedList)) // 將整個列表的迭代器推進堆疊\n    → Step 1.2: Method hasNext() // 判斷是否還有整數可取\n        → Decision: stack.isEmpty()? // 檢查堆疊是否為空\n            Yes → Step 1.2.1: Return false // 沒有更多整數\n            No  → Step 1.2.2: While true // 進入尋找循環\n                → Decision: stack.peek().hasNext()? // 頂層迭代器是否還有下一個\n                    Yes → Step 1.2.2.1: element ← stack.peek().next() // 取下一個元素\n                        → Decision: element.isInteger()? // 判斷是否為整數\n                            Yes → Step 1.2.2.1.1: nextInt ← element.getInteger() // 儲存整數\n                                → Step 1.2.2.1.1.1: Return true // 找到整數，返回 true\n                            No  → Step 1.2.2.1.2: stack.push(Iterator(element.getList())) // 推進子列表\n                        → Step 1.2.2.1.3: Continue // 重新檢查\n                    No  → Step 1.2.2.2: stack.pop() // 迭代器已完畢，移除\n                → Step 1.2.2.3: Continue // 重複循環\n    → Step 1.3: Method next() // 取得下一個整數\n        → Step 1.3.1: temp ← nextInt // 取得存儲的整數\n        → Step 1.3.2: nextInt ← null // 清除緩存\n        → Step 1.3.3: Return temp // 返回整數\nEnd // 程式結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass NestedIterator:\n    def __init__(self, nestedList):\n        \"\"\"將嵌套列表展平成一維列表，並初始化索引。\"\"\"\n        self.flat = []\n        self._flatten(nestedList)\n        self.idx = 0\n\n    def _flatten(self, lst):\n        \"\"\"遞迴展開所有整數。\"\"\"\n        for el in lst:\n            if isinstance(el, int):\n                self.flat.append(el)\n            else:\n                self._flatten(el)\n\n    def next(self):\n        \"\"\"返回下一個整數。\"\"\"\n        if not self.hasNext():\n            raise StopIteration\n        val = self.flat[self.idx]\n        self.idx += 1\n        return val\n\n    def hasNext(self):\n        \"\"\"判斷是否還有未取出的整數。\"\"\"\n        return self.idx < len(self.flat)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 支援兩種輸入格式：nestedList = [...]\n    if data.lower().startswith(\"nestedlist\"):\n        _, _, expr = data.partition(\"=\")\n        expr = expr.strip()\n    else:\n        expr = data\n    try:\n        nestedList = ast.literal_eval(expr)\n    except Exception:\n        # 若解析失敗，直接終止\n        sys.exit()\n\n    iterator = NestedIterator(nestedList)\n    res = []\n    while iterator.hasNext():\n        res.append(iterator.next())\n\n    # 輸出符合範例的格式（無空格）\n    print(\"[\" + \",\".join(map(str, res)) + \"]\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nestedList = [[1,1],2,[1,1]]",
          "expected_output": "[1,1,2,1,1]",
          "success": true,
          "output": "[1,1,2,1,1]"
        },
        {
          "example_index": 1,
          "input": "nestedList = [1,[4,[6]]]",
          "expected_output": "[1,4,6]",
          "success": true,
          "output": "[1,4,6]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode485.json",
    "problem_index_in_file": 0,
    "title": "Max Consecutive Ones",
    "description_snippet": "Given a binary array nums, return the maximum number of consecutive 1's in the array....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanation for the requirement: Given binary array nums, return maximum number of consecutive 1's. It's a simple problem. Need to produce virtual code lines: Start, variables initialization, loop, counters, max, decision branches. Provide explanation after each line. Use arrow →, Decision etc. Ensure each line has \"虛擬碼步驟 // 解釋/說明\". Need to not output actual code. Just steps.\n\nLet's craft steps:\n\nStart // program starts\n→ Step 1: 初始化 maxCount = 0, currentCount = 0 // 设初始最大和当前计数\n→ Step 2: 遍历数组 nums // 遍历每个元素\n    Decision: 当前元素等于 1? // 检查是否是 1\n        Yes → Step 3: currentCount += 1 // 当前计数加一\n        No  → Step 4: maxCount = max(maxCount, currentCount) // 更新最大计数\n              → Step 5: currentCount = 0 // 重置当前计数\n→ Step 6: 循环结束后, 更新一次 maxCount = max(maxCount, currentCount) // 处理数组结尾的 1\n→ Step 7: 返回 maxCount // 输出结果\nEnd // 程序结束\n\nMake sure each line is separate, use arrows. Also need to use virtual code arrow formatting. Provide lines accordingly. Each line should have explanation. Let's do it.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxCount = 0, currentCount = 0 // 設定最大連續 1 數與目前連續 1 數的初始值  \n→ Step 2: 遍歷 nums 的每一個元素 // 開始逐個檢查陣列中的值  \n    Decision: 如果元素 == 1? // 判斷目前元素是否為 1  \n        Yes → Step 3: currentCount += 1 // 連續 1 數增加  \n        No  → Step 4: maxCount = max(maxCount, currentCount) // 更新最大值  \n              → Step 5: currentCount = 0 // 連續計數重置  \n→ Step 6: 循環結束後再次更新 maxCount = max(maxCount, currentCount) // 處理最後一段可能的 1  \n→ Step 7: 返回 maxCount // 輸出結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums):\n        max_count = 0\n        count = 0\n        for num in nums:\n            if num == 1:\n                count += 1\n                max_count = max(max_count, count)\n            else:\n                count = 0\n        return max_count\n\ndef parse_input(data: str):\n    \"\"\"從輸入字串中解析出整數列表。\"\"\"\n    data = data.strip()\n    # 先嘗試直接使用 ast.literal_eval（適用於純列表輸入）\n    try:\n        return ast.literal_eval(data)\n    except Exception:\n        pass\n    # 如果輸入類似 \"nums = [1,2,3]\"，提取中括號內的內容\n    match = re.search(r'\\[(.*?)\\]', data)\n    if match:\n        nums_str = match.group(1)\n        if nums_str.strip() == '':\n            return []\n        return [int(x.strip()) for x in nums_str.split(',')]\n    # 失敗則回傳空列表\n    return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    result = Solution().findMaxConsecutiveOnes(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,0,1,1,1]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,0,1,1,0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode453.json",
    "problem_index_in_file": 0,
    "title": "Minimum Moves to Equal Array Elements",
    "description_snippet": "Given an integer array nums of size n, return the minimum number of moves required to make all array...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for the problem: given array nums, min moves to make all equal by incrementing n-1 elements by 1. Equivalent to decrement one element by 1. Standard solution: moves = sum(nums) - n * min(nums). Provide virtual code steps. The user wants \"逐行\" code. We should output each line with virtual code and explanation. Use Start, End, Decision, etc. We'll produce algorithm steps: Start, Step: read array, Step: find min, Step: compute sum, Step: compute moves, Step: output moves, End. Also could include decision? Maybe no decisions. But we can include Decision for empty array? Not needed. Provide explanation.\n\nMake sure to follow format: each line \"虛擬碼步驟 // 解釋/說明\".\n\nAlso must use arrow syntax: \"→ Step: ...\" etc. But format example: \"Start // 程式開始執行\" etc. So we should do:\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums // 取得輸入的數列\n→ Step 2: 計算陣列長度 n // 取得元素個數\n→ Step 3: 找到陣列最小值 minVal // 找出最小元素\n→ Step 4: 計算所有元素之和 totalSum // 求數列總和\n→ Step 5: 計算最小移動次數 moves = totalSum - n * minVal // 公式\n→ Step 6: 輸出 moves // 顯示結果\nEnd // 程式結束\n\nWe might also include Decision if n==0? Not necessary.\n\nWe should use virtual code arrow? The example uses \"→ Step 1: ...\" lines. So we should match that.\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 nums // 取得輸入的數列\n→ Step 2: 計算陣列長度 n // 取得元素個數\n→ Step 3: 找到陣列中最小值 minVal // 找出最小元素\n→ Step 4: 計算所有元素之和 totalSum // 求數列總和\n→ Step 5: 計算最小移動次數 moves = totalSum - n * minVal // 根據公式得到最小步數\n→ Step 6: 輸出 moves // 顯示結果\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def minMoves(self, nums):\n        \"\"\"Return the minimum number of moves to make all array elements equal.\"\"\"\n        return sum(nums) - min(nums) * len(nums)\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list expression after '=' if present\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        expr = expr.strip()\n    else:\n        expr = data\n\n    # Safely evaluate the list expression\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        print(\"0\")\n        return\n\n    # Compute and print the result\n    solution = Solution()\n    print(solution.minMoves(nums))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode225.json",
    "problem_index_in_file": 0,
    "title": "Implement Stack using Queues",
    "description_snippet": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should suppo...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, with explanations. The task: implement a LIFO stack using only two queues. Need operations push, pop, top, empty. We should present steps for each method. Use only queue operations: enqueue to back, dequeue from front, peek front, size, isEmpty. Provide steps for each method in pseudo-code. Use arrow syntax and Decision etc. Need to output for each method? We can structure as:\n\nStart MyStack // class initialization\n→ Step 1: 初始化 queue1, queue2 // create two queues\n→ Decision: ?\n\nThen methods:\n\npush(x):\n→ Step: 將 x 放入 queue1 // since queue1 used as active queue\n...\n\npop():\n→ Step: 如果 queue1 為空? // return null or error\n→ Decision: 如果 queue1 只剩一個元素? // then dequeue and return\n→ Else: Transfer all except last to queue2, then dequeue last, then swap queues, return.\n\ntop():\nsimilar but after retrieving last element, push it back to queue2 and swap.\n\nempty():\n→ Return queue1 is empty.\n\nWe need to output line by line virtual code for entire class? Probably produce steps for class init and each method. Provide explanation after each line. Use arrow '→'. For decision lines use indent with Yes → and No →. Provide comments.\n\nWe must not output actual code, only virtual steps.\n\nOk. Let's create.\n\nStart // MyStack class initialization\n→ Step 1: queue1 ← new Queue // 用來存放元素\n→ Step 2: queue2 ← new Queue // 佔位用\n\nNow push(x):\nStart push\n→ Step 1: Enqueue x into queue1 // 把新元素放到 queue1 的尾部\nEnd push\n\npop():\nStart pop\n→ Decision: queue1 is empty? // 檢查是否為空\n    Yes → Return null // 無元素可 pop\n    No  → Decision: queue1 size == 1? // 只剩一個元素\n        Yes → result ← Dequeue from queue1 // 直接取出\n            → Return result\n        No  → // 需要把最後一個元素留到 queue2\n            → Step 1: While queue1 size > 1:\n                → Dequeue from queue1 → Enqueue into queue2 // 移動前面的元素\n            → result ← Dequeue from queue1 // 取出最後一個\n            → Step 2: Swap queue1 and queue2 // 讓 queue1 成為新的主隊列\n            → Return result\nEnd pop\n\ntop():\nStart top\n→ Decision: queue1 is empty? // 檢查是否為空\n    Yes → Return null\n    No  → Decision: queue1 size == 1? // 只剩一個元素\n        Yes → result ← Peek front of queue1 // 取得但不移除\n            → Return result\n        No  → // 同 pop 但保留元素\n            → Step 1: While queue1 size > 1:\n                → Dequeue from queue1 → Enqueue into queue2\n            → result ← Dequeue from queue1 // 取出最後一個\n            → Enqueue result into queue2 // 把它放回去\n            → Step 2: Swap queue1 and queue2\n            → Return result\nEnd top\n\nempty():\nStart empty\n→ Return queue1 is empty // 判斷是否為空\nEnd empty\n\nEnd // MyStack class end\n\nBut format requires \"Start\", \"End\" etc. For each method, maybe use \"Start push\" and \"End push\". They didn't specify exactly but we can.\n\nUse indentation: lines for decision: e.g.\n\n→ Decision: queue1 is empty? // ...\n    Yes → Return null // ...\n    No  → Decision: queue1 size == 1? // ...\n        Yes → ...\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n\n...done thinking.\n\nStart // MyStack 類別初始化\n→ Step 1: queue1 ← new Queue // 主隊列，用於儲存所有元素\n→ Step 2: queue2 ← new Queue // 辅助隊列，用於在 pop / top 時暫存元素\n\nStart push // push 方法\n→ Step 1: Enqueue x into queue1 // 把新元素放入主隊列的尾部\nEnd push\n\nStart pop // pop 方法\n→ Decision: queue1 is empty? // 判斷是否還有元素可彈出\n    Yes → Return null // 空堆疊時返回空值\n    No  → Decision: queue1 size == 1? // 只剩一個元素時直接彈出\n        Yes → result ← Dequeue from queue1 // 取出並移除\n            → Return result // 返回彈出的值\n        No  → // 需要將最後一個元素保留，其他全部移到 queue2\n            → Step 1: While queue1 size > 1:\n                → Dequeue from queue1 → Enqueue into queue2 // 把前面的元素轉移\n            → result ← Dequeue from queue1 // 取出最後一個元素\n            → Step 2: Swap queue1 and queue2 // 重新將 queue2 成為主隊列\n            → Return result // 返回彈出的值\nEnd pop\n\nStart top // top 方法\n→ Decision: queue1 is empty? // 判斷是否有元素可取\n    Yes → Return null // 空堆疊時返回空值\n    No  → Decision: queue1 size == 1? // 只剩一個元素時直接查看\n        Yes → result ← Peek front of queue1 // 取得但不移除\n            → Return result // 返回頂部值\n        No  → // 需要將最後一個元素保留並再次放回\n            → Step 1: While queue1 size > 1:\n                → Dequeue from queue1 → Enqueue into queue2 // 把前面的元素轉移\n            → result ← Dequeue from queue1 // 取出最後一個元素\n            → Enqueue result into queue2 // 把它放回去\n            → Step 2: Swap queue1 and queue2 // 重新將 queue2 成為主隊列\n            → Return result // 返回頂部值\nEnd top\n\nStart empty // empty 方法\n→ Return queue1 is empty // 判斷主隊列是否為空\nEnd empty\n\nEnd // MyStack 類別結束",
      "generated_code": "import sys\nimport json\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"LIFO stack implemented with two FIFO queues.\"\"\"\n\n    def __init__(self):\n        self.q1 = deque()  # 主隊列，保持堆疊頂部在前端\n        self.q2 = deque()  # 佔位隊列\n\n    def push(self, x):\n        \"\"\"將元素 x 推入堆疊頂部。\"\"\"\n        self.q2.append(x)               # 先把新元素放入輔助隊列\n        while self.q1:                  # 把主隊列中的所有元素移到輔助隊列\n            self.q2.append(self.q1.popleft())\n        self.q1, self.q2 = self.q2, self.q1  # 交換，完成 push\n\n    def pop(self):\n        \"\"\"移除並返回堆疊頂部元素。\"\"\"\n        if not self.q1:\n            return None\n        return self.q1.popleft()\n\n    def top(self):\n        \"\"\"返回堆疊頂部元素但不移除。\"\"\"\n        if not self.q1:\n            return None\n        return self.q1[0]\n\n    def empty(self):\n        \"\"\"若堆疊為空返回 True，否則 False。\"\"\"\n        return not self.q1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 去掉可能的 \"Input\" 前綴\n    if data.startswith('Input'):\n        data = data[len('Input'):].strip()\n    # 轉成合法的 JSON 字串，兩個列表以 '], [' 分隔\n    data = data.replace('\\n', ' ').replace('\\r', ' ')\n    data = data.replace('], [', '],[')\n    data = '[' + data + ']'\n    try:\n        ops, args = json.loads(data)\n    except json.JSONDecodeError:\n        # 若解析失敗，直接退出\n        return\n\n    results = [None]  # 建構子呼叫的結果為 null\n    stack = MyStack()\n    for op, arg in zip(ops[1:], args[1:]):  # 第一個 op 是 \"MyStack\" 已處理\n        if op == 'push':\n            stack.push(arg[0] if arg else None)\n            results.append(None)\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n        else:\n            # 任何未知操作忽略\n            pass\n\n    # 將結果轉成期望的輸出格式\n    out_strs = []\n    for val in results:\n        if val is None:\n            out_strs.append('null')\n        elif isinstance(val, bool):\n            out_strs.append('true' if val else 'false')\n        else:\n            out_strs.append(str(val))\n    print('[' + ', '.join(out_strs) + ']')\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "success": true,
          "output": "[null, null, null, 2, 2, false]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode279.json",
    "problem_index_in_file": 0,
    "title": "Perfect Squares",
    "description_snippet": "Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect squa...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the algorithm: given n, find least number of perfect squares that sum to n. Classic problem: using BFS or DP or number theory (Lagrange's four-square theorem). Implementation typical: DP where dp[i] = min(dp[i - j*j] + 1). We should provide step-by-step virtual code.\n\nWe need to output line by line with virtual code steps and explanation comments. Use arrow, Start, End, Decision.\n\nWe must not output actual code, only virtual steps.\n\nWe need to show algorithm: input n, initialize array dp[0..n] with large number, dp[0]=0. For i from 1 to n: for j from 1 to floor(sqrt(i)): dp[i] = min(dp[i], dp[i - j*j] + 1). Output dp[n].\n\nWe'll produce virtual steps accordingly. We need to be clear that loops are represented. Use \"→ For i from 1 to n\" and inner loop.\n\nAlso decision on whether dp[i] > candidate? So \"Decision: If candidate < dp[i]?\" etc.\n\nLet's produce. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 輸入整數 n // 從使用者取得要拆解的數字\n→ Step 2: 建立 dp 陣列長度 n+1，並設所有值為無限大 // 用來記錄最少的平方數個數\n→ Step 3: 設定 dp[0] = 0 // 零可以由 0 個平方數得到\n→ Step 4: For i = 1 到 n // 逐個計算每個數字所需的最少平方數\n    → Step 5: 設定 minVal = 無限大 // 暫存目前 i 的最小值\n    → Step 6: For j = 1 到 floor(sqrt(i)) // 嘗試所有平方數 j*j\n        → Step 7: 計算 candidate = dp[i - j*j] + 1 // 使用 j*j 加上一個平方數的組合\n        → Decision: 如果 candidate < minVal? // 判斷是否為目前最小\n            Yes → Step 8: 設定 minVal = candidate // 更新最小值\n            No  → Step 8: 省略 // 保持原值\n    → Step 9: 設定 dp[i] = minVal // 存入最小組合數\n→ Step 10: 輸出 dp[n] // 回傳答案，即 n 的最小平方數個數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        \"\"\"Return the least number of perfect square numbers that sum to n.\"\"\"\n        dp = [float('inf')] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            j = 1\n            while j * j <= i:\n                dp[i] = min(dp[i], dp[i - j * j] + 1)\n                j += 1\n        return dp[n]\n\ndef main() -> None:\n    data = sys.stdin.read()\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    solution = Solution()\n    print(solution.numSquares(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 13",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode330.json",
    "problem_index_in_file": 0,
    "title": "Patching Array",
    "description_snippet": "Given a sorted integer array nums and an integer n, add/patch elements to the array such that any nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for the \"Patching Array\" problem. The user wants the virtual code lines with explanation after //.\n\nWe need to not output actual code, just structure. Use Start, End, Decision, arrow etc. Provide line by line. Should produce algorithm: use greedy approach: maintain current reachable [1, reach] and patch when nums[i] > reach+1 etc. Provide loops.\n\nLet's design pseudocode:\n\nStart\n→ Initialize reach = 0 // sum we can currently reach\n→ Initialize patches = 0 // count patches\n→ Initialize i = 0 // index for nums\n→ Decision: while reach < n? // we still need to reach n\n   Yes → Decision: if i < nums.length and nums[i] <= reach+1? // current number can extend reach\n        Yes → Step: reach += nums[i]; i++ // add current number\n        No → Step: reach += reach+1; patches++ // patch with reach+1\n   No → End\n\nReturn patches\n\nAlso maybe incorporate loop within decision. Provide explanation.\n\nWe need to adhere to the format exactly: each line is \"虛擬碼步驟 // 解釋/說明\".\n\nAlso include the decision indent. The example shows indentation with spaces. We must indent accordingly. Provide arrow '→' before each line. The 'Decision:' lines may be indented further with spaces. Provide nested indent: maybe 4 spaces per level.\n\nWe need to include 'Start' line without arrow? In example, \"Start // 程式開始執行\" no arrow. But they use \"Start // 程式開始執行\" no arrow. So we follow: Start. Then subsequent lines with arrow. For decisions, use \"Decision: ...\". Indentation: \"Decision:\" lines are same indentation as previous line? In example, Decision line is at same indent as Step? They indent with one space before \"Decision:\"? They show:\n\n```\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // ...\n```\n\nThey used indentation of 4 spaces before Yes. So the Decision line is not indented further. So we can do similar.\n\nLet's produce lines.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → 初始化 reach = 0 // 初始可達總和為 0\n\nLine 3: → 初始化 patches = 0 // 已補丁數量\n\nLine 4: → 初始化 i = 0 // 數組指標\n\nLine 5: → Decision: 當 reach < n? // 需要繼續補丁直到可達範圍覆蓋 1..n\n\nThen inside that while loop, we need a nested loop: The decision inside while? We'll use nested decisions. But we could write:\n\nInside while:\n\nDecision: if i < nums.length and nums[i] <= reach+1?\n\nYes → Step: reach += nums[i]; i++ // 使用現有數字擴大可達範圍\n\nNo → Step: reach += reach+1; patches++ // 補丁，使用 reach+1\n\nThen loop back to while condition.\n\nSo we need to represent nested decisions inside while. Indentation: 4 spaces for nested decisions.\n\nLet's produce:\n\nLine 6:     Decision: i < nums.length 且 nums[i] <= reach+1? // 可否使用當前數字\n\nLine 7:         Yes → Step: reach += nums[i]; i++ // 加入 nums[i]，擴大可達範圍\n\nLine 8:         No  → Step: reach += reach+1; patches++ // 補丁，使用 reach+1\n\nLine 9: End // 程式結束\n\nBut we also need to loop back. Maybe represent loop by repeating Decision: while reach < n? at top. We could show that the loop encloses inner decision. Use indentation:\n\nLine 5: Decision: reach < n? // 循環條件\n\nLine 6:     Decision: i < nums.length 且 nums[i] <= reach+1? // 是否可直接使用\n\nLine 7:         Yes → Step: reach += nums[i]; i++ // 使用現有數字\n\nLine 8:         No  → Step: reach += reach+1; patches++ // 補丁\n\nAfter this, it goes back to line 5.\n\nNeed to show that loop continues. In pseudocode representation, after inner decision we don't need explicit loop arrow; the decision at line 5 will iterate.\n\nSo we need to add \"End\" after the loop. So line 9: End // 程式結束\n\nAlso maybe include \"Return patches\" before End? In example they don't show return separately. We can add:\n\nLine 8.5: → Step: return patches // 回傳補丁數\n\nBut we must maintain order. Let's put it before End.\n\nSo line 8: → Step: return patches // 回傳最小補丁數\n\nBut the example shows \"End // 程式執行結束\" after step 4. They don't show return. But maybe we can keep consistent: after loop, we just have End. But need to output patches. We can include as separate step. But maybe they don't require return step. It's okay to include.\n\nLet's incorporate \"→ Step: return patches // 回傳結果\" before End.\n\nBut the pseudocode is linear. Actually after loop, we would \"Return patches\" then \"End\". So we need to represent Return as a step. So line 8: → Step: return patches // 回傳最小補丁數\n\nThen line 9: End // 程式結束\n\nNow indent: Step lines inside loop? Return should be outside loop, so no indent.\n\nLet's produce final output.\n\nAlso we need to maintain the format: Each line \"虛擬碼步驟 // 解釋\".\n\nUse \"虛擬碼步驟\" as the actual code piece. For decisions, \"Decision:\" etc.\n\nThus produce:\n\n```\nStart // 程式開始執行\n→ 初始化 reach = 0 // 初始可達總和為 0\n→ 初始化 patches = 0 // 已補丁數量\n→ 初始化 i = 0 // 數組指標\n→ Decision: reach < n? // 需要繼續補丁直到可達範圍覆蓋 1..n\n    Decision: i < nums.length 且 nums[i] <= reach+1? // 可否使用當前數字\n        Yes → Step: reach += nums[i]; i++ // 加入 nums[i]，擴大可達範圍\n        No  → Step: reach += reach+1; patches++ // 補丁，使用 reach+1\n→ Step: return patches // 回傳最小補丁數\nEnd // 程式結束\n```\n\nCheck indentation: The \"Yes\" and \"No\" lines have four spaces indentation. Also we might indent \"Step: return patches\" no indent.\n\nBut in example they used \"Yes → Step\" with one space after indentation? Actually they had:\n\n```\nYes → Step 2: 輸出 '正數' // ...\nNo  → Decision: 如果數字等於 0? // ...\n```\n\nSo we can replicate with 4 spaces before Yes and No.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ 初始化 reach = 0 // 初始可達總和為 0\n→ 初始化 patches = 0 // 已補丁數量\n→ 初始化 i = 0 // 數組指標\n→ Decision: reach < n? // 需要繼續補丁直到可達範圍覆蓋 1..n\n    Decision: i < nums.length 且 nums[i] <= reach+1? // 可否使用當前數字\n        Yes → Step: reach += nums[i]; i++ // 加入 nums[i]，擴大可達範圍\n        No  → Step: reach += reach+1; patches++ // 補丁，使用 reach+1\n→ Step: return patches // 回傳最小補丁數\nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def minPatches(self, nums, n):\n        patches = 0          # 已補丁的個數\n        miss = 1             # 目前最小缺口\n        i = 0                # nums 的索引\n        while miss <= n:\n            if i < len(nums) and nums[i] <= miss:\n                miss += nums[i]\n                i += 1\n            else:\n                miss += miss          # 補丁為 miss 本身\n                patches += 1\n        return patches\n\ndef parse_input(data: str):\n    \"\"\"\n    從 stdin 讀取的字串中解析出 nums 與 n。\n    支援「nums = [1,3], n = 6」以及分行輸入的格式。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return [], 0\n\n    # 先搜尋方括號中的列表\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if list_match:\n        nums_str = list_match.group(0)  # 包含 [ 與 ]\n        nums = ast.literal_eval(nums_str)\n    else:\n        # 失敗則假設第一行即為列表\n        lines = data.splitlines()\n        nums = ast.literal_eval(lines[0].strip())\n\n    # 搜尋 n 的值\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', data)\n    if n_match:\n        n_val = int(n_match.group(1))\n    else:\n        # 失敗則假設第二行為 n\n        lines = data.splitlines()\n        n_val = int(lines[1].strip()) if len(lines) > 1 else 0\n\n    return nums, n_val\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums, n = parse_input(raw_input)\n    solution = Solution()\n    result = solution.minPatches(nums, n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,3], n = 6",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,10], n = 20",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,2], n = 5",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode210.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule II",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for topological sort. We'll explain line by line. Use Start, Decision, etc. Should not output actual code. Just steps. Provide explanation after each line. Use virtual code syntax. Provide steps: build graph, indegree, queue, result, loop, etc. Ensure arrow lines. Use indentation for nested decisions. Provide clear explanation. Use \"→\" for each step. Provide at least those steps. Let's craft.\n\nWe need to produce a sequential algorithm. Outline:\n\nStart\n→ Step 1: 初始化圖和入度\n→ Step 2: 將每個課程添加到圖並更新入度\n→ Step 3: 將入度為0的課程加入隊列\n→ Decision: 判斷隊列是否空? No → Step 4: 從隊列取出課程，加入結果\n→ Step 5: 為每個相鄰課程減少入度，若入度變0則加入隊列\n→ End loop\n→ Decision: 判斷結果長度是否等於 numCourses? Yes → Return 結果\n→ No → Return 空陣列\n\nBut need to include \"Start\" and \"End\". Provide arrow lines with explanation.\n\nLet's craft more detailed steps: Step1: Build adjacency list and indegree array. Step2: For each pair in prerequisites: add edge, increment indegree. Step3: Initialize queue with indegree 0. Step4: While queue not empty: pop course, append to order, for each neighbor: decrement indegree, if becomes 0, enqueue. Step5: After loop, if order length = numCourses, return order else return empty.\n\nAdd explanation. Use arrow notation \"→\". Use indentation for nested loops. Also include Decision steps with Yes/No arrows.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空的鄰接表 `adj` 與入度陣列 `indeg`，長度為 `numCourses` // 準備資料結構  \n→ Step 2: 遍歷 `prerequisites`  \n    → For each pair `[a, b]`:  \n        → Add `a` 到 `b` 的鄰接清單 (`adj[b] ← a`) // 建立邊  \n        → `indeg[a] ← indeg[a] + 1` // 計算入度  \n→ Step 3: 建立空的佇列 `queue`  \n    → Decision: 每個課程 `i` 的入度為 0? // 找出無前置條件的課程  \n        Yes → `queue.Enqueue(i)` // 加入佇列  \n→ Step 4: 建立空列表 `order` 用於存放課程順序  \n→ Step 5: Decision: `queue` 是否為空? // 開始拓撲排序  \n    No → Step 6: 從 `queue` 取出一個課程 `cur`  \n        → Append `cur` 到 `order` // 先完成此課程  \n        → Decision: `adj[cur]` 是否存在?  \n            Yes → For each neighbour `next` in `adj[cur]`:  \n                → `indeg[next] ← indeg[next] - 1` // 減少入度  \n                → Decision: `indeg[next]` 變為 0?  \n                    Yes → `queue.Enqueue(next)` // 現在可完成此課程  \n        → 回到 Step 5 進行下一輪  \n    Yes → End // 佇列已空，排序完成  \n→ Step 7: Decision: `order` 的長度是否等於 `numCourses`? // 檢查是否成功完成所有課程  \n    Yes → Return `order` // 有效的課程順序  \n    No → Return 空陣列 `[]` // 週期存在，無法完成課程  \nEnd // 程式執行結束",
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立鄰接表與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 填入邊與入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點作為起點\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # 拓撲排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有課程都被加入順序，回傳結果；否則回傳空陣列\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入資料。支援兩種格式：\n    1. 例如: \"numCourses = 2, prerequisites = [[1,0]]\"\n    2. 兩行分別為 numCourses 與 prerequisites\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return None\n\n    # 嘗試以字典形式 eval\n    try:\n        parsed = eval('{' + data + '}')\n        return parsed['numCourses'], parsed['prerequisites']\n    except Exception:\n        pass\n\n    # 兩行分別輸入的情況\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        try:\n            num = int(lines[0].strip())\n            prereq = eval(lines[1].strip())\n            return num, prereq\n        except Exception:\n            pass\n\n    # 單行分隔的情況\n    parts = data.split()\n    if len(parts) >= 2:\n        try:\n            num = int(parts[0])\n            prereq = eval(parts[1])\n            return num, prereq\n        except Exception:\n            pass\n\n    return None\n\ndef main():\n    raw_input = sys.stdin.read()\n    parsed = parse_input(raw_input)\n    if parsed is None:\n        print(\"[]\")\n        return\n\n    numCourses, prerequisites = parsed\n    solver = Solution()\n    order = solver.findOrder(numCourses, prerequisites)\n    print(order)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,1]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,1]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,1,2,3]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,1,2,3]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0,1,2,3]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[0]'\nRaw Got:      '[]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode516.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Subsequence",
    "description_snippet": "Given a string s, find the longest palindromic subsequence's length in s.\n\nA subsequence is a sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output pseudocode steps to compute longest palindromic subsequence length. Use dynamic programming. Provide line by line with comments. Must use \"Start\", \"End\", \"Decision:\" etc. We should generate steps: Input string, length n, create dp matrix n x n. Initialize dp[i][i]=1. For cl from 2 to n: for i from 0 to n-cl: j=i+cl-1. If s[i]==s[j] and cl==2 then dp[i][j]=2 else if s[i]==s[j] then dp[i][j]=dp[i+1][j-1]+2 else dp[i][j]=max(dp[i+1][j],dp[i][j-1]). Finally output dp[0][n-1]. We need to present each line with arrow arrow or Yes/No decision. Use decision statements for loops? Might use Decision: if s[i]==s[j]? but loops we can express. Provide \"→\" before steps. Each line: \"虛擬碼步驟 // 解釋\". Ensure each line has arrow. Use indentation perhaps but each line separate. We might produce \"→ Step 1: 輸入字符串 s\". etc.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入字串 s // 獲取待處理的字串\n→ Step 2: 計算字串長度 n // 用於後續迴圈\n→ Step 3: 建立 n × n 的 dp 陣列 // dp[i][j] 儲存子字串 s[i..j] 的最大回文子序列長度\n→ Decision: 是否需要初始化單字母回文? // 每個單字符都是長度1的回文\n    Yes → Step 4: 對 i in 0..n-1 設定 dp[i][i] = 1 // 每個位置自我回文長度為1\n    No  → // （不會發生，因為 n≥1）\n→ Step 5: 設定 cl = 2 // 子字串長度從 2 開始\n→ Decision: cl ≤ n? // 循環遍歷所有可能的子字串長度\n    Yes → Step 6: 對 i in 0..n-cl 設定 j = i + cl - 1 // 確定子字串的起止位置\n        → Decision: s[i] == s[j]? // 比較兩端字符是否相同\n            Yes → Decision: cl == 2? // 兩字符相同時的特別處理\n                Yes → Step 7: 設定 dp[i][j] = 2 // 兩個相同字符直接形成回文\n                No  → Step 8: 設定 dp[i][j] = dp[i+1][j-1] + 2 // 內部已經是回文，外加兩字符\n            No  → Step 9: 設定 dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取不包含左或右字符的最大值\n        → Step 10: cl = cl + 1 // 進入下一個子字串長度\n    No  → // 當 cl>n 時跳出迴圈\n→ Step 11: 輸出 dp[0][n-1] // 最大回文子序列長度為整個字串\nEnd // 程式執行結束\n\nMake sure each line has arrow and comment. Use \"→\" at beginning of each line. For Decision, we indent? We can just include them as separate lines.\n\nWe must ensure no actual code, just pseudocode steps. So we can produce as above. Ensure each line ends with // 解釋. The arrows inside Decision lines too. Use \"Yes →\" etc. Good. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 獲取待處理的字串  \n→ Step 2: 計算字串長度 n // 用於後續迴圈  \n→ Step 3: 建立 n × n 的 dp 陣列 // dp[i][j] 儲存子字串 s[i..j] 的最大回文子序列長度  \n→ Decision: 是否需要初始化單字母回文? // 每個單字符都是長度1的回文  \n Yes → Step 4: 對 i in 0..n-1 設定 dp[i][i] = 1 // 每個位置自我回文長度為1  \n No  → // （不會發生，因為 n≥1）  \n→ Step 5: 設定 cl = 2 // 子字串長度從 2 開始  \n→ Decision: cl ≤ n? // 循環遍歷所有可能的子字串長度  \n Yes → Step 6: 對 i in 0..n-cl 設定 j = i + cl - 1 // 確定子字串的起止位置  \n  → Decision: s[i] == s[j]? // 比較兩端字符是否相同  \n   Yes → Decision: cl == 2? // 兩字符相同時的特別處理  \n    Yes → Step 7: 設定 dp[i][j] = 2 // 兩個相同字符直接形成回文  \n    No  → Step 8: 設定 dp[i][j] = dp[i+1][j-1] + 2 // 內部已經是回文，外加兩字符  \n   No  → Step 9: 設定 dp[i][j] = max(dp[i+1][j], dp[i][j-1]) // 取不包含左或右字符的最大值  \n  → Step 10: cl = cl + 1 // 進入下一個子字串長度  \n No  → // 當 cl>n 時跳出迴圈  \n→ Step 11: 輸出 dp[0][n-1] // 最大回文子序列長度為整個字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\ndef longest_palindromic_subseq(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                if j == i + 1:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    print(longest_palindromic_subseq(s))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"bbbab\"",
          "expected_output": "4",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '4'\nGot (Norm):      '6'\n--- (Raw) ---\nRaw Expected: '4'\nRaw Got:      '6'"
        },
        {
          "example_index": 1,
          "input": "\"cbbd\"",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '4'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '4'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode4.json",
    "problem_index_in_file": 0,
    "title": "Median of Two Sorted Arrays",
    "description_snippet": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for merging two sorted arrays and find median with O(log(m+n)). It's standard \"find median of two sorted arrays\" problem. The algorithm: binary search partition method. Steps: ensure nums1 is smaller. Binary search on nums1 to find partition. Compute left1, right1, left2, right2. Check conditions. Determine median. Provide virtual steps. Use Start, End, Decision blocks. Use arrows.\n\nWe need to output step-by-step virtual code, each line with explanation. We must not output actual code, only structure.\n\nWe need to handle cases where one array empty.\n\nLet's write:\n\nStart\n→ Step 1: 確定 nums1 為較短陣列 // 確保二分搜尋在較小陣列上進行\n→ Decision: 如果 nums1 不是最短陣列? // 交換兩陣列\n    Yes → Step 2: 交換 nums1 與 nums2\n    No  → (continue)\n\n→ Step 3: 計算 m = nums1 的長度，n = nums2 的長度\n→ Step 4: 設定 low = 0, high = m // 二分搜尋指標\n\n→ Loop: While low <= high // 找到合適的分割點\n    → Step 5: partition1 = (low + high) // 2 // nums1 的分割索引\n    → Step 6: partition2 = (m + n + 1) // 2 - partition1 // nums2 的分割索引\n\n    → Decision: partition1 < m AND nums2[partition2 - 1] > nums1[partition1]?\n        Yes → Step 7: low = partition1 + 1 // partition1 太小，向右移\n        No → Decision: partition1 > 0 AND nums1[partition1 - 1] > nums2[partition2]?\n            Yes → Step 8: high = partition1 - 1 // partition1 太大，向左移\n            No → (找到正確分割點)\n\n→ Step 9: 計算 maxLeft\n    → Decision: partition1 == 0?\n        Yes → maxLeft = nums2[partition2 - 1]\n        No → Decision: partition2 == 0?\n            Yes → maxLeft = nums1[partition1 - 1]\n            No → maxLeft = max(nums1[partition1 - 1], nums2[partition2 - 1])\n\n→ Step 10: 如果 (m + n) 是奇數?\n    Yes → Step 11: 返回 maxLeft // 中位數即為左側最大值\n    No → Step 12: 計算 minRight\n        → Decision: partition1 == m?\n            Yes → minRight = nums2[partition2]\n            No → Decision: partition2 == n?\n                Yes → minRight = nums1[partition1]\n                No → minRight = min(nums1[partition1], nums2[partition2])\n        → Step 13: 返回 (maxLeft + minRight) / 2 // 中位數為左右兩邊平均值\n\nEnd\n\nWe need to include explanations after each line.\n\nAlso include step for empty array: If m==0, handle separately. We can include a decision before loop: if m==0, then directly median of nums2. But we can incorporate into logic.\n\nSimplify: At start, check if m == 0. Then median = nums2[ (n-1)/2] or avg if even.\n\nLet's add.\n\nStart // ...\n→ Step 1: 確定 nums1 為較短陣列 // 確保二分搜尋在較小陣列上進行\n→ Decision: 如果 nums1 不是最短陣列? // 交換兩陣列\n    Yes → Step 2: 交換 nums1 與 nums2\n    No  → (continue)\n\n→ Step 3: 計算 m = nums1 的長度，n = nums2 的長度\n→ Decision: 如果 m == 0? // 若最短陣列為空，直接取 nums2 的中位數\n    Yes → Decision: n 是奇數?\n        Yes → Step 4: 返回 nums2[(n-1)/2]\n        No  → Step 5: 返回 (nums2[n/2 - 1] + nums2[n/2]) / 2\n    No  → (continue)\n\n→ Step 6: 設定 low = 0, high = m // 二分搜尋指標\n\n→ Decision: While low <= high // 找到合適的分割點\n    Yes → Step 7: partition1 = (low + high) // 2\n    Yes → Step 8: partition2 = (m + n + 1) // 2 - partition1\n\n    → Decision: partition1 < m AND nums2[partition2 - 1] > nums1[partition1]?\n        Yes → Step 9: low = partition1 + 1 // partition1 太小，向右移\n        No → Decision: partition1 > 0 AND nums1[partition1 - 1] > nums2[partition2]?\n            Yes → Step 10: high = partition1 - 1 // partition1 太大，向左移\n            No → (正確分割點已找到，跳出迴圈)\n\n→ Step 11: 計算 maxLeft\n    → Decision: partition1 == 0?\n        Yes → maxLeft = nums2[partition2 - 1]\n        No → Decision: partition2 == 0?\n            Yes → maxLeft = nums1[partition1 - 1]\n            No → maxLeft = max(nums1[partition1 - 1], nums2[partition2 - 1])\n\n→ Decision: (m + n) 是奇數?\n    Yes → Step 12: 返回 maxLeft\n    No  → Step 13: 計算 minRight\n        → Decision: partition1 == m?\n            Yes → minRight = nums2[partition2]\n            No → Decision: partition2 == n?\n                Yes → minRight = nums1[partition1]\n                No → minRight = min(nums1[partition1], nums2[partition2])\n\n→ Step 14: 返回 (maxLeft + minRight) / 2\n\nEnd // 程式執行結束\n\nWe need to keep each line with explanation. We need to use \"→\" before each step, and Decision lines with Yes → etc. Also ensure no actual code. Use Chinese for explanations.\n\nLet's output exactly with each line. Ensure each line ends with // explanation. Use spaces appropriately.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 確定 nums1 為較短陣列 // 使二分搜尋在較小陣列上進行  \n→ Decision: 如果 nums1 不是最短陣列? // 若不是，則交換兩陣列  \n Yes → Step 2: 交換 nums1 與 nums2 // 交換兩個陣列使 nums1 為較短  \n No  → (continue) // 若已是最短陣列，繼續往下  \n→ Step 3: 計算 m = nums1 的長度，n = nums2 的長度 // 取得兩陣列長度  \n→ Decision: 如果 m == 0? // 若最短陣列為空，直接取 nums2 的中位數  \n Yes → Decision: n 是奇數?  \n  Yes → Step 4: 返回 nums2[(n-1)/2] // 奇數長度，中位數為中間元素  \n  No  → Step 5: 返回 (nums2[n/2 - 1] + nums2[n/2]) / 2 // 偶數長度，中位數為兩中間元素平均值  \n No  → (continue) // 若 m 不為 0，繼續往下  \n→ Step 6: 設定 low = 0, high = m // 二分搜尋的左右指標  \n→ Decision: While low <= high // 找到合適的分割點  \n Yes → Step 7: partition1 = (low + high) // 2 // nums1 的分割索引  \n Yes → Step 8: partition2 = (m + n + 1) // 2 - partition1 // nums2 的分割索引  \n  Decision: partition1 < m AND nums2[partition2 - 1] > nums1[partition1]? // partition1 太小？  \n   Yes → Step 9: low = partition1 + 1 // 將 partition1 向右調整  \n   No → Decision: partition1 > 0 AND nums1[partition1 - 1] > nums2[partition2]? // partition1 太大？  \n    Yes → Step 10: high = partition1 - 1 // 將 partition1 向左調整  \n    No → (正確分割點已找到，跳出迴圈)  \n→ Step 11: 計算 maxLeft // 左側最大值，用於中位數計算  \n  Decision: partition1 == 0?  \n   Yes → maxLeft = nums2[partition2 - 1] // nums1 左側無元素，取 nums2  \n   No → Decision: partition2 == 0?  \n    Yes → maxLeft = nums1[partition1 - 1] // nums2 左側無元素，取 nums1  \n    No → maxLeft = max(nums1[partition1 - 1], nums2[partition2 - 1]) // 兩邊皆有，取較大值  \n→ Decision: (m + n) 是奇數? // 判斷總長度奇偶  \n Yes → Step 12: 返回 maxLeft // 奇數時中位數即左側最大值  \n No  → Step 13: 計算 minRight // 右側最小值，用於平均  \n  Decision: partition1 == m?  \n   Yes → minRight = nums2[partition2] // nums1 右側無元素，取 nums2  \n   No → Decision: partition2 == n?  \n    Yes → minRight = nums1[partition1] // nums2 右側無元素，取 nums1  \n    No → minRight = min(nums1[partition1], nums2[partition2]) // 兩邊皆有，取較小值  \n→ Step 14: 返回 (maxLeft + minRight) / 2 // 偶數時中位數為左右兩邊平均值  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        # 確保 nums1 為較短陣列\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        m, n = len(nums1), len(nums2)\n\n        # 若最短陣列為空，直接處理\n        if m == 0:\n            if n % 2 == 1:\n                return float(nums2[n // 2])\n            else:\n                return (nums2[n // 2 - 1] + nums2[n // 2]) / 2.0\n\n        low, high = 0, m\n        while low <= high:\n            i = (low + high) // 2\n            j = (m + n + 1) // 2 - i\n\n            left1 = float('-inf') if i == 0 else nums1[i - 1]\n            right1 = float('inf') if i == m else nums1[i]\n            left2 = float('-inf') if j == 0 else nums2[j - 1]\n            right2 = float('inf') if j == n else nums2[j]\n\n            if left1 <= right2 and left2 <= right1:\n                if (m + n) % 2 == 1:\n                    return float(max(left1, left2))\n                return (max(left1, left2) + min(right1, right2)) / 2.0\n            elif left1 > right2:\n                high = i - 1\n            else:\n                low = i + 1\n        # 理論上不會執行到此\n        return 0.0\n\ndef parse_input(s):\n    \"\"\"從輸入字串中擷取兩個整數列表。\"\"\"\n    parts = re.findall(r'\\[([^\\]]*)\\]', s)\n    if len(parts) < 2:\n        return [], []\n    nums1 = [int(x.strip()) for x in parts[0].split(',') if x.strip()]\n    nums2 = [int(x.strip()) for x in parts[1].split(',') if x.strip()]\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "success": true,
          "output": "2.00000"
        },
        {
          "example_index": 1,
          "input": "nums1 = [1,2], nums2 = [3,4]",
          "expected_output": "2.50000",
          "success": true,
          "output": "2.50000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode201.json",
    "problem_index_in_file": 0,
    "title": "Bitwise AND of Numbers Range",
    "description_snippet": "Given two integers left and right that represent the range [left, right], return the bitwise AND of ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for computing bitwise AND over range [left, right]. We should produce step by step with decision and loops. Provide explanation each line. Use Start, End, Decision. Use arrow. Ensure each line contains virtual code step + space + // explanation.\n\nThe algorithm: common approach: find common prefix by shifting right until left==right, count shift, then left << shift. Or compute by while loop: while left < right, right = right & (right-1) maybe? But typical solution: shift until left==right.\n\nWe produce:\n\nStart\n→ Step 1: Initialize shiftCount = 0 // count how many right shifts performed\n→ Decision: If left == right? // check if the range collapsed\n    Yes → Step 2: Return left << shiftCount // shift back to original value\n    No → Step 3: right = right & (right - 1) // remove lowest set bit from right\n    No → Step 4: shiftCount = shiftCount + 1 // increment shift count\n    No → Step 5: Go back to Decision\n\nEnd\n\nBut need \"逐行\" with indentation? In sample, nested lines indented maybe with spaces. Provide arrow and step lines. Use Decision arrow with Yes → and No → lines indented. Provide code accordingly.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 shiftCount = 0 // 記錄右移位數  \n→ Decision: 如果 left == right? // 判斷範圍是否已收斂  \n  Yes → Step 2: 返回 left << shiftCount // 將共通前綴還原並回傳結果  \n  No  → Step 3: right = right & (right - 1) // 移除 right 最低位的 1  \n  No  → Step 4: shiftCount = shiftCount + 1 // 記錄已移動一次位  \n  No  → Step 5: 回到 Decision // 重複檢查條件  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef range_bitwise_and(left: int, right: int) -> int:\n    \"\"\"\n    以位移的方式找出 [left, right] 的共同前綴，回傳其位與結果。\n    \"\"\"\n    shift = 0\n    while left < right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取形如 'left = 5, right = 7' 的文字，提取兩個整數，\n    呼叫計算函式後將結果輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read()\n    numbers = re.findall(r'-?\\d+', data)\n    if len(numbers) < 2:\n        return  # 若輸入格式不符則不做任何輸出\n    left, right = int(numbers[0]), int(numbers[1])\n    result = range_bitwise_and(left, right)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "left = 5, right = 7",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "left = 0, right = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 2,
          "input": "left = 1, right = 2147483647",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode313.json",
    "problem_index_in_file": 0,
    "title": "Super Ugly Number",
    "description_snippet": "A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an int...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving nth super ugly number. Provide step-by-step pseudo algorithm. We need to output per line: virtual code step + \" // explanation\". Use arrows. We'll outline algorithm: Use dynamic programming with pointers. Steps: Start, initialize ugly array of size n, set ugly[0]=1. indices array size len(primes) all zero. For i from 1 to n-1: compute next candidate as min(primes[j]*ugly[idx[j]]) for j. Set ugly[i]=candidate. For each j where primes[j]*ugly[idx[j]]==candidate, idx[j]++. End. Return ugly[n-1].\n\nWe will produce each step line by line. Should we include loops as steps? Provide line: \"→ Step: 設定 ugly[0] = 1 // 第 0 個超醜數\" etc.\n\nAlso incorporate decision to iterate. Use \"Decision:\" for if. For loops can be represented as a \"While\" maybe. Let's produce:\n\nStart\n→ Step 1: 建立陣列 ugly[0..n-1] 並設定 ugly[0] = 1 // 初始化最小超醜數\n→ Step 2: 建立指標 idx[0..k-1] 全部設定為 0 // 每個素數的索引\n→ Step 3: For i from 1 到 n-1 循環 // 填充剩餘的超醜數\n    → Step 3.1: 計算 next = min(primes[j] * ugly[idx[j]]) for all j // 找到下一個最小候選值\n    → Step 3.2: 設定 ugly[i] = next // 把最小值加入序列\n    → Step 3.3: Decision: 如果 primes[j] * ugly[idx[j]] == next? // 更新相等指標\n        Yes → Step 3.3.1: idx[j]++ // 指標移動\n        No  → Step 3.3.2: 仍保持原指標\nEnd // 結束計算，返回 ugly[n-1]\n\nBut the decision inside loop has multiple j's. We can express as a loop over j with a conditional increment. Instead of \"Decision\" we can just specify \"→ Step: For each j: if primes[j]*ugly[idx[j]]==next then idx[j]++\". But requirement: Use Decision: and Yes/No arrows. Maybe we can nest.\n\nWe can have:\n\n→ Step 3.3: Decision: 對於每個 j, 若 primes[j]*ugly[idx[j]] == next? // 檢查是否需要移動指標\n        Yes → Step 3.3.1: idx[j]++ // 移動指標\n        No  → Step 3.3.2: 什麼也不做 // 仍保持\n\nBut we need to handle \"for each j\" - we could represent as \"→ Decision: j loop\" maybe not required. We can use separate step \"→ Step: For j in 0..k-1\" but we still need decision for each j. Let's produce:\n\n→ Step 3.3: For j in 0..k-1 // 遍歷所有素數\n    → Decision: 若 primes[j]*ugly[idx[j]] == next? // 判斷是否與最小值相等\n        Yes → Step 3.3.1: idx[j]++ // 指標前進\n        No  → Step 3.3.2: 無操作 // 不變\n\nFinally after loop we finish.\n\nLet's produce lines accordingly.\n\nMake sure each line has a single step and explanation.\n\nWe can also include \"Return ugly[n-1]\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立陣列 ugly[0..n-1] 並設定 ugly[0] = 1 // 初始化第一個超醜數  \n→ Step 2: 建立指標陣列 idx[0..k-1] 全部設定為 0 // 每個素數的索引初始為 0  \n→ Step 3: For i from 1 到 n-1 循環 // 填寫剩餘的超醜數  \n → Step 3.1: 計算 next = min(primes[j] * ugly[idx[j]]) for all j // 找出下一個最小候選值  \n → Step 3.2: 設定 ugly[i] = next // 將最小值加入序列  \n → Step 3.3: For j from 0 到 k-1 循環 // 遍歷所有素數  \n   → Decision: 若 primes[j] * ugly[idx[j]] == next? // 判斷是否需移動指標  \n    Yes → Step 3.3.1: idx[j]++ // 指標前進，準備下一次乘法  \n    No  → Step 3.3.2: 無操作 // 指標保持不變  \nEnd // 完成所有計算，超醜數序列已填好  \n→ Step 4: Return ugly[n-1] // 回傳第 n 個超醜數",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def nthSuperUglyNumber(self, n, primes):\n        # 基本情況：第一個超醜數永遠是 1\n        ugly = [1]\n        indices = [0] * len(primes)\n        vals = list(primes)\n\n        for _ in range(1, n):\n            # 找到下一個最小的候選值\n            next_ugly = min(vals)\n            ugly.append(next_ugly)\n\n            # 更新所有產生此最小值的指標\n            for i in range(len(primes)):\n                if vals[i] == next_ugly:\n                    indices[i] += 1\n                    vals[i] = ugly[indices[i]] * primes[i]\n\n        return ugly[-1]\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，支持「n = 12, primes = [2,7,13,19]」等格式\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if not nums:\n        sys.exit()\n    n = nums[0]\n    primes = nums[1:]\n\n    solution = Solution()\n    result = solution.nthSuperUglyNumber(n, primes)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 12, primes = [2,7,13,19]",
          "expected_output": "32",
          "success": true,
          "output": "32"
        },
        {
          "example_index": 1,
          "input": "n = 1, primes = [2,3,5]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode448.json",
    "problem_index_in_file": 0,
    "title": "Find All Numbers Disappeared in an Array",
    "description_snippet": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the i...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: Find all missing numbers in [1,n] given array nums of size n with values 1..n. Classic solution: iterate and mark presence via index mapping or use a set. But we need pseudocode with steps and explanations. We must produce each line: \"虛擬碼步驟 // 解釋/說明\". Use arrows → and Decision etc. Include Start, End. Probably we produce algorithm: Start → Initialize result list → For each num in nums: mark presence by negative marking or use boolean array. Then iterate indices 1..n, if not marked, add to result. End.\n\nWe must be careful to not output actual code. Provide structure with arrows. Provide explanation for each line.\n\nLet's produce like:\n\nStart\n→ Step 1: Let n = length of nums // 取得陣列長度\n→ Step 2: Create boolean array seen of size n+1, all False // 標記每個數字是否出現\n→ Decision: For each num in nums? // 逐一處理輸入數字\n    Yes → Step 3: Set seen[num] = True // 標記 num 已出現\n→ Step 4: Initialize empty list missing // 儲存缺失數字\n→ Decision: For i from 1 to n? // 檢查每個可能的數字\n    Yes → Decision: If seen[i] is False? // 未標記即缺失\n        Yes → Step 5: Append i to missing // 加入缺失列表\n        No → // 已出現，不需處理\n→ End // 完成\n\nBut must include arrows, maybe use indentation to show nested decisions. Use \"Yes →\" \"No →\". Use \"Decision:\" lines. Provide explanation after //.\n\nLet's produce in Chinese.\n\nWe need to include \"虛擬碼步驟\" each line. Provide step names.\n\nOk. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: let n = length(nums) // 取得陣列長度 n  \n→ Step 2: create boolean array seen[1…n] and set all entries to False // 用來標記每個數字是否出現  \n→ Decision: 遍歷 nums 中的每個 num? // 逐一處理輸入的數字  \n  Yes → Step 3: seen[num] = True // 將對應索引標記為已出現  \n→ Step 4: create empty list missing // 用於儲存缺失的數字  \n→ Decision: 遍歷 i 從 1 到 n? // 檢查每個可能的數字  \n  Yes → Decision: seen[i] 為 False? // 該數字未出現即缺失  \n    Yes → Step 5: append i to missing // 將缺失數字加入結果列表  \n    No → // 該數字已出現，略過  \n→ End // 程式執行結束，missing 為最終答案\n\n---  \n上述虛擬碼步驟以「Decision」區塊處理條件分支，並使用「Yes →」與「No →」指示流程走向。每行後方的 `//` 供快速閱讀說明。",
      "generated_code": "import sys\n\nclass Solution:\n    def findDisappearedNumbers(self, nums):\n        n = len(nums)\n        # 將每個數字對應的索引位置設為負數，表示該數字已出現\n        for num in nums:\n            index = abs(num) - 1\n            nums[index] = -abs(nums[index])\n        # 所有正數位置對應的索引+1即為缺失的數字\n        return [i + 1 for i in range(n) if nums[i] > 0]\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中抽取列表，例如：\n    'nums = [4,3,2,7,8,2,3,1]' 或 '[4,3,2,7,8,2,3,1]'\n    \"\"\"\n    start = data.find('[')\n    if start == -1:\n        return []\n    end = data.find(']', start)\n    if end == -1:\n        return []\n    list_str = data[start:end+1]\n    # 用 eval 解析列表字面量，安全性已經足夠 (輸入僅為簡單數字列表)\n    return eval(list_str)\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入\n    raw_input = sys.stdin.read().strip()\n    # 解析出 nums 列表\n    nums = parse_input(raw_input)\n    # 求解\n    result = Solution().findDisappearedNumbers(nums)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,7,8,2,3,1]",
          "expected_output": "[5,6]",
          "success": true,
          "output": "[5, 6]"
        },
        {
          "example_index": 1,
          "input": "nums = [1,1]",
          "expected_output": "[2]",
          "success": true,
          "output": "[2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode273.json",
    "problem_index_in_file": 0,
    "title": "Integer to English Words",
    "description_snippet": "Convert a non-negative integer num to its English words representation....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants to produce a virtual code (pseudocode) to convert a non-negative integer to its English words representation. We need to output step-by-step pseudocode lines, each with a short explanation. Use Start, End, Decision, arrow →, Yes →, No →. No actual code, just pseudocode.\n\nWe need to think about typical algorithm: break into thousands groups: billions, millions, thousands, hundreds. Use mapping arrays for ones, teens, tens, thousands suffixes. Then recursively convert each group of 3 digits.\n\nWe need to produce the pseudocode step by step. Use Start, End, Decision. Provide lines like \"Start // program starts\" etc.\n\nLet's plan lines:\n\nStart\n→ Step 1: Receive integer num // input\n→ Decision: If num == 0? // check zero\n    Yes → Step 2: Output 'Zero' // output\n    No  → Step 3: Initialize result as empty string // prepare\n→ Step 4: Define list of thousand separators ['','Thousand','Million','Billion'] // mapping\n→ Step 5: Initialize counter i = 0 // index for thousand separators\n→ Step 6: While num > 0 // process groups\n    → Step 7: Extract group = num mod 1000 // last three digits\n    → Decision: If group != 0? // skip zero groups\n        Yes → Step 8: Convert group to words via helper function // group words\n            → Step 9: Prepend group words + separator to result // add\n        No → Step 10: Do nothing // skip\n    → Step 11: num = num div 1000 // shift\n    → Step 12: i = i + 1 // next separator\n→ Step 13: Output trimmed result // final string\nEnd\n\nNow we need a helper function to convert group of up to 3 digits to words.\n\nAdd:\n\n→ Start Helper ConvertThreeDigits(group) // convert 0-999\n    → Step 1: If group == 0? // skip zero in helper\n        Yes → Step 2: Return empty string // nothing\n        No  → Step 3: Initialize words empty\n    → Step 4: If group >= 100? // hundreds\n        → Step 5: words += ones[group // 100] + ' Hundred'\n        → Step 6: group = group % 100\n    → Step 7: If group >= 20? // tens\n        → Step 8: words += ' ' + tens[group // 10]\n        → Step 9: group = group % 10\n    → Step 10: If group >= 10? // teens\n        → Step 11: words += ' ' + teens[group - 10]\n        → Step 12: group = 0\n    → Step 13: If group > 0? // ones\n        → Step 14: words += ' ' + ones[group]\n    → Step 15: Return trimmed words\nEnd Helper\n\nBut we might not need to show function separately? The user didn't specify to define function, but we can produce it as part of pseudocode. The problem: output must be step-by-step; we can show a helper as sub-block.\n\nWe'll produce something like:\n\n→ Step 8: Define helper function ConvertGroup(group) // convert 0-999 to words\n\nThen the helper block inside.\n\nNeed to use arrows: maybe \"→\" for steps, \"Decision:\" for condition, \"Yes →\" \"No →\" for branches.\n\nMake sure each line ends with // explanation.\n\nAlso include \"Start\" and \"End\" markers.\n\nWe can include \"Decision:\" for conditions like if.\n\nWe need to include \"→ Step\" numbering.\n\nLet's craft final output accordingly. Use proper formatting.\n\nWe will produce lines with \"→\" preceding steps. The first line \"Start\" no arrow.\n\nLet's create pseudocode.\n\nEnsure each line ends with explanation. Use consistent indent? They didn't require indentation but we can indent under Decision? We'll include indent as spaces.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Receive integer num // 取得使用者輸入的非負整數  \n→ Decision: 若 num == 0? // 檢查是否為零  \n  Yes → Step 2: Output 'Zero' // 若為零，直接輸出結果並結束  \n  No  → Step 3: 初始化 result 為空字串 // 準備存放最終英文單詞  \n→ Step 4: 定義千位分隔符陣列 separators = ['', 'Thousand', 'Million', 'Billion'] // 以便後續加上相應後綴  \n→ Step 5: 初始化 counter i = 0 // 用於對應 separators  \n→ Step 6: While num > 0 // 逐個 3 位數進行處理  \n  → Step 7: 提取 group = num mod 1000 // 取得最後三位數  \n  → Decision: 若 group != 0? // 只有非零組才需要轉換  \n    Yes → Step 8: words = ConvertGroup(group) // 呼叫輔助函式轉成單詞  \n        → Step 9: result = words + ' ' + separators[i] + ' ' + result // 前置組合到結果  \n    No  → Step 10: Do nothing // 跳過零組  \n  → Step 11: num = num div 1000 // 移除已處理的三位數  \n  → Step 12: i = i + 1 // 進入下一千位級別  \n→ Step 13: Output result.Trim() // 去除前後空白並輸出最終字串  \nEnd // 程式執行結束  \n\n// ---------- ConvertGroup 函式 ----------  \nStart // 開始 ConvertGroup  \n→ Step 1: 若 group == 0? // 內部遞迴中若為零直接返回空字串  \n  Yes → Step 2: Return '' // 不產生任何字串  \n  No  → Step 3: 初始化 words 為空字串 // 準備累積單詞  \n→ Step 4: 若 group >= 100? // 處理百位  \n  Yes → Step 5: words += Ones[group / 100] + ' Hundred' // 加上百位單詞  \n    → Step 6: group = group mod 100 // 更新剩餘兩位  \n  No → Step 7: Do nothing  \n→ Step 8: 若 group >= 20? // 處理十位（大於等於20）  \n  Yes → Step 9: words += ' ' + Tens[group / 10] // 加上十位單詞  \n    → Step 10: group = group mod 10 // 更新剩餘個位  \n  No → Step 11: Do nothing  \n→ Step 12: 若 group >= 10? // 處理十一到十九  \n  Yes → Step 13: words += ' ' + Teens[group - 10] // 加上特殊單詞  \n    → Step 14: group = 0 // 兩位已處理完  \n  No → Step 15: Do nothing  \n→ Step 16: 若 group > 0? // 處理個位  \n  Yes → Step 17: words += ' ' + Ones[group] // 加上個位單詞  \n  No → Step 18: Do nothing  \n→ Step 19: Return words.Trim() // 去除前後空白並回傳結果  \nEnd // ConvertGroup 結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return \"Zero\"\n\n        def one(n: int) -> str:\n            switcher = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n                        \"Seven\", \"Eight\", \"Nine\"]\n            return switcher[n]\n\n        def two_less_20(n: int) -> str:\n            switcher = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\",\n                        \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n            return switcher[n - 10]\n\n        def ten(n: int) -> str:\n            switcher = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\",\n                        \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n            return switcher[n]\n\n        def two(n: int) -> str:\n            if n == 0:\n                return \"\"\n            elif n < 10:\n                return one(n)\n            elif n < 20:\n                return two_less_20(n)\n            else:\n                tens = n // 10\n                rest = n % 10\n                return ten(tens) + (\" \" + one(rest) if rest != 0 else \"\")\n\n        def three(n: int) -> str:\n            hundred = n // 100\n            rest = n % 100\n            if hundred != 0 and rest != 0:\n                return one(hundred) + \" Hundred \" + two(rest)\n            elif hundred == 0 and rest != 0:\n                return two(rest)\n            elif hundred != 0 and rest == 0:\n                return one(hundred) + \" Hundred\"\n            else:\n                return \"\"\n\n        billion = num // 1_000_000_000\n        million = (num % 1_000_000_000) // 1_000_000\n        thousand = (num % 1_000_000) // 1_000\n        rest = num % 1_000\n\n        parts = []\n        if billion != 0:\n            parts.append(three(billion) + \" Billion\")\n        if million != 0:\n            parts.append(three(million) + \" Million\")\n        if thousand != 0:\n            parts.append(three(thousand) + \" Thousand\")\n        if rest != 0:\n            parts.append(three(rest))\n\n        return \" \".join(parts)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    match = re.search(r\"\\d+\", data)\n    num = int(match.group()) if match else 0\n    solution = Solution()\n    words = solution.numberToWords(num)\n    print(f'\"{words}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 123",
          "expected_output": "\"One Hundred Twenty Three\"",
          "success": true,
          "output": "\"One Hundred Twenty Three\""
        },
        {
          "example_index": 1,
          "input": "num = 12345",
          "expected_output": "\"Twelve Thousand Three Hundred Forty Five\"",
          "success": true,
          "output": "\"Twelve Thousand Three Hundred Forty Five\""
        },
        {
          "example_index": 2,
          "input": "num = 1234567",
          "expected_output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"",
          "success": true,
          "output": "\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode89.json",
    "problem_index_in_file": 0,
    "title": "Gray Code",
    "description_snippet": "An n-bit gray code sequence is a sequence of 2^n integers where:\n\nEvery integer is in the inclusive ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps for generating an n-bit Gray code sequence. Steps: Start, input n, calculate 2^n, create sequence list, start with 0, loop k from 0 to 2^n-1, generate Gray code using k XOR (k>>1) maybe. Append to list. After loop, output list. End. Also need explanation. Use decision? Maybe not needed. Provide simple steps. Use arrow. Let's craft.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\". Use Chinese. Provide steps.\n\nLet's write:\n\nStart // 程式開始執行\n→ Input: n // 取得位元數\n→ Compute: total ← 2^n // 計算序列長度\n→ Init: sequence ← [] // 建立空列表\n→ For k from 0 to total-1: // 產生 2^n 個 Gray code\n    → Compute: gray ← k XOR (k >> 1) // 透過 k ⊕ k>>1 產生 Gray code\n    → Append: sequence.Append(gray) // 加入序列\n→ Output: sequence // 回傳 Gray code 序列\nEnd // 程式執行結束\n\nNeed each line separate, maybe nested? They ask to use arrows and structure. Could use Decision? Not necessary. But we can use Step 1, Step 2. Provide indent? The sample shows indentation with 4 spaces for nested.\n\nWe'll keep simple linear.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: n // 取得位元數  \n→ Compute: total ← 2^n // 計算 Gray code 序列長度  \n→ Init: sequence ← [] // 建立空列表以儲存結果  \n→ For k from 0 to total-1: // 產生 2^n 個 Gray code  \n    → Compute: gray ← k XOR (k >> 1) // 透過 k ⊕ (k>>1) 產生 Gray code  \n    → Append: sequence.Append(gray) // 將 Gray code 加入列表  \n→ Output: sequence // 回傳完成的 Gray code 序列  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def grayCode(self, n: int) -> list[int]:\n        \"\"\"生成 n 位 Gray 代码序列\"\"\"\n        res = [0]                     # 第一步，序列起始為 0\n        for i in range(n):            # 迭代 n 次\n            add = 1 << i               # 2^i，用於鏡像反轉後加上\n            res += [x + add for x in reversed(res)]  # 反向加上 offset\n        return res\n\n\ndef main() -> None:\n    import sys, re\n    data = sys.stdin.read()          # 讀取所有輸入\n    match = re.search(r'\\d+', data)  # 找出第一個整數\n    if not match:\n        return\n    n = int(match.group())           # 轉成整數\n    solution = Solution()\n    result = solution.grayCode(n)\n    print(result)                    # 直接輸出列表，符合題目要求\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "[0,1,3,2]",
          "success": true,
          "output": "[0, 1, 3, 2]"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "[0,1]",
          "success": true,
          "output": "[0, 1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode16.json",
    "problem_index_in_file": 0,
    "title": "3Sum Closest",
    "description_snippet": "Given an integer array nums of length n and an integer target, find three integers in nums such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code (pseudo code) for \"3Sum Closest\" problem. Must output line by line with \"虛擬碼步驟\" + \" // 解釋\". Use arrow syntax. Should be in Traditional Chinese. No actual code, just pseudo. Should cover sorting, two-pointer loop, track best sum. Ensure unique solution. Provide each step. Let's produce:\n\nStart\n→ Step 1: 輸入數組 nums 與目標 target // 取得輸入\n→ Step 2: 將 nums 以升序排序 // 方便雙指標\n→ Step 3: 初始化 bestSum 為無窮大或第一個三元組的和 // 用來儲存最近的總和\n→ Decision: 遍歷索引 i 從 0 到 n-3 // 固定第一個數\n    → Step 4: 設 left 為 i+1, right 為 n-1 // 左右指標\n    → While left < right:\n        → Step 5: currentSum ← nums[i] + nums[left] + nums[right] // 計算當前總和\n        → Decision: 是否 currentSum == target? // 完全等於目標\n            Yes → bestSum ← target // 找到最準確答案\n            Yes → Return bestSum // 立即返回\n            No → Decision: 是否 |currentSum - target| < |bestSum - target|? // 更接近\n                Yes → bestSum ← currentSum // 更新最佳答案\n                No  → // 不更新\n        → Decision: 是否 currentSum < target? // 需要更大的和\n            Yes → left ← left + 1 // 移動左指標\n            No  → right ← right - 1 // 移動右指標\n    → End While\n→ End Decision\n→ Return bestSum // 所有組合完成後回傳最接近的總和\nEnd\n\nBut need arrow formatting: Start, →, Decision, Yes →, No →.\n\nWe need each line with arrow and explanation. Ensure each line includes \"虛擬碼步驟\" and \"// 解釋\". For Decision block, we can indent and show Yes → ... No → ... lines.\n\nLet's craft the output exactly as required. Each line with code-like pseudo then // explanation. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 數組 nums 與 數值 target // 取得輸入資料  \n→ Step 2: 將 nums 以升序排序 // 方便後續雙指標搜尋  \n→ Step 3: 初始化 bestSum 為 無窮大 或 nums[0]+nums[1]+nums[2] // 用來儲存目前最接近的總和  \n→ Decision: 迴圈 i 從 0 到 n-3 // 固定第一個數  \n  Yes → Step 4: 設 left 為 i+1, right 為 n-1 // 左右指標定位  \n  Yes → While left < right:  \n    Step 5: currentSum ← nums[i] + nums[left] + nums[right] // 計算目前三數之和  \n    Decision: currentSum == target? // 完全等於目標值  \n     Yes → bestSum ← target  \n     Yes → Return bestSum // 立即返回最準確答案  \n     No  → Decision: |currentSum - target| < |bestSum - target|? // 是否更接近目標  \n      Yes → bestSum ← currentSum // 更新最佳答案  \n      No  → // 不更新  \n    Decision: currentSum < target? // 需要更大的和  \n     Yes → left ← left + 1 // 向右移動左指標  \n     No  → right ← right - 1 // 向左移動右指標  \n    End While  \n  End Decision  \n→ Return bestSum // 所有組合完成後回傳最接近的總和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        找出 nums 中任意三個數字的和，使其最接近 target。\n        \"\"\"\n        nums.sort()                      # 先排序，方便雙指標\n        n = len(nums)\n        closest_sum = float('inf')       # 儲存目前最接近 target 的和\n\n        for i in range(n - 2):           # 固定第一個數字\n            left, right = i + 1, n - 1   # 設置左右指標\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]  # 當前三數之和\n                # 若更接近目標，更新答案\n                if abs(total - target) < abs(closest_sum - target):\n                    closest_sum = total\n\n                if total < target:       # 需要更大的和\n                    left += 1\n                elif total > target:     # 需要更小的和\n                    right -= 1\n                else:                    # 完全等於 target，直接返回\n                    return total\n\n        return closest_sum\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n\n    # 解析 nums 與 target\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n\n    if nums_match:\n        nums = eval(nums_match.group(1))\n    else:\n        nums = []\n\n    if target_match:\n        target = int(target_match.group(1))\n    else:\n        target = 0\n\n    # 呼叫解法並輸出結果\n    sol = Solution()\n    result = sol.threeSumClosest(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,2,1,-4], target = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,0], target = 1",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode65.json",
    "problem_index_in_file": 0,
    "title": "Valid Number",
    "description_snippet": "Given a string s, return whether s is a valid number.\n\nFor example, all the following are valid numb...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Should be algorithm to check valid number. Use state machine approach? Use steps: trim, check optional sign, parse integer or decimal part, optional exponent. Provide decisions. Use pseudocode steps: Start, trim spaces, handle optional sign, parse integer part digits, parse decimal part. We'll produce decision structure.\n\nWe need to adhere to format: Each line: \"虛擬碼步驟 // 解釋\". Use arrows for flow.\n\nLet's produce step-by-step.\n\nWe might include variable names like i, n. Provide decisions: If char is sign, skip. If digit, parse digits. etc.\n\nWe'll need to cover exponent: after digits or decimal part, if e/E present, parse exponent integer (sign optional). Ensure at least one digit in integer or fractional parts. Provide conditions.\n\nWe'll output as virtual code lines, not actual code.\n\nLet's craft.\n\nStart // 程式開始\n\n→ Step 1: 去除前後空白 // 先去除字串前後的空格\n\n→ Step 2: If 字串為空, 返回 false // 空字串不是合法數字\n\n→ Step 3: i = 0, n = length(s) // 初始化指標\n\n→ Decision: 如果 s[i] 為 '+' 或 '-', i++ // 處理符號\n\n→ Step 4: hasDigits = false // 標記是否已讀到數字\n\n→ Step 5: hasDot = false // 標記是否已遇到小數點\n\n→ Decision: 如果 s[i] 為數字, 解析數字直到非數字 // 讀取整數部分\n\n    Yes → Step 6: hasDigits = true // 讀到數字\n\n    No → 無操作\n\n→ Decision: 如果 s[i] 為 '.', 有小數點\n\n    Yes → Step 7: hasDot = true, i++ // 跳過點\n\n    No → 無操作\n\n→ Step 8: 再次解析數字直到非數字 // 讀取小數部分\n\n    If 有數字, hasDigits = true\n\n→ Decision: 若沒有數字且沒有小數點, 返回 false // 例如 \"e10\"\n\n→ Decision: 若沒有數字且有小數點, 但後面無數字, 返回 false // 例如 \".\"\n\n→ Decision: 若 s[i] 為 'e' 或 'E', 解析指數\n\n    Yes → Step 9: i++ // 跳過 e/E\n\n        → Decision: 如果 s[i] 為 '+' 或 '-', i++ // 指數符號\n\n        → Step 10: 解析數字直到結束 // 指數部分\n\n            If 有數字, hasExpDigits = true\n\n            No → 返回 false // e 如 \"1e\" 或 \"1e+\"\n\n        → Decision: 如果指數後還有其他字符, 返回 false\n\n    No → 無操作\n\n→ Decision: 若還有剩餘字符 (i < n), 返回 false // 例如 \"1a\"\n\n→ Decision: 若 hasDigits 為 false, 返回 false // 例如 \".\" 或 \"e\"\n\n→ End // 程式結束\n\nBut we need to incorporate decisions and branches. We must use format with \"Decision:\" lines. We need to use Yes → and No → arrows.\n\nLet's create each line accordingly.\n\nWe should keep structure simple: Use indentation for nested decisions.\n\nI'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 去除 s 的前後空白 // 先移除輸入字串兩端的空格\n→ Decision: 如果 s 為空字串? // 檢查是否剩餘任何字符\n    Yes → Step 2: 回傳 false // 空字串不是合法數字\n    No  → 進入下一步\n→ Step 3: i ← 0, n ← s 的長度 // 初始化指標\n→ Decision: 如果 s[i] 為 '+' 或 '-'? // 處理可選符號\n    Yes → i ← i + 1 // 跳過符號\n    No  → 直接進行\n→ Step 4: hasDigits ← false // 標記是否已經讀到至少一個數字\n→ Step 5: hasDot ← false // 標記是否已經遇到小數點\n→ Decision: 如果 s[i] 為數字? // 讀取整數部分\n    Yes → Step 6: 解析數字直到非數字 // i 逐位往後移\n        hasDigits ← true // 已讀到數字\n    No  → 仍保持 hasDigits 為 false\n→ Decision: 如果 s[i] 為 '.'? // 檢查小數點\n    Yes → Step 7: hasDot ← true, i ← i + 1 // 標記小數點並跳過\n    No  → 直接進行\n→ Decision: 如果 s[i] 為數字? // 讀取小數部分\n    Yes → Step 8: 解析數字直到非數字\n        hasDigits ← true // 有小數位數\n    No  → 仍保持 hasDigits\n→ Decision: 如果 hasDigits 為 false? // 例如僅有符號或小數點\n    Yes → Step 9: 回傳 false // 無任何數字，非法\n    No  → 進行下一步\n→ Decision: 如果 s[i] 為 'e' 或 'E'? // 檢查是否存在指數\n    Yes → Step 10: i ← i + 1 // 跳過 e/E\n        → Decision: 如果 s[i] 為 '+' 或 '-'? // 指數符號\n            Yes → i ← i + 1 // 跳過符號\n            No  → 直接進行\n        → Step 11: hasExpDigits ← false // 標記指數部分是否有數字\n        → Decision: 如果 s[i] 為數字? // 解析指數\n            Yes → Step 12: 解析數字直到結束\n                hasExpDigits ← true // 指數有數字\n            No  → Step 13: 回傳 false // e 後缺少數字\n        → Decision: 如果 hasExpDigits 為 false? // 指數沒有數字\n            Yes → Step 14: 回傳 false\n            No  → 進行下一步\n    No  → 直接進行\n→ Decision: 如果 i ≠ n? // 還有未處理字符\n    Yes → Step 15: 回傳 false // 例如 \"1a\"\n    No  → 進行下一步\n→ Decision: 如果 hasDigits 為 false? // 例如 \".\" 或 \"e\"\n    Yes → Step 16: 回傳 false\n    No  → 進行下一步\n→ Step 17: 回傳 true // 所有檢查通過，為合法數字\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_number(s: str) -> bool:\n    \"\"\"\n    檢查字串 s 是否為合法的數字。\n    \"\"\"\n    s = s.strip()\n    if not s:\n        return False\n\n    num_seen = False   # 是否已讀到至少一個數字\n    dot_seen = False   # 是否已遇到小數點\n    e_seen = False     # 是否已遇到指數符號\n\n    for i, ch in enumerate(s):\n        if ch.isdigit():\n            num_seen = True\n\n        elif ch == '.':\n            # 小數點只能出現在整數或小數部分，且只能出現一次\n            if dot_seen or e_seen:\n                return False\n            dot_seen = True\n\n        elif ch in ('e', 'E'):\n            # 指數符號必須在至少一個數字之後，且只能出現一次\n            if e_seen or not num_seen:\n                return False\n            e_seen = True\n            num_seen = False  # 指數部分再次要求至少一個數字\n\n        elif ch in ('+', '-'):\n            # 符號只能出現在字串開頭或指數符號之後\n            if i != 0 and s[i - 1] not in ('e', 'E'):\n                return False\n\n        else:\n            # 任何其他字符都非法\n            return False\n\n    # 最終必須至少有一個數字（不管是整數、小數或指數部分）\n    return num_seen\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取資料，提取字串並判斷是否為合法數字。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 先嘗試從 's = \"...\"' 或類似格式中抽取字串\n    match = re.search(r'[\"\\'](.*)[\"\\']', data, re.S)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有引號，直接使用整行作為字串\n        s = data\n\n    print(is_number(s))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"0\"",
          "expected_output": "True",
          "success": true,
          "output": "True"
        },
        {
          "example_index": 1,
          "input": "s = \"e\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        },
        {
          "example_index": 2,
          "input": "s = \".\"",
          "expected_output": "False",
          "success": true,
          "output": "False"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode121.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou wan...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations for the problem: \"max profit from single buy-sell\" typical algorithm: iterate through array, keep min_price so far and max_profit. Output steps. Provide lines with virtual code and explanation. Format: \"虛擬碼步驟 // 解釋\". Use arrow indicators. Use Start End Decision. Let's produce steps: Start, initialize min_price to large, max_profit to 0, iterate i from 0 to n-1: update min_price if price < min_price, else compute profit = price - min_price, update max_profit if profit > max_profit. At end return max_profit. Also if max_profit <0 return 0 but we maintain max_profit min 0. Use Decision at end maybe.\n\nWe'll output each step line by line.\n\nLet's craft.\n\nPotential steps:\n\nStart // 程式開始\n→ Step 1: 初始化 min_price 為正無限 // 以便找出最小價\n→ Step 2: 初始化 max_profit 為 0 // 初始最大利潤為 0\n→ Step 3: 針對每個價格 in prices 進行迴圈 // 遍歷所有天數\n    → Decision: 如果價格 < min_price? // 檢查是否為新最小值\n        Yes → Step 4: 設定 min_price 為價格 // 更新最小買入價\n        No  → Step 5: 計算 profit = 價格 - min_price // 以當前賣價計算利潤\n              → Decision: 如果 profit > max_profit? // 檢查是否為新最大利潤\n                  Yes → Step 6: 設定 max_profit 為 profit // 更新最大利潤\n                  No  → // 留下現有 max_profit\n→ Step 7: 回傳 max_profit // 輸出最終最大利潤\nEnd // 程式結束\n\nAlso could add decision at end for negative but we never have negative since we keep zero. Might add final check: Decision: 如果 max_profit < 0? → return 0 else return max_profit. But since max_profit starts 0 and only increases, it can't be negative.\n\nBut we can include final decision: If max_profit <=0 then return 0 else return max_profit.\n\nLet's incorporate. We'll keep Step 7 and Step 8 for final decision.\n\nSo lines count maybe 9 or 10. Let's produce accordingly.\n\nMake sure each line follows format: `虛擬碼步驟 // 解釋`. Use arrow and decision lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 min_price 為 +∞ // 用來儲存迴圈中遇到的最低買入價  \n→ Step 2: 設定 max_profit 為 0 // 初始最大利潤，確保負利潤不會被計算  \n→ Step 3: 針對每個價格 in prices 進行迴圈 // 遍歷所有天數的股價  \n  → Decision: 如果 價格 < min_price? // 檢查是否為新的最小價  \n   Yes → Step 4: min_price ← 價格 // 更新最低買入價  \n   No → Step 5: profit ← 價格 - min_price // 用當前賣價計算利潤",
      "generated_code": "import sys\nimport ast\n\ndef max_profit(prices):\n    if not prices:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices[1:]:\n        max_profit = max(max_profit, price - min_price)\n        min_price = min(min_price, price)\n    return max_profit\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 解析輸入，允許形如 \"prices = [7,1,5,3,6,4]\" 的格式\n    if data.lower().startswith(\"prices\"):\n        idx = data.find(\"=\")\n        if idx != -1:\n            data = data[idx + 1:].strip()\n    try:\n        prices = ast.literal_eval(data)\n        if not isinstance(prices, list):\n            raise ValueError\n    except Exception:\n        prices = []\n    result = max_profit(prices)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode44.json",
    "problem_index_in_file": 0,
    "title": "Wildcard Matching",
    "description_snippet": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for wildcard pattern matching, covering entire string. Use Start, Decision, etc. We must generate step by step pseudo-code with explanations. Need to decide algorithm. Could use DP. Let's produce steps:\n\nStart\n→ Initialize DP table rows s_len+1 x p_len+1 boolean\n→ Set DP[0][0] true\n→ For j from 1 to p_len: if p[j-1]=='*' DP[0][j] = DP[0][j-1] else break\n→ For i from 1 to s_len:\n    → For j from 1 to p_len:\n        → Decision: if p[j-1] == s[i-1] or p[j-1]=='?':\n                Yes → DP[i][j] = DP[i-1][j-1]\n                No  → Decision: if p[j-1]=='*':\n                        Yes → DP[i][j] = DP[i][j-1] or DP[i-1][j]\n                        No  → DP[i][j] = false\n→ Result = DP[s_len][p_len]\n→ Output result\nEnd\n\nBut need to be more explanatory step lines. Let's produce each line with explanation.\n\nWe need to use arrow notation. Use \"→\" arrow for step. We can use \"Decision:\" with Yes→ and No→. Also use \"Start\" and \"End\".\n\nLet's write lines:\n\nStart // 程式開始\n→ Initialize DP matrix of size (len(s)+1) x (len(p)+1) with False // 建立 DP 表\n→ DP[0][0] = True // 空字串對空字串匹配\n→ For j = 1 to len(p): // 初始化第一列，處理前導 '*'\n    Decision: if p[j-1] == '*'?\n        Yes → DP[0][j] = DP[0][j-1] // '*' 可匹配空字串\n        No  → Break // 其他字符則無法匹配空字串，停止\n→ For i = 1 to len(s): // 遍歷字串 s\n    → For j = 1 to len(p): // 遍歷模式 p\n        → Decision: if p[j-1] == s[i-1] or p[j-1] == '?'?\n            Yes → DP[i][j] = DP[i-1][j-1] // 正常匹配\n            No  → Decision: if p[j-1] == '*'?\n                Yes → DP[i][j] = DP[i][j-1] or DP[i-1][j] // '*' 視為空或單個字符\n                No  → DP[i][j] = False // 其它情況不匹配\n→ Result = DP[len(s)][len(p)] // 檢查整個字串是否匹配\n→ Output Result // 回傳匹配結果\nEnd // 程式結束\n\nBut we need each line with `//` explanation. We need to include arrow `→` at each step. For loops, we can have a line like `→ For j = 1 to len(p):` then inside we have decision block. But we need to maintain indentation? Format not strict; we can write each line with arrow. For nested loops, we can still maintain arrow lines but may need to indent? Not required.\n\nWe should keep each line separate.\n\nWe must ensure we only output the virtual code lines, each with explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize DP matrix of size (len(s)+1) × (len(p)+1) with False // 建立 DP 表，預設全部為 False\n→ DP[0][0] = True // 空字串與空模式相匹配\n→ For j = 1 to len(p): // 處理前導 '*'，以填充第一列\n    Decision: if p[j-1] == '*'\n        Yes → DP[0][j] = DP[0][j-1] // '*' 可匹配空字串，遞延前一個狀態\n        No  → Break // 直至遇到非 '*'，此後的列保持 False\n→ For i = 1 to len(s): // 遍歷字串 s 的每個字符\n    → For j = 1 to len(p): // 遍歷模式 p 的每個字符\n        → Decision: if p[j-1] == s[i-1] or p[j-1] == '?'\n            Yes → DP[i][j] = DP[i-1][j-1] // 正常匹配或 '?'，取左上角狀態\n            No  → Decision: if p[j-1] == '*'\n                Yes → DP[i][j] = DP[i][j-1] or DP[i-1][j] // '*' 可匹配空或單個字符\n                No  → DP[i][j] = False // 其他情況不匹配\n→ Result = DP[len(s)][len(p)] // 整個字串是否完全匹配模式\n→ Output Result // 回傳匹配結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\n        return dp[m][n]\n\ndef parse_input(data: str):\n    # Extract strings inside double quotes\n    quoted = re.findall(r'\"(.*?)\"', data)\n    if len(quoted) >= 2:\n        return quoted[0], quoted[1]\n    # Fallback: split by whitespace or comma\n    parts = re.split(r'[,\\s]+', data.strip())\n    parts = [p for p in parts if p]\n    if len(parts) >= 2:\n        return parts[0], parts[1]\n    # If still not found, return empty strings\n    return '', ''\n\ndef main():\n    data = sys.stdin.read()\n    s, p = parse_input(data)\n    solution = Solution()\n    result = solution.isMatch(s, p)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aa\", p = \"a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "s = \"aa\", p = \"*\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "s = \"cb\", p = \"?a\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode216.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum III",
    "description_snippet": "Find all valid combinations of k numbers that sum up to n such that the following conditions are tru...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem. Must not output actual code, just structured steps with explanations. Must be in Traditional Chinese.\n\nWe need to describe algorithm: backtracking, DFS, generate combinations from numbers 1-9, choose k numbers, sum n. Use recursion, track current combination, sum. Avoid duplicates automatically because we choose numbers in increasing order. We'll produce steps accordingly. Use Start, Decision, etc.\n\nLet's produce each step line: Start, → Step 1: 初始化參數, etc. Provide explanation after //.\n\nLet's produce the algorithm in steps: maybe 10-15 lines.\n\nMake sure each line is: \"虛擬碼步驟 // 解釋\". Use arrow notation: \"→\".\n\nUse Decision: \"Decision: ...\" with Yes → etc.\n\nWe need to be careful to cover all steps: define DFS function, call DFS(1, [], 0). Inside DFS, if len(comb)==k and sum==n, add comb copy to result. Else if len(comb)>k or sum>n, backtrack. For i from start to 9, choose i, add to comb, call DFS(i+1, comb, sum+i), then pop.\n\nAlso need to return result.\n\nWe'll produce pseudo steps:\n\nStart\n→ Step 1: 定義結果列表 results // 用來儲存所有有效組合\n→ Step 2: 定義遞迴函式 DFS(current, combination, current_sum) // current 是下一個可選數字的起始值\n→ Decision: 是否已完成組合? // 檢查是否達到 k 個數字\n    Yes → Decision: sum 是否等於 n? // 檢查總和是否符合\n        Yes → Step 3: 將 combination 複製加入 results // 收集有效組合\n        No  → Step 4: 返回 // 不符合，回溯\n    No  → Decision: current_sum 已超過 n 或組合長度已 > k? // 防止不必要搜尋\n        Yes → Step 5: 返回 // 超過條件，回溯\n        No  → Step 6: For i in range(current, 10): // 選擇下一個數字\n            → Step 7: 添加 i 至 combination // 將數字加入當前組合\n            → Step 8: 更新 current_sum += i // 更新總和\n            → Step 9: 調用 DFS(i+1, combination, current_sum) // 深度優先遞迴\n            → Step 10: 移除 i 從 combination // 回溯，恢復狀態\n            → Step 11: 更新 current_sum -= i // 釐清總和\n→ Step 12: 呼叫 DFS(1, [], 0) // 開始遞迴\n→ Step 13: 返回 results // 返回所有組合\n\nBut we need to ensure each line uses correct arrow formatting. Let's produce line numbers? Not required. We just produce sequential lines. Use \"→\" at start of each step. For decisions, indent? The example uses indentation. We'll mimic.\n\nLet's craft the output accordingly.\n\nMake sure to include \"Start\" and \"End\" lines.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 results // 用來儲存所有有效組合\n→ Step 2: 定義遞迴函式 DFS(current, combination, current_sum) // current 是下一個可選數字的起始值\n    → Decision: if len(combination) == k? // 檢查是否已選到 k 個數字\n        Yes → Decision: current_sum == n? // 檢查總和是否正好等於 n\n            Yes → Step 3: results.append(copy of combination) // 收集有效組合\n            No  → Step 4: return // 不符合條件，回溯\n        No  → Decision: current_sum > n 或 len(combination) > k? // 防止不必要搜尋\n            Yes → Step 5: return // 超過條件，回溯\n            No  → Step 6: for i in range(current, 10): // 從 current 到 9 選擇下一個數字\n                → Step 7: combination.append(i) // 加入當前數字\n                → Step 8: current_sum += i // 更新總和\n                → Step 9: DFS(i+1, combination, current_sum) // 進一步搜尋\n                → Step 10: combination.pop() // 回溯，移除數字\n                → Step 11: current_sum -= i // 恢復總和\n→ Step 12: DFS(1, [], 0) // 啟動遞迴搜尋\n→ Step 13: return results // 返回所有有效組合\nEnd // 程式執行結束\n\nBut we need to be careful: each line must have \"虛擬碼步驟 [空格] // 解釋\". The indentation can be done with spaces? In example, they had indentation under Decision lines. We'll replicate with indentation but maintain line format.\n\nWe also need to ensure that \"Step 1:\" etc. Use \"→\" before Step lines.\n\nAlso for decision lines, use \"Decision:\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化結果列表 results // 用來儲存所有符合條件的組合\n→ Step 2: 定義遞迴函式 DFS(current, combination, current_sum) // current 表示下一個可選的數字起點\n    → Decision: 如果 len(combination) == k? // 判斷是否已選到 k 個數字\n        Yes → Decision: current_sum == n? // 判斷總和是否正好等於 n\n            Yes → Step 3: results.append(copy of combination) // 收集有效組合\n            No  → Step 4: return // 不符合條件，回溯\n        No  → Decision: current_sum > n 或 len(combination) > k? // 超過總和或長度，提前停止\n            Yes → Step 5: return // 回溯\n            No  → Step 6: for i in range(current, 10): // 從 current 到 9 逐一嘗試\n                → Step 7: combination.append(i) // 加入當前數字\n                → Step 8: current_sum += i // 更新目前總和\n                → Step 9: DFS(i+1, combination, current_sum) // 深度優先遞迴\n                → Step 10: combination.pop() // 回溯，移除數字\n                → Step 11: current_sum -= i // 回復總和\n→ Step 12: DFS(1, [], 0) // 開始遞迴搜尋\n→ Step 13: return results // 返回所有合法組合\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\ndef combinationSum3(k: int, n: int):\n    \"\"\"回溯尋找所有使用 1~9、每個最多一次、且恰好有 k 個數字總和為 n 的組合。\"\"\"\n    res = []\n\n    def backtrack(start: int, path: list[int], total: int):\n        # 若已選 k 個數字並且總和符合，加入結果\n        if len(path) == k and total == n:\n            res.append(path[:])\n            return\n        # 若數量或總和已超過限制，則回溯\n        if len(path) > k or total > n:\n            return\n\n        # 從 start 開始，嘗試加入 1~9 的每個數字\n        for i in range(start, 10):\n            path.append(i)\n            backtrack(i + 1, path, total + i)\n            path.pop()  # 回溯，恢復狀態\n\n    backtrack(1, [], 0)\n    return res\n\n\ndef main() -> None:\n    # 讀取整個輸入（可能是「k = 3, n = 7」或「3 7」等格式）\n    data = sys.stdin.read()\n    # 先用正則找出所有整數\n    nums = re.findall(r'-?\\d+', data)\n\n    if len(nums) >= 2:\n        k, n = int(nums[0]), int(nums[1])\n    else:\n        # 若正則沒抓到，直接分割空白\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            k, n = int(parts[0]), int(parts[1])\n        else:\n            return\n\n    result = combinationSum3(k, n)\n    # 使用 json.dumps 並去除空格，符合範例輸出格式\n    print(json.dumps(result, separators=(',', ':')))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "k = 3, n = 7",
          "expected_output": "[[1,2,4]]",
          "success": true,
          "output": "[[1,2,4]]"
        },
        {
          "example_index": 1,
          "input": "k = 3, n = 9",
          "expected_output": "[[1,2,6],[1,3,5],[2,3,4]]",
          "success": true,
          "output": "[[1,2,6],[1,3,5],[2,3,4]]"
        },
        {
          "example_index": 2,
          "input": "k = 4, n = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode126.json",
    "problem_index_in_file": 0,
    "title": "Word Ladder II",
    "description_snippet": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a seque...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for algorithm: Find all shortest transformation sequences between beginWord and endWord given dictionary. Standard BFS to build adjacency and then DFS/backtracking to produce all paths of minimal length. So steps: preprocess wordList set, build graph via neighbors by changing one letter, BFS from beginWord to find distances, maintain parent mapping, then DFS from beginWord to endWord using parent mapping to build all shortest paths. We need to produce virtual code steps line by line with explanation. Must include Start, End, Decision. Use arrows. Each line: \"虛擬碼步驟 // 解釋\". Must not output actual code.\n\nSo we will produce pseudocode with high-level steps: Start -> Build dictionary set -> If endWord not in set -> Return empty list. -> Initialize adjacency map? Actually we can generate neighbors on the fly. BFS: queue, visited distance map. Use a map of word -> list of previous words? Actually for all shortest we need parent mapping. Standard approach: BFS builds distance and parent mapping. For each word visited, we store its distance. For each neighbor if not visited, set distance and add to queue, add current as parent. If neighbor visited with same distance, add current as another parent. After BFS, if endWord not visited -> return empty list. Then DFS recursively from beginWord to endWord using parent mapping reversed: from beginWord we go to its children? Actually parent mapping from each word to previous words along shortest paths. So we can DFS from beginWord: maintain path list, at each step add next word from children? Usually we use children mapping: from each word we have list of next words on shortest path. Could use reverse: for DFS from beginWord we need next words such that distance increases. We can use the distance map to enforce distance+1. So DFS from beginWord: for neighbor in all words: if distance[neighbor]==distance[current]+1 and current is parent? Actually better to build children map: during BFS, when we set distance for neighbor, we add current as parent of neighbor. Later we can reverse to children: for each word, for each parent, add word to children of parent. Then DFS from beginWord to endWord via children.\n\nBut we just need pseudocode, not actual data structures.\n\nWe must include decisions like: if endWord not in dictionary. BFS queue etc.\n\nWe need to output each step as one line of pseudocode. Let's plan number of steps.\n\nWe can break into functions: BuildNeighbors, BFS, DFS. But we may not need function definitions. Just steps.\n\nLet's produce steps:\n\nStart\n→ Step 1: Convert wordList to set dictionary // for O(1) lookup\n→ Decision: If endWord not in dictionary? // check existence\n    Yes → Step 2: Return empty list // no path possible\n    No  → Continue\n→ Step 3: Initialize distance map with beginWord distance 0 // record levels\n→ Step 4: Initialize parent map: empty list for each word // store previous nodes\n→ Step 5: Initialize queue with beginWord // BFS queue\n→ Step 6: While queue not empty: // BFS loop\n    → Decision: If queue empty? // termination\n        Yes → Break loop\n        No  → \n    → Step 7: Pop current word from queue // current node\n    → Step 8: For each position i in current word: // generate neighbors\n        → Step 9: For each letter 'a' to 'z':\n            → Step 10: Replace character at i with letter to form neighborWord\n            → Decision: If neighborWord in dictionary? // valid word\n                Yes → Step 11: If neighborWord not in distance map? // first visit\n                    Yes → Step 12: Set distance[neighborWord] = distance[current] + 1\n                    → Step 13: Add neighborWord to queue\n                    → Step 14: Add current to parent map of neighborWord // record path\n                No → Step 15: If distance[neighborWord] == distance[current] + 1? // same level\n                    Yes → Step 16: Add current to parent map of neighborWord // add alternative path\n                    No  → Do nothing\n    → End While\n→ Decision: If endWord not in distance map? // no path found\n    Yes → Step 17: Return empty list\n    No  → Continue\n→ Step 18: Build children map from parent map // reverse mapping\n    → Step 19: For each word in parent map:\n        → Step 20: For each parent in parent list:\n            → Step 21: Add word to children map of parent\n→ Step 22: Initialize result list empty // to store all paths\n→ Step 23: Define recursive DFS function (currentWord, path)\n    → Step 24: Append currentWord to path\n    → Decision: If currentWord == endWord? // reached target\n        Yes → Step 25: Append copy of path to result list // store a full path\n        No  → Step 26: For each child in children map of currentWord:\n            → Step 27: Call DFS(child, path) // explore deeper\n    → Step 28: Remove last word from path // backtrack\n→ Step 29: Call DFS(beginWord, empty list) // start DFS\n→ Step 30: Return result list // all shortest sequences\nEnd\n\nBut the requirement: each line must have \"虛擬碼步驟 [空格] // 解釋\". So we need to format each line accordingly.\n\nAlso arrow usage: \"→\". For decisions we need nested lines. In example, decision lines are indented? They used indenting for nested steps. We can follow similar.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: 建立 dictionary set from wordList // 用於快速查找\n→ Decision: 是否 endWord 在 dictionary? // 檢查目標字是否存在\n    Yes → Step 2: 回傳空清單 // 無法到達\n    No  → // 繼續後續流程\n→ Step 3: 設定 distance[beginWord] = 0 // 初始距離\n→ Step 4: 建立 parentMap 空字典 // 儲存前驅節點\n→ Step 5: 初始化 queue = [beginWord] // BFS 隊列\n→ Step 6: While queue 非空: // BFS 主迴圈\n    → Decision: queue 為空? // 判斷結束\n        Yes → Break // 跳出迴圈\n        No  → // 繼續\n    → Step 7: current = queue.pop_front() // 取出隊首元素\n    → Step 8: For i in 0 .. len(current)-1: // 逐位產生相鄰字\n        → Step 9: For letter in 'a'..'z':\n            → Step 10: neighbor = current 的第 i 位改為 letter\n            → Decision: neighbor 在 dictionary? // 是否為合法單字\n                Yes → Step 11: 如果 neighbor 未在 distance? // 第一次訪問\n                    Yes → Step 12: distance[neighbor] = distance[current] + 1\n                    → Step 13: queue.append(neighbor)\n                    → Step 14: parentMap[neighbor].append(current) // 記錄前驅\n                No → Step 15: 如果 distance[neighbor] == distance[current] + 1? // 同一層\n                    Yes → Step 16: parentMap[neighbor].append(current) // 加入另一條路徑\n                    No  → // 不做任何事\n    → End While\n→ Decision: endWord 是否在 distance? // 路徑是否存在\n    Yes → // 繼續\n    No  → Step 17: 回傳空清單 // 沒有路徑\n→ Step 18: 建立 childrenMap 為空字典 // 反向映射\n    → Step 19: For word, parents in parentMap.items():\n        → Step 20: For parent in parents:\n            → Step 21: childrenMap[parent].append(word)\n→ Step 22: 初始化 result = [] // 存放所有最短路徑\n→ Step 23: 定義遞迴 DFS(current, path)\n    → Step 24: path.append(current)\n    → Decision: current == endWord? // 到達終點\n        Yes → Step 25: result.append(path.copy()) // 儲存完整路徑\n        No  → Step 26: For child in childrenMap.get(current, []):\n            → Step 27: DFS(child, path) // 深度遞迴\n    → Step 28: path.pop() // 回溯\n→ Step 29: 呼叫 DFS(beginWord, []) // 開始搜尋\n→ Step 30: 回傳 result // 所有最短序列\nEnd // 程式結束執行\n\nWe must ensure each line uses the specified format: `虛擬碼步驟 [space] // 解釋`. We can include \"→\" at the beginning of each line after Start. For decisions, the nested lines are indented, but still should follow the same pattern. Example format: \"Decision: 如果數字大於 0? // 檢查數值是否為正\" then nested \"Yes → Step ...\" etc. In our case we can use similar.\n\nWe need to ensure each line ends with `//` and explanation. Should we include `//` after each line? Yes.\n\nAlso we need to show \"Start\" line: \"Start // 程式開始執行\".\n\nThen arrow lines with \"→\".\n\nWe need to be careful with indentation but likely not critical.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dictionary set 以包含 wordList 所有單字 // 用於 O(1) 查詢  \n→ Decision: endWord 是否在 dictionary? // 確認目標字存在  \n  Yes → Step 2: 回傳空清單 // 無法轉換到目標  \n  No  → // 繼續後續流程  \n→ Step 3: 設定 distance[beginWord] = 0 // 初始距離為 0  \n→ Step 4: 建立 parentMap 為空字典 // 儲存每個字的前驅節點  \n→ Step 5: 初始化 queue = [beginWord] // BFS 隊列  \n→ Step 6: While queue 非空: // BFS 主迴圈  \n  → Decision: queue 為空? // 判斷是否結束  \n    Yes → Break // 跳出迴圈  \n    No  → // 繼續  \n  → Step 7: current = queue.pop_front() // 取出隊首字  \n  → Step 8: For i in 0 .. len(current)-1: // 逐位產生相鄰字  \n    → Step 9: For letter in 'a'..'z':  \n      → Step 10: neighbor = current 的第 i 位改為 letter // 生成候選字  \n      → Decision: neighbor 在 dictionary? // 是否為合法單字  \n        Yes → Step 11: 如果 neighbor 未在 distance? // 第一次訪問  \n         Yes → Step 12: distance[neighbor] = distance[current] + 1 // 設定距離  \n          → Step 13: queue.append(neighbor) // 加入隊列  \n          → Step 14: parentMap[neighbor].append(current) // 記錄前驅  \n        No → Step 15: 如果 distance[neighbor] == distance[current] + 1? // 同層  \n         Yes → Step 16: parentMap[neighbor].append(current) // 加入另一條路徑  \n         No  → // 不處理  \n  → End While  \n→ Decision: endWord 是否在 distance? // 判斷是否找到路徑  \n  Yes → // 繼續  \n  No  → Step 17: 回傳空清單 // 無法到達 endWord  \n→ Step 18: 建立 childrenMap 為空字典 // 反向映射父子關係  \n  → Step 19: For word, parents in parentMap.items():  \n    → Step 20: For parent in parents:  \n      → Step 21: childrenMap[parent].append(word) // 記錄子節點  \n→ Step 22: 初始化 result = [] // 儲存所有最短路徑  \n→ Step 23: 定義遞迴 DFS(current, path)  \n  → Step 24: path.append(current) // 加入目前節點  \n  → Decision: current == endWord? // 到達終點  \n    Yes → Step 25: result.append(path.copy()) // 存入完整路徑  \n    No  → Step 26: For child in childrenMap.get(current, []):  \n      → Step 27: DFS(child, path) // 深度優先搜尋  \n  → Step 28: path.pop() // 回溯  \n→ Step 29: 呼叫 DFS(beginWord, []) // 開始 DFS  \n→ Step 30: 回傳 result // 所有最短序列  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        # BFS to find shortest distance and parents\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    if c == word[i]:\n                        continue\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        if endWord not in parents:\n            return []\n\n        # DFS to build all shortest paths\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        dfs([endWord], endWord)\n        return res\n\ndef parse_input(data: str):\n    \"\"\"Parse input string of the form:\n       beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\"]\n    \"\"\"\n    begin = re.search(r'beginWord\\s*=\\s*\"([^\"]+)\"', data)\n    end = re.search(r'endWord\\s*=\\s*\"([^\"]+)\"', data)\n    list_part = re.search(r'wordList\\s*=\\s*\\[([^\\]]*)\\]', data)\n    if not (begin and end and list_part):\n        raise ValueError(\"Input format is incorrect.\")\n    beginWord = begin.group(1)\n    endWord = end.group(1)\n    words = re.findall(r'\"([^\"]+)\"', list_part.group(1))\n    return beginWord, endWord, words\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    beginWord, endWord, wordList = parse_input(raw_input)\n    sol = Solution()\n    result = sol.findLadders(beginWord, endWord, wordList)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "success": true,
          "output": "[['hit', 'hot', 'dot', 'dog', 'cog'], ['hit', 'hot', 'lot', 'log', 'cog']]"
        },
        {
          "example_index": 1,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode436.json",
    "problem_index_in_file": 0,
    "title": "Find Right Interval",
    "description_snippet": "You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.\n...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to find right interval. Classic solution: sort intervals by start, keep original indices. For each interval, binary search for smallest start >= end. Complexity O(n log n). Steps: Build list of (start, index). Sort. For each interval i, binary search over sorted starts for end. If found, output sorted_index_of_found; else -1.\n\nWe must output line by line with comments. Use Start, End, Decision, etc. Need to include arrow syntax.\n\nLet's craft. Each step: \"Start\", \"→ Build list\", \"→ Sort\", \"→ Initialize result array\", \"→ For each interval i from 0 to n-1\", inside loop: compute end, binary search. Represent binary search: Decision: while low <= high? But maybe simpler: \"→ Binary Search for end in sorted_starts\". Then produce result[i] accordingly.\n\nNeed to maintain clarity. Provide steps like \"→ Step X: binary search sorted starts for end\" with explanation.\n\nWill produce approximate algorithm.\n\nLet's produce code lines:\n\nStart\n→ Build list L: for each interval i, push (start, i)\n→ Sort L by start ascending\n→ Extract sorted_starts array from L\n→ Extract sorted_indices array from L\n→ Initialize result array of length n with -1\n→ For each interval index i from 0 to n-1:\n    → Get end_i = intervals[i][1]\n    → Binary Search in sorted_starts for first start >= end_i\n    → Decision: Found? \n        Yes → result[i] = sorted_indices[pos]\n        No  → result[i] stays -1\n→ End\n\nNeed to incorporate arrows and decisions inside loops. Use indentation with spaces.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Build list L: for each interval i, push (start_i, i) // 建立(start, 原始索引)對\n→ Sort L by start ascending // 依起點排序\n→ Extract sorted_starts: 取出排序後的起點陣列 // 用於搜尋\n→ Extract sorted_indices: 取出排序後的原始索引陣列 // 對應到起點\n→ Initialize result array res[n] with -1 // 預設無右區間\n→ For each index i from 0 to n-1:\n    → end_i = intervals[i][1] // 取得該區間結束值\n    → Binary Search in sorted_starts for first start >= end_i // 搜尋最小符合條件的起點\n    → Decision: 找到位置 pos? // 判斷是否存在\n        Yes → res[i] = sorted_indices[pos] // 設定右區間索引\n        No  → res[i] remains -1 // 無符合區間\n→ End // 程式結束\n\nWe might need to include loop arrow lines properly. In earlier example, \"→ Step 1:\" etc. For loops, maybe use \"→ For i in 0..n-1:\" line. Also need indent for nested decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build list L: for each interval i, push (start_i, i) // 建立 (起點, 原始索引) 的對  \n→ Sort L by start ascending // 依起點由小到大排序  \n→ Extract sorted_starts: 取出排序後的起點陣列 // 用於二分搜尋  \n→ Extract sorted_indices: 取出排序後的原始索引陣列 // 對應到每個起點  \n→ Initialize result array res[n] with -1 // 預設所有區間都沒有右區間  \n→ For each index i from 0 to n-1:  \n    → end_i = intervals[i][1] // 取得該區間的結束值  \n    → Binary Search in sorted_starts for first start >= end_i // 搜尋最小符合條件的起點  \n    → Decision: 找到位置 pos? // 判斷是否存在符合條件的區間  \n        Yes → res[i] = sorted_indices[pos] // 設定右區間的原始索引  \n        No  → res[i] remains -1 // 沒有符合條件，保持 -1  \n→ End // 程式執行結束",
      "generated_code": "import sys\nimport bisect\nimport ast\n\nclass Solution:\n    def findRightInterval(self, intervals):\n        \"\"\"\n        找出每個區間的右區間索引。\n        1. 先把所有區間的起點和原始索引整理成列表，並按起點排序。\n        2. 針對每個區間，用二分搜尋找最小的起點 >= 這個區間的結束值。\n        3. 若找到就回傳對應的原始索引，否則回傳 -1。\n        \"\"\"\n        # 建立 (起點, 原始索引) 的列表並排序\n        starts = sorted((interval[0], i) for i, interval in enumerate(intervals))\n        result = []\n\n        for interval in intervals:\n            end = interval[1]                     # 取結束值\n            # 二分搜尋最小起點 >= end\n            idx = bisect.bisect_left(starts, (end, ))\n            if idx < len(starts):\n                result.append(starts[idx][1])    # 回傳原始索引\n            else:\n                result.append(-1)                # 無右區間\n        return result\n\ndef main():\n    \"\"\"\n    主程式：\n    1. 從標準輸入讀取整行字串。\n    2. 解析成 intervals 清單（使用 ast.literal_eval 以避免 eval 風險）。\n    3. 呼叫 Solution.findRightInterval 幫忙計算結果。\n    4. 將結果以列表形式輸出到標準輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入格式，例如 'intervals = [[1,2]]'\n    try:\n        _, rhs = data.split('=', 1)\n        intervals = ast.literal_eval(rhs.strip())\n    except Exception:\n        # 若輸入本身就是清單，例如 '[[1,2]]'\n        intervals = ast.literal_eval(data)\n\n    solution = Solution()\n    output = solution.findRightInterval(intervals)\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2]]",
          "expected_output": "[-1]",
          "success": true,
          "output": "[-1]"
        },
        {
          "example_index": 1,
          "input": "intervals = [[3,4],[2,3],[1,2]]",
          "expected_output": "[-1,0,1]",
          "success": true,
          "output": "[-1, 0, 1]"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,4],[2,3],[3,4]]",
          "expected_output": "[-1,2,-1]",
          "success": true,
          "output": "[-1, 2, -1]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode517.json",
    "problem_index_in_file": 0,
    "title": "Super Washing Machines",
    "description_snippet": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. Problem: equal number of dresses across machines. Standard solution: if sum% n !=0 => -1. Else compute average. Then iterate to compute max of cumulative imbalance and absolute imbalance. Return max.\n\nSo virtual code steps: Start, check sum% n. If not zero: return -1. Then average. Then cumulative sum diff. Keep max. At end return max.\n\nLet's produce line by line with comments. Use Decision etc. Provide arrow. For loops: \"Loop i from 0 to n-1\" can be represented as Step: for each machine. Use Decision etc.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 計算總件數 total = sum(machines) // 取得所有衣服總數\n→ Decision: 是否可平均? (total % n != 0) // 檢查總數能否被機器數整除\n    Yes → Step 2: 回傳 -1 // 無法平均，直接結束\n    No  → Step 3: 計算平均值 avg = total / n // 每台機器應有的衣服數\n→ Step 4: 初始化變數 cumulative = 0, maxMoves = 0 // 用於累積差異與最大步數\n→ Step 5: Loop i from 0 to n-1 // 遍歷每台洗衣機\n    → Step 6: cumulative = cumulative + machines[i] - avg // 更新累積差異\n    → Step 7: maxMoves = max(maxMoves, abs(cumulative), abs(machines[i] - avg)) // 更新需要的步數\n→ End // 結束計算\n→ Step 8: 回傳 maxMoves // 最小移動步數\n\nBut we need use \"Decision:\" inside loop for max update? We can use Step: maxMoves = max(maxMoves, abs(cumulative)) and then update with abs(machines[i] - avg). But maybe simpler: we can decide max of two. But we can use Decision: if abs(cumulative) > maxMoves then maxMoves=abs(cumulative). Then same for abs(machines[i]-avg).\n\nLet's craft accordingly.\n\nAlso need use arrow '→' for each step. Use \"Decision:\" for if.\n\nEnsure each line ends with comment. Provide explanation.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 計算總件數 total = sum(machines) // 取得所有衣服總數  \n→ Decision: 若 total % n != 0? // 檢查總數能否被機器數整除  \n  Yes → Step 2: 回傳 -1 // 無法平均，直接結束  \n  No  → Step 3: 計算平均值 avg = total / n // 每台機器應有的衣服數  \n→ Step 4: 初始化變數 cumulative = 0, maxMoves = 0 // 用於累積差異與最大步數  \n→ Step 5: Loop i 從 0 到 n-1 // 遍歷每台洗衣機  \n  → Step 6: cumulative = cumulative + machines[i] - avg // 更新累積差異  \n  → Decision: abs(cumulative) > maxMoves? // 檢查是否為目前最大步數  \n    Yes → Step 7: maxMoves = abs(cumulative) // 更新最大步數  \n  → Decision: abs(machines[i] - avg) > maxMoves? // 檢查單台差異是否更大  \n    Yes → Step 8: maxMoves = abs(machines[i] - avg) // 更新最大步數  \n→ End // 結束迴圈與計算  \n→ Step 9: 回傳 maxMoves // 最小移動步數完成返回",
      "generated_code": "import sys\nimport json\n\ndef find_min_moves(machines):\n    \"\"\"\n    計算最小步數使所有洗衣機擁有相同數量的衣服。\n    若無法平均，返回 -1。\n    \"\"\"\n    total = sum(machines)\n    n = len(machines)\n    if total % n != 0:\n        return -1\n\n    avg = total // n\n    res = 0\n    cum_diff = 0\n\n    for load in machines:\n        diff = load - avg\n        cum_diff += diff\n        # 需要的步數取決於累積差異和單台差異的絕對值\n        res = max(res, abs(cum_diff), abs(diff))\n\n    return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 嘗試使用 json 解析，若失敗則回退到 eval（安全性較低，但在本環境可行）\n    try:\n        machines = json.loads(data)\n    except Exception:\n        machines = eval(data)\n\n    print(find_min_moves(machines))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[1,0,5]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "[0,3,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,2,0]",
          "expected_output": "-1",
          "success": true,
          "output": "-1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode278.json",
    "problem_index_in_file": 0,
    "title": "First Bad Version",
    "description_snippet": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output pseudocode for binary search to find first bad version. Must be line by line, with arrow etc. Use \"Start\" etc. Use virtual code steps.\n\nFormat:\n\nStart // 程式開始執行\n→ Step: variable declarations etc.\n\nWe need to incorporate the decision arrow format: Decision: if low <= high? etc. Use Yes →, No →.\n\nLet's craft.\n\nPseudo:\n\nStart\n→ Step 1: low = 1 // 初始化搜索范围\n→ Step 2: high = n // 初始化搜索范围\n→ Decision: low <= high? // 判断是否还有搜索区间\n    Yes → Step 3: mid = low + (high - low) / 2 // 计算中点\n    → Decision: isBadVersion(mid)? // 判断中点是否为坏版本\n        Yes → Step 4: high = mid - 1 // 把高端移到 mid-1，继续搜索左半边\n        No  → Step 5: low = mid + 1 // 把低端移到 mid+1，继续搜索右半边\n    No → Step 6: return low // low 指向第一个坏版本\nEnd\n\nBut need to use virtual code lines exactly.\n\nUse arrow indent.\n\nLet's produce each line with // explanation.\n\nMake sure to maintain \"Decision:\" lines with indent and Yes/No arrows.\n\nLet's craft.\n\nWe should also mention n as input param to function.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: low = 1 // 搜索区间左端点\n→ Step 2: high = n // 搜索区间右端点\n→ Decision: low <= high? // 是否仍有区间需要搜索\n    Yes → Step 3: mid = low + (high - low) / 2 // 计算中点\n    → Decision: isBadVersion(mid)? // 判断 mid 是否为坏版本\n        Yes → Step 4: high = mid - 1 // 继续搜索左侧，记录 mid 可能是答案\n        No  → Step 5: low = mid + 1 // 继续搜索右侧\n    No → Step 6: return low // low 为第一个坏版本\nEnd // 程式結束\n\nCheck format: Each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\". So we need to include \"Step 1:\" etc. The explanation after \"//\". For decisions we use \"Decision:\".\n\nAlso the indentation maybe optional. We should use arrow before each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low = 1 // 搜索區間左端點  \n→ Step 2: high = n // 搜索區間右端點  \n→ Decision: low <= high? // 是否仍有區間需要搜索  \n  Yes → Step 3: mid = low + (high - low) / 2 // 取得中點  \n  → Decision: isBadVersion(mid)? // 判斷中點是否為壞版本  \n    Yes → Step 4: high = mid - 1 // 將高端縮小到 mid-1，繼續搜索左側  \n    No  → Step 5: low = mid + 1 // 將低端縮小到 mid+1，繼續搜索右側  \n  No  → Step 6: return low // low 指向第一個壞版本  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\n\n# The isBadVersion API is already defined for you.\n# For this standalone script we define it using the provided bad version.\ndef isBadVersionFactory(bad):\n    def isBadVersion(version):\n        return version >= bad\n    return isBadVersion\n\nclass Solution:\n    def firstBadVersion(self, n):\n        left, right = 1, n\n        while left < right:\n            mid = left + (right - left) // 2\n            if isBadVersion(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) < 2:\n        # Default to the first number as n and the second as bad if possible\n        n = numbers[0] if numbers else 0\n        bad = numbers[1] if len(numbers) > 1 else n\n    else:\n        n, bad = numbers[0], numbers[1]\n    # Create a version checker based on the bad version\n    isBadVersion = isBadVersionFactory(bad)\n    # Solve and print the result\n    solution = Solution()\n    print(solution.firstBadVersion(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 5, bad = 4",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "n = 1, bad = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode81.json",
    "problem_index_in_file": 0,
    "title": "Search in Rotated Sorted Array II",
    "description_snippet": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values)...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for searching in a rotated sorted array with duplicates. Standard solution: binary search with handling duplicates. Provide pseudo-code steps line by line. Use Start, Decision, etc. We need to include explanations after each line. Use arrow symbols.\n\nLet's produce:\n\nStart // Begin\n\n→ Step 1: Initialize left = 0, right = nums.length - 1 // pointers\n\n→ Decision: While left <= right? // loop condition\n\n    Yes → Step 2: mid = (left + right) // 2 // middle index\n\n    → Decision: nums[mid] == target? // check target\n\n        Yes → Step 3: Return true // found\n\n        No → Decision: nums[left] == nums[mid] and nums[right] == nums[mid]? // duplicates at ends\n\n            Yes → Step 4: left = left + 1; right = right - 1 // shrink boundaries\n\n            No → Decision: nums[left] <= nums[mid]? // left half sorted\n\n                Yes → Decision: nums[left] <= target < nums[mid]? // target in left half\n\n                    Yes → Step 5: right = mid - 1 // search left\n\n                    No → Step 6: left = mid + 1 // search right\n\n                No → Decision: nums[mid] < target <= nums[right]? // target in right half\n\n                    Yes → Step 7: left = mid + 1 // search right\n\n                    No → Step 8: right = mid - 1 // search left\n\n    No → Loop back\n\n→ End // not found\n\nBut we need to ensure we produce steps each line. Use the format with arrow for each line. Also need to incorporate indentation? The format example uses indentation but we can use spaces to show nested decisions. Use \"Decision:\" etc. Provide explanation after each line.\n\nLet's craft final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 初始化 left = 0, right = nums.length - 1 // 設定搜尋區間邊界\n→ Decision: 是否滿足 left <= right? // 判斷搜尋區間是否還存在元素\n    Yes → Step 2: mid = (left + right) // 2 // 取得中間索引\n    → Decision: nums[mid] == target? // 檢查中間元素是否為目標\n        Yes → Step 3: 回傳 true // 找到目標，結束搜尋\n        No → Decision: nums[left] == nums[mid] 且 nums[right] == nums[mid]? // 兩端與中間相同，無法判斷哪半段有序\n            Yes → Step 4: left = left + 1; right = right - 1 // 收縮搜尋區間，跳過重複值\n            No → Decision: nums[left] <= nums[mid]? // 左半段是否為有序區段\n                Yes → Decision: nums[left] <= target < nums[mid]? // 目標是否位於左半段\n                    Yes → Step 5: right = mid - 1 // 將搜尋區間縮小到左半段\n                    No → Step 6: left = mid + 1 // 目標不在左半段，往右搜尋\n                No → Decision: nums[mid] < target <= nums[right]? // 目標是否位於右半段\n                    Yes → Step 7: left = mid + 1 // 將搜尋區間縮小到右半段\n                    No → Step 8: right = mid - 1 // 目標不在右半段，往左搜尋\n    No → Loop 回到 Decision: 是否滿足 left <= right? // 重新檢查搜尋區間是否仍有效\n→ End // 所有區間都檢查完畢，未找到目標，程式結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    nums = eval(nums_match.group(1)) if nums_match else []\n    target = int(target_match.group(1)) if target_match else 0\n    result = Solution().search(nums, target)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,5,6,0,0,1,2], target = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [2,5,6,0,0,1,2], target = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode435.json",
    "problem_index_in_file": 0,
    "title": "Non-overlapping Intervals",
    "description_snippet": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, for the problem: minimum intervals to remove to make intervals non-overlapping. Classic solution: sort by end, then iterate, count overlapping and increase removal count. Steps:\n\nStart\n→ Step: Sort intervals by end ascending // Sort intervals by finishing time\n→ Step: Initialize last_end = -∞, removals = 0 // trackers\n→ Decision: For each interval (start, end) in sorted list // iterate\n    → Decision: If start >= last_end? // non-overlap\n        Yes → Step: Update last_end = end // keep interval\n        No  → Step: Increment removals // remove current interval\n→ Step: Return removals // result\n\nBut need to be explicit about loop. Use Decision for loop? Might use Step: For each interval in intervals // loop start. In virtual code, we can express loop as Step: For each interval in intervals // loop.\n\nAlternatively, use Decision: While intervals not empty. We'll produce a simple loop representation.\n\nAlso need to include Step: Sort intervals // maybe mention using stable sort.\n\nWe should produce each line with \"虛擬碼步驟\" plus comment.\n\nNeed to not output actual code, only structured steps.\n\nWe should include End.\n\nLet's produce.\n\nAlso maybe step: intervals ← sort by end ascending // sorting.\n\nAlso step: for each interval in intervals do // loop.\n\nInside loop: Decision: if start >= last_end? // check.\n\nYes: Update last_end = end\n\nNo: removals++\n\nAfter loop: Step: Output removals\n\nEnd\n\nLet's produce lines.\n\nMake sure each line ends with comment.\n\nUse \"Start\" and \"End\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step: intervals ← sort intervals by end ascending // 先以結束時間升序排列，方便選取最早結束的區間\n→ Step: last_end ← -∞ // 追蹤已選區間的最右邊界\n→ Step: removals ← 0 // 需要移除的區間數量\n→ Step: For each interval in intervals // 逐一檢查每個區間\n    → Decision: 是否 start ≥ last_end? // 若當前區間左端不早於上一已保留區間的右端，則不重疊\n        Yes → Step: last_end ← interval.end // 保留此區間，更新右端\n        No  → Step: removals ← removals + 1 // 需移除此區間，計數加一\n→ Step: Return removals // 回傳最小移除數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals):\n        if not intervals:\n            return 0\n        \n        # 先按結束時間升序排序\n        intervals.sort(key=lambda x: x[1])\n        \n        # 追蹤已選區間數量\n        keep = 1\n        last_end = intervals[0][1]\n        \n        for start, end in intervals[1:]:\n            if start >= last_end:\n                # 不重疊，保留\n                keep += 1\n                last_end = end\n            # 重疊的情況不做任何改動，會被移除\n        # 需要移除的數量 = 總數 - 保留數\n        return len(intervals) - keep\n\ndef parse_input(data: str):\n    \"\"\"將 stdin 內容轉為 intervals list\"\"\"\n    data = data.strip()\n    # 若包含 'intervals =', 只取等號右邊\n    if '=' in data:\n        _, expr = data.split('=', 1)\n        data = expr.strip()\n    # eval 轉成 Python 物件\n    try:\n        return eval(data, {})\n    except Exception:\n        return []\n\ndef main():\n    raw_input = sys.stdin.read()\n    intervals = parse_input(raw_input)\n    result = Solution().eraseOverlapIntervals(intervals)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[1,2],[1,2]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "intervals = [[1,2],[2,3]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode137.json",
    "problem_index_in_file": 0,
    "title": "Single Number II",
    "description_snippet": "Given an integer array nums where every element appears three times except for one, which appears ex...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: find single number appearing once when others appear thrice. Use bitwise count mod 3 method. Steps: initialize result=0, counts[32] array? But constant space, use three accumulators: ones, twos, and maybe thrice. Actually typical solution uses bitwise: for each num: ones = (ones XOR num) & ~twos; twos = (twos XOR num) & ~ones; return ones. Provide virtual steps. Each line: description. We'll produce Start, Loop over nums, update ones, twos, maybe. At end return ones. Use decision? Not needed. We'll still adhere.\n\nLet's produce lines:\n\nStart // 程式開始\n\n→ Step 1: 初始化 ones = 0, twos = 0 // 用兩個位元寄存器追蹤一次和兩次出現的位元\n\n→ Decision: 如果 nums 為空? // 檢查輸入是否有效\n\n    Yes → End // 空陣列直接結束\n\n    No  → 進入迴圈\n\n→ Loop: for each num in nums // 遍歷陣列\n\n    → Step 2: 更新 twos = twos XOR num // 先將 num 加入 twos\n\n    → Step 3: 更新 ones = ones XOR num // 同時更新 ones\n\n    → Step 4: 令 twos = twos & ~ones // 將已經在 ones 的位元從 twos 移除\n\n    → Step 5: 令 ones = ones & ~twos // 將已經在 twos 的位元從 ones 移除\n\n    // 這樣每個位元在出現三次時會被清零\n\n→ End // 循環結束\n\n→ Step 6: 返回 ones // ones 即為唯一出現一次的數\n\nBut we need to incorporate logic in correct order: typical algorithm:\n\nfor num in nums:\n    twos |= ones & num\n    ones ^= num\n    common_mask = ~(ones & twos)\n    ones &= common_mask\n    twos &= common_mask\n\nBut simpler variant: use ones and twos as described.\n\nLet's adopt version:\n\nones = 0\ntwos = 0\nfor num in nums:\n    twos = twos ^ (ones & num)  // if bit is already in ones, add to twos\n    ones = ones ^ num\n    common_mask = ~(ones & twos)\n    ones = ones & common_mask\n    twos = twos & common_mask\n\nAt the end, ones holds unique.\n\nWe'll produce step by step. Provide explanation per line. Also may add decision for early termination if array empty. Let's produce.\n\nEnsure each line format: `虛擬碼步驟 // 解釋`. Use arrows and indentation as per example.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 ones ← 0, twos ← 0 // 用兩個寄存器追蹤出現 1 次與 2 次的位元  \n→ Decision: 若 nums 為空？ // 檢查輸入是否有效  \n    Yes → End // 空陣列直接結束，無結果  \n    No  → 進入迴圈  \n→ Loop: 對每個 num 於 nums  \n    → Step 2: twos ← twos XOR (ones AND num) // 若某位已在 ones，則加入 twos  \n    → Step 3: ones ← ones XOR num // 將 num 加入 ones  \n    → Step 4: common_mask ← NOT (ones AND twos) // 找出同時在 ones 與 twos 的位元  \n    → Step 5: ones ← ones AND common_mask // 清除同時出現的位元  \n    → Step 6: twos ← twos AND common_mask // 同上，保留只在 twos 的位元  \n    // 這樣每個位元在出現三次時會被清零，僅剩唯一元素的位元留在 ones  \n→ End // 迴圈結束  \n→ Step 7: 返回 ones // ones 即為唯一出現一次的數字  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef single_number(nums):\n    \"\"\"Return the element that appears once when all others appear three times.\"\"\"\n    ones = twos = 0\n    for num in nums:\n        # Update ones first, then twos using the new value of ones\n        ones = (ones ^ num) & ~twos\n        twos = (twos ^ num) & ~ones\n    return ones\n\nif __name__ == \"__main__\":\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit(0)\n\n    # Attempt to extract a list literal from the input string\n    try:\n        start = raw.index('[')\n        end = raw.rindex(']')\n        list_str = raw[start:end + 1]\n        nums = ast.literal_eval(list_str)\n    except (ValueError, SyntaxError):\n        # Fallback: try to parse the whole input as a list\n        try:\n            nums = ast.literal_eval(raw)\n        except Exception:\n            nums = []\n\n    result = single_number(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "success": true,
          "output": "99"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode478.json",
    "problem_index_in_file": 0,
    "title": "Generate Random Point in a Circle",
    "description_snippet": "Given the radius and the position of the center of a circle, implement the function randPoint which ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce pseudo-code step by step, using the specified format. Provide lines like \"Start // 程式開始執行\" etc. The requirement: Implement the Solution class with constructor and randPoint method. Provide algorithm: generate random point inside circle uniformly: we can generate random radius r from 0 to radius with sqrt distribution: r = radius * sqrt(rand()), random angle theta uniform [0, 2π). Then x = x_center + r * cos(theta), y = y_center + r * sin(theta). Or use rejection sampling. Provide pseudocode accordingly. Need to output line by line with arrow and decision statements. Should show class definition, constructor, method, random generation steps.\n\nLet's structure:\n\nStart\n→ Step 1: Define class Solution\n→ Step 2: Constructor with radius, x_center, y_center // store values\n→ Step 3: randPoint method\n    → Step 4: Generate random angle theta uniformly in [0, 2π)\n    → Step 5: Generate random radial distance r using sqrt(random()) * radius // ensures uniform distribution\n    → Step 6: Compute x = x_center + r * cos(theta)\n    → Step 7: Compute y = y_center + r * sin(theta)\n    → Step 8: Return [x, y]\nEnd\n\nInclude Decision? Not necessary but can show maybe random. But spec says use Decision and arrow. We can incorporate decision for random generator? Not needed. Provide pseudo-code with arrow. We'll just use steps.\n\nLet's output with format lines: \"虛擬碼步驟 // 解釋/說明\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立包含半徑與圓心座標的物件  \n→ Step 2: Constructor(radius, x_center, y_center) // 取得半徑與圓心座標並儲存  \n→ Step 3: 方法 randPoint() // 產生一個隨機點  \n  → Step 4: theta ← Random() * 2π // 產生均勻分布的角度 [0, 2π)  \n  → Step 5: u ← Random() // 產生均勻分布的隨機數 [0, 1)  \n  → Step 6: r ← radius * sqrt(u) // 用 sqrt 取得均勻分布的半徑  \n  → Step 7: x ← x_center + r * cos(theta) // 計算 x 座標  \n  → Step 8: y ← y_center + r * sin(theta) // 計算 y 座標  \n  → Step 9: 返回 [x, y] // 回傳隨機點  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 均勻生成半徑（使用 sqrt 保證均勻分佈）\n        r = self.radius * math.sqrt(random.random())\n        # 隨機角度 [0, 2π)\n        theta = random.uniform(0, 2 * math.pi)\n        # 轉換回直角座標\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        return\n    methods = json.loads(data[0])      # 例: [\"Solution\", \"randPoint\", ...]\n    args_list = json.loads(data[1])    # 例: [[1.0, 0.0, 0.0], [], ...]\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)          # 建構子不回傳任何值\n        else:\n            func = getattr(obj, method)\n            results.append(func())\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.630835903689705,0.5840531498859491],[0.5769737488401133,0.49421223637398815],[-0.5255685815823914,-0.6783440833167521]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.630835903689705, 0.5840531498859491], [0.5769737488401133, 0.49421223637398815], [-0.5255685815823914, -0.6783440833167521]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode77.json",
    "problem_index_in_file": 0,
    "title": "Combinations",
    "description_snippet": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step, each line with virtual code step and comment, using arrow symbols. The problem: \"Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\" So we need to produce virtual code for generating combinations, typical backtracking. We need step by step: Start, Step: initialize result, Step: define backtrack function, etc.\n\nWe must include lines like: Start // program starts.\n\nWe need to maintain structure: Start, → Step: declare variables, etc. Use Decision: for recursion base, etc. Use arrows for backtracking loops. Use \"→\" arrow after each step. Use indent for nested decisions. Should be clear.\n\nWe cannot output actual code. So we need pseudocode. Provide each line as \"虛擬碼步驟 // 解釋\". Must use Start and End markers. The lines: \"Start // 程式開始執行\". Then \"→ Step 1: ...\".\n\nWe should include arrow from Start to Step 1: \"Start // 程式開始執行\" and then \"→ Step 1: 初始化結果容器 results = [] // 用來儲存所有組合\". Then \"→ Step 2: 定義遞迴函式 backtrack(start, path) // start 為下一個可選數字, path 為目前組合\". Then within backtrack, a Decision: \"Decision: 如果 path 長度 == k?\" then Yes -> add to results; No -> loop for i from start to n. Indent inside for. For each i: \"→ Step 3: 將 i 加入 path\" then call backtrack(i+1, path) then \"→ Step 4: 移除 i 從 path // 回溯\". After loop ends, return. Then after backtrack defined, call backtrack(1, []). Then \"→ Step 5: 回傳 results\". End.\n\nWe need to provide each line with arrow and comment. For indentation of Decision: we need to use the \"Decision:\" line and nested Yes/No arrows. The example uses \"Decision:\" with indent. We should use \"Decision: if path length == k?\" and then \"Yes → Step ...\" and \"No → ...\".\n\nThe for loop inside decision can be represented as \"→ Step 3: 將 i 加入 path\" etc.\n\nLet's produce final. Use proper Chinese comments. Ensure each line ends with \" // 解釋/說明\". Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化結果容器 results = [] // 用來儲存所有組合  \n→ Step 2: 定義遞迴函式 backtrack(start, path) // start 為下一個可選數字, path 為目前組合  \n→ Decision: 如果 path 長度 == k? // 判斷是否已選滿 k 個數字  \n  Yes → Step 3: 複製 path 並加入 results // 取得一個完整組合  \n  No  → Decision: 循環 i 從 start 到 n? // 從可選數字中選下一個  \n    Yes → Step 4: 將 i 加入 path // 選擇當前數字  \n    Yes → Step 5: 呼叫 backtrack(i+1, path) // 進行下一層遞迴  \n    Yes → Step 6: 從 path 移除 i // 回溯，準備選擇下一個數字  \n    No  → End // i 已超過 n，結束循環  \n→ Step 7: 呼叫 backtrack(1, []) // 從 1 開始建立組合  \n→ Step 8: 回傳 results // 傳回所有符合條件的組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def combine(self, n: int, k: int):\n        res = []\n\n        def backtrack(start, path):\n            if len(path) == k:\n                res.append(path[:])\n                return\n            for i in range(start, n + 1):\n                path.append(i)\n                backtrack(i + 1, path)\n                path.pop()\n\n        backtrack(1, [])\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 從輸入中擷取所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        print(\"[]\")\n        sys.exit(0)\n\n    n, k = nums[0], nums[1]\n    solution = Solution()\n    result = solution.combine(n, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4, k = 2",
          "expected_output": "[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]",
          "success": true,
          "output": "[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
        },
        {
          "example_index": 1,
          "input": "n = 1, k = 1",
          "expected_output": "[[1]]",
          "success": true,
          "output": "[[1]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode365.json",
    "problem_index_in_file": 0,
    "title": "Water and Jug Problem",
    "description_snippet": "You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Ret...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, following format. Provide explanation after space and //. Use Start, End, Decision etc.\n\nWe need to outline algorithm: using BFS or gcd condition. But simpler: use GCD: target <= x+y and target % gcd(x,y)==0. So we can just compute. Steps: read x,y,target. Compute sum; if target>sum → false. Compute gcd. If target%gcd==0 → true else false. End. Provide virtual code. Let's produce steps:\n\nStart\n→ Step 1: 讀取 x, y, target // 取得兩個水壺容量和目標容量\n→ Step 2: 計算總容量 sum = x + y // 兩個水壺可容納的最大水量\n→ Decision: 如果 target > sum? // 檢查目標是否超過最大可用水量\n    Yes → Step 3: 回傳 False // 超過就不可能達到\n    No  → Step 4: 計算 g = GCD(x, y) // 兩個容量的最大公因數\n→ Step 5: Decision: 如果 target mod g == 0? // 目標是否能被 GCD 整除\n    Yes → Step 6: 回傳 True // 可達到目標\n    No  → Step 7: 回傳 False // 不能達到\nEnd\n\nAlso maybe include subroutine GCD. Provide steps. Let's produce virtual code with arrow \"→\" and decisions \"Yes →\", \"No →\". We'll follow example.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取 x, y, target // 取得兩個水壺容量與目標水量  \n→ Step 2: 計算 sum = x + y // 兩個水壺可容納的最大水量  \n→ Decision: target > sum? // 檢查目標是否超過最大可用水量  \n    Yes → Step 3: 回傳 False // 超過就不可能達到  \n    No → Step 4: 計算 g = GCD(x, y) // 求兩個容量的最大公因數  \n→ Step 5: Decision: target mod g == 0? // 目標是否能被 GCD 整除  \n    Yes → Step 6: 回傳 True // 可達到目標  \n    No → Step 7: 回傳 False // 不能達到  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def canMeasureWater(self, x: int, y: int, target: int) -> bool:\n        # 計算兩個數的最大公因數\n        def gcd(a: int, b: int) -> int:\n            while b:\n                a, b = b, a % b\n            return a\n\n        # 目標水量若超過兩個水壺總容量，直接不可能\n        if target > x + y:\n            return False\n        # 若目標水量能被最大公因數整除，則可達到\n        return target % gcd(x, y) == 0\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料，並以正則表達式抓取所有整數\n    data = sys.stdin.read()\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) >= 3:\n        x, y, target = nums[0], nums[1], nums[2]\n    else:\n        # 若輸入格式不符，直接輸出 false\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.canMeasureWater(x, y, target)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 3, y = 5, target = 4",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "x = 2, y = 6, target = 5",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "x = 1, y = 2, target = 3",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode5.json",
    "problem_index_in_file": 0,
    "title": "Longest Palindromic Substring",
    "description_snippet": "Given a string s, return the longest palindromic substring in s....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line, no actual code. Use arrow notation. Provide explanation comments. For given problem: find longest palindromic substring.\n\nWe should describe algorithm: expand around center, or DP. Simpler: expand around each center, O(n^2). Provide steps: Start, Input string s, Initialize variables longestStart, longestLen. For i in 0..len-1: ExpandOdd(i), ExpandEven(i). Keep track. After loop, return substring. End.\n\nWe need to output each line with virtual code step + explanation. Use arrows \"→\". Indent decisions. Let's produce maybe something like:\n\nStart // 程式開始\n→ Input s // 取得輸入字串\n→ Set longestStart = 0 // 最長回文起始位置\n→ Set longestLen = 1 // 最長回文長度\n→ Decision: If s is empty? // 檢查字串是否為空\n    Yes → Return \"\" // 空字串直接回傳\n    No  → (繼續)\n→ For i = 0 to s.length - 1 // 遍歷每個字符作為中心\n    → Call expandAroundCenter(i, i) // 奇數長度回文\n    → Call expandAroundCenter(i, i+1) // 偶數長度回文\n→ Function expandAroundCenter(left, right)\n    → While left >= 0 AND right < s.length AND s[left] == s[right]\n        → left--\n        → right++\n    → After loop: right - left - 1 // 取得回文長度\n    → If currentLen > longestLen\n        → Update longestStart = left + 1\n        → Update longestLen = currentLen\n→ After loop: Return s.substring(longestStart, longestStart + longestLen) // 取得最長回文子字串\nEnd // 程式結束\n\nBut need each line in format: `虛擬碼步驟 // 解釋`. For functions we can show lines accordingly. Indentation maybe.\n\nLet's produce a step-by-step. Ensure each line ends with comment after //.\n\nWe can present code block with line numbers? Not required.\n\nLet's output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Input s // 取得使用者輸入的字串\n→ Set longestStart = 0 // 初始化最長回文子字串的起始位置\n→ Set longestLen = 1 // 初始化最長回文子字串的長度\n→ Decision: s 為空? // 檢查字串是否為空\n    Yes → Return \"\" // 若空字串，直接回傳空字串\n    No  → （繼續執行）\n→ For i = 0 to s.length - 1 // 逐一把每個字元視為中心\n    → Call expandAroundCenter(i, i) // 奇數長度回文擴展\n    → Call expandAroundCenter(i, i+1) // 偶數長度回文擴展\n→ Function expandAroundCenter(left, right) // 定義擴展中心的函式\n    → While left >= 0 AND right < s.length AND s[left] == s[right] // 對稱擴展直到不相等\n        → left-- // 向左移動指標\n        → right++ // 向右移動指標\n    → Set currentLen = right - left - 1 // 計算得到的回文長度\n    → Decision: currentLen > longestLen? // 判斷是否更新最長回文\n        Yes → Set longestStart = left + 1 // 更新起始位置\n             → Set longestLen = currentLen // 更新長度\n        No  → （不更新）\n→ Return s.substring(longestStart, longestStart + longestLen) // 取得並回傳最長回文子字串\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \"\"\"\n        Find the longest palindromic substring in s.\n        Uses expand‑around‑center technique (O(n^2) time, O(1) extra space).\n        \"\"\"\n        if not s:\n            return \"\"\n\n        longest_start, longest_len = 0, 1\n\n        def expand(left: int, right: int) -> None:\n            nonlocal longest_start, longest_len\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            cur_len = right - left - 1\n            if cur_len > longest_len:\n                longest_start = left + 1\n                longest_len = cur_len\n\n        for i in range(len(s)):\n            # odd length palindrome (center at i)\n            expand(i, i)\n            # even length palindrome (center between i and i+1)\n            expand(i, i + 1)\n\n        return s[longest_start:longest_start + longest_len]\n\n\ndef main():\n    # 讀取輸入，格式假設為「s = 'xxxx'」或僅字串\n    line = sys.stdin.readline().strip()\n    if \"'\" in line:\n        first = line.find(\"'\")\n        last = line.rfind(\"'\")\n        s = line[first + 1:last]\n    else:\n        s = line\n\n    solution = Solution()\n    result = solution.longestPalindrome(s)\n    # 將結果以單引號包住輸出，符合範例\n    print(f\"'{result}'\")\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = 'babad'",
          "expected_output": "'bab'",
          "success": true,
          "output": "'bab'"
        },
        {
          "example_index": 1,
          "input": "s = 'cbbd'",
          "expected_output": "'bb'",
          "success": true,
          "output": "'bb'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode454.json",
    "problem_index_in_file": 0,
    "title": "4Sum II",
    "description_snippet": "Given four integer arrays A, B, C, and D all of length n, return the number of tuples (i, j, k, l) s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem is 4Sum II. Approach: compute sums of A and B pairs, store counts in hash map. Then for each pair of C and D, check negative sum in map. Count total. Complexity O(n^2). We'll output step-by-step.\n\nNeed Start, End. For loops: we need loops over i, j, k, l. Use decisions.\n\nLet's craft steps:\n\nStart\n\n→ Step 1: Initialize hash map sumCount // store sum of A[i]+B[j] counts\n\n→ Step 2: For i from 0 to n-1 // iterate over array A\n\n   → Step 3: For j from 0 to n-1 // iterate over array B\n\n       → Step 4: Compute sumAB = A[i] + B[j] // sum of A and B\n\n       → Step 5: Update sumCount[sumAB] += 1 // increment count\n\n→ Step 6: Initialize result = 0 // total tuples\n\n→ Step 7: For k from 0 to n-1 // iterate over array C\n\n   → Step 8: For l from 0 to n-1 // iterate over array D\n\n       → Step 9: Compute sumCD = C[k] + D[l] // sum of C and D\n\n       → Step 10: If sumCount contains key -sumCD\n\n           Yes → Step 11: result += sumCount[-sumCD] // add matching pairs\n\n→ Step 12: Return result // output number\n\nEnd\n\nBut need to add explanations. Use the arrow format. Each line with // explanation. Use Decision with Yes →.\n\nAlso include \"Decision:\" lines.\n\nLet's produce.\n\nNeed to be careful with formatting: Use \"→\" for steps, \"Decision:\" for if. Provide explanation after space.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 hashMap sumCount // 用來存 A[i]+B[j] 的出現次數\n→ Step 2: 迴圈 i = 0 到 n-1 // 逐一遍歷陣列 A\n    → Step 3: 迴圈 j = 0 到 n-1 // 逐一遍歷陣列 B\n        → Step 4: 計算 sumAB = A[i] + B[j] // A 與 B 的兩數之和\n        → Step 5: 若 sumCount 中已存在 sumAB, sumCount[sumAB] += 1, 否則 sumCount[sumAB] = 1 // 更新出現次數\n→ Step 6: 初始化 result = 0 // 儲存符合條件的四元組數量\n→ Step 7: 迴圈 k = 0 到 n-1 // 逐一遍歷陣列 C\n    → Step 8: 迴圈 l = 0 到 n-1 // 逐一遍歷陣列 D\n        → Step 9: 計算 sumCD = C[k] + D[l] // C 與 D 的兩數之和\n        → Decision: 若 sumCount 中存在 -sumCD? // 判斷是否有對應的 A+B 之和能抵消\n            Yes → Step 10: result += sumCount[-sumCD] // 加入所有符合的 A+B 配對數量\n            No  → // 沒有匹配，跳過\n→ Step 11: Return result // 回傳總數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\nclass Solution:\n    def fourSumCount(self, A, B, C, D):\n        # Count all possible sums of elements from A and B\n        ab_counts = Counter(a + b for a in A for b in B)\n        total = 0\n        # For each pair from C and D, check if its negation exists in ab_counts\n        for c in C:\n            for d in D:\n                total += ab_counts.get(-(c + d), 0)\n        return total\n\ndef parse_input(input_str: str):\n    # 找出所有的列表字串\n    lists = re.findall(r'\\[.*?\\]', input_str)\n    if len(lists) < 4:\n        raise ValueError(\"輸入格式錯誤，無法找到四個列表\")\n    A = ast.literal_eval(lists[0])\n    B = ast.literal_eval(lists[1])\n    C = ast.literal_eval(lists[2])\n    D = ast.literal_eval(lists[3])\n    return A, B, C, D\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read()\n    A, B, C, D = parse_input(raw_input)\n    sol = Solution()\n    result = sol.fourSumCount(A, B, C, D)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "A = [1,2], B = [-2,-1], C = [-1,2], D = [0,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "A = [0], B = [0], C = [0], D = [0]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode50.json",
    "problem_index_in_file": 0,
    "title": "Pow(x, n)",
    "description_snippet": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n)....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for pow(x, n). We should provide steps: handle negative exponent, handle exponent zero, iterative exponentiation by squaring or recursive. Use virtual code style: Start, →, Decision: etc. Provide brief explanation after each line. Avoid actual code.\n\nNeed to include negative exponent: compute 1 / pow(x, -n). For zero exponent: return 1. Use iterative multiplication maybe with loop. Or use exponentiation by squaring.\n\nI'll produce something like:\n\nStart\n→ Step 1: Read x and n\n→ Decision: 如果 n < 0? \n    Yes → Step 2: Set n = -n ; Set sign = -1? Actually for negative exponent, result = 1 / pow(x, n)\n    No  → Step 3: Continue\n\nBut we need virtual steps. For negative exponent: we can treat by computing result = 1 / compute pow(x, -n). Use recursion? Simpler: treat sign.\n\nI'll write:\n\nStart // 開始執行\n→ Step 1: 取得 x, n // 取得底數和指數\n→ Decision: n 是否為 0? // 檢查指數是否為 0\n    Yes → Step 2: 輸出 1 // x^0 = 1\n    No  → Decision: n 是否為負? // 檢查指數是否為負\n        Yes → Step 3: 設定 n = -n ; 計算 reciprocal = 1 / (x^n) // 將負指數轉為正再求倒數\n            → Step 4: 輸出 reciprocal // 輸出結果\n        No  → Step 5: 設定 result = 1 ; 計算 base = x ; cnt = n // 初始化乘法變數\n            → Decision: cnt > 0? // 迴圈條件\n                Yes → Step 6: result = result * base ; cnt = cnt - 1 // 累積乘法\n                No  → Step 7: 輸出 result // 完成，輸出結果\nEnd // 結束\n\nBut this is not using exponentiation by squaring, but simpler. Provide steps.\n\nAlso show iterative exponentiation by squaring:\n\n→ Decision: cnt % 2 == 1? // 若指數為奇數\n    Yes → result = result * base\n→ base = base * base\n→ cnt = cnt / 2\n\nBut we can incorporate.\n\nI'll produce a structured pseudocode. Provide each step. Ensure each line has a comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 x, n // 從使用者或函式呼叫取得底數與指數  \n→ Decision: n 是否為 0? // 檢查是否為特殊情況  \n  Yes → Step 2: 輸出 1 // 任何數的 0 次方為 1  \n  No  → Decision: n 是否為負? // 判斷指數是否為負數  \n    Yes → Step 3: 設定 n = -n ; 計算 reciprocal = 1 / pow(x, n) // 將負指數轉成正並取倒數  \n     → Step 4: 輸出 reciprocal // 輸出最終結果  \n    No  → Step 5: 設定 result = 1 ; base = x ; cnt = n // 初始化乘法累積變數  \n     → Decision: cnt > 0? // 進入迴圈，累乘直至指數為 0  \n       Yes → Step 6: result = result * base ; cnt = cnt - 1 // 每一步累乘一次  \n       No  → Step 7: 輸出 result // 迴圈結束，輸出計算結果  \nEnd // 程式執行結束\n\n---  \n\n**改進版：使用快速冪（指數平方）**\n\nStart // 程式開始執行  \n→ Step 1: 取得 x, n // 取得底數與指數  \n→ Decision: n 是否為 0?  \n  Yes → Step 2: 輸出 1  \n  No  → Decision: n 是否為負?  \n    Yes → Step 3: 設定 n = -n ; 計算 reciprocal = 1 / pow(x, n)  \n     → Step 4: 輸出 reciprocal  \n    No  → Step 5: 設定 result = 1 ; base = x ; cnt = n // 初始化  \n     → Decision: cnt > 0?  \n       Yes → Step 6: Decision: cnt 為奇數?  \n        Yes → result = result * base // 若奇數，乘一次  \n        No  → // 跳過  \n        base = base * base ; cnt = cnt / 2 // 平方底數，除以 2  \n        → 回到 Decision: cnt > 0?  \n       No  → Step 7: 輸出 result // 完成計算  \nEnd // 程式結束\n\n---  \n\n以上虛擬碼展示了從基礎的迴圈累乘到更高效的快速冪（指數平方）兩種實作方式。每行都附有簡短直觀的解釋。",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        # Handle zero exponent\n        if n == 0:\n            return 1.0\n        # Handle negative exponent by inverting base and making exponent positive\n        if n < 0:\n            x = 1.0 / x\n            n = -n\n\n        # Fast exponentiation using recursion\n        def fast_pow(base: float, exp: int) -> float:\n            if exp == 0:\n                return 1.0\n            half = fast_pow(base, exp // 2)\n            if exp % 2 == 0:\n                return half * half\n            else:\n                return half * half * base\n\n        return fast_pow(x, n)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 找出所有數字（浮點或整數），忽略文字\n    nums = re.findall(r'-?\\d+\\.?\\d*', data)\n    if len(nums) < 2:\n        return\n    x = float(nums[0])\n    # 可能輸入的 n 以浮點形式出現，例如 \"10.0\"，轉成 int\n    n = int(float(nums[1]))\n\n    solver = Solution()\n    result = solver.myPow(x, n)\n    # 按題目要求輸出五位小數\n    print(f\"{result:.5f}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 2.00000, n = 10",
          "expected_output": "1024.00000",
          "success": true,
          "output": "1024.00000"
        },
        {
          "example_index": 1,
          "input": "x = 2.10000, n = 3",
          "expected_output": "9.26100",
          "success": true,
          "output": "9.26100"
        },
        {
          "example_index": 2,
          "input": "x = 2.00000, n = -2",
          "expected_output": "0.25000",
          "success": true,
          "output": "0.25000"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode8.json",
    "problem_index_in_file": 0,
    "title": "String to Integer (atoi)",
    "description_snippet": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer.\n\nThe al...",
    "examples_loaded": 5,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line, following format. Each line: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Provide algorithm.\n\nLet's outline steps:\n\nStart\n→ Step 1: 初始化 index = 0, n = length(s)\n→ Step 2: Skip leading whitespace: while index < n and s[index] == ' ': index++\n→ Step 3: Determine sign: sign = 1; if index < n and (s[index] == '+' or '-'): if s[index]=='-': sign = -1; index++\n→ Step 4: Parse digits: result = 0; digitsRead = false; while index < n and isdigit(s[index]): digitsRead=true; digit = s[index]-'0'; // before overflow check\n    → Decision: result * 10 + digit overflows 32-bit signed? (need to compare)\nWe can do overflow check by using 64-bit or compare with max/10 etc.\n\nBut virtual code: we can use Decision: if result > INT_MAX/10 or (result == INT_MAX/10 and digit > 7) then overflow.\n\nBut for negative, similar.\n\nSimplify: use long long temp = result * 10 + digit; if sign==1 and temp > INT_MAX then result=INT_MAX; break; if sign==-1 and -temp < INT_MIN then result= -INT_MIN? Wait negative min is -2147483648; sign * temp < INT_MIN.\n\nLet's produce generic overflow check: if sign == 1 and result > (INT_MAX - digit)/10 then overflow; else if sign == -1 and result > (INT_MAX - digit)/10? For negative, we need to consider negative range. For simplicity: compute temp = result * 10 + digit; if sign==1 and temp > INT_MAX then overflow; if sign==-1 and -temp < INT_MIN then overflow. Use long long.\n\nAfter overflow: set result = sign==1? INT_MAX : INT_MIN; break;\n\nAfter loop: if !digitsRead: return 0;\n\nReturn sign*result.\n\nEdge: rounding.\n\nLet's produce virtual code lines accordingly.\n\nNeed to include decisions with Yes/No arrows.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: index ← 0, n ← length(s) // 設定索引與字串長度\n→ Step 2: while index < n and s[index] = ' ' do index ← index + 1 // 跳過前導空白\n→ Step 3: sign ← 1 // 預設正號\n→ Decision: index < n and (s[index] = '+' or s[index] = '-')? // 判斷符號\n    Yes → Step 4: if s[index] = '-' then sign ← -1 // 取得符號\n              index ← index + 1 // 移至下一位\n    No  → // 沒有符號，保持正號\n→ Step 5: result ← 0 // 初始化整數累積\n→ Step 6: digitsRead ← false // 追蹤是否讀到任何數字\n→ Step 7: while index < n and isDigit(s[index]) do\n        → digitsRead ← true // 已讀到數字\n        → digit ← s[index] - '0' // 取得數字值\n        → temp ← result * 10 + digit // 暫存計算結果（使用長整型避免即時溢出）\n        → Decision: sign = 1 and temp > INT_MAX? // 檢查正數溢出\n            Yes → result ← INT_MAX // 依規則四捨五入至上限\n                  break // 跳出迴圈\n            No  →\n                Decision: sign = -1 and -temp < INT_MIN? // 檢查負數溢出\n                    Yes → result ← -INT_MIN // 依規則四捨五入至下限\n                          break // 跳出迴圈\n                    No  →\n                        → result ← temp // 正常累積\n        → index ← index + 1 // 移至下一位\n→ Decision: digitsRead = false? // 未讀到任何數字\n    Yes → Return 0 // 沒有有效數字，結果為 0\n    No  →\n        → Return sign * result // 返回帶符號的整數結果\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def myAtoi(self, s: str) -> int:\n        \"\"\"\n        Convert a string to a 32-bit signed integer following the LeetCode\n        myAtoi specification.\n        \"\"\"\n        # 1. 先移除前導空白\n        s = s.lstrip()\n        if not s:\n            return 0\n\n        # 2. 判斷符號\n        sign = 1\n        idx = 0\n        if s[0] == '+':\n            idx += 1\n        elif s[0] == '-':\n            sign = -1\n            idx += 1\n\n        # 3. 解析數字\n        result = 0\n        digits_read = False\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        while idx < len(s) and s[idx].isdigit():\n            digits_read = True\n            digit = int(s[idx])\n\n            # 檢查是否會溢出\n            if sign == 1 and result > (INT_MAX - digit) // 10:\n                return INT_MAX\n            if sign == -1 and result > (INT_MAX - digit) // 10:\n                return INT_MIN\n\n            result = result * 10 + digit\n            idx += 1\n\n        if not digits_read:\n            return 0\n\n        result *= sign\n        return result\n\nif __name__ == \"__main__\":\n    # 讀取整行輸入，可能是形式 like s = \"42\"\n    raw_input = sys.stdin.read().strip()\n\n    # 嘗試從雙引號中擷取字串\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = raw_input[first_quote + 1:last_quote]\n    else:\n        # 若沒有雙引號，直接使用整行\n        s = raw_input.strip('\"')\n\n    solution = Solution()\n    result = solution.myAtoi(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"42\"",
          "expected_output": "42",
          "success": true,
          "output": "42"
        },
        {
          "example_index": 1,
          "input": "s = \" -042\"",
          "expected_output": "-42",
          "success": true,
          "output": "-42"
        },
        {
          "example_index": 2,
          "input": "s = \"1337c0d3\"",
          "expected_output": "1337",
          "success": true,
          "output": "1337"
        },
        {
          "example_index": 3,
          "input": "s = \"0-1\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 4,
          "input": "s = \"words and 987\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode151.json",
    "problem_index_in_file": 0,
    "title": "Reverse Words in a String",
    "description_snippet": "Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-spa...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Need to satisfy formatting: \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow arrows, structure like Start, End, Decision, etc. For reversing words in string with trimming spaces. We'll produce algorithm:\n\nStart\n→ Step 1: 取得輸入字符串 s\n→ Step 2: 以空格分割成詞列表 words_temp，保留非空項目\n→ Decision: 若 words_temp 為空? // 如果沒有詞\n    Yes → Step 3: 輸出空字符串 // 回傳空字串\n    No → Step 4: 逆序 words_temp\n→ Step 5: 用單個空格連接逆序詞列表成 result\n→ Step 6: 輸出 result\nEnd\n\nAlso need to handle trimming leading/trailing, multiple spaces. The splitting method: iterate through characters to extract words. Might detail: Step 2: 建立空列表 words, 迭代 s 逐字收集 word until space, then push. So we can include step.\n\nLet's craft virtual code lines:\n\nStart // 程式開始\n→ Step 1: 初始化 words 為空列表，current_word 為空字符串 // 準備儲存單詞\n→ Step 2: 對 s 的每個字符 c 進行迭代 // 遍歷輸入字串\n    Decision: 如果 c 為空格? // 判斷是否為單詞分隔符\n        Yes → Decision: 如果 current_word 不為空? // 有累積到一個單詞\n            Yes → Step 3: 把 current_word 加入 words，重置 current_word 為空 // 存儲單詞\n            No  → // 空格但未累積單詞，直接忽略\n        No  → Step 4: 把 c 加到 current_word // 繼續構造單詞\n→ Decision: 迴圈結束後，是否還有未加入 words 的 current_word? // 檢查最後一個單詞\n    Yes → Step 5: 把 current_word 加入 words // 存儲最後單詞\n    No  → // 無需額外處理\n→ Step 6: 逆序 words 列表 // 反轉單詞順序\n→ Step 7: 用單個空格將 words 連接成 result 字串 // 生成結果\n→ Step 8: 輸出 result // 回傳\nEnd // 程式結束\n\nMake sure each line follows \"虛擬碼步驟 [space] // 解釋/說明\". Also indent for nested decision branches? The example uses indentation. We'll produce similar indentation.\n\nLet's write lines accordingly. Use Start and End.\n\nBe careful to keep consistent arrow and indentation. Use \"Decision:\" for decision. Use \"Yes →\" \"No →\" for branches. Indentation spaces. Should we include multiple lines? Each line includes code and comment. We'll produce like:\n\nStart // 程式開始\n→ Step 1: 初始化 words 為空列表，current_word 為空字符串 // 準備儲存單詞\n→ Step 2: 對 s 的每個字符 c 進行迭代 // 遍歷輸入字串\n    Decision: 如果 c 為空格? // 判斷是否為單詞分隔符\n        Yes → Decision: 如果 current_word 不為空? // 有累積到一個單詞\n            Yes → Step 3: 把 current_word 加入 words，重置 current_word 為空 // 存儲單詞\n            No  → // 空格但未累積單詞，直接忽略\n        No  → Step 4: 把 c 加到 current_word // 繼續構造單詞\n→ Decision: 迴圈結束後，是否還有未加入 words 的 current_word? // 檢查最後一個單詞\n    Yes → Step 5: 把 current_word 加入 words // 存儲最後單詞\n    No  → // 無需額外處理\n→ Step 6: 逆序 words 列表 // 反轉單詞順序\n→ Step 7: 用單個空格將 words 連接成 result 字串 // 生成結果\n→ Step 8: 輸出 result // 回傳\nEnd // 程式結束\n\nCheck formatting: each line must be \"虛擬碼步驟 [space] // 解釋/說明\". The indentation lines inside decision should still have the code. For example:\n\nDecision: 如果 c 為空格? // 判斷是否為單詞分隔符\n\nBut we need \"Decision:\" line with code. Then nested lines should be indented. The arrow lines for branches.\n\nWe should maintain the structure as per example. Use \"Yes →\" \"No →\".\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 初始化 words 為空列表，current_word 為空字符串 // 準備儲存單詞  \n→ Step 2: 對 s 的每個字符 c 進行迭代 // 遍歷輸入字串  \n    Decision: 如果 c 為空格? // 判斷是否為單詞分隔符  \n        Yes → Decision: 如果 current_word 不為空? // 有累積到一個單詞  \n                Yes → Step 3: 把 current_word 加入 words，重置 current_word 為空 // 存儲單詞  \n                No → // 空格但未累積單詞，直接忽略  \n        No → Step 4: 把 c 加到 current_word // 繼續構造單詞  \n→ Decision: 迴圈結束後，是否還有未加入 words 的 current_word? // 檢查最後一個單詞  \n    Yes → Step 5: 把 current_word 加入 words // 存儲最後單詞  \n    No → // 無需額外處理  \n→ Step 6: 逆序 words 列表 // 反轉單詞順序  \n→ Step 7: 用單個空格將 words 連接成 result 字串 // 生成結果  \n→ Step 8: 輸出 result // 回傳  \nEnd // 程式結束",
      "generated_code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        \"\"\"\n        1. 先去除首尾空白字元\n        2. 以空格切割得到所有單字\n        3. 逆序後用單個空格連結回字串\n        \"\"\"\n        # split() 會自動忽略多個空白，strip() 去除首尾空白\n        words = s.strip().split()\n        # 逆序並用單空格連結\n        return ' '.join(words[::-1])\n\n\ndef main() -> None:\n    import sys\n\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    data = data.strip()\n\n    # 若輸入形式為「s = \"...\"」，先取等號後面的內容\n    if '=' in data:\n        _, val = data.split('=', 1)\n        s = val.strip()\n    else:\n        s = data\n\n    # 若字串被雙引號或單引號包住，去掉包住字元\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        s = s[1:-1]\n\n    sol = Solution()\n    result = sol.reverseWords(s)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"the sky is blue\"",
          "expected_output": "\"blue is sky the\"",
          "success": true,
          "output": "blue is sky the"
        },
        {
          "example_index": 1,
          "input": "s = \"  hello world  \"",
          "expected_output": "\"world hello\"",
          "success": true,
          "output": "world hello"
        },
        {
          "example_index": 2,
          "input": "s = \"a good   example\"",
          "expected_output": "\"example good a\"",
          "success": true,
          "output": "example good a"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode27.json",
    "problem_index_in_file": 0,
    "title": "Remove Element",
    "description_snippet": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps with explanations. It's a problem to remove all occurrences of val from array nums in-place, return k. So algorithm: two pointers: slow index to place next non-val element. Iterate over array with fast pointer i. If nums[i] != val, set nums[slow] = nums[i]; increment slow. At end return slow. Explanation each line.\n\nWe need to use Start, End, Decision, arrows. Use line by line.\n\nLet's produce:\n\nStart // start\n→ Step 1: 初始化 slow = 0 // 慢指標位置\n→ For i from 0 to nums.length-1: // 快指標遍歷\n    → Decision: nums[i] != val? // 判斷是否為非目標值\n        Yes → Step 2: nums[slow] = nums[i] // 把非目標值寫入 slow 位置\n            → Step 3: slow = slow + 1 // 移動慢指標\n        No  → // 如果是目標值，跳過\nEnd // 回傳 slow 作為 k\n\nBut they want step numbers maybe. Use Step labels. Use arrows: →.\n\nWe need to ensure each line includes virtual code step and explanation comment. For loops maybe use \"Loop\" step.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: slow ← 0 // 初始化慢指標，代表已處理的非 val 元素數量\n→ Loop i from 0 to nums.length - 1 // 快速遍歷整個陣列\n    → Decision: nums[i] ≠ val? // 判斷目前元素是否不是要移除的值\n        Yes → Step 2: nums[slow] ← nums[i] // 將非 val 元素寫入 slow 位置\n            → Step 3: slow ← slow + 1 // 進一步移動慢指標\n        No  → // 如果是 val，直接跳過，慢指標不動\nEnd // 回傳 slow 作為剩餘元素個數 k\n\nBut we might want to include return. So add Step 4: return slow // k\n\nLet's ensure arrows: Use \"→\" before each step. Use \"Decision:\" with indentation. Provide explanation after //.\n\nAlso they want \"Yes →\" and \"No →\" for decisions. So include:\n\nDecision: nums[i] ≠ val?\n    Yes → Step 2 ...\n    No  → Step 3 ?\n\nActually No branch does nothing. We can just comment.\n\nLet's format accordingly:\n\nStart // 程式開始執行\n→ Step 1: slow ← 0 // 初始化慢指標\n→ Loop i from 0 to nums.length - 1 // 快速遍歷陣列\n    → Decision: nums[i] ≠ val? // 檢查當前元素是否非目標值\n        Yes → Step 2: nums[slow] ← nums[i] // 將非 val 元素放到慢指標位置\n            → Step 3: slow ← slow + 1 // 移動慢指標以準備下一個非 val 元素\n        No  → // 當前元素為 val，直接跳過\n→ Step 4: return slow // 回傳 k，表示前 k 個元素為非 val\nEnd // 程式結束\n\nLet's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← 0 // 初始化慢指標，代表已處理的非 val 元素數量  \n→ Loop i from 0 to nums.length - 1 // 快速遍歷整個陣列  \n&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: nums[i] ≠ val? // 判斷目前元素是否不是要移除的值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes → Step 2: nums[slow] ← nums[i] // 將非 val 元素寫入 slow 位置  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Step 3: slow ← slow + 1 // 移動慢指標，準備寫入下一個非 val 元素  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No  → // 當前元素為 val，直接跳過  \n→ Step 4: return slow // 回傳 k，表示前 k 個元素為非 val  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，並返回剩餘元素的數量 k。\n        \"\"\"\n        slow = 0  # 慢指標，指向下一個要寫入的非 val 元素位置\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    # 從 stdin 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析「nums = [...]」與「val = ...」的內容\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*val\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data)\n    if not match:\n        print(\"Invalid input format\")\n        return\n\n    nums_str = match.group(1)\n    val_str = match.group(2)\n\n    # 轉成 Python 物件\n    try:\n        nums = eval(nums_str, {\"__builtins__\": None}, {})\n    except Exception as e:\n        print(f\"Error parsing nums: {e}\")\n        return\n    val = int(val_str)\n\n    # 執行解法\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 將剩餘元素與未使用的位置以 '_' 表示，保持原始長度\n    output_list = [str(nums[i]) if i < k else '_' for i in range(len(nums))]\n    print(f\"{k}, nums = [{', '.join(output_list)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "success": true,
          "output": "2, nums = [2, 2, _, _]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,3,0,4,_,_,_]",
          "success": true,
          "output": "5, nums = [0, 1, 3, 0, 4, _, _, _]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode357.json",
    "problem_index_in_file": 0,
    "title": "Count Numbers with Unique Digits",
    "description_snippet": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanations. It's a problem: Count numbers with unique digits up to 10^n. This is LeetCode 357. Approach: use DP: For n=0 return 1. For n>0, count = 1 + sum_{i=1 to n} 9 * P(9,i-1). We need to generate steps: Start, input n, decision for n==0, compute result. Use loops to compute permutations. Provide steps. Must not output actual code, only virtual code. Use arrow syntax. Provide each line.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Input: n // 取得輸入整數 n\n→ Decision: 是否 n == 0? // 檢查是否為 0\n    Yes → Output 1 // 只有 0 這一個數\n    No  → Begin 計算\n\nNow we need to compute count. Steps: initialize result=1 for 0. Use factorial/permutation.\n\nWe can do:\n\n→ Step 1: result ← 1 // 包含數字 0\n→ Step 2: perm ← 9 // 第一個非零數字的選擇\n→ Step 3: count ← 9 // 第一位非零數字的組合數\n→ Decision: i from 2 to n? // 迴圈從 2 到 n\n    Yes → Step 4: perm ← perm × (10 - i) // 更新可選的數字數\n           → Step 5: count ← count + 9 × perm // 加上當前位數組合\n           → Go back to Decision\n    No  → Output result + count // 加總並輸出\n\nBut need to reflect DP.\n\nAlternatively: result=1; for i in 1..n: result += 9 * perm; perm *= (10-i).\n\nBut careful: For i=1: perm=9? We can set perm=9 initially? Actually for i=1: perm=9 (9 options for first digit). Then result += 9*perm? That would be 81 double. So better: Use perm=9, result=1. For i from 1 to n: result += 9*perm; perm *= (10 - i). That works: For i=1: result += 9*9 =81; perm *= 9 => 81. For i=2: result +=9*81=729; perm*=8 => 648. etc. At end result is sum.\n\nThus algorithm.\n\nLet's produce virtual code:\n\nStart\n→ Input n\n→ Decision: n == 0?\n    Yes → Output 1\n    No  → Begin\n        → result ← 1 // 包含 0\n        → perm ← 9 // 第一個非零位的選擇數\n        → i ← 1 // 目前處理的位數\n        → Decision: i <= n?\n            Yes → result ← result + 9 × perm // 加入當前位數的組合\n                → perm ← perm × (10 - i) // 更新剩餘可選數字\n                → i ← i + 1 // 進到下一位\n                → Go back to Decision\n            No  → Output result // 回傳總數\nEnd\n\nBut we need to produce arrow lines. Use \"→\" each step.\n\nLet's format:\n\nStart // 程式開始執行\n→ Input n // 取得使用者輸入的 n\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Output 1 // 只有 0 這一個數\n    No  → Begin // 開始計算\n\nNow inside begin: we need to set variables and loop. We'll produce separate lines.\n\nLet's ensure we use \"Decision:\" only once for loop. Use nested decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Input n // 取得使用者輸入的 n\n→ Decision: n == 0? // 檢查是否為 0\n    Yes → Output 1 // 只有 0 這一個數\n    No  → // 開始計算\n        → result ← 1 // 包含數字 0\n        → perm ← 9 // 第一個非零數字的選擇數\n        → i ← 1 // 目前處理的位數\n        → Decision: i <= n? // 是否還有位數要處理\n            Yes → result ← result + 9 × perm // 加上當前位數的組合\n                → perm ← perm × (10 - i) // 更新剩餘可選數字\n                → i ← i + 1 // 進到下一位\n                → Go back to Decision\n            No  → Output result // 回傳總數\nEnd // 程式執行結束\n\nBut \"Go back to Decision\" is not a step; we can just show that after i++ we go back to Decision. In pseudocode, we can just loop. Let's produce lines with indentation? The specification doesn't mention indentation but we can use indentation for readability. Use spaces.\n\nWe must not output actual code, only virtual code with arrows. Use \"→\" each line. Provide explanation after //.\n\nAlso \"Decision:\" lines should be followed by Yes → and No → lines. We can use indentation.\n\nLet's craft final output accordingly.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input n // 取得使用者輸入的 n  \n→ Decision: n == 0? // 檢查是否為 0  \n  Yes → Output 1 // 只有 0 這一個數  \n  No  → // 開始計算  \n    → result ← 1 // 包含數字 0  \n    → perm ← 9 // 第一個非零數字的選擇數  \n    → i ← 1 // 目前處理的位數  \n    → Decision: i <= n? // 是否還有位數要處理  \n      Yes → result ← result + 9 × perm // 加上當前位數的組合  \n       → perm ← perm × (10 - i) // 更新剩餘可選數字  \n       → i ← i + 1 // 進到下一位  \n       → Go back to Decision // 重新判斷是否繼續  \n      No  → Output result // 回傳總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef count_unique_numbers(n: int) -> int:\n    \"\"\"\n    Return the count of all numbers with unique digits x,\n    where 0 <= x < 10^n.\n    \"\"\"\n    if n == 0:\n        return 1          # only number 0\n    n = min(n, 10)        # more than 10 digits will repeat\n    result = 1           # include 0\n    perm = 9             # first non-zero digit choices\n    for i in range(1, n + 1):\n        result += 9 * perm\n        perm *= (10 - i)\n    return result\n\ndef main() -> None:\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    print(count_unique_numbers(n))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '811'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '811'"
        },
        {
          "example_index": 1,
          "input": "n = 0",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode392.json",
    "problem_index_in_file": 0,
    "title": "Is Subsequence",
    "description_snippet": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise.\n\nA subsequenc...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm to check if s is subsequence of t. Provide each line with explanation. Use Start, End, Decision, etc. The algorithm: two pointers i for s, j for t. While j < len(t) and i < len(s): if t[j]==s[i] then i++ ; j++. After loop, if i==len(s) then true else false.\n\nBut we can also do direct scanning: iterate char in t, if matches current s char increment index. At end check index==len(s).\n\nWe produce steps.\n\nInclude Start, Step: Initialize indices, Decision: s length 0? etc. But keep simple.\n\nWe must avoid actual code, only pseudo-steps.\n\nLet's produce:\n\nStart // start\n\n→ Step 1: Set i = 0 // index for s\n\n→ Step 2: Set j = 0 // index for t\n\n→ Decision: If i equals length of s? // if s empty\n\n    Yes → Step 3: Return true // empty string is subsequence\n\n    No → Decision: If j equals length of t? // if t empty\n\n        Yes → Step 4: Return false // t empty but s not\n\n        No → Step 5: If t[j] equals s[i]? // compare current chars\n\n            Yes → Step 6: Increment i // move to next char in s\n\n            No  → // no increment\n\n            → Step 7: Increment j // move to next char in t\n\n            → Decision: If i equals length of s? // all chars matched\n\n                Yes → Step 8: Return true\n\n                No  → Step 9: If j equals length of t? // t exhausted\n\n                    Yes → Step 10: Return false\n\n                    No  → Go back to Step 5 // continue loop\n\nEnd\n\nBut maybe we need to structure decision loops with arrows. Use \"Decision:\" with indent. Provide lines accordingly.\n\nLet's craft final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: i ← 0 // 建立 s 的索引  \n→ Step 2: j ← 0 // 建立 t 的索引  \n→ Decision: i 等於 s 的長度? // 判斷 s 是否為空串  \n Yes → Step 3: 返回 true // 空串永遠是子序列  \n No → Decision: j 等於 t 的長度? // 判斷 t 是否為空串  \n  Yes → Step 4: 返回 false // t 為空但 s 不為空，必不符合  \n  No → Decision: t[j] 等於 s[i]? // 比較目前兩個字元  \n   Yes → Step 5: i ← i + 1 // 兩字元相等，向前移動 s 的索引  \n   No  → // 兩字元不相等，s 的索引保持不變  \n   → Step 6: j ← j + 1 // 兩字元比較完畢，向前移動 t 的索引  \n   → Decision: i 等於 s 的長度? // 是否已匹配完 s 的所有字元  \n    Yes → Step 7: 返回 true // 成功匹配全部字元  \n    No → Decision: j 等於 t 的長度? // t 是否已遍歷完  \n     Yes → Step 8: 返回 false // t 用完但 s 尚未匹配完成  \n     No → Step 9: 回到 Decision: t[j] 等於 s[i]? // 重新檢查下一個字元  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_subsequence(s: str, t: str) -> bool:\n    \"\"\"\n    判斷字串 s 是否為 t 的子序列。\n    若 s 為空，直接回傳 True。\n    以雙指標方式掃描 t，當 t 的字元與 s 的當前字元相等時\n    進一步向前移動 s 的指標；若整個 s 都被成功匹配，\n    則回傳 True，否則在 t 遍歷完畢後回傳 False。\n    \"\"\"\n    if not s:\n        return True\n    idx = 0  # s 的指標\n    for ch in t:\n        if ch == s[idx]:\n            idx += 1\n            if idx == len(s):\n                return True\n    return False\n\ndef main() -> None:\n    \"\"\"\n    主函式：\n    1. 從標準輸入讀取整行資料。\n    2. 以正規表達式擷取所有被雙引號包圍的子字串，\n       第一個為 s，第二個為 t。\n    3. 呼叫 is_subsequence 判斷結果。\n    4. 將布林值以小寫字串形式輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出所有 \"xxx\" 的內容\n    parts = re.findall(r'\"([^\"]*)\"', data)\n    if len(parts) >= 2:\n        s, t = parts[0], parts[1]\n    else:\n        # 若輸入格式不同，嘗試以空白分隔\n        tokens = data.split()\n        s, t = tokens[0], tokens[1] if len(tokens) > 1 else \"\"\n\n    result = is_subsequence(s, t)\n    print(str(result).lower())\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abc\", t = \"ahbgdc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"axc\", t = \"ahbgdc\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode91.json",
    "problem_index_in_file": 0,
    "title": "Decode Ways",
    "description_snippet": "You have intercepted a secret message encoded as a string of numbers. The message is decoded via the...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for decoding number of ways. It's typical dynamic programming. Steps: Start, input s. Edge cases: empty string, leading zero. Use DP array. Iterate. Use conditions. Provide each line with arrow and explanation.\n\nNeed to output virtual code lines with \"Start\", \"→ Step\", \"→ Decision\", etc.\n\nLet's produce a structured pseudo algorithm.\n\nWe'll produce:\n\nStart\n→ Step 1: Initialize dp array of length len(s)+1, dp[0]=1\n→ Step 2: If s[0]=='0' then return 0\n→ Step 3: Set dp[1]=1\n→ Decision: For i from 2 to len(s)\n    → Decision: If s[i-1] != '0' then dp[i] += dp[i-1]\n    → Decision: TwoDigit = int(s[i-2:i])\n    → Decision: If 10 <= TwoDigit <= 26 then dp[i] += dp[i-2]\nEnd\n\nReturn dp[len(s)].\n\nNeed to incorporate checks for invalid codes like '06'.\n\nAlso handle string length 0.\n\nWe can incorporate decisions like:\n\nDecision: If s empty? etc.\n\nLet's output each line with \"→\" and explanation.\n\nAlso use arrow for decisions with Yes/No.\n\nLet's craft.\n\nWe'll do something like:\n\nStart // 程式開始\n\n→ Step 1: Get length n = len(s) // 取得字串長度\n\n→ Decision: n == 0? // 檢查是否為空字串\n    Yes → Step 2: Return 0 // 空字串無法解碼\n\n→ Decision: s[0] == '0'? // 第一個字元不能為 0\n    Yes → Step 3: Return 0 // 以 0 開頭無效\n\n→ Step 4: dp[0] = 1 // 空前綴有一種解碼方式\n→ Step 5: dp[1] = 1 // 第一個數字有效，僅一種解碼\n\n→ Decision: n >= 2? // 是否至少兩個字元\n    No → Step 6: Return dp[1] // 只有一個字元，直接回傳\n\n→ Step 7: For i = 2 to n // 逐位遍歷剩餘字元\n    → Decision: s[i-1] != '0'? // 單位數字可解碼\n        Yes → dp[i] += dp[i-1] // 加上一種方式\n        No  → No action // 為 0 時不加\n    → Step 8: Two = int(s[i-2:i]) // 取前兩位數\n    → Decision: 10 <= Two <= 26? // 是否為合法兩位碼\n        Yes → dp[i] += dp[i-2] // 加上一種方式\n        No  → No action\n\n→ Step 9: Return dp[n] // 最終解碼方式數\n\nEnd // 程式結束\n\nWe need to include arrow before each decision line. Use \"Decision:\" then \"Yes →\", \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(s) // 取得字串長度  \n→ Decision: n == 0? // 檢查是否為空字串  \n  Yes → Step 2: Return 0 // 空字串無法解碼  \n  No  → No action  \n→ Decision: s[0] == '0'? // 第一個字元不能為 0  \n  Yes → Step 3: Return 0 // 以 0 開頭無效  \n  No  → No action  \n→ Step 4: dp[0] = 1 // 空前綴有一種解碼方式  \n→ Step 5: dp[1] = 1 // 第一個數字有效，僅一種解碼  \n→ Decision: n >= 2? // 是否至少兩個字元  \n  No  → Step 6: Return dp[1] // 只有一個字元，直接回傳  \n  Yes → No action  \n→ Step 7: For i = 2 to n // 逐位遍歷剩餘字元  \n  → Decision: s[i-1] != '0'? // 單位數字可解碼  \n    Yes → dp[i] += dp[i-1] // 加上一種方式  \n    No  → No action  \n  → Step 8: Two = int(s[i-2:i]) // 取前兩位數  \n  → Decision: 10 <= Two <= 26? // 是否為合法兩位碼  \n    Yes → dp[i] += dp[i-2] // 加上一種方式  \n    No  → No action  \n→ Step 9: Return dp[n] // 最終解碼方式數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef num_decodings(s: str) -> int:\n    \"\"\"Return the number of ways to decode the digit string `s`.\"\"\"\n    if not s or s[0] == '0':          # empty or leading zero -> impossible\n        return 0\n\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1                          # empty prefix has one decoding\n    dp[1] = 1                          # first digit is valid (not '0')\n\n    for i in range(2, n + 1):\n        # Check single digit (last digit of the prefix)\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n\n        # Check two-digit number formed by the last two digits\n        two_digit = int(s[i - 2:i])\n        if 10 <= two_digit <= 26:\n            dp[i] += dp[i - 2]\n\n    return dp[n]\n\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Extract the first group of digits (handles cases like 's = \"12\"')\n    match = re.search(r'\\d+', raw_input)\n    s = match.group(0) if match else \"\"\n\n    result = num_decodings(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"12\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \"226\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"06\"",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode523.json",
    "problem_index_in_file": 0,
    "title": "Continuous Subarray Sum",
    "description_snippet": "Given an integer array nums and an integer k, return true if nums has a good subarray or false other...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with explanation. The user wants to solve problem: Given array nums and integer k, return true if nums has a good subarray (contiguous subarray length>=2 and sum multiple of k). Classic problem. Use prefix sum mod k and store earliest index of each mod. Need length >=2, so difference in indices >1.\n\nWe must produce virtual code lines: Start, Step 1: Input array and k, Step 2: initialize dictionary map from remainder to index, set map[0] = -1 (for starting index). Step 3: iterate through array with prefix sum, compute mod, check if remainder seen, check distance >=2, return true if found. After loop, return false. Use decision arrows.\n\nLet's write each step. Must be plain text. Include arrow lines like \"→ Step ...\". Provide explanation comment. Format each line as \"虛擬碼步驟 // 解釋\". Use Chinese comments.\n\nWe also need to handle case k==0 separately? In problem, 0 is multiple of k always, but sum must be multiple of k. If k==0, need subarray sum zero. For k==0, we can check if any two consecutive zeros? Actually need sum 0 multiple of 0? Any number times 0 is 0, so only 0 sum qualifies. So we need subarray sum==0. For k==0, we can treat as normal but avoid division by zero. For mod operations, if k==0, we cannot compute mod. So handle separately: iterate, keep cumulative sum, if any subarray length>=2 sum==0. Could use dictionary of cumulative sum to index. Let's add decision for k==0.\n\nLet's produce steps:\n\nStart\n→ Input nums, k\n→ Decision: if k == 0? // Special case\n    Yes → Step: initialize map sum_to_index with sum 0 at index -1\n         → For i in 0..len(nums)-1:\n             → Update sum += nums[i]\n             → Decision: if sum in map? // check earlier occurrence\n                 Yes → Decision: if i - map[sum] >=2? // length condition\n                        Yes → Step: return true // found subarray sum 0\n                        No → Step: continue\n                 No → Step: map[sum] = i // store first occurrence\n         → Step: return false // no subarray found\n    No  → Step: initialize map remainder_to_index with 0: -1 // remainder 0 at index -1\n         → For i in 0..len(nums)-1:\n             → Update prefix_sum += nums[i]\n             → rem = prefix_sum % k // handle negative\n             → Decision: if rem in map? // seen remainder\n                 Yes → Decision: if i - map[rem] >=2? // length>=2\n                        Yes → Step: return true\n                        No → Step: continue\n                 No → Step: map[rem] = i\n         → Step: return false\n\nEnd\n\nWe must produce each line as \"虛擬碼步驟 // 解釋\". Use arrow lines. Ensure each step line has space then comment.\n\nWe need to use the virtual code arrow syntax like \"→\". Example: \"→ Decision: if k == 0?\" etc. Use indentation with spaces to show nested steps. Provide explanation in Chinese.\n\nLet's craft lines.\n\nImportant: each line must contain \"虛擬碼步驟\" then a space then \"// 解釋\". Use arrow for decision and step lines.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ Input nums, k // 取得輸入的陣列與整數 k\n→ Decision: 如果 k == 0? // 特殊情況：k 為 0 時模運算無效\n    Yes → Step: 初始化 map sum_to_index = {0: -1} // 累加和為 0 的起始位置\n        → For i = 0 to nums.length-1: // 遍歷陣列\n            → Update sum += nums[i] // 累加當前元素\n            → Decision: 如果 sum 已在 sum_to_index? // 檢查之前是否有相同的累加和\n                Yes → Decision: 如果 i - sum_to_index[sum] >= 2? // 子陣列長度至少 2\n                        Yes → Step: 回傳 true // 找到符合條件的子陣列\n                        No → Step: 繼續 // 長度不足，繼續搜尋\n                No → Step: sum_to_index[sum] = i // 記錄第一次出現的索引\n        → Step: 回傳 false // 沒有找到任何子陣列\n    No  → Step: 初始化 map rem_to_index = {0: -1} // remainder 0 的起始位置\n        → For i = 0 to nums.length-1: // 遍歷陣列\n            → Update prefix_sum += nums[i] // 累加總和\n            → Compute rem = (prefix_sum % k + k) % k // 取得非負餘數\n            → Decision: 如果 rem 已在 rem_to_index? // 檢查是否已有相同餘數\n                Yes → Decision: 如果 i - rem_to_index[rem] >= 2? // 子陣列長度至少 2\n                        Yes → Step: 回傳 true // 找到符合條件的子陣列\n                        No → Step: 繼續 // 長度不足，繼續搜尋\n                No → Step: rem_to_index[rem] = i // 記錄第一次出現的索引\n        → Step: 回傳 false // 沒有找到任何子陣列\nEnd // 程式執行結束\n\nMake sure each line uses the same format. For nested steps, we may indent with spaces before arrow? The example shows \"    Yes → Step 2...\" with indentation. So we can indent lines after Yes/No. Use spaces for indentation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Input nums, k // 取得輸入的陣列與整數 k\n→ Decision: 如果 k == 0? // 特殊情況：k 為 0 時模運算無效\n    Yes → Step: 初始化 sum_to_index = {0: -1} // 累加和為 0 的起始位置\n        → For i = 0 to nums.length-1: // 遍歷陣列\n            → Update sum += nums[i] // 累加當前元素\n            → Decision: 如果 sum 已在 sum_to_index? // 檢查之前是否有相同的累加和\n                Yes → Decision: 如果 i - sum_to_index[sum] >= 2? // 子陣列長度至少 2\n                        Yes → Step: 回傳 true // 找到符合條件的子陣列\n                        No → Step: 繼續 // 長度不足，繼續搜尋\n                No → Step: sum_to_index[sum] = i // 記錄第一次出現的索引\n        → Step: 回傳 false // 沒有找到任何子陣列\n    No  → Step: 初始化 rem_to_index = {0: -1} // remainder 0 的起始位置\n        → For i = 0 to nums.length-1: // 遍歷陣列\n            → Update prefix_sum += nums[i] // 累加總和\n            → Compute rem = (prefix_sum % k + k) % k // 取得非負餘數\n            → Decision: 如果 rem 已在 rem_to_index? // 檢查是否已有相同餘數\n                Yes → Decision: 如果 i - rem_to_index[rem] >= 2? // 子陣列長度至少 2\n                        Yes → Step: 回傳 true // 找到符合條件的子陣列\n                        No → Step: 繼續 // 長度不足，繼續搜尋\n                No → Step: rem_to_index[rem] = i // 記錄第一次出現的索引\n        → Step: 回傳 false // 沒有找到任何子陣列\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def checkSubarraySum(self, nums, k):\n        # Handle k == 0 separately\n        if k == 0:\n            seen = {0: -1}\n            total = 0\n            for i, num in enumerate(nums):\n                total += num\n                if total in seen:\n                    if i - seen[total] >= 2:\n                        return True\n                else:\n                    seen[total] = i\n            return False\n\n        # General case\n        mod_map = {0: -1}\n        total = 0\n        for i, num in enumerate(nums):\n            total += num\n            total %= k\n            if total in mod_map:\n                if i - mod_map[total] >= 2:\n                    return True\n            else:\n                mod_map[total] = i\n        return False\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Find the position of the first closing bracket to split list and k\n    try:\n        end_idx = data.index(']') + 1\n    except ValueError:\n        # Fallback: split by comma, assuming list is given without brackets\n        parts = data.split(',', 1)\n        list_part = parts[0]\n        k_part = parts[1] if len(parts) > 1 else '0'\n    else:\n        list_part = data[:end_idx]\n        k_part = data[end_idx:].strip().lstrip(',')\n\n    nums = ast.literal_eval(list_part.strip())\n    k = int(k_part.strip())\n\n    solution = Solution()\n    result = solution.checkSubarraySum(nums, k)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[23,2,4,6,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "[23,2,6,4,7], 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "[23,2,6,4,7], 13",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode41.json",
    "problem_index_in_file": 0,
    "title": "First Missing Positive",
    "description_snippet": "Given an unsorted integer array nums. Return the smallest positive integer that is not present in nu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code solution for the problem: \"Given an unsorted integer array nums. Return the smallest positive integer that is not present in nums.\" Algorithm O(n) time, O(1) extra space. Standard solution: place numbers in correct index (index+1). Then find first index where nums[i] != i+1. Return i+1. If all good return n+1.\n\nWe need to produce step-by-step pseudocode with arrows, decisions, etc. Each line: \"虛擬碼步驟 // 解釋/說明\".\n\nUse structure: Start, End, Decision.\n\nLet's produce.\n\nSteps:\n\nStart\n→ Step 1: Set n = length of nums // get array size\n→ Step 2: For i from 0 to n-1: // iterate to reorder numbers\n    → Decision: If nums[i] <= 0 or nums[i] > n? // ignore non-positive or >n\n        Yes → Continue // skip\n        No  → Decision: If nums[i] == i+1? // already in correct place\n            Yes → Continue // no swap needed\n            No  → Step 3: While nums[i] != i+1 and nums[i] <= n and nums[i] != nums[nums[i]-1]: // place into correct slot\n                → Swap nums[i] with nums[nums[i]-1] // put current number into its position\n                // after swap, nums[i] changes, loop again\n\nAfter rearrangement, step 4: For i from 0 to n-1:\n    → Decision: If nums[i] != i+1?\n        Yes → Step 5: Return i+1 // first missing positive\n        No → Continue\n\nAfter loop: Step 6: Return n+1 // all positions filled\n\nEnd\n\nBut need to use \"→\" arrow lines. We should include nested lines for decisions. Let's format each line with appropriate indentation.\n\nUse \"→\" to indicate next line, \"Decision:\" for decisions, and \"Yes →\" \"No →\". For loops we can represent \"→ Loop:\" etc.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set n = length(nums) // 取得陣列長度  \n→ Step 2: For i from 0 to n-1: // 逐一檢查每個元素  \n  Decision: nums[i] <= 0 or nums[i] > n? // 非正數或大於 n 的數不需要處理  \n   Yes → Continue // 跳過此元素  \n   No  → Decision: nums[i] == i+1? // 已經在正確位置  \n    Yes → Continue // 無需交換  \n    No  → Step 3: While nums[i] != i+1 and nums[i] <= n and nums[i] != nums[nums[i]-1]: // 交換至正確位置  \n      Swap nums[i] with nums[nums[i]-1] // 將目前數字放到正確索引  \n      // 交換後 nums[i] 可能改變，重新檢查條件  \n→ Step 4: For i from 0 to n-1: // 找尋第一個不符合規則的索引  \n  Decision: nums[i] != i+1? // 該位置的數字不等於預期值  \n   Yes → Step 5: Return i+1 // 找到最小缺失正整數  \n   No  → Continue // 檢查下一個索引  \n→ Step 6: Return n+1 // 所有位置都正確，最小缺失值為 n+1  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def firstMissingPositive(self, nums):\n        \"\"\"Return the smallest missing positive integer in an unsorted array.\"\"\"\n        n = len(nums)\n        # Place each number in its correct position (index+1)\n        for i in range(n):\n            # While nums[i] is a valid index and not already in the correct spot\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                # Swap nums[i] with the number at its target index\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        # After reordering, the first index where the value is wrong is the answer\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        # All positions correct, missing number is n+1\n        return n + 1\n\ndef parse_input() -> list[int]:\n    \"\"\"\n    Parse the standard input and extract a list of integers.\n    The input may be in the form:\n        nums = [1,2,0]\n    or simply:\n        [1,2,0]\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return []\n\n    # Find a substring that looks like a Python list\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1 and end > start:\n        list_str = data[start:end + 1]\n        try:\n            nums = ast.literal_eval(list_str)\n            if isinstance(nums, list):\n                return nums\n        except Exception:\n            pass\n\n    # Fallback: try to interpret the whole input as a list\n    try:\n        nums = ast.literal_eval(data)\n        if isinstance(nums, list):\n            return nums\n    except Exception:\n        pass\n\n    # If nothing matches, return an empty list\n    return []\n\nif __name__ == \"__main__\":\n    nums = parse_input()\n    solution = Solution()\n    result = solution.firstMissingPositive(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,0]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "nums = [3,4,-1,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [7,8,9,11,12]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode551.json",
    "problem_index_in_file": 0,
    "title": "Student Attendance Record I",
    "description_snippet": "You are given a string s representing an attendance record for a student where each character signif...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step. Use arrows. Should reflect algorithm: iterate string, count 'A', track consecutive 'L'. If any condition fails, return false. End true.\n\nWe'll produce lines: Start, iterate, decision. Must include comments.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 absentCount ← 0, consecutiveLate ← 0 // 記錄缺席天數與連續遲到天數\n→ Step 2: 將字串 s 轉為字元序列 chars // 方便逐字處理\n→ Decision: 是否還有字元要處理? // 判斷是否已遍歷完所有天數\n    Yes → Step 3: 取得 chars[0] 並移除 // 讀取今天的出勤狀態\n        Yes → Decision: 字元是否為 'A'? // 檢查是否缺席\n            Yes → Step 4: absentCount ← absentCount + 1 // 增加缺席天數\n            No  → Decision: 字元是否為 'L'? // 檢查是否遲到\n                Yes → Step 5: consecutiveLate ← consecutiveLate + 1 // 連續遲到累加\n                No  → Step 6: consecutiveLate ← 0 // 不是遲到，重置連續遲到計數\n        No  → // 若不是 'A' 或 'L'，即為 'P'，不改變計數\n    // 之後重複 Decision，直至 chars 為空\n→ Decision: absentCount >= 2 或 consecutiveLate >= 3? // 判斷是否已違反任一條件\n    Yes → Step 7: 回傳 false // 不符合獎勵條件\n    No  → // 繼續檢查剩餘字元\n→ Step 8: 回傳 true // 所有條件滿足，符合獎勵\nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def checkRecord(self, s: str) -> bool:\n        \"\"\"\n        判斷學生是否符合出勤獎勵條件。\n        條件一：缺席('A')的天數 < 2\n        條件二：連續遲到('L')的天數 < 3\n        \"\"\"\n        # 只要缺席天數不超過 1 天且不存在連續三個 'L'\n        return s.count('A') <= 1 and 'LLL' not in s\n\ndef main() -> None:\n    \"\"\"\n    主程式：從標準輸入讀取字串，判斷並輸出結果。\n    \"\"\"\n    # 讀取整個輸入，並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    \n    # 若輸入包含引號（如 \"PPALLP\"），則將其移除\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    \n    solution = Solution()\n    result = solution.checkRecord(raw_input)\n    \n    # 按題目要求輸出 'true' 或 'false'\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"PPALLP\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"PPALLL\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode26.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solution: removing duplicates from sorted array in-place, return count. Provide steps with Start, Decision, etc. Should be in Chinese. Each line: virtual code step + space + // explanation. Use arrows → and Yes → No →.\n\nWe need to design algorithm: use two pointers: write pointer at index 0, iterate read pointer from 1 to n-1, if nums[read] != nums[write] then increment write and set nums[write] = nums[read]. At end return write+1. Also handle empty array.\n\nLet's produce lines:\n\nStart\n→ If length of nums == 0? // Check empty\n    Yes → End with return 0\n    No → Set write = 0 // first unique index\n→ For read from 1 to nums.length-1 // iterate remaining\n    → Decision: nums[read] != nums[write]? // new unique?\n        Yes → Increment write\n             → nums[write] = nums[read] // place unique\n        No → // duplicate, do nothing\n→ End // finish\n→ Return write + 1 // number of unique elements\n\nWe must use virtual code syntax: maybe like \"If length of nums == 0?\" as Decision. Use \"Yes → End // ...\" Actually we need to include \"End\" line after return? The sample had End after steps. So we will have \"End // 程式執行結束\" after return? Maybe we can include return step before End. Eg: \"→ Step: Return write + 1 // 返回唯一元素個數\". Then End.\n\nLet's produce each line accordingly.\n\nMake sure each line includes the virtual code step plus space then // explanation.\n\nUse Chinese explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: nums.length == 0? // 判斷陣列是否為空  \n    Yes → End // 空陣列直接結束，返回 0  \n    No → Set write = 0 // 初始化寫入指標指向第一個位置  \n→ For read from 1 to nums.length - 1 // 從第二個元素開始遍歷  \n    → Decision: nums[read] != nums[write]? // 檢查是否為新唯一元素  \n        Yes → Increment write // 移動寫入指標  \n             → nums[write] = nums[read] // 把新唯一元素寫入正確位置  \n        No → // 重複元素，忽略不處理  \n→ Return write + 1 // 回傳唯一元素個數 k  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef remove_duplicates(nums):\n    \"\"\"移除已排序陣列中的重複項，返回唯一元素個數。\"\"\"\n    if not nums:\n        return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取出中括號內的字串並解析為 list\n    left = data.find('[')\n    right = data.rfind(']')\n    if left == -1 or right == -1:\n        return\n    list_str = data[left:right+1]\n    try:\n        nums = ast.literal_eval(list_str)\n    except Exception:\n        nums = []\n\n    k = remove_duplicates(nums)\n\n    # 建立輸出格式：先顯示前 k 個唯一元素，後面用 \"_\" 代表未定義元素\n    output_elements = []\n    for i in range(len(nums)):\n        if i < k:\n            output_elements.append(str(nums[i]))\n        else:\n            output_elements.append('_')\n    output_str = \"[\" + \",\".join(output_elements) + \"]\"\n\n    print(f\"{k}, nums = {output_str}\")\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,2]",
          "expected_output": "2, nums = [1,2,_]",
          "success": true,
          "output": "2, nums = [1,2,_]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,2,2,3,3,4]",
          "expected_output": "5, nums = [0,1,2,3,4,_,_,_,_,_]",
          "success": true,
          "output": "5, nums = [0,1,2,3,4,_,_,_,_,_]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode414.json",
    "problem_index_in_file": 0,
    "title": "Third Maximum Number",
    "description_snippet": "Given an integer array nums, return the third distinct maximum number in this array. If the third ma...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps with comments. For the problem: find third distinct maximum, or return max if not exist. We need to produce algorithm: Use variables max1, max2, max3; iterate through nums; update if distinct. At the end check if max3 set. Use large sentinel maybe None. We should output in virtual code format.\n\nWe need to maintain distinctness: skip duplicates.\n\nPseudo steps:\n\nStart\n→ Initialize max1, max2, max3 to None // 3 variables to hold top 3 distinct maxes\n→ For each number x in nums: // iterate\n    → Decision: If max1 is None or x > max1? // new highest\n        Yes → max3 = max2 // shift\n            → max2 = max1\n            → max1 = x\n        No  → Decision: If x equals max1? // duplicate highest\n            Yes → Continue // skip\n            No  → Decision: If max2 is None or x > max2? // new second highest\n                Yes → max3 = max2\n                    → max2 = x\n                No  → Decision: If x equals max2? // duplicate second\n                    Yes → Continue\n                    No  → Decision: If max3 is None or x > max3? // new third highest\n                        Yes → max3 = x\n                        No  → Continue\n→ Decision: If max3 is None? // third distinct doesn't exist\n    Yes → Return max1\n    No  → Return max3\nEnd\n\nWe need to output each line with arrow and comment. The arrow indicates flow. Indent for nested decisions.\n\nMake sure to use \"→\" for each step. For decisions we use \"Decision: ...\". For each branch, use \"Yes →\" or \"No →\".\n\nWe need to not output actual code. Use virtual code lines.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Initialize max1, max2, max3 to None // 記錄前三個最大不重複值\n→ For each number x in nums: // 遍歷陣列\n    → Decision: 是否未設置 max1 或 x > max1? // 判斷是否為新的最大值\n        Yes → max3 = max2 // 位置右移\n            → max2 = max1\n            → max1 = x // 更新最大值\n        No  → Decision: x == max1? // 判斷是否與目前最大值重複\n            Yes → Continue // 重複不處理\n            No  → Decision: 是否未設置 max2 或 x > max2? // 判斷是否為第二大\n                Yes → max3 = max2\n                    → max2 = x // 更新第二大\n                No  → Decision: x == max2? // 判斷是否與第二大重複\n                    Yes → Continue\n                    No  → Decision: 是否未設置 max3 或 x > max3? // 判斷是否為第三大\n                        Yes → max3 = x // 更新第三大\n                        No  → Continue // 比較後仍較小，忽略\n→ Decision: max3 是否為 None? // 判斷是否存在第三大\n    Yes → Return max1 // 沒有第三大，回傳最大值\n    No  → Return max3 // 回傳第三大\nEnd // 程式結束\n\nMake sure each line includes \"→\" or \"Start\" or \"End\". For decision branches, we indent and use Yes → / No →.\n\nWe must also ensure each line is separate. Let's number them? Not necessary.\n\nNeed to ensure \"Start\" line has no arrow. Each \"→\" line has arrow. Indentation for nested lines maybe use spaces or tabs. Use 4 spaces indent maybe.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize max1, max2, max3 to None // 先存放三個最大的不同值\n→ For each number x in nums: // 遍歷陣列\n    → Decision: 是否未設置 max1 或 x > max1? // 判斷是否為新的最大值\n        Yes → max3 = max2 // 位置右移\n            → max2 = max1\n            → max1 = x // 更新最大值\n        No  → Decision: x == max1? // 判斷是否與目前最大值重複\n            Yes → Continue // 重複不處理\n            No  → Decision: 是否未設置 max2 或 x > max2? // 判斷是否為第二大\n                Yes → max3 = max2\n                    → max2 = x // 更新第二大\n                No  → Decision: x == max2? // 判斷是否與第二大重複\n                    Yes → Continue\n                    No  → Decision: 是否未設置 max3 或 x > max3? // 判斷是否為第三大\n                        Yes → max3 = x // 更新第三大\n                        No  → Continue // 比較後仍較小，忽略\n→ Decision: max3 是否為 None? // 判斷是否存在第三大\n    Yes → Return max1 // 沒有第三大，回傳最大值\n    No  → Return max3 // 回傳第三大\nEnd // 程式結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def thirdMax(self, nums):\n        # 使用三個變數保存前三個最大值，初始值為負無限大\n        first = second = third = float('-inf')\n        # 去重，避免重複值影響排名\n        nums_set = set(nums)\n        for num in nums_set:\n            if num > first:\n                third = second\n                second = first\n                first = num\n            elif num > second:\n                third = second\n                second = num\n            elif num > third:\n                third = num\n        # 若集合大小至少為3，返回第三大；否則返回最大值\n        return third if len(nums_set) >= 3 else first\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 假設輸入形如 \"nums = [3,2,1]\"\n    try:\n        # 找到等號後面並使用 literal_eval 解析為列表\n        _, expr = data.split('=', 1)\n        nums = ast.literal_eval(expr.strip())\n    except Exception:\n        # 若解析失敗，直接嘗試直接評估整個輸入\n        nums = ast.literal_eval(data)\n    # 取得答案並輸出\n    sol = Solution()\n    result = sol.thirdMax(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [1,2]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "nums = [2,2,3,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode367.json",
    "problem_index_in_file": 0,
    "title": "Valid Perfect Square",
    "description_snippet": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect s...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with comments. It's a flow for checking if num is perfect square without sqrt.\n\nWe'll likely implement binary search: low=1, high=num. While low<=high: mid=(low+high)/2; mid*mid==num? true; else if mid*mid< num low=mid+1 else high=mid-1. Then false.\n\nWe'll also include Start, End.\n\nNeed to include virtual code steps with arrow. Use format:\n\nStart // 程式開始執行\n→ Step 1: 初始化 low=1, high=num // 設定搜尋範圍\n→ Decision: 低於等於 高? // 判斷是否繼續搜尋\n   Yes → Step 2: 計算 mid = (low + high) / 2 // 找到中間值\n   Yes → Step 3: 估算 square = mid * mid // 計算 mid 的平方\n   Yes → Decision: square 等於 num? // 檢查是否為平方數\n        Yes → Step 4: 返回 true // 找到平方數，返回真\n        No  → Decision: square 小於 num? // 如果不等，判斷方向\n            Yes → Step 5: low = mid + 1 // 更新下界\n            No  → Step 6: high = mid - 1 // 更新上界\n   Yes → Decision: low <= high? // 循環判斷\n        Yes → 回到 Step 2\n        No  → Step 7: 返回 false // 未找到平方數，返回假\nEnd // 程式執行結束\n\nNeed to ensure each line has \"→\" arrow and comment. Also we need to include Start, End. We may also need to include decision steps with Yes/No arrow lines.\n\nWe should format each decision line with \"Decision: ...?\" and nested Yes →, No →.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化 low = 1, high = num // 設定搜尋範圍\n→ Decision: low <= high? // 判斷是否仍有搜尋空間\n    Yes → Step 2: mid = (low + high) / 2 // 計算中間值\n    Yes → Step 3: square = mid * mid // 計算中間值的平方\n    Yes → Decision: square == num? // 檢查是否為目標平方\n        Yes → Step 4: return true // 找到平方數，返回真\n        No  → Decision: square < num? // 判斷平方是否小於目標\n            Yes → Step 5: low = mid + 1 // 更新下界\n            No  → Step 6: high = mid - 1 // 更新上界\n    Yes → Decision: low <= high? // 再次檢查循環條件\n        Yes → 回到 Step 2 // 繼續循環\n        No  → Step 7: return false // 未找到平方數，返回假\nEnd // 程式執行結束\n\nMake sure each line starts with \"→\" after Start. For the back to Step 2, we might just note \"→ 回到 Step 2\". But maybe we don't need arrow. But format expects arrow.\n\nAlso each line should end with comment. We need to ensure no actual code is output, only virtual code. Use placeholders like Step 1 etc. Use Chinese comments.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 low = 1, high = num // 設定搜尋範圍  \n→ Decision: low <= high? // 判斷是否仍有搜尋空間  \n  Yes → Step 2: mid = (low + high) / 2 // 計算中間值  \n  Yes → Step 3: square = mid * mid // 計算中間值的平方  \n  Yes → Decision: square == num? // 檢查是否為目標平方  \n   Yes → Step 4: return true // 找到平方數，返回真  \n   No  → Decision: square < num? // 判斷平方是否小於目標  \n    Yes → Step 5: low = mid + 1 // 更新下界  \n    No  → Step 6: high = mid - 1 // 更新上界  \n  Yes → Decision: low <= high? // 再次檢查循環條件  \n   Yes → 回到 Step 2 // 繼續循環  \n   No  → Step 7: return false // 未找到平方數，返回假  \nEnd // 程式執行結束",
      "generated_code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        \"\"\"\n        判斷 num 是否為完全平方數。\n        使用二分搜尋，時間複雜度 O(log num)。\n        \"\"\"\n        if num < 2:          # 0 或 1 都是完全平方數\n            return True\n\n        left, right = 2, num // 2  # 範圍可縮小到 2 到 num//2\n        while left <= right:\n            mid = (left + right) // 2\n            guess = mid * mid\n            if guess == num:\n                return True\n            elif guess > num:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return False\n\n\nif __name__ == \"__main__\":\n    import sys\n\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 假設輸入格式為 \"num = <value>\"\n    try:\n        _, value = data.split('=')\n        num = int(value.strip())\n    except Exception:\n        # 若輸入格式不符，直接退出\n        sys.exit()\n\n    solution = Solution()\n    result = solution.isPerfectSquare(num)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 16",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "num = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode53.json",
    "problem_index_in_file": 0,
    "title": "Maximum Subarray",
    "description_snippet": "Given an integer array nums, find the subarray with the largest sum, and return its sum....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo-code) that solves the maximum subarray sum problem (Kadane's algorithm). Must output line by line with \"虛擬碼步驟 // 解釋\". Use arrows, decision, etc. Use Start, End. Provide explanation in Chinese.\n\nEnsure no actual code. Just pseudo steps. Provide explanation after each line. Use arrow → for next step. Use Decision: for condition. Use Yes → and No → substeps. Format exactly as described.\n\nLet's produce:\n\nStart // start\n\n→ Step 1: 初始化 maxSum 為 nums[0]，currentSum 為 nums[0] // 初始化全局最大和和当前和\n\n→ Decision: 迭代 nums 的索引 i 從 1 到 nums.length-1? // 遍歷數組剩餘元素\n\n    Yes → Step 2: currentSum ← max(nums[i], currentSum + nums[i]) // 更新當前子陣列和\n\n    Yes → Step 3: maxSum ← max(maxSum, currentSum) // 更新全局最大和\n\n    No  → End // 迴圈結束\n\nEnd // 回傳 maxSum\n\nBut need decision for loop? Use Decision for iteration? The sample uses Decision for condition like \"if\". But we can treat loop as Decision: If i < len? Use Yes/No arrow.\n\nAlternatively simpler: Step 4: 回傳 maxSum.\n\nLet's format properly. Use \"Decision:\" for condition check. Provide explanation each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 maxSum 為 nums[0]，currentSum 為 nums[0] // 設定初始全局最大和與當前子陣列和  \n→ Decision: 迭代 nums 的索引 i 從 1 到 nums.length-1? // 檢查是否還有未處理的元素  \n    Yes → Step 2: currentSum ← max(nums[i], currentSum + nums[i]) // 更新當前子陣列和，選擇包含或不包含新元素  \n    Yes → Step 3: maxSum ← max(maxSum, currentSum) // 若更新後的 currentSum 更大，更新全局最大和  \n    No → End // 所有元素已處理，結束迴圈  \nEnd // 程式執行結束，返回 maxSum",
      "generated_code": "import sys\nimport ast\n\ndef max_subarray(nums):\n    \"\"\"使用 Kadane 演算法求最大子陣列和\"\"\"\n    max_current = max_global = nums[0]\n    for num in nums[1:]:\n        # 更新目前子陣列和：要麼從本身開始，要麼加入上一個子陣列\n        max_current = max(num, max_current + num)\n        # 更新全域最大值\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取全部資料\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 找出資料中的 list 字串，若無則直接使用整段文字\n    start = data.find('[')\n    end = data.rfind(']')\n    if start != -1 and end != -1:\n        list_str = data[start:end + 1]\n    else:\n        list_str = data\n\n    # 以安全方式解析 list\n    nums = ast.literal_eval(list_str)\n\n    # 計算並輸出結果\n    print(max_subarray(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode14.json",
    "problem_index_in_file": 0,
    "title": "Longest Common Prefix",
    "description_snippet": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code line by line with explanation. Need to start with Start, then steps.\n\nImplement longest common prefix function. Steps: Input array. If empty return \"\". Choose first string as prefix. Iterate over each string, while prefix not match start of string, trim last char from prefix. If prefix becomes empty break. After loop return prefix. Use decision statements.\n\nWe should output virtual code lines: Start, Step 1: input array, Step 2: if array empty return \"\", etc. Use decision arrows.\n\nLet's craft. Ensure each line ends with // explanation. Use appropriate arrow. Provide structure.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收字串陣列 words // 取得輸入字串列表  \n→ Decision: words 是否為空? // 檢查是否有任何字串  \n  Yes → Step 2: 回傳 \"\" // 無字串時直接返回空字串  \n  No → Step 3: 設定 prefix = words[0] // 以第一個字串作為初始前綴  \n→ Decision: words 的長度是否大於 1? // 若只有一個字串，直接返回它  \n  Yes → Step 4: 從 index = 1 開始循環遍歷其餘字串  \n   → Step 5: 從 index 迴圈到 words.length-1  \n    → Decision: prefix 是否為空? // 前綴已無內容可比對  \n     Yes → Step 6: 跳出迴圈 // 直接結束循環  \n     No → Decision: words[index] 是否以 prefix 為開頭? // 判斷前綴是否仍匹配  \n      Yes → Step 7: 進行下一個字串的比較 // 前綴仍有效，繼續循環  \n      No → Step 8: 把 prefix 的最後一個字母移除 // 逐步縮短前綴  \n       → 回到 Decision: prefix 是否為空? // 重新檢查是否還剩下可用前綴  \n         Yes → Step 9: 跳出迴圈 // 前綴已空，結束循環  \n         No → Step 10: 回到 Decision: words[index] 是否以 prefix 為開頭? // 重新評估剔除後的前綴  \n          …（重複第 8 步的流程）  \n   → Step 11: 回傳 prefix // 迴圈結束後返回最長公共前綴  \n  No → Step 12: 回傳 words[0] // 只有一個字串時直接返回它  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\ndef longest_common_prefix(strs):\n    \"\"\"返回最長公共前綴字串\"\"\"\n    if not strs:                # 若字串陣列為空\n        return \"\"               # 回傳空字串\n    prefix = strs[0]            # 先把第一個字串視為前綴\n    for s in strs[1:]:          # 從第二個字串開始遍歷\n        # 當前綴不是 s 的開頭時，縮短前綴\n        while not s.startswith(prefix):\n            prefix = prefix[:-1]  # 去掉前綴的最後一個字元\n            if not prefix:        # 前綴已經變空\n                return \"\"         # 沒有公共前綴，直接回傳\n    return prefix                 # 迴圈結束，回傳最長公共前綴\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個輸入字串\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        words = []                       # 無輸入時處理為空列表\n    else:\n        # 取出 '[' 與 ']' 之間的子字串，並安全解析為列表\n        l_idx = raw_input.find('[')\n        r_idx = raw_input.rfind(']')\n        if l_idx != -1 and r_idx != -1:\n            try:\n                words = ast.literal_eval(raw_input[l_idx:r_idx+1])\n            except Exception:\n                words = []               # 解析失敗時視為空列表\n        else:\n            words = []                   # 沒有括號時視為空列表\n\n    # 計算並輸出最長公共前綴，使用雙引號包住輸出\n    result = longest_common_prefix(words)\n    print(f'\"{result}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "expected_output": "\"fl\"",
          "success": true,
          "output": "\"fl\""
        },
        {
          "example_index": 1,
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "expected_output": "\"\"",
          "success": true,
          "output": "\"\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode72.json",
    "problem_index_in_file": 0,
    "title": "Edit Distance",
    "description_snippet": "Given two strings word1 and word2, return the minimum number of operations required to convert word1...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code, line by line, with comments after each line. The problem: minimum edit distance (Levenshtein distance). We need to produce pseudocode steps.\n\nWe need to use Start, End, Decision. Should produce dynamic programming algorithm: dp[i][j] minimal operations to convert word1[0..i-1] to word2[0..j-1].\n\nWe'll produce steps: initialize dp array of size (len1+1)*(len2+1). Set dp[0][j]=j (insert j chars). Set dp[i][0]=i (delete i chars). Then iterate i from 1 to len1, j from 1 to len2, compute cost: if word1[i-1]==word2[j-1] cost=0 else cost=1. dp[i][j] = min(dp[i-1][j]+1 (delete), dp[i][j-1]+1 (insert), dp[i-1][j-1]+cost (replace or match)). Return dp[len1][len2].\n\nAlso we might include decisions: if chars equal else not equal.\n\nWe must output each step as line with arrow or decision structure.\n\nWe need to follow format: Start // ...\n→ Step 1: ...\n→ Decision: ...\nYes → ...\nNo  → ...\n\nWe must not output actual code. Just virtual steps.\n\nLet's structure:\n\nStart // program start\n→ Step 1: Let m = length(word1) // get length\n→ Step 2: Let n = length(word2) // get length\n→ Step 3: Create 2D array dp of size (m+1)x(n+1) // DP table\n→ Step 4: Initialize dp[0][j] = j for j=0..n // base case: inserts\n→ Step 5: Initialize dp[i][0] = i for i=0..m // base case: deletes\n→ Step 6: For i from 1 to m // iterate over word1\n    → Step 7: For j from 1 to n // iterate over word2\n        → Decision: If word1[i-1] == word2[j-1] // characters match\n            Yes → Step 8: Set cost = 0 // no operation needed\n            No  → Step 8: Set cost = 1 // replacement needed\n        → Step 9: dp[i][j] = min(\n            dp[i-1][j] + 1, // delete\n            dp[i][j-1] + 1, // insert\n            dp[i-1][j-1] + cost) // replace or match\n→ Step 10: Return dp[m][n] // result\n\nEnd // program end\n\nNeed to ensure formatting: Use arrow or decision accordingly. Each line with // explanation.\n\nAlso we need to indent decisions and substeps. Use nested indentation? Not required but may be.\n\nWe need to ensure each line has \"→\" prefix, but for Start and End we don't need arrow? Format example uses Start without arrow. So we can use \"Start\" and \"End\" no arrow. Others use \"→\". For decisions, show indentation. Example: \n```\n→ Decision: ...\n    Yes → ...\n    No  → ...\n```\nWe need to ensure consistent spacing.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Let m = length(word1) // 取得 word1 的長度\n→ Step 2: Let n = length(word2) // 取得 word2 的長度\n→ Step 3: Create 2D array dp of size (m+1) × (n+1) // 建立動態規劃表\n→ Step 4: For j from 0 to n, set dp[0][j] = j // 將空字串轉為 word2 需要 j 次插入\n→ Step 5: For i from 0 to m, set dp[i][0] = i // 將 word1 轉為空字串需要 i 次刪除\n→ Step 6: For i from 1 to m // 逐行遍歷 word1\n    → Step 7: For j from 1 to n // 逐列遍歷 word2\n        → Decision: If word1[i-1] == word2[j-1]? // 檢查當前字符是否相同\n            Yes → Step 8: Set cost = 0 // 字符相同，無需操作\n            No  → Step 8: Set cost = 1 // 字符不同，需替換\n        → Step 9: dp[i][j] = min(\n            dp[i-1][j] + 1,     // 刪除 word1[i-1]\n            dp[i][j-1] + 1,     // 插入 word2[j-1]\n            dp[i-1][j-1] + cost) // 替換或保持不變\n→ Step 10: Return dp[m][n] // 最小編輯距離為表格右下角的值\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 初始化第一行和第一列\n        for i in range(m + 1):\n            dp[i][0] = i          # 刪除 i 個字元\n        for j in range(n + 1):\n            dp[0][j] = j          # 插入 j 個字元\n\n        # 填充 DP 表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]          # 字元相同，無需操作\n                else:\n                    dp[i][j] = 1 + min(\n                        dp[i - 1][j],      # 刪除\n                        dp[i][j - 1],      # 插入\n                        dp[i - 1][j - 1]   # 替換\n                    )\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n\n    # 嘗試從雙引號中提取字串\n    words = re.findall(r'\"([^\"]*)\"', data)\n    if len(words) >= 2:\n        word1, word2 = words[0], words[1]\n    else:\n        # 若無雙引號，則按空格分隔\n        parts = data.strip().split()\n        if len(parts) >= 2:\n            word1, word2 = parts[0], parts[1]\n        else:\n            # 若僅提供一個字串，另一個設為空字串\n            word1 = parts[0] if parts else \"\"\n            word2 = \"\"\n\n    solution = Solution()\n    result = solution.minDistance(word1, word2)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "word1 = \"horse\", word2 = \"ros\"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "word1 = \"intention\", word2 = \"execution\"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode374.json",
    "problem_index_in_file": 0,
    "title": "Guess Number Higher or Lower",
    "description_snippet": "We are playing the Guess Game. The game is as follows: \n\nI pick a number from 1 to n. You have to gu...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the \"Guess Number Higher or Lower\" problem, typical binary search. The output must be step by step lines: Start, → Step etc. Each line ends with // explanation.\n\nWe must not output actual code. Use virtual code like \"Start\", \"→ Step 1: 初始化 low = 1, high = n\". Use arrow etc.\n\nAlso include decisions: Decision: 是否 low > high? But typical algorithm: while low <= high, guess mid, check result. If 0 return mid. If -1 high = mid-1 else low = mid+1.\n\nWe produce lines.\n\nLet's produce:\n\nStart\n→ Step 1: low ← 1 // 初始化搜索下界\n→ Step 2: high ← n // 初始化搜索上界\n→ Decision: low ≤ high? // 循環條件\n    Yes → Step 3: mid ← (low + high) / 2 // 計算中間值\n    Yes → Step 4: result ← guess(mid) // 調用 API\n    Yes → Decision: result == 0? // 判斷是否猜對\n        Yes → Step 5: Return mid // 找到答案\n        No  → Decision: result == -1? // 猜的太大\n            Yes → Step 6: high ← mid - 1 // 更新上界\n            No  → Step 7: low ← mid + 1 // 更新下界\n    No  → End // 搜索結束\nEnd\n\nBut must show arrow indentation? Use spaces? Provided example uses indent with 4 spaces for nested.\n\nWe'll format accordingly.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: low ← 1 // 初始化搜尋下界  \n→ Step 2: high ← n // 初始化搜尋上界  \n→ Decision: low ≤ high? // 判斷是否還有範圍可搜尋  \n    Yes → Step 3: mid ← (low + high) / 2 // 取中間值作為猜測  \n    Yes → Step 4: result ← guess(mid) // 呼叫 API 取得猜測結果  \n    Yes → Decision: result == 0? // 判斷是否猜中  \n        Yes → Step 5: Return mid // 找到正確答案，結束搜尋  \n        No  → Decision: result == -1? // 猜測值太大  \n            Yes → Step 6: high ← mid - 1 // 收縮上界  \n            No  → Step 7: low ← mid + 1 // 收縮下界  \n    No  → End // 搜尋結束，未找到（理論上不會發生）  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\n# Global variable to store the number that the player has picked.\npick = None\n\ndef guess(num: int) -> int:\n    \"\"\"\n    模擬猜數字的 API。\n    -1 表示猜的數字比目標大\n     1 表示猜的數字比目標小\n     0 表示猜對了\n    \"\"\"\n    global pick\n    if num > pick:\n        return -1\n    elif num < pick:\n        return 1\n    else:\n        return 0\n\nclass Solution:\n    def guessNumber(self, n: int) -> int:\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read()\n    # 從輸入中擷取所有整數，第一個為 n，第二個為 pick\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        raise ValueError(\"輸入格式錯誤，應包含 n 和 pick。\")\n    n, pick = nums[0], nums[1]\n\n    # 呼叫解題函式\n    sol = Solution()\n    result = sol.guessNumber(n)\n\n    # 將結果輸出\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 10, pick = 6",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "n = 1, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2, pick = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode18.json",
    "problem_index_in_file": 0,
    "title": "4Sum",
    "description_snippet": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. It's basically 4-sum algorithm: sort array, two-pointer or hash map. Use nested loops with pruning, duplicates skip. Provide virtual code step-by-step, with decision arrows. We should produce lines with \"Start\", \"End\". Each line: \"虛擬碼步驟 // 解釋\". We need to avoid actual code, but step names and arrows.\n\nWe must produce a structure. Let's design algorithm:\n\n1. Start\n2. Sort nums\n3. Initialize result list\n4. For i from 0 to n-4:\n   - If i > 0 and nums[i]==nums[i-1], continue (skip duplicates)\n   - For j from i+1 to n-3:\n      - If j > i+1 and nums[j]==nums[j-1], continue\n      - left = j+1, right = n-1\n      - While left < right:\n          sum = nums[i]+nums[j]+nums[left]+nums[right]\n          If sum == target:\n              add quadruplet to result\n              left++ while left<right and nums[left]==nums[left-1]\n              right-- while left<right and nums[right]==nums[right+1]\n          Else if sum < target: left++\n          Else: right--\n5. End\n\nBut we need virtual code lines: each step, maybe combine loops. Use decisions. Provide explanation.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: Sort array nums ascending // 方便後續兩指標搜尋及重複值過濾\n→ Step 2: Initialize empty result list // 用來存放所有符合條件的四元組\n→ Step 3: For i from 0 to n-4 // 第一個索引\n    → Decision: i > 0 AND nums[i] == nums[i-1]？ // 判斷是否跳過重複值\n        Yes → Continue to next i // 跳過重複的第一個元素\n        No  → For j from i+1 to n-3 // 第二個索引\n            → Decision: j > i+1 AND nums[j] == nums[j-1]？ // 判斷是否跳過重複的第二個元素\n                Yes → Continue to next j // 跳過重複的第二個元素\n                No  → Set left = j+1, right = n-1 // 第三、四個索引初始化\n                    → While left < right // 兩指標掃描\n                        → Step 4: Compute sum = nums[i] + nums[j] + nums[left] + nums[right] // 目前四個數字之和\n                        → Decision: sum == target？ // 檢查是否符合目標\n                            Yes → Step 5: Append [nums[i], nums[j], nums[left], nums[right]] to result // 收集符合的四元組\n                                → left++ // 移動左指標\n                                → Decision: left < right AND nums[left] == nums[left-1]？ // 跳過重複的左側數字\n                                    Yes → left++ // 跳過重複值\n                                    No  →\n                                → right-- // 移動右指標\n                                → Decision: right > left AND nums[right] == nums[right+1]？ // 跳過重複的右側數字\n                                    Yes → right-- // 跳過重複值\n                                    No  →\n                            No  →\n                                → Decision: sum < target？ // 和太小，需要增大左指標\n                                    Yes → left++ // 左指標右移\n                                    No  → right-- // 和太大，右指標左移\nEnd // 程式結束\n\nMake sure each line follows \"虛擬碼步驟 // 解釋\". Use appropriate indentation? The format shows arrow lines with indentation. Use spaces and indentation as in example. Provide each line as separate output lines.\n\nWe must use the arrow \"→\" and \"Yes →\" etc. Provide the indentation like in example.\n\nOk produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort array nums ascending // 方便後續兩指標搜尋及重複值過濾  \n→ Step 2: Initialize empty result list // 用來存放所有符合條件的四元組  \n→ Step 3: For i from 0 to n-4 // 第一個索引  \n  → Decision: i > 0 AND nums[i] == nums[i-1]？ // 判斷是否跳過重複值  \n   Yes → Continue to next i // 跳過重複的第一個元素  \n   No  → For j from i+1 to n-3 // 第二個索引  \n    → Decision: j > i+1 AND nums[j] == nums[j-1]？ // 判斷是否跳過重複的第二個元素  \n     Yes → Continue to next j // 跳過重複的第二個元素  \n     No  → Set left = j+1, right = n-1 // 第三、四個索引初始化  \n      → While left < right // 兩指標掃描  \n       → Step 4: Compute sum = nums[i] + nums[j] + nums[left] + nums[right] // 目前四個數字之和  \n       → Decision: sum == target？ // 檢查是否符合目標  \n        Yes → Step 5: Append [nums[i], nums[j], nums[left], nums[right]] to result // 收集符合的四元組  \n         → left++ // 移動左指標  \n         → Decision: left < right AND nums[left] == nums[left-1]？ // 跳過重複的左側數字  \n          Yes → left++ // 跳過重複值  \n          No  →  \n         → right-- // 移動右指標  \n         → Decision: right > left AND nums[right] == nums[right+1]？ // 跳過重複的右側數字  \n          Yes → right-- // 跳過重複值  \n          No  →  \n        No  →  \n         → Decision: sum < target？ // 和太小，需要增大左指標  \n          Yes → left++ // 左指標右移  \n          No  → right-- // 和太大，右指標左移  \nEnd // 程式結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        res = []\n\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total == target:\n                        res.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n                    elif total < target:\n                        left += 1\n                    else:\n                        right -= 1\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 解析輸入：預期格式為 \"nums = [...], target = ...\"\n    pattern = r'nums\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*target\\s*=\\s*(-?\\d+)'\n    match = re.search(pattern, data, re.DOTALL)\n    if not match:\n        # 若輸入格式不符，直接結束\n        return\n    nums_str = match.group(1)\n    target_str = match.group(2)\n    nums = ast.literal_eval(nums_str)\n    target = int(target_str)\n\n    sol = Solution()\n    result = sol.fourSum(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,0,-1,0,-2,2], target = 0",
          "expected_output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
          "success": true,
          "output": "[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [2,2,2,2,2], target = 8",
          "expected_output": "[[2,2,2,2]]",
          "success": true,
          "output": "[[2, 2, 2, 2]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode509.json",
    "problem_index_in_file": 0,
    "title": "Fibonacci Number",
    "description_snippet": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code in the specified format. The user says \"用繁體中文回答\", so explanation must be in Traditional Chinese. Provide virtual code steps: Start, steps to read n, compute Fibonacci recursively or iteratively? Probably iterative approach. We'll use loop. Each line: 虛擬碼步驟 + space + // explanation.\n\nStructure with Start, End, Decision etc. Let's produce:\n\nStart\n→ Step 1: 讀取輸入 n // 取得要計算的項數\n→ Decision: 如果 n < 2? // 檢查是否為 0 或 1\n    Yes → Step 2: 設定 result = n // 直接回傳 0 或 1\n    No  → Step 3: 初始化 a = 0, b = 1 // 設定前兩項\n           → Step 4: 循環從 i = 2 到 n // 計算剩餘項\n              → Step 5: temp = a + b // 計算下一項\n              → Step 6: a = b // 更新 a 為前一項\n              → Step 7: b = temp // 更新 b 為當前項\n           → Step 8: 設定 result = b // 取得第 n 項\n→ Step 9: 輸出 result // 顯示 Fibonacci 數\nEnd\n\nNeed to format with arrows, indent for decisions. Provide indentation with spaces maybe. Use arrow arrow? In example: \"Yes → Step 2:\" and \"No → Decision:\" etc.\n\nWe also need to show each line as separate, with step names. Use \"Step X: ...\" for each.\n\nLet's produce final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 n // 取得要計算的 Fibonacci 項數\n→ Decision: 如果 n < 2? // 判斷是否為 0 或 1\n    Yes → Step 2: 設定 result = n // 直接回傳 0 或 1\n    No  → Step 3: 初始化 a = 0, b = 1 // 設定前兩項\n          → Step 4: 循環從 i = 2 到 n // 開始計算剩餘項\n                → Step 5: temp = a + b // 計算下一項\n                → Step 6: a = b // 更新 a 為前一項\n                → Step 7: b = temp // 更新 b 為當前項\n          → Step 8: 設定 result = b // 取得第 n 項\n→ Step 9: 輸出 result // 顯示 Fibonacci 數\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef fib(n: int) -> int:\n    \"\"\"計算第 n 個 Fibonacci 數字（0,1,1,2,3,5,8,…）。\"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取所有資料，並嘗試找出第一個整數\n    data = sys.stdin.read()\n    match = re.search(r\"-?\\d+\", data)\n    n = int(match.group()) if match else 0\n\n    # 計算並輸出結果\n    print(fib(n))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "n = 3",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "n = 4",
          "expected_output": "3",
          "success": true,
          "output": "3"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode15.json",
    "problem_index_in_file": 0,
    "title": "3Sum",
    "description_snippet": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for 3Sum problem: find all unique triplets that sum to zero. Use sorting + two-pointer. Provide step-by-step virtual code with explanation. Format: Start, → Step, Decision, etc. Each line \"虛擬碼步驟 // 解釋\". Must not output actual code. Just virtual steps. We must follow structure: \"Start // 程式開始執行\". Then steps. For array sort, iterate i from 0 to n-3. For each i, skip duplicates. Then left = i+1, right = n-1. While left < right: sum = nums[i]+nums[left]+nums[right]. If sum==0: record triplet, left++, right--, skip duplicates. If sum<0: left++. Else right--. After loop, after i loop, End.\n\nWe need to show decision steps for skipping duplicates. Use arrow and Decision. Provide explanation each line. Ensure we don't output actual code. Provide \"虛擬碼步驟\" as pseudo like \"Sort(nums)\". Use bullet \"→\" etc.\n\nLet's craft:\n\nStart\n→ Step 1: Sort(nums) // 將數組升序排列，方便後續兩指針法\n→ Step 2: 初始化 result 為空列表 // 用來存放符合條件的三元組\n→ For i from 0 to len(nums)-3 // 遍歷每個作為三元組第一個元素\n    → Decision: i > 0 且 nums[i] == nums[i-1]? // 跳過重複的第一個元素\n        Yes → Continue // 若重複則跳過此 i\n        No  →\n            → Step 3: left ← i+1 // 左指針從 i 的下一個位置開始\n            → Step 4: right ← len(nums)-1 // 右指針從數組末尾開始\n            → While left < right // 左右指針未相遇時\n                → Step 5: sum ← nums[i] + nums[left] + nums[right] // 計算當前三個元素的和\n                → Decision: sum == 0? // 是否正好為 0\n                    Yes →\n                        → Step 6: Append [nums[i], nums[left], nums[right]] to result // 保存有效三元組\n                        → Step 7: left ← left + 1 // 移動左指針\n                        → Step 8: right ← right - 1 // 移動右指針\n                        → Decision: left < right 且 nums[left] == nums[left-1]? // 跳過左側重複\n                            Yes → left ← left + 1 // 連續移動直到非重複\n                            No  → // 不做任何事\n                        → Decision: left < right 且 nums[right] == nums[right+1]? // 跳過右側重複\n                            Yes → right ← right - 1\n                            No  → // 不做任何事\n                    No →\n                        → Decision: sum < 0? // 和小於 0，需增大和\n                            Yes → left ← left + 1\n                            No  → right ← right - 1\n→ End // 程式結束，返回 result\n\nNeed to ensure each line has \"虛擬碼步驟 // 解釋\". Use indentation for decision branches. Use \"→\" lines. Provide each line.\n\nLet's craft final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: Sort(nums) // 將數組升序排列，方便後續兩指針法\n→ Step 2: result ← [] // 初始化結果列表，用於存放所有符合條件的三元組\n→ Decision: i from 0 to len(nums)-3? // 循環遍歷每個可能作為三元組首項的元素\n    Yes → Step 3: left ← i + 1 // 左指針初始位置\n    Yes → Step 4: right ← len(nums) - 1 // 右指針初始位置\n    Yes → Decision: i > 0 且 nums[i] == nums[i-1]? // 跳過重複的首項\n        Yes → Continue // 若重複則跳到下一個 i\n        No  →\n            Yes → While left < right? // 左右指針未相遇時進行搜索\n                Yes → Step 5: sum ← nums[i] + nums[left] + nums[right] // 計算當前三個元素之和\n                Yes → Decision: sum == 0? // 是否恰好為零\n                    Yes → Step 6: Append [nums[i], nums[left], nums[right]] to result // 存入符合條件的三元組\n                    Yes → Step 7: left ← left + 1 // 左指針向右移動\n                    Yes → Step 8: right ← right - 1 // 右指針向左移動\n                    Yes → Decision: left < right 且 nums[left] == nums[left-1]? // 跳過左側重複\n                        Yes → left ← left + 1 // 繼續移動直到遇到不同元素\n                        No  → // 不作任何處理\n                    Yes → Decision: left < right 且 nums[right] == nums[right+1]? // 跳過右側重複\n                        Yes → right ← right - 1\n                        No  → // 不作任何處理\n                    No  → Decision: sum < 0? // 和小於零，需增大和\n                        Yes → left ← left + 1\n                        No  → right ← right - 1\n                No → // left >= right，結束此 i 的搜索\n    No → // i 已到最後三個元素之前的位置，結束整個循環\nEnd // 程式執行結束，返回 result\n```",
      "generated_code": "import sys\n\nclass Solution:\n    def threeSum(self, nums):\n        nums.sort()\n        res = []\n        n = len(nums)\n        for i in range(n):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, n - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total == 0:\n                    res.append([nums[i], nums[left], nums[right]])\n                    # Skip duplicates for left\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    # Skip duplicates for right\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n                elif total < 0:\n                    left += 1\n                else:\n                    right -= 1\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print([])\n        sys.exit()\n    # Extract the list part from input like \"nums = [-1,0,1]\"\n    if '=' in data:\n        data = data.split('=', 1)[1].strip()\n    try:\n        nums = eval(data)\n    except Exception:\n        nums = []\n    result = Solution().threeSum(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "success": true,
          "output": "[[-1, -1, 2], [-1, 0, 1]]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "success": true,
          "output": "[[0, 0, 0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode474.json",
    "problem_index_in_file": 0,
    "title": "Ones and Zeroes",
    "description_snippet": "You are given an array of binary strings strs and two integers m and n.\n\nReturn the size of the larg...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for solving problem: given array of binary strings, and m zeros, n ones, find largest subset size with at most m zeros and n ones. Classic DP: 0-1 knapsack with two constraints. Use DP array of size (m+1)*(n+1) initialized 0. For each string, count zeros and ones, iterate backwards on m and n to update dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones]+1). Output dp[m][n].\n\nWe produce step-by-step virtual code with explanations. Must follow format: Start, → Step 1 etc. Use Decision where needed. No actual code. Should not include brackets. Provide each step with explanation after //.\n\nWe need to output lines: Start // 程式開始執行, then each step. Steps: read input, initialize DP, loop over strings, count zeros and ones, inner loops for j from m down to zeros, k from n down to ones, update DP, after all, output result. Use decision only maybe to skip strings with zeros > m or ones > n. Provide explanation. Use virtual code arrow syntax. Ok.\n\nLet's craft. Use \"Step 1: 讀取 strs、m、n\" etc.\n\nWe'll produce maybe 15-20 lines. Ensure no actual code, just pseudo steps. Provide arrow.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入陣列 strs 與整數 m, n // 取得問題的資料  \n→ Step 2: 建立 2 維 DP 陣列 dp[0…m][0…n] 並全部初始化為 0 // dp[j][k] 表示使用至多 j 個 0 與 k 個 1 時可選的最大子集大小  \n→ Decision: 是否存在任何字串? // 檢查 strs 是否為空  \n    Yes → Step 3: 進入字串迴圈  \n    No  → Step 4: 輸出 0 並 End // 若沒有字串，最大子集大小為 0  \nStep 3: 對於每個字串 s 在 strs 中進行  \n → Step 5: 計算 s 中 0 的數量 zeros 與 1 的數量 ones // 這是本字串的「重量」  \n → Decision: zeros > m 或 ones > n? // 若超過限制則不可能被加入任何子集  \n  Yes → Step 6: 跳過此字串 // 直接進入下一個字串  \n  No → Step 7: 進行 2 维迴圈更新 dp  \n   → Step 8: 對 j 從 m 降至 zeros  \n    → Step 9: 對 k 從 n 降至 ones  \n     → Step 10: dp[j][k] = max(dp[j][k], dp[j-zeros][k-ones] + 1) // 決定是否把 s 加入子集  \n     // 反向迴圈避免同一字串被重複計算  \nStep 3:（迴圈結束）  \n→ Step 11: 取出 dp[m][n] // 這即為符合限制的最大子集大小  \n→ Step 12: 輸出 dp[m][n]  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\ndef find_max_form(strs, m, n):\n    # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for s in strs:\n        zeros = s.count('0')\n        ones = s.count('1')\n        # 逆序遍歷，避免重複使用同一個字串\n        for i in range(m, zeros - 1, -1):\n            for j in range(n, ones - 1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n    return dp[m][n]\n\ndef parse_input(data):\n    \"\"\"\n    從輸入字串中擷取 strs、m、n。\n    輸入示例：\n    'strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3'\n    \"\"\"\n    pattern = r'strs\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*m\\s*=\\s*(\\d+)\\s*,\\s*n\\s*=\\s*(\\d+)'\n    match = re.search(pattern, data, re.S)\n    if not match:\n        raise ValueError(\"Invalid input format\")\n    strs_part = match.group(1)\n    m_part = int(match.group(2))\n    n_part = int(match.group(3))\n    strs = ast.literal_eval(strs_part)\n    return strs, m_part, n_part\n\ndef solve():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    strs, m, n = parse_input(data)\n    result = find_max_form(strs, m, n)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "success": true,
          "output": "2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode227.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator II",
    "description_snippet": "Given a string s which represents an expression, evaluate this expression and return its value.\n\nThe...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that evaluates a string expression with +,-,*,/ and parentheses presumably. Basic approach: use stack and parse char by char. Use two stacks: operands and operators. Precedence: * and / higher than + -. Use standard algorithm. We'll output step-by-step virtual code.\n\nWe need to be concise: Each line has virtual code step + comment. Use arrows, decisions.\n\nLet's design steps:\n\nStart\n→ Step 1: Initialize empty operand stack and operator stack // stacks for numbers and ops\n→ Step 2: Append a sentinel '(' at start and ')' at end of expression to simplify parsing // ensures full processing\n→ Decision: For each character in expression // loop over chars\n    → Step 3: If char is whitespace → continue // skip spaces\n    → Step 4: If char is digit → build number until non-digit // collect multi-digit number\n    → Step 5: Push number onto operand stack // store value\n    → Step 6: Else if char is '(' → push onto operator stack // start subexpression\n    → Step 7: Else if char is ')' → while top operator not '(' → apply operator // compute subexpr\n    → Step 8: Else if char is operator (+,-,*,/) → while operator stack not empty and precedence(top) >= precedence(current) → apply operator // enforce precedence\n    → Step 9: Push current operator onto operator stack // after handling higher/equal precedence\n→ Decision: After loop, while operator stack not empty → apply operator // final computation\n→ Step 10: Result = top of operand stack // final value\nEnd\n\nNeed apply operator step: pop op, pop right, pop left, compute left op right with integer trunc toward zero for division.\n\nWe will create substeps for apply operator.\n\nLet's write as virtual code lines.\n\nWe might need substeps inside apply.\n\nWe'll present as separate lines maybe with indentation? The spec not specify indentation but can include nested decisions.\n\nLet's produce.\n\nAlso mention integer trunc toward zero: in many languages division of negative numbers truncates toward zero.\n\nWe'll include comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化兩個空棧 operands, operators // operands 用於存數字，operators 用於存運算符\n→ Step 2: 在輸入字串 s 前後分別加入 '(' 與 ')' // 方便統一處理括號\n→ Decision: 對 s 中每個字元 ch 進行遍歷 // 逐字元解析\n    → Step 3: 如果 ch 為空白符 → 直接跳過 // 忽略空格\n    → Step 4: 如果 ch 為數字 → 連續讀取後面的數字字元構成完整整數 num // 允許多位數\n        → Step 5: 將 num 推入 operands 棧 // 將數值存入 operands\n    → Step 6: 否則若 ch 為 '(' → 將 ch 推入 operators 棧 // 開啟子表達式\n    → Step 7: 否則若 ch 為 ')' → \n        → Decision: 當 operators.top() != '(' 時 → \n            → Step 8: 執行 ApplyOperator() // 計算子表達式\n        → Step 9: 將 '(' 從 operators 中彈出 // 結束子表達式\n    → Step 10: 否則若 ch 為運算符 (+,-,*,/) → \n        → Decision: operators 非空且 Precedence(operators.top()) >= Precedence(ch) 時 → \n            → Step 11: 執行 ApplyOperator() // 先算高或相同優先級\n        → Step 12: 將 ch 推入 operators 棧 // 放入當前運算符\n→ Decision: 遍歷完後，當 operators 非空時 →\n    → Step 13: 執行 ApplyOperator() // 完成剩餘計算\n→ Step 14: Result = operands.top() // 最終結果\nEnd // 程式執行結束\n\n// ApplyOperator() 步驟（在上文呼叫）\n→ Step 15: op = operators.pop() // 取得要執行的運算符\n→ Step 16: right = operands.pop() // 右操作數\n→ Step 17: left = operands.pop() // 左操作數\n→ Decision: op == '+' 時 →\n    → Step 18: result = left + right // 加法\n    → Step 19: operands.push(result) // 將結果重新推回 operands\n    → Decision 轉移到 EndApply\n→ Decision: op == '-' 時 →\n    → Step 20: result = left - right // 減法\n    → Step 21: operands.push(result)\n    → Decision 轉移到 EndApply\n→ Decision: op == '*' 時 →\n    → Step 22: result = left * right // 乘法\n    → Step 23: operands.push(result)\n    → Decision 轉移到 EndApply\n→ Decision: op == '/' 時 →\n    → Step 24: result = int(left / right) // 整數除法，截斷向零\n    → Step 25: operands.push(result)\n→ Step 26: EndApply // ApplyOperator 完成\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    \"\"\"\n    Evaluate an arithmetic expression containing integers, +, -, *, / and parentheses.\n    Division truncates toward zero.\n    \"\"\"\n    def calculate(self, s: str) -> int:\n        # Helper to return precedence of operators\n        def precedence(op: str) -> int:\n            if op in '+-':\n                return 1\n            if op in '*/':\n                return 2\n            return 0  # '(' has lowest precedence\n\n        # Helper to apply the operator on the top of the operator stack\n        def apply_operator() -> None:\n            op = operators.pop()\n            right = operands.pop()\n            left = operands.pop()\n            if op == '+':\n                operands.append(left + right)\n            elif op == '-':\n                operands.append(left - right)\n            elif op == '*':\n                operands.append(left * right)\n            elif op == '/':\n                # Truncate toward zero\n                operands.append(int(left / right))\n\n        operands: list[int] = []            # stack for numbers\n        operators: list[str] = ['(']        # stack for operators, start with '(' for sentinel\n\n        # Add surrounding parentheses to simplify processing\n        s = s.strip()\n        s = '(' + s + ')'\n\n        i = 0\n        while i < len(s):\n            ch = s[i]\n\n            if ch.isspace():            # skip spaces\n                i += 1\n                continue\n\n            if ch.isdigit():            # build multi‑digit number\n                num = 0\n                while i < len(s) and s[i].isdigit():\n                    num = num * 10 + int(s[i])\n                    i += 1\n                operands.append(num)\n                continue\n\n            if ch == '(':\n                operators.append(ch)\n            elif ch == ')':\n                # evaluate until the matching '('\n                while operators[-1] != '(':\n                    apply_operator()\n                operators.pop()          # remove '('\n            else:                        # operator (+ - * /)\n                # resolve operators of higher or equal precedence\n                while operators and precedence(operators[-1]) >= precedence(ch):\n                    apply_operator()\n                operators.append(ch)\n\n            i += 1\n\n        # The result is the last number on the operands stack\n        return operands[-1] if operands else 0\n\n\ndef main() -> None:\n    # Read entire input; it may contain the pattern s = \"expression\"\n    data = sys.stdin.read()\n\n    # Extract the expression inside double quotes if present\n    match = re.search(r'\"([^\"]*)\"', data)\n    expr = match.group(1) if match else data.strip()\n\n    solution = Solution()\n    result = solution.calculate(expr)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3+2*2\"",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "s = \" 3/2 \"",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "s = \" 3+5 / 2 \"",
          "expected_output": "5",
          "success": true,
          "output": "5"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode152.json",
    "problem_index_in_file": 0,
    "title": "Maximum Product Subarray",
    "description_snippet": "Given an integer array nums, find a subarray that has the largest product, and return the product.\n\n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm to find max product subarray. Use dynamic programming: maintain max and min product ending at each index. We'll output steps: Start, input array, iterate, update max/min, track global max, End. Use Decision arrows.\n\nWe must produce virtual code steps, each line: step description and comment. Use arrow notation.\n\nWe need to use \"→ Step ...\" lines. For loops: maybe \"→ For i from 1 to n-1\" etc. Use decision for negative product.\n\nBetter to outline algorithm: start with first element as current max/min and global max. Then iterate.\n\nLet's produce:\n\nStart\n→ Input array nums // 接收整數陣列\n→ If nums is empty? Decision...\nBut we can assume not empty.\n\nInitialize current_max = nums[0] // 以第一個元素作為初始最大值\nInitialize current_min = nums[0] // 以第一個元素作為初始最小值\nInitialize global_max = nums[0] // 記錄全域最大值\n\n→ For i from 1 to length(nums)-1 // 逐個遍歷陣列\n    → current_num = nums[i] // 取出當前數字\n    → Decision: current_num < 0? // 判斷符號\n        Yes → Swap current_max and current_min // 乘以負數時最大最小交換\n        No → No operation\n    → current_max = current_max * current_num // 更新最大乘積\n    → current_min = current_min * current_num // 更新最小乘積\n    → Decision: current_max > global_max? // 比較全域最大\n        Yes → global_max = current_max // 更新全域最大\n        No → No operation\nEnd // 回傳全域最大\n\nBut we need output of product as result; maybe step: Return global_max // 回傳最大子陣列乘積\n\nThus include final step.\n\nAlso include decision for empty array: But we may skip.\n\nWe should include each line with arrow and comment.\n\nLet's output:\n\nStart // 程式開始執行\n→ Input array nums // 取得整數陣列\n→ Decision: nums 為空? // 檢查陣列是否為空\n    Yes → Return 0 // 空陣列直接回傳 0\n    No  → Continue // 非空則繼續\n→ Initialize current_max = nums[0] // 以第一個元素為初始最大乘積\n→ Initialize current_min = nums[0] // 以第一個元素為初始最小乘積\n→ Initialize global_max = nums[0] // 記錄全域最大乘積\n→ For i from 1 to length(nums)-1 // 從第二個元素開始遍歷\n    → current_num = nums[i] // 取出當前元素\n    → Decision: current_num < 0? // 判斷符號\n        Yes → Swap current_max and current_min // 乘以負數時最大最小交換\n        No  → No operation\n    → current_max = current_max * current_num // 更新以當前元素結束的最大乘積\n    → current_min = current_min * current_num // 更新以當前元素結束的最小乘積\n    → Decision: current_max > global_max? // 判斷是否更新全域最大\n        Yes → global_max = current_max // 更新全域最大\n        No  → No operation\n→ Return global_max // 回傳最大的子陣列乘積\nEnd // 程式執行結束\n\nBut we must maintain format: \"→ Step ...\" lines. Should we include \"Decision:\" lines within For loop? Use indent? But they expect arrow lines with decisions.\n\nLet's adopt: Use \"→ Decision:\" lines for decision.\n\nBut our lines inside For loop might need indentation; we can still use same format. Example:\n\n→ For i from 1 to length(nums)-1 // 遍歷陣列\n    → current_num = nums[i] // 取出當前元素\n    → Decision: current_num < 0? // 判斷符號\n        Yes → Swap current_max and current_min // 乘以負數時最大最小交換\n        No  → No operation // 正數時保持不變\n    → current_max = current_max * current_num // 更新最大乘積\n    → current_min = current_min * current_num // 更新最小乘積\n    → Decision: current_max > global_max? // 更新全域最大\n        Yes → global_max = current_max // 取得新最大值\n        No  → No operation\n\nBut we need each line to have \"虛擬碼步驟 [space] // 解釋\". For decision lines, \"Decision: if ...\". The format shows \"Decision: 如果數字大於 0?\" etc. So we use \"Decision: 如果 current_num < 0?\" etc.\n\nAlso for For loop line, \"→ For i from 1 to length(nums)-1 // ...\" fine.\n\nMake sure each line has arrow \"→\" except Start and End.\n\nWe need to ensure the code structure: Start, lines, End.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input array nums // 取得整數陣列  \n→ Decision: nums 為空? // 檢查陣列是否為空  \n Yes → Return 0 // 空陣列直接回傳 0  \n No  → Continue // 非空則繼續  \n→ Initialize current_max = nums[0] // 以第一個元素為初始最大乘積  \n→ Initialize current_min = nums[0] // 以第一個元素為初始最小乘積  \n→ Initialize global_max = nums[0] // 記錄全域最大乘積  \n→ For i from 1 to length(nums)-1 // 從第二個元素開始遍歷陣列  \n → current_num = nums[i] // 取出當前元素  \n → Decision: current_num < 0? // 判斷符號  \n  Yes → Swap current_max and current_min // 乘以負數時最大最小交換  \n  No  → No operation // 正數時保持不變  \n → current_max = current_max * current_num // 更新以當前元素結束的最大乘積  \n → current_min = current_min * current_num // 更新以當前元素結束的最小乘積  \n → Decision: current_max > global_max? // 判斷是否更新全域最大  \n  Yes → global_max = current_max // 更新全域最大  \n  No  → No operation // 若不是則保持現值  \n→ Return global_max // 回傳最大的子陣列乘積  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def maxProduct(self, nums):\n        if not nums:\n            return 0\n\n        max_prod = min_prod = result = nums[0]\n\n        for num in nums[1:]:\n            if num < 0:\n                max_prod, min_prod = min_prod, max_prod\n\n            max_prod = max(num, max_prod * num)\n            min_prod = min(num, min_prod * num)\n\n            result = max(result, max_prod)\n\n        return result\n\ndef parse_input(s: str):\n    \"\"\"Parse input string of the form 'nums = [1,2,-3]'.\"\"\"\n    m = re.search(r'\\[.*\\]', s)\n    if m:\n        return ast.literal_eval(m.group())\n    # Fallback: comma‑separated numbers without brackets\n    return list(map(int, re.findall(r'-?\\d+', s)))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    nums = parse_input(data)\n    solution = Solution()\n    print(solution.maxProduct(nums))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,-2,4]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 1,
          "input": "nums = [-2,0,-1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode494.json",
    "problem_index_in_file": 0,
    "title": "Target Sum",
    "description_snippet": "You are given an integer array nums and an integer target.\n\nYou want to build an expression out of n...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a virtual code description for this algorithm. It is classic target sum problem. Approach: use DFS/backtracking to assign +/- for each number, compute sum, count matches. Use recursion.\n\nNeed to output step-by-step pseudo code with arrow lines. Each line: virtual code step + comment.\n\nSo produce lines like:\n\nStart\n→ Step 1: Define function dfs(index, currentSum)\n...\n\nMake sure to include decision arrows etc.\n\nWe must not output real code, only virtual steps.\n\nWe need to mention input array, target, result counter, recursion.\n\nWe'll produce pseudo code with structure. Also we need to explain each line.\n\nLet's craft.\n\nWe'll produce:\n\nStart // 程式開始\n\n→ Step 1: Initialize count = 0 // 用於統計符合目標的表達式數量\n\n→ Step 2: Define recursive function DFS(pos, accumulated) // pos為目前處理到的數字索引，accumulated為已計算的總和\n\n    → Decision: 是否 pos 等於 nums.length? // 判斷是否已經處理完所有數字\n\n        Yes → Decision: 是否 accumulated 等於 target? // 檢查累積和是否達到目標\n\n            Yes → Step 3: Increment count // 符合目標，計數+1\n\n            No  → Step 4: Return // 不符合目標，返回\n\n        No  → Step 5: 取得 nums[pos] // 取得目前數字\n\n        → Step 6: 呼叫 DFS(pos+1, accumulated + nums[pos]) // 加號選項\n\n        → Step 7: 呼叫 DFS(pos+1, accumulated - nums[pos]) // 減號選項\n\n→ Step 8: 呼叫 DFS(0, 0) // 從第一個數字開始，初始累積和為0\n\n→ Step 9: Return count // 返回符合目標的表達式數量\n\nEnd\n\nWe should include comments after each line.\n\nAlso include indentation for decisions.\n\nMake sure to include arrow after each line: \"→\".\n\nAlso include spaces: arrow then step.\n\nAlso comment after space.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Initialize count = 0 // 用於統計符合目標的表達式數量  \n→ Step 2: Define function DFS(pos, accumulated) // pos 為目前處理到的數字索引，accumulated 為已計算的總和  \n  → Decision: pos == nums.length? // 判斷是否已經處理完所有數字  \n   Yes → Decision: accumulated == target? // 檢查累積和是否達到目標  \n    Yes → Step 3: Increment count // 符合目標，計數+1  \n    No  → Step 4: Return // 不符合目標，結束此遞迴分支  \n   No  → Step 5: num = nums[pos] // 取得目前數字  \n   → Step 6: Call DFS(pos+1, accumulated + num) // 加號選項，遞迴往下  \n   → Step 7: Call DFS(pos+1, accumulated - num) // 減號選項，遞迴往下  \n→ Step 8: Call DFS(0, 0) // 從第一個數字開始，初始累積和為0  \n→ Step 9: Return count // 回傳符合目標的表達式總數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom collections import defaultdict\n\ndef findTargetSumWays(nums, target):\n    \"\"\"Return the number of ways to assign + or - to each element in nums\n    such that the resulting expression evaluates to target.\"\"\"\n    dp = defaultdict(int)\n    dp[0] = 1  # one way to reach sum 0 with no numbers\n\n    for num in nums:\n        next_dp = defaultdict(int)\n        for s, count in dp.items():\n            next_dp[s + num] += count\n            next_dp[s - num] += count\n        dp = next_dp\n\n    return dp[target]\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # Extract the list of numbers\n    list_match = re.search(r'\\[([^\\]]*)\\]', data)\n    if list_match:\n        nums_str = list_match.group(1)\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    else:\n        nums = []\n\n    # Extract the target value\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    target = int(target_match.group(1)) if target_match else 0\n\n    # Compute and print the result\n    result = findTargetSumWays(nums, target)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,1,1], target = 3",
          "expected_output": "5",
          "success": true,
          "output": "5"
        },
        {
          "example_index": 1,
          "input": "nums = [1], target = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode447.json",
    "problem_index_in_file": 0,
    "title": "Number of Boomerangs",
    "description_snippet": "You are given n points in the plane that are all distinct, where points[i] = [x_i, y_i]. A boomerang...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines explaining algorithm for counting boomerangs. Use pseudocode with Start, Decision, etc. We'll produce step-by-step: read points, loop each i, compute distances to all other points, group counts, for each count m add m*(m-1) to answer. Use virtual arrows. Provide each line explanation. Ensure each line is one statement. Provide structure.\n\nWe'll produce something like:\n\nStart\n→ Step 1: Initialize answer = 0 // 计数器\n→ Step 2: For each point i in points // 主循环\n    → Step 3: Create map distanceCount // 记录距离出现次数\n    → Step 4: For each point j in points where j != i\n        → Step 5: Compute d = distance between i and j // 距离\n        → Step 6: Increment distanceCount[d] by 1 // 统计\n    → Step 7: For each entry cnt in distanceCount\n        → Step 8: If cnt > 1\n            → Step 9: answer += cnt * (cnt - 1) // 计算排列\nEnd\n\nAlso handle duplicate distances.\n\nLet's produce final answer with virtual code lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: ans ← 0 // 初始化結果計數器  \n→ Step 2: For each point i in points // 遍歷每個作為中心的點  \n    → Step 3: distanceCount ← empty map // 用於統計到其它點的距離頻率  \n    → Step 4: For each point j in points where j ≠ i // 對每個非自身點計算距離  \n        → Step 5: d ← (x_i - x_j)² + (y_i - y_j)² // 先算平方距離，避免開方開銷  \n        → Step 6: distanceCount[d] ← distanceCount[d] + 1 // 將此距離的出現次數累加  \n    → Step 7: For each value cnt in distanceCount values // 處理所有相同距離的組合  \n        → Step 8: If cnt > 1 // 至少有兩個點與 i 等距  \n            → Step 9: ans ← ans + cnt * (cnt - 1) // 每對 (j,k) 皆為一個排列，計算排列數  \nEnd // 程式執行結束，ans 為所有 boomerang 的總數",
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\ndef number_of_boomerangs(points):\n    \"\"\"計算所有符合條件的 boomerang 數量。\"\"\"\n    total = 0\n    for x1, y1 in points:\n        dist_count = defaultdict(int)\n        for x2, y2 in points:\n            if x1 == x2 and y1 == y2:\n                continue\n            d = (x1 - x2) ** 2 + (y1 - y2) ** 2  # 用平方距離避免浮點誤差\n            dist_count[d] += 1\n        for cnt in dist_count.values():\n            total += cnt * (cnt - 1)  # 兩兩排列組合\n    return total\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 若輸入包含 \"points =\"，取等號右側\n    if '=' in data:\n        _, data = data.split('=', 1)\n    # 轉成 Python 物件\n    try:\n        points = ast.literal_eval(data.strip())\n    except Exception:\n        # 如果解析失敗直接輸出 0\n        print(0)\n        return\n    # 進行計算並輸出結果\n    result = number_of_boomerangs(points)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "points = [[0,0],[1,0],[2,0]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "points = [[1,1],[2,2],[3,3]]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "points = [[1,1]]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode384.json",
    "problem_index_in_file": 0,
    "title": "Shuffle an Array",
    "description_snippet": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of ...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nThe user wants virtual code for designing a shuffle algorithm. Must output line by line, each line with code and comment. Use arrow syntax. Need to produce solution class with constructor, reset, shuffle. Use Fisher-Yates algorithm. Represent as virtual code. Ensure each line has code + space + // explanation. Use arrows for steps. Provide Start and End. Provide decisions. So produce steps for initialization, reset, shuffle. Use array copying. Use random selection. Provide simple flow. Use Start, End.\n\nLet's produce:\n\nStart // program start\n→ Step 1: Declare class Solution // 定義 Solution 類\n→ Step 2: Declare private variable originalNums // 儲存原始陣列\n→ Step 3: Declare private variable nums // 可變陣列用於 shuffle\n→ Step 4: Constructor Solution(numsInput) // 初始化\n    → Step 5: originalNums ← Copy(numsInput) // 複製一份原始\n    → Step 6: nums ← Copy(numsInput) // 複製一份作業陣列\n→ Step 7: reset() // 重置陣列\n    → Step 8: nums ← Copy(originalNums) // 重新複製原始\n    → Step 9: return nums // 回傳重置後陣列\n→ Step 10: shuffle() // 隨機打亂\n    → Step 11: For i from length(nums)-1 down to 1\n        → Step 12: j ← Random integer between 0 and i\n        → Step 13: Swap nums[i] and nums[j] // Fisher–Yates swap\n    → Step 14: return nums // 回傳打亂後陣列\nEnd // 程式結束\n\nNeed to use arrow notation. For loops use → Step. Provide decisions? None needed. Use arrow for each. Add // comment. Ensure each line includes code plus comment. Let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Declare class Solution // 定義 Solution 類  \n→ Step 2: Declare private variable originalNums // 儲存原始陣列的複製  \n→ Step 3: Declare private variable nums // 供 shuffle 變動的陣列  \n→ Step 4: Constructor Solution(numsInput) // 建構子，接受輸入陣列  \n  → Step 5: originalNums ← Copy(numsInput) // 將輸入陣列複製為原始版本  \n  → Step 6: nums ← Copy(numsInput) // 再複製一次作為工作陣列  \n→ Step 7: reset() // 重置陣列至原始配置  \n  → Step 8: nums ← Copy(originalNums) // 重新複製原始陣列到工作陣列  \n  → Step 9: return nums // 回傳重置後的陣列  \n→ Step 10: shuffle() // 產生隨機排列  \n  → Step 11: For i from length(nums)-1 down to 1 // 從尾到頭遍歷  \n    → Step 12: j ← Random integer between 0 and i // 隨機選取一個索引  \n    → Step 13: Swap nums[i] and nums[j] // 交換位置（Fisher–Yates）  \n  → Step 14: return nums // 回傳已打亂的陣列  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列，並建立可變副本\n        self.original = list(nums)\n        self.nums = list(nums)\n\n    def reset(self):\n        # 重新把陣列還原成原始狀態\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        # Fisher–Yates 洗牌演算法\n        shuffled = list(self.nums)\n        n = len(shuffled)\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            shuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n        return shuffled\n\ndef main():\n    # 讀取整個 stdin 作為輸入字串\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 將輸入包成 JSON 陣列，方便解析\n    data = json.loads('[' + raw + ']')\n    commands, args = data[0], data[1]\n\n    outputs = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == 'Solution':\n            # 解題輸入通常為 [[1,2,3]]，取內層作為陣列\n            nums = arg[0] if isinstance(arg, list) and len(arg) == 1 else arg\n            obj = Solution(nums)\n            outputs.append(None)\n        elif cmd == 'reset':\n            outputs.append(obj.reset())\n        elif cmd == 'shuffle':\n            outputs.append(obj.shuffle())\n        else:\n            outputs.append(None)\n\n    # 將結果以 Python list 形式輸出\n    print(outputs)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[None,[1,2,3],[1,2,3],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[None, [1, 2, 3], [1, 2, 3], [3, 1, 2]]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode405.json",
    "problem_index_in_file": 0,
    "title": "Convert a Number to Hexadecimal",
    "description_snippet": "Given a 32-bit integer num, return a string representing its hexadecimal representation. For negativ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting 32-bit integer to hex string without built-in library, using two's complement for negative. Provide step-by-step with explanations. Use Start, End, Decision, etc. Each line: virtual code step, space, comment. Use arrow.\n\nLet's design algorithm:\n\nInput: 32-bit integer num.\n\nWe need to produce hex string.\n\nApproach: For negative numbers, we treat as unsigned 32-bit representation. So we can use bitwise operations: for each 4 bits from least significant to most, convert to hex char. Stop when no more non-zero bits, unless number is zero. Ensure lower-case.\n\nWe cannot use built-in library, but can use bitwise & 0xF etc.\n\nSteps:\n\nStart.\n\n→ Step 1: If num == 0 → Step 2: Return \"0\".\n\nOtherwise:\n\n→ Step 3: If num < 0 → Step 4: num_unsigned = num + 2^32 (i.e., num + 4294967296). // convert negative to unsigned.\n\nElse → Step 5: num_unsigned = num.\n\n→ Step 6: Initialize empty string result.\n\n→ Step 7: While num_unsigned > 0:\n\n    - current_digit = num_unsigned & 0xF // get lowest 4 bits\n\n    - hex_char = map current_digit to '0'-'f' // using if-else or array\n\n    - Prepend hex_char to result (since we are extracting from least significant, we need to build reversed string).\n\n    - num_unsigned = num_unsigned >> 4 // shift right 4 bits (unsigned shift; in pseudo we treat as integer division by 16).\n\n→ Step 8: Return result.\n\nMake sure to handle leading zeros not present: while loop stops when num_unsigned becomes 0, so no leading zeros. But if initial num_unsigned had leading zeros, they are omitted.\n\nAlso ensure mapping from 0-15 to '0'-'9','a'-'f'. We cannot use library, but can use a small array or condition. We'll just represent as mapping step.\n\nAlso we need to use decision arrow lines.\n\nWe'll produce virtual code lines accordingly.\n\nNow produce final answer in required format.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: num 是否為 0? // 判斷輸入是否為零  \n    Yes → Step 1: 返回 \"0\" // 零的十六進位表示為單一字元  \n    No  → Step 2: 若 num < 0? // 檢查數字是否為負數  \n        Yes → Step 3: num_unsigned = num + 4294967296 // 將負數轉為 32‑bit 無符號表示  \n        No  → Step 4: num_unsigned = num // 正數直接使用原值  \n→ Step 5: 初始化空字串 result = \"\" // 用來累積十六進位字元  \n→ Step 6: Decision: num_unsigned > 0? // 若仍有剩餘位元  \n    Yes → → Step 7: current_digit = num_unsigned & 0xF // 取最低 4 位  \n    → Decision: current_digit < 10? // 判斷是數字還是字母  \n        Yes → Step 8: hex_char = '0' + current_digit // 轉為 '0'~'9'  \n        No  → Step 9: hex_char = 'a' + (current_digit - 10) // 轉為 'a'~'f'  \n    → Step 10: result = hex_char + result // 將新字元加到前面  \n    → Step 11: num_unsigned = num_unsigned >> 4 // 右移 4 位，丟棄已處理的位元  \n    → Step 12: 回到 Decision: num_unsigned > 0? // 繼續處理剩餘位元  \n    No  → Step 13: 返回 result // 完成十六進位字串  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def toHex(self, num: int) -> str:\n        \"\"\"\n        Convert a 32‑bit signed integer to its hexadecimal string representation.\n        Uses two's complement for negative numbers and returns a lowercase string\n        without leading zeros (except for the zero itself).\n        \"\"\"\n        if num == 0:\n            return \"0\"\n\n        # If num is negative, add 2^32 to get the unsigned 32‑bit representation\n        if num < 0:\n            num += 2 ** 32\n\n        hex_chars = \"0123456789abcdef\"\n        res = \"\"\n        while num > 0:\n            res = hex_chars[num & 15] + res  # take lowest 4 bits\n            num >>= 4                        # shift right by 4 bits\n        return res\n\nif __name__ == \"__main__\":\n    # Read all input from stdin, extract the first integer (supports format like \"num = 26\")\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    if match:\n        num = int(match.group(0))\n        solution = Solution()\n        print(solution.toHex(num))\n    else:\n        print(\"0\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num = 26",
          "expected_output": "1a",
          "success": true,
          "output": "1a"
        },
        {
          "example_index": 1,
          "input": "num = -1",
          "expected_output": "ffffffff",
          "success": true,
          "output": "ffffffff"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode292.json",
    "problem_index_in_file": 0,
    "title": "Nim Game",
    "description_snippet": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on th...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for solution of Nim game with n stones, remove 1-3 each turn, first player win if n%4 != 0. We need step-by-step algorithm. Use virtual code lines with explanations. Use Start, Decision, etc. So we produce something like:\n\nStart\n→ Step 1: 讀取 n // input stones\n→ Decision: 如果 n <= 0? // invalid\n    No → ...\n→ Step 2: 計算 n mod 4 // check remainder\n→ Decision: 如果 n mod 4 == 0? // losing position\n    Yes → Step 3: 返回 False // lose\n    No → Step 4: 返回 True // win\nEnd\n\nWe might also include base cases. Provide each line with explanation.\n\nLet's produce final answer in Traditional Chinese. Ensure each line ends with // 解釋.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 讀取變數 n // 取得堆中石子數\n→ Decision: n <= 0? // 檢查輸入是否合法\n    Yes → Step 2: 返回 False // 無石子無法取，視為無法勝\n    No  → // 繼續\n→ Step 3: 計算 remainder = n mod 4 // 取餘數判斷局勢\n→ Decision: remainder == 0? // 0餘數即輸\n    Yes → Step 4: 返回 False // 你無法取勝\n    No  → Step 5: 返回 True // 你可以取勝\nEnd // 程式結束\n\nAdd explanation each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取變數 n // 取得堆中石子總數  \n→ Decision: n <= 0? // 檢查輸入是否有效  \n Yes → Step 2: 返回 False // 若無石子，無法取勝  \n No  → // 繼續往下執行  \n→ Step 3: 計算 remainder = n mod 4 // 取餘數判斷局勢  \n→ Decision: remainder == 0? // 若餘數為 0，表示輸  \n Yes → Step 4: 返回 False // 你必定輸  \n No  → Step 5: 返回 True // 你能確保取勝  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef can_win_nim(n: int) -> bool:\n    \"\"\"\n    判斷先手玩家是否能贏得 Nim 遊戲。\n    若石子數為 4 的倍數，先手必輸；否則先手必勝。\n    \"\"\"\n    return n % 4 != 0\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析石子數，並輸出 'true' 或 'false'。\n    支援類似 'n = 4' 或僅 '4' 的輸入格式。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中搜尋第一個整數\n    match = re.search(r'-?\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n\n    result = can_win_nim(n)\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 4",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 2",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode263.json",
    "problem_index_in_file": 0,
    "title": "Ugly Number",
    "description_snippet": "An ugly number is a positive integer which does not have a prime factor other than 2, 3, and 5.\n\nGiv...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for determining if n is ugly (only prime factors 2,3,5). No actual code. Just virtual steps. Format lines: Step description + comment. Use Start, End, Decision: with arrows. Must be line by line. Also need to mention check for positive integer? Problem says positive integer. So start: check n>0? Actually Ugly defined for positive integer. Should we handle non-positive? Might just return false. But typical solution: if n<=0 return false; else divide by 2,3,5 until cannot. At end if n==1 return true else false. So produce virtual steps accordingly.\n\nLet's produce:\n\nStart\n→ Step 1: 接收輸入整數 n // 獲取待測試數字\n→ Decision: n <= 0? // 判斷是否為正整數\n    Yes → Step 2: 輸出 false // 非正數非丑數\n    No  → Step 3: 初始化 list factors = [2,3,5] // 定義可接受的質因數\n→ Step 4: For each factor in list factors:\n    → Decision: n mod factor == 0? // 是否能被該質因數整除\n        Yes → Step 5: n = n / factor // 繼續除以該質因數\n        No  → (無操作) // 跳過\n    → (重複此判斷直到無法再整除)\n→ Step 6: Decision: n == 1? // 最終剩餘是否為1\n    Yes → Step 7: 輸出 true // 只含 2,3,5 之因數\n    No  → Step 8: 輸出 false // 存在其他質因數\nEnd\n\nBut need to use arrow \"→\" each line, and Decision: lines. Also Step: lines. Also nested decisions. Use \"Yes →\" \"No →\" lines. We must maintain proper indentation. Provide explanation after //.\n\nWe must ensure we use only the given arrow characters.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收輸入整數 n // 獲取待測試數字  \n→ Decision: n <= 0? // 判斷是否為正整數  \n  Yes → Step 2: 輸出 false // 非正數不屬於丑數  \n  No  → Step 3: 初始化 list factors = [2, 3, 5] // 定義可接受的質因數  \n→ Step 4: For each factor in factors  \n  → Decision: n mod factor == 0? // 是否能被該質因數整除  \n    Yes → Step 5: n = n / factor // 先除以該質因數  \n    No  → (跳過) // 不是此質因數，移至下一個  \n  → 重複此判斷直到 n 不能再被任何 factor 整除  \n→ Decision: n == 1? // 最終剩餘是否為 1  \n  Yes → Step 6: 輸出 true // 只含 2、3、5 之因數  \n  No  → Step 7: 輸出 false // 仍有其他質因數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef is_ugly(n: int) -> bool:\n    \"\"\"判斷 n 是否為丑數（只含質因數 2、3、5）。\"\"\"\n    if n <= 0:\n        return False\n    for p in (2, 3, 5):\n        while n % p == 0:\n            n //= p\n    return n == 1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read()\n    # 用正則表達式尋找第一個整數（可能有負號）\n    match = re.search(r'-?\\d+', data)\n    if match:\n        n = int(match.group())\n    else:\n        n = 0  # 若找不到數字，視為 0\n    # 判斷並輸出結果（小寫）\n    print(str(is_ugly(n)).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 6",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 2,
          "input": "n = 14",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode78.json",
    "problem_index_in_file": 0,
    "title": "Subsets",
    "description_snippet": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe so...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating power set of array of unique elements. We need to produce step-by-step pseudo-code with comments in Chinese. Use arrow syntax. Each line: \"虛擬碼步驟 // 解釋\". Must start with Start, End. Use Decision nodes. We need to show algorithm: could use backtracking recursion or iterative bitmask. Provide steps: initialize result, define backtrack function, etc. Provide virtual code lines. Each line should include explanation. Use arrow lines. Use indentation for decisions. Use \"→\" arrow.\n\nWe should keep it simple. Steps:\n\nStart\n→ Step 1: Initialize result as empty list\n→ Step 2: Define recursive function backtrack(start, currentSubset)\n→ Decision: If start == length of nums?\n→ Yes → Step 3: Append copy of currentSubset to result\n→ No → Step 4: For i from start to len-1\n    → Step 5: Append nums[i] to currentSubset\n    → Step 6: Call backtrack(i+1, currentSubset)\n    → Step 7: Remove last element from currentSubset (backtrack)\n→ Step 8: Call backtrack(0, empty list)\n→ Step 9: Return result\nEnd\n\nBut we must use arrow after each step. Use indent for decision branches. Use \"Yes →\" and \"No →\".\n\nWe must ensure each line includes comment after //. Use Chinese explanation. Provide virtual code step numbers? The example uses \"Step 1:\" etc. We'll include. Provide \"Start\" line and \"End\" line. Use arrow \"→\" after Start? In example: \"Start // 程式開始執行\" then \"→ Step 1: ...\" So we follow.\n\nLet's produce. Use consistent formatting.\n\nEdge: use \"Decision:\" line with condition. Then under Yes and No indent. Use arrow after Yes. Good.\n\nLet's write.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來儲存所有子集  \n→ Step 2: 定義遞迴函式 backtrack(start, currentSubset) // 回溯演算法入口  \n→ Decision: start 等於 nums 長度? // 檢查是否已遍歷完所有元素  \n Yes → Step 3: 把 currentSubset 的複本加入 result // 完整子集加入結果  \n No  → Step 4: 針對 i 從 start 到 nums 長度-1 做循環 // 嘗試把每個元素加入子集  \n  → Step 5: 把 nums[i] 加入 currentSubset // 暫時擴展子集  \n  → Step 6: 呼叫 backtrack(i+1, currentSubset) // 進入下一層回溯  \n  → Step 7: 移除 currentSubset 最後一個元素 // 回溯回原狀  \n→ Step 8: 呼叫 backtrack(0, 空列表) // 從第一個元素開始遞迴  \n→ Step 9: 回傳 result // 返回所有子集  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"回傳所有子集（冪集合）\"\"\"\n        res = []\n\n        def backtrack(start, path):\n            # 目前的 path 是一個完整的子集，加入結果\n            res.append(path[:])\n            # 從 start 開始嘗試把每個元素加入子集\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()  # 回溯：移除剛才加入的元素\n\n        backtrack(0, [])\n        return res\n\ndef main():\n    # 讀取整個輸入，去掉首尾空白\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，預期格式為 \"nums = [1,2,3]\" 或僅 \"[1,2,3]\"\n    if '=' in data:\n        _, arr_str = data.split('=', 1)\n        arr_str = arr_str.strip()\n    else:\n        arr_str = data\n\n    # 使用安全方式解析 Python 表達式\n    try:\n        nums = ast.literal_eval(arr_str)\n    except Exception:\n        print(\"[]\")\n        return\n\n    solution = Solution()\n    result = solution.subsets(nums)\n\n    # 以 JSON 格式輸出，去除逗號後的空格\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0]",
          "expected_output": "[[],[0]]",
          "success": true,
          "output": "[[],[0]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode423.json",
    "problem_index_in_file": 0,
    "title": "Reconstruct Original Digits from English",
    "description_snippet": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with arrow and decision structure, for a problem: given a string s containing out-of-order English representation of digits 0-9, return the digits in ascending order.\n\nSo typical solution: count letters, use unique letters to determine counts of digits: 'z' for zero, 'w' for two, 'u' for four, 'x' for six, 'g' for eight. Then others: 'o' for one after zero two four, etc. We need to produce virtual pseudocode step by step. Provide explanation after each line. Use Start, End. Each line like \"→ Step 1: ... // Explanation\". Use Decision steps when needed.\n\nWe need to produce the solution algorithm, not actual code.\n\nLet's outline steps:\n\nStart\n→ Step 1: Count frequency of each letter in s // build map\n→ Step 2: Initialize array result[10] = 0 // store digit counts\n→ Decision: If 'z' exists in freq? // zero\n    Yes → Step 3: result[0] = freq['z']; // zero count\n    No → Step 3: result[0] = 0\n→ Step 4: Subtract letter counts of 'zero' result[0] times from freq // adjust\nSimilarly for 'w' => two, 'u' => four, 'x' => six, 'g' => eight.\nAfter that, compute one, three, five, seven, nine using remaining unique letters:\nDecision: If 'o' in freq? // after zero two four\nYes → result[1] = freq['o'];\n...\nContinue.\n\nAfter computing all, build output string ascending digits repeated result times.\n\nLet's produce virtual code with each step, including Decision nodes. Use Yes/No branches but we might not need No branch for each because we can just assign zero if not present. But to follow format, we need Decision and Yes/No.\n\nWe can compress some decisions.\n\nWe also need to maintain that each line ends with // explanation.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Count each letter in s → freq // 建立字母頻率表\n→ Step 2: Initialise array digitCnt[10] = 0 // 用於儲存每個數字的出現次數\n→ Decision: freq 包含 'z'? // 'z' 只出現在 \"zero\"\n    Yes → Step 3: digitCnt[0] = freq['z'] // 取得 0 的數量\n    No  → Step 3: digitCnt[0] = 0 // 若沒有 'z' 則 0 的數量為 0\n→ Step 4: For i from 1 to digitCnt[0]: subtract letters of \"zero\" from freq // 去除已計算的 0\n→ Decision: freq 包含 'w'? // 'w' 只出現在 \"two\"\n    Yes → Step 5: digitCnt[2] = freq['w'] // 取得 2 的數量\n    No  → Step 5: digitCnt[2] = 0\n→ Step 6: For i from 1 to digitCnt[2]: subtract letters of \"two\" from freq // 去除已計算的 2\n→ Decision: freq 包含 'u'? // 'u' 只出現在 \"four\"\n    Yes → Step 7: digitCnt[4] = freq['u'] // 取得 4 的數量\n    No  → Step 7: digitCnt[4] = 0\n→ Step 8: For i from 1 to digitCnt[4]: subtract letters of \"four\" from freq // 去除已計算的 4\n→ Decision: freq 包含 'x'? // 'x' 只出現在 \"six\"\n    Yes → Step 9: digitCnt[6] = freq['x'] // 取得 6 的數量\n    No  → Step 9: digitCnt[6] = 0\n→ Step 10: For i from 1 to digitCnt[6]: subtract letters of \"six\" from freq // 去除已計算的 6\n→ Decision: freq 包含 'g'? // 'g' 只出現在 \"eight\"\n    Yes → Step 11: digitCnt[8] = freq['g'] // 取得 8 的數量\n    No  → Step 11: digitCnt[8] = 0\n→ Step 12: For i from 1 to digitCnt[8]: subtract letters of \"eight\" from freq // 去除已計算的 8\n→ Decision: freq 包含 'o'? // 'o' 只剩於 \"one\"（0,2,4 已除）\n    Yes → Step 13: digitCnt[1] = freq['o'] // 取得 1 的數量\n    No  → Step 13: digitCnt[1] = 0\n→ Step 14: For i from 1 to digitCnt[1]: subtract letters of \"one\" from freq // 去除已計算的 1\n→ Decision: freq 包含 'h'? // 'h' 只剩於 \"three\"（已除 8）\n    Yes → Step 15: digitCnt[3] = freq['h'] // 取得 3 的數量\n    No  → Step 15: digitCnt[3] = 0\n→ Step 16: For i from 1 to digitCnt[3]: subtract letters of \"three\" from freq // 去除已計算的 3\n→ Decision: freq 包含 'f'? // 'f' 只剩於 \"five\"（已除 4）\n    Yes → Step 17: digitCnt[5] = freq['f'] // 取得 5 的數量\n    No  → Step 17: digitCnt[5] = 0\n→ Step 18: For i from 1 to digitCnt[5]: subtract letters of \"five\" from freq // 去除已計算的 5\n→ Decision: freq 包含 's'? // 's' 只剩於 \"seven\"（已除 6）\n    Yes → Step 19: digitCnt[7] = freq['s'] // 取得 7 的數量\n    No  → Step 19: digitCnt[7] = 0\n→ Step 20: For i from 1 to digitCnt[7]: subtract letters of \"seven\" from freq // 去除已計算的 7\n→ Decision: freq 包含 'i'? // 'i' 只剩於 \"nine\"（已除 1,5,6）\n    Yes → Step 21: digitCnt[9] = freq['i'] // 取得 9 的數量\n    No  → Step 21: digitCnt[9] = 0\n→ Step 22: For i from 1 to digitCnt[9]: subtract letters of \"nine\" from freq // 完成所有數字\n→ Step 23: 建立結果字串 output\n→ Step 24: For d from 0 to 9:\n    → Step 24a: Append d to output digitCnt[d] 次 // 按升序將數字加入字串\n→ End // 程式執行結束，output 為排序後的數字字串",
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def originalDigits(self, s: str) -> str:\n        \"\"\"\n        依照字母頻率推算各數字出現的次數，並以升序輸出數字字串。\n        \"\"\"\n        freq = Counter(s)  # 1. 取得每個字母的出現頻率\n        out = {}           # 2. 用於儲存每個數字的數量\n\n        # 3. 先解決具有唯一字母的數字\n        out['0'] = freq['z']          # 'z' 只出現在 \"zero\"\n        out['2'] = freq['w']          # 'w' 只出現在 \"two\"\n        out['4'] = freq['u']          # 'u' 只出現在 \"four\"\n        out['6'] = freq['x']          # 'x' 只出現在 \"six\"\n        out['8'] = freq['g']          # 'g' 只出現在 \"eight\"\n\n        # 4. 再解決剩下的數字，利用已知數字消除重複字母\n        out['3'] = freq['h'] - out['8']          # 'h' 只剩於 \"three\"\n        out['5'] = freq['f'] - out['4']          # 'f' 只剩於 \"five\"\n        out['7'] = freq['s'] - out['6']          # 's' 只剩於 \"seven\"\n        out['1'] = freq['o'] - out['0'] - out['2'] - out['4']  # 'o' 只剩於 \"one\"\n        out['9'] = freq['i'] - out['5'] - out['6'] - out['8']  # 'i' 只剩於 \"nine\"\n\n        # 5. 以升序組合結果字串\n        res = [digit * out[digit] for digit in sorted(out.keys())]\n        return ''.join(res)\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 若輸入為類似 s = \"...\" 的形式，抽取雙引號內的字串\n    match = re.search(r'[\"\\'](.*?)[\"\\']', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # 直接使用整行內容\n        s = raw_input\n\n    solution = Solution()\n    result = solution.originalDigits(s)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"owoztneoer\"",
          "expected_output": "\"012\"",
          "success": true,
          "output": "012"
        },
        {
          "example_index": 1,
          "input": "s = \"fviefuro\"",
          "expected_output": "\"45\"",
          "success": true,
          "output": "45"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode479.json",
    "problem_index_in_file": 0,
    "title": "Largest Palindrome Product",
    "description_snippet": "Given an integer n, return the largest palindromic integer that can be represented as the product of...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with explanation. The task: given n, find largest palindrome product of two n-digit numbers, mod 1337. This is the known problem from Leetcode 872.\n\nWe need virtual steps: compute high = 10^n -1, low = 10^(n-1). Iterate a from high to low, b from a to low? Actually to find max, we iterate a from high to low, b from a to low, compute product, check palindrome, update max. Complexity maybe large but fine for n <= 4? Actually n <= 4? but it's conceptual.\n\nWe need to generate algorithm steps, not actual code. Let's produce lines with Start, Steps, Decision, etc.\n\nWe need to produce for each line: Virtual Code Step + space + // explanation.\n\nWe'll need loops and decisions.\n\nLet's produce:\n\nStart // 開始\n→ Step 1: 計算 max_num = 10^n - 1 // 最高 n 位數\n→ Step 2: 計算 min_num = 10^(n-1) // 最小 n 位數\n→ Step 3: 初始化 max_pal = 0 // 儲存最大的回文數\n→ Step 4: 初始化 answer = 0 // 儲存結果模 1337\n→ Step 5: 對 a 從 max_num 下降到 min_num // 外層迴圈\n→ Decision: 是否 a < min_num? // 控制迴圈結束\n    Yes → End // 迴圈結束\n    No  →\n        → Step 6: 對 b 從 a 下降到 min_num // 內層迴圈\n        → Decision: 是否 b < min_num? // 控制內層迴圈結束\n            Yes →\n                → Step 7: 如果 max_pal > 0? // 若已找到回文\n                    Yes →\n                        → Step 8: answer ← answer * (max_pal mod 1337) // 更新答案\n                        → Step 9: 將 answer 取模 1337 // 確保模數\n                    No →\n                        → Step 10: 跳過 // 尚未找到回文\n                → Decision: 是否 a < min_num? // 檢查外層迴圈結束\n                    Yes → End\n                    No → Back to Step 5\n            No  →\n                → Step 11: 計算 product = a * b // 乘積\n                → Decision: 是否 product <= max_pal? // 若不可能更大\n                    Yes →\n                        → Step 12: 內層迴圈提前結束 // b 可以遞減但不再尋找\n                        → Decision: 是否 a < min_num? // 檢查外層迴圈結束\n                            Yes → End\n                            No → Back to Step 5\n                    No →\n                        → Step 13: 判斷 product 是否為回文 // 判斷函式\n                        → Decision: 是否是回文? // 回文檢查\n                            Yes →\n                                → Step 14: max_pal ← product // 更新最大回文\n                                → Step 15: answer ← answer * (product mod 1337) // 更新答案\n                                → Step 16: answer 取模 1337 // 確保模數\n                                → Decision: 是否 a < min_num? // 檢查外層迴圈結束\n                                    Yes → End\n                                    No → Back to Step 5\n                            No  →\n                                → Decision: 是否 a < min_num? // 檢查外層迴圈結束\n                                    Yes → End\n                                    No → Back to Step 5\n\nBut this structure may be too detailed. We can simplify but must follow output format.\n\nLet's produce simpler but still correct algorithm.\n\nNeed to include decision and loops.\n\nWe also need to include functions like isPalindrome, mod.\n\nWe should also mention that we multiply answer by palindrome % 1337 and mod again.\n\nSimplify: Outer loop a, inner loop b, compute product, if palindrome, update max, answer.\n\nWe can include early break: if product <= max_pal, break inner loop.\n\nAlso after outer loop, output answer.\n\nLet's produce final virtual code steps:\n\nStart // 程式開始\n→ Step 1: 計算 max_num = 10^n - 1 // 最大 n 位數\n→ Step 2: 計算 min_num = 10^(n-1) // 最小 n 位數\n→ Step 3: 初始化 max_pal = 0 // 儲存目前最大的回文乘積\n→ Step 4: 初始化 answer = 1 // 乘積結果，起始為 1\n→ Step 5: 對 a 從 max_num 降至 min_num // 外層迴圈\n→ Decision: 是否 a < min_num? // 判斷外層迴圈結束\n    Yes → End // 所有組合已檢查\n    No →\n        → Step 6: 對 b 從 a 降至 min_num // 內層迴圈\n        → Decision: 是否 b < min_num? // 判斷內層迴圈結束\n            Yes →\n                → Decision: 是否 a < min_num? // 再次檢查外層結束\n                    Yes → End\n                    No → Back to Step 5\n            No →\n                → Step 7: 計算 product = a * b // 乘積\n                → Decision: 是否 product <= max_pal? // 早停條件\n                    Yes →\n                        → Step 8: 內層迴圈提前結束 // 無法得到更大回文\n                        → Decision: 是否 a < min_num? // 檢查外層\n                            Yes → End\n                            No → Back to Step 5\n                    No →\n                        → Step 9: 呼叫 isPalindrome(product) // 判斷是否回文\n                        → Decision: 是否為回文? // 判斷結果\n                            Yes →\n                                → Step 10: max_pal ← product // 更新最大回文\n                                → Step 11: answer ← answer * (product mod 1337) // 更新答案\n                                → Step 12: answer 取模 1337 // 確保取模\n                                → Decision: 是否 a < min_num? // 外層檢查\n                                    Yes → End\n                                    No → Back to Step 5\n                            No  →\n                                → Decision: 是否 a < min_num? // 外層檢查\n                                    Yes → End\n                                    No → Back to Step 5\n\nBut we need to ensure we exit loops properly. The step 8: \"內層迴圈提前結束\" but we still need to go to next a. We'll include a step that sets b = min_num-1 maybe? but easier: we can just break inner loop by moving b to min_num -1 and then outer loop continues. Represented by \"break\" maybe.\n\nSimplify further: we can remove some nested decisions and just have simple loops and decisions.\n\nLet's produce final answer with proper structure.\n\nWe should also include function isPalindrome, but we can treat as subroutine.\n\nThe output: each line has \"虛擬碼步驟\" + \" // 解釋\". So we need each line as described.\n\nWe'll produce:\n\nStart // 程式開始\n→ Step 1: max_num ← 10^n - 1 // 最高 n 位數\n→ Step 2: min_num ← 10^(n-1) // 最小 n 位數\n→ Step 3: max_pal ← 0 // 目前已找到的最大回文乘積\n→ Step 4: answer ← 1 // 乘積結果，初始為 1\n→ Step 5: 對 a ← max_num 下降至 min_num // 外層迴圈\n→ Decision: a < min_num? // 判斷外層迴圈結束\n    Yes → End // 所有組合已檢查，結束程式\n    No →\n        → Step 6: 對 b ← a 下降至 min_num // 內層迴圈\n        → Decision: b < min_num? // 判斷內層迴圈結束\n            Yes →\n                → Decision: a < min_num? // 再次檢查外層\n                    Yes → End\n                    No → Back to Step 5\n            No →\n                → Step 7: product ← a * b // 乘積\n                → Decision: product ≤ max_pal? // 若已不可能更大\n                    Yes →\n                        → Step 8: 內層迴圈提前結束 // 直接跳到下一個 a\n                        → Decision: a < min_num? // 外層檢查\n                            Yes → End\n                            No → Back to Step 5\n                    No →\n                        → Step 9: is_palindrome ← isPalindrome(product) // 判斷回文\n                        → Decision: is_palindrome? // 判斷結果\n                            Yes →\n                                → Step 10: max_pal ← product // 更新最大回文\n                                → Step 11: answer ← (answer * (product mod 1337)) mod 1337 // 更新答案並取模\n                                → Decision: a < min_num? // 外層檢查\n                                    Yes → End\n                                    No → Back to Step 5\n                            No →\n                                → Decision: a < min_num? // 外層檢查\n                                    Yes → End\n                                    No → Back to Step 5\n\nWe should also include function isPalindrome, but it's called.\n\nThis looks okay.\n\nMake sure each line is preceded by arrow if necessary. In example, they use \"→ Step 1: ...\". For Start and End lines, no arrow. So we follow.\n\nNow produce final output.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: max_num ← 10^n - 1 // 最高 n 位數\n→ Step 2: min_num ← 10^(n-1) // 最小 n 位數\n→ Step 3: max_pal ← 0 // 目前已找到的最大回文乘積\n→ Step 4: answer ← 1 // 乘積結果，初始為 1\n→ Step 5: 對 a ← max_num 下降至 min_num // 外層迴圈\n→ Decision: a < min_num? // 判斷外層迴圈結束\n    Yes → End // 所有組合已檢查，結束程式\n    No →\n        → Step 6: 對 b ← a 下降至 min_num // 內層迴圈\n        → Decision: b < min_num? // 判斷內層迴圈結束\n            Yes →\n                → Decision: a < min_num? // 再次檢查外層\n                    Yes → End\n                    No → Back to Step 5\n            No →\n                → Step 7: product ← a * b // 乘積\n                → Decision: product ≤ max_pal? // 若已不可能更大\n                    Yes →\n                        → Step 8: 內層迴圈提前結束 // 直接跳到下一個 a\n                        → Decision: a < min_num? // 外層檢查\n                            Yes → End\n                            No → Back to Step 5\n                    No →\n                        → Step 9: is_palindrome ← isPalindrome(product) // 判斷回文\n                        → Decision: is_palindrome? // 判斷結果\n                            Yes →\n                                → Step 10: max_pal ← product // 更新最大回文\n                                → Step 11: answer ← (answer * (product mod 1337)) mod 1337 // 更新答案並取模\n                                → Decision: a < min_num? // 外層檢查\n                                    Yes → End\n                                    No → Back to Step 5\n                            No →\n                                → Decision: a < min_num? // 外層檢查\n                                    Yes → End\n                                    No → Back to Step 5",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def largestPalindrome(self, n: int) -> int:\n        # n = 1 is a special case: the largest palindrome product is 9\n        if n == 1:\n            return 9\n\n        # Upper and lower bounds for n-digit numbers\n        max_num = 10 ** n - 1\n        min_num = 10 ** (n - 1)\n\n        max_pal = 0\n\n        # Iterate over the first factor from largest to smallest\n        for a in range(max_num, min_num - 1, -1):\n            # If the product of a with itself is already <= current max_pal,\n            # no need to continue the inner loop\n            if a * a <= max_pal:\n                break\n\n            # Iterate over the second factor from a down to min_num\n            for b in range(a, min_num - 1, -1):\n                product = a * b\n                if product <= max_pal:\n                    # Further decreasing b will only produce smaller products\n                    break\n\n                if self.is_palindrome(product):\n                    max_pal = product\n                    # Once we find a palindrome for this a,\n                    # no need to check smaller b for the same a\n                    break\n\n        # Return the largest palindrome product modulo 1337\n        return max_pal % 1337\n\n    @staticmethod\n    def is_palindrome(num: int) -> bool:\n        s = str(num)\n        return s == s[::-1]\n\nif __name__ == \"__main__\":\n    # Read all input and extract the first integer\n    data = sys.stdin.read()\n    numbers = re.findall(r'\\d+', data)\n    if not numbers:\n        raise ValueError(\"No integer input found.\")\n    n = int(numbers[0])\n\n    solution = Solution()\n    result = solution.largestPalindrome(n)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "987",
          "success": true,
          "output": "987"
        },
        {
          "example_index": 1,
          "input": "n = 1",
          "expected_output": "9",
          "success": true,
          "output": "9"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode2410.json",
    "problem_index_in_file": 0,
    "title": "Maximum Matching of Players With Trainers",
    "description_snippet": "You are given a 0-indexed integer array players, where players[i] represents the ability of the i^th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code with comments. Problem: match players to trainers, each can match at most once. It's maximum bipartite matching under condition ability <= capacity. Equivalent to greedy matching after sorting: sort both arrays ascending, iterate players and trainers with two pointers, count matches when player <= trainer. That's typical. Virtual code steps: Start, input arrays, sort players, sort trainers, initialize pointers i=0,j=0, count=0. While i<players.len and j<trainers.len: if players[i]<=trainers[j] then count++, i++, j++; else j++? Wait typical: if player <= trainer, match and move both; else trainer < player, trainer too weak? Actually we need ability <= capacity; trainer capacity < player ability, so trainer can't match with current player or any later players? Actually players sorted ascending, if current trainer capacity < current player ability, then trainer cannot match any future player (since future players have greater or equal ability). So skip trainer (j++). So logic: if players[i] <= trainers[j] -> match; i++; j++; else j++. After loop, return count.\n\nWe need to produce virtual code with arrows, decisions. Use virtual code lines with explanation. Let's craft.\n\nWe should mention sorting arrays. Use decision blocks for condition checks. Provide lines.\n\nLet's output:\n\nStart // 開始\n\n→ Step 1: Sort players ascending // 依能力從小到大排序\n\n→ Step 2: Sort trainers ascending // 依訓練容量從小到大排序\n\n→ Step 3: Initialize i=0, j=0, matchCount=0 // 指標與計數初始化\n\n→ Decision: i < len(players) AND j < len(trainers)? // 判斷是否仍有未處理的選手與教練\n\n    Yes → Decision: players[i] <= trainers[j]? // 檢查當前選手是否可被當前教練配對\n\n        Yes → Step 4: matchCount++ ; i++; j++; // 成功配對，計數+1，兩指標前進\n\n        No  → Step 5: j++; // 教練容量不足，嘗試下一位教練\n\n    No → End // 所有選手或教練已處理完畢\n\nEnd // 程式結束，返回 matchCount\n\nBut we need each line: \"虛擬碼步驟 [space] // 解釋\". Also include arrows in decision? In sample, they use \"Decision:\" with arrow lines inside. We need to maintain that format. Use \"→ Decision:\" lines. Also for the Yes/No lines they indent and put \"Yes →\" etc. Use this structure.\n\nLet's produce lines accordingly. Ensure each line ends with comment.\n\nAlso include \"Return matchCount\" maybe separate step before End. In sample, End comment. We can include Step 6: Return matchCount // 回傳結果.\n\nLet's incorporate.\n\nNow produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort players ascending // 依能力由小到大排序  \n→ Step 2: Sort trainers ascending // 依訓練容量由小到大排序  \n→ Step 3: i = 0, j = 0, matchCount = 0 // 初始化兩個指標與計數  \n→ Decision: i < len(players) AND j < len(trainers)? // 是否還有未處理的選手與教練  \n  Yes → Decision: players[i] <= trainers[j]? // 判斷當前選手是否能被當前教練配對  \n    Yes → Step 4: matchCount++; i++; j++; // 成功配對，計數+1，兩指標同時前進  \n    No  → Step 5: j++; // 教練容量不足，嘗試下一位教練  \n  No → Step 6: Return matchCount // 所有選手或教練已處理完畢，回傳最大配對數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef match_players_and_trainers(players, trainers):\n    \"\"\"Return the maximum number of matchings where each player can be matched\n    with at most one trainer and vice versa, provided the player's ability\n    does not exceed the trainer's capacity.\"\"\"\n    players.sort()\n    trainers.sort()\n    i = j = matches = 0\n    while i < len(players) and j < len(trainers):\n        if players[i] <= trainers[j]:\n            matches += 1\n            i += 1\n        j += 1\n    return matches\n\ndef parse_input(data: str):\n    \"\"\"Extract two lists of integers from the input string.\"\"\"\n    # Find the two bracketed lists in the input\n    brackets = re.findall(r'\\[([^\\]]*)\\]', data)\n    if len(brackets) != 2:\n        # If the input format is not as expected, return empty lists\n        return [], []\n    # Convert each comma‑separated string to a list of ints\n    players = [int(x.strip()) for x in brackets[0].split(',') if x.strip()]\n    trainers = [int(x.strip()) for x in brackets[1].split(',') if x.strip()]\n    return players, trainers\n\nif __name__ == \"__main__\":\n    # Read all data from standard input\n    raw_input = sys.stdin.read()\n    players, trainers = parse_input(raw_input)\n    result = match_players_and_trainers(players, trainers)\n    # Output the result\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "players = [4,7,9], trainers = [8,2,5,8]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "players = [1,1,1], trainers = [10]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode461.json",
    "problem_index_in_file": 0,
    "title": "Hamming Distance",
    "description_snippet": "The Hamming distance between two integers is the number of positions at which the corresponding bits...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code step by step explaining Hamming distance between two integers. Use Start, Decision, End. Provide virtual steps line by line with explanation. Use arrows.\n\nWe need to include steps: Input x, y, maybe convert to binary or just XOR. The algorithm: XOR x and y, count set bits. Steps: Start, Step 1: Compute XOR, Step 2: Initialize count = 0, Step 3: While XOR > 0: if XOR & 1 then count++, XOR >>=1, Step 4: return count. Or simpler: while xor: count++, xor &= xor-1 (Brian Kernighan). Use Decision for loop.\n\nLet's produce virtual code accordingly. Ensure each line has \"虛擬碼步驟\" + space + \"// 解釋\". Provide arrows accordingly.\n\nWe'll use \"→\" arrows after Start.\n\nLet's produce: Start, → Step 1: 计算 XOR = x XOR y // 取得兩數的異或結果, 等於不同位的位\n\n→ Step 2: 初始化 count = 0 // 計數器用於儲存不同位數\n\n→ Step 3: Decision: 如果 XOR ≠ 0? // 檢查是否還有剩餘不同位\n\n    Yes → Step 4: count = count + 1 // 目前最低位不同，計數加一\n\n    Yes → Step 5: XOR = XOR >> 1 // 移除已檢查的最低位\n\n    Yes → Step 3 // 重新檢查新的 XOR\n\n    No  → Step 6: return count // 所有不同位已計數完成\n\nEnd // 程式執行結束\n\nBut we need to use \"Decision:\" lines, and the Yes and No branches properly indented.\n\nMaybe we should use loop representation:\n\nDecision: XOR != 0?\n\nYes → Step 4: count = count + 1\n\nYes → Step 5: XOR = XOR >> 1\n\nYes → Step 3 // loop\n\nNo → Step 6: return count\n\nBut arrow for decision? Let's format as per example:\n\nStart // 程式開始執行\n\n→ Step 1: Compute XOR = x XOR y // 取得兩數不同位\n\n→ Step 2: Initialize count = 0 // 計數器\n\n→ Decision: XOR ≠ 0? // 判斷是否還有位未處理\n\n    Yes → Step 3: count = count + 1 // 低位不同，計數\n\n    Yes → Step 4: XOR = XOR >> 1 // 移除已處理位\n\n    Yes → Step 2 // 重新判斷\n\n    No  → Step 5: return count // 完成\n\nEnd // 程式結束\n\nBut the example shows indentation for branches. We need to keep that. The steps for branches may be indented or not? In example they use indent for branches under decision. We'll replicate that.\n\nAlso include '→' arrow for each step. For decision branch we include indentation. So:\n\nStart // 程式開始執行\n→ Step 1: x XOR y → xor // 計算兩個數的 XOR\n→ Step 2: count = 0 // 初始化差距計數器\n→ Decision: xor ≠ 0? // 檢查是否還有不同位\n    Yes → Step 3: count = count + 1 // 低位不同，計數\n    Yes → Step 4: xor = xor >> 1 // 去掉已處理的位\n    Yes → Step 2 // 重新檢查\n    No  → Step 5: return count // 所有不同位已計算\nEnd // 程式執行結束\n\nBut we need to ensure each line has the format: \"虛擬碼步驟 [空格] // 解釋\". So \"Start // 程式開始執行\". For decisions we can put \"Decision:\" preceding.\n\nLet's create final answer.\n\nAlso mention that we use bitwise operations. Use arrow '→' before each step. Indentation for branches.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: x XOR y → xor // 計算兩個整數的 XOR，得到所有不同位的位\n→ Step 2: count = 0 // 初始化計數器，用於統計不同位的數量\n→ Decision: xor ≠ 0? // 判斷還有沒有剩餘未處理的不同位\n    Yes → Step 3: count = count + 1 // 低位不同，計數加一\n    Yes → Step 4: xor = xor >> 1 // 移除已處理的最低位，向右移位\n    Yes → Step 2 // 重新檢查新的 xor 值\n    No  → Step 5: return count // 所有不同位已經計算完成，返回結果\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef hamming_distance(x: int, y: int) -> int:\n    \"\"\"計算兩個整數的 Hamming 距離。\"\"\"\n    xor = x ^ y                # 取得兩數不同位的位\n    distance = 0\n    while xor:\n        distance += xor & 1    # 若最低位為 1，計數加一\n        xor >>= 1              # 移除已處理的最低位\n    return distance\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    data = sys.stdin.read().strip()\n    # 只取出整數（可處理正負號）\n    nums = re.findall(r'-?\\d+', data)\n    if len(nums) >= 2:\n        x, y = map(int, nums[:2])\n        print(hamming_distance(x, y))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "x = 1, y = 4",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "x = 3, y = 1",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode621.json",
    "problem_index_in_file": 0,
    "title": "Task Scheduler",
    "description_snippet": "You are given an array of CPU tasks, each labeled with a letter from A to Z, and a number n. Each CP...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode step-by-step. We need to think about algorithm: Count frequencies, find max freq, count how many tasks with max freq. The formula: (maxFreq-1)*(n+1)+maxCount; then result = max(total tasks, formula). But also we might need to handle n=0.\n\nSo produce steps: Start, Input tasks array and n. Count frequencies. Determine max freq and number of tasks with max freq. Compute empty slots. Compute available tasks to fill. Compute idle slots. Compute idle = max(0, emptySlots - availableTasks). Total intervals = tasks + idle. Or use formula. Then output. Let's produce pseudocode lines accordingly.\n\nWe must output line by line. Use Start, End, Decision, etc.\n\nWe need to keep in mind we are not writing actual code but pseudocode. Use arrow → to indicate next step. Provide explanation.\n\nLet's produce like:\n\nStart // 程式開始\n→ Step 1: 取得 tasks 陣列與 n // ...\n→ Step 2: 建立字典 freq 以統計每個字母出現次數 // ...\n→ Step 3: 找到最大頻率 maxFreq 以及具有此頻率的任務數目 maxCount // ...\n→ Decision: 如果 n == 0? // ...\n    Yes → Step 4: 結果 = tasks.Length // ...\n    No → Step 5: 計算空位 slots = (maxFreq - 1) * n // ...\n    → Step 6: 計算可用任務 fillTasks = tasks.Length - maxCount // ...\n    → Decision: 如果 slots > fillTasks? // ...\n        Yes → Step 7: idle = slots - fillTasks // ...\n        No  → Step 8: idle = 0 // ...\n    → Step 9: 結果 = tasks.Length + idle // ...\n→ End // 程式結束\n\nBut must also explain each line. Use //.\n\nMake sure each line includes the arrow and explanation. Also include \"Step\" label.\n\nWe need to use \"→\" at start of each line after Start? Example: The format example uses \"→ Step 1:\" etc.\n\nWe need to maintain indentation: Use indent for Decision branches maybe with two spaces? In example, they indent Yes → and No → within Decision block. We'll mimic.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入的 tasks 陣列與間隔 n // 從使用者或測試案例取得資料  \n→ Step 2: 建立字典 freq 以統計每個任務字母出現次數 // 方便後續找出最常見任務  \n→ Step 3: 找到最大頻率 maxFreq 與具有此頻率的任務數目 maxCount // 用於計算空位與閒置時間  \n→ Decision: 是否 n 等於 0? // 如果沒有間隔要求，直接完成所有任務  \n  Yes → Step 4: 計算總間隔為 tasks.Length // n=0 時不需要空位  \n  No  → Step 5: 計算需要的空位 slots = (maxFreq - 1) * n // 每一個最常見任務之間的最小間隔  \n   → Step 6: 計算可填充的其他任務數目 fillTasks = tasks.Length - maxCount // 除了最常見任務外的任務數量  \n   → Decision: slots 大於 fillTasks? // 判斷是否還需要閒置時間  \n    Yes → Step 7: idle = slots - fillTasks // 仍需要的閒置間隔數  \n    No  → Step 8: idle = 0 // 沒有閒置時間  \n   → Step 9: 計算總間隔 intervals = tasks.Length + idle // 任務數 + 必要的閒置  \n→ End // 程式執行結束，輸出 intervals 以上即為所需最小 CPU 間隔數。",
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import Counter\n\ndef least_interval(tasks, n):\n    \"\"\"Return the minimum number of CPU intervals required to finish all tasks.\"\"\"\n    if not tasks:\n        return 0\n    # Count frequency of each task\n    freq = Counter(tasks)\n    max_freq = max(freq.values())\n    # Number of tasks that appear max_freq times\n    max_count = sum(1 for v in freq.values() if v == max_freq)\n    # Compute intervals based on the formula\n    intervals = (max_freq - 1) * (n + 1) + max_count\n    # The answer cannot be less than the number of tasks\n    return max(intervals, len(tasks))\n\ndef parse_input(input_text):\n    \"\"\"Parse input of the form 'tasks = [...], n = X'.\"\"\"\n    tasks_match = re.search(r'tasks\\s*=\\s*(\\[[^\\]]*\\])', input_text)\n    n_match = re.search(r'n\\s*=\\s*(-?\\d+)', input_text)\n    if not tasks_match or not n_match:\n        raise ValueError(\"Input format is incorrect.\")\n    tasks_str = tasks_match.group(1)\n    n_str = n_match.group(1)\n    # Safely evaluate the list of tasks\n    tasks = ast.literal_eval(tasks_str)\n    n = int(n_str)\n    return tasks, n\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    raw_input = sys.stdin.read().strip()\n    # Parse tasks and n\n    tasks, n = parse_input(raw_input)\n    # Compute result\n    result = least_interval(tasks, n)\n    # Output the answer\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
          "expected_output": "8",
          "success": true,
          "output": "8"
        },
        {
          "example_index": 1,
          "input": "tasks = [\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"], n = 1",
          "expected_output": "6",
          "success": true,
          "output": "6"
        },
        {
          "example_index": 2,
          "input": "tasks = [\"A\",\"A\",\"A\", \"B\",\"B\",\"B\"], n = 3",
          "expected_output": "10",
          "success": true,
          "output": "10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode355.json",
    "problem_index_in_file": 0,
    "title": "Design Twitter",
    "description_snippet": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, an...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to generate virtual code with explanation lines. The user wants design of simplified Twitter with given methods. We'll produce pseudo steps for each method and overall structure. Use arrow. For each method, we can include steps. Also include initialization.\n\nWe must output in Traditional Chinese. Provide line by line.\n\nLet's craft: Start, then steps for Twitter() init, then postTweet, getNewsFeed, follow, unfollow. For each method maybe sub-steps. Provide Decision structures.\n\nLet's proceed.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立資料結構 // 初始化所有必要的資料結構  \n  → Step 1.1: 建立字典 userTweets: userId → 列表 (儲存此使用者發佈的 tweetId，按照發佈時間先後) // 追蹤每個使用者的推文  \n  → Step 1.2: 建立字典 followees: userId → 集合 (儲存此使用者關注的使用者) // 追蹤關注關係  \n  → Step 1.3: 建立全局計數器 timestamp ← 0 // 為每則推文賦予遞增的時間戳，方便排序  \n\nEnd // 初始化完成  \n\n---  \n\n// 方法：postTweet(userId, tweetId)  \nStart // 呼叫 postTweet  \n→ Step 2: timestamp ← timestamp + 1 // 取得新推文的時間戳  \n→ Step 2.1: 若 userId 未在 userTweets 中，則建立空列表 // 新使用者首次發文時初始化  \n→ Step 2.2: 在 userTweets[userId] 前插入 (timestamp, tweetId) // 儲存推文並保持時間先後  \nEnd // postTweet 完成  \n\n---  \n\n// 方法：getNewsFeed(userId)  \nStart // 呼叫 getNewsFeed  \n→ Step 3: 取得關注清單: followList ← followees.get(userId, 空集合) ∪ {userId} // 包含自己和關注的使用者  \n→ Step 3.1: 建立空列表 candidates ← [] // 用於收集候選推文  \n→ Step 3.2: 對於 each followee 在 followList  \n  → Step 3.2.1: 取其最近的前 10 個推文 userTweets[followee][:10]  \n  → Step 3.2.2: 將這些推文加到 candidates 中  \n→ Step 4: 使用最小堆（大小不超過 10）將 candidates 按時間戳排序，取出 10 個時間戳最大的推文  \n  → Step 4.1: 對 candidates 中每個 (timestamp, tweetId)  \n    → Decision: 如果堆大小 < 10? // 堆還未滿  \n      Yes → push (timestamp, tweetId)  \n      No → 若 timestamp > 堆頂時間戳? // 新推文更新  \n       Yes → pop 堆頂，push (timestamp, tweetId)  \n       No → 省略  \n→ Step 5: 取出堆中的元素，按時間戳降序排序，取 tweetId 形成結果列表 result  \n→ Step 6: 返回 result  \nEnd // getNewsFeed 完成  \n\n---  \n\n// 方法：follow(followerId, followeeId)  \nStart // 呼叫 follow  \n→ Step 7: 若 followerId 未在 followees 中，則建立空集合 // 新使用者首次關注時初始化  \n→ Step 7.1: 向 followees[followerId] 加入 followeeId // 建立關注關係  \nEnd // follow 完成  \n\n---  \n\n// 方法：unfollow(followerId, followeeId)  \nStart // 呼叫 unfollow  \n→ Step 8: 若 followerId 在 followees 中  \n  → Step 8.1: 從 followees[followerId] 中移除 followeeId（若存在） // 解除關注關係  \nEnd // unfollow 完成  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nimport heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)     # userId -> list of (time, tweetId)\n        self.following = defaultdict(set)   # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.time += 1\n        self.tweets[userId].append((self.time, tweetId))\n        # ensure user follows themselves\n        self.following[userId].add(userId)\n\n    def getNewsFeed(self, userId: int):\n        # ensure user follows themselves\n        self.following[userId].add(userId)\n\n        heap = []\n        # push the most recent tweet from each followee onto the heap\n        for fid in self.following[userId]:\n            tws = self.tweets.get(fid)\n            if tws:\n                idx = len(tws) - 1\n                ttime, tid = tws[idx]\n                heapq.heappush(heap, (-ttime, tid, fid, idx))\n\n        res = []\n        while heap and len(res) < 10:\n            negtime, tid, fid, idx = heapq.heappop(heap)\n            res.append(tid)\n            if idx > 0:\n                ttime, tid_prev = self.tweets[fid][idx - 1]\n                heapq.heappush(heap, (-ttime, tid_prev, fid, idx - 1))\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            # user automatically follows themselves\n            self.following[followerId].add(followerId)\n            return\n        self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followerId == followeeId:\n            return\n        self.following[followerId].discard(followeeId)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # input format: [\"Twitter\", \"postTweet\", ...], [[], [1, 5], ...]\n    parts = json.loads(data)\n    commands = parts[0]\n    args_list = parts[1]\n\n    twitter = Twitter()\n    results = []\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Twitter\":\n            results.append(None)\n        elif cmd == \"postTweet\":\n            twitter.postTweet(*args)\n            results.append(None)\n        elif cmd == \"getNewsFeed\":\n            res = twitter.getNewsFeed(*args)\n            results.append(res)\n        elif cmd == \"follow\":\n            twitter.follow(*args)\n            results.append(None)\n        elif cmd == \"unfollow\":\n            twitter.unfollow(*args)\n            results.append(None)\n        else:\n            # unknown command\n            results.append(None)\n\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"], [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]",
          "expected_output": "[null, null, [5], null, null, [6, 5], null, [5]]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmpfngqzew2.py\", line 57, in <module>\n    parts = json.loads(data)\n            ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 105 (char 104)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode303.json",
    "problem_index_in_file": 0,
    "title": "Range Sum Query - Immutable",
    "description_snippet": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of th...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for implementing NumArray class with prefix sum array. Must output in the specified format: each line with virtual code and comment. Use arrows etc. Must not output actual code, only steps.\n\nWe need to consider steps: Start, constructor, building prefix array, sumRange method. Provide decision? Not necessary. Just steps. Let's produce.\n\nWe need to show the class structure. Use Start and End. Provide arrow lines with Step numbers or method names. Each line has comment. Use \"→\" for steps. Provide decisions maybe for checking bounds? Might include if left>right? But problem states left <= right.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 NumArray 類別\n→ Step 2: 在建構子內部宣告 prefix 數組\n→ Step 3: 初始化 prefix[0] = 0\n→ Step 4: 迭代 nums 並填入 prefix[i+1] = prefix[i] + nums[i]\n→ Step 5: sumRange 方法接收 left、right\n→ Step 6: 回傳 prefix[right+1] - prefix[left]\nEnd\n\nAlso could include decision if left > right: No need.\n\nLet's produce in format:\n\nStart // 程式開始執行\n→ Step 1: 定義 NumArray 類別 // 建立類別結構\n→ Step 2: 在建構子中宣告 prefix 數組 // 用於儲存前綴和\n→ Step 3: 將 prefix[0] 設為 0 // 前綴和基底\n→ Step 4: 循環遍歷 nums，計算 prefix[i+1] = prefix[i] + nums[i] // 建立前綴和\n→ Step 5: sumRange 方法接收 left, right // 定義查詢函式\n→ Step 6: 回傳 prefix[right+1] - prefix[left] // 取得區間和\nEnd // 程式執行結束\n\nMake sure each line ends with comment.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 NumArray 類別 // 建立類別結構  \n→ Step 2: 在建構子中宣告 prefix 數組 // 用於儲存前綴和  \n→ Step 3: 將 prefix[0] 設為 0 // 前綴和基底  \n→ Step 4: 循環遍歷 nums，計算 prefix[i+1] = prefix[i] + nums[i] // 建立前綴和  \n→ Step 5: sumRange 方法接收 left, right // 定義查詢函式  \n→ Step 6: 回傳 prefix[right+1] - prefix[left] // 取得區間和  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列\n        self.prefix_sums = [0]\n        for num in nums:\n            self.prefix_sums.append(self.prefix_sums[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix_sums[right+1] - prefix_sums[left]\n        return self.prefix_sums[right + 1] - self.prefix_sums[left]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 分離操作名稱與對應參數\n    # 假設輸入格式為: ['[\"NumArray\", ...]', '[[...], ...]']\n    # 先切除最左側的引號與逗號\n    try:\n        ops_part, args_part = raw_input.split('],', 1)\n        ops_str = ops_part + ']'\n        args_str = args_part\n        ops = ast.literal_eval(ops_str)\n        args = ast.literal_eval(args_str)\n    except Exception:\n        # 若解析失敗，直接退出\n        sys.exit()\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"NumArray\":\n            # 建構子呼叫\n            obj = NumArray(arg[0])\n            results.append(None)\n        elif op == \"sumRange\" and obj is not None:\n            # sumRange 呼叫\n            results.append(obj.sumRange(*arg))\n        else:\n            # 忽略未知操作\n            results.append(None)\n\n    # 輸出結果，將 None 轉為 JSON 的 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "success": true,
          "output": "[null, 1, -1, -3]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode80.json",
    "problem_index_in_file": 0,
    "title": "Remove Duplicates from Sorted Array II",
    "description_snippet": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such tha...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for algorithm that removes duplicates to at most twice. We must produce lines: Start, → Step ... // explanation, Decision: ... etc.\n\nWe need to design algorithm. Standard solution: two pointers. Write to position i, keep count of occurrences of current number. Approach: keep index writeIdx. For each element from 0 to len-1, if writeIdx < 2 or nums[writeIdx-2] != nums[i] then set nums[writeIdx] = nums[i]; writeIdx++. Then return writeIdx.\n\nWe need to produce pseudocode steps with explanations. Include Start, End. Use Decision: if condition else. Use arrows.\n\nWe need to output only the virtual code lines. Each line: \"虛擬碼步驟\" + space + \"// 解釋\".\n\nLet's craft step-by-step:\n\n1. Start\n2. Step: initialize writeIndex = 0 // write position\n3. Step: iterate i from 0 to len(nums)-1 // read position\n4. Decision: if writeIndex < 2 or nums[writeIndex - 2] != nums[i]?\n    Yes → Step: nums[writeIndex] = nums[i] // keep element\n    Yes → Step: writeIndex += 1 // move write pointer\n    No → // skip element (duplicate beyond twice)\n5. End\n6. Return writeIndex // k\n\nBut need to output each line as separate line. Use arrow indentation for nested steps? Use \"→\" arrow. Use Decision lines with Yes / No. For No branch, nothing else or comment that it's skipped. Provide explanation.\n\nNeed to follow format: each line: \"虛擬碼步驟\" + space + \"// 解釋\". For Decision we need \"Decision:\" then condition. For Yes → steps, indent with \"→\". For No → we can just comment that nothing to do.\n\nLet's produce.\n\nAlso ensure we don't output actual code; just pseudocode.\n\nOk. Let's craft lines.\n\nStart // 程式開始執行\n→ Step: writeIdx ← 0 // 用來寫入允許重複兩次的元素\n→ Step: for i ← 0 to length(nums) - 1 do // 逐一檢查原陣列\n    Decision: if writeIdx < 2 or nums[writeIdx - 2] ≠ nums[i] ? // 判斷是否可以寫入\n        Yes → Step: nums[writeIdx] ← nums[i] // 將元素寫入允許位置\n        Yes → Step: writeIdx ← writeIdx + 1 // 更新寫入指標\n        No  → // 這個元素已出現超過兩次，跳過\nEnd // 程式執行結束\n→ Step: return writeIdx // k 個有效元素已寫入前 k 位\n\nCheck indentation: We need to keep same format with \"→\" for all steps including nested ones. For Decision we indent with no arrow? According to example, Decision line starts with \"Decision:\" and then lines with Yes → or No → each starting with \"→\" but indentation? In example they had:\n\nDecision: ...\n    Yes → Step...\n    No  → Decision...\n\nThey used indentation with spaces. We'll mimic: For Decision line, we can indent two spaces before Yes. But we should keep format: \"Decision:\" on its own line, then indent subsequent lines with \"→\". So we will do:\n\nDecision: if writeIdx < 2 or nums[writeIdx - 2] ≠ nums[i] ? // 判斷是否可以寫入\n    Yes → Step: nums[writeIdx] ← nums[i] // ...\n    Yes → Step: writeIdx ← writeIdx + 1 // ...\n    No  → // 這個元素已出現超過兩次，跳過\n\nThis matches style.\n\nAlso at the very beginning we had \"Start\". Then arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step: writeIdx ← 0 // 用來寫入允許重複兩次的元素  \n→ Step: for i ← 0 to length(nums) - 1 do // 逐一檢查原陣列  \n Decision: if writeIdx < 2 or nums[writeIdx - 2] ≠ nums[i] ? // 判斷是否可以寫入  \n  Yes → Step: nums[writeIdx] ← nums[i] // 將元素寫入允許位置  \n  Yes → Step: writeIdx ← writeIdx + 1 // 更新寫入指標  \n  No  → // 這個元素已出現超過兩次，跳過  \nEnd // 程式執行結束  \n→ Step: return writeIdx // k 個有效元素已寫入前 k 位",
      "generated_code": "import sys\nimport re\n\ndef remove_duplicates(nums):\n    if not nums:\n        return 0\n    write_idx = 0\n    for num in nums:\n        if write_idx < 2 or nums[write_idx - 2] != num:\n            nums[write_idx] = num\n            write_idx += 1\n    return write_idx\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    # Extract all integers from the input string\n    nums = [int(x) for x in re.findall(r'-?\\d+', data)]\n    k = remove_duplicates(nums)\n\n    # Build string representation with underscores for unused positions\n    elements = ', '.join(str(nums[i]) if i < k else '_' for i in range(len(nums)))\n    output = f\"{k}, nums = [{elements}]\"\n    print(output)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "success": true,
          "output": "5, nums = [1, 1, 2, 2, 3, _]"
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "success": true,
          "output": "7, nums = [0, 0, 1, 1, 2, 3, 3, _, _]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode29.json",
    "problem_index_in_file": 0,
    "title": "Divide Two Integers",
    "description_snippet": "Given two integers dividend and divisor, divide two integers without using multiplication, division,...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for integer division without *, /, %. Provide each line with explanation. We must use Start, End, Decision:, →, Yes →, No →. We need to cover algorithm: handle overflow, convert to negatives to avoid overflow, shift subtraction, etc. Provide step-by-step.\n\nWe should outline algorithm:\n\n- If dividend == INT_MIN and divisor == -1 return INT_MAX (overflow)\n- Convert both to negatives: sign = positive if signs same else negative\n- Make dividend negative (if positive, negate)\n- Make divisor negative (if positive, negate)\n- Initialize quotient = 0\n- While dividend <= divisor: (since negative numbers)\n    - temp = divisor\n    - multiple = 1\n    - while dividend <= (temp << 1) and (temp << 1) >= INT_MIN: temp <<=1; multiple <<=1\n    - dividend -= temp\n    - quotient += multiple\n- Apply sign to quotient\n- Return quotient\n\nEdge: negative INT_MIN etc. Use 32-bit.\n\nWe need to produce each line as virtual code.\n\nLet's produce lines:\n\nStart\n→ Step 1: 定義常數 INT_MAX = 2^31 - 1, INT_MIN = -2^31\n→ Step 2: 若 dividend == INT_MIN and divisor == -1 則返回 INT_MAX // 防止溢出\n→ Step 3: 計算 sign = (dividend > 0) XOR (divisor > 0) ? -1 : 1 // 判斷結果符號\n→ Step 4: 若 dividend > 0 則 dividend = -dividend // 轉為負數以避免溢出\n→ Step 5: 若 divisor > 0 則 divisor = -divisor // 同上\n→ Step 6: 初始化 quotient = 0 // 儲存結果\n→ Decision: dividend <= divisor? // 進行減法循環\n    Yes → Step 7: temp = divisor\n    → Step 8: multiple = 1\n    → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 盡可能把 temp 乘 2\n        Yes → temp <<= 1 // temp 乘 2\n        → multiple <<= 1 // multiple 乘 2\n        → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 重複\n            Yes → … // 循環\n            No  → Step 9: dividend -= temp // 把 temp 從 dividend 減去\n            → Step 10: quotient += multiple // 累加 quotient\n        No  → Step 9: dividend -= temp\n        → Step 10: quotient += multiple\n    No  → End // 迴圈結束\n→ Step 11: 若 sign == -1 則 quotient = -quotient // 反轉符號\n→ Step 12: 返回 quotient\n\nBut we need to express loops and decisions. Use indentation.\n\nWe need to show each line as \"虛擬碼步驟 [space] // 解釋\". We'll produce each line accordingly.\n\nWe need to show decisions with Yes → and No →.\n\nWe should include loops: Use Decision repeated.\n\nBetter to express loop using Decision: while dividend <= divisor: but we can write as Decision: dividend <= divisor? Yes→ ... No→End.\n\nBut we also need nested decisions.\n\nLet's produce a more structured pseudo-code:\n\nStart\n→ Step 1: 定義 INT_MAX, INT_MIN // 32 位整數上限下限\n→ Step 2: 如果 dividend == INT_MIN 且 divisor == -1 則返回 INT_MAX // 溢出處理\n→ Step 3: 計算 sign = ((dividend > 0) XOR (divisor > 0)) ? -1 : 1 // 確定結果符號\n→ Step 4: 如果 dividend > 0 則 dividend = -dividend // 轉為負數避免 overflow\n→ Step 5: 如果 divisor > 0 則 divisor = -divisor // 同上\n→ Step 6: 初始化 quotient = 0 // 存放商\n→ Decision: dividend <= divisor? // 循環條件，因負數比較\n    Yes →\n        → Step 7: temp = divisor\n        → Step 8: multiple = 1\n        → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 盡量左移\n            Yes →\n                → Step 9: temp <<= 1\n                → Step 10: multiple <<= 1\n                → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 重複左移\n                    Yes → … // 這裡不寫重複的細節\n                    No →\n                        → Step 11: dividend -= temp\n                        → Step 12: quotient += multiple\n            No →\n                → Step 13: dividend -= temp\n                → Step 14: quotient += multiple\n    No → End // 完成除法\n→ Step 15: 如果 sign == -1 則 quotient = -quotient // 反轉符號\n→ Step 16: 返回 quotient // 結果輸出\n\nBut we might need to show loop of while. Perhaps we can show as a Decision repeated by using a label. But we can keep simple.\n\nNeed to maintain indentation using tabs? Not required.\n\nWe should include \"Start\" and \"End\".\n\nLet's produce lines exactly with \"虛擬碼步驟\" etc.\n\nWill produce something like:\n\nStart // 程式開始\n\n→ Step 1: 定義 INT_MAX = 2^31 - 1, INT_MIN = -2^31 // 設定 32 位整數極限\n\n→ Step 2: 若 dividend == INT_MIN 且 divisor == -1 則返回 INT_MAX // 防止溢出\n\n→ Step 3: 計算 sign = ((dividend > 0) XOR (divisor > 0)) ? -1 : 1 // 確定商的符號\n\n→ Step 4: 若 dividend > 0 則 dividend = -dividend // 轉為負數以避免 INT_MIN 超限\n\n→ Step 5: 若 divisor > 0 則 divisor = -divisor // 同上\n\n→ Step 6: 初始化 quotient = 0 // 商的累積變數\n\n→ Decision: dividend <= divisor? // 只要 dividend 還能減去 divisor 就繼續\n\n    Yes →\n        → Step 7: temp = divisor // 暫存 divisor 的負值\n        → Step 8: multiple = 1 // 暫存倍數\n        → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 盡可能把 temp 乘 2\n            Yes →\n                → Step 9: temp <<= 1\n                → Step 10: multiple <<= 1\n                → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 迴圈檢查\n                    Yes → … // 連續左移，直到不符合條件\n                    No →\n                        → Step 11: dividend -= temp\n                        → Step 12: quotient += multiple\n            No →\n                → Step 13: dividend -= temp\n                → Step 14: quotient += multiple\n    No → End // 所有可減除的次數已完成\n\n→ Step 15: 若 sign == -1 則 quotient = -quotient // 把商轉回正負\n\n→ Step 16: 返回 quotient // 結果輸出\n\nBut we need to use arrow style exactly: \"→\", \"Yes →\", \"No →\" with indentation maybe.\n\nWe must show each line separate. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 INT_MAX = 2^31 - 1, INT_MIN = -2^31 // 設定 32 位整數上限下限\n→ Step 2: 若 dividend == INT_MIN 且 divisor == -1 則返回 INT_MAX // 防止溢出\n→ Step 3: 計算 sign = ((dividend > 0) XOR (divisor > 0)) ? -1 : 1 // 判斷結果符號\n→ Step 4: 若 dividend > 0 則 dividend = -dividend // 轉為負數避免 INT_MIN 溢出\n→ Step 5: 若 divisor > 0 則 divisor = -divisor // 同上\n→ Step 6: 初始化 quotient = 0 // 商的累積變數\n→ Decision: dividend <= divisor? // 循環條件，因負數比較\n    Yes →\n        → Step 7: temp = divisor // 暫存 divisor 的負值\n        → Step 8: multiple = 1 // 暫存倍數\n        → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 盡可能把 temp 乘 2\n            Yes →\n                → Step 9: temp <<= 1\n                → Step 10: multiple <<= 1\n                → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 重複左移\n                    Yes → … // 連續左移，直到不符合條件\n                    No →\n                        → Step 11: dividend -= temp\n                        → Step 12: quotient += multiple\n            No →\n                → Step 13: dividend -= temp\n                → Step 14: quotient += multiple\n    No → End // 所有可減除的次數已完成\n→ Step 15: 若 sign == -1 則 quotient = -quotient // 反轉符號\n→ Step 16: 返回 quotient // 結果輸出\nEnd // 程式結束執行\n\nBut need to use 'End' after returning? The End is for program finish. Actually we have End after the last return; we might need to place End after Step 16? Step 16 is return, after that End maybe not needed. But we can have End at final.\n\nWe also need to be careful with indentation: Each nested decision lines should be indented. We can use spaces.\n\nWe need to not produce code but virtual steps. Already fine.\n\nCheck requirement: Each line must include '虛擬碼步驟' + space + '// 解釋/說明'. Actually sample: \"Start // 程式開始執行\". So we just follow sample. For each step, write e.g. \"→ Step 1: ... // ...\" etc. Yes.\n\nNow ensure we use arrows '→', 'Yes →', 'No →'. Provide.\n\nAlso we need to indicate Decision lines: \"Decision:\" etc. Eg \"Decision: dividend <= divisor?\" Then indented following lines.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 INT_MAX = 2^31 - 1, INT_MIN = -2^31 // 設定 32 位整數上限下限  \n→ Step 2: 若 dividend == INT_MIN 且 divisor == -1 則返回 INT_MAX // 防止溢出  \n→ Step 3: 計算 sign = ((dividend > 0) XOR (divisor > 0)) ? -1 : 1 // 判斷結果符號  \n→ Step 4: 若 dividend > 0 則 dividend = -dividend // 轉為負數避免 INT_MIN 溢出  \n→ Step 5: 若 divisor > 0 則 divisor = -divisor // 同上  \n→ Step 6: 初始化 quotient = 0 // 商的累積變數  \n→ Decision: dividend <= divisor? // 循環條件，因負數比較  \n    Yes →  \n        → Step 7: temp = divisor // 暫存 divisor 的負值  \n        → Step 8: multiple = 1 // 暫存倍數  \n        → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 盡可能把 temp 乘 2  \n            Yes →  \n                → Step 9: temp <<= 1  \n                → Step 10: multiple <<= 1  \n                → Decision: dividend <= (temp << 1) 且 (temp << 1) >= INT_MIN? // 重複左移  \n                    Yes → … // 連續左移，直到不符合條件  \n                    No →  \n                        → Step 11: dividend -= temp  \n                        → Step 12: quotient += multiple  \n            No →  \n                → Step 13: dividend -= temp  \n                → Step 14: quotient += multiple  \n    No → End // 所有可減除的次數已完成  \n→ Step 15: 若 sign == -1 則 quotient = -quotient // 反轉符號  \n→ Step 16: 返回 quotient // 結果輸出  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        # Handle overflow case\n        if dividend == INT_MIN and divisor == -1:\n            return INT_MAX\n\n        negative = (dividend < 0) != (divisor < 0)\n\n        # Work with absolute values to simplify logic\n        a = abs(dividend)\n        b = abs(divisor)\n\n        quotient = 0\n        while a >= b:\n            temp = b\n            multiple = 1\n            # Double temp and multiple until temp would overflow a\n            while a >= (temp << 1):\n                temp <<= 1\n                multiple <<= 1\n            a -= temp\n            quotient += multiple\n\n        return -quotient if negative else quotient\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    input_data = sys.stdin.read()\n    # Extract integers (handles formats like \"dividend = 10, divisor = 3\")\n    nums = list(map(int, re.findall(r'-?\\d+', input_data)))\n    if len(nums) < 2:\n        sys.exit(\"Invalid input: expected two integers for dividend and divisor.\")\n    dividend, divisor = nums[0], nums[1]\n\n    solution = Solution()\n    result = solution.divide(dividend, divisor)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "dividend = 10, divisor = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "dividend = 7, divisor = -3",
          "expected_output": "-2",
          "success": true,
          "output": "-2"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode290.json",
    "problem_index_in_file": 0,
    "title": "Word Pattern",
    "description_snippet": "Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match,...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm: pattern match bijection between pattern letters and words. Use mapping dictionary for pattern->word and word->pattern. Steps: split s into words, check length. Iterate. Use mapping. Output result. We'll produce steps. Ensure each line has \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Let's produce algorithm.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 取得輸入變數 pattern 與 s // 讀入模式字串與待檢測字串\n→ Step 2: 以空格分割 s 為 words 陣列 // 將 s 拆成單字列表\n→ Decision: 是否 words 長度等於 pattern 長度? // 檢查字數與模式長度是否一致\n    Yes → Step 3: 初始化 mapPatternToWord 為空字典 // 建立字母對單字的映射表\n    No  → Step 4: 回傳 False // 若長度不符，無法對應，直接失敗\n→ Step 5: 初始化 mapWordToPattern 為空字典 // 建立單字對字母的映射表\n→ Step 6: 以索引 i 從 0 到 words.length-1 迭代\n    → Decision: pattern[i] 已存在於 mapPatternToWord? // 判斷此字母是否已映射\n        Yes →\n            → Decision: mapPatternToWord[pattern[i]] 是否等於 words[i]? // 確認映射單字是否相同\n                Yes → // 兩者一致，繼續下一個字母\n                No  → Step 7: 回傳 False // 映射不一致，失敗\n        No →\n            → Decision: words[i] 已存在於 mapWordToPattern? // 判斷此單字是否已被其他字母映射\n                Yes → Step 8: 回傳 False // 兩字母映射同一單字，失敗\n                No  → Step 9: 建立 mapPatternToWord[pattern[i]] = words[i] // 新增映射\n                      → Step 10: 建立 mapWordToPattern[words[i]] = pattern[i] // 同時新增逆映射\n→ Step 11: 回傳 True // 所有字母均成功映射且唯一，符合模式\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nfrom typing import Dict\n\nclass Solution:\n    \"\"\"\n    判斷字串 s 是否完全符合給定的 pattern。\n    每個 pattern 中的字母必須唯一映射到 s 中的一個非空單字，\n    同時單字與字母之間必須一一對應（雙向唯一）。\n    \"\"\"\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        # 把 s 以空白分割成單字列表\n        words = s.split()\n        # 若單字數量與 pattern 長度不符，直接失敗\n        if len(pattern) != len(words):\n            return False\n\n        # 建立兩張映射表：字母 → 單字，單字 → 字母\n        char_to_word: Dict[str, str] = {}\n        word_to_char: Dict[str, str] = {}\n\n        for c, w in zip(pattern, words):\n            # 已經有對應關係，檢查是否一致\n            if c in char_to_word:\n                if char_to_word[c] != w:\n                    return False\n            else:\n                char_to_word[c] = w\n\n            # 單字是否已被映射\n            if w in word_to_char:\n                if word_to_char[w] != c:\n                    return False\n            else:\n                word_to_char[w] = c\n\n        return True\n\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入資料解析出 pattern 與 s。\n    期望的格式類似於：\n        pattern = \"abba\", s = \"dog cat cat dog\"\n    \"\"\"\n    pattern_match = re.search(r'pattern\\s*=\\s*\"([^\"]+)\"', data)\n    s_match = re.search(r's\\s*=\\s*\"([^\"]+)\"', data)\n\n    if not pattern_match or not s_match:\n        raise ValueError(\"Invalid input format.\")\n\n    pattern = pattern_match.group(1)\n    s = s_match.group(1)\n    return pattern, s\n\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    input_data = sys.stdin.read()\n    if not input_data.strip():\n        sys.exit(0)\n\n    try:\n        pattern_str, s_str = parse_input(input_data)\n    except ValueError:\n        print(\"false\")\n        sys.exit(0)\n\n    sol = Solution()\n    result = sol.wordPattern(pattern_str, s_str)\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "pattern = \"abba\", s = \"dog cat cat dog\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "pattern = \"abba\", s = \"dog cat cat fish\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "pattern = \"aaaa\", s = \"dog cat cat dog\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode400.json",
    "problem_index_in_file": 0,
    "title": "Nth Digit",
    "description_snippet": "Given an integer n, return the n^th digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for problem: given integer n, find nth digit of infinite concatenated natural numbers starting from 1. Classic problem: find digit. Approach: Determine block of numbers with same length. Count digits in each block: length 1: 1-9 (9 digits), length 2: 10-99 (90*2=180 digits), etc. Find which block contains nth digit, find offset to number, then digit within that number.\n\nWe'll produce pseudo-code with Start, Decision etc. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's outline steps:\n\nStart\n→ Input n\n→ Initialize length=1, count=9, start=1, totalDigits=length*count\n→ Decision: while n > totalDigits? if yes: n -= totalDigits, length++, start*=10, count*=9, totalDigits=length*count; else exit loop\n→ After loop, the target number = start + (n-1)/length\n→ digitIndex = (n-1) % length\n→ Convert number to string, output char at digitIndex\n→ End\n\nWe need to use Decision lines with Yes/No arrows.\n\nImplement loop as Decision with Yes→ step inside, No→ after.\n\nLet's craft.\n\nAlso we might add an auxiliary step for computing digits etc.\n\nWe'll produce lines accordingly.\n\nWe need each line with virtual code and explanation. Use arrow notation.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 輸入整數 n // 取得使用者輸入的 n\n→ Step 2: 設定 length = 1, start = 1, count = 9 // 初始化數字位數、起始數字與可用數字數量\n→ Step 3: 計算 totalDigits = length * count // 本位數範圍內所有數字共佔的位數\n→ Decision: n > totalDigits? // 判斷 n 是否超過此位數範圍\n    Yes → Step 4: n = n - totalDigits // 把已經越過的位數扣除\n    Yes → Step 5: length = length + 1 // 進入下一位數範圍\n    Yes → Step 6: start = start * 10 // 更新起始數字為下一個位數的最小值\n    Yes → Step 7: count = count * 9 // 可用數字數量增加 9 倍\n    Yes → Step 8: totalDigits = length * count // 重新計算本位數範圍內的位數\n    Yes → Step 9: 回到 Decision // 重新檢查 n 是否仍超過範圍\n    No  → Step 10: 計算 targetNumber = start + (n - 1) / length // 找到包含目標位數的數字\n    No  → Step 11: 計算 digitIndex = (n - 1) % length // 確定在該數字內的第幾位\n    No  → Step 12: 將 targetNumber 轉成字串 strNumber // 方便取位\n    No  → Step 13: 取 strNumber[digitIndex] 為 result // 取得目標位數的字符\n    No  → Step 14: 輸出 result // 顯示結果\nEnd // 程式結束\n\nBut we need to use virtual code with arrows like \"Yes →\" and \"No →\". For loop we might use \"Decision:\".\n\nBetter to structure as:\n\nDecision: n > totalDigits?\n    Yes → Step 4...\n    No → Step 10...\n\nWe need to show \"→\" before steps.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 n // 取得使用者輸入的目標位數  \n→ Step 2: 設定 length = 1, start = 1, count = 9 // 初始化位數、起始數字與可用數字數量  \n→ Step 3: 計算 totalDigits = length * count // 本位數範圍內所有數字總共佔的位數  \n\nDecision: n > totalDigits? // 判斷 n 是否超過此位數範圍  \n    Yes → Step 4: n = n - totalDigits // 把已經越過的位數扣除  \n    Yes → Step 5: length = length + 1 // 進入下一位數範圍  \n    Yes → Step 6: start = start * 10 // 更新起始數字為下一個位數的最小值  \n    Yes → Step 7: count = count * 9 // 可用數字數量增加 9 倍  \n    Yes → Step 8: totalDigits = length * count // 重新計算本位數範圍內的位數  \n    Yes → Step 9: 回到 Decision // 重新檢查 n 是否仍超過範圍  \n    No  → Step 10: 計算 targetNumber = start + (n - 1) / length // 找到包含目標位數的數字  \n    No  → Step 11: 計算 digitIndex = (n - 1) % length // 確定在該數字內的第幾位  \n    No  → Step 12: 將 targetNumber 轉成字串 strNumber // 方便取位  \n    No  → Step 13: 取 strNumber[digitIndex] 為 result // 取得目標位數的字符  \n    No  → Step 14: 輸出 result // 顯示結果  \n\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef find_nth_digit(n: int) -> int:\n    \"\"\"Return the n-th digit in the infinite concatenated sequence 123456789101112….\"\"\"\n    length = 1          # current digit length of numbers\n    count = 9           # how many numbers have this digit length\n    start = 1           # first number with this digit length\n\n    # Move to the block that contains the n-th digit\n    while n > length * count:\n        n -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    # Find the exact number and digit within that number\n    start += (n - 1) // length\n    s = str(start)\n    return int(s[(n - 1) % length])\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract the first integer from the input, e.g. \"n = 11\" -> 11\n    match = re.search(r'\\d+', data)\n    if not match:\n        return\n    n = int(match.group())\n    result = find_nth_digit(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 11",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode504.json",
    "problem_index_in_file": 0,
    "title": "Base 7",
    "description_snippet": "Given an integer num, return a string of its base 7 representation....",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. We have the requirement: given integer num, return base 7 string. Steps: start, if num is zero return \"0\". Determine sign: negative? Then keep absolute value, loop while >0: digit = num % 7; push to stack or prepend; num = num // 7. After loop, join digits. If negative, prepend '-'. End.\n\nWe need to format as virtual code. Use Start, End, Decision, Steps, etc. Each line: \"虛擬碼步驟 // 解釋\". Use arrow. The steps must be line-by-line. We can show arrow for step 1 etc.\n\nWe need to include Start, End. Steps numbered maybe. Use \"→ Step X: ...\" for each step. Use Decision lines for branching.\n\nAlso handle negative check.\n\nWe'll produce as per example.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數 num // 從使用者或呼叫處取得整數  \n→ Decision: 如果 num 為 0? // 判斷是否為零  \n Yes → Step 2: 回傳字串 \"0\" // 零的七進位為 0，直接回傳  \n No  → Decision: 如果 num 為負? // 判斷是否為負數  \n  Yes → Step 3: 設定 sign = \"-\" // 記錄負號  \n   → Step 4: num = -num // 轉成正數進行後續計算  \n  No  → Step 3: 設定 sign = \"\" // 正數不需要負號  \n→ Step 5: 建立空字串 digits // 用於累積七進位的各位  \n→ Step 6: 迴圈開始 while num > 0 // 逐位計算七進位  \n  → Step 7: digit = num % 7 // 取最低位數字  \n   → Step 8: digits = digit + digits // 前置數字到字串前面  \n   → Step 9: num = num // 7 // 移除已處理的最低位  \n→ Step 10: 計算結果 = sign + digits // 加上符號並形成最終字串  \n→ Step 11: 回傳結果 // 將七進位字串返回給呼叫者  \nEnd // 程式執行結束",
      "generated_code": "# -*- coding: utf-8 -*-\n\"\"\"\nBase 7 conversion utility with a command‑line interface.\n\nThe program reads a single integer from standard input, converts it\nto base 7, and prints the result.  It implements the conversion logic\ninside a ``Solution`` class to mirror typical interview or coding‑platform\nstyle, but also provides a generic ``main`` block for standalone use.\n\"\"\"\n\nclass Solution:\n    def convertToBase7(self, num: int) -> str:\n        \"\"\"\n        Convert an integer to its base 7 string representation.\n\n        Args:\n            num: The integer to convert.\n\n        Returns:\n            A string containing the base 7 representation of ``num``.\n        \"\"\"\n        # Special case: zero is represented by the single digit '0'\n        if num == 0:\n            return \"0\"\n\n        # Remember if the number is negative; conversion is done on its\n        # absolute value, and a minus sign is added afterwards.\n        negative = num < 0\n        num = abs(num)\n\n        # Build the digits in reverse order.\n        digits = []\n        while num > 0:\n            digits.append(str(num % 7))\n            num //= 7\n\n        # If the original number was negative, prepend a minus sign.\n        if negative:\n            digits.append('-')\n\n        # The digits list currently holds the least‑significant digit first,\n        # so reverse it to obtain the correct order.\n        return ''.join(reversed(digits))\n\n\ndef main() -> None:\n    \"\"\"\n    Read an integer from standard input, convert it to base 7,\n    and print the result.\n    \"\"\"\n    import sys\n\n    # Read the entire input and strip any surrounding whitespace.\n    data = sys.stdin.read().strip()\n    if not data:\n        return  # No input provided.\n\n    # Convert the input string to an integer.\n    try:\n        num = int(data)\n    except ValueError:\n        # If the input is not a valid integer, exit gracefully.\n        print(\"Invalid input: expected an integer.\", file=sys.stderr)\n        return\n\n    # Perform the conversion and output the result.\n    solver = Solution()\n    result = solver.convertToBase7(num)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "100",
          "expected_output": "\"202\"",
          "success": true,
          "output": "202"
        },
        {
          "example_index": 1,
          "input": "-7",
          "expected_output": "\"-10\"",
          "success": true,
          "output": "-10"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode460.json",
    "problem_index_in_file": 0,
    "title": "LFU Cache",
    "description_snippet": "Design and implement a data structure for a Least Frequently Used (LFU) cache.\n\nImplement the LFUCac...",
    "examples_loaded": 1,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing LFU cache. The steps should be line-by-line, each line with \"虛擬碼步驟 // 解釋\". Use arrows and structure. We should include Start, End, Decision, etc. The user wants design and implement data structure for LFU cache. Steps include initialization, get, put, maintain freq map, minFreq, etc. The virtual code should reflect logic: use hash maps for key to node, freq to linked list of keys, node has key, value, freq. On get: if key not exist return -1, else update freq, move node to freq+1 list, update minFreq if necessary. On put: if capacity 0 return; if key exists: update value, same as get for freq; else if cache at capacity: evict key with minFreq list's head; remove from key map; then insert new node with freq 1, add to freq list, set minFreq=1. Ensure O(1). Provide steps for initialization of structures. Should include decision blocks for key existence, capacity, etc.\n\nWe need to produce \"虛擬碼\" steps. Use arrow `→` and indentation. Provide short explanations. Let's structure:\n\nStart\n→ Step 1: Initialize capacity, keyMap, freqMap, minFreq // Set up main data structures\n→ Step 2: Define Node structure // Node contains key, value, freq\n\nDefine get\n→ Step 3: Check if key exists in keyMap // Determine presence\n    Yes → Step 4: Retrieve node // Get node\n        → Step 5: Increment freq // Update frequency\n        → Step 6: Move node from current freq list to freq+1 list // Re-link\n        → Step 7: If current freq list empty and freq == minFreq → Step 8: Increment minFreq // Update minFreq\n        → Step 9: Return node.value // Successful get\n    No  → Step 10: Return -1 // Key not found\n\nDefine put\n→ Step 11: If capacity == 0 → End // No storage\n→ Step 12: If key exists in keyMap\n    Yes → Step 13: Update node.value // Set new value\n        → Step 14: Perform same freq update as get // Reuse logic\n    No  → Step 15: If cache size == capacity\n        Yes → Step 16: Identify key to evict from freqMap[minFreq] head // Get LRU among min freq\n            → Step 17: Remove evicted key from keyMap // Delete mapping\n            → Step 18: Remove node from freqMap[minFreq] list // Delete from list\n        No → No action // No eviction needed\n        → Step 19: Create new node with freq=1 // New node\n            → Step 20: Add node to keyMap // Insert mapping\n            → Step 21: Add node to freqMap[1] list // Insert into freq list\n            → Step 22: Set minFreq = 1 // Reset minFreq\nEnd\n\nWe may need to include Decision blocks for various conditions. Use \"Decision:\" with \"Yes →\" \"No →\". The structure must include indentation for nested decisions.\n\nWe need to output line by line. Each line includes virtual code step, a space, then `//` comment.\n\nLet's create the output accordingly. Use proper indentation for nested decisions.\n\nThe user asked to generate \"虛擬碼\" and line-by-line explanation. So we need to produce the entire algorithm. Let's write.\n\nWe can start with:\n\nStart // 程式開始執行\n\n→ Step 1: Set capacity, minFreq, keyMap, freqMap // 初始化容量、最小頻率、鍵值對映射與頻率映射\n\nDefine Node structure maybe separate. But maybe we can skip explicit Node definition? We'll include.\n\n→ Step 2: Define Node(key, value, freq) // 資料節點包含鍵、值與頻率\n\nNow get function:\n\n→ Step 3: Define get(key) // 取得 key 的值\n\n→ Decision: key 在 keyMap 中? // 檢查 key 是否存在\n    Yes → Step 4: node = keyMap[key] // 取得節點\n        → Step 5: freq = node.freq // 讀取當前頻率\n        → Step 6: Remove node from freqMap[freq] list // 從舊頻率列表移除\n        → Step 7: node.freq = freq + 1 // 更新頻率\n        → Step 8: Add node to freqMap[freq+1] list // 加入新頻率列表\n        → Decision: freqMap[freq] 为空且 freq == minFreq? // 檢查是否需要調整最小頻率\n            Yes → Step 9: minFreq = minFreq + 1 // 更新最小頻率\n            No  → No // 保持不變\n        → Step 10: Return node.value // 回傳值\n    No  → Step 11: Return -1 // 未找到 key\n\nNow put function:\n\n→ Step 12: Define put(key, value) // 插入或更新 key\n\n→ Decision: capacity == 0? // 檢查容量是否為 0\n    Yes → End // 無法儲存\n    No  → No // 繼續\n\n→ Decision: key 在 keyMap 中? // 檢查 key 是否已存在\n    Yes → Step 13: node = keyMap[key] // 取得節點\n        → Step 14: node.value = value // 更新值\n        → Step 15: freq = node.freq // 讀取頻率\n        → Step 16: Remove node from freqMap[freq] list // 從舊頻率列表移除\n        → Step 17: node.freq = freq + 1 // 更新頻率\n        → Step 18: Add node to freqMap[freq+1] list // 加入新頻率列表\n        → Decision: freqMap[freq] 为空且 freq == minFreq? // 檢查是否需要調整最小頻率\n            Yes → Step 19: minFreq = minFreq + 1 // 更新最小頻率\n            No  → No // 保持不變\n    No  → Step 20: If keyMap.size == capacity? // 判斷是否已滿\n            Yes → Step 21: evictKey = freqMap[minFreq].head.key // 找到最舊的最小頻率鍵\n                → Step 22: Remove evictKey from keyMap // 從鍵值對映射移除\n                → Step 23: Remove evictKey node from freqMap[minFreq] list // 從頻率列表移除\n            No  → No // 不需要淘汰\n            → Step 24: Create new node(key, value, freq=1) // 新節點\n                → Step 25: Add node to keyMap // 插入鍵值對映射\n                → Step 26: Add node to freqMap[1] list // 插入頻率列表\n                → Step 27: minFreq = 1 // 重置最小頻率\n\nEnd // 程式結束\n\nBut we need to maintain indentation. Each step line uses arrow `→`. For decisions, indent inside. The structure above may need consistent indentation. Use spaces.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set capacity, minFreq = 0, keyMap = {}, freqMap = {} // 初始化容量、最小頻率及映射表  \n→ Step 2: Define Node(key, value, freq) // 資料節點包含鍵、值與頻率  \n\n// ======== get(key) ========  \n→ Step 3: Define get(key) // 取得 key 的值  \n→ Decision: key 在 keyMap 中? // 檢查 key 是否存在  \n  Yes → Step 4: node = keyMap[key] // 取得節點  \n   → Step 5: freq = node.freq // 讀取當前頻率  \n   → Step 6: Remove node from freqMap[freq] list // 從舊頻率列表移除  \n   → Step 7: node.freq = freq + 1 // 更新頻率  \n   → Step 8: Add node to freqMap[freq+1] list // 加入新頻率列表  \n   → Decision: freqMap[freq] 为空且 freq == minFreq? // 若舊頻率表空且是最小頻率  \n    Yes → Step 9: minFreq = minFreq + 1 // 更新最小頻率  \n    No  → No // 不變  \n   → Step 10: Return node.value // 回傳值  \n  No  → Step 11: Return -1 // 未找到 key  \n\n// ======== put(key, value) ========  \n→ Step 12: Define put(key, value) // 插入或更新 key  \n→ Decision: capacity == 0? // 檢查容量是否為 0  \n  Yes → End // 無法儲存，直接結束  \n  No  → No // 繼續執行  \n→ Decision: key 在 keyMap 中? // 檢查 key 是否已存在  \n  Yes → Step 13: node = keyMap[key] // 取得節點  \n   → Step 14: node.value = value // 更新值  \n   → Step 15: freq = node.freq // 讀取頻率  \n   → Step 16: Remove node from freqMap[freq] list // 從舊頻率列表移除  \n   → Step 17: node.freq = freq + 1 // 更新頻率  \n   → Step 18: Add node to freqMap[freq+1] list // 加入新頻率列表  \n   → Decision: freqMap[freq] 为空且 freq == minFreq? // 檢查是否需調整最小頻率  \n    Yes → Step 19: minFreq = minFreq + 1 // 更新最小頻率  \n    No  → No // 保持不變  \n  No  → Step 20: If keyMap.size == capacity? // 判斷是否已滿  \n    Yes → Step 21: evictKey = freqMap[minFreq].head.key // 找到最舊的最小頻率鍵  \n     → Step 22: Remove evictKey from keyMap // 從鍵值對映射移除  \n     → Step 23: Remove evictKey node from freqMap[minFreq] list // 從頻率列表移除  \n    No  → No // 不需要淘汰  \n    → Step 24: node = Node(key, value, 1) // 新節點  \n    → Step 25: Add node to keyMap // 插入鍵值對映射  \n    → Step 26: Add node to freqMap[1] list // 插入頻率列表  \n    → Step 27: minFreq = 1 // 重置最小頻率  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport json\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}  # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current frequency list\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next frequency list\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key):\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\ndef list_to_str(lst):\n    parts = []\n    for x in lst:\n        if x is None:\n            parts.append('null')\n        else:\n            parts.append(str(x))\n    return '[' + ', '.join(parts) + ']'\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, params = json.loads(data)\n    cache = None\n    results = []\n    for op, param in zip(ops, params):\n        if op == \"LFUCache\":\n            cache = LFUCache(param[0])\n            results.append(None)\n        elif op == \"put\":\n            cache.put(param[0], param[1])\n            results.append(None)\n        elif op == \"get\":\n            val = cache.get(param[0])\n            results.append(val)\n    print(list_to_str(results))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "success": false,
          "output": "Traceback (most recent call last):\n  File \"/tmp/tmp2xxkzwhm.py\", line 78, in <module>\n    main()\n  File \"/tmp/tmp2xxkzwhm.py\", line 62, in main\n    ops, params = json.loads(data)\n                  ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 83 (char 82)"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode241.json",
    "problem_index_in_file": 0,
    "title": "Different Ways to Add Parentheses",
    "description_snippet": "Given a string expression of numbers and operators, return all possible results from computing all t...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code that describes algorithm to compute all possible results from different parenthesizations of expression. This is typical Leetcode problem \"Different Ways to Add Parentheses\". Approach: recursively compute all possible results by splitting at each operator. Use memoization. For each index range compute results. Steps: parse expression string into list of numbers and operators maybe. Or directly iterate over chars, when encounter operator at position i, split left and right. Recursion base: single number. Use dictionary map: key (l,r) -> results.\n\nWe output virtual code lines with arrows, decisions. Each line includes code comment after //. No actual code, but pseudo.\n\nWe'll structure: Start -> Parse expression into list tokens? Or not necessary, we can treat string indices.\n\nSteps:\n\nStart // program start\n\n→ Step 1: Define recursive function compute(l, r) // returns list of results for substring l..r\n\n→ Decision: if (l == r)? Actually if substring contains only number (no operator). We'll check by scanning for operator. But easier: if substring contains only digits, parse int and return list with that int.\n\n→ Decision: If cached results exist for (l,r) // memoization\n\nYes → Return cached list\n\nNo → Initialize empty list results\n\n→ For each position i from l to r:\n\n    → Decision: if char at i is operator\n\n    Yes → Recursively compute left = compute(l, i-1) // left part\n\n    → Recursively compute right = compute(i+1, r) // right part\n\n    → For each lv in left:\n\n        → For each rv in right:\n\n            → Compute result = apply operator at i to lv, rv\n\n            → Append result to results\n\n→ After loop, cache results for (l,r)\n\n→ Return results\n\nMain function:\n\n→ Step 2: Call compute(0, len(expr)-1) // full expression\n\n→ Step 3: Output results\n\nEnd\n\nAdd explanation comments.\n\nWe need to maintain the \"virtual code\" style with arrows, decision, etc.\n\nWe must not output actual code; just steps. Use \"→\" arrow for flow. For decisions use \"Decision:\".\n\nAlso use \"Start\" and \"End\". The \"→\" can prefix each line after decision? In example they used \"→ Step 1:\" etc.\n\nLet's produce.\n\nAlso need to handle splitting on indices; but we can use \"i\" loop.\n\nAlso we might need function to apply operator.\n\nUse \"→ Function: apply(op, a, b) // apply operator\" but may not necessary.\n\nLet's produce step-by-step.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: 定義遞迴函式 compute(start, end) // 計算子區間的所有結果\n\n→ Decision: 若子字串中沒有運算符? // 檢查區間是否為單一數字\n\nYes → Return [int(substring)] // 返回單一結果\n\nNo → 進行遞迴分割\n\n→ Decision: 是否已在 memo 中存有結果? // 檢查是否已計算過\n\nYes → Return memo[(start,end)] // 直接回傳快取結果\n\nNo → 初始化結果列表 results = []\n\n→ For i from start to end:\n\n    → Decision: 若字元 i 為運算符? // 找到可分割點\n\n    Yes →\n\n        → Step 2: left = compute(start, i-1) // 左側子表達式結果\n\n        → Step 3: right = compute(i+1, end) // 右側子表達式結果\n\n        → For each lv in left:\n\n            → For each rv in right:\n\n                → Step 4: res = apply(op at i, lv, rv) // 依運算符計算\n\n                → Append res to results\n\n→ Store results in memo[(start,end)]\n\n→ Return results\n\n→ End function\n\nMain:\n\n→ Step 5: memo = {} // 快取字典\n\n→ Step 6: all_results = compute(0, len(expr)-1) // 取得全部結果\n\n→ Step 7: 輸出 all_results\n\nEnd // 程式結束\n\nNeed to include \"Apply\" step. Provide explanation.\n\nLet's craft final answer in specified format. Ensure each line ends with // explanation.\n\nWe need each line separate with newline. Provide no code, just pseudocode lines with comments. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義遞迴函式 compute(start, end) // 計算子區間的所有可能結果  \n→ Decision: 子字串是否只包含數字? // 檢查區間是否為單一數字  \n  Yes → Return [int(substring)] // 回傳單一數字結果  \n  No → 進行遞迴分割  \n→ Decision: 是否已在 memo 中存有結果? // 檢查是否已計算過此區間  \n  Yes → Return memo[(start, end)] // 直接回傳快取結果  \n  No → 初始化結果列表 results = [] // 用於存放所有可能結果  \n→ For i從 start 到 end: // 遍歷區間內所有位置  \n  → Decision: 字元 i 是否為運算符? // 找到可分割點  \n   Yes →  \n  → Step 2: left = compute(start, i-1) // 計算左側子表達式的所有結果  \n  → Step 3: right = compute(i+1, end) // 計算右側子表達式的所有結果  \n  → For each lv in left: // 迭代左側結果  \n  →  For each rv in right: // 迭代右側結果  \n  →   → Step 4: res = apply(op at i, lv, rv) // 依運算符計算新結果  \n  →   → Append res 到 results // 加入結果列表  \n→ Store results 在 memo[(start, end)] // 快取以供未來重複使用  \n→ Return results // 回傳此區間的所有可能結果  \nEnd // 遞迴函式結束  \n\n// 主程式流程  \n→ Step 5: memo = {} // 建立快取字典  \n→ Step 6: all_results = compute(0, len(expr)-1) // 取得整個表達式的所有結果  \n→ Step 7: 輸出 all_results // 顯示所有不同的計算結果  \nEnd // 程式結束執行",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n            results = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                results.append(l + r)\n                            elif ch == '-':\n                                results.append(l - r)\n                            else:  # '*'\n                                results.append(l * r)\n            if not results:  # expr is a single number\n                results.append(int(expr))\n            memo[expr] = results\n            return results\n\n        return ways(expression)\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n    # Extract the expression inside single or double quotes\n    m = re.search(r'[\"\\'](.*?)[\"\\']', data)\n    expr = m.group(1) if m else data.strip()\n    sol = Solution()\n    res = sol.diffWaysToCompute(expr)\n    print(res)\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[2,0]",
          "success": true,
          "output": "[2, 0]"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-10,-14,-10,10]",
          "success": true,
          "output": "[-34, -10, -14, -10, 10]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode260.json",
    "problem_index_in_file": 0,
    "title": "Single Number III",
    "description_snippet": "Given an integer array nums, in which exactly two elements appear only once and all the other elemen...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code for algorithm: XOR all numbers to get xor of the two unique elements, then find a bit that differs, split into two groups, XOR each group to get each unique. Provide step-by-step virtual code with explanation. Ensure each line: virtual code step + // explanation. Use Start, End, Decision: etc. Provide lines like \"Start // 程式開始執行\" etc. For algorithm: 1. Initialize xor = 0. 2. For each num in nums: xor ^= num. 3. Find rightmost set bit in xor: diffBit = xor & -xor. 4. Initialize num1 = 0, num2 = 0. 5. For each num in nums: if num & diffBit != 0 then num1 ^= num else num2 ^= num. 6. Return [num1, num2]. Provide explanation each line.\n\nWe should ensure \"逐行\" means each step a line. Use arrow lines as given: \"→ Step 1: ...\" but each line is a step; the arrow lines may be prefixed with \"→\". The example had Start, → Step 1, → Decision. We'll mimic.\n\nWe need to ensure \"virtual code step\" phrase is something like \"Step 1: initialize xor = 0\". After the arrow maybe \"→ Step 1: ...\".\n\nMake sure we include \"Decision:\" lines for decisions. Eg: \"Decision: Find a bit that is set in xor?\" not necessary as it's just one line. We can include \"Decision: bit exists?\" but not needed.\n\nAlso must output in Traditional Chinese.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: 初始化 xor = 0 // 用於累積所有數字的 XOR\n→ Step 2: 對 nums 中的每個 num 執行 xor = xor XOR num // 最終 xor 等於兩個唯一數字的 XOR\n→ Step 3: 計算 diffBit = xor & (-xor) // 提取 xor 中最低位的 1，作為分隔兩個唯一數字的標記\n→ Step 4: 初始化 num1 = 0, num2 = 0 // 用於分別存儲兩個唯一數字\n→ Step 5: 對 nums 中的每個 num 執行\n  Decision: num & diffBit ≠ 0? // 判斷 num 是否屬於第一組\n   Yes → num1 = num1 XOR num // 把屬於第一組的數字進行 XOR\n   No  → num2 = num2 XOR num // 把屬於第二組的數字進行 XOR\n→ Step 6: 返回 [num1, num2] // 兩個唯一數字，順序任意\n\nEnd // 程式執行結束\n\nWe must ensure each line includes \"虛擬碼步驟\" + space + comment. So we have to add \"→\" and step names. The lines inside loop need to be considered separate? The example had a block for Decision. We'll emulate that: Step 5: for each num in nums: then Decision: etc. But each line must be \"虛擬碼步驟\" then comment. So \"Step 5: 對 nums 中的每個 num 執行\" is a step. Then we may indent Decision lines? Provide separate lines: \"Decision: num & diffBit ≠ 0?\" etc. But inside the loop we might need to mention loop context. Let's produce:\n\nStep 5: 對 nums 中的每個 num 執行 // 迭代每個數字\nDecision: num & diffBit ≠ 0? // 判斷該數字屬於哪一組\nYes → Step 5.1: num1 = num1 XOR num // 第一組的 XOR\nNo  → Step 5.2: num2 = num2 XOR num // 第二組的 XOR\n\nBut need to ensure \"虛擬碼步驟\" includes \"Step 5.1:\" etc. Provide arrow lines.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 xor = 0 // 用於累積所有數字的 XOR  \n→ Step 2: 對 nums 中的每個 num 執行 xor = xor XOR num // 最終 xor 等於兩個唯一數字的 XOR  \n→ Step 3: 計算 diffBit = xor & (-xor) // 提取 xor 中最低位的 1，作為分隔兩個唯一數字的標記  \n→ Step 4: 初始化 num1 = 0, num2 = 0 // 用於分別存儲兩個唯一數字  \n→ Step 5: 對 nums 中的每個 num 執行 // 迭代每個數字  \n  Decision: num & diffBit ≠ 0? // 判斷該數字屬於哪一組  \n   Yes → Step 5.1: num1 = num1 XOR num // 第一組的 XOR  \n   No  → Step 5.2: num2 = num2 XOR num // 第二組的 XOR  \n→ Step 6: 返回 [num1, num2] // 兩個唯一數字，順序任意  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def singleNumber(self, nums):\n        xor = 0\n        for num in nums:\n            xor ^= num\n\n        # 找到 xor 的最右邊 1\n        diff_bit = xor & -xor\n\n        a = b = 0\n        for num in nums:\n            if num & diff_bit:\n                a ^= num\n            else:\n                b ^= num\n        return [a, b]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 讀取形式可能為 \"nums = [1,2,1,3,2,5]\" 或僅 [1,2,1,3,2,5]\n    if data.startswith('nums'):\n        _, nums_str = data.split('=', 1)\n        nums = ast.literal_eval(nums_str.strip())\n    else:\n        nums = ast.literal_eval(data)\n    result = Solution().singleNumber(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,1,3,2,5]",
          "expected_output": "[3,5]",
          "success": true,
          "output": "[3, 5]"
        },
        {
          "example_index": 1,
          "input": "nums = [-1,0]",
          "expected_output": "[-1,0]",
          "success": true,
          "output": "[-1, 0]"
        },
        {
          "example_index": 2,
          "input": "nums = [0,1]",
          "expected_output": "[1,0]",
          "success": true,
          "output": "[1, 0]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode224.json",
    "problem_index_in_file": 0,
    "title": "Basic Calculator",
    "description_snippet": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and r...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations. The requirement: \"Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\" So we need to produce pseudocode for evaluating expression string with +, -, parentheses, spaces maybe, no eval. Should parse and compute. We must use Start, End, Decision, etc. Must output line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow →.\n\nWe must design algorithm: Use stack. Traverse string, accumulate numbers, push previous sign. When see '(' push current result and sign onto stack, reset. When see ')' pop sign and previous result, combine. Use integer result. Implementation details.\n\nLet's produce step-by-step. Use variable 'i', 'n', 'num', 'sign', 'result', stack. Let's produce steps:\n\nStart\n→ Initialize variables: result = 0, sign = 1, num = 0, stack = empty\n→ Iterate over each character in string s with index i\n    → If char is digit → accumulate num = num*10 + int(digit)\n    → Else if char is '+' or '-' → result += sign * num; num = 0; sign = 1 if '+' else -1\n    → Else if char is '(' → push result onto stack, push sign onto stack; result = 0; sign = 1\n    → Else if char is ')' → result += sign * num; num = 0; previous_sign = stack.pop(); previous_result = stack.pop(); result = previous_result + previous_sign * result\n    → Else if char is space → continue\nAfter loop: result += sign * num\nEnd\n\nBut must produce arrow lines. Also need Decision for each condition.\n\nWe need each line of virtual code with explanation. Should use \"Decision:\" for if statements.\n\nWe need to use \"→\" arrow at start of lines after start? Example format: \"→ Step 1: ... // ...\" or \"→ Decision: if digit? // ...\". For loops, maybe \"→ For each char in s: // ...\". Then decisions inside.\n\nLet's craft.\n\nWe'll use:\n\nStart // 程式開始執行\n→ Initialize result = 0, sign = 1, num = 0, stack = [] // 初始化變數\n→ For each character ch in s // 遍歷輸入字串\n    → Decision: ch 是數字? // 判斷是否為數字\n        Yes → num = num * 10 + int(ch) // 累積數字\n        No  → Decision: ch 是 '+' 或 '-'? // 判斷加減號\n            Yes → result = result + sign * num // 將前一個數加入結果\n                → num = 0 // 重置數字\n                → sign = 1 if ch == '+' else -1 // 設定新符號\n            No  → Decision: ch 是 '('? // 判斷左括號\n                Yes → stack.push(result) // 推入當前結果\n                    → stack.push(sign) // 推入當前符號\n                    → result = 0 // 重置結果\n                    → sign = 1 // 重置符號\n                No  → Decision: ch 是 ')'? // 判斷右括號\n                    Yes → result = result + sign * num // 加入最後一個數\n                        → num = 0 // 重置數字\n                        → prevSign = stack.pop() // 取回符號\n                        → prevResult = stack.pop() // 取回結果\n                        → result = prevResult + prevSign * result // 合併\n                    No  → Decision: ch 是空格? // 判斷空白\n                        Yes → // 跳過空白\n                        No  → // 其他字符（若有）忽略\n→ Decision: 循環結束後還有未加入的數字? // 迴圈結束後處理最後一個數字\n    Yes → result = result + sign * num // 加入最後一個數\n    No  → // 無需處理\nEnd // 程式執行結束\n\nBut we need each line to start with \"→\" maybe. We also need indentation or arrow for nested decisions. The format example uses \"→ Decision: ...\" and indentation for branches. We can follow that. Use \"→ Decision:\" etc. Use \"Yes →\" and \"No →\" lines for branches. For nested decisions, indent accordingly.\n\nMake sure each line ends with \" // 解釋\".\n\nLet's craft final output. Ensure consistent Chinese explanations. Use \"Start // 程式開始執行\". Use \"End // 程式執行結束\". Use arrow lines. For loops: \"→ For each character ch in s: // 遍歷輸入字串\". Inside, \"→ Decision: ch 是數字? // 判斷是否為數字\". Branch Yes, No etc.\n\nAlso, need to include \"決策\" lines for space or other char? We can treat else as skip. Keep it simple.\n\nAlso need to show stack operations: push, pop. Use \"stack.push\" etc.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize result = 0, sign = 1, num = 0, stack = [] // 初始化計算所需變數  \n→ For each character ch in s: // 遍歷輸入字串  \n  → Decision: ch 是數字? // 判斷是否為數字字符  \n   Yes → num = num * 10 + int(ch) // 累積多位數  \n   No → Decision: ch 是 '+' 或 '-'? // 判斷加減號  \n    Yes → result = result + sign * num // 將上一個數加入結果  \n     → num = 0 // 重置數字累積  \n     → sign = 1 if ch == '+' else -1 // 設定新符號  \n    No → Decision: ch 是 '('? // 判斷左括號  \n     Yes → stack.push(result) // 推入目前結果  \n      → stack.push(sign) // 推入目前符號  \n      → result = 0 // 重置結果以計算括號內部  \n      → sign = 1 // 重置符號  \n     No → Decision: ch 是 ')'? // 判斷右括號  \n      Yes → result = result + sign * num // 加入最後一個數字  \n       → num = 0 // 重置數字累積  \n       → prevSign = stack.pop() // 取回上一符號  \n       → prevResult = stack.pop() // 取回上一結果  \n       → result = prevResult + prevSign * result // 合併結果  \n      No → Decision: ch 是空白? // 判斷空白字符  \n       Yes → // 跳過空白  \n       No → // 忽略其他非關鍵字符  \n→ Decision: 循環結束後 num 是否 > 0? // 檢查是否還有未加入結果的數字  \n  Yes → result = result + sign * num // 加入最後一個數字  \n  No  → // 無需處理  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def calculate(self, s: str) -> int:\n        stack = []\n        res = 0\n        num = 0\n        sign = 1\n\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c in '+-':\n                res += sign * num\n                num = 0\n                sign = 1 if c == '+' else -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                # multiply by the sign before the parenthesis\n                res *= stack.pop()\n                # add the result before the parenthesis\n                res += stack.pop()\n        res += sign * num\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得表達式文字\n    if '=' in data:\n        expr = data.split('=', 1)[1].strip()\n    else:\n        expr = data\n\n    # 去除外層雙引號（若存在）\n    if expr.startswith('\"') and expr.endswith('\"'):\n        expr = expr[1:-1]\n\n    # 若仍包含多行，將其連接成一行\n    if '\\n' in expr:\n        expr = ' '.join(line.strip() for line in expr.splitlines())\n\n    result = Solution().calculate(expr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "success": true,
          "output": "23"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode55.json",
    "problem_index_in_file": 0,
    "title": "Jump Game",
    "description_snippet": "You are given an integer array nums. You are initially positioned at the array's first index, and ea...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the Jump Game problem. Provide step-by-step logic. Use Start, End, Decision. Each line with virtual code step and explanation comment. Avoid actual code. Provide algorithm: Greedy: track furthest reachable index. Iterate. If index > furthest, cannot reach. If furthest >= last index, true.\n\nProvide virtual steps.\n\nMake sure each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision: if condition. Use Yes → and No → lines. Use indenting.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums 並取得陣列長度 n // 獲得輸入資料  \n→ Step 2: 設定 furthest = 0 // 代表目前能到達的最遠索引  \n→ Step 3: 從 index = 0 開始迴圈，直到 index < n  \n  → Decision: index 之於 furthest 是否超過？ // 檢查當前位置是否可達  \n    Yes → End // 若 index > furthest，表示無法往前，結束並回傳 false  \n    No  → Step 4: 更新 furthest = max(furthest, index + nums[index]) // 擴大可到達範圍  \n     Decision: furthest 是否已達最後索引？ // 檢查是否已經可以到達結尾  \n      Yes → End // 若 furthest >= n-1，結束並回傳 true  \n      No  → Step 5: index = index + 1 // 移動到下一個位置並繼續迴圈  \n→ End // 若迴圈結束仍未回傳，表示無法到達最後索引，回傳 false",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canJump(self, nums):\n        \"\"\"\n        Determine if the last index is reachable from the first index.\n        Uses a greedy approach tracking the furthest reachable index.\n        \"\"\"\n        max_reach = 0\n        n = len(nums)\n        for i in range(n):\n            if i > max_reach:          # current position is unreachable\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True\n\ndef main():\n    # 讀取全部輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中提取方括號內的數字列表\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or start > end:\n        nums = []\n    else:\n        list_str = data[start:end+1]\n        nums = ast.literal_eval(list_str)\n\n    solution = Solution()\n    can_reach = solution.canJump(nums)\n\n    # 輸出符合範例的 'true' / 'false'\n    print('true' if can_reach else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,3,1,1,4]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [3,2,1,0,4]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode220.json",
    "problem_index_in_file": 0,
    "title": "Contains Duplicate III",
    "description_snippet": "You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indice...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to output virtual code. No actual code. The requirement: Step by step. Use Start, End, Decision. Provide explanation after each line. We need to implement algorithm. Approach: Use sliding window with balanced BST or hash map. But in virtual code we can describe a nested loop, but to be efficient we can use sliding window set and binary search tree. For simplicity, we can describe two nested loops with early break. But we need efficient algorithm: For each i, we keep a set of previous numbers within indexDiff. We need to query if any number in set has difference <= valueDiff. We can use balanced BST to find floor and ceil. Virtual code will illustrate this. Use pseudo steps: Start, initialize set, for i in 0..n-1: use Decision to check if any in set satisfies difference condition, if Yes then return true. Add nums[i] to set. If i >= indexDiff then remove nums[i-indexDiff] from set. After loop return false. End. Use Decision lines for check difference.\n\nWe need to show virtual code steps: Start, Step 1: Initialize data structure, Step 2: For i = 0 to n-1, Decision: Is there element in set with |x - nums[i]| <= valueDiff? Yes -> return true; No -> continue. Step 3: Add nums[i] to set. Step 4: If i >= indexDiff, remove nums[i-indexDiff] from set. Loop end. End. Return false. Also handle empty.\n\nLet's produce. Ensure each line uses arrow and explanation. Use '→' after each line? In example, they use '→ Step 1: ...'. So start with 'Start //'. Then arrow for each step. Use 'Decision:' lines indented maybe but still arrow. They use indentation with 4 spaces for nested steps. We'll produce accordingly.\n\nLet's craft:\n\nStart // 程式開始\n→ Step 1: 建立有序集合 window // 用於存放符合 indexDiff 條件的數值\n→ Step 2: 迴圈 i 從 0 到 nums.length-1 // 遍歷每個索引\n    → Decision: 是否存在窗口中數值 x 使 |x - nums[i]| ≤ valueDiff? // 檢查是否有符合 valueDiff 的數對\n        Yes → Return true // 找到符合條件的索引對，直接返回\n        No  → // 沒有符合條件，繼續處理\n    → Step 3: 將 nums[i] 加入窗口 // 將目前索引的值加入集合\n    → Decision: i ≥ indexDiff? // 判斷是否需要移除過舊索引對應的數值\n        Yes → Step 4: 移除 nums[i - indexDiff] 從窗口 // 使距離不超過 indexDiff\n        No  → // 不需要移除\n→ Return false // 完整遍歷後仍未找到符合條件，返回 false\nEnd // 程式結束\n\nWe should ensure each line has explanation after space. We must not output actual code, only virtual code steps. This meets requirements. Use arrow in each line after Step label. Provide indentation. Use 'Step' for actions. Provide 'Decision:' for decisions.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始  \n→ Step 1: 建立有序集合 window // 用於存放符合 indexDiff 條件的數值  \n→ Step 2: 迴圈 i 從 0 到 nums.length-1 // 遍歷每個索引  \n  → Decision: 是否存在窗口中數值 x 使 |x - nums[i]| ≤ valueDiff? // 檢查是否有符合 valueDiff 的數對  \n   Yes → Return true // 找到符合條件的索引對，直接返回  \n   No → // 沒有符合條件，繼續處理  \n  → Step 3: 將 nums[i] 加入窗口 // 將目前索引的值加入集合  \n  → Decision: i ≥ indexDiff? // 判斷是否需要移除過舊索引對應的數值  \n   Yes → Step 4: 移除 nums[i - indexDiff] 從窗口 // 使距離不超過 indexDiff  \n   No → // 不需要移除  \n→ Return false // 完整遍歷後仍未找到符合條件，返回 false  \nEnd // 程式結束",
      "generated_code": "import sys\nimport bisect\nimport re\n\nclass Solution:\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        判斷是否存在符合條件的索引對。\n        :param nums: 整數列表\n        :param k: indexDiff\n        :param t: valueDiff\n        :return: 布林值，若存在符合條件的索引對則為 True\n        \"\"\"\n        if k <= 0 or t < 0:\n            return False\n\n        window = []  # 有序窗口\n\n        for i, num in enumerate(nums):\n            # 在窗口中查找最小不小於 (num - t) 的位置\n            pos = bisect.bisect_left(window, num - t)\n            # 若該位置存在且差值不超過 t，則找到了合法對\n            if pos < len(window) and abs(window[pos] - num) <= t:\n                return True\n\n            # 插入當前數字，保持有序\n            bisect.insort(window, num)\n\n            # 保持窗口大小不超過 k\n            if len(window) > k:\n                # 刪除最舊的數字\n                idx_to_remove = bisect.bisect_left(window, nums[i - k])\n                # 可能出現同值，需要確保刪除正確的索引\n                while idx_to_remove < len(window) and window[idx_to_remove] != nums[i - k]:\n                    idx_to_remove += 1\n                if idx_to_remove < len(window):\n                    window.pop(idx_to_remove)\n\n        return False\n\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從輸入字串解析出 nums、indexDiff、valueDiff。\n    \"\"\"\n    # 解析 nums 列表\n    nums_match = re.search(r'\\[([^\\]]*)\\]', input_str)\n    if nums_match:\n        nums_str = nums_match.group(1).strip()\n        nums = [int(x.strip()) for x in nums_str.split(',')] if nums_str else []\n    else:\n        nums = []\n\n    # 解析 indexDiff\n    index_match = re.search(r'indexDiff\\s*=\\s*(-?\\d+)', input_str)\n    index_diff = int(index_match.group(1)) if index_match else 0\n\n    # 解析 valueDiff\n    value_match = re.search(r'valueDiff\\s*=\\s*(-?\\d+)', input_str)\n    value_diff = int(value_match.group(1)) if value_match else 0\n\n    return nums, index_diff, value_diff\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    nums, index_diff, value_diff = parse_input(raw_input)\n\n    solution = Solution()\n    result = solution.containsNearbyAlmostDuplicate(nums, index_diff, value_diff)\n\n    # 按要求輸出小寫的 true/false\n    print(\"true\" if result else \"false\")",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3,1], indexDiff = 3, valueDiff = 0",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode229.json",
    "problem_index_in_file": 0,
    "title": "Majority Element II",
    "description_snippet": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times....",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with arrow and explanation. This is the Boyer-Moore majority vote algorithm generalized for n/3. The algorithm: maintain up to two candidates and counts. Then second pass to confirm counts > n/3. Steps: input array; initialize candidate1, candidate2, count1, count2; iterate through array: if element equals candidate1, count1++; else if equals candidate2, count2++; else if count1==0, candidate1 = element, count1=1; else if count2==0, candidate2=element, count2=1; else count1--, count2--. After first pass, reset counts and count occurrences; check > n/3. Output list. Provide virtual code line by line.\n\nWe must adhere to format: each line: `虛擬碼步驟 // 解釋`. Use arrows. Starting: Start. Then steps. Use indent for nested decisions. Use `Decision:`.\n\nLet's craft:\n\nStart\n→ Step 1: Read array A of size n // 取得輸入陣列\n→ Step 2: Initialize cand1 = None, cand2 = None, count1 = 0, count2 = 0 // 準備候選人\n→ Step 3: For each num in A // 第一遍：找出最多兩個候選人\n    → Decision: num == cand1? // 檢查是否為第一候選人\n        Yes → count1++ // 只增計數\n        No  → Decision: num == cand2? // 檢查是否為第二候選人\n            Yes → count2++ \n            No  → Decision: count1 == 0? // 沒有第一候選人\n                Yes → cand1 = num; count1 = 1\n                No  → Decision: count2 == 0? // 沒有第二候選人\n                    Yes → cand2 = num; count2 = 1\n                    No  → count1--; count2-- // 兩者都不匹配，兩計數減一\n→ Step 4: Reset count1 = 0, count2 = 0 // 第二遍：確認候選人實際出現次數\n→ Step 5: For each num in A\n    → Decision: num == cand1? // 計數候選人1\n        Yes → count1++ \n        No  → Decision: num == cand2? // 計數候選人2\n            Yes → count2++ \n→ Step 6: Initialize result = [] // 儲存符合條件的元素\n→ Step 7: If count1 > n/3 Then add cand1 to result // 檢查候選人1是否符合\n→ Step 8: If count2 > n/3 Then add cand2 to result // 檢查候選人2是否符合\n→ Step 9: Output result // 顯示所有符合的元素\nEnd\n\nMake sure each line has arrow? For Step 3 loops we can write `→ Step 3: For each num in A` and indent the Decision. Use `Decision:` lines with indentation. Ensure format. Provide as plain text. Let's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 讀取整數陣列 A（大小為 n） // 從使用者或資料來源取得輸入\n→ Step 2: 初始化 cand1 = None, cand2 = None, count1 = 0, count2 = 0 // 準備兩個候選人與計數\n→ Step 3: For each num in A // 第一遍：找出最多兩個候選人\n    → Decision: num == cand1? // 判斷是否為第一候選人\n        Yes → count1++ // 第一候選人數量加一\n        No  → Decision: num == cand2? // 判斷是否為第二候選人\n            Yes → count2++ // 第二候選人數量加一\n            No  → Decision: count1 == 0? // 若第一候選人尚未設定\n                Yes → cand1 = num; count1 = 1 // 設定第一候選人\n                No  → Decision: count2 == 0? // 若第二候選人尚未設定\n                    Yes → cand2 = num; count2 = 1 // 設定第二候選人\n                    No  → count1--; count2-- // 兩者皆不匹配，兩計數同時減一\n→ Step 4: Reset count1 = 0, count2 = 0 // 第二遍：重新計算候選人實際出現次數\n→ Step 5: For each num in A\n    → Decision: num == cand1? // 統計第一候選人的出現次數\n        Yes → count1++ \n        No  → Decision: num == cand2? // 統計第二候選人的出現次數\n            Yes → count2++ \n→ Step 6: 初始化 result = [] // 儲存符合條件的元素\n→ Step 7: If count1 > n/3 Then result.add(cand1) // 檢查第一候選人是否超過 n/3\n→ Step 8: If count2 > n/3 Then result.add(cand2) // 檢查第二候選人是否超過 n/3\n→ Step 9: 輸出 result // 顯示所有符合條件的元素\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def majorityElement(self, nums):\n        if not nums:\n            return []\n\n        candidate1, candidate2 = None, None\n        count1, count2 = 0, 0\n\n        # 第一遍：找出最多兩個候選人\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:\n                candidate1, count1 = num, 1\n            elif count2 == 0:\n                candidate2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n\n        # 第二遍：確認候選人實際出現次數\n        result = []\n        n = len(nums)\n        count1 = count2 = 0\n        for num in nums:\n            if num == candidate1:\n                count1 += 1\n            elif num == candidate2:\n                count2 += 1\n\n        if count1 > n // 3:\n            result.append(candidate1)\n        if count2 > n // 3:\n            result.append(candidate2)\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入，支援格式如 'nums = [1, 2, 3]' 或直接 '[1, 2, 3]'。\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n\n    # 若含 '='，取 '=' 右側\n    if '=' in data:\n        _, rhs = data.split('=', 1)\n        data = rhs.strip()\n\n    # 用 ast.literal_eval 解析為 Python 物件\n    try:\n        return ast.literal_eval(data)\n    except Exception:\n        # 若解析失敗，回傳空清單\n        return []\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n    sol = Solution()\n    result = sol.majorityElement(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [3,2,3]",
          "expected_output": "[3]",
          "success": true,
          "output": "[3]"
        },
        {
          "example_index": 1,
          "input": "nums = [1]",
          "expected_output": "[1]",
          "success": true,
          "output": "[1]"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2]",
          "expected_output": "[1,2]",
          "success": true,
          "output": "[1, 2]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode136.json",
    "problem_index_in_file": 0,
    "title": "Single Number",
    "description_snippet": "Given a non-empty array of integers nums, every element appears twice except for one. Find that sing...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code for the problem: find unique element in array where others appear twice. Linear runtime, constant space. Standard solution: XOR all elements. The virtual code should reflect that.\n\nWe need to produce line-by-line virtual code with explanations after each line. Use structure: Start, End, Decision, etc. Use arrows. The virtual code: Start, Step: initialize result = 0, iterate through nums: XOR, return result.\n\nWe need to use the arrow symbol \"→\" to indicate steps. For decisions, but maybe not needed.\n\nWe can include a loop structure. Use Decision for loop? The standard pseudocode: Start → Step: result = 0 → For each num in nums: result = result XOR num → End.\n\nWe could add a Decision: If array empty? But problem states non-empty.\n\nWe could still include: Decision: Is nums empty? No → proceed.\n\nBut requirement: non-empty, linear time, constant space. So simple.\n\nBut the format: each line must contain \"虛擬碼步驟\" + \" \" + \"// 解釋/說明\". Use arrow \"→\". Also can use \"Start\" and \"End\". Use Decision only if needed.\n\nWe should keep consistent formatting: For example:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化結果為 0\n→ Step 2: 對於每個 num 在 nums 中 // 遍歷陣列\n    → Step 2a: result ← result XOR num // 將 num 與結果做 XOR\n→ Step 3: 返回 result // 唯一元素即為結果\nEnd // 程式結束\n\nBut each line should be separate. Need to use \"→\" preceding each step. For nested steps, we can indent or use multiple arrows? The format sample uses indentation with arrows. We'll mimic that.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化唯一元素的暫存變數\n→ Decision: 是否需要遍歷陣列? // 檢查是否還有元素待處理\n    Yes → Step 2: 對於每個 num 在 nums 中 // 逐一讀取陣列元素\n        → Step 2a: result ← result XOR num // 用 XOR 把相同數字抵消，保留唯一數字\n    No → End // 如果陣列已經遍歷完，結束\n→ Step 3: 返回 result // 回傳唯一出現一次的數字\nEnd // 程式執行結束\n\nBut the Decision \"是否需要遍歷陣列?\" is always true until end. We can skip decision.\n\nBetter:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化唯一數字\n→ Step 2: 對於每個 num 在 nums 中 // 逐一處理\n    → Step 2a: result ← result XOR num // XOR 把重複數字抵消\n→ Step 3: 返回 result // 最終唯一數字\nEnd // 程式結束\n\nWe need to adhere to format: each line is a separate line. For nested steps, we could indent with spaces but still each line has \"→\". The sample shows nested steps with arrow and indentation, and no additional arrows for nested. Eg:\n\n→ Decision: ...\n    Yes → Step...\n\nSo we can do:\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化唯一數字\n→ Step 2: 對於每個 num 在 nums 中 // 逐一處理\n    → Step 2a: result ← result XOR num // XOR 把重複數字抵消\n→ Step 3: 返回 result // 最終唯一數字\nEnd // 程式結束\n\nEach line includes \"→\" before each step except Start and End. For nested, we indent with spaces. Ensure each line has virtual code and explanation separated by space.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: result ← 0 // 初始化唯一數字的暫存變數\n→ Step 2: 對於每個 num 在 nums 中 // 逐一處理陣列元素\n    → Step 2a: result ← result XOR num // XOR 把重複出現的數字抵消，只保留唯一數字\n→ Step 3: 返回 result // 回傳最終得到的唯一元素\nEnd // 程式結束",
      "generated_code": "import sys\n\ndef main() -> None:\n    # 從標準輸入讀取整個內容\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入字串，找出列表部分\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1 or end < start:\n        nums = []\n    else:\n        # 取得 [ ... ] 之間的字串並 eval 為列表\n        nums_str = data[start:end + 1]\n        nums = eval(nums_str)\n\n    # 以 XOR 方式找出唯一數字\n    result = 0\n    for num in nums:\n        result ^= num\n\n    # 將結果輸出到標準輸出\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,2,1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "nums = [4,1,2,1,2]",
          "expected_output": "4",
          "success": true,
          "output": "4"
        },
        {
          "example_index": 2,
          "input": "nums = [1]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode520.json",
    "problem_index_in_file": 0,
    "title": "Detect Capital",
    "description_snippet": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\nAll le...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps line by line. The algorithm: check if all letters are uppercase, all lowercase, or only first uppercase rest lowercase. Return true if one holds. Steps: input word. Check conditions. Could do: check is_all_upper = word == word.upper(); is_all_lower = word == word.lower(); is_first_capital = word[0].isupper() and word[1:] == word[1:].lower(). Return is_all_upper or is_all_lower or is_first_capital.\n\nWe must use the structure with Start, Decision, Yes→, No→, End. We need to generate lines each with \"虛擬碼步驟\" then space then \"// 解釋/說明\". Use arrows →.\n\nWe must not output actual code but structure. So we can write pseudo like:\n\nStart // 開始\n→ Input word // 取得輸入字串\n→ Decision: word 全部大寫? // 判斷是否全部大寫\n    Yes → Return true // 條件滿足\n    No → Decision: word 全部小寫? // 判斷是否全部小寫\n        Yes → Return true // 條件滿足\n        No → Decision: 第一個字母大寫且其餘小寫? // 判斷首字母大寫其餘小寫\n            Yes → Return true // 條件滿足\n            No → Return false // 以上皆不符\nEnd\n\nMake sure each line uses the arrow format. Use \"→\" before each step. Use indentation maybe but not necessary. Use \"Decision:\" line, then Yes →, No →. Provide explanation after //.\n\nWe also need to mention \"虛擬碼步驟\" like \"Input word\". The lines should contain \"虛擬碼步驟\" maybe like \"Start\". The example used \"Start\" alone. So we follow same style. For decision lines, we use \"Decision:\" with condition. For Yes/No lines we use \"Yes → Step\" etc.\n\nWe need to maintain one step per line, each with explanation after //.\n\nSo produce:\n\nStart // 程式開始執行\n→ Input word // 取得輸入字串\n→ Decision: 如果 word 全部大寫? // 檢查是否所有字母都是大寫\n    Yes → Return true // 符合條件，直接回傳真\n    No → Decision: 如果 word 全部小寫? // 檢查是否所有字母都是小寫\n        Yes → Return true // 符合條件，直接回傳真\n        No → Decision: 如果第一個字母大寫且其餘小寫? // 檢查首字母大寫且其餘小寫\n            Yes → Return true // 符合條件，直接回傳真\n            No → Return false // 以上皆不符，回傳假\nEnd // 程式執行結束\n\nThat's it. Ensure each line has arrow and explanation. Use consistent formatting.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input word // 取得輸入字串  \n→ Decision: 如果 word 全部大寫? // 檢查是否所有字母都是大寫  \n    Yes → Return true // 符合條件，直接回傳真  \n    No → Decision: 如果 word 全部小寫? // 檢查是否所有字母都是小寫  \n        Yes → Return true // 符合條件，直接回傳真  \n        No → Decision: 如果第一個字母大寫且其餘小寫? // 檢查首字母大寫且其餘小寫  \n            Yes → Return true // 符合條件，直接回傳真  \n            No → Return false // 以上皆不符，回傳假  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        # 直接使用 str 內建方法判斷大小寫規則\n        return word.isupper() or word.islower() or word.istitle()\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取一行，並去除可能的前後空白與雙引號\n    raw_input = sys.stdin.readline().strip()\n    # 若輸入包含雙引號，將其移除\n    if raw_input.startswith('\"') and raw_input.endswith('\"'):\n        raw_input = raw_input[1:-1]\n    solution = Solution()\n    result = solution.detectCapitalUse(raw_input)\n    # 按題目要求輸出小寫的 true/false\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "\"USA\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "\"FlaG\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode171.json",
    "problem_index_in_file": 0,
    "title": "Excel Sheet Column Number",
    "description_snippet": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code lines that convert Excel column title to number. Provide each line with comment. Use Start, End, Decision, arrows. Should be step by step. Probably algorithm: iterate over characters, accumulate result = result * 26 + (char - 'A' + 1). Use for loop. Also handle string input. Provide pseudocode. Let's produce lines:\n\nStart\n→ Step 1: 初始化 result = 0 // 結果變數\n→ Step 2: 針對 columnTitle 的每個字元 char in columnTitle 循環\n    → Step 3: 計算數值 val = (ASCII value of char - ASCII value of 'A' + 1)\n    → Step 4: result = result * 26 + val // 累加\n→ Step 5: 輸出 result // 回傳欄號\nEnd\n\nBut need use Decision? Not necessary. But maybe include a Decision for empty string? But not required.\n\nI'll produce:\n\nStart // 程式開始\n→ Step 1: 設定 result ← 0 // 用於累積欄號\n→ Step 2: 對 columnTitle 的每個字元 c 進行迴圈\n    → Step 3: val ← (c - 'A' + 1) // 把字母轉為數值 1~26\n    → Step 4: result ← result * 26 + val // 進行十進制累加\n→ Step 5: 輸出 result // 回傳最終欄號\nEnd // 程式結束\n\nBut need arrow formatting: \"→\" before each step. Also need decision maybe for empty? We can include Decision: if columnTitle 為空? But not necessary.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: result ← 0 // 初始化累積變數為 0  \n→ Step 2: 對 columnTitle 的每個字元 c 進行迴圈  \n → Step 3: val ← (c - 'A' + 1) // 把字母轉為 1~26 的數值  \n → Step 4: result ← result * 26 + val // 依序累加得到最終欄號  \n→ Step 5: 輸出 result // 回傳計算得到的欄號  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        \"\"\"\n        將 Excel 欄位標題轉換為對應的欄號。\n        例如：'A' -> 1，'AA' -> 27。\n        \"\"\"\n        result = 0\n        for char in columnTitle:\n            result = result * 26 + (ord(char) - ord('A') + 1)\n        return result\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入，解析變數 assignment，\n    呼叫 titleToNumber，並將結果輸出到標準輸出。\n    \"\"\"\n    # 讀取全部輸入，並移除首尾空白與換行\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析形如 \"columnTitle = 'AB'\" 的字串\n    if '=' in data:\n        _, value = data.split('=', 1)\n        value = value.strip()\n        # 去除外層單引號或雙引號\n        if (value.startswith(\"'\") and value.endswith(\"'\")) or \\\n           (value.startswith('\"') and value.endswith('\"')):\n            value = value[1:-1]\n        column_title = value\n    else:\n        # 若直接提供字串，例如 \"'AB'\"，則直接去除引號\n        column_title = data.strip(\"'\\\"\")\n\n    solution = Solution()\n    result = solution.titleToNumber(column_title)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "columnTitle = 'A'",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "columnTitle = 'AB'",
          "expected_output": "28",
          "success": true,
          "output": "28"
        },
        {
          "example_index": 2,
          "input": "columnTitle = 'ZY'",
          "expected_output": "701",
          "success": true,
          "output": "701"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode39.json",
    "problem_index_in_file": 0,
    "title": "Combination Sum",
    "description_snippet": "Given an array of distinct integers candidates and a target integer target, return a list of all uni...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for combination sum. The user wants virtual code lines with explanation. So produce a step-by-step algorithm, likely DFS/backtracking. Use Start, End, Decision. Provide virtual code lines. Let's produce something like:\n\nStart // start\n→ Step 1: sort candidates // optional for pruning\n→ Step 2: call backtrack(0, [], 0) // start DFS\n\nDefine backtrack(index, path, currentSum):\n→ Decision: currentSum == target? // check if reached target\n    Yes → Step: add copy of path to result\n    No → Decision: currentSum > target? // exceed target\n        Yes → Step: return // prune\n        No → For each i from index to len(candidates)-1:\n                -> Step: append candidates[i] to path\n                -> Step: backtrack(i, path, currentSum + candidates[i]) // same index for unlimited use\n                -> Step: remove last from path // backtrack\n\nFinally, End.\n\nNeed to include step numbers maybe not necessary. The example shows Step 1: etc. We'll include steps. Use \"Step X:\" maybe not required. Keep consistent with sample.\n\nWe need to use arrow notation: \"→\" before each step. Use indentation for nested decisions.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 方便剪枝\n→ Step 2: Initialize result list // 儲存符合條件的組合\n→ Step 3: Call DFS(startIndex=0, currentSum=0, currentPath=[]) // 開始遞迴搜索\n\nDefine DFS(startIndex, currentSum, currentPath):\n    → Decision: currentSum == target? // 是否達到目標和\n        Yes → Step: Add copy of currentPath to result // 記錄有效組合\n        No  → Decision: currentSum > target? // 超過目標和\n                Yes → Step: Return // 直接回溯\n                No  → For i from startIndex to len(candidates)-1:\n                        → Step: Append candidates[i] to currentPath // 選擇數字\n                        → Step: DFS(i, currentSum + candidates[i], currentPath) // 允許重複使用同一數字\n                        → Step: Remove last element from currentPath // 回溯\n\n→ Step 4: Return result // 輸出所有組合\n\nEnd // 程式執行結束\n\nBut need to maintain virtual code format: lines starting with \"→\" maybe nested with indent. Example: Decision: If X? with Yes → Step. Use indentation. Let's produce like:\n\nStart // 程式開始執行\n→ Step 1: Sort candidates ascending // 方便剪枝\n→ Step 2: Initialize result list // 儲存符合條件的組合\n→ Step 3: Call DFS(start=0, sum=0, path=[]) // 開始遞迴搜索\n\nDefine DFS(start, sum, path):\n    → Decision: sum == target? // 判斷是否達到目標\n        Yes → Step: Add copy of path to result // 儲存有效組合\n        No  → Decision: sum > target? // 是否已超過目標\n            Yes → Step: Return // 超過則回溯\n            No  → For i from start to len(candidates)-1:\n                    → Step: Append candidates[i] to path // 選擇此數字\n                    → Step: DFS(i, sum + candidates[i], path) // 重複使用同一數字\n                    → Step: Remove last element from path // 回溯到上一層\n\n→ Step 4: Return result // 回傳所有組合\n\nEnd // 程式執行結束\n\nBut we need to ensure each line starts with \"→\" except maybe Start/End lines? In example Start line is \"Start //\". So maybe Start and End lines do not have arrow. So we should keep that.\n\nThus produce final answer. Ensure each line is \"虛擬碼步驟 [空格] // 解釋/說明\". The example uses no colon after Start. Let's follow that.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort candidates ascending // 方便剪枝，確保遞迴時能提前結束  \n→ Step 2: Initialize result list // 用來收集所有符合條件的組合  \n→ Step 3: Call DFS(startIndex = 0, currentSum = 0, currentPath = []) // 開始深度優先搜尋  \n\nDefine DFS(startIndex, currentSum, currentPath):  \n → Decision: currentSum == target? // 檢查是否已達到目標和  \n  Yes → Step: Add copy of currentPath to result // 存入有效組合  \n  No → Decision: currentSum > target? // 檢查是否已超過目標和  \n   Yes → Step: Return // 超過則直接回溯  \n   No → For i from startIndex to len(candidates)-1: // 逐個嘗試剩餘候選數  \n    → Step: Append candidates[i] to currentPath // 選擇此數字  \n    → Step: DFS(i, currentSum + candidates[i], currentPath) // 允許重複使用同一數字  \n    → Step: Remove last element from currentPath // 回溯到上一層  \n\n→ Step 4: Return result // 回傳所有找到的組合  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(list(path))\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\ndef parse_input(s):\n    \"\"\"Parse input string of the form:\n       'candidates = [2,3,6,7], target = 7'\n    \"\"\"\n    s = s.strip()\n    cand_match = re.search(r'candidates\\s*=\\s*(\\[[^\\]]*\\])', s)\n    tgt_match = re.search(r'target\\s*=\\s*(-?\\d+)', s)\n    if cand_match and tgt_match:\n        candidates = ast.literal_eval(cand_match.group(1))\n        target = int(tgt_match.group(1))\n        return candidates, target\n    # Fallback: allow tuple format like ([2,3],7)\n    try:\n        data = ast.literal_eval(s)\n        if isinstance(data, tuple) and len(data) == 2:\n            return list(data[0]), int(data[1])\n    except Exception:\n        pass\n    raise ValueError(\"Input format not recognized\")\n\ndef main():\n    input_data = sys.stdin.read()\n    candidates, target = parse_input(input_data)\n    sol = Solution()\n    result = sol.combinationSum(candidates, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "success": true,
          "output": "[[2, 2, 3], [7]]"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "success": true,
          "output": "[[2, 2, 2, 2], [2, 3, 3], [3, 5]]"
        },
        {
          "example_index": 2,
          "input": "candidates = [2], target = 1",
          "expected_output": "[]",
          "success": true,
          "output": "[]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode525.json",
    "problem_index_in_file": 0,
    "title": "Contiguous Array",
    "description_snippet": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number o...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need produce virtual code steps line by line, each line: \"虛擬碼步驟 // 解釋\". Use arrow notation, decision etc. Problem: maximum length of contiguous subarray with equal 0 and 1. Standard approach: convert 0->-1, cumulative sum, store earliest index of each sum. When encountering same sum again, subarray length = current index - first index. Need to handle sum=0 starting index at -1. Provide steps accordingly.\n\nLet's produce pseudo-code with decisions.\n\nWe need to produce step-by-step, no actual code, but pseudo-code. Use Start, End, Decision.\n\nWe can do:\n\nStart\n→ Step 1: Initialize hashmap with key 0 value -1 // to handle subarray starting from index 0\n→ Step 2: Initialize sum = 0, maxLen = 0\n→ Step 3: For each element num at index i in nums\n    → Step 3a: If num == 0 then sum = sum - 1 else sum = sum + 1 // transform 0 to -1\n    → Decision: Has sum already in hashmap?\n        Yes → Step 3b: Compute length = i - hashmap[sum]\n              → Decision: length > maxLen?\n                  Yes → maxLen = length // update max\n                  No  → do nothing\n        No  → Step 3c: Add sum to hashmap with value i // first occurrence\n→ Step 4: Return maxLen\nEnd\n\nWe need each line with // explanation. Use arrow \"→\" before steps except decisions. Use \"Decision:\" for decisions. For decision branches, use Yes → and No → with indentation.\n\nEnsure each line separate.\n\nLet's craft. Ensure each line includes explanation after //.\n\nAlso use Start and End.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 hash map 以儲存每個累積和第一次出現的索引, 並將 key 0 對應值設為 -1 // 方便處理從起始位置開始的子陣列  \n→ Step 2: 設定 sum = 0, maxLen = 0 // 初始累積和與最大長度  \n→ Step 3: 循環遍歷 nums 中的每個元素 num 與其索引 i  \n    → Step 3a: 若 num 為 0，sum = sum - 1；否則 sum = sum + 1 // 將 0 視為 -1 以便平衡計算  \n    → Decision: 是否已經在 hash map 中存在這個 sum？  \n        Yes → Step 3b: 計算 subLen = i - hash[sum] // 從第一次出現到現在的子陣列長度  \n            → Decision: subLen 是否大於 maxLen？  \n                Yes → maxLen = subLen // 更新最大長度  \n                No → // 無需改動  \n        No → Step 3c: 把 sum 與當前索引 i 存入 hash map // 記錄首次出現的位置  \n→ Step 4: 回傳 maxLen // 最長等數 0 與 1 的子陣列長度  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxLength(self, nums):\n        # 將 0 視為 -1，1 視為 +1，並計算累積和\n        count_map = {0: -1}   # 累積和為 0 時的最早索引\n        max_len = 0\n        count = 0\n        for i, num in enumerate(nums):\n            count += 1 if num == 1 else -1\n            if count in count_map:\n                # 相同累積和代表中間子陣列 0 與 1 的數量相等\n                max_len = max(max_len, i - count_map[count])\n            else:\n                # 記錄第一次出現的索引\n                count_map[count] = i\n        return max_len\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入，並將其轉為 Python list\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n    nums = ast.literal_eval(data)  # 解析類似 '[0,1,0]' 的字串\n    sol = Solution()\n    result = sol.findMaxLength(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[0,1]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 1,
          "input": "[0,1,0]",
          "expected_output": "2",
          "success": true,
          "output": "2"
        },
        {
          "example_index": 2,
          "input": "[0,1,1,1,1,1,0,0,0]",
          "expected_output": "6",
          "success": true,
          "output": "6"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode207.json",
    "problem_index_in_file": 0,
    "title": "Course Schedule",
    "description_snippet": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for solving the course schedule problem: determine if all courses can be finished given prerequisites; essentially detect cycle in directed graph. So algorithm: build adjacency list, perform DFS with visited set and recursion stack, or Kahn's algorithm (BFS). We'll produce virtual code steps.\n\nWe need to output each line: virtual code step + space + // explanation. Use arrows and structure Start, Decision, End. Each step should be distinct. Use Step numbers. Provide explanation for each line. Should not output actual code, just virtual steps. So something like:\n\nStart // start\n→ Step 1: Build adjacency list // create graph\n→ Step 2: Initialize visited and recursionStack // for DFS\n→ Step 3: For each node, if not visited, call DFS(node) // start DFS\n→ Decision: DFS(node) returns true? // cycle found\n    Yes → Step 4: Return false // cycle => cannot finish\n    No  → Continue loop\n→ Step 5: After loop, return true // no cycles\nEnd // finish\n\nAlso need to show DFS function:\n\n→ Function DFS(node) // recursive\n    → Mark node visited\n    → Mark node in recursionStack\n    → For each neighbor of node\n        → Decision: neighbor visited and in recursionStack? // cycle?\n            Yes → Return true // cycle\n            No  → Decision: neighbor visited? // if visited no need to DFS\n                Yes → Continue\n                No  → Decision: DFS(neighbor) returns true? // propagate cycle\n                    Yes → Return true\n                    No  → Continue\n    → Unmark node from recursionStack\n    → Return false // no cycle found\n\nWe need to embed this in the overall flow.\n\nThe requirement: \"逐行地產生對應的虛擬碼 (Virtual Code)，並在每行虛擬碼之後立即提供該行的簡短、直觀的解釋。\". Also must use arrows: →, Yes →, No →, etc. Must be structured.\n\nWe need to output the virtual code as lines. Should not output real code. Use natural language in explanation.\n\nMake sure each line has: virtual code step + space + // explanation. The virtual code step may include 'Start', 'End', 'Decision', 'Function', 'For', 'If', 'Return', etc. Must be sequential. For function definition, we can use 'Function DFS(node)'. For loops, we can use 'For each node' etc.\n\nAlso include indentation maybe via spaces? They didn't specify indentation, but arrow usage shows structure. We can indent sub-steps. Use indentation or just newline lines.\n\nWe need to ensure clarity. Each step in virtual code includes the arrow symbol before the step.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Build adjacency list from prerequisites // 將課程依賴關係轉成圖  \n→ Step 2: Initialize visited[0…numCourses-1] = false, inStack[0…numCourses-1] = false // 標記節點是否被訪問與是否在當前遞迴堆疊  \n→ Step 3: For each course i from 0 to numCourses-1  \n  Decision: visited[i] ? // 已經處理過此節點嗎？  \n   Yes → Continue // 跳過已訪問節點  \n   No  → Step 4: Call DFS(i) // 開始深度優先搜尋  \n    Decision: DFS(i) returns true? // DFS發現循環嗎？  \n     Yes → Step 5: Return false // 有循環，無法完成所有課程  \n     No  → Continue // 沒有循環，繼續處理下一個節點  \n→ Step 6: Return true // 所有節點都檢查過且無循環，課程可完成  \nEnd // 程式執行結束  \n\nFunction DFS(node) // 定義遞迴 DFS  \n → Mark visited[node] = true // 標記節點已被訪問  \n → Mark inStack[node] = true // 把節點加入遞迴堆疊  \n → For each neighbor in adjacencyList[node]  \n   Decision: visited[neighbor] && inStack[neighbor] ? // 還在堆疊中的已訪問節點  \n     Yes → Return true // 發現環，立即回傳 true  \n     No  → Decision: visited[neighbor] ? // 已訪問但不在堆疊  \n       Yes → Continue // 不需要再次 DFS  \n       No  → Decision: DFS(neighbor) returns true? // 進一步搜尋子節點  \n         Yes → Return true // 子節點發現循環  \n         No  → Continue // 子節點無循環，繼續迭代  \n → Mark inStack[node] = false // 將節點從堆疊移除，完成 DFS  \n → Return false // 這條路徑沒有發現循環  \nEnd Function   // DFS 函式結束",
      "generated_code": "import sys\nimport re\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n        # 建立圖與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 所有入度為 0 的節點先加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        # Kahn 的拓撲排序演算法\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有節點都被訪問，表示無循環\n        return visited == numCourses\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 取出所有整數\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # 第一個整數為 numCourses\n    numCourses = nums[0] if nums else 0\n\n    # 其餘整數以兩兩一組作為 prerequisites\n    prereq_pairs = []\n    for i in range(1, len(nums), 2):\n        if i + 1 < len(nums):\n            prereq_pairs.append([nums[i], nums[i + 1]])\n\n    sol = Solution()\n    result = sol.canFinish(numCourses, prereq_pairs)\n    print(str(result).lower())",
      "validation_results": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode459.json",
    "problem_index_in_file": 0,
    "title": "Repeated Substring Pattern",
    "description_snippet": "Given a string s, check if it can be constructed by taking a substring of it and appending multiple ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to generate virtual code step by step for algorithm: given string s, check if it can be constructed by taking a substring and appending multiple copies. This is classic repeated substring pattern problem. Approach: For i from 1 to len(s)/2, if len(s)%i==0 and s==s[:i]* (len(s)//i) then true. Or use KMP trick: find longest prefix suffix.\n\nWe produce virtual code lines with arrows. Let's produce steps: Start, input string s, get length n, compute for i in 1 to n/2, if n % i == 0 then construct candidate substring s[:i], repeat n/i times to build candidate string, compare with s. If match return true else after loop return false. End. Provide explanations.\n\nNeed to be line by line: each line is \"Step X:\" etc. Use arrows. Provide explanation comments. Use \"Start\" and \"End\".\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入字串 s // 取得需要檢查的字串  \n→ Step 2: 設定變數 n ← s.length // 取得字串長度  \n→ Decision: 如果 n <= 1? // 單字元或空字串無法重複  \n    Yes → Step 3: 輸出 False // 直接回傳 False  \n    No  → Step 4: for i from 1 to n/2 // 嘗試所有可能的子字串長度  \n→ Decision: 如果 n % i == 0? // 長度必須能被子字串長度整除  \n        Yes → Step 5: 子字串 sub ← s[0:i] // 取得前 i 個字元作為子字串  \n        Yes → Step 6: 重複次數 repeat ← n / i // 計算需要重複的次數  \n        Yes → Step 7: 建立候選字串 candidate ← sub * repeat // 重複拼接  \n        Yes → Decision: 如果 candidate == s? // 檢查是否與原字串相同  \n            Yes → Step 8: 輸出 True // 找到符合的重複模式  \n            No  → Step 9: 繼續迴圈 // 重新嘗試下一個 i  \n        No  → Step 9: 繼續迴圈 // 長度不整除，跳過此 i  \n→ Step 10: 輸出 False // 所有 i 都未成功  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                if s[:i] * (n // i) == s:\n                    return True\n        return False\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，並移除可能的前導文字與雙引號\n    raw_input = sys.stdin.read().strip()\n    # 先嘗試找出被雙引號包住的字串\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # 若沒有雙引號，嘗試直接去除「s =」之類的字串\n        s = raw_input.replace('s =', '').strip().strip('\"')\n    solution = Solution()\n    result = solution.repeatedSubstringPattern(s)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"abab\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "s = \"aba\"",
          "expected_output": "false",
          "success": true,
          "output": "false"
        },
        {
          "example_index": 2,
          "input": "s = \"abcabcabcabc\"",
          "expected_output": "true",
          "success": true,
          "output": "true"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode528.json",
    "problem_index_in_file": 0,
    "title": "Random Pick with Weight",
    "description_snippet": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith in...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to output virtual code steps. The requirement: \"You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index. Implement pickIndex() to randomly pick index based on weight.\" So we need to produce algorithm: preprocess cumulative weights array, total sum. In pickIndex, generate random number between 1 and sum inclusive, binary search for first cumulative >= rand. Provide step-by-step. Use Start, End, Decision. Each line: \"虛擬碼步驟 // 解釋\". Use arrows and decisions. Let's produce steps for initialization and pickIndex. Possibly we separate two functions: Constructor and pickIndex. Provide steps for constructor: compute cumulative array and total. Provide steps for pickIndex: generate random, binary search. Let's use decision arrow for binary search loop. Provide pseudocode. Use \"Start\" and \"End\". Provide line numbering maybe. But no numbers required. Just arrow steps.\n\nWe need to adhere to format: \"Start // 程式開始執行\" etc. Provide sequential steps. Use \"→\" for steps. Use \"Decision:\" for condition. Let's produce code. Ensure to use \"虛擬碼步驟\" meaning the step content, then space, then \"// 解釋\". Provide Chinese explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空陣列 prefix // 用於儲存累積權重  \n→ Step 2: 設定 totalWeight = 0 // 儲存所有權重總和  \n→ Step 3: For i in 0 .. w.length-1  \n    → Step 3.1: totalWeight += w[i] // 加總權重  \n    → Step 3.2: prefix[i] = totalWeight // 儲存到前綴和陣列  \n→ End // 完成建構階段  \n---  \nStart // pickIndex 呼叫開始  \n→ Step 1: randVal = RandomInt(1, totalWeight) // 產生 1 到總和之間的隨機整數  \n→ Step 2: low = 0; high = prefix.length - 1 // 設定二分搜尋區間  \n→ Decision: low <= high? // 是否還有區間可搜尋？  \n    Yes → Step 3: mid = (low + high) // 2 // 取中點  \n        Decision: randVal <= prefix[mid]? // 隨機值是否落在 mid 索引的區間內？  \n            Yes → Step 4: return mid // 找到符合條件的索引  \n            No  → Step 5: low = mid + 1 // 搜尋右半區間  \n        → Step 6: 從 Step 2 回到 Decision  \n    No  → Step 7: return -1 // 理論上不會發生，僅作安全回傳  \nEnd // pickIndex 執行結束",
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    \"\"\"\n    用前綴和做加權隨機挑選。\n    1. 建構時先把所有權重累積到 prefix_sum。\n    2. pickIndex 產生一個 1~total 之間的隨機整數，然後用二分搜尋\n       找到最小的 prefix_sum >= 隨機值，該索引即為結果。\n    \"\"\"\n    def __init__(self, w):\n        self.prefix_sum = []          # 前綴和\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total            # 所有權重總和\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        # bisect_left 回傳第一個大於等於 target 的索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 解析輸入為兩個列表：方法名稱和對應參數\n    # 例如： '[\"Solution\",\"pickIndex\"], [[[1]],[]]'\n    # 先將字串包在括號內，成為合法的 tuple 表達式\n    methods, args_list = ast.literal_eval('(' + raw_input + ')')\n\n    results = []          # 儲存每一次呼叫的結果\n    instance = None\n\n    for idx, method in enumerate(methods):\n        if method == \"Solution\":\n            # 第一個參數是權重列表\n            w = args_list[idx][0]\n            instance = Solution(w)\n            results.append(None)          # 建構器不回傳值，使用 None\n        else:\n            # 呼叫 pickIndex\n            res = instance.pickIndex()\n            results.append(res)\n\n    # 輸出 JSON 格式，將 None 轉成 null\n    print(json.dumps(results))",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"Solution\",\"pickIndex\"], [[[1]],[]]",
          "expected_output": "[null,0]",
          "success": true,
          "output": "[null, 0]"
        },
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 0, 1, 1]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode394.json",
    "problem_index_in_file": 0,
    "title": "Decode String",
    "description_snippet": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for decoding string like \"3[a]2[bc]\" etc. Use stack approach. Provide line-by-line with arrow and decision, and comments. Should not output real code, just pseudocode. Ensure each line has `虛擬碼步驟` + ` // 解釋`. Use Start, End, Decision. Provide steps.\n\nLet's design:\n\nStart\n→ Step 1: Initialize empty stack of characters and numbers\n→ Step 2: Initialize current_num = 0, current_string = \"\"\n→ Decision: While iterating through input characters? We'll use for each char in s.\n   → Step 3: If char is digit → accumulate current_num\n   → Step 4: Else if char is '[' → push current_string and current_num onto stack, reset current_string, current_num\n   → Step 5: Else if char is ']' → pop repeat_count and prev_string from stack, set current_string = prev_string + repeat_count * current_string\n   → Step 6: Else (letter) → append to current_string\n→ End loop\n→ Step 7: Return current_string\nEnd\n\nNeed to incorporate loops and decisions. Each step line with arrow maybe like \"→ For each character ch in s:\"? But the format requires arrow after Start etc. We can use \"→ For each character ch in s:\".\n\nBut arrow indicates next step. Use indent with decisions. Provide Decision blocks: if, else, etc.\n\nOk produce.\n\nEnsure each line has \"虛擬碼步驟\" (but we can write in Chinese). For clarity, we may use English for code steps but comment in Chinese.\n\nWe must not output actual code but virtual code: use pseudo like \"Loop ch in s:\" etc.\n\nLet's craft lines.\n\n1. Start // 程式開始執行\n2. → Init stack = [] // 存放已完成的字符串與重複數\n3. → Init current_num = 0 // 暫存讀取到的數字\n4. → Init current_string = \"\" // 暫存目前層級的字符串\n5. → For each character ch in input // 逐字遍歷整個編碼字串\n6. → Decision: if ch is digit? // 判斷是否為數字\n7.     Yes → current_num = current_num * 10 + int(ch) // 累積多位數字\n8.     No → Decision: if ch is '['? // 開啟新層級\n9.         Yes → Push (current_string, current_num) onto stack // 保存上一層級資料\n10.        → Reset current_string = \"\" // 開始新的子字串\n11.        → Reset current_num = 0 // 重設數字累積\n12.        No → Decision: if ch is ']'? // 關閉當前層級\n13.            Yes → (prev_string, repeat) = Pop from stack // 取出上一層級資料\n14.            → current_string = prev_string + repeat * current_string // 重複拼接\n15.            No → // ch 是普通字母\n16.                → current_string = current_string + ch // 加入字母到當前層級\n17. → End // 完成遍歷\n18. → Return current_string // 解碼後的完整字串\nEnd // 程式執行結束\n\nNeed to ensure each line has arrow. Lines 5-16 maybe need arrow. Use \"→ For each character ch in input\" then indent decisions.\n\nMake sure each line after arrow ends with comment.\n\nLet's write final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Init stack = [] // 存放已完成的字符串與重複數\n→ Init current_num = 0 // 暫存讀取到的數字\n→ Init current_string = \"\" // 暫存目前層級的字符串\n→ For each character ch in input // 逐字遍歷整個編碼字串\n    → Decision: if ch is digit? // 判斷是否為數字\n        Yes → current_num = current_num * 10 + int(ch) // 累積多位數字\n        No → Decision: if ch is '['? // 開啟新層級\n            Yes → Push (current_string, current_num) onto stack // 保存上一層級資料\n            → Reset current_string = \"\" // 開始新的子字串\n            → Reset current_num = 0 // 重設數字累積\n            No → Decision: if ch is ']'? // 關閉當前層級\n                Yes → (prev_string, repeat) = Pop from stack // 取出上一層級資料\n                → current_string = prev_string + repeat * current_string // 重複拼接\n                No → // ch 是普通字母\n                    → current_string = current_string + ch // 加入字母到當前層級\n→ End // 完成遍歷\n→ Return current_string // 解碼後的完整字串\nEnd // 程式執行結束\n```",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_num = 0\n        current_str = ''\n        for char in s:\n            if char.isdigit():\n                current_num = current_num * 10 + int(char)\n            elif char == '[':\n                stack.append((current_str, current_num))\n                current_str = ''\n                current_num = 0\n            elif char == ']':\n                last_str, num = stack.pop()\n                current_str = last_str + current_str * num\n            else:\n                current_str += char\n        return current_str\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    # 尝试提取双引号内的字符串，如果不存在则直接使用整行内容\n    match = re.search(r'\"([^\"]*)\"', data)\n    encoded = match.group(1) if match else data\n    solution = Solution()\n    decoded = solution.decodeString(encoded)\n    # 按照示例输出，结果前后加引号\n    print(f'\"{decoded}\"')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"3[a]2[bc]\"",
          "expected_output": "\"aaabcbc\"",
          "success": true,
          "output": "\"aaabcbc\""
        },
        {
          "example_index": 1,
          "input": "s = \"3[a2[c]]\"",
          "expected_output": "\"accaccacc\"",
          "success": true,
          "output": "\"accaccacc\""
        },
        {
          "example_index": 2,
          "input": "s = \"2[abc]3[cd]ef\"",
          "expected_output": "\"abcabccdcdcdef\"",
          "success": true,
          "output": "\"abcabccdcdcdef\""
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode191.json",
    "problem_index_in_file": 0,
    "title": "Number of 1 Bits",
    "description_snippet": "Given a positive integer n, write a function that returns the number of set bits in its binary repre...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce a step-by-step pseudo-code. Use Start, End, Decision. No actual code. We need to describe function, input n, count bits. Use loop, maybe while n>0, n & 1, increment count, n >> 1. Also could use Brian Kernighan's algorithm: while n!=0, count++, n = n & (n-1). Provide steps. Provide simple loop.\n\nWe must not output actual code, only structured steps with explanation after each line.\n\nLet's output:\n\nStart\n→ Step 1: 定義變數 count = 0 // 用於儲存設定位數\n→ Step 2: 定義變數 temp = n // 以備操作原始值\n→ Decision: temp 是否為 0? // 檢查是否已完成\n    Yes → End // 若 temp 為 0，結束計算\n    No  → Decision: temp 的最低位為 1? // 判斷目前位是否為 1\n        Yes → Step 3: count = count + 1 // 設定位數加 1\n        No  → // 無操作，直接進行移位\n        → Step 4: temp = temp 右移 1 位 // 把最低位丟棄，處理下一位\n→ Decision: 回到 Decision: temp 是否為 0? // 迴圈繼續\n… But we need to use the arrow properly. Might need a loop. We can use while loop structure. Use Decision: while temp != 0?\n\nSimplify: use while loop.\n\nStart\n→ Step 1: 設定 count = 0 // 计数器初始值\n→ Step 2: 設定 temp = n // 复制输入\n→ Decision: temp 是否等於 0? // 判断是否结束\n    Yes → End // 若 temp 为 0，直接结束\n    No  → Decision: temp 的最低位為 1? // 检查当前位\n        Yes → Step 3: count = count + 1 // 位为 1，计数器加 1\n        No  → // 位为 0，计数器保持不变\n        → Step 4: temp = temp 右移 1 位 // 去掉已检查的最低位\n→ Decision: 重复 Step 2? // 返回顶部继续循环\nBut we need to show the loop structure: Start → Step 1 → ... → Decision: temp ≠ 0? Yes → Step 2 → ... End.\n\nWe need to ensure that we follow the output format: each line \"虛擬碼步驟 [space] // 解釋/說明\". Use arrow for flow. The decision lines must include Yes → ... and No → ... with indent.\n\nLet's produce a clear pseudo-code:\n\nStart // 程式開始執行\n→ Step 1: 設定 count = 0 // 初始化計數器\n→ Step 2: 設定 temp = n // 取得輸入數值的副本\n→ Decision: temp 是否等於 0? // 檢查是否需要停止\n    Yes → End // 若 temp 為 0，結束執行\n    No  → Decision: temp 的最低位是否為 1? // 判斷目前位\n        Yes → Step 3: count = count + 1 // 位置為 1，累加計數\n        No  → // 位置為 0，不變\n        → Step 4: temp = temp 右移 1 位 // 刪除已處理的最低位\n→ Decision: 迴圈回到 Decision: temp 是否等於 0? // 重新檢查\n    Yes → End\n    No  → Decision: temp 的最低位是否為 1? // 重複步驟\n        Yes → Step 3 ...\n        No  → ...\n        → Step 4 ...\n... etc.\n\nBut the format might be better to show loop structure explicitly:\n\nStart // 程式開始執行\n→ Step 1: 設定 count = 0 // 初始化計數器\n→ Step 2: 設定 temp = n // 複製輸入值\n→ Decision: temp 是否為 0? // 判斷是否已無位可處理\n    Yes → End // 結束流程\n    No  → Decision: temp 的最低位是否為 1? // 檢查當前位\n        Yes → Step 3: count = count + 1 // 位為 1，計數器加 1\n        No  → // 位為 0，保持不變\n        → Step 4: temp = temp 右移 1 位 // 移除最低位\n→ Decision: 回到 Decision: temp 是否為 0? // 重複處理\n\nBut we need to ensure no actual code; just pseudo steps.\n\nLet's produce final output accordingly. Use \"Step 1:\", \"Decision:\" lines etc.\n\nWe should include arrow for flow: \"→\" before each line. Indentation for nested decisions can be represented by spaces. But we can keep simple.\n\nWe should maintain \"Start\" and \"End\".\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 count = 0 // 初始化計數器  \n→ Step 2: 設定 temp = n // 複製輸入數值  \n→ Decision: temp 是否為 0? // 判斷是否已無位可處理  \n    Yes → End // 若 temp 為 0，結束執行  \n    No  → Decision: temp 的最低位是否為 1? // 檢查目前最低位  \n        Yes → Step 3: count = count + 1 // 位置為 1，累加計數  \n        No  → // 位置為 0，不做變更  \n        → Step 4: temp = temp 右移 1 位 // 去除已檢查的最低位  \n→ Decision: 回到 Decision: temp 是否為 0? // 重新檢查以繼續迴圈  \n    Yes → End // 完成所有位的計算  \n    No  → Decision: temp 的最低位是否為 1? // 重複前述步驟  \n        Yes → Step 3: count = count + 1  \n        No  →  \n        → Step 4: temp = temp 右移 1 位  \n... // 依此重複直到 temp 為 0  \nEnd // 程式執行結束",
      "generated_code": "import sys\n\nclass Solution:\n    @staticmethod\n    def hammingWeight(n: int) -> int:\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count\n\nif __name__ == \"__main__\":\n    # 讀取全部輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 解析數字，支援 'n = 11' 或直接 '11' 的輸入格式\n    if '=' in raw_input:\n        _, value_part = raw_input.split('=', 1)\n        n_str = value_part.strip()\n    else:\n        n_str = raw_input.strip()\n    n = int(n_str)\n    # 計算 Hamming weight\n    result = Solution.hammingWeight(n)\n    # 輸出結果\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 11",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "n = 128",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 2147483645",
          "expected_output": "30",
          "success": true,
          "output": "30"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode1337.json",
    "problem_index_in_file": 0,
    "title": "The K Weakest Rows in a Matrix",
    "description_snippet": "You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civili...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. The problem: given binary matrix, each row has all 1s then 0s. Find k weakest rows indices sorted by weakness. Approach: compute soldier count per row via binary search or linear. Then sort rows by count then index. Then return first k indices.\n\nWe need to produce step-by-step virtual code with arrows and decisions. Ensure each line is in format: \"虛擬碼步驟 // 解釋\". Use Start, End, Decision: and arrows.\n\nWe need to cover: Input reading, count soldiers per row, store pair (count, index), sort, pick first k, output indices. Might include helper function to count soldiers via binary search. We'll produce pseudocode. Each line with arrow or indent. Use \"→\" to indicate next step. For decisions: \"Decision: condition?\" then Yes/No.\n\nWe need to ensure the steps are sequential, each line separate.\n\nLet's produce:\n\nStart\n→ Step 1: Initialize empty list rowsInfo // store pairs (soldierCount, rowIndex)\n→ Step 2: For each rowIndex from 0 to m-1\n    → Decision: Count soldiers in row rowIndex? // use binary search to find first 0\n        Yes → Step 3: binarySearchFirstZero(row) → return firstZeroIdx // index of first 0\n        No → Step 4: soldierCount = firstZeroIdx // number of 1s\n    → Step 5: Append (soldierCount, rowIndex) to rowsInfo // store row data\n→ Step 6: Sort rowsInfo by (soldierCount ascending, rowIndex ascending) // order by weakness\n→ Step 7: Initialize result list weakIndices\n→ Decision: k > 0? // ensure k is positive\n    Yes → Step 8: For i from 0 to k-1\n        → Step 9: weakIndices.append(rowsInfo[i].rowIndex) // collect weakest k indices\n    No → Step 10: weakIndices remains empty\n→ Step 11: Return weakIndices // output result\nEnd\n\nBut we need to include binarySearchFirstZero function as separate step maybe. Provide details.\n\nLet's produce more detailed pseudocode with function definitions:\n\nStart\n→ Step 1: Define function countSoldiers(row)\n    → Step 1a: left = 0, right = length(row)\n    → Decision: left < right? // binary search loop\n        Yes → Step 1b: mid = (left + right) / 2\n              → Decision: row[mid] == 1? // still soldier\n                  Yes → Step 1c: left = mid + 1\n                  No  → Step 1d: right = mid\n        No  → Step 1e: Return left // number of 1s\nEnd function\n→ Step 2: Initialize empty list rowsInfo\n→ Decision: matrix is not empty? // to handle edge case\n    Yes → Step 3: For each rowIndex in 0 .. m-1\n        → Step 4: soldierCount = countSoldiers(matrix[rowIndex]) // get count\n        → Step 5: Append (soldierCount, rowIndex) to rowsInfo\n    No → Step 6: rowsInfo remains empty\n→ Step 7: Sort rowsInfo by soldierCount ascending, then rowIndex ascending\n→ Step 8: Initialize empty list weakIndices\n→ Decision: k > 0? // guard\n    Yes → Step 9: For i in 0 .. k-1\n        → Step 10: weakIndices.append(rowsInfo[i].rowIndex)\n    No → Step 11: weakIndices stays empty\n→ Step 12: Return weakIndices\nEnd\n\nBut we need to use the arrow notation and indent lines accordingly. Use \"→\" at each step. For decisions, indent Yes and No with spaces.\n\nAlso each line must be \"虛擬碼步驟 // 解釋\". We'll include comments.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Define function countSoldiers(row) // 建立計算每列士兵數量的輔助函式  \n    → Step 1a: left = 0, right = length(row) // 初始化二分搜尋範圍  \n    → Decision: left < right? // 進入二分搜尋迴圈  \n        Yes → Step 1b: mid = (left + right) / 2 // 計算中間位置  \n            → Decision: row[mid] == 1? // 判斷中間是否還是士兵  \n                Yes → Step 1c: left = mid + 1 // 右半段繼續搜尋  \n                No  → Step 1d: right = mid // 左半段繼續搜尋  \n        No → Step 1e: Return left // left 為第一個 0 的索引，即士兵數量  \nEnd function // 結束函式定義  \n\n→ Step 2: Initialize empty list rowsInfo // 用來存放 (士兵數, 行號)  \n→ Decision: matrix is not empty? // 確保矩陣非空  \n    Yes → Step 3: For each rowIndex in 0 .. m-1  \n        → Step 4: soldierCount = countSoldiers(matrix[rowIndex]) // 計算該列士兵數  \n        → Step 5: Append (soldierCount, rowIndex) to rowsInfo // 儲存資料  \n    No → Step 6: rowsInfo remains empty // 空矩陣情況  \n\n→ Step 7: Sort rowsInfo by soldierCount ascending, then rowIndex ascending // 排序弱到強  \n→ Step 8: Initialize empty list weakIndices // 用來儲存最弱 k 行的索引  \n→ Decision: k > 0? // 檢查 k 是否有效  \n    Yes → Step 9: For i in 0 .. k-1  \n        → Step 10: weakIndices.append(rowsInfo[i].rowIndex) // 取出前 k 個行號  \n    No → Step 11: weakIndices stays empty // k 為 0 時直接返回空  \n\n→ Step 12: Return weakIndices // 回傳結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def kWeakestRows(self, mat, k):\n        # Binary search to count soldiers (1s) in a row\n        def count_soldiers(row):\n            left, right = 0, len(row)\n            while left < right:\n                mid = (left + right) // 2\n                if row[mid] == 1:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n\n        # Build list of (soldier_count, row_index)\n        rows_info = [(count_soldiers(row), idx) for idx, row in enumerate(mat)]\n        # Sort by soldier count then by row index\n        rows_info.sort()\n        # Extract first k row indices\n        return [idx for _, idx in rows_info[:k]]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Flexible input parsing: handle \"mat = [...], k = ...\" or two lines\n    if \"k =\" in data:\n        mat_part, k_part = data.split(\"k =\", 1)\n        mat_str = mat_part.split(\"=\", 1)[1].strip()\n        k_str = k_part.strip()\n        mat = ast.literal_eval(mat_str)\n        k = int(k_str)\n    else:\n        lines = data.splitlines()\n        mat = ast.literal_eval(lines[0].strip())\n        k = int(lines[1].strip())\n\n    sol = Solution()\n    result = sol.kWeakestRows(mat, k)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "mat = [[1,1,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,1,0,0,0],[1,1,1,1,1]], k = 3",
          "expected_output": "[2,0,3]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,0,3]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[2,0,3]'\nRaw Got:      '[0]'"
        },
        {
          "example_index": 1,
          "input": "mat = [[1,0,0,0],[1,1,1,1],[1,0,0,0],[1,0,0,0]], k = 2",
          "expected_output": "[0,2]",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[0]'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode753.json",
    "problem_index_in_file": 0,
    "title": "Cracking the Safe",
    "description_snippet": "There is a safe protected by a password. The password is a sequence of n digits where each digit can...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to construct a minimal length string that guarantees unlock for any password of length n digits each digit from [0,k-1]. This is classic De Bruijn sequence generation. So steps: generate de Bruijn sequence B(k, n). Then output that string. Provide virtual code: Start, Step to create array of digits, recursive function deBruijn, append, etc. Must be line-by-line. Use arrows. Provide explanation. No actual code. Use Start, Decision, etc. Ok.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變數 `k` 為字元集合大小，`n` 為密碼長度 // 取得輸入參數  \n→ Step 2: 初始化空陣列 `a`，長度為 `k * n`，並將所有元素設為 0 // 用於遞迴演算法的輔助陣列  \n→ Step 3: 建立空字串變數 `sequence` 以存放最終結果 // 儲存 De Bruijn 序列  \n→ Step 4: 定義遞迴函式 `deBruijn(t, p)`  \n  → Decision: 是否 `t > n`? // 判斷遞迴結束條件  \n   Yes → If `n % p == 0` // 若 `p` 為 `n` 的除子  \n    → Step 5: 將 `a[1..p]` 之值依序追加到 `sequence` // 產生有效子序列  \n   No → End // 退出遞迴  \n   No → Set `a[t] = a[t - p]` // 重複前一個元素以構成節點  \n   → Step 6: 呼叫 `deBruijn(t + 1, p)` // 深入下一層  \n   → For `j` 從 `a[t - p] + 1` 到 `k - 1`  \n    → Step 7: 設定 `a[t] = j`  \n    → Step 8: 呼叫 `deBruijn(t + 1, t)` // 以新的分割點進行遞迴  \n→ Step 9: 呼叫 `deBruijn(1, 1)` // 從第一個位置開始遞迴生成序列  \n→ Step 10: 將 `sequence` 轉換為字串形式，並將其輸出作為答案 // 最短字串已產生  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    \"\"\"\n    Generate the shortest string that will unlock the safe.\n    It is the De Bruijn sequence B(k, n) followed by the initial (n-1)-digit prefix.\n    \"\"\"\n    # Visited set for edges represented as strings of length n\n    seen = set()\n    result = []\n\n    def dfs(node: str):\n        \"\"\"\n        Hierholzer's algorithm: traverse all edges in the De Bruijn graph.\n        `node` is a string of length n-1 (the current vertex).\n        \"\"\"\n        for digit in map(str, range(k)):\n            nxt = node + digit\n            if nxt not in seen:\n                seen.add(nxt)\n                dfs(nxt[1:])   # move to the next vertex (drop the first char)\n                result.append(digit)\n\n    start = '0' * (n - 1)\n    dfs(start)\n    # The traversal records digits in reverse order, so reverse at the end\n    return ''.join(result[::-1]) + start\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # Extract all integers from the input; the first is n, the second is k\n    nums = list(map(int, re.findall(r'\\d+', data)))\n    if len(nums) < 2:\n        print(\"Invalid input\")\n        return\n    n, k = nums[0], nums[1]\n    answer = crack_safe(n, k)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        },
        {
          "example_index": 1,
          "input": "n = 2, k = 2",
          "expected_output": "\"01100\"",
          "success": true,
          "output": "01100"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode172.json",
    "problem_index_in_file": 0,
    "title": "Factorial Trailing Zeroes",
    "description_snippet": "Given an integer n, return the number of trailing zeroes in n!. \n\nNote that n! = n * (n - 1) * (n - ...",
    "examples_loaded": 3,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce pseudocode that counts trailing zeros in n! using algorithm: number of factors of 5 in n!. For each i from 5 to n, sum floor(n/5^k). So steps: read n, if n <=0 maybe handle, set count=0, power=5, while power <= n: count += n // power; power *=5. Output count. Then end.\n\nWe must use the specified format: each line: \"虛擬碼步驟 // 解釋\". Use arrow notation.\n\nNeed to start with Start, then → Step 1: 輸入 n, etc. Also decision: maybe if n <=0 return 0.\n\nWe need to use Decision structure where appropriate.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入 整數 n // 取得使用者輸入的整數  \n→ Decision: n 是否小於等於 0? // 檢查 n 是否為非正數  \n  Yes → Step 2: 設定 trailingZeroes = 0 // 非正數的階乘為 1 或 0，尾數為 0  \n  No  → Step 3: 設定 trailingZeroes = 0 // 初始化計數器  \n  No  → Step 4: 設定 power = 5 // 第一個能產生 5 的指數  \n  No  → Decision: power 是否小於等於 n? // 判斷是否還有更高次方的 5  \n   Yes → Step 5: trailingZeroes += n // power // 加上 n 除以 power 的商  \n   Yes → Step 6: power *= 5 // 進一步到下一個 5 的指數  \n   Yes → Decision: power 是否小於等於 n? // 重複上述循環直到指數大於 n  \n   No  → Step 7: 輸出 trailingZeroes // 顯示計算得到的尾數個數  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\ndef trailing_zeroes(n: int) -> int:\n    \"\"\"\n    計算 n! 的尾隨零個數。\n    方法：統計 5 的因子個數，因為每 5 與 2 配對產生 10。\n    \"\"\"\n    count = 0\n    power = 5\n    while power <= n:\n        count += n // power\n        power *= 5\n    return count\n\ndef main() -> None:\n    \"\"\"\n    讀取輸入、解析整數 n、計算尾隨零並輸出結果。\n    \"\"\"\n    data = sys.stdin.read()\n    # 從輸入字串中搜尋第一個整數（包含負數）\n    match = re.search(r'-?\\d+', data)\n    n = int(match.group()) if match else 0\n\n    result = trailing_zeroes(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "n = 3",
          "expected_output": "0",
          "success": true,
          "output": "0"
        },
        {
          "example_index": 1,
          "input": "n = 5",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 2,
          "input": "n = 0",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode131.json",
    "problem_index_in_file": 0,
    "title": "Palindrome Partitioning",
    "description_snippet": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code for the problem: Given string s, partition into all palindromic substrings. We need to produce steps. Use backtracking. Output steps as described. Use \"Start\", \"End\". Each line: \"虛擬碼步驟\" + space + \"// 解釋\".\n\nWe need to be careful: Provide only virtual code lines, not actual code. Use arrow \"→\". Use Decision. We'll produce a high-level pseudocode.\n\nWe need to handle: compute palindrome table? or use recursion with isPalindrome check each time. We'll illustrate.\n\nPseudo steps:\n\nStart\n→ Step 1: Define function isPalindrome(substring) → Return true if substring is palindrome\n→ Step 2: Define recursive function backtrack(startIndex, currentPartition) // Backtracking\n→ Decision: 如果 startIndex 等於 s.length? // All characters processed\n    Yes → Step 3: 把 currentPartition 的副本加到結果列表\n    No → Step 4: for i from startIndex to s.length-1\n            Step 5: substring = s[startIndex:i+1]\n            Decision: 如果 substring 為 palindrome?\n                Yes → Step 6: currentPartition 加入 substring\n                Step 7: backtrack(i+1, currentPartition)\n                Step 8: currentPartition 從尾部移除 substring // 回溯\n                No → Step 9: 继续循环\n\nEnd\n\nWe also need top-level: call backtrack(0, emptyList) and return result.\n\nLet's write in line by line:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 isPalindrome(sub) // 判斷子字串是否為回文\n→ Step 2: 初始化結果列表 result = [] // 存放所有合法分割\n→ Step 3: 定義遞迴函式 backtrack(start, path) // start 為目前處理位置，path 為已建立的子字串清單\n→ Decision: 如果 start == s.length? // 所有字元已處理完\n    Yes → Step 4: 把 path 的拷貝加入 result // 成功分割，存入結果\n    No  → Step 5: for end from start to s.length-1\n        Step 6: substring = s[start:end+1] // 從 start 到 end 的子字串\n        Decision: 如果 isPalindrome(substring)? // 子字串是否回文\n            Yes → Step 7: 把 substring 加入 path // 將子字串加入目前路徑\n            Step 8: backtrack(end+1, path) // 進一步遞迴\n            Step 9: 把 substring 從 path 移除 // 回溯，恢復狀態\n            No  → Step 10: 繼續 for 迴圈\n→ Step 11: 呼叫 backtrack(0, []) // 開始遞迴\n→ Step 12: 回傳 result // 將所有分割結果回傳\nEnd // 程式執行結束\n\nBut need arrow lines and proper indentation? Provide each line separate with arrows.\n\nUse \"→ Decision:\" for decision. For loops, we may treat as steps. Use \"→\" to indicate next step.\n\nLet's format exactly: \"虛擬碼步驟\" + space + \"// 解釋\".\n\nMake sure no actual code. Use only virtual code.\n\nWe should include \"Start\", \"End\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函式 isPalindrome(sub) // 判斷子字串是否為回文  \n→ Step 2: 初始化結果列表 result = [] // 存放所有合法分割  \n→ Step 3: 定義遞迴函式 backtrack(start, path) // start 為目前處理位置，path 為已建立的子字串清單  \n→ Decision: 如果 start == s.length? // 所有字元已處理完  \n  Yes → Step 4: 把 path 的拷貝加入 result // 成功分割，存入結果  \n  No  → Step 5: for end from start to s.length-1  \n    Step 6: substring = s[start:end+1] // 從 start 到 end 的子字串  \n    Decision: 如果 isPalindrome(substring)? // 子字串是否回文  \n     Yes → Step 7: 把 substring 加入 path // 將子字串加入目前路徑  \n      → Step 8: backtrack(end+1, path) // 進一步遞迴  \n      → Step 9: 把 substring 從 path 移除 // 回溯，恢復狀態  \n     No  → Step 10: 繼續 for 迴圈 // 跳過非回文子字串  \n→ Step 11: 呼叫 backtrack(0, []) // 開始遞迴  \n→ Step 12: 回傳 result // 將所有分割結果回傳  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def partition(self, s: str):\n        res = []\n\n        def is_palindrome(sub: str) -> bool:\n            return sub == sub[::-1]\n\n        def dfs(start: int, path: list):\n            if start == len(s):\n                res.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if is_palindrome(s[start:end]):\n                    dfs(end, path + [s[start:end]])\n\n        dfs(0, [])\n        return res\n\ndef main() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 尋找雙引號內的字串，若不存在則直接使用整個輸入\n    match = re.search(r'\"([^\"]*)\"', data)\n    s = match.group(1) if match else data\n\n    solution = Solution()\n    result = solution.partition(s)\n    # 使用 json.dumps 可以得到雙引號的 JSON 格式輸出\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
          "success": true,
          "output": "[[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]]"
        },
        {
          "example_index": 1,
          "input": "s = \"a\"",
          "expected_output": "[[\"a\"]]",
          "success": true,
          "output": "[[\"a\"]]"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode43.json",
    "problem_index_in_file": 0,
    "title": "Multiply Strings",
    "description_snippet": "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for string multiplication of two non-negative integers without built-in big integer or conversion. It's essentially implementing grade-school multiplication. Steps: If either is \"0\", return \"0\". Prepare result array length sum of lengths. For each digit from right to left in num1 and num2 multiply and add to result array positions. Handle carry. Then convert to string trimming leading zeros. Provide each line with explanation.\n\nWe need to output line by line: \"Start // 程式開始執行\", etc. Use virtual arrows.\n\nLet's produce.\n\nWe should include loops. Use nested loops. We can use indices i, j. Use decision for zero check.\n\nLet's write:\n\nStart // 程式開始執行\n→ Decision: 是否 num1 為 '0' 或 num2 為 '0'? // 檢查是否有零輸入\n    Yes → Step 1: 返回 '0' // 若任一為零，直接回傳\n    No  → Step 2: 初始化結果陣列 len = len(num1)+len(num2) 並設為 0 // 用於累積乘法結果\n→ For i from len(num1)-1 downto 0 // 遍歷 num1 的每位\n    → For j from len(num2)-1 downto 0 // 遍歷 num2 的每位\n        → Step 3: 計算 digit1 = num1[i] - '0' // 取得數字\n        → Step 4: 計算 digit2 = num2[j] - '0' // 取得數字\n        → Step 5: product = digit1 * digit2 + result[i+j+1] // 加上前一次累積\n        → Step 6: result[i+j+1] = product % 10 // 存入目前位\n        → Step 7: result[i+j] += product / 10 // 將進位累加至前一位\n→ Step 8: 將結果陣列轉成字串，跳過前置零 // 建立最終答案\n→ End // 程式執行結束\n\nBut we need \"virtual code\" arrow formatting: Use \"→ Step x:\" for each action, \"Decision:\" for if.\n\nAlso need to indent decision branches properly.\n\nUse the arrow and indentation as example: They used indent inside decision.\n\nWe'll produce accordingly.\n\nNeed each line separated. Provide explanation after //.\n\nAlso we must not output actual code. Just virtual steps.\n\nLet's write final.\n...done thinking.\n\nStart // 程式開始執行\n→ Decision: 是否 num1 為 '0' 或 num2 為 '0'? // 檢查是否有零輸入\n    Yes → Step 1: 返回 '0' // 若任一為零，直接回傳\n    No  → Step 2: 初始化結果陣列 len = len(num1)+len(num2) 並設為 0 // 用於累積乘法結果\n→ For i from len(num1)-1 downto 0 // 遍歷 num1 的每位\n    → For j from len(num2)-1 downto 0 // 遍歷 num2 的每位\n        → Step 3: digit1 = num1[i] - '0' // 取得 num1 第 i 位的整數\n        → Step 4: digit2 = num2[j] - '0' // 取得 num2 第 j 位的整數\n        → Step 5: product = digit1 * digit2 + result[i+j+1] // 加上先前累積的值\n        → Step 6: result[i+j+1] = product % 10 // 設定目前位數\n        → Step 7: result[i+j] += product / 10 // 將進位加到前一位\n→ Step 8: 轉換結果陣列為字串，並跳過前置零 // 產生最終乘積字串\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        # 如果任一數字為 0，直接返回 \"0\"\n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n\n        m, n = len(num1), len(num2)\n        # 結果長度最多為 m + n\n        pos = [0] * (m + n)\n\n        # 逐位相乘，從右往左\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = (ord(num1[i]) - 48) * (ord(num2[j]) - 48)\n                p1, p2 = i + j, i + j + 1\n                total = mul + pos[p2]\n                pos[p1] += total // 10          # 進位累加到前一位\n                pos[p2] = total % 10            # 取餘數存入當前位\n\n        # 把數組轉成字串，去除前導 0\n        result = ''.join(map(str, pos)).lstrip('0')\n        return result or \"0\"   # 若結果為空，表示 0\n\ndef main() -> None:\n    data = sys.stdin.read()\n    # 從輸入中找出所有連續的數字\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        return\n    num1, num2 = nums[0], nums[1]\n    sol = Solution()\n    print(sol.multiply(num1, num2))\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "num1 = '2', num2 = '3'",
          "expected_output": "'6'",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '6'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: \"'6'\"\nRaw Got:      '2'"
        },
        {
          "example_index": 1,
          "input": "num1 = '123', num2 = '456'",
          "expected_output": "'56088'",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '56088'\nGot (Norm):      '123'\n--- (Raw) ---\nRaw Expected: \"'56088'\"\nRaw Got:      '123'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode539.json",
    "problem_index_in_file": 0,
    "title": "Minimum Time Difference",
    "description_snippet": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference b...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: Given list of time points strings \"HH:MM\", find minimum minutes difference between any two points. Use sorting, convert to minutes, compute differences including wrap-around.\n\nWe must output line by line with \"虛擬碼步驟 // 解釋/說明\". Must include Start, End, Decision: etc. Use arrows →.\n\nWe must not produce actual code, just pseudo.\n\nOk. Provide steps: Start, Step1: Parse list to minutes, Step2: Sort, Step3: Initialize minDiff to large number, Step4: Iterate adjacent pairs compute diff, update minDiff, Step5: Compute wrap-around diff between first and last with 24*60 addition, Step6: Return minDiff. End.\n\nAdd decisions? Might not need, but could use Decision to check if list size > 1. But we can add.\n\nLet's produce lines:\n\nStart // start\n→ Step 1: 將輸入的時間字串轉換為分鐘值 // 轉成整數分鐘\n→ Decision: 時間點數量 < 2? // 若不足兩點無法計算差值\n    Yes → Step 2: 回傳 0 // 直接返回 0\n    No  → Step 3: 將分鐘值列表排序 // 方便相鄰比較\n→ Step 4: 設定 minDiff 為 24*60 // 初始最大差值\n→ Decision: 迭代索引 i 0 到 n-2? // 逐對比較相鄰時間\n    Yes → Step 5: 計算 diff = times[i+1] - times[i] // 差值\n    → Decision: diff < minDiff? // 更新最小差\n        Yes → Step 6: minDiff = diff\n        No  → Step 7: 繼續迭代\n    → Decision: 繼續迭代? // 循環結束判斷\n        Yes → Step 8: i += 1\n        No  → Step 9: 計算 wrapDiff = (24*60 - times[-1]) + times[0] // 循環差\n        → Decision: wrapDiff < minDiff? // 更新\n            Yes → Step 10: minDiff = wrapDiff\n            No  → Step 11: 繼續\n→ Step 12: 回傳 minDiff // 最終結果\nEnd // 程式結束\n\nBut we need to keep format with arrow indent and \"Decision:\" lines. Use Yes → and No →.\n\nWe must produce each line. Let's do final output.\n\nEnsure each line has \"虛擬碼步驟\" followed by // explanation.\n\nUse Start, End.\n\nWe'll use Step numbers or not? We can use descriptive names.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 將輸入的時間字串轉換為分鐘值 // 轉成整數分鐘，方便計算  \n→ Decision: 時間點數量 < 2? // 若不足兩點無法計算差值  \n  Yes → Step 2: 回傳 0 // 直接返回 0，表示沒有可比對的差值  \n  No  → Step 3: 將分鐘值列表排序 // 方便相鄰時間點直接比較  \n→ Step 4: 設定 minDiff 為 24*60 // 初始最大差值，保證任何實際差都比它小  \n→ Decision: 迭代索引 i 從 0 到 n-2? // 逐對比較相鄰時間點  \n  Yes → Step 5: 計算 diff = times[i+1] - times[i] // 相鄰時間差  \n    → Decision: diff < minDiff? // 是否更新最小差值  \n     Yes → Step 6: minDiff = diff // 更新為更小的差值  \n     No  → Step 7: 不變，保持現有 minDiff  \n    → Decision: 繼續迭代? // 判斷是否已到最後一對  \n     Yes → Step 8: i += 1  \n     No  → Step 9: 計算 wrapDiff = (24*60 - times[-1]) + times[0] // 週期差值  \n      → Decision: wrapDiff < minDiff? // 比較週期差是否更小  \n       Yes → Step 10: minDiff = wrapDiff // 更新最小差值  \n       No  → Step 11: 保持 minDiff  \n→ Step 12: 回傳 minDiff // 最終返回最小分鐘差  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMinDifference(self, timePoints):\n        minutes = []\n        for t in timePoints:\n            h, m = map(int, t.split(':'))\n            minutes.append(h * 60 + m)\n        minutes.sort()\n        min_diff = float('inf')\n        for i in range(1, len(minutes)):\n            min_diff = min(min_diff, minutes[i] - minutes[i - 1])\n        # 考慮跨午夜的差距\n        min_diff = min(min_diff, 1440 - (minutes[-1] - minutes[0]))\n        return min_diff\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        sys.exit(0)\n    try:\n        time_points = ast.literal_eval(data)\n    except Exception:\n        # 如果輸入不是合法的字面量，直接返回 0\n        print(0)\n        sys.exit(0)\n    if not isinstance(time_points, list) or len(time_points) < 2:\n        print(0)\n    else:\n        solution = Solution()\n        result = solution.findMinDifference(time_points)\n        print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "[\"23:59\",\"00:00\"]",
          "expected_output": "1",
          "success": true,
          "output": "1"
        },
        {
          "example_index": 1,
          "input": "[\"00:00\",\"23:59\",\"00:00\"]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode446.json",
    "problem_index_in_file": 0,
    "title": "Arithmetic Slices II - Subsequence",
    "description_snippet": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n\nA sequen...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Provide line-by-line steps for algorithm. The problem: count number of arithmetic subsequences (length>=3). Standard solution: DP with hash maps per index storing counts of sequences ending at index with a given difference. For each pair (j,i) j<i compute diff = nums[i]-nums[j]; we look up map_j[diff] counts of sequences ending at j with that diff. These sequences can be extended by i. We add to result number of new sequences of length>=3: result += map_j[diff] (because each of those sequences extended gives new length>=3). Then we increment map_i[diff] by map_j[diff]+1 (the +1 accounts for the new pair (j,i) as length-2 sequence). Implementation detail: use dict for map_i. Use loops.\n\nWe need to generate virtual code lines: Start, Step1: initialize result=0, list of dicts, loops, etc. Provide comments. Use arrow symbols as described.\n\nLet's produce lines:\n\nStart\n→ Step 1: Initialize result = 0 // 用於儲存長度至少 3 的等差子序列數量\n→ Step 2: Initialize dp array of maps of size n, each map empty // dp[i] 记录以 nums[i] 结尾且固定差值的子序列计数\n→ Decision: If n < 3? // 早期终止\n    Yes → Step 3: Return 0 // 长度不足不可能有等差子序列\n    No →\n→ Step 4: For i from 0 to n-1 // 遍历数组索引\n    → Step 5: For j from 0 to i-1 // 对每一对 (j,i)\n        → Step 6: Compute diff = nums[i] - nums[j] // 计算当前差值\n        → Step 7: Let count_j = dp[j].get(diff, 0) // 该差值在 j 处已有的子序列数\n        → Step 8: result += count_j // 每个已存在的子序列扩展为长度>=3，计入结果\n        → Step 9: dp[i][diff] = dp[i].get(diff, 0) + count_j + 1 // 更新以 i 结尾的子序列计数，+1 为新长度2的序列\n→ End // 返回结果\n→ Step 10: Return result // 输出最终计数\n\nNeed to format with arrow syntax: Start, → Step 1 etc.\n\nMake sure to indent decision branches. Use \"Yes →\" and \"No →\" accordingly. Use comments.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 result = 0 // 用於儲存長度至少 3 的等差子序列數量\n→ Step 2: 初始化 dp = [空字典 for _ in range(len(nums))] // dp[i] 记录以 nums[i] 结尾且固定差值的子序列计数\n→ Decision: 如果 n < 3? // 早期終止，長度不足以形成等差子序列\n    Yes → Step 3: 返回 0 // 沒有等差子序列可計算\n    No →\n→ Step 4: 對 i 從 0 到 n-1 逐個遍歷 // 主循環，處理每個位置作為序列終點\n    → Step 5: 對 j 從 0 到 i-1 逐個遍歷 // 形成 (j, i) 的每對\n        → Step 6: 計算 diff = nums[i] - nums[j] // 當前差值\n        → Step 7: 取得 count_j = dp[j].get(diff, 0) // j 位置已存在的相同差值序列數\n        → Step 8: result += count_j // 每個已存在序列擴展後成長度≥3，計入結果\n        → Step 9: dp[i][diff] = dp[i].get(diff, 0) + count_j + 1 // 更新以 i 結尾的序列數，+1 為新的長度 2 序列\n→ End // 程式執行結束\n→ Step 10: 返回 result // 輸出所有長度至少 3 的等差子序列總數",
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        Count the number of arithmetic subsequences (length >= 3) in nums.\n        Uses dynamic programming where dp[i] maps a difference to the\n        number of arithmetic subsequences ending at index i with that difference.\n        \"\"\"\n        n = len(nums)\n        if n < 3:\n            return 0\n\n        dp = [defaultdict(int) for _ in range(n)]\n        total = 0\n\n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                count = dp[j][diff]            # existing sequences ending at j\n                total += count                 # extend them to include nums[i]\n                dp[i][diff] += count + 1       # add new sequences (including pair j,i)\n\n        return total\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may be in the form:\n        nums = [1,2,3]\n    or simply:\n        [1,2,3]\n    Returns the list of integers.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    if data.startswith(\"nums\"):\n        # Split on the first '=' and evaluate the right side\n        _, expr = data.split('=', 1)\n        return eval(expr.strip())\n    # Assume the whole string is a Python literal list\n    return eval(data)\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read()\n    nums = parse_input(raw_input)\n\n    sol = Solution()\n    result = sol.numberOfArithmeticSlices(nums)\n    print(result)",
      "validation_results": [
        {
          "example_index": 0,
          "input": "nums = [2,4,6,8,10]",
          "expected_output": "7",
          "success": true,
          "output": "7"
        },
        {
          "example_index": 1,
          "input": "nums = [7,7,7,7,7]",
          "expected_output": "16",
          "success": true,
          "output": "16"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode309.json",
    "problem_index_in_file": 0,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "description_snippet": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind th...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nThe user wants pseudo-code for best time to buy and sell stock with cooldown. Should produce line-by-line pseudo-code with explanations.\n\nNeed to adhere to format: each line: \"虛擬碼步驟 // 解釋\".\n\nUse arrows. Start, End, Decision. Provide algorithm: dynamic programming with states: hold, sell, rest. Use arrays or variables. Provide steps:\n\nStart\n→ Initialize n = length(prices)\n→ If n==0 → End // no days\n→ Initialize arrays hold[n], sold[n], rest[n] or variables.\n→ For i from 0 to n-1\n   → Decision: i==0? // handle base\n       Yes → hold[0] = -prices[0] // buy first day\n       No  → // for i>0\n           → Decision: if i>=2? // allow transition from rest to hold\n               Yes → hold[i] = max(hold[i-1], rest[i-2] - prices[i])\n               No  → hold[i] = max(hold[i-1], -prices[i]) // only initial\n           → hold[i] = max(hold[i-1], rest[i-2] - prices[i]) // simplified\n           → sold[i] = hold[i-1] + prices[i] // sell today\n           → rest[i] = max(rest[i-1], sold[i-1]) // rest day after sell or rest\n→ Decision: maximum profit = max(sold[n-1], rest[n-1]) // cannot hold at end\nEnd\n\nNeed to explain each line.\n\nLet's produce lines with \"→\" arrow.\n\nBe careful: use Decision blocks for base cases.\n\nAlso include comments after space. Must keep the format exactly.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 prices 为空? // 檢查是否有任何價格資料  \n  Yes → End // 無資料直接結束  \n  No  →  // 有資料時繼續  \n→ Step 1: n = length(prices) // 獲取天數  \n→ Step 2: 初始化三個狀態陣列  \n  hold[n] // 持有股票時的最大利潤  \n  sold[n] // 卖出股票時的最大利潤  \n  rest[n] // 休息（冷卻）時的最大利潤  \n→ Step 3: 設定基礎狀態  \n  hold[0] = -prices[0] // 第一天買進  \n  sold[0] = 0 // 第一天不能賣出  \n  rest[0] = 0 // 第一天休息  \n→ Step 4: 循環處理剩下的天數 i = 1 到 n-1  \n  → Decision: i >= 2? // 判斷能否從休息狀態轉至持有  \n   Yes → hold[i] = max(hold[i-1], rest[i-2] - prices[i]) // 轉換或繼續持有  \n   No  → hold[i] = max(hold[i-1], -prices[i]) // 只考慮從第一天買進  \n  → sold[i] = hold[i-1] + prices[i] // 今日賣出，利潤 = 前一日持有利潤 + 當日價格  \n  → rest[i] = max(rest[i-1], sold[i-1]) // 今日休息，取前一日休息或前一日賣出的最大值  \n→ Step 5: 決定最終最大利潤  \n  → Decision: maxProfit = max(sold[n-1], rest[n-1]) // 結束時不能持有  \n→ End // 程式執行結束",
      "generated_code": "class Solution:\n    def maxProfit(self, prices):\n        if not prices:\n            return 0\n\n        hold = -prices[0]   # 最大持有時的利潤\n        sold = 0            # 今日剛賣出的利潤\n        rest = 0            # 今日休息（冷卻）時的利潤\n\n        for price in prices[1:]:\n            prev_sold = sold\n            sold = hold + price          # 今日賣出\n            hold = max(hold, rest - price)  # 今日持有或買入\n            rest = max(rest, prev_sold)     # 今日休息\n\n        return max(sold, rest)\n\n\ndef main():\n    import sys, ast\n    data = sys.stdin.read().strip()\n    if not data:\n        print(0)\n        return\n\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        prices = []\n    else:\n        try:\n            prices = ast.literal_eval(data[start:end + 1])\n        except Exception:\n            prices = []\n\n    solution = Solution()\n    print(solution.maxProfit(prices))\n\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "prices = [1,2,3,0,2]",
          "expected_output": "3",
          "success": true,
          "output": "3"
        },
        {
          "example_index": 1,
          "input": "prices = [1]",
          "expected_output": "0",
          "success": true,
          "output": "0"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode275.json",
    "problem_index_in_file": 0,
    "title": "H-Index II",
    "description_snippet": "Given an array of integers citations where citations[i] is the number of citations a researcher rece...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": false,
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. Problem: compute h-index from sorted array of citations. Need logarithmic time: binary search. Steps: find largest index i such that citations[i] >= n-i (where n length). Then h = n-i. Use binary search on indices 0..n-1. Steps: Start, compute n, low=0, high=n-1, ans=0. While low <= high: mid=(low+high)/2. If citations[mid] >= n-mid: ans=n-mid; low=mid+1; else high=mid-1. End loop, return ans. Also handle empty array return 0. Let's produce virtual code with explanations per line.\n\nWe need to use structure: Start, Decision, etc. Provide arrow. Each line: \"虛擬碼步驟 // 解釋\". Use arrow for flow. Let's produce.\n\nWe'll start with Start. Then Step: Initialize variables. Then Decision: empty? etc. Provide binary search loop. Use arrow for loops.\n\nBut we need to use arrow \"→\" and indent decision branches.\n\nWe need to show binary search logic: Use Decision: citations[mid] >= n-mid? Yes → store ans, low=mid+1 else high=mid-1.\n\nWe also need to loop. Might use while decision: while low <= high? Use Decision for loop condition.\n\nWe'll produce as:\n\nStart // 程式開始執行\n→ Step 1: Let n be length of citations // 取得陣列長度\n→ Decision: 若 n==0? // 檢查是否為空陣列\n    Yes → Step 2: 回傳 0 // 空陣列時 h-index 為 0\n    No  → Step 3: low=0, high=n-1, ans=0 // 初始化二分搜尋參數\n→ Decision: while low <= high? // 進行二分搜尋\n    Yes → Step 4: mid=(low+high)/2 // 計算中點\n    → Decision: citations[mid] >= n-mid? // 判斷此位置是否符合 h-index 條件\n        Yes → Step 5: ans=n-mid // 更新 h-index\n        → Step 6: low=mid+1 // 在右半區繼續搜尋更大的 h-index\n        No  → Step 7: high=mid-1 // 在左半區搜尋\n    No → Step 8: 回傳 ans // 搜尋結束，返回結果\nEnd // 程式執行結束\n\nNeed to maintain arrow indent: In example they used nested indents for decisions. We'll follow.\n\nAlso need to include \"→ Decision:\" lines. For loop we might use while decision. Provide Yes/No branches.\n\nMake sure to include spaces after arrow. Provide explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Let n be length of citations // 取得陣列長度  \n→ Decision: 若 n==0? // 檢查是否為空陣列  \n    Yes → Step 2: 回傳 0 // 空陣列時 h-index 為 0  \n    No  → Step 3: low=0, high=n-1, ans=0 // 初始化二分搜尋參數  \n→ Decision: while low <= high? // 進行二分搜尋  \n    Yes → Step 4: mid=(low+high)/2 // 計算中點  \n    → Decision: citations[mid] >= n-mid? // 判斷此位置是否符合 h-index 條件  \n        Yes → Step 5: ans=n-mid // 更新 h-index  \n        → Step 6: low=mid+1 // 在右半區繼續搜尋更大的 h-index  \n        No  → Step 7: high=mid-1 // 在左半區搜尋  \n    No → Step 8: 回傳 ans // 搜尋結束，返回結果  \nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\nimport re\n\nclass Solution:\n    def hIndex(self, citations):\n        n = len(citations)\n        if n == 0:\n            return 0\n        left, right = 0, n - 1\n        while left <= right:\n            mid = (left + right) // 2\n            # At index mid, there are n - mid papers with citations >= citations[mid]\n            if citations[mid] >= n - mid:\n                # Move right to find a larger h\n                left = mid + 1\n            else:\n                right = mid - 1\n        # left is the first index where citations[left] < n - left\n        # Therefore, h-index is n - left\n        return n - left\n\ndef parse_input(data: str):\n    \"\"\"\n    Extract a list of integers from the input string.\n    Handles inputs like:\n      - 'citations = [0,1,3,5,6]'\n      - '[1,2,100]'\n      - '0 1 3 5 6'\n    \"\"\"\n    # Try to find a list literal\n    match = re.search(r'\\[.*\\]', data, re.DOTALL)\n    if match:\n        try:\n            return ast.literal_eval(match.group(0))\n        except Exception:\n            pass\n    # Fallback: extract all integers\n    tokens = re.findall(r'-?\\d+', data)\n    return [int(tok) for tok in tokens]\n\ndef main():\n    raw = sys.stdin.read()\n    if not raw:\n        return\n    citations = parse_input(raw)\n    solution = Solution()\n    result = solution.hIndex(citations)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "validation_results": [
        {
          "example_index": 0,
          "input": "citations = [0,1,3,5,6]",
          "expected_output": "3",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "citations = [1,2,100]",
          "expected_output": "2",
          "success": false,
          "output": "[Output Mismatch (Normalized)]\nExpected (Norm): '2'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '2'\nRaw Got:      '0'"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  },
  {
    "source_file": "Leetcode/leetcode403.json",
    "problem_index_in_file": 0,
    "title": "Frog Jump",
    "description_snippet": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there ...",
    "examples_loaded": 2,
    "reference_solution_found": true,
    "generation_result": {
      "success": true,
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step. Need to solve problem: frog crossing river, given sorted stones positions. Classic Leetcode 403. We need to output algorithm. We need step-by-step pseudocode. Each line \"虛擬碼步驟 // 解釋\". Use arrow \"→\". Use Decision, Start, End. We must not output actual code. So produce pseudocode using virtual steps. Let's design algorithm: Use DFS with memoization or DP mapping stone index to set of possible last jump lengths. We'll produce pseudocode steps: Start, build hash map of stone positions to index. Create a DP array of sets. DP[0] contains 1 (first jump). Iterate over stones, for each possible k in DP[i], compute next positions pos + k-1, k, k+1 if in set, add to next set. Finally check if DP[last] non-empty. Output result.\n\nWe will write step by step. Use arrow for each action.\n\nWe must produce line by line with explanation. Use \"Start // 程式開始執行\". Then steps.\n\nLet's produce 25-30 lines maybe. Need each line as \"虛擬碼步驟 // 解釋\".\n\nWill include Decision blocks for loops, conditions.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立一個字典 stonesIndex，把每個石頭位置對應到它在陣列中的索引 // 方便快速查找石頭是否存在\n→ Step 2: 初始化 DP 為一個長度為石頭數的陣列，每個元素為一個空集合 // DP[i] 代表到第 i 個石頭時可能的上一跳距離集合\n→ Step 3: DP[0] ← {1} // 起點石頭，第一跳必須是 1 單位\n→ Decision: 迭代 i 從 0 到 n-2 // 遍歷所有石頭，排除最後一個因為不需要再跳\n    Yes → Step 4: 對於每個可能的 k 來自 DP[i] // k 是在石頭 i 上的最後一次跳距離\n        → Decision: 針對 delta in {k-1, k, k+1} // 三種可能的下一跳距離\n            Yes → Step 5: nextPos ← stones[i] + delta // 計算下一個潛在落腳點\n            → Decision: nextPos 是否在 stonesIndex 中？ // 判斷該位置是否有石頭\n                Yes → Step 6: nextIndex ← stonesIndex[nextPos] // 取得下一個石頭的索引\n                → Step 7: 把 delta 加入 DP[nextIndex] 的集合中 // 記錄到下一石頭時可用的跳距離\n                No  → Step 8: // 下一點是水，忽略\n    No  → // i 已經到達 n-2，結束外層迴圈\n→ Decision: DP[n-1] 是否為空？ // 判斷最後一個石頭是否能到達\n    Yes → Step 9: 回傳 true // 至少有一條可行路徑\n    No  → Step 10: 回傳 false // 沒有可行路徑\nEnd // 程式執行結束",
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def canCross(self, stones):\n        stone_set = set(stones)\n        jumps = {stone: set() for stone in stones}\n        jumps[stones[0]].add(0)  # 初始跳為 0，下一跳必為 1\n\n        for stone in stones:\n            for k in jumps[stone]:\n                for step in (k - 1, k, k + 1):\n                    if step > 0 and stone + step in stone_set:\n                        jumps[stone + step].add(step)\n\n        return bool(jumps[stones[-1]])\n\n\ndef parse_input(input_str):\n    \"\"\"將形如 'stones = [0,1,3]' 的字串轉成 list[int]\"\"\"\n    input_str = input_str.strip()\n    if '=' in input_str:\n        _, list_part = input_str.split('=', 1)\n        list_str = list_part.strip()\n    else:\n        list_str = input_str\n    return ast.literal_eval(list_str)\n\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    stones = parse_input(data)\n    result = Solution().canCross(stones)\n    print('true' if result else 'false')",
      "validation_results": [
        {
          "example_index": 0,
          "input": "stones = [0,1,3,5,6,8,12,17]",
          "expected_output": "true",
          "success": true,
          "output": "true"
        },
        {
          "example_index": 1,
          "input": "stones = [0,1,2,3,4,8,9,11]",
          "expected_output": "false",
          "success": true,
          "output": "false"
        }
      ],
      "reference_solution_provided": true,
      "error": null
    }
  }
]