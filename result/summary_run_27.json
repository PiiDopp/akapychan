{
  "run_index": 27,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 294,
  "generation_or_validation_failure_count": 40,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin，雖然此題不需要使用，但符合「必須從 stdin 讀取」的要求\n    _ = sys.stdin.read()\n\n    try:\n        with open('data.txt', 'r', encoding='utf-8') as f:\n            lines = f.readlines()\n            print(f\"檔案共有 {len(lines)} 行\")\n    except FileNotFoundError:\n        print(\"找不到檔案！\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. Use Start, End, Decision, etc. Use with and try/except. Steps: open file, try to read lines, count lines, print count, except FileNotFoundError: print message. Provide step-by-step with arrow. Should be clear. Each line: \"虛擬碼步驟 // 解釋\".\n\nLet's structure: Start, Decision: file exists? Actually use try block. Start, try → with open(file) as f: lines = f.readlines() → count = len(lines) → print count. End of try. except FileNotFoundError: print message. End.\n\nBut need to show with syntax. Let's produce:\n\nStart\n→ Decision: 嘗試開啟檔案? Actually we start with try block.\n\n→ Decision: 進入 try? maybe \"try\" not a decision. Use \"Try:\" then inside. But we can show:\n\n→ Decision: 進入 try? maybe \"Try:\".\n\nBetter to mimic:\n\nStart\n→ Decision: 進入 try? Not needed.\n\nWe can produce:\n\nStart\n→ Decision: 嘗試打開檔案? // 進入 try 區塊\n    Yes → Step: with open('data.txt', 'r') as f: // 使用 with 開啟檔案\n        → Step: lines = f.readlines() // 讀取所有行\n        → Step: count = len(lines) // 計算行數\n        → Step: print(f\"總共 {count} 行\") // 輸出行數\n    No  → Decision: 發生 FileNotFoundError? // except 區塊\n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut we need to reflect try/except. Maybe:\n\nStart\n→ Decision: 嘗試打開檔案? // 進入 try 區塊\n    Yes → Step: with open('data.txt', 'r') as f: // 打開檔案\n        → Step: lines = f.readlines() // 讀取所有行\n        → Step: count = len(lines) // 計算行數\n        → Step: print(f\"總共 {count} 行\") // 輸出行數\n    No → Decision: FileNotFoundError? // except 區塊\n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nBut the structure may not strictly match expected. They expect arrow lines with \"→ Step\" etc. Use \"Decision:\" then Yes/No. Let's produce:\n\nStart // 程式開始執行\n→ Decision: 嘗試進入 try 區塊? // 進入 try\n    Yes → Step: with open('data.txt', 'r') as f: // 使用 with 開啟檔案\n        → Step: lines = f.readlines() // 讀取所有行\n        → Step: count = len(lines) // 計算行數\n        → Step: print(f\"總共 {count} 行\") // 輸出行數\n    No  → Decision: 是否發生 FileNotFoundError? // 進入 except\n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd // 程式執行結束\n\nBut we need to reflect that try/except block: The \"No\" branch of Decision: 嘗試進入 try 區塊? may not make sense. Maybe better:\n\nStart\n→ Decision: 是否嘗試打開檔案? // 進入 try\n    Yes → Step: with open('data.txt', 'r') as f: // 開啟檔案\n        → Step: lines = f.readlines() // 讀取內容\n        → Step: count = len(lines) // 計算行數\n        → Step: print(f\"總共 {count} 行\") // 輸出結果\n    No  → Decision: 是否拋出 FileNotFoundError? // except\n        Yes → Step: print('找不到檔案！') // 顯示訊息\nEnd\n\nMaybe we can keep it simpler: Use a Decision to represent try block. But typical flow: Start -> Try block -> ... -> End. We can represent try block as \"Decision: 嘗試執行?\".\n\nBetter: Represent as:\n\nStart\n→ Decision: 進入 try 區塊? // 嘗試打開檔案\n    Yes → Step: with open('data.txt', 'r') as f: // 開啟檔案\n        → Step: lines = f.readlines() // 讀取所有行\n        → Step: count = len(lines) // 計算行數\n        → Step: print(f\"總共 {count} 行\") // 輸出行數\n    No → Decision: 是否捕獲 FileNotFoundError? // except\n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息\nEnd\n\nWe need to produce each line with arrow. Should be clear. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 進入 try 區塊? // 嘗試打開檔案  \n    Yes → Step: with open('data.txt', 'r') as f: // 使用 with 開啟檔案  \n        → Step: lines = f.readlines() // 讀取檔案中所有行  \n        → Step: count = len(lines) // 計算行數  \n        → Step: print(f\"總共 {count} 行\") // 輸出總行數  \n    No → Decision: 是否捕獲 FileNotFoundError? // 進入 except 區塊  \n        Yes → Step: print('找不到檔案！') // 顯示錯誤訊息  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,2,6,2,1]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 2, 6, 2, 1]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    code = sys.stdin.read()\n    if code:\n        # Execute the code in the current global namespace\n        exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations. The user wants to simulate dice rolls using random module, function roll_dice(n). Should return list of results. Provide virtual code with Start, End, Decision etc. We need to not output actual code, just virtual steps. Provide each line as \"虛擬碼步驟 // 解釋\". Use arrow arrows.\n\nWe need to describe importing random, defining function, initializing list, loop for n times, generate random integer 1-6, append to list, return list, end. Use decisions? maybe check if n <= 0? Might include optional decision.\n\nLet's produce:\n\nStart\n→ Import random module\n→ Decision: Is n a positive integer? // Check input validity\n   Yes → Step: Initialize empty list results\n   Yes → Step: For i from 1 to n: // Loop\n         → Step: roll = random.randint(1,6)\n         → Step: Append roll to results\n   Yes → Step: Return results\n   No → Step: Return empty list or raise error\nEnd\n\nBut must use \"Decision:\" with arrow Yes → and No →. Use \"→ Step\" lines.\n\nAlso need to use \"Start\" and \"End\" lines. Provide each line.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import random module // 載入 random 函式庫以便產生隨機數  \n→ Decision: n 是否為正整數? // 檢查輸入是否合法  \n  Yes → Step: results ← 空串列 // 建立儲存擲骰結果的容器  \n  Yes → Step: i ← 1 // 初始化迴圈計數器  \n  Yes → Decision: i ≤ n? // 判斷是否還有骰子要擲  \n    Yes → Step: roll ← random.randint(1,6) // 產生 1~6 的隨機數  \n    Yes → Step: Append roll to results // 把本次擲骰結果加入串列  \n    Yes → Step: i ← i + 1 // 迴圈計數器加一  \n    Yes → 再往回決策: i ≤ n?  \n    No → Step: Return results // 迴圈結束，回傳所有結果  \n  No → Step: Return 空串列 // n 非正整數時回傳空串列或可拋出例外  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量給定函式 func 執行所需的秒數，並回傳四捨五入到小數點三位的結果。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\ndef main():\n    # 從標準輸入讀取完整程式碼（含測試範例）\n    code = sys.stdin.read()\n    # 建立執行環境，確保 measure_time 及 time 模組可用\n    exec_env = {\"measure_time\": measure_time, \"time\": time}\n    # 執行讀入的程式碼，任何 print 會直接輸出到 stdout\n    exec(code, exec_env)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code line by line. The user wants a function measure_time(func, *args) that uses time module to measure seconds, returns result rounded to 3 decimal places. Provide virtual code lines and explanation.\n\nWe need to include Start, End, Decision maybe not needed. Just linear steps.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n→ Step 1: 載入 time 模組 // 導入必要的模組\n→ Step 2: 定義函數 measure_time(func, *args) // 建立函式\n    → Step 3: 取得 start_time = time.time() // 記錄開始時間\n    → Step 4: 執行結果 = func(*args) // 執行傳入函式\n    → Step 5: 取得 end_time = time.time() // 記錄結束時間\n    → Step 6: 計算 elapsed = end_time - start_time // 計算耗時\n    → Step 7: 四捨五入 elapsed = round(elapsed, 3) // 四捨五入到小數點 3 位\n    → Step 8: 回傳 elapsed // 返回耗時\n→ Step 9: End // 程式結束\n\nBut we need each line with virtual code and explanation. Use arrow, indentation with indentation maybe with tabs or spaces? In example, they use \"→ Decision:\" etc. We'll follow.\n\nAlso we may include \"→ Step 2: ...\" and inside define function. Maybe we need to indent lines inside function.\n\nLet's produce.\n\nNeed to output only virtual code lines with explanations.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: 載入 time 模組 // 導入 time 模組以便測量時間\n→ Step 2: 定義函數 measure_time(func, *args) // 建立一個可測量任意函式執行時間的函式\n    → Step 3: 取得 start_time = time.time() // 記錄執行開始的時間戳\n    → Step 4: 執行結果 = func(*args) // 呼叫傳入的函式並傳遞所有參數\n    → Step 5: 取得 end_time = time.time() // 記錄執行結束的時間戳\n    → Step 6: 計算 elapsed = end_time - start_time // 計算總耗時（秒）\n    → Step 7: 取四捨五入 elapsed = round(elapsed, 3) // 四捨五入到小數點三位\n    → Step 8: 回傳 elapsed // 將經過的時間回傳給呼叫者\n→ End // 程式執行結束\n\nWe might need to include comment after each line: //.\n\nAlso for the function step, maybe we need \"→ Step 2: 定義函數 measure_time(func, *args)\".\n\nFor inner steps we indent with spaces or tab. The example uses tab for inner lines. We'll mimic: use tab or 4 spaces. We'll use 4 spaces indent.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 載入 time 模組 // 導入 time 模組以便測量時間\n→ Step 2: 定義函數 measure_time(func, *args) // 建立可測量任意函式執行時間的函式\n    → Step 3: 取得 start_time = time.time() // 記錄執行開始的時間戳\n    → Step 4: 執行結果 = func(*args) // 呼叫傳入的函式並傳遞所有參數\n    → Step 5: 取得 end_time = time.time() // 記錄執行結束的時間戳\n    → Step 6: 計算 elapsed = end_time - start_time // 計算總耗時（秒）\n    → Step 7: 取四捨五入 elapsed = round(elapsed, 3) // 四捨五入到小數點三位\n    → Step 8: 回傳 elapsed // 將經過的時間回傳給呼叫者\n→ End // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"melon\",\"grape\",\"apple\",\"orange\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'melon', 'grape', 'apple', 'orange'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取標準輸入（此題不需要實際處理輸入，但為符合要求仍呼叫 read）\n    sys.stdin.read()\n    \n    # 初始化集合\n    fruits = {'apple', 'banana'}\n    \n    # 新增單一元素\n    fruits.add('orange')\n    \n    # 一次新增多個元素\n    fruits.update(['grape', 'melon'])\n    \n    # 移除已存在的元素\n    fruits.remove('banana')\n    \n    # 嘗試移除不存在的元素（不會拋錯）\n    fruits.discard('pineapple')\n    \n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with explanation after each line. Use virtual code arrows, Start, Decision, etc. For this simple script, no decisions needed except maybe check existence? But we can just show remove/discard.\n\nWe'll do:\n\nStart\n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合\n→ Step 2: fruits.add('orange') // 新增 orange\n→ Step 3: fruits.update(['grape', 'melon']) // 一次新增多個\n→ Step 4: fruits.remove('banana') // 移除 banana，存在必須\n→ Step 5: fruits.discard('pineapple') // 嘗試移除不存在元素，無錯誤\n→ Step 6: print(fruits) // 輸出集合\n\nEnd\n\nBut ensure formatting: \"虛擬碼步驟 [空格] // 解釋\" each line. Use arrows: \"→ Step X:\".\n\nNo decision required. So produce 7 lines plus Start and End. Ensure each line has comment after.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: fruits = {'apple', 'banana'} // 初始化集合 fruits  \n→ Step 2: fruits.add('orange') // 使用 add() 新增 'orange'  \n→ Step 3: fruits.update(['grape', 'melon']) // 使用 update() 一次新增 'grape' 與 'melon'  \n→ Step 4: fruits.remove('banana') // 使用 remove() 移除 'banana'（元素必須存在）  \n→ Step 5: fruits.discard('pineapple') // 使用 discard() 嘗試移除 'pineapple'（不存在時不拋錯誤）  \n→ Step 6: print(fruits) // 輸出最終的集合內容  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.66TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.66 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\nimport tkinter as tk\n\ndef fetch_rate() -> float | None:\n    \"\"\"\n    向匯率 API 取得 USD → TWD 的匯率。\n    若成功回傳浮點數，失敗則回傳 None。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        return data[\"rates\"][\"TWD\"]\n    except Exception:\n        return None\n\ndef update_label(label: tk.Label) -> None:\n    \"\"\"\n    取得匯率後，更新 tkinter 標籤的顯示文字。\n    \"\"\"\n    rate = fetch_rate()\n    if rate is not None:\n        label.config(text=f\"目前美元匯率：約 {rate} TWD\")\n    else:\n        label.config(text=\"更新失敗，請檢查網路連線\")\n\ndef start_gui() -> None:\n    \"\"\"\n    建立簡易的 tkinter 視窗，包含一個顯示匯率的標籤與一個更新按鈕。\n    \"\"\"\n    win = tk.Tk()\n    win.title(\"匯率查詢\")\n\n    label = tk.Label(win, text=\"請按下按鈕更新匯率\", font=(\"Arial\", 12))\n    label.pack(pady=10)\n\n    button = tk.Button(win, text=\"更新匯率\", command=lambda: update_label(label))\n    button.pack(pady=5)\n\n    win.mainloop()\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入：\n      - 若收到任何內容，視為「按下更新匯率」的指令，取得匯率並印出結果。\n      - 若無輸入，則啟動 GUI 介面等待使用者操作。\n    \"\"\"\n    input_data = sys.stdin.read().strip()\n    if input_data:\n        # 只要收到任何輸入，即執行一次匯率查詢並輸出結果\n        rate = fetch_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n        return\n\n    # 沒有輸入時啟動 GUI\n    start_gui()\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output a virtual code, line by line, with explanation. Format: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision, Yes/No arrows. Use request to fetch API. Use tkinter for window, button to update. Should be in plain pseudo-code, not actual code. Ensure no actual code. Provide steps. Must use \"→\" and arrows etc. Let's produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: Import requests 模組 // 導入 HTTP 請求功能\n→ Step 2: Import tkinter 模組並建立主視窗 // 建立圖形介面\n→ Step 3: 在主視窗中加入標籤用於顯示匯率 // 顯示文字訊息的空間\n→ Step 4: 在主視窗中加入更新按鈕 // 供使用者觸發更新動作\n→ Step 5: 定義函式 UpdateRate() // 按鈕點擊時執行的邏輯\n    → Sub-step 5.1: 設定 API URL 為 https://api.exchangerate-api.com/v4/latest/USD // 目標匯率 API\n    → Sub-step 5.2: 使用 requests.get(url) 發送 GET 請求 // 取得 API 回應\n    → Sub-step 5.3: 判斷回應是否成功 (status 200) ?\n        Yes → Sub-step 5.3.1: 解析 JSON 資料 // 將回應轉為字典\n        Yes → Sub-step 5.3.2: 取出 rates.TWD 值 // 取得台幣匯率\n        Yes → Sub-step 5.3.3: 更新標籤文字為 \"USD → TWD: {value}\" // 顯示匯率\n        No  → Sub-step 5.3.4: 更新標籤文字為 \"無法取得匯率\" // 顯示錯誤訊息\n→ Step 6: 將 UpdateRate() 連結至按鈕的 command // 使按鈕能呼叫函式\n→ Step 7: 在主視窗啟動事件循環 mainloop() // 顯示介面並等待使用者操作\nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[None,True,False,True,2,True,False,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[None, True, False, True, 2, True, False, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\n\nclass RandomizedSet:\n    \"\"\"一個可在平均 O(1) 時間內完成插入、刪除、隨機取值的集合。\"\"\"\n\n    def __init__(self):\n        # 存放所有元素的陣列\n        self.values = []\n        # 元素值到其在 values 陣列中的索引\n        self.val_to_index = {}\n\n    def insert(self, val: int) -> bool:\n        \"\"\"若元素不存在則插入，否則返回 False。\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"若元素存在則刪除，否則返回 False。\"\"\"\n        if val not in self.val_to_index:\n            return False\n        idx = self.val_to_index[val]\n        last_val = self.values[-1]\n        # 把最後一個元素搬到要刪除的位置，保持陣列連續\n        self.values[idx] = last_val\n        self.val_to_index[last_val] = idx\n        self.values.pop()\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素，所有元素等概率。\"\"\"\n        return random.choice(self.values)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找到兩個列表之間的分隔位置\n    split_idx = data.find('], [')  # 典型分隔符\n    if split_idx == -1:\n        split_idx = data.find('],')  # 若沒有空格則用此分隔\n        sep_len = 2\n    else:\n        sep_len = 3\n\n    ops_str = data[:split_idx + 1]          # 第一個列表，包括結尾的 ']'\n    args_str = data[split_idx + sep_len:]   # 第二個列表\n\n    ops = ast.literal_eval(ops_str)\n    args = ast.literal_eval(args_str)\n\n    res = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"RandomizedSet\":\n            obj = RandomizedSet()\n            res.append(None)  # 建構子不返回值，對應 LeetCode 的 null\n        elif op == \"insert\":\n            res.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            res.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            res.append(obj.getRandom())\n        else:\n            # 若遇到未知操作，直接跳過\n            res.append(None)\n\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with comments. Provide steps for RandomizedSet class methods. Virtual code: Start, then class definition, methods etc. Use arrows, decisions, etc. Let's craft.\n\nWe need to produce the entire algorithm for the class and methods. Use internal data structures: array/list for values, hashmap from val to index. For insert: check if present in map. If not, append to array, store index. For remove: check if present. If yes, get index, swap with last element in array, update map for swapped element, pop last, delete map entry. Return true. getRandom: generate random index within array length and return element at that index. All operations average O(1). We'll produce virtual code step-by-step. Let's format each line like \"Start // ...\" etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 RandomizedSet 類別 // 建立 RandomizedSet 類別的骨架  \n→ Step 2: 內部變數：Array values // 存放所有元素的動態陣列  \n→ Step 3: 內部變數：Map indexMap // 從元素值到其在 values 陣列中的索引  \n→ Step 4: 建構子 RandomizedSet() // 初始化空集合  \n    → Step 5: values ← 空陣列 // values 初始化為空  \n    → Step 6: indexMap ← 空映射 // indexMap 初始化為空  \n→ End // 建構子完成  \n\n→ Step 7: 函式 insert(val) // 插入元素的流程  \n    → Decision: 若 indexMap 中存在 val? // 檢查元素是否已存在  \n        Yes → Step 8: return false // 已存在，插入失敗  \n        No  → Step 9: append val 至 values // 將 val 加到陣列末尾  \n            → Step 10: indexMap[val] ← values.length - 1 // 記錄新索引  \n            → Step 11: return true // 插入成功  \n\n→ Step 12: 函式 remove(val) // 刪除元素的流程  \n    → Decision: 若 indexMap 中不存在 val? // 檢查元素是否存在  \n        Yes → Step 13: return false // 無法刪除，返回失敗  \n        No  → Step 14: idx ← indexMap[val] // 取得要刪除元素的索引  \n            → Step 15: lastVal ← values.last() // 取得陣列最後一個元素  \n            → Decision: 若 idx ≠ values.length - 1? // 判斷是否不是最後一個  \n                Yes → Step 16: values[idx] ← lastVal // 用最後一個元素覆蓋要刪除的位置  \n                    → Step 17: indexMap[lastVal] ← idx // 更新被覆蓋元素的新索引  \n                No  → // idx 已是最後一個，無需覆蓋  \n            → Step 18: values.pop() // 刪除陣列最後一個元素  \n            → Step 19: delete indexMap[val] // 移除映射條目  \n            → Step 20: return true // 刪除成功  \n\n→ Step 21: 函式 getRandom() // 取得隨機元素  \n    → Step 22: n ← values.length // 取集合大小  \n    → Step 23: randIdx ← randomInteger(0, n-1) // 產生隨機索引  \n    → Step 24: return values[randIdx] // 返回隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0,0], [1,0], [2,0], null, [2,0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows, n_cols):\n        # 設定矩陣大小與初始可選格子數\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols   # 仍可被選的格子數\n        self.flipped = {}              # 映射表，存放已被選位置的對應值\n\n    def flip(self):\n        # 隨機抽取剩餘格子中的位置\n        r = random.randint(0, self.total - 1)\n        # 取得實際矩陣索引\n        idx = self.flipped.get(r, r)\n        # 取得最後剩餘格子實際索引\n        last_idx = self.flipped.get(self.total - 1, self.total - 1)\n        # 把已選位置映射到最後剩餘格子，確保 r 不再可選\n        self.flipped[r] = last_idx\n        # 更新剩餘格子數目\n        self.total -= 1\n        # 轉換回行列座標\n        return [idx // self.cols, idx % self.cols]\n\n    def reset(self):\n        # 重設映射表與剩餘格子數目\n        self.flipped.clear()\n        self.total = self.rows * self.cols\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 把輸入包成一個頂層列表，以符合 json.loads 的格式\n    wrapper = '[' + data + ']'\n    ops, args = json.loads(wrapper)\n\n    solution_instance = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            solution_instance = Solution(*arg)\n            results.append(None)\n        elif op == \"flip\":\n            results.append(solution_instance.flip())\n        elif op == \"reset\":\n            solution_instance.reset()\n            results.append(None)\n        else:\n            # 若有未知指令，直接忽略\n            results.append(None)\n\n    # 將結果轉成期望的字串格式\n    output = '[' + ', '.join(\n        'null' if r is None else f'[{r[0]},{r[1]}]' for r in results\n    ) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce step-by-step virtual code for a solution class that supports flip and reset on an m x n binary matrix, initially zeros, randomly pick zero index uniformly, flip to 1. Need to minimize random calls, optimize time and space.\n\nStandard solution: treat matrix as 1D array of size m*n. Maintain list of available indices. Use reservoir or mapping trick: maintain a mapping of index to value. For each flip: pick random k in [0, remaining-1]; let idx = mapping.get(k, k). Then set mapping[k] = mapping.get(remaining-1, remaining-1). Decrease remaining. For reset: clear mapping, set remaining = m*n.\n\nWe must produce pseudo-code lines with explanation after each line.\n\nWe need to produce algorithmic description, not actual code. We can create class structure: Start, define variables, etc. Provide steps for initialization, flip, reset.\n\nWe'll output lines like:\n\nStart // 程式開始執行\n→ Step 1: Set total = m * n // 總格數\n→ Step 2: Initialize remaining = total // 仍可選的格子數\n→ Step 3: Initialize map = empty // index映射表\n\nFlip function:\n\nStart // flip開始\n→ Step 1: If remaining == 0 → return error? // 無可選格子\n→ Step 2: r = random integer in [0, remaining-1] // 隨機取剩餘格子索引\n→ Step 3: idx = map.get(r, r) // 取得實際矩陣索引\n→ Step 4: last = map.get(remaining-1, remaining-1) // 取得最後剩餘格子索引\n→ Step 5: map[r] = last // 替換映射，使已選位置不再可選\n→ Step 6: remaining = remaining - 1 // 更新剩餘數\n→ Step 7: row = idx // m  // 轉換回行列\n→ Step 8: col = idx % n // 轉換回行列\n→ Step 9: return [row, col] // 返回位置\n\nReset:\n\nStart // reset開始\n→ Step 1: Clear map // 移除所有映射\n→ Step 2: remaining = total // 重新設置剩餘格子數\n→ Step 3: return // 結束\n\nWe also need to define class structure.\n\nLet's produce final answer accordingly.\n\nAlso ensure use of arrow and indentation for decisions? Not needed for this algorithm.\n\nBut we can use 'Decision: If remaining == 0?' but maybe not necessary.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← m * n // 計算矩陣總格數  \n→ Step 2: remaining ← total // 可被選取的格子數目  \n→ Step 3: map ← empty // 建立索引映射表，鍵為抽到的隨機位置，值為實際矩陣索引  \n\n// --- flip() 方法開始 ---\nStart // flip() 開始執行  \n→ Step 1: 若 remaining == 0 → return error // 若無可選格子則拋錯  \n→ Step 2: r ← randomInteger(0, remaining - 1) // 隨機抽取剩餘格子中的位置  \n→ Step 3: idx ← map.get(r, r) // 取得實際矩陣索引（若映射存在則取映射值，否則取 r 本身）  \n→ Step 4: lastIdx ← map.get(remaining - 1, remaining - 1) // 取得最後剩餘格子實際索引  \n→ Step 5: map[r] ← lastIdx // 把已選位置映射到最後剩餘格子，確保 r 不再可選  \n→ Step 6: remaining ← remaining - 1 // 更新剩餘格子數目  \n→ Step 7: row ← idx / n // 將一維索引轉回行  \n→ Step 8: col ← idx % n // 將一維索引轉回列  \n→ Step 9: return [row, col] // 回傳隨機選中的索引  \n\n// --- reset() 方法開始 ---\nStart // reset() 開始執行  \n→ Step 1: map.clear() // 清空所有映射，恢復為全 0  \n→ Step 2: remaining ← total // 重設剩餘格子數目為總格數  \n→ Step 3: return // 退出方法  \n\nEnd // 程式結束執行"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp3ukwmjbe.py\", line 40, in <module>\n    time_series, duration = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp3ukwmjbe.py\", line 32, in parse_input\n    time_series = ast.literal_eval(lst_str)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpxmr1y9pb.py\", line 40, in <module>\n    time_series, duration = parse_input(raw_input)\n                            ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpxmr1y9pb.py\", line 32, in parse_input\n    time_series = ast.literal_eval(lst_str)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        \"\"\"Return total seconds Ashe is poisoned.\"\"\"\n        if not timeSeries:\n            return 0\n        total = 0\n        for i in range(len(timeSeries) - 1):\n            diff = timeSeries[i + 1] - timeSeries[i]\n            total += min(diff, duration)\n        total += duration\n        return total\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input of the form:\n        timeSeries = [1,4], duration = 2\n    or any whitespace separated variation.\n    \"\"\"\n    # Replace newlines and tabs with space for easier splitting\n    data = data.replace('\\n', ' ').replace('\\t', ' ')\n    parts = data.split(',')\n    time_series = []\n    duration = 0\n    for part in parts:\n        part = part.strip()\n        if part.startswith('timeSeries'):\n            # Extract the part after '=' and evaluate safely\n            lst_str = part.split('=', 1)[1].strip()\n            time_series = ast.literal_eval(lst_str)\n        elif part.startswith('duration'):\n            dur_str = part.split('=', 1)[1].strip()\n            duration = int(dur_str)\n    return time_series, duration\n\nif __name__ == \"__main__\":\n    raw_input = sys.stdin.read()\n    time_series, duration = parse_input(raw_input)\n    result = Solution().findPoisonedDuration(time_series, duration)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. We need to parse the problem: given sorted array timeSeries and duration, compute total poison time. Typical solution: iterate, accumulate duration, but adjust overlapping intervals by subtracting min(duration, diff) or using max. Use variable total = 0; for i in range(len(timeSeries)): if i == 0: total += duration else: diff = timeSeries[i] - timeSeries[i-1]; total += min(diff, duration). After loop, return total.\n\nWe must produce each line with virtual code step and explanation, using arrow syntax etc. Format: each line: \"Start // ...\", \"→ Step X: ...\" etc. We need to use virtual arrows. Each step we can label with Step numbers.\n\nLet's produce:\n\nStart // Program starts\n→ Step 1: Initialize total to 0 // 用來累計毒化秒數\n→ Step 2: For each index i from 0 to len(timeSeries)-1 // 遍歷攻擊時間\n    → Decision: 如果 i == 0? // 第一次攻擊\n        Yes → Step 3: total += duration // 初始毒化\n        No → Step 4: 計算前後攻擊時間差 diff = timeSeries[i] - timeSeries[i-1] // 前後攻擊間隔\n            → Decision: 如果 diff >= duration? // 是否覆蓋前一次毒化\n                Yes → Step 5: total += duration // 全部新毒化時間\n                No  → Step 6: total += diff // 只加入未覆蓋部分\n→ Step 7: Return total // 回傳總毒化秒數\nEnd // 程式結束\n\nBut must keep each line separately, no nested indentation? They used indentation in example. We'll replicate: use spaces to show indentation.\n\nMake sure each line ends with // explanation.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← 0 // 初始化累計毒化秒數  \n→ Step 2: for i ← 0 to length(timeSeries)-1 // 遍歷所有攻擊時間  \n  → Decision: i == 0? // 是否為第一次攻擊  \n   Yes → Step 3: total ← total + duration // 第一次攻擊直接加上整個毒化時間  \n   No → Step 4: diff ← timeSeries[i] - timeSeries[i-1] // 計算本次與前一次攻擊的時間差  \n    → Decision: diff >= duration? // 本次攻擊是否能覆蓋整個前一次毒化時間  \n     Yes → Step 5: total ← total + duration // 覆蓋完整，直接加 duration  \n     No  → Step 6: total ← total + diff // 只加上未被覆蓋的時間段  \n→ Step 7: return total // 回傳總毒化秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"()()()\",\"(())()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      '[\"()()()\", \"(())()\"]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport json\n\nclass Solution:\n    def removeInvalidParentheses(self, s: str):\n        def is_valid(string):\n            count = 0\n            for c in string:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n\n        level = {s}\n        while level:\n            valid = list(filter(is_valid, level))\n            if valid:\n                return valid\n            next_level = set()\n            for item in level:\n                for i in range(len(item)):\n                    if item[i] in ('(', ')'):\n                        next_level.add(item[:i] + item[i+1:])\n            level = next_level\n        return []\n\ndef parse_input(data: str) -> str:\n    # Extract string inside quotes if present\n    m = re.search(r'[\"\\'](.+?)[\"\\']', data)\n    if m:\n        return m.group(1)\n    # Otherwise remove leading 's =' and surrounding whitespace/quotes\n    data = data.strip()\n    if data.lower().startswith('s'):\n        data = data.split('=', 1)[-1]\n    return data.strip().strip('\"\\'').strip()\n\ndef main():\n    data = sys.stdin.read()\n    s = parse_input(data)\n    sol = Solution()\n    result = sol.removeInvalidParentheses(s)\n    print(json.dumps(result))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for algorithm: given string s with parentheses and letters, remove minimal number of invalid parentheses to make valid string, return all unique results. This is classic problem: remove invalid parentheses (LeetCode 301). Standard solution: BFS or DFS with counting left/right removal. Use BFS generating all possible strings by removing one char each level until find valid. Use set to store results. Provide pseudo-code step by step. Use Start/End and Decision, etc.\n\nWe need produce each line as \"虛擬碼步驟 // 解釋\". Each line after the arrow includes explanation.\n\nLet's plan lines:\n\nStart // start\n→ Step 1: Initialize variables: queue, visited, result list, found flag // initialize\n→ Step 2: Enqueue original string into queue // add initial\n→ Decision: While queue not empty? // BFS loop\n   Yes → Step 3: Dequeue string cur // current string\n   → Decision: Is cur valid? // check\n        Yes → Add cur to result list // store\n        → Set found = true // found valid level\n        No  → If not found, generate next level\n            → For i in 0 to len(cur)-1:\n                → Decision: If cur[i] is '(' or ')'?\n                    Yes → newStr = cur without char i\n                    → Decision: newStr not in visited?\n                        Yes → Add newStr to visited\n                        → Enqueue newStr // next level\n   → Decision: If found, break loop? // only process current level\nEnd // finish\n\nWe also need function IsValid(str). That is a helper, can be separate steps.\n\nWe can produce steps for IsValid: start, count =0, loop through characters: if '(' increment, if ')' decrement, if count<0 return false, after loop return count==0.\n\nAlso we need to ensure unique strings.\n\nOk produce pseudo-code. Use indentation or arrow for decision.\n\nNeed to follow output format exactly: each line \"虛擬碼步驟 // 解釋\". Use \"Start\", \"End\" etc. Use arrow \"→\" before each step after Start? Example format: Start // 程式開始執行. Then arrow each step. Provide indentation maybe. Use Decision: and Yes →, No → lines.\n\nWe should provide unique results. Use set resultSet to avoid duplicates. Then convert to list.\n\nWe'll produce step-by-step.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Step 1: Initialize queue Q, visited set, result set, found flag = false // 置備資料結構\n\nLine 3: → Step 2: Enqueue s into Q // 把原始字串加入佇列\n\nLine 4: → Decision: Q not empty? // 進行 BFS 迴圈\n\nLine 5: Yes → Step 3: Dequeue cur from Q // 取出佇列首個字串\n\nLine 6: → Decision: IsValid(cur)? // 檢查字串是否有效\n\nLine 7: Yes → Step 4: Add cur to result set // 存入合法結果\n\nLine 8: → Step 5: Set found = true // 標記已找到合法字串\n\nLine 9: No  → Decision: found == true? // 已找到合法字串時只處理本層\n\nLine10: Yes → Decision: break? Actually we may want to break after level? We can use a flag and after processing all nodes of current level? But easier: we can collect all nodes of current level. But for pseudo-code we can simply break after first found and after processing all nodes at current depth. We'll simplify: After found, skip generating children for nodes of current level. But still need to process all nodes of current level. We'll incorporate that logic: If found, continue; else generate children.\n\nLet's adjust: after found flag true, we still want to continue but skip children generation. So Step 9: Yes → Step 6: Continue to next iteration // skip generating children\n\nLine 10: No → Decision: For i in 0..len(cur)-1? // generate children\n\nLine 11: Yes → Step 7: If cur[i] is '(' or ')' // only remove parentheses\n\nLine 12: Yes → Step 8: newStr = cur[0:i] + cur[i+1:] // remove char\n\nLine 13: → Decision: newStr not in visited? // avoid duplicates\n\nLine 14: Yes → Step 9: Add newStr to visited // mark visited\n\nLine 15: → Step 10: Enqueue newStr into Q // add to next level\n\nLine 16: After loop, go back to Step 4? Actually Step 4 loop continues while Q not empty.\n\nLine 17: End // 程式結束\n\nWe also need helper function IsValid.\n\nWe'll put earlier:\n\nStart // 程式開始執行\n\n→ Step 1: Define function IsValid(str) // 檢查字串是否合法\n\n→ Inside function: count=0 // 初始化計數\n\n→ For each char c in str // 逐字符遍歷\n\n→ Decision: If c == '('? // 左括號\n\n→ Yes → Increment count\n\n→ No → Decision: If c == ')'?\n\n→ Yes → Decrement count\n\n→ Decision: If count < 0? // 右括號多於左括號\n\n→ Yes → Return false\n\n→ End for\n\n→ Decision: count == 0? // 所有括號配對\n\n→ Yes → Return true\n\n→ No → Return false\n\nEnd // function ends\n\nBut need to maintain format: each line a step.\n\nBetter to treat function definition as a separate section.\n\nBut we may not need to detail the function; we can just note \"Function IsValid(str) returns bool\" but not elaborate? But might be expected.\n\nSimplify: \"Step 0: Define helper function IsValid(str) to check parentheses balance\" plus explanation. That may be enough.\n\nWe should keep lines manageable.\n\nLet's produce final pseudo-code:\n\nStart // 程式開始執行\n→ Step 0: Define helper function IsValid(str) // 檢查字串是否為有效括號序列\n→ Step 1: Initialize queue Q, visited set, result set, found flag = false // 佇列、已訪問、結果、是否已找到合法字串\n→ Step 2: Enqueue s into Q // 把原始字串加入佇列\n→ Decision: Q not empty? // 開始 BFS 迴圈\n    Yes → Step 3: Dequeue cur from Q // 取出佇列首個字串\n    → Decision: IsValid(cur)? // 檢查字串是否有效\n        Yes → Step 4: Add cur to result set // 存入合法結果\n        → Step 5: Set found = true // 標記已找到合法字串\n        No → Decision: found == true? // 已找到合法字串時不再產生子節點\n            Yes → Step 6: Continue // 跳過產生子節點，處理下一個佇列元素\n            No  → Step 7: For i in 0 to len(cur)-1 // 產生子節點\n                → Decision: cur[i] is '(' or ')'?\n                    Yes → Step 8: newStr = cur without character i // 刪除第 i 個括號\n                    → Decision: newStr not in visited?\n                        Yes → Step 9: Add newStr to visited // 記錄已訪問\n                        → Step 10: Enqueue newStr into Q // 加入下一層佇列\n→ Decision: Q not empty? // 迴圈判斷重複\nEnd // 程式結束\n\nWe also need to produce results as list from result set. So after loop, maybe Step 11: Convert result set to list and return. Add it.\n\nAlso note we might need to break out of loop when found and queue is processed. But the pseudo-code above may not break properly; but we can say \"If found and Q empty, exit loop.\" It's fine.\n\nLet's add:\n\n→ Decision: found == true and Q empty? // 找到合法結果並且佇列處理完畢\n\n    Yes → Step 11: Break loop // 退出 BFS\n\nThen after loop: Step 12: Return list of result set // 將集合轉為列表返回\n\nAdd end.\n\nLet's restructure.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: Define helper function IsValid(str) // 檢查字串是否為有效括號序列  \n→ Step 1: Initialize queue Q, visited set, result set, found flag = false // 佇列、已訪問、結果、是否已找到合法字串  \n→ Step 2: Enqueue s into Q // 把原始字串加入佇列  \n→ Decision: Q not empty? // 開始 BFS 迴圈  \n  Yes → Step 3: Dequeue cur from Q // 取出佇列首個字串  \n  → Decision: IsValid(cur)? // 檢查字串是否有效  \n    Yes → Step 4: Add cur to result set // 存入合法結果  \n    → Step 5: Set found = true // 標記已找到合法字串  \n    No → Decision: found == true? // 已找到合法字串時不再產生子節點  \n      Yes → Step 6: Continue // 跳過產生子節點，處理下一個佇列元素  \n      No  → Step 7: For i in 0 to len(cur)-1 // 產生子節點  \n       → Decision: cur[i] is '(' or ')'?  \n         Yes → Step 8: newStr = cur without character i // 刪除第 i 個括號  \n         → Decision: newStr not in visited?  \n           Yes → Step 9: Add newStr to visited // 記錄已訪問  \n           → Step 10: Enqueue newStr into Q // 加入下一層佇列  \n→ Decision: Q not empty? // 迴圈判斷重複  \n  Yes → (重複 Step 3–10)  \n  No → Step 11: Break loop // 佇列已空，結束 BFS  \n→ Step 12: Convert result set to list and return // 將集合轉為列表返回  \nEnd // 程式結束"
    },
    {
      "title": "Assign Cookies",
      "source_file": "Leetcode/leetcode455.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "g = [1,2,3], s = [1,1]",
          "expected_output": "1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\n\nclass Solution:\n    def findContentChildren(self, g, s):\n        \"\"\"Greedy: sort both lists and use two pointers.\"\"\"\n        g.sort()\n        s.sort()\n        i = j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1          # child i is satisfied\n            j += 1              # move to next cookie\n        return i\n\ndef parse_input(text: str):\n    \"\"\"\n    尝试解析输入。支持：\n    1) 单行类似 \"g = [1,2,3], s = [1,1]\"\n    2) 两行分别给出列表\n    \"\"\"\n    g = s = None\n    # 先按逗号分割，查找包含 'g' 或 's' 的片段\n    parts = [p.strip() for p in text.split(',')]\n    for part in parts:\n        if 'g' in part:\n            m = re.search(r'\\[([^\\]]*)\\]', part)\n            if m:\n                g = ast.literal_eval('[' + m.group(1) + ']')\n        if 's' in part:\n            m = re.search(r'\\[([^\\]]*)\\]', part)\n            if m:\n                s = ast.literal_eval('[' + m.group(1) + ']')\n    # 若上面解析不到，再尝试按行解析\n    if g is None or s is None:\n        lines = [line.strip() for line in text.strip().splitlines() if line.strip()]\n        if len(lines) >= 2:\n            g = ast.literal_eval(lines[0])\n            s = ast.literal_eval(lines[1])\n    # 作为最后的保险，若仍未解析成功，尝试从所有数字中拆分\n    if g is None or s is None:\n        nums = list(map(int, re.findall(r'-?\\d+', text)))\n        # 这里假设前半部为 g，后半部为 s\n        half = len(nums) // 2\n        g = nums[:half]\n        s = nums[half:]\n    return g, s\n\ndef main():\n    data = sys.stdin.read()\n    g, s = parse_input(data)\n    result = Solution().findContentChildren(g, s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps, line by line, with \"虛擬碼步驟\" and explanation. No actual code. So we write algorithm: sort both arrays, two pointers. Steps: Start, Input arrays, sort greed, sort sizes, init i,j counters, while i<n and j<m: if s[j] >= g[i] then count++ and i++ and j++ else j++. Finally output count. Use decisions.\n\nWe need to produce lines like:\n\nStart // 程式開始執行\n\n→ Step 1: 輸入子女數量 n 與餅乾數量 m // 取得輸入\n\n→ Step 2: 讀取 g[0..n-1] // 子女貪婪度\n\n→ Step 3: 讀取 s[0..m-1] // 餅乾大小\n\n→ Step 4: 將 g 陣列遞增排序 // 方便比對\n\n→ Step 5: 將 s 陣列遞增排序 // 方便比對\n\n→ Step 6: 初始化指標 i=0, j=0, count=0 // i 指向子女, j 指向餅乾\n\n→ Decision: 是否還有未處理子女與餅乾? // 迴圈條件\n\n    Yes → Decision: s[j] 是否 >= g[i] ?\n\n        Yes → Step 7: count++ // 內容子女數加 1\n\n            → Step 8: i++ ; j++ // 移動兩指標\n\n        No → Step 9: j++ // 尋找更大餅乾\n\n    No → Step 10: 輸出 count // 結果\n\nEnd // 程式結束\n\nBut we need \"虛擬碼步驟\" format: maybe like \"Step 1: ...\". Use arrow. For decision lines, indent.\n\nLet's craft final output accordingly. Use the exact format: each line \"虛擬碼步驟 [space] // 解釋\". Use arrow '→'. Use indentation for nested decisions. Provide final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入子女數量 n 與餅乾數量 m // 取得輸入  \n→ Step 2: 讀取 g[0..n-1] // 子女的貪婪度  \n→ Step 3: 讀取 s[0..m-1] // 餅乾的大小  \n→ Step 4: 將 g 陣列遞增排序 // 方便後續匹配  \n→ Step 5: 將 s 陣列遞增排序 // 方便後續匹配  \n→ Step 6: 初始化指標 i = 0, j = 0, count = 0 // i 指向子女，j 指向餅乾  \n→ Decision: 是否還有未處理的子女與餅乾? // 迴圈條件  \n  Yes → Decision: s[j] 是否 ≥ g[i]? // 判斷餅乾是否足夠  \n   Yes → Step 7: count++ // 內容子女數量加一  \n    → Step 8: i++ ; j++ // 同時移動子女與餅乾指標  \n   No  → Step 9: j++ // 找下一個更大的餅乾  \n  No  → Step 10: 輸出 count // 顯示最大內容子女數  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        while i >= 0 or j >= 0 or carry:\n            x = int(num1[i]) if i >= 0 else 0\n            y = int(num2[j]) if j >= 0 else 0\n            total = x + y + carry\n            res.append(str(total % 10))\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        return ''.join(reversed(res))\n\ndef main():\n    data = sys.stdin.read().strip()\n    # 找出所有數字串\n    nums = re.findall(r'\\d+', data)\n    if len(nums) < 2:\n        # 可能是兩行分別給予數字\n        lines = data.splitlines()\n        nums = [line.strip() for line in lines if line.strip()]\n    num1, num2 = nums[0], nums[1]\n    result = Solution().addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for adding two large numbers given as strings, without using big integers or converting to int. We'll implement addition via digit arrays. Steps: Start; Input strings; Reverse or process from end; Initialize carry; Loop over positions; Sum digits; Append result char; After loop, if carry remains, append; Reverse result; Output; End. Use virtual code with arrows and decision.\n\nEnsure each line has \"虛擬碼步驟 // 解釋\". Provide line by line. Use Start, End. Use Decision. Use arrow for steps.\n\nLet's craft.\n\nWe'll do:\n\nStart // 程式開始\n\n→ Step 1: 接收 num1, num2 // 取得兩個字串\n\n→ Step 2: 將 num1, num2 反轉 // 方便從低位開始加\n\n→ Step 3: 初始化 carry = 0, result = 空串 // 準備加法\n\n→ Step 4: 取 max_len = max(len(num1_rev), len(num2_rev)) // 取得較長長度\n\n→ Step 5: 循環 i 從 0 到 max_len - 1 // 逐位相加\n\n    → Decision: i < len(num1_rev) ? // 是否有 num1 位\n\n        Yes → digit1 = num1_rev[i] - '0' // 取 num1 的該位\n\n        No  → digit1 = 0 // 無位時視為 0\n\n    → Decision: i < len(num2_rev) ?\n\n        Yes → digit2 = num2_rev[i] - '0' // 取 num2 的該位\n\n        No  → digit2 = 0\n\n    → Step 6: sum = digit1 + digit2 + carry // 計算此位總和\n\n    → Step 7: result += (sum % 10) + '0' // 把個位加到結果\n\n    → Step 8: carry = sum / 10 // 更新進位\n\n→ Decision: carry > 0 ? // 最後是否還有進位\n\n    Yes → result += carry + '0' // 加上進位\n\n    No  → // 無進位不做事\n\n→ Step 9: 反轉 result // 轉回正序\n\n→ Step 10: 輸出 result // 顯示相加結果\n\nEnd // 程式結束\n\nMake sure each line ends with // 解釋.\n\nUse the arrow symbol: \"→\".\n\nMake sure indentation is preserved for nested steps, but we just use arrow at each line. For decision branches, indent with spaces maybe. Provide line numbers? Not required.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收 num1, num2 // 取得兩個字串作為輸入  \n→ Step 2: 將 num1, num2 反轉 // 方便從最低位開始相加  \n→ Step 3: 初始化 carry = 0, result = 空串 // 準備進位和結果存儲  \n→ Step 4: 取 max_len = max(len(num1_rev), len(num2_rev)) // 取得較長字串的長度  \n→ Step 5: 循環 i 從 0 到 max_len - 1 // 逐位相加  \n  → Decision: i < len(num1_rev) ? // 是否 num1 有該位  \n   Yes → digit1 = num1_rev[i] - '0' // 取得 num1 的數字  \n   No  → digit1 = 0 // 缺位視為 0  \n  → Decision: i < len(num2_rev) ? // 是否 num2 有該位  \n   Yes → digit2 = num2_rev[i] - '0' // 取得 num2 的數字  \n   No  → digit2 = 0 // 缺位視為 0  \n  → Step 6: sum = digit1 + digit2 + carry // 計算此位總和  \n  → Step 7: result += (sum % 10) + '0' // 把個位數字加入結果  \n  → Step 8: carry = sum / 10 // 更新進位  \n→ Decision: carry > 0 ? // 最後是否還有進位  \n  Yes → result += carry + '0' // 加上進位  \n  No  → // 無進位不做事  \n→ Step 9: 反轉 result // 將結果從低位到高位轉回正序  \n→ Step 10: 輸出 result // 顯示相加後的字串結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays",
      "source_file": "Leetcode/leetcode349.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpkbhbm6hc.py\", line 25, in <module>\n    nums1 = ast.literal_eval(nums1_str)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    nums1 = [1,2,2,1]\n          ^\nSyntaxError: invalid syntax"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[9,4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpeyh0hbq0.py\", line 25, in <module>\n    nums1 = ast.literal_eval(nums1_str)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    nums1 = [4,9,5]\n          ^\nSyntaxError: invalid syntax"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        \"\"\"返回兩個整數陣列的唯一交集\"\"\"\n        return list(set(nums1) & set(nums2))\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # 假設輸入格式為: \"nums1 = [1,2,2,1], nums2 = [2,2]\"\n    # 先分割兩個陣列字串\n    try:\n        part1, part2 = data.split('], nums2 = ')\n    except ValueError:\n        # 如果格式不符直接退出\n        sys.exit()\n\n    # 補回缺失的右括號並解析成 Python 列表\n    nums1_str = part1 + ']'\n    nums2_str = part2\n    nums1 = ast.literal_eval(nums1_str)\n    nums2 = ast.literal_eval(nums2_str)\n\n    sol = Solution()\n    result = sol.intersection(nums1, nums2)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, line by line, using the format: \"虛擬碼步驟 // 解釋\". Should not output actual code, just structured steps. Use Start, Decision, etc. Need to solve intersection of two integer arrays, unique elements. So steps: Start, Step 1: Initialize empty set for result, Step 2: Convert nums1 to set, Step 3: Iterate nums2, for each element check if in set of nums1, if yes, add to result set. Step 4: Convert result set to array. Step 5: Return array. End. Could use decisions? Actually we can show a Decision to check if element in set, Yes: add to result. That uses Yes →.\n\nLet's produce steps:\n\nStart // start\n→ Step 1: Convert nums1 into SetA // use set for O(1) lookup\n→ Step 2: Initialize empty SetResult // store unique intersections\n→ Step 3: For each element x in nums2 // iterate second array\n    Decision: 是否 x 在 SetA? // check presence\n        Yes → Step 4: Add x 到 SetResult // add to result set\n        No  → Skip // nothing\n→ Step 5: Convert SetResult 為 ListResult // result list\n→ Step 6: Return ListResult // output\nEnd // end\n\nBut we need to produce in format lines with `虛擬碼步驟` and explanation. Each line should be separate. Use arrow, but need to maintain indentation maybe with spaces. Example format: \"→ Step 3: For each element x in nums2 // iterate second array\". Then inside Decision, we indent maybe with spaces: \"    Decision: 是否 x 在 SetA? // check presence\" Then \"        Yes → Step 4: Add x 到 SetResult // add\". So we need to include arrow and indentation. Also we must show arrow for decision.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Convert nums1 into SetA // 將第一個陣列轉成集合以便 O(1) 查找  \n→ Step 2: Initialize empty SetResult // 用於儲存唯一交集元素  \n→ Step 3: For each element x in nums2 // 逐一檢查第二個陣列的元素  \n    Decision: 是否 x 在 SetA? // 判斷 x 是否為 nums1 的成員  \n        Yes → Step 4: Add x 到 SetResult // 若存在，將 x 加入結果集合  \n        No  → Skip // 若不存在，直接略過  \n→ Step 5: Convert SetResult 為 ListResult // 將集合轉成陣列/列表  \n→ Step 6: Return ListResult // 回傳交集結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,4,0,2]'\nGot (Norm):      '[null,3,0,3]'\n--- (Raw) ---\nRaw Expected: '[null, 4, 0, 2]'\nRaw Got:      '[null, 3, 0, 3]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 將每個數字對應到其所有索引\n        self.num_indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.num_indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選對應索引\n        return random.choice(self.num_indices[target])\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將兩個列表包裝成一個列表方便解析\n    data = ast.literal_eval('[' + raw_input + ']')\n    commands, args_list = data\n\n    results = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # args[0] 是 nums 的列表\n            obj = Solution(args[0])\n            results.append(None)  # null\n        elif cmd == \"pick\":\n            # args[0] 是 target\n            results.append(obj.pick(args[0]))\n        else:\n            # 若有其他方法，可在此處擴充\n            results.append(None)\n\n    # 輸出結果，None 會被轉為 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines. The requirement: no actual code, just steps with arrow. Steps should cover initialization and pick method. For pick, algorithm: reservoir sampling? But since we know target exists, we can count occurrences and pick random. Approach: iterate through array, for each index where nums[i]==target, increment count, and with probability 1/count, select current index. Return selected index.\n\nLet's produce steps: Start, initialize solution: store array, maybe length. pick method: count=0, result=-1; for each index i from 0 to nums.length-1: if nums[i]==target: count++; if randomInt(count)==1: result=i; return result.\n\nWe need to produce virtual code steps. Let's produce like:\n\nStart\n→ Step 1: Store nums in object // ...\n→ End\n\npick method:\n\nStart\n→ Step 1: Initialize count = 0, result = -1 // ...\n→ Step 2: For each index i in 0..nums.length-1 // ...\n    → Decision: nums[i]==target? // check equality\n        Yes → Step 3: count++ // increment\n        Yes → Step 4: Generate random integer r in [1,count] // ...\n        Yes → Decision: r==1? // probability 1/count\n            Yes → Step 5: result = i // select index\n        No  → Continue loop\n        No  → Continue loop\n→ Step 6: Return result // after loop\n\nNeed to include arrows and decisions.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". Let's produce.\n\nAlso include class structure: Start of class, constructor, pick method.\n\nBut the spec only wants steps for algorithm, not actual code. So just steps.\n\nLet's produce:\n\nStart // 開始執行\n→ Step 1: Initialize object with array nums // 儲存輸入陣列\n→ End // 初始化完成\n\nThen pick:\n\nStart // pick 方法開始\n→ Step 1: 設定 count = 0, result = -1 // 初始化計數與回傳值\n→ Step 2: 從 0 到 nums.length-1 逐個檢查索引 i // 遍歷整個陣列\n    → Decision: 如果 nums[i] == target? // 檢查當前元素是否為目標\n        Yes → Step 3: count += 1 // 找到目標後計數遞增\n        Yes → Step 4: 產生隨機整數 r 於 [1, count] // 隨機決定是否選中\n        Yes → Decision: 如果 r == 1? // 機率為 1/count\n            Yes → Step 5: result = i // 選中此索引\n            No  → // 不選中，繼續\n        No  → // 當前元素不是目標，繼續\n→ Step 6: 回傳 result // 返回等概率的索引\nEnd // pick 方法結束\n\nNeed to add arrow \"→\" before each step lines. Indent decisions properly.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化物件並儲存陣列 nums // 讓物件擁有整個輸入數列  \nEnd // 初始化結束  \n\nStart // pick 方法開始執行  \n→ Step 1: 設定 count = 0, result = -1 // 用於統計目標出現次數與暫存隨機選取的索引  \n→ Step 2: 從 0 到 nums.length-1 逐個檢查索引 i // 逐步遍歷整個陣列  \n  Decision: 如果 nums[i] == target? // 判斷目前元素是否為目標值  \n   Yes → Step 3: count += 1 // 找到目標後計數遞增  \n   Yes → Step 4: 產生隨機整數 r 於 [1, count] // 以 1/count 的機率決定是否選中  \n   Yes → Decision: 如果 r == 1? // 檢查是否被選中  \n    Yes → Step 5: result = i // 成功選中此索引，更新結果  \n    No  → // r ≠ 1 時不選中，繼續迴圈  \n   No  → // nums[i] 不是目標，直接繼續迴圈  \n→ Step 6: 回傳 result // 最後返回等機率選出的索引  \nEnd // pick 方法結束執行"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def frequencySort(self, s: str) -> str:\n        \"\"\"\n        Sort characters in descending order of frequency.\n        \"\"\"\n        # Count frequency of each character\n        freq = Counter(s)\n        # Build result by repeating each character 'count' times,\n        # sorted by frequency descending.\n        return ''.join(char * count for char, count in freq.most_common())\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, process it, and print the sorted string.\n    The input format may be either:\n        s = \"tree\"\n    or simply:\n        tree\n    \"\"\"\n    raw_input = sys.stdin.read().strip()\n\n    # Extract the string value.\n    s = None\n    # Try to find quoted string\n    for quote in ('\"', \"'\"):\n        start = raw_input.find(quote)\n        if start != -1:\n            end = raw_input.find(quote, start + 1)\n            if end != -1:\n                s = raw_input[start + 1:end]\n                break\n    # Fallback: take entire input as the string\n    if s is None:\n        # Remove any surrounding code like 's = '\n        parts = raw_input.split('=', 1)\n        if len(parts) == 2:\n            s = parts[1].strip()\n        else:\n            s = raw_input.strip()\n\n    solution = Solution()\n    result = solution.frequencySort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line, with comments. The user wants virtual code to sort a string in decreasing order of character frequency. We'll produce steps: Start, Step 1: input string s, Step 2: count frequency of each char, Step 3: create list of pairs char and freq, Step 4: sort list descending by freq, Step 5: build result string by repeating char freq times, End.\n\nAlso we should cover handling multiple answers, but just produce any. So no additional decisions.\n\nLet's produce.\n\nAlso we should use arrows: →. For decision: if needed. Not many decisions.\n\nOk produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者取得要排序的字串  \n→ Step 2: 建立頻率表 freqMap // 以字典儲存每個字元出現的次數  \n→ Step 3: 遍歷字串 s  \n  → For each character c in s  \n   → freqMap[c] = freqMap.get(c, 0) + 1 // 更新字元頻率  \n→ Step 4: 將頻率表轉成字元-頻率對列表 pairs  \n  → For each (char, count) in freqMap.items()  \n   → Append (char, count) to pairs // 收集所有字元及其頻率  \n→ Step 5: 按頻率降序排序 pairs // 最高頻率的字元先出現  \n  → pairs.sort(key = lambda pair: pair[1], reverse = True)  \n→ Step 6: 建立結果字串 result = ''  \n  → For each (char, count) in pairs  \n   → result += char * count // 重複字元 count 次加入結果  \n→ End // 輸出結果字串並結束程式"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef is_palindrome(s: str) -> bool:\n    \"\"\"判斷字串 s 是否為回文。\"\"\"\n    return s == s[::-1]\n\ndef palindrome_pairs(words):\n    \"\"\"找出所有回文對，時間複雜度 O(總字長)。\"\"\"\n    word_to_index = {word: i for i, word in enumerate(words)}\n    res_set = set()\n\n    # 1. 空字串特殊處理\n    if '' in word_to_index:\n        empty_index = word_to_index['']\n        for i, w in enumerate(words):\n            if i == empty_index:\n                continue\n            if is_palindrome(w):\n                res_set.add((empty_index, i))\n                res_set.add((i, empty_index))\n\n    # 2. 其餘情況\n    for i, word in enumerate(words):\n        rev_word = word[::-1]\n\n        # 完全倒序對\n        if rev_word in word_to_index:\n            j = word_to_index[rev_word]\n            if i != j:\n                res_set.add((i, j))\n\n        # 斷開檢查\n        for cut in range(len(word) + 1):\n            prefix = word[:cut]\n            suffix = word[cut:]\n\n            # 前半段是回文，後半段倒序存在\n            if is_palindrome(prefix):\n                rev_suffix = suffix[::-1]\n                if rev_suffix in word_to_index:\n                    j = word_to_index[rev_suffix]\n                    if i != j:\n                        res_set.add((j, i))\n\n            # 後半段是回文，前半段倒序存在\n            if cut != len(word) and is_palindrome(suffix):\n                rev_prefix = prefix[::-1]\n                if rev_prefix in word_to_index:\n                    j = word_to_index[rev_prefix]\n                    if i != j:\n                        res_set.add((i, j))\n\n    # 轉回 list 並維持可讀性順序\n    return [list(pair) for pair in res_set]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 取出列表部分，允許前面有 'words ='\n    start = data.find('[')\n    end = data.rfind(']')\n    if start == -1 or end == -1:\n        raise ValueError(\"輸入格式錯誤，請輸入形如 words = [..] 的資料\")\n    list_str = data[start:end+1]\n    words = ast.literal_eval(list_str)\n\n    result = palindrome_pairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code in Chinese with explanations. Need to satisfy algorithm O(total length). Standard approach: build dictionary of reversed words, check prefixes/suffixes. Virtual code step by step.\n\nWe produce steps:\n\nStart\n→ Build map word->index\n→ For each word, reverse it, check if reversed exists (excluding same)\n→ For each word, iterate over splits\n    prefix, suffix\n    if prefix is palindrome and reversed suffix in map\n    if suffix is palindrome and reversed prefix in map\nEdge cases: empty string\n\nReturn pairs.\n\nWe need to output each step with explanation. Use arrow, Decision etc. Also include loops.\n\nLet's structure:\n\nStart\n→ Build dictionary\n→ For each word index i:\n    → Check reversed exists\n    → For each split position j from 0 to len:\n        → Decision: prefix is palindrome?\n            Yes → Check if reversed suffix exists\n                Yes → Record pair (revIndex, i)\n        → Decision: suffix is palindrome?\n            Yes → Check if reversed prefix exists\n                Yes → Record pair (i, revIndex)\n\nAlso handle empty string case: If empty exists, for all other words if word is palindrome, add pairs.\n\nAlso ensure not duplicate pairs.\n\nWe'll produce pseudo-code lines.\n\nNeed to show each line with explanation after //.\n\nOk. Let's produce final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立字典 wordToIndex，將每個單詞映射到其索引 // 用於 O(1) 查找反向單詞\n→ Step 2: 若字典中包含空字串，將空字串索引儲存為 emptyIndex // 空字串需要特殊處理\n→ Step 3: 初始化結果 list pairs = [] // 存放所有符合的 (i, j) 對\n\n→ Decision: 若 emptyIndex 存在？ // 檢查是否有空字串\n    Yes → Step 4: 對於每個索引 i，若 i ≠ emptyIndex 且 words[i] 為回文\n        → Step 4a: pairs.append((emptyIndex, i)) // 空 + 回文\n        → Step 4b: pairs.append((i, emptyIndex)) // 回文 + 空\n    No  →  // 不需要執行空字串特例\n\n→ Step 5: 對於每個索引 i 與單詞 word\n    → Step 5a: reversedWord ← reverse(word) // 取得單詞倒序\n    → Decision: reversedWord 在 wordToIndex 且 wordToIndex[reversedWord] ≠ i？\n        Yes → Step 5b: pairs.append((i, wordToIndex[reversedWord])) // 完全倒序對\n        No  →  // 無需處理\n\n    → Step 6: 對於分割位置 j 從 0 到 len(word)\n        → prefix ← word[:j] // 前段\n        → suffix ← word[j:] // 後段\n\n        → Decision: prefix 是回文？\n            Yes → revSuffix ← reverse(suffix)\n                → Decision: revSuffix 在 wordToIndex 且 wordToIndex[revSuffix] ≠ i？\n                    Yes → pairs.append((wordToIndex[revSuffix], i)) // 以 suffix 為前綴的倒序對\n                    No  →  // 無此對\n            No  →  // 前段非回文，不考慮\n\n        → Decision: suffix 是回文？\n            Yes → revPrefix ← reverse(prefix)\n                → Decision: revPrefix 在 wordToIndex 且 wordToIndex[revPrefix] ≠ i 且 j ≠ len(word)？\n                    Yes → pairs.append((i, wordToIndex[revPrefix])) // 以 prefix 為後綴的倒序對\n                    No  →  // 無此對\n            No  →  // 後段非回文，不考慮\n\nEnd // 程式執行結束，pairs 為所有回文對的列表"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef is_subsequence(a: str, b: str) -> bool:\n    \"\"\"Return True if a is a subsequence of b.\"\"\"\n    it = iter(b)\n    return all(ch in it for ch in a)\n\ndef find_lus_length(strs):\n    \"\"\"Find the length of the longest uncommon subsequence.\"\"\"\n    max_len = -1\n    for s in strs:\n        # If s is a subsequence of any other string, skip it\n        if any(is_subsequence(s, t) for t in strs if t != s):\n            continue\n        max_len = max(max_len, len(s))\n    return max_len\n\nif __name__ == \"__main__\":\n    # Read entire input, strip whitespace\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Parse the list of strings\n    try:\n        strs = ast.literal_eval(data)\n    except Exception:\n        print(-1)\n        sys.exit(0)\n    # Ensure we have a list of strings\n    if not isinstance(strs, list) or not all(isinstance(x, str) for x in strs):\n        print(-1)\n        sys.exit(0)\n    result = find_lus_length(strs)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate pseudocode steps for algorithm to find longest uncommon subsequence (LUS) length among array of strings.\n\nKnown solution: if there exists a string that is unique in array, then answer is its length. Else -1. Because if a string is unique, it cannot be a subsequence of any other string of same length? Actually uniqueness of entire string ensures no other string equal; but still could be subsequence of another longer string. But typical solution: If there is any string not equal to any other string, then answer is its length. Because to be uncommon subsequence, we need a string that is a subsequence of itself and not subsequence of any other. The unique string may still be subsequence of another longer string. Example: strs = [\"ab\",\"a\"]; unique string \"ab\" length 2, but \"ab\" is not subsequence of \"a\" but could be subsequence of another? No. If \"ab\" is unique but may be subsequence of some longer string. But algorithm still works: choose the longest unique string; if it's not a subsequence of any other, length else -1. But typical accepted solution: answer = longest string if it's unique; else -1. For arrays of strings, any string that is not duplicated qualifies because if there is duplicate string, that string is subsequence of the duplicate, so not uncommon. For uniqueness, length of longest unique string works.\n\nBut we need pseudocode line-by-line. We'll assume simple algorithm: count frequency of each string. Find longest string among those with freq==1. If none, return -1.\n\nLet's produce pseudocode steps accordingly.\n\nSteps:\n\nStart\n→ Step 1: Count frequency of each string in strs\n→ Step 2: Initialize maxLen = -1\n→ Step 3: For each string s in strs\n→ Decision: If freq[s] == 1? \n   Yes → Decision: If length(s) > maxLen? \n       Yes → Step 4: maxLen = length(s)\n       No → (do nothing)\n   No → (do nothing)\n→ Step 5: Return maxLen // if still -1 then no uncommon subsequence\n\nLet's produce in required format with explanation.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空的頻率字典 freq // 用於統計每個字串出現的次數  \n→ Step 2: 對於陣列 strs 中的每個字串 s  \n→ Decision: 如果 freq 已存在則 freq[s]++，否則 freq[s] = 1 // 更新頻率統計  \n→ Step 3: 初始化 maxLen = -1 // 儲存目前找到的最大長度，-1 表示尚未找到  \n→ Step 4: 對於陣列 strs 中的每個字串 s  \n→ Decision: 如果 freq[s] == 1? // 只考慮唯一出現的字串  \n    Yes → Decision: 如果 length(s) > maxLen? // 比較長度是否更長  \n        Yes → Step 5: maxLen = length(s) // 更新最大長度  \n        No  → (不做任何事)  \n    No  → (不做任何事)  \n→ Step 6: Return maxLen // 回傳最大長度；若為 -1 則代表不存在不常見子序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        slow = fast = nums[0]\n        # 第一階段: 找到相遇點\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # 第二階段: 找到入環點（重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # 從輸入字串中提取列表\n    try:\n        start = data.index('[')\n        end = data.rindex(']') + 1\n        nums = ast.literal_eval(data[start:end])\n    except (ValueError, SyntaxError):\n        print(\"Invalid input format\")\n        sys.exit(1)\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the problem: find duplicate in array with numbers 1..n, length n+1, one duplicate, no modification, constant extra space. Classic Floyd's Tortoise and Hare cycle detection.\n\nWe need to produce virtual code line by line, with explanation, using arrow notation. Use \"Start\", \"End\", \"Decision:\" etc. Provide steps: read array, maybe use pointer indexes. Implementation: first phase: find intersection using slow and fast pointers. second phase: find entrance of cycle.\n\nWe need to produce virtual code, not actual code.\n\nThus produce something like:\n\nStart\n→ Step 1: Initialize slow = nums[0], fast = nums[0] // set pointers\n→ Step 2: Loop until slow == fast\n    → slow = nums[slow] // move slow by one step\n    → fast = nums[nums[fast]] // move fast by two steps\n→ Step 3: Reset fast to nums[0] // start from head\n→ Step 4: Loop until slow == fast\n    → slow = nums[slow] // move slow by one step\n    → fast = nums[fast] // move fast by one step\n→ Step 5: Return slow // duplicate number\nEnd\n\nBut we need to follow the specified format exactly. Each line: \"虛擬碼步驟 [space] // 解釋\".\n\nAlso we need to use arrows where appropriate. Use \"Start\" \"End\". Use Decision: only if needed.\n\nSo produce lines:\n\nStart // 程式開始執行\n→ Step 1: 設定 slow = nums[0], fast = nums[0] // 初始化慢指標與快指標\n→ Decision: 直到 slow == fast? // 檢查是否相遇\n    Yes → Step 2: slow = nums[slow] // 慢指標移動一步\n    Yes → Step 3: fast = nums[nums[fast]] // 快指標移動兩步\n    No  → Step 2/3 // 重複執行直到相遇\n→ Step 4: 重新將 fast 設為 nums[0] // 重新定位快指標到起點\n→ Decision: 直到 slow == fast? // 檢查再次相遇\n    Yes → Step 5: slow = nums[slow] // 慢指標移動一步\n    Yes → Step 6: fast = nums[fast] // 快指標移動一步\n    No  → Step 5/6 // 重複直到相遇\n→ Step 7: 回傳 slow // 相遇點即重複數字\nEnd // 程式執行結束\n\nBut the arrow style in the example: they used:\n\n→ Step 1: ...\n→ Decision: ...\n    Yes → Step 2: ...\n    No  → Decision: ...\n\nBut our decision steps may have loops, but we need to show iterative steps. But typical style is to show loops with decision. For example:\n\n→ Decision: slow != fast?\n    Yes → Step 2: slow = nums[slow]\n          → Step 3: fast = nums[nums[fast]]\n          → Go back to Decision\n    No  → Next step\n\nBut they used simple arrow style.\n\nWe should produce lines with \"Start\" \"End\". And each step uses arrow arrow.\n\nWe also need to include that we must not modify the array, use constant space. So we can mention that.\n\nAlso each line we produce must be unique. Provide explanation after //.\n\nThus produce final answer accordingly.\n\nWe must be careful: The example shows a structure: \"Start\", then \"→ Step 1:\", \"→ Decision:\" etc. They didn't include loops in a single line but repeated lines. So we can mimic that.\n\nBetter produce:\n\nStart // 程式開始執行\n→ Step 1: slow = nums[0], fast = nums[0] // 初始化慢指標與快指標指向陣列第一個元素\n→ Decision: slow != fast? // 判斷慢快指標是否相遇\n    Yes → Step 2: slow = nums[slow] // 慢指標向前移動一步\n          → Step 3: fast = nums[nums[fast]] // 快指標向前移動兩步\n          → Go back to Decision\n    No  → Next\n→ Step 4: fast = nums[0] // 重新將快指標設回起點\n→ Decision: slow != fast? // 再次判斷兩指標是否相遇\n    Yes → Step 5: slow = nums[slow] // 慢指標一步\n          → Step 6: fast = nums[fast] // 快指標一步\n          → Go back to Decision\n    No  → Next\n→ Step 7: return slow // 相遇點即重複數字\nEnd // 程式執行結束\n\nBut we must format each line exactly with \"虛擬碼步驟\" + space + \"// 解釋\". And use arrows.\n\nWe need to ensure we don't use actual code like 'return' but it's fine as pseudo-code.\n\nWe can keep as described.\n\nAlso maybe include \"constant extra space\" mention, but it's okay.\n\nThus produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow = nums[0], fast = nums[0] // 初始化慢指標與快指標指向陣列第一個元素  \n→ Decision: slow != fast? // 判斷兩指標是否相遇  \n    Yes → Step 2: slow = nums[slow] // 慢指標向前移動一步  \n          → Step 3: fast = nums[nums[fast]] // 快指標向前移動兩步  \n          → Go back to Decision  \n    No  → Next  \n→ Step 4: fast = nums[0] // 重新將快指標設回起點  \n→ Decision: slow != fast? // 再次判斷兩指標是否相遇  \n    Yes → Step 5: slow = nums[slow] // 慢指標一步  \n          → Step 6: fast = nums[fast] // 快指標一步  \n          → Go back to Decision  \n    No  → Next  \n→ Step 7: return slow // 相遇點即為重複數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6y2e4j38.py\", line 79, in <module>\n    main()\n  File \"/tmp/tmp6y2e4j38.py\", line 56, in main\n    params = json.loads(params_str)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 3 (char 2)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass RandomizedCollection:\n    def __init__(self):\n        self.data = []                     # 存放所有元素的列表\n        self.idx_map = {}                  # value -> set of indices in data\n\n    def insert(self, val):\n        \"\"\"插入元素，若是第一次插入則回傳 True，否則回傳 False。\"\"\"\n        self.data.append(val)\n        if val in self.idx_map:\n            self.idx_map[val].add(len(self.data) - 1)\n            return False\n        else:\n            self.idx_map[val] = {len(self.data) - 1}\n            return True\n\n    def remove(self, val):\n        \"\"\"移除一個 val，若不存在則回傳 False。\"\"\"\n        if val not in self.idx_map or not self.idx_map[val]:\n            return False\n\n        remove_idx = self.idx_map[val].pop()          # 任取一個索引\n        last_idx = len(self.data) - 1\n        last_val = self.data[last_idx]\n\n        # 把最後一個元素搬到要刪除的位置\n        self.data[remove_idx] = last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(last_idx)\n\n        self.data.pop()                               # 刪除最後一個元素\n\n        if not self.idx_map[val]:\n            del self.idx_map[val]                     # 若此值已無任何索引，刪除映射\n        return True\n\n    def getRandom(self):\n        \"\"\"隨機返回一個元素，出現機率與頻率成正比。\"\"\"\n        return random.choice(self.data)\n\n\ndef main():\n    raw = sys.stdin.read().strip()\n    if not raw:\n        return\n\n    # 解析輸入：分成兩個列表\n    parts = raw.split('], [', 1)\n    ops_str = parts[0] + ']'          # 第一個列表\n    params_str = parts[1]             # 第二個列表（已包含外層方括號）\n\n    ops = json.loads(ops_str)\n    params = json.loads(params_str)\n\n    outputs = []\n    obj = None\n\n    for i, op in enumerate(ops):\n        if op == 'RandomizedCollection':\n            obj = RandomizedCollection()\n            outputs.append(None)\n        elif op == 'insert':\n            res = obj.insert(params[i][0])\n            outputs.append(res)\n        elif op == 'remove':\n            res = obj.remove(params[i][0])\n            outputs.append(res)\n        elif op == 'getRandom':\n            res = obj.getRandom()\n            outputs.append(res)\n\n    print(json.dumps(outputs))\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code steps explaining the design of RandomizedCollection with operations insert, remove, getRandom. Must use Start, End, Decision, arrows, etc. Provide line-by-line pseudo-code with explanation. Must not output actual code, just pseudo-code. Each line: \"虛擬碼步驟 // 解釋\". Use arrows \"→\". Provide structure of algorithm: use list for values, hashmap from val to set of indices. For remove, pick index to delete, swap with last element, update map. Insert adds at end and updates map. getRandom returns random element from list. Need average O(1). Provide explanation lines. Should be in traditional Chinese. Let's produce pseudo-code lines. Ensure each line includes code text, a space, then // explanation. Use indentation? The example shows indentation. Use spaces after decision arrow lines. We'll produce. Let's deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Init: 建立空 list values // 用於儲存所有元素  \n→ Init: 建立空 hash valToIndices // map: val → set of positions in values  \n→ Init: 建立隨機數產生器 rng // 用於 getRandom  \n\n→ Function insert(val)  \n    → Append val to values // 把新值放到 list 最後  \n    → Index newIndex ← values.size - 1 // 取得新元素索引  \n    → If val not in valToIndices  \n        → Create new empty set indicesSet  \n        → valToIndices[val] ← indicesSet  \n        → ReturnTrue ← true // 第一次加入  \n      Else  \n        → ReturnTrue ← false // 已存在，仍插入但回傳 false  \n    → Add newIndex to valToIndices[val] // 更新索引集合  \n    → Return ReturnTrue  \n\n→ Function remove(val)  \n    → If val not in valToIndices or valToIndices[val] empty  \n        → Return false // 沒有該值可移除  \n    → Get an arbitrary index idx from valToIndices[val] // 取一個要移除的位置  \n    → lastIndex ← values.size - 1 // 取得最後一個元素位置  \n    → lastVal ← values[lastIndex] // 取得最後一個元素值  \n    → values[idx] ← lastVal // 用最後一個元素覆蓋要移除的位置  \n    → Remove idx from valToIndices[val] // 移除原本的索引  \n    → If idx ≠ lastIndex  \n        → Remove lastIndex from valToIndices[lastVal] // 更新最後一個元素的索引集合  \n        → Add idx to valToIndices[lastVal] // 新位置加入索引集合  \n    → Remove last element from values // 刪除 list 最後一個（已被覆蓋）  \n    → If valToIndices[val] now empty  \n        → Delete valToIndices[val] // 清除空集合以節省空間  \n    → Return true  \n\n→ Function getRandom()  \n    → randomIdx ← rng.nextInt(values.size) // 隨機取 0~size-1  \n    → Return values[randomIdx] // 回傳隨機元素  \n\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7960dyth.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp7960dyth.py\", line 30, in main\n    coins = eval(coins_part)\n            ^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # 初始化 dp 陣列，dp[i] 表示湊成金額 i 所需最少硬幣數\n        dp = [amount + 1] * (amount + 1)  # 使用 amount+1 作為 INF\n        dp[0] = 0\n\n        for coin in coins:\n            for i in range(coin, amount + 1):\n                if dp[i - coin] + 1 < dp[i]:\n                    dp[i] = dp[i - coin] + 1\n\n        return dp[amount] if dp[amount] <= amount else -1\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，例如：'coins = [1,2,5], amount = 11'\n    coins = []\n    amount = 0\n    parts = [p.strip() for p in data.split(',')]\n    for part in parts:\n        if part.startswith('coins'):\n            # 取等號後面的部分並 eval 取得 list\n            coins_part = part.split('=', 1)[1].strip()\n            coins = eval(coins_part)\n        elif part.startswith('amount'):\n            amount_part = part.split('=', 1)[1].strip()\n            amount = int(amount_part)\n\n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation. It's coin change problem: minimal number of coins to make amount using infinite supply. Classic dynamic programming. We need to produce step-by-step pseudocode with explanations. Use Start, Decision, etc. Must output line-by-line with virtual code and comments.\n\nWe need to incorporate algorithm: dp array length amount+1, initialize dp[0]=0, others to large INF. Iterate for each coin, for i from coin to amount: dp[i] = min(dp[i], dp[i-coin]+1). After loops, if dp[amount] is INF then return -1 else dp[amount]. Use decision to check.\n\nWe need to output line by line:\n\nStart\n→ Step 1: 初始化 dp[0] = 0, 其餘 dp[i] = INF\n→ Step 2: For each coin in coins:\n   → Step 2.1: For i from coin to amount:\n        → Step 2.1.1: dp[i] = min(dp[i], dp[i-coin]+1)\n→ Decision: 如果 dp[amount] 為 INF? \n    Yes → Step 3: 返回 -1 // 不能組合\n    No  → Step 3: 返回 dp[amount] // 最小硬幣數\n\nEnd\n\nAlso we may include initialization of INF as amount+1.\n\nAlso we may show the loop structure.\n\nLet's produce detailed lines with arrow and indentation. We should use \"→\" for each step. Decision lines as per requirement.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 INF = amount + 1 // 取一個大於任何可能硬幣數量的值  \n→ Step 2: 建立 dp 陣列長度 amount + 1，並將 dp[0] 設為 0，其他位置皆設為 INF  \n→ Step 3: Decision: 是否存在 coin 列表？  \n  Yes → Step 4: For each coin in coins: // 遍歷每種硬幣面額  \n    → Step 5: For i from coin to amount: // 從該硬幣面額開始，計算更高金額  \n      → Step 6: dp[i] = min(dp[i], dp[i - coin] + 1) // 若以此硬幣能得到更少硬幣數，則更新  \n      → Step 7: End // i 迴圈結束  \n    → Step 8: End // coin 迴圈結束  \n  No → Step 9: // 若 coins 為空，直接跳到判斷結果  \n→ Decision: dp[amount] 是否等於 INF? // 判斷是否能組成目標金額  \n  Yes → Step 10: Return -1 // 無法組成任何金額  \n  No  → Step 10: Return dp[amount] // 返回最小硬幣數量  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1.5,null,2.0]'\nGot (Norm):      '[null,null,null,1.5,null,2]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1.5, null, 2.0]'\nRaw Got:      '[null, null, null, 1.5, null, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\nimport json\n\nclass MedianFinder:\n    \"\"\"維持兩個堆，實時取得中位數。\"\"\"\n    def __init__(self):\n        # 小堆（最大堆，實作為負數）\n        self.small = []\n        # 大堆（最小堆）\n        self.large = []\n\n    def addNum(self, num: int) -> None:\n        # 先把數字放進小堆\n        heapq.heappush(self.small, -num)\n\n        # 若兩堆均不空且小堆最大值大於大堆最小值，交換\n        if self.large and -self.small[0] > self.large[0]:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # 平衡堆的大小，允許的差值為 1\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        elif len(self.large) > len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0\n\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 將輸入轉為合法的 Python tuple，方便解析\n    try:\n        ops, args = ast.literal_eval('(' + data + ')')\n    except Exception:\n        # 若解析失敗，直接終止\n        return\n\n    output = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            output.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            output.append(None)\n        elif op == \"findMedian\":\n            median = obj.findMedian()\n            output.append(median)\n\n    # 使用 json.dumps 以得到 'null' 的輸出格式\n    print(json.dumps(output))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step-by-step for implementing MedianFinder with addNum and findMedian. Use two heaps: max-heap for lower half, min-heap for upper half. Keep size difference <=1. findMedian returns middle if odd, else average.\n\nWe must follow format: each line: \"虛擬碼步驟 // 解釋\".\n\nInclude Start, End, Decision. Probably class definition, constructor, addNum, findMedian. Use arrows.\n\nLet's craft:\n\nStart\n→ Class MedianFinder // 定義 MedianFinder 類\n    → Step 1: 定義 maxHeap (最大堆) // 儲存較小的一半\n    → Step 2: 定義 minHeap (最小堆) // 儲存較大的一半\n    → Step 3: Initialize heaps empty // 初始化\n\n→ Method addNum(num) // 新增數字\n    → Decision: maxHeap is empty or num <= maxHeap.top? // 判斷放在哪個堆\n        Yes → Insert num into maxHeap // 放入較小堆\n        No  → Insert num into minHeap // 放入較大堆\n    → Decision: size(maxHeap) > size(minHeap)+1? // 調整大小差\n        Yes → Move top of maxHeap to minHeap // 平衡\n        No  → Decision: size(minHeap) > size(maxHeap)+1? // 另一方向\n            Yes → Move top of minHeap to maxHeap\n            No → No action\n\n→ Method findMedian() // 取得中位數\n    → Decision: size(maxHeap) == size(minHeap)? // 數量相同\n        Yes → Return (maxHeap.top + minHeap.top) / 2.0 // 平均\n        No → Decision: size(maxHeap) > size(minHeap)? // 大堆多\n            Yes → Return maxHeap.top\n            No  → Return minHeap.top\n\nEnd\n\nEnsure each line has \"虛擬碼步驟 // 解釋\".\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MedianFinder // 定義 MedianFinder 類  \n    → Step 1: 定義 maxHeap (最大堆) // 儲存較小的一半數字  \n    → Step 2: 定義 minHeap (最小堆) // 儲存較大的一半數字  \n    → Step 3: Initialize heaps empty // 初始化兩個堆為空  \n→ Method addNum(num) // 新增數字到資料結構  \n    → Decision: maxHeap is empty or num <= maxHeap.top? // 判斷該數字屬於哪一半  \n        Yes → Insert num into maxHeap // 放入較小堆  \n        No  → Insert num into minHeap // 放入較大堆  \n    → Decision: size(maxHeap) > size(minHeap)+1? // 檢查左堆是否過大  \n        Yes → Move top of maxHeap to minHeap // 從左堆轉移至右堆以平衡  \n        No → Decision: size(minHeap) > size(maxHeap)+1? // 檢查右堆是否過大  \n            Yes → Move top of minHeap to maxHeap // 從右堆轉移至左堆以平衡  \n            No → No action // 大小差已在允許範圍內  \n→ Method findMedian() // 計算並返回目前的中位數  \n    → Decision: size(maxHeap) == size(minHeap)? // 堆大小相等，總數為偶數  \n        Yes → Return (maxHeap.top + minHeap.top) / 2.0 // 兩個中位數的平均值  \n        No → Decision: size(maxHeap) > size(minHeap)? // 左堆較多，數量為奇數  \n            Yes → Return maxHeap.top // 返回左堆頂作為中位數  \n            No  → Return minHeap.top // 返回右堆頂作為中位數  \nEnd // 程式執行結束"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[None,None,[[1,1]],None,[[1,1],[3,3]],None,[[1,1],[3,3],[7,7]],None,[[1,3],[7,7]],None,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[None, None, [[1, 1]], None, [[1, 1], [3, 3]], None, [[1, 1], [3, 3], [7, 7]], None, [[1, 3], [7, 7]], None, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n\n    def addNum(self, val):\n        new_interval = [val, val]\n        res = []\n        placed = False\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # current interval is completely before new number\n                res.append([start, end])\n            elif val + 1 < start:\n                # current interval is after new number and not adjacent\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                # intervals overlap or are adjacent – merge\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n        if not placed:\n            res.append(new_interval)\n        self.intervals = res\n\n    def getIntervals(self):\n        return self.intervals\n\n\ndef main():\n    data = sys.stdin.read().strip().splitlines()\n    if len(data) < 2:\n        return\n    methods = ast.literal_eval(data[0].strip())\n    args_list = ast.literal_eval(data[1].strip())\n\n    results = []\n    obj = None\n\n    for method, args in zip(methods, args_list):\n        if method == \"SummaryRanges\":\n            obj = SummaryRanges()\n            results.append(None)\n        elif method == \"addNum\":\n            obj.addNum(args[0])\n            results.append(None)\n        elif method == \"getIntervals\":\n            results.append(obj.getIntervals())\n\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line with comments. We need to design a virtual code algorithm for the SummaryRanges class: maintain intervals sorted and disjoint. Methods: addNum, getIntervals.\n\nWe need to produce step-by-step pseudo-code, with decision arrows etc. Probably include initialization: create empty intervals list. For addNum: find position to insert or merge. Use binary search or linear scan. Use sorted intervals. Steps: find left and right boundaries.\n\nWe will produce pseudocode lines starting with Start etc. Let's structure as:\n\nStart\n→ Step: Initialize intervals as empty list // constructor\n→ Step: Define addNum(value)\n→ Step: Define getIntervals()\n\nWithin addNum: maybe do:\n\n→ Decision: If intervals empty → Step: add [value,value] to list\n\nElse:\n\nFind position where value would fit.\n\nPseudo: i = 0\n→ Decision: i < intervals.size AND intervals[i].end < value? ... but we need loop.\n\nSimplify: iterate through intervals, find overlapping or adjacent intervals.\n\nAlgorithm: For each interval in intervals:\n   if value < interval.start - 1: // value before this interval and not adjacent\n        insert before this interval\n        return\n   else if value <= interval.end + 1: // value touches or inside interval\n        merge: interval.start = min(interval.start, value)\n        interval.end = max(interval.end, value)\n        // after merge, might need to merge with next intervals if overlapping\n        merge with subsequent intervals while next.start <= interval.end + 1\n        return\nIf no break, add at end.\n\nThus produce pseudocode lines.\n\nAlso getIntervals: simply return copy of intervals.\n\nLet's produce virtual code lines accordingly. Use arrow indentation.\n\nWe need to include Start and End for each method? maybe Start for program, then steps.\n\nWe can represent methods as steps.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: SummaryRanges() // 初始化空間\n→ Decision: intervals.isEmpty()? // 檢查是否有區間\n...\n\nActually better: Outline constructor.\n\nLet's produce like:\n\nStart // 程式開始執行\n→ Step 1: Define SummaryRanges()\n    → Step 1.1: intervals ← empty list // 用於儲存區間\n→ Step 2: Define addNum(value)\n    → Step 2.1: i ← 0\n    → Decision: i < intervals.size AND intervals[i].end < value - 1? // value 距離目前區間太遠，繼續往後\n        Yes → i ← i + 1 → Step 2.1: // 迭代至可能位置\n        No  → Decision: intervals[i].start <= value <= intervals[i].end + 1? // value 在或相鄰於當前區間\n            Yes → Step 2.2: intervals[i].start ← min(intervals[i].start, value)\n                 → Step 2.3: intervals[i].end ← max(intervals[i].end, value)\n                 → Step 2.4: // 合併後續重疊或相鄰區間\n                    → While i+1 < intervals.size AND intervals[i+1].start <= intervals[i].end + 1\n                        → Step 2.5: intervals[i].end ← max(intervals[i].end, intervals[i+1].end)\n                        → Step 2.6: remove intervals[i+1]\n                    → End While\n                 → End // addNum 完成\n            No → Decision: i == intervals.size? // value 在所有區間之後\n                Yes → Step 2.7: append [value,value] to intervals\n                No  → Step 2.8: insert [value,value] before intervals[i]\n        // End addNum\n→ Step 3: Define getIntervals()\n    → Step 3.1: return intervals // 直接返回區間清單\nEnd // 程式執行結束\n\nWe need to ensure indentation using arrow? We can use arrow for steps.\n\nWe might need to add 'Start' at program start, but each method has its own start? We'll show steps with indentation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n\n→ Step 1: Define SummaryRanges() // 建構子\n    → Step 1.1: intervals ← empty list // 用於儲存所有不相交區間\n\n→ Step 2: Define addNum(value) // 新增數值\n    → Step 2.1: i ← 0 // 從第一個區間開始搜尋\n    → Decision: i < intervals.size AND intervals[i].end < value - 1? // 數值太小，繼續往後\n        Yes → i ← i + 1 → Step 2.1: // 迭代至可能位置\n        No  → Decision: intervals[i].start ≤ value ≤ intervals[i].end + 1? // 數值在或相鄰於當前區間\n            Yes → Step 2.2: intervals[i].start ← min(intervals[i].start, value) // 擴大起始點\n                 → Step 2.3: intervals[i].end ← max(intervals[i].end, value)   // 擴大結束點\n                 → Step 2.4: // 合併後續重疊或相鄰區間\n                    → While i + 1 < intervals.size AND intervals[i + 1].start ≤ intervals[i].end + 1\n                        → Step 2.5: intervals[i].end ← max(intervals[i].end, intervals[i + 1].end) // 合併結束點\n                        → Step 2.6: remove intervals[i + 1] // 刪除被合併的區間\n                    → End While\n                 → End // addNum 完成\n            No → Decision: i == intervals.size? // 數值在所有區間之後\n                Yes → Step 2.7: append [value, value] to intervals // 新增最後一個區間\n                No  → Step 2.8: insert [value, value] before intervals[i] // 新增中間區間\n        // End of addNum\n\n→ Step 3: Define getIntervals() // 取得目前所有區間\n    → Step 3.1: return intervals // 直接回傳區間清單\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "All O`one Data Structure",
      "source_file": "Leetcode/leetcode432.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input\n[\"AllOne\", \"inc\", \"inc\", \"getMaxKey\", \"getMinKey\", \"inc\", \"getMaxKey\", \"getMinKey\"]\n[[], [\"hello\"], [\"hello\"], [], [], [\"leet\"], [], []]",
          "expected_output": "Output\n[null, null, null, \"hello\", \"hello\", null, \"hello\", \"leet\"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpomx0zuw6.py\", line 103, in <module>\n    main()\n  File \"/tmp/tmpomx0zuw6.py\", line 78, in main\n    ops = json.loads(lines[0])\n          ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 355, in raw_decode\n    raise JSONDecodeError(\"Expecting value\", s, err.value) from None\njson.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass Node:\n    __slots__ = ('keys', 'prev', 'next', 'count')\n    def __init__(self, count=0):\n        self.keys = set()\n        self.prev = None\n        self.next = None\n        self.count = count\n\nclass AllOne:\n    def __init__(self):\n        self.head = Node()\n        self.tail = Node()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.key_to_node = {}\n\n    def _insert_after(self, prev_node, count):\n        node = Node(count)\n        node.prev = prev_node\n        node.next = prev_node.next\n        prev_node.next.prev = node\n        prev_node.next = node\n        return node\n\n    def _remove(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def inc(self, key):\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            next_node = node.next\n            if next_node == self.tail or next_node.count > node.count + 1:\n                next_node = self._insert_after(node, node.count + 1)\n            next_node.keys.add(key)\n            self.key_to_node[key] = next_node\n            node.keys.remove(key)\n            if not node.keys:\n                self._remove(node)\n        else:\n            first_node = self.head.next\n            if first_node == self.tail or first_node.count > 1:\n                first_node = self._insert_after(self.head, 1)\n            first_node.keys.add(key)\n            self.key_to_node[key] = first_node\n\n    def dec(self, key):\n        node = self.key_to_node[key]\n        node.keys.remove(key)\n        if node.count == 1:\n            del self.key_to_node[key]\n        else:\n            prev_node = node.prev\n            if prev_node == self.head or prev_node.count < node.count - 1:\n                prev_node = self._insert_after(prev_node, node.count - 1)\n            prev_node.keys.add(key)\n            self.key_to_node[key] = prev_node\n        if not node.keys:\n            self._remove(node)\n\n    def getMaxKey(self):\n        if self.tail.prev == self.head:\n            return \"\"\n        return next(iter(self.tail.prev.keys))\n\n    def getMinKey(self):\n        if self.head.next == self.tail:\n            return \"\"\n        return next(iter(self.head.next.keys))\n\ndef main():\n    lines = [line.strip() for line in sys.stdin if line.strip()]\n    if len(lines) < 2:\n        return\n    ops = json.loads(lines[0])\n    args = json.loads(lines[1])\n\n    results = []\n    all_one = None\n\n    for op, arg in zip(ops, args):\n        if op == \"AllOne\":\n            all_one = AllOne()\n            results.append(None)\n        elif op == \"inc\":\n            all_one.inc(arg[0])\n            results.append(None)\n        elif op == \"dec\":\n            all_one.dec(arg[0])\n            results.append(None)\n        elif op == \"getMaxKey\":\n            results.append(all_one.getMaxKey())\n        elif op == \"getMinKey\":\n            results.append(all_one.getMinKey())\n\n    print(\"Output\")\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code (pseudo) line by line with comments. It's design of AllOne structure. The algorithm: use doubly linked list of buckets for counts, each bucket holds set of keys. Map key -> bucket node. Each bucket node has count and a set of keys. Inc: if key not exist, create count 1 bucket. If exists, move key to next bucket. If next bucket count != current+1, create new bucket. Remove from old bucket, delete node if empty. Dec: similar reverse. GetMaxKey: return any key from tail bucket's set; GetMinKey: from head.\n\nWe need to produce virtual code lines with arrows. Use Start, End, Decision, etc. Provide brief explanation after each line.\n\nLet's output the structure: Start, initialize data structures, inc method, dec method, getMaxKey, getMinKey. Each line within methods.\n\nWe need to use \"→\" arrow and \"Decision:\" etc. Provide explanation.\n\nWe must not produce actual code; just pseudo.\n\nLet's craft.\n\nMake lines like:\n\nStart // 程式開始\n\n→ Step 1: Initialize head bucket (count 0) // dummy head sentinel\n\n→ Step 2: Initialize tail bucket (count 0) // dummy tail sentinel\n\n→ Step 3: Link head ↔ tail // establish empty list\n\n→ Step 4: Create hashmap keyToBucket // map key to its bucket node\n\nNow define inc:\n\n→ Step 5: inc(key) // begin increment operation\n\n→ Decision: If key not in keyToBucket? // check existence\n\n→   Yes → Step 6: If count 1 bucket exists? // check bucket count 1\n\n→       Yes → Step 7: Add key to that bucket's key set // reuse\n\n→       No → Step 8: Create new bucket with count 1 after head // insert\n\n→       → Step 9: Add key to new bucket's key set\n\n→       → Step 10: keyToBucket[key] = new bucket // map\n\n→   No → Step 11: oldBucket = keyToBucket[key] // get current bucket\n\n→   → Step 12: nextBucket = oldBucket.next // bucket after current\n\n→   → Decision: If nextBucket.count != oldBucket.count + 1? // need new bucket\n\n→       Yes → Step 13: Create new bucket with count oldBucket.count+1 after oldBucket // insert\n\n→       → Step 14: nextBucket = new bucket\n\n→   → Step 15: Move key from oldBucket to nextBucket's key set // add\n\n→   → Step 16: Remove key from oldBucket's key set // delete\n\n→   → Decision: If oldBucket.key set empty? // maybe remove\n\n→       Yes → Step 17: Remove oldBucket from list // unlink\n\n→       → Step 18: Delete oldBucket // clean\n\n→   → Step 19: keyToBucket[key] = nextBucket // update mapping\n\nReturn.\n\nSimilarly for dec:\n\n→ Step 20: dec(key) // begin decrement\n\n→ Step 21: oldBucket = keyToBucket[key] // get bucket\n\n→ Step 22: prevBucket = oldBucket.prev // bucket before current\n\n→ Decision: If oldBucket.count == 1? // will become 0\n\n→   Yes → Step 23: Remove key from oldBucket's key set // delete\n\n→   → Step 24: Delete key from keyToBucket // remove mapping\n\n→   → Decision: If oldBucket.key set empty? // maybe remove bucket\n\n→       Yes → Step 25: Remove oldBucket from list\n\n→       → Step 26: Delete oldBucket\n\n→   No → Step 27: Decision: If prevBucket.count != oldBucket.count - 1? // need new bucket\n\n→       Yes → Step 28: Create new bucket with count oldBucket.count-1 before oldBucket // insert\n\n→       → Step 29: prevBucket = new bucket\n\n→   → Step 30: Move key from oldBucket to prevBucket's key set // add\n\n→   → Step 31: Remove key from oldBucket's key set // delete\n\n→   → Decision: If oldBucket.key set empty? // remove bucket\n\n→       Yes → Step 32: Remove oldBucket from list\n\n→       → Step 33: Delete oldBucket\n\n→   → Step 34: keyToBucket[key] = prevBucket // update mapping\n\nReturn.\n\nGetMaxKey:\n\n→ Step 35: getMaxKey() // begin\n\n→ Decision: If tail.prev == head? // empty list\n\n→   Yes → Step 36: Return \"\" // no elements\n\n→   No → Step 37: maxBucket = tail.prev // bucket with max count\n\n→   → Step 38: Return any key from maxBucket.key set // e.g., first\n\nSimilarly getMinKey:\n\n→ Step 39: getMinKey()\n\n→ Decision: If head.next == tail? // empty\n\n→   Yes → Step 40: Return \"\"\n\n→   No → Step 41: minBucket = head.next\n\n→   → Step 42: Return any key from minBucket.key set\n\nEnd // 程式結束\n\nBut we need to format each line with arrow and explanation. Use \"→\" and maybe indentation for Decision branches. Provide explanation after \"//\".\n\nLet's produce final answer with these lines. Ensure each line ends with comment explaining. Use Chinese. Let's format accordingly.\n\nUse \"→ Step X:\" for each step.\n\nWe'll use \"Decision:\" lines with Yes/No branches. For each branch, use indentation with tabs maybe but keep consistent.\n\nLet's craft final.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化頭節點 head(count=0) // dummy head，用於連結所有 count bucket\n→ Step 2: 初始化尾節點 tail(count=0) // dummy tail，作為鏈表終點\n→ Step 3: head ↔ tail // 將 head 與 tail 連接，形成空鏈表\n→ Step 4: 建立哈希表 keyToBucket // 存儲每個 key 所對應的 bucket 節點\n// ---------------------------\n// inc(key) 入口\n// ---------------------------\n→ Step 5: inc(key) // 開始 key 的遞增操作\n→ Decision: key 是否在 keyToBucket 裡? // 判斷 key 是否已存在\n    Yes → Step 6: 取得 count 1 的 bucket（bucket1） // 該 bucket 可能已存在\n    → Decision: bucket1 是否存在? // 若不存在則需要新建\n        Yes → Step 7: 將 key 加入 bucket1 的 key 集合 // 重複使用現有 bucket\n        No  → Step 8: 在 head 之後插入新 bucket1(count=1) // 建立新的 bucket\n        → Step 9: 將 key 加入 bucket1 的 key 集合\n    → Step 10: keyToBucket[key] = bucket1 // 更新映射\n    No  → Step 11: oldBucket = keyToBucket[key] // 取得 key 原來所在的 bucket\n    → Step 12: nextBucket = oldBucket.next // 取下一個 bucket\n    → Decision: nextBucket.count 是否等於 oldBucket.count + 1? // 判斷是否需要新建 bucket\n        Yes → Step 13: nextBucket = oldBucket.next // 已經是正確的 count\n        No  → Step 14: 在 oldBucket 之後插入新 bucket(count=oldBucket.count+1) // 新建 bucket\n        → Step 15: nextBucket = 新建的 bucket\n    → Step 16: 將 key 從 oldBucket.key 集合中移除 // 從舊 bucket 移除\n    → Step 17: 將 key 加入 nextBucket.key 集合 // 加入新 bucket\n    → Decision: oldBucket.key 集合是否為空? // 判斷是否要刪除空 bucket\n        Yes → Step 18: 移除 oldBucket 從鏈表 // 解鏈\n        → Step 19: 釋放 oldBucket // 釋放記憶體\n    → Step 20: keyToBucket[key] = nextBucket // 更新 key 的 bucket 映射\n// ---------------------------\n// dec(key) 入口\n// ---------------------------\n→ Step 21: dec(key) // 開始 key 的遞減操作\n→ Step 22: oldBucket = keyToBucket[key] // 取得 key 原來所在的 bucket\n→ Step 23: prevBucket = oldBucket.prev // 取前一個 bucket\n→ Decision: oldBucket.count 是否等於 1? // 若為 1，key 會被移除\n    Yes → Step 24: 從 oldBucket.key 集合移除 key // 移除 key\n    → Step 25: 從 keyToBucket 刪除 key // 完全移除映射\n    → Decision: oldBucket.key 集合是否為空? // 若空，刪除 bucket\n        Yes → Step 26: 移除 oldBucket 從鏈表\n        → Step 27: 釋放 oldBucket\n    No  → Step 28: Decision: prevBucket.count 是否等於 oldBucket.count - 1? // 判斷是否需要新建 bucket\n        Yes → Step 29: prevBucket = oldBucket.prev // 已經是正確的 count\n        No  → Step 30: 在 oldBucket 之前插入新 bucket(count=oldBucket.count-1) // 新建 bucket\n        → Step 31: prevBucket = 新建的 bucket\n    → Step 32: 將 key 從 oldBucket.key 集合移除 // 移除舊 bucket\n    → Step 33: 將 key 加入 prevBucket.key 集合 // 加入新 bucket\n    → Decision: oldBucket.key 集合是否為空? // 判斷是否刪除空 bucket\n        Yes → Step 34: 移除 oldBucket 從鏈表\n        → Step 35: 釋放 oldBucket\n    → Step 36: keyToBucket[key] = prevBucket // 更新 key 的 bucket 映射\n// ---------------------------\n// getMaxKey() 入口\n// ---------------------------\n→ Step 37: getMaxKey() // 開始取得最大 count 的 key\n→ Decision: tail.prev 是否等於 head? // 判斷是否為空\n    Yes → Step 38: 回傳 \"\" // 沒有任何 key\n    No  → Step 39: maxBucket = tail.prev // 最大 count 的 bucket\n    → Step 40: 回傳 maxBucket.key 集合中的任意一個 key // 任意返回一個 key\n// ---------------------------\n// getMinKey() 入口\n// ---------------------------\n→ Step 41: getMinKey() // 開始取得最小 count 的 key\n→ Decision: head.next 是否等於 tail? // 判斷是否為空\n    Yes → Step 42: 回傳 \"\" // 沒有任何 key\n    No  → Step 43: minBucket = head.next // 最小 count 的 bucket\n    → Step 44: 回傳 minBucket.key 集合中的任意一個 key // 任意返回一個 key\nEnd // 程式結束執行"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      \"[['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]\""
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        Group strings that are anagrams of each other.\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            # Use sorted string as the grouping key\n            key = ''.join(sorted(s))\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\ndef main():\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the list part (after '[')\n    try:\n        idx = data.index('[')\n        list_str = data[idx:]\n    except ValueError:\n        # If no '[' found, assume the whole input is the list\n        list_str = data\n\n    # Safely evaluate the list\n    try:\n        strs = ast.literal_eval(list_str)\n    except Exception as e:\n        # If evaluation fails, exit silently\n        return\n\n    # Ensure we have a list of strings\n    if not isinstance(strs, list):\n        return\n\n    sol = Solution()\n    result = sol.groupAnagrams(strs)\n\n    # Print the result to stdout\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for grouping anagrams: typical approach: use hashmap keyed by sorted string or char count. Output groups. Provide each line with arrow, explanation. Use Start, End. Let's produce simple pseudo: Start → Step 1: initialize map. → Step 2: loop each word. → Decision: if key not in map, create list. → Step 3: add word to list. End. Then produce result list. Use arrow formatting.\n\nWe must avoid actual code. Provide each line with \"虛擬碼步驟 // 解釋\". Use arrow. Eg:\n\nStart // 程式開始\n\n→ Step 1: Initialize empty hash map `anagramMap` // 建立雜湊表來儲存分組\n\n→ Step 2: For each string `s` in `strs` // 逐一處理輸入字串\n\n    → Decision: Compute sorted key `key` by sorting characters in `s` // 取得字串的排序後鍵值\n\n        → Step 3: If `key` not in `anagramMap` then create new empty list // 若鍵不存在，新增分組\n\n        → Step 4: Append `s` to `anagramMap[key]` // 將字串加入對應分組\n\n→ Step 5: Collect all lists from `anagramMap` into result array // 將分組結果彙總\n\n→ End // 程式結束\n\nWe need to maintain each line separate. Indentation not necessary but we can indent decisions. Use arrow `→`. Use `Decision:` for if. Provide explanation in Chinese. Let's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空雜湊表 `anagramMap` // 用於把相同字母組合的字串放在同一分組  \n→ Step 2: 循環遍歷輸入陣列 `strs`，取得每個字串 `s` // 逐一處理所有字串  \n    → Decision: 以字串 `s` 的字符排序後得到鍵 `key` // 生成可比較的分組鍵  \n        → Step 3: 若 `key` 未存在於 `anagramMap`，則建立一個新的空列表 // 為新分組做準備  \n    → Step 4: 將字串 `s` 加入 `anagramMap[key]` 的列表中 // 把字串放進對應分組  \n→ Step 5: 從 `anagramMap` 取得所有列表並放入結果陣列 `result` // 收集所有分組  \nEnd // 程式執行結束"
    },
    {
      "title": "Kth Largest Element in a Stream",
      "source_file": "Leetcode/leetcode703.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"], [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
          "expected_output": "[null, 4, 5, 5, 8, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjuyisbyj.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpjuyisbyj.py\", line 24, in main\n    ops = ast.literal_eval(ops_str.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"KthLargest\"\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"], [[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]",
          "expected_output": "[null, 7, 7, 7, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppfst6l7f.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmppfst6l7f.py\", line 24, in main\n    ops = ast.literal_eval(ops_str.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"KthLargest\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.min_heap = []\n        for num in nums:\n            self.add(num)\n\n    def add(self, val):\n        heapq.heappush(self.min_heap, val)\n        if len(self.min_heap) > self.k:\n            heapq.heappop(self.min_heap)\n        return self.min_heap[0]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 以第一個逗號分隔操作列表與參數列表\n    ops_str, args_str = data.split(',', 1)\n    ops = ast.literal_eval(ops_str.strip())\n    args = ast.literal_eval(args_str.strip())\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"KthLargest\":\n            k, nums = arg\n            obj = KthLargest(k, nums)\n            results.append(None)          # 建構子沒有返回值\n        elif op == \"add\":\n            res = obj.add(arg[0])\n            results.append(res)\n        else:\n            results.append(None)          # 若有其他操作可自行處理\n\n    # 轉換成 LeetCode 樣式輸出，None 用 null 取代\n    output = '[' + ', '.join('null' if r is None else str(r) for r in results) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode lines. The requirement: Provide a virtual code that implements KthLargest class that maintains kth largest. Usually solution uses min-heap of size k. For each add, push val, if heap size > k pop min. Then return top of heap. On initialization, add all initial nums to heap same way.\n\nSo produce pseudocode with steps: Start, Step: define class, constructor, add method. Each line with arrow and comment.\n\nWe need to produce \"逐行\" output, each line is a step.\n\nThe pseudocode format: \"Start // 程式開始執行\" etc.\n\nWe need to produce code for class, but as pseudocode lines.\n\nSo produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 KthLargest // 定義需要的類別\n→ Step 2: 宣告變數 k, minHeap // 存儲 k 和最小堆\n→ Decision: 需要初始化? // 是否有初始數組\n    Yes → Step 3: 建立空的最小堆 // 初始化堆\n    No  → Step 4: 跳過 // 若無初始數組則不做\n→ Step 5: 初始化方法 KthLargest(k, nums) // 建構子\n    → Step 5.1: 設定 k 為傳入參數 // 記錄 k\n    → Step 5.2: 建立空最小堆 // 建立堆\n    → Step 5.3: 對 nums 中每個數值 v\n        → Step 5.3.1: add(v) // 用 add 方法加入每個數值\n→ Step 6: 方法 add(val)\n    → Step 6.1: 將 val 插入 minHeap // 加入堆\n    → Step 6.2: 如果 minHeap 大小 > k\n        → Step 6.2.1: 移除最小值 // 以維持大小\n    → Step 6.3: 返回 minHeap 根 // 返回 k-th largest\nEnd // 程式結束\n\nBut need to use the arrow format: → Step 1: ...\n\nAlso need Decision blocks: \"Decision:\" lines with \"Yes →\", \"No →\" etc.\n\nWe should produce clear pseudocode lines.\n\nLet's craft step-by-step.\n\nAlso incorporate \"class KthLargest\" declaration.\n\nWe can have:\n\nStart\n→ Step 1: 定義類別 KthLargest // 建立類別\n→ Step 2: 宣告成員變數 k: Int, minHeap: MinHeap // 儲存 k 及最小堆\n→ Step 3: 定義建構子 KthLargest(k: Int, nums: Int[]) // 初始化\n    → Step 3.1: 設定 this.k = k\n    → Step 3.2: 建立空最小堆 minHeap = new MinHeap()\n    → Step 3.3: 對 nums 中每個 v\n        → Step 3.3.1: add(v) // 用 add 方法加入\n→ Step 4: 定義方法 add(val: Int): Int // 新增分數\n    → Step 4.1: minHeap.insert(val) // 插入\n    → Step 4.2: Decision: 如果 minHeap.size > k? // 檢查大小\n        Yes → Step 4.3: minHeap.extractMin() // 移除最小\n    → Step 4.4: Return minHeap.peek() // 回傳 k-th largest\nEnd\n\nWe also need to use \"Decision:\" format with Yes→ and No→ lines. In the add method, if size > k, we pop. So decision: \"是否>k\" with Yes pop. If No nothing.\n\nBut need to maintain structure: Decision: ...? // comment\n\nYes → step\n\nNo → step\n\nAlso we need to maintain arrow indentation.\n\nAlso we should include that minHeap is a priority queue with min at top.\n\nAlso we need to mention \"If nums is empty\" but optional.\n\nWe need to use Chinese explanation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義類別 KthLargest // 建立 KthLargest 類別\n→ Step 2: 宣告成員變數 k: Int, minHeap: MinHeap // k 代表第 k 大，minHeap 用來維持前 k 個最大值\n→ Step 3: 定義建構子 KthLargest(k: Int, nums: Int[]) // 初始化時給定 k 與初始分數陣列\n    → Step 3.1: 設定 this.k = k // 記錄 k 的值\n    → Step 3.2: 建立空的最小堆 minHeap = new MinHeap() // 初始化最小堆\n    → Step 3.3: 對 nums 中的每個 v 執行\n        → Step 3.3.1: add(v) // 利用 add 方法把初始分數加入堆中\n→ Step 4: 定義方法 add(val: Int): Int // 新增一筆分數並返回第 k 大值\n    → Step 4.1: minHeap.insert(val) // 把 val 插入最小堆\n    → Step 4.2: Decision: minHeap.size > k? // 檢查堆是否多於 k 個元素\n        Yes → Step 4.3: minHeap.extractMin() // 若多於 k，移除最小（即第 k+1 大的值）\n        No  → // 什麼都不做，堆長度已符合要求\n    → Step 4.4: Return minHeap.peek() // 堆頂即為第 k 大值，回傳給使用者\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Complex Number Multiplication",
      "source_file": "Leetcode/leetcode537.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "\"1+-1i\", \"1+-1i\"",
          "expected_output": "\"0+-2i\"",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4t42feq1.py\", line 48, in <module>\n    main()\n  File \"/tmp/tmp4t42feq1.py\", line 44, in main\n    result = multiply_complex(num1, num2)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4t42feq1.py\", line 20, in multiply_complex\n    a_real, a_imag = parse_complex(a)\n                     ^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp4t42feq1.py\", line 12, in parse_complex\n    real_part = int(s[:split_pos])\n                ^^^^^^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: '1+'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef parse_complex(s: str):\n    \"\"\"\n    把形如 \"a+bi\" 或 \"a-bi\" 的字串解析成 (a, b) 的整數元組。\n    \"\"\"\n    # 去掉尾部的 'i'\n    s = s.rstrip('i')\n    # 找到最後一次出現的 '+' 或 '-'（但不是字串最前面用來表示實部的符號）\n    split_pos = max(s.rfind('+', 1), s.rfind('-', 1))\n    real_part = int(s[:split_pos])\n    imag_part = int(s[split_pos:])\n    return real_part, imag_part\n\ndef multiply_complex(a: str, b: str) -> str:\n    \"\"\"\n    計算兩個複數字串的乘積，回傳形如 \"x+yi\" 的字串。\n    \"\"\"\n    a_real, a_imag = parse_complex(a)\n    b_real, b_imag = parse_complex(b)\n\n    real_part = a_real * b_real - a_imag * b_imag\n    imag_part = a_real * b_imag + a_imag * b_real\n\n    sign = '+' if imag_part >= 0 else '-'\n    return f\"{real_part}{sign}{abs(imag_part)}i\"\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析兩個複數字串，輸出乘積。\n    \"\"\"\n    data = sys.stdin.read()\n    # 先嘗試正則表達式抓取所有形如 整數+/- 整數i 的字串\n    complex_strs = re.findall(r'-?\\d+[+-]\\d+i', data)\n    if len(complex_strs) >= 2:\n        num1, num2 = complex_strs[0], complex_strs[1]\n    else:\n        # 如果沒有抓到，嘗試用逗號分隔並去除引號\n        parts = data.split(',')\n        num1 = parts[0].strip().strip('\"')\n        num2 = parts[1].strip().strip('\"')\n\n    result = multiply_complex(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for multiplying two complex numbers represented as strings \"a+bi\" where a,b are integers possibly negative, within [-100,100]. We output the product as string \"real+bi\". Steps: parse input strings, extract real and imag parts (handling signs). Multiply using formula: (a+bi)*(c+di)= (ac - bd) + (ad + bc)i. Construct string. Edge cases: negative sign for imaginary part: input format always uses + sign between real and imaginary? Possibly \"a+bi\" but could be \"a-bi\"? Problem says \"real+imaginaryi\" form; real is integer, imaginary is integer; maybe sign inside imaginary part. But they said string on the form \"real+imaginaryi\" where real and imaginary are integers, so could be negative imaginary part e.g., \"2-3i\"? The pattern still \"real+imaginaryi\" but imaginary part may include '-' sign? The example uses '+'? We'll assume string may contain sign before imaginary part. We'll parse using regex.\n\nSteps: Start, input num1, num2. Step parse: split at 'i' to remove 'i', then split by '+' or '-' except first char. Implementation: find position of last '+' or '-' after first char to separate real and imaginary. Then convert to int.\n\nAfter parse both numbers, compute realProduct = a*c - b*d, imagProduct = a*d + b*c. Build result string: realProduct + (if imagProduct >=0 then '+' else '-') + abs(imagProduct) + 'i'.\n\nReturn result.\n\nWe'll produce virtual code line by line with comments.\n\nLet's produce code with arrow lines. Use \"→\" for step lines, \"Decision:\" for branching. We'll need to parse string into integers: find sign index.\n\nWe'll produce steps: Start, Input, Parse num1 into a and b, Parse num2 into c and d, Compute real, imag, Build result string, Output, End.\n\nInclude decisions for sign handling when building result. Also for parsing: need to decide if imaginary part negative. Let's create Decision for \"是否存在 '-' 作為實部與虛部分隔符\" or easier: find index of last '+' or '-' after first char. We'll step:\n\n→ Step: Find split index = index of last '+' or '-' after position 1. This will decide sign. Then extract realPart = substring(0, splitIndex). ImagPart = substring(splitIndex, len-1) (excluding 'i'). Convert to int.\n\nWe'll need decision: if char at splitIndex is '+'? then sign positive else negative. But conversion handles sign.\n\nAlso building string: Decision on imagProduct >= 0.\n\nLet's produce.\n\nAlso include parsing of imaginary sign.\n\nLet's produce lines.\n\nRemember format: each line: virtual code step + space + // explanation.\n\nWe need to use \"Start\" and \"End\". For decisions, use \"Decision:\".\n\nOk.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: num1 ← 讀取第一個複數字串 // 從輸入取得 num1  \n→ Step 2: num2 ← 讀取第二個複數字串 // 從輸入取得 num2  \n\n→ Decision: 解析 num1 為實部 a 與虛部 b?  \n    Yes → Step 3: splitIdx1 ← 找到 num1 中最後一次出現的 '+' 或 '-'，且位置 > 0 // 找分隔符位置  \n    → Step 4: realPart1 ← substring(num1, 0, splitIdx1) // 取得實部字串  \n    → Step 5: imagPart1 ← substring(num1, splitIdx1, length(num1)-1) // 取得虛部字串（去掉 'i'）  \n    → Step 6: a ← toInt(realPart1) // 轉為整數  \n    → Step 7: b ← toInt(imagPart1) // 轉為整數  \n\n→ Decision: 解析 num2 為實部 c 與虛部 d?  \n    Yes → Step 8: splitIdx2 ← 找到 num2 中最後一次出現的 '+' 或 '-'，且位置 > 0 // 找分隔符位置  \n    → Step 9: realPart2 ← substring(num2, 0, splitIdx2) // 取得實部字串  \n    → Step10: imagPart2 ← substring(num2, splitIdx2, length(num2)-1) // 取得虛部字串（去掉 'i'）  \n    → Step11: c ← toInt(realPart2) // 轉為整數  \n    → Step12: d ← toInt(imagPart2) // 轉為整數  \n\n→ Step13: realProduct ← a * c - b * d // 計算實部  \n→ Step14: imagProduct ← a * d + b * c // 計算虛部  \n\n→ Decision: imagProduct 是否為負數?  \n    Yes → Step15: result ← realProduct + \"-\" + abs(imagProduct) + \"i\" // 虛部為負，使用 '-'  \n    No  → Step16: result ← realProduct + \"+\" + imagProduct + \"i\" // 虛部為正，使用 '+'  \n\n→ Step17: 輸出 result // 顯示乘積的複數字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[7]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[7]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[1,8]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[1, 8]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[1,7,2]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[1, 7, 2]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport random\n\n# 模擬給定的 rand7() API\ndef rand7() -> int:\n    \"\"\"產生 1~7 的均勻隨機整數（假設此函式由題目提供）。\"\"\"\n    return random.randint(1, 7)\n\ndef rand10() -> int:\n    \"\"\"\n    使用 rand7() 產生 1~10 的均勻隨機整數。\n    方案：先用兩次 rand7() 產生 1~49 的整數，\n    只接受 <= 40 的結果，剩餘部分重新嘗試。\n    \"\"\"\n    while True:\n        a = rand7()\n        b = rand7()\n        val = (a - 1) * 7 + b          # 1 ~ 49\n        if val <= 40:                  # 只保留 1 ~ 40\n            return 1 + (val - 1) % 10  # 轉換到 1 ~ 10\n\ndef main() -> None:\n    \"\"\"\n    讀取 stdin，格式類似於 'n = 3'，產生對應數量的 rand10() 結果並輸出。\n    \"\"\"\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 從輸入字串中提取整數 n\n    match = re.search(r'(\\d+)', data)\n    if not match:\n        return\n    n = int(match.group(1))\n\n    # 生成 n 個 rand10() 的結果\n    results = [rand10() for _ in range(n)]\n    print(results)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step for implementing rand10() using rand7() only. Approach: Use rejection sampling by generating numbers 1-49 from two rand7() calls: (a-1)*7 + b => 1-49. If <= 40, map to 1-10 via mod 10: ((val-1) mod 10)+1. Else repeat. That ensures uniform distribution. So steps: Start, Step: call rand7() twice, compute val, check <= 40, if yes, compute result, else repeat loop. End. Use Decision blocks. Provide comments. Ensure each line has virtual code + explanation. Use arrow for flow. Use Start and End. Provide step numbers maybe. Let's output accordingly. Use Chinese comments.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 需要重試? // 判斷是否已經得到合法的隨機數  \n    Yes → Step 1: a ← rand7() // 產生第一個 1~7 的隨機數  \n    Yes → Step 2: b ← rand7() // 產生第二個 1~7 的隨機數  \n    Yes → Step 3: val ← (a-1)*7 + b // 將兩個數轉換為 1~49 的數  \n    Yes → Decision: val ≤ 40? // 只接受前 40 個數以保持均勻性  \n        Yes → Step 4: result ← ((val-1) mod 10) + 1 // 映射到 1~10  \n        Yes → Step 5: Return result // 返回最終隨機數  \n        No  → Step 6: 回到 Step 1 // 若 val>40，重新嘗試  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp8ongctgf.py\", line 55, in <module>\n    main()\n  File \"/tmp/tmp8ongctgf.py\", line 36, in main\n    ops, args_list = json.loads(data)\n                     ^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 47 (char 46)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]                     # copy original array\n        self.tree = [0] * (self.n + 1)          # Fenwick Tree (1-indexed)\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    ops, args_list = json.loads(data)\n    obj = None\n    outputs = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"NumArray\":\n            obj = NumArray(args[0])\n            outputs.append(None)\n        elif op == \"update\":\n            obj.update(args[0], args[1])\n            outputs.append(None)\n        elif op == \"sumRange\":\n            outputs.append(obj.sumRange(args[0], args[1]))\n        else:\n            outputs.append(None)\n\n    print(json.dumps(outputs))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanations. Provide a virtual code for implementing a NumArray class with update and sumRange, using maybe segment tree or fenwick tree. We need to produce steps only, not actual code. Each line: virtual code step + space + // explanation.\n\nUse arrows: Start, →, Decision:, Yes→, No→, End.\n\nWe need to describe the logic of building tree, update, query. Provide high-level pseudocode. Let's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收初始陣列 nums // 建立物件時獲取整數陣列  \n→ Step 2: 建立大小為 4*nums.length 的 segment tree 陣列 seg // 為分段樹預留足夠空間  \n→ Step 3: 呼叫 BuildTree(node=1, start=0, end=nums.length-1) // 建構分段樹  \n\nBuildTree(node, start, end) // 分段樹建立  \n    → Decision: start == end? // 檢查是否為葉節點  \n        Yes → seg[node] = nums[start] // 葉節點儲存對應元素  \n        No  →  \n            → mid = (start + end) / 2 // 計算中點  \n            → BuildTree(node*2, start, mid) // 建構左子樹  \n            → BuildTree(node*2+1, mid+1, end) // 建構右子樹  \n            → seg[node] = seg[node*2] + seg[node*2+1] // 父節點儲存左右子節之和  \nEnd // 建構完成  \n\n→ Step 4: 定義 update(index, val) 方法 // 更新指定索引的值  \n    → 呼叫 UpdateTree(node=1, start=0, end=nums.length-1, idx=index, newVal=val)  \n\nUpdateTree(node, start, end, idx, newVal) // 更新分段樹  \n    → Decision: start == end? // 到達目標葉節點  \n        Yes → seg[node] = newVal // 更新葉節點值  \n        No  →  \n            → mid = (start + end) / 2  \n            → Decision: idx <= mid? // 判斷索引落於左子樹  \n                Yes → UpdateTree(node*2, start, mid, idx, newVal) // 更新左子樹  \n                No  → UpdateTree(node*2+1, mid+1, end, idx, newVal) // 更新右子樹  \n            → seg[node] = seg[node*2] + seg[node*2+1] // 重新計算父節點總和  \nEnd  \n\n→ Step 5: 定義 sumRange(left, right) 方法 // 回傳區間總和  \n    → Return QueryTree(node=1, start=0, end=nums.length-1, l=left, r=right)  \n\nQueryTree(node, start, end, l, r) // 分段樹查詢  \n    → Decision: l <= start && end <= r? // 節點完全在查詢區間內  \n        Yes → Return seg[node] // 直接回傳節點總和  \n        No  →  \n            → mid = (start + end) / 2  \n            → Decision: r <= mid? // 区间完全在左子树  \n                Yes → Return QueryTree(node*2, start, mid, l, r) // 只查左子树  \n                No  →  \n                    → Decision: l > mid? // 区间完全在右子树  \n                        Yes → Return QueryTree(node*2+1, mid+1, end, l, r) // 只查右子树  \n                        No  → // 区间跨越左右子树  \n                            → leftSum = QueryTree(node*2, start, mid, l, mid) // 左侧部分  \n                            → rightSum = QueryTree(node*2+1, mid+1, end, mid+1, r) // 右侧部分  \n                            → Return leftSum + rightSum // 合并两侧结果  \nEnd  \n\nEnd // NumArray 類別實作結束"
    },
    {
      "title": "Super Pow",
      "source_file": "Leetcode/leetcode372.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "a = 2, b = [1,0]",
          "expected_output": "1024",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpn3x6_mfy.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmpn3x6_mfy.py\", line 40, in main\n    a, b = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn3x6_mfy.py\", line 31, in parse_input\n    b = ast.literal_eval(b_str)  # 解析成 list\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "a = 1, b = [4,3,3,8,5,2]",
          "expected_output": "1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp36xpn17c.py\", line 45, in <module>\n    main()\n  File \"/tmp/tmp36xpn17c.py\", line 40, in main\n    a, b = parse_input(data)\n           ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp36xpn17c.py\", line 31, in parse_input\n    b = ast.literal_eval(b_str)  # 解析成 list\n        ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nMOD = 1337\n\ndef super_pow(a: int, b: list[int]) -> int:\n    \"\"\"\n    計算 a^b mod 1337，b 為由十進位數字組成的陣列。\n    透過「重複平方 + 10 次方」的技巧來處理大指數。\n    \"\"\"\n    result = 1\n    for digit in b:\n        # 先把已算好的結果提升到 10 次方\n        result = pow(result, 10, MOD)\n        # 再乘以 a 的 digit 次方\n        result = result * pow(a, digit, MOD) % MOD\n    return result\n\ndef parse_input(data: str):\n    \"\"\"\n    將類似 'a = 2, b = [3,0]' 的輸入字串解析為 a 與 b。\n    \"\"\"\n    parts = [p.strip() for p in data.split(',')]\n    a = None\n    b = None\n    for part in parts:\n        if part.startswith('a'):\n            a = int(part.split('=')[1].strip())\n        elif part.startswith('b'):\n            b_str = part.split('=')[1].strip()\n            b = ast.literal_eval(b_str)  # 解析成 list\n    if a is None or b is None:\n        raise ValueError(\"輸入格式不正確\")\n    return a, b\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    a, b = parse_input(data)\n    result = super_pow(a, b)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to compute a^b mod 1337, where b is large given as array of digits (likely base 10). We need algorithm: modular exponentiation using exponentiation by squaring with exponent given as array. We can use repeated squaring: treat exponent array as big integer; we can process digits: convert to base 10 exponent; use method: while exponent > 0: if exponent is odd: result = result * a % m; a = a * a % m; exponent = exponent / 2. But exponent is big array, we need to implement division by 2 on array. Steps: initialize result=1, base=a % m. While exponent array not zero: check odd? (last digit %2). If odd: result = result * base % m. Divide exponent by 2 (integer division). base = base * base % m. Continue. End. Also need to convert exponent array into array of digits. Provide virtual steps.\n\nWe need to output each step line with \"→\" etc. Format: Start, then steps. Use Decision and Yes/No arrows.\n\nLet's draft:\n\nStart\n→ Initialize result = 1 // 初始結果為 1\n→ Initialize base = a mod 1337 // 把 a 取模得到基底\n→ Decision: exponent是否為 0? // 判斷指數是否為 0\n    No → While迴圈開始 // 只要指數不為 0 就執行\n        → Decision: 指數是否為奇數? // 判斷目前指數是否為奇數\n            Yes → Step: result = (result * base) mod 1337 // 奇數時更新結果\n            No  → // 不做任何事\n        → Step: base = (base * base) mod 1337 // 基底平方取模\n        → Step: exponent = exponent // 2 // 將指數除以 2（整除）\n        → Decision: 指數是否為 0? // 判斷是否還有剩餘\n            Yes → EndWhile\n            No  → 回到 While迴圈開始\n→ Decision: 指數是否為 0? // 指數為 0 時\n    Yes → Step: return result // 回傳結果\nEnd\n\nBut need to format lines with virtual code and explanation after //. Use \"Start\" and \"End\". Use arrow \"→\". Use Decision lines.\n\nAlso we might need a helper function to divide big array by 2. So we can have Step: exponent = BigIntDiv2(exponent) // divide big integer array by 2.\n\nBetter to present as virtual code:\n\nStart // 程式開始執行\n→ Step: result = 1 // 初始化結果\n→ Step: base = a mod 1337 // 取模後得到基底\n→ Decision: 指數是否為 0? // 判斷是否已達到終點\n    Yes → Step: return result // 如果指數為 0，直接回傳\n    No  → // 進入主迴圈\n→ Step: While 指數 ≠ 0  // 只要指數不為 0 就執行\n    → Decision: 指數最後一位數是否為奇數? // 檢查指數是否為奇數\n        Yes → Step: result = (result * base) mod 1337 // 奇數時更新結果\n        No  → // 不更新\n    → Step: base = (base * base) mod 1337 // 基底平方取模\n    → Step: 指數 = BigDiv2(指數) // 將指數除以 2（整除）\n→ Step: return result // 回傳最終結果\nEnd // 程式執行結束\n\nWe must ensure each line has virtual code + // explanation.\n\nWe need to incorporate arrow formatting: \"→ Step:\" etc. For decisions: \"Decision:\" lines, with \"Yes →\" and \"No →\".\n\nLet's create final output accordingly.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: result = 1 // 初始化結果為 1\n→ Step: base = a mod 1337 // 取 a 的模 1337，作為初始基底\n→ Decision: 指數是否為 0? // 判斷指數是否已經為 0\n    Yes → Step: return result // 若指數為 0，直接回傳結果\n    No  → // 進入主計算迴圈\n→ Step: While 指數 ≠ 0  // 只要指數不為 0 就繼續計算\n    → Decision: 指數最後一位數是否為奇數? // 檢查指數是否為奇數\n        Yes → Step: result = (result * base) mod 1337 // 奇數時乘以基底並取模\n        No  → // 若為偶數，結果保持不變\n    → Step: base = (base * base) mod 1337 // 基底平方並取模\n    → Step: 指數 = BigDiv2(指數) // 將大整數指數除以 2（整除）\n→ Step: return result // 計算完成，回傳最終結果\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        將 nums 重新排序，滿足 nums[0] < nums[1] > nums[2] < nums[3] ...\n        算法：線性遍歷，根據索引奇偶性決定交換條件。\n        \"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            # 當 i 為奇數時，需要 nums[i] > nums[i-1]\n            if i % 2 == 1:\n                if nums[i] <= nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            # 當 i 為偶數時，需要 nums[i] < nums[i-1]\n            else:\n                if nums[i] >= nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n        return nums\n\ndef main():\n    \"\"\"\n    從標準輸入讀取「nums = [1,5,1,1,6,4]」或「[1,5,1,1,6,4]」形式的字串，\n    解析為 list，執行 wiggleSort，並將結果輸出到標準輸出。\n    \"\"\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 如果輸入包含 'nums ='，去掉前綴\n    if '=' in raw_input:\n        _, rhs = raw_input.split('=', 1)\n        raw_input = rhs.strip()\n\n    # 用 ast.literal_eval 解析為 Python list\n    try:\n        nums = ast.literal_eval(raw_input)\n    except Exception as e:\n        print(\"Invalid input format\")\n        return\n\n    # 確保輸入是一個 list\n    if not isinstance(nums, list):\n        print(\"Input must be a list of integers\")\n        return\n\n    solution = Solution()\n    result = solution.wiggleSort(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with comments. The algorithm: reorder array into wiggle sequence: nums[0] < nums[1] > nums[2] < nums[3] etc. Standard solution: iterate i from 1 to n-1: if (i%2==1 and nums[i]<=nums[i-1]) swap; else if (i%2==0 and nums[i]>=nums[i-1]) swap. That's simple O(n). Provide virtual steps accordingly.\n\nWe need \"虛擬碼步驟\" and comments. Use arrows and structure. Should start with Start, End. Use Decision, Yes → etc.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 輸入整數陣列 nums // 取得輸入數列  \n→ Step 2: 設定 n = nums.length // 取得陣列長度  \n→ Step 3: 設定 i = 1 // 從第二個元素開始檢查  \n→ Decision: i < n? // 是否還有元素未檢查  \n Yes → Step 4: 計算 isOdd = (i % 2 == 1) // 判斷索引奇偶性  \n  Decision: isOdd? // 索引為奇數  \n   Yes → Decision: nums[i] <= nums[i-1]? // 需要 <，若不滿足則交換  \n     Yes → Step 5: 交換 nums[i] 與 nums[i-1] // 修正順序  \n     No → Step 6: 無需操作 // 已符合條件  \n   No  → Decision: nums[i] >= nums[i-1]? // 索引為偶數，需 >，若不滿足則交換  \n     Yes → Step 7: 交換 nums[i] 與 nums[i-1] // 修正順序  \n     No → Step 8: 無需操作 // 已符合條件  \n  Step 9: i = i + 1 // 移動至下一個位置  \n  → 回到 Decision: i < n?  \n  No → End // 所有位置已檢查，程序結束"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpqb8ebwfu.py\", line 49, in <module>\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpqb8ebwfu.py\", line 40, in parse_input\n    equations = ast.literal_eval(equations_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpec9rxwgq.py\", line 49, in <module>\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpec9rxwgq.py\", line 40, in parse_input\n    equations = ast.literal_eval(equations_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpfpvc7z_n.py\", line 49, in <module>\n    equations, values, queries = parse_input(data)\n                                 ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpfpvc7z_n.py\", line 40, in parse_input\n    equations = ast.literal_eval(equations_match.group(1))\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[\"a\",\"b\"]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1:\n                        return weight * res\n            return -1\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef parse_input(input_str: str):\n    # Extract the three lists using regular expressions\n    equations_match = re.search(r'equations\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    values_match = re.search(r'values\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n    queries_match = re.search(r'queries\\s*=\\s*(\\[[^\\]]*\\])', input_str)\n\n    if not (equations_match and values_match and queries_match):\n        raise ValueError(\"Input format is incorrect.\")\n\n    equations = ast.literal_eval(equations_match.group(1))\n    values = ast.literal_eval(values_match.group(1))\n    queries = ast.literal_eval(queries_match.group(1))\n    return equations, values, queries\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    equations, values, queries = parse_input(data)\n    sol = Solution()\n    results = sol.calcEquation(equations, values, queries)\n    formatted = \"[\" + \",\".join(f\"{x:.5f}\" for x in results) + \"]\"\n    print(formatted)",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for solving division equations using equations and queries. Approach: Build graph with variables as nodes, edges weighted by values. For each query, do DFS or BFS to find ratio or return -1. Use union find with weighting or DFS. Provide virtual code line-by-line with comments. Must not output actual code, only virtual steps. Use arrows.\n\nLet's produce algorithm:\n\nStart\n→ Build adjacency list from equations and values\n→ For each query in queries:\n    → If either variable not in graph: answer -1.0\n    → Else if variables equal: answer 1.0\n    → Else: Do DFS to find ratio\n        → Initialize visited set\n        → Call DFS from numerator to denominator\n        → DFS returns ratio or -1\n        → Store result\n→ Output results\n\nDFS subroutine:\n→ DFS(current, target, accumulated_product, visited):\n    → Mark visited\n    → If current == target: return accumulated_product\n    → For each neighbor, weight:\n        → If neighbor not visited:\n            → result = DFS(neighbor, target, accumulated_product * weight, visited)\n            → If result != -1: return result\n    → Return -1\n\nAlternatively use union find.\n\nWe'll produce steps accordingly. Use arrows: Start, → Step 1, etc.\n\nNeed to adhere to format: Each line: \"虛擬碼步驟 [space] // 解釋\"\n\nInclude indentation for decisions and sub-steps? We can use indentation with tabs? But formatting: use arrow and indent. Use Decision: etc.\n\nWe'll produce:\n\nStart // 程式開始\n\n→ Build adjacency list from equations and values // 建立變量間的有向圖\n\nThen for each query: use a loop:\n\n→ For each query in queries: // 逐一處理每個查詢\n\nThen inside:\n\n    Decision: 若 Cj 或 Dj 不在圖中? // 判斷變量是否已知\n        Yes → Append -1.0 to results // 未知變量返回 -1\n        No  → Decision: 若 Cj == Dj? // 相同變量\n            Yes → Append 1.0 to results // 自己除以自己等於1\n            No  → Step: DFS尋找路徑 // 用DFS找Cj到Dj的路徑\n\nThen subroutine:\n\n→ Function DFS(current, target, product, visited): // 定義DFS\n\n... etc.\n\nBut need to output each line separately.\n\nLet's craft detailed lines.\n\nWe need to use virtual code arrow `→` for steps, `Decision:` for branching. Use `Yes →` and `No →`.\n\nAlso need to handle return of results list.\n\nWe can incorporate steps to append to results.\n\nFinally End.\n\nLet's produce.\n\nMake sure each line ends with // comment.\n\nOk.\n...done thinking.\n\nStart // 程式開始\n\n→ BuildAdjacencyList // 建立變量之間的圖，存放相鄰節點與權重\n\n→ Init Results ← empty list // 用來儲存每個查詢的答案\n\n→ For each query in queries // 逐一處理每個查詢\n    Decision: 如果 query[0] 或 query[1] 不在圖中? // 判斷變量是否已知\n        Yes → Append -1.0 to Results // 未知變量，答案為 -1\n        No  → Decision: 若 query[0] == query[1]? // 相同變量\n            Yes → Append 1.0 to Results // 自己除以自己等於 1\n            No  → Step: Call DFS(query[0], query[1], 1.0, empty set) // 用 DFS 找路徑\n                Decision: DFS 返回值為 -1? // 判斷是否找到路徑\n                    Yes → Append -1.0 to Results // 無路徑，答案為 -1\n                    No  → Append DFS result to Results // 有路徑，存放計算得到的比例\n\n→ Return Results // 輸出所有查詢的答案\n\n// ------------------------------\n// 定義 DFS 子程序\nDecision: 定義 DFS(current, target, product, visited)\n    // 將目前節點標記為已訪問\n    → Mark current as visited\n    Decision: 若 current == target? // 到達目標\n        Yes → Return product // 乘積即為比例\n        No  → For each (neighbor, weight) in adjacency[current] // 遍歷相鄰節點\n                Decision: 若 neighbor 未訪問? // 防止循環\n                    Yes → Step: Call DFS(neighbor, target, product * weight, visited) // 深度優先探索\n                        Decision: DFS 返回值 != -1? // 若找到路徑\n                            Yes → Return DFS result // 返回比例\n                            No  → Continue 循環\n                // 若所有相鄰節點都無法到達目標，則回傳 -1\n    → Return -1 // 無法找到路徑\n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        },
        {
          "example_index": 2,
          "input": "numCourses = 1, prerequisites = []",
          "expected_output": "[0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpjqnlxd63.py\", line 51, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpjqnlxd63.py\", line 41, in parse_input\n    raise ValueError(\"輸入格式錯誤\")\nValueError: 輸入格式錯誤"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立圖（鄰接表）與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 取入度為 0 的節點進入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # Kahn 演算法：逐步取出節點，更新鄰居入度\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若所有節點都已排好順序，返回；否則有循環，返回空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input(input_str: str):\n    \"\"\"\n    從類似 'numCourses = 2, prerequisites = [[1,0]]' 的字串中提取\n    numCourses 與 prerequisites，並回傳兩個值。\n    \"\"\"\n    num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', input_str)\n    pre_match = re.search(r'prerequisites\\s*=\\s*(\\[\\[.*\\]\\])', input_str)\n\n    if not num_match or not pre_match:\n        raise ValueError(\"輸入格式錯誤\")\n\n    numCourses = int(num_match.group(1))\n    prerequisites = ast.literal_eval(pre_match.group(1))\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    # 解析輸入\n    numCourses, prerequisites = parse_input(raw_input)\n\n    # 求解\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n\n    # 輸出結果\n    print(order)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for problem: course schedule II, find ordering of courses. Use topological sort (Kahn's algorithm). Steps: create adjacency list, indegree array, queue for zero indegree, process, build order. If count equals numCourses, return order else empty. Provide step-by-step virtual code with explanations. Use arrows and decision structures. Ensure each line with // explanation. Use Start, End. Use Step: etc. Use 1-index? But courses 0..n-1. Provide generic. Need to include loops etc. We'll produce lines like:\n\nStart // program start\n→ Step 1: Initialize adjacency list adj of size numCourses // each course list of courses depending on it\n→ Step 2: Initialize indegree array indeg of size numCourses with 0 // count prerequisites\n→ Step 3: For each pair [a,b] in prerequisites:\n    → Step 3.1: Append a to adj[b] // b prerequisite for a\n    → Step 3.2: indeg[a] += 1 // increment indegree of a\n→ Step 4: Initialize queue Q // courses ready to take\n→ Step 5: For i from 0 to numCourses-1:\n    → Decision: if indeg[i] == 0?\n        Yes → Q.enqueue(i) // add courses with no prerequisites\n        No  → ...\n→ Step 6: Initialize empty list order // result\n→ Step 7: While Q not empty:\n    → Step 7.1: course = Q.dequeue()\n    → Step 7.2: order.append(course)\n    → Step 7.3: For each neighbor in adj[course]:\n        → Step 7.3.1: indeg[neighbor] -= 1\n        → Step 7.3.2: if indeg[neighbor] == 0?\n            Yes → Q.enqueue(neighbor)\n→ Step 8: Decision: if len(order) == numCourses?\n    Yes → Return order // all courses scheduled\n    No  → Return empty array // cycle detected\nEnd // end\n\nAlso need maybe Step 9: etc. Ensure formatting. Provide arrows with indent. Use indentation maybe with spaces? The example used spaces and indentation. We'll mimic.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化鄰接表 adj[0..numCourses-1] 為空清單 // 每門課代表圖的節點  \n→ Step 2: 初始化入度陣列 indeg[0..numCourses-1] 為 0 // 記錄每門課的前置課程數量  \n→ Step 3: 對於 prerequisites 中的每對 [a, b]：  \n  → Step 3.1: 把 a 加入 adj[b] // b 必先修，a 後續課程  \n  → Step 3.2: indeg[a] += 1 // a 的入度加一  \n→ Step 4: 初始化佇列 Q 為空 // 用來存放入度為 0 的課程  \n→ Step 5: 從 0 到 numCourses-1 逐一檢查：  \n  → Decision: if indeg[i] == 0?  \n   Yes → Q.enqueue(i) // 無前置課程，立即可修  \n   No  →  // 需要前置課程，保持不動  \n→ Step 6: 初始化空列表 order // 存放最終修課順序  \n→ Step 7: 當 Q 不為空時重複：  \n  → Step 7.1: course = Q.dequeue() // 取出一門可修課程  \n  → Step 7.2: order.append(course) // 加入順序  \n  → Step 7.3: 對於 adj[course] 中的每個 neighbour：  \n    → Step 7.3.1: indeg[neighbour] -= 1 // 減少 neighbour 的入度  \n    → Decision: if indeg[neighbour] == 0?  \n     Yes → Q.enqueue(neighbour) // 入度為 0，現在可以修  \n     No  →  // 還有未滿足的前置課程  \n→ Step 8: Decision: if len(order) == numCourses? // 是否已安排完所有課程  \n  Yes → Return order // 有效的修課順序  \n  No  → Return [] // 循環存在，無法完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "source_file": "Leetcode/leetcode4.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2.00000'\nGot (Norm):      '3.00000'\n--- (Raw) ---\nRaw Expected: '2.00000'\nRaw Got:      '3.00000'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef findMedianSortedArrays(nums1, nums2):\n    # 使 nums1 為較短陣列，方便二分搜尋\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    low, high = 0, m\n    while True:\n        i = (low + high) // 2\n        j = (m + n + 1) // 2 - i\n        Aleft  = float('-inf') if i == 0 else nums1[i-1]\n        Aright = float('inf')  if i == m else nums1[i]\n        Bleft  = float('-inf') if j == 0 else nums2[j-1]\n        Bright = float('inf')  if j == n else nums2[j]\n        if Aleft <= Bright and Bleft <= Aright:\n            if (m + n) % 2:\n                return min(Aright, Bright)\n            return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n        elif Aleft > Bright:\n            high = i - 1\n        else:\n            low = i + 1\n\ndef parse_input(text):\n    \"\"\"從輸入字串中解析兩個整數陣列。\"\"\"\n    # 找到所有 [... ] 之間的內容\n    brackets = re.findall(r'\\[([^\\]]*)\\]', text)\n    nums = []\n    for br in brackets:\n        if br.strip() == '':\n            nums.append([])\n        else:\n            nums.append([int(x.strip()) for x in br.split(',') if x.strip() != ''])\n    # 如果只抓到一個陣列，則第二個為空\n    if len(nums) == 1:\n        nums.append([])\n    return nums[0], nums[1]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    nums1, nums2 = parse_input(data)\n    median = findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")",
      "virtual_code": "Thinking...\nWe need to produce pseudocode line by line, with explanation. The algorithm: find median of two sorted arrays, O(log(m+n)). Use binary search on smaller array to partition.\n\nWe produce steps: Start, decide smaller array, define left/right pointers, loop while True, compute i, j, get Aleft, Aright, Bleft, Bright. Compare, adjust. After loop, compute median based on total parity. End.\n\nWe must ensure each line is: \"虛擬碼步驟 // 解釋\".\n\nUse arrows and decisions: \"Start\", \"Decision:\". Format must use arrow \"→\" preceding each step, except Start and End. Use indent for nested decisions.\n\nAlso \"Decision: 如果 nums1 小於 nums2?\".\n\nNeed to use Chinese explanation. Let's craft.\n\nLine 1: Start // 程式開始執行\nLine 2: → Decision: 令 A 為較短陣列，B 為較長陣列 // 以較短陣列做二分搜尋\n    Yes → A = nums1 ; B = nums2 ; m = len(nums1) ; n = len(nums2) // A 為 nums1\n    No  → A = nums2 ; B = nums1 ; m = len(nums2) ; n = len(nums1) // A 為 nums2\nLine for setting low, high: → Step: low = 0 ; high = m // 搜尋範圍為 A\nLoop: → Step: while True: // 重複搜尋直到找到正確分割\nInside loop: compute i, j: → Step: i = (low + high) / 2 ; j = (m + n + 1) / 2 - i // i 為 A 的分割位置\nCompute Aleft, Aright, Bleft, Bright with sentinel values: need to handle boundaries. Use steps: Aleft = -∞ if i==0 else A[i-1]; Aright = ∞ if i==m else A[i]; Bleft = -∞ if j==0 else B[j-1]; Bright = ∞ if j==n else B[j];\nThen decisions: if Aleft > Bright → adjust high; if Bleft > Aright → adjust low; else break.\n\nAfter break, compute maxLeft = max(Aleft, Bleft); minRight = min(Aright, Bright);\nIf (m+n) % 2 == 1 → median = maxLeft else median = (maxLeft + minRight)/2\nEnd.\n\nWe need each line separate with arrow.\n\nWe must ensure no actual code, just virtual steps.\n\nUse Chinese commentary.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 令 A 為較短陣列，B 為較長陣列 // 以較短陣列做二分搜尋  \n  Yes → A = nums1 ; B = nums2 ; m = len(nums1) ; n = len(nums2) // A 為 nums1  \n  No  → A = nums2 ; B = nums1 ; m = len(nums2) ; n = len(nums1) // A 為 nums2  \n→ Step: low = 0 ; high = m // 搜尋範圍為 A  \n→ Step: while True: // 重複搜尋直到找到正確分割  \n  → Step: i = (low + high) / 2 ; j = (m + n + 1) / 2 - i // i 為 A 的分割位置  \n  → Step: Aleft = -∞ if i == 0 else A[i-1] // A 左邊最大值  \n  → Step: Aright = ∞ if i == m else A[i] // A 右邊最小值  \n  → Step: Bleft = -∞ if j == 0 else B[j-1] // B 左邊最大值  \n  → Step: Bright = ∞ if j == n else B[j] // B 右邊最小值  \n  → Decision: 如果 Aleft > Bright? // 判斷左半邊是否太大  \n    Yes → Step: high = i - 1 // 右移 high  \n    No → Decision: 如果 Bleft > Aright? // 判斷左半邊是否太小  \n      Yes → Step: low = i + 1 // 右移 low  \n      No → Step: break // 找到正確分割  \n→ Step: maxLeft = max(Aleft, Bleft) // 左邊最大值  \n→ Step: minRight = min(Aright, Bright) // 右邊最小值  \n→ Decision: 如果 (m + n) % 2 == 1? // 判斷總長度是否奇數  \n  Yes → Step: median = maxLeft // 奇數時中位數為左邊最大值  \n  No → Step: median = (maxLeft + minRight) / 2 // 偶數時取兩邊平均  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[-0.23148666466083903,-0.08101266301549195],[-0.8683535261739916,0.3185093897805456],[-0.32656519943813866,0.6257364179472599]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [-0.23148666466083903, -0.08101266301549195], [-0.8683535261739916, 0.3185093897805456], [-0.32656519943813866, 0.6257364179472599]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport math\nimport random\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    methods = ast.literal_eval(data[0])\n    args_list = ast.literal_eval(data[1])\n\n    obj = None\n    results = []\n\n    for method, args in zip(methods, args_list):\n        if method == \"Solution\":\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            func = getattr(obj, method)\n            result = func(*args)\n            results.append(result)\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to generate pseudo-code for this algorithm: generate uniform random point inside circle. The standard method: sample radius r = sqrt(random()) * radius; sample angle theta = random()*2π; x = x_center + r*cos(theta); y = y_center + r*sin(theta). Or sample x and y from square and reject outside circle; but uniform requires area weighting.\n\nThus need to produce step-by-step virtual code: Start, constructors, randPoint method, etc. Use arrow notation. Each line must have virtual code step and explanation after //.\n\nInclude Start, End, Decision: etc. Probably also Decision for validation? But algorithm straightforward.\n\nAlso need to include initialization of random generator.\n\nWill produce something like:\n\nStart // 程式開始執行\n→ Step 1: 讀取 radius, x_center, y_center // 初始化圓的半徑與中心座標\n→ Step 2: 建立 Solution 物件 // 將參數存入物件屬性\n→ End\n\nBut we need to present functions: constructor, randPoint. So produce virtual code lines for constructor and method. Might include separate steps.\n\nWill produce something like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立類別以存放半徑與中心座標\n→ Step 2: 在 Solution 內部定義屬性 radius, x_center, y_center // 用於後續產生隨機點\n→ Step 3: 實作建構子 Solution(radius, x_center, y_center) // 初始化屬性\n→ Step 4: 實作方法 randPoint() // 產生均勻分佈點\n    → Decision: 無需判斷 // 直接執行隨機點生成\n    → Step 5: 產生 u ∈ [0,1) // 隨機數\n    → Step 6: 產生 v ∈ [0,1) // 隨機數\n    → Step 7: 計算 r = sqrt(u) * radius // 取半徑\n    → Step 8: 計算 theta = 2π * v // 取角度\n    → Step 9: 計算 x = x_center + r * cos(theta) // 計算 x 座標\n    → Step 10: 計算 y = y_center + r * sin(theta) // 計算 y 座標\n    → Step 11: 回傳 [x, y] // 回傳隨機點\n→ End // 程式結束\n\nBut need to adhere to format: each line should start with \"虛擬碼步驟\" maybe like \"→ Step 1: ...\". But we need to use arrow notation: \"→\" for steps. Also \"Decision:\" for decisions. We don't have actual decision except maybe none. But we can still structure.\n\nLet's craft final answer: use Chinese explanation.\n\nMake sure each line ends with // 解釋/說明. Provide all lines. Ensure no actual code, just pseudo-steps.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立類別以存放圓參數  \n→ Step 2: 在 Solution 內部宣告屬性 radius, x_center, y_center // 用於存儲半徑與中心座標  \n→ Step 3: 實作建構子 Solution(radius, x_center, y_center)  \n    → Step 4: 將傳入的 radius、x_center、y_center 賦值給相對應屬性 // 初始化物件  \n→ Step 4: 實作方法 randPoint() // 產生均勻分佈於圓內的隨機點  \n    → Step 5: 產生 u ∈ [0,1) // 隨機數，用於計算半徑  \n    → Step 6: 產生 v ∈ [0,1) // 隨機數，用於計算角度  \n    → Step 7: 計算 r = sqrt(u) * radius // 調整半徑以保證均勻分佈  \n    → Step 8: 計算 theta = 2π * v // 隨機角度  \n    → Step 9: 計算 x = x_center + r * cos(theta) // 轉換為座標系內的 x  \n    → Step 10: 計算 y = y_center + r * sin(theta) // 轉換為座標系內的 y  \n    → Step 11: 回傳 [x, y] // 回傳隨機點  \n→ End // 程式結束執行"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [3,2,2,3], val = 3",
          "expected_output": "2, nums = [2,2,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2,nums=[2,2,_,_]'\nGot (Norm):      '2,nums=[2,2]'\n--- (Raw) ---\nRaw Expected: '2, nums = [2,2,_,_]'\nRaw Got:      '2, nums = [2, 2]'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0, 1, 3, 0, 4]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除所有等於 val 的元素，並返回不等於 val 的元素個數 k。\n        這個實作使用雙指標，快慢指標的原理：慢指標指向下一個可以寫入的位置，\n        快指標遍歷整個陣列，遇到非 val 的元素就將其寫入慢指標位置，然後慢指標往後移動。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums 與 val。\n    支援兩種格式：\n        1. 以文字描述的形式： 'nums = [1,2,3], val = 2'\n        2. 兩行獨立輸入： 第一行是列表，第二行是整數\n    \"\"\"\n    # 先嘗試文字描述格式\n    nums_match = re.search(r'nums\\s*=\\s*(\\[[^\\]]*\\])', data)\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    if nums_match and val_match:\n        nums = eval(nums_match.group(1))\n        val = int(val_match.group(1))\n        return nums, val\n\n    # 若無文字描述，則假設兩行輸入\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if len(lines) >= 2:\n        nums = eval(lines[0])\n        val = int(lines[1])\n        return nums, val\n\n    raise ValueError(\"無法解析輸入資料\")\n\ndef main():\n    raw_input = sys.stdin.read()\n    nums, val = parse_input(raw_input)\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 將結果輸出到標準輸出\n    # 這裡僅印出 k 以及前 k 個元素\n    print(f\"{k}, nums = {nums[:k]}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line. Use Start, End, Decision, arrows. For each step explain. Provide algorithm: two pointers: slow (i) index of next position to write non-val, fast (j) iterate through array. If nums[j]!=val, set nums[i]=nums[j], i++. After loop, return i. Provide virtual code accordingly. Ensure each line has `虛擬碼步驟 // 解釋`. Use Chinese explanations. Use arrows like `→`. Use `Start`, `End`, `Decision:`, `Yes →`, `No →`. Must not output actual code. Provide only the virtual steps. Let's craft.\n\nFirst line: Start // program start. Next line: `→ Initialize i = 0` // i pointer for position to write. Next: `→ For j from 0 to length-1` // iterate. Inside loop: decision: if nums[j] != val? Then assign, increment i. Else skip. After loop: return i. End.\n\nEnsure each line has arrow? In example, each step preceded by arrow `→`. For decision: `Decision:`, and inside use `Yes →`, `No →`. So we should format:\n\nStart // 程式開始執行\n→ Step 1: 初始化 i = 0 // i 是寫入位置指標\n→ Step 2: 循環 j 從 0 到 nums.length-1 // 逐個檢查元素\n    Decision: nums[j] != val? // 判斷元素是否不等於要刪除的值\n        Yes → Step 3: nums[i] = nums[j] // 把非 val 元素寫入前面\n        Yes → Step 4: i = i + 1 // 移動寫入指標\n        No → // 跳過，直接進入下一個 j\nEnd // 程式結束\n\nBut we need to show `→` before each step. For nested steps, indent? Use spaces. Use `Decision:` then lines indented with four spaces. Also, after the loop we need to return i. So add Step 5: return i.\n\nWe need to reflect algorithm fully. Let's craft final output.\n\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 初始化 i = 0 // i 為寫入非 val 元素的位置指標\n→ Step 2: 循環 j 從 0 到 nums.length-1 // 逐個檢查每個元素\n    Decision: nums[j] != val? // 判斷當前元素是否不是要移除的值\n        Yes → Step 3: nums[i] = nums[j] // 把非 val 元素寫入前面\n        Yes → Step 4: i = i + 1 // 移動寫入指標\n        No  → // 若是 val，直接跳過\n→ Step 5: 返回 i // i 為非 val 元素的個數 k\nEnd // 程式執行結束"
    },
    {
      "title": "Ones and Zeroes",
      "source_file": "Leetcode/leetcode474.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpitby5crp.py\", line 27, in <module>\n    exec(raw_input, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "strs = [\"10\",\"0\",\"1\"], m = 1, n = 1",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyzkwg2k2.py\", line 27, in <module>\n    exec(raw_input, {}, local_vars)\n  File \"<string>\", line 1\n    strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\n    ^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findMaxForm(self, strs, m, n):\n        # dp[i][j] 表示使用 i 個 0 和 j 個 1 能形成的最大字串數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for s in strs:\n            zeros = s.count('0')\n            ones = s.count('1')\n            # 逆序遍歷，避免重複使用同一個字串\n            for i in range(m, zeros - 1, -1):\n                for j in range(n, ones - 1, -1):\n                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n        return dp[m][n]\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    # 解析輸入：期望形式為\n    # strs = [...], m = ..., n = ...\n    # 使用 exec 取得變數，因為輸入本身已是合法的 Python 表達式\n    local_vars = {}\n    exec(raw_input, {}, local_vars)\n\n    strs = local_vars.get('strs', [])\n    m = int(local_vars.get('m', 0))\n    n = int(local_vars.get('n', 0))\n\n    solution = Solution()\n    result = solution.findMaxForm(strs, m, n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given array of binary strings strs and integers m, n. Return largest subset size such that total number of 0s <= m, total number of 1s <= n. Classic DP: 2D DP: dp[i][j] = max number of strings using at most i zeros and j ones. iterate over each string, count zeros, ones, update dp from high to low. Output dp[m][n].\n\nWe must produce step-by-step pseudocode with explanations, each line in format: \"虛擬碼步驟 // 解釋\". Use arrows and Decision. The pseudocode should be clear.\n\nWe need to include Start, End. Use Decision: for loops? We can treat loops as steps. Use arrows: \"→\" to go deeper. For loops: \"Step: For each string s in strs\" etc. Use nested arrow.\n\nAlso need to handle counting zeros and ones: Step: countZeros, countOnes. Use decision maybe? But just step. Use dp array initialization: dp array size (m+1)x(n+1) zero.\n\nPseudo lines:\n\nStart // 程式開始\n\n→ Step 1: 初始化 dp 為 (m+1)×(n+1) 的 0 // dp 表示在給定 0,1 限制下可選字串的最大數量\n\n→ Step 2: 對於每個 binary string s in strs // 逐一處理每個字串\n\n    → Step 3: 計算 zeros, ones 在 s 中 // 為後續 dp 更新做準備\n\n    → Step 4: 從 i=m 到 zeros 下降\n\n        → Step 5: 從 j=n 到 ones 下降\n\n            → Step 6: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 更新 dp\n\n→ Step 7: 回傳 dp[m][n] // 最終答案\n\nEnd // 程式結束\n\nBut we need to produce with arrow lines. Use Decision? Maybe not needed. But we can include \"Decision: 如果 zeros <= i && ones <= j?\" but we already loop from m downwards ensures that.\n\nAlso we might show Decision for each string maybe? but not necessary.\n\nLet's produce step-by-step.\n\nWe need each line \"虛擬碼步驟 // 解釋\".\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 定義二維 dp 陣列大小為 (m+1)×(n+1)，初始值 0 // dp[i][j] 代表最多使用 i 個 0 和 j 個 1 時可選的字串最大數量\n\n→ Step 2: 對 strs 中每個字串 s 進行\n\n    → Step 3: 計算 s 中 0 的數量 zeros 以及 1 的數量 ones // 為更新 dp 做準備\n\n    → Step 4: 從 i = m 降至 zeros\n\n        → Step 5: 從 j = n 降至 ones\n\n            → Step 6: 更新 dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 如果把 s 加入子集，看看能否得到更大的子集\n\n→ Step 7: 回傳 dp[m][n] // 結果即為最大子集大小\n\nEnd // 程式結束\n\nAlso we may mention Decision: if zeros <= i && ones <= j? but loops guarantee. But could show Decision to illustrate.\n\nLet's include Decision: Step 5: Decision: if i-zeros >=0 && j-ones >=0? Actually we loop from m downwards so it's always satisfied.\n\nBut we can show Decision in nested structure for clarity:\n\n→ Step 4: Decision: i從m到zeros\n\n    Yes → Step 5: Decision: j從n到ones\n\n        Yes → Step 6: dp[i][j] = ...\n\nBut that's weird. Let's keep simple.\n\nWe can also show Start and End lines. Provide arrow lines with appropriate indentation. Each line must have \"虛擬碼步驟\" then space then \"// 解釋\".\n\nMake sure each line's arrow uses \"→\" at start. Use indent for nested lines. Use no actual code, only pseudocode. Provide line numbers? Not necessary.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 定義二維 dp 陣列，大小為 (m+1)×(n+1)，並將所有元素初始化為 0 // dp[i][j] 代表在最多使用 i 個 0 和 j 個 1 時可選的字串最大數量\n\n→ Step 2: 對 strs 中的每一個二進位字串 s 執行以下步驟 // 逐一處理每個字串\n\n    → Step 3: 計算 s 中 0 的個數 zeros 與 1 的個數 ones // 為之後的 dp 更新做準備\n\n    → Step 4: 從 i = m 降至 zeros\n\n        → Step 5: 從 j = n 降至 ones\n\n            → Step 6: dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1) // 若將 s 加入子集，更新能取得的最大字串數量\n\n→ Step 7: 回傳 dp[m][n] // dp[m][n] 即為滿足 0、1 數量限制下最大的子集大小\n\nEnd // 程式結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[3,2,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [3, 2, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport ast\n\nclass Solution:\n    \"\"\"實作 Fisher‑Yates 隨機洗牌。\"\"\"\n\n    def __init__(self, nums):\n        # 儲存原始陣列的副本，避免被外部修改\n        self.original = list(nums)\n\n    def reset(self):\n        \"\"\"回傳原始陣列。\"\"\"\n        return list(self.original)\n\n    def shuffle(self):\n        \"\"\"返回一個等機率的隨機排列。\"\"\"\n        arr = list(self.original)\n        n = len(arr)\n        # Fisher‑Yates 洗牌，從最後一個元素往前交換\n        for i in range(n - 1, 0, -1):\n            j = random.randint(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析輸入：兩個頂層列表\n    # 例如：[\"Solution\",\"shuffle\"], [[[1,2,3]],[]]\n    # 先將整段加上外層方括號，使其成為合法 JSON\n    parsed = json.loads(f'[{data}]')\n    operations, arguments = parsed\n\n    results = []\n    obj = None\n\n    for idx, op in enumerate(operations):\n        if op == \"Solution\":\n            # 取得初始陣列並建立物件\n            obj = Solution(arguments[idx][0])\n            results.append(None)  # LeetCode 樣式的 null\n        elif op == \"reset\":\n            results.append(obj.reset())\n        elif op == \"shuffle\":\n            results.append(obj.shuffle())\n        else:\n            # 如有其他方法，可自行擴充\n            results.append(None)\n\n    # 輸出 JSON 格式，None 會被轉成 null\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. We need to design algorithm for shuffle with equal probability. Use Fisher-Yates shuffle. The class has constructor storing original array copy. reset returns copy of original. shuffle creates copy and shuffles.\n\nWe must produce lines with virtual code steps. Use \"Start\", \"End\". Steps maybe labelled. Use decision structure? Not necessary. Just linear steps. But we can include decision for random selection.\n\nLet's write:\n\nStart // start\n\n→ Step 1: Define class Solution // class definition\n\n→ Step 2: Declare variable originalArray // store original\n\n→ Step 3: Constructor Solution(nums) // initialize\n\n→ Step 4: originalArray ← copy of nums // copy array\n\n→ Step 5: reset() // method definition\n\n→ Step 6: Return copy of originalArray // reset returns original\n\n→ Step 7: shuffle() // method definition\n\n→ Step 8: array ← copy of originalArray // copy to shuffle\n\n→ Step 9: n ← length of array // get size\n\n→ Step 10: For i from n-1 down to 1 // Fisher-Yates loop\n\n→ Step 11: j ← random integer between 0 and i inclusive // random index\n\n→ Step 12: Swap array[i] and array[j] // swap\n\n→ Step 13: End for\n\n→ Step 14: Return array // shuffled result\n\nEnd // end program\n\nBut need to output \"虛擬碼步驟\" + space + comment.\n\nUse arrows? Format: \"→ Step 1: ...\" etc. Use \"Start\" at first. \"End\" at last.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類別 Solution // 建立解題類別  \n→ Step 2: 宣告變數 originalArray // 儲存原始陣列  \n→ Step 3: 構造函式 Solution(nums) // 初始化時接受輸入陣列  \n→ Step 4: originalArray ← nums 的複製品 // 先複製避免被修改  \n→ Step 5: 方法 reset() // 重置功能  \n→ Step 6: Return originalArray 的複製品 // 回傳原始順序  \n→ Step 7: 方法 shuffle() // 隨機打亂功能  \n→ Step 8: array ← originalArray 的複製品 // 用於打亂的暫存陣列  \n→ Step 9: n ← array 的長度 // 取得陣列長度  \n→ Step 10: 從 i = n-1 迴圈到 1 (降序) // Fisher-Yates 迴圈  \n    → Step 11: j ← 隨機整數 [0, i] // 隨機選取索引  \n    → Step 12: 交換 array[i] 與 array[j] // 進行交換  \n→ Step 13: End for // 迴圈結束  \n→ Step 14: Return array // 回傳已打亂的陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def subsets(self, nums):\n        \"\"\"Return all subsets of the unique integer list `nums`.\"\"\"\n        res = []\n\n        def backtrack(start, path):\n            # Add a copy of the current subset to the results\n            res.append(path[:])\n\n            # Iterate over the remaining elements to build larger subsets\n            for i in range(start, len(nums)):\n                path.append(nums[i])          # Include nums[i]\n                backtrack(i + 1, path)        # Recurse with next start index\n                path.pop()                    # Backtrack: remove nums[i]\n\n        backtrack(0, [])\n        return res\n\nif __name__ == \"__main__\":\n    # Read the whole input from stdin\n    data = sys.stdin.read().strip()\n\n    # Extract the list literal from the input, e.g. from \"nums = [1,2,3]\"\n    match = re.search(r'\\[.*\\]', data, re.S)\n    if match:\n        nums_str = match.group(0)\n        # Safely evaluate the list string\n        try:\n            nums = eval(nums_str, {\"__builtins__\": None}, {})\n        except Exception:\n            nums = []\n    else:\n        nums = []\n\n    # Compute all subsets\n    solution = Solution()\n    result = solution.subsets(nums)\n\n    # Print the result in Python list format\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating all subsets of a unique integer array, no duplicates. Use backtracking or iterative. The requirement: no actual code, just virtual code with arrows and explanations. Output each line: virtual code step + // explanation.\n\nFollow format:\n\nStart // 程式開始執行\n→ Step 1: ...\n… etc.\n\nWe need to cover entire algorithm.\n\nPseudo:\n\nStart\n→ Initialize result list\n→ Sort nums (not necessary unique but sorted for deterministic)\n→ Define recursive backtrack(start, path)\n   → Add current path to result\n   → For i from start to nums.length-1\n        → Append nums[i] to path\n        → backtrack(i+1, path)\n        → Remove last from path\n→ Call backtrack(0, empty list)\n→ Return result\nEnd\n\nAlso maybe use iterative method: iterate over nums, for each element, add it to existing subsets. But backtracking is fine.\n\nWe need to write each step as separate line.\n\nLet's produce each step:\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums，並初始化空集合 result // 儲存所有子集\n→ Step 2: 定義遞迴函式 backtrack(startIndex, currentSubset) // 建立子集的遞迴流程\n    → Decision: 是否將 currentSubset 加入 result? // 確保每個子集都被紀錄\n        Yes → Step 3: result.add(copy_of(currentSubset)) // 把當前子集加入結果\n        No → // 這裡不會發生，因為始終加入\n    → Decision: startIndex 是否小於 nums.length? // 判斷是否還有元素可選\n        Yes →\n            → Step 4: for i in range(startIndex, nums.length) // 逐一考慮剩餘元素\n                → Step 5: currentSubset.append(nums[i]) // 把 nums[i] 加入子集\n                → Step 6: backtrack(i + 1, currentSubset) // 以下一個索引遞迴\n                → Step 7: currentSubset.pop() // 回溯，移除剛加入的元素\n        No → // 迴圈結束\n→ Step 8: 呼叫 backtrack(0, []) // 從索引0開始，空子集作為起點\n→ Step 9: 返回 result // 完成所有子集的生成\nEnd // 程式執行結束\n\nBut we need to use arrow lines: '→ Step x:' etc. For decisions: Use 'Decision: ...' with Yes/No arrow.\n\nWe need to keep each line separate. For nested steps we indent accordingly.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義輸入陣列 nums，並初始化空集合 result // 用來儲存所有子集\n→ Step 2: 定義遞迴函式 backtrack(startIndex, currentSubset) // 建立子集的遞迴流程\n    → Decision: 是否將 currentSubset 加入 result? // 確保每個子集都被紀錄\n        Yes → Step 3: result.add(copy_of(currentSubset)) // 把當前子集加入結果\n        No  → // 這裡不會發生，始終加入\n    → Decision: startIndex 是否小於 nums.length? // 判斷是否還有元素可選\n        Yes →\n            → Step 4: for i in range(startIndex, nums.length) // 逐一考慮剩餘元素\n                → Step 5: currentSubset.append(nums[i]) // 把 nums[i] 加入子集\n                → Step 6: backtrack(i + 1, currentSubset) // 以下一個索引遞迴\n                → Step 7: currentSubset.pop() // 回溯，移除剛加入的元素\n        No → // 迴圈結束，回到上一層遞迴\n→ Step 8: 呼叫 backtrack(0, []) // 從索引 0 開始，空子集作為起點\n→ Step 9: 返回 result // 完成所有子集的生成\nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Immutable",
      "source_file": "Leetcode/leetcode303.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"], [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]",
          "expected_output": "[null, 1, -1, -3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp986sanob.py\", line 47, in <module>\n    main()\n  File \"/tmp/tmp986sanob.py\", line 29, in main\n    ops = ast.literal_eval(ops_str.strip())\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [\"NumArray\"\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\n\nclass NumArray:\n    def __init__(self, nums):\n        # 建立前綴和陣列，方便 O(1) 查詢\n        self.prefix = [0]\n        for num in nums:\n            self.prefix.append(self.prefix[-1] + num)\n\n    def sumRange(self, left, right):\n        # sumRange(left, right) = prefix[right+1] - prefix[left]\n        return self.prefix[right + 1] - self.prefix[left]\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 依照可能的輸入格式取得 ops 與 args\n    if '\\n' in data:\n        ops_str, args_str = data.split('\\n', 1)\n    else:\n        # 兩個 list 之間用逗號分隔\n        ops_str, args_str = data.split(',', 1)\n\n    # 解析為 Python 物件\n    ops = ast.literal_eval(ops_str.strip())\n    args_list = ast.literal_eval(args_str.strip())\n\n    # 執行指令並收集結果\n    res = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == 'NumArray':\n            obj = NumArray(args[0])\n            res.append(None)          # 代表 null\n        elif op == 'sumRange':\n            result = obj.sumRange(args[0], args[1])\n            res.append(result)\n\n    # 輸出結果，使用 JSON 以得到 null 的正確表示\n    print(json.dumps(res))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing NumArray class with sumRange queries. We must output each line with the step and explanation. The virtual code must use arrows, Start, End, Decision: etc. No actual code. The steps include constructing prefix sum array for quick queries. Steps: Start, Step: initialize with nums, compute prefix sum, define sumRange method, compute sum using prefix array, End. Also need to illustrate queries? Might include usage example.\n\nMake sure each line ends with `// 解釋/說明`.\n\nAlso need to adhere to the structure: `Start // 程式開始執行` then `→ Step 1: ...` etc. Also use Decision if needed. Here maybe no decision needed.\n\nWe can include decision for error if left > right? But spec says left <= right.\n\nJust show virtual steps. Let's produce something like:\n\nStart\n→ Step 1: 接收陣列 nums 作為建構參數 // 初始化物件\n→ Step 2: 建立 prefixSum 陣列長度 = len(nums)+1 // 為方便計算\n→ Step 3: prefixSum[0] ← 0 // 前綴和首項設為 0\n→ Decision: nums 是否非空? // 若陣列有元素\n    Yes → Loop i from 0 to len(nums)-1\n        → Step 4: prefixSum[i+1] ← prefixSum[i] + nums[i] // 計算前綴和\n    No → Step 5: 直接跳過 // 空陣列不需要計算\n→ Step 6: 定義方法 sumRange(left, right)\n→ Step 7: 若 left > right → Error handling // 但根據條件不會發生\n→ Step 8: result ← prefixSum[right+1] - prefixSum[left] // 取得區間和\n→ Step 9: Return result // 回傳答案\nEnd\n\nMake sure each line with `→` or `Start` etc.\n\nAlso we can include usage example lines but maybe not necessary.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 接收陣列 nums 作為建構參數 // 初始化物件  \n→ Step 2: 建立 prefixSum 陣列長度為 nums 的長度 + 1 // 為方便計算前綴和  \n→ Step 3: prefixSum[0] ← 0 // 前綴和起始值設為 0  \n→ Decision: nums 是否非空? // 若陣列有元素  \n Yes → Loop i 從 0 到 nums.length - 1  \n  → Step 4: prefixSum[i + 1] ← prefixSum[i] + nums[i] // 計算每個位置的前綴和  \n No  → Step 5: 跳過前綴和計算 // 空陣列不需要前綴和  \n→ Step 6: 定義方法 sumRange(left, right) // 回傳區間總和  \n→ Step 7: 若 left > right → 抛出錯誤 // 依照題目左 <= 右的條件一般不會發生  \n→ Step 8: result ← prefixSum[right + 1] - prefixSum[left] // 用前綴和快速算出區間和  \n→ Step 9: Return result // 回傳計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2, 0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34, -10, -14, -10, 10]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    # 讀取所有輸入資料\n    data = sys.stdin.read()\n    # 從輸入中尋找被雙引號包住的表達式\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        expression = match.group(1)\n    else:\n        # 若沒有引號，直接去除空白再當作表達式\n        expression = data.strip()\n\n    solver = Solution()\n    results = solver.diffWaysToCompute(expression)\n    print(results)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for this problem: compute all possible results from evaluating expression by all possible parentheses placements. This is typical LeetCode 241. Use divide and conquer / recursion + memoization. So produce virtual code step by step.\n\nWe need to output each line: virtual code + \" // \" explanation. Use arrow characters and structure. We need to produce code step by step. Each line should be simple. Include Start, End, Decision, etc. Provide line numbers? Not necessary.\n\nWe need to include steps: parse expression, recursion function compute(start, end). Memoization map. If substring is number return list of int. For each operator index, compute left and right recursively, combine.\n\nAlso main function: call compute(0, len-1), return result list.\n\nMake sure to include variable initialization, loops, decisions.\n\nLet's produce.\n\nAlso consider that expression can have digits > 9? Usually digits only 0-9 single-digit. But we can parse numbers.\n\nOk produce.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 compute(l, r) // 計算子序列 l~r 的所有結果\n→ Step 2: 若 memo.containsKey(l, r) → return memo[l, r] // 快速回傳已計算結果\n→ Decision: 若 substring[l..r] 為純數字? // 檢查是否為單一數字\n    Yes → Step 3: 轉換 substring 為整數，放入 list，memo[l, r] = list，返回 list\n    No → Step 4: 初始化 resultList // 儲存所有可能的結果\n→ Step 5: 對 i 在 l 到 r:\n→ Decision: 若 s[i] 為運算符? // 判斷符號位置\n    Yes →\n        → Step 6: leftList = compute(l, i-1) // 計算左子表達式\n        → Step 7: rightList = compute(i+1, r) // 計算右子表達式\n        → Step 8: 對 a 在 leftList:\n        → Step 9: 對 b 在 rightList:\n        → Step 10: 結果 = applyOperator(a, b, s[i]) // 執行對應運算\n        → Step 11: resultList.add(結果) // 收集結果\n        No → Continue // 非運算符忽略\n→ Step 12: memo[l, r] = resultList // 記錄結果\n→ Step 13: 返回 resultList // 結束子計算\n→ Step 14: 定義 applyOperator(a, b, op) // 執行加減乘\n→ Decision: op 為 '+'\n    Yes → 返回 a + b\n    No →\n        Decision: op 為 '-'\n            Yes → 返回 a - b\n            No → 返回 a * b\n→ Step 15: 主程式: 調用 compute(0, len-1) // 計算整個表達式\n→ Step 16: 返回結果 // 輸出所有可能的值\nEnd // 程式執行結束\n\nBut we need arrow lines. We can indent decisions. Each step lines preceded by arrow. Use \"→\". For Decision: \"Decision: ...\" with indent Yes/No arrows.\n\nMake sure to include \"Start\", \"End\".\n\nAlso might need to include variable for memo: \"memo = new Map\" etc. Let's include Step 0 before compute definition.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 0: 建立 memo map (鍵為「l,r」字串，值為整數清單) // 用於快取子表達式結果  \n→ Step 1: 定義函式 compute(l, r) // 計算子序列 l~r 的所有結果  \n→ Step 2: 若 memo.containsKey(l, r) → return memo[l, r] // 快速回傳已計算結果  \n→ Decision: 若 s.substring(l, r+1) 為純數字? // 判斷是否為單一數字  \n Yes → Step 3: 轉換 substring 為整數，放入 list，memo[l, r] = list，返回 list // 單值情況  \n No  → Step 4: 初始化 resultList // 儲存所有可能的結果  \n→ Step 5: 對 i 在 l 到 r:  \n → Decision: 若 s[i] 為運算符? // 判斷符號位置  \n  Yes →  \n   → Step 6: leftList = compute(l, i-1) // 計算左子表達式  \n   → Step 7: rightList = compute(i+1, r) // 計算右子表達式  \n   → Step 8: 對 a 在 leftList:  \n    → Step 9: 對 b 在 rightList:  \n     → Step 10: 結果 = applyOperator(a, b, s[i]) // 執行對應運算  \n     → Step 11: resultList.add(結果) // 收集結果  \n   No → Continue // 非運算符忽略  \n→ Step 12: memo[l, r] = resultList // 記錄子表達式結果  \n→ Step 13: 返回 resultList // 結束子計算  \n→ Step 14: 定義 applyOperator(a, b, op) // 執行加減乘  \n → Decision: op 為 '+'?  \n  Yes → 返回 a + b  \n  No →  \n   → Decision: op 為 '-'?  \n    Yes → 返回 a - b  \n    No → 返回 a * b  \n→ Step 15: 主程式: 調用 compute(0, len-1) // 計算整個表達式  \n→ Step 16: 返回結果 // 輸出所有可能的值  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,0,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 0, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef parse_input(s: str):\n    \"\"\"\n    解析「方法列表」與「參數列表」。\n    兩個列表之間以最外層逗號分隔，逗號所在層級 depth == 0。\n    \"\"\"\n    depth = 0\n    split_index = None\n    for i, ch in enumerate(s):\n        if ch == '[':\n            depth += 1\n        elif ch == ']':\n            depth -= 1\n        elif ch == ',' and depth == 0:\n            split_index = i\n            break\n    if split_index is None:\n        raise ValueError(\"Invalid input format\")\n    methods_part = s[:split_index].strip()\n    args_part = s[split_index+1:].strip()\n    methods = json.loads(methods_part)\n    args = json.loads(args_part)\n    return methods, args\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    methods, args = parse_input(data)\n\n    results = []\n    obj = None\n    for i, method in enumerate(methods):\n        if i == 0:          # 第一個方法總是建構子\n            obj = Solution(*args[i])  # args[i] 是一個列表，例如 [[1,3]]\n            results.append(None)\n        else:\n            # 之後的都是 pickIndex()\n            if method == \"pickIndex\":\n                results.append(obj.pickIndex())\n            else:\n                raise NotImplementedError(f\"Unsupported method: {method}\")\n\n    # 輸出結果，將 None 轉為 JSON null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for implementing pickIndex with weighted random selection. Use prefix sums array. Steps: preprocess compute cumulative sum; pick random number r in [1, total]; binary search. Provide explanation per line. Use Start, End, Decision.\n\nWe should output each line with virtual code and comment. Use arrows.\n\nLet's write:\n\nStart // 初始化\n\n→ Step 1: input array w // 接收权重数组\n\n→ Step 2: 初始化空数组 prefix // 用于存前缀和\n\n→ Step 3: total = 0 // 用于累计总和\n\n→ Step 4: For each weight in w: total += weight; append total to prefix // 计算前缀和\n\n→ End of preprocessing // 预处理完成\n\n→ Function pickIndex() // 定义函数\n\n→ Decision: Generate random integer r in [1, total] // 随机数生成\n\n    Yes → Step 5: 使用二分搜索在 prefix 中找到最小索引 idx 使得 prefix[idx] >= r // 查找对应权重区间\n\n    Yes → Step 6: Return idx // 返回选中的索引\n\n→ End // 结束函数\n\nBut need use arrow format: Start //, then → Step 1, etc. Also Decision lines need Yes/No arrows.\n\nWe need each line with \"虛擬碼步驟\" and comment.\n\nLet's write lines:\n\nStart // 程式開始\n\n→ Step 1: Receive array w // 取得權重陣列\n\n→ Step 2: Initialize empty list prefix // 用來存前綴和\n\n→ Step 3: total ← 0 // 初始化總和\n\n→ Step 4: For i from 0 to length(w)-1 do // 遍歷權重\n\n→     total ← total + w[i] // 累加權重\n\n→     Append total to prefix // 存前綴和\n\n→ End For // 完成前綴和構造\n\n→ End Preprocess // 预处理结束\n\n→ Function pickIndex() // 定義 pickIndex\n\n→ Decision: Generate random integer r in [1, total] // 產生隨機數\n\n    Yes → Step 5: idx ← BinarySearch(prefix, r) // 找最小索引\n\n    Yes → Step 6: Return idx // 返回結果\n\n→ End // 程式結束\n\nBut we need decision with Yes arrow. No not needed.\n\nBinarySearch step: BinarySearch(prefix, r) returns index such that prefix[idx] >= r. Explain.\n\nNeed to include details.\n\nLet's format each line:\n\nStart // 程式開始執行\n\n→ Step 1: Input array w // 取得權重陣列\n\n→ Step 2: Initialize list prefix = [] // 用於儲存前綴和\n\n→ Step 3: total ← 0 // 用於累加總重量\n\n→ Step 4: For i = 0 to length(w)-1 do // 遍歷每個權重\n\n→     total ← total + w[i] // 累加到 total\n\n→     Append total to prefix // 將累積值存入前綴和\n\n→ End For // 前綴和構造完成\n\n→ End Preprocess // 预处理结束\n\n→ Function pickIndex() // 定義 pickIndex 函式\n\n→ Decision: Generate random integer r in [1, total] // 產生隨機數\n\n    Yes → Step 5: idx ← BinarySearch(prefix, r) // 二分搜尋最小符合條件的索引\n\n    Yes → Step 6: Return idx // 回傳選擇的索引\n\n→ End // 程式執行結束\n\nNeed to ensure each line with comment. The decision line: \"Decision: Generate random integer r in [1, total]\" has Yes arrow? It's a decision but it's a step to generate random. Usually we just use step. But the spec says use Decision. So maybe:\n\n→ Decision: 隨機數 r 是否已生成? // 檢查是否完成生成\n\n    Yes → Step 5: idx ← BinarySearch(prefix, r) // ...\n\nBut that seems redundant. Maybe treat generation as step.\n\nBetter: Use Decision to decide which index to pick based on r. So:\n\n→ Step 5: r ← RandomInt(1, total) // 產生隨機數\n\n→ Decision: r <= prefix[0]? // decide index 0 or else\n\nBut simpler: use binary search.\n\nBut we need decision arrow lines maybe not necessary. But spec says use Decision for branching. Use binary search algorithm has branching.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: Input array w // 取得權重陣列\n\n→ Step 2: prefix ← [] // 前綴和列表\n\n→ Step 3: total ← 0 // 總和初值\n\n→ Step 4: For i = 0 to length(w)-1 do // 遍歷權重\n\n→     total ← total + w[i] // 加總\n\n→     Append total to prefix // 儲存前綴和\n\n→ End For // 完成前綴和\n\n→ End Preprocess // 预处理完成\n\n→ Function pickIndex() // 定義函式\n\n→ Step 5: r ← RandomInt(1, total) // 產生隨機整數\n\n→ Step 6: left ← 0 ; right ← length(prefix)-1 // 初始化二分搜尋界限\n\n→ Decision: left <= right? // 是否仍有搜尋範圍\n\n    Yes → Step 7: mid ← (left + right) // 2 // 計算中點\n\n    Yes → Decision: r <= prefix[mid]? // r 是否落在左半區\n\n        Yes → Step 8: right ← mid - 1 // 移至左半\n\n        No  → Step 9: left ← mid + 1 // 移至右半\n\n    Yes → (loop back to Decision)\n\n→ Step 10: idx ← left // left 即為最小符合條件的索引\n\n→ Step 11: Return idx // 回傳選中的索引\n\n→ End // 程式結束\n\nBut we need each line with comment. Use arrow lines accordingly. Provide explanation.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input array w // 取得權重陣列  \n→ Step 2: prefix ← [] // 建立空列表以存放前綴和  \n→ Step 3: total ← 0 // 初始化總重量  \n→ Step 4: For i = 0 to length(w)-1 do // 遍歷每個權重  \n→     total ← total + w[i] // 累加至總重量  \n→     Append total to prefix // 將累積值存入前綴和列表  \n→ End For // 前綴和構造完成  \n→ End Preprocess // 预处理結束  \n\n→ Function pickIndex() // 定義 pickIndex 函式  \n→ Step 5: r ← RandomInt(1, total) // 產生 1 到 total 之間的隨機整數  \n→ Step 6: left ← 0 ; right ← length(prefix)-1 // 初始化二分搜尋界限  \n→ Decision: left <= right? // 是否還有搜尋範圍？  \n    Yes → Step 7: mid ← (left + right) // 2 // 計算中點  \n    Yes → Decision: r <= prefix[mid]? // 隨機數落在左半區？  \n        Yes → Step 8: right ← mid - 1 // 移至左半區尋找更小的符合條件索引  \n        No  → Step 9: left ← mid + 1 // 移至右半區尋找更大的索引  \n    Yes → (loop back to Decision)  \n→ Step 10: idx ← left // left 即為最小符合條件的索引  \n→ Step 11: Return idx // 回傳選中的索引  \n→ End // 程式結束執行"
    }
  ]
}