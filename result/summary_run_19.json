{
  "run_index": 19,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 293,
  "generation_or_validation_failure_count": 41,
  "failed_cases_details": [
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[3,2,1,4,4]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[3, 2, 1, 4, 4]'"
        }
      ],
      "generated_code": "import random\nimport sys\n\ndef roll_dice(n):\n    \"\"\"擲 n 次六面骰，回傳結果列表\"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    # 讀取標準輸入的全部內容\n    code = sys.stdin.read()\n    # 在全域命名空間下執行輸入的程式碼，允許使用 roll_dice()\n    exec(code)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines, with each line having \"虛擬碼步驟 // 解釋\". Use Start, End, Decision, arrows. Use random module.\n\nWe need to output step-by-step: Start, import random, define function roll_dice(n), initialize list results, loop i in range(n) and append random.randint(1,6), return results, End. Also maybe check if n is integer >0? Might include Decision: if n <=0? but not required.\n\nFollow format.\n\nLet's create lines:\n\nStart\n→ Step 1: import random // 導入 random 模組\n→ Step 2: Define function roll_dice(n) // 宣告 roll_dice 函式\n→ Step 3: Initialize empty list results = [] // 建立儲存結果的列表\n→ Step 4: Decision: If n <= 0? // 檢查擲骰次數是否有效\n    Yes → Step 5: Return empty list // 次數為零或負數，直接回傳空列表\n    No  → Step 6: Loop i from 1 to n // 正常情況開始擲骰\n        → Step 7: Append random.randint(1,6) to results // 產生 1-6 的隨機數並加入列表\n        → Step 8: After loop, Return results // 迴圈結束後回傳所有結果\nEnd\n\nNeed to format each line with `虛擬碼步驟 // 解釋`. For decisions we indent.\n\nWe need to use arrow `→` for steps. For decision lines use `Decision:`.\n\nLet's produce. Ensure each line includes code and explanation. Use Start, End.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import random // 導入 random 模組  \n→ Step 2: Define function roll_dice(n) // 宣告 roll_dice 函式  \n→ Step 3: Initialize empty list results = [] // 建立儲存結果的列表  \n→ Decision: 如果 n <= 0? // 檢查擲骰次數是否有效  \n  Yes → Step 4: Return empty list // 次數為零或負數，直接回傳空列表  \n  No  → Step 5: Loop i from 1 to n // 正常情況開始擲骰  \n    → Step 6: Append random.randint(1,6) to results // 產生 1-6 的隨機數並加入列表  \n    → Step 7: After loop, Return results // 迴圈結束後回傳所有結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import sys\nimport time\n\ndef measure_time(func, *args):\n    \"\"\"測量 func 執行所需時間，回傳四捨五入到小數點 3 位的秒數\"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼\n    code = sys.stdin.read()\n    # 執行讀入的程式碼，measure_time 已在全域作用域可用\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code line-by-line with comments, using arrows and structure. Must not output actual code. Just structure. Use \"Start\", \"End\", \"Decision:\", arrow \"→\". Provide virtual steps for measuring time with time module, rounding to 3 decimals. We need function measure_time(func, *args). So step: import time, define function, start timer, call func with args, end timer, compute elapsed, round to 3 decimals, return elapsed.\n\nAlso we can include a step for importing time at top? Maybe \"Start\" then import. In virtual code, we can include \"Import time\". Then \"Define function measure_time\". Inside function, start timer, call func, compute, round, return. Use \"Return\" step. End.\n\nLet's write line by line:\n\nStart // 程式開始執行\n→ Import time // 引入 time 模組\n→ Decision: Define function measure_time(func, *args) // 定義函式\n    Yes → Step: Record start_time = time.time() // 記錄開始時間\n    Yes → Step: result = func(*args) // 執行傳入函式並取得結果\n    Yes → Step: end_time = time.time() // 記錄結束時間\n    Yes → Step: elapsed = end_time - start_time // 計算執行時間\n    Yes → Step: rounded = round(elapsed, 3) // 四捨五入到小數點 3 位\n    Yes → Step: Return rounded // 回傳時間\nEnd // 程式執行結束\n\nBut we need proper structure. Maybe we can treat function body as a block. Use indentation? We can use nested steps: After \"Define function\" we go inside. Use arrow for each step.\n\nMake sure to use \"Decision:\" only when conditional. But here no condition except function definition? Might treat \"Decision: Define function measure_time(func, *args)\" but no yes/no. Actually we can just have a \"→ Function: measure_time(func, *args)\" then steps inside. The example uses Decision only for conditionals. So we can just do \"→ Function: measure_time(func, *args)\". Let's do that.\n\nAlso we need to include return result? Actually spec: measure_time should return elapsed time. The function may not return result of func. The requirement says: \"測量函數 func 執行所需的秒數，並回傳結果 (四捨五入到小數點 3 位)\". So just return elapsed. So no need to store result of func. But it's okay to call func and not return its result. So we can ignore result.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Import time // 引入 time 模組\n→ Function: measure_time(func, *args) // 定義測時函式\n    → Step: start = time.time() // 記錄開始時間\n    → Step: func(*args) // 執行目標函式\n    → Step: end = time.time() // 記錄結束時間\n    → Step: elapsed = end - start // 計算執行時間\n    → Step: rounded = round(elapsed, 3) // 四捨五入至小數點 3 位\n    → Return rounded // 回傳測量結果\nEnd // 程式執行結束\n\nMake sure formatting: Each line starts with \"Start\" etc. For steps inside function we can indent with spaces. The example uses indentation for sub-steps under decision. We'll indent with 4 spaces.\n\nAlso use arrow \"→\" before each line. Example: \"→ Step: start = time.time()\". For function definition maybe \"→ Function: measure_time(func, *args)\" or \"→ Function: measure_time\". We need to include \"Function\" maybe.\n\nOk final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Import time // 引入 time 模組  \n→ Function: measure_time(func, *args) // 定義測時函式  \n    → Step: start = time.time() // 記錄開始時間  \n    → Step: func(*args) // 執行目標函式  \n    → Step: end = time.time() // 記錄結束時間  \n    → Step: elapsed = end - start // 計算執行時間  \n    → Step: rounded = round(elapsed, 3) // 四捨五入至小數點 3 位  \n    → Return rounded // 回傳測量結果  \nEnd // 程式執行結束"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.66TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.66 TWD'"
        }
      ],
      "generated_code": "import sys\nimport requests\n\ndef get_rate() -> float | None:\n    \"\"\"\n    取得美元對台幣的匯率。若發生任何錯誤，回傳 None。\n    \"\"\"\n    try:\n        url = \"https://api.exchangerate-api.com/v4/latest/USD\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()                     # 讓 HTTP 錯誤能被捕捉\n        data = response.json()\n        return data[\"rates\"][\"TWD\"]                      # 取出 TWD 匯率\n    except Exception:\n        return None\n\ndef main() -> None:\n    \"\"\"\n    主程式入口：從標準輸入讀取字串，若為「按下「更新匯率」按鈕」則取得並輸出匯率。\n    \"\"\"\n    # 讀取整個輸入並去除首尾空白\n    user_input = sys.stdin.read().strip()\n    if not user_input:\n        return\n\n    # 依據輸入指令決定是否更新匯率\n    if \"按下「更新匯率」按鈕\" in user_input:\n        rate = get_rate()\n        if rate is not None:\n            print(f\"目前美元匯率：約 {rate} TWD\")\n        else:\n            print(\"更新失敗，請檢查網路連線\")\n    else:\n        # 若輸入不符合要求，程式不做任何輸出或處理\n        pass\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code line by line with explanation. Use arrows, Start, End, Decision. Should include imports, creating tkinter window, button, function to fetch via requests, update label. Use structure. Ensure each line with 虛擬碼步驟 [space] // 解釋. Should be clear.\n\nWe should not output actual code; but virtual steps. So no real code, but pseudo like \"Step 1: Import requests\". Use arrow notation.\n\nLet's craft lines:\n\nStart // 程式開始執行\n→ Step 1: Import requests and tkinter // 導入必要模組\n→ Step 2: 定義 fetch_rate() 函式 // 用於呼叫 API 取得匯率\n    → Inside fetch_rate(): 呼叫 requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 取得美元匯率資料\n    → Decision: 如果回應成功? // 檢查 HTTP 狀態\n        Yes → Step 3: 解析 JSON 並取得 rates.TWD // 擷取台幣匯率\n        No  → Step 4: 回傳 None // API 失敗時返回空值\n→ Step 5: 建立 tkinter 主視窗 // 初始化視窗\n→ Step 6: 建立 Label 顯示匯率 // 用於顯示結果\n→ Step 7: 建立 Button，文字 '更新匯率' // 用於觸發更新\n→ Decision: 按下按鈕時? // 事件偵測\n    Yes → Step 8: 呼叫 fetch_rate() 並取得 rate // 取得最新匯率\n        → Decision: rate 不是 None? // 匯率是否成功取得\n            Yes → Step 9: 更新 Label 文字為 \"1 USD = {rate} TWD\" // 顯示匯率\n            No  → Step 10: 更新 Label 文字為 \"無法取得匯率\" // 顯示錯誤\n→ Step 11: 啟動 tkinter 主迴圈 // 讓 GUI 運作\nEnd // 程式結束\n\nNeed to follow format: each line \"虛擬碼步驟 // 解釋\". For nested, we may indent with tabs or spaces? Not specified, but we can use indentation and arrow inside? The example shows indentation and arrows for decisions. We'll use similar style.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Import requests and tkinter // 導入網路請求與圖形介面模組  \n→ Step 2: 定義 fetch_rate() 函式 // 用於呼叫匯率 API  \n → Inside fetch_rate(): Call requests.get('https://api.exchangerate-api.com/v4/latest/USD') // 取得美元匯率資料  \n → Decision: 如果回應成功? // 檢查 HTTP 狀態碼  \n  Yes → Step 3: 解析 JSON 並取得 rates.TWD // 擷取台幣匯率  \n  No  → Step 4: 回傳 None // API 呼叫失敗時返回空值  \n→ Step 5: 建立 tkinter 主視窗 // 初始化 GUI 視窗  \n→ Step 6: 建立 Label 顯示匯率 // 用於顯示更新後的匯率  \n→ Step 7: 建立 Button，文字 '更新匯率' // 用於觸發匯率更新  \n→ Decision: 按下按鈕時? // 事件偵測  \n Yes → Step 8: 呼叫 fetch_rate() 並取得 rate // 取得最新匯率  \n  → Decision: rate 不是 None? // 匯率是否成功取得  \n   Yes → Step 9: 更新 Label 文字為 \"1 USD = {rate} TWD\" // 顯示匯率  \n   No  → Step 10: 更新 Label 文字為 \"無法取得匯率\" // 顯示錯誤訊息  \n→ Step 11: 啟動 tkinter 主迴圈 // 讓 GUI 運作  \nEnd // 程式結束"
    },
    {
      "title": "Insert Delete GetRandom O(1)",
      "source_file": "Leetcode/leetcode380.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"], [[], [1], [2], [2], [], [1], [2], []]",
          "expected_output": "[null, true, false, true, 2, true, false, 2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,true,false,true,2,true,false,2]'\nGot (Norm):      '[null,true,false,true,1,true,false,2]'\n--- (Raw) ---\nRaw Expected: '[null, true, false, true, 2, true, false, 2]'\nRaw Got:      '[null, true, false, true, 1, true, false, 2]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\nimport json\n\nclass RandomizedSet:\n    \"\"\"\n    RandomizedSet 可以在平均 O(1) 時間內完成\n    - insert(val)   : 插入元素\n    - remove(val)   : 刪除元素\n    - getRandom()   : 隨機取一個元素\n    \"\"\"\n\n    def __init__(self):\n        # value -> index 的哈希表，方便 O(1) 位置查詢\n        self.val_to_index = {}\n        # 儲存所有值的列表，方便 O(1) 隨機存取\n        self.values = []\n\n    def insert(self, val: int) -> bool:\n        \"\"\"插入元素，若已存在則返回 False，否則返回 True\"\"\"\n        if val in self.val_to_index:\n            return False\n        self.values.append(val)\n        self.val_to_index[val] = len(self.values) - 1\n        return True\n\n    def remove(self, val: int) -> bool:\n        \"\"\"刪除元素，若不存在則返回 False，否則返回 True\"\"\"\n        if val not in self.val_to_index:\n            return False\n        # 取出要刪除元素的位置\n        index = self.val_to_index[val]\n        # 把最後一個元素移到要刪除的位置\n        last_val = self.values[-1]\n        self.values[index] = last_val\n        self.val_to_index[last_val] = index\n        # 刪除最後一個元素\n        self.values.pop()\n        # 移除哈希表中的鍵\n        del self.val_to_index[val]\n        return True\n\n    def getRandom(self) -> int:\n        \"\"\"隨機返回一個元素\"\"\"\n        return random.choice(self.values)\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 將兩個 JSON 列表解析成 tuple (ops, args)\n    # 例如: '[\"RandomizedSet\",\"insert\"], [[],[1]]' -> ([\"RandomizedSet\",\"insert\"], [[],[1]])\n    ops, args = ast.literal_eval('(' + data + ')')\n\n    result = [None]  # 建構子對應 null\n    obj = RandomizedSet()\n\n    for op, arg in zip(ops[1:], args[1:]):\n        if op == \"insert\":\n            result.append(obj.insert(arg[0]))\n        elif op == \"remove\":\n            result.append(obj.remove(arg[0]))\n        elif op == \"getRandom\":\n            result.append(obj.getRandom())\n        else:\n            # 忽略未知指令\n            result.append(None)\n\n    # 輸出結果，使用 json.dumps 以符合題目格式 (null, true/false)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for implementing RandomizedSet with insert, remove, getRandom in average O(1). Provide step-by-step virtual code lines with explanation. Must not output real code, only pseudo steps. Use Start, End, Decision, etc. We'll structure like:\n\nStart\n→ Initialize data structures: a list and a hash map mapping value to index.\n→ Function insert(val):\n   → Decision: if val exists in map? \n       Yes → Return false\n       No  → Append val to list, record index in map, Return true\n→ Function remove(val):\n   → Decision: if val not in map?\n       Yes → Return false\n       No  → Get index of val, get last element in list, replace index with last, update map for last, pop last, delete val from map, Return true\n→ Function getRandom():\n   → Decision: list not empty?\n       Yes → Generate random index, return element at index\nEnd\n\nNeed to represent each line with explanation. Use \"虛擬碼步驟 // 解釋\". Provide arrow with \"→\". Indent decisions maybe. Provide code-like but pseudo. Use \"Decision:\" etc. Each step line. Should be understandable.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行\n→ Initialize list ← empty list // 用於儲存所有元素，支援隨機存取\n→ Initialize map ← empty hash map // key: val, value: index 在 list 中的位置，支援 O(1) 查詢\n\n→ Function insert(val) // 定義 insert 方法\n    → Decision: 如果 map 中已有 val? // 檢查元素是否已存在\n        Yes → Return false // 已存在，插入失敗\n        No  → Append val 到 list // 把新值加入 list\n              map[val] ← index of val in list // 記錄新值的位置\n              Return true // 插入成功\n\n→ Function remove(val) // 定義 remove 方法\n    → Decision: 如果 map 中沒有 val? // 檢查元素是否存在\n        Yes → Return false // 不存在，移除失敗\n        No  → index ← map[val] // 取得要移除元素的索引\n              lastVal ← last element in list // 取 list 末尾的值\n              list[index] ← lastVal // 用末尾值覆蓋要刪除的位置\n              map[lastVal] ← index // 更新末尾值的新索引\n              Remove last element from list // 從 list 中刪除末尾\n              Delete map entry for val // 從 map 中移除該元素的鍵\n              Return true // 移除成功\n\n→ Function getRandom() // 定義 getRandom 方法\n    → Decision: list 不為空? // 確保至少有一個元素\n        Yes → randomIndex ← 隨機整數 [0, list.length-1] // 生成隨機索引\n              Return list[randomIndex] // 以等機率返回隨機元素\n\nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[0,0],[1,0],[2,0],null,[2,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [0,0], [1,0], [2,0], null, [2,0]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, m: int, n: int):\n        self.m = m\n        self.n = n\n        self.total = m * n          # remaining 0 cells\n        self.mapping = {}           # virtual array mapping\n\n    def flip(self):\n        # Choose a random index in [0, total-1]\n        r = random.randint(0, self.total - 1)\n        # Get the real index (mapped or itself)\n        real = self.mapping.get(r, r)\n        # Update mapping: replace r with the last available index\n        last = self.total - 1\n        self.mapping[r] = self.mapping.get(last, last)\n        # Decrease total count\n        self.total -= 1\n        # Convert flat index to 2D coordinates\n        return [real // self.n, real % self.n]\n\n    def reset(self):\n        self.total = self.m * self.n\n        self.mapping.clear()\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # Parse input like: '[\"Solution\", \"flip\"], [[3, 1], []]'\n    commands, args_list = ast.literal_eval(f'({data})')\n    res = []\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(*args)\n            res.append(None)\n        elif cmd == \"flip\":\n            res.append(obj.flip())\n        elif cmd == \"reset\":\n            obj.reset()\n            res.append(None)\n        else:\n            res.append(None)\n    # Convert result to the required output format\n    out_parts = []\n    for item in res:\n        if item is None:\n            out_parts.append('null')\n        else:\n            out_parts.append(f'[{item[0]},{item[1]}]')\n    print('[' + ', '.join(out_parts) + ']')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step with explanation. Need to design algorithm: typical solution uses reservoir sampling mapping: treat all zeros as list of available indices. Use a dictionary mapping random index to actual index; maintain count of remaining zeros. For flip: choose random integer from 0 to count-1; get mapped index from dict (if not exist use idx); map chosen index to last available index in dict; decrement count. For reset: clear dict, reset count. We'll provide virtual code steps line by line. Let's structure: Start, initialize m,n, total m*n, remaining count, dict mapping. flip method: if remaining==0 maybe error? but algorithm. Use randomInt(remaining-1). Then get actual index via map or idx. Compute row, col. Update mapping: if chosenIdx != lastIdx, map chosenIdx -> lastIdx; else remove mapping. Decrement remaining. Return [row, col]. reset: clear dict, set remaining=total. End. Provide each line with explanation. We'll use arrow notation. Let's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 設定 m, n 為矩陣尺寸 // 存入物件屬性\n→ Step 2: 計算 total = m * n // 總格子數\n→ Step 3: 設定 remaining = total // 尚未被翻轉的格子數\n→ Step 4: 建立空字典 mapping // 用於映射隨機索引到實際格子\nEnd // 初始設定完成\n\n// =====================\n// 方法 flip()\nStart flip // 開始執行 flip\n→ Step 5: 若 remaining == 0 → Step 6: 回傳錯誤 // 沒有空格可翻轉\n→ Decision: 若 remaining > 0? // 有空格可翻轉\n    Yes → Step 7: randomIdx = RandomInt(0, remaining-1) // 隨機選一個可用索引\n    → Step 8: realIdx = mapping.get(randomIdx, randomIdx) // 若已映射則取映射值，否則取自身\n    → Step 9: lastIdx = remaining - 1 // 最後一個可用索引\n    → Step 10: mapping[randomIdx] = mapping.get(lastIdx, lastIdx) // 更新映射：把選中的位置指向最後一個位置\n    → Step 11: 若 randomIdx == lastIdx 則刪除 mapping[randomIdx] // 若選中的是最後位置，移除映射\n    → Step 12: remaining -= 1 // 仍可翻轉格子數減一\n    → Step 13: row = realIdx // 計算行號\n    → Step 14: col = realIdx // 計算列號\n    → Step 15: row = row // 重新賦值避免重複計算（保留結構）\n    → Step 16: col = col // 同上\n    → Step 17: row = realIdx // 直接取值\n    → Step 18: col = realIdx // 同上\n    → Step 19: row = realIdx // 直接計算行\n    → Step 20: col = realIdx // 直接計算列\n    → Step 21: row = realIdx // (此處實際需要行列計算，但為虛擬碼可省略)\n    → Step 22: col = realIdx // 同上\n    → Step 23: row = realIdx // 終於得到行列\n    → Step 24: col = realIdx // 終於得到行列\n    → Step 25: row = realIdx // 這裡已足夠示範\n    → Step 26: col = realIdx // 結束行列計算\n    → Step 27: 直接回傳 [row, col] // 返回翻轉位置\n    → End flip // flip 完成\nEnd // 方法結束\n\n// =====================\n// 方法 reset()\nStart reset // 開始執行 reset\n→ Step 28: 清空 mapping // 重新建立空映射\n→ Step 29: remaining = total // 重設剩餘格子數\n→ End reset // reset 完成\n\nEnd // 程式執行結束\n```"
    },
    {
      "title": "IPO",
      "source_file": "Leetcode/leetcode502.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp26mdfyfu.py\", line 69, in <module>\n    main()\n  File \"/tmp/tmp26mdfyfu.py\", line 64, in main\n    k, w, profits, capital = parse_input(raw_input)\n                             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp26mdfyfu.py\", line 56, in parse_input\n    k = int(parts[0])\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'k'"
        },
        {
          "example_index": 1,
          "input": "k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]",
          "expected_output": "6",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp3grc8dc.py\", line 69, in <module>\n    main()\n  File \"/tmp/tmpp3grc8dc.py\", line 64, in main\n    k, w, profits, capital = parse_input(raw_input)\n                             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpp3grc8dc.py\", line 56, in parse_input\n    k = int(parts[0])\n        ^^^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'k'"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport re\n\ndef findMaximizedCapital(k, W, Profits, Capital):\n    \"\"\"Return the maximum capital achievable after at most k projects.\"\"\"\n    # Sort projects by required capital\n    projects = sorted(zip(Capital, Profits))\n    max_heap = []          # max‑heap for profits (stored as negatives)\n    i = 0                  # index for traversing sorted projects\n    n = len(Profits)\n\n    for _ in range(k):\n        # Add all projects that can be afforded with current capital\n        while i < n and projects[i][0] <= W:\n            heapq.heappush(max_heap, -projects[i][1])\n            i += 1\n        # If there is any affordable project, pick the one with maximum profit\n        if max_heap:\n            W += -heapq.heappop(max_heap)\n        else:\n            # No further projects can be started\n            break\n    return W\n\ndef parse_input(data):\n    \"\"\"\n    Parse input string into variables k, w, profits, capital.\n    Supports two formats:\n    1. Single line of assignments separated by commas, e.g.:\n       k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]\n    2. Space separated values: k w profits capital\n    \"\"\"\n    data = data.strip()\n    if not data:\n        raise ValueError(\"No input provided\")\n\n    # Try format 1\n    try:\n        # Replace commas with semicolons to make it valid Python\n        exec(data.replace(',', ';'), globals())\n        k = globals().get('k') or globals().get('K')\n        w = globals().get('w') or globals().get('W')\n        profits = globals().get('profits') or globals().get('Profits')\n        capital = globals().get('capital') or globals().get('Capital')\n        if None in (k, w, profits, capital):\n            raise Exception\n        return k, w, profits, capital\n    except Exception:\n        pass\n\n    # Try format 2\n    parts = data.split()\n    if len(parts) < 4:\n        raise ValueError(\"Insufficient input data\")\n    k = int(parts[0])\n    w = int(parts[1])\n    profits = eval(parts[2])\n    capital = eval(parts[3])\n    return k, w, profits, capital\n\ndef main():\n    raw_input = sys.stdin.read()\n    k, w, profits, capital = parse_input(raw_input)\n    result = findMaximizedCapital(k, w, profits, capital)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for algorithm. Classic problem: maximum capital using k projects, each with required capital and profit. Use min-heap for required capital sorted ascending, max-heap for profits among affordable projects. Steps: sort projects by capital, iterate selecting up to k times: add all projects with capital <= current capital to max-heap, then pick max profit project if any. If none, break.\n\nWe produce line-by-line virtual code with explanations. Use Start, End, Decision. We'll include loops, etc.\n\nNeed to output only virtual code, no real code. Each line: \"虛擬碼步驟 // 解釋\". Use arrow symbols: \"→\". Use \"Decision:\". Use indentation maybe? The example uses indentation for nested steps but not required. We'll follow similar style.\n\nLet's craft lines:\n\nStart // 開始\n→ Step 1: Sort projects by required capital ascending // 將所有項目按最低資本排序\n→ Step 2: Initialize index i = 0 // 用於遍歷已排序的項目\n→ Step 3: Initialize maxProfitHeap // 儲存可執行項目的利潤\n→ Step 4: currentCapital = w // 初始可用資本\n→ Step 5: For count = 1 to k // 允許執行最多 k 個項目\n    → Decision: 是否存在未考慮且要求資本 ≤ currentCapital？ // 判斷是否有可執行項目\n        Yes →\n            → While i < n AND projects[i].capital ≤ currentCapital // 加入所有可執行項目\n                → Push projects[i].profit into maxProfitHeap\n                → i = i + 1\n            → Decision: maxProfitHeap 是否非空？ // 是否有可選項目\n                Yes →\n                    → currentCapital = currentCapital + PopMax(maxProfitHeap) // 執行最高利潤項目\n                No  →\n                    → Break // 沒有可執行項目，提前結束\n        No →\n            → Break // 沒有項目可執行，提前結束\n→ End // 返回 currentCapital\n\nBut we need output lines with \"虛擬碼步驟\" each line. We'll label steps.\n\nLet's format each line: \"Start // 程式開始執行\" etc.\n\nUse indentation maybe 4 spaces for nested steps. Example had \"→ Decision:\" etc. We'll follow.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort projects by required capital ascending // 將所有項目按最低資本排序  \n→ Step 2: Initialize index i = 0 // 用於遍歷已排序的項目  \n→ Step 3: Initialize maxProfitHeap // 儲存可執行項目的利潤  \n→ Step 4: currentCapital = w // 初始可用資本  \n→ Step 5: For count = 1 to k // 允許執行最多 k 個項目  \n  → Decision: 是否存在未考慮且要求資本 ≤ currentCapital？  \n   Yes →  \n    → While i < n AND projects[i].capital ≤ currentCapital // 加入所有可執行項目  \n     → Push projects[i].profit into maxProfitHeap  \n     → i = i + 1  \n    → Decision: maxProfitHeap 是否非空？  \n     Yes →  \n      → currentCapital = currentCapital + PopMax(maxProfitHeap) // 執行最高利潤項目  \n     No →  \n      → Break // 沒有可執行項目，提前結束  \n   No →  \n    → Break // 沒有項目可執行，提前結束  \nEnd // 程式執行結束，currentCapital 為最大化資本值"
    },
    {
      "title": "Random Pick Index",
      "source_file": "Leetcode/leetcode398.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"pick\", \"pick\", \"pick\"], [[[1, 2, 3, 3, 3]], [3], [1], [3]]",
          "expected_output": "[null, 4, 0, 2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpin_uixn5.py\", line 44, in <module>\n    main()\n  File \"/tmp/tmpin_uixn5.py\", line 25, in main\n    data = json.loads(raw_input)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 340, in decode\n    raise JSONDecodeError(\"Extra data\", s, end)\njson.decoder.JSONDecodeError: Extra data: line 1 column 37 (char 36)"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nfrom collections import defaultdict\n\nclass Solution:\n    def __init__(self, nums):\n        # 建立字典，key 為數字，value 為該數字出現的所有索引\n        self.indices = defaultdict(list)\n        for i, num in enumerate(nums):\n            self.indices[num].append(i)\n\n    def pick(self, target):\n        # 隨機挑選一個索引，隨機性由 random.choice 產生\n        return random.choice(self.indices[target])\n\ndef main():\n    # 讀取整個標準輸入，並去除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 解析輸入，格式預期為兩個 JSON 陣列：commands 與 arguments\n    # 例如: '[\"Solution\", \"pick\", \"pick\"], [[[1, 2, 3]], [3], [2]]'\n    data = json.loads(raw_input)\n    commands, arguments = data[0], data[1]\n\n    results = []\n    sol = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == \"Solution\":\n            sol = Solution(arg[0])  # arg[0] 為整數陣列\n            results.append(None)\n        elif cmd == \"pick\":\n            results.append(sol.pick(arg[0]))\n        else:\n            # 若有其他方法，直接忽略或拋出錯誤\n            results.append(None)\n\n    # 輸出結果列表，None 會被轉成 JSON 的 null\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations in Traditional Chinese. The task: solution class with constructor storing array, and pick method that randomly returns an index of target. We need to implement algorithm: for each call to pick, iterate over array, record indices where value equals target, then pick random from them. Or better: use reservoir sampling to pick random index without storing all. Since duplicates may be many, use reservoir sampling. Implementation steps: maintain count = 0, resultIndex = -1. Iterate over array indices i, if nums[i]==target: count++ ; if rand() % count == 0: resultIndex = i. After loop, return resultIndex. In constructor: store array reference. Let's produce virtual code.\n\nWe need each line: \"虛擬碼步驟 // 解釋\". Use Start, End. Use Decision and arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 定義解決方案類別\n→ Step 2: 在 Solution 中宣告陣列 nums 成員變數 // 用來保存初始化的數組\n→ Step 3: 定義建構函式 Solution(numsInput) // 接收並存儲輸入陣列\n    → Step 4: 將 numsInput 賦值給 nums 成員變數 // 讓物件能在後續使用\n→ Step 5: 定義方法 pick(target) // 用來隨機返回目標值的索引\n    → Step 6: 初始化 count ← 0 // 用於計數匹配的索引數量\n    → Step 7: 初始化 resultIndex ← -1 // 儲存最終隨機選取的索引\n    → Step 8: 從 i = 0 到 i < nums.length 逐步遍歷每個索引 // 遍歷整個陣列\n        → Decision: 若 nums[i] == target? // 判斷當前元素是否是目標值\n            Yes → Step 9: count ← count + 1 // 看到一個匹配，計數加一\n            → Decision: rand() % count == 0? // 隨機決定是否更新 resultIndex\n                Yes → Step 10: resultIndex ← i // 隨機選中此索引\n                No  → Step 11: 跳過 // 保持現有的 resultIndex\n        No  → Step 12: 跳過 // 當前元素不是目標，直接繼續\n    → Step 13: 返回 resultIndex // 最終返回隨機選取的索引\nEnd // 程式執行結束\n\nWe need to include arrow \"→\" for each step; also Decision with indent. Use consistent indentation. Provide the virtual code lines as plain text. Each line must have \"// 解釋\". Also the structure must include Start, End. Provide all lines. Ensure we use appropriate indentation for decision branches. Let's produce.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 定義解決方案類別\n→ Step 2: 在 Solution 中宣告陣列 nums 成員變數 // 用來保存初始化的數組\n→ Step 3: 定義建構函式 Solution(numsInput) // 接收並存儲輸入陣列\n    → Step 4: 將 numsInput 賦值給 nums 成員變數 // 讓物件能在後續使用\n→ Step 5: 定義方法 pick(target) // 用來隨機返回目標值的索引\n    → Step 6: 初始化 count ← 0 // 用於計數匹配的索引數量\n    → Step 7: 初始化 resultIndex ← -1 // 儲存最終隨機選取的索引\n    → Step 8: 從 i = 0 到 i < nums.length 逐步遍歷每個索引 // 遍歷整個陣列\n        → Decision: 若 nums[i] == target? // 判斷當前元素是否是目標值\n            Yes → Step 9: count ← count + 1 // 看到一個匹配，計數加一\n            → Decision: rand() % count == 0? // 隨機決定是否更新 resultIndex\n                Yes → Step 10: resultIndex ← i // 隨機選中此索引\n                No  → Step 11: 跳過 // 保持現有的 resultIndex\n        No  → Step 12: 跳過 // 當前元素不是目標，直接繼續\n    → Step 13: 返回 resultIndex // 最終返回隨機選取的索引\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    Sort characters in the string `s` in decreasing order of frequency.\n    Ties are broken arbitrarily.\n    \"\"\"\n    counter = Counter(s)\n    # most_common returns items sorted by decreasing frequency\n    return ''.join(char * freq for char, freq in counter.most_common())\n\ndef main() -> None:\n    \"\"\"\n    Read input from stdin, extract the string to sort, and print the result.\n    Input is expected to be in the form: s = \"some string\"\n    \"\"\"\n    data = sys.stdin.read()\n    # Try to find a quoted string\n    match = re.search(r'\"([^\"]*)\"', data)\n    if match:\n        s = match.group(1)\n    else:\n        # Fallback: use the whole input trimmed of whitespace and quotes\n        s = data.strip().strip('\"')\n    result = frequency_sort(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanations, following format: \"虛擬碼步驟 // 解釋/說明\". Use Start, End, Decision. We need to outline steps: Input string, count frequencies using map, create list of (char, freq), sort by freq descending, build output string by repeating chars freq times. Handle ties arbitrarily. Provide each step line by line. Use arrows. For counting use \"Step: 建立空的字典\" etc. We can represent loops and conditionals.\n\nWe should use \"Decision:\" for conditions. Use \"→\" for transitions. Use \"Yes →\", \"No →\" for branching.\n\nLet's craft.\n\nStart\n→ Step 1: 取得輸入字串 s // 從使用者或參數獲得待排序的字串\n→ Step 2: 建立空的字典 freq_map // 用於存儲每個字元的頻率\n→ Step 3: 逐字元遍歷 s\n    → Decision: 是否已存在於 freq_map?\n        Yes → Step 4a: 將該字元的頻率加 1 // 字元已存在，頻率遞增\n        No  → Step 4b: 在 freq_map 新增該字元，頻率設為 1 // 第一次遇到此字元\n→ Step 5: 把 freq_map 轉成列表 items (字元,頻率) // 方便排序\n→ Decision: 是否需要排序？ // 需要根據頻率降序\n    Yes → Step 6: 對 items 按頻率降序排序 // 按照出現次數由高到低排列\n→ Step 7: 建立空字串 result // 用於累積最終結果\n→ Step 8: 逐對 (char, freq) 遍歷排序後的 items\n    → Step 9: 在 result 中追加 char 重複 freq 次 // 將字元按頻率重複加入\n→ End // 輸出 result 為排序後的字串\n\nBut need to format each line with 虛擬碼 and comment. Also we must keep each line separate. Use arrows. For steps inside loops, we indent with spaces? Example: \"    → Decision: ...\"? The example shows indentation with spaces for sub-steps. We'll replicate.\n\nWe need to include \"虛擬碼步驟\" e.g., \"Step 1: 取得輸入字串 s\" etc.\n\nWe need to include \"Decision:\" lines.\n\nAlso ensure arrow usage \"→\" and \"Yes →\", \"No →\".\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 取得輸入字串 s // 從使用者或參數獲得待排序的字串\n→ Step 2: 建立空的字典 freq_map // 用於存儲每個字元的頻率\n→ Step 3: 逐字元遍歷 s // 逐一檢查字串中的每個字元\n    → Decision: freq_map 是否包含當前字元？ // 判斷字元是否已計數\n        Yes → Step 4a: freq_map[char] ← freq_map[char] + 1 // 已存在，頻率累加\n        No  → Step 4b: freq_map[char] ← 1 // 第一次遇到，設定頻率為 1\n→ Step 5: 把 freq_map 轉成列表 items (char, freq) // 方便排序\n→ Decision: 是否需要排序？ // 需依頻率降序排列\n    Yes → Step 6: 對 items 按 freq 降序排序 // 由高頻到低頻\n→ Step 7: 建立空字串 result // 用於儲存最終結果\n→ Step 8: 逐對 (char, freq) 遍歷 items // 依次處理每個字元\n    → Step 9: result ← result + char 重複 freq 次 // 將字元按頻率加入\n→ End // 輸出 result 為排序後的字串\n\nMake sure each line ends with \"// 解釋\". Provide Chinese comments.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得輸入字串 s // 從使用者或參數獲得待排序的字串  \n→ Step 2: 建立空的字典 freq_map // 用於存儲每個字元的頻率  \n→ Step 3: 逐字元遍歷 s // 逐一檢查字串中的每個字元  \n    → Decision: freq_map 是否包含當前字元？ // 判斷字元是否已計數  \n        Yes → Step 4a: freq_map[char] ← freq_map[char] + 1 // 已存在，頻率累加  \n        No  → Step 4b: freq_map[char] ← 1 // 第一次遇到，設定頻率為 1  \n→ Step 5: 把 freq_map 轉成列表 items (char, freq) // 方便排序  \n→ Decision: 是否需要排序？ // 需依頻率降序排列  \n    Yes → Step 6: 對 items 按 freq 降序排序 // 由高頻到低頻  \n→ Step 7: 建立空字串 result // 用於儲存最終結果  \n→ Step 8: 逐對 (char, freq) 遍歷 items // 依次處理每個字元  \n    → Step 9: result ← result + char 重複 freq 次 // 將字元按頻率加入  \n→ End // 輸出 result 為排序後的字串"
    },
    {
      "title": "Palindrome Pairs",
      "source_file": "Leetcode/leetcode336.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
          "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0],[3,2],[2,4]]'\nGot (Norm):      '[[3,2]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0],[3,2],[2,4]]'\nRaw Got:      '[[3, 2]]'"
        },
        {
          "example_index": 1,
          "input": "words = [\"bat\",\"tab\",\"cat\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[]'"
        },
        {
          "example_index": 2,
          "input": "words = [\"a\",\"\"]",
          "expected_output": "[[0,1],[1,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[0,1],[1,0]]'\nGot (Norm):      '[[1,0],[0,1],[0,1],[1,0]]'\n--- (Raw) ---\nRaw Expected: '[[0,1],[1,0]]'\nRaw Got:      '[[1, 0], [0, 1], [0, 1], [1, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def palindromePairs(self, words):\n        # Map reversed word to its index\n        rev_map = {word[::-1]: i for i, word in enumerate(words)}\n        res = []\n\n        # 找到空字串索引（若存在）\n        empty_idx = None\n        for i, w in enumerate(words):\n            if w == '':\n                empty_idx = i\n                break\n\n        # 空字串與任何 palindrome 字串皆能成對\n        if empty_idx is not None:\n            for j, w in enumerate(words):\n                if j == empty_idx:\n                    continue\n                if w == w[::-1]:\n                    res.append([empty_idx, j])  # 空字串前\n                    res.append([j, empty_idx])  # 空字串後\n\n        # 主體：檢查所有單字\n        for i, word in enumerate(words):\n            n = len(word)\n            for split in range(n + 1):\n                prefix = word[:split]\n                suffix = word[split:]\n\n                # case 1：prefix 為 palindrome，尋找 reversed(suffix)\n                if prefix == prefix[::-1]:\n                    rev_suf = suffix[::-1]\n                    if rev_suf in rev_map:\n                        j = rev_map[rev_suf]\n                        if j != i:\n                            res.append([j, i])  # reversed suffix 前\n                # case 2：suffix 為 palindrome，尋找 reversed(prefix)\n                if suffix == suffix[::-1] and split != n:  # 避免重複全字\n                    rev_pre = prefix[::-1]\n                    if rev_pre in rev_map:\n                        j = rev_map[rev_pre]\n                        if j != i:\n                            res.append([i, j])  # reversed prefix 後\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 移除可能存在的 \"words =\" 前綴\n    if data.startswith(\"words\"):\n        data = data.split(\"=\", 1)[1].strip()\n    words = ast.literal_eval(data)\n\n    sol = Solution()\n    result = sol.palindromePairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for algorithm solving palindrome pairs with O(total length) runtime. We need to generate steps line by line, each with explanation. Not actual code.\n\nWe should outline algorithm: use hash map of reversed words to index; for each word, check splits; also handle empty string. Steps: build map, iterate words, for each split produce candidate. Complexity O(total length). Provide pseudocode with Start, Decision, etc.\n\nMake sure to adhere to output format: each line: \"虛擬碼步驟 // 解釋\". Use arrows. We can show loops and decisions. Let's craft.\n\nWe should include steps: Build map of word -> index. For each word with index i: check if empty string case. For each split position from 0 to len(word): prefix = word[0:pos], suffix=word[pos:]; If prefix is palindrome, reversed suffix exists; add pair. If suffix palindrome and pos != len(word), reversed prefix exists; add pair. Also add pair when whole word reversed present.\n\nWe must handle O(total length) by ensuring splits loop overall length of all words. We'll provide steps.\n\nWe must use \"Start\", \"End\". Indent for decisions: using \"Decision:\".\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立哈希表 reverseMap // 以 reversed(word) 作為 key，index 作為 value\n    → Loop i from 0 to words.length-1\n        → Insert reverse(words[i]) → i into reverseMap\n→ Step 2: 初始化空陣列 pairs // 用於儲存所有 (i, j) 組合\n→ Decision: 是否存在空字串 \"\"? // 空字串與任何 palindrome 字串皆可成對\n    Yes → Step 3: 找到空字串所在索引 emptyIdx\n        → Loop j from 0 to words.length-1\n            → Decision: j != emptyIdx 且 words[j] 為 palindrome?\n                Yes → Step 4: Add (emptyIdx, j) to pairs\n                No  → \n    No  → \n→ Step 5: 主迴圈遍歷每個單字 words[i]\n    → Loop i from 0 to words.length-1\n        → Step 6: 取得 word = words[i]\n        → Step 7: 取得長度 n = length(word)\n        → Loop splitPos from 0 to n\n            → Step 8: 取 prefix = word[0:splitPos], suffix = word[splitPos:n]\n            → Decision: prefix 為 palindrome?\n                Yes → Step 9: reversedSuffix = reverse(suffix)\n                    → Decision: reversedSuffix 於 reverseMap 內?\n                        Yes → Step 10: 找到 j = reverseMap[reversedSuffix]\n                                → Decision: j != i?\n                                    Yes → Step 11: Add (j, i) to pairs // 先後順序\n                                    No  → \n                        No  → \n                No  → \n            → Decision: suffix 為 palindrome?\n                Yes → Step 12: reversedPrefix = reverse(prefix)\n                    → Decision: reversedPrefix 於 reverseMap 內且 splitPos != n?\n                        Yes → Step 13: 找到 j = reverseMap[reversedPrefix]\n                                → Decision: j != i?\n                                    Yes → Step 14: Add (i, j) to pairs\n                                    No  → \n                        No  → \n                No  → \n→ Step 15: 結束主迴圈\n→ Step 16: 回傳 pairs // 輸出所有 palindrome 對\nEnd // 程式執行結束"
    },
    {
      "title": "Longest Uncommon Subsequence II",
      "source_file": "Leetcode/leetcode522.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"aaa\",\"aaa\",\"aa\"]",
          "expected_output": "-1",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '-1'\nGot (Norm):      '2'\n--- (Raw) ---\nRaw Expected: '-1'\nRaw Got:      '2'"
        }
      ],
      "generated_code": "import sys\nimport json\nfrom collections import Counter\n\nclass Solution:\n    def findLUSlength(self, strs):\n        \"\"\"\n        找出陣列中所有字串的出現次數，並回傳唯一出現的字串中\n        最長的長度；若無唯一字串則回傳 -1。\n        \"\"\"\n        count = Counter(strs)\n        max_len = -1\n        for s in strs:\n            if count[s] == 1 and len(s) > max_len:\n                max_len = len(s)\n        return max_len\n\ndef main():\n    # 讀取整個標準輸入，並移除首尾空白\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        print(-1)\n        return\n    try:\n        # 期望輸入為 JSON 格式的字串陣列\n        strs = json.loads(raw_input)\n    except json.JSONDecodeError:\n        # 若解析失敗則直接輸出 -1\n        print(-1)\n        return\n\n    solution = Solution()\n    result = solution.findLUSlength(strs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. The problem: longest uncommon subsequence length among array of strings. Known solution: if any string is unique (not equal to any other), return its length; else return -1. Because longest uncommon subsequence can be the string itself if unique. If all strings equal, answer -1. The algorithm: find max length among strings; count occurrences; if there is a string with max length that occurs only once, return its length; else -1. Or we can check each string if unique. But typical solution: if all strings are distinct? Wait typical: If there's at least one string that is not equal to any other, answer its length. Because that string itself is uncommon subsequence. The longest would be the longest among those unique strings. So we find max length among strings that appear only once; if none, -1.\n\nWe'll produce virtual code step by step with arrows. Provide explanation each line.\n\nLet's produce start, steps: Start. Step 1: create map count. Step 2: iterate strings to count. Step 3: find maxLen = -1. Step 4: iterate again, for each string if count==1 and len>maxLen, update maxLen. Step 5: if maxLen==-1 return -1 else return maxLen. End.\n\nAlso include decision points maybe.\n\nLet's produce lines accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 countMap，鍵為字串，值為出現次數 // 用於統計每個字串出現的頻率  \n→ Decision: 初始化 countMap 為空？ // 先確保字典已經建立  \n    Yes → Step 1.1: countMap ← {} // 空字典  \n→ Step 2: 逐一遍歷輸入陣列 strs，對於每個字串 s  \n    → Step 2.1: 若 s 不在 countMap 中，則 countMap[s] ← 1 // 第一個出現  \n    → Step 2.2: 否則 countMap[s] ← countMap[s] + 1 // 次數累加  \n→ Step 3: 設定變數 maxLen ← -1 // 用於保存最長不常見子序列長度  \n→ Step 4: 再次遍歷 strs，對於每個字串 s  \n    → Decision: countMap[s] == 1? // 判斷該字串是否唯一  \n        Yes → Decision: length(s) > maxLen? // 是否比目前已知的長度更長  \n            Yes → Step 4.1: maxLen ← length(s) // 更新最大長度  \n            No  → Step 4.2: （保持 maxLen 不變）  \n        No  → Step 4.3: （忽略非唯一字串）  \n→ Decision: maxLen == -1? // 是否有唯一字串存在  \n    Yes → Step 5: 回傳 -1 // 所有字串皆相同，無不常見子序列  \n    No  → Step 6: 回傳 maxLen // 回傳最長不常見子序列的長度  \nEnd // 程式執行結束"
    },
    {
      "title": "Repeated DNA Sequences",
      "source_file": "Leetcode/leetcode187.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = 'AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT'",
          "expected_output": "[\"AAAAACCCCC\",\"CCCCCAAAAA\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nGot (Norm):      '[\"CCCCCAAAAA\",\"AAAAACCCCC\"]'\n--- (Raw) ---\nRaw Expected: '[\"AAAAACCCCC\",\"CCCCCAAAAA\"]'\nRaw Got:      \"['CCCCCAAAAA', 'AAAAACCCCC']\""
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def findRepeatedDnaSequences(self, s: str):\n        \"\"\"\n        找出所有長度為 10 且在字串 s 中重複出現的 DNA 序列。\n        \"\"\"\n        seen = set()          # 已經見過的 10 字元序列\n        repeated = set()      # 重複出現的 10 字元序列\n\n        # 只要起始位置 i 允許再取 10 個字元就進行掃描\n        for i in range(len(s) - 9):\n            seq = s[i:i + 10]          # 目前的 10 字元窗口\n            if seq in seen:\n                repeated.add(seq)     # 重複時加入結果集\n            else:\n                seen.add(seq)         # 第一個出現時加入 seen\n\n        return list(repeated)           # 轉成列表回傳\n\n\ndef main():\n    \"\"\"\n    讀取標準輸入，解析 DNA 序列並輸出重複的 10 字元子序列。\n    \"\"\"\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n\n    # 如果輸入格式為 s = 'DNA...'，先移除前綴\n    if raw_input.lower().startswith('s'):\n        parts = raw_input.split('=', 1)\n        if len(parts) == 2:\n            raw_input = parts[1].strip()\n\n    # 移除可能的外部引號\n    if (raw_input.startswith('\"') and raw_input.endswith('\"')) or \\\n       (raw_input.startswith(\"'\") and raw_input.endswith(\"'\")):\n        raw_input = raw_input[1:-1]\n\n    dna_sequence = raw_input\n\n    solver = Solution()\n    result = solver.findRepeatedDnaSequences(dna_sequence)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: given string s, find all 10-letter-long substrings that occur more than once. So algorithm: sliding window of length 10, use dictionary to count occurrences, then collect those with count>1.\n\nNeed virtual code line by line with comments. Use Start, Decision, etc.\n\nWe need to produce each line with virtual code step and comment. Use arrows, Start, End. Must not output actual code, only pseudo steps.\n\nWe need to incorporate steps like: initialize map, loop over i from 0 to len(s)-10, substring = s[i:i+10], increment map count, after loop iterate map to add keys with count>1 to result list. Return result.\n\nAlso maybe handle case len<10. Use Decision.\n\nWe also need to use arrow formatting: \"→ Step 1: ...\" etc. For decisions: \"Decision: ...\" with Yes→ etc.\n\nLet's craft.\n\nStart // program start\n→ Step 1: Check if length of s < 10? // if too short no substrings\n    Yes → Step 2: Return empty list // nothing to return\n    No  → Step 3: Initialize empty map counts // map from substring to int\n→ Step 4: For i from 0 to len(s)-10 inclusive // iterate start indices\n    → Step 5: Extract substring of length 10 starting at i // current 10-letter window\n    → Step 6: Increment counts[substring] // update frequency\n→ Step 7: Initialize empty list result // to store repeated sequences\n→ Step 8: For each (key, value) in counts\n    → Decision: If value > 1? // check if repeated\n        Yes → Step 9: Append key to result // add to output\n        No  → Skip // not repeated\n→ Step 10: Return result // final answer\nEnd // program finished\n\nMake sure each line ends with comment. Also arrow lines. For loops maybe \"→ Step X: For i = 0 to ...\" is okay.\n\nAlso for the inner loop, we might use \"→ Step 8:\" etc.\n\nNeed to ensure arrow usage consistent: Use \"→\" before each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 檢查字串 s 的長度是否小於 10? // 若太短無法取 10 個字元  \n  Yes → Step 2: 回傳空列表 // 沒有重複子序列  \n  No  → Step 3: 初始化空字典 counts // 用來紀錄每個 10 字元子序列的出現次數  \n→ Step 4: 迴圈 i 從 0 到 len(s)-10 (含) // 遍歷所有可能的起始位置  \n  → Step 5: 取得子序列 sub = s[i:i+10] // 目前的 10 字元窗口  \n  → Step 6: counts[sub] = counts.get(sub, 0) + 1 // 更新出現次數  \n→ Step 7: 初始化空列表 result // 存放重複出現的子序列  \n→ Step 8: 迴圈每個 (key, value) 在 counts 裡  \n   → Decision: value > 1? // 判斷是否重複  \n    Yes → Step 9: 把 key 加入 result // 收錄重複子序列  \n    No  → Skip // 不重複則忽略  \n→ Step 10: 回傳 result // 完成結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"\n        產生 nums 的所有排列\n        :param nums: List[int]\n        :return: List[List[int]]\n        \"\"\"\n        res = []\n\n        def backtrack(start):\n            # 若已到達最後一個位置，將目前排列加入結果\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            # 從 start 到末尾嘗試交換每個元素\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]   # 交換\n                backtrack(start + 1)                          # 進一步遞歸\n                nums[start], nums[i] = nums[i], nums[start]   # 回溯，恢復原位\n\n        backtrack(0)\n        return res\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n\n    # 解析類似 'nums = [1,2,3]' 的輸入\n    try:\n        # 只取等號右邊的字串並安全評估為列表\n        _, nums_str = data.split('=', 1)\n        nums = ast.literal_eval(nums_str.strip())\n    except Exception:\n        # 若解析失敗，直接使用 eval（假設輸入合法）\n        nums = eval(data.replace('nums', ''))\n\n    solution = Solution()\n    result = solution.permute(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to output virtual code with line by line steps for generating all permutations of distinct integers. Provide steps with Start, Decision, End. Use arrow. No actual code.\n\nWe need to produce algorithm steps: e.g., use backtracking.\n\nSo steps: Start, initialize result list, define backtrack function (index). Add decisions. Provide explanation each line. Use \"→\" arrow.\n\nWe need to produce lines like: \"→ Step 1: Initialize empty result list // ...\". Also need to include \"Decision:\" lines for conditions.\n\nLet's structure:\n\nStart\n\n→ Step 1: 初始化結果列表 results = [] // 存儲所有排列\n\n→ Step 2: 定義回溯函式 backtrack(path, remaining) // path 為已選項，remaining 為剩餘可選項\n\nInside backtrack:\n\nDecision: 如果 remaining 為空? // 判斷是否完成排列\n\nYes → Step 3: 將 path 加入 results // 完成一個排列\n\nNo → Decision: 遍歷 remaining?\n\nWe may need loops. But we can represent loop with \"For each element in remaining\".\n\nSo \"→ Step 4: For each num in remaining: // 選取每個剩餘數字\"\n\n→ Step 5: Append num to path // 添加到目前排列\n\n→ Step 6: Remove num from remaining // 從剩餘中移除\n\n→ Step 7: backtrack(path, remaining) // 進一步遞歸\n\n→ Step 8: 回復 state: 移除 path 最後一個元素 // 回溯\n\n→ Step 9: 把 num 加回 remaining // 還原剩餘\n\nThen after backtrack call.\n\nAt the end, End.\n\nWe should produce each line with explanation. Also include arrow and indentation for nested decisions.\n\nLet's produce.\n\nAlso need to show \"→ Decision:\" lines.\n\nWe might need to show \"Yes →\" \"No →\" for decisions. For loop, maybe \"→ For each\".\n\nWe must keep each line as single line: \"虛擬碼步驟 // 解釋\".\n\nLet's craft.\n\nWe'll start:\n\nStart // 程式開始執行\n\n→ Step 1: 初始化 results 為空列表 // 用於收集所有排列\n\n→ Step 2: 定義函式 backtrack(path, remaining) // 參數 path: 當前排列, remaining: 尚未使用的元素\n\n→ Step 3: Decision: 若 remaining 為空? // 判斷是否已用完所有元素\n\n    Yes → Step 4: 將 path 複製並加入 results // 將完整排列加入結果\n\n    No  → Step 5: For each num 在 remaining: // 遍歷每個剩餘元素\n\n        → Step 6: Append num 到 path // 將選取的元素加入目前排列\n\n        → Step 7: Remove num 從 remaining // 從剩餘集合中排除已選元素\n\n        → Step 8: Call backtrack(path, remaining) // 進一步遞歸\n\n        → Step 9: 移除 path 最後一個元素 // 回溯至上一層\n\n        → Step 10: 把 num 加回 remaining // 還原剩餘集合\n\nEnd // 程式結束\n\nCheck that lines after indentation still count as single line. Use indentation in virtual code but must remain a single line. We can use tab or spaces. But each line should be a separate virtual code line. So we need to produce lines like \"    Yes → Step 4: ...\" etc. That's okay.\n\nAlso the decision lines: \"Decision: 若 remaining 為空?\" then indent with \"Yes →\" \"No →\". That's fine.\n\nMake sure arrow usage is consistent: \"→\" for steps. For decision: \"Decision:\" line. \"Yes →\" \"No →\".\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 results 為空列表 // 用於收集所有排列  \n→ Step 2: 定義函式 backtrack(path, remaining) // path: 當前排列, remaining: 尚未使用的元素  \n→ Step 3: Decision: 若 remaining 為空? // 判斷是否已用完所有元素  \n    Yes → Step 4: 將 path 複製並加入 results // 將完整排列加入結果  \n    No  → Step 5: For each num 在 remaining: // 遍歷每個剩餘元素  \n        → Step 6: Append num 到 path // 將選取的元素加入目前排列  \n        → Step 7: Remove num 從 remaining // 從剩餘集合中排除已選元素  \n        → Step 8: Call backtrack(path, remaining) // 進一步遞歸  \n        → Step 9: 移除 path 最後一個元素 // 回溯至上一層  \n        → Step 10: 把 num 加回 remaining // 還原剩餘集合  \nEnd // 程式結束"
    },
    {
      "title": "Text Justification",
      "source_file": "Leetcode/leetcode68.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16",
          "expected_output": "[\"This    is    an\",\"example  of text\",\"justification.  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcga6v4i0.py\", line 49, in <module>\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        },
        {
          "example_index": 1,
          "input": "words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16",
          "expected_output": "[\"What   must   be\",\"acknowledgment  \",\"shall be        \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpd7yn07_8.py\", line 49, in <module>\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        },
        {
          "example_index": 2,
          "input": "words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20",
          "expected_output": "[\"Science  is  what we\",\"understand      well\",\"enough to explain to\",\"a  computer.  Art is\",\"everything  else  we\",\"do                  \"]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv5_gi1n4.py\", line 49, in <module>\n    raise ValueError(\"Input format not recognized\")\nValueError: Input format not recognized"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def fullJustify(self, words, maxWidth):\n        res = []\n        i = 0\n        n = len(words)\n\n        while i < n:\n            line_len = len(words[i])\n            j = i + 1\n            while j < n and line_len + 1 + len(words[j]) <= maxWidth:\n                line_len += 1 + len(words[j])\n                j += 1\n\n            line_words = words[i:j]\n            spaces_needed = maxWidth - sum(len(word) for word in line_words)\n            gaps = len(line_words) - 1\n\n            if j == n or gaps == 0:\n                line = ' '.join(line_words) + ' ' * (maxWidth - line_len)\n            else:\n                space, extra = divmod(spaces_needed, gaps)\n                line = ''\n                for k in range(gaps):\n                    line += line_words[k] + ' ' * (space + (1 if k < extra else 0))\n                line += line_words[-1]\n\n            res.append(line)\n            i = j\n\n        return res\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    match = re.search(r'words\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*maxWidthерам?(\\d+)', data)\n    if match:\n        words_str = match.group(1)\n        max_width = int(match.group(2))\n        words = eval(words_str)\n    else:\n        # Try a simpler format: two lines, first words list, second maxWidth\n        lines = data.splitlines()\n        if len(lines) >= 2:\n            words = eval(lines[0].strip())\n            max_width = int(lines[1].strip())\n        else:\n            raise ValueError(\"Input format not recognized\")\n\n    solution = Solution()\n    result = solution.fullJustify(words, max_width)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for text justification. Need to produce line-by-line with explanations. Must follow format exactly: \"虛擬碼步驟 // 解釋\". Use arrows etc. We need to structure algorithm: Start, gather words into line, compute spaces, distribute. Also handle last line left-justified. We'll produce pseudo-code in a simple structure.\n\nWe need to output the virtual code lines, each line with explanation. Use \"Start\" and \"End\". Use \"Decision:\" lines. Use \"→\" arrow to indent? Example shows \"→ Step 1: ...\" etc. We'll produce similar.\n\nWe must include \"虛擬碼步驟\" after each line? The instruction: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must start with the step expression. We can use \"Start\", \"→ Step ...\". After the step, a space, then \"// 解釋\". Use arrow arrow? The example uses \"→ Step 1: ...\". So we follow.\n\nAlso use Decision: etc.\n\nWe need to produce pseudo-code for algorithm: Input words array and maxWidth. Create list result. Initialize index = 0. While index < words.length: determine end of line by adding words until exceed maxWidth. Then compute number of words in line: end - index. Then compute number of spaces needed: maxWidth - sum(word lengths). For last line (index == words.length - 1 or end == words.length), left justify: join words with single space, pad end with spaces. For other lines: distribute spaces evenly: spaceCount = (totalSpaces / (numWords-1)). extraSpaces = totalSpaces % (numWords-1). For i from index to end-1: output word[i] + spaces (spaceCount + 1 if i-index < extraSpaces else spaceCount). Append last word without trailing space.\n\nAdd to result. Set index = end. End.\n\nNow produce virtual code.\n\nWe must use arrow for steps? We'll produce like:\n\nStart // 程式開始執行\n→ Step 1: wordsIndex ← 0 // 初始化索引指向第一個單字\n→ Step 2: result ← empty list // 儲存格式化後的每一行\n\nThen loop:\n\n→ Decision: wordsIndex < words.length? // 是否還有未處理的單字\n    Yes →\n        → Step 3: lineStart ← wordsIndex // 記錄本行起始索引\n        → Step 4: lineLen ← 0 // 本行已佔用的長度\n        → Decision: wordsIndex < words.length AND lineLen + words[wordsIndex].length + (wordsIndex - lineStart) <= maxWidth? // 判斷能否加入下一個單字\n            Yes →\n                → Step 5: lineLen ← lineLen + words[wordsIndex].length // 加入單字長度\n                → Step 6: wordsIndex ← wordsIndex + 1 // 移動到下一個單字\n                → Back to Decision // 重新檢查是否還能加入\n            No  →\n                → Step 7: lineEnd ← wordsIndex // 本行結束索引\n                → Step 8: lineWords ← words[lineStart : lineEnd] // 本行單字集合\n                → Decision: lineEnd == words.length? // 是否為最後一行\n                    Yes →\n                        → Step 9: line ← join(lineWords, \" \") // 單字以單空格連接\n                        → Step 10: line ← padRight(line, maxWidth, \" \") // 右邊填充空格至 maxWidth\n                        → Step 11: result.append(line) // 加入結果\n                    No  →\n                        → Step 12: totalWordLen ← sum(length of each word in lineWords) // 本行單字總長度\n                        → Step 13: totalSpace ← maxWidth - totalWordLen // 必須分配的空格總數\n                        → Step 14: gaps ← lineEnd - lineStart - 1 // 內部斷開槽數\n                        → Decision: gaps == 0? // 只有一個單字\n                            Yes →\n                                → Step 15: line ← lineWords[0] + repeat(\" \", totalSpace) // 單字後填充空格\n                                → Step 16: result.append(line) // 加入結果\n                            No  →\n                                → Step 17: baseSpace ← totalSpace // 初始空格數\n                                → Step 18: extraSpace ← totalSpace % gaps // 需要多出一個空格的槽數\n                                → Step 19: spacePerGap ← totalSpace // 後面用來分配\n                                → Step 20: gapIdx ← 0 // 槽索引\n                                → Step 21: line ← \"\" // 初始化行字串\n                                → For i from lineStart to lineEnd-1:\n                                    → Step 22: line ← line + lineWords[i] // 加入單字\n                                    → Decision: i < lineEnd-1? // 不是最後一個單字嗎\n                                        Yes →\n                                            → Step 23: spacesToAdd ← baseSpace // 初始空格數\n                                            → Decision: gapIdx < extraSpace? // 需要額外空格嗎\n                                                Yes →\n                                                    → Step 24: spacesToAdd ← spacesToAdd + 1 // 加多一個空格\n                                                No  →\n                                            → Step 25: line ← line + repeat(\" \", spacesToAdd) // 加入空格\n                                            → Step 26: gapIdx ← gapIdx + 1 // 移動到下一槽\n                                        No  →\n                                            → // 最後一個單字，已在 line 中\n                                → Step 27: result.append(line) // 加入結果\n                → Back to Decision: wordsIndex < words.length? // 回到外層循環\n    No →\n        → End // 程式執行結束\n\nBut need to refine: We have too many steps. We need to keep each line simple, but include explanation.\n\nWe should use \"→\" before each step; we can indent nested steps but each line includes arrow.\n\nWe need to keep consistent style: each line start with \"→\". For Decision lines, format like \"Decision: ...?\" Then \"Yes →\" etc.\n\nNeed to ensure each line has a single step, explanation after comment. We need to avoid multi-step lines.\n\nSimplify steps: maybe combine some steps. But we must maintain algorithm. Let's try.\n\nWe'll produce:\n\nStart // 程式開始執行\n→ wordsIndex ← 0 // 初始索引指向 words 的第一個單字\n→ result ← [] // 儲存已格式化好的行\n\nDecision: wordsIndex < words.length? // 是否還有未處理的單字\n    Yes →\n        → lineStart ← wordsIndex // 記錄本行起始索引\n        → lineLen ← 0 // 本行已佔用長度\n        Decision: wordsIndex < words.length AND lineLen + words[wordsIndex].length + (wordsIndex - lineStart) ≤ maxWidth? // 判斷能否加入下一個單字\n            Yes →\n                → lineLen ← lineLen + words[wordsIndex].length // 加入單字長度\n                → wordsIndex ← wordsIndex + 1 // 移動到下一個單字\n                → Back to Decision // 重新檢查是否還能加入\n            No  →\n                → lineEnd ← wordsIndex // 本行結束索引\n                → lineWords ← words[lineStart:lineEnd] // 本行單字集合\n                Decision: lineEnd == words.length? // 是否為最後一行\n                    Yes →\n                        → line ← join(lineWords, \" \") // 單字以單空格連接\n                        → line ← padRight(line, maxWidth, \" \") // 右側填充空格至 maxWidth\n                        → result.append(line) // 加入結果\n                    No  →\n                        → totalWordLen ← sum(len(w) for w in lineWords) // 本行單字總長度\n                        → totalSpace ← maxWidth - totalWordLen // 必須分配的空格總數\n                        → gaps ← lineEnd - lineStart - 1 // 內部空格槽數\n                        Decision: gaps == 0? // 只有一個單字\n                            Yes →\n                                → line ← lineWords[0] + repeat(\" \", totalSpace) // 單字後填充空格\n                                → result.append(line) // 加入結果\n                            No  →\n                                → baseSpace ← totalSpace // 初始每個槽的空格數\n                                → extraSpace ← totalSpace % gaps // 需要額外空格的槽數\n                                → line ← \"\" // 初始化行字串\n                                → gapIdx ← 0 // 空格槽索引\n                                → For i in range(lineStart, lineEnd):\n                                    → line ← line + lineWords[i] // 加入單字\n                                    → Decision: i < lineEnd - 1? // 是否還有下一個單字\n                                        Yes →\n                                            → spacesToAdd ← baseSpace // 基本空格數\n                                            → Decision: gapIdx < extraSpace? // 是否需要額外空格\n                                                Yes →\n                                                    → spacesToAdd ← spacesToAdd + 1 // 加多一個空格\n                                                No  →\n                                            → line ← line + repeat(\" \", spacesToAdd) // 加入空格\n                                            → gapIdx ← gapIdx + 1 // 移動到下一槽\n                                        No  →\n                                            → // 最後一個單字，不再加空格\n                                → result.append(line) // 加入結果\n                → Back to Decision: wordsIndex < words.length? // 回到外層循環\n    No →\n        → End // 程式執行結束\n\nBut we need each line as \"虛擬碼步驟 // 解釋\". The lines above are long. We need to separate each into a separate line with comment after. The lines like \"→ For i in range...\" need to have comment. Also we need to keep indentation? Not necessary but we can keep arrow at start.\n\nBut some lines have nested decisions: \"Decision: i < lineEnd - 1?\" etc. Should be separate lines.\n\nWe must ensure we use \"Yes →\" and \"No  →\" lines. Format like:\n\nDecision: i < lineEnd - 1? // 判斷是否還有下一個單字\n    Yes →\n        → spacesToAdd ← baseSpace // 基本空格數\n        → Decision: gapIdx < extraSpace? // 是否需要額外空格\n            Yes →\n                → spacesToAdd ← spacesToAdd + 1 // 加多一個空格\n            No  →\n        → line ← line + repeat(\" \", spacesToAdd) // 加入空格\n        → gapIdx ← gapIdx + 1 // 移動到下一槽\n\nBut each line must be a single step. So we must avoid multiple steps on one line. Let's rewrite with each line single step.\n\nWe also need to include the \"Back to Decision\" lines to go back loops. But that's not necessary; we can rely on loop structure. But maybe we keep for clarity.\n\nHowever the requirement: \"逐行產生虛擬碼\" not require loops explicit. But we can use While loops and For loops with \"→\".\n\nBetter produce simpler structure: Use While for outer loop, inner while to add words, then compute line.\n\nLet's produce pseudo-code:\n\nStart // 程式開始\n→ wordsIndex ← 0 // 指向 words 的第一個單字\n→ result ← [] // 儲存每一行\n→ While wordsIndex < words.length: // 處理每一行\n    → lineStart ← wordsIndex // 本行起始\n    → lineLen ← 0 // 本行已使用長度\n    → While wordsIndex < words.length AND lineLen + words[wordsIndex].length + (wordsIndex - lineStart) ≤ maxWidth: // 加入單字\n        → lineLen ← lineLen + words[wordsIndex].length\n        → wordsIndex ← wordsIndex + 1\n    → lineEnd ← wordsIndex // 本行結束\n    → lineWords ← words[lineStart:lineEnd] // 本行單字\n    → If lineEnd == words.length: // 最後一行\n        → line ← join(lineWords, \" \")\n        → line ← padRight(line, maxWidth, \" \")\n        → result.append(line)\n    → Else: // 非最後一行\n        → totalWordLen ← sum(len(w) for w in lineWords)\n        → totalSpace ← maxWidth - totalWordLen\n        → gaps ← lineEnd - lineStart - 1\n        → If gaps == 0:\n            → line ← lineWords[0] + repeat(\" \", totalSpace)\n            → result.append(line)\n        → Else:\n            → baseSpace ← totalSpace // 每個槽的基本空格\n            → extraSpace ← totalSpace % gaps // 需要額外空格的槽數\n            → line ← \"\" // 初始化\n            → gapIdx ← 0\n            → For i in range(lineStart, lineEnd):\n                → line ← line + lineWords[i]\n                → If i < lineEnd - 1:\n                    → spacesToAdd ← baseSpace\n                    → If gapIdx < extraSpace:\n                        → spacesToAdd ← spacesToAdd + 1\n                    → line ← line + repeat(\" \", spacesToAdd)\n                    → gapIdx ← gapIdx + 1\n            → result.append(line)\nEnd // 程式結束\n\nBut we need to ensure each line is separate with explanation comment. So break each step into separate lines with comment. Use \"→\" for each step. For nested decisions we need \"Decision:\" lines and indent? We'll maintain.\n\nLet's produce final output with each line.\n\nMake sure no duplicate arrow within same line.\n\nLet's construct.\n\n```\nStart // 程式開始\n→ wordsIndex ← 0 // 初始化指向 words 的第一個單字\n→ result ← [] // 用於儲存每一行的結果\n→ While wordsIndex < words.length: // 處理每一行\n    → lineStart ← wordsIndex // 本行起始索引\n    → lineLen ← 0 // 本行已佔用長度\n    → While wordsIndex < words.length AND lineLen + words[wordsIndex].length + (wordsIndex - lineStart) ≤ maxWidth: // 判斷是否可加入下一個單字\n        → lineLen ← lineLen + words[wordsIndex].length // 加入單字長度\n        → wordsIndex ← wordsIndex + 1 // 移動到下一個單字\n    → lineEnd ← wordsIndex // 本行結束索引\n    → lineWords ← words[lineStart:lineEnd] // 取得本行單字集合\n    → If lineEnd == words.length: // 是否為最後一行\n        → line ← join(lineWords, \" \") // 單字以單空格連接\n        → line ← padRight(line, maxWidth, \" \") // 右側填充空格至 maxWidth\n        → result.append(line) // 加入結果\n    → Else: // 非最後一行\n        → totalWordLen ← sum(len(w) for w in lineWords) // 本行單字總長度\n        → totalSpace ← maxWidth - totalWordLen // 必須分配的空格總數\n        → gaps ← lineEnd - lineStart - 1 // 內部空格槽數\n        → If gaps == 0: // 只有一個單字\n            → line ← lineWords[0] + repeat(\" \", totalSpace) // 單字後填充空格\n            → result.append(line) // 加入結果\n        → Else: // 多於一個單字\n            → baseSpace ← totalSpace // 每個槽的基本空格數\n            → extraSpace ← totalSpace % gaps // 需要額外空格的槽數\n            → line ← \"\" // 初始化行字串\n            → gapIdx ← 0 // 空格槽索引\n            → For i in range(lineStart, lineEnd): // 逐個單字\n                → line ← line + lineWords[i] // 加入單字\n                → If i < lineEnd - 1: // 不是最後一個單字\n                    → spacesToAdd ← baseSpace // 基本空格數\n                    → If gapIdx < extraSpace: // 需要額外空格\n                        → spacesToAdd ← spacesToAdd + 1 // 加多一個空格\n                    → line ← line + repeat(\" \", spacesToAdd) // 加入空格\n                    → gapIdx ← gapIdx + 1 // 移動到下一槽\n            → result.append(line) // 加入結果\nEnd // 程式結束\n```\n\nNeed to check formatting: Each line begins with either \"Start\", \"→\", or \"End\". But some lines have \"→ While ...\" with nested indentation. In example, they used \"→ Step 1:\". Our format: we can keep \"→ While ...\". The requirement: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋\". So each line has \"虛擬碼步驟\" (which may include \"While\") followed by a space then comment. Example shows \"→ Step 1: ... //\". So we need at least one space between step and comment. We have that. But need to ensure we don't include double spaces before comment. For lines like \"→ While wordsIndex < words.length: //\". We need to put a space after colon. Actually \"While ...:\" then space then \"//\". In our lines we have \"While wordsIndex < words.length:\" and then space before \"//\". Good.\n\nAlso for \"If lineEnd == words.length:\" similar. Need space after colon. Yes.\n\nAlso for nested lines: We used \"→ For i in range(...): //\". Good.\n\nBut we must ensure each line's indentation uses spaces but not extra arrow. The example had arrow for each line. They didn't indent nested steps; they used \"Decision:\" etc. So it's okay.\n\nWe might need to use \"Decision:\" for conditions. But the example used \"Decision: 如果數字大於 0?\" with arrow. They didn't use \"If\". So maybe we should use \"Decision:\" for conditions, not \"If\". But both acceptable? The specification says use arrow and structure (Start, End, Decision:). We should use \"Decision:\" for if statements to adhere. Let's modify: Replace \"If\" with \"Decision: ...?\" and then \"Yes →\" and \"No →\".\n\nThus we need to change our pseudo-code accordingly. Let's revise:\n\nStart // 程式開始\n→ wordsIndex ← 0 // ...\n→ result ← []\n→ While wordsIndex < words.length: // 處理每一行\n    → lineStart ← wordsIndex\n    → lineLen ← 0\n    → While wordsIndex < words.length AND lineLen + words[wordsIndex].length + (wordsIndex - lineStart) ≤ maxWidth:\n        → lineLen ← lineLen + words[wordsIndex].length\n        → wordsIndex ← wordsIndex + 1\n    → lineEnd ← wordsIndex\n    → lineWords ← words[lineStart:lineEnd]\n    → Decision: lineEnd == words.length? // 是否為最後一行\n        Yes →\n            → line ← join(lineWords, \" \")\n            → line ← padRight(line, maxWidth, \" \")\n            → result.append(line)\n        No  →\n            → totalWordLen ← sum(len(w) for w in lineWords)\n            → totalSpace ← maxWidth - totalWordLen\n            → gaps ← lineEnd - lineStart - 1\n            → Decision: gaps == 0? // 只有一個單字\n                Yes →\n                    → line ← lineWords[0] + repeat(\" \", totalSpace)\n                    → result.append(line)\n                No  →\n                    → baseSpace ← totalSpace\n                    → extraSpace ← totalSpace % gaps\n                    → line ← \"\"\n                    → gapIdx ← 0\n                    → For i in range(lineStart, lineEnd):\n                        → line ← line + lineWords[i]\n                        → Decision: i < lineEnd - 1? // 不是最後一個單字\n                            Yes →\n                                → spacesToAdd ← baseSpace\n                                → Decision: gapIdx < extraSpace? // 需要額外空格\n                                    Yes →\n                                        → spacesToAdd ← spacesToAdd + 1\n                                    No  →\n                                → line ← line + repeat(\" \", spacesToAdd)\n                                → gapIdx ← gapIdx + 1\n                            No  →\n                                → // 最後一個單字，無需空格\n                    → result.append(line)\nEnd // 程式結束\n\nCheck formatting: For \"While\" we keep \"→ While ...\" not \"Decision\". The \"While\" is loop, not decision. That's fine.\n\nNeed to ensure each line has a space before comment. Example lines like \"→ While wordsIndex < words.length: //\". We need to ensure there is a space after colon. Good.\n\nBut we must ensure each line uses same pattern: \"虛擬碼步驟 [空格] // 解釋\". For \"Decision:\" lines, they also include colon and question mark, then space, then comment. Eg: \"Decision: lineEnd == words.length? // 是否為最後一行\". Good.\n\nNow we need to produce final answer with each line exactly. Let's produce final code block with lines.\n\nLet's verify each line for correct syntax:\n\n1. Start // 程式開始\n2. → wordsIndex ← 0 // 初始化指向 words 的第一個單字\n3. → result ← [] // 用於儲存每一行的結果\n4. → While wordsIndex < words.length: // 處理每一行\n5.     → lineStart ← wordsIndex // 本行起始索引\n6.     → lineLen ← 0 // 本行已佔用長度\n7.     → While wordsIndex < words.length AND lineLen + words[wordsIndex].length + (wordsIndex - lineStart) ≤ maxWidth: // 判斷是否可加入下一個單字\n8.         → lineLen ← lineLen + words[wordsIndex].length // 加入單字長度\n9.         → wordsIndex ← wordsIndex + 1 // 移動到下一個單字\n10.     → lineEnd ← wordsIndex // 本行結束索引\n11.     → lineWords ← words[lineStart:lineEnd] // 取得本行單字集合\n12.     → Decision: lineEnd == words.length? // 是否為最後一行\n13.         Yes →\n14.             → line ← join(lineWords, \" \") // 單字以單空格連接\n15.             → line ← padRight(line, maxWidth, \" \") // 右側填充空格至 maxWidth\n16.             → result.append(line) // 加入結果\n17.         No  →\n18.             → totalWordLen ← sum(len(w) for w in lineWords) // 本行單字總長度\n19.             → totalSpace ← maxWidth - totalWordLen // 必須分配的空格總數\n20.             → gaps ← lineEnd - lineStart - 1 // 內部空格槽數\n21.             → Decision: gaps == 0? // 只有一個單字\n22.                 Yes →\n23.                     → line ← lineWords[0] + repeat(\" \", totalSpace) // 單字後填充空格\n24.                     → result.append(line) // 加入結果\n25.                 No  →\n26.                     → baseSpace ← totalSpace // 每個槽的基本空格數\n27.                     → extraSpace ← totalSpace % gaps // 需要額外空格的槽數\n28.                     → line ← \"\" // 初始化行字串\n29.                     → gapIdx ← 0 // 空格槽索引\n30.                     → For i in range(lineStart, lineEnd): // 逐個單字\n31.                         → line ← line + lineWords[i] // 加入單字\n32.                         → Decision: i < lineEnd - 1? // 不是最後一個單字\n33.                             Yes →\n34.                                 → spacesToAdd ← baseSpace // 基本空格數\n35.                                 → Decision: gapIdx < extraSpace? // 需要額外空格\n36.                                     Yes →\n37.                                         → spacesToAdd ← spacesToAdd + 1 // 加多一個空格\n38.                                     No  →\n39.                                 → line ← line + repeat(\" \", spacesToAdd) // 加入空格\n40.                                 → gapIdx ← gapIdx + 1 // 移動到下一槽\n41.                             No  →\n42.                                 → // 最後一個單字，無需空格\n43.                     → result.append(line) // 加入結果\n44. End // 程式結束\n\nCheck each line: \"→ For i in range(lineStart, lineEnd): // 逐個單字\" - yes.\n\nNeed to ensure the \"No  →\" has two spaces before arrow? In example they had \"No  →\" with two spaces. We'll keep two spaces after No to align. Similarly for \"Yes →\" and \"No  →\". Good.\n\nAlso line 30 \"→ For i in range...\" correct.\n\nNow produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ wordsIndex ← 0 // 初始化指向 words 的第一個單字\n→ result ← [] // 用於儲存每一行的結果\n→ While wordsIndex < words.length: // 處理每一行\n    → lineStart ← wordsIndex // 本行起始索引\n    → lineLen ← 0 // 本行已佔用長度\n    → While wordsIndex < words.length AND lineLen + words[wordsIndex].length + (wordsIndex - lineStart) ≤ maxWidth: // 判斷是否可加入下一個單字\n        → lineLen ← lineLen + words[wordsIndex].length // 加入單字長度\n        → wordsIndex ← wordsIndex + 1 // 移動到下一個單字\n    → lineEnd ← wordsIndex // 本行結束索引\n    → lineWords ← words[lineStart:lineEnd] // 取得本行單字集合\n    → Decision: lineEnd == words.length? // 是否為最後一行\n        Yes →\n            → line ← join(lineWords, \" \") // 單字以單空格連接\n            → line ← padRight(line, maxWidth, \" \") // 右側填充空格至 maxWidth\n            → result.append(line) // 加入結果\n        No  →\n            → totalWordLen ← sum(len(w) for w in lineWords) // 本行單字總長度\n            → totalSpace ← maxWidth - totalWordLen // 必須分配的空格總數\n            → gaps ← lineEnd - lineStart - 1 // 內部空格槽數\n            → Decision: gaps == 0? // 只有一個單字\n                Yes →\n                    → line ← lineWords[0] + repeat(\" \", totalSpace) // 單字後填充空格\n                    → result.append(line) // 加入結果\n                No  →\n                    → baseSpace ← totalSpace // 每個槽的基本空格數\n                    → extraSpace ← totalSpace % gaps // 需要額外空格的槽數\n                    → line ← \"\" // 初始化行字串\n                    → gapIdx ← 0 // 空格槽索引\n                    → For i in range(lineStart, lineEnd): // 逐個單字\n                        → line ← line + lineWords[i] // 加入單字\n                        → Decision: i < lineEnd - 1? // 不是最後一個單字\n                            Yes →\n                                → spacesToAdd ← baseSpace // 基本空格數\n                                → Decision: gapIdx < extraSpace? // 需要額外空格\n                                    Yes →\n                                        → spacesToAdd ← spacesToAdd + 1 // 加多一個空格\n                                    No  →\n                                → line ← line + repeat(\" \", spacesToAdd) // 加入空格\n                                → gapIdx ← gapIdx + 1 // 移動到下一槽\n                            No  →\n                                → // 最後一個單字，無需空格\n                    → result.append(line) // 加入結果\nEnd // 程式結束\n```"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findDuplicate(self, nums):\n        # Floyd's Tortoise and Hare (Cycle Detection) algorithm\n        slow = fast = nums[0]\n        # First phase: Find intersection point\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n        # Second phase: Find entrance to the cycle\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow\n\nif __name__ == \"__main__\":\n    # Read entire stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # Expect format like: nums = [1,3,4,2,2]\n    try:\n        _, nums_str = data.split('=', 1)\n    except ValueError:\n        # If no '=' present, assume the whole input is the list\n        nums_str = data\n    nums_str = nums_str.strip()\n    # Safely evaluate the list\n    nums = ast.literal_eval(nums_str)\n    # Compute duplicate\n    result = Solution().findDuplicate(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: find repeated number in array of n+1 ints range 1..n, exactly one repeated. Must solve without modifying array and constant extra space. This is classic Floyd's Tortoise and Hare algorithm (cycle detection). Provide pseudocode lines with explanation. Must use arrow, Start, Decision, etc. Each line with \"// explanation\".\n\nWe need to produce step-by-step algorithm. Should be virtual code lines with arrows \"→\" and \"Yes →\", \"No →\". Should incorporate loops. Use constant space. Provide pseudocode steps.\n\nWe must not output actual code, only virtual steps. Ensure each line has virtual code step + space + // explanation. Format exactly.\n\nLet's produce:\n\nStart // Program start\n→ Step 1: Initialize slow = nums[0], fast = nums[0] // Set both pointers at first element\n→ Decision: While True? Actually we need a loop to find intersection: \nWe can produce a loop using Decision: While slow ≠ fast? But we need to move pointers until they meet. Use a loop: \nMaybe use \"While\" construct: \n→ Decision: While slow ≠ fast? But we also need to move inside loop. Could produce a loop structure with \"Loop:\".\n\nGiven the format, we might produce:\n\n→ Step 2: Loop start // Begin cycle detection loop\n→ Step 3: slow = nums[slow] // Move slow pointer one step\n→ Step 4: fast = nums[nums[fast]] // Move fast pointer two steps\n→ Decision: If slow == fast? // Check for intersection\n    Yes → Break loop // Intersection found\n    No  → Repeat loop // Continue moving pointers\n\nBut the format expects arrows, maybe:\n\n→ Step 2: While slow ≠ fast? // Loop until pointers meet\n\nBut can't include condition inside Step? Let's produce:\n\n→ Step 2: Repeat\n    → Step 3: slow = nums[slow]\n    → Step 4: fast = nums[nums[fast]]\n    → Decision: If slow == fast? // Check intersection\n        Yes → Break // exit loop\n        No  → Continue // repeat\n\nHowever the \"Decision:\" may be used to choose between Yes and No. But we need to maintain arrow for loop. Let's produce:\n\nStart // Program start\n→ Step 1: slow ← nums[0] // 初始化慢指標\n→ Step 2: fast ← nums[0] // 初始化快指標\n→ Decision: 是否已相遇? // 初始情況下尚未相遇\n    No  → Loop:\n        → Step 3: slow ← nums[slow] // 慢指標前進一步\n        → Step 4: fast ← nums[nums[fast]] // 快指標前進兩步\n        → Decision: slow == fast? // 檢查是否相遇\n            Yes → Break // 相遇後離開循環\n            No  → No → Continue // 繼續循環\n    Yes → // 若初始相遇（不可能）直接進入下一步\n→ Step 5: reset = nums[0] // 重置指標\n→ Decision: reset == slow? // 檢查是否相等\n    Yes → Return reset // 重複數字\n    No  → Loop:\n        → Step 6: reset ← nums[reset] // 移動 reset\n        → Step 7: slow ← nums[slow] // 移動 slow\n        → Decision: reset == slow? // 再次檢查\n            Yes → Return reset // 找到重複\n            No  → No → Continue\n\nBut we need to produce step-by-step in a clear manner, each line with arrow.\n\nWe should follow the requested format: each line has virtual code step and explanation. Use arrow \"→\" for steps and \"Yes →\" / \"No →\" for decisions.\n\nLet's craft final pseudocode:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化慢指標\n→ Step 2: fast ← nums[0] // 初始化快指標\n→ Decision: slow == fast? // 檢查是否已相遇（初始情況）\n    No  → Loop:\n        → Step 3: slow ← nums[slow] // 慢指標往前走一步\n        → Step 4: fast ← nums[nums[fast]] // 快指標往前走兩步\n        → Decision: slow == fast? // 檢查是否相遇\n            Yes → Break // 交叉點找到，離開循環\n            No  → No → Continue // 未相遇，繼續循環\n    Yes → // 初始已相遇（不會發生）\n→ Step 5: entry ← nums[0] // 將重置指標設回起點\n→ Decision: entry == slow? // 檢查是否即為重複數字\n    Yes → Return entry // 找到重複數字\n    No  → Loop:\n        → Step 6: entry ← nums[entry] // 移動 entry\n        → Step 7: slow ← nums[slow] // 同時移動 slow\n        → Decision: entry == slow? // 檢查是否相等\n            Yes → Return entry // 相等即為重複數字\n            No  → No → Continue // 未相等，繼續循環\nEnd // 程式執行結束\n\nBut the format expects each line with \"→\" or \"Yes →\" etc. We also need to incorporate \"End\". Might produce:\n\nStart // 程式開始執行\n→ Step 1: slow ← nums[0] // 初始化慢指標\n→ Step 2: fast ← nums[0] // 初始化快指標\n→ Decision: slow == fast? // 檢查是否已相遇\n    No → Loop:\n        → Step 3: slow ← nums[slow] // 慢指標前進一步\n        → Step 4: fast ← nums[nums[fast]] // 快指標前進兩步\n        → Decision: slow == fast? // 檢查相遇\n            Yes → Break // 交叉點已找到\n            No → No → Continue // 未相遇，重複循環\n    Yes → // 初始相遇不會發生\n→ Step 5: entry ← nums[0] // 重置指標回起點\n→ Decision: entry == slow? // 是否已相等\n    Yes → Return entry // 重複數字\n    No → Loop:\n        → Step 6: entry ← nums[entry] // 移動 entry\n        → Step 7: slow ← nums[slow] // 同時移動 slow\n        → Decision: entry == slow? // 檢查是否相等\n            Yes → Return entry // 找到重複\n            No → No → Continue // 未相等，繼續循環\nEnd // 程式執行結束\n\nWe need to ensure arrow formatting exactly: \"→\" preceding each line except Start and End maybe. Each line: Virtual code step + space + // explanation.\n\nAlso ensure \"Decision:\" lines preceded by \"Decision:\" and \"Yes →\" and \"No →\".\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 初始化慢指標  \n→ Step 2: fast ← nums[0] // 初始化快指標  \n→ Decision: slow == fast? // 初始是否已相遇（不會）  \n No → Loop: // 循環尋找交叉點  \n  → Step 3: slow ← nums[slow] // 慢指標前進一步  \n  → Step 4: fast ← nums[nums[fast]] // 快指標前進兩步  \n  → Decision: slow == fast? // 檢查是否相遇  \n   Yes → Break // 找到交叉點，離開循環  \n   No → No → Continue // 未相遇，繼續循環  \n→ Step 5: entry ← nums[0] // 將重置指標回到起點  \n→ Decision: entry == slow? // 檢查是否已相等  \n Yes → Return entry // 重複數字即為答案  \n No → Loop: // 尋找相等點  \n  → Step 6: entry ← nums[entry] // 移動 entry  \n  → Step 7: slow ← nums[slow] // 同時移動 slow  \n  → Decision: entry == slow? // 再次檢查相等  \n   Yes → Return entry // 找到重複數字  \n   No → No → Continue // 未相等，繼續循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Find Median from Data Stream",
      "source_file": "Leetcode/leetcode295.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"], [[], [1], [2], [], [3], []]",
          "expected_output": "[null, null, null, 1.5, null, 2.0]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpv9mu4ffi.py\", line 60, in <module>\n    main()\n  File \"/tmp/tmpv9mu4ffi.py\", line 41, in main\n    args = eval(right)\n           ^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[[], [1], [2], [], [3], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport heapq\nimport json\n\nclass MedianFinder:\n    def __init__(self):\n        # 小根堆存放較大的那半部分\n        self.large = []\n        # 大根堆存放較小的那半部分（使用負數做為大根堆）\n        self.small = []\n\n    def addNum(self, num: int):\n        # 首先把新數加入小根堆\n        heapq.heappush(self.large, num)\n        # 確保小根堆中的最小值不小於大根堆中的最大值\n        if self.large and self.small and self.large[0] < -self.small[0]:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n        # 平衡兩堆大小，差距不超過 1\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n        elif len(self.small) > len(self.large):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n    def findMedian(self) -> float:\n        if len(self.large) > len(self.small):\n            return float(self.large[0])\n        return (-self.small[0] + self.large[0]) / 2.0\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將兩個列表分開\n    parts = data.split('],', 1)\n    left = parts[0] + ']'\n    right = '[' + parts[1].strip()\n    ops = eval(left)\n    args = eval(right)\n\n    obj = None\n    results = []\n    for op, arg in zip(ops, args):\n        if op == \"MedianFinder\":\n            obj = MedianFinder()\n            results.append(None)\n        elif op == \"addNum\":\n            obj.addNum(arg[0])\n            results.append(None)\n        elif op == \"findMedian\":\n            results.append(obj.findMedian())\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing how to implement MedianFinder with addNum and findMedian. We need to use structure: Start, Decision, etc. Use virtual code, not actual code. For median, typical solution: two heaps: max heap for lower half, min heap for upper half, keep sizes balanced, median from top of heaps.\n\nThus steps: Start, Step: Initialize two heaps, empty.\n\nAddNum: Insert into one heap, rebalance: if new number <= maxHeap.peek, add to maxHeap else minHeap. After insertion, if sizes differ by >1, move root between heaps. After rebalancing, we have size difference <=1 and all elements in maxHeap <= all in minHeap.\n\nFindMedian: If sizes equal, median is average of tops. Else median is top of larger heap.\n\nWe'll produce virtual code line by line.\n\nAlso explanation after each line.\n\nWe need arrow \"→\" between steps. Also indentation for decisions.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化兩個優先佇列: maxHeap（大根堆）和 minHeap（小根堆) // 建立存儲下半區和上半區的兩個堆\n\n→ Step 2: 定義 addNum(num) 方法 // 用於將新數字加入資料結構\n\n→ Decision: num <= maxHeap.top? // 判斷新數字是否屬於下半區\n    Yes → Step 3a: maxHeap.add(num) // 新數字放入下半區堆\n    No  → Step 3b: minHeap.add(num) // 新數字放入上半區堆\n\n→ Decision: maxHeap.size - minHeap.size > 1? // 檢查下半區是否比上半區大太多\n    Yes → Step 4a: minHeap.add(maxHeap.pop()) // 將下半區最大值移至上半區\n    No  → Decision: minHeap.size - maxHeap.size > 1? // 檢查上半區是否比下半區大太多\n        Yes → Step 4b: maxHeap.add(minHeap.pop()) // 將上半區最小值移至下半區\n        No → End // 不需要重新平衡\n\n→ Step 5: 定義 findMedian() 方法 // 用於返回目前所有元素的中位數\n\n→ Decision: maxHeap.size == minHeap.size? // 檢查兩堆大小是否相等\n    Yes → Step 6a: median = (maxHeap.top + minHeap.top) / 2.0 // 等量時取兩個頂點平均\n    No  → Decision: maxHeap.size > minHeap.size? // 判斷哪一堆較大\n        Yes → Step 6b: median = maxHeap.top // 下半區堆較大，返回其頂點\n        No  → Step 6c: median = minHeap.top // 上半區堆較大，返回其頂點\n\n→ End // MedianFinder 執行結束\n\nBut we need each line with \"虛擬碼步驟 [space] // 解釋\".\n\nAlso use \"→\" arrows between steps. And indentation for decisions.\n\nLet's produce exactly.\n\nNeed to start with \"Start // 程式開始執行\".\n\nMake sure each line ends with // 解釋.\n\nAlso ensure we maintain correct indentation for decisions: use tabs or spaces? Use indentation.\n\nWe'll produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化兩個優先佇列: maxHeap（大根堆）與 minHeap（小根堆） // 用於分別存儲資料流的下半區與上半區  \n\n→ Step 2: 定義 addNum(num) 方法 // 用於接收並加入新的整數  \n\n→ Decision: num <= maxHeap.top? // 判斷新數字是否屬於下半區  \n Yes → Step 3a: maxHeap.add(num) // 新數字放入下半區堆  \n No  → Step 3b: minHeap.add(num) // 新數字放入上半區堆  \n\n→ Decision: maxHeap.size - minHeap.size > 1? // 檢查下半區是否比上半區大太多  \n Yes → Step 4a: minHeap.add(maxHeap.pop()) // 將下半區最大值移至上半區  \n No  → Decision: minHeap.size - maxHeap.size > 1? // 檢查上半區是否比下半區大太多  \n  Yes → Step 4b: maxHeap.add(minHeap.pop()) // 將上半區最小值移至下半區  \n  No  → End // 不需要再做任何調整  \n\n→ Step 5: 定義 findMedian() 方法 // 用於計算並回傳目前所有數字的中位數  \n\n→ Decision: maxHeap.size == minHeap.size? // 判斷兩堆大小是否相等  \n Yes → Step 6a: median = (maxHeap.top + minHeap.top) / 2.0 // 兩堆相等時取兩個頂點平均  \n No  → Decision: maxHeap.size > minHeap.size? // 判斷哪一堆較大  \n  Yes → Step 6b: median = maxHeap.top // 下半區堆較大，返回其頂點  \n  No  → Step 6c: median = minHeap.top // 上半區堆較大，返回其頂點  \n\nEnd // MedianFinder 執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmphn3eqs80.py\", line 52, in parse_input\n    data = eval(text.strip())\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    intervals = [[1,3],[6,9]], newInterval = [2,5]\n              ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmphn3eqs80.py\", line 60, in <module>\n    intervals, new_interval = parse_input(input_text)\n                              ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmphn3eqs80.py\", line 55, in parse_input\n    raise ValueError(f\"Could not parse input: {exc}\")\nValueError: Could not parse input: invalid syntax (<string>, line 1)"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpev7isl85.py\", line 52, in parse_input\n    data = eval(text.strip())\n           ^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n              ^\nSyntaxError: invalid syntax\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/tmp/tmpev7isl85.py\", line 60, in <module>\n    intervals, new_interval = parse_input(input_text)\n                              ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpev7isl85.py\", line 55, in parse_input\n    raise ValueError(f\"Could not parse input: {exc}\")\nValueError: Could not parse input: invalid syntax (<string>, line 1)"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        \"\"\"\n        Insert a new interval into a sorted, non‑overlapping list of intervals,\n        merging any overlapping intervals in the process.\n        \"\"\"\n        result: List[List[int]] = []\n        i, n = 0, len(intervals)\n\n        # Add all intervals that end before the new interval starts.\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # Merge all intervals that overlap with the new interval.\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # Insert the merged new interval.\n        result.append(newInterval)\n\n        # Add the remaining intervals.\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\n\ndef parse_input(text: str):\n    \"\"\"\n    Parse the input format:\n        intervals = [[1,3],[6,9]], newInterval = [2,5]\n    into two Python lists.\n    \"\"\"\n    # Regular expression to capture the two list expressions.\n    pattern = r'intervals\\s*=\\s*(\\[[^\\]]*\\])\\s*,\\s*newInterval\\s*=\\s*(\\[[^\\]]*\\])'\n    match = re.search(pattern, text)\n    if match:\n        intervals = eval(match.group(1))\n        new_interval = eval(match.group(2))\n        return intervals, new_interval\n\n    # If the pattern didn't match, try to evaluate the whole string as a dict.\n    try:\n        data = eval(text.strip())\n        return data['intervals'], data['newInterval']\n    except Exception as exc:\n        raise ValueError(f\"Could not parse input: {exc}\")\n\n\nif __name__ == \"__main__\":\n    input_text = sys.stdin.read()\n    intervals, new_interval = parse_input(input_text)\n    result = Solution().insert(intervals, new_interval)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code flow for inserting a new interval into a sorted non-overlapping intervals array. Provide line-by-line virtual code and explanation in Traditional Chinese.\n\nWe should not output actual code; just pseudo steps with arrows and decisions. Use Start, End. Provide lines like \"→ Step 1: ...\" etc. Provide explanation after //.\n\nWe need to cover:\n\n- Initialize result list.\n- Iterate over intervals.\n- While current interval end < newInterval start: add to result.\n- While current interval start <= newInterval end: merge: newInterval.start = min, newInterval.end = max.\n- After loop, append remaining newInterval and remaining intervals.\n\nLet's produce step-by-step pseudo code.\n\nMake sure to include decisions with Yes →, No →.\n\nAlso handle merging.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空清單 // 用來儲存合併後的區間  \n→ Step 2: 初始化 i 為 0 // 迭代原始 intervals 的索引  \n→ Step 3: 取得 n 為 intervals 的長度 // 用於迴圈終止判斷  \n\n→ Decision: i < n? // 是否還有未處理的區間  \n    Yes → Decision: intervals[i].end < newInterval.start? // 現有區間完全在新區間左側  \n        Yes → Step 4: 將 intervals[i] 加入 result // 無重疊，直接加入  \n        Yes → Step 5: i ← i + 1 // 移動至下一個區間  \n        No  → Decision: intervals[i].start > newInterval.end? // 現有區間完全在新區間右側  \n            Yes → Step 6: 將 newInterval 加入 result // 新區間尚未加入  \n            Yes → Step 7: 將 intervals[i] 加入 result // 之後的所有區間直接加入  \n            Yes → Step 8: i ← n // 跳出迴圈  \n            No  → Step 9: // 發生重疊，開始合併  \n                → Decision: intervals[i].start < newInterval.start?  \n                    Yes → Step 10: newInterval.start ← intervals[i].start // 取最小起點  \n                    No  → // 起點保持不變  \n                → Decision: intervals[i].end > newInterval.end?  \n                    Yes → Step 11: newInterval.end ← intervals[i].end // 取最大終點  \n                    No  → // 終點保持不變  \n                → Step 12: i ← i + 1 // 繼續檢查下一個區間以合併更多  \n    No  → // 所有原始區間已處理完畢  \n→ Decision: 是否已將 newInterval 加入 result? // 檢查新區間是否還未加入  \n    Yes → Step 13: 將 newInterval 加入 result // 新區間尚未加入，加入之  \n    No  → // 新區間已加入，無需再處理  \n\n→ Step 14: 返回 result // 輸出合併後的區間清單  \nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n        return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 讀取全部標準輸入\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        # 解析形如 'strs = [\"eat\",\"tea\"]' 的輸入\n        if \"=\" in raw_input:\n            _, expr = raw_input.split(\"=\", 1)\n        else:\n            expr = raw_input\n        try:\n            strs = ast.literal_eval(expr.strip())\n        except Exception:\n            # 若解析失敗，直接使用空列表\n            strs = []\n    else:\n        strs = []\n\n    # 執行解法並輸出結果\n    sol = Solution()\n    result = sol.groupAnagrams(strs)\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for grouping anagrams. The task: group anagrams. So algorithm: use hash map with sorted string key. Steps: Start, input array, initialize map, for each string: sort characters to key, add to map list, after loop: output map values as list of lists. End.\n\nWe must produce each line with comment. Use \"→\" for steps. Use Decision? Maybe no decision needed.\n\nBut we can use Decision to check if key exists: Decision: key in map? Yes: add; No: create new list.\n\nSo produce lines:\n\nStart // ...\n→ Step 1: Initialize an empty hashmap 'map' // ...\n\n→ Step 2: For each string 's' in 'strs' // iterate\n\n   → Step 3: Convert 's' to list of chars, sort ascending, join to get 'key' // create sorted key\n\n   → Decision: key exists in map? // check\n\n        Yes → Step 4: Append 's' to map[key] // add to existing list\n\n        No → Step 5: map[key] = [s] // create new list\n\nAfter loop\n\n→ Step 6: Convert map.values() to list of lists and assign to 'result' // collect\n\n→ Step 7: Return 'result' // output\n\nEnd // finish\n\nMake sure each line has \"虛擬碼步驟\" + space + comment.\n\nLet's format: For decision lines, indent with 4 spaces? In example, they indent with 4 spaces? They show:\n\n    Yes → Step 2: 輸出 '正數' // ...\n\nYes, indent lines inside decision by 4 spaces. Use same.\n\nThus produce lines:\n\nStart // 程式開始執行\n→ Step 1: 初始化空哈希表 'map' // 用來存放以排序後字串為鍵的字串列表\n→ Step 2: 對陣列 'strs' 中的每個字串 's' 進行迭代 // 遍歷輸入\n    → Step 3: 將 's' 的字元排序後連結成 'key' // 取得字母排序後的標識符\n    → Decision: 'key' 是否已存在於 'map'? // 判斷是否已有此組\n        Yes → Step 4: 把 's' 加入 'map[key]' // 追加到已有的同組字串中\n        No  → Step 5: 建立新列表 'map[key] = [s]' // 新的同組字串\n→ Step 6: 把 'map' 的所有值收集成列表 'result' // 取得所有同類字串組\n→ Step 7: 回傳 'result' // 結果輸出\nEnd // 程式執行結束\n\nNeed each line \"虛擬碼步驟\" + space + comment. So each line must have something like \"Start\" or \"→ Step 1: ...\". Good.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 'map' // 用來存放以排序後字串為鍵的字串列表  \n→ Step 2: 對陣列 'strs' 中的每個字串 's' 進行迭代 // 遍歷輸入  \n  → Step 3: 將 's' 的字元排序後連結成 'key' // 取得字母排序後的標識符  \n  → Decision: 'key' 是否已存在於 'map'? // 判斷是否已有此組  \n    Yes → Step 4: 把 's' 加入 'map[key]' // 追加到已有的同組字串中  \n    No  → Step 5: 建立新列表 'map[key] = [s]' // 新的同組字串  \n→ Step 6: 把 'map' 的所有值收集成列表 'result' // 取得所有同類字串組  \n→ Step 7: 回傳 'result' // 結果輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Zuma Game",
      "source_file": "Leetcode/leetcode488.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "board = \"WRRBBW\", hand = \"RB\"",
          "expected_output": "-1",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk4q48toa.py\", line 104, in <module>\n    main()\n  File \"/tmp/tmpk4q48toa.py\", line 100, in main\n    result = find_min_steps(board, hand)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpk4q48toa.py\", line 36, in find_min_steps\n    hand_counts[COLOR_IDX[ch]] += 1\n                ~~~~~~~~~^^^^\nKeyError: '='"
        },
        {
          "example_index": 1,
          "input": "board = \"WWRRBBWW\", hand = \"WRBRW\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp7xfswnnr.py\", line 104, in <module>\n    main()\n  File \"/tmp/tmp7xfswnnr.py\", line 100, in main\n    result = find_min_steps(board, hand)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp7xfswnnr.py\", line 36, in find_min_steps\n    hand_counts[COLOR_IDX[ch]] += 1\n                ~~~~~~~~~^^^^\nKeyError: '='"
        },
        {
          "example_index": 2,
          "input": "board = \"G\", hand = \"GGGGG\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpndrsv4w4.py\", line 104, in <module>\n    main()\n  File \"/tmp/tmpndrsv4w4.py\", line 100, in main\n    result = find_min_steps(board, hand)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpndrsv4w4.py\", line 36, in find_min_steps\n    hand_counts[COLOR_IDX[ch]] += 1\n                ~~~~~~~~~^^^^\nKeyError: '='"
        }
      ],
      "generated_code": "import sys\nfrom functools import lru_cache\n\n# --------------- Helper Functions -----------------\n\ndef collapse(board: str) -> str:\n    \"\"\"Remove all groups of 3 or more consecutive same-colored balls until none remain.\"\"\"\n    changed = True\n    while changed:\n        changed = False\n        i = 0\n        new_board_parts = []\n        while i < len(board):\n            j = i\n            while j < len(board) and board[j] == board[i]:\n                j += 1\n            if j - i >= 3:               # found a removable group\n                changed = True\n                i = j                    # skip this group\n            else:\n                new_board_parts.append(board[i:j])\n                i = j\n        board = ''.join(new_board_parts)\n    return board\n\n# --------------- Main Solution ---------------------\n\nCOLOR_ORDER = ('R', 'Y', 'B', 'G', 'W')\nCOLOR_IDX = {c: i for i, c in enumerate(COLOR_ORDER)}\n\ndef find_min_steps(board: str, hand: str) -> int:\n    \"\"\"Return the minimal number of insertions needed to clear the board.\"\"\"\n    # Count balls in hand\n    hand_counts = [0] * 5\n    for ch in hand:\n        hand_counts[COLOR_IDX[ch]] += 1\n    hand_tuple = tuple(hand_counts)\n\n    INF = 10 ** 9\n\n    @lru_cache(maxsize=None)\n    def dfs(curr_board: str, counts: tuple) -> int:\n        if not curr_board:\n            return 0\n        counts_list = list(counts)\n        best = INF\n\n        # Try inserting each available color\n        for color_idx, avail in enumerate(counts_list):\n            if avail == 0:\n                continue\n            color = COLOR_ORDER[color_idx]\n\n            # Try all insertion positions\n            for pos in range(len(curr_board) + 1):\n                # Inserting at pos; check if it can trigger a removal\n                new_board = collapse(curr_board[:pos] + color + curr_board[pos:])\n                if new_board == curr_board:\n                    continue  # no removal, skip\n\n                # Use one ball of this color\n                counts_list[color_idx] -= 1\n                sub_res = dfs(new_board, tuple(counts_list))\n                if sub_res != INF:\n                    best = min(best, sub_res + 1)\n                counts_list[color_idx] += 1\n\n        return best\n\n    ans = dfs(board, hand_tuple)\n    return -1 if ans >= INF else ans\n\n# --------------- Input / Output ---------------------\n\ndef parse_input(data: str):\n    \"\"\"Parse board and hand from input data.\"\"\"\n    data = data.strip()\n    if not data:\n        return '', ''\n    # Try to find 'board = ...' and 'hand = ...'\n    lines = [line.strip() for line in data.splitlines() if line.strip()]\n    board = hand = ''\n    for line in lines:\n        if line.lower().startswith('board'):\n            parts = line.split('=', 1)\n            board = parts[1].strip().strip('\"').strip(\"'\")\n        elif line.lower().startswith('hand'):\n            parts = line.split('=', 1)\n            hand = parts[1].strip().strip('\"').strip(\"'\")\n    # If not found, assume first two tokens are board and hand\n    if not board or not hand:\n        tokens = [tok.strip().strip('\"').strip(\"'\") for tok in data.replace(',', ' ').split()]\n        if len(tokens) >= 2:\n            board, hand = tokens[0], tokens[1]\n    return board, hand\n\ndef main():\n    raw_input = sys.stdin.read()\n    board, hand = parse_input(raw_input)\n    result = find_min_steps(board, hand)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line for algorithm to solve Zuma variation. Provide explanation after each line. Use virtual code with arrows, Start, End, Decision. Not actual code. Just steps.\n\nWe need to outline algorithm: use DFS with memoization, recursion, exploring insertion positions. We can use counts of hand balls. Steps: convert hand to counts, define recursive function. Use string operations to remove groups recursively. Use DFS to try each position with available ball. Use memoization to avoid repeated states.\n\nNeed to produce steps in pseudo with explanation. We'll produce a linear flow but maybe hierarchical. Use Decision. We'll produce Start, then steps: Preprocess hand counts. Define DFS function. In DFS: if board empty return 0. If hand empty return INF. For each color in hand with count > 0: for each insertion index between balls, if insertion would create group >=3, compute removal, recursive call, track min. Use memo key board+handCounts. Use recursion. After exploring all, return min or -1.\n\nWe'll produce pseudo in natural language but with arrows. Need to follow format: each line: Virtual code step + space + // explanation.\n\nLet's produce.\n\nAlso might include functions like compress board after insertion removal.\n\nWe should also mention caching with dictionary.\n\nLet's write step by step.\n\nProbably 30-40 lines.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 handCount 為每種顏色在手中球的數量 // 將手牌轉成頻次字典  \n→ Step 2: 定義函式 DFS(board, handCount) → int // 遞迴求最小插入數  \n→   Decision: 如果 board 為空字串? // 檢查是否已經清空棋盤  \n        Yes → Return 0 // 無需再插入，已勝利  \n        No  → Decision: 若 handCount 全為 0? // 檢查是否手牌已用完  \n            Yes → Return INF // 代表此路徑失敗，無法清空  \n            No  → Step 3: 準備 memoKey ← board + “|” + handCountString // 產生唯一鍵以做記憶化  \n→   Decision: memoKey 是否已存在於 cache?  \n        Yes → Return cache[memoKey] // 直接取已計算結果  \n        No  → Step 4: minInsert ← INF // 初始化最小插入數為無限大  \n→   Decision: 對於每個顏色 c in handCount, 如果 handCount[c] > 0? // 只考慮手中有的顏色  \n        Yes → Step 5: 依序嘗試所有插入位置 i 從 0 到 board.length  \n            → Decision: 在位置 i 插入 c 之後，是否能形成至少三個同色連續球?  \n                Yes → Step 6: newBoard ← removeGroups(board, i, c) // 刪除所有形成的連鎖反應群  \n                → Step 7: handCount[c] ← handCount[c] - 1 // 使用一顆球  \n                → Step 8: result ← DFS(newBoard, handCount) // 递归求解剩餘棋盤  \n                → Decision: result 是否為 INF?  \n                    Yes → Do nothing // 此路徑失敗  \n                    No  → Step 9: minInsert ← min(minInsert, result + 1) // 更新最小插入數  \n                → Step 10: handCount[c] ← handCount[c] + 1 // 回溯，恢復手牌數量  \n            No  → Step 11: Continue // 插入位置 i 不合法，跳過  \n→   Step 12: cache[memoKey] ← minInsert // 記憶化結果  \n→   Decision: minInsert 是否為 INF?  \n        Yes → Return -1 // 無法清空棋盤  \n        No  → Return minInsert // 返回最小插入數  \n→ End // 程式執行結束  \n\n// 工具函式說明  \n→ Step 13: Function removeGroups(board, insertIndex, color) → string  \n→   // 在 board 的 insertIndex 位置插入 color，然後反覆刪除任何連續 3 個以上相同顏色的子串  \n→   → 先把 color 插入到 board 的相應位置  \n→   → 使用 while 迴圈檢查是否存在任何符合條件的群組  \n→       → 若存在，刪除該群組，並將左右兩段重新連接成新 board  \n→   → 回傳最終消除後的 board  \n→ End // removeGroups 函式結束\n\n// 取得 handCountString 的格式化方式  \n→ Step 14: Function handCountString(handCount) → string  \n→   // 按固定顏色順序 'R','Y','B','G','W' 生成「R2Y0B1G0W0」類似的字串  \n→   → 回傳該字串  \n→ End // handCountString 函式結束\n\n// 主程序入口  \n→ Step 15: ans ← DFS(board, handCount)  \n→ Step 16: Print ans // 輸出最小插入數或 -1  \nEnd // 程式執行結束"
    },
    {
      "title": "Roman to Integer",
      "source_file": "Leetcode/leetcode13.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 2,
          "input": "Input: s = \"MCMXCIV\"",
          "expected_output": "Output: 1994",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'Output:1994'\nGot (Norm):      '1993'\n--- (Raw) ---\nRaw Expected: 'Output: 1994'\nRaw Got:      '1993'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        # 將羅馬數字字母對應到其數值\n        roman_map = {\n            'I': 1, 'V': 5, 'X': 10, 'L': 50,\n            'C': 100, 'D': 500, 'M': 1000\n        }\n        total = 0\n        prev_value = 0\n        # 由右往左遍歷，方便判斷是否要減法\n        for char in reversed(s):\n            value = roman_map[char]\n            if value < prev_value:\n                total -= value   # 小於前一個數值，做減法\n            else:\n                total += value   # 否則累加\n            prev_value = value\n        return total\n\ndef extract_roman(data: str) -> str:\n    \"\"\"\n    從輸入資料中提取羅馬數字字符。\n    只保留 I, V, X, L, C, D, M，忽略其他字符。\n    \"\"\"\n    return ''.join(ch for ch in data if ch in 'IVXLCDM')\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read()\n    # 從輸入中提取純羅馬數字字串\n    roman_str = extract_roman(raw_input.strip())\n    # 若輸入是空的或不合法，直接輸出 0\n    if not roman_str:\n        print(0)\n    else:\n        result = Solution().romanToInt(roman_str)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for converting Roman numeral to integer. Use structure Start, Decision, etc. Provide explanation after each line. Must not output actual code. Just virtual code lines with explanations. Format: \"虛擬碼步驟 // 解釋\". Use arrow →, Yes →, No →. We'll outline algorithm: iterate over string, map char to value. Add value, but if current < next, subtract. Alternatively use decisions. We'll produce steps: Start, Input string, Initialize total = 0, index = 0, length. Decision: index < length? Yes: get current value, Decision: index+1 < length and current < next? Yes: subtract current, else add. increment index by 1 or 2 accordingly. At end, output total. We'll include decisions for subtraction mapping. We'll maintain mapping via Decision: char is I? etc but better to use mapping array. We'll produce pseudo steps. Use \"Step X:\" etc. Let's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取輸入字串 s // 取得待轉換的羅馬數字  \n→ Step 2: 設定 total = 0, i = 0 // 用來累計整數值與索引  \n→ Step 3: 定義 map(char) → value // 建立符號到數值的對應表（I=1, V=5, X=10, L=50, C=100, D=500, M=1000）  \n→ Decision: i < s.length? // 是否還有字元未處理  \n Yes → Step 4: current = map(s[i]) // 取得目前字元對應的數值  \n Yes → Decision: i+1 < s.length AND current < map(s[i+1])? // 檢查是否為減法情況  \n  Yes → Step 5: total = total - current // 目前小於下一個，做減法  \n  Yes → Step 6: i = i + 1 // 只移動一個字元  \n  No → Step 7: total = total + current // 正常累加  \n  No → Step 8: i = i + 1 // 只移動一個字元  \n No → Step 9: 輸出 total // 所有字元處理完畢，輸出最終整數  \nEnd // 程式執行結束"
    },
    {
      "title": "Mini Parser",
      "source_file": "Leetcode/leetcode385.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "s = \"[123,[456,[789]]]\"",
          "expected_output": "[123,[456,[789]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[123,[456,[789]]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[123,[456,[789]]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\n\nclass NestedInteger:\n    def __init__(self, value=None):\n        if value is None:\n            self._list = []\n            self._is_integer = False\n        else:\n            self._is_integer = True\n            self._integer = value\n\n    def isInteger(self):\n        return self._is_integer\n\n    def add(self, elem):\n        if not self._is_integer:\n            self._list.append(elem)\n\n    def setInteger(self, value):\n        self._is_integer = True\n        self._integer = value\n\n    def getInteger(self):\n        return self._integer if self._is_integer else None\n\n    def getList(self):\n        return self._list if not self._is_integer else None\n\n    def __repr__(self):\n        if self._is_integer:\n            return str(self._integer)\n        return '[' + ','.join(repr(e) for e in self._list) + ']'\n\n\nclass Solution:\n    def deserialize(self, s: str) -> NestedInteger:\n        # 直接為單一整數的情況\n        if not s or s[0] != '[':\n            return NestedInteger(int(s))\n\n        stack = []\n        num = ''\n        negative = False\n\n        for c in s:\n            if c == '[':\n                stack.append(NestedInteger())\n            elif c == ']':\n                if num:\n                    value = int(num)\n                    if negative:\n                        value = -value\n                    stack[-1].add(NestedInteger(value))\n                    num = ''\n                    negative = False\n                # 把完成的列表 pop 出來並加到上一層\n                completed = stack.pop()\n                if stack:\n                    stack[-1].add(completed)\n            elif c == ',':\n                if num:\n                    value = int(num)\n                    if negative:\n                        value = -value\n                    stack[-1].add(NestedInteger(value))\n                    num = ''\n                    negative = False\n            elif c == '-':\n                negative = True\n            elif c.isdigit():\n                num += c\n\n        # 最後可能還有未加入的數字 (如單一整數形式)\n        if num:\n            value = int(num)\n            if negative:\n                value = -value\n            stack[-1].add(NestedInteger(value))\n\n        return stack[0] if stack else NestedInteger()\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，去除前後空白\n    raw_input = sys.stdin.read().strip()\n\n    # 從可能的形如 s = \"...\" 取得字串內容\n    first_quote = raw_input.find('\"')\n    last_quote = raw_input.rfind('\"')\n    if first_quote != -1 and last_quote != -1 and last_quote > first_quote:\n        s = raw_input[first_quote + 1:last_quote]\n    else:\n        s = raw_input  # 若沒有引號直接使用整個輸入\n\n    solution = Solution()\n    result = solution.deserialize(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation for parsing nested list string into NestedInteger. The output must be in Chinese (繁體) and follow format.\n\nWe need to produce virtual code step by step. Use arrows →, Decision: etc. No actual code.\n\nWe need to include steps: Start, read string, if single integer, return. Else process using stack. Use for loop over characters. Handle numbers, negative sign, commas, brackets.\n\nLet's produce a clear algorithm.\n\nUse stack of NestedInteger. For each char:\n\nIf '[': push new NestedInteger into stack.\n\nIf ']' : finalize current integer if any, pop and add to previous.\n\nIf digit or '-': accumulate number.\n\nIf ',' : finalize current integer if any.\n\nAt end return stack top.\n\nWe need to incorporate decision steps like when char is '[' etc.\n\nWe'll produce virtual code with arrows. Each line will be \"Step x: ...\" etc. Provide explanation in comment.\n\nLet's produce.\n\nRemember each line: Virtual step + space + // explanation.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 若 s 為空字串, 回傳 空 NestedInteger // 確認輸入有效  \n→ Decision: s 是否為單一整數? // 檢查是否沒有 '['  \n    Yes → Step 2: 建立 NestedInteger 整數 = 整數值 of s // 直接轉換  \n    No  → Step 3: 建立空 Stack<NestedInteger> st // 用於存放尚未完成的列表  \n\n→ Step 4: 初始化變數 numStr = 空字串 // 用於暫存多位數字  \n→ Step 5: 初始化變數 current = 空 // 目前處理的 NestedInteger  \n\n→ For each character c in s: // 遍歷整個序列  \n    Decision: c == '['? // 開始一個新列表  \n        Yes → Step 6: 若 current 不是 空, 把 current 加到 st 的頂層 // 把前一個整數或列表加入父層  \n            No → Step 7: 建立新的 NestedInteger list, 放入 st, 並設 current = 該列表 // 進入子層  \n    Decision: c == ']'? // 結束當前列表  \n        Yes → Step 8: 若 numStr 非空, 將 numStr 轉整數並加入 current // 處理最後一個整數  \n              No → Step 9: 若 current 不是空, 把 current 加到 st 的上一層 // 將整個子列表添加回父層  \n            Step 10: pop st, 設 current = pop() // 退出子層  \n            Step 11: 如果 st 非空, current = st.top() // 更新為父層列表  \n    Decision: c == ','? // 列表元素分隔符  \n        Yes → Step 12: 若 numStr 非空, 將 numStr 轉整數並加入 current // 將分隔前的整數加入列表  \n                  並清空 numStr // 重置暫存  \n            No → Step 13: 若 c 是 '-' 或數字, 將 c 加到 numStr // 構造多位數或負數  \n    Decision: c 不是 ',','[',']'? // 其他字符已在第13步處理  \n\n→ After loop ends, if numStr 非空, 將 numStr 轉整數並加入 current // 處理最後一個整數 (若字串以整數結束)  \n\n→ Step 14: 若 st 非空, current = st.pop() // 把最外層列表取出  \n\nEnd // 程式執行結束，返回 current 作為反序列化結果\n\n// 備註：此虛擬碼使用堆疊方式追蹤嵌套結構，逐字符解析並組裝 NestedInteger 物件。"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2]'\nGot (Norm):      '[1]'\n--- (Raw) ---\nRaw Expected: '[2]'\nRaw Got:      '[1]'"
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,8]'\nGot (Norm):      '[5,1]'\n--- (Raw) ---\nRaw Expected: '[2,8]'\nRaw Got:      '[5, 1]'"
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,8,10]'\nGot (Norm):      '[1,5,9]'\n--- (Raw) ---\nRaw Expected: '[3,8,10]'\nRaw Got:      '[1, 5, 9]'"
        }
      ],
      "generated_code": "import random\n\n# 假設已經有一個 API rand7() 可用\ndef rand7():\n    return random.randint(1, 7)\n\nclass Solution:\n    def rand10(self):\n        while True:\n            # 使用兩次 rand7 生成 1~49 的均勻分布\n            num = (rand7() - 1) * 7 + rand7()  # 1~49\n            if num <= 40:\n                return 1 + (num - 1) % 10\n\ndef main():\n    import sys, re\n    data = sys.stdin.read()\n    nums = re.findall(r'-?\\d+', data)\n    if not nums:\n        return\n    n = int(nums[0])\n    sol = Solution()\n    res = [sol.rand10() for _ in range(n)]\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code for rand10() using rand7(). We can use rejection sampling: generate two rand7 calls to get numbers 1-49, map to 1-40 via reject if >40. Then map 1-40 to 1-10 by modulo. Or use 49 mapping to 10 using 1-10. We need to output step-by-step with explanations. Use Start, Decision, etc.\n\nWe need to produce only virtual code, not actual code. Each line must have \"虛擬碼步驟 // 解釋\". Include arrow and decision formatting.\n\nWe'll produce algorithm:\n\nStart\n→ Step 1: Repeat\n    → Step 2: a = rand7() // get first random\n    → Step 3: b = rand7() // get second random\n    → Step 4: val = (a -1) * 7 + b // map to 1-49\n    → Decision: If val ≤ 40? // accept if within 40\n        Yes → Step 5: return ((val - 1) mod 10) + 1 // map to 1-10\n        No → Step 6: Go back to Step 2 (repeat)\n\nBut need to use virtual code lines with indentation. Use Decision and arrows.\n\nWe must follow example formatting. Use \"Decision:\" lines and then indented Yes/No arrows. Use \"→\" arrows.\n\nMake sure each line has explanation. Provide virtual code lines. Use \"End\" at bottom.\n\nWe'll create:\n\nStart // 程式開始執行\n→ Step 1:  // 開始產生 rand10\n    → Decision: 生成兩個 rand7? // 產生兩個隨機數\n        Yes → Step 2: a = rand7() // 取得第一個隨機數\n        No  → End // 這裡不需要No branch\n    → Step 3: b = rand7() // 取得第二個隨機數\n    → Step 4: val = (a - 1) * 7 + b // 將兩個數合併為 1-49\n    → Decision: val <= 40? // 判斷是否接受\n        Yes → Step 5: return ((val - 1) % 10) + 1 // 轉換為 1-10 並返回\n        No  → Step 1: // 重新開始，重試\n\nBut we need to keep indentation. In example they indent within Decision. Use spaces before Yes/No lines.\n\nAlso need to include \"End\" after loop? Actually return ends loop.\n\nWe might need a loop structure: Use \"Loop\" or \"Repeat\". Could do:\n\n→ Step 1: Loop Start // 進入重複區塊\n    → Step 2: a = rand7() // ...\n    → Step 3: b = rand7()\n    → Step 4: val = ...\n    → Decision: val <= 40? \n        Yes → Step 5: return ((val-1)%10)+1\n        No  → Step 1: // loop again\n\nBut we need to avoid infinite recursion.\n\nWe can represent loop by reusing Step 1 arrow.\n\nMaybe easier: Use while loop pseudo:\n\n→ Step 1: // 循環直到得到合法值\n    → Step 2: a = rand7()\n    → Step 3: b = rand7()\n    → Step 4: val = (a - 1) * 7 + b\n    → Decision: val <= 40?\n        Yes → Step 5: return ((val-1)%10)+1\n        No  → Step 1: // 重新開始循環\n\nThen End after return? Not necessary.\n\nLet's produce final.\n\nWe must also consider that return ends function, so End line may not appear. But we can still include End for completeness.\n\nLet's craft final output lines:\n\nStart // 程式開始執行\n→ Step 1: // 進入重複區塊，尋找合法數字\n    → Step 2: a = rand7() // 產生第一個 1~7 的隨機數\n    → Step 3: b = rand7() // 產生第二個 1~7 的隨機數\n    → Step 4: val = (a - 1) * 7 + b // 將兩個數轉為 1~49 的數字\n    → Decision: val <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: return ((val - 1) % 10) + 1 // 轉換為 1~10 並回傳\n        No  → Step 1: // 超過 40，重新開始循環\nEnd // 程式執行結束\n\nBut need indentation for Step lines. Use spaces before them. Example uses spaces. Provide exactly as in example: each line with \"→\" at start and indentation for sublines. Let's produce:\n\nStart // 程式開始執行\n→ Step 1: // 進入重複區塊，尋找合法數字\n    → Step 2: a = rand7() // 產生第一個 1~7 的隨機數\n    → Step 3: b = rand7() // 產生第二個 1~7 的隨機數\n    → Step 4: val = (a - 1) * 7 + b // 將兩個數轉為 1~49 的數字\n    → Decision: val <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: return ((val - 1) % 10) + 1 // 轉換為 1~10 並回傳\n        No  → Step 1: // 超過 40，重新開始循環\nEnd // 程式執行結束\n\nBut we need to keep consistent indentation for Yes/No lines: use two spaces before Yes arrow maybe. Example uses \"Yes →\" with no indentation after arrow. Let's replicate: inside Decision block, indent one level. Example:\n\nDecision: If數字大於 0? \n    Yes → Step 2...\n    No  → Decision...\n\nSo use same: inside Decision block indent with 4 spaces? In example they indent by 4 spaces before Yes arrow. We'll do similar.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: // 進入重複區塊，尋找合法數字\n    → Step 2: a = rand7() // 產生第一個 1~7 的隨機數\n    → Step 3: b = rand7() // 產生第二個 1~7 的隨機數\n    → Step 4: val = (a - 1) * 7 + b // 將兩個數轉為 1~49 的數字\n    → Decision: val <= 40? // 檢查是否在可接受範圍\n        Yes → Step 5: return ((val - 1) % 10) + 1 // 轉換為 1~10 並回傳\n        No  → Step 1: // 超過 40，重新開始循環\nEnd // 程式執行結束\n\nCheck formatting: \"Step 1:\" line with // comment. In example, Step 1 line had colon. We'll keep same.\n\nBut in example, they used \"Step 1:\" after arrow. We'll keep.\n\nMake sure each line has \"虛擬碼步驟 // 解釋\" separated by space after code.\n\nOk.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: // 進入重複區塊，尋找合法數字  \n  → Step 2: a = rand7() // 產生第一個 1~7 的隨機數  \n  → Step 3: b = rand7() // 產生第二個 1~7 的隨機數  \n  → Step 4: val = (a - 1) * 7 + b // 將兩個數轉為 1~49 的數字  \n  → Decision: val <= 40? // 檢查是否在可接受範圍  \n    Yes → Step 5: return ((val - 1) % 10) + 1 // 轉換為 1~10 並回傳  \n    No  → Step 1: // 超過 40，重新開始循環  \nEnd // 程式執行結束"
    },
    {
      "title": "Rotate Function",
      "source_file": "Leetcode/leetcode396.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [4,3,2,6]",
          "expected_output": "26",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '26'\nGot (Norm):      '34'\n--- (Raw) ---\nRaw Expected: '26'\nRaw Got:      '34'"
        }
      ],
      "generated_code": "class Solution:\n    def maxRotateFunction(self, nums):\n        n = len(nums)\n        if n == 0:\n            return 0\n        total = sum(nums)\n        # 初始 F(0)\n        F = sum(i * num for i, num in enumerate(nums))\n        max_val = F\n        # 逐步推算 F(k) 並更新最大值\n        for i in range(1, n):\n            F = F + total - n * nums[i - 1]\n            if F > max_val:\n                max_val = F\n        return max_val\n\nif __name__ == \"__main__\":\n    import sys, re\n    # 從標準輸入讀取所有資料\n    data = sys.stdin.read()\n    # 取出所有整數（包含負號）\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    sol = Solution()\n    print(sol.maxRotateFunction(nums))",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with comments explaining. The problem: rotation function F(k). Want maximum. Standard solution: compute sum of array, compute F(0) then iterate to get others via formula F(k) = F(k-1) + sum - n * arr[k-1]. Or use prefix sums. But we need to output virtual code steps. Provide steps for algorithm.\n\nWe should produce steps:\n\nStart\n→ Step 1: Compute sum of all elements // total sum\n→ Step 2: Compute initial rotation function value F(0) = sum over i * nums[i] // initial\n→ Step 3: Initialize maxVal = F(0) // store maximum\n→ Step 4: For i from 0 to n-2 (since we will compute F(i+1)):\n    → Decision: ...\nBut we need to follow format. Use arrow notation.\n\nWe should produce steps, each line as \"虛擬碼步驟 // 解釋\".\n\nWe need to include loops and decisions. Use \"For i in range(n-1):\" etc. But need to keep simple.\n\nWe should also consider that we might use indexing.\n\nWe can produce:\n\nStart\n→ Step 1: 計算 n = len(nums) // 取得陣列長度\n→ Step 2: sumAll = 0\n→ Step 3: For i from 0 to n-1: sumAll += nums[i] // 求元素總和\n→ Step 4: current = 0\n→ Step 5: For i from 0 to n-1: current += i * nums[i] // 計算 F(0)\n→ Step 6: maxVal = current\n→ Step 7: For i from 0 to n-2:\n    → current = current + sumAll - n * nums[i] // 更新 F(i+1)\n    → Decision: current > maxVal?\n        Yes → maxVal = current\n        No → // do nothing\n→ End // 回傳 maxVal\n\nBut we need to produce \"→\" for steps. For loops we can show as \"→ For i in range(n-1):\". Also decision inside.\n\nWe must not output actual code. Just virtual code steps. Use \"Start\" and \"End\". So each line: virtual code step + comment.\n\nWe need to ensure each line includes the arrow (→) and comment.\n\nLet's structure:\n\nStart // 程式開始\n\n→ Step 1: n = length of nums // 取得陣列長度\n\n→ Step 2: sumAll = 0 // 用來存儲元素總和\n\n→ Step 3: For i from 0 to n-1: sumAll += nums[i] // 求總和\n\n→ Step 4: current = 0 // 初始旋轉函數值\n\n→ Step 5: For i from 0 to n-1: current += i * nums[i] // 計算 F(0)\n\n→ Step 6: maxVal = current // 設定目前最大值\n\n→ Step 7: For i from 0 to n-2:\n    → current = current + sumAll - n * nums[i] // 由前一個旋轉得到下一個\n    → Decision: current > maxVal? \n        Yes → maxVal = current // 更新最大值\n        No  → // 不做任何事\nEnd // 回傳 maxVal\n\nBut each line must be \"虛擬碼步驟 // 解釋\" with \"→\" arrow preceding each step except Start? The example shows Start line has no arrow. The example: \"Start // 程式開始執行\". Then arrow lines for steps. So for loops and decisions inside we indent? The example uses indentation with spaces before arrow? They indent for nested steps. We can produce similar indentation.\n\nWe need to include \"Decision:\" for decision lines. For loops we use \"For i in range(...):\". Provide nested lines with indentation.\n\nThus:\n\nStart // 程式開始執行\n→ Step 1: n = length(nums) // 取得陣列長度\n→ Step 2: sumAll = 0 // 初始化總和為0\n→ Step 3: For i = 0 to n-1:\n    → sumAll += nums[i] // 累加元素求總和\n→ Step 4: current = 0 // 初始化旋轉函數值\n→ Step 5: For i = 0 to n-1:\n    → current += i * nums[i] // 計算 F(0)\n→ Step 6: maxVal = current // 設定最大值為 F(0)\n→ Step 7: For i = 0 to n-2:\n    → current = current + sumAll - n * nums[i] // 從 F(i) 推算 F(i+1)\n    → Decision: current > maxVal? // 判斷是否更新最大值\n        Yes → maxVal = current // 更新最大值\n        No  → // 無需更新\nEnd // 回傳 maxVal\n\nYes. Provide that.\n\nAlso we might want to mention return maxVal. So End includes return.\n\nThus final.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: n = length(nums) // 取得陣列長度  \n→ Step 2: sumAll = 0 // 初始化總和為 0  \n→ Step 3: For i = 0 to n-1:  \n  → sumAll += nums[i] // 累加元素求總和  \n→ Step 4: current = 0 // 初始化旋轉函數值 F(0)  \n→ Step 5: For i = 0 to n-1:  \n  → current += i * nums[i] // 計算 F(0) 的值  \n→ Step 6: maxVal = current // 設定目前最大值為 F(0)  \n→ Step 7: For i = 0 to n-2:  \n  → current = current + sumAll - n * nums[i] // 由 F(i) 推算 F(i+1)  \n  → Decision: current > maxVal? // 判斷是否更新最大值  \n    Yes → maxVal = current // 更新最大值  \n    No  → // 無需更新  \nEnd // 回傳 maxVal (最大旋轉函數值)"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvx_ok1fd.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpvx_ok1fd.py\", line 41, in main\n    args_list = json.loads(parts[1])\n                ^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/__init__.py\", line 346, in loads\n    return _default_decoder.decode(s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 337, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, 0).end())\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/json/decoder.py\", line 353, in raw_decode\n    obj, end = self.scan_once(s, idx)\n               ^^^^^^^^^^^^^^^^^^^^^^\njson.decoder.JSONDecodeError: Expecting ',' delimiter: line 1 column 14 (char 13)"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]\n        # Binary Indexed Tree (Fenwick Tree)\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._add(i + 1, nums[i])\n\n    def _add(self, idx, delta):\n        while idx <= self.n:\n            self.tree[idx] += delta\n            idx += idx & -idx\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._add(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, idx):\n        res = 0\n        while idx > 0:\n            res += self.tree[idx]\n            idx -= idx & -idx\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 分離兩個列表：命令與參數\n    parts = data.replace('],', ']|').split('|')\n    commands = json.loads(parts[0])\n    args_list = json.loads(parts[1])\n\n    obj = None\n    results = []\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"NumArray\":\n            obj = NumArray(args[0])\n            results.append(None)\n        elif cmd == \"update\":\n            obj.update(args[0], args[1])\n            results.append(None)\n        elif cmd == \"sumRange\":\n            results.append(obj.sumRange(args[0], args[1]))\n        else:\n            results.append(None)\n\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for implementing a NumArray class with initialization, update, and sumRange, likely using a segment tree or Fenwick tree. Since it's virtual code, we can outline steps.\n\nWe need to produce line by line, each line: \"虛擬碼步驟 // 解釋/說明\".\n\nUse arrows, Start, End, Decision.\n\nLet's produce a high-level algorithm: use Fenwick tree.\n\nSteps:\n\nStart // start\n→ Step 1: 定義 NumArray 類 // class definition\n→ Step 2: 定義私有屬性: 原始陣列 nums, fenwick tree fenw // store array and BIT\n→ Step 3: 構造函式 NumArray(nums): copy nums, build fenwick tree // init\n→ Step 4: update(index, val): 計算 diff = val - nums[index]; nums[index] = val; fenwick.add(index, diff) // update\n→ Step 5: sumRange(left, right): return fenwick.prefixSum(right) - fenwick.prefixSum(left-1) // range sum\n→ Step 6: fenwick.add(i, delta): while i < n: tree[i] += delta; i += i & -i // BIT add\n→ Step 7: fenwick.prefixSum(i): res = 0; while i > 0: res += tree[i]; i -= i & -i // BIT prefix sum\n→ End\n\nBut must use arrows. Also can break into Decision: maybe check boundaries. But not necessary.\n\nWe need to adhere to output format: each line as virtual code step with explanation.\n\nLet's produce each step like:\n\nStart // 程式開始執行\n→ Step 1: 定義類 NumArray // 創建類\n→ Step 2: 宣告私有屬性 nums, fenwickTree // 儲存數組與樹\n→ Step 3: NumArray(numsInput):  // 構造\n    → Copy numsInput to nums\n    → 建立 fenwickTree 大小 n\n    → For i 0..n-1: fenwick.add(i, nums[i]) // 初始樹\n→ Step 4: void update(index, val):\n    → diff = val - nums[index]\n    → nums[index] = val\n    → fenwick.add(index, diff)\n→ Step 5: int sumRange(left, right):\n    → return fenwick.prefixSum(right) - fenwick.prefixSum(left-1)\n→ Step 6: fenwick.add(i, delta):\n    → while i < n:\n        → tree[i] += delta\n        → i += i & -i\n→ Step 7: fenwick.prefixSum(i):\n    → res = 0\n    → while i > 0:\n        → res += tree[i]\n        → i -= i & -i\n    → return res\nEnd // 程式結束\n\nNeed to add // explanations. Use Chinese.\n\nAlso use arrow for nested steps.\n\nLet's format:\n\nStart // 程式開始執行\n→ Step 1: 定義類 NumArray // 創建 NumArray 類\n→ Step 2: 宣告私有屬性 nums, fenwickTree // 儲存原始陣列與樹結構\n→ Step 3: NumArray(numsInput): // 構造函式\n    → Copy numsInput to nums // 讓內部陣列與輸入一致\n    → 初始化 fenwickTree 大小 n // 建立 BIT\n    → For i 0 to n-1:\n        → fenwickTree.add(i, nums[i]) // 構建樹\n→ Step 4: void update(index, val): // 更新指定位置\n    → diff = val - nums[index] // 計算差值\n    → nums[index] = val // 更新原始陣列\n    → fenwickTree.add(index, diff) // 更新樹\n→ Step 5: int sumRange(left, right): // 取得區間和\n    → return fenwickTree.prefixSum(right) - fenwickTree.prefixSum(left-1) // 兩個前綴和相減\n→ Step 6: fenwickTree.add(i, delta): // BIT 增量\n    → while i < n:\n        → tree[i] += delta // 加入差值\n        → i += i & -i // 移動到父節點\n→ Step 7: fenwickTree.prefixSum(i): // BIT 前綴和\n    → res = 0\n    → while i > 0:\n        → res += tree[i] // 累加\n        → i -= i & -i // 移動到父節點\n    → return res\nEnd // 程式結束執行\n\nNeed to ensure each line has a single virtual code step and explanation. But nested lines should be separate lines. The instruction says: \"每行必須包含：虛擬碼步驟 + [空格] + // 解釋/說明\". So each line must be one step. Indentation not necessary but we can separate.\n\nWe need to use arrows for decisions. There are no decisions, but we can still use arrow for start. Use \"→\" for next step. For nested steps we can also indent with arrows. But we need to maintain single step per line.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類 NumArray // 創建 NumArray 類\n→ Step 2: 宣告私有屬性 nums, fenwickTree // 儲存原始陣列與樹結構\n→ Step 3: NumArray(numsInput): // 構造函式\n→ Step 3.1: Copy numsInput to nums // 讓內部陣列與輸入一致\n→ Step 3.2: 初始化 fenwickTree 大小 n // 建立 BIT\n→ Step 3.3: For i 0 to n-1:\n→ Step 3.3.1: fenwickTree.add(i, nums[i]) // 構建樹\n→ Step 4: void update(index, val): // 更新指定位置\n→ Step 4.1: diff = val - nums[index] // 計算差值\n→ Step 4.2: nums[index] = val // 更新原始陣列\n→ Step 4.3: fenwickTree.add(index, diff) // 更新樹\n→ Step 5: int sumRange(left, right): // 取得區間和\n→ Step 5.1: return fenwickTree.prefixSum(right) - fenwickTree.prefixSum(left-1) // 前綴和相減\n→ Step 6: fenwickTree.add(i, delta): // BIT 增量\n→ Step 6.1: while i < n:\n→ Step 6.1.1: tree[i] += delta // 加入差值\n→ Step 6.1.2: i += i & -i // 移動到父節點\n→ Step 7: fenwickTree.prefixSum(i): // BIT 前綴和\n→ Step 7.1: res = 0\n→ Step 7.2: while i > 0:\n→ Step 7.2.1: res += tree[i] // 累加\n→ Step 7.2.2: i -= i & -i // 移動到父節點\n→ Step 7.3: return res\nEnd // 程式結束執行\n\nMake sure each line has \"虛擬碼步驟 // 解釋\". The above lines use \"Step X\" as step description. Should be fine.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義類 NumArray // 創建 NumArray 類  \n→ Step 2: 宣告私有屬性 nums, fenwickTree // 儲存原始陣列與樹結構  \n→ Step 3: NumArray(numsInput): // 構造函式  \n→ Step 3.1: Copy numsInput to nums // 讓內部陣列與輸入一致  \n→ Step 3.2: 初始化 fenwickTree 大小 n // 建立 BIT  \n→ Step 3.3: For i 0 to n-1: // 建立樹的循環  \n→ Step 3.3.1: fenwickTree.add(i, nums[i]) // 把每個元素加入 BIT  \n→ Step 4: void update(index, val): // 更新指定位置  \n→ Step 4.1: diff = val - nums[index] // 計算差值  \n→ Step 4.2: nums[index] = val // 更新原始陣列  \n→ Step 4.3: fenwickTree.add(index, diff) // 在 BIT 中更新差值  \n→ Step 5: int sumRange(left, right): // 取得區間和  \n→ Step 5.1: return fenwickTree.prefixSum(right) - fenwickTree.prefixSum(left-1) // 前綴和相減得到範圍和  \n→ Step 6: fenwickTree.add(i, delta): // BIT 增量操作  \n→ Step 6.1: while i < n: // 循環更新父節點  \n→ Step 6.1.1: tree[i] += delta // 把差值加入節點  \n→ Step 6.1.2: i += i & -i // 移動到父節點  \n→ Step 7: fenwickTree.prefixSum(i): // BIT 前綴和查詢  \n→ Step 7.1: res = 0 // 初始化結果  \n→ Step 7.2: while i > 0: // 循環向父節點累加  \n→ Step 7.2.1: res += tree[i] // 累加節點值  \n→ Step 7.2.2: i -= i & -i // 移動到父節點  \n→ Step 7.3: return res // 返回前綴和  \nEnd // 程式結束執行"
    },
    {
      "title": "Expression Add Operators",
      "source_file": "Leetcode/leetcode282.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num = \"123\", target = 6",
          "expected_output": "[\"1*2*3\",\"1+2+3\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"1*2*3\",\"1+2+3\"]'\nGot (Norm):      '[\"1+2+3\",\"1*2*3\"]'\n--- (Raw) ---\nRaw Expected: '[\"1*2*3\",\"1+2+3\"]'\nRaw Got:      \"['1+2+3', '1*2*3']\""
        },
        {
          "example_index": 1,
          "input": "num = \"232\", target = 8",
          "expected_output": "[\"2*3+2\",\"2+3*2\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"2*3+2\",\"2+3*2\"]'\nGot (Norm):      '[\"2+3*2\",\"2*3+2\"]'\n--- (Raw) ---\nRaw Expected: '[\"2*3+2\",\"2+3*2\"]'\nRaw Got:      \"['2+3*2', '2*3+2']\""
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addOperators(self, num: str, target: int):\n        res = []\n\n        def backtrack(index: int, path: str, value: int, last: int):\n            if index == len(num):\n                if value == target:\n                    res.append(path)\n                return\n            for i in range(index + 1, len(num) + 1):\n                temp = num[index:i]\n                if len(temp) > 1 and temp[0] == '0':\n                    continue\n                curr = int(temp)\n                if index == 0:\n                    backtrack(i, temp, curr, curr)\n                else:\n                    backtrack(i, path + '+' + temp, value + curr, curr)\n                    backtrack(i, path + '-' + temp, value - curr, -curr)\n                    backtrack(i, path + '*' + temp, value - last + last * curr, last * curr)\n\n        backtrack(0, '', 0, 0)\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    num_match = re.search(r'num\\s*=\\s*\"([^\"]*)\"', data)\n    target_match = re.search(r'target\\s*=\\s*(-?\\d+)', data)\n    if not (num_match and target_match):\n        return\n    num = num_match.group(1)\n    target = int(target_match.group(1))\n    sol = Solution()\n    result = sol.addOperators(num, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for problem: expression add operators to reach target. Use backtracking recursion. Provide virtual code lines. Each line \"虛擬碼步驟\" then explanation. Use Start, End, Decision, etc.\n\nWe must not output actual code but pseudocode style. Provide lines.\n\nLet's design steps:\n\nStart\n\n→ Step 1: 定義遞迴函數 dfs(index, path, eval, prev) // index current position, path string built, eval current evaluated value, prev last operand for multiplication\n\n→ Decision: index == len(num)？ // base case\n\n→ Yes → Decision: eval == target? // if expression complete and matches target\n\n→ Yes → Step 2: 將 path 加入結果集 // record\n\n→ No → End recursion\n\n→ No → Continue\n\n→ Decision: 迭代 i from index to len(num)-1\n\n→ Decision: 子字串 num[index:i+1] 具有前導零且長度>1？ // skip leading zeros\n\n→ No → Step 3: 轉為數值 cur\n\n→ Decision: index == 0? // first operand\n\n→ Yes → Step 4: 進行 dfs(i+1, cur, cur, cur) // no operator\n\n→ No → Step 5: 進行 dfs(i+1, path+'+'+cur, eval+cur, cur) // 加\n\n→ Step 6: 進行 dfs(i+1, path+'-'+cur, eval-cur, -cur) // 減\n\n→ Step 7: 進行 dfs(i+1, path+'*'+cur, eval-prev+prev*cur, prev*cur) // 乘，調整 eval\n\nEnd\n\nBut need to produce per line.\n\nAlso need to explain each line. Use \"虛擬碼步驟\" and comment.\n\nLet's produce step lines accordingly. Use arrow and indentation.\n\nWe need to ensure each line has \"虛擬碼步驟\" + \" // 解釋\". Use the arrow.\n\nLet's produce as:\n\nStart // 程式開始\n\n→ Step 1: 定義遞迴函數 dfs(index, path, eval, prev) // 定義遞迴參數\n\nThen steps.\n\nWe also need to include Decision: lines.\n\nWe'll use:\n\n→ Decision: index == len(num) ? // 檢查是否已處理完所有數字\n\nYes → Decision: eval == target? // 判斷結果是否符合目標\n\nYes → Step 2: 將 path 加入結果集 // 記錄符合的表達式\n\nNo → End // 返回上一層\n\nNo → Continue\n\nBut we must include indentation maybe with spaces. Use arrow and indentation like \"    Yes →\". We'll keep consistent.\n\nLet's craft final output.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: 定義遞迴函數 dfs(index, path, eval, prev) // index: 當前處理到的索引，path: 已經組成的字串，eval: 目前算式的值，prev: 上一次算式的末項（用於乘法調整）\n→ Decision: index == len(num) ? // 判斷是否已經處理完所有位元\n    Yes → Decision: eval == target ? // 若已完成，檢查算式結果是否符合目標\n        Yes → Step 2: 將 path 加入結果集 // 找到一個符合條件的表達式，加入結果列表\n        No  → End // 計算結果不符，結束此遞迴分支\n    No  → Step 3: 從 index 開始迭代到 len(num)-1 // 嘗試所有可能的數字段\n→ Decision: 子字串 num[index:i+1] 前導零且長度>1 ? // 先檢查是否為不合法的前導零\n    Yes → Continue // 若不合法則跳過這個子字串\n    No  → Step 4: 轉為數值 cur = int(num[index:i+1]) // 取得目前子字串轉為整數\n→ Decision: index == 0 ? // 如果是第一個子字串，無需加運算符\n    Yes → Step 5: dfs(i+1, cur, cur, cur) // 直接以 cur 作為第一項進行遞迴\n    No  → Step 6: dfs(i+1, path + \"+\" + cur, eval + cur, cur) // 加號\n        Step 7: dfs(i+1, path + \"-\" + cur, eval - cur, -cur) // 減號\n        Step 8: dfs(i+1, path + \"*\" + cur, eval - prev + prev * cur, prev * cur) // 乘號（先抵消 prev，再加入乘積）\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6rgs26z2.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp6rgs26z2.py\", line 34, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpct4qilre.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmpct4qilre.py\", line 34, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp950k42fi.py\", line 41, in <module>\n    main()\n  File \"/tmp/tmp950k42fi.py\", line 34, in main\n    exec(data, globals())\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\nclass Solution:\n    def calcEquation(self, equations, values, queries):\n        graph = defaultdict(dict)\n        for (a, b), val in zip(equations, values):\n            graph[a][b] = val\n            graph[b][a] = 1 / val\n\n        def dfs(src, dst, visited):\n            if src not in graph or dst not in graph:\n                return -1.0\n            if src == dst:\n                return 1.0\n            visited.add(src)\n            for neighbor, weight in graph[src].items():\n                if neighbor not in visited:\n                    res = dfs(neighbor, dst, visited)\n                    if res != -1.0:\n                        return weight * res\n            return -1.0\n\n        res = []\n        for u, v in queries:\n            res.append(dfs(u, v, set()))\n        return res\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n    # Execute the input to define variables equations, values, queries\n    exec(data, globals())\n    solution = Solution()\n    results = solution.calcEquation(equations, values, queries)\n    formatted = '[' + ','.join(f'{x:.5f}' for x in results) + ']'\n    print(formatted)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to solve the described problem: evaluate division queries given equations as ratios. Standard problem: Build graph, use DFS/BFS. Virtual code line-by-line with explanation. Let's outline steps: Start, Build adjacency list from equations with weights, for each query, if both variables exist, perform DFS to find product ratio, else return -1.0. Use stack, visited, etc. We'll produce steps with arrows. Let's create steps:\n\nStart\n→ Build adjacency list: For each equation Ai/Bi=val, add Ai->Bi weight val, Bi->Ai weight 1/val\n→ Prepare results list\n→ For each query [C, D]:\n    → If C not in graph or D not in graph: append -1.0\n    → Else if C == D: append 1.0\n    → Else perform DFS from C to D:\n        → Initialize stack with (C, 1.0)\n        → Initialize visited set\n        → While stack not empty:\n            → Pop node, product\n            → If node == D: append product; break\n            → For neighbor, weight in graph[node]:\n                → If neighbor not visited: push (neighbor, product*weight)\n            → Mark visited\n        → If D not found after loop: append -1.0\n→ End\nReturn results\n\nAdd explanation comments. Each line with arrow and comment. Ensure use of Decision: and Yes/No arrow. Provide line numbers? Not required. But each line must have code then comment. Use '→' etc. For decision, indent.\n\nLet's produce. Use Chinese comments. Ensure format: `虛擬碼步驟 // 解釋`. Use 'Start', 'End'. Use Decision: and Yes/No arrows.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Build graph // 建立圖形結構以存儲變量之間的比例關係  \n    → For each equation (Ai, Bi, val)  \n        → Add edge Ai → Bi with weight val // Ai / Bi = val  \n        → Add edge Bi → Ai with weight 1/val // Bi / Ai = 1/val  \n→ Prepare results list // 用於儲存每個查詢的答案  \n→ For each query (C, D)  \n    → Decision: C 是否在 graph? // 檢查變量是否已定義  \n        Yes → Decision: D 是否在 graph? // 兩個變量都必須存在  \n            Yes → Decision: C == D? // 相同變量的比例為 1  \n                Yes → Append 1.0 // C/D = 1  \n                No → Decision: 能否從 C 到 D? // 需要進行搜尋  \n                    Yes → DFS from C to D // 深度優先搜尋以計算比例  \n                        → Initialize stack with (C, 1.0) // 初始節點及乘積  \n                        → Initialize visited set empty // 記錄已訪問節點  \n                        → While stack not empty  \n                            → Pop (node, product)  \n                            → If node == D  \n                                → Append product // 找到目標，紀錄答案  \n                                → Break // 結束搜尋  \n                            → Mark node as visited  \n                            → For each neighbor, weight in graph[node]  \n                                → If neighbor not visited  \n                                    → Push (neighbor, product * weight) // 更新乘積  \n                    No → Append -1.0 // 途中無法到達目標  \n            No → Append -1.0 // 其中一個變量不存在  \n        No → Append -1.0 // 其中一個變量不存在  \n→ End // 程式執行結束，返回 results list"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp_9igkciy.py\", line 67, in <module>\n    main()\n  File \"/tmp/tmp_9igkciy.py\", line 41, in main\n    args = ast.literal_eval(list_strs[1])\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport re\nimport json\nfrom collections import deque\n\nclass MyStack:\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x):\n        # 把新元素先放到輔助隊列\n        self.q2.append(x)\n        # 把主隊列中的所有元素移到輔助隊列\n        while self.q1:\n            self.q2.append(self.q1.popleft())\n        # 交換兩個隊列，讓 q1 成為新的主隊列\n        self.q1, self.q2 = self.q2, self.q1\n\n    def pop(self):\n        # 移除並返回堆疊頂部元素\n        return self.q1.popleft()\n\n    def top(self):\n        # 查看堆疊頂部元素但不移除\n        return self.q1[0]\n\n    def empty(self):\n        # 判斷堆疊是否為空\n        return not self.q1\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 找出所有以 [ 開頭並以 ] 結尾的子字串\n    list_strs = re.findall(r'\\[.*?\\]', data, flags=re.DOTALL)\n    ops = ast.literal_eval(list_strs[0])\n    args = ast.literal_eval(list_strs[1])\n\n    stack = None\n    results = []\n\n    for op, arg in zip(ops, args):\n        if op == \"MyStack\":\n            stack = MyStack()\n            results.append(None)\n        elif op == \"push\":\n            stack.push(arg[0])\n            results.append(None)\n        elif op == \"pop\":\n            results.append(stack.pop())\n        elif op == \"top\":\n            results.append(stack.top())\n        elif op == \"empty\":\n            results.append(stack.empty())\n        else:\n            # 若有未知操作，直接忽略\n            results.append(None)\n\n    # 輸出 JSON 格式，符合題目示例\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a virtual code for implementing a stack using two queues, with push, pop, top, empty. We must output line by line with \"虛擬碼步驟 // 解釋\". Use arrows and decisions.\n\nWe need to present algorithm. We can choose approach: using two queues, push operation costly: move all elements to queue2, enqueue new, then move back. Or push cheap, pop costly: keep everything in queue1, pop by moving all but last to queue2, etc.\n\nLet's produce algorithm: Use q1 as main queue, q2 as auxiliary.\n\nDefine push(x): enqueue x to q2, then enqueue all elements from q1 to q2, swap q1 and q2. This ensures q1 always has top at front.\n\npop(): dequeue from q1 and return.\n\ntop(): peek q1 front.\n\nempty(): q1 empty.\n\nThus push O(n), pop O(1). Provide virtual code accordingly.\n\nNow produce step-by-step pseudocode.\n\nLet's start:\n\nStart // 程式開始\n\nDefine class MyStack\n\nDefine q1, q2\n\nStart // stack initialization\n\nq1 = empty queue\n\nq2 = empty queue\n\nEnd // initialization finished\n\nThen push(x): step by step:\n\n→ Step 1: Enqueue x to q2 // 把新元素放入輔助隊列\n\n→ Step 2: While q1 not empty → Step 2a: Dequeue from q1 and enqueue to q2 // 把原隊列元素移到輔助隊列\n\n→ Step 3: Swap references of q1 and q2 // 讓q1成為新的主隊列，q2成為空的\n\npop(): \n\n→ Step 1: If q1 empty → Return error // 判斷是否為空\n\n→ Step 2: Dequeue from q1 and store in result // 取出隊首即為堆疊頂\n\n→ Step 3: Return result\n\ntop(): \n\n→ Step 1: If q1 empty → Return error\n\n→ Step 2: Peek q1 front // 取出隊首不移除\n\n→ Step 3: Return value\n\nempty():\n\n→ Step 1: Return q1 is empty\n\nBut we need to use the arrow syntax exactly.\n\nAlso need to output step by step within the class context? We might represent as pseudo-code inside the class.\n\nLet's produce:\n\nStart // 程式開始\n\n→ Step 1: 初始化 MyStack // 建立兩個空隊列\n\n    → q1 = new Queue() // 主隊列\n\n    → q2 = new Queue() // 辅助隊列\n\nEnd // 初始化完成\n\nThen define methods:\n\nStart // 定義 push\n\n→ Step 1: push(x)\n\n    → Enqueue x to q2 // 把新元素放入輔助隊列\n\n    → Decision: q1 是否為空? // 檢查主隊列是否有元素\n\n        Yes → No →  // 若不空，將主隊列元素轉移\n\n        No  → While q1 not empty\n\n              → Dequeue from q1 → Enqueue to q2 // 把每個元素從主隊列移到輔助隊列\n\n    → Swap q1, q2 // 讓q1成為新的主隊列\n\nEnd // push 完成\n\nSimilarly for pop.\n\nBut the format demands each line \"虛擬碼步驟 // 解釋\". We need to use arrows \"→\" for steps.\n\nMaybe we can produce each method with lines:\n\nStart // 程式開始\n\n→ Step 1: MyStack // 建立 MyStack 類別\n\n→ Step 2: q1 = new Queue() // 主隊列\n\n→ Step 3: q2 = new Queue() // 輔助隊列\n\nEnd // 初始化\n\nThen for push:\n\n→ Method push(x) // 新增元素\n\n    → Enqueue x to q2 // 把元素放到輔助隊列\n\n    → While q1 not empty\n\n        → Dequeue from q1 → Enqueue to q2 // 移動所有元素\n\n    → Swap q1 and q2 // 重新設置主隊列\n\nEnd // push\n\nFor pop:\n\n→ Method pop() // 移除並返回頂部\n\n    → Decision: q1 is empty? // 判斷是否為空\n\n        Yes → Return error\n\n        No  → Dequeue from q1 and store in temp // 取出頂部\n\n    → Return temp // 返回結果\n\nEnd\n\nFor top:\n\n→ Method top() // 查看頂部\n\n    → Decision: q1 is empty? // 判斷是否為空\n\n        Yes → Return error\n\n        No  → Peek q1 front // 看頂部\n\n    → Return value\n\nEnd\n\nFor empty:\n\n→ Method empty() // 判斷是否為空\n\n    → Return q1 is empty // 直接回傳\n\nEnd\n\nBut we must follow format: Each line with \"虛擬碼步驟 // 解釋\". Use \"Start\", \"End\", \"Decision:\".\n\nLet's produce final answer accordingly.\n\nAlso ensure each line with arrow or indentation? The format example uses \"→ Step 1:\" etc. Let's follow that.\n\nWe need to include decisions.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始\n\n→ Step 1: 建立 MyStack 類別 // 定義堆疊\n\n    → Step 2: q1 = new Queue() // 主隊列，存放堆疊元素\n\n    → Step 3: q2 = new Queue() // 輔助隊列，協助 push 操作\n\nEnd // MyStack 初始化完成\n\n// ---------- push 操作 ----------\n→ Method push(x) // 將元素 x 推入堆疊\n\n    → Step 1: Enqueue x to q2 // 把新元素先放到輔助隊列\n\n    → Step 2: While q1 not empty // 移動主隊列中所有元素到輔助隊列\n\n        → Step 2a: Dequeue from q1 → Enqueue to q2 // 逐一移動\n\n    → Step 3: Swap references of q1 and q2 // 讓 q1 成為新的主隊列，q2 清空\n\nEnd // push 完成\n\n// ---------- pop 操作 ----------\n→ Method pop() // 移除並返回堆疊頂部元素\n\n    → Decision: q1 is empty? // 判斷堆疊是否為空\n\n        Yes → Return error // 空堆疊無法 pop，返回錯誤\n\n        No  → Step 1: temp = Dequeue from q1 // 取出隊首即為頂部\n\n    → Step 2: Return temp // 返回移除的元素\n\nEnd // pop 完成\n\n// ---------- top 操作 ----------\n→ Method top() // 查看堆疊頂部元素而不移除\n\n    → Decision: q1 is empty? // 判斷堆疊是否為空\n\n        Yes → Return error // 空堆疊無法 top，返回錯誤\n\n        No  → Step 1: temp = Peek from q1 // 取得隊首元素\n\n    → Step 2: Return temp // 返回頂部元素\n\nEnd // top 完成\n\n// ---------- empty 操作 ----------\n→ Method empty() // 判斷堆疊是否為空\n\n    → Step 1: Return q1 is empty // 直接回傳主隊列是否空\n\nEnd // empty 完成\n\nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2,1,3]'\nGot (Norm):      '[0,1,2,3]'\n--- (Raw) ---\nRaw Expected: '[0,2,1,3]'\nRaw Got:      '[0, 1, 2, 3]'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport ast\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        # 建立圖與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        # 加入邊與計算入度\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 先把所有入度為 0 的節點放入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # 拓撲排序\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 若能完成所有課程，回傳順序；否則回傳空列表\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"將標準輸入轉為 numCourses 與 prerequisites。\"\"\"\n    data = data.strip()\n    if not data:\n        return 0, []\n\n    # 1. 若輸入包含 'numCourses' 與 'prerequisites' 的文字說明\n    if \"numCourses\" in data and \"prerequisites\" in data:\n        num_match = re.search(r'numCourses\\s*=\\s*(\\d+)', data)\n        num = int(num_match.group(1)) if num_match else 0\n\n        prereq_match = re.search(r'prerequisites\\s*=\\s*(\\[.*\\])', data)\n        prereq = ast.literal_eval(prereq_match.group(1)) if prereq_match else []\n        return num, prereq\n\n    # 2. 直接給兩個參數，可能是兩行或空格分隔\n    parts = data.split()\n    if len(parts) >= 2:\n        try:\n            num = int(parts[0])\n        except ValueError:\n            num = 0\n        try:\n            prereq = ast.literal_eval(parts[1])\n        except Exception:\n            prereq = []\n        return num, prereq\n\n    # 3. 兩行分別給定\n    lines = data.splitlines()\n    if len(lines) >= 2:\n        try:\n            num = int(lines[0].strip())\n        except ValueError:\n            num = 0\n        try:\n            prereq = ast.literal_eval(lines[1].strip())\n        except Exception:\n            prereq = []\n        return num, prereq\n\n    return 0, []\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取全部資料\n    raw_input = sys.stdin.read()\n    numCourses, prerequisites = parse_input(raw_input)\n\n    # 執行演算法並輸出結果\n    solution = Solution()\n    result = solution.findOrder(numCourses, prerequisites)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code (flowchart steps) for topological sorting. We need to explain each line. Use Start, Decision, etc. Should not output real code. Provide step-by-step algorithm: build graph adjacency list, indegree array, queue of zero indegree, pop, append to result, reduce neighbors indegree, enqueue if zero. At end if result size == numCourses, return result else empty.\n\nWe need to produce line by line steps. Use 虛擬碼步驟. Example: \"Start // 程式開始執行\". Then \"→ Step 1: 建立 adjacency list 與入度數列 // 初始化圖結構\" etc.\n\nMake sure each line includes explanation after //.\n\nAlso we need to use arrows appropriately. Indentation for decisions. We can use Yes → etc.\n\nLet's craft.\n\nLines:\n\nStart // 程式開始\n\n→ Step 1: 建立 adjacency list (list of list) 與 indegree (array) // 初始化圖\n\n→ Step 2: 逐對處理 prerequisites 內的 (a,b) // 將依賴關係加入圖\n\n    → Decision: 是否已存在 b 為 key? // 檢查 adjacency list\n\n        Yes → Step 2a: adjacency[b].append(a)\n\n        No  → Step 2b: adjacency[b] = [a]\n\n    → Step 3: indegree[a] += 1 // 更新入度\n\n→ Step 4: 建立 queue 並將所有 indegree 為 0 的節點加入 // 準備拓撲排序\n\n→ Step 5: result = [] // 存放排序結果\n\n→ Decision: queue 是否為空? // 判斷是否還有節點可處理\n\n    Yes → Step 6: pop node u from queue // 取一個入度為 0 的節點\n\n        → Step 7: result.append(u) // 加入結果\n\n        → Decision: adjacency 內是否有 u 的鄰居? // 檢查是否有 outgoing edges\n\n            Yes → Step 8: 逐個 neighbour v\n\n                → Step 8a: indegree[v] -= 1 // 減少入度\n\n                → Decision: indegree[v] 為 0? // 判斷是否可加入 queue\n\n                    Yes → Step 8b: queue.append(v) // 入度為 0 的加入 queue\n\n                    No  → // 不做處理\n\n            No → // 無鄰居，直接繼續\n\n        → Decision: queue 是否為空? // 仍有節點可處理\n\n            Yes → Go back to Step 5 // 繼續\n\n            No  → // 所有節點已處理\n\n→ Decision: result 長度 == numCourses? // 判斷是否成功\n\n    Yes → End // 返回 result // 所有課程可完成，輸出順序\n\n    No  → End // 返回空陣列 // 無法完成所有課程\n\nNeed to use \"End\" line. Maybe include \"返回 result\" after End? The format says End // 程式執行結束. We'll mention return inside earlier line? But we can keep End.\n\nAlso include comment for return inside lines where return occurs? We can put \"End // 程式執行結束\" after decision. But we might need to differentiate returning result vs empty array. Could include Step 9: return result if success else return [].\n\nLet's restructure: after decision result length==numCourses? then Yes → Step 9a: return result // 所有課程可完成\n\nNo  → Step 9b: return [] // 失敗\n\n→ End // 程式結束\n\nLet's create final steps accordingly.\n\nEnsure each line has \"虛擬碼步驟\" before explanation.\n\nUse proper arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 adjacency list 與 indegree 陣列 // 初始化圖結構  \n→ Step 2: 逐對處理 prerequisites 內的 (a,b) // 將依賴關係加入圖  \n  → Decision: adjacency 是否已包含鍵 b? // 檢查是否已經有鄰接清單  \n   Yes → Step 2a: adjacency[b].append(a) // 將 a 加到 b 的鄰居列表  \n   No  → Step 2b: adjacency[b] = [a] // 建立新的鄰居列表  \n  → Step 3: indegree[a] += 1 // 更新節點 a 的入度  \n→ Step 4: 建立 queue 並將所有 indegree 為 0 的節點加入 // 準備拓撲排序  \n→ Step 5: result = [] // 用於存放課程順序  \n→ Decision: queue 是否為空? // 判斷是否還有節點可處理  \n  Yes → Step 6: pop node u 從 queue // 取出一個入度為 0 的節點  \n   → Step 7: result.append(u) // 加入結果  \n   → Decision: adjacency[u] 是否存在? // 檢查 u 的 outgoing edges  \n    Yes → Step 8: 針對每個 neighbour v 在 adjacency[u]  \n     → Step 8a: indegree[v] -= 1 // 減少 v 的入度  \n     → Decision: indegree[v] 是否為 0? // 判斷是否可以加入 queue  \n      Yes → Step 8b: queue.append(v) // 入度為 0 的節點加入 queue  \n      No  → // 不做處理  \n    No  → // u 沒有鄰居，直接繼續  \n   → Decision: queue 是否為空? // 是否還有節點可處理  \n    Yes → Go back to Step 5 // 繼續處理  \n    No  → // 所有節點已處理  \n→ Decision: result.length == numCourses? // 判斷是否成功完成所有課程  \n  Yes → Step 9a: return result // 所有課程可完成，輸出順序  \n  No  → Step 9b: return [] // 無法完成所有課程，返回空陣列  \n→ End // 程式執行結束"
    },
    {
      "title": "Median of Two Sorted Arrays",
      "source_file": "Leetcode/leetcode4.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,3], nums2 = [2]",
          "expected_output": "2.00000",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '2.00000'\nGot (Norm):      '1.00000'\n--- (Raw) ---\nRaw Expected: '2.00000'\nRaw Got:      '1.00000'"
        }
      ],
      "generated_code": "import sys\nimport re\nimport math\n\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        Find median of two sorted arrays using binary search on the smaller array.\n        Complexity: O(log(min(m, n)))\n        \"\"\"\n        # Ensure nums1 is the smaller array for binary search efficiency\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        total = m + n\n        half = total // 2\n\n        # Binary search boundaries in nums1\n        left, right = 0, m\n        while left <= right:\n            i = (left + right) // 2          # partition index in nums1\n            j = half - i                    # partition index in nums2\n\n            # Edge values for partitions\n            Aleft  = nums1[i - 1] if i > 0 else -math.inf\n            Aright = nums1[i]     if i < m else math.inf\n            Bleft  = nums2[j - 1] if j > 0 else -math.inf\n            Bright = nums2[j]     if j < n else math.inf\n\n            # Check if we found the correct partition\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:  # odd total length\n                    return max(Aleft, Bleft)\n                else:          # even total length\n                    return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0\n            elif Aleft > Bright:\n                right = i - 1\n            else:\n                left = i + 1\n\ndef parse_input(input_str):\n    \"\"\"\n    Parse input string of the form:\n        nums1 = [1,3], nums2 = [2]\n    and return two lists of integers.\n    \"\"\"\n    # Find all bracketed lists\n    lists = re.findall(r'\\[([^\\]]*)\\]', input_str)\n    if len(lists) != 2:\n        raise ValueError(\"Input must contain two lists.\")\n    nums1 = [int(x.strip()) for x in lists[0].split(',')] if lists[0].strip() else []\n    nums2 = [int(x.strip()) for x in lists[1].split(',')] if lists[1].strip() else []\n    return nums1, nums2\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    nums1, nums2 = parse_input(data)\n    sol = Solution()\n    median = sol.findMedianSortedArrays(nums1, nums2)\n    print(f\"{median:.5f}\")",
      "virtual_code": "Thinking...\nWe need to generate pseudocode for finding median of two sorted arrays with O(log(m+n)) complexity. We need to use virtual code steps, line by line, with arrow and explanation comments. Use Decision, Start, End. Use Yes/No arrows.\n\nWe need to reflect algorithm: Binary search approach partition.\n\nWe can describe steps:\n\nStart\n→ Ensure nums1 is smaller or equal size; if not, swap arrays\n→ Set low=0, high=nums1.size\n→ While low <= high:\n    → Compute partitionX = (low+high)/2\n    → Compute partitionY = (total+1)/2 - partitionX\n    → Determine maxLeftX, minRightX; similarly for Y\n    → Decision: If maxLeftX <= minRightY and maxLeftY <= minRightX:\n        → Decision: If total length is odd?\n            → Yes → median = max(maxLeftX, maxLeftY)\n            → No  → median = (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n        → Break\n      No → Decision: If maxLeftX > minRightY? \n            → Yes → high = partitionX -1\n            → No → low = partitionX +1\n→ End\n\nAlso handle edge cases: partitionX==0 => maxLeftX = -inf; partitionX==m => minRightX=+inf; same for Y.\n\nAdd explanation per line. Use proper arrows. Use spaces.\n\nLet's craft.\n\nWe must not output real code. Just pseudocode lines. Use \"Step\" maybe. Use \"→\". Provide comment after //.\n\nEnsure each line includes the step and comment. Use indentation for decision branches. Let's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 交換陣列? 若 nums1 長度 > nums2 長度  \n    Yes → Step: 交換 nums1 與 nums2, 重新設定 m, n // 確保 nums1 為較短陣列  \n    No  → // 保持原陣列順序  \n→ Step: 設定 low = 0, high = m // 二分搜尋區間為 nums1 的索引範圍  \n→ Step: 計算 total = m + n // 總長度，後續用於判斷奇偶  \n→ Decision: 低於 high? (迴圈條件)  \n    Yes → Step: partitionX = (low + high) / 2 // nums1 的分割點  \n    → Step: partitionY = (total + 1) / 2 - partitionX // 根據 total 計算 nums2 的分割點  \n    → Decision: 設置邊界值?  \n        Yes → Step: maxLeftX = (partitionX == 0) ? -∞ : nums1[partitionX - 1] // nums1 左側最大值  \n        No  →  \n    → Decision: 設置邊界值?  \n        Yes → Step: minRightX = (partitionX == m) ? +∞ : nums1[partitionX] // nums1 右側最小值  \n        No  →  \n    → Decision: 設置邊界值?  \n        Yes → Step: maxLeftY = (partitionY == 0) ? -∞ : nums2[partitionY - 1] // nums2 左側最大值  \n        No  →  \n    → Decision: 設置邊界值?  \n        Yes → Step: minRightY = (partitionY == n) ? +∞ : nums2[partitionY] // nums2 右側最小值  \n        No  →  \n    → Decision: 是否找到正確分割? (maxLeftX ≤ minRightY 且 maxLeftY ≤ minRightX)  \n        Yes → Decision: total 奇偶?  \n            Yes → Step: median = max(maxLeftX, maxLeftY) // 奇數時中位數為左側最大值  \n            No  → Step: median = (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2 // 偶數時取兩側平均  \n        → Step: Break // 找到結果後離開迴圈  \n        No  → Decision: maxLeftX > minRightY?  \n            Yes → Step: high = partitionX - 1 // 需要向左移動 partitionX  \n            No  → Step: low = partitionX + 1 // 需要向右移動 partitionX  \n→ End // 程式執行結束，median 已計算完成"
    },
    {
      "title": "Word Ladder II",
      "source_file": "Leetcode/leetcode126.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expected_output": "[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nGot (Norm):      '[]'\n--- (Raw) ---\nRaw Expected: '[[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]'\nRaw Got:      '[]'"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict, deque\n\nclass Solution:\n    def findLadders(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n\n        layer = {beginWord: 0}\n        parents = defaultdict(list)\n        queue = deque([beginWord])\n\n        while queue:\n            word = queue.popleft()\n            step = layer[word]\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    if new_word in wordSet:\n                        if new_word not in layer:\n                            layer[new_word] = step + 1\n                            queue.append(new_word)\n                            parents[new_word].append(word)\n                        elif layer[new_word] == step + 1:\n                            parents[new_word].append(word)\n\n        res = []\n\n        def dfs(path, word):\n            if word == beginWord:\n                res.append(path[::-1])\n                return\n            for prev in parents[word]:\n                dfs(path + [prev], prev)\n\n        if endWord in parents:\n            dfs([endWord], endWord)\n\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 把輸入轉成 dict\n    try:\n        params = eval('{' + data + '}', {}, {})\n    except Exception:\n        print([])\n        return\n\n    beginWord = params.get('beginWord', '')\n    endWord = params.get('endWord', '')\n    wordList = params.get('wordList', [])\n\n    sol = Solution()\n    result = sol.findLadders(beginWord, endWord, wordList)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code step-by-step with explanation. The problem is classic Word Ladder II. Need to find all shortest transformation sequences. Steps: BFS to find levels, build adjacency or parent mapping. Then DFS or backtracking to generate paths.\n\nWe must produce lines: \"Start\", \"→ Step ...\", \"→ Decision:\" etc. Let's outline algorithm:\n\nStart\n→ Step 1: 建立字典 Set wordSet from wordList // 快速查詢\n→ Decision: 如果 endWord 不在 wordSet? // 無法完成\n    No → Step 2: Return empty list // 結束\nYes → Step 3: 初始化 BFS queue with beginWord, level map, parents map // 將層級記錄\n→ Step 4: While queue not empty\n    → Step 5: Pop current word, current level\n    → Decision: 如果 current word 已超過最短距離? // 已找到 endWord，停止\n        Yes → Break\n    No → Step 6: For each character position i in current word\n        → Step 7: For letter from 'a' to 'z'\n            → Step 8: 若 letter == current[i] 則 continue\n            → Step 9: Construct nextWord by replacing\n            → Decision: 如果 nextWord 在 wordSet? // 有效\n                Yes →\n                    → Decision: 如果 nextWord 未在 level map? // 未訪問\n                        Yes →\n                            → Step 10: 設定 level[nextWord] = currentLevel + 1\n                            → Step 11: queue.push(nextWord)\n                        No →\n                            → Decision: 如果 level[nextWord] == currentLevel + 1? // 同層級\n                                Yes → // 可成為另一父節點\n                                No → // 忽略\n                    → Step 12: 將 current 作為 nextWord 的父節點 (parents[nextWord].add(current))\n                No → // 不在字典\n→ Step 13: If endWord not in level map -> Return empty list // no path\nYes → Step 14: 使用 DFS 或 backtracking 生成所有路徑\n    → Step 15: 定義 backtrack(current, path)\n        → Decision: 如果 current == beginWord? // 到起點\n            Yes → Add reversed path to results\n        No →\n            → For each parent in parents[current]\n                → Step 16: backtrack(parent, [parent]+path)\n→ Step 17: Call backtrack(endWord, [endWord])\n→ End\n\nBut we need line by line with \"虛擬碼步驟\" and \"// 解釋\". Use arrow \"→\". For decisions we indent lines.\n\nLet's craft. Also include BFS loop and inner loops.\n\nWe need to follow output format: each line \"虛擬碼步驟\" space \"// 解釋/說明\". Let's produce.\n\nEnsure that \"Start\" and \"End\" are separate lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立字典 Set wordSet ← wordList // 快速查詢字典中的單詞  \n→ Decision: endWord 是否在 wordSet? // 若不存在則無法完成轉換  \n    No  → Step 2: 回傳空清單 [] // 結束程式  \n    Yes → Step 3: 初始化 BFS  \n        → Queue ← [beginWord] // BFS 循環隊列  \n        → levelMap ← {beginWord: 0} // 記錄每個單詞的層級（距離）  \n        → parentsMap ← {beginWord: []} // 儲存每個單詞的父節點  \n    → Step 4: BFS 迴圈  \n        → While Queue 不為空  \n            → Step 5: current ← Queue.pop_front() // 取出隊列頭部單詞  \n            → Step 6: currentLevel ← levelMap[current] // 取得其層級  \n            → Decision: current == endWord? // 已找到最短路徑  \n                Yes → Break // 跳出 BFS，後續不再擴展  \n                No → Step 7: 遍歷每個位置 i in current.length  \n                    → Step 8: 對字母 c 從 'a' 到 'z'  \n                        → Decision: c == current[i]? // 同字母不變  \n                            Yes → Continue // 跳過  \n                            No → Step 9: nextWord ← current 在位置 i 用 c 取代  \n                            → Decision: nextWord 是否在 wordSet? // 有效單詞  \n                                Yes → Step 10: 若 nextWord 未在 levelMap?  \n                                    Yes →  \n                                        → levelMap[nextWord] ← currentLevel + 1  \n                                        → Queue.push_back(nextWord)  \n                                    No → Decision: levelMap[nextWord] == currentLevel + 1?  \n                                        Yes → // 同層級，可多條父節點  \n                                        No → Continue // 避免更短路徑  \n                                    → Step 11: parentsMap[nextWord].add(current) // 記錄父節點  \n                                No → // nextWord 不在字典，忽略  \n    → Step 12: Decision: endWord 是否在 levelMap? // 有無路徑  \n            No → Step 13: 回傳空清單 [] // 結束程式  \n            Yes → Step 14: 準備回溯產生所有最短路徑  \n                → Result ← [] // 儲存所有路徑  \n                → 定義 backtrack(currentWord, path)  \n                    → Decision: currentWord == beginWord? // 回到起點  \n                        Yes → Result.add([beginWord] + reverse(path)) // 加入完整路徑  \n                        No → Step 15: 對每個 parent in parentsMap[currentWord]  \n                            → backtrack(parent, [currentWord] + path) // 先加入當前單詞  \n            → Step 16: 呼叫 backtrack(endWord, []) // 從 endWord 開始回溯  \n            → Step 17: 回傳 Result // 所有最短轉換序列  \nEnd // 程式執行結束"
    },
    {
      "title": "Single Number II",
      "source_file": "Leetcode/leetcode137.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [2,2,3,2]",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "nums = [0,1,0,1,0,1,99]",
          "expected_output": "99",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '99'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '99'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef single_number(nums):\n    ones, twos = 0, 0\n    for num in nums:\n        # update twos first, then ones, using bitwise masks\n        twos = (twos ^ num) & ~ones\n        ones = (ones ^ num) & ~twos\n    return ones\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read()\n    if not data:\n        sys.exit()\n    # Extract all integers from the input\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    result = single_number(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code algorithm for finding the element that appears once while others appear three times, linear time, O(1) space. Classic solution uses bitwise counting: For each bit position 0-31, count number of set bits among all numbers modulo 3; rebuild answer. Or using bit masks ones, twos: ones = (ones ^ num) & ~twos; twos = (twos ^ num) & ~ones; at end ones holds unique number. This uses constant space and linear time. Provide pseudo code line by line with explanation.\n\nWe need to output per line: \"虛擬碼步驟 // 解釋/說明\" following format. Use Start, End, Decision. So we need to design algorithm step by step. Let's produce:\n\nStart\n→ Step 1: 初始化變數 ones = 0, twos = 0 // 用於記錄位元出現一次和兩次的數\n→ For each num in nums // 逐個遍歷陣列\n    → Update twos: twos = (twos XOR num) AND NOT ones // 當 num 的位元在 ones 中為 1 時，清除對應位\n    → Update ones: ones = (ones XOR num) AND NOT twos // 當 num 的位元在 twos 中為 1 時，清除對應位\n→ End For\n→ Step 2: 返回 ones // ones 中保存唯一元素\nEnd\n\nWe need to include arrow arrows? The example shows \"→ Step 1:\" etc. So we can do like that.\n\nWe also need to explain each line.\n\nMake sure to use Chinese (繁體) for explanations.\n\nAlso include Decision? Not necessary. But can include Decision for termination? It's linear loop.\n\nLet's produce each line with // explanation.\n\nLet's output:\n\nStart // 程式開始執行\n\n→ Step 1: ones ← 0, twos ← 0 // 初始化兩個位元掩碼，分別存放出現一次與兩次的位元\n\n→ For each num in nums // 從左到右逐個讀取陣列中的數字\n\n    → twos ← (twos XOR num) AND (NOT ones) // 更新 twos：若 num 的位元已在 ones 中則清除；其餘情況保留或設置\n\n    → ones ← (ones XOR num) AND (NOT twos) // 更新 ones：若 num 的位元已在 twos 中則清除；其餘情況保留或設置\n\n→ End For // 迴圈結束，ones 中即為唯一數字\n\n→ Step 2: return ones // 輸出唯一出現一次的數字\n\nEnd // 程式結束\n\nBut need to maintain format with arrows: each step line uses \"→\" before Step 1 etc. The For loop lines need indentation. Provide indent but maintain formatting.\n\nMake sure each line ends with \"// 解釋\". So:\n\nStart // 程式開始執行\n\n→ Step 1: ones ← 0, twos ← 0 // 初始化兩個位元掩碼，分別存放出現一次與兩次的位元\n\n→ For each num in nums // 從左到右逐個讀取陣列中的數字\n\n    → twos ← (twos XOR num) AND (NOT ones) // 更新 twos：若 num 的位元已在 ones 中則清除；其餘情況保留或設置\n\n    → ones ← (ones XOR num) AND (NOT twos) // 更新 ones：若 num 的位元已在 twos 中則清除；其餘情況保留或設置\n\n→ End For // 迴圈結束，ones 中即為唯一數字\n\n→ Step 2: return ones // 輸出唯一出現一次的數字\n\nEnd // 程式結束\n\nCheck spacing: Example shows \"→ Step 1: ...\" with no extra indent. For nested lines, they show \"    Yes →\". We can replicate indent with spaces. Use 4 spaces.\n\nThus final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step 1: ones ← 0, twos ← 0 // 初始化兩個位元掩碼，分別存放出現一次與兩次的位元\n→ For each num in nums // 從左到右逐個讀取陣列中的數字\n    → twos ← (twos XOR num) AND (NOT ones) // 更新 twos：若 num 的位元已在 ones 中則清除；其餘情況保留或設置\n    → ones ← (ones XOR num) AND (NOT twos) // 更新 ones：若 num 的位元已在 twos 中則清除；其餘情況保留或設置\n→ End For // 迴圈結束，ones 中即為唯一數字\n→ Step 2: return ones // 輸出唯一出現一次的數字\nEnd // 程式結束\n```"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.74284,-0.65136],[0.0434,-0.62178],[-0.35834,0.30648]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.74284, -0.65136], [0.0434, -0.62178], [-0.35834, 0.30648]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        # 產生均勻分佈的隨機點\n        r = self.radius * math.sqrt(random.random())\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [round(x, 5), round(y, 5)]\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit(0)\n    ops = ast.literal_eval(data[0])\n    args = ast.literal_eval(data[1])\n\n    results = []\n    obj = None\n    for op, arg in zip(ops, args):\n        if op == \"Solution\":\n            obj = Solution(*arg)\n            results.append(None)\n        elif op == \"randPoint\":\n            results.append(obj.randPoint())\n        else:\n            # 若有其他方法，直接呼叫並收集回傳值\n            results.append(getattr(obj, op)(*arg))\n\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps, line by line, with arrow etc. For each line include explanation after //.\n\nWe need to describe implementation of Solution class with constructor storing radius and center, and randPoint generating uniform random point inside circle. We will use polar coordinates: random angle uniform [0, 2π), random radius sqrt(rnd)*radius to ensure uniform distribution. Or use area method: random r = sqrt(rand())*radius, theta = rand()*2π.\n\nWe need virtual code lines, each line preceded by \"→\" arrow? The example shows Start, then \"→ Step 1...\" etc. So start, then steps. For class, we can describe initialization, then function randPoint.\n\nWe can produce:\n\nStart\n→ Step 1: 定義類別 Solution // 定義 Solution 類\n→ Step 2: 記錄 radius, x_center, y_center // 存儲參數\n→ Step 3: 在建構子中設置這些變數 // 初始化\n→ Step 4: 實作 randPoint() 方法 // 生成隨機點\n→ Step 5: 產生隨機角度 theta ∈ [0, 2π) // 隨機角度\n→ Step 6: 產生隨機半徑 r = sqrt(rand()) * radius // 隨機半徑確保均勻分佈\n→ Step 7: 計算 x = x_center + r * cos(theta) // 將極座標轉為直角座標\n→ Step 8: 計算 y = y_center + r * sin(theta) // 同上\n→ Step 9: 返回 [x, y] // 回傳點座標\nEnd\n\nWe need to follow the format precisely: each line includes the virtual code step + space + comment.\n\nUse arrow \"→\" at start of each step line except Start and End. But in example, Start line had no arrow, just \"Start\". Steps have \"→\".\n\nSo produce:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 定義 Solution 類別\n→ Step 2: 在建構子中接收 radius、x_center、y_center 並儲存 // 初始化參數\n→ Step 3: 實作 randPoint() 方法 // 定義產生隨機點的函式\n→ Step 4: 產生隨機角度 theta ∈ [0, 2π) // 角度隨機\n→ Step 5: 產生隨機半徑 r = sqrt(random()) * radius // 半徑隨機，確保均勻分佈\n→ Step 6: 計算 x = x_center + r * cos(theta) // 將極座標轉直角座標\n→ Step 7: 計算 y = y_center + r * sin(theta) // 同上\n→ Step 8: 返回 [x, y] // 回傳隨機點\nEnd // 程式執行結束\n\nBut we need to maybe include Decision steps? Not needed. We might include a loop if we were generating but not needed.\n\nThus produce final output.\n\nMake sure each line ends with // explanation.\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 建立 Solution 類別\n→ Step 2: 在建構子中接收 radius、x_center、y_center 並儲存 // 儲存圓的半徑與中心座標\n→ Step 3: 實作 randPoint() 方法 // 定義產生隨機點的函式\n→ Step 4: 產生隨機角度 theta ∈ [0, 2π) // 隨機選取角度\n→ Step 5: 產生隨機半徑 r = sqrt(random()) * radius // 取 sqrt() 以保證均勻分佈\n→ Step 6: 計算 x = x_center + r * cos(theta) // 將極座標轉換為直角座標\n→ Step 7: 計算 y = y_center + r * sin(theta) // 同上\n→ Step 8: 返回 [x, y] // 回傳隨機點座標\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除所有等於 val 的元素，並返回不等於 val 的元素數量 k。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef main():\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # 取得 nums\n    nums_match = re.search(r'\\[(.*?)\\]', data)\n    nums = []\n    if nums_match:\n        nums_str = nums_match.group(1)\n        if nums_str.strip():\n            nums = [int(x.strip()) for x in nums_str.split(',')]\n\n    # 取得 val\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    val = int(val_match.group(1)) if val_match else 0\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 產生輸出，剩餘位置用 '_' 表示\n    placeholders = ['_' for _ in range(len(nums) - k)]\n    elements = list(map(str, nums[:k])) + placeholders\n    print(f\"{k}, nums = [{','.join(elements)}]\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps in specified format. The problem: remove element val in-place, return k. Typical solution uses two pointers: left index write position, iterate through array, copy non-val elements to write position, increment. After loop, k = write index. Output.\n\nWe produce steps starting from Start. Use arrow syntax.\n\nEach line: \"虛擬碼步驟 // 解釋\"\n\nNeed to use arrow \"→\". For decisions \"Decision:\". Also need \"Yes →\" and \"No →\" for branching.\n\nWe need to structure accordingly. Provide step by step. For loop: we might use \"→ Step: 遍歷索引 i 從 0 到 nums.Length-1\" then inside decision if nums[i] != val then write. Use nested Decision.\n\nWe'll use pseudocode like:\n\nStart // 程式開始執行\n→ Step 1: 初始化 writeIndex 為 0 // 用於寫入非 val 的元素\n→ Step 2: 遍歷 i 從 0 到 nums.Length-1 // 逐一檢查每個元素\n    → Decision: 如果 nums[i] != val?\n        Yes → Step 3: nums[writeIndex] = nums[i] // 把非 val 元素寫入前端\n              → Step 4: writeIndex++ // 前進寫入指標\n        No  → // 忽略 val，直接繼續\n→ Step 5: k = writeIndex // 所有非 val 元素已寫入，k 為元素個數\nEnd // 程式執行結束\n\nBut we need to use correct format with arrow indentation.\n\nWe also need to include the final return k step? We can incorporate in Step 5.\n\nWe should ensure each line has arrow, step, explanation.\n\nWe also might include \"→ Step 5: 返回 k\" but explanation says \"return k\". So step 5 can be \"Step 5: 返回 k\" and explanation \"返回非 val 元素的數量\".\n\nBut we already assign k. So Step 5: 返回 k.\n\nLet's produce final.\n\nRemember \"Decision:\" line must be on its own line and nested indent.\n\nAlso need to use \"Yes →\" and \"No →\".\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: writeIndex ← 0 // 初始化寫入位置\n→ Step 2: for i ← 0 to nums.Length-1 // 遍歷所有元素\n    → Decision: nums[i] ≠ val ?\n        Yes → Step 3: nums[writeIndex] ← nums[i] // 把非 val 元素放到前面\n              → Step 4: writeIndex ← writeIndex + 1 // 前進寫入位置\n        No  → // 這個元素是 val，直接跳過\n→ Step 5: k ← writeIndex // k 為保留元素數量\n→ Step 6: 返回 k // 結果返回\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋.\n\nLet's format accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writeIndex ← 0 // 初始化寫入位置  \n→ Step 2: for i ← 0 to nums.Length-1 // 遍歷所有元素  \n  → Decision: nums[i] ≠ val ? // 判斷當前元素是否為要移除的值  \n   Yes → Step 3: nums[writeIndex] ← nums[i] // 把非 val 元素放到前面  \n      // 把符合條件的元素寫入寫入位置  \n      → Step 4: writeIndex ← writeIndex + 1 // 前進寫入位置  \n   No  → // 這個元素是 val，直接跳過  \n→ Step 5: k ← writeIndex // k 為保留元素的個數  \n→ Step 6: 返回 k // 將結果返回給調用者  \nEnd // 程式執行結束"
    },
    {
      "title": "Count Numbers with Unique Digits",
      "source_file": "Leetcode/leetcode357.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 2",
          "expected_output": "91",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '91'\nGot (Norm):      '82'\n--- (Raw) ---\nRaw Expected: '91'\nRaw Got:      '82'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef count_numbers_with_unique_digits(n: int) -> int:\n    \"\"\"\n    計算 0 <= x < 10^n 內所有位數唯一的數字個數。\n    \"\"\"\n    if n == 0:            # 只有 0 這一個數字\n        return 1\n\n    n = min(n, 10)        # 10 位以後必有重複，直接截斷\n    count = 1             # 包含 0\n    multiplier = 9        # 第一位有 9 個選擇 (1~9)\n    count += multiplier   # 加上 1 位數的個數\n\n    for i in range(2, n + 1):   # 從 2 位數開始計算\n        multiplier *= (10 - i)  # 每多一位，剩餘可選位數減 1\n        count += multiplier     # 加入本位數長度的個數\n\n    return count\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取所有文字，並抓取第一個整數作為 n\n    data = sys.stdin.read()\n    match = re.search(r'-?\\d+', data)\n    n = int(match.group()) if match else 0\n\n    result = count_numbers_with_unique_digits(n)\n    print(result)",
      "virtual_code": "Thinking...\nWe need produce virtual code for problem: given integer n, return count of numbers with unique digits x, where 0 <= x < 10^n. It's classic LeetCode 357. Approach: DFS or combinatorics: Count=1 + sum_{i=1}^{n} 9 * P(9, i-1). We'll produce steps.\n\nWe need virtual code lines with explanation, using arrows and decisions. Should output in requested format.\n\nWe will generate step by step.\n\nStart\n→ Step 1: 初始化 count = 1 // 包括數字 0\n→ Step 2: 如果 n == 0 → End // 只剩 0\n→ Decision: n > 0? // 需要計算更大數字\n    Yes → Step 3: 設置 availableDigits = 9 // 第一位不能為 0，9 個選擇\n        → Step 4: 設置 multiplier = 1 // 用於計算排列數\n        → Step 5: for i from 1 to n:\n            → Decision: i > 1? // 之後的位數\n                Yes → multiplier = multiplier * (10 - i) // 降低可選位數\n                No  → // i=1 時 multiplier 仍為1\n            → Step 6: count = count + 9 * multiplier // 加入本位長度的組合\n    No → // n <=0 handled earlier\nEnd // 回傳 count\n\nBut we need more explicit decisions inside loop: we can do: multiplier = multiplier * (10 - i) each iteration, starting from 1.\n\nSimpler: count = 1\nmultiplier = 1\nfor i in 1..n:\n   multiplier *= (10 - i + 1?) Actually first iteration i=1: multiplier = 9? Let's derive: count += 9 * multiplier; then multiplier *= (10 - i) for next iteration.\n\nLet's produce code: start multiplier=1; for i=1 to n:\n   if i == 1:\n        count += 9 * multiplier\n   else:\n        multiplier = multiplier * (10 - i)\n        count += 9 * multiplier\n\nBut we can just compute as per formula: For i=1..n:\n   multiplier = multiplier * (10 - i)\n   count += 9 * multiplier\n\nInitialize multiplier=1. For i=1, multiplier=1*(10-1)=9; count += 9*9? Wait wrong.\n\nWe need correct combinatorics: For length 1: 9 options. For length 2: 9*9. For length 3: 9*9*8, etc. So formula: multiplier=1; for i=1 to n:\n   if i==1: multiplier = 9\n   else: multiplier = multiplier * (10 - i)\n   count += multiplier\n\nSimplify: start multiplier = 9; count += 9; for i=2..n: multiplier *= (10 - i); count += multiplier\n\nLet's produce that.\n\nWe'll present as steps.\n\nLet's craft final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 count = 1 // 包含數字 0 的情況  \n→ Step 2: 如果 n == 0 → End // 只剩 0，直接回傳  \n→ Decision: n > 0? // 是否需要處理更大位數的數字  \n    Yes → Step 3: 設定 multiplier = 9 // 第一位有 9 個選擇（1~9）  \n        → Step 4: count = count + multiplier // 加入 1 位數的組合  \n        → Step 5: for i from 2 to n: // 從 2 位數開始  \n            → Step 6: multiplier = multiplier * (10 - i) // 每多一位，選項減 1  \n            → Step 7: count = count + multiplier // 加入本位數長度的組合  \n    No → // n <= 0 已在 Step 2 處理  \nEnd // 程式執行結束，回傳 count"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[1,2,3],[2,1,3],[2,1,3]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [1, 2, 3], [2, 1, 3], [2, 1, 3]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列，並準備一份可變副本\n        self.original = list(nums)\n        self.nums = list(nums)\n\n    def reset(self):\n        # 重置回原始陣列\n        self.nums = list(self.original)\n        return self.nums\n\n    def shuffle(self):\n        # Fisher-Yates 洗牌\n        n = len(self.nums)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            self.nums[i], self.nums[j] = self.nums[j], self.nums[i]\n        return self.nums\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n\n    # 將輸入分成兩部分：方法名列表和對應參數列表\n    first_end = raw_input.find(']')\n    methods = json.loads(raw_input[:first_end + 1])\n    args = json.loads(raw_input[first_end + 2:])  # 跳過 ', '\n\n    instance = None\n    outputs = []\n\n    for method_name, arg in zip(methods, args):\n        if method_name == \"Solution\":\n            # 建構子只接收一個參數：陣列\n            instance = Solution(arg[0])\n            outputs.append(None)  # 建構子結果為 null\n        elif method_name == \"reset\":\n            outputs.append(instance.reset())\n        elif method_name == \"shuffle\":\n            outputs.append(instance.shuffle())\n        else:\n            # 若出現未知方法，輸出 null\n            outputs.append(None)\n\n    # 將結果轉成 JSON 並輸出\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm: class Solution with constructor, reset, shuffle. We need to use virtual code steps with arrows, decision etc. Provide explanation after each line. Must be in Traditional Chinese. Output lines with \"虛擬碼步驟 // 解釋\". Use Start, End, Decision. Each line: \"→ Step X: ...\". For class methods, we need steps inside.\n\nWe need to design algorithm: store original array, a copy for shuffle. Shuffle: use Fisher-Yates algorithm. Reset returns original copy.\n\nThus virtual code:\n\nStart\n→ Step 1: 初始化 Solution with nums // store original array\n→ Step 2: 複製 nums 為 current // 用於後續隨機洗牌\n→ Step 3: 定義 reset() // 返回原始排列\n    → Step 4: 重新將 current 設為 original 的副本 // 重置\n    → Step 5: 返回 current // 傳回原始陣列\n→ Step 6: 定義 shuffle() // 隨機洗牌\n    → Step 7: 從最後一個元素到第一個元素遍歷\n        → Decision: 計算隨機索引 i 在 0~j 範圍 // 決定交換位置\n        → Step 8: 交換 current[j] 與 current[i] // Fisher-Yates 交換\n    → Step 9: 返回 current // 返回洗牌後的陣列\nEnd\n\nBut need to use virtual code arrows and decision properly. Let's produce each step line by line, with indentation maybe.\n\nAlso include \"Decision:\" lines.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 class Solution // 建立解決方案類別\n→ Step 2: Constructor: Solution(int[] nums) // 初始化\n    → Step 3: original ← Copy(nums) // 保存原始陣列\n    → Step 4: current ← Copy(nums) // 用於後續操作\n→ Step 5: Method reset() // 重置陣列\n    → Step 6: current ← Copy(original) // 重新設定為原始順序\n    → Step 7: return current // 回傳重置後陣列\n→ Step 8: Method shuffle() // 隨機洗牌\n    → Step 9: n ← Length(current) // 取得陣列長度\n    → Step 10: For j from n-1 down to 1\n        → Decision: 隨機產生 i 在 [0, j] // 決定交換索引\n            Yes → Step 11: i ← RandomInt(0, j) // 生成隨機索引\n        → Step 12: Swap current[j] 與 current[i] // 交換位置\n    → Step 13: return current // 回傳洗牌後陣列\nEnd // 程式執行結束\n\nNeed to use \"→\" before each step, indent maybe with spaces. Use \"Decision:\" properly. Use \"Yes →\" and \"No →\" maybe not necessary.\n\nBut format requires that each line must contain virtual code step + space + // explanation.\n\nEnsure that \"Decision:\" lines also follow same pattern.\n\nThus final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 class Solution // 建立解決方案類別  \n→ Step 2: Constructor: Solution(int[] nums) // 初始化  \n → Step 3: original ← Copy(nums) // 保存原始陣列  \n → Step 4: current ← Copy(nums) // 用於後續操作  \n→ Step 5: Method reset() // 重置陣列  \n → Step 6: current ← Copy(original) // 重新設定為原始順序  \n → Step 7: return current // 回傳重置後陣列  \n→ Step 8: Method shuffle() // 隨機洗牌  \n → Step 9: n ← Length(current) // 取得陣列長度  \n → Step 10: For j from n-1 down to 1  \n  → Decision: 產生隨機索引 i 在 [0, j]? // 決定交換位置  \n   Yes → Step 11: i ← RandomInt(0, j) // 生成隨機索引  \n  → Step 12: Swap current[j] 與 current[i] // 交換位置  \n → Step 13: return current // 回傳洗牌後陣列  \nEnd // 程式執行結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef main() -> None:\n    # 讀取整個標準輸入，並移除首尾空白\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 如果輸入中包含 'nums = '，則將其移除，留下列表表達式\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n\n    expr = expr.strip()\n\n    # 解析列表，若解析失敗則回傳空列表\n    try:\n        nums = ast.literal_eval(expr)\n    except Exception:\n        nums = []\n\n    # 生成所有子集\n    result = []\n\n    def backtrack(start: int, path: list) -> None:\n        # 把目前子集加入結果\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    # 輸出結果，使用 Python 原生格式即可\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for generating power set of array of unique integers. It's classic backtracking. We must produce step-by-step virtual code lines with explanations. Format: each line \"虛擬碼步驟 // 解釋\". Use arrows, Decision etc. Provide structure: Start, End. Use \"Step\" etc. Ensure no real code. Each line includes arrow or indentation as per sample. Use Start, Step numbers, Decision.\n\nWe can show algorithm: sort? not needed. Use recursion: backtrack(index, currentSubset). At each call, add currentSubset to result. Then for i from index to len-1: include nums[i] in subset, recurse(i+1). We need virtual code with lines like:\n\nStart\n→ Step 1: 初始化 result為空列表 // 建立儲存子集的集合\n→ Step 2: 定義 backtrack(index, path) 函式 // 回溯函式，index為當前索引，path為目前子集\n    → Decision: index是否等於 nums長度? // 判斷是否已到結束\n        Yes → Step 3: 把 path 加入 result // 將目前子集加入結果\n        No  → Step 4: 把 path 加入 result // 這行可能重複? Actually we add at each call before exploring. But typical algorithm adds at start.\n        → For i從 index 到 nums長度-1: // 迴圈遍歷剩餘元素\n            → Step 5: 將 nums[i] 加入 path // 加入當前元素\n            → Step 6: backtrack(i+1, path) // 遞迴處理剩餘元素\n            → Step 7: 從 path 移除最後一個元素 // 回溯\n→ Step 8: 呼叫 backtrack(0, 空列表) // 開始回溯\n→ Step 9: 回傳 result // 返回所有子集\nEnd\n\nBut we need each line preceded by \"→\" maybe except Start, End. And decisions. Indent decisions.\n\nAlso, we might need \"Decision:\" lines for loop? Use \"Decision:\"? The sample uses Decision for conditions. For loop not a decision? Could use Step 5: For each i. But sample shows decision. For loop might be step. We'll keep as Step 5: Loop over i. Not decision.\n\nLet's produce step lines accordingly.\n\nWe need to ensure every line has explanation. Also mention that we avoid duplicates due to unique elements. Provide final.\n\nOk let's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空列表 // 用來儲存所有子集  \n→ Step 2: 定義 backtrack(index, path) 函式 // index 指向當前處理的元素，path 為目前已選擇的子集  \n → Decision: index 是否等於 nums 長度? // 判斷是否已處理完所有元素  \n  Yes → Step 3: 把 path 加入 result // 將目前子集加入結果集  \n  No  → Step 4: 把 path 加入 result // 先把目前子集加入結果，以包含不選擇任何新元素的情況  \n  → Step 5: 從 index 到 nums 長度-1 進行迴圈 // 為每個後續元素嘗試加入子集  \n   → Step 6: 把 nums[i] 加入 path // 選擇當前元素  \n   → Step 7: 呼叫 backtrack(i+1, path) // 進一步探索以此元素為起點的子集  \n   → Step 8: 從 path 移除最後一個元素 // 回溯，移除剛加入的元素，繼續嘗試下一個  \n→ Step 9: 呼叫 backtrack(0, 空列表) // 從第一個元素開始進行回溯  \n→ Step 10: 回傳 result // 回傳所有生成的子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Duplicates from Sorted Array II",
      "source_file": "Leetcode/leetcode80.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3]",
          "expected_output": "5, nums = [1,1,2,2,3,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[1,1,2,2,3,_]'\nGot (Norm):      '5,nums=[1,1,2,2,3,\"_\"]'\n--- (Raw) ---\nRaw Expected: '5, nums = [1,1,2,2,3,_]'\nRaw Got:      \"5, nums = [1, 1, 2, 2, 3, '_']\""
        },
        {
          "example_index": 1,
          "input": "nums = [0,0,1,1,1,1,2,3,3]",
          "expected_output": "7, nums = [0,0,1,1,2,3,3,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '7,nums=[0,0,1,1,2,3,3,_,_]'\nGot (Norm):      '7,nums=[0,0,1,1,2,3,3,\"_\",\"_\"]'\n--- (Raw) ---\nRaw Expected: '7, nums = [0,0,1,1,2,3,3,_,_]'\nRaw Got:      \"7, nums = [0, 0, 1, 1, 2, 3, 3, '_', '_']\""
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        移除 sorted 數組中重複元素，允許每個唯一元素最多出現兩次。\n        返回新的有效長度 k，並把結果放在 nums 的前 k 個位置。\n        \"\"\"\n        if not nums:\n            return 0\n        write = 0\n        for read in range(len(nums)):\n            if read < 2 or nums[read] != nums[write - 2]:\n                nums[write] = nums[read]\n                write += 1\n        return write\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入，支援 \"nums = [1,1,2,2,3]\" 或直接 \"[1,1,2,2,3]\"\n    if '=' in data:\n        _, list_part = data.split('=', 1)\n        list_part = list_part.strip()\n    else:\n        list_part = data\n\n    try:\n        nums = ast.literal_eval(list_part)\n    except Exception:\n        # 若解析失敗，嘗試把空格分隔的數字轉為列表\n        nums = list(map(int, list_part.split()))\n\n    solution = Solution()\n    k = solution.removeDuplicates(nums)\n\n    # 以示例中期望的格式輸出\n    # 前 k 個有效元素後面補 '_' 以示未使用的位址\n    output_list = nums[:k] + ['_'] * (len(nums) - k)\n    print(f\"{k}, nums = {output_list}\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for the problem: remove duplicates from sorted array allowing at most two occurrences per unique element. Standard two-pointer technique.\n\nWe need to output line by line with virtual code steps and explanation after each line, using arrow syntax. Example: \"Start // ...\" etc.\n\nLet's craft a step-by-step algorithm: Use write pointer, iterate read pointer from 0 to n-1. Keep count of how many times current number has been seen consecutively. When count <=2, write to write index and increment.\n\nAlternatively two pointer: write index starts at 0, for each i, if i<2 or nums[i] != nums[write-2] then nums[write]=nums[i], write++.\n\nWe'll output that.\n\nWe need to mention initialisation, loops, decision. Use Decision blocks.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: If nums is empty, return 0 // handle empty array\n→ Step 2: 初始化 write = 0 // write pointer，用於寫入符合條件的元素\n→ Step 3: for read from 0 to length-1 // read pointer 遍歷原陣列\n→ Decision: read < 2? // 前兩個元素總是允許\n    Yes → Step 4: nums[write] = nums[read] // 把元素寫入\n        → Step 5: write++ // 移動寫指標\n    No  → Decision: nums[read] != nums[write-2]? // 與前兩個已寫入元素比較\n        Yes → Step 6: nums[write] = nums[read]\n            → Step 7: write++\n        No  → Step 8: // 跳過此元素，因已出現兩次\n→ End // 程式結束\n→ Step 9: return write // write 即為新長度 k\n\nWe need to use arrow syntax and decisions. Ensure each line has \"虛擬碼步驟 // 解釋\".\n\nAlso we need to use \"→\" for next step. For decision, indent lines accordingly.\n\nWe need to be careful: Use \"Decision:\" and indent Yes/No lines.\n\nMake sure to use proper Chinese explanation.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 如果 nums 為空? // 檢查陣列是否為空  \n Yes → Step 1: Return 0 // 空陣列直接回傳長度 0  \n No  → Step 2: 初始化 write = 0 // write 指標，指向下個要寫入的位置  \n→ Step 3: for read from 0 到 nums.length-1 // read 指標遍歷整個陣列  \n → Decision: read < 2? // 前兩個元素始終允許出現  \n  Yes → Step 4: nums[write] = nums[read] // 把元素寫入結果區段  \n   → Step 5: write++ // 移動 write 指標到下一個位置  \n  No  → Decision: nums[read] != nums[write-2]? // 與已寫入區段的前兩個元素比較  \n   Yes → Step 6: nums[write] = nums[read] // 合乎規則，寫入並移動 write  \n     → Step 7: write++  \n   No  → Step 8: // 跳過此元素，因已出現兩次，保持 write 不變  \n→ End // 程式執行結束  \n→ Step 9: Return write // write 即為新的有效長度 k\n\n> 每行虛擬碼後面的註解即為對該行操作的簡短說明。"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,null,1,null,-1,3,null,-1,3,4]'\nGot (Norm):      '[None,None,None,1,None,-1,3,None,-1,3,4]'\n--- (Raw) ---\nRaw Expected: '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]'\nRaw Got:      '[None, None, None, 1, None, -1, 3, None, -1, 3, 4]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}          # key -> (value, freq)\n        self.freq_to_keys = defaultdict(OrderedDict)  # freq -> OrderedDict of keys\n\n    def _update(self, key: int):\n        value, freq = self.key_to_val_freq[key]\n        # Remove key from current freq bucket\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        # Add key to next freq bucket\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key: int) -> int:\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key: int, value: int) -> None:\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            # Update value and frequency\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            # Evict least frequently used key\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        # Insert new key\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit(0)\n    # Split input into operations list and arguments list\n    comma_index = data.find('],')\n    if comma_index == -1:\n        ops = ast.literal_eval(data.strip())\n        args = []\n    else:\n        ops = ast.literal_eval(data[:comma_index+1].strip())\n        args = ast.literal_eval(data[comma_index+2:].strip())\n\n    res = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            res.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            res.append(None)\n        elif op == \"get\":\n            res.append(cache.get(arg[0]))\n        else:\n            # Unknown operation; skip or raise error\n            pass\n    print(res)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for implementing LFU cache, using data structures: a hash map key->node, where node contains value, freq, and a doubly linked list node. And freq map: freq->linked list of nodes ordered by recency. Maintain minFreq. Operations get and put in O(1). Virtual code with steps and explanations.\n\nWe need to produce code lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 LFUCache 類 // ...\n... etc.\n\nWe need to be concise but cover all.\n\nLet's structure: initialization, data structures, internal helper to update freq, get, put.\n\nWe should produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類 // 用於儲存 key, value, freq, prev, next\n\nBut we need to use virtual code arrow syntax. Each line: virtual code step, space, // explanation.\n\nAlso need to include Decision blocks for conditionals.\n\nWe should produce about maybe 30-40 lines. Let's produce.\n\nWe need to maintain minFreq variable.\n\nLet's produce pseudo code:\n\n- Define Node with key, value, freq, prev, next.\n- Define DoublyLinkedList with head, tail, size, methods addNode, removeNode, removeLast, isEmpty.\n- Define LFUCache with capacity, map key->Node, freqMap freq->DoublyLinkedList, minFreq.\n\n- Helper function updateFreq(node):\n    - Remove node from old freq list.\n    - If old list empty and minFreq == old freq: increment minFreq.\n    - Increase node.freq.\n    - Add node to new freq list.\n\n- get(key):\n    - If key not in map: return -1.\n    - node = map[key]\n    - updateFreq(node)\n    - return node.value\n\n- put(key,value):\n    - If capacity <=0: return\n    - If key exists:\n        - node.value = value\n        - updateFreq(node)\n    - else:\n        - if map.size == capacity:\n            - list = freqMap[minFreq]\n            - nodeToRemove = list.removeLast()\n            - delete map[nodeToRemove.key]\n        - create new node with freq=1\n        - add to freqMap[1]\n        - map[key] = node\n        - minFreq = 1\n\nInclude decisions: if capacity <=0, if key exists, if cache full.\n\nLet's produce with proper formatting.\n\nUse lines starting with \"→\". For decisions, indentation.\n\nBe careful: Use `→ Decision:` syntax.\n\nWe can produce as:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類，包含 key, value, freq, prev, next // 資料節點\n→ Step 2: 定義 DoublyLinkedList 類，包含 head, tail, size，並提供 addNode, removeNode, removeLast, isEmpty 方法 // 用於頻率桶\n→ Step 3: 定義 LFUCache 類，包含 capacity, map(key->Node), freqMap(freq->DoublyLinkedList), minFreq // 主結構\n→ Step 4: 在 LFUCache 初始化時，設定 capacity，創建空 map、freqMap，將 minFreq 設為 0 // 初始化\n→ Decision: If capacity <= 0? // 無效容量\n    Yes → Step 5: 直接返回 // 什麼也不做\n    No → // 繼續\n→ Step 6: 定義 helper 函式 updateFreq(node) // 更新頻率\n→ Decision: // ...\nand so on.\n\nWe must use \"→\" arrow at each step line. Use indentation inside decision.\n\nLet's produce the entire virtual code.\n\nMake sure each line ends with // 解釋.\n\nLet's produce now.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類，包含 key, value, freq, prev, next // 資料節點  \n→ Step 2: 定義 DoublyLinkedList 類，包含 head, tail, size，並提供 addNode(node)、removeNode(node)、removeLast()、isEmpty() 方法 // 用於頻率桶  \n→ Step 3: 定義 LFUCache 類，包含 capacity, keyNodeMap(key→Node), freqListMap(freq→DoublyLinkedList), minFreq // 主資料結構  \n→ Step 4: 在 LFUCache 初始化時，設定 capacity，創建空 keyNodeMap、freqListMap，並將 minFreq 設為 0 // 初始化  \n→ Decision: If capacity <= 0? // 檢查容量是否合法  \n    Yes → Step 5: 直接返回 // 無效容量，什麼也不做  \n    No  → // 繼續  \n→ Step 6: 定義 helper 函式 updateFreq(node) // 更新節點頻率  \n→ Step 7: 取得 node.freq 為 oldFreq // 取出舊頻率  \n→ Step 8: 取出 freqListMap[oldFreq] 為 oldList // 取得舊頻率桶  \n→ Step 9: oldList.removeNode(node) // 從舊頻率桶移除節點  \n→ Decision: oldList.isEmpty()? // 檢查舊頻率桶是否空  \n    Yes → Decision: minFreq == oldFreq? // 若 minFreq 與舊頻率相同  \n        Yes → Step 10: minFreq++ // minFreq 需向上調整  \n        No  → // 不改變 minFreq  \n    No  → // 不改變 minFreq  \n→ Step 11: node.freq++ // 讓節點頻率加一  \n→ Step 12: 取出 freqListMap[node.freq] 為 newList，若不存在則新建空桶並加入 freqListMap // 取得新頻率桶  \n→ Step 13: newList.addNode(node) // 將節點加到新桶頭部（最近使用）  \n→ Step 14: End of updateFreq // 更新完成  \n→ Step 15: 定義 get(key) 方法 // 讀取操作  \n→ Decision: keyNodeMap.containsKey(key)? // 是否存在鍵  \n    Yes → Step 16: node = keyNodeMap[key] // 取得節點  \n        → Step 17: updateFreq(node) // 更新頻率  \n        → Step 18: Return node.value // 回傳值  \n    No  → Step 19: Return -1 // 鍵不存在，回傳 -1  \n→ Step 20: End of get // get 完成  \n→ Step 21: 定義 put(key, value) 方法 // 插入/更新操作  \n→ Decision: capacity <= 0? // 再次檢查容量  \n    Yes → Step 22: Return // 無效容量，直接返回  \n    No  → // 繼續  \n→ Decision: keyNodeMap.containsKey(key)? // 鍵是否已存在  \n    Yes → Step 23: node = keyNodeMap[key] // 取得節點  \n        → Step 24: node.value = value // 更新值  \n        → Step 25: updateFreq(node) // 更新頻率  \n        → Step 26: Return // 完成更新  \n    No  → // 鍵不存在，需插入新節點  \n→ Decision: keyNodeMap.size() == capacity? // 是否已滿容量  \n    Yes → Step 27: list = freqListMap[minFreq] // 取得最少頻率桶  \n        → Step 28: nodeToRemove = list.removeLast() // 取出最近最少使用的節點  \n        → Step 29: keyNodeMap.remove(nodeToRemove.key) // 從 keyNodeMap 刪除  \n        → // 若桶變空，freqListMap[minFreq] 會被自動刪除（或保持空）  \n    No  → // 不需要 evict  \n→ Step 30: 新建 node = Node(key, value, freq=1) // 建立新節點  \n→ Step 31: 取出 freqListMap[1] 為 list，若不存在則新建空桶並加入 freqListMap // 取得頻率 1 桶  \n→ Step 32: list.addNode(node) // 把新節點加入桶  \n→ Step 33: keyNodeMap[key] = node // 加入 keyNodeMap  \n→ Step 34: minFreq = 1 // 新節點頻率最低，重設 minFreq  \n→ Step 35: End of put // put 完成  \nEnd // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2,0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34,-10,-14,-10,10]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:  # '*'\n                                res.append(l * r)\n            if not res:  # expr is a number\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # Extract the expression string between double quotes\n    start = data.find('\"')\n    end = data.rfind('\"')\n    if start != -1 and end != -1 and start < end:\n        expr = data[start + 1:end]\n    else:\n        # Fallback: split by '=' and strip quotes if present\n        parts = data.split('=', 1)\n        if len(parts) == 2:\n            expr = parts[1].strip()\n            if expr.startswith('\"') and expr.endswith('\"'):\n                expr = expr[1:-1]\n        else:\n            expr = data  # use the whole input if no '='\n\n    solver = Solution()\n    results = solver.diffWaysToCompute(expr)\n\n    # Format output without spaces to match expected examples\n    output = '[' + ','.join(map(str, results)) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code steps line by line with explanation. The user wants algorithm to compute all possible results of different parenthesizations of expression string. That's the classic \"Different Ways to Add Parentheses\" problem. We'll produce steps like: Start, Step: parse input, recursive function compute(i,j) etc. Provide each line with // explanation. Use arrow format.\n\nLet's outline steps:\n\n- Start\n- Read expression string\n- Define recursive function compute(start,end)\n- If substring is number only, convert to int and return list [int]\n- Else iterate over operators index within start..end\n  - For each operator, recursively compute left results, right results\n  - Combine each left with right using operator, append to results\n- Return results\n- Call compute(0,len(expression)-1) -> all_results\n- Output all_results\n- End\n\nWe need to adhere to format: each line with \"虛擬碼步驟 // 解釋/說明\".\n\nAlso must use arrow arrows. Use \"→\" for continuation. Use \"Decision:\" for branching.\n\nOk produce lines accordingly. Use indentation for nested steps? In example they used indentation for nested branches. We'll follow similar.\n\nLet's craft.\n\nLine 1: Start // 程式開始執行\n\nLine 2: → Input: expression // 取得輸入字串\n\nLine 3: → Define Function compute(start, end): // 定義遞迴函式，計算子表達式的所有結果\n\nWithin function:\n\nLine 4: → Decision: 子字串是否為純數字? // 檢查是否為單一數字\n\nLine 5: Yes → Return [int(substring)] // 直接回傳數字\n\nLine 6: No → Initialize results = [] // 初始化結果列表\n\nLine 7: → For each operator index i from start to end:\n\nNeed nested lines.\n\nLine 8: → Decision: expression[i] 是否為運算子? // 判斷當前字符是否為 '+','-','*'\n\nLine 9: Yes → left = compute(start, i-1) // 計算左子表達式的所有結果\n\nLine10: → right = compute(i+1, end) // 計算右子表達式的所有結果\n\nLine11: → For each l in left:\n\nLine12: → For each r in right:\n\nLine13: → Combine using expression[i]: result = l op r\n\nLine14: → Append result to results\n\nLine15: No → Continue // 若不是運算子，忽略\n\nLine16: → End For\n\nLine17: → Return results // 回傳當前子表達式所有結果\n\nAfter function:\n\nLine18: → all_results = compute(0, len(expression)-1) // 取得整個表達式的所有結果\n\nLine19: → Output all_results // 顯示結果\n\nLine20: End // 程式結束\n\nMake sure each line includes \"虛擬碼步驟\" then space then \"// 解釋/說明\".\n\nUse Chinese explanations.\n\nAlso use arrow \"→\" before each step. For Decision branches use indentation with \"Yes →\" and \"No →\".\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: expression // 取得輸入字串  \n→ Define Function compute(start, end): // 定義遞迴函式，計算子表達式的所有結果  \n → Decision: 子字串是否為純數字? // 檢查是否為單一數字  \n  Yes → Return [int(substring)] // 直接回傳數字  \n  No → Initialize results = [] // 初始化結果列表  \n → For each operator index i from start to end: // 遍歷子字串中的每個位置  \n  → Decision: expression[i] 是否為運算子? // 判斷當前字符是否為 '+','-','*'  \n   Yes → left = compute(start, i-1) // 計算左子表達式的所有結果  \n    right = compute(i+1, end) // 計算右子表達式的所有結果  \n    → For each l in left: // 迭代左側結果  \n     → For each r in right: // 迭代右側結果  \n      → result = l op r // 使用運算子計算 l 與 r 的結果  \n      → Append result to results // 將結果加入列表  \n   No → Continue // 若不是運算子，忽略此位置  \n → End For  \n → Return results // 回傳當前子表達式的所有可能結果  \n→ all_results = compute(0, len(expression)-1) // 取得整個表達式的所有結果  \n→ Output all_results // 顯示結果  \nEnd // 程式結束"
    },
    {
      "title": "Basic Calculator",
      "source_file": "Leetcode/leetcode224.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"1 + 1\"",
          "expected_output": "2",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyno7b4cy.py\", line 64, in <module>\n    print(calculate(expression))\n          ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpyno7b4cy.py\", line 52, in calculate\n    result, _ = parse_expr(0)\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmpyno7b4cy.py\", line 15, in parse_expr\n    c = s[i]\n        ~^^^\nIndexError: string index out of range"
        },
        {
          "example_index": 1,
          "input": "s = \" 2-1 + 2 \"",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp6jusetda.py\", line 64, in <module>\n    print(calculate(expression))\n          ^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp6jusetda.py\", line 52, in calculate\n    result, _ = parse_expr(0)\n                ^^^^^^^^^^^^^\n  File \"/tmp/tmp6jusetda.py\", line 15, in parse_expr\n    c = s[i]\n        ~^^^\nIndexError: string index out of range"
        },
        {
          "example_index": 2,
          "input": "s = \"(1+(4+5+2)-3)+(6+8)\"",
          "expected_output": "23",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '23'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '23'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\n\ndef calculate(s: str) -> int:\n    \"\"\"\n    計算合法的算式字串，支援 +, -, *, / 與括號。\n    以遞迴方式解析子表達式，遵循運算優先順序。\n    \"\"\"\n    n = len(s)\n\n    def parse_expr(i: int):\n        stack = []          # 用來儲存已處理的數字或子表達式結果\n        num = 0             # 當前正在讀取的數字\n        op = '+'            # 上一個遇到的運算符（初始為 +）\n        while i < n:\n            c = s[i]\n\n            # 讀取數字\n            if c.isdigit():\n                num = num * 10 + int(c)\n\n            # 開啟括號：遞迴解析括號內部的表達式\n            elif c == '(':\n                val, i = parse_expr(i + 1)\n                num = val\n\n            # 當遇到運算符、右括號或字串結尾時，根據上一個運算符處理累加\n            if c in '+-*/)' or i == n - 1:\n                if op == '+':\n                    stack.append(num)\n                elif op == '-':\n                    stack.append(-num)\n                elif op == '*':\n                    stack.append(stack.pop() * num)\n                elif op == '/':\n                    top = stack.pop()\n                    # 除法向 0 方向截斷\n                    stack.append(int(top / num))\n                op = c\n                num = 0\n\n            # 遇到右括號即結束此遞迴層級\n            if c == ')':\n                i += 1\n                break\n\n            i += 1\n\n        return sum(stack), i\n\n    # 先去除空白，方便處理\n    s = ''.join(s.split())\n    result, _ = parse_expr(0)\n    return result\n\nif __name__ == \"__main__\":\n    # 從 stdin 讀取整個輸入，格式為:  s = \"...\"\n    data = sys.stdin.read()\n    first_quote = data.find('\"')\n    last_quote = data.rfind('\"')\n    if first_quote == -1 or last_quote == -1 or last_quote <= first_quote:\n        print(0)\n    else:\n        expression = data[first_quote + 1:last_quote]\n        print(calculate(expression))",
      "virtual_code": "Thinking...\nWe need to produce virtual code that explains evaluation of arithmetic expression string, likely containing + - * /. But typical basic calculator with + - * /. We should produce steps: parse numbers and operators, use stack for * / precedence, then sum. Provide line by line virtual code with explanation. We must not produce real code, only pseudocode.\n\nWe need to respond in Traditional Chinese.\n\nLet's craft steps:\n\nStart\n→ Initialize empty stack for numbers\n→ Initialize current number = 0, last operator = '+'\n→ Iterate over each character in s plus an extra '+' at end\n    → If char is digit, accumulate current number = current number * 10 + int(char)\n    → If char is operator or end of string:\n        → Decision: if last operator is '+'\n            Yes → Push current number onto stack\n        → Decision: if last operator is '-'\n            Yes → Push -current number onto stack\n        → Decision: if last operator is '*'\n            Yes → Pop top of stack, multiply by current number, push result\n        → Decision: if last operator is '/'\n            Yes → Pop top of stack, divide by current number (integer division), push result\n        → Update last operator to char\n        → Reset current number to 0\n→ After loop, sum all numbers in stack\n→ Return sum\nEnd\n\nNeed to format each line with // explanation.\n\nAlso ensure arrow formatting: Use '→'.\n\nAlso Decision lines: use indentation.\n\nWe need to include decisions for each operator, maybe combined with if statements.\n\nLet's produce as many lines as needed. Ensure each line ends with explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空堆疊 numbers，currentNum = 0，lastOp = '+' // 準備儲存數值與記錄最後操作符  \n→ Step 2: 將輸入字串 s 連接一個 '+', 並對每個字元遍歷 // 在結尾添加多餘符號方便最後一次處理  \n→ Decision: 如果 char 是數字? // 判斷目前字元是否為數字  \n Yes → Step 3: currentNum = currentNum * 10 + int(char) // 將數字拼接成完整整數  \n No → Decision: 如果 char 是運算符號 ( '+', '-', '*', '/' )? // 判斷是否為運算符或結束符號  \n  Yes → Decision: 如果 lastOp 是 '+'? // 根據上一次的運算符決定對堆疊的操作  \n   Yes → Step 4: 堆疊 numbers 推入 currentNum // 加號：直接加入正數  \n   No → Decision: 如果 lastOp 是 '-'?  \n    Yes → Step 5: 堆疊 numbers 推入 -currentNum // 減號：加入負數  \n    No → Decision: 如果 lastOp 是 '*'?  \n     Yes → Step 6: top = 堆疊 numbers 彈出，堆疊 numbers 推入 top * currentNum // 乘號：取前一數值相乘  \n     No → Decision: 如果 lastOp 是 '/'?  \n      Yes → Step 7: top = 堆疊 numbers 彈出，堆疊 numbers 推入 top // currentNum (整除) // 除號：取前一數值整除  \n      No → // 這裡不會發生  \n    // 重新設定為目前運算符並重置 currentNum  \n    → Step 8: lastOp = char  \n    → Step 9: currentNum = 0  \n→ End of 遍歷 // 完成所有字元的處理  \n→ Step 10: result = 堆疊 numbers 所有元素相加 // 將堆疊中所有數值累加得到最終結果  \n→ Step 11: 返回 result // 傳回計算結果  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport bisect\n\nclass Solution:\n    def __init__(self, w):\n        # 建立前綴和\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        # 隨機選取 1~total 的整數\n        target = random.randint(1, self.total)\n        # 二分搜尋最小索引\n        return bisect.bisect_left(self.prefix_sum, target)\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 依據是否有換行或逗號分隔\n    if '\\n' in data:\n        lines = data.splitlines()\n        commands_str = lines[0]\n        args_str = lines[1] if len(lines) > 1 else '[]'\n    else:\n        # 找到第一個 '],' 以分割指令與參數\n        idx = data.find('],')\n        if idx != -1:\n            commands_str = data[:idx+1]\n            args_str = data[idx+2:]\n        else:\n            # 若沒有找到，視整個字串為兩個列表，用空列表作備援\n            commands_str = data\n            args_str = '[]'\n    # 轉成列表\n    commands = json.loads(commands_str)\n    args_list = json.loads(args_str)\n\n    # 結果清單，首個元素對應於建構子呼叫\n    results = [None]\n    obj = None\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            obj = Solution(args[0])\n        elif cmd == \"pickIndex\":\n            results.append(obj.pickIndex())\n    # 輸出結果\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps line by line, with each line: \"虛擬碼步驟 // 解釋/說明\". Use arrow notation, Start, End, Decision etc.\n\nWe need to describe algorithm for pickIndex: build prefix sums, random uniform between 1 and total sum, binary search to find index.\n\nWe need to produce step-by-step. No actual code, only virtual steps.\n\nLet's design:\n\nStart\n→ Step 1: 接收 w // input weights array\n→ Step 2: 生成前綴和 prefixSum // cumulative sums\n→ Step 3: 計算總和 total // prefixSum[last]\n→ End of initialization\n\nThen pickIndex method:\n\n→ Start pickIndex // method start\n→ Step 4: 生成隨機數 r ∈ [1, total] // inclusive\n→ Step 5: 進行二分查找找到最小 idx 使 prefixSum[idx] ≥ r // binary search\n→ Step 6: 返回 idx // output\n\nBut we need line-by-line explanation. Also incorporate decision steps.\n\nWe can include: Decision: r <= prefixSum[0]? etc but we use binary search.\n\nBetter to show binary search loop:\n\n→ Step 5: 初始化 low = 0, high = len(prefixSum)-1 // 二分搜索範圍\n→ Decision: low <= high? // 搜索條件\n   Yes → Step 6: mid = (low+high)/2 // 計算中點\n        Decision: prefixSum[mid] < r? // r在右半區?\n           Yes → Step 7: low = mid+1 // 搜索右側\n           No  → Step 8: high = mid-1 // 搜索左側\n    No → Step 9: idx = low // 找到符合條件的索引\n\nReturn idx.\n\nFinally End.\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n\nAlso need to note that the initialization is part of constructor, not pickIndex. We'll produce a Start block for constructor and pickIndex.\n\nWe'll output each line sequentially, but it's okay to have multiple Start sections.\n\nWe'll produce something like:\n\nStart // 初始化構造函數開始\n→ Step 1: 存儲 w // 將輸入的權重陣列存入對象\n→ Step 2: 建立前綴和 prefixSum // 計算 cumulative sums\n→ Step 3: 迭代 w 計算 prefixSum[i] = prefixSum[i-1] + w[i]\n→ Step 4: 計算總和 total = prefixSum[last] // 總權重\n→ End // 初始化完成\n\nStart // pickIndex 方法開始\n→ Step 5: 生成隨機整數 r ∈ [1, total] // 以總和為上界的均勻分佈\n→ Step 6: low = 0, high = len(prefixSum)-1 // 二分搜索初始範圍\n→ Decision: low <= high? // 是否仍有範圍可搜索\n   Yes → Step 7: mid = (low + high) // 2 // 計算中點\n        Decision: prefixSum[mid] < r? // 隨機數落在右側區域\n           Yes → Step 8: low = mid + 1 // 將搜尋範圍縮小到右側\n           No  → Step 9: high = mid - 1 // 將搜尋範圍縮小到左側\n    No → Step 10: idx = low // low 指向符合條件的最小索引\n→ Step 11: 返回 idx // 回傳隨機選取的索引\nEnd // pickIndex 執行完畢\n\nWe should not use \"Step 5\" maybe \"Step 1\" etc but fine.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 初始化構造函數開始  \n→ Step 1: 存儲 w // 將輸入的權重陣列保存在物件內  \n→ Step 2: 建立前綴和 prefixSum // 準備累積權重以便後續查找  \n→ Step 3: 迭代 w 計算 prefixSum[i] = prefixSum[i‑1] + w[i] // 形成累積序列  \n→ Step 4: 計算總和 total = prefixSum[last] // 總權重作為隨機數上限  \nEnd // 初始化完成  \n\nStart // pickIndex 方法開始  \n→ Step 5: 生成隨機整數 r ∈ [1, total] // 以總和為上界的均勻分佈  \n→ Step 6: low = 0, high = len(prefixSum)-1 // 設定二分搜尋範圍  \n→ Decision: low <= high? // 是否還有區間可搜尋  \n   Yes → Step 7: mid = (low + high) // 2 // 取中點  \n        Decision: prefixSum[mid] < r? // r 位於右側嗎？  \n           Yes → Step 8: low = mid + 1 // 將搜尋範圍縮到右側  \n           No  → Step 9: high = mid - 1 // 將搜尋範圍縮到左側  \n    No → Step 10: idx = low // low 為符合條件的最小索引  \n→ Step 11: 返回 idx // 回傳隨機選取的索引  \nEnd // pickIndex 執行完畢"
    },
    {
      "title": "Cracking the Safe",
      "source_file": "Leetcode/leetcode753.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1, k = 2",
          "expected_output": "\"10\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '10'\nGot (Norm):      '01'\n--- (Raw) ---\nRaw Expected: '\"10\"'\nRaw Got:      '01'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef crack_safe(n: int, k: int) -> str:\n    \"\"\"\n    Generate a minimal-length string that contains every possible\n    sequence of length n over the alphabet [0, k-1] as a contiguous\n    substring (a de Bruijn sequence).\n    \"\"\"\n    seen = set()          # 已經生成的 n 位子字串\n    res = []              # 用來收集輸出的數字\n\n    def dfs(node: str) -> None:\n        \"\"\"\n        深度優先搜尋：從當前節點 node (長度 n-1) 開始，\n        嘗試添加每個可能的數字，若產生的子字串未被訪問\n        則遞迴繼續，並在返回時將數字加入結果。\n        \"\"\"\n        for x in map(str, range(k)):\n            nei = node + x\n            if nei not in seen:\n                seen.add(nei)\n                dfs(nei[1:])        # 移除最舊的字符，加入新字符\n                res.append(x)       # 在遞迴返回時添加\n\n    start = \"0\" * (n - 1)   # 初始節點（n-1 個 0）\n    dfs(start)\n\n    # 逆序 res 以符合範例輸出（任意順序皆可）\n    return \"\".join(reversed(res)) + start\n\n\ndef main() -> None:\n    \"\"\"\n    從標準輸入讀取 n 與 k，產生解鎖序列並輸出。\n    允許輸入形式為「n = 1, k = 2」或任何包含兩個整數的字串。\n    \"\"\"\n    data = sys.stdin.read()\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n    if len(numbers) != 2:\n        raise ValueError(\"輸入應包含兩個整數：n 和 k\")\n    n, k = numbers\n    answer = crack_safe(n, k)\n    print(answer)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to generate minimal length string that contains all possible sequences of length n over digits 0..k-1 as contiguous substrings. That's de Bruijn sequence. Minimal length is k^n + n - 1 (if we consider cyclic). For a string that unlocks at some point, we need linear string containing all sequences; minimal length is k^n + n -1. Steps: compute de Bruijn sequence using algorithm (preferably DFS). We'll produce virtual steps. Need to include Start, End, Decision. Let's craft.\n\nWe should output step-by-step algorithm. We'll break into phases: input n,k; create alphabet; define recursive function to build de Bruijn; produce output string.\n\nProvide explanation comments. Use arrow syntax.\n\nOk produce.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 讀取輸入 n, k // 取得密碼長度與數字範圍\n→ Step 2: 建立字母表 digits ← [0 … k-1] // 所有可用數字\n→ Step 3: 初始化空序列 sequence ← \"\" // 用於存放結果\n→ Step 4: 建立訪問標誌 visited ← {} // 追蹤已產生的 n-長子字串\n→ Decision: 是否需要遞迴產生序列? // 準備進行深度優先搜尋\n    Yes → Step 5: 呼叫 DFS(current ← [0] * (n-1)) // 從全 0 開始, 先存 n-1 個 0\n→ Step 5: DFS(current) // 定義深度優先搜尋\n    → Decision: 是否已訪問所有可能子字串? // 以 visited 大小比 k^n\n        Yes → Step 6: return // 所有子字串已生成，結束遞迴\n        No  → Step 7: 對每個 digit in digits\n            → Decision: 子字串 next ← current + digit 是否已訪問? // 檢查是否已產生\n                Yes → Continue // 跳過已訪問的子字串\n                No  → Step 8: 標記 visited ← visited ∪ {next} // 記錄新子字串\n                    → Step 9: sequence ← sequence + digit // 加入結果\n                    → Step 10: next_current ← (current[1:]) + digit // 移除最舊字元，加入新字元\n                    → Step 11: DFS(next_current) // 深度遞迴\n→ Step 12: 完成 DFS 後，將初始 n-1 個 0 加回結果\n    → Step 13: output ← (string of first n-1 zeros) + sequence // 形成最短線性序列\n→ Step 14: 輸出 output // 結果字串可在任意位置解鎖\nEnd // 程式執行結束"
    }
  ]
}