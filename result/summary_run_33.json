{
  "run_index": 33,
  "total_files_found": 391,
  "total_files_processed": 323,
  "files_skipped": 68,
  "files_failed_load": 0,
  "---": "--- (以下基於 *題目* 總數) ---",
  "total_problems_attempted": 334,
  "generation_and_validation_success_count": 292,
  "generation_or_validation_failure_count": 42,
  "failed_cases_details": [
    {
      "title": "統計文字行數",
      "source_file": "900.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "（假設 data.txt 內容如下）\\nHello\\nPython\\nWorld",
          "expected_output": "檔案共有 3 行",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '檔案共有3行'\nGot (Norm):      '檔案共有1行'\n--- (Raw) ---\nRaw Expected: '檔案共有 3 行'\nRaw Got:      '檔案共有 1 行'"
        }
      ],
      "generated_code": "import sys\n\ndef main() -> None:\n    \"\"\"\n    讀取標準輸入中的全部文字，將其拆成行並計算行數。\n    最後輸出「檔案共有 X 行」的訊息。\n    \"\"\"\n    # 讀取全部輸入\n    content = sys.stdin.read()\n    # splitlines() 會忽略最後一行的換行符號\n    lines = content.splitlines()\n    # 行數\n    line_count = len(lines)\n    # 輸出結果\n    print(f\"檔案共有 {line_count} 行\")\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanations. Must use virtual code syntax: Start, End, Decision, Yes →, No →, Step. Should reflect use of with, try/except. Should be line-by-line. Provide explanation after space. For example:\n\nStart // ...\n→ Step 1: Define file path // ...\n→ Decision: 如果文件存在? but we use try except, so maybe Step 2: try open file with 'with'. But we need to incorporate try/except. Let's design:\n\nStart\n→ Step 1: 將檔案路徑設定為 'data.txt' // 指定檔案名稱\n→ Decision: 是否準備進入 try? Actually just go to try block.\n\n→ Step 2: try 開啟檔案 with open(file_path, 'r') as f // 嘗試開啟檔案\n    → Step 3: count = 0 // 初始化行數\n    → Step 4: 迴圈: for line in f: count += 1 // 計算行數\n    → Step 5: 輸出 f'共 {count} 行' // 顯示行數\n    → Step 6: End // 程式結束\n\nBut we need to show except block: except FileNotFoundError: // 錯誤處理\n    → Step 7: 輸出 '找不到檔案！' // 顯示錯誤訊息\n    → Step 8: End // 程式結束\n\nBut we need to format with virtual code lines, using 'Decision:' maybe not needed. Could just use Step with indentation for try except. But we must keep the format: \"虛擬碼步驟 [space] // 解釋\". Use arrows and indentation.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 設定 file_path 為 'data.txt' // 定義檔案路徑\n→ Decision: 進入 try 區塊? // 進入錯誤處理流程\n    Yes → Step 2: try 開啟 file_path 並使用 with open(file_path, 'r') as f // 嘗試以 read 模式開啟檔案\n        → Step 3: count ← 0 // 初始化行數計數\n        → Step 4: for 每行 in f: count ← count + 1 // 逐行計算\n        → Step 5: 輸出 f'共 {count} 行' // 顯示總行數\n        → End // 成功完成\n    No → Decision: 發生 FileNotFoundError? // 檢查是否為檔案不存在\n        Yes → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息\n        No → End // 其他錯誤可忽略\nEnd // 程式執行結束\n\nBut maybe we need to show except block: Instead of Decision: Yes/No, we can show try/except as Step 2: try open...; Step 3: except FileNotFoundError: ... but in virtual code we might use Decision to simulate exception path. Use \"Decision:\" with Yes/No to indicate if exception occurs.\n\nLet's produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 file_path 為 'data.txt' // 定義要讀取的檔案路徑  \n→ Decision: 進入 try 區塊? // 進入錯誤處理流程  \n Yes → Step 2: try 開啟 file_path 並使用 with open(file_path, 'r') as f // 嘗試以讀取模式開啟檔案  \n  → Step 3: count ← 0 // 初始化行數計數器  \n  → Step 4: for line in f: count ← count + 1 // 逐行讀取並累加  \n  → Step 5: 輸出 f'共 {count} 行' // 顯示總行數  \n  → End // 成功完成執行  \n No → Decision: 是否發生 FileNotFoundError? // 判斷是否為檔案不存在的錯誤  \n  Yes → Step 6: 輸出 '找不到檔案！' // 顯示錯誤訊息  \n  No → End // 其他錯誤可忽略或另行處理  \nEnd // 程式執行結束"
    },
    {
      "title": "模擬擲骰子遊戲",
      "source_file": "800.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "print(roll_dice(5))",
          "expected_output": "[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[3,6,1,4,2]#(結果會隨機，每次可能不同)'\nGot (Norm):      '[4,4,4,4,2]'\n--- (Raw) ---\nRaw Expected: '[3, 6, 1, 4, 2]   # (結果會隨機，每次可能不同)'\nRaw Got:      '[4, 4, 4, 4, 2]'"
        }
      ],
      "generated_code": "import random\n\ndef roll_dice(n):\n    \"\"\"\n    擲 n 次六面骰子，返回結果列表。\n    \"\"\"\n    results = []\n    for _ in range(n):\n        results.append(random.randint(1, 6))\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    # 讀取所有輸入（可能是一行或多行程式碼）\n    code = sys.stdin.read()\n    # 執行輸入程式碼，前提是輸入中會使用到 roll_dice 函式\n    exec(code)",
      "virtual_code": "Thinking...\nThe user requests to produce virtual code in the specified format for a function roll_dice(n) that uses random module to simulate rolling a six-sided die n times and returns a list of results.\n\nWe need to output step by step virtual code, each line has code then // explanation. Must use arrows and structure: Start, End, Decision: etc. Must include '虛擬碼步驟' but in this context we just output code. Format sample: Start, → Step 1: etc. We must not output actual code. Just virtual steps. We should include import of random, define function, maybe a loop, append results, return list, End.\n\nUse \"Start // 程式開始執行\" then arrow etc.\n\nMake sure to use \"→\" arrow before each step after Start. Include Decision maybe for checking n>0 etc. Not necessary but could include.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 匯入 random 模組 // 引入隨機數功能\n→ Step 2: 定義函數 roll_dice(n) // 建立擲骰子函數\n→ Decision: n 是否為正整數? // 檢查輸入是否合法\n    Yes → Step 3: 建立空列表 results // 用於存放骰子結果\n    → Step 4: 為 i 從 1 到 n 迴圈 // 重複擲骰子 n 次\n        → Step 5: 產生 random.randint(1,6) // 隨機產生 1-6\n        → Step 6: 將結果 append 到 results // 加入結果\n    → Step 7: 回傳 results // 將所有結果返回\n    No  → Step 8: 回傳空列表 // 非正整數時回傳空結果\nEnd // 程式執行結束\n\nWe must ensure each line ends with // explanation. Also maintain correct indentation? Not necessary. The sample uses arrows and indentations with tabs. We'll mimic sample.\n\nNeed to output \"Start\", then \"→ Step 1:\", etc.\n\nMake sure the code lines are separated by newline. Use the exact format.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 匯入 random 模組 // 引入隨機數功能  \n→ Step 2: 定義函數 roll_dice(n) // 建立擲骰子函數  \n→ Decision: n 是否為正整數? // 檢查輸入是否合法  \n Yes → Step 3: 建立空列表 results // 用於存放骰子結果  \n  → Step 4: 為 i 從 1 到 n 迴圈 // 重複擲骰子 n 次  \n   → Step 5: 產生 random.randint(1,6) // 隨機產生 1-6  \n   → Step 6: 將結果 append 到 results // 加入結果  \n  → Step 7: 回傳 results // 將所有結果返回  \n No  → Step 8: 回傳空列表 // 非正整數時回傳空結果  \nEnd // 程式執行結束"
    },
    {
      "title": "計算程式執行時間",
      "source_file": "800.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "import time\n\ndef slow_add(a, b):\n    time.sleep(2)\n    return a + b\n\nprint(measure_time(slow_add, 3, 5))",
          "expected_output": "約 2.0 秒 (依電腦執行環境略有差異)",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '約2.0秒(依電腦執行環境略有差異)'\nGot (Norm):      '2.0'\n--- (Raw) ---\nRaw Expected: '約 2.0 秒 (依電腦執行環境略有差異)'\nRaw Got:      '2.0'"
        }
      ],
      "generated_code": "import time\nimport sys\n\ndef measure_time(func, *args):\n    \"\"\"\n    測量傳入函式 func 執行所需秒數，並四捨五入至小數點 3 位回傳。\n    \"\"\"\n    start = time.time()\n    func(*args)\n    end = time.time()\n    return round(end - start, 3)\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整程式碼並執行\n    code = sys.stdin.read()\n    exec(code, globals())",
      "virtual_code": "Thinking...\nWe need to produce virtual code, line by line, with explanation. Use Start, End, Decision, arrow. The code is to define a function measure_time(func, *args) that measures time. Use time module. We should write virtual steps like: import time, define function, start timer, call func, stop timer, compute elapsed, round to 3 decimals, return result. Also maybe return elapsed time? Problem says \"並回傳結果 (四捨五入到小數點 3 位)\". It could mean return the measured time. We'll interpret that we need to return the elapsed time rounded to 3 decimals.\n\nSo virtual steps:\n\nStart\n\n→ Step 1: Import time module // get time functionality\n\n→ Step 2: Define function measure_time(func, *args) // function signature\n\n→ Step 3: Inside function: Record start time // capture start\n\n→ Step 4: Execute func(*args) and store result // run function\n\n→ Step 5: Record end time // capture end\n\n→ Step 6: Calculate elapsed = end - start // difference\n\n→ Step 7: Round elapsed to 3 decimal places // rounding\n\n→ Step 8: Return rounded elapsed // return value\n\nEnd\n\nBut we need to use arrow for decisions? Not needed. So just steps. Use \"Step\" numbering or \"→ Step 1:\".\n\nMake sure each line ends with // explanation.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: import time // 引入 time 模組以取得時間功能  \n→ Step 2: define function measure_time(func, *args) // 定義測量時間的函式，接收待測函式及其參數  \n→ Step 3:    start_time ← time.time() // 記錄函式執行前的起始時間  \n→ Step 4:    result ← func(*args) // 執行待測函式並保存其回傳結果  \n→ Step 5:    end_time ← time.time() // 記錄函式執行後的結束時間  \n→ Step 6:    elapsed ← end_time - start_time // 計算實際執行所需的秒數  \n→ Step 7:    rounded_elapsed ← round(elapsed, 3) // 將秒數四捨五入至小數點第三位  \n→ Step 8:    return rounded_elapsed // 回傳經四捨五入後的執行時間  \nEnd // 程式執行結束"
    },
    {
      "title": "集合函數練習",
      "source_file": "600.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "無（程式內建立）",
          "expected_output": "{'apple', 'orange', 'grape', 'melon'}",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '{\"apple\",\"orange\",\"grape\",\"melon\"}'\nGot (Norm):      '{\"orange\",\"melon\",\"apple\",\"grape\"}'\n--- (Raw) ---\nRaw Expected: \"{'apple', 'orange', 'grape', 'melon'}\"\nRaw Got:      \"{'orange', 'melon', 'apple', 'grape'}\""
        }
      ],
      "generated_code": "import sys\n\ndef main():\n    # 讀取 stdin（若有輸入，僅為消費，實際邏輯不依賴）\n    sys.stdin.read()\n\n    # 初始化集合\n    fruits = {'apple', 'banana'}\n\n    # 1. 新增 'orange'\n    fruits.add('orange')\n\n    # 2. 一次新增 'grape' 與 'melon'\n    fruits.update(['grape', 'melon'])\n\n    # 3. 移除 'banana'\n    fruits.remove('banana')\n\n    # 4. 嘗試移除不存在的 'pineapple'\n    fruits.discard('pineapple')\n\n    # 輸出最終集合\n    print(fruits)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines per step. Use Start, End, Decision maybe not needed. But just show steps. Provide line numbers? Not needed. Just each line. Provide the virtual code step followed by space and // explanation.\n\nThe requirement: use virtual code arrows, etc. The example shows \"Start // 程式開始執行\". Use \"→\" for next line. Provide operations: Create set, add, update, remove, discard, print.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: Set fruits ← {'apple', 'banana'} // 初始化集合\n→ Step 2: Call fruits.add('orange') // 新增 'orange'\n→ Step 3: Call fruits.update({'grape', 'melon'}) // 一次新增多個元素\n→ Step 4: Call fruits.remove('banana') // 移除 'banana'\n→ Step 5: Call fruits.discard('pineapple') // 嘗試移除不存在的元素\n→ Step 6: Print fruits // 輸出最終集合\nEnd // 程式結束\n\nMake sure arrow symbol used: \"→\". Use \"Step\" label. Provide explanation after //. Done.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Set fruits ← {'apple', 'banana'} // 初始化集合，包含 'apple' 與 'banana'  \n→ Step 2: Call fruits.add('orange') // 使用 add() 新增單一元素 'orange'  \n→ Step 3: Call fruits.update({'grape', 'melon'}) // 使用 update() 同時加入 'grape' 與 'melon'  \n→ Step 4: Call fruits.remove('banana') // 使用 remove() 刪除 'banana'，若不存在則拋錯誤  \n→ Step 5: Call fruits.discard('pineapple') // 使用 discard() 嘗試刪除 'pineapple'，但不會拋錯誤  \n→ Step 6: Print fruits // 輸出最終的集合內容  \nEnd // 程式結束執行"
    },
    {
      "title": "即時匯率查詢小工具",
      "source_file": "1200.json",
      "problem_index_in_file": 1,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "按下「更新匯率」按鈕",
          "expected_output": "目前美元匯率：約 32.5 TWD",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '目前美元匯率：約32.5TWD'\nGot (Norm):      '目前美元匯率：約30.57TWD'\n--- (Raw) ---\nRaw Expected: '目前美元匯率：約 32.5 TWD'\nRaw Got:      '目前美元匯率：約 30.57 TWD'"
        }
      ],
      "generated_code": "import requests\nimport sys\n\ndef get_rate():\n    try:\n        url = 'https://api.exchangerate-api.com/v4/latest/USD'\n        r = requests.get(url, timeout=10)\n        r.raise_for_status()\n        data = r.json()\n        rate = data['rates']['TWD']\n        return f'目前美元匯率：約 {rate} TWD'\n    except Exception:\n        return '更新失敗，請檢查網路連線'\n\ndef main():\n    # 讀取任何輸入，避免輸入對程式執行有影響\n    sys.stdin.read()\n    result = get_rate()\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output virtual code lines with explanation. Must not output actual code, just structure. Should use Start, End, Decision, etc. Steps: import modules, create Tk root, create button, function to fetch, parse JSON, update label, button command, main loop. Use requests and tkinter. Use arrows. Need to produce each line with explanation. Ensure each line is separate. Let's write.\n\nRemember to include \"虛擬碼步驟\" and then comment. Format: \"Start // 程式開始執行\". Use \"→\" for arrows. Use \"Decision:\" for if. Use \"Yes →\", \"No →\". So we can produce.\n\nWe don't need actual code, just steps. Should include steps: import, create window, create label, function fetch_rate, call API, parse, update label, button creation, set command, mainloop, End.\n\nLet's produce.\n\nAlso need to include decision for HTTP status. Use Decision. Good.\n\nLet's write lines.\n...done thinking.\n\nStart // 程式開始執行  \n→ 虛擬碼步驟: 導入 requests 模組並導入 tkinter 的所有內容 // 準備網路請求和 GUI 元件  \n→ 虛擬碼步驟: 建立 tkinter 視窗物件 root // GUI 主視窗  \n→ 虛擬碼步驟: 建立顯示匯率的 Label，初始文字為 '匯率待更新' // 供使用者查看匯率  \n→ 虛擬碼步驟: 定義函式 fetch_rate() 用於向 API 取得資料 // 主要業務邏輯  \n→ 虛擬碼步驟: 在 fetch_rate() 內部，使用 requests.get() 請求 https://api.exchangerate-api.com/v4/latest/USD // 發送 GET 請求  \n→ Decision: 檢查 HTTP 狀態碼是否為 200? // 確保請求成功  \n    Yes → 虛擬碼步驟: 解析回傳 JSON，取得 rates.TWD 的值 // 取得台幣匯率  \n    Yes → 虛擬碼步驟: 將匯率格式化為字串，並更新 Label 的文字為 '1 USD = X TWD' // 顯示匯率  \n    No  → 虛擬碼步驟: 更新 Label 文字為 '取得匯率失敗' // 顯示錯誤訊息  \n→ 虛擬碼步驟: 建立 Button，文字為 '更新匯率' 並將 command 設定為 fetch_rate // 使用者點擊更新  \n→ 虛擬碼步驟: 使用 pack() 或 grid() 放置 Label 與 Button 到 root 視窗 // 布局排列  \n→ 虛擬碼步驟: 呼叫 root.mainloop() 開始事件迴圈 // 進入 GUI 事件處理  \nEnd // 程式執行結束"
    },
    {
      "title": "Top K Frequent Elements",
      "source_file": "Leetcode/leetcode347.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,1,1,2,2,3], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp4q36wm3v.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmp4q36wm3v.py\", line 23, in main\n    k_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 2,
          "input": "nums = [1,2,1,2,1,2,3,1,3,2], k = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp59mztnxu.py\", line 32, in <module>\n    main()\n  File \"/tmp/tmp59mztnxu.py\", line 23, in main\n    k_part = parts[1].split('=')[1].strip()\n             ~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport heapq\nfrom collections import Counter\n\ndef topKFrequent(nums, k):\n    \"\"\"回傳頻率最高的 k 個元素\"\"\"\n    if k == 0:\n        return []\n    # 統計每個元素的出現次數\n    freq = Counter(nums)\n    # 取出頻率最高的 k 個項目\n    return [item for item, _ in heapq.nlargest(k, freq.items(), key=lambda x: x[1])]\n\ndef main():\n    # 讀取整個輸入字串\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析格式為 \"nums = [...], k = ...\"\n    parts = data.split(',')\n    nums_part = parts[0].split('=')[1].strip()\n    k_part = parts[1].split('=')[1].strip()\n\n    nums = eval(nums_part)          # 轉成 list\n    k = int(k_part)                 # 轉成 int\n\n    result = topKFrequent(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps. Should describe algorithm: count frequencies, use heap or bucket sort, get top k. We'll use bucket sort approach: count freq, build buckets of values by freq, iterate from high freq to low until k elements collected. Provide virtual code with Start, End, Decisions. Each line with arrow and explanation. Use \"→\". Should be step-by-step. Provide comments. No actual code. Use the required format.\n\nLet's draft:\n\nStart\n→ Step 1: 建立空字典 freq // 用來記錄每個元素出現次數\n→ Step 2: 逐個元素遍歷 nums，累加 freq\n→ Step 3: 取得最大頻率 maxFreq // 方便建立桶\n→ Step 4: 建立桶 buckets，長度 maxFreq+1 // 每個索引代表頻率，存儲對應元素集合\n→ Step 5: 將 freq 中每個元素放入對應頻率桶\n→ Decision: k == 0? // 若 k 為 0，直接返回空陣列\n    Yes → Step 6: 返回空陣列 // 結束\n    No → Step 7: 建立空結果列表 result\n→ Step 8: 從 maxFreq 降至 1 迴圈，累加桶中的元素到 result\n    Decision: result 長度已達 k? // 檢查是否已收集足夠\n        Yes → Break // 退出迴圈\n        No  → Continue\n→ Step 9: 回傳 result[:k] // 只取前 k 個\nEnd\n\nNeed to ensure \"→ Decision\" format. Provide explanation after \"//\".\n\nLet's format each line with arrow and comment. Use proper indentation? The example shows indentation inside Decision. We can indent with tab or spaces. I'll use two spaces before nested lines.\n\nWe'll output:\n\nStart // 程式開始執行\n→ Step 1: 初始化字典 freq // 用於儲存每個元素的頻率\n→ Step 2: 對 nums 中每個值 v 進行\n  → freq[v] = freq.get(v, 0) + 1 // 累加頻率\n→ Step 3: maxFreq = max(freq.values()) // 找出最高頻率\n→ Step 4: 建立長度 maxFreq+1 的桶 buckets // index 代表頻率\n→ Step 5: 對 freq 中每個 (value, count) 進行\n  → buckets[count].append(value) // 把元素放到對應頻率桶\n→ Decision: k == 0? // 若 k 為 0，直接返回空陣列\n    Yes → Step 6: return [] // 結束\n    No  → Step 7: result = [] // 用於存放最頻繁元素\n→ Step 8: 從 freq 值的最大頻率 maxFreq 迴圈到 1\n  → for freq_level in range(maxFreq, 0, -1):\n    → for val in buckets[freq_level]:\n      → result.append(val) // 加入結果\n      → if len(result) == k:\n          → Break // 已收集 k 個\n→ Step 9: return result // 回傳前 k 個最頻繁元素\nEnd // 程式執行結束\n\nWe need each line with \"→\" arrow and explanation. Indentation inside loops and decisions must maintain arrow lines. In example, nested lines are prefixed with \"→\". So we can keep consistent. We'll ensure each nested line has its own arrow.\n\nLet's write final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立空字典 freq // 用來記錄每個元素的頻率  \n→ Step 2: 逐個遍歷 nums 中的元素 v  \n  → freq[v] = freq.get(v, 0) + 1 // 將 v 的頻率累加  \n→ Step 3: maxFreq = max(freq.values()) // 取得最高頻率  \n→ Step 4: 建立長度 maxFreq+1 的桶 buckets // 索引代表頻率  \n→ Step 5: 對 freq 中的每個 (value, count) 進行  \n  → buckets[count].append(value) // 把 value 放到對應頻率桶  \n→ Decision: k == 0? // 若 k 為 0，直接回傳空陣列  \n    Yes → Step 6: return [] // 結束  \n    No  → Step 7: result = [] // 用於存放最頻繁的元素  \n→ Step 8: 從 maxFreq 迴圈至 1  \n  → for freq_level in range(maxFreq, 0, -1): // 依頻率遞減  \n    → for val in buckets[freq_level]: // 取桶中的每個值  \n      → result.append(val) // 加入結果  \n      → if len(result) == k: // 已收集足夠元素  \n          → Break // 跳出內部迴圈  \n→ Step 9: return result // 回傳前 k 個最頻繁元素  \nEnd // 程式執行結束"
    },
    {
      "title": "Random Flip Matrix",
      "source_file": "Leetcode/leetcode519.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"], [[3, 1], [], [], [], [], []]",
          "expected_output": "[null, [1,0], [2,0], [0,0], null, [2,0]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[1,0],[2,0],[0,0],null,[2,0]]'\nGot (Norm):      '[null,[1,0],[2,0],[0,0],null,[0,0]]'\n--- (Raw) ---\nRaw Expected: '[null, [1,0], [2,0], [0,0], null, [2,0]]'\nRaw Got:      '[null, [1, 0], [2, 0], [0, 0], null, [0, 0]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\n\nclass Solution:\n    def __init__(self, n_rows: int, n_cols: int) -> None:\n        \"\"\"初始化矩陣大小，所有格子皆為 0。\"\"\"\n        self.rows = n_rows\n        self.cols = n_cols\n        self.total = n_rows * n_cols          # 還未被翻轉的 0 的格子數\n        self.flipped = {}                     # 映射已被交換的索引\n\n    def flip(self) -> list[int]:\n        \"\"\"隨機挑選一個還為 0 的格子，翻轉成 1，並返回其座標。\"\"\"\n        # 隨機取得 0 ~ total-1 之間的索引\n        r = random.randint(0, self.total - 1)\n\n        # 如果 r 已經被交換過，則取其映射值；否則直接使用 r 本身\n        idx = self.flipped.get(r, r)\n\n        # 取得最後一個剩餘格子的實際索引\n        last_idx = self.flipped.get(self.total - 1, self.total - 1)\n\n        # 將 r 位置映射到最後一個格子\n        self.flipped[r] = last_idx\n\n        # 已翻轉一格，剩餘格子數減 1\n        self.total -= 1\n\n        # 將一次維度的索引轉回 2D 座標\n        row = idx // self.cols\n        col = idx % self.cols\n        return [row, col]\n\n    def reset(self) -> None:\n        \"\"\"將所有格子重置為 0。\"\"\"\n        self.total = self.rows * self.cols\n        self.flipped.clear()\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入，將其包裝為一個 JSON 陣列以方便解析\n    raw_input = sys.stdin.read().strip()\n    if raw_input:\n        wrapped = f'[{raw_input}]'\n        try:\n            ops, args_list = json.loads(wrapped)\n        except json.JSONDecodeError:\n            # 若輸入格式不符合預期，直接結束\n            sys.exit(0)\n    else:\n        sys.exit(0)\n\n    res = []\n    sol = None\n    for op, arg in zip(ops, args_list):\n        if op == \"Solution\":\n            sol = Solution(*arg)\n            res.append(None)          # 代表 null\n        elif op == \"flip\":\n            res.append(sol.flip())\n        elif op == \"reset\":\n            sol.reset()\n            res.append(None)          # 代表 null\n\n    # 輸出結果，使用 JSON 以得到 null 的格式\n    print(json.dumps(res))",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for the algorithm. Approach: Use reservoir-like approach: flatten indices into range [0, m*n-1], maintain list mapping of available indices. Initially mapping[i] = i. After picking random r in [0, total-1], swap mapping[r] with mapping[total-1], reduce total. Convert flat index to 2D: row = idx / n, col = idx % n. reset() reset total = m*n, clear mapping? Use dictionary to store only swapped values: map[r] if swapped, else r. We can use hashmap to store mapping of indices that have been swapped. That's typical solution.\n\nWe need to produce virtual code lines describing algorithm step by step. Each line: \"虛擬碼步驟 // 解釋\". Use arrows etc.\n\nLet's produce:\n\nStart\n→ Step 1: 初始化 m, n, total = m * n // 計算總格子數\n→ Step 2: 建立空映射 map // 用於存儲已交換的索引\nEnd\n\nBut we need to show class methods.\n\nWe might do:\n\nStart // 程式開始執行\n→ Step 1: 宣告變數 m, n, total, map // m, n 為矩陣尺寸，total 為剩餘 0 的格子數，map 用於映射\n→ Step 2: Reset() // 初始化或重置所有值\n    → Step 3: total ← m * n // 重新設為全 0\n    → Step 4: 清空 map // 清除所有映射\n→ End\n\nThen flip()\n\n→ Step 5: flip() // 隨機選擇一個 0 的格子並翻轉\n    → Step 6: r ← random(0, total - 1) // 取得隨機索引\n    → Step 7: idx ← map.get(r, r) // 若映射存在則取映射值，否則使用自身\n    → Step 8: last ← map.get(total - 1, total - 1) // 取最後一個剩餘索引\n    → Step 9: map[r] ← last // 將 r 位置更新為最後一個索引\n    → Step 10: total ← total - 1 // 减少可選格子數\n    → Step 11: row ← idx / n // 轉換為行\n    → Step 12: col ← idx % n // 轉換為列\n    → Step 13: 返回 [row, col] // 回傳翻轉位置\n→ End\n\nAlso mention decision? maybe not needed.\n\nWe need to use arrows and decisions maybe. But not mandatory. We can include decisions for resetting mapping etc. But it's okay.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 宣告變數 m, n, total, map // m、n 為矩陣尺寸，total 為剩餘 0 的格子數，map 用於存儲已交換的索引  \n→ Step 2: Reset() // 重置所有值  \n    → Step 3: total ← m * n // 重新設為全 0  \n    → Step 4: 清空 map // 清除所有映射  \n→ Step 5: flip() // 隨機選擇一個 0 的格子並翻轉  \n    → Step 6: r ← random(0, total - 1) // 取得隨機索引  \n    → Step 7: idx ← map.get(r, r) // 若映射存在則取映射值，否則使用自身  \n    → Step 8: last ← map.get(total - 1, total - 1) // 取最後一個剩餘索引  \n    → Step 9: map[r] ← last // 將 r 位置更新為最後一個索引  \n    → Step 10: total ← total - 1 // 減少可選格子數  \n    → Step 11: row ← idx / n // 轉換為行  \n    → Step 12: col ← idx % n // 轉換為列  \n    → Step 13: return [row, col] // 回傳翻轉位置  \nEnd // 程式執行結束"
    },
    {
      "title": "Teemo Attacking",
      "source_file": "Leetcode/leetcode495.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "timeSeries = [1,4], duration = 2",
          "expected_output": "4",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpk3qe1uge.py\", line 34, in <module>\n    timeSeries = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "timeSeries = [1,2], duration = 2",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppwzqia5b.py\", line 34, in <module>\n    timeSeries = ast.literal_eval(val)\n                 ^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def findPoisonedDuration(self, timeSeries, duration):\n        if not timeSeries:\n            return 0\n        total = 0\n        prev = None\n        for t in timeSeries:\n            if prev is not None and t <= prev + duration - 1:\n                total += duration - (t - prev)\n            else:\n                total += duration\n            prev = t\n        return total\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將多行輸入轉成一行，方便解析\n    data = data.replace(\"\\n\", \" \").strip()\n    parts = [p.strip() for p in data.split(\",\")]\n    timeSeries = []\n    duration = 0\n    for part in parts:\n        if not part:\n            continue\n        key, val = part.split(\"=\", 1)\n        key = key.strip()\n        val = val.strip()\n        if key == \"timeSeries\":\n            timeSeries = ast.literal_eval(val)\n        elif key == \"duration\":\n            duration = int(val)\n    result = Solution().findPoisonedDuration(timeSeries, duration)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines step by step for problem: compute total poisoned time. Provide pseudo steps line by line. Use structure: Start, decisions etc. Provide each line with explanation comment after //.\n\nWe need to output just virtual code lines. No actual code. Use arrows. Provide steps: initialize total=0, prevAttack= -inf, loop over timeSeries. For each time, if current <= prevAttack+duration-1 then overlap, add only new part: duration - (current - prevAttack). Else add full duration. Update prevAttack to current. After loop, return total. Use decision to check overlap.\n\nLet's create lines:\n\nStart\n→ Step 1: 初始化 total = 0 // 計算總毒持續時間\n→ Step 2: 初始化 prev = -infinity // 前一次攻擊時間\n→ For each attack time in timeSeries: // 迭代每一次攻擊\n    → Decision: 如果 time <= prev + duration - 1? // 判斷與上一毒劑是否重疊\n        Yes → Step 3: total += duration - (time - prev) // 只計算未重疊部分\n        No  → Step 4: total += duration // 完全不重疊，直接加全長\n    → Step 5: prev = time // 更新前一次攻擊時間\n→ Step 6: Return total // 回傳總毒持續秒數\nEnd\n\nNeed to add arrows accordingly: For loop we might show \"→ For each t in timeSeries:\" then indent. Use arrow to next lines. Provide indentation maybe with tab or spaces? But just each line separate. Use arrow before each step.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: total ← 0 // 計算總毒持續秒數  \n→ Step 2: prev ← -∞ // 前一次攻擊時間（初始化為負無限大）  \n→ For each t in timeSeries: // 逐個處理每一次攻擊  \n  → Decision: 如果 t ≤ prev + duration - 1? // 判斷此攻擊是否與上一段毒劑重疊  \n    Yes → Step 3: total ← total + duration - (t - prev) // 只計算未重疊的時間  \n    No  → Step 4: total ← total + duration // 完全不重疊，直接加入整段毒效時間  \n  → Step 5: prev ← t // 更新前一次攻擊時間為本次攻擊時刻  \n→ Step 6: Return total // 回傳 Ashe 總共被毒的秒數  \nEnd // 程式執行結束"
    },
    {
      "title": "Remove Invalid Parentheses",
      "source_file": "Leetcode/leetcode301.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"()())()\"",
          "expected_output": "[\"(())()\",\"()()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(())()\",\"()()()\"]'\nGot (Norm):      '[\"(())\",\"()()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(())()\",\"()()()\"]'\nRaw Got:      \"['(())', '()()']\""
        },
        {
          "example_index": 1,
          "input": "s = \"(a)())()\"",
          "expected_output": "[\"(a())()\",\"(a)()()\"]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[\"(a())()\",\"(a)()()\"]'\nGot (Norm):      '[\"(a())\",\"(a)()\"]'\n--- (Raw) ---\nRaw Expected: '[\"(a())()\",\"(a)()()\"]'\nRaw Got:      \"['(a())', '(a)()']\""
        }
      ],
      "generated_code": "import sys\n\ndef remove_invalid_parentheses(s: str):\n    # 先計算需要刪除的左括號與右括號\n    left_rem, right_rem = 0, 0\n    for ch in s:\n        if ch == '(':\n            left_rem += 1\n        elif ch == ')':\n            if left_rem > 0:\n                left_rem -= 1\n            else:\n                right_rem += 1\n\n    res = set()\n\n    def dfs(idx, left_cnt, right_cnt, l_rem, r_rem, path):\n        # 當左右括號數相等且沒剩下要刪除時，已完成合法字串\n        if l_rem == 0 and r_rem == 0 and left_cnt == right_cnt:\n            res.add(path)\n            return\n        if idx == len(s):\n            return\n\n        ch = s[idx]\n        if ch == '(':\n            # 方案 1：刪除這個 '('\n            if l_rem > 0:\n                dfs(idx + 1, left_cnt, right_cnt, l_rem - 1, r_rem, path)\n            # 方案 2：保留這個 '('\n            dfs(idx + 1, left_cnt + 1, right_cnt, l_rem, r_rem, path + ch)\n        elif ch == ')':\n            # 方案 1：刪除這個 ')'\n            if r_rem > 0:\n                dfs(idx + 1, left_cnt, right_cnt, l_rem, r_rem - 1, path)\n            # 方案 2：保留這個 ')', 但只能在 left_cnt > right_cnt 時\n            if left_cnt > right_cnt:\n                dfs(idx + 1, left_cnt, right_cnt + 1, l_rem, r_rem, path + ch)\n        else:\n            # 普通字元，直接保留\n            dfs(idx + 1, left_cnt, right_cnt, l_rem, r_rem, path + ch)\n\n    dfs(0, 0, 0, left_rem, right_rem, \"\")\n    return list(res)\n\n\ndef parse_input(raw: str) -> str:\n    \"\"\"\n    從輸入文字中抽取字串 s\n    支援兩種格式：\n        1. s = \"...\"\n        2. 直接給字串\n    \"\"\"\n    raw = raw.strip()\n    if '=' in raw:\n        _, value = raw.split('=', 1)\n        value = value.strip()\n    else:\n        value = raw\n    # 去掉可能存在的單/雙引號\n    if (value.startswith('\"') and value.endswith('\"')) or \\\n       (value.startswith(\"'\") and value.endswith(\"'\")):\n        value = value[1:-1]\n    return value\n\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    input_text = sys.stdin.read()\n    # 以換行分割取得第一行作為輸入\n    first_line = input_text.strip().splitlines()[0] if input_text else \"\"\n    s = parse_input(first_line)\n    result = remove_invalid_parentheses(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for problem: remove minimum parentheses to make string valid, return all unique strings. It's classic LeetCode 301. Approach: BFS or DFS with pruning. We'll produce virtual steps: Start, compute number of left and right to remove, DFS recursion, use backtracking, skip duplicates, etc. Output list.\n\nWe need to produce step-by-step pseudocode lines with explanations. Use arrows and decision structures. Provide unique results. Provide algorithmic logic.\n\nWe must output line by line.\n\nLet's craft pseudocode:\n\nStart\n\n→ Step 1: 定義函數 removeInvalidParentheses(s)\n\n→ Step 2: 計算需要刪除的左括號 remLeft 及右括號 remRight\n\n→ Step 3: 初始化結果集合 result\n\n→ Step 4: 定義遞迴函數 dfs(index, leftCount, rightCount, remL, remR, path)\n\n→ Step 5: Decision: 如果 remL==0 且 remR==0 且 leftCount==rightCount → Add path to result // 完成合法字串\n\n→ Step 6: Decision: index == len(s) → return // 到達字串結束\n\n→ Step 7: Get char c = s[index]\n\n→ Step 8: Decision: c == '(' ?\n\n        → Decision: remL > 0? // 是否可以刪除\n                Yes → dfs(index+1, leftCount, rightCount, remL-1, remR, path) // 刪除此 '('\n        → dfs(index+1, leftCount+1, rightCount, remL, remR, path + c) // 保留 '('\n\n        No → Decision: c == ')' ?\n\n                → Decision: remR > 0? \n                        Yes → dfs(index+1, leftCount, rightCount, remL, remR-1, path) // 刪除 ')'\n                → Decision: leftCount > rightCount? // 是否能保留\n                        Yes → dfs(index+1, leftCount, rightCount+1, remL, remR, path + c) // 保留 ')'\n                No → dfs(index+1, leftCount, rightCount, remL, remR, path + c) // 其他字元，直接保留\n\n→ Step 9: Start dfs(0,0,0,remLeft,remRight,\"\")\n\n→ Step 10: Return result as list\n\nEdge: avoid duplicates: Use set.\n\nLet's produce step-by-step lines with arrow and explanation. Use Decision structures.\n\nWe'll ensure each line contains virtual code step and comment.\n\nWe'll produce maybe 15-20 lines.\n\nLet's craft.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義函數 removeInvalidParentheses(s) // 建立主函數  \n→ Step 2: 計算需要刪除的左括號 remLeft 與右括號 remRight  \n→ Decision: 從 s 逐字元遍歷  \n  → if char == '(' → remLeft++  \n  → else if char == ')' → if remLeft > 0 → remLeft-- else remRight++  \n→ Step 3: 初始化結果集合 result ← 空集合 // 用來存唯一合法字串  \n→ Step 4: 定義遞迴函數 dfs(index, leftCount, rightCount, remL, remR, path)  \n→ Decision: 如果 remL==0 且 remR==0 且 leftCount==rightCount → result.add(path) // 完成合法字串  \n  → return // 從此分支返回  \n→ Decision: 如果 index == len(s) → return // 到達字串結束  \n→ Step 5: char c ← s[index] // 取得目前字元  \n→ Decision: c == '('?  \n  Yes → Decision: remL > 0?  \n    Yes → dfs(index+1, leftCount, rightCount, remL-1, remR, path) // 刪除 '('  \n    No → // 不刪除  \n     dfs(index+1, leftCount+1, rightCount, remL, remR, path + c) // 保留 '('  \n  No → Decision: c == ')' ?  \n   Yes → Decision: remR > 0?  \n     Yes → dfs(index+1, leftCount, rightCount, remL, remR-1, path) // 刪除 ')'  \n     No → Decision: leftCount > rightCount?  \n      Yes → dfs(index+1, leftCount, rightCount+1, remL, remR, path + c) // 保留 ')'  \n      No → // 不保留，因不合法  \n       return  \n   No → // c 為字母  \n    dfs(index+1, leftCount, rightCount, remL, remR, path + c) // 直接保留字母  \n→ Step 6: 呼叫 dfs(0, 0, 0, remLeft, remRight, \"\") // 從頭開始遞迴  \n→ Step 7: Return list(result) // 轉回清單輸出  \nEnd // 程式執行結束"
    },
    {
      "title": "Longest Substring with At Least K Repeating Characters",
      "source_file": "Leetcode/leetcode395.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aaabb\", k = 3",
          "expected_output": "3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '3'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '3'\nRaw Got:      '0'"
        },
        {
          "example_index": 1,
          "input": "s = \"ababbc\", k = 2",
          "expected_output": "5",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5'\nGot (Norm):      '0'\n--- (Raw) ---\nRaw Expected: '5'\nRaw Got:      '0'"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\ndef longest_substring(s: str, k: int) -> int:\n    \"\"\"Return length of longest substring where each char appears at least k times.\"\"\"\n    if len(s) < k:\n        return 0\n    freq = Counter(s)\n    # If every character meets the requirement, whole string is valid\n    if all(count >= k for count in freq.values()):\n        return len(s)\n    # Find a character that violates the rule and split on it\n    split_chars = [ch for ch, cnt in freq.items() if cnt < k]\n    max_len = 0\n    for ch in split_chars:\n        for part in s.split(ch):\n            max_len = max(max_len, longest_substring(part, k))\n    return max_len\n\ndef parse_input() -> tuple[str, int]:\n    \"\"\"Parse stdin, accepting flexible formats such as:\n       aaabb\n       3\n       or\n       s = \"aaabb\", k = 3\n    \"\"\"\n    data = sys.stdin.read()\n    # Remove common delimiters and quotes\n    for ch in ['=', ',', '\"', \"'\"]:\n        data = data.replace(ch, ' ')\n    tokens = data.split()\n    # Find first token that contains alphabetic characters as the string\n    s = ''\n    k = 0\n    for tok in tokens:\n        if s == '' and any(c.isalpha() for c in tok):\n            s = tok\n        elif s != '' and k == 0:\n            try:\n                k = int(tok)\n                break\n            except ValueError:\n                continue\n    return s, k\n\nif __name__ == \"__main__\":\n    s, k = parse_input()\n    result = longest_substring(s, k)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations, following format. The problem is \"Longest Substring with At Least K Repeating Characters\" typical Leetcode 395. We need algorithm: divide and conquer or sliding window. We produce virtual code using divide and conquer: find invalid chars that appear less than k in whole string, split at those, recursively solve subsegments, take max. Or sliding window for all possible distinct counts.\n\nWe just produce pseudocode, not actual code, but each line with explanation. Use Start, Decision, etc. Each line with virtual step and comment. Use arrows → etc.\n\nWe need to output step by step, including function signature, input reading, main algorithm. We can show algorithm:\n\nStart\n→ Step 1: Define function longestSubstring(s, k)\n→ Step 2: If length(s) < k: return 0 // cannot satisfy\n→ Decision: Count frequency of each char in s\n    → Step 3: For each char freq < k:\n            → Decision: Is char in s? // basically for each char with freq < k, split\n                → Step 4: Split s by that char into substrings\n                → Step 5: For each substring:\n                    → Step 6: Recursively call longestSubstring(sub, k)\n                → Step 7: Return maximum of these results\n    → Else // all chars freq >= k\n        → Step 8: Return length(s)\nEnd\n\nBut we need step-by-step with virtual arrows and decisions. Let's produce more detailed steps:\n\nStart // 程式開始\n\n→ Step 1: Read input string s and integer k // 取得使用者輸入\n\n→ Step 2: Call longestSubstring(s, k) // 開始計算\n\nDefine function longestSubstring(s, k):\n    → Step 3: If s.length < k: return 0 // 子字串長度不足\n    → Step 4: Count frequency of each character in s // 建立頻率表\n    → Decision: 是否存在頻率 < k 的字元？\n        Yes → Step 5: 選取第一個頻率 < k 的字元 ch // 找到分割點\n        → Step 6: 將 s 按 ch 分割成多個子字串 arr // 取得所有子段\n        → Step 7: 初始化 maxLen = 0 // 記錄最大長度\n        → Step 8: For each substring part in arr:\n                → Step 9: result = longestSubstring(part, k) // 递归\n                → Step 10: If result > maxLen: maxLen = result // 更新最大值\n        → Step 11: Return maxLen // 返回遞迴結果\n        No → Step 12: Return s.length // 所有字元頻率 >= k\nEnd\n\nReturn value printed.\n\nBut we need each line as \"虛擬碼步驟 [space] // 解釋\". Use arrow and decisions.\n\nLet's format: lines start with \"Start\", \"→ Step 1:\", \"→ Decision:\" etc.\n\nMake sure to include decisions. For each decision, provide two branches: Yes → ... No → ...\n\nThe function body is inside indentation. Use spaces for indentation but not required.\n\nWe'll produce the pseudocode in a single block. Ensure every line ends with // comment. Use Chinese comments.\n\nOk. Let's write:\n\nStart // 程式開始\n\n→ Step 1: 讀取輸入字串 s 與整數 k // 從使用者取得參數\n\n→ Step 2: 計算結果 = longestSubstring(s, k) // 呼叫主函式\n\n→ Step 3: 輸出結果 // 顯示最長子字串長度\n\n→ Step 4: End // 程式結束\n\nDefine function longestSubstring(s, k):\n    → Step 5: If s.length < k: return 0 // 子字串長度不足以滿足\n    → Step 6: 產生字元頻率表 freq // 計算每個字元出現次數\n    → Decision: 是否存在頻率 < k 的字元？\n        Yes → Step 7: 取第一個 freq[char] < k 的字元 splitChar // 作為分割符\n        → Step 8: 將 s 以 splitChar 分割成陣列 parts // 取得所有子段\n        → Step 9: 初始化 maxLen = 0 // 儲存最大長度\n        → Step 10: For each part in parts:\n                → Step 11: len = longestSubstring(part, k) // 递归\n                → Step 12: If len > maxLen: maxLen = len // 更新最大值\n        → Step 13: Return maxLen // 回傳遞迴結果\n        No → Step 14: Return s.length // 所有字元頻率均 >= k\n\nBut we need to maintain formatting of \"Decision:\" with arrows. Use indentation and \"→\" for steps inside branches. Provide Yes → and No →.\n\nOk. Let's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: 讀取輸入字串 s 與整數 k // 從使用者取得參數\n→ Step 2: 計算結果 = longestSubstring(s, k) // 呼叫主函式\n→ Step 3: 輸出結果 // 顯示最長子字串長度\n→ Step 4: End // 程式結束\n\nDefine function longestSubstring(s, k):\n    → Step 5: If s.length < k: return 0 // 子字串長度不足以滿足條件\n    → Step 6: 產生字元頻率表 freq // 計算每個字元出現次數\n    → Decision: 是否存在頻率 < k 的字元？\n        Yes → Step 7: 取第一個 freq[char] < k 的字元 splitChar // 作為分割符\n        → Step 8: 將 s 以 splitChar 分割成陣列 parts // 取得所有子段\n        → Step 9: 初始化 maxLen = 0 // 儲存最大長度\n        → Step 10: For each part in parts:\n                → Step 11: len = longestSubstring(part, k) // 递归調用自身\n                → Step 12: If len > maxLen: maxLen = len // 更新最大值\n        → Step 13: Return maxLen // 回傳遞迴結果\n        No  → Step 14: Return s.length // 所有字元頻率均 ≥ k，整個字串即為合法子字串\n```"
    },
    {
      "title": "Subsets II",
      "source_file": "Leetcode/leetcode90.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,2]",
          "expected_output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nGot (Norm):      '[[],[1],[2],[1,2],[2,2],[1,2,2]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[1,2],[1,2,2],[2],[2,2]]'\nRaw Got:      '[[], [1], [2], [1, 2], [2, 2], [1, 2, 2]]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef subsets_with_dup(nums):\n    \"\"\"回傳不重複的所有子集。\"\"\"\n    nums.sort()                     # 排序以便跳過重複元素\n    res = [[]]                      # 初始子集為空集\n    for num in nums:\n        # 為目前已經得到的子集新增一個包含 num 的子集\n        new_subsets = [subset + [num] for subset in res]\n        res.extend(new_subsets)\n    # 移除重複的子集\n    seen = set()\n    unique_res = []\n    for subset in res:\n        key = tuple(subset)\n        if key not in seen:\n            seen.add(key)\n            unique_res.append(subset)\n    return unique_res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 期望輸入類似 \"nums = [1,2,2]\" 或直接 \"[1,2,2]\"\n    # 取出中括號內的部分並 eval 為列表\n    match = re.search(r'\\[.*\\]', data)\n    if match:\n        nums_str = match.group(0)\n    else:\n        nums_str = data\n    try:\n        nums = eval(nums_str)\n    except Exception:\n        # 若 eval 失敗，直接回傳空輸出\n        return\n    result = subsets_with_dup(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, for generating all subsets of an integer array that may contain duplicates, ensuring no duplicate subsets. Classic backtracking after sorting array, skip duplicates.\n\nWe produce lines like:\n\nStart\n→ Sort nums // Sort array to handle duplicates\n→ Decision: nums empty? // Check base case\nYes → Step: return [[]] // Return empty subset\nNo → Step: Initialize result [] // result list\n→ Step: Define backtrack(index, path) // recursive function\n→ Step: Append path to result // include current subset\n→ Decision: index == len(nums)? // If reached end, return\nYes → Return // End recursion\nNo → Decision: nums[index] == nums[index-1] and index > 0? // skip duplicates\nYes → Decision: skip current element? // decide whether to skip\n    Yes → backtrack(index+1, path) // skip\n    No  → backtrack(index+1, path + [nums[index]]) // include\n    No  → backtrack(index+1, path + [nums[index]]) // include (when not duplicate)\n→ Step: Call backtrack(0, []) // start recursion\n→ Step: Return result // final output\nEnd\n\nBut we need to express virtual code with arrows and decisions. Use the format:\n\nStart // ...\n→ Step 1: ...\n→ Decision: if ...?\n    Yes → ...\n    No → ...\n\nWe should keep step numbering consistent? Not necessary but can.\n\nWe should produce explanation comments after each line. Also we must keep each line separate.\n\nWe need to produce final answer only. Use Traditional Chinese comments.\n\nLet's craft.\n\nFirst line: Start // 程式開始執行\n\nSecond line: → Step 1: Sort nums ascending // 排序陣列以便處理重複元素\n\nThird: → Step 2: Initialize result as empty list // 用於儲存所有子集\n\nFourth: → Step 3: 定義 backtrack(index, path) // 回溯函式\n\nBut in virtual code, we might put Step 3 as a comment or as a function definition. But we can just write \"→ Step 3: backtrack(index, path)\" as starting the function.\n\nBut better to show function skeleton.\n\nWe need to keep each line with arrow and explanation. Let's design.\n\nLine 3: → Step 3: 定義函式 backtrack(index, path) // 建立遞迴子集產生函式\n\nThen inside function we need to add lines with indentation maybe but keep arrow.\n\nWe can use arrow with indentation: \"    → Step 4: Append path to result\" but we need to maintain the same arrow? The example shows indentation but arrow only at top. We can show with \"    →\" or just \"    →\". In example, indent lines inside decision: they use indentation and arrow after the indent. They show:\n\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n\nSo we need to indent with 4 spaces, then arrow, etc.\n\nThus inside backtrack we indent.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: Sort nums ascending // 排序陣列以便處理重複元素\n→ Step 2: Initialize result as empty list // 用於儲存所有子集\n→ Step 3: Define backtrack(index, path) // 建立遞迴子集產生函式\n    → Step 4: Append path to result // 將目前子集加入結果\n    → Decision: index == len(nums) ? // 是否已遍歷完整個陣列\n        Yes → Step 5: Return // 結束本次遞迴\n        No  → Decision: index > 0 and nums[index] == nums[index-1] ? // 判斷是否為重複元素且已經處理過\n            Yes → Step 6: backtrack(index+1, path) // 跳過重複元素，直接遞迴下一個\n            No  → Step 7: backtrack(index+1, path + [nums[index]]) // 包含目前元素並遞迴\n→ Step 8: Call backtrack(0, []) // 從索引0開始遞迴\n→ Step 9: Return result // 回傳所有不重複子集\nEnd // 程式執行結束\n\nBut we need to handle duplicate skipping correctly. The classic algorithm: When at index, we always do include. But skip duplicates by checking that if index>0 and nums[index]==nums[index-1] then only proceed if we included previous? Actually typical algorithm: In recursion, we skip duplicate by only considering inclusion when the element is not same as previous or we only include after we skip. Another approach: in each step, we iterate over i from index to len(nums)-1, skip duplicates by if i>index and nums[i]==nums[i-1] continue. Then call backtrack(i+1, path+[nums[i]]). And always append path to result before loop. That's simpler.\n\nLet's design algorithm accordingly:\n\nSteps:\n\n- Sort nums\n\n- result = []\n\n- define backtrack(start, path):\n\n   - append path to result\n\n   - for i from start to len(nums)-1:\n\n       - if i > start and nums[i]==nums[i-1]: continue\n\n       - backtrack(i+1, path + [nums[i]])\n\n- backtrack(0, [])\n\n- return result\n\nWe can implement with for loop conceptually. Use decision in loop? We can represent for loop as Step and Decision.\n\nLet's produce virtual code accordingly.\n\nLine: → Step 3: Define backtrack(start, path) // 建立遞迴子集產生函式\n\nInside:\n\n- Append path to result\n\n- Decision: start == len(nums)? Actually we don't need; we just loop.\n\nWe'll represent loop:\n\n→ Step 4: For i from start to len(nums)-1 // 迭代剩餘元素\n\n    → Decision: i > start AND nums[i] == nums[i-1] ? // 判斷是否重複且已跳過\n        Yes → Step 5: Continue // 跳過重複元素\n        No  → Step 6: backtrack(i+1, path + [nums[i]]) // 包含元素並遞迴\n\nBut we need a way to express \"Continue\". We can just put Step 5: Continue to next iteration // 跳過\n\nBut better to express as Step 5: Continue // 跳過重複元素\n\nBut this is ambiguous. Maybe better to restructure as:\n\n→ Step 4: For i from start to len(nums)-1 // 迭代剩餘元素\n    → Decision: i > start AND nums[i] == nums[i-1] ?\n        Yes → Step 5: Continue // 跳過重複元素\n        No  → Step 6: backtrack(i+1, path + [nums[i]]) // 包含元素並遞迴\n\nThis might be okay.\n\nNow the rest lines.\n\nLet's produce final answer.\n\nEnsure each line includes arrow and comment. Use Traditional Chinese. Provide explanation.\n\nCheck format: Start, → Step 1, etc.\n\nLet's output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Sort nums ascending // 將陣列排序，以便後續跳過重複元素  \n→ Step 2: Initialize result as empty list // 用於儲存所有不重複的子集  \n→ Step 3: Define backtrack(start, path) // 建立遞迴子集產生函式  \n → Step 4: Append path to result // 先把目前子集加入結果  \n → Step 5: For i from start to len(nums)-1 // 迭代剩餘元素  \n   → Decision: i > start AND nums[i] == nums[i-1] ? // 判斷是否為重複元素且已處理過  \n    Yes → Step 6: Continue // 跳過重複元素，進入下一輪迴圈  \n    No  → Step 7: backtrack(i+1, path + [nums[i]]) // 包含該元素並遞迴至下一層  \n→ Step 8: Call backtrack(0, []) // 從索引 0 開始遞迴，初始子集為空  \n→ Step 9: Return result // 回傳所有不重複的子集  \nEnd // 程式執行結束"
    },
    {
      "title": "Add Strings",
      "source_file": "Leetcode/leetcode415.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "num1 = \"11\", num2 = \"123\"",
          "expected_output": "\"134\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '134'\nGot (Norm):      '12'\n--- (Raw) ---\nRaw Expected: '\"134\"'\nRaw Got:      '12'"
        },
        {
          "example_index": 1,
          "input": "num1 = \"456\", num2 = \"77\"",
          "expected_output": "\"533\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '533'\nGot (Norm):      '457'\n--- (Raw) ---\nRaw Expected: '\"533\"'\nRaw Got:      '457'"
        },
        {
          "example_index": 2,
          "input": "num1 = \"0\", num2 = \"0\"",
          "expected_output": "\"0\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '0'\nGot (Norm):      '1'\n--- (Raw) ---\nRaw Expected: '\"0\"'\nRaw Got:      '1'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        \"\"\"Add two non‑negative integer strings without using int conversion.\"\"\"\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        res = []\n\n        # Process each digit from right to left\n        while i >= 0 or j >= 0 or carry:\n            x = ord(num1[i]) - 48 if i >= 0 else 0\n            y = ord(num2[j]) - 48 if j >= 0 else 0\n            total = x + y + carry\n            res.append(chr((total % 10) + 48))  # store digit as char\n            carry = total // 10\n            i -= 1\n            j -= 1\n\n        # Reverse the list to obtain the final sum string\n        return ''.join(reversed(res))\n\ndef main():\n    # Read entire stdin input\n    data = sys.stdin.read()\n    # Extract all digit sequences (handles formats like num1 = \"11\", num2 = \"123\")\n    numbers = re.findall(r'\\d+', data)\n    num1 = numbers[0] if len(numbers) > 0 else '0'\n    num2 = numbers[1] if len(numbers) > 1 else '0'\n\n    solver = Solution()\n    result = solver.addStrings(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for adding two big integers represented as strings, without converting to int or using BigInteger. Steps: pad, iterate from right to left, add digits and carry, build result string reversed, reverse at end, trim leading zeros? but leading zeros maybe no. Output string.\n\nWe'll produce steps: Start, get lengths, determine max, pad shorter with zeros, iterate index from max-1 to 0, convert char to digit by subtracting '0', add digits and carry, compute sum digit, append to result string (e.g., result = digitChar + result). After loop, if carry>0, prepend. End.\n\nWe should provide each line with virtual code and explanation.\n\nWe'll use virtual code like:\n\nStart // start\n→ Step 1: Determine length of num1 and num2 // get lengths\n→ Step 2: Compute maxLen = max(len1, len2) // longest length\n→ Step 3: Pad num1 and num2 with leading zeros to length maxLen // align digits\n→ Step 4: Initialize carry = 0 // start carry\n→ Step 5: Initialize result as empty string // to build sum\n→ Step 6: For i from maxLen-1 down to 0 // iterate digits\n   → Step 7: digit1 = num1[i] - '0' // char to int\n   → Step 8: digit2 = num2[i] - '0' // char to int\n   → Step 9: sum = digit1 + digit2 + carry // add digits\n   → Step 10: carry = sum / 10 // new carry\n   → Step 11: result = (sum % 10 + '0') + result // prepend digit\n→ Decision: carry > 0? // check remaining carry\n   Yes → Step 12: result = '1' + result // add final carry\n   No  → skip\n→ Step 13: return result // output sum string\nEnd // finish\n\nBut we need to produce virtual code with arrows and structure.\n\nWe'll include decision structure after loop.\n\nLet's produce each line.\n\nAlso note to include // 解釋/說明 after each line.\n\nLet's format exactly: \"Start // 程式開始執行\". For steps, use \"→ Step X: ...\". For Decision: \"→ Decision: ...\". Use Yes → Step X. No → Step X.\n\nThus produce lines.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 取得 num1 與 num2 的長度 // 取得兩字串長度  \n→ Step 2: 計算 maxLen = max(len(num1), len(num2)) // 取較長者作為迴圈長度  \n→ Step 3: 若 num1 長度 < maxLen，將 num1 前置 '0' 直到長度為 maxLen // 對齊右端  \n→ Step 4: 若 num2 長度 < maxLen，將 num2 前置 '0' 直到長度為 maxLen // 對齊右端  \n→ Step 5: 初始化 carry = 0 // 加法進位  \n→ Step 6: 初始化 result 為空字串 // 用於累積相加結果  \n→ Step 7: 從 i = maxLen-1 到 0 迴圈 // 從最低位開始處理  \n   → Step 8: digit1 = num1[i] - '0' // 將字符轉成整數  \n   → Step 9: digit2 = num2[i] - '0' // 將字符轉成整數  \n   → Step 10: sum = digit1 + digit2 + carry // 計算三數之和  \n   → Step 11: carry = sum / 10 // 新進位（整數除法）  \n   → Step 12: result = (sum % 10 + '0') + result // 將本位數字符加到結果前面  \n→ Decision: carry > 0? // 最後是否還有進位  \n    Yes → Step 13: result = '1' + result // 把最後進位加到最前面  \n    No  → // 若無進位則不變  \n→ Step 14: 返回 result // 輸出加法結果字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Sort Characters By Frequency",
      "source_file": "Leetcode/leetcode451.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"tree\"",
          "expected_output": "\"eert\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'eert'\nGot (Norm):      'eetr'\n--- (Raw) ---\nRaw Expected: '\"eert\"'\nRaw Got:      'eetr'"
        },
        {
          "example_index": 1,
          "input": "s = \"cccaaa\"",
          "expected_output": "\"aaaccc\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aaaccc'\nGot (Norm):      'cccaaa'\n--- (Raw) ---\nRaw Expected: '\"aaaccc\"'\nRaw Got:      'cccaaa'"
        }
      ],
      "generated_code": "import sys\nimport re\nfrom collections import Counter\n\ndef frequency_sort(s: str) -> str:\n    \"\"\"\n    依字元出現頻率遞減排序，並回傳結果字串。\n    \"\"\"\n    cnt = Counter(s)\n    # most_common 會依頻率從高到低排序\n    return ''.join(char * freq for char, freq in cnt.most_common())\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read().strip()\n\n    # 嘗試從輸入中提取被雙引號包住的字串\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        s = raw_input\n\n    # 計算並輸出結果\n    result = frequency_sort(s)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for sorting string by decreasing frequency. Provide line by line with explanation. Use Start, Decision etc. Provide steps: count frequencies using dictionary, create list of (char, freq), sort by freq descending, build result string by repeating char freq times. Return string. We don't output actual code. Just virtual steps.\n\nWe need to output in Traditional Chinese.\n\nLet's craft steps:\n\nStart\n→ Step 1: Initialize frequency map // 以空字典記錄字元出現次數\n→ Step 2: For each char in s: increment count // 逐個字元計數\n→ Step 3: Create list of (char, freq) from map // 轉成可排序的列表\n→ Decision: 是否需要排序? // 需要\n→ Step 4: Sort list by freq descending // 按頻率降序排列\n→ Step 5: Initialize result string // 準備結果\n→ Step 6: For each (char, freq) in sorted list: append char freq times to result // 依次添加\n→ Step 7: Return result string // 回傳排序後的字串\nEnd\n\nAdd explanations. Use appropriate arrow and indent. Use Yes/No? But here only one decision. But we can use Decision: 是否需要排序? Yes → Step 4.\n\nLet's format as per example.\n\nWe should keep each line separate.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化頻率字典 // 用空字典記錄每個字元的出現次數  \n→ Step 2: 遍歷字串 s，對每個字元 freq[char]++ // 逐個字元更新計數  \n→ Step 3: 建立 (字元, 次數) 的列表 list_freq 來自 freq 字典 // 轉成可排序的形式  \n→ Decision: 是否需要排序? // 需要  \n  Yes → Step 4: 將 list_freq 按次數降序排序 // 依頻率從高到低排列  \n→ Step 5: 初始化空字串 result // 用於累積最終結果  \n→ Step 6: 對於每個 (字元, 次數) 在排序後的 list_freq：  \n  → result += 字元 * 次數 // 將字元重複次數次加入結果  \n→ Step 7: 回傳 result 字串 // 返回按頻率降序排列的字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Lexicographical Numbers",
      "source_file": "Leetcode/leetcode386.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 13",
          "expected_output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[1,2]",
          "actual_output_or_error": "[Validation Error] Code execution timed out (10s)."
        }
      ],
      "generated_code": "import sys\nimport re\n\ndef lexical_order(n: int):\n    \"\"\"\n    產生 1~n 的字典序排列。\n    時間複雜度 O(n)，額外空間 O(1)（除結果列表外）。\n    \"\"\"\n    result = []\n    current = 1\n    while current <= n:\n        result.append(current)\n        # 若可以往更深層（乘以 10）則進入下一層\n        if current * 10 <= n:\n            current *= 10\n        else:\n            # 否則先回溯到能往右移動的節點\n            while (current % 10 == 9) or (current + 1 > n):\n                current //= 10\n            current += 1\n    return result\n\ndef main():\n    # 讀取輸入，抓取第一個整數\n    data = sys.stdin.read()\n    m = re.search(r'\\d+', data)\n    if not m:\n        return\n    n = int(m.group(0))\n    result = lexical_order(n)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce pseudocode steps for lexicographic order from 1 to n, O(n) time, O(1) extra space. It's typical algorithm: using a stack simulation or DFS to produce lexicographic order: For i from 1 to n, we print i; then if i*10 <= n: go deeper: i*=10, else while i%10==9 or i+1>n: i/=10; i++; etc. But need to produce pseudocode lines.\n\nWe should produce Start, Step etc. Provide explanation after each line.\n\nLet's produce:\n\nStart\n\n→ Step 1: Set current = 1 // initialize first number\n\n→ Decision: while current <= n? // main loop\n\n   Yes → Step 2: Output current // print current number\n\n   → Decision: if current * 10 <= n? // can go deeper\n\n       Yes → Step 3: current = current * 10 // move to next prefix\n\n       No → Step 4: Decision: if current % 10 == 9 or current + 1 > n? // determine if need to backtrack\n\n           Yes → Step 5: current = current / 10 // backtrack to parent\n\n           No → Step 6: current = current + 1 // move to next sibling\n\n   → End Decision // end inner decision\n\n→ Decision: loop back to Step 1? // check again\n\n   Yes → (continue)\n\n   No → End // loop finished\n\nBut we need to produce lines with appropriate indentation or arrow.\n\nWe must use \"Decision:\" and \"Yes →\", \"No →\".\n\nLet's produce step-by-step:\n\nStart // 程式開始執行\n\n→ Step 1: 設定 current = 1 // 初始化第一個數字\n\n→ Decision: current <= n? // 主迴圈：只要 current 在 1~n 範圍內\n\n    Yes → Step 2: 輸出 current // 輸出目前數字\n\n    → Decision: current * 10 <= n? // 可以進一步展開為更長的前綴\n\n        Yes → Step 3: current = current * 10 // 進入下一個子節點\n\n        No  → Decision: current % 10 == 9 或 current + 1 > n? // 需要回溯還是向右移動\n\n            Yes → Step 4: current = current / 10 // 回溯到父節點\n\n            No  → Step 5: current = current + 1 // 向右移動到下一個兄弟節點\n\n    → End Decision // 內部 Decision 結束\n\n→ Decision: current <= n? // 再次檢查是否繼續\n\n    Yes → (回到 Step 1)\n\n    No  → End // 迴圈結束，程式結束\n\nBut we need to ensure we use \"→ Decision:\" for each decision, and \"Yes →\", \"No →\". Also use \"End\" for end of program.\n\nWe need to include explanation after each line.\n\nLet's format:\n\nStart // 程式開始執行\n\n→ Step 1: 設定 current = 1 // 初始化第一個數字\n\n→ Decision: current <= n? // 判斷是否還有數字可輸出\n\n    Yes → Step 2: 輸出 current // 輸出目前數字\n\n    → Decision: current * 10 <= n? // 判斷是否可以深入下一級前綴\n\n        Yes → Step 3: current = current * 10 // 進入下一層\n\n        No  → Decision: current % 10 == 9 或 current + 1 > n? // 判斷是否需回溯或向右移動\n\n            Yes → Step 4: current = current / 10 // 回溯到父節點\n\n            No  → Step 5: current = current + 1 // 移動到下一個兄弟節點\n\n    → End Decision // 內層決策結束\n\n→ Decision: current <= n? // 重新檢查是否繼續\n\n    Yes → (回到 Step 1)\n\n    No  → End // 結束程式\n\nWe might need to mention \"End Decision\" lines. But it's okay.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 設定 current = 1 // 初始化第一個數字  \n\n→ Decision: current <= n? // 判斷是否還有數字可輸出  \n    Yes → Step 2: 輸出 current // 輸出目前數字  \n\n    → Decision: current * 10 <= n? // 判斷是否可以進一步深入下一層前綴  \n        Yes → Step 3: current = current * 10 // 進入下一層，將 current 乘 10  \n        No  → Decision: current % 10 == 9 或 current + 1 > n? // 判斷是回溯還是向右移動  \n            Yes → Step 4: current = current / 10 // 回溯到父節點，除以 10  \n            No  → Step 5: current = current + 1 // 向右移動到下一個兄弟節點  \n\n    → End Decision // 內層決策結束  \n\n→ Decision: current <= n? // 再次檢查是否還有數字可輸出  \n    Yes → (回到 Step 1)  \n    No  → End // 程式執行結束"
    },
    {
      "title": "Regular Expression Matching",
      "source_file": "Leetcode/leetcode10.json",
      "problem_index_in_file": 0,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "Thinking...\nWe need to produce full Python code that implements regex matching with '.' and '*', reading from stdin. Input format: from examples, seems input is like: 's = \"aa\", p = \"a\"'. So we need to parse such string from stdin. The examples show that stdin will contain a line: 's = \"aa\", p = \"a\"'. We need to parse into variables s and p. Could also be multiple lines? They didn't specify multiple test cases+//2#8C@:@AB\";\"(A9=F"
        }
      ],
      "generated_code": null,
      "virtual_code": "Thinking...\nThe task: generate virtual code (pseudo) for regular expression matching with '.' and '*', similar to LeetCode 10. Should produce step by step pseudo code with explanations, following the output format: each line \"虛擬碼步驟 // 解釋\".\n\nWe need to output pseudo code lines: Start, steps, Decision, End, using arrows → etc. We should include recursion or DP approach.\n\nGiven constraints: no actual code, just pseudo. So we produce something like:\n\nStart\n→ Step 1: 定義函式 isMatch(s, p) // 檢查兩字串\n→ Decision: 如果 s 與 p 都為空? // 兩者皆空，匹配成功\n   Yes → Return true\n   No → Decision: 如果 p 為空? // p 空但 s 不空，匹配失敗\n      Yes → Return false\n...\n\nThen handle star: if len(p)>=2 && p[1]=='*', then consider zero occurrence or one/more occurrences.\n\nWe need to maintain recursion logic.\n\nPseudo: Use recursion: if firstMatch and star -> or not.\n\nAlternatively DP: 2D table.\n\nProbably simpler: recursion pseudo.\n\nWe need to use arrows \"→\" etc. Indent decisions. Each line must have \"虛擬碼步驟\" + \" // \" explanation.\n\nWe need to include \"Start // 程式開始執行\" etc.\n\nWe can create steps:\n\nStart // 程式開始執行\n→ Step 1: 定義遞迴函式 Match(i, j) // i 為 s 的索引, j 為 p 的索引，檢查子字串是否匹配\n→ Decision: 如果 j 已到 p 的末尾? // 檢查模式是否已全部處理\n    Yes → Return i 等於 s 的長度? // 若 s 也已結束則匹配成功，否則失敗\n    No → ...\n\nThen compute firstMatch: i < len(s) 且 (p[j]==s[i] 或 p[j]=='.')\n\nDecision: 如果 j+1 < len(p) 且 p[j+1]=='*'? // 有 * 進行處理\n   Yes → Decision: firstMatch ?\n      Yes → Return Match(i, j+2) 或 Match(i+1, j) // 兩種可能\n      No  → Return Match(i, j+2) // 只能跳過 *，因為不匹配一個字符\n   No  → Decision: firstMatch ?\n      Yes → Return Match(i+1, j+1) // 直接匹配一個字符\n      No  → Return false\n\nEnd\n\nBut we need each step as line: each \"Step\" line with explanation.\n\nWe need to include recursion calls etc.\n\nLet's produce lines accordingly.\n\nMake sure to use \"→\" arrow at each step, \"Decision:\" etc. Provide explanations in Chinese.\n\nWe can also produce some comments: // for each line.\n\nLet's craft pseudo code:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 Match(i, j) // i: s 的索引，j: p 的索引\n→ Decision: 如果 j == len(p)? // 模式已處理完\n    Yes → Return i == len(s)? // 只有 s 也結束才成功\n    No  → Decision: 如果 i == len(s)? // s 已結束但模式未結束\n        Yes → Return False? // 仍有字符在模式中（除非都是 *）\n        No  → ...\nWait: We need to consider that if s ended but pattern remains like 'a*', still could match empty. So we need to handle in star logic.\n\nBetter to integrate star check.\n\nWe can write logic:\n\n→ Step 2: firstMatch = (i < len(s)) and (p[j]==s[i] or p[j]=='.')\n\n→ Decision: j+1 < len(p) and p[j+1]=='*'? // 是否有 * 隨後\n    Yes →\n        Decision: firstMatch? \n            Yes → Return Match(i, j+2) or Match(i+1, j) // skip * or consume one\n            No  → Return Match(i, j+2) // skip *\n    No  →\n        Decision: firstMatch? \n            Yes → Return Match(i+1, j+1) // consume one\n            No  → Return False\n\nBut need to ensure we include recursion return.\n\nWe also need base case: if j==len(p): return i==len(s)\n\nSo we can put that as Step.\n\nLet's produce lines:\n\nStart\n→ Step 1: 定義函式 Match(i, j) // i 是 s 的位置，j 是 p 的位置\n→ Decision: 如果 j == len(p)? // 模式已結束\n    Yes → Return i == len(s)? // 若 s 也結束則匹配成功\n    No  → Step 2: firstMatch = (i < len(s)) 且 (p[j]==s[i] 或 p[j]=='.') // 檢查首字符是否匹配\n→ Decision: 如果 j+1 < len(p) 且 p[j+1] == '*'? // 有 '*' 進行特殊處理\n    Yes →\n        Decision: firstMatch? \n            Yes → Return Match(i, j+2) 或 Match(i+1, j) // 跳過 '*' 或消耗一個字符\n            No  → Return Match(i, j+2) // 只能跳過 '*'\n    No  →\n        Decision: firstMatch? \n            Yes → Return Match(i+1, j+1) // 正常匹配一個字符\n            No  → Return False // 無法匹配\n\nBut each line needs to be in format: `虛擬碼步驟 // 解釋`. So we need to include comments after `//`. The code part must show arrow `→`, and `Decision:` etc.\n\nAlso, at each `Yes →` line, we need to have something after that arrow, maybe like `Step X: ...`. But the requirement: \"使用虛擬碼的箭頭 (`→`, `Yes →`, `No →`) 和結構 (`Start`, `End`, `Decision:`).\" So we can have arrow at each step. For decisions we have \"Decision:\" then indent with Yes/No lines with arrow.\n\nWe need to be careful with formatting: Each line like:\n\nStart // 程式開始執行\n→ Step 1: ... // 解釋\n→ Decision: ... // 解釋\n    Yes → ... // 解釋\n    No  → ... // 解釋\nEnd // 程式執行結束\n\nAlso, the \"Start\" and \"End\" lines not preceded by arrow. Only within steps.\n\nBut the example shows \"Start // 程式開始執行\" then \"→ Step 1:\" etc. So we follow.\n\nNow we need to write final pseudo.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 Match(i, j) // i 為 s 的索引，j 為 p 的索引\n→ Decision: j == len(p)? // 檢查模式是否已經處理完\n    Yes → Return i == len(s)? // 若 s 也結束則匹配成功，否則失敗\n    No  → Step 2: firstMatch = (i < len(s)) 且 (p[j] == s[i] 或 p[j] == '.') // 檢查首字符是否匹配\n→ Decision: (j + 1 < len(p)) 且 (p[j+1] == '*')? // 下一個字符是否為 '*'\n    Yes →\n        Decision: firstMatch? \n            Yes → Return Match(i, j+2) 或 Match(i+1, j) // 跳過 '*' 或消耗一個字符\n            No  → Return Match(i, j+2) // 只能跳過 '*'\n    No  →\n        Decision: firstMatch? \n            Yes → Return Match(i+1, j+1) // 正常匹配一個字符\n            No  → Return False // 無法匹配\nEnd // 程式執行結束\n\nBut we need to ensure each line has correct syntax: arrow lines need to have a code segment after arrow. For Decision lines, the line \"Decision:\" counts as a line. But in example, they used indentation inside decision for Yes and No lines. So we need to indent lines after Decision with 4 spaces? In example they used 4 spaces indent for Yes/No. Let's maintain that.\n\nThus final output will be:\n\nStart // 程式開始執行\n→ Step 1: 定義函式 Match(i, j) // i 為 s 的索引，j 為 p 的索引\n→ Decision: j == len(p)? // 模式已經處理完\n    Yes → Return i == len(s)? // 若 s 也結束則匹配成功，否則失敗\n    No  → Step 2: firstMatch = (i < len(s)) 且 (p[j] == s[i] 或 p[j] == '.') // 檢查首字符是否匹配\n→ Decision: (j + 1 < len(p)) 且 (p[j+1] == '*')? // 下一個字符是否為 '*'\n    Yes →\n        Decision: firstMatch? \n            Yes → Return Match(i, j+2) 或 Match(i+1, j) // 跳過 '*' 或消耗一個字符\n            No  → Return Match(i, j+2) // 只能跳過 '*'\n    No  →\n        Decision: firstMatch? \n            Yes → Return Match(i+1, j+1) // 正常匹配一個字符\n            No  → Return False // 無法匹配\nEnd // 程式執行結束\n\nBut we need to ensure each line ends with `// 解釋`. Already we have. For lines like `Yes → Return ...`, the comment is after //.\n\nAlso \"Return Match(i, j+2) 或 Match(i+1, j)\" might not be clear; but it's fine.\n\nBut we need to include \"或\" meaning or. However in pseudo we could use \"或\" for \"or\".\n\nAlso \"Return Match(i, j+2) 或 Match(i+1, j)\" maybe ambiguous. Should be something like \"Return Match(i, j+2) 或 Match(i+1, j)\" but we might separate two separate statements? We can use \"或\" to represent OR. But we need to produce something like \"Return Match(i, j+2) 或 Match(i+1, j)\" as a single return expression? In pseudo, we can keep as is.\n\nBut maybe we should write \"Return Match(i, j+2) 或 Match(i+1, j)\" as a comment that it's or.\n\nBut some lines may be ambiguous due to 'or' within the line. But it's okay.\n\nWe must ensure each line contains arrow, colon, etc.\n\nNow, we also need to include the recursion call in the initial steps: We defined function but we need to call it at the end. So we might add at the end: \"Return Match(0, 0)\" to start recursion. That may be part of top-level. But not required maybe. But we can include as Step: `Return Match(0, 0) // 開始匹配` before End. So include:\n\n→ Step 3: Return Match(0, 0) // 開始匹配\n\nBut the function is defined inside but to call we need separate line. But maybe it's okay to skip.\n\nBut to be thorough, we can add:\n\n→ Step 3: Return Match(0, 0) // 從頭開始匹配整個字符串\n\nAdd before End.\n\nSo final lines:\n\nStart\n→ Step 1: 定義函式 Match(i, j) // i 為 s 的索引，j 為 p 的索引\n→ Decision: j == len(p)? // 模式已經處理完\n    Yes → Return i == len(s)? // 若 s 也結束則匹配成功，否則失敗\n    No  → Step 2: firstMatch = (i < len(s)) 且 (p[j] == s[i] 或 p[j] == '.') // 檢查首字符是否匹配\n→ Decision: (j + 1 < len(p)) 且 (p[j+1] == '*')? // 下一個字符是否為 '*'\n    Yes →\n        Decision: firstMatch? \n            Yes → Return Match(i, j+2) 或 Match(i+1, j) // 跳過 '*' 或消耗一個字符\n            No  → Return Match(i, j+2) // 只能跳過 '*'\n    No  →\n        Decision: firstMatch? \n            Yes → Return Match(i+1, j+1) // 正常匹配一個字符\n            No  → Return False // 無法匹配\n→ Step 3: Return Match(0, 0) // 開始整體匹配\nEnd\n\nBut \"Step 3\" is inside the function? Actually we need to call the function outside. Maybe we need to create a wrapper function, but it's okay.\n\nWe can also add \"→ Step 3: Return Match(0, 0) // 呼叫遞迴進行匹配\" as top-level step after defining function.\n\nBut to align with indentation: After Decision lines, we have \"→ Step 3: ...\" as same level as \"→ Step 1:\". That is fine.\n\nBut we need to ensure we don't have stray \"→\" inside comment or explanation.\n\nMake sure each line ends with comment.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義函式 Match(i, j) // i 為 s 的索引，j 為 p 的索引\n→ Decision: j == len(p)? // 檢查模式是否已經處理完\n    Yes → Return i == len(s)? // 若 s 也結束則匹配成功，否則失敗\n    No  → Step 2: firstMatch = (i < len(s)) 且 (p[j] == s[i] 或 p[j] == '.') // 檢查首字符是否匹配\n→ Decision: (j + 1 < len(p)) 且 (p[j+1] == '*')? // 下一個字符是否為 '*'\n    Yes →\n        Decision: firstMatch? \n            Yes → Return Match(i, j+2) 或 Match(i+1, j) // 跳過 '*' 或消耗一個字符\n            No  → Return Match(i, j+2) // 只能跳過 '*'\n    No  →\n        Decision: firstMatch? \n            Yes → Return Match(i+1, j+1) // 正常匹配一個字符\n            No  → Return False // 無法匹配\n→ Step 3: Return Match(0, 0) // 呼叫遞迴開始整體匹配\nEnd // 程式執行結束"
    },
    {
      "title": "Coin Change II",
      "source_file": "Leetcode/leetcode518.json",
      "problem_index_in_file": 0,
      "generation_error": "Failed to extract code from model response.",
      "failed_validation_details": [
        {
          "example_index": -1,
          "input": null,
          "expected_output": null,
          "actual_output_or_error": "Thinking...\nWe need to output code in a python block. Code must read input format: examples show input string '5, [1,2,5]'. That is amount then comma then list representation. Could also be '3, [2]'. So input line is something like: amount, [coin1,coin2,...]. So we can parse by splitting by comma, but careful with list syntax. Approach: read entire stdin as string, strip. If contains comma, split once: first part amount, second part coins string. Evaluate second part with eval or ast.literal_eval. But safer use ast.literal_eval. Let's do:\n\nimportE\",>36&D&AD,94E#E;C%4;.45;+&'1<@E"
        }
      ],
      "generated_code": null,
      "virtual_code": "\u001b[?2026h\u001b[?25l\u001b[1G⠙ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠹ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠸ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠼ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠴ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠦ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠧ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠇ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠏ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠋ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠙ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠹ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠸ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠼ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠴ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠦ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠧ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠇ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠇ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠋ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠙ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠹ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠸ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠼ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠴ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠦ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠧ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?2026h\u001b[?25l\u001b[1G⠇ \u001b[K\u001b[?25h\u001b[?2026l\u001b[?25l\u001b[?2026h\u001b[?25l\u001b[1G\u001b[K\u001b[?25h\u001b[?2026l\u001b[2K\u001b[1G\u001b[?25hError: model runner has unexpectedly stopped, this may be due to resource limitations or an internal error, check ollama server logs for details"
    },
    {
      "title": "Permutations",
      "source_file": "Leetcode/leetcode46.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nGot (Norm):      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'\n--- (Raw) ---\nRaw Expected: '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]'\nRaw Got:      '[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,2,1],[3,1,2]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport re\n\nclass Solution:\n    def permute(self, nums):\n        \"\"\"回溯演算法，產生 nums 的所有排列\"\"\"\n        res = []\n\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])          # 把目前排列複製加入結果\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # 交換\n                backtrack(start + 1)                       # 進入下一層\n                nums[start], nums[i] = nums[i], nums[start]  # 回復原始順序\n\n        backtrack(0)\n        return res\n\ndef main():\n    # 讀取整個輸入\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 取得方括號中的列表字串\n    match = re.search(r'\\[.*\\]', data)\n    if not match:\n        return\n    list_str = match.group(0)\n\n    # 轉換成 Python list\n    nums = json.loads(list_str)\n\n    # 產生排列並輸出\n    sol = Solution()\n    result = sol.permute(nums)\n    print(json.dumps(result, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for generating all permutations of an array of distinct integers. Provide step-by-step, each line: virtual code step + // explanation. Use arrows, Start, End, Decision.\n\nWe need to design algorithm: Use backtracking: maintain current permutation, used set.\n\nWe'll produce lines like:\n\nStart // 程式開始執行\n→ Step 1: 初始化空列表 results，調用 backtrack(0) // 初始化結果並啟動回溯\n→ Function backtrack(start): // 回溯函數\n   ...\nWe need to produce steps line by line. Use indentation? Use arrow for each step, we can indent under decisions.\n\nUse \"→\" for normal step. For decision, \"Decision:\" and Yes/No arrows.\n\nWe should show the algorithm in pseudocode style but not actual code. Provide step by step.\n\nWe can break down into major steps: 1) Start, 2) Initialize result list, 3) Define backtrack function, 4) In backtrack, if start == length, add current permutation to results. 5) Else loop over indices i from start to n-1, swap elements, call backtrack(start+1), swap back.\n\nBut we need to produce in virtual code lines: we can write like:\n\n→ Step 1: Define function backtrack(start) // 定義回溯函數\n→ Step 2: Decision: 是否已經生成完整排列? // 檢查是否到達最後一個位置\n    Yes → Step 3: 將當前排列複製加入結果 // 完整排列加入結果\n    No → Step 4: 循環 i = start to n-1 // 將每個未固定元素放到当前位置\n         → Step 5: Swap nums[start] and nums[i] // 交換元素以生成新排列\n         → Step 6: Call backtrack(start+1) // 進入下一層\n         → Step 7: Swap nums[start] and nums[i] 回復 // 回溯\n\nBut we also need to initialize results and call backtrack(0). And at the end return results.\n\nSo produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義變量 results = [] // 用於存儲所有排列\n→ Step 2: 定義函數 backtrack(start) // 回溯核心\n→ Step 3: Decision: 如果 start == nums.length? // 檢查是否完成\n    Yes → Step 4: results.append(nums.clone()) // 添加當前排列\n    No  → Step 5: 循環 i from start to nums.length-1 // 嘗試每個候選\n        → Step 6: Swap nums[start] 和 nums[i] // 置換\n        → Step 7: Call backtrack(start+1) // 深入下一層\n        → Step 8: Swap nums[start] 和 nums[i] // 回復原狀\n→ Step 9: Call backtrack(0) // 啟動回溯\n→ Step 10: Return results // 回傳所有排列\nEnd // 程式結束\n\nNeed to provide each line with explanation after //.\n\nMake sure each line includes virtual code step + space + // explanation. Use arrows. Use proper indent maybe.\n\nWe need \"逐行輸出\" meaning each line separate. Use '→' for normal steps. For decisions, use \"Decision:\".\n\nAlso may include \"Start\" and \"End\".\n\nLet's write accordingly.\n\nWe'll produce final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義變量 results = [] // 用於存放所有排列  \n→ Step 2: 定義函數 backtrack(start) // 回溯核心函式  \n→     Decision: start == nums.length? // 檢查是否已完成一個排列  \n→         Yes → Step 3: results.append(nums.clone()) // 將目前排列複製加入結果  \n→         No  → Step 4: 循環 i from start to nums.length - 1 // 嘗試每個未固定的元素  \n→             → Step 5: Swap nums[start] 與 nums[i] // 交換元素以生成新排列  \n→             → Step 6: Call backtrack(start + 1) // 進一步深層遞迴  \n→             → Step 7: Swap nums[start] 與 nums[i] // 回復原始狀態（回溯）  \n→ Step 8: Call backtrack(0) // 從第一個位置開始遞迴  \n→ Step 9: Return results // 回傳所有產生的排列  \nEnd // 程式執行結束"
    },
    {
      "title": "Find the Duplicate Number",
      "source_file": "Leetcode/leetcode287.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [3,1,3,4,2]",
          "expected_output": "O3",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'O3'\nGot (Norm):      '3'\n--- (Raw) ---\nRaw Expected: 'O3'\nRaw Got:      '3'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def findDuplicate(self, nums):\n        \"\"\"\n        使用 Floyd's Tortoise and Hare (Cycle Detection) 演算法\n        找出只重複一次的數字，無需修改原陣列且使用常數額外空間。\n        \"\"\"\n        # 1️⃣ 第一階段：尋找兩指針相遇點\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]          # 慢指針走一步\n            fast = nums[nums[fast]]    # 快指針走兩步\n            if slow == fast:\n                break\n\n        # 2️⃣ 第二階段：尋找入環點（即重複數字）\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n\n        return slow\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整資料\n    data = sys.stdin.read().strip()\n\n    # 取得陣列內容，支援「nums = [1,3,4,2,2]」等格式\n    match = re.search(r'\\[([^\\]]*)\\]', data)\n    if match:\n        nums_str = match.group(1)\n        nums = [int(x.strip()) for x in nums_str.split(',') if x.strip()]\n    else:\n        # 若找不到方括號，直接嘗試 eval（保險起見）\n        try:\n            nums = eval(data)\n        except Exception:\n            nums = []\n\n    # 呼叫解法並輸出結果\n    if nums:\n        result = Solution().findDuplicate(nums)\n        print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for finding duplicate in array without modifying and constant space. Use Floyd's Tortoise and Hare cycle detection. Outline steps: define slow, fast start at first element. Move slow one step, fast two steps until they meet. Then find entrance: set ptr1 at start, ptr2 at meeting point, move both one step until equal; that value is duplicate. Provide virtual code line by line with comments. Ensure format: \"Start // ...\" etc.\n\nLet's generate. Use arrows. Use \"→\" after each step. Use Decision for loops? Might just step by step. Use while loops as Decision with Yes/No? Provide \"Decision: 循環檢查 slow ≠ fast?\" etc.\n\nAlso array indexing: nums[0] gives first element. But they might consider 1-based? The values are 1..n, so using nums[i-1]? But typical algorithm: start at nums[0]. Then move pointers as nums[ptr]. So we can refer.\n\nWe should not modify array. So just read values.\n\nImplement with virtual code. Use steps: Start, Step 1: Set slow = nums[0], fast = nums[nums[0]] // initial positions. Then loop until slow == fast. Provide Decision loop.\n\nThen after meeting, Step 2: Set ptr1 = nums[0], ptr2 = slow. Then loop until ptr1 == ptr2, each moving one step: ptr1 = nums[ptr1], ptr2 = nums[ptr2]. When equal, return ptr1 (duplicate). End.\n\nAdd comments.\n\nLet's produce.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: slow ← nums[0] // 把慢指針設定為陣列第一個元素  \n→ Step 2: fast ← nums[nums[0]] // 把快指針設定為 nums[slow]，即跳兩步的起點  \n→ Decision: slow ≠ fast? // 判斷慢指針與快指針是否相遇  \n Yes → Step 3: slow ← nums[slow] // 慢指針走一步  \n     fast ← nums[nums[fast]] // 快指針走兩步  \n     → 回到 Decision  \n No  → // slow 與 fast 相遇，進入下一段  \n→ Step 4: ptr1 ← nums[0] // 第一次指針重新從陣列開始  \n→ Step 5: ptr2 ← slow // 第二次指針從相遇點開始  \n→ Decision: ptr1 ≠ ptr2? // 判斷兩指針是否已到同一位置  \n Yes → Step 6: ptr1 ← nums[ptr1] // ptr1 走一步  \n     ptr2 ← nums[ptr2] // ptr2 走一步  \n     → 回到 Decision  \n No  → // ptr1 與 ptr2 相遇，ptr1（或 ptr2）即為重複數字  \n→ Step 7: return ptr1 // 回傳重複的數字  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Delete GetRandom O(1) - Duplicates allowed",
      "source_file": "Leetcode/leetcode381.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"], [[], [1], [1], [2], [], [1], []]",
          "expected_output": "[null, true, false, true, 2, true, 1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpns6oeug_.py\", line 76, in <module>\n    main()\n  File \"/tmp/tmpns6oeug_.py\", line 52, in main\n    args_list = ast.literal_eval(args_str)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [ [[], [1], [1], [2], [], [1], []]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nimport random\nimport collections\n\nclass RandomizedCollection:\n    def __init__(self):\n        # data stores all elements\n        self.data = []\n        # idx_map maps value -> set of indices in data\n        self.idx_map = collections.defaultdict(set)\n\n    def insert(self, val: int) -> bool:\n        self.data.append(val)\n        self.idx_map[val].add(len(self.data) - 1)\n        # Return True if this is the first occurrence\n        return len(self.idx_map[val]) == 1\n\n    def remove(self, val: int) -> bool:\n        if not self.idx_map[val]:\n            return False\n        # Index to remove\n        remove_idx = self.idx_map[val].pop()\n        # Last element in the list\n        last_val = self.data[-1]\n        # Move last element to the spot of removed element\n        self.data[remove_idx] = last_val\n        # Update indices for last_val\n        self.idx_map[last_val].add(remove_idx)\n        self.idx_map[last_val].discard(len(self.data) - 1)\n        # Remove last element from list\n        self.data.pop()\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.data)\n\ndef main():\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        return\n    # Expected format: ['method1', 'method2', ...], [args1, args2, ...]\n    # Split into two parts at the first comma that separates the lists\n    parts = raw_input.split('],', 1)\n    if len(parts) != 2:\n        raise ValueError(\"Input format incorrect\")\n    # Re-add the missing brackets and comma\n    methods_str = parts[0] + ']'\n    args_str = '[' + parts[1]\n    methods = ast.literal_eval(methods_str)\n    args_list = ast.literal_eval(args_str)\n\n    obj = None\n    results = []\n    for method, args in zip(methods, args_list):\n        if method == \"RandomizedCollection\":\n            obj = RandomizedCollection()\n            results.append(None)          # Represent null\n        elif method == \"insert\":\n            res = obj.insert(args[0])\n            results.append(res)\n        elif method == \"remove\":\n            res = obj.remove(args[0])\n            results.append(res)\n        elif method == \"getRandom\":\n            res = obj.getRandom()\n            results.append(res)\n        else:\n            raise ValueError(f\"Unknown method {method}\")\n\n    # Convert results to JSON-like output (true/false/null)\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output pseudo-code step by step for implementing RandomizedCollection with insert, remove, getRandom in O(1). Use virtual code with arrows, decisions, etc. Provide explanation after each line. Use Start/End.\n\nWe need to outline the structure: maintain vector of values and map from value to set of indices. Insertion: push_back val to vector, add index to map; return true if val not existed before. Removal: if val not present return false. Else get an index of val from map, also get last element index, swap in vector, update map sets accordingly, pop_back. Return true. getRandom: random index from vector.\n\nWe should output step-by-step pseudocode for each method and constructor.\n\nMake sure each line ends with // explanation.\n\nLet's produce something like:\n\nStart // Program start\n→ Step: Initialize RandomizedCollection class\n    → Start constructor\n        → Initialize data structures\n        → End constructor\n    → End initialization\n\nBut better to show each method separate. Use virtual code with Start/End for each method.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step: 宣告 RandomizedCollection 類別\n    → Start constructor\n        → 資料結構: arr = [] // 存儲所有元素\n        → 資料結構: pos = {} // value -> set of indices\n        → End constructor\n    → Start insert(val)\n        → 如果 val 不在 pos: 新增空集合\n        → idx = arr.size() // 新元素索引\n        → arr.append(val)\n        → pos[val].add(idx)\n        → 回傳 (pos[val].size() == 1) // 是否首次插入\n        → End insert\n    → Start remove(val)\n        → 如果 val 不在 pos 或 pos[val] 為空: 回傳 false\n        → idx_to_remove = 任一元素從 pos[val] 取出\n        → last_idx = arr.size() - 1\n        → last_val = arr[last_idx]\n        → arr[idx_to_remove] = last_val // 覆蓋\n        → 更新 pos[last_val]: 移除 last_idx, 加入 idx_to_remove\n        → 移除 pos[val] 中 idx_to_remove\n        → arr.pop_back()\n        → 若 pos[val] 為空: 刪除 pos[val]\n        → 回傳 true\n        → End remove\n    → Start getRandom()\n        → idx = random(0, arr.size()-1)\n        → 回傳 arr[idx]\n        → End getRandom\nEnd // 程式執行結束\n\nBut we need to use arrows and decisions for conditional. Provide more explicit decisions with Yes/No. Also need to include each line. Use decision blocks. Provide short explanation.\n\nWe should produce like:\n\nStart // 程式開始執行\n→ Step: 建立 RandomizedCollection\n    → Start constructor // 建構子初始化\n        → arr = [] // 空陣列儲存所有元素\n        → pos = {} // map value → set of indices\n        → End constructor\n    → Start insert(val) // 插入元素\n        → Decision: 若 val 不在 pos? // 檢查是否首次插入\n            Yes → pos[val] = {} // 建立索引集合\n            No  → // 已存在\n        → idx = arr.size() // 新元素索引\n        → arr.append(val) // 加入陣列\n        → pos[val].add(idx) // 標記索引\n        → Decision: 若 pos[val] 大小 == 1? // 首次插入\n            Yes → Return true\n            No  → Return false\n        → End insert\n    → Start remove(val) // 移除元素\n        → Decision: 若 val 不在 pos 或 pos[val] 為空? // 元素不存在\n            Yes → Return false\n            No  → // 繼續\n        → idx_to_remove = 任一元素從 pos[val] 取出 // 任意索引\n        → last_idx = arr.size() - 1\n        → last_val = arr[last_idx]\n        → arr[idx_to_remove] = last_val // 覆蓋被移除位置\n        → Decision: 若 last_val == val? // 若刪除的就是最後一個\n            Yes → pos[val].remove(last_idx) // 移除最後索引\n            No  → // 需要更新\n                pos[last_val].remove(last_idx) // 移除舊索引\n                pos[last_val].add(idx_to_remove) // 加入新索引\n        → pos[val].remove(idx_to_remove) // 移除被刪除索引\n        → arr.pop_back() // 移除最後元素\n        → Decision: 若 pos[val] 變空? // 清理空集合\n            Yes → del pos[val]\n            No  → // 留下\n        → Return true\n        → End remove\n    → Start getRandom() // 隨機取值\n        → idx = random(0, arr.size()-1)\n        → Return arr[idx]\n        → End getRandom\nEnd // 程式執行結束\n\nMake sure each line ends with // 解釋.\n\nUse virtual code arrows. Use spaces appropriately.\n\nLet's produce final answer.\n...done thinking.\n\n```\nStart // 程式開始執行\n→ Step: 建立 RandomizedCollection 物件\n    → Start constructor // 初始化資料結構\n        → arr = [] // 用來儲存所有元素\n        → pos = {} // map: value → set of indices\n        → End constructor\n    → Start insert(val) // 插入元素\n        → Decision: 若 val 不在 pos? // 檢查是否首次插入\n            Yes → pos[val] = {} // 新增索引集合\n            No  → // 已存在\n        → idx = arr.size() // 取得新元素索引\n        → arr.append(val) // 將值加入陣列\n        → pos[val].add(idx) // 標記此索引\n        → Decision: 若 pos[val] 大小 == 1? // 判斷是否首次\n            Yes → Return true // 第一次插入\n            No  → Return false // 已存在\n        → End insert\n    → Start remove(val) // 移除元素\n        → Decision: 若 val 不在 pos 或 pos[val] 為空? // 元素不存在\n            Yes → Return false\n            No  → // 繼續執行\n        → idx_to_remove = 任一元素從 pos[val] 取出 // 任意索引\n        → last_idx = arr.size() - 1\n        → last_val = arr[last_idx]\n        → arr[idx_to_remove] = last_val // 用最後一個元素覆蓋被刪位置\n        → Decision: 若 last_val == val? // 刪除的正是最後一個元素\n            Yes → pos[val].remove(last_idx) // 移除舊索引\n            No  → // 需要更新另一個索引\n                pos[last_val].remove(last_idx) // 移除舊索引\n                pos[last_val].add(idx_to_remove) // 加入新索引\n        → pos[val].remove(idx_to_remove) // 移除被刪元素的索引\n        → arr.pop_back() // 刪除陣列最後元素\n        → Decision: 若 pos[val] 為空? // 清理空集合\n            Yes → del pos[val]\n            No  → // 留下\n        → Return true\n        → End remove\n    → Start getRandom() // 隨機取值\n        → idx = random(0, arr.size()-1) // 產生隨機索引\n        → Return arr[idx] // 取得隨機元素\n        → End getRandom\nEnd // 程式執行結束\n```"
    },
    {
      "title": "Coin Change",
      "source_file": "Leetcode/leetcode322.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpj2q0r17b.py\", line 28, in <module>\n    coins = eval(part.split('=')[1].strip())\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def coinChange(self, coins, amount):\n        # dp[i] 表示湊成金額 i 所需的最少硬幣數，初始化為無限大\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0  # 零金額不需要硬幣\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                if dp[x - coin] + 1 < dp[x]:\n                    dp[x] = dp[x - coin] + 1\n        return dp[amount] if dp[amount] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取資料\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit()\n    # 允許輸入跨多行，將換行符號轉為空格以方便分割\n    raw_input = raw_input.replace('\\n', ' ')\n    # 分割為「coins = [...]」與「amount = ...」兩部分\n    parts = [p.strip() for p in raw_input.split(',')]\n    coins = []\n    amount = 0\n    for part in parts:\n        if part.startswith('coins'):\n            # 解析 coins 列表\n            coins = eval(part.split('=')[1].strip())\n        elif part.startswith('amount'):\n            amount = int(part.split('=')[1].strip())\n    # 執行解法\n    solution = Solution()\n    result = solution.coinChange(coins, amount)\n    # 將答案輸出到標準輸出\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for coin change min coins. Should use dynamic programming. Provide steps. Must be in Traditional Chinese. Format: each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nLet's produce steps:\n\nStart\n\n→ Initialize array dp of size amount+1 with Infinity\n\n→ Set dp[0] = 0\n\n→ For each coin in coins:\n\n    → For i from coin to amount:\n\n        → If dp[i-coin] + 1 < dp[i] then dp[i] = dp[i-coin] + 1\n\n→ After loops, if dp[amount] == Infinity return -1 else return dp[amount]\n\nEnd\n\nAdd explanation for each.\n\nNeed to include Decision nodes? Could add decision at end: if dp[amount] == Infinity? Use Decision.\n\nLet's produce step-by-step.\n\nMake sure to include arrows.\n\nWe'll produce something like:\n\nStart // 程式開始執行\n\n→ Step 1: 建立 dp 陣列長度 amount+1 並以 Infinity 初始化 // 用來儲存各金額最少硬幣數\n\n→ Step 2: dp[0] ← 0 // 零金額不需要硬幣\n\n→ Step 3: Decision: 迭代每種硬幣 denom in coins? // 遍歷所有硬幣面額\n\n    Yes → Loop 1: For each coin\n\nBut we might need nested loops.\n\nBetter: Use Step 3: For each coin in coins // 對每個硬幣進行處理\n\nThen inside, Step 4: For amount i from coin to amount // 嘗試用此硬幣組合更新 dp\n\nThen Step 5: Decision: 如果 dp[i-coin] + 1 < dp[i]? // 判斷是否能得到更少硬幣\n\n    Yes → Step 6: dp[i] ← dp[i-coin] + 1 // 更新更優解\n\n    No → Skip\n\nAfter loops, Step 7: Decision: 如果 dp[amount] == Infinity?\n\n    Yes → Step 8: Return -1 // 無法組成金額\n\n    No  → Step 9: Return dp[amount] // 回傳最少硬幣數\n\nEnd // 程式執行結束\n\nBut we need to use \"Yes →\", \"No →\" arrows inside decision.\n\nEnsure each line follows format: \"虛擬碼步驟 // 解釋\". The decision lines also follow that format.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 dp 陣列長度 amount+1 並以 Infinity 初始化 // 用來儲存各金額最少硬幣數  \n→ Step 2: dp[0] ← 0 // 零金額不需要硬幣  \n→ Step 3: Decision: 迭代每個硬幣 denom in coins? // 遍歷所有硬幣面額  \n    Yes → Step 4: For i from denom to amount // 以當前硬幣面額遞增檢查金額  \n        → Step 5: Decision: 如果 dp[i-denom] + 1 < dp[i]? // 判斷是否能用更少硬幣組成金額  \n            Yes → Step 6: dp[i] ← dp[i-denom] + 1 // 更新為更優解  \n            No  → // 不更新，保持現有更小值  \n→ Step 7: Decision: 如果 dp[amount] == Infinity? // 檢查是否能組成目標金額  \n    Yes → Step 8: Return -1 // 無法組成金額，返回 -1  \n    No  → Step 9: Return dp[amount] // 回傳最少硬幣數  \nEnd // 程式執行結束"
    },
    {
      "title": "Data Stream as Disjoint Intervals",
      "source_file": "Leetcode/leetcode352.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]",
          "expected_output": "[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,null,[[1,1]],null,[[1,1],[3,3]],null,[[1,1],[3,3],[7,7]],null,[[1,3],[7,7]],null,[[1,3],[6,7]]]'\nGot (Norm):      '[None,None,[[1,1]],None,[[1,1],[3,3]],None,[[1,1],[3,3],[7,7]],None,[[1,3],[7,7]],None,[[1,3],[6,7]]]'\n--- (Raw) ---\nRaw Expected: '[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]'\nRaw Got:      '[None, None, [[1, 1]], None, [[1, 1], [3, 3]], None, [[1, 1], [3, 3], [7, 7]], None, [[1, 3], [7, 7]], None, [[1, 3], [6, 7]]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass SummaryRanges:\n    \"\"\"\n    用於動態維護不重疊區間的資料結構。\n    內部以有序列表 self.intervals 來儲存所有區間。\n    每個區間以 [start, end] 的形式存放，且互不重疊且有序。\n    \"\"\"\n\n    def __init__(self):\n        # 初始時沒有任何數字，區間列表為空\n        self.intervals = []\n\n    def addNum(self, val: int) -> None:\n        \"\"\"\n        把數字 val 加入到區間集合中。\n        若 val 已經屬於某個區間，則不改動。\n        否則合併與它相鄰的區間，或新增一個區間。\n        \"\"\"\n        # 以 val 本身為新的區間\n        new_interval = [val, val]\n        res = []          # 儲存更新後的區間\n        placed = False    # 標記是否已將 new_interval 放入 res\n\n        # 遍歷現有區間，根據與 val 的關係決定動作\n        for start, end in self.intervals:\n            if end + 1 < val:\n                # 現有區間在 val 的左側，且不相鄰\n                res.append([start, end])\n            elif val + 1 < start:\n                # 現有區間在 val 的右側，且不相鄰\n                if not placed:\n                    res.append(new_interval)\n                    placed = True\n                res.append([start, end])\n            else:\n                # val 與現有區間相鄰或重疊，合併\n                new_interval[0] = min(start, new_interval[0])\n                new_interval[1] = max(end, new_interval[1])\n\n        # 若新的區間還沒放入，則最後放入\n        if not placed:\n            res.append(new_interval)\n\n        # 更新區間列表\n        self.intervals = res\n\n    def getIntervals(self) -> list:\n        \"\"\"\n        回傳目前所有不重疊且已排序好的區間列表。\n        \"\"\"\n        return self.intervals\n\n\nif __name__ == \"__main__\":\n    # 讀取兩行輸入：命令序列與對應參數\n    commands = ast.literal_eval(sys.stdin.readline().strip())\n    args = ast.literal_eval(sys.stdin.readline().strip())\n\n    result = []\n    obj = None\n\n    for cmd, arg in zip(commands, args):\n        if cmd == \"SummaryRanges\":\n            obj = SummaryRanges()\n            result.append(None)  # 建構子回傳 None\n        elif cmd == \"addNum\":\n            # addNum 只接收一個整數\n            obj.addNum(arg[0] if isinstance(arg, list) else arg)\n            result.append(None)\n        elif cmd == \"getIntervals\":\n            result.append(obj.getIntervals())\n\n    # 直接輸出結果，LeetCode 會將 None 轉為 null\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code for SummaryRanges class with methods: constructor, addNum, getIntervals. Should use virtual code with arrows and explanation. Use structure: Start, Decision, End. Probably need data structures: sorted list or balanced BST. Use list of intervals, merging on insertion.\n\nOutline: maintain list of intervals sorted. On addNum, find position to insert or merge. Use binary search for efficiency. But pseudo code can be simple: iterate over intervals, find where value fits, merge.\n\nPseudo:\n\nStart\n→ Initialize intervals as empty list // list of [start, end]\n→ addNum(value): // add value\n    → Decision: if intervals empty? // if no intervals\n        Yes → intervals.append([value, value]) // new interval\n        No → Find position i such that intervals[i].start <= value <= intervals[i].end? or between.\n            → Decision: if value already in an interval? // check overlap\n                Yes → Do nothing // value already covered\n                No → Find left neighbor and right neighbor to merge\n                    → Decision: if left exists and left.end +1 == value? // adjacent left\n                        Yes → left.end = value\n                        No → ...\n                    → Decision: if right exists and right.start -1 == value? // adjacent right\n                        Yes → right.start = value\n                        No → ...\n                    → Decision: if left and right both adjacent? // merge both\n                        Yes → left.end = right.end; remove right\n                        No → create new interval [value,value] and insert at correct spot\n→ getIntervals(): return intervals copy\n\nEnd\n\nWe need each line: virtual code step + comment. Use arrow syntax and decisions.\n\nLet's produce step-by-step:\n\nStart\n→ Initialize intervals as empty list // 用於儲存已加入的區間\n→ Function addNum(value) // 進入新增數字的流程\n    → Decision: intervals 为空? // 檢查是否還沒有任何區間\n        Yes → intervals.append([value, value]) // 建立新的單一區間\n        No  → // 需要找尋值所在的位置\n            → Find i such that intervals[i].start <= value <= intervals[i].end? // 確認值是否已被覆蓋\n                → Decision: value 在某區間內? // 判斷是否已有覆蓋\n                    Yes → End // 已覆蓋，無需任何變更\n                    No  → // 準備合併相鄰區間\n                        → Find left = interval just before i, right = interval just after i\n                        → Decision: left exists and left.end +1 == value? // 可與左相鄰\n                            Yes → left.end = value // 延伸左區間結尾\n                            No  → // 無左相鄰\n                                → Decision: right exists and right.start -1 == value? // 可與右相鄰\n                                    Yes → right.start = value // 延伸右區間開始\n                                    No  → // 同時無左右相鄰\n                                        → Decision: left exists and left.end +1 == right.start -1 == value? // 同時相鄰左右，合併兩區間\n                                            Yes → left.end = right.end // 合併右區間至左\n                                            No  → // 兩邊均不相鄰，單獨插入新區間\n                                                → intervals.insert(position, [value,value]) // 插入新區間\n→ Function getIntervals() // 取得目前所有區間\n    → Return copy of intervals // 回傳不會被外部改動的區間清單\nEnd\n\nNeed to format each line with \"虛擬碼步驟\" + space + \"// 解釋\".\n\nMake sure to include arrows '→', 'Yes →', 'No →' properly. Each line should be a step; decisions are multiple lines under decision.\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Initialize intervals as empty list // 用於儲存已加入的區間  \n→ Function addNum(value) // 進入新增數字的流程  \n    → Decision: intervals 为空? // 檢查是否還沒有任何區間  \n        Yes → intervals.append([value, value]) // 建立新的單一區間  \n        No  → // 需要找尋值所在的位置  \n            → Find i such that intervals[i].start <= value <= intervals[i].end? // 確認值是否已被覆蓋  \n                → Decision: value 在某區間內? // 判斷是否已有覆蓋  \n                    Yes → End // 已覆蓋，無需任何變更  \n                    No  → // 準備合併相鄰區間  \n                        → Find left = interval just before i, right = interval just after i  \n                        → Decision: left exists and left.end +1 == value? // 可與左相鄰  \n                            Yes → left.end = value // 延伸左區間結尾  \n                            No  → // 無左相鄰  \n                                → Decision: right exists and right.start -1 == value? // 可與右相鄰  \n                                    Yes → right.start = value // 延伸右區間開始  \n                                    No  → // 同時無左右相鄰  \n                                        → Decision: left exists and left.end +1 == right.start -1 == value? // 同時相鄰左右，合併兩區間  \n                                            Yes → left.end = right.end // 合併右區間至左  \n                                            No  → // 兩邊均不相鄰，單獨插入新區間  \n                                                → intervals.insert(position, [value,value]) // 插入新區間  \n→ Function getIntervals() // 取得目前所有區間  \n    → Return copy of intervals // 回傳不會被外部改動的區間清單  \nEnd // 程式執行結束"
    },
    {
      "title": "Insert Interval",
      "source_file": "Leetcode/leetcode57.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
          "expected_output": "[[1,5],[6,9]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppfrw6s45.py\", line 48, in <module>\n    intervals, newInterval = parse_input(raw_input)\n                             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppfrw6s45.py\", line 41, in parse_input\n    values[key.strip()] = eval(val.strip())\n                          ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",
          "expected_output": "[[1,2],[3,10],[12,16]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpyq6_7g2j.py\", line 48, in <module>\n    intervals, newInterval = parse_input(raw_input)\n                             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpyq6_7g2j.py\", line 41, in parse_input\n    values[key.strip()] = eval(val.strip())\n                          ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom typing import List\n\nclass Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        result = []\n        i = 0\n        n = len(intervals)\n\n        # 先加入所有不與 newInterval 重疊且在它之前的區間\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n\n        # 合併所有與 newInterval 重疊的區間\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n\n        # 加入合併後的區間\n        result.append(newInterval)\n\n        # 加入剩餘不重疊的區間\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n\n        return result\n\ndef parse_input(data: str):\n    \"\"\"\n    解析輸入字串，預期格式類似：\n    intervals = [[1,3],[6,9]], newInterval = [2,5]\n    \"\"\"\n    parts = data.split(',')\n    values = {}\n    for part in parts:\n        if '=' in part:\n            key, val = part.split('=', 1)\n            values[key.strip()] = eval(val.strip())\n    return values['intervals'], values['newInterval']\n\nif __name__ == \"__main__\":\n    # 讀取整個輸入\n    raw_input = sys.stdin.read()\n    # 解析 intervals 與 newInterval\n    intervals, newInterval = parse_input(raw_input)\n    # 執行插入與合併\n    sol = Solution()\n    result = sol.insert(intervals, newInterval)\n    # 輸出結果\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce a virtual code, step by step, with explanations, using the format. Should describe algorithm: merge intervals insertion. Use virtual code steps. Must not output actual code. Use Start, Decision, Yes→, No→, etc.\n\nWe need to think of algorithm: given sorted non-overlapping intervals, insert newInterval, merge overlaps. Typical approach: iterate through intervals, output before newInterval, then merge, then output after.\n\nPseudocode:\n\nStart\n→ Step 1: Initialize result list\n→ Step 2: Initialize i=0\n→ Decision: While i < intervals.length and intervals[i].end < newInterval.start? // before new interval\nYes → Step: Add intervals[i] to result; i++\nNo → End While\n→ Step: Initialize mergedStart = min(intervals[i].start, newInterval.start) // start of merged interval\n→ Step: mergedEnd = max(intervals[i].end, newInterval.end)\n→ Decision: While i < intervals.length and intervals[i].start <= mergedEnd? // overlap\nYes → mergedEnd = max(mergedEnd, intervals[i].end); i++\nNo → End While\n→ Step: Add [mergedStart, mergedEnd] to result\n→ Decision: While i < intervals.length? // append remaining\nYes → Step: Add intervals[i] to result; i++\nNo → End While\n→ End // return result\n\nAlso handle case if all intervals before newInterval: if while loop finishes without merging, then we need to add newInterval after loop. Actually we need to handle cases where newInterval is after all intervals. But the algorithm above merges only if there is an overlap; but we also need to add newInterval if there is no overlapping.\n\nSimplify: Approach: iterate intervals, add those ending before newInterval.start. When encountering first interval that might overlap, we merge starting with newInterval. If no overlap found at all (i reached end), just add newInterval. Then continue adding remaining intervals.\n\nThus steps:\n\nStart\n→ Step: result = []\n→ Step: i = 0\n→ Decision: i < len(intervals) and intervals[i].end < newInterval.start?\n    Yes → Step: result.append(intervals[i]); i++ // add non-overlap before\n    No  → End While\nIf i == len(intervals):\n    → Step: result.append(newInterval) // new interval goes at end\n    → End // return result\nElse:\n    → Step: mergedStart = min(intervals[i].start, newInterval.start)\n    → Step: mergedEnd = max(intervals[i].end, newInterval.end)\n    → Decision: i < len(intervals) and intervals[i].start <= mergedEnd?\n        Yes → mergedEnd = max(mergedEnd, intervals[i].end); i++\n        No → End While\n    → Step: result.append([mergedStart, mergedEnd])\n→ Decision: i < len(intervals)?\n    Yes → Step: result.append(intervals[i]); i++\n    No → End While\n→ End\n\nWe need to produce each step line with explanation.\n\nWe can embed decision blocks. Use indentation for nested.\n\nWe need to use `→` arrow for steps, `Decision:` for decision, `Yes →` and `No →`.\n\nWe need to avoid actual code, so use plain description: result.append, etc.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化 result 為空陣列 // 建立儲存結果的列表  \n→ Step 2: 設定 i = 0 // 用於遍歷原 intervals  \n\n→ Decision: i < intervals.length 且 intervals[i].end < newInterval.start? // 檢查是否還有不重疊且在新區間前的區間  \n    Yes → Step 3: 將 intervals[i] 加入 result；i++ // 將所有完全在新區間之前的區間直接加入結果  \n    No  → End While // 遞迴完成，跳出循環  \n\n→ Decision: i == intervals.length? // 新區間在所有原區間之後  \n    Yes → Step 4: 將 newInterval 加入 result // 新區間直接放在結尾  \n    No  → Step 5: 進行合併過程 // 有可能會與後續區間重疊  \n\n→ Step 6: 設定 mergedStart = min(intervals[i].start, newInterval.start) // 合併區間起點  \n→ Step 7: 設定 mergedEnd = max(intervals[i].end, newInterval.end) // 合併區間終點  \n\n→ Decision: i < intervals.length 且 intervals[i].start <= mergedEnd? // 判斷是否與目前區間重疊  \n    Yes → Step 8: 更新 mergedEnd = max(mergedEnd, intervals[i].end)；i++ // 更新合併終點並移至下一區間  \n    No  → End While // 無重疊，結束合併  \n\n→ Step 9: 將 [mergedStart, mergedEnd] 加入 result // 將合併後的區間存入結果  \n\n→ Decision: i < intervals.length? // 還有剩餘原區間  \n    Yes → Step 10: 將 intervals[i] 加入 result；i++ // 直接加入後續區間  \n    No  → End While // 所有區間已處理  \n\nEnd // 程式執行結束，返回 result"
    },
    {
      "title": "Reorganize String",
      "source_file": "Leetcode/leetcode767.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"aab\"",
          "expected_output": "\"aba\"",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): 'aba'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '\"aba\"'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\nimport re\nimport heapq\nfrom collections import Counter\n\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        \"\"\"Rearrange string so that no two adjacent characters are the same.\n        Return an empty string if it's impossible.\"\"\"\n        n = len(s)\n        if n <= 1:\n            return s\n\n        # Count frequency of each character\n        freq = Counter(s)\n        max_freq = max(freq.values())\n\n        # Quick feasibility check\n        if max_freq > (n + 1) // 2:\n            return \"\"\n\n        # Build a max-heap of (negative frequency, character)\n        max_heap = [(-count, ch) for ch, count in freq.items()]\n        heapq.heapify(max_heap)\n\n        prev_freq, prev_char = 0, ''\n        result = []\n\n        # Main loop: pick two most frequent characters each time\n        while len(max_heap) > 1:\n            f1, c1 = heapq.heappop(max_heap)\n            f2, c2 = heapq.heappop(max_heap)\n\n            # Append the two characters\n            result.append(c1)\n            result.append(c2)\n\n            # Decrease frequencies and push back if still positive\n            if f1 + 1 < 0:\n                heapq.heappush(max_heap, (f1 + 1, c1))\n            if f2 + 1 < 0:\n                heapq.heappush(max_heap, (f2 + 1, c2))\n\n        # If one character remains, append it\n        if max_heap:\n            f, c = heapq.heappop(max_heap)\n            if f < 0:  # more than one remaining instance -> impossible\n                return \"\"\n            result.append(c)\n\n        # Final check: length should match original string\n        rearranged = ''.join(result)\n        return rearranged if len(rearranged) == n else \"\"\n\nif __name__ == \"__main__\":\n    # Read all input from stdin\n    raw_input = sys.stdin.read().strip()\n\n    # Try to extract the string inside double quotes\n    match = re.search(r'\"([^\"]*)\"', raw_input)\n    if match:\n        s = match.group(1)\n    else:\n        # If no quotes, use the whole input as the string\n        s = raw_input\n\n    sol = Solution()\n    output = sol.reorganizeString(s)\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for rearranging string so adjacent chars not same. This is typical problem: reorganize string. Use priority queue of frequencies. Steps: count frequencies, check if max freq <= (n+1)/2 else impossible. Build result by repeatedly picking two most frequent characters and appending, decrement counts. After loop, if one char remains add it. Implementation pseudo-code: Start; Input s; Count freq; Determine max freq; If max_freq > (len+1)/2 return \"\"; Initialize max-heap with pairs (freq,char). Initialize result string. While heap size > 1: pop two highest freq chars; append them; decrement; if freq>0 push back. After loop if heap not empty push remaining char. Return result.\n\nWe need to output each line with virtual code and explanation.\n\nWe need to use arrow format. Let's produce step-by-step.\n\nWe should ensure each line: \"虛擬碼步驟 // 解釋\". Use arrow \"→\" etc.\n\nLet's write:\n\nStart // 程式開始執行\n→ Step 1: Input string s // 取得輸入字串\n→ Step 2: Count frequency of each character in s → result freq_map // 建立字元頻率表\n→ Step 3: Determine maximum frequency maxFreq from freq_map // 找出最頻繁字元的次數\n→ Decision: 如果 maxFreq > (len(s)+1)/2? // 檢查是否能重新排列\n    Yes → Step 4: Return \"\" // 不可能，直接回傳空字串\n    No  → Step 5: 建立最大堆 (priority queue) 以 freq 為優先級並加入所有 (freq, char) // 用堆管理頻率\n→ Step 6: 初始化空字串 result // 用來儲存排列結果\n→ Decision: 堆大小 > 1? // 需要至少兩個字元才能繼續交替\n    Yes → Step 7: 取出兩個頻率最高的項目 (freq1, char1) 和 (freq2, char2) // 取兩個最常見字元\n        → Step 8: Append char1 與 char2 到 result // 將兩個字元交替加入結果\n        → Step 9: 逐一減少 freq1、freq2\n        → Decision: freq1 > 0? // 若 char1 還有剩餘\n            Yes → Step 10: 將 (freq1-1, char1) 放回堆 // 放回堆中\n        → Decision: freq2 > 0? // 若 char2 還有剩餘\n            Yes → Step 11: 將 (freq2-1, char2) 放回堆 // 放回堆中\n        → Step 12: 回到 Decision: 堆大小 > 1? // 重新檢查堆大小\n    No  → Decision: 堆是否還有剩餘字元? // 可能剩下一個字元\n        Yes → Step 13: 取出唯一項目 (freq, char) // 取剩下的字元\n            → Decision: freq > 1? // 檢查剩餘次數是否超過 1\n                Yes → Step 14: Return \"\" // 超過 1 表示無法排布\n                No  → Step 15: Append char 到 result // 單次字元加入結果\n        No  → // 堆已空，無剩餘字元\n→ Step 16: Return result // 回傳完成的排列字串\nEnd // 程式執行結束\n\nBut we need to ensure each line is distinct. Maybe we need to break decision blocks accordingly.\n\nLet's create properly with indentation.\n\nWe also need to ensure each line ends with `//` comment.\n\nLet's produce.\n\nAlso maybe we can use \"Decision:\" lines with arrow indent.\n\nMake sure each line of code: either step or decision. Use arrow arrow or colon. Format example: \"Decision: 如果 maxFreq > (len(s)+1)/2?\" etc. Then indent lines inside yes/no.\n\nLet's produce final answer.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: Input string s // 取得輸入字串  \n→ Step 2: Count frequency of each character in s → freq_map // 建立字元頻率表  \n→ Step 3: Determine maximum frequency maxFreq from freq_map // 找出最頻繁字元的次數  \n→ Decision: 如果 maxFreq > (len(s)+1)/2? // 檢查是否能重新排列  \n  Yes → Step 4: Return \"\" // 不可能，直接回傳空字串  \n  No  → Step 5: Build a max‑heap (priority queue) from freq_map entries (freq, char) // 用堆管理頻率  \n→ Step 6: Initialize empty string result // 用來儲存排列結果  \n→ Decision: 堆大小 > 1? // 需要至少兩個字元才能交替放置  \n  Yes → Step 7: Pop two highest‑frequency items (freq1, char1) and (freq2, char2) from heap // 取兩個最常見字元  \n    → Step 8: Append char1 and char2 to result // 將兩個字元交替加入結果  \n    → Step 9: Decrement freq1 and freq2 by 1 // 逐一減少頻率  \n    → Decision: freq1 > 0?  \n     Yes → Step 10: Push (freq1-1, char1) back into heap // 若 char1 還有剩餘，放回堆  \n    → Decision: freq2 > 0?  \n     Yes → Step 11: Push (freq2-1, char2) back into heap // 若 char2 還有剩餘，放回堆  \n    → Step 12: 回到 Decision: 堆大小 > 1? // 重新檢查堆大小  \n  No  → Decision: 堆是否還有剩餘字元? // 可能剩下一個字元  \n    Yes → Step 13: Pop the single remaining item (freq, char) from heap // 取剩下的字元  \n      → Decision: freq > 1? // 檢查剩餘次數是否超過 1  \n       Yes → Step 14: Return \"\" // 超過 1 表示無法排布  \n       No  → Step 15: Append char to result // 單次字元加入結果  \n    No  → // 堆已空，無剩餘字元  \n→ Step 16: Return result // 回傳完成的排列字串  \nEnd // 程式執行結束"
    },
    {
      "title": "Group Anagrams",
      "source_file": "Leetcode/leetcode49.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nGot (Norm):      '[[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]'\n--- (Raw) ---\nRaw Expected: '[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]'\nRaw Got:      '[[\"eat\", \"tea\", \"ate\"], [\"tan\", \"nat\"], [\"bat\"]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport json\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        組合所有字母相同的字串\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        anagrams = defaultdict(list)\n        for s in strs:\n            # 先排序後再轉成 tuple 作為鍵，因為字串不可哈希\n            key = tuple(sorted(s))\n            anagrams[key].append(s)\n        # 只取值，鍵不需要\n        return list(anagrams.values())\n\nif __name__ == \"__main__\":\n    # 讀取整個 stdin\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        # 沒有輸入就直接結束\n        sys.exit(0)\n\n    # 如果輸入包含等號，取得等號右側的表達式\n    if \"=\" in raw_input:\n        _, expr = raw_input.split(\"=\", 1)\n    else:\n        expr = raw_input\n\n    # 用 ast.literal_eval 解析成 Python 物件，安全性高\n    try:\n        strs = ast.literal_eval(expr.strip())\n    except Exception:\n        # 若解析失敗，則直接終止\n        sys.exit(1)\n\n    solution = Solution()\n    result = solution.groupAnagrams(strs)\n\n    # 使用 json.dumps 讓輸出使用雙引號，符合範例格式\n    print(json.dumps(result))",
      "virtual_code": "Thinking...\nWe need to produce virtual code for grouping anagrams. Provide step-by-step. Use Start, End, Decision. Need to produce in Chinese. Provide explanation after each line. Virtual code lines: Start, input array, maybe iterate, create map keyed by sorted string or char counts. Add to map, then output groups. Provide simple logic. Let's produce steps:\n\n1. Start.\n2. Step: Initialize empty hash map dict: key->list.\n3. Step: For each string s in strs:\n   - Step: sort chars to key.\n   - Step: if key not in dict, add new list.\n   - Step: append s to dict[key].\n4. Step: result = list of dict values.\n5. End.\n\nAdd explanation after each line. Use \"→\" for flow. Provide decisions? Could include decision to check if key exists: Decision. Provide branching. So implement:\n\nStart\n→ Step 1: 初始化空哈希表 anagram_map // 建立鍵值對存放字母組合及其字串\n→ Decision: 是否開始遍歷 strs? Yes → Step 2: 循環遍歷 strs 中每個字串 s // 對每個字串進行處理\n    → Step 3: 將 s 轉換為排序後的字母串 key // 排序後的字串作為分組鍵\n    → Decision: key 是否存在於 anagram_map? Yes → Step 4: 追加 s 到 anagram_map[key] // 已有鍵，追加字串\n                     No  → Step 5: 創建新列表 anagram_map[key] ← [s] // 新鍵，創建列表並加入字串\n→ Step 6: 取得 anagram_map 的所有值作為結果 list_of_groups // 將分組結果轉為列表\nEnd\n\nAdd explanation. Use Chinese. Ensure each line ends with // 解釋. Use arrow. Provide decision branches. Use \"Yes →\" and \"No →\". Good.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化空哈希表 anagram_map // 建立鍵值對存放字母組合及其字串  \n→ Decision: 是否開始遍歷 strs?  \n    Yes → Step 2: 循環遍歷 strs 中每個字串 s // 對每個字串進行處理  \n        → Step 3: 將 s 轉換為排序後的字母串 key // 排序後的字串作為分組鍵  \n        → Decision: key 是否存在於 anagram_map?  \n            Yes → Step 4: 追加 s 到 anagram_map[key] // 已有鍵，追加字串  \n            No  → Step 5: 創建新列表 anagram_map[key] ← [s] // 新鍵，創建列表並加入字串  \n→ Step 6: 取得 anagram_map 的所有值作為結果 list_of_groups // 將分組結果轉為列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Intersection of Two Arrays II",
      "source_file": "Leetcode/leetcode350.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
          "expected_output": "[2,2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpdthj6ef7.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpdthj6ef7.py\", line 35, in main\n    nums1, nums2 = parse_input(data)\n                   ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpdthj6ef7.py\", line 27, in parse_input\n    nums[key] = eval(val)\n                ^^^^^^^^^\n  File \"<string>\", line 1\n    [1\n    ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
          "expected_output": "[4,9]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpe9b119ag.py\", line 43, in <module>\n    main()\n  File \"/tmp/tmpe9b119ag.py\", line 35, in main\n    nums1, nums2 = parse_input(data)\n                   ^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpe9b119ag.py\", line 27, in parse_input\n    nums[key] = eval(val)\n                ^^^^^^^^^\n  File \"<string>\", line 1\n    [4\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import Counter\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        # Count occurrences in both lists\n        c1 = Counter(nums1)\n        c2 = Counter(nums2)\n        res = []\n        # For each number in nums1's counter, add the minimum count present in both\n        for num in c1:\n            if num in c2:\n                res.extend([num] * min(c1[num], c2[num]))\n        return res\n\ndef parse_input(data: str):\n    \"\"\"\n    解析形如 'nums1 = [1,2,2,1], nums2 = [2,2]' 的輸入字串。\n    \"\"\"\n    parts = data.split(',')\n    nums = {}\n    for part in parts:\n        key, val = part.split('=', 1)\n        key = key.strip()\n        val = val.strip()\n        # 使用 eval 解析列表字面量\n        nums[key] = eval(val)\n    return nums['nums1'], nums['nums2']\n\ndef main():\n    # 讀取整個 stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    nums1, nums2 = parse_input(data)\n    solution = Solution()\n    result = solution.intersect(nums1, nums2)\n    # 輸出不含空格的列表格式\n    output = '[' + ','.join(map(str, result)) + ']'\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps in Chinese, no actual code, line by line with explanation. The task: given two integer arrays, return intersection array with duplicates counted as min occurrences. Approach: count elements of first array into hash map, then iterate second array, if present count>0 add to result and decrement. Steps: Start, initialize map, iterate nums1, etc. Use virtual code format.\n\nLet's write.\n\nStart // program start\n→ Step 1: 定義空字典 freqMap // 用於存儲 nums1 中各數字及其出現次數\n→ Step 2: 定義空列表 result // 用於儲存最終交集\n→ Decision: 如果 nums1 為空? // 若第一個陣列為空，直接返回空結果\n    Yes → Step 3: 返回 result // 交集為空\n    No  → Step 4: 迭代 nums1 // 將 nums1 中每個數字加入 freqMap\n        → Step 4.1: 若 freqMap 中已有該數字，將其計數加 1\n        → Step 4.2: 否則將該數字加入 freqMap，計數設為 1\n→ Step 5: 迭代 nums2 // 遍歷第二個陣列\n    → Step 5.1: 如果 freqMap 包含 nums2[i] 且計數 > 0\n        → Step 5.1.1: 將 nums2[i] 加入 result\n        → Step 5.1.2: 將 freqMap[nums2[i]] 減 1\n→ End // 程式結束，result 為所需交集\n\nNeed to ensure we follow the format: each line: 虛擬碼步驟 + space + // 解釋\n\nAlso use arrow notation: Start, → Step, Decision: etc.\n\nAlso need to consider indentation? Format can show indentation by spaces. But just keep as separate lines.\n\nLet's produce final.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義空字典 freqMap // 用於存儲 nums1 中各數字及其出現次數  \n→ Step 2: 定義空列表 result // 用於儲存最終交集  \n→ Decision: 如果 nums1 為空? // 若第一個陣列為空，直接返回空結果  \n  Yes → Step 3: 返回 result // 交集為空，結束執行  \n  No  → Step 4: 迭代 nums1 // 將 nums1 中每個數字加入 freqMap  \n    → Step 4.1: 若 freqMap 中已有該數字，將其計數加 1 // 更新計數  \n    → Step 4.2: 否則將該數字加入 freqMap，計數設為 1 // 新增項目  \n→ Step 5: 迭代 nums2 // 遍歷第二個陣列，尋找共同元素  \n    → Step 5.1: 如果 freqMap 包含 nums2[i] 且計數 > 0  \n        → Step 5.1.1: 將 nums2[i] 加入 result // 交集元素加入結果  \n        → Step 5.1.2: 將 freqMap[nums2[i]] 減 1 // 減少可用次數  \nEnd // 程式執行結束，result 為所需交集的列表。"
    },
    {
      "title": "Distinct Subsequences",
      "source_file": "Leetcode/leetcode115.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "s = \"rabbbit\", t = \"rabbit\"",
          "expected_output": "3",
          "actual_output_or_error": "File \"/tmp/tmpbm7rdgme.py\", line 44\n    t = token[2:].strip('\"\")\n                        ^\nSyntaxError: unterminated string literal (detected at line 44)"
        },
        {
          "example_index": 1,
          "input": "s = \"babgbag\", t = \"bag\"",
          "expected_output": "5",
          "actual_output_or_error": "File \"/tmp/tmpm6j57td_.py\", line 44\n    t = token[2:].strip('\"\")\n                        ^\nSyntaxError: unterminated string literal (detected at line 44)"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        \"\"\"Return the number of distinct subsequences of s that equal t.\"\"\"\n        m, n = len(s), len(t)\n        # dp[i][j] 表示 s 的前 i 個字元能形成 t 的前 j 個字元的方式數\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # 空字串 t 可以由任何 s 的前綴產生，dp[i][0] = 1\n        for i in range(m + 1):\n            dp[i][0] = 1\n\n        # 填表\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    # 匹配：可以把這個字元做為 t 的最後一個字元，也可以忽略它\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    # 不匹配：只能忽略 s[i-1]\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[m][n]\n\ndef parse_input(data: str) -> tuple[str, str]:\n    \"\"\"\n    從輸入資料中解析出 s 和 t。支援兩種常見格式：\n    1. s = \"string\", t = \"string\"\n    2. 任意空白分隔且含有 s=... t=... 的字串\n    \"\"\"\n    pattern = r's\\s*=\\s*\"([^\"]*)\"\\s*,\\s*t\\s*=\\s*\"([^\"]*)\"'\n    match = re.search(pattern, data)\n    if match:\n        return match.group(1), match.group(2)\n\n    # fallback: 逐個 token 搜尋\n    s, t = \"\", \"\"\n    for token in data.replace(\"\\n\", \" \").split():\n        if token.startswith(\"s=\"):\n            s = token[2:].strip('\"')\n        elif token.startswith(\"t=\"):\n            t = token[2:].strip('\"\")\n    return s, t\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    s, t = parse_input(input_data)\n    result = Solution().numDistinct(s, t)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code step by step for algorithm: count distinct subsequences of s equal to t. Classic DP: dp[i][j] count ways s[0..i-1] to form t[0..j-1]. dp[0][0]=1, dp[i][0]=1, dp[0][j>0]=0. Recurrence: if s[i-1]==t[j-1] dp[i][j] = dp[i-1][j-1] + dp[i-1][j]; else dp[i][j] = dp[i-1][j]. Need to output as virtual code step by step, no real code. Each line \"虛擬碼步驟\" + space + comment. Use arrows etc. We'll produce steps: Start, Input s and t, n,m lengths, Initialize 2D array dp, set base cases, loops over i, j, apply decision if characters equal, update dp, after loops return dp[n][m], End.\n\nNeed to keep each line a step. Use Decision: if char equal? Yes-> add dp[i-1][j-1], No-> keep dp[i-1][j]. Might include separate assignments.\n\nLet's craft. We'll use arrows to indicate sequence. Provide explanation. Each line will be like:\n\nStart // 程式開始\n\n→ Step 1: 讀取字串 s 和 t // 從使用者取得兩個字串\n\n→ Step 2: 計算長度 n = s.length, m = t.length // 取得字串長度\n\n→ Step 3: 建立 dp 二維陣列 (n+1)×(m+1) // 用於存儲子問題答案\n\n→ Step 4: 初始化 dp[0][0] = 1 // 空字串與空字串的匹配方式\n\n→ Step 5: 初始化 dp[i][0] = 1 for i=1..n // 空目標字串可由任意前綴產生\n\n→ Step 6: 初始化 dp[0][j] = 0 for j=1..m // 無前綴無法產生非空目標\n\n→ Decision: i 從 1 到 n 迭代? // 進入第一層迴圈\n\n    Yes → → Step 7: 設定 j 從 1 到 m 迭代 // 進入第二層迴圈\n\n        Yes → → Decision: s[i-1] == t[j-1]? // 檢查當前字元是否匹配\n\n            Yes → → Step 8: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] // 匹配時加入兩種情況\n\n            No  → → Step 9: dp[i][j] = dp[i-1][j] // 不匹配時只可跳過 s 的字元\n\nEnd // 程式結束\n\nBut we need to output with arrow formatting: e.g., \"→ Step 1: 讀取字串 s 和 t // ...\" Use indent to show decision branching maybe using spaces. Provide final return: Step 10: 回傳 dp[n][m] // 返回答案.\n\nLet's create lines accordingly. Use \"Decision:\" lines with indentation. Ensure each line includes explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 讀取字串 s 和 t // 從使用者取得兩個字串\n→ Step 2: 計算長度 n = s.length, m = t.length // 取得兩個字串的長度\n→ Step 3: 建立 dp 二維陣列 (n+1)×(m+1) // 用於存儲子問題答案\n→ Step 4: 初始化 dp[0][0] = 1 // 空字串與空字串的匹配方式\n→ Step 5: 針對 i 從 1 到 n, 設定 dp[i][0] = 1 // 任意前綴都能匹配空目標\n→ Step 6: 針對 j 從 1 到 m, 設定 dp[0][j] = 0 // 無前綴無法匹配非空目標\n→ Decision: i 從 1 到 n 迭代? // 進入第一層迴圈\n    Yes → → Step 7: 針對 j 從 1 到 m 迭代 // 進入第二層迴圈\n        Yes → → Decision: s[i-1] == t[j-1]? // 檢查當前字元是否匹配\n            Yes → → Step 8: dp[i][j] = dp[i-1][j-1] + dp[i-1][j] // 匹配時加入兩種情況\n            No  → → Step 9: dp[i][j] = dp[i-1][j] // 不匹配時只能跳過 s 的字元\n→ Step 10: 回傳 dp[n][m] // 返回最終答案\nEnd // 程式結束"
    },
    {
      "title": "Count of Smaller Numbers After Self",
      "source_file": "Leetcode/leetcode315.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [5,2,6,1]",
          "expected_output": "[2,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,1,1,0]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[2,1,1,0]'\nRaw Got:      ''"
        },
        {
          "example_index": 1,
          "input": "nums = [-1]",
          "expected_output": "[0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[0]'\nRaw Got:      ''"
        },
        {
          "example_index": 2,
          "input": "nums = [-1,-1]",
          "expected_output": "[0,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,0]'\nGot (Norm):      ''\n--- (Raw) ---\nRaw Expected: '[0,0]'\nRaw Got:      ''"
        }
      ],
      "generated_code": "import sys\n\nclass BIT:\n    def __init__(self, size):\n        self.tree = [0] * (size + 1)\n        self.size = size\n\n    def update(self, index, delta):\n        while index <= self.size:\n            self.tree[index] += delta\n            index += index & -index\n\n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\n\nclass Solution:\n    def countSmaller(self, nums):\n        # 將所有不重複的數字排序，並為每個數字建立排名\n        sorted_unique = sorted(set(nums))\n        ranks = {num: i + 1 for i, num in enumerate(sorted_unique)}\n\n        bit = BIT(len(ranks))\n        res = []\n\n        # 從右往左遍歷，對於每個數字，查詢比它小的數字個數\n        for num in reversed(nums):\n            rank = ranks[num]\n            res.append(bit.query(rank - 1))\n            bit.update(rank, 1)\n\n        return res[::-1]\n\n\nif __name__ == \"__main__\":\n    # 從標準輸入讀取完整內容\n    data_str = sys.stdin.read().strip()\n    if not data_str:\n        sys.exit(0)\n\n    # 解析輸入，期望類似 \"nums = [5,2,6,1]\"\n    try:\n        data = eval(data_str)\n        nums = data[\"nums\"]\n    except Exception:\n        # 如果輸入格式不符，直接終止\n        sys.exit(0)\n\n    result = Solution().countSmaller(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce pseudocode for the problem: given array nums, return counts of smaller elements to right. Classic \"Count of Smaller Numbers After Self\". Approach: use BIT or BST or merge sort with counting. Let's use merge sort inversion count variant. Provide line by line steps.\n\nWe need to output in required format: each line: \"虛擬碼步驟 // 解釋\". Use arrows.\n\nWe'll create a function CountSmaller(nums). Steps: create pairs with index, sort via merge sort counting. Provide start, decision, loops.\n\nLet's produce pseudocode:\n\nStart\n→ Step 1: 初始化 counts 為長度 n 的全 0 // 用來存結果\n→ Step 2: 創建 arr 為 [(value, index)] // 保存值和原始位置\n→ Step 3: 呼叫 MergeSort(arr, 0, n-1, counts) // 分治排序同時計算\n→ End // 返回 counts\n\nMergeSort(arr, left, right, counts)\n→ Decision: 如果 left >= right? // 基本情況\n    Yes → Return arr // 子陣列只一個元素\n→ Step 4: mid = (left + right) / 2\n→ Step 5: leftSorted = MergeSort(arr, left, mid, counts)\n→ Step 6: rightSorted = MergeSort(arr, mid+1, right, counts)\n→ Step 7: Merge two halves while counting\n    // Merge: i指向左半，j指向右半，k存合併結果\n→ Step 8: i=left, j=mid+1, k=0\n→ Step 9: 創建 temp 為空陣列 // 存合併後結果\n→ Step 10: While i <= mid and j <= right\n    → Decision: 左半 arr[i].value <= 右半 arr[j].value?\n        Yes →\n            → Step 11: temp[k] = arr[i]\n            → Step 12: counts[arr[i].index] += j - (mid+1) // 已經放右邊小於它的元素數\n            → Step 13: i++ // 左指標往右\n        No →\n            → Step 14: temp[k] = arr[j]\n            → Step 15: j++ // 右指標往右\n    → Step 16: k++\n→ Step 17: While i <= mid\n    → Step 18: temp[k] = arr[i]\n    → Step 19: counts[arr[i].index] += j - (mid+1)\n    → Step 20: i++; k++\n→ Step 18b: While j <= right\n    → Step 21: temp[k] = arr[j]\n    → Step 22: j++; k++\n→ Step 23: Copy temp back to arr[left:right+1]\n    // For idx from 0 to temp.length-1\n        → Step 24: arr[left+idx] = temp[idx]\n→ End // 返回 arr\n\nNeed to follow output format: each line should be \"虛擬碼步驟 // 解釋\" with arrow etc. Use \"Start\", \"End\", \"Decision:\" lines. The pseudocode for MergeSort function can be nested inside but each line still separate.\n\nWe must produce step by step lines: 1: Start. 2: → Step 1: ... . Need to maintain arrow for steps within function as well. Use nested indentation? Not required, but we can indent inside the function by adding spaces or using a different arrow style? The example shows arrow at beginning of each line after Start. Use \"→\" before each step. For decision lines use \"Decision:\".\n\nFor function definition we might use \"→ Function: MergeSort(arr, left, right, counts)\"? Not necessary. We'll just include lines. But better to show.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: nums = 輸入陣列 // 取得輸入\n→ Step 2: n = length(nums) // 數組長度\n→ Step 3: counts = new array of size n, initialized to 0 // 結果存儲\n→ Step 4: arr = 空陣列 // 存放值與索引\n→ Step 5: for i in 0 to n-1\n    → Step 6: arr.append((nums[i], i)) // 建立 (值, 原始索引) 對\n→ Step 7: MergeSort(arr, 0, n-1, counts) // 分治排序同時計算\n→ Step 8: return counts // 回傳結果\nEnd // 程式結束\n\nMergeSort(arr, left, right, counts)\n→ Decision: 如果 left >= right? // 子陣列只剩一個元素\n    Yes → Return arr // 直接返回\n→ Step 9: mid = (left + right) / 2 // 計算中點\n→ Step 10: leftSorted = MergeSort(arr, left, mid, counts) // 左半排序\n→ Step 11: rightSorted = MergeSort(arr, mid+1, right, counts) // 右半排序\n→ Step 12: i = left // 左半起點\n→ Step 13: j = mid + 1 // 右半起點\n→ Step 14: k = 0 // 合併結果索引\n→ Step 15: temp = 空陣列 // 用於合併\n→ Decision: 如果 i <= mid 且 j <= right? // 同時還有元素\n    Yes →\n        → Decision: 如果 arr[i].value <= arr[j].value? // 左小於等於右\n            Yes →\n                → Step 16: temp[k] = arr[i] // 取左\n                → Step 17: counts[arr[i].index] += j - (mid + 1) // 計算右邊已放入的比左小的數\n                → Step 18: i++ // 左指標前進\n            No →\n                → Step 19: temp[k] = arr[j] // 取右\n                → Step 20: j++ // 右指標前進\n        → Step 21: k++ // 合併索引前進\n    No →\n        → Decision: 如果 i <= mid? // 只剩左半\n            Yes →\n                → Step 22: temp[k] = arr[i] // 取左\n                → Step 23: counts[arr[i].index] += j - (mid + 1) // 右邊已放入的比左小的數\n                → Step 24: i++ // 左指標前進\n                → Step 25: k++\n            No →\n                → Decision: 如果 j <= right? // 只剩右半\n                    Yes →\n                        → Step 26: temp[k] = arr[j] // 取右\n                        → Step 27: j++ // 右指標前進\n                        → Step 28: k++\n                    No →\n                        → End // 合併完成\n→ Step 29: for idx in 0 to length(temp)-1\n    → Step 30: arr[left + idx] = temp[idx] // 把合併結果拷貝回原陣列\n→ End // MergeSort 返回\n\nBut the above may be too nested. Need to keep formatting simple.\n\nAlternatively, produce pseudocode using simpler logic: while i <= mid and j <= right loop, after loop, copy remains. Provide count updates inside loops.\n\nLet's restructure:\n\nStart\n→ Step 1: nums = 輸入陣列\n→ Step 2: n = length(nums)\n→ Step 3: counts = new int[n] initialized to 0\n→ Step 4: create arr = list of (value, index) pairs\n→ Step 5: for i from 0 to n-1: arr[i] = (nums[i], i)\n→ Step 6: call MergeSort(arr, 0, n-1, counts)\n→ Step 7: return counts\nEnd\n\nMergeSort(arr, left, right, counts)\n→ Decision: 如果 left >= right? // 基本情況\n    Yes → Return arr\n→ Step 8: mid = (left + right) / 2\n→ Step 9: MergeSort(arr, left, mid, counts)\n→ Step 10: MergeSort(arr, mid+1, right, counts)\n→ Step 11: i = left; j = mid + 1; temp = empty list\n→ Decision: 如果 i <= mid 且 j <= right?\n    Yes →\n        → Decision: arr[i].value <= arr[j].value?\n            Yes →\n                → Step 12: temp.append(arr[i])\n                → Step 13: counts[arr[i].index] += j - (mid + 1)\n                → Step 14: i++\n            No →\n                → Step 15: temp.append(arr[j])\n                → Step 16: j++\n    No →\n        → Decision: i <= mid?\n            Yes →\n                → Step 17: temp.append(arr[i])\n                → Step 18: counts[arr[i].index] += j - (mid + 1)\n                → Step 19: i++\n            No →\n                → Step 20: temp.append(arr[j])\n                → Step 21: j++\n→ Step 22: copy temp back to arr[left:right+1]\n→ End\n\nBut this still needs loops. Let's include loop lines.\n\nBetter produce pseudocode with clear loops:\n\nMergeSort(arr, left, right, counts)\n→ Decision: left >= right? \n    Yes → Return\n→ Step 8: mid = (left + right) / 2\n→ Step 9: MergeSort(arr, left, mid, counts)\n→ Step 10: MergeSort(arr, mid+1, right, counts)\n→ Step 11: i = left; j = mid + 1; k = 0; temp = array of size (right-left+1)\n→ While i <= mid and j <= right\n    → Decision: arr[i].value <= arr[j].value?\n        Yes →\n            → Step 12: temp[k] = arr[i]\n            → Step 13: counts[arr[i].index] += j - (mid + 1)\n            → Step 14: i++; k++\n        No →\n            → Step 15: temp[k] = arr[j]\n            → Step 16: j++; k++\n→ While i <= mid\n    → Step 17: temp[k] = arr[i]\n    → Step 18: counts[arr[i].index] += j - (mid + 1)\n    → Step 19: i++; k++\n→ While j <= right\n    → Step 20: temp[k] = arr[j]\n    → Step 21: j++; k++\n→ For idx from 0 to k-1\n    → Step 22: arr[left + idx] = temp[idx]\n→ End\n\nWe need to adhere to format: Each line has arrow before step. The \"While\" loops need arrow too. The \"Decision:\" lines inside loops also need arrow.\n\nLet's produce final answer with clear indentation. Use \"→\" before each step. Decision lines include \"Decision:\" and arrow.\n\nWe also need to show the function signature? The example uses \"Step 1:\" etc. We'll use \"Step X:\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: nums = 輸入陣列 // 取得使用者輸入\n→ Step 2: n = length(nums) // 取得陣列長度\n→ Step 3: counts = new int[n] // 初始化計數結果\n→ Step 4: arr = 空陣列 // 用於存放 (值, 索引) 對\n→ Step 5: for i in 0 to n-1\n    → Step 6: arr.append((nums[i], i)) // 建立對應關係\n→ Step 7: MergeSort(arr, 0, n-1, counts) // 分治排序並計算\n→ Step 8: return counts // 回傳答案\nEnd // 程式執行結束\n\nMergeSort(arr, left, right, counts)\n→ Decision: if left >= right? // 基本情況\n    Yes → Return // 子陣列只有一個元素\n→ Step 9: mid = (left + right) / 2 // 計算中點\n→ Step 10: MergeSort(arr, left, mid, counts) // 排序左半\n→ Step 11: MergeSort(arr, mid+1, right, counts) // 排序右半\n→ Step 12: i = left // 左半指標\n→ Step 13: j = mid + 1 // 右半指標\n→ Step 14: k = 0 // 合併結果索引\n→ Step 15: temp = 空陣列 // 用於暫存合併後的順序\n→ While i <= mid and j <= right\n    → Decision: if arr[i].value <= arr[j].value? // 左邊小於等於右邊\n        Yes →\n            → Step 16: temp[k] = arr[i] // 放左邊元素\n            → Step 17: counts[arr[i].index] += j - (mid + 1) // 計算右邊已放入且比左邊小的數\n            → Step 18: i++; k++ // 進一步左指標\n        No →\n            → Step 19: temp[k] = arr[j] // 放右邊元素\n            → Step 20: j++; k++ // 進一步右指標\n→ While i <= mid\n    → Step 21: temp[k] = arr[i] // 左半剩餘\n    → Step 22: counts[arr[i].index] += j - (mid + 1) // 計算右半已放入的數\n    → Step 23: i++; k++ // 進一步左指標\n→ While j <= right\n    → Step 24: temp[k] = arr[j] // 右半剩餘\n    → Step 25: j++; k++ // 進一步右指標\n→ For idx in 0 to k-1\n    → Step 26: arr[left + idx] = temp[idx] // 把合併結果拷回原陣列\n→ End // MergeSort 完成\n\nLet's ensure each line ends with // 解釋. Good. The loops lines must include arrow. Provide \"While\" as a step with arrow. For while loops, include \"While\" with arrow. Indent substeps inside loops? In the example, indent inside decisions by spaces; but we can simply write new lines with arrow and indent for readability. The requirement says \"逐行輸出\" each line must contain code step and explanation. So we can just list lines sequentially, not nested indentation; but indentation helps readability. We'll just produce each line.\n\nMake sure each line uses \"→\" at start. Provide explanation. Ensure there is a line for \"Return\" in MergeSort.\n\nBut in the example, for a function, they did \"→ Decision:\" inside. So we should do \"→ Decision: if left >= right?\".\n\nOk final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: nums = 輸入陣列 // 取得使用者輸入  \n→ Step 2: n = length(nums) // 取得陣列長度  \n→ Step 3: counts = new int[n] // 初始化計數結果  \n→ Step 4: arr = 空陣列 // 用於存放 (值, 索引) 對  \n→ Step 5: for i in 0 to n-1  \n  → Step 6: arr.append((nums[i], i)) // 建立 (值, 索引) 對  \n→ Step 7: MergeSort(arr, 0, n-1, counts) // 分治排序並計算  \n→ Step 8: return counts // 回傳答案  \nEnd // 程式執行結束  \n\nMergeSort(arr, left, right, counts)  \n→ Decision: if left >= right? // 基本情況，子陣列只有一個元素  \n  Yes → Return // 直接返回  \n→ Step 9: mid = (left + right) / 2 // 計算中點  \n→ Step 10: MergeSort(arr, left, mid, counts) // 排序左半  \n→ Step 11: MergeSort(arr, mid+1, right, counts) // 排序右半  \n→ Step 12: i = left // 左半指標  \n→ Step 13: j = mid + 1 // 右半指標  \n→ Step 14: k = 0 // 合併結果索引  \n→ Step 15: temp = 空陣列 // 用於暫存合併後的順序  \n→ While i <= mid and j <= right  \n  → Decision: if arr[i].value <= arr[j].value? // 左邊小於等於右邊  \n   Yes →  \n     → Step 16: temp[k] = arr[i] // 放左邊元素  \n     → Step 17: counts[arr[i].index] += j - (mid + 1) // 計算右邊已放入且比左邊小的數  \n     → Step 18: i++; k++ // 進一步左指標  \n   No →  \n     → Step 19: temp[k] = arr[j] // 放右邊元素  \n     → Step 20: j++; k++ // 進一步右指標  \n→ While i <= mid  \n  → Step 21: temp[k] = arr[i] // 左半剩餘  \n  → Step 22: counts[arr[i].index] += j - (mid + 1) // 計算右半已放入的數  \n  → Step 23: i++; k++ // 進一步左指標  \n→ While j <= right  \n  → Step 24: temp[k] = arr[j] // 右半剩餘  \n  → Step 25: j++; k++ // 進一步右指標  \n→ For idx in 0 to k-1  \n  → Step 26: arr[left + idx] = temp[idx] // 把合併結果拷回原陣列  \n→ End // MergeSort 完成"
    },
    {
      "title": "Implement Rand10() Using Rand7()",
      "source_file": "Leetcode/leetcode470.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "n = 1",
          "expected_output": "[2]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpodhk9l08.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpodhk9l08.py\", line 51, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmpodhk9l08.py\", line 28, in rand10\n    a = rand7()\n        ^^^^^^^\n  File \"/tmp/tmpodhk9l08.py\", line 15, in rand7\n    raise NotImplementedError(\"rand7() is not implemented in this environment.\")\nNotImplementedError: rand7() is not implemented in this environment."
        },
        {
          "example_index": 1,
          "input": "n = 2",
          "expected_output": "[2,8]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpgoc37ld_.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpgoc37ld_.py\", line 51, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmpgoc37ld_.py\", line 28, in rand10\n    a = rand7()\n        ^^^^^^^\n  File \"/tmp/tmpgoc37ld_.py\", line 15, in rand7\n    raise NotImplementedError(\"rand7() is not implemented in this environment.\")\nNotImplementedError: rand7() is not implemented in this environment."
        },
        {
          "example_index": 2,
          "input": "n = 3",
          "expected_output": "[3,8,10]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpp8m48_e_.py\", line 56, in <module>\n    main()\n  File \"/tmp/tmpp8m48_e_.py\", line 51, in main\n    results = [rand10() for _ in range(n)]\n               ^^^^^^^^\n  File \"/tmp/tmpp8m48_e_.py\", line 28, in rand10\n    a = rand7()\n        ^^^^^^^\n  File \"/tmp/tmpp8m48_e_.py\", line 15, in rand7\n    raise NotImplementedError(\"rand7() is not implemented in this environment.\")\nNotImplementedError: rand7() is not implemented in this environment."
        }
      ],
      "generated_code": "import sys\nimport re\n\n# ----------------------------------\n# 假設 rand7() 已由外部提供，以下為占位實作\n# 若在本地測試，請自行用隨機產生器實作\n# ----------------------------------\ndef rand7():\n    \"\"\"\n    這個函式應由題目提供，返回 1~7 的均勻隨機整數。\n    若自行測試，請用以下方式改寫：\n        import random\n        return random.randint(1, 7)\n    \"\"\"\n    raise NotImplementedError(\"rand7() is not implemented in this environment.\")\n\n\n# ----------------------------------\n# 生成 1~10 的均勻隨機整數\n# ----------------------------------\ndef rand10():\n    \"\"\"\n    透過兩次 rand7() 呼叫產生 1~49 的均勻分布。\n    只接受前 40 個結果，映射到 1~10，其他結果重新嘗試。\n    \"\"\"\n    while True:\n        # 兩次呼叫得到兩個 1~7 的隨機數\n        a = rand7()\n        b = rand7()\n        # 合併為 1~49 的唯一值\n        x = (a - 1) * 7 + b\n        # 只使用 1~40 的值\n        if x <= 40:\n            return 1 + (x - 1) % 10\n\n\n# ----------------------------------\n# 主程式\n# ----------------------------------\ndef main():\n    \"\"\"\n    讀取 stdin，例如 'n = 3'，產生 n 次 rand10() 的結果並輸出\n    \"\"\"\n    line = sys.stdin.readline()\n    if not line:\n        return\n    # 從輸入中擷取數字\n    m = re.search(r'\\d+', line)\n    n = int(m.group()) if m else 0\n\n    results = [rand10() for _ in range(n)]\n    print(results)\n\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code, step by step, explaining each line. We must follow format: each line \"虛擬碼步驟 // 解釋/說明\". Use arrow syntax. We need to design algorithm to generate uniform random 1-10 using rand7. Classic approach: use two calls to get 49 outcomes. Accept values 1-40. Map to 1-10 via modulo or mapping. Or use rejection sampling. So algorithm: repeat: r1=rand7(); r2=rand7(); x = (r1-1)*7 + r2; // 1-49. If x <= 40 then return ((x-1)%10)+1 else repeat.\n\nVirtual code: Start, Decision loops. We'll produce a virtual pseudocode accordingly.\n\nEnsure use of arrow → and Decision: syntax. Provide brief explanation each line.\n\nLet's craft lines:\n\nStart // 開始\n\n→ Step 1: 重複執行以下區塊直到成功 // 進行重複嘗試\n\n→ Step 1.1: 取得 rand7() 的兩個隨機數值 // 兩次呼叫獲得兩個 1-7 的數字\n\n→ Step 1.2: 計算 x = (a-1)*7 + b // 將兩個數字合併為 1-49 的唯一值\n\n→ Decision: x 是否 ≤ 40? // 只接受前 40 個結果\n\n    Yes → Step 1.3: 回傳 ((x-1) mod 10) + 1 // 轉換為 1-10\n\n    No  → Step 1.4: 返回到重複開始 // 重新嘗試\n\nEnd // 結束\n\nBut need to use correct format: Use arrows. Possibly indent decisions. Provide each line. Use \"Decision:\" only once for the condition. Use Yes/No branches. Ensure each line includes \"虛擬碼步驟 // 解釋\".\n\nLet's produce.\n\nAlso include variable names maybe a,b,x. Use \"a = rand7()\", etc.\n\nLet's craft final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Decision: 需要生成 1-10? // 判斷是否開始生成  \n    Yes → Step 1: 重複以下步驟直到成功 // 進行重複嘗試  \n        → Step 1.1: a ← rand7() // 呼叫 rand7() 取得第一個隨機數  \n        → Step 1.2: b ← rand7() // 再次呼叫 rand7() 取得第二個隨機數  \n        → Step 1.3: x ← (a - 1) * 7 + b // 把兩個 1-7 數字轉換成 1-49 的唯一值  \n        → Decision: x ≤ 40? // 只接受前 40 個結果，保證均勻性  \n            Yes → Step 1.4: return ((x - 1) mod 10) + 1 // 轉換為 1-10 的隨機數  \n            No  → Step 1.5: 返回到 Step 1.1 重新嘗試 // 超過 40 時重新呼叫  \nEnd // 程式執行結束"
    },
    {
      "title": "Range Sum Query - Mutable",
      "source_file": "Leetcode/leetcode307.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"], [[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]",
          "expected_output": "[null, 9, null, 8]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,9,null,8]'\nGot (Norm):      '[None,9,None,8]'\n--- (Raw) ---\nRaw Expected: '[null, 9, null, 8]'\nRaw Got:      '[None, 9, None, 8]'"
        }
      ],
      "generated_code": "import sys\nimport json\n\nclass NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.nums = nums[:]          # 原始數組副本\n        self.tree = [0] * (self.n + 1)\n        for i in range(self.n):\n            self._update_tree(i + 1, nums[i])\n\n    def _update_tree(self, i, val):\n        while i <= self.n:\n            self.tree[i] += val\n            i += i & -i\n\n    def update(self, index, val):\n        diff = val - self.nums[index]\n        self.nums[index] = val\n        self._update_tree(index + 1, diff)\n\n    def sumRange(self, left, right):\n        return self._query(right + 1) - self._query(left)\n\n    def _query(self, i):\n        res = 0\n        while i > 0:\n            res += self.tree[i]\n            i -= i & -i\n        return res\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    # 將輸入包裝成合法 JSON，並解析成兩個列表\n    commands, arguments = json.loads('[' + data + ']')\n    res = []\n    obj = None\n    for cmd, arg in zip(commands, arguments):\n        if cmd == 'NumArray':\n            obj = NumArray(arg[0])\n            res.append(None)\n        elif cmd == 'update':\n            obj.update(arg[0], arg[1])\n            res.append(None)\n        elif cmd == 'sumRange':\n            res.append(obj.sumRange(arg[0], arg[1]))\n    print(res)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce a step-by-step virtual code for implementing a NumArray class that supports update and range sum queries. Use virtual code format with arrows, decisions. Should be clear. No actual code, just pseudocode steps. Provide explanation after //.\n\nWe need to structure: Start, Step: initialize BIT or segment tree. Use tree. Provide operations: update, sumRange.\n\nLet's produce virtual steps:\n\nStart\n→ Step 1: 建立樹結構 (Segment Tree 或 Binary Indexed Tree) 並把 nums 存入 // 初始化數據結構\n→ Step 2: 定義 Update 函式 // 更新單一元素\n→ Decision: 是否使用 Segment Tree 或 BIT? // 取決於實作偏好\nIf Segment Tree:\n    → Step 3: SegmentTree.Update(index, val) // 更新樹節點\nElse BIT:\n    → Step 3: BIT.Update(index, delta) // delta = val - oldVal\n→ Step 4: 定義 SumRange 函式 // 計算區間和\n→ Decision: 是否使用 Segment Tree 或 BIT?\nIf Segment Tree:\n    → Step 5: SegmentTree.Query(left, right) // 返回區間和\nElse BIT:\n    → Step 6: return BIT.Query(right) - BIT.Query(left-1)\n→ End\n\nBut we need to produce each line with virtual code and explanation. Use arrows properly.\n\nLet's structure as:\n\nStart\n→ Step 1: 建立 NumArray 類別並將 nums 存入 // 進入建構子\n    → Decision: 是否使用 Segment Tree? // 決定底層資料結構\n        Yes → Step 2a: 建立 Segment Tree，將 nums 逐一加入 // 構建樹\n        No  → Step 2b: 建立 Binary Indexed Tree，將 nums 累加進去 // 構建 BIT\n→ Step 3: 定義 update(index, val) 方法 // 更新元素\n    → Decision: 是否使用 Segment Tree?\n        Yes → Step 3a: SegmentTree.Update(index, val) // 更新樹\n        No  → Step 3b: delta = val - currentValue(index); BIT.Update(index, delta) // 更新 BIT\n→ Step 4: 定義 sumRange(left, right) 方法 // 查詢區間和\n    → Decision: 是否使用 Segment Tree?\n        Yes → Step 4a: return SegmentTree.Query(left, right) // 回傳和\n        No  → Step 4b: return BIT.Query(right) - BIT.Query(left-1) // 計算前綴和差\nEnd\n\nWe also might include a decision on updating currentValue for BIT.\n\nNeed to ensure each line includes arrow with appropriate indentation. Use \"→\" arrow for each step. For decision branches use \"Decision:\" line then \"Yes →\" and \"No →\" lines indented.\n\nMake sure to include explanation after //.\n\nLet's craft final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 建立 NumArray 類別並把 nums 存入 // 進入建構子  \n → Decision: 使用 Segment Tree 或 Binary Indexed Tree? // 決定底層資料結構  \n  Yes → Step 2a: 建立 Segment Tree，將 nums 逐一加入 // 構建樹，初始化區間和  \n  No  → Step 2b: 建立 Binary Indexed Tree，將 nums 累加進去 // 構建 BIT，建立前綴和結構  \n→ Step 3: 定義 update(index, val) 方法 // 更新單一元素  \n → Decision: 使用 Segment Tree? // 根據建構子決定  \n  Yes → Step 3a: SegmentTree.Update(index, val) // 更新節點並維護區間和  \n  No  → Step 3b: delta ← val - currentValue(index); BIT.Update(index, delta) // 先計算變化值再更新 BIT  \n→ Step 4: 定義 sumRange(left, right) 方法 // 查詢區間和  \n → Decision: 使用 Segment Tree? // 根據建構子決定  \n  Yes → Step 4a: return SegmentTree.Query(left, right) // 直接取得區間和  \n  No  → Step 4b: return BIT.Query(right) - BIT.Query(left-1) // 用前綴和差值計算區間和  \nEnd // 程式執行結束"
    },
    {
      "title": "Wiggle Sort II",
      "source_file": "Leetcode/leetcode324.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,5,1,1,6,4]",
          "expected_output": "[1,6,1,5,1,4]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[1,6,1,5,1,4]'\nGot (Norm):      '[1,5,1,6,1,4]'\n--- (Raw) ---\nRaw Expected: '[1,6,1,5,1,4]'\nRaw Got:      '[1, 5, 1, 6, 1, 4]'"
        },
        {
          "example_index": 1,
          "input": "nums = [1,3,2,2,3,1]",
          "expected_output": "[2,3,1,3,1,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[2,3,1,3,1,2]'\nGot (Norm):      '[1,3,2,3,1,2]'\n--- (Raw) ---\nRaw Expected: '[2,3,1,3,1,2]'\nRaw Got:      '[1, 3, 2, 3, 1, 2]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\nclass Solution:\n    def wiggleSort(self, nums):\n        \"\"\"\n        Rearrange nums so that nums[0] < nums[1] > nums[2] < nums[3] ...\n        The algorithm scans the array once, swapping adjacent elements\n        whenever the wiggle condition is violated.\n        \"\"\"\n        n = len(nums)\n        for i in range(1, n):\n            # If i is odd, we want nums[i] > nums[i-1]\n            if i % 2 == 1:\n                if nums[i] <= nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n            # If i is even, we want nums[i] < nums[i-1]\n            else:\n                if nums[i] >= nums[i - 1]:\n                    nums[i], nums[i - 1] = nums[i - 1], nums[i]\n\ndef parse_input(data: str):\n    \"\"\"\n    Parse input that may contain a variable assignment like 'nums = [1,2,3]'.\n    Returns the list of integers.\n    \"\"\"\n    data = data.strip()\n    if not data:\n        return []\n    # Split at the first '=' if present\n    if '=' in data:\n        _, expr = data.split('=', 1)\n    else:\n        expr = data\n    expr = expr.strip()\n    return ast.literal_eval(expr)\n\ndef main():\n    input_data = sys.stdin.read()\n    nums = parse_input(input_data)\n    Solution().wiggleSort(nums)\n    print(nums)\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps for algorithm that reorders array into wiggle pattern: nums[0] < nums[1] > nums[2] < nums[3] ...\n\nGiven assumption always valid answer. Standard solution: sort array then place smallest to odd indices? Actually wiggle sort can be done by iterating and swapping. Approach: for i from 1 to len-1, if (i%2==1 and nums[i] <= nums[i-1]) or (i%2==0 and nums[i] >= nums[i-1]) swap.\n\nLet's produce steps.\n\nWe need start, decision, etc.\n\nSteps:\n\nStart // start program\n→ Step 1: Input array nums // get array\n→ Step 2: For i from 1 to nums.length-1 // iterate\n    → Decision: i is odd? // determine parity\n        Yes → Decision: nums[i] <= nums[i-1]? // if current <= previous\n            Yes → Step 3a: Swap nums[i] and nums[i-1] // swap to satisfy < > pattern\n            No → No action\n        No → Decision: nums[i] >= nums[i-1]? // if even index, should be <\n            Yes → Step 3b: Swap nums[i] and nums[i-1] // swap to satisfy > < pattern\n            No → No action\n→ End // finished\n\nWe should add explanation comments after each line.\n\nMake sure each line ends with // explanation.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 讀取整數陣列 nums // 從使用者或資料來源取得整數陣列  \n→ Step 2: 從 i = 1 到 nums.length-1 逐一檢查每個位置 // 以 i 為索引遍歷陣列  \n  → Decision: i 為奇數? // 判斷目前索引是否為奇數  \n   Yes → Decision: nums[i] ≤ nums[i-1]? // 奇數位置應為 “>”，若不符合則需交換  \n    Yes → Step 3a: 交換 nums[i] 與 nums[i-1] // 交換使 nums[i-1] < nums[i] 成立  \n    No → No action // 已符合條件，無需更動  \n   No  → Decision: nums[i] ≥ nums[i-1]? // 偶數位置應為 “<”，若不符合則需交換  \n    Yes → Step 3b: 交換 nums[i] 與 nums[i-1] // 交換使 nums[i-1] > nums[i] 成立  \n    No → No action // 已符合條件，無需更動  \n→ End // 程式執行結束，陣列已重排為 wiggle sequence"
    },
    {
      "title": "Evaluate Division",
      "source_file": "Leetcode/leetcode399.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]",
          "expected_output": "[6.00000,0.50000,-1.00000,1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpb4pe0cez.py\", line 45, in <module>\n    solve()\n  File \"/tmp/tmpb4pe0cez.py\", line 11, in solve\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 1,
          "input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]",
          "expected_output": "[3.75000,0.40000,5.00000,0.20000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpr9bb6l79.py\", line 45, in <module>\n    solve()\n  File \"/tmp/tmpr9bb6l79.py\", line 11, in solve\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        },
        {
          "example_index": 2,
          "input": "equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]",
          "expected_output": "[0.50000,2.00000,-1.00000,-1.00000]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpzegl1sz6.py\", line 45, in <module>\n    solve()\n  File \"/tmp/tmpzegl1sz6.py\", line 11, in solve\n    exec(data, {}, local_vars)\n  File \"<string>\", line 1\n    equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\n    ^^^^^^^^^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?"
        }
      ],
      "generated_code": "import sys\nfrom collections import defaultdict\n\ndef solve() -> None:\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    local_vars = {}\n    # 执行输入代码，得到 equations、values、queries\n    exec(data, {}, local_vars)\n\n    equations = local_vars.get('equations', [])\n    values = local_vars.get('values', [])\n    queries = local_vars.get('queries', [])\n\n    # 建立图\n    graph = defaultdict(dict)\n    for (a, b), val in zip(equations, values):\n        graph[a][b] = val\n        graph[b][a] = 1.0 / val\n\n    # 深度优先搜索求解\n    def dfs(src: str, dst: str, visited: set) -> float:\n        if src not in graph or dst not in graph:\n            return -1.0\n        if src == dst:\n            return 1.0\n        visited.add(src)\n        for neighbor, weight in graph[src].items():\n            if neighbor not in visited:\n                res = dfs(neighbor, dst, visited)\n                if res != -1.0:\n                    return weight * res\n        return -1.0\n\n    results = []\n    for u, v in queries:\n        results.append(dfs(u, v, set()))\n\n    # 输出结果，保留五位小数\n    print('[' + ','.join(f'{x:.5f}' for x in results) + ']')\n\nif __name__ == \"__main__\":\n    solve()",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps with explanations. For the problem: compute division queries from equations. Standard approach: build graph of variables with edges weight = ratio, then use DFS/BFS to compute ratio for query, return -1 if unreachable. Steps: Build graph, for each query, if start and end exist, run DFS to compute product ratio else -1. Use map<string, vector<pair<string,double>>> adjacency. Use visited set. Implementation pseudocode.\n\nNeed to produce line by line. Each line: \"虛擬碼步驟 // 解釋\". Use arrow etc. Let's craft.\n\nLet's create steps:\n\nStart\n→ Step 1: 建立圖 adjacency list // 存放每個變量的鄰接節點與比值\n→ For each equation Ai / Bi = val: \n    → Add edge Ai → Bi weight val\n    → Add edge Bi → Ai weight 1/val\n\n→ Step 2: 定義計算函式 DFS(current, target, acc, visited) // 深度優先搜索累乘比值\n    → If current == target: return acc // 找到路徑\n    → Mark current visited\n    → For each neighbor (next, weight):\n        → If next 未被訪問:\n            → Result = DFS(next, target, acc * weight, visited)\n            → If result ≠ -1: return result\n    → Return -1 // 無路徑\n\n→ Step 3: 建立答案陣列 result\n→ For each query [C,D]:\n    → If C 或 D 不在 graph: → result.append(-1)\n    → Else: → ans = DFS(C, D, 1, empty set)\n    → result.append(ans)\n\n→ End\n\nBut we need per-line representation with decision. Provide decisions for existence etc.\n\nLet's craft step-by-step.\n\nWe'll produce lines:\n\nStart // 程式開始\n→ Step 1: 建立 adjacency map for all variables // 以字典形式儲存變量與鄰接節點及比值\n    → For each equation index i:\n        → Ai = equations[i][0]; Bi = equations[i][1]; val = values[i]\n        → Add Ai → Bi weight val // Ai / Bi = val\n        → Add Bi → Ai weight 1/val // Bi / Ai = 1/val\n→ Step 2: 定義 DFS 函式 (current, target, acc, visited) // 用於尋找從 current 到 target 的累乘比值\n    → Decision: current 等於 target? // 判斷是否已到達目標\n        Yes → Return acc // 取得累積比值\n        No  → Mark current 為已訪問 // 避免循環\n            → For each neighbor (next, weight) in graph[current]:\n                → Decision: next 未訪問? // 是否還未走過\n                    Yes → Recursively call DFS(next, target, acc * weight, visited)\n                        → Decision: result ≠ -1? // 是否找到路徑\n                            Yes → Return result\n                            No  → 繼續搜尋\n            → Return -1 // 無法到達目標\n→ Step 3: 初始化結果列表 results // 存放所有查詢答案\n→ For each query index j:\n    → C = queries[j][0]; D = queries[j][1]\n    → Decision: C 或 D 不在 graph? // 若未定義\n        Yes → results.append(-1.0) // 無法計算\n        No  → Call DFS(C, D, 1.0, empty set) 并將結果加入 results\n→ End // 程式結束\n\nBut we need to match format: \"虛擬碼步驟 // 解釋\". Each line separate. Use arrows? We can embed arrow as \"→\".\n\nLet's produce final output.\n...done thinking.\n\n```\nStart // 程式開始\n→ Step 1: 建立 adjacency map // 以字典形式儲存變量與鄰接節點及比值\n    → For each equation i:\n        → Ai = equations[i][0]; Bi = equations[i][1]; val = values[i]\n        → Add edge Ai → Bi with weight val // Ai / Bi = val\n        → Add edge Bi → Ai with weight 1/val // Bi / Ai = 1/val\n→ Step 2: 定義 DFS 函式 (current, target, acc, visited) // 用於尋找從 current 到 target 的累乘比值\n    → Decision: current == target? // 判斷是否已到達目標\n        Yes → Return acc // 取得累積比值\n        No  → Mark current 為已訪問 // 避免循環\n            → For each neighbor (next, weight) in graph[current]:\n                → Decision: next 未訪問? // 是否還未走過\n                    Yes → Result = DFS(next, target, acc * weight, visited)\n                        → Decision: Result ≠ -1? // 是否找到路徑\n                            Yes → Return Result\n                            No  → 繼續搜尋\n            → Return -1 // 無法到達目標\n→ Step 3: 初始化結果列表 results // 存放所有查詢答案\n→ For each query j:\n    → C = queries[j][0]; D = queries[j][1]\n    → Decision: C 或 D 不在 graph? // 若未定義\n        Yes → results.append(-1.0) // 無法計算\n        No  → ans = DFS(C, D, 1.0, empty set) // 以 DFS 計算比值\n            → results.append(ans)\nEnd // 程式結束\n```"
    },
    {
      "title": "Implement Stack using Queues",
      "source_file": "Leetcode/leetcode225.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"], [[], [1], [2], [], [], []]",
          "expected_output": "[null, null, null, 2, 2, false]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpvc4rtxr0.py\", line 83, in <module>\n    main()\n  File \"/tmp/tmpvc4rtxr0.py\", line 65, in main\n    ops, args = parse_input(raw_input)\n                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpvc4rtxr0.py\", line 60, in parse_input\n    args = ast.literal_eval(second_list_str)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 66, in literal_eval\n    node_or_string = parse(node_or_string.lstrip(\" \\t\"), mode='eval')\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/lib/python3.12/ast.py\", line 52, in parse\n    return compile(source, filename, mode, flags,\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<unknown>\", line 1\n    [[]\n    ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nimport json\nimport ast\nfrom collections import deque\n\nclass MyStack:\n    \"\"\"Stack implemented with two queues (deque).\"\"\"\n    def __init__(self):\n        self.q1 = deque()  # 主佇列\n        self.q2 = deque()  # 幫助佇列\n\n    def push(self, x):\n        \"\"\"把元素壓入堆疊頂部。\"\"\"\n        self.q1.append(x)\n\n    def pop(self):\n        \"\"\"移除並回傳堆疊頂部元素。\"\"\"\n        if not self.q1:\n            return None\n        # 將除最後一個外的所有元素搬到 q2\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()  # 最後一個即為頂部\n        # 交換兩個佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def top(self):\n        \"\"\"取得堆疊頂部元素但不移除。\"\"\"\n        if not self.q1:\n            return None\n        while len(self.q1) > 1:\n            self.q2.append(self.q1.popleft())\n        top_val = self.q1.popleft()\n        self.q2.append(top_val)  # 再放回輔助佇列\n        self.q1, self.q2 = self.q2, self.q1\n        return top_val\n\n    def empty(self):\n        \"\"\"判斷堆疊是否為空。\"\"\"\n        return not self.q1\n\ndef parse_input(data: str):\n    \"\"\"解析 LeetCode 風格的輸入，返回 ops 與 args。\"\"\"\n    data = data.strip()\n    if data.startswith('Input '):\n        data = data[6:].strip()\n    # 找到第一個 list\n    first_start = data.find('[')\n    first_end = data.find(']', first_start)\n    first_list_str = data[first_start:first_end+1]\n    rest = data[first_end+1:].strip()\n    # 移除前導逗號\n    if rest.startswith(','):\n        rest = rest[1:].strip()\n    second_start = rest.find('[')\n    second_end = rest.find(']', second_start)\n    second_list_str = rest[second_start:second_end+1]\n    ops = ast.literal_eval(first_list_str)\n    args = ast.literal_eval(second_list_str)\n    return ops, args\n\ndef main():\n    raw_input = sys.stdin.read()\n    ops, args = parse_input(raw_input)\n    stack = MyStack()\n    results = []\n    for op, arg in zip(ops, args):\n        if op == 'MyStack':\n            results.append(None)\n        elif op == 'push':\n            stack.push(arg[0])\n            results.append(None)\n        elif op == 'pop':\n            results.append(stack.pop())\n        elif op == 'top':\n            results.append(stack.top())\n        elif op == 'empty':\n            results.append(stack.empty())\n    print(json.dumps(results))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to output step-by-step virtual code. The requirement: \"Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\"\n\nWe need to produce virtual code in lines with arrows, decisions, etc.\n\nWe should design algorithm: Use two queues, q1 and q2. For push: enqueue into q1. For pop: move all but last element from q1 to q2, pop last element (top). Then swap q1 and q2. For top: same as pop but after retrieving, re-queue the popped element into q2. For empty: q1.isEmpty.\n\nAlternate: maintain only one queue with reordering. But they said two queues. So we use two.\n\nWe'll produce pseudocode structure.\n\nWe should produce each step line with explanation comment.\n\nWe should include Start, End. We also need to implement methods: push, pop, top, empty. The virtual code should reflect entire class and methods.\n\nWe need to output line by line.\n\nWe can start with \"Start // 程式開始執行\".\n\nThen define class MyStack: but we should use pseudo code for class and methods. Provide initialization: q1, q2 empty.\n\nThen methods: push, pop, top, empty.\n\nWe'll use decision structures for operations.\n\nLet's craft:\n\nStart // 程式開始執行\n→ Step 1: Define class MyStack // 建立堆疊類別\n→ Step 2: Initialize q1 as empty queue // 主佇列\n→ Step 3: Initialize q2 as empty queue // 幫助佇列\n→ Decision: // 函式定義區\n    → Step 4: Define push(x) // 壓入元素\n        → q1.enqueue(x) // 只用佇列後插\n        → End\n    → Step 5: Define pop() // 取出頂部\n        → Decision: q1.isEmpty? // 檢查是否為空\n            Yes → Return null // 若空則回傳空\n            No →\n                → While q1.size > 1: // 移動除最後一個以外的元素\n                    → temp = q1.dequeue() // 從前端取\n                    → q2.enqueue(temp) // 重新排入輔助佇列\n                → topVal = q1.dequeue() // 最後一個即為頂部\n                → Swap q1 and q2 // 重新設為主佇列\n                → Return topVal // 回傳頂部\n        → End\n    → Step 6: Define top() // 查看頂部不移除\n        → Decision: q1.isEmpty?\n            Yes → Return null\n            No →\n                → While q1.size > 1:\n                    → temp = q1.dequeue()\n                    → q2.enqueue(temp)\n                → topVal = q1.dequeue()\n                → q2.enqueue(topVal) // 再放回輔助佇列\n                → Swap q1 and q2\n                → Return topVal\n        → End\n    → Step 7: Define empty() // 判斷空\n        → Return q1.isEmpty()\n        → End\nEnd // 程式結束\n\nBut we need each line to have arrow \"→\". For decisions we need indentation? Provide \"Decision: ...\" then \"Yes →\" and \"No →\". Also for loops, we can denote with \"While\".\n\nAlso we need explanation after each line.\n\nEnsure every line includes `//` comment with explanation.\n\nLet's refine.\n\nLine1: Start // 程式開始執行\n\nLine2: → Class MyStack // 定義堆疊類別\n\nBut arrow before? The example shows \"→ Step 1: 輸入使用者數字\". So we should prefix each line with \"→\". For start we can just \"Start\".\n\nBut the example had Start without arrow. Then each subsequent line begins with \"→\". So we follow.\n\nSo line1: Start // 程式開始執行\n\nLine2: → Class MyStack // 建立堆疊類別\n\nLine3: → q1 = EmptyQueue() // 主佇列，用於存放元素\n\nLine4: → q2 = EmptyQueue() // 幫助佇列，協助搬移元素\n\nThen method definitions:\n\nLine5: → Method push(x): // 壓入元素到堆疊頂部\n\nLine6: → → q1.enqueue(x) // 只用佇列後插入\n\nLine7: → End // 結束 push 方法\n\nLine8: → Method pop(): // 取出並返回堆疊頂部元素\n\nLine9: → → Decision: q1.isEmpty? // 判斷堆疊是否為空\n\nLine10: → →   Yes → Return null // 空時回傳 null（或錯誤訊息）\n\nLine11: → →   No → // 非空情況\n\nLine12: → →     While q1.size > 1: // 把除最後一個元素外全部搬到 q2\n\nLine13: → →       → temp = q1.dequeue() // 從前端取出\n\nLine14: → →       → q2.enqueue(temp) // 放入輔助佇列\n\nLine15: → →     End While\n\nLine16: → →     topVal = q1.dequeue() // 最後一個即為頂部元素\n\nLine17: → →     Swap(q1, q2) // 重新將輔助佇列設為主佇列\n\nLine18: → →     Return topVal // 回傳頂部值\n\nLine19: → End // 結束 pop 方法\n\nSimilarly for top:\n\nLine20: → Method top(): // 取得堆疊頂部元素但不移除\n\nLine21: → → Decision: q1.isEmpty? // 判斷是否為空\n\nLine22: → →   Yes → Return null\n\nLine23: → →   No →\n\nLine24: → →     While q1.size > 1:\n\nLine25: → →       → temp = q1.dequeue()\n\nLine26: → →       → q2.enqueue(temp)\n\nLine27: → →     End While\n\nLine28: → →     topVal = q1.dequeue() // 頂部元素\n\nLine29: → →     q2.enqueue(topVal) // 重新放回輔助佇列\n\nLine30: → →     Swap(q1, q2) // 重新設為主佇列\n\nLine31: → →     Return topVal\n\nLine32: → End\n\nAnd empty method:\n\nLine33: → Method empty(): // 判斷堆疊是否為空\n\nLine34: → → Return q1.isEmpty() // 若主佇列為空則堆疊為空\n\nLine35: → End\n\nEnd // 程式結束\n\nCheck each line has arrow at start? For nested, we might indent or use additional arrow. The example uses arrows and indentation. For example, \"→ Decision: 如果數字大於 0?\" then inside indentation \"Yes → Step ...\". So we should follow.\n\nThus line3: \"→ q1 = EmptyQueue() // ...\" It's fine.\n\nFor nested lines, we indent with spaces then arrow.\n\nWe'll include `→` for each line, but for nested lines we can use additional indentation, but still start with arrow? In example, they have \"→ Decision: ...\", then indent: \"Yes → Step ...\". So yes, we start with arrow but maybe no extra arrow? Let's follow.\n\nAlso we need to keep all lines sequential, each line must contain \"虛擬碼步驟\" + space + \"// 解釋/說明\".\n\nThus each line: \"Start // 程式開始執行\". Next lines: \"→ Class MyStack // 建立堆疊類別\". Ensure there is space after \"→\" before code. For nested lines: \"    Yes → Return null // 空時回傳 null\". Provide indentation.\n\nLet's write final answer accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Class MyStack // 建立堆疊類別  \n→ q1 = EmptyQueue() // 主佇列，用於存放元素  \n→ q2 = EmptyQueue() // 幫助佇列，協助搬移元素  \n\n→ Method push(x): // 壓入元素到堆疊頂部  \n → q1.enqueue(x) // 只用佇列後插入  \n→ End // 結束 push 方法  \n\n→ Method pop(): // 取出並返回堆疊頂部元素  \n → Decision: q1.isEmpty? // 判斷堆疊是否為空  \n  Yes → Return null // 空時回傳 null（或錯誤訊息）  \n  No → // 非空情況  \n   While q1.size > 1: // 把除最後一個元素外全部搬到 q2  \n    → temp = q1.dequeue() // 從前端取出  \n    → q2.enqueue(temp) // 放入輔助佇列  \n   End While  \n   topVal = q1.dequeue() // 最後一個即為頂部元素  \n   Swap(q1, q2) // 重新將輔助佇列設為主佇列  \n   Return topVal // 回傳頂部值  \n→ End // 結束 pop 方法  \n\n→ Method top(): // 取得堆疊頂部元素但不移除  \n → Decision: q1.isEmpty? // 判斷是否為空  \n  Yes → Return null // 空時回傳 null  \n  No →  \n   While q1.size > 1: // 把除最後一個元素外全部搬到 q2  \n    → temp = q1.dequeue() // 從前端取出  \n    → q2.enqueue(temp) // 放入輔助佇列  \n   End While  \n   topVal = q1.dequeue() // 頂部元素  \n   q2.enqueue(topVal) // 重新放回輔助佇列  \n   Swap(q1, q2) // 重新設為主佇列  \n   Return topVal // 回傳頂部值  \n→ End // 結束 top 方法  \n\n→ Method empty(): // 判斷堆疊是否為空  \n → Return q1.isEmpty() // 若主佇列為空則堆疊為空  \n→ End // 結束 empty 方法  \n\nEnd // 程式結束"
    },
    {
      "title": "Course Schedule II",
      "source_file": "Leetcode/leetcode210.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "[0,1]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmp266w59_u.py\", line 57, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmp266w59_u.py\", line 48, in parse_input\n    prerequisites = eval(val.strip())\n                    ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
          "expected_output": "[0,2,1,3]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmppej8k1_a.py\", line 57, in <module>\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmppej8k1_a.py\", line 48, in parse_input\n    prerequisites = eval(val.strip())\n                    ^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def findOrder(self, numCourses: int, prerequisites):\n        \"\"\"\n        使用拓扑排序（Kahn 演算法）求解課程安排順序。\n        若存在環則返回空列表。\n        \"\"\"\n        # 1. 建立圖與入度\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 2. 找出所有入度為 0 的節點，加入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        order = []\n\n        # 3. Kahn 演算法主循環\n        while queue:\n            node = queue.popleft()\n            order.append(node)\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        # 4. 判斷是否成功完成所有課程\n        return order if len(order) == numCourses else []\n\ndef parse_input(data: str):\n    \"\"\"\n    從形如 'numCourses = 2, prerequisites = [[1,0]]' 的字串中解析出\n    numCourses 與 prerequisites 兩個參數。\n    \"\"\"\n    numCourses = 0\n    prerequisites = []\n    parts = data.split(',')\n    for part in parts:\n        part = part.strip()\n        if part.startswith('numCourses'):\n            _, val = part.split('=', 1)\n            numCourses = int(val.strip())\n        elif part.startswith('prerequisites'):\n            _, val = part.split('=', 1)\n            prerequisites = eval(val.strip())\n    return numCourses, prerequisites\n\nif __name__ == \"__main__\":\n    # 讀取整個標準輸入\n    raw_input = sys.stdin.read().strip()\n    if not raw_input:\n        sys.exit(0)\n\n    numCourses, prerequisites = parse_input(raw_input)\n    solution = Solution()\n    order = solution.findOrder(numCourses, prerequisites)\n    print(order)",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps for topological sort. Provide steps: start, read inputs, build adjacency, indegree, queue, etc. Use virtual code arrows. Must be line by line. Provide explanation comments.\n\nLet's craft.\n\nStart // start\n→ Step 1: Initialize graph adjacency list and indegree array of size numCourses // create structures\n→ Step 2: For each pair [a, b] in prerequisites: add edge b→a in graph; increment indegree[a] // build graph\n→ Step 3: Initialize empty queue Q // to hold courses with no prerequisites\n→ Step 4: For each course i from 0 to numCourses-1: if indegree[i]==0 push i into Q // find starting nodes\n→ Step 5: Initialize empty list order // to record result\n→ Decision: If Q is empty? // no startable course\n    Yes → Return empty array // impossible\n    No  → continue\n→ Step 6: While Q not empty: // process nodes\n    → Step 6.1: Pop course u from Q\n    → Step 6.2: Append u to order\n    → Step 6.3: For each neighbor v in graph[u]: // courses dependent on u\n        → Step 6.3.1: Decrement indegree[v]\n        → Step 6.3.2: If indegree[v]==0 push v into Q\n→ Decision: If length of order == numCourses? // all courses taken\n    Yes → Return order // success\n    No  → Return empty array // cycle detected\n\nEnd // end\n\nLet's produce accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 初始化圖的鄰接表與入度陣列（大小為 numCourses） // 建立儲存依賴關係與入度的資料結構  \n→ Step 2: 對於 prerequisites 中每個對 [a, b]：將 b → a 的邊加入圖，並將 indegree[a] 加 1 // 构建有向图并计算入度  \n→ Step 3: 建立空隊列 Q // 用於儲存入度為 0 的課程  \n→ Step 4: 遍歷 0~numCourses-1，若 indegree[i] == 0，將 i 加入 Q // 找到所有無前置課程的起點  \n→ Step 5: 初始化空列表 order // 用於記錄完成順序  \n→ Decision: Q 是否為空？ // 是否存在可立即開始的課程  \n    Yes → 返回空陣列 // 無法完成所有課程（存在環）  \n    No  → 繼續  \n→ Step 6: While Q 不為空： // 逐步進行拓撲排序  \n    → Step 6.1: 從 Q 中取出一個課程 u // 取出一個可以學的課程  \n    → Step 6.2: 將 u 加入 order // 記錄完成順序  \n    → Step 6.3: 對 graph[u] 中的每個相鄰課程 v：  \n        → Step 6.3.1: indegree[v] 減 1 // 去除已完成課程的依賴  \n        → Step 6.3.2: 若 indegree[v] == 0，將 v 加入 Q // 若無剩餘前置課程，加入隊列  \n→ Decision: order 的長度是否等於 numCourses？ // 是否已排完所有課程  \n    Yes → 返回 order // 成功得到一個可行的學習順序  \n    No  → 返回空陣列 // 仍有課程未排完，表示存在循環依賴  \nEnd // 程式執行結束"
    },
    {
      "title": "Generate Random Point in a Circle",
      "source_file": "Leetcode/leetcode478.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]",
          "expected_output": "[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[-0.02493,-0.38077],[0.82314,0.38945],[0.36572,0.17248]]'\nGot (Norm):      '[null,[0.37862942815378675,0.8907537092375764],[0.24468074452234537,-0.5336214373187409],[-0.2321424506074284,0.9403896564699439]]'\n--- (Raw) ---\nRaw Expected: '[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]'\nRaw Got:      '[null, [0.37862942815378675, 0.8907537092375764], [0.24468074452234537, -0.5336214373187409], [-0.2321424506074284, 0.9403896564699439]]'"
        }
      ],
      "generated_code": "import sys\nimport json\nimport random\nimport math\n\nclass Solution:\n    def __init__(self, radius, x_center, y_center):\n        \"\"\"初始化圓的半徑與中心座標。\"\"\"\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self):\n        \"\"\"\n        產生一個在圓內均勻分布的隨機點。\n        先隨機產生一個 0~1 的數，取平方根後乘以半徑得到半徑 r，\n        再隨機產生角度 θ，最後轉回直角座標。\n        \"\"\"\n        r = self.radius * math.sqrt(random.random())   # 保證均勻分布\n        theta = random.uniform(0, 2 * math.pi)\n        x = self.x_center + r * math.cos(theta)\n        y = self.y_center + r * math.sin(theta)\n        return [x, y]\n\nif __name__ == \"__main__\":\n    # 讀取 stdin 的兩行輸入\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n\n    # 第一行是命令列表，第二行是對應的參數列表\n    commands = json.loads(data[0])\n    args_list = json.loads(data[1]) if len(data) > 1 else []\n\n    outputs = []\n    obj = None\n\n    for cmd, args in zip(commands, args_list):\n        if cmd == \"Solution\":\n            # 建構物件，輸出 None（對應 JSON 的 null）\n            obj = Solution(*args)\n            outputs.append(None)\n        else:\n            # 執行方法並收集結果\n            result = getattr(obj, cmd)(*args)\n            outputs.append(result)\n\n    # 將結果輸出為 JSON 字串（None 會轉成 null）\n    print(json.dumps(outputs))",
      "virtual_code": "Thinking...\nWe need to produce pseudo-code line-by-line with comments. Should include class, constructor, randPoint. For generating uniform point inside circle: method: choose random r= sqrt(random()) * radius; theta=random()*2π; x=x_center+r*cos(theta); y=y_center+r*sin(theta). Steps: Start, Step 1: Store radius etc. randPoint: generate random, compute r, theta, x, y, return.\n\nWe should use virtual code steps with arrows. For decision we don't have decisions? maybe not. Just straightforward.\n\nLet's craft.\n\nLine 1: Start // 開始程式\n\nThen class definition? Use \"Start\" to begin. Maybe use \"Step 1: 定義類別 Solution\" etc. Then constructor etc.\n\nWe need to produce lines with arrow for each step. Use indentation to show hierarchical structure.\n\nWe can produce like:\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類\n    → Step 2: 定義建構子 Solution(radius, x_center, y_center) // 初始化半徑與中心座標\n        → Step 3: 儲存 radius, x_center, y_center 成員變數 // 方便 randPoint 使用\n    → Step 4: 定義方法 randPoint() // 產生隨機點\n        → Step 5: 產生 uniform 隨機數 u ∈ [0,1) // 用於 r 計算\n        → Step 6: 計算半徑 r = sqrt(u) * radius // 確保點均勻分布\n        → Step 7: 產生角度 θ = uniform 0 到 2π // 隨機方向\n        → Step 8: 計算點座標 x = x_center + r * cos(θ) // 應用極座標轉直角座標\n        → Step 9: 計算點座標 y = y_center + r * sin(θ) // 同上\n        → Step 10: 回傳 [x, y] // 返回隨機點\nEnd // 程式執行結束\n\nThat's the virtual code. Provide each line with // explanation. Use arrows appropriately. Ensure each line has \"虛擬碼步驟\" and comment. Use \"→\" for flow.\n\nWe might include decision? None needed. So use simple arrows.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 定義類別 Solution // 宣告 Solution 類別\n    → Step 2: 定義建構子 Solution(radius, x_center, y_center) // 接收半徑與中心座標\n        → Step 3: 儲存 radius, x_center, y_center 為類別成員變數 // 供 randPoint 使用\n    → Step 4: 定義方法 randPoint() // 產生隨機點\n        → Step 5: 產生 uniform 隨機數 u ∈ [0,1) // 用於計算半徑\n        → Step 6: 計算 r = sqrt(u) * radius // 使點在圓內均勻分布\n        → Step 7: 產生隨機角度 θ ∈ [0, 2π) // 隨機方向\n        → Step 8: 計算 x = x_center + r * cos(θ) // 從極座標轉直角座標\n        → Step 9: 計算 y = y_center + r * sin(θ) // 同上\n        → Step 10: 回傳 [x, y] // 返回隨機點座標\nEnd // 程式執行結束"
    },
    {
      "title": "Remove Element",
      "source_file": "Leetcode/leetcode27.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "nums = [0,1,2,2,3,0,4,2], val = 2",
          "expected_output": "5, nums = [0,1,4,0,3,_,_,_]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '5,nums=[0,1,4,0,3,_,_,_]'\nGot (Norm):      '5,nums=[0,1,3,0,4,_,_,_]'\n--- (Raw) ---\nRaw Expected: '5, nums = [0,1,4,0,3,_,_,_]'\nRaw Got:      '5, nums = [0,1,3,0,4,_,_,_]'"
        }
      ],
      "generated_code": "import sys\nimport re\n\nclass Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        移除 nums 中所有等於 val 的元素，並返回新長度 k。\n        兩指標法：slow 指向寫入位置，fast 遍歷原始陣列。\n        \"\"\"\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != val:\n                nums[slow] = nums[fast]\n                slow += 1\n        return slow\n\ndef parse_input(data: str):\n    \"\"\"\n    從輸入字串中解析出 nums 與 val。\n    允許類似 'nums = [1,2,3], val = 2' 的格式。\n    \"\"\"\n    nums_match = re.search(r'\\[([^\\]]*)\\]', data)\n    nums = [int(x) for x in nums_match.group(1).split(',')] if nums_match else []\n\n    val_match = re.search(r'val\\s*=\\s*(-?\\d+)', data)\n    val = int(val_match.group(1)) if val_match else 0\n    return nums, val\n\ndef main():\n    data = sys.stdin.read().strip()\n    nums, val = parse_input(data)\n\n    sol = Solution()\n    k = sol.removeElement(nums, val)\n\n    # 以 '_' 取代剩餘位置\n    result_list = [str(nums[i]) if i < k else '_' for i in range(len(nums))]\n    print(f'{k}, nums = [{\",\".join(result_list)}]')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need produce virtual code steps with explanations. Problem: remove elements equal to val in-place, return count k. Approach: two-pointer: iterate i, if nums[i] != val, put at position k and increment k. At end return k. Provide Start, End, Decision etc. Provide each line with arrow.\n\nWe need to show virtual code line by line. Use \"→\" arrow each step. Use Start, End, Decision. Provide explanation after //.\n\nLet's craft:\n\nStart\n→ Step 1: Initialize index writePos = 0 // pointer for next write position\n→ Step 2: For each index readPos from 0 to nums.length-1 // iterate over array\n→ Decision: If nums[readPos] != val? // check not equal\n    Yes → Step 3: nums[writePos] = nums[readPos] // keep element\n    Yes → Step 4: writePos = writePos + 1 // move write pointer\n    No  → // skip element equal to val\nEnd // return writePos as k\n\nBut need to maintain structure: decision nested inside loop.\n\nLet's output as:\n\nStart // 程式開始執行\n→ Step 1: writePos = 0 // 初始化寫入位置\n→ Step 2: for readPos = 0 to nums.length - 1 // 逐個遍歷陣列\n    → Decision: nums[readPos] != val? // 判斷當前元素是否需要保留\n        Yes → Step 3: nums[writePos] = nums[readPos] // 把不等於 val 的元素寫入\n        Yes → Step 4: writePos = writePos + 1 // 移動寫入指標\n        No  → // 若等於 val，直接跳過\nEnd // 回傳 writePos 作為 k\n\nWe need \"Yes →\" and \"No →\" arrow? They used Yes → and No →. But we have only \"Yes →\" lines. For No case we can just comment. They want each line must contain 虛擬碼步驟 + space + // 解釋. So we need to output each line separately. For decisions, we might output separate lines: \"→ Decision: ...\" and nested lines maybe indented with spaces. The example uses indentation for nested lines. Use spaces before arrows for nested? Example:\n\n→ Decision: 如果數字大於 0? // 檢查數值是否為正\n    Yes → Step 2: 輸出 '正數' // 如果是正數，顯示該訊息\n    No  → Decision: 如果數字等於 0? // 如果不是正數，檢查是否為零\n\nSo we follow that style. Use 4 spaces indentation before nested.\n\nThus produce:\n\nStart // 程式開始執行\n→ Step 1: writePos = 0 // 初始化寫入位置為 0\n→ Step 2: for readPos = 0 to nums.length - 1 // 從頭到尾逐個讀取\n    → Decision: nums[readPos] != val? // 判斷當前元素是否不是目標值\n        Yes → Step 3: nums[writePos] = nums[readPos] // 把非目標值寫入寫入位置\n        Yes → Step 4: writePos = writePos + 1 // 移動寫入指標\n        No  → // 若為目標值，直接跳過\nEnd // 回傳 writePos 作為 k\n\nNeed to include \"End\" line. Good.\n\nReturn value: \"return writePos\". Should be included before End. They ask to return k. We can add Step 5: return writePos. Place before End. The structure: End // 程式執行結束.\n\nAdd Step 5: return writePos // 將計數返回\n\nLet's produce final output.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: writePos = 0 // 初始化寫入位置為 0  \n→ Step 2: for readPos = 0 to nums.length - 1 // 從頭到尾逐個讀取  \n    → Decision: nums[readPos] != val? // 判斷當前元素是否不是目標值  \n        Yes → Step 3: nums[writePos] = nums[readPos] // 把非目標值寫入寫入位置  \n        Yes → Step 4: writePos = writePos + 1 // 移動寫入指標  \n        No  → // 若為目標值，直接跳過  \n→ Step 5: return writePos // 將計數返回，作為不等於 val 的元素個數  \nEnd // 程式執行結束"
    },
    {
      "title": "Shuffle an Array",
      "source_file": "Leetcode/leetcode384.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"], [[[1, 2, 3]], [], [], []]",
          "expected_output": "[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,[3,1,2],[1,2,3],[1,3,2]]'\nGot (Norm):      '[null,[2,3,1],[1,2,3],[2,3,1]]'\n--- (Raw) ---\nRaw Expected: '[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]'\nRaw Got:      '[null, [2, 3, 1], [1, 2, 3], [2, 3, 1]]'"
        }
      ],
      "generated_code": "import sys\nimport random\nimport ast\n\nclass Solution:\n    def __init__(self, nums):\n        # 儲存原始陣列的複製\n        self.original = list(nums)\n\n    def reset(self):\n        # 回傳原始陣列\n        return list(self.original)\n\n    def shuffle(self):\n        # 使用 Fisher–Yates 洗牌演算法\n        arr = list(self.original)\n        n = len(arr)\n        for i in range(n):\n            j = random.randint(i, n - 1)\n            arr[i], arr[j] = arr[j], arr[i]\n        return arr\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n\n    # 解析輸入：將兩個列表包在括號中以形成一個 tuple\n    ops, args_list = eval('(' + data + ')')\n\n    result = []\n    obj = None\n    for op, args in zip(ops, args_list):\n        if op == 'Solution':\n            obj = Solution(args[0])\n            result.append(None)\n        else:\n            # 呼叫對應的方法\n            func = getattr(obj, op)\n            val = func(*args)\n            result.append(val)\n\n    # 將結果轉成 LeetCode 風格的字串輸出\n    out_parts = []\n    for item in result:\n        if item is None:\n            out_parts.append('null')\n        else:\n            out_parts.append(repr(item))\n    print('[{}]'.format(', '.join(out_parts)))\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines with explanation, not actual code. For the algorithm: Fisher-Yates shuffle. Need class initialization, reset, shuffle. Steps: store original array copy, reset returns copy, shuffle returns new array with shuffle applied.\n\nWe produce line-by-line with arrows. Use Start, End. Use Decision maybe not necessary. But maybe decision to choose random index.\n\nLet's produce:\n\nStart\n→ Step 1: 定義 class Solution with member arrays original and current // store copies\n→ Step 2: Constructor: 將 nums 複製到 original // 記錄原始陣列\n→ Step 3: 把 original 複製到 current // 初始狀態\n→ End\n\nFor reset:\nStart\n→ Step 1: 把 current 設為 original 的複製 // 回復原始\n→ Step 2: 回傳 current // 提供回復後陣列\nEnd\n\nFor shuffle:\nStart\n→ Step 1: 把 current 先複製成 temp // 避免修改原始\n→ Step 2: 取得長度 n = temp.length // 計算長度\n→ Step 3: 針對 i 從 0 到 n-1 做：\n    → Decision: 隨機選取 j 在 [i, n-1] // 選擇隨機索引\n        Yes → Step 4: 交換 temp[i] 與 temp[j] // 交換元素\n→ Step 4: 回傳 temp // 返回隨機排列\nEnd\n\nNeed to format lines with virtual code arrow and explanation.\n\nWe need to use arrows: →, Yes →, No →. But for loops we can just use Step. Let's structure:\n\nStart\n→ Step 1: 定義 Solution 類，包含 original 與 current 陣列 // 儲存原始與當前\n→ Step 2: Constructor: 把 nums 複製為 original 並複製給 current // 初始化\n→ End\n\nSimilarly for reset.\n\nBut the user likely expects the steps of the methods. The format requires Start and End for program but maybe each method separate? Could combine? Probably separate Start/End for each method.\n\nLet's produce:\n\nStart // 程式開始\n→ Step 1: 定義類 Solution // 主類\n    → Step 2: 宣告原始陣列 original 以及工作陣列 current // 存儲資料\n→ End // 類結束\n\nStart // reset 方法\n→ Step 1: current ← original 的複製 // 回復初始\n→ Step 2: 回傳 current // 結果\nEnd // reset 結束\n\nStart // shuffle 方法\n→ Step 1: temp ← current 的複製 // 用於 shuffling\n→ Step 2: n ← temp.length // 取得長度\n→ Step 3: for i 從 0 到 n-1:\n    → Decision: 隨機挑選 j 在 [i, n-1] 之間 // 確保均勻分佈\n        Yes → Step 4: swap temp[i] 與 temp[j] // 交換\n→ Step 5: 回傳 temp // 返回隨機排列\nEnd // shuffle 結束\n\nBut maybe we need to show the loop explicitly: we can show Step 3 as \"for i in 0..n-1\". Use arrow to indicate iteration. Let's craft more precisely:\n\n→ Step 3: for i = 0 to n-1:\n    → Decision: 產生隨機整數 j 在 [i, n-1] // 隨機選取位置\n        Yes → Step 4: temp[i] ↔ temp[j] // 交換元素\n    → End // 迴圈結束\n\nBut we can't use nested End; maybe just show end of loop. We can keep simpler.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始\n→ Step 1: 定義類 Solution，包含兩個陣列原始原始 original 與工作 current // 用於儲存資料\n→ End // 類結束\n\nStart // reset() 方法\n→ Step 1: current ← original 的複製 // 回復為最初配置\n→ Step 2: 回傳 current // 結果回傳\nEnd // reset 方法結束\n\nStart // shuffle() 方法\n→ Step 1: temp ← current 的複製 // 用於隨機打亂，避免改變原始\n→ Step 2: n ← temp.length // 取得陣列長度\n→ Step 3: for i = 0 to n-1\n    → Decision: 產生隨機整數 j 在 [i, n-1] 之間 // 保證均勻分佈\n        Yes → Step 4: temp[i] ↔ temp[j] // 交換元素\n→ Step 5: 回傳 temp // 返回隨機排列\nEnd // shuffle 方法結束"
    },
    {
      "title": "Subsets",
      "source_file": "Leetcode/leetcode78.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "nums = [1,2,3]",
          "expected_output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nGot (Norm):      '[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]'\n--- (Raw) ---\nRaw Expected: '[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]'\nRaw Got:      '[[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]'"
        }
      ],
      "generated_code": "import sys\nimport ast\n\ndef subsets(nums):\n    \"\"\"Return all subsets of a list of unique integers.\"\"\"\n    res = []\n\n    def backtrack(start, path):\n        # Add a copy of the current subset\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            # Include nums[i] and continue searching\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            # Backtrack: remove the last element added\n            path.pop()\n\n    backtrack(0, [])\n    return res\n\nif __name__ == \"__main__\":\n    # Read entire input from stdin\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n\n    # Expected format: \"nums = [1,2,3]\"\n    try:\n        _, nums_str = data.split('=', 1)\n        nums = ast.literal_eval(nums_str.strip())\n    except Exception as e:\n        # If parsing fails, output an empty list\n        print([])\n        sys.exit()\n\n    result = subsets(nums)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code for generating power set of unique array. Steps: Start, input array, create result list, define recursive function or iterative. Use DFS recursion: choose include or exclude each element. Steps: function DFS(index, path). If index==len(nums): add path to result. Else: DFS(index+1, path) // exclude current; DFS(index+1, path+[nums[index]]) // include. Return result. Provide lines with arrow. Let's produce.\n\nUse arrow lines for recursive function? Provide steps inside.\n\nEnsure format: Each line: \"虛擬碼步驟 // 解釋\". Use arrow: →. Use Decision. Provide Start, End.\n\nLet's produce.\n\n...done thinking.\n\nStart // 程式開始執行  \n→ Input: nums // 取得輸入的唯一整數陣列  \n→ Declare: result = [] // 用於存放所有子集  \n→ Define: DFS(index, path) // 递归函数：index 为当前处理元素索引，path 为已选择的子集  \n    Decision: index == len(nums)? // 判断是否已遍历完所有元素  \n     Yes → Append path to result // 把完整子集加入结果  \n     No  →  \n      → DFS(index + 1, path) // 不包含当前元素，继续递归  \n      → DFS(index + 1, path + [nums[index]]) // 包含当前元素，继续递归  \n→ Call DFS(0, []) // 从第一个元素开始，初始子集为空  \n→ Return result // 输出所有子集  \nEnd // 程式執行結束"
    },
    {
      "title": "LFU Cache",
      "source_file": "Leetcode/leetcode460.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"], [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]",
          "expected_output": "[null, null, null, 1, null, -1, 3, null, -1, 3, 4]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpcqy2f23n.py\", line 49, in <module>\n    args = ast.literal_eval(data[1].strip())\n                            ~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\nimport ast\nfrom collections import defaultdict, OrderedDict\n\nclass LFUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.min_freq = 0\n        self.key_to_val_freq = {}\n        self.freq_to_keys = defaultdict(OrderedDict)\n\n    def _update(self, key):\n        value, freq = self.key_to_val_freq[key]\n        del self.freq_to_keys[freq][key]\n        if not self.freq_to_keys[freq]:\n            del self.freq_to_keys[freq]\n            if self.min_freq == freq:\n                self.min_freq += 1\n        self.freq_to_keys[freq + 1][key] = None\n        self.key_to_val_freq[key] = (value, freq + 1)\n\n    def get(self, key):\n        if key not in self.key_to_val_freq:\n            return -1\n        self._update(key)\n        return self.key_to_val_freq[key][0]\n\n    def put(self, key, value):\n        if self.capacity == 0:\n            return\n        if key in self.key_to_val_freq:\n            self.key_to_val_freq[key] = (value, self.key_to_val_freq[key][1])\n            self._update(key)\n            return\n        if len(self.key_to_val_freq) >= self.capacity:\n            evict_key, _ = self.freq_to_keys[self.min_freq].popitem(last=False)\n            del self.key_to_val_freq[evict_key]\n            if not self.freq_to_keys[self.min_freq]:\n                del self.freq_to_keys[self.min_freq]\n        self.key_to_val_freq[key] = (value, 1)\n        self.freq_to_keys[1][key] = None\n        self.min_freq = 1\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip().splitlines()\n    if not data:\n        sys.exit()\n    ops = ast.literal_eval(data[0].strip())\n    args = ast.literal_eval(data[1].strip())\n\n    res = []\n    cache = None\n    for op, arg in zip(ops, args):\n        if op == \"LFUCache\":\n            cache = LFUCache(arg[0])\n            res.append(None)\n        elif op == \"put\":\n            cache.put(arg[0], arg[1])\n            res.append(None)\n        elif op == \"get\":\n            val = cache.get(arg[0])\n            res.append(val)\n    output = '[' + ', '.join('null' if v is None else str(v) for v in res) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to produce virtual code with explanations, line by line. Need to design LFU Cache O(1). We'll produce pseudo-code steps.\n\nWe need to show Start, decisions etc. Provide stepwise logic: initialization, get, put, helper functions to update frequency, evict.\n\nWe'll produce pseudo code that uses: hashmap key->node, node has key, value, freq, prev/next. Also freqList map freq->DLL of nodes. Also minFreq variable. Implementation steps.\n\nWe should output each line like:\n\nStart // start\n\n→ Step 1: 定義 Node // etc.\n\nBut we need to show algorithm steps not full code. It's okay to outline.\n\nWe should produce maybe about 30-40 lines.\n\nWe need to ensure each line has \"虛擬碼步驟\" + space + \"// 解釋/說明\". We use arrow arrows.\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類別，包含 key, value, freq, prev, next // 定義節點資料結構\n→ Step 2: 定義 DoublyLinkedList 類別，具有 head, tail, size，提供 addNode, removeNode, removeHead // 用於存儲同頻節點\n→ Step 3: 定義 LFUCache 類別，初始化 capacity, minFreq, keyNodeMap, freqListMap // 主要結構\n→ Step 4: 在 LFUCache.__init__(capacity) // 內初始化各資料結構 // 1\n    → Set this.capacity = capacity\n    → Set this.minFreq = 0\n    → 初始化 keyNodeMap 為空映射\n    → 初始化 freqListMap 為空映射\n→ Step 5: 定義 get(key) 方法 // 取得值\n    → Decision: 若 key 不在 keyNodeMap? // 檢查是否存在\n        Yes → Return -1 // 不存在返回 -1\n        No → Node = keyNodeMap[key] // 取得節點\n        → Call updateFrequency(Node) // 更新頻率\n        → Return Node.value // 回傳值\n→ Step 6: 定義 put(key, value) 方法 // 插入/更新\n    → Decision: capacity == 0? // 特殊情況\n        Yes → Return // 無法存儲\n        No →\n    → Decision: 若 key 在 keyNodeMap? // 更新已存在\n        Yes →\n            Node = keyNodeMap[key]\n            Node.value = value // 更新值\n            Call updateFrequency(Node) // 更新頻率\n            → Return\n        No →\n            → Decision: keyNodeMap.size == capacity? // 檢查是否已滿\n                Yes →\n                    → EvictLeastFrequent() // 刪除 LFU 節點\n                No → // 續行\n            → 建立新節點 Node(key, value, freq=1)\n            → 插入 keyNodeMap[key] = Node\n            → 如果 freqListMap[1] 不存在，建立新的 DoublyLinkedList\n            → freqListMap[1].addNode(Node)\n            → Set minFreq = 1 // 最小頻率更新\n→ Step 7: 定義 updateFrequency(node) 方法 // 升級頻率\n    → f = node.freq\n    → freqListMap[f].removeNode(node) // 從舊頻率列表移除\n    → 若 freqListMap[f] 空且 f == minFreq? // 若該頻率列表被清空\n        → minFreq += 1 // 取新最小頻率\n    → node.freq += 1 // 增加頻率\n    → 若 freqListMap[node.freq] 不存在，建立新 DoublyLinkedList\n    → freqListMap[node.freq].addNode(node) // 加入新頻率列表\n→ Step 8: 定義 EvictLeastFrequent() 方法 // 刪除 LFU 節點\n    → list = freqListMap[minFreq] // 取得最小頻率的列表\n    → NodeToRemove = list.removeHead() // LRU 節點\n    → 從 keyNodeMap 刪除 NodeToRemove.key\n    → 若 list.size == 0, 刪除 freqListMap[minFreq] // 清理空列表\n→ End // 程式執行結束\n\nBut each line must have \"虛擬碼步驟\" with explanation after //.\n\nAlso arrow lines for decision.\n\nWe need to ensure the pseudo-code lines include arrows and decision structure. Let's craft more detailed lines, maybe 50 lines. Ensure each line has the format: \"虛擬碼步驟 // 解釋/說明\".\n\nWe should include \"Start\", \"End\".\n\nWe need to use arrow notation \"→\". For decision we show \"Decision:\".\n\nAlso use \"Yes →\", \"No →\" indent.\n\nLet's produce lines:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類別，含 key, value, freq, prev, next // 節點結構，存儲鍵值與頻率\n→ Step 2: 定義 DoublyLinkedList 類別，含 head, tail, size，並提供 addNode、removeNode、removeHead 方法 // 用於快速插入、刪除與取得最舊節點\n→ Step 3: 定義 LFUCache 類別，含 capacity, minFreq, keyNodeMap, freqListMap // 整體結構\n→ Step 4: LFUCache.__init__(capacity) // 初始化\n    → Set this.capacity = capacity\n    → Set this.minFreq = 0\n    → 初始化 keyNodeMap 為空映射\n    → 初始化 freqListMap 為空映射\n→ Step 5: get(key) 方法 // 取得鍵的值\n    → Decision: 若 key 不在 keyNodeMap? // 檢查是否存在\n        Yes → Return -1 // 不存在直接返回 -1\n        No → node = keyNodeMap[key] // 取出節點\n            → updateFrequency(node) // 更新頻率\n            → Return node.value // 回傳值\n→ Step 6: put(key, value) 方法 // 插入或更新鍵\n    → Decision: capacity == 0? // 特殊容量為 0 的情況\n        Yes → Return // 無法存儲\n        No →\n    → Decision: 若 key 在 keyNodeMap? // 已存在鍵\n        Yes →\n            node = keyNodeMap[key]\n            node.value = value // 更新值\n            → updateFrequency(node) // 更新頻率\n            → Return\n        No →\n            → Decision: keyNodeMap.size == capacity? // 是否已滿\n                Yes →\n                    → EvictLeastFrequent() // 刪除 LFU 節點\n                No →\n            → 建立新節點 node = Node(key, value, freq=1)\n            → keyNodeMap[key] = node\n            → 若 freqListMap[1] 不存在，建立新的 DoublyLinkedList\n            → freqListMap[1].addNode(node)\n            → minFreq = 1 // 最小頻率重設\n→ Step 7: updateFrequency(node) 方法 // 升級節點頻率\n    → f = node.freq\n    → freqListMap[f].removeNode(node) // 從舊頻率列表移除\n    → 若 freqListMap[f] 空且 f == minFreq? // 若該頻率列表被清空\n        Yes → minFreq += 1 // 更新最小頻率\n    → node.freq += 1 // 設定新頻率\n    → 若 freqListMap[node.freq] 不存在，建立新的 DoublyLinkedList\n    → freqListMap[node.freq].addNode(node) // 加入新頻率列表\n→ Step 8: EvictLeastFrequent() 方法 // 刪除最少使用節點\n    → list = freqListMap[minFreq] // 取得最小頻率的列表\n    → node = list.removeHead() // 取得最舊節點（LRU）\n    → 從 keyNodeMap 刪除 node.key\n    → 若 list.size == 0, 刪除 freqListMap[minFreq] // 清理空列表\n→ End // 程式執行結束\n\nCheck formatting: Each line begins with \"虛擬碼步驟\" but we have multiple lines with indent. For decision lines we need \"Decision:\" with arrows. For example:\n\n→ Decision: 若 key 不在 keyNodeMap? // 檢查是否存在\n    Yes → node = keyNodeMap[key] // 取出節點\n\nWe need to keep each line as separate. The indentation could be represented by spaces; but each line still starts with arrow.\n\nMaybe we should produce each line exactly like:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類別，含 key, value, freq, prev, next // 節點結構，存儲鍵值與頻率\n→ Step 2: 定義 DoublyLinkedList 類別，含 head, tail, size，並提供 addNode、removeNode、removeHead 方法 // 用於快速插入、刪除與取得最舊節點\n→ Step 3: 定義 LFUCache 類別，含 capacity, minFreq, keyNodeMap, freqListMap // 整體結構\n→ Step 4: LFUCache.__init__(capacity) // 初始化\n    → Set this.capacity = capacity\n    → Set this.minFreq = 0\n    → 初始化 keyNodeMap 為空映射\n    → 初始化 freqListMap 為空映射\n→ Step 5: get(key) 方法 // 取得鍵的值\n    → Decision: 若 key 不在 keyNodeMap? // 檢查是否存在\n        Yes → node = keyNodeMap[key] // 取出節點\n            → updateFrequency(node) // 更新頻率\n            → Return node.value // 回傳值\n        No  → Return -1 // 不存在返回 -1\n→ Step 6: put(key, value) 方法 // 插入或更新鍵\n    → Decision: capacity == 0? // 特殊容量為 0 的情況\n        Yes → Return // 無法存儲\n        No →\n    → Decision: 若 key 在 keyNodeMap? // 已存在鍵\n        Yes →\n            node = keyNodeMap[key]\n            node.value = value // 更新值\n            → updateFrequency(node) // 更新頻率\n            → Return\n        No →\n            → Decision: keyNodeMap.size == capacity? // 是否已滿\n                Yes →\n                    → EvictLeastFrequent() // 刪除 LFU 節點\n                No →\n            → 建立新節點 node = Node(key, value, freq=1)\n            → keyNodeMap[key] = node\n            → 若 freqListMap[1] 不存在，建立新的 DoublyLinkedList\n            → freqListMap[1].addNode(node)\n            → minFreq = 1 // 最小頻率重設\n→ Step 7: updateFrequency(node) 方法 // 升級節點頻率\n    → f = node.freq\n    → freqListMap[f].removeNode(node) // 從舊頻率列表移除\n    → 若 freqListMap[f] 空且 f == minFreq? // 若該頻率列表被清空\n        Yes → minFreq += 1 // 更新最小頻率\n    → node.freq += 1 // 設定新頻率\n    → 若 freqListMap[node.freq] 不存在，建立新的 DoublyLinkedList\n    → freqListMap[node.freq].addNode(node) // 加入新頻率列表\n→ Step 8: EvictLeastFrequent() 方法 // 刪除最少使用節點\n    → list = freqListMap[minFreq] // 取得最小頻率的列表\n    → node = list.removeHead() // 取得最舊節點（LRU）\n    → 從 keyNodeMap 刪除 node.key\n    → 若 list.size == 0, 刪除 freqListMap[minFreq] // 清理空列表\n→ End // 程式執行結束\n\nWe need to keep each line as a separate line. In decision blocks, we can have indentation but still a separate line each.\n\nLet's ensure each line uses \"→\" arrow at start. But some lines inside decision block start with spaces before arrow. The spec: \"使用虛擬碼的箭頭 (→, Yes →, No →)\". So inside decision block we should use \"Yes →\" or \"No →\". So we need to keep indentation maybe with spaces but each line start with \"Yes →\" or \"No →\".\n\nLet's produce:\n\nStart // 程式開始執行\n→ Step 1: 定義 Node 類別，含 key, value, freq, prev, next // 節點結構，存儲鍵值與頻率\n→ Step 2: 定義 DoublyLinkedList 類別，含 head, tail, size，並提供 addNode、removeNode、removeHead 方法 // 用於快速插入、刪除與取得最舊節點\n→ Step 3: 定義 LFUCache 類別，含 capacity, minFreq, keyNodeMap, freqListMap // 整體結構\n→ Step 4: LFUCache.__init__(capacity) // 初始化\n    → Set this.capacity = capacity\n    → Set this.minFreq = 0\n    → 初始化 keyNodeMap 為空映射\n    → 初始化 freqListMap 為空映射\n→ Step 5: get(key) 方法 // 取得鍵的值\n    → Decision: 若 key 不在 keyNodeMap? // 檢查是否存在\n        Yes → node = keyNodeMap[key] // 取出節點\n            → updateFrequency(node) // 更新頻率\n            → Return node.value // 回傳值\n        No  → Return -1 // 不存在返回 -1\n→ Step 6: put(key, value) 方法 // 插入或更新鍵\n    → Decision: capacity == 0? // 特殊容量為 0 的情況\n        Yes → Return // 無法存儲\n        No →\n    → Decision: 若 key 在 keyNodeMap? // 已存在鍵\n        Yes →\n            node = keyNodeMap[key]\n            node.value = value // 更新值\n            → updateFrequency(node) // 更新頻率\n            → Return\n        No →\n            → Decision: keyNodeMap.size == capacity? // 是否已滿\n                Yes →\n                    → EvictLeastFrequent() // 刪除 LFU 節點\n                No →\n            → 建立新節點 node = Node(key, value, freq=1)\n            → keyNodeMap[key] = node\n            → 若 freqListMap[1] 不存在，建立新的 DoublyLinkedList\n            → freqListMap[1].addNode(node)\n            → minFreq = 1 // 最小頻率重設\n→ Step 7: updateFrequency(node) 方法 // 升級節點頻率\n    → f = node.freq\n    → freqListMap[f].removeNode(node) // 從舊頻率列表移除\n    → 若 freqListMap[f] 空且 f == minFreq? // 若該頻率列表被清空\n        Yes → minFreq += 1 // 更新最小頻率\n    → node.freq += 1 // 設定新頻率\n    → 若 freqListMap[node.freq] 不存在，建立新的 DoublyLinkedList\n    → freqListMap[node.freq].addNode(node) // 加入新頻率列表\n→ Step 8: EvictLeastFrequent() 方法 // 刪除最少使用節點\n    → list = freqListMap[minFreq] // 取得最小頻率的列表\n    → node = list.removeHead() // 取得最舊節點（LRU）\n    → 從 keyNodeMap 刪除 node.key\n    → 若 list.size == 0, 刪除 freqListMap[minFreq] // 清理空列表\n→ End // 程式執行結束\n\nWe need to ensure each line has a \"虛擬碼步驟\" but we wrote \"→ Step 1: ...\" etc. That's fine.\n\nBut we must ensure each line contains a space after the step code and before the comment. We already have that.\n\nNow confirm each line has comment after //.\n\nNow deliver.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: 定義 Node 類別，含 key, value, freq, prev, next // 節點結構，存儲鍵值與頻率  \n→ Step 2: 定義 DoublyLinkedList 類別，含 head, tail, size，並提供 addNode、removeNode、removeHead 方法 // 用於快速插入、刪除與取得最舊節點  \n→ Step 3: 定義 LFUCache 類別，含 capacity, minFreq, keyNodeMap, freqListMap // 整體結構  \n→ Step 4: LFUCache.__init__(capacity) // 初始化  \n&nbsp;&nbsp;→ Set this.capacity = capacity  \n&nbsp;&nbsp;→ Set this.minFreq = 0  \n&nbsp;&nbsp;→ 初始化 keyNodeMap 為空映射  \n&nbsp;&nbsp;→ 初始化 freqListMap 為空映射  \n→ Step 5: get(key) 方法 // 取得鍵的值  \n&nbsp;&nbsp;→ Decision: 若 key 不在 keyNodeMap? // 檢查是否存在  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → node = keyNodeMap[key] // 取出節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ updateFrequency(node) // 更新頻率  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Return node.value // 回傳值  \n&nbsp;&nbsp;&nbsp;&nbsp;No → Return -1 // 不存在返回 -1  \n→ Step 6: put(key, value) 方法 // 插入或更新鍵  \n&nbsp;&nbsp;→ Decision: capacity == 0? // 特殊容量為 0 的情況  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → Return // 無法存儲  \n&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;→ Decision: 若 key 在 keyNodeMap? // 已存在鍵  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node = keyNodeMap[key]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.value = value // 更新值  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ updateFrequency(node) // 更新頻率  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Return  \n&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ Decision: keyNodeMap.size == capacity? // 是否已滿  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Yes →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ EvictLeastFrequent() // 刪除 LFU 節點  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No →  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ 建立新節點 node = Node(key, value, freq=1)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ keyNodeMap[key] = node  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ 若 freqListMap[1] 不存在，建立新的 DoublyLinkedList  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ freqListMap[1].addNode(node)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;→ minFreq = 1 // 最小頻率重設  \n→ Step 7: updateFrequency(node) 方法 // 升級節點頻率  \n&nbsp;&nbsp;→ f = node.freq  \n&nbsp;&nbsp;→ freqListMap[f].removeNode(node) // 從舊頻率列表移除  \n&nbsp;&nbsp;→ 若 freqListMap[f] 空且 f == minFreq? // 若該頻率列表被清空  \n&nbsp;&nbsp;&nbsp;&nbsp;Yes → minFreq += 1 // 更新最小頻率  \n&nbsp;&nbsp;→ node.freq += 1 // 設定新頻率  \n&nbsp;&nbsp;→ 若 freqListMap[node.freq] 不存在，建立新的 DoublyLinkedList  \n&nbsp;&nbsp;→ freqListMap[node.freq].addNode(node) // 加入新頻率列表  \n→ Step 8: EvictLeastFrequent() 方法 // 刪除最少使用節點  \n&nbsp;&nbsp;→ list = freqListMap[minFreq] // 取得最小頻率的列表  \n&nbsp;&nbsp;→ node = list.removeHead() // 取得最舊節點（LRU）  \n&nbsp;&nbsp;→ 從 keyNodeMap 刪除 node.key  \n&nbsp;&nbsp;→ 若 list.size == 0, 刪除 freqListMap[minFreq] // 清理空列表  \n→ End // 程式執行結束"
    },
    {
      "title": "Different Ways to Add Parentheses",
      "source_file": "Leetcode/leetcode241.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "expression = \"2-1-1\"",
          "expected_output": "[0,2]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[0,2]'\nGot (Norm):      '[2,0]'\n--- (Raw) ---\nRaw Expected: '[0,2]'\nRaw Got:      '[2,0]'"
        },
        {
          "example_index": 1,
          "input": "expression = \"2*3-4*5\"",
          "expected_output": "[-34,-14,-10,-10,10]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[-34,-14,-10,-10,10]'\nGot (Norm):      '[-34,-10,-14,-10,10]'\n--- (Raw) ---\nRaw Expected: '[-34,-14,-10,-10,10]'\nRaw Got:      '[-34,-10,-14,-10,10]'"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def diffWaysToCompute(self, expression: str):\n        memo = {}\n\n        def ways(expr: str):\n            if expr in memo:\n                return memo[expr]\n\n            res = []\n            for i, ch in enumerate(expr):\n                if ch in '+-*':\n                    left = ways(expr[:i])\n                    right = ways(expr[i+1:])\n                    for l in left:\n                        for r in right:\n                            if ch == '+':\n                                res.append(l + r)\n                            elif ch == '-':\n                                res.append(l - r)\n                            else:\n                                res.append(l * r)\n            if not res:\n                res.append(int(expr))\n            memo[expr] = res\n            return res\n\n        return ways(expression)\n\nif __name__ == \"__main__\":\n    data = sys.stdin.read().strip()\n    if not data:\n        sys.exit()\n    # 將輸入拆成 expression = \"...\" 的形式\n    if '=' in data:\n        expr = data.split('=', 1)[1].strip()\n    else:\n        expr = data.strip()\n    # 移除可能存在的雙引號或單引號\n    expr = expr.strip('\"').strip(\"'\")\n    solution = Solution()\n    results = solution.diffWaysToCompute(expr)\n    # 以不帶空格的方式輸出結果列表\n    output = '[' + ','.join(str(x) for x in results) + ']'\n    print(output)",
      "virtual_code": "Thinking...\nWe need to generate virtual code steps for algorithm: parse expression, compute all results via divide and conquer, caching. Let's produce line-by-line.\n\nWe need start, decision, steps, end.\n\nLet's create pseudocode:\n\nStart // begin\n\n→ Step 1: 取得輸入字串 expr // get expression\n\n→ Step 2: 初始化 memo dictionary // cache for subexpressions\n\n→ Step 3: 定義遞迴函式 compute(start, end) // compute results for substring\n\n→ Decision: if substring already in memo? // caching\n\n    Yes → Return memoized results\n\n    No → Proceed\n\n→ Decision: 如果 substring 為單一數字? // base case\n\n    Yes → 將數字轉成 int 並放入 list → memoize → Return list\n\n    No → 初始化結果列表\n\n→ Step 4: 迴圈 i 從 start 到 end 遍歷\n\n    Decision: 如果 expr[i] 為運算子 (+, -, *)? // operator found\n\n        → 左子問題 = compute(start, i-1)\n\n        → 右子問題 = compute(i+1, end)\n\n        → 迴圈左結果\n\n            迴圈右結果\n\n                → 計算 left op right → 加入結果\n\n→ Memoize substring with results\n\n→ Return results\n\n→ Step 5: 取得整個表達式的結果 compute(0, len(expr)-1)\n\n→ Step 6: 輸出結果列表\n\nEnd\n\nWe must write each line as \"虛擬碼步驟 // 解釋\". Use arrow notation.\n\nLet's produce step-by-step, with indentation for decision branches. Ensure each line includes arrow and explanation. Use proper arrow symbols: \"→\", \"Yes →\", \"No →\".\n\nLet's format.\n\nStart // 程式開始\n\n→ Step 1: expr ← InputString() // 取得輸入字串\n\n→ Step 2: memo ← EmptyDictionary() // 初始化子問題快取\n\n→ Step 3: 定義函式 compute(start, end) // 計算子字串的所有結果\n\n→ Decision: 如果 (start, end) ∈ memo? // 檢查是否已計算\n\n    Yes → Return memo[(start, end)] // 回傳快取結果\n\n    No → 進行計算\n\n→ Decision: 如果 expr[start..end] 為單一數字? // 基本情況\n\n    Yes → value ← Integer(expr[start..end]) // 轉為整數\n\n        → memo[(start, end)] ← [value] // 快取\n\n        → Return [value] // 回傳\n\n    No → results ← EmptyList() // 用於收集所有結果\n\n→ Step 4: 對 i 從 start 到 end 做迴圈 // 遍歷子字串\n\n    Decision: 如果 expr[i] 為運算子 (+, -, *)? // 找到分割點\n\n        → left ← compute(start, i-1) // 計算左子問題\n\n        → right ← compute(i+1, end) // 計算右子問題\n\n        → 對 leftValue in left 做迴圈\n\n            → 對 rightValue in right 做迴圈\n\n                → If expr[i] == '+': res ← leftValue + rightValue\n\n                → Else if expr[i] == '-': res ← leftValue - rightValue\n\n                → Else: res ← leftValue * rightValue\n\n                → results ← Append(res) // 收集結果\n\n→ memo[(start, end)] ← results // 快取\n\n→ Return results // 回傳\n\n→ Step 5: allResults ← compute(0, Length(expr)-1) // 計算整個表達式\n\n→ Step 6: Output(allResults) // 輸出結果列表\n\nEnd // 程式結束\n\nWe need to keep the format strictly: each line \"虛擬碼步驟 // 解釋\". Use indentation maybe.\n\nLet's produce final output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Step 1: expr ← InputString() // 取得輸入字串  \n→ Step 2: memo ← EmptyDictionary() // 初始化子問題快取  \n→ Step 3: 定義函式 compute(start, end) // 計算子字串的所有結果  \n→ Decision: 如果 (start, end) ∈ memo? // 檢查是否已計算  \n Yes → Return memo[(start, end)] // 回傳快取結果  \n No → 進行計算  \n→ Decision: 如果 expr[start..end] 為單一數字? // 基本情況  \n Yes → value ← Integer(expr[start..end]) // 轉為整數  \n  → memo[(start, end)] ← [value] // 快取  \n  → Return [value] // 回傳  \n No → results ← EmptyList() // 用於收集所有結果  \n→ Step 4: 對 i 從 start 到 end 做迴圈 // 遍歷子字串  \n  Decision: 如果 expr[i] 為運算子 (+, -, *)? // 找到分割點  \n   → left ← compute(start, i-1) // 計算左子問題  \n   → right ← compute(i+1, end) // 計算右子問題  \n   → 對 leftValue in left 做迴圈  \n    → 對 rightValue in right 做迴圈  \n     → If expr[i] == '+': res ← leftValue + rightValue  \n     → Else if expr[i] == '-': res ← leftValue - rightValue  \n     → Else: res ← leftValue * rightValue  \n     → results ← Append(res) // 收集結果  \n→ memo[(start, end)] ← results // 快取  \n→ Return results // 回傳  \n→ Step 5: allResults ← compute(0, Length(expr)-1) // 計算整個表達式  \n→ Step 6: Output(allResults) // 輸出結果列表  \nEnd // 程式執行結束"
    },
    {
      "title": "Combination Sum",
      "source_file": "Leetcode/leetcode39.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "candidates = [2,3,6,7], target = 7",
          "expected_output": "[[2,2,3],[7]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmph3zbkkdc.py\", line 33, in <module>\n    target_str = target_part.split(\"=\")[1]\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        },
        {
          "example_index": 1,
          "input": "candidates = [2,3,5], target = 8",
          "expected_output": "[[2,2,2,2],[2,3,3],[3,5]]",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpc7uzm4bw.py\", line 33, in <module>\n    target_str = target_part.split(\"=\")[1]\n                 ~~~~~~~~~~~~~~~~~~~~~~^^^\nIndexError: list index out of range"
        }
      ],
      "generated_code": "import sys\n\nclass Solution:\n    def combinationSum(self, candidates, target):\n        res = []\n\n        def backtrack(start, path, total):\n            if total == target:\n                res.append(path.copy())\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n\n        backtrack(0, [], 0)\n        return res\n\nif __name__ == \"__main__\":\n    import re\n    data = sys.stdin.read().strip()\n    # Normalize spaces and split the two assignments\n    data = data.replace(\" \", \"\")\n    if not data:\n        sys.exit(0)\n    parts = data.split(\",\")\n    cand_part = parts[0]\n    target_part = parts[1]\n    # Extract list and target value\n    candidates_str = cand_part.split(\"=\")[1]\n    target_str = target_part.split(\"=\")[1]\n    candidates = eval(candidates_str)\n    target = int(target_str)\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines describing algorithm: typical combination sum backtracking. Need to output in specified format, each line: \"虛擬碼步驟 // 解釋\". Use arrows etc. Provide start, end, decisions, loops, recursion.\n\nWe must not output actual code, only pseudocode with steps.\n\nLet's design:\n\nStart\n→ Sort candidates // for pruning and uniqueness\n→ Define Result list // to hold combinations\n→ Define DFS function (currentIndex, currentCombo, currentSum) // recursion\n→ Decision: currentSum == target? // check\n   Yes → Add copy of currentCombo to Result // record\n   No → Decision: currentSum > target? // prune\n        Yes → Return // overshoot\n        No → Loop i from currentIndex to candidates length\n              Add candidates[i] to currentCombo // choose\n              Recurse with i (allow reuse) and updated sum // DFS\n              Remove last from currentCombo // backtrack\n→ Call DFS(0, [], 0) // start\nEnd // done\n\nNeed to output line per step. Use arrow for decisions: \"Decision:\" then nested.\n\nNeed to indicate loop and recursion.\n\nWe should number or label steps? Not necessary but we can indicate steps.\n\nLet's produce lines:\n\nStart // 程式開始\n→ Sort candidates ascending // 為了後續剪枝與避免重複\n→ Define Result as empty list // 用於儲存所有有效組合\n→ Define DFS(currentIndex, currentCombo, currentSum) // 遞迴探索\n    → Decision: currentSum == target? // 判斷是否達到目標和\n        Yes → Append copy of currentCombo to Result // 找到一組合法組合\n        No  → Decision: currentSum > target? // 超過目標和，剪枝\n            Yes → Return // 回溯\n            No  → For i from currentIndex to len(candidates)-1 // 嘗試每個候選數\n                → Append candidates[i] to currentCombo // 選擇該數字\n                → DFS(i, currentCombo, currentSum + candidates[i]) // 允許重複使用\n                → Remove last element from currentCombo // 回溯撤銷選擇\n→ Call DFS(0, [], 0) // 開始探索\nEnd // 程式執行結束\n\nWe need to include arrow markers as per format: use \"→\" before each line. For nested decisions, indent? Example uses indentation. We'll follow similar.\n\nWe need to use \"Yes →\" and \"No →\" for decisions.\n\nLet's format:\n\nStart // 程式開始執行\n→ Sort candidates ascending // 為後續剪枝與避免重複\n→ Define Result as empty list // 用於儲存所有合法組合\n→ Define DFS(currentIndex, currentCombo, currentSum) // 遞迴函式\n    → Decision: currentSum == target? // 判斷是否已達到目標和\n        Yes → Append copy of currentCombo to Result // 找到一組合法結果\n        No  → Decision: currentSum > target? // 檢查是否已超過目標和\n            Yes → Return // 超過則直接回溯\n            No  → For i from currentIndex to len(candidates)-1 // 嘗試每個候選數\n                → Append candidates[i] to currentCombo // 選擇該數字\n                → DFS(i, currentCombo, currentSum + candidates[i]) // 允許重複使用\n                → Remove last element from currentCombo // 回溯撤銷\n→ Call DFS(0, [], 0) // 啟動搜尋\nEnd // 程式執行結束\n\nMake sure each line ends with \"// 解釋\". Already.\n\nBut need to ensure every line has \"虛擬碼步驟\" plus space plus comment. Use \"→\" arrow before each step. Indentation should be preserved.\n\nLet's output accordingly.\n...done thinking.\n\nStart // 程式開始執行  \n→ Sort candidates ascending // 為後續剪枝與避免重複  \n→ Define Result as empty list // 用於儲存所有合法組合  \n→ Define DFS(currentIndex, currentCombo, currentSum) // 遞迴函式  \n    → Decision: currentSum == target? // 判斷是否已達到目標和  \n        Yes → Append copy of currentCombo to Result // 找到一組合法結果  \n        No  → Decision: currentSum > target? // 檢查是否已超過目標和  \n            Yes → Return // 超過則直接回溯  \n            No  → For i from currentIndex to len(candidates)-1 // 嘗試每個候選數  \n                → Append candidates[i] to currentCombo // 選擇該數字  \n                → DFS(i, currentCombo, currentSum + candidates[i]) // 允許重複使用  \n                → Remove last element from currentCombo // 回溯撤銷  \n→ Call DFS(0, [], 0) // 啟動搜尋  \nEnd // 程式執行結束"
    },
    {
      "title": "Course Schedule",
      "source_file": "Leetcode/leetcode207.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 0,
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpayk3hbey.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpayk3hbey.py\", line 54, in main\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpayk3hbey.py\", line 48, in parse_input\n    prerequisites = eval(val)  # 直接 eval 解析成 list of lists\n                    ^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        },
        {
          "example_index": 1,
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "actual_output_or_error": "Traceback (most recent call last):\n  File \"/tmp/tmpia7kzury.py\", line 61, in <module>\n    main()\n  File \"/tmp/tmpia7kzury.py\", line 54, in main\n    numCourses, prerequisites = parse_input(raw_input)\n                                ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpia7kzury.py\", line 48, in parse_input\n    prerequisites = eval(val)  # 直接 eval 解析成 list of lists\n                    ^^^^^^^^^\n  File \"<string>\", line 1\n    [[1\n     ^\nSyntaxError: '[' was never closed"
        }
      ],
      "generated_code": "import sys\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n        # 建立鄰接清單與入度表\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n\n        for dest, src in prerequisites:\n            graph[src].append(dest)\n            indegree[dest] += 1\n\n        # 將所有入度為 0 的節點放入佇列\n        queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n        visited = 0\n\n        while queue:\n            node = queue.popleft()\n            visited += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return visited == numCourses\n\ndef parse_input(raw: str):\n    \"\"\"\n    將類似 'numCourses = 2, prerequisites = [[1,0]]' 的字串\n    解析成 (numCourses, prerequisites) 兩個值。\n    \"\"\"\n    raw = raw.strip()\n    if not raw:\n        return 0, []\n\n    parts = raw.split(',')\n    numCourses = 0\n    prerequisites = []\n\n    for part in parts:\n        key, val = part.split('=')\n        key = key.strip()\n        val = val.strip()\n        if key == 'numCourses':\n            numCourses = int(val)\n        elif key == 'prerequisites':\n            prerequisites = eval(val)  # 直接 eval 解析成 list of lists\n\n    return numCourses, prerequisites\n\ndef main():\n    raw_input = sys.stdin.read()\n    numCourses, prerequisites = parse_input(raw_input)\n    solution = Solution()\n    result = solution.canFinish(numCourses, prerequisites)\n    # 輸出小寫的 'true' 或 'false'\n    print('true' if result else 'false')\n\nif __name__ == \"__main__\":\n    main()",
      "virtual_code": "Thinking...\nWe need to produce virtual code lines for algorithm that checks if all courses can be finished given prerequisites, typical topological sort or cycle detection. We need to output each line with // explanation. Use arrow syntax. Let's craft steps: Start, initialize adjacency list and indegree, for each prerequisite add edge and indegree, queue for zero indegree, process, count visited, at end check if count==numCourses, output result. Use Decision. No actual code. So produce each line accordingly.\n\nWe need to follow format: e.g., \"Start // 程式開始執行\". Each line with \"→\". Use \"Decision:\" for if statements. For loops: maybe \"Loop:\" or \"For each\". Use \"While\" etc. Ensure each line has explanation after comment. Let's write:\n\nStart // 程式開始執行\n→ Step 1: 建立空的鄰接清單 adjacency[0..numCourses-1] // 用來記錄各課程的後置課程\n→ Step 2: 建立 indegree[0..numCourses-1] 全部設為 0 // 記錄每門課的前置課程數量\n→ Decision: 如果 prerequisites 為空? // 先檢查是否有前置關係\n    Yes → Step 3: 回傳 true // 沒有前置關係，所有課都能完成\n    No  → Loop: for each pair [a,b] in prerequisites // 逐一處理前置關係\n        → Step 4: 加入 b 到 adjacency[a] 的後置列表 // 建立邊 a←b\n        → Step 5: indegree[a] += 1 // a 的入度加一\n→ Step 6: 建立空的佇列 queue // 用來存取入度為 0 的課程\n→ Loop: for i in 0..numCourses-1\n    → Decision: if indegree[i] == 0?\n        Yes → queue.enqueue(i) // 入度為 0 的課程先放入佇列\n→ Step 7: 計數 visited = 0 // 記錄已處理課程數\n→ While queue 不為空\n    → Step 8: 取出 course = queue.dequeue() // 取出可立即修的課程\n    → Step 9: visited += 1 // 已處理課程數加一\n    → Loop: for each nextCourse in adjacency[course]\n        → Step 10: indegree[nextCourse] -= 1 // 減少後置課程的入度\n        → Decision: if indegree[nextCourse] == 0?\n            Yes → queue.enqueue(nextCourse) // 入度降為 0 則加入佇列\n→ Decision: if visited == numCourses?\n    Yes → Step 11: 回傳 true // 所有課程都能完成\n    No  → Step 12: 回傳 false // 存在循環，無法完成\n\nEnd // 程式執行結束\n\nWe must ensure format: each line \"→\". For decision with nested, use indentation? In example they used indentation with spaces and newlines. We'll replicate that. For loops: we can use \"Loop:\" as indicator. Use \"→ Loop:\"? In example they used \"Loop:\" not preceded by arrow. But we can use \"→ Loop:\" maybe.\n\nThe output should match requested format: each line with \"虛擬碼步驟\" + space + \"// 解釋/說明\". For decisions they used \"Decision:\".\n\nThus final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: 建立空的鄰接清單 adjacency[0..numCourses-1] // 用來記錄各課程的後置課程\n→ Step 2: 建立 indegree[0..numCourses-1] 全部設為 0 // 記錄每門課的前置課程數量\n→ Decision: 如果 prerequisites 為空? // 先檢查是否有前置關係\n    Yes → Step 3: 回傳 true // 沒有前置關係，所有課都能完成\n    No  → Loop: for each pair [a,b] in prerequisites // 逐一處理前置關係\n        → Step 4: 加入 b 到 adjacency[a] 的後置列表 // 建立邊 a←b\n        → Step 5: indegree[a] += 1 // a 的入度加一\n→ Step 6: 建立空的佇列 queue // 用來存取入度為 0 的課程\n→ Loop: for i in 0..numCourses-1\n    → Decision: if indegree[i] == 0?\n        Yes → queue.enqueue(i) // 入度為 0 的課程先放入佇列\n→ Step 7: 計數 visited = 0 // 記錄已處理課程數\n→ While queue 不為空\n    → Step 8: 取出 course = queue.dequeue() // 取出可立即修的課程\n    → Step 9: visited += 1 // 已處理課程數加一\n    → Loop: for each nextCourse in adjacency[course]\n        → Step 10: indegree[nextCourse] -= 1 // 減少後置課程的入度\n        → Decision: if indegree[nextCourse] == 0?\n            Yes → queue.enqueue(nextCourse) // 入度降為 0 則加入佇列\n→ Decision: if visited == numCourses?\n    Yes → Step 11: 回傳 true // 所有課程都能完成\n    No  → Step 12: 回傳 false // 存在循環，無法完成\nEnd // 程式執行結束"
    },
    {
      "title": "Random Pick with Weight",
      "source_file": "Leetcode/leetcode528.json",
      "problem_index_in_file": 0,
      "generation_error": null,
      "failed_validation_details": [
        {
          "example_index": 1,
          "input": "[\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"], [[[1,3]],[],[],[],[],[]]",
          "expected_output": "[null,1,1,1,1,0]",
          "actual_output_or_error": "[Output Mismatch (Normalized)]\nExpected (Norm): '[null,1,1,1,1,0]'\nGot (Norm):      '[null,1,1,1,1,1]'\n--- (Raw) ---\nRaw Expected: '[null,1,1,1,1,0]'\nRaw Got:      '[null, 1, 1, 1, 1, 1]'"
        }
      ],
      "generated_code": "import sys\nimport ast\nimport random\nimport bisect\nimport json\n\nclass Solution:\n    def __init__(self, w):\n        \"\"\"Build prefix sum array for the given weights.\"\"\"\n        self.prefix_sum = []\n        total = 0\n        for weight in w:\n            total += weight\n            self.prefix_sum.append(total)\n        self.total = total\n\n    def pickIndex(self):\n        \"\"\"Return an index based on weighted probability.\"\"\"\n        target = random.randint(1, self.total)\n        return bisect.bisect_left(self.prefix_sum, target)\n\nif __name__ == \"__main__\":\n    # Read entire input as a string\n    raw = sys.stdin.read().strip()\n    if not raw:\n        sys.exit()\n\n    # Wrap the input string in brackets so that ast.literal_eval can parse it\n    data = ast.literal_eval(f'[{raw}]')\n    ops, args_list = data[0], data[1]\n\n    obj = None\n    results = []\n\n    for op, args in zip(ops, args_list):\n        if op == \"Solution\":\n            # Constructor: pass the arguments as a list\n            obj = Solution(*args)\n            results.append(None)\n        else:\n            # Other methods: invoke and store the result\n            method = getattr(obj, op)\n            results.append(method(*args))\n\n    # Output the results as a JSON array (None becomes null)\n    print(json.dumps(results))",
      "virtual_code": "Thinking...\nWe need to produce virtual code steps to implement pickIndex, with prefix of initialization maybe. So structure: Start, Preprocess: compute prefix sums array. pickIndex: generate random number between 0 and totalWeight-1 inclusive, binary search in prefix sums, return index.\n\nWe need to output line by line: each line \"虛擬碼步驟 // 解釋\". Use arrow and decisions. Ensure we include Start, End. Also we need to show pre-processing steps maybe as part of constructor. So steps:\n\nStart\n→ Step 1: Build prefixSum array from w // cumulative weights\n→ Step 2: totalWeight = prefixSum[last] // sum\n→ Step 3: define function pickIndex() // main function\n→ Decision: None? we can just proceed.\n\nInside pickIndex:\n→ Step 4: randVal = random integer in [1, totalWeight] // or 0 to totalWeight-1\n→ Step 5: low=0, high=prefixSum.length-1 // binary search\n→ Decision: while low <= high? or do binary search loop\nWe can structure as Decision: low <= high? Yes → Step 6: mid = (low+high)/2\n→ Decision: randVal <= prefixSum[mid]? Yes → Step 7: high = mid -1 // search left\n→ No → Step 8: low = mid +1 // search right\nLoop until low > high\n→ Step 9: return low // index found\n\nThen End.\n\nNeed to keep the format: each line \"虛擬碼步驟 // 解釋\". Use arrow lines.\n\nLet's produce final answer.\n...done thinking.\n\nStart // 程式開始執行\n→ Step 1: prefixSum ← [] // 建立前綴和陣列，用於儲存累積權重\n→ Step 2: totalWeight ← 0 // 初始化總權重\n→ Step 3: for each weight w[i] in w:\n    → Step 3.1: totalWeight ← totalWeight + w[i] // 累加總權重\n    → Step 3.2: prefixSum.append(totalWeight) // 將累積值加入前綴和\n→ Step 4: 定義函式 pickIndex() // 主要功能：隨機挑選索引\n→ Step 5: randVal ← random integer in [1, totalWeight] // 產生隨機數，範圍為 1~總權重\n→ Step 6: low ← 0 // 二分搜尋左端點\n→ Step 7: high ← prefixSum.length - 1 // 二分搜尋右端點\n→ Decision: low ≤ high? // 是否還有範圍可搜尋？\n    Yes → Step 8: mid ← (low + high) // 2 // 計算中間索引\n    Yes → Decision: randVal ≤ prefixSum[mid]? // 隨機數是否落在左半段？\n        Yes → Step 9: high ← mid - 1 // 繼續搜尋左半段\n        No  → Step 10: low ← mid + 1 // 繼續搜尋右半段\n    No  → Step 11: return low // 找到符合條件的索引\nEnd // 程式執行結束"
    }
  ]
}